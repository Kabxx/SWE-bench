{"repo": "bitflags/bitflags", "pull_number": 282, "instance_id": "bitflags__bitflags-282", "issue_numbers": ["228"], "base_commit": "810dc35aba3df7314de01b93c7aa137968e925d4", "patch": "diff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\nindex b7b2486e..f00ed6c2 100644\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -46,8 +46,17 @@ jobs:\n         profile: minimal\n         toolchain: ${{ matrix.channel }}-${{ matrix.rust_target }}\n \n-    - name: Tests\n-      run: cargo test --features example_generated\n+    - name: Install cargo-hack\n+      run: cargo install cargo-hack\n+\n+    - name: Powerset\n+      run: cargo hack test --feature-powerset --lib --optional-deps \"serde\" --depth 3 --skip rustc-dep-of-std\n+\n+    - name: Docs\n+      run: cargo doc --features example_generated\n+\n+    - name: Smoke test\n+      run: cargo run --manifest-path tests/smoke-test/Cargo.toml\n \n   embedded:\n     name: Build (embedded)\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 9c7c7aa7..0ff60e1d 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -16,16 +16,16 @@ categories = [\"no-std\"]\n description = \"\"\"\n A macro to generate structures which behave like bitflags.\n \"\"\"\n-exclude = [\"bors.toml\"]\n+exclude = [\"tests\", \".github\"]\n \n [dependencies]\n-core = { version = '1.0.0', optional = true, package = 'rustc-std-workspace-core' }\n-compiler_builtins = { version = '0.1.2', optional = true }\n+serde = { version = \"1.0\", optional = true }\n+core = { version = \"1.0.0\", optional = true, package = \"rustc-std-workspace-core\" }\n+compiler_builtins = { version = \"0.1.2\", optional = true }\n \n [dev-dependencies]\n trybuild = \"1.0\"\n rustversion = \"1.0\"\n-serde = \"1.0\"\n serde_derive = \"1.0\"\n serde_json = \"1.0\"\n \ndiff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs\nindex 440d5274..fd0a913a 100644\n--- a/src/bitflags_trait.rs\n+++ b/src/bitflags_trait.rs\n@@ -1,8 +1,5 @@\n use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};\n \n-#[doc(hidden)]\n-pub trait ImplementedByBitFlagsMacro {}\n-\n /// A trait that is automatically implemented for all bitflags.\n ///\n /// It should not be implemented manually.\n@@ -25,16 +22,7 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     fn from_bits_truncate(bits: Self::Bits) -> Self;\n     /// Convert from underlying bit representation, preserving all\n     /// bits (even those not corresponding to a defined flag).\n-    ///\n-    /// # Safety\n-    ///\n-    /// The caller of the `bitflags!` macro can chose to allow or\n-    /// disallow extra bits for their bitflags type.\n-    ///\n-    /// The caller of `from_bits_unchecked()` has to ensure that\n-    /// all bits correspond to a defined flag or that extra bits\n-    /// are valid for this bitflags type.\n-    unsafe fn from_bits_unchecked(bits: Self::Bits) -> Self;\n+    fn from_bits_retain(bits: Self::Bits) -> Self;\n     /// Returns `true` if no flags are currently stored.\n     fn is_empty(&self) -> bool;\n     /// Returns `true` if all flags are currently set.\n@@ -53,9 +41,22 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     fn set(&mut self, other: Self, value: bool);\n }\n \n+/// A marker trait that signals that an implementation of `BitFlags` came from the `bitflags!` macro.\n+///\n+/// There's nothing stopping an end-user from implementing this trait, but we don't guarantee their\n+/// manual implementations won't break between non-breaking releases.\n+#[doc(hidden)]\n+pub trait ImplementedByBitFlagsMacro {}\n+\n // Not re-exported\n pub trait Sealed {}\n \n+// Private implementation details\n+//\n+// The `Bits`, `PublicFlags`, and `InternalFlags` traits are implementation details of the `bitflags!`\n+// macro that we're free to change here. They work with the `bitflags!` macro to separate the generated\n+// code that belongs to end-users, and the generated code that belongs to this library.\n+\n /// A private trait that encodes the requirements of underlying bits types that can hold flags.\n ///\n /// This trait may be made public at some future point, but it presents a compatibility hazard\n@@ -107,3 +108,11 @@ impl_bits! {\n     u64, i64,\n     u128, i128,\n }\n+\n+pub trait PublicFlags {\n+    type InternalFlags;\n+}\n+\n+pub trait InternalFlags {\n+    type PublicFlags;\n+}\ndiff --git a/src/example_generated.rs b/src/example_generated.rs\nindex cf188d99..18985c75 100644\n--- a/src/example_generated.rs\n+++ b/src/example_generated.rs\n@@ -9,6 +9,35 @@ bitflags! {\n         const A = 0b00000001;\n         const B = 0b00000010;\n         const C = 0b00000100;\n-        const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+        const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n     }\n }\n+\n+/// This is the same internal field available as `self.0` on bitflags types.\n+/// These types aren't reachable by callers of `bitflags!`, they don't appear in the API of your\n+/// crate, but you can still interact with them through `self.0` in the module that defines the\n+/// bitflags type.\n+///\n+/// You can use this example as a reference for what methods are available to all internal bitflags\n+/// fields if you want to add custom functionality to your bitflags types.\n+///\n+/// Note that this struct is just for documentation purposes only, it must not be used outside\n+/// this crate.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[repr(transparent)]\n+pub struct FlagsField {\n+    bits: u32,\n+}\n+\n+__impl_internal_bitflags! {\n+    FlagsField: u32 {\n+        A;\n+        B;\n+        C;\n+        ABC;\n+    }\n+}\n+\n+impl crate::__private::InternalFlags for FlagsField {\n+    type PublicFlags = Flags;\n+}\ndiff --git a/src/lib.rs b/src/lib.rs\nindex 979ff918..fefac414 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -21,11 +21,12 @@\n //! use bitflags::bitflags;\n //!\n //! bitflags! {\n+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!     struct Flags: u32 {\n //!         const A = 0b00000001;\n //!         const B = 0b00000010;\n //!         const C = 0b00000100;\n-//!         const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+//!         const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n //!     }\n //! }\n //!\n@@ -51,6 +52,7 @@\n //! use bitflags::bitflags;\n //!\n //! bitflags! {\n+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!     struct Flags: u32 {\n //!         const A = 0b00000001;\n //!         const B = 0b00000010;\n@@ -59,14 +61,7 @@\n //!\n //! impl Flags {\n //!     pub fn clear(&mut self) {\n-//!         self.bits = 0;  // The `bits` field can be accessed from within the\n-//!                         // same module where the `bitflags!` macro was invoked.\n-//!     }\n-//! }\n-//!\n-//! impl fmt::Display for Flags {\n-//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-//!         write!(f, \"hi!\")\n+//!         *self.0.bits_mut() = 0;\n //!     }\n //! }\n //!\n@@ -74,9 +69,8 @@\n //!     let mut flags = Flags::A | Flags::B;\n //!     flags.clear();\n //!     assert!(flags.is_empty());\n-//!     assert_eq!(format!(\"{}\", flags), \"hi!\");\n-//!     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n-//!     assert_eq!(format!(\"{:?}\", Flags::B), \"B\");\n+//!     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"Flags(A | B)\");\n+//!     assert_eq!(format!(\"{:?}\", Flags::B), \"Flags(B)\");\n //! }\n //! ```\n //!\n@@ -91,10 +85,12 @@\n //!     use bitflags::bitflags;\n //!\n //!     bitflags! {\n+//!         #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!         pub struct Flags1: u32 {\n //!             const A = 0b00000001;\n //!         }\n //!\n+//!         #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //! #       pub\n //!         struct Flags2: u32 {\n //!             const B = 0b00000010;\n@@ -123,6 +119,7 @@\n //!\n //! bitflags! {\n //!     #[repr(transparent)]\n+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!     struct Flags: u32 {\n //!         const A = 0b00000001;\n //!         const B = 0b00000010;\n@@ -133,13 +130,8 @@\n //!\n //! # Trait implementations\n //!\n-//! The `Copy`, `Clone`, `PartialEq`, `Eq`, `PartialOrd`, `Ord` and `Hash`\n-//! traits are automatically derived for the `struct`s using the `derive` attribute.\n-//! Additional traits can be derived by providing an explicit `derive`\n-//! attribute on `struct`.\n-//!\n-//! The `Extend` and `FromIterator` traits are implemented for the `struct`s,\n-//! too: `Extend` adds the union of the instances of the `struct` iterated over,\n+//! The `Extend` and `FromIterator` traits are implemented for the `struct`s.\n+//! `Extend` adds the union of the instances of the `struct` iterated over,\n //! while `FromIterator` calculates the union.\n //!\n //! The `Binary`, `Debug`, `LowerHex`, `Octal` and `UpperHex` traits are also\n@@ -167,7 +159,7 @@\n //!                defined flag\n //! - `from_bits_truncate`: convert from underlying bit representation, dropping\n //!                         any bits that do not correspond to defined flags\n-//! - `from_bits_unchecked`: convert from underlying bit representation, keeping\n+//! - `from_bits_retain`: convert from underlying bit representation, keeping\n //!                          all bits (even those not corresponding to defined\n //!                          flags)\n //! - `is_empty`: `true` if no flags are currently stored\n@@ -204,7 +196,7 @@\n //!\n //! bitflags! {\n //!     // Results in default value with bits: 0\n-//!     #[derive(Default)]\n+//!     #[derive(Default, Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!     struct Flags: u32 {\n //!         const A = 0b00000001;\n //!         const B = 0b00000010;\n@@ -224,6 +216,7 @@\n //! use bitflags::bitflags;\n //!\n //! bitflags! {\n+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!     struct Flags: u32 {\n //!         const A = 0b00000001;\n //!         const B = 0b00000010;\n@@ -252,6 +245,7 @@\n //! use bitflags::bitflags;\n //!\n //! bitflags! {\n+//!     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n //!     struct Flags: u32 {\n //!         const NONE = 0b00000000;\n //!         const SOME = 0b00000001;\n@@ -285,10 +279,62 @@ mod bitflags_trait;\n \n #[doc(hidden)]\n pub mod __private {\n-    pub use crate::bitflags_trait::{Bits, ImplementedByBitFlagsMacro};\n+    pub use crate::bitflags_trait::{Bits, ImplementedByBitFlagsMacro, InternalFlags, PublicFlags};\n     pub use core;\n+\n+    #[cfg(feature = \"serde\")]\n+    pub use serde;\n }\n \n+/*\n+How does the bitflags crate work?\n+\n+This library generates `struct`s in the end-user's crate with a bunch of constants on it that represent flags.\n+The difference between `bitflags` and a lot of other libraries is that we don't actually control the generated `struct` in the end.\n+It's part of the end-user's crate, so it belongs to them. That makes it difficult to extend `bitflags` with new functionality\n+because we could end up breaking valid code that was already written.\n+\n+Our solution is to split the type we generate into two: the public struct owned by the end-user, and an internal struct owned by `bitflags` (us).\n+To give you an example, let's say we had a crate that called `bitflags!`:\n+\n+```rust\n+bitflags! {\n+    pub struct MyFlags: u32 {\n+        const A = 1;\n+        const B = 2;\n+    }\n+}\n+```\n+\n+What they'd end up with looks something like this:\n+\n+```rust\n+pub struct MyFlags(<MyFlags as PublicFlags>::InternalFlags);\n+\n+const _: () = {\n+    #[repr(transparent)]\n+    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+    pub struct MyInternalFlags {\n+        bits: u32,\n+    }\n+\n+    impl PublicFlags for MyFlags {\n+        type InternalFlags = InternalFlags;\n+    }\n+\n+    impl InternalFlags for MyInternalFlags {\n+        type PublicFlags = MyFlags;\n+    }\n+};\n+```\n+\n+If we want to expose something like a new trait impl for generated flags types, we add it to our generated `MyInternalFlags`,\n+and let `#[derive]` on `MyFlags` pick up that implementation, if an end-user chooses to add one.\n+\n+The public API is generated in the `__impl_bitflags_public!` macro, and the internal API is generated in\n+the `__impl_bitflags_internal!` macro.\n+*/\n+\n /// The macro used to generate the flag structure.\n ///\n /// See the [crate level docs](../bitflags/index.html) for complete documentation.\n@@ -299,11 +345,12 @@ pub mod __private {\n /// use bitflags::bitflags;\n ///\n /// bitflags! {\n+///     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n ///     struct Flags: u32 {\n ///         const A = 0b00000001;\n ///         const B = 0b00000010;\n ///         const C = 0b00000100;\n-///         const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+///         const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n ///     }\n /// }\n ///\n@@ -326,6 +373,7 @@ pub mod __private {\n /// use bitflags::bitflags;\n ///\n /// bitflags! {\n+///     #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n ///     struct Flags: u32 {\n ///         const A = 0b00000001;\n ///         const B = 0b00000010;\n@@ -334,14 +382,7 @@ pub mod __private {\n ///\n /// impl Flags {\n ///     pub fn clear(&mut self) {\n-///         self.bits = 0;  // The `bits` field can be accessed from within the\n-///                         // same module where the `bitflags!` macro was invoked.\n-///     }\n-/// }\n-///\n-/// impl fmt::Display for Flags {\n-///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-///         write!(f, \"hi!\")\n+///         *self.0.bits_mut() = 0;\n ///     }\n /// }\n ///\n@@ -349,9 +390,8 @@ pub mod __private {\n ///     let mut flags = Flags::A | Flags::B;\n ///     flags.clear();\n ///     assert!(flags.is_empty());\n-///     assert_eq!(format!(\"{}\", flags), \"hi!\");\n-///     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n-///     assert_eq!(format!(\"{:?}\", Flags::B), \"B\");\n+///     assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"Flags(A | B)\");\n+///     assert_eq!(format!(\"{:?}\", Flags::B), \"Flags(B)\");\n /// }\n /// ```\n #[macro_export(local_inner_macros)]\n@@ -368,12 +408,9 @@ macro_rules! bitflags {\n         $($t:tt)*\n     ) => {\n         $(#[$outer])*\n-        #[derive(Copy, PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\n-        $vis struct $BitFlags {\n-            bits: $T,\n-        }\n+        $vis struct $BitFlags(<$BitFlags as $crate::__private::PublicFlags>::InternalFlags);\n \n-        __impl_bitflags! {\n+        __impl_public_bitflags! {\n             $BitFlags: $T {\n                 $(\n                     $(#[$inner $($args)*])*\n@@ -382,6 +419,31 @@ macro_rules! bitflags {\n             }\n         }\n \n+        const _: () = {\n+            #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+            #[repr(transparent)]\n+            $vis struct InternalFlags {\n+                bits: $T,\n+            }\n+\n+            __impl_internal_bitflags! {\n+                InternalFlags: $T {\n+                    $(\n+                        $(#[$inner $($args)*])*\n+                        $Flag;\n+                    )*\n+                }\n+            }\n+\n+            impl $crate::__private::InternalFlags for InternalFlags {\n+                type PublicFlags = $BitFlags;\n+            }\n+\n+            impl $crate::__private::PublicFlags for $BitFlags {\n+                type InternalFlags = InternalFlags;\n+            }\n+        };\n+\n         bitflags! {\n             $($t)*\n         }\n@@ -389,70 +451,42 @@ macro_rules! bitflags {\n     () => {};\n }\n \n+/// Implement functions on the public (user-facing) bitflags type.\n+///\n+/// We need to be careful about adding new methods and trait implementations here because they\n+/// could conflict with items added by the end-user.\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n-macro_rules! __impl_bitflags {\n+macro_rules! __impl_public_bitflags {\n     (\n-        $BitFlags:ident: $T:ty {\n+        $PublicBitFlags:ident: $T:ty {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident = $value:expr;\n             )*\n         }\n     ) => {\n-        impl $crate::__private::core::fmt::Debug for $BitFlags {\n+        impl $crate::__private::core::fmt::Binary for $PublicBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                // Iterate over the valid flags\n-                let mut first = true;\n-                for (name, _) in self.iter() {\n-                    if !first {\n-                        f.write_str(\" | \")?;\n-                    }\n-\n-                    first = false;\n-                    f.write_str(name)?;\n-                }\n-\n-                // Append any extra bits that correspond to flags to the end of the format\n-                let extra_bits = self.bits & !Self::all().bits();\n-\n-                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n-                    if !first {\n-                        f.write_str(\" | \")?;\n-                    }\n-                    first = false;\n-                    $crate::__private::core::write!(f, \"{:#x}\", extra_bits)?;\n-                }\n-\n-                if first {\n-                    f.write_str(\"(empty)\")?;\n-                }\n-\n-                $crate::__private::core::fmt::Result::Ok(())\n-            }\n-        }\n-\n-        impl $crate::__private::core::fmt::Binary for $BitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Binary::fmt(&self.bits, f)\n+                $crate::__private::core::fmt::Binary::fmt(&self.0, f)\n             }\n         }\n \n-        impl $crate::__private::core::fmt::Octal for $BitFlags {\n+        impl $crate::__private::core::fmt::Octal for $PublicBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Octal::fmt(&self.bits, f)\n+                $crate::__private::core::fmt::Octal::fmt(&self.0, f)\n             }\n         }\n \n-        impl $crate::__private::core::fmt::LowerHex for $BitFlags {\n+        impl $crate::__private::core::fmt::LowerHex for $PublicBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::LowerHex::fmt(&self.bits, f)\n+                $crate::__private::core::fmt::LowerHex::fmt(&self.0, f)\n             }\n         }\n \n-        impl $crate::__private::core::fmt::UpperHex for $BitFlags {\n+        impl $crate::__private::core::fmt::UpperHex for $PublicBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::UpperHex::fmt(&self.bits, f)\n+                $crate::__private::core::fmt::UpperHex::fmt(&self.0, f)\n             }\n         }\n \n@@ -464,40 +498,37 @@ macro_rules! __impl_bitflags {\n             unused_mut,\n             non_upper_case_globals\n         )]\n-        impl $BitFlags {\n+        impl $PublicBitFlags {\n             $(\n                 $(#[$attr $($args)*])*\n-                pub const $Flag: Self = Self { bits: $value };\n+                pub const $Flag: Self = Self::from_bits_retain($value);\n             )*\n \n             /// Returns an empty set of flags.\n             #[inline]\n             pub const fn empty() -> Self {\n-                Self { bits: <$T as $crate::__private::Bits>::EMPTY }\n+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::empty())\n             }\n \n             /// Returns the set containing all flags.\n             #[inline]\n             pub const fn all() -> Self {\n-                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)\n+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::all())\n             }\n \n             /// Returns the raw value of the flags currently stored.\n             #[inline]\n             pub const fn bits(&self) -> $T {\n-                self.bits\n+                self.0.bits()\n             }\n \n             /// Convert from underlying bit representation, unless that\n             /// representation contains bits that do not correspond to a flag.\n             #[inline]\n             pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n-                let truncated = Self::from_bits_truncate(bits).bits;\n-\n-                if truncated == bits {\n-                    $crate::__private::core::option::Option::Some(Self { bits })\n-                } else {\n-                    $crate::__private::core::option::Option::None\n+                match <$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::from_bits(bits) {\n+                    $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n+                    $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n                 }\n             }\n \n@@ -505,20 +536,7 @@ macro_rules! __impl_bitflags {\n             /// that do not correspond to flags.\n             #[inline]\n             pub const fn from_bits_truncate(bits: $T) -> Self {\n-                if bits == <$T as $crate::__private::Bits>::EMPTY {\n-                    return Self { bits }\n-                }\n-\n-                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n-\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    if bits & Self::$Flag.bits == Self::$Flag.bits {\n-                        truncated |= Self::$Flag.bits\n-                    }\n-                )*\n-\n-                Self { bits: truncated }\n+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::from_bits_truncate(bits))\n             }\n \n             /// Convert from underlying bit representation, preserving all\n@@ -529,64 +547,60 @@ macro_rules! __impl_bitflags {\n             /// The caller of the `bitflags!` macro can choose to allow or\n             /// disallow extra bits for their bitflags type.\n             ///\n-            /// The caller of `from_bits_unchecked()` has to ensure that\n+            /// The caller of `from_bits_retain()` has to ensure that\n             /// all bits correspond to a defined flag or that extra bits\n             /// are valid for this bitflags type.\n             #[inline]\n-            pub const unsafe fn from_bits_unchecked(bits: $T) -> Self {\n-                Self { bits }\n+            pub const fn from_bits_retain(bits: $T) -> Self {\n+                Self(<$PublicBitFlags as $crate::__private::PublicFlags>::InternalFlags::from_bits_retain(bits))\n             }\n \n             /// Returns `true` if no flags are currently stored.\n             #[inline]\n             pub const fn is_empty(&self) -> bool {\n-                self.bits() == Self::empty().bits()\n+                self.0.is_empty()\n             }\n \n             /// Returns `true` if all flags are currently set.\n             #[inline]\n             pub const fn is_all(&self) -> bool {\n-                Self::all().bits | self.bits == self.bits\n+                self.0.is_all()\n             }\n \n             /// Returns `true` if there are flags common to both `self` and `other`.\n             #[inline]\n             pub const fn intersects(&self, other: Self) -> bool {\n-                !(Self { bits: self.bits & other.bits}).is_empty()\n+                self.0.intersects(other.0)\n             }\n \n             /// Returns `true` if all of the flags in `other` are contained within `self`.\n             #[inline]\n             pub const fn contains(&self, other: Self) -> bool {\n-                (self.bits & other.bits) == other.bits\n+                self.0.contains(other.0)\n             }\n \n             /// Inserts the specified flags in-place.\n             #[inline]\n             pub fn insert(&mut self, other: Self) {\n-                self.bits |= other.bits;\n+                self.0.insert(other.0)\n             }\n \n             /// Removes the specified flags in-place.\n             #[inline]\n             pub fn remove(&mut self, other: Self) {\n-                self.bits &= !other.bits;\n+                self.0.remove(other.0)\n             }\n \n             /// Toggles the specified flags in-place.\n             #[inline]\n             pub fn toggle(&mut self, other: Self) {\n-                self.bits ^= other.bits;\n+                self.0.toggle(other.0)\n             }\n \n             /// Inserts or removes the specified flags depending on the passed value.\n             #[inline]\n             pub fn set(&mut self, other: Self, value: bool) {\n-                if value {\n-                    self.insert(other);\n-                } else {\n-                    self.remove(other);\n-                }\n+                self.0.set(other.0, value)\n             }\n \n             /// Returns the intersection between the flags in `self` and\n@@ -602,7 +616,7 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn intersection(self, other: Self) -> Self {\n-                Self { bits: self.bits & other.bits }\n+                Self(self.0.intersection(other.0))\n             }\n \n             /// Returns the union of between the flags in `self` and `other`.\n@@ -619,7 +633,7 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn union(self, other: Self) -> Self {\n-                Self { bits: self.bits | other.bits }\n+                Self(self.0.union(other.0))\n             }\n \n             /// Returns the difference between the flags in `self` and `other`.\n@@ -637,7 +651,7 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn difference(self, other: Self) -> Self {\n-                Self { bits: self.bits & !other.bits }\n+                Self(self.0.difference(other.0))\n             }\n \n             /// Returns the [symmetric difference][sym-diff] between the flags\n@@ -656,7 +670,7 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn symmetric_difference(self, other: Self) -> Self {\n-                Self { bits: self.bits ^ other.bits }\n+                Self(self.0.symmetric_difference(other.0))\n             }\n \n             /// Returns the complement of this set of flags.\n@@ -675,159 +689,101 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             #[must_use]\n             pub const fn complement(self) -> Self {\n-                Self::from_bits_truncate(!self.bits)\n+                Self(self.0.complement())\n             }\n \n             /// Returns an iterator over set flags and their names.\n             pub fn iter(self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, Self)> {\n                 use $crate::__private::core::iter::Iterator as _;\n \n-                const NUM_FLAGS: usize = {\n-                    let mut num_flags = 0;\n-\n-                    $(\n-                        $(#[$attr $($args)*])*\n-                        {\n-                            num_flags += 1;\n-                        }\n-                    )*\n-\n-                    num_flags\n-                };\n-\n-                const OPTIONS: [$BitFlags; NUM_FLAGS] = [\n-                    $(\n-                        $(#[$attr $($args)*])*\n-                        $BitFlags::$Flag,\n-                    )*\n-                ];\n-\n-                const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n-                    $(\n-                        $(#[$attr $($args)*])*\n-                        $crate::__private::core::stringify!($Flag),\n-                    )*\n-                ];\n-\n-                let mut start = 0;\n-                let mut state = self;\n-\n-                $crate::__private::core::iter::from_fn(move || {\n-                    if state.is_empty() || NUM_FLAGS == 0 {\n-                        $crate::__private::core::option::Option::None\n-                    } else {\n-                        for (flag, flag_name) in OPTIONS[start..NUM_FLAGS].iter().copied()\n-                            .zip(OPTIONS_NAMES[start..NUM_FLAGS].iter().copied())\n-                        {\n-                            start += 1;\n-\n-                            // NOTE: We check whether the flag exists in self, but remove it from\n-                            // a different value. This ensure that overlapping flags are handled\n-                            // properly. Take the following example:\n-                            //\n-                            // const A: 0b00000001;\n-                            // const B: 0b00000101;\n-                            //\n-                            // Given the bits 0b00000101, both A and B are set. But if we removed A\n-                            // as we encountered it we'd be left with 0b00000100, which doesn't\n-                            // correspond to a valid flag on its own.\n-                            if self.contains(flag) {\n-                                state.remove(flag);\n-\n-                                return $crate::__private::core::option::Option::Some((flag_name, flag))\n-                            }\n-                        }\n-\n-                        $crate::__private::core::option::Option::None\n-                    }\n-                })\n+                self.0.iter().map(|(name, bits)| (name, Self::from_bits_retain(bits)))\n             }\n \n         }\n \n-        impl $crate::__private::core::ops::BitOr for $BitFlags {\n+        impl $crate::__private::core::ops::BitOr for $PublicBitFlags {\n             type Output = Self;\n \n             /// Returns the union of the two sets of flags.\n             #[inline]\n-            fn bitor(self, other: $BitFlags) -> Self {\n-                Self { bits: self.bits | other.bits }\n+            fn bitor(self, other: $PublicBitFlags) -> Self {\n+                self.union(other)\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitOrAssign for $BitFlags {\n+        impl $crate::__private::core::ops::BitOrAssign for $PublicBitFlags {\n             /// Adds the set of flags.\n             #[inline]\n             fn bitor_assign(&mut self, other: Self) {\n-                self.bits |= other.bits;\n+                self.0 = self.0.union(other.0);\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitXor for $BitFlags {\n+        impl $crate::__private::core::ops::BitXor for $PublicBitFlags {\n             type Output = Self;\n \n             /// Returns the left flags, but with all the right flags toggled.\n             #[inline]\n             fn bitxor(self, other: Self) -> Self {\n-                Self { bits: self.bits ^ other.bits }\n+                self.symmetric_difference(other)\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitXorAssign for $BitFlags {\n+        impl $crate::__private::core::ops::BitXorAssign for $PublicBitFlags {\n             /// Toggles the set of flags.\n             #[inline]\n             fn bitxor_assign(&mut self, other: Self) {\n-                self.bits ^= other.bits;\n+                self.0 = self.0.symmetric_difference(other.0);\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitAnd for $BitFlags {\n+        impl $crate::__private::core::ops::BitAnd for $PublicBitFlags {\n             type Output = Self;\n \n             /// Returns the intersection between the two sets of flags.\n             #[inline]\n             fn bitand(self, other: Self) -> Self {\n-                Self { bits: self.bits & other.bits }\n+                self.intersection(other)\n             }\n         }\n \n-        impl $crate::__private::core::ops::BitAndAssign for $BitFlags {\n+        impl $crate::__private::core::ops::BitAndAssign for $PublicBitFlags {\n             /// Disables all flags disabled in the set.\n             #[inline]\n             fn bitand_assign(&mut self, other: Self) {\n-                self.bits &= other.bits;\n+                self.0 = self.0.intersection(other.0);\n             }\n         }\n \n-        impl $crate::__private::core::ops::Sub for $BitFlags {\n+        impl $crate::__private::core::ops::Sub for $PublicBitFlags {\n             type Output = Self;\n \n             /// Returns the set difference of the two sets of flags.\n             #[inline]\n             fn sub(self, other: Self) -> Self {\n-                Self { bits: self.bits & !other.bits }\n+                self.difference(other)\n             }\n         }\n \n-        impl $crate::__private::core::ops::SubAssign for $BitFlags {\n+        impl $crate::__private::core::ops::SubAssign for $PublicBitFlags {\n             /// Disables all flags enabled in the set.\n             #[inline]\n             fn sub_assign(&mut self, other: Self) {\n-                self.bits &= !other.bits;\n+                self.0 = self.0.difference(other.0);\n             }\n         }\n \n-        impl $crate::__private::core::ops::Not for $BitFlags {\n+        impl $crate::__private::core::ops::Not for $PublicBitFlags {\n             type Output = Self;\n \n             /// Returns the complement of this set of flags.\n             #[inline]\n             fn not(self) -> Self {\n-                Self { bits: !self.bits } & Self::all()\n+                self.complement()\n             }\n         }\n \n-        impl $crate::__private::core::iter::Extend<$BitFlags> for $BitFlags {\n+        impl $crate::__private::core::iter::Extend<$PublicBitFlags> for $PublicBitFlags {\n             fn extend<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(&mut self, iterator: T) {\n                 for item in iterator {\n                     self.insert(item)\n@@ -835,7 +791,7 @@ macro_rules! __impl_bitflags {\n             }\n         }\n \n-        impl $crate::__private::core::iter::FromIterator<$BitFlags> for $BitFlags {\n+        impl $crate::__private::core::iter::FromIterator<$PublicBitFlags> for $PublicBitFlags {\n             fn from_iter<T: $crate::__private::core::iter::IntoIterator<Item=Self>>(iterator: T) -> Self {\n                 use $crate::__private::core::iter::Extend;\n \n@@ -845,181 +801,421 @@ macro_rules! __impl_bitflags {\n             }\n         }\n \n-        impl $crate::BitFlags for $BitFlags {\n+        impl $crate::BitFlags for $PublicBitFlags {\n             type Bits = $T;\n \n             fn empty() -> Self {\n-                $BitFlags::empty()\n+                $PublicBitFlags::empty()\n             }\n \n             fn all() -> Self {\n-                $BitFlags::all()\n+                $PublicBitFlags::all()\n             }\n \n             fn bits(&self) -> $T {\n-                $BitFlags::bits(self)\n+                $PublicBitFlags::bits(self)\n             }\n \n-            fn from_bits(bits: $T) -> $crate::__private::core::option::Option<$BitFlags> {\n-                $BitFlags::from_bits(bits)\n+            fn from_bits(bits: $T) -> $crate::__private::core::option::Option<$PublicBitFlags> {\n+                $PublicBitFlags::from_bits(bits)\n             }\n \n-            fn from_bits_truncate(bits: $T) -> $BitFlags {\n-                $BitFlags::from_bits_truncate(bits)\n+            fn from_bits_truncate(bits: $T) -> $PublicBitFlags {\n+                $PublicBitFlags::from_bits_truncate(bits)\n             }\n \n-            unsafe fn from_bits_unchecked(bits: $T) -> $BitFlags {\n-                $BitFlags::from_bits_unchecked(bits)\n+            fn from_bits_retain(bits: $T) -> $PublicBitFlags {\n+                $PublicBitFlags::from_bits_retain(bits)\n             }\n \n             fn is_empty(&self) -> bool {\n-                $BitFlags::is_empty(self)\n+                $PublicBitFlags::is_empty(self)\n             }\n \n             fn is_all(&self) -> bool {\n-                $BitFlags::is_all(self)\n+                $PublicBitFlags::is_all(self)\n             }\n \n-            fn intersects(&self, other: $BitFlags) -> bool {\n-                $BitFlags::intersects(self, other)\n+            fn intersects(&self, other: $PublicBitFlags) -> bool {\n+                $PublicBitFlags::intersects(self, other)\n             }\n \n-            fn contains(&self, other: $BitFlags) -> bool {\n-                $BitFlags::contains(self, other)\n+            fn contains(&self, other: $PublicBitFlags) -> bool {\n+                $PublicBitFlags::contains(self, other)\n             }\n \n-            fn insert(&mut self, other: $BitFlags) {\n-                $BitFlags::insert(self, other)\n+            fn insert(&mut self, other: $PublicBitFlags) {\n+                $PublicBitFlags::insert(self, other)\n             }\n \n-            fn remove(&mut self, other: $BitFlags) {\n-                $BitFlags::remove(self, other)\n+            fn remove(&mut self, other: $PublicBitFlags) {\n+                $PublicBitFlags::remove(self, other)\n             }\n \n-            fn toggle(&mut self, other: $BitFlags) {\n-                $BitFlags::toggle(self, other)\n+            fn toggle(&mut self, other: $PublicBitFlags) {\n+                $PublicBitFlags::toggle(self, other)\n             }\n \n-            fn set(&mut self, other: $BitFlags, value: bool) {\n-                $BitFlags::set(self, other, value)\n+            fn set(&mut self, other: $PublicBitFlags, value: bool) {\n+                $PublicBitFlags::set(self, other, value)\n             }\n         }\n \n-        impl $crate::__private::ImplementedByBitFlagsMacro for $BitFlags {}\n+        impl $crate::__private::ImplementedByBitFlagsMacro for $PublicBitFlags {}\n     };\n+}\n \n-    // Every attribute that the user writes on a const is applied to the\n-    // corresponding const that we generate, but within the implementation of\n-    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n-    // particular, including a #[deprecated] attribute on those items would fail\n-    // to compile.\n-    // https://github.com/bitflags/bitflags/issues/109\n-    //\n-    // Input:\n-    //\n-    //     ? #[cfg(feature = \"advanced\")]\n-    //     ? #[deprecated(note = \"Use something else.\")]\n-    //     ? #[doc = r\"High quality documentation.\"]\n-    //     fn f() -> i32 { /* ... */ }\n-    //\n-    // Output:\n-    //\n-    //     #[cfg(feature = \"advanced\")]\n-    //     fn f() -> i32 { /* ... */ }\n+/// Implement functions on the private (bitflags-facing) bitflags type.\n+///\n+/// Methods and trait implementations can be freely added here without breaking end-users.\n+/// If we want to expose new functionality to `#[derive]`, this is the place to do it.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_internal_bitflags {\n     (\n-        $(#[$filtered:meta])*\n-        ? #[cfg $($cfgargs:tt)*]\n-        $(? #[$rest:ident $($restargs:tt)*])*\n-        fn $($item:tt)*\n-    ) => {\n-        __impl_bitflags! {\n-            $(#[$filtered])*\n-            #[cfg $($cfgargs)*]\n-            $(? #[$rest $($restargs)*])*\n-            fn $($item)*\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n         }\n-    };\n-    (\n-        $(#[$filtered:meta])*\n-        // $next != `cfg`\n-        ? #[$next:ident $($nextargs:tt)*]\n-        $(? #[$rest:ident $($restargs:tt)*])*\n-        fn $($item:tt)*\n     ) => {\n-        __impl_bitflags! {\n-            $(#[$filtered])*\n-            // $next filtered out\n-            $(? #[$rest $($restargs)*])*\n-            fn $($item)*\n+        // Any new library traits impls should be added here\n+        __impl_internal_bitflags_serde! {\n+            $InternalBitFlags: $T {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n         }\n-    };\n-    (\n-        $(#[$filtered:meta])*\n-        fn $($item:tt)*\n-    ) => {\n-        $(#[$filtered])*\n-        fn $($item)*\n-    };\n \n-    // Every attribute that the user writes on a const is applied to the\n-    // corresponding const that we generate, but within the implementation of\n-    // Debug and all() we want to ignore everything but #[cfg] attributes. In\n-    // particular, including a #[deprecated] attribute on those items would fail\n-    // to compile.\n-    // https://github.com/bitflags/bitflags/issues/109\n-    //\n-    // const version\n-    //\n-    // Input:\n-    //\n-    //     ? #[cfg(feature = \"advanced\")]\n-    //     ? #[deprecated(note = \"Use something else.\")]\n-    //     ? #[doc = r\"High quality documentation.\"]\n-    //     const f: i32 { /* ... */ }\n-    //\n-    // Output:\n-    //\n-    //     #[cfg(feature = \"advanced\")]\n-    //     const f: i32 { /* ... */ }\n-    (\n-        $(#[$filtered:meta])*\n-        ? #[cfg $($cfgargs:tt)*]\n-        $(? #[$rest:ident $($restargs:tt)*])*\n-        const $($item:tt)*\n-    ) => {\n-        __impl_bitflags! {\n-            $(#[$filtered])*\n-            #[cfg $($cfgargs)*]\n-            $(? #[$rest $($restargs)*])*\n-            const $($item)*\n+        impl $crate::__private::core::default::Default for $InternalBitFlags {\n+            #[inline]\n+            fn default() -> Self {\n+                $InternalBitFlags::empty()\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::Debug for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                // Iterate over the valid flags\n+                let mut first = true;\n+                for (name, _) in self.iter() {\n+                    if !first {\n+                        f.write_str(\" | \")?;\n+                    }\n+\n+                    first = false;\n+                    f.write_str(name)?;\n+                }\n+\n+                // Append any extra bits that correspond to flags to the end of the format\n+                let extra_bits = self.bits & !Self::all().bits;\n+\n+                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n+                    if !first {\n+                        f.write_str(\" | \")?;\n+                    }\n+                    first = false;\n+                    $crate::__private::core::write!(f, \"{:#x}\", extra_bits)?;\n+                }\n+\n+                if first {\n+                    f.write_str(\"empty\")?;\n+                }\n+\n+                $crate::__private::core::fmt::Result::Ok(())\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::Binary for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::Binary::fmt(&self.bits(), f)\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::Octal for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::Octal::fmt(&self.bits(), f)\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::LowerHex for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::LowerHex::fmt(&self.bits(), f)\n+            }\n+        }\n+\n+        impl $crate::__private::core::fmt::UpperHex for $InternalBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::UpperHex::fmt(&self.bits(), f)\n+            }\n+        }\n+\n+        #[allow(\n+            dead_code,\n+            deprecated,\n+            unused_doc_comments,\n+            unused_attributes,\n+            unused_mut,\n+            non_upper_case_globals\n+        )]\n+        impl $InternalBitFlags {\n+            #[inline]\n+            pub const fn empty() -> Self {\n+                Self { bits: <$T as $crate::__private::Bits>::EMPTY }\n+            }\n+\n+            #[inline]\n+            pub const fn all() -> Self {\n+                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)\n+            }\n+\n+            #[inline]\n+            pub const fn bits(&self) -> $T {\n+                self.bits\n+            }\n+\n+            #[inline]\n+            pub fn bits_mut(&mut self) -> &mut $T {\n+                &mut self.bits\n+            }\n+\n+            #[inline]\n+            pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n+                let truncated = Self::from_bits_truncate(bits).bits;\n+\n+                if truncated == bits {\n+                    $crate::__private::core::option::Option::Some(Self { bits })\n+                } else {\n+                    $crate::__private::core::option::Option::None\n+                }\n+            }\n+\n+            #[inline]\n+            pub const fn from_bits_truncate(bits: $T) -> Self {\n+                if bits == <$T as $crate::__private::Bits>::EMPTY {\n+                    return Self { bits }\n+                }\n+\n+                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n+\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    if bits & <$InternalBitFlags as $crate::__private::InternalFlags>::PublicFlags::$Flag.bits() == <$InternalBitFlags as $crate::__private::InternalFlags>::PublicFlags::$Flag.bits() {\n+                        truncated |= <$InternalBitFlags as $crate::__private::InternalFlags>::PublicFlags::$Flag.bits()\n+                    }\n+                )*\n+\n+                Self { bits: truncated }\n+            }\n+\n+            #[inline]\n+            pub const fn from_bits_retain(bits: $T) -> Self {\n+                Self { bits }\n+            }\n+\n+            #[inline]\n+            pub const fn is_empty(&self) -> bool {\n+                self.bits == Self::empty().bits\n+            }\n+\n+            #[inline]\n+            pub const fn is_all(&self) -> bool {\n+                Self::all().bits | self.bits == self.bits\n+            }\n+\n+            #[inline]\n+            pub const fn intersects(&self, other: Self) -> bool {\n+                !(Self { bits: self.bits & other.bits}).is_empty()\n+            }\n+\n+            #[inline]\n+            pub const fn contains(&self, other: Self) -> bool {\n+                (self.bits & other.bits) == other.bits\n+            }\n+\n+            #[inline]\n+            pub fn insert(&mut self, other: Self) {\n+                self.bits |= other.bits;\n+            }\n+\n+            #[inline]\n+            pub fn remove(&mut self, other: Self) {\n+                self.bits &= !other.bits;\n+            }\n+\n+            #[inline]\n+            pub fn toggle(&mut self, other: Self) {\n+                self.bits ^= other.bits;\n+            }\n+\n+            #[inline]\n+            pub fn set(&mut self, other: Self, value: bool) {\n+                if value {\n+                    self.insert(other);\n+                } else {\n+                    self.remove(other);\n+                }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn intersection(self, other: Self) -> Self {\n+                Self { bits: self.bits & other.bits }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn union(self, other: Self) -> Self {\n+                Self { bits: self.bits | other.bits }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn difference(self, other: Self) -> Self {\n+                Self { bits: self.bits & !other.bits }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn symmetric_difference(self, other: Self) -> Self {\n+                Self { bits: self.bits ^ other.bits }\n+            }\n+\n+            #[inline]\n+            #[must_use]\n+            pub const fn complement(self) -> Self {\n+                Self::from_bits_truncate(!self.bits)\n+            }\n+\n+            pub fn iter(self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, $T)> {\n+                use $crate::__private::core::iter::Iterator as _;\n+\n+                const NUM_FLAGS: usize = {\n+                    let mut num_flags = 0;\n+\n+                    $(\n+                        $(#[$attr $($args)*])*\n+                        {\n+                            num_flags += 1;\n+                        }\n+                    )*\n+\n+                    num_flags\n+                };\n+\n+                const OPTIONS: [$T; NUM_FLAGS] = [\n+                    $(\n+                        $(#[$attr $($args)*])*\n+                        <$InternalBitFlags as $crate::__private::InternalFlags>::PublicFlags::$Flag.bits(),\n+                    )*\n+                ];\n+\n+                const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n+                    $(\n+                        $(#[$attr $($args)*])*\n+                        $crate::__private::core::stringify!($Flag),\n+                    )*\n+                ];\n+\n+                let mut start = 0;\n+                let mut state = self;\n+\n+                $crate::__private::core::iter::from_fn(move || {\n+                    if state.is_empty() || NUM_FLAGS == 0 {\n+                        $crate::__private::core::option::Option::None\n+                    } else {\n+                        for (flag, flag_name) in OPTIONS[start..NUM_FLAGS].iter().copied()\n+                            .zip(OPTIONS_NAMES[start..NUM_FLAGS].iter().copied())\n+                        {\n+                            start += 1;\n+\n+                            // NOTE: We check whether the flag exists in self, but remove it from\n+                            // a different value. This ensure that overlapping flags are handled\n+                            // properly. Take the following example:\n+                            //\n+                            // const A: 0b00000001;\n+                            // const B: 0b00000101;\n+                            //\n+                            // Given the bits 0b00000101, both A and B are set. But if we removed A\n+                            // as we encountered it we'd be left with 0b00000100, which doesn't\n+                            // correspond to a valid flag on its own.\n+                            if self.contains(Self { bits: flag }) {\n+                                state.remove(Self { bits: flag });\n+\n+                                return $crate::__private::core::option::Option::Some((flag_name, flag))\n+                            }\n+                        }\n+\n+                        $crate::__private::core::option::Option::None\n+                    }\n+                })\n+            }\n         }\n     };\n+}\n+\n+// Optional features\n+//\n+// These macros implement additional library traits for the internal bitflags type so that\n+// the end-user can either implement or derive those same traits based on the implementation\n+// we provide in `bitflags`.\n+//\n+// These macros all follow a  similar pattern. If an optional feature of `bitflags` is enabled\n+// they'll expand to some impl blocks based on a re-export of the library. If the optional feature\n+// is not enabled then they expand to a no-op.\n+\n+/// Implement `Serialize` and `Deserialize` for the internal bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(feature = \"serde\")]\n+macro_rules! __impl_internal_bitflags_serde {\n     (\n-        $(#[$filtered:meta])*\n-        // $next != `cfg`\n-        ? #[$next:ident $($nextargs:tt)*]\n-        $(? #[$rest:ident $($restargs:tt)*])*\n-        const $($item:tt)*\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n     ) => {\n-        __impl_bitflags! {\n-            $(#[$filtered])*\n-            // $next filtered out\n-            $(? #[$rest $($restargs)*])*\n-            const $($item)*\n+        impl $crate::__private::serde::Serialize for $InternalBitFlags {\n+            fn serialize<S: $crate::__private::serde::Serializer>(&self, serializer: S) -> $crate::__private::core::result::Result<S::Ok, S::Error> {\n+                $crate::serde_support::serialize_bits_default($crate::__private::core::stringify!($InternalBitFlags), &self.bits, serializer)\n+            }\n         }\n-    };\n+\n+        impl<'de> $crate::__private::serde::Deserialize<'de> for $InternalBitFlags {\n+            fn deserialize<D: $crate::__private::serde::Deserializer<'de>>(deserializer: D) -> $crate::__private::core::result::Result<Self, D::Error> {\n+                let bits = $crate::serde_support::deserialize_bits_default($crate::__private::core::stringify!($InternalBitFlags), deserializer)?;\n+\n+                $crate::__private::core::result::Result::Ok($InternalBitFlags::from_bits_retain(bits))\n+            }\n+        }\n+    }\n+}\n+\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(not(feature = \"serde\"))]\n+macro_rules! __impl_internal_bitflags_serde {\n     (\n-        $(#[$filtered:meta])*\n-        const $($item:tt)*\n-    ) => {\n-        $(#[$filtered])*\n-        const $($item)*\n-    };\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n+    ) => { }\n }\n \n #[cfg(feature = \"example_generated\")]\n pub mod example_generated;\n \n+#[cfg(feature = \"serde\")]\n+pub mod serde_support;\n+\n #[cfg(test)]\n mod tests {\n     use std::collections::hash_map::DefaultHasher;\n@@ -1030,7 +1226,7 @@ mod tests {\n         #[doc = \"> you are the easiest person to fool.\"]\n         #[doc = \"> \"]\n         #[doc = \"> - Richard Feynman\"]\n-        #[derive(Default)]\n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct Flags: u32 {\n             const A = 0b00000001;\n             #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n@@ -1039,28 +1235,32 @@ mod tests {\n             #[doc = \"* cmr bed\"]\n             #[doc = \"* strcat table\"]\n             #[doc = \"<strcat> wait what?\"]\n-            const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+            const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n         }\n \n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct _CfgFlags: u32 {\n             #[cfg(unix)]\n             const _CFG_A = 0b01;\n             #[cfg(windows)]\n             const _CFG_B = 0b01;\n             #[cfg(unix)]\n-            const _CFG_C = Self::_CFG_A.bits | 0b10;\n+            const _CFG_C = Self::_CFG_A.bits() | 0b10;\n         }\n \n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct AnotherSetOfFlags: i8 {\n             const ANOTHER_FLAG = -1_i8;\n         }\n \n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct LongFlags: u32 {\n             const LONG_A = 0b1111111111111111;\n         }\n     }\n \n     bitflags! {\n+        #[derive(Clone, Copy, Default, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         struct EmptyFlags: u32 {\n         }\n     }\n@@ -1113,28 +1313,28 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_from_bits_unchecked() {\n-        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n-        assert_eq!(unsafe { Flags::from_bits_unchecked(0) }, Flags::empty());\n-        assert_eq!(unsafe { Flags::from_bits_unchecked(0b1) }, Flags::A);\n-        assert_eq!(unsafe { Flags::from_bits_unchecked(0b10) }, Flags::B);\n+    fn test_from_bits_retain() {\n+        let extra = Flags::from_bits_retain(0b1000);\n+        assert_eq!(Flags::from_bits_retain(0), Flags::empty());\n+        assert_eq!(Flags::from_bits_retain(0b1), Flags::A);\n+        assert_eq!(Flags::from_bits_retain(0b10), Flags::B);\n \n         assert_eq!(\n-            unsafe { Flags::from_bits_unchecked(0b11) },\n+            Flags::from_bits_retain(0b11),\n             (Flags::A | Flags::B)\n         );\n         assert_eq!(\n-            unsafe { Flags::from_bits_unchecked(0b1000) },\n+            Flags::from_bits_retain(0b1000),\n             (extra | Flags::empty())\n         );\n         assert_eq!(\n-            unsafe { Flags::from_bits_unchecked(0b1001) },\n+            Flags::from_bits_retain(0b1001),\n             (extra | Flags::A)\n         );\n \n-        let extra = unsafe { EmptyFlags::from_bits_unchecked(0b1000) };\n+        let extra = EmptyFlags::from_bits_retain(0b1000);\n         assert_eq!(\n-            unsafe { EmptyFlags::from_bits_unchecked(0b1000) },\n+            EmptyFlags::from_bits_retain(0b1000),\n             (extra | EmptyFlags::empty())\n         );\n     }\n@@ -1157,7 +1357,7 @@ mod tests {\n         assert!(!Flags::A.is_all());\n         assert!(Flags::ABC.is_all());\n \n-        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n+        let extra = Flags::from_bits_retain(0b1000);\n         assert!(!extra.is_all());\n         assert!(!(Flags::A | extra).is_all());\n         assert!((Flags::ABC | extra).is_all());\n@@ -1255,7 +1455,7 @@ mod tests {\n \n     #[test]\n     fn test_operators_unchecked() {\n-        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n+        let extra = Flags::from_bits_retain(0b1000);\n         let e1 = Flags::A | Flags::C | extra;\n         let e2 = Flags::B | Flags::C;\n         assert_eq!((e1 | e2), (Flags::ABC | extra)); // union\n@@ -1274,9 +1474,9 @@ mod tests {\n         let ab = Flags::A.union(Flags::B);\n         let ac = Flags::A.union(Flags::C);\n         let bc = Flags::B.union(Flags::C);\n-        assert_eq!(ab.bits, 0b011);\n-        assert_eq!(bc.bits, 0b110);\n-        assert_eq!(ac.bits, 0b101);\n+        assert_eq!(ab.bits(), 0b011);\n+        assert_eq!(bc.bits(), 0b110);\n+        assert_eq!(ac.bits(), 0b101);\n \n         assert_eq!(ab, Flags::B.union(Flags::A));\n         assert_eq!(ac, Flags::C.union(Flags::A));\n@@ -1329,10 +1529,10 @@ mod tests {\n \n     #[test]\n     fn test_set_ops_unchecked() {\n-        let extra = unsafe { Flags::from_bits_unchecked(0b1000) };\n+        let extra = Flags::from_bits_retain(0b1000);\n         let e1 = Flags::A.union(Flags::C).union(extra);\n         let e2 = Flags::B.union(Flags::C);\n-        assert_eq!(e1.bits, 0b1101);\n+        assert_eq!(e1.bits(), 0b1101);\n         assert_eq!(e1.union(e2), (Flags::ABC | extra));\n         assert_eq!(e1.intersection(e2), Flags::C);\n         assert_eq!(e1.difference(e2), Flags::A | extra);\n@@ -1346,11 +1546,12 @@ mod tests {\n     fn test_set_ops_exhaustive() {\n         // Define a flag that contains gaps to help exercise edge-cases,\n         // especially around \"unknown\" flags (e.g. ones outside of `all()`\n-        // `from_bits_unchecked`).\n+        // `from_bits_retain`).\n         // - when lhs and rhs both have different sets of unknown flags.\n         // - unknown flags at both ends, and in the middle\n         // - cases with \"gaps\".\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Test: u16 {\n                 // Intentionally no `A`\n                 const B = 0b000000010;\n@@ -1364,12 +1565,12 @@ mod tests {\n             }\n         }\n         let iter_test_flags =\n-            || (0..=0b111_1111_1111).map(|bits| unsafe { Test::from_bits_unchecked(bits) });\n+            || (0..=0b111_1111_1111).map(|bits| Test::from_bits_retain(bits));\n \n         for a in iter_test_flags() {\n             assert_eq!(\n                 a.complement(),\n-                Test::from_bits_truncate(!a.bits),\n+                Test::from_bits_truncate(!a.bits()),\n                 \"wrong result: !({:?})\",\n                 a,\n             );\n@@ -1378,37 +1579,37 @@ mod tests {\n                 // Check that the named operations produce the expected bitwise\n                 // values.\n                 assert_eq!(\n-                    a.union(b).bits,\n-                    a.bits | b.bits,\n+                    a.union(b).bits(),\n+                    a.bits() | b.bits(),\n                     \"wrong result: `{:?}` | `{:?}`\",\n                     a,\n                     b,\n                 );\n                 assert_eq!(\n-                    a.intersection(b).bits,\n-                    a.bits & b.bits,\n+                    a.intersection(b).bits(),\n+                    a.bits() & b.bits(),\n                     \"wrong result: `{:?}` & `{:?}`\",\n                     a,\n                     b,\n                 );\n                 assert_eq!(\n-                    a.symmetric_difference(b).bits,\n-                    a.bits ^ b.bits,\n+                    a.symmetric_difference(b).bits(),\n+                    a.bits() ^ b.bits(),\n                     \"wrong result: `{:?}` ^ `{:?}`\",\n                     a,\n                     b,\n                 );\n                 assert_eq!(\n-                    a.difference(b).bits,\n-                    a.bits & !b.bits,\n+                    a.difference(b).bits(),\n+                    a.bits() & !b.bits(),\n                     \"wrong result: `{:?}` - `{:?}`\",\n                     a,\n                     b,\n                 );\n                 // Note: Difference is checked as both `a - b` and `b - a`\n                 assert_eq!(\n-                    b.difference(a).bits,\n-                    b.bits & !a.bits,\n+                    b.difference(a).bits(),\n+                    b.bits() & !a.bits(),\n                     \"wrong result: `{:?}` - `{:?}`\",\n                     b,\n                     a,\n@@ -1577,28 +1778,28 @@ mod tests {\n \n     #[test]\n     fn test_debug() {\n-        assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n-        assert_eq!(format!(\"{:?}\", Flags::empty()), \"(empty)\");\n-        assert_eq!(format!(\"{:?}\", Flags::ABC), \"A | B | C\");\n+        assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"Flags(A | B)\");\n+        assert_eq!(format!(\"{:?}\", Flags::empty()), \"Flags(empty)\");\n+        assert_eq!(format!(\"{:?}\", Flags::ABC), \"Flags(A | B | C)\");\n \n-        let extra = unsafe { Flags::from_bits_unchecked(0xb8) };\n+        let extra = Flags::from_bits_retain(0xb8);\n \n-        assert_eq!(format!(\"{:?}\", extra), \"0xb8\");\n-        assert_eq!(format!(\"{:?}\", Flags::A | extra), \"A | 0xb8\");\n+        assert_eq!(format!(\"{:?}\", extra), \"Flags(0xb8)\");\n+        assert_eq!(format!(\"{:?}\", Flags::A | extra), \"Flags(A | 0xb8)\");\n \n         assert_eq!(\n             format!(\"{:?}\", Flags::ABC | extra),\n-            \"A | B | C | ABC | 0xb8\"\n+            \"Flags(A | B | C | ABC | 0xb8)\"\n         );\n \n-        assert_eq!(format!(\"{:?}\", EmptyFlags::empty()), \"(empty)\");\n+        assert_eq!(format!(\"{:?}\", EmptyFlags::empty()), \"EmptyFlags(empty)\");\n     }\n \n     #[test]\n     fn test_binary() {\n         assert_eq!(format!(\"{:b}\", Flags::ABC), \"111\");\n         assert_eq!(format!(\"{:#b}\", Flags::ABC), \"0b111\");\n-        let extra = unsafe { Flags::from_bits_unchecked(0b1010000) };\n+        let extra = Flags::from_bits_retain(0b1010000);\n         assert_eq!(format!(\"{:b}\", Flags::ABC | extra), \"1010111\");\n         assert_eq!(format!(\"{:#b}\", Flags::ABC | extra), \"0b1010111\");\n     }\n@@ -1607,7 +1808,7 @@ mod tests {\n     fn test_octal() {\n         assert_eq!(format!(\"{:o}\", LongFlags::LONG_A), \"177777\");\n         assert_eq!(format!(\"{:#o}\", LongFlags::LONG_A), \"0o177777\");\n-        let extra = unsafe { LongFlags::from_bits_unchecked(0o5000000) };\n+        let extra = LongFlags::from_bits_retain(0o5000000);\n         assert_eq!(format!(\"{:o}\", LongFlags::LONG_A | extra), \"5177777\");\n         assert_eq!(format!(\"{:#o}\", LongFlags::LONG_A | extra), \"0o5177777\");\n     }\n@@ -1616,7 +1817,7 @@ mod tests {\n     fn test_lowerhex() {\n         assert_eq!(format!(\"{:x}\", LongFlags::LONG_A), \"ffff\");\n         assert_eq!(format!(\"{:#x}\", LongFlags::LONG_A), \"0xffff\");\n-        let extra = unsafe { LongFlags::from_bits_unchecked(0xe00000) };\n+        let extra = LongFlags::from_bits_retain(0xe00000);\n         assert_eq!(format!(\"{:x}\", LongFlags::LONG_A | extra), \"e0ffff\");\n         assert_eq!(format!(\"{:#x}\", LongFlags::LONG_A | extra), \"0xe0ffff\");\n     }\n@@ -1625,17 +1826,19 @@ mod tests {\n     fn test_upperhex() {\n         assert_eq!(format!(\"{:X}\", LongFlags::LONG_A), \"FFFF\");\n         assert_eq!(format!(\"{:#X}\", LongFlags::LONG_A), \"0xFFFF\");\n-        let extra = unsafe { LongFlags::from_bits_unchecked(0xe00000) };\n+        let extra = LongFlags::from_bits_retain(0xe00000);\n         assert_eq!(format!(\"{:X}\", LongFlags::LONG_A | extra), \"E0FFFF\");\n         assert_eq!(format!(\"{:#X}\", LongFlags::LONG_A | extra), \"0xE0FFFF\");\n     }\n \n     mod submodule {\n         bitflags! {\n+            #[derive(Clone, Copy)]\n             pub struct PublicFlags: i8 {\n                 const X = 0;\n             }\n \n+            #[derive(Clone, Copy)]\n             struct PrivateFlags: i8 {\n                 const Y = 0;\n             }\n@@ -1659,6 +1862,7 @@ mod tests {\n \n         bitflags! {\n             /// baz\n+            #[derive(Clone, Copy)]\n             struct Flags: foo::Bar {\n                 const A = 0b00000001;\n                 #[cfg(foo)]\n@@ -1672,19 +1876,21 @@ mod tests {\n     #[test]\n     fn test_in_function() {\n         bitflags! {\n-           struct Flags: u8 {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+            struct Flags: u8 {\n                 const A = 1;\n                 #[cfg(any())] // false\n                 const B = 2;\n             }\n         }\n         assert_eq!(Flags::all(), Flags::A);\n-        assert_eq!(format!(\"{:?}\", Flags::A), \"A\");\n+        assert_eq!(format!(\"{:?}\", Flags::A), \"Flags(A)\");\n     }\n \n     #[test]\n     fn test_deprecated() {\n         bitflags! {\n+            #[derive(Clone, Copy)]\n             pub struct TestFlags: u32 {\n                 #[deprecated(note = \"Use something else.\")]\n                 const ONE = 1;\n@@ -1696,6 +1902,7 @@ mod tests {\n     fn test_pub_crate() {\n         mod module {\n             bitflags! {\n+                #[derive(Clone, Copy)]\n                 pub (crate) struct Test: u8 {\n                     const FOO = 1;\n                 }\n@@ -1712,6 +1919,7 @@ mod tests {\n                 bitflags! {\n                     // `pub (in super)` means only the module `module` will\n                     // be able to access this.\n+                    #[derive(Clone, Copy)]\n                     pub (in super) struct Test: u8 {\n                         const FOO = 1;\n                     }\n@@ -1737,6 +1945,7 @@ mod tests {\n     #[test]\n     fn test_zero_value_flags() {\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Flags: u32 {\n                 const NONE = 0b0;\n                 const SOME = 0b1;\n@@ -1747,8 +1956,8 @@ mod tests {\n         assert!(Flags::SOME.contains(Flags::NONE));\n         assert!(Flags::NONE.is_empty());\n \n-        assert_eq!(format!(\"{:?}\", Flags::empty()), \"(empty)\");\n-        assert_eq!(format!(\"{:?}\", Flags::SOME), \"NONE | SOME\");\n+        assert_eq!(format!(\"{:?}\", Flags::empty()), \"Flags(empty)\");\n+        assert_eq!(format!(\"{:?}\", Flags::SOME), \"Flags(NONE | SOME)\");\n     }\n \n     #[test]\n@@ -1759,69 +1968,33 @@ mod tests {\n     #[test]\n     fn test_u128_bitflags() {\n         bitflags! {\n-            struct Flags128: u128 {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+            struct Flags: u128 {\n                 const A = 0x0000_0000_0000_0000_0000_0000_0000_0001;\n                 const B = 0x0000_0000_0000_1000_0000_0000_0000_0000;\n                 const C = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n-                const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\n+                const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n             }\n         }\n \n-        assert_eq!(Flags128::ABC, Flags128::A | Flags128::B | Flags128::C);\n-        assert_eq!(Flags128::A.bits, 0x0000_0000_0000_0000_0000_0000_0000_0001);\n-        assert_eq!(Flags128::B.bits, 0x0000_0000_0000_1000_0000_0000_0000_0000);\n-        assert_eq!(Flags128::C.bits, 0x8000_0000_0000_0000_0000_0000_0000_0000);\n+        assert_eq!(Flags::ABC, Flags::A | Flags::B | Flags::C);\n+        assert_eq!(Flags::A.bits(), 0x0000_0000_0000_0000_0000_0000_0000_0001);\n+        assert_eq!(Flags::B.bits(), 0x0000_0000_0000_1000_0000_0000_0000_0000);\n+        assert_eq!(Flags::C.bits(), 0x8000_0000_0000_0000_0000_0000_0000_0000);\n         assert_eq!(\n-            Flags128::ABC.bits,\n+            Flags::ABC.bits(),\n             0x8000_0000_0000_1000_0000_0000_0000_0001\n         );\n-        assert_eq!(format!(\"{:?}\", Flags128::A), \"A\");\n-        assert_eq!(format!(\"{:?}\", Flags128::B), \"B\");\n-        assert_eq!(format!(\"{:?}\", Flags128::C), \"C\");\n-        assert_eq!(format!(\"{:?}\", Flags128::ABC), \"A | B | C\");\n-    }\n-\n-    #[test]\n-    fn test_serde_bitflags_serialize() {\n-        let flags = SerdeFlags::A | SerdeFlags::B;\n-\n-        let serialized = serde_json::to_string(&flags).unwrap();\n-\n-        assert_eq!(serialized, r#\"{\"bits\":3}\"#);\n-    }\n-\n-    #[test]\n-    fn test_serde_bitflags_deserialize() {\n-        let deserialized: SerdeFlags = serde_json::from_str(r#\"{\"bits\":12}\"#).unwrap();\n-\n-        let expected = SerdeFlags::C | SerdeFlags::D;\n-\n-        assert_eq!(deserialized.bits, expected.bits);\n-    }\n-\n-    #[test]\n-    fn test_serde_bitflags_roundtrip() {\n-        let flags = SerdeFlags::A | SerdeFlags::B;\n-\n-        let deserialized: SerdeFlags =\n-            serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n-\n-        assert_eq!(deserialized.bits, flags.bits);\n-    }\n-\n-    bitflags! {\n-        #[derive(serde_derive::Serialize, serde_derive::Deserialize)]\n-        struct SerdeFlags: u32 {\n-            const A = 1;\n-            const B = 2;\n-            const C = 4;\n-            const D = 8;\n-        }\n+        assert_eq!(format!(\"{:?}\", Flags::A), \"Flags(A)\");\n+        assert_eq!(format!(\"{:?}\", Flags::B), \"Flags(B)\");\n+        assert_eq!(format!(\"{:?}\", Flags::C), \"Flags(C)\");\n+        assert_eq!(format!(\"{:?}\", Flags::ABC), \"Flags(A | B | C)\");\n     }\n \n     #[test]\n     fn test_from_bits_edge_cases() {\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Flags: u8 {\n                 const A = 0b00000001;\n                 const BC = 0b00000110;\n@@ -1837,6 +2010,7 @@ mod tests {\n     #[test]\n     fn test_from_bits_truncate_edge_cases() {\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Flags: u8 {\n                 const A = 0b00000001;\n                 const BC = 0b00000110;\n@@ -1852,6 +2026,7 @@ mod tests {\n     #[test]\n     fn test_iter() {\n         bitflags! {\n+            #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n             struct Flags: u32 {\n                 const ONE  = 0b001;\n                 const TWO  = 0b010;\ndiff --git a/src/serde_support.rs b/src/serde_support.rs\nnew file mode 100644\nindex 00000000..41cf1128\n--- /dev/null\n+++ b/src/serde_support.rs\n@@ -0,0 +1,84 @@\n+use core::fmt;\n+use serde::{Serializer, Deserializer, Serialize, Deserialize, ser::SerializeStruct, de::{Error, MapAccess, Visitor}};\n+\n+// These methods are compatible with the result of `#[derive(Serialize, Deserialize)]` on bitflags `1.0` types\n+\n+pub fn serialize_bits_default<B: Serialize, S: Serializer>(name: &'static str, bits: &B, serializer: S) -> Result<S::Ok, S::Error> {\n+    let mut serialize_struct = serializer.serialize_struct(name, 1)?;\n+    serialize_struct.serialize_field(\"bits\", bits)?;\n+    serialize_struct.end()\n+}\n+\n+pub fn deserialize_bits_default<'de, B: Deserialize<'de>, D: Deserializer<'de>>(name: &'static str, deserializer: D) -> Result<B, D::Error> {\n+    struct BitsVisitor<T>(core::marker::PhantomData<T>);\n+\n+    impl<'de, T: Deserialize<'de>> Visitor<'de> for BitsVisitor<T> {\n+        type Value = T;\n+\n+        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+            formatter.write_str(\"a primitive bitflags value wrapped in a struct\")\n+        }\n+\n+        fn visit_map<A: MapAccess<'de>>(self, mut map: A) -> Result<Self::Value, A::Error> {\n+            let mut bits = None;\n+\n+            while let Some(key) = map.next_key()? {\n+                match key {\n+                    \"bits\" => {\n+                        if bits.is_some() {\n+                            return Err(Error::duplicate_field(\"bits\"));\n+                        }\n+\n+                        bits = Some(map.next_value()?);\n+                    }\n+                    v => return Err(Error::unknown_field(v, &[\"bits\"]))\n+                }\n+            }\n+\n+            bits.ok_or_else(|| Error::missing_field(\"bits\"))\n+        }\n+    }\n+\n+    deserializer.deserialize_struct(name, &[\"bits\"], BitsVisitor(Default::default()))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    bitflags! {\n+        #[derive(serde_derive::Serialize, serde_derive::Deserialize)]\n+        struct SerdeFlags: u32 {\n+            const A = 1;\n+            const B = 2;\n+            const C = 4;\n+            const D = 8;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_serde_bitflags_default_serialize() {\n+        let flags = SerdeFlags::A | SerdeFlags::B;\n+\n+        let serialized = serde_json::to_string(&flags).unwrap();\n+\n+        assert_eq!(serialized, r#\"{\"bits\":3}\"#);\n+    }\n+\n+    #[test]\n+    fn test_serde_bitflags_default_deserialize() {\n+        let deserialized: SerdeFlags = serde_json::from_str(r#\"{\"bits\":12}\"#).unwrap();\n+\n+        let expected = SerdeFlags::C | SerdeFlags::D;\n+\n+        assert_eq!(deserialized.bits(), expected.bits());\n+    }\n+\n+    #[test]\n+    fn test_serde_bitflags_default_roundtrip() {\n+        let flags = SerdeFlags::A | SerdeFlags::B;\n+\n+        let deserialized: SerdeFlags =\n+            serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n+\n+        assert_eq!(deserialized.bits(), flags.bits());\n+    }\n+}\n\\ No newline at end of file\n", "test_patch": "diff --git a/tests/basic.rs b/tests/basic.rs\nindex 73a52bec..790ec41c 100644\n--- a/tests/basic.rs\n+++ b/tests/basic.rs\n@@ -4,13 +4,14 @@ use bitflags::bitflags;\n \n bitflags! {\n     /// baz\n+    #[derive(Debug, PartialEq, Eq)]\n     struct Flags: u32 {\n         const A = 0b00000001;\n         #[doc = \"bar\"]\n         const B = 0b00000010;\n         const C = 0b00000100;\n         #[doc = \"foo\"]\n-        const ABC = Flags::A.bits | Flags::B.bits | Flags::C.bits;\n+        const ABC = Flags::A.bits() | Flags::B.bits() | Flags::C.bits();\n     }\n }\n \ndiff --git a/tests/compile-fail/impls/copy.stderr b/tests/compile-fail/impls/copy.stderr\ndeleted file mode 100644\nindex 966f3c9a..00000000\n--- a/tests/compile-fail/impls/copy.stderr\n+++ /dev/null\n@@ -1,27 +0,0 @@\n-error[E0119]: conflicting implementations of trait `std::marker::Copy` for type `Flags`\n- --> $DIR/copy.rs:3:1\n-  |\n-3 | / bitflags! {\n-4 | |     #[derive(Clone, Copy)]\n-  | |                     ---- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0119]: conflicting implementations of trait `std::clone::Clone` for type `Flags`\n- --> $DIR/copy.rs:3:1\n-  |\n-3 | / bitflags! {\n-4 | |     #[derive(Clone, Copy)]\n-  | |              ----- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a/tests/compile-fail/impls/eq.stderr b/tests/compile-fail/impls/eq.stderr\ndeleted file mode 100644\nindex cb1d6a08..00000000\n--- a/tests/compile-fail/impls/eq.stderr\n+++ /dev/null\n@@ -1,55 +0,0 @@\n-error[E0119]: conflicting implementations of trait `std::marker::StructuralPartialEq` for type `Flags`\n- --> $DIR/eq.rs:3:1\n-  |\n-3 | / bitflags! {\n-4 | |     #[derive(PartialEq, Eq)]\n-  | |              --------- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0119]: conflicting implementations of trait `std::cmp::PartialEq` for type `Flags`\n- --> $DIR/eq.rs:3:1\n-  |\n-3 | / bitflags! {\n-4 | |     #[derive(PartialEq, Eq)]\n-  | |              --------- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0119]: conflicting implementations of trait `std::marker::StructuralEq` for type `Flags`\n- --> $DIR/eq.rs:3:1\n-  |\n-3 | / bitflags! {\n-4 | |     #[derive(PartialEq, Eq)]\n-  | |                         -- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `Eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0119]: conflicting implementations of trait `std::cmp::Eq` for type `Flags`\n- --> $DIR/eq.rs:3:1\n-  |\n-3 | / bitflags! {\n-4 | |     #[derive(PartialEq, Eq)]\n-  | |                         -- first implementation here\n-5 | |     struct Flags: u32 {\n-6 | |         const A = 0b00000001;\n-7 | |     }\n-8 | | }\n-  | |_^ conflicting implementation for `Flags`\n-  |\n-  = note: this error originates in the derive macro `Eq` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\nindex 69d89dc5..e477281c 100644\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -4,6 +4,16 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 116 |     struct Flags128: MyInt {\n     |                      ^^^^^ the trait `Bits` is not implemented for `MyInt`\n     |\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n note: required by a bound in `bitflags::BitFlags::Bits`\n    --> src/bitflags_trait.rs\n     |\n@@ -22,7 +32,17 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 121 | | }\n     | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n@@ -36,7 +56,17 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 121 | | }\n     | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n@@ -50,7 +80,69 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 121 | | }\n     | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n@@ -64,4 +156,142 @@ error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n 121 | | }\n     | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n+    |\n+    = help: the following other types implement trait `Bits`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              u128\n+              u16\n+              u32\n+            and 2 others\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a/tests/compile-fail/non_integer_base/all_missing.stderr b/tests/compile-fail/non_integer_base/all_missing.stderr\nindex ee95f836..7f047c68 100644\n--- a/tests/compile-fail/non_integer_base/all_missing.stderr\n+++ b/tests/compile-fail/non_integer_base/all_missing.stderr\n@@ -1,5 +1,5 @@\n error[E0204]: the trait `Copy` may not be implemented for this type\n-  --> $DIR/all_missing.rs:5:1\n+  --> tests/compile-fail/non_integer_base/all_missing.rs:5:1\n    |\n 5  | / bitflags! {\n 6  | |     struct Flags128: MyInt {\n@@ -10,4 +10,4 @@ error[E0204]: the trait `Copy` may not be implemented for this type\n 11 | | }\n    | |_^ this field does not implement `Copy`\n    |\n-   = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the derive macro `Copy` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a/tests/compile-fail/redefined.rs b/tests/compile-fail/redefined.rs\nnew file mode 100644\nindex 00000000..6d194d6c\n--- /dev/null\n+++ b/tests/compile-fail/redefined.rs\n@@ -0,0 +1,14 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags1 {\n+        const A = 1;\n+    }\n+}\n+\n+bitflags! {\n+    pub struct Flags1 {\n+        const A = 1;\n+    }\n+}\ndiff --git a/tests/compile-fail/redefined.stderr b/tests/compile-fail/redefined.stderr\nnew file mode 100644\nindex 00000000..85bc7f10\n--- /dev/null\n+++ b/tests/compile-fail/redefined.stderr\n@@ -0,0 +1,17 @@\n+error: no rules expected the token `{`\n+ --> tests/compile-fail/redefined.rs:5:23\n+  |\n+5 |     pub struct Flags1 {\n+  |                       ^ no rules expected this token in macro call\n+\n+error: no rules expected the token `{`\n+  --> tests/compile-fail/redefined.rs:11:23\n+   |\n+11 |     pub struct Flags1 {\n+   |                       ^ no rules expected this token in macro call\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+  --> tests/compile-fail/redefined.rs:14:2\n+   |\n+14 | }\n+   |  ^ consider adding a `main` function to `$DIR/tests/compile-fail/redefined.rs`\ndiff --git a/tests/compile-fail/syntax/missing_type.rs b/tests/compile-fail/syntax/missing_type.rs\nnew file mode 100644\nindex 00000000..323b8583\n--- /dev/null\n+++ b/tests/compile-fail/syntax/missing_type.rs\n@@ -0,0 +1,8 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags1 {\n+        const A = 1;\n+    }\n+}\ndiff --git a/tests/compile-fail/syntax/missing_type.stderr b/tests/compile-fail/syntax/missing_type.stderr\nnew file mode 100644\nindex 00000000..ed8c8ac4\n--- /dev/null\n+++ b/tests/compile-fail/syntax/missing_type.stderr\n@@ -0,0 +1,11 @@\n+error: no rules expected the token `{`\n+ --> tests/compile-fail/syntax/missing_type.rs:5:23\n+  |\n+5 |     pub struct Flags1 {\n+  |                       ^ no rules expected this token in macro call\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+ --> tests/compile-fail/syntax/missing_type.rs:8:2\n+  |\n+8 | }\n+  |  ^ consider adding a `main` function to `$DIR/tests/compile-fail/syntax/missing_type.rs`\ndiff --git a/tests/compile-fail/syntax/missing_value.rs b/tests/compile-fail/syntax/missing_value.rs\nnew file mode 100644\nindex 00000000..c1221035\n--- /dev/null\n+++ b/tests/compile-fail/syntax/missing_value.rs\n@@ -0,0 +1,8 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags1 {\n+        const A;\n+    }\n+}\ndiff --git a/tests/compile-fail/syntax/missing_value.stderr b/tests/compile-fail/syntax/missing_value.stderr\nnew file mode 100644\nindex 00000000..6b1b46a1\n--- /dev/null\n+++ b/tests/compile-fail/syntax/missing_value.stderr\n@@ -0,0 +1,11 @@\n+error: no rules expected the token `{`\n+ --> tests/compile-fail/syntax/missing_value.rs:5:23\n+  |\n+5 |     pub struct Flags1 {\n+  |                       ^ no rules expected this token in macro call\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+ --> tests/compile-fail/syntax/missing_value.rs:8:2\n+  |\n+8 | }\n+  |  ^ consider adding a `main` function to `$DIR/tests/compile-fail/syntax/missing_value.rs`\ndiff --git a/tests/compile-fail/trait/custom_impl.rs b/tests/compile-fail/trait/custom_impl.rs\nindex 80be2f91..55dd929d 100644\n--- a/tests/compile-fail/trait/custom_impl.rs\n+++ b/tests/compile-fail/trait/custom_impl.rs\n@@ -25,7 +25,7 @@ impl BitFlags for BootlegFlags {\n         unimplemented!()\n     }\n \n-    unsafe fn from_bits_unchecked(_: u32) -> BootlegFlags {\n+    fn from_bits_retain(_: u32) -> BootlegFlags {\n         unimplemented!()\n     }\n \ndiff --git a/tests/compile-fail/visibility/private_field.rs b/tests/compile-fail/visibility/private_field.rs\ndeleted file mode 100644\nindex a6a3912a..00000000\n--- a/tests/compile-fail/visibility/private_field.rs\n+++ /dev/null\n@@ -1,13 +0,0 @@\n-mod example {\n-    use bitflags::bitflags;\n-\n-    bitflags! {\n-        pub struct Flags1: u32 {\n-            const FLAG_A = 0b00000001;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let flag1 = example::Flags1::FLAG_A.bits;\n-}\ndiff --git a/tests/compile-fail/visibility/private_field.stderr b/tests/compile-fail/visibility/private_field.stderr\ndeleted file mode 100644\nindex e1146989..00000000\n--- a/tests/compile-fail/visibility/private_field.stderr\n+++ /dev/null\n@@ -1,10 +0,0 @@\n-error[E0616]: field `bits` of struct `Flags1` is private\n-  --> $DIR/private_field.rs:12:41\n-   |\n-12 |     let flag1 = example::Flags1::FLAG_A.bits;\n-   |                                         ^^^^ private field\n-   |\n-help: a method `bits` also exists, call it with parentheses\n-   |\n-12 |     let flag1 = example::Flags1::FLAG_A.bits();\n-   |                                             ++\ndiff --git a/tests/compile-fail/visibility/private_flags.rs b/tests/compile-fail/visibility/private_flags.rs\nindex 85a5b186..a132d2f9 100644\n--- a/tests/compile-fail/visibility/private_flags.rs\n+++ b/tests/compile-fail/visibility/private_flags.rs\n@@ -13,6 +13,6 @@ mod example {\n }\n \n fn main() {\n-    let flag1 = example::Flags1::FLAG_A;\n-    let flag2 = example::Flags2::FLAG_B;\n+    let _ = example::Flags1::FLAG_A;\n+    let _ = example::Flags2::FLAG_B;\n }\ndiff --git a/tests/compile-fail/visibility/private_flags.stderr b/tests/compile-fail/visibility/private_flags.stderr\nindex d23f8320..47a53c25 100644\n--- a/tests/compile-fail/visibility/private_flags.stderr\n+++ b/tests/compile-fail/visibility/private_flags.stderr\n@@ -1,11 +1,11 @@\n error[E0603]: struct `Flags2` is private\n-  --> $DIR/private_flags.rs:17:26\n+  --> tests/compile-fail/visibility/private_flags.rs:17:22\n    |\n-17 |     let flag2 = example::Flags2::FLAG_B;\n-   |                          ^^^^^^ private struct\n+17 |     let _ = example::Flags2::FLAG_B;\n+   |                      ^^^^^^ private struct\n    |\n note: the struct `Flags2` is defined here\n-  --> $DIR/private_flags.rs:4:5\n+  --> tests/compile-fail/visibility/private_flags.rs:4:5\n    |\n 4  | /     bitflags! {\n 5  | |         pub struct Flags1: u32 {\ndiff --git a/tests/compile-fail/impls/copy.rs b/tests/compile-pass/impls/copy.rs\nsimilarity index 100%\nrename from tests/compile-fail/impls/copy.rs\nrename to tests/compile-pass/impls/copy.rs\ndiff --git a/tests/compile-fail/impls/eq.rs b/tests/compile-pass/impls/eq.rs\nsimilarity index 100%\nrename from tests/compile-fail/impls/eq.rs\nrename to tests/compile-pass/impls/eq.rs\ndiff --git a/tests/compile-pass/impls/fmt.rs b/tests/compile-pass/impls/fmt.rs\nindex 567fd448..93dbf1b1 100644\n--- a/tests/compile-pass/impls/fmt.rs\n+++ b/tests/compile-pass/impls/fmt.rs\n@@ -1,6 +1,7 @@\n use bitflags::bitflags;\n \n bitflags! {\n+    #[derive(Debug)]\n     struct Flags: u8 {\n         const TWO = 0x2;\n     }\n@@ -8,7 +9,7 @@ bitflags! {\n \n fn main() {\n     // bug #267 (https://github.com/bitflags/bitflags/issues/267)\n-    let flags = unsafe { Flags::from_bits_unchecked(0b11) };\n-    assert_eq!(format!(\"{:?}\", flags), \"TWO | 0x1\");\n-    assert_eq!(format!(\"{:#?}\", flags), \"TWO | 0x1\");\n+    let flags = Flags::from_bits_retain(0b11);\n+    assert_eq!(format!(\"{:?}\", flags), \"Flags(TWO | 0x1)\");\n+    assert_eq!(format!(\"{:#?}\", flags), \"Flags(\\n    TWO | 0x1,\\n)\");\n }\ndiff --git a/tests/compile-pass/item_positions.rs b/tests/compile-pass/item_positions.rs\nnew file mode 100644\nindex 00000000..def7bbe3\n--- /dev/null\n+++ b/tests/compile-pass/item_positions.rs\n@@ -0,0 +1,52 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags1: u32 {\n+        const A = 1;\n+    }\n+}\n+\n+bitflags! {\n+    pub struct Flags2: u32 {\n+        const A = 1;\n+    }\n+}\n+\n+pub mod nested {\n+    bitflags! {\n+        pub struct Flags1: u32 {\n+            const A = 1;\n+        }\n+    }\n+\n+    bitflags! {\n+        pub struct Flags2: u32 {\n+            const A = 1;\n+        }\n+    }\n+}\n+\n+pub const _: () = {\n+    bitflags! {\n+        pub struct Flags1: u32 {\n+            const A = 1;\n+        }\n+    }\n+};\n+\n+fn main() {\n+    bitflags! {\n+        pub struct Flags1: u32 {\n+            const A = 1;\n+        }\n+    }\n+\n+    let _ = {\n+        bitflags! {\n+            pub struct Flags2: u32 {\n+                const A = 1;\n+            }\n+        }\n+    };\n+}\ndiff --git a/tests/compile-pass/no_prelude.rs b/tests/compile-pass/no_prelude.rs\nindex c54b7a31..b1c57dac 100644\n--- a/tests/compile-pass/no_prelude.rs\n+++ b/tests/compile-pass/no_prelude.rs\n@@ -7,7 +7,7 @@ bitflags::bitflags! {\n         const A = 0b00000001;\n         const B = 0b00000010;\n         const C = 0b00000100;\n-        const ABC = Flags::A.bits | Flags::B.bits | Flags::C.bits;\n+        const ABC = Flags::A.bits() | Flags::B.bits() | Flags::C.bits();\n     }\n }\n \ndiff --git a/tests/compile-pass/redefinition/macros.rs b/tests/compile-pass/redefinition/macros.rs\nindex a9835124..cfff19ab 100644\n--- a/tests/compile-pass/redefinition/macros.rs\n+++ b/tests/compile-pass/redefinition/macros.rs\n@@ -13,6 +13,7 @@ macro_rules! write {\n }\n \n bitflags! {\n+    #[derive(Debug)]\n     struct Test: u8 {\n         const A = 1;\n     }\n@@ -20,5 +21,5 @@ bitflags! {\n \n fn main() {\n     // Just make sure we don't call the redefined `stringify` or `write` macro\n-    assert_eq!(format!(\"{:?}\", unsafe { Test::from_bits_unchecked(0b11) }), \"A | 0x2\");\n+    assert_eq!(format!(\"{:?}\", Test::from_bits_retain(0b11)), \"Test(A | 0x2)\");\n }\ndiff --git a/tests/compile-pass/visibility/bits_field.rs b/tests/compile-pass/visibility/bits_field.rs\nindex 33a7967e..5b0c6e43 100644\n--- a/tests/compile-pass/visibility/bits_field.rs\n+++ b/tests/compile-pass/visibility/bits_field.rs\n@@ -7,5 +7,5 @@ bitflags! {\n }\n \n fn main() {\n-    assert_eq!(0b00000001, Flags1::FLAG_A.bits);\n+    assert_eq!(0b00000001, Flags1::FLAG_A.bits());\n }\ndiff --git a/tests/smoke-test/Cargo.toml b/tests/smoke-test/Cargo.toml\nnew file mode 100644\nindex 00000000..f7265667\n--- /dev/null\n+++ b/tests/smoke-test/Cargo.toml\n@@ -0,0 +1,8 @@\n+[package]\n+name = \"bitflags-smoke-test\"\n+version = \"0.0.0\"\n+edition = \"2021\"\n+publish = false\n+\n+[dependencies.bitflags]\n+path = \"../../\"\ndiff --git a/tests/smoke-test/src/main.rs b/tests/smoke-test/src/main.rs\nnew file mode 100644\nindex 00000000..9ff4305d\n--- /dev/null\n+++ b/tests/smoke-test/src/main.rs\n@@ -0,0 +1,15 @@\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    #[derive(Debug)]\n+    pub struct Flags: u32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+        const ABC = Flags::A.bits() | Flags::B.bits() | Flags::C.bits();\n+    }\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", Flags::ABC);\n+}\n", "problem_statement": "Add an option for checking for valid bits is in the getter rather than constructor\nHi, I want to use bitflags for generated code that interacts with data in other languages, some of which are bitflags (https://github.com/google/flatbuffers/pull/6098). I don't want to drop data so I'd like to use `from_bits_unchecked`. However, it is marked as unsafe. I'd like to submit a PR to add an option to get around this. I have two ideas:\r\n\r\n1) Move the valid-bits-check to the getter: There'll be only one constructor: `from_bits` and the `bits()` getter becomes `bits() -> Result<...>`, `unsafe bits_unchecked()`, and `bits_truncated()`\r\n\r\n2) #200 documents that this crate uses `unsafe` to mean a usage issue rather than a memory issue, so maybe I could make an option to remove the unsafe altogether, and update the generated documentation appropriately?\r\n\r\nWhat are your thoughts on these ideas? Does bitflags depend on the \"bits are truncated to defined flags\" invariant?\n", "hints_text": "Related: #188, #200, #207, #208, #211\n@niklasf @KodrAus worked on #200 \nBump!\r\n\r\nI'll do the PR if needed\nHi @CasperN! :wave:\r\n\r\nWe can't consider any changes to the `bits()` method, because the library is already stable.\r\n\r\nThe way we modeled this originally was that the flags represents a closed enum, where the set specified in the definition is the complete set of possible flags the enum could combine. Since not all valid bit patterns of the underlying integer type are valid bit patterns of the flags it's not safe for us to simply accept any integer and treat it as valid flags. So we made the `unchecked` method unsafe.\r\n\r\nIf we wanted to clean up the semantics we could consider allowing an `#[open]` attribute or something on the `bitflags!` definition itself, so you'd declare an open bitflags that could happily accept any integer, assuming it's not the source-of-truth for what flags exist:\r\n\r\n```rust\r\nbitflags! {\r\n    #[open]\r\n    struct Flags: u32 {\r\n        const A = 0b00000001;\r\n        const B = 0b00000010;\r\n    }\r\n}\r\n```\r\n\r\nThen let these `#[open]` bitflags have `#[repr(transparent)]` and so can be soundly transmuted to and from the given integer type, making `from_bits_unchecked` safe.\r\n\r\nWhat do you think?\nWe could also use `#[repr(transparent)]` for this. I don\u2019t think that\u2019s too much of a semantic hijacking, so long as it also does apply the attribute.", "created_at": "2022-05-25T04:14:38Z", "version": "1.3", "FAIL_TO_PASS": [], "PASS_TO_PASS": [], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
{"repo": "bitflags/bitflags", "pull_number": 281, "instance_id": "bitflags__bitflags-281", "issue_numbers": ["215"], "base_commit": "f38ce72d11ef3e264d4b62f360bd8a5597b916d9", "patch": "diff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs\nindex 0ffee465..440d5274 100644\n--- a/src/bitflags_trait.rs\n+++ b/src/bitflags_trait.rs\n@@ -1,3 +1,5 @@\n+use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};\n+\n #[doc(hidden)]\n pub trait ImplementedByBitFlagsMacro {}\n \n@@ -5,7 +7,8 @@ pub trait ImplementedByBitFlagsMacro {}\n ///\n /// It should not be implemented manually.\n pub trait BitFlags: ImplementedByBitFlagsMacro {\n-    type Bits;\n+    type Bits: Bits;\n+\n     /// Returns an empty set of flags.\n     fn empty() -> Self;\n     /// Returns the set containing all flags.\n@@ -15,7 +18,8 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     /// Convert from underlying bit representation, unless that\n     /// representation contains bits that do not correspond to a flag.\n     fn from_bits(bits: Self::Bits) -> Option<Self>\n-    where Self: Sized;\n+    where\n+        Self: Sized;\n     /// Convert from underlying bit representation, dropping any bits\n     /// that do not correspond to flags.\n     fn from_bits_truncate(bits: Self::Bits) -> Self;\n@@ -48,3 +52,58 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     /// Inserts or removes the specified flags depending on the passed value.\n     fn set(&mut self, other: Self, value: bool);\n }\n+\n+// Not re-exported\n+pub trait Sealed {}\n+\n+/// A private trait that encodes the requirements of underlying bits types that can hold flags.\n+///\n+/// This trait may be made public at some future point, but it presents a compatibility hazard\n+/// so is left internal for now.\n+#[doc(hidden)]\n+pub trait Bits:\n+    Clone\n+    + Copy\n+    + BitAnd\n+    + BitAndAssign\n+    + BitOr\n+    + BitOrAssign\n+    + BitXor\n+    + BitXorAssign\n+    + Not\n+    + Sized\n+    + Sealed\n+{\n+    /// The value of `Self` where no bits are set.\n+    const EMPTY: Self;\n+\n+    /// The value of `Self` where all bits are set.\n+    const ALL: Self;\n+}\n+\n+macro_rules! impl_bits {\n+    ($($u:ty, $i:ty,)*) => {\n+        $(\n+            impl Bits for $u {\n+                const EMPTY: $u = 0;\n+                const ALL: $u = <$u>::MAX;\n+            }\n+\n+            impl Bits for $i {\n+                const EMPTY: $i = 0;\n+                const ALL: $i = <$u>::MAX as $i;\n+            }\n+\n+            impl Sealed for $u {}\n+            impl Sealed for $i {}\n+        )*\n+    }\n+}\n+\n+impl_bits! {\n+    u8, i8,\n+    u16, i16,\n+    u32, i32,\n+    u64, i64,\n+    u128, i128,\n+}\ndiff --git a/src/lib.rs b/src/lib.rs\nindex a2d3193b..979ff918 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -285,8 +285,8 @@ mod bitflags_trait;\n \n #[doc(hidden)]\n pub mod __private {\n+    pub use crate::bitflags_trait::{Bits, ImplementedByBitFlagsMacro};\n     pub use core;\n-    pub use crate::bitflags_trait::ImplementedByBitFlagsMacro;\n }\n \n /// The macro used to generate the flag structure.\n@@ -389,45 +389,6 @@ macro_rules! bitflags {\n     () => {};\n }\n \n-// A helper macro to implement the `all` function.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-macro_rules! __impl_all_bitflags {\n-    (\n-        $BitFlags:ident: $T:ty {\n-            $(\n-                $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident = $value:expr;\n-            )+\n-        }\n-    ) => {\n-        // See `Debug::fmt` for why this approach is taken.\n-        #[allow(non_snake_case)]\n-        trait __BitFlags {\n-            $(\n-                #[allow(deprecated)]\n-                const $Flag: $T = 0;\n-            )+\n-        }\n-        #[allow(non_snake_case)]\n-        impl __BitFlags for $BitFlags {\n-            $(\n-                __impl_bitflags! {\n-                    #[allow(deprecated)]\n-                    $(? #[$attr $($args)*])*\n-                    const $Flag: $T = Self::$Flag.bits;\n-                }\n-            )+\n-        }\n-        Self { bits: $(<Self as __BitFlags>::$Flag)|+ }\n-    };\n-    (\n-        $BitFlags:ident: $T:ty { }\n-    ) => {\n-        Self { bits: 0 }\n-    };\n-}\n-\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n macro_rules! __impl_bitflags {\n@@ -455,7 +416,7 @@ macro_rules! __impl_bitflags {\n                 // Append any extra bits that correspond to flags to the end of the format\n                 let extra_bits = self.bits & !Self::all().bits();\n \n-                if extra_bits != 0 {\n+                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n                     if !first {\n                         f.write_str(\" | \")?;\n                     }\n@@ -495,7 +456,14 @@ macro_rules! __impl_bitflags {\n             }\n         }\n \n-        #[allow(dead_code)]\n+        #[allow(\n+            dead_code,\n+            deprecated,\n+            unused_doc_comments,\n+            unused_attributes,\n+            unused_mut,\n+            non_upper_case_globals\n+        )]\n         impl $BitFlags {\n             $(\n                 $(#[$attr $($args)*])*\n@@ -505,20 +473,13 @@ macro_rules! __impl_bitflags {\n             /// Returns an empty set of flags.\n             #[inline]\n             pub const fn empty() -> Self {\n-                Self { bits: 0 }\n+                Self { bits: <$T as $crate::__private::Bits>::EMPTY }\n             }\n \n             /// Returns the set containing all flags.\n             #[inline]\n             pub const fn all() -> Self {\n-                __impl_all_bitflags! {\n-                    $BitFlags: $T {\n-                        $(\n-                            $(#[$attr $($args)*])*\n-                            $Flag = $value;\n-                        )*\n-                    }\n-                }\n+                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)\n             }\n \n             /// Returns the raw value of the flags currently stored.\n@@ -532,8 +493,9 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n                 let truncated = Self::from_bits_truncate(bits).bits;\n+\n                 if truncated == bits {\n-                    $crate::__private::core::option::Option::Some(Self{ bits })\n+                    $crate::__private::core::option::Option::Some(Self { bits })\n                 } else {\n                     $crate::__private::core::option::Option::None\n                 }\n@@ -543,15 +505,13 @@ macro_rules! __impl_bitflags {\n             /// that do not correspond to flags.\n             #[inline]\n             pub const fn from_bits_truncate(bits: $T) -> Self {\n-                if bits == 0 {\n+                if bits == <$T as $crate::__private::Bits>::EMPTY {\n                     return Self { bits }\n                 }\n \n-                #[allow(unused_mut)]\n-                let mut truncated = 0;\n+                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n \n                 $(\n-                    #[allow(unused_doc_comments, unused_attributes)]\n                     $(#[$attr $($args)*])*\n                     if bits & Self::$Flag.bits == Self::$Flag.bits {\n                         truncated |= Self::$Flag.bits\n@@ -719,15 +679,13 @@ macro_rules! __impl_bitflags {\n             }\n \n             /// Returns an iterator over set flags and their names.\n-            pub fn iter(mut self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, Self)> {\n+            pub fn iter(self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, Self)> {\n                 use $crate::__private::core::iter::Iterator as _;\n \n                 const NUM_FLAGS: usize = {\n-                    #[allow(unused_mut)]\n                     let mut num_flags = 0;\n \n                     $(\n-                        #[allow(unused_doc_comments, unused_attributes)]\n                         $(#[$attr $($args)*])*\n                         {\n                             num_flags += 1;\n@@ -739,13 +697,11 @@ macro_rules! __impl_bitflags {\n \n                 const OPTIONS: [$BitFlags; NUM_FLAGS] = [\n                     $(\n-                        #[allow(unused_doc_comments, unused_attributes)]\n                         $(#[$attr $($args)*])*\n                         $BitFlags::$Flag,\n                     )*\n                 ];\n \n-                #[allow(unused_doc_comments, unused_attributes)]\n                 const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n                     $(\n                         $(#[$attr $($args)*])*\n@@ -754,17 +710,29 @@ macro_rules! __impl_bitflags {\n                 ];\n \n                 let mut start = 0;\n+                let mut state = self;\n \n                 $crate::__private::core::iter::from_fn(move || {\n-                    if self.is_empty() || NUM_FLAGS == 0 {\n+                    if state.is_empty() || NUM_FLAGS == 0 {\n                         $crate::__private::core::option::Option::None\n                     } else {\n                         for (flag, flag_name) in OPTIONS[start..NUM_FLAGS].iter().copied()\n                             .zip(OPTIONS_NAMES[start..NUM_FLAGS].iter().copied())\n                         {\n                             start += 1;\n+\n+                            // NOTE: We check whether the flag exists in self, but remove it from\n+                            // a different value. This ensure that overlapping flags are handled\n+                            // properly. Take the following example:\n+                            //\n+                            // const A: 0b00000001;\n+                            // const B: 0b00000101;\n+                            //\n+                            // Given the bits 0b00000101, both A and B are set. But if we removed A\n+                            // as we encountered it we'd be left with 0b00000100, which doesn't\n+                            // correspond to a valid flag on its own.\n                             if self.contains(flag) {\n-                                self.remove(flag);\n+                                state.remove(flag);\n \n                                 return $crate::__private::core::option::Option::Some((flag_name, flag))\n                             }\n@@ -1353,7 +1321,10 @@ mod tests {\n         assert_eq!(UNION, Flags::A | Flags::C);\n         assert_eq!(DIFFERENCE, Flags::all() - Flags::A);\n         assert_eq!(COMPLEMENT, !Flags::C);\n-        assert_eq!(SYM_DIFFERENCE, (Flags::A | Flags::C) ^ (Flags::all() - Flags::A));\n+        assert_eq!(\n+            SYM_DIFFERENCE,\n+            (Flags::A | Flags::C) ^ (Flags::all() - Flags::A)\n+        );\n     }\n \n     #[test]\n@@ -1609,13 +1580,15 @@ mod tests {\n         assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n         assert_eq!(format!(\"{:?}\", Flags::empty()), \"(empty)\");\n         assert_eq!(format!(\"{:?}\", Flags::ABC), \"A | B | C\");\n+\n         let extra = unsafe { Flags::from_bits_unchecked(0xb8) };\n+\n         assert_eq!(format!(\"{:?}\", extra), \"0xb8\");\n         assert_eq!(format!(\"{:?}\", Flags::A | extra), \"A | 0xb8\");\n \n         assert_eq!(\n             format!(\"{:?}\", Flags::ABC | extra),\n-            \"A | B | C | 0xb8\"\n+            \"A | B | C | ABC | 0xb8\"\n         );\n \n         assert_eq!(format!(\"{:?}\", EmptyFlags::empty()), \"(empty)\");\n@@ -1830,7 +1803,8 @@ mod tests {\n     fn test_serde_bitflags_roundtrip() {\n         let flags = SerdeFlags::A | SerdeFlags::B;\n \n-        let deserialized: SerdeFlags = serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n+        let deserialized: SerdeFlags =\n+            serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n \n         assert_eq!(deserialized.bits, flags.bits);\n     }\n@@ -1854,7 +1828,6 @@ mod tests {\n             }\n         }\n \n-\n         let flags = Flags::from_bits(0b00000100);\n         assert_eq!(flags, None);\n         let flags = Flags::from_bits(0b00000101);\n@@ -1875,7 +1848,7 @@ mod tests {\n         let flags = Flags::from_bits_truncate(0b00000101);\n         assert_eq!(flags, Flags::A);\n     }\n-  \n+\n     #[test]\n     fn test_iter() {\n         bitflags! {\n@@ -1887,24 +1860,31 @@ mod tests {\n                 const FOUR_WIN = 0b1000;\n                 #[cfg(unix)]\n                 const FOUR_UNIX = 0b10000;\n+                const FIVE = 0b01000100;\n             }\n         }\n \n         let count = {\n             #[cfg(any(unix, windows))]\n             {\n-                4\n+                5\n             }\n \n             #[cfg(not(any(unix, windows)))]\n             {\n-                3\n+                4\n             }\n         };\n \n         let flags = Flags::all();\n         assert_eq!(flags.iter().count(), count);\n+\n+        for (_, flag) in flags.iter() {\n+            assert!(flags.contains(flag));\n+        }\n+\n         let mut iter = flags.iter();\n+\n         assert_eq!(iter.next().unwrap(), (\"ONE\", Flags::ONE));\n         assert_eq!(iter.next().unwrap(), (\"TWO\", Flags::TWO));\n         assert_eq!(iter.next().unwrap(), (\"THREE\", Flags::THREE));\n@@ -1918,6 +1898,8 @@ mod tests {\n             assert_eq!(iter.next().unwrap(), (\"FOUR_WIN\", Flags::FOUR_WIN));\n         }\n \n+        assert_eq!(iter.next().unwrap(), (\"FIVE\", Flags::FIVE));\n+\n         assert_eq!(iter.next(), None);\n \n         let flags = Flags::empty();\n@@ -1925,7 +1907,9 @@ mod tests {\n \n         let flags = Flags::ONE | Flags::THREE;\n         assert_eq!(flags.iter().count(), 2);\n+\n         let mut iter = flags.iter();\n+\n         assert_eq!(iter.next().unwrap(), (\"ONE\", Flags::ONE));\n         assert_eq!(iter.next().unwrap(), (\"THREE\", Flags::THREE));\n         assert_eq!(iter.next(), None);\n", "test_patch": "diff --git a/tests/compile-fail/cfg/multi.stderr b/tests/compile-fail/cfg/multi.stderr\ndeleted file mode 100644\nindex be9ba21c..00000000\n--- a/tests/compile-fail/cfg/multi.stderr\n+++ /dev/null\n@@ -1,17 +0,0 @@\n-error[E0428]: the name `FOO` is defined multiple times\n-  --> tests/compile-fail/cfg/multi.rs:6:1\n-   |\n-6  | / bitflags! {\n-7  | |     pub struct Flags: u32 {\n-8  | |         #[cfg(target_os = \"linux\")]\n-9  | |         const FOO = 1;\n-...  |\n-12 | |     }\n-13 | | }\n-   | | ^\n-   | | |\n-   | |_`FOO` redefined here\n-   |   previous definition of the value `FOO` here\n-   |\n-   = note: `FOO` must be defined only once in the value namespace of this trait\n-   = note: this error originates in the macro `__impl_all_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\nindex fb9c2867..69d89dc5 100644\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -1,22 +1,16 @@\n-error[E0308]: mismatched types\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:116:22\n     |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+116 |     struct Flags128: MyInt {\n+    |                      ^^^^^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n+note: required by a bound in `bitflags::BitFlags::Bits`\n+   --> src/bitflags_trait.rs\n     |\n-458 |                 if extra_bits != MyInt(0) {\n-    |                                  ++++++ +\n+    |     type Bits: Bits;\n+    |                ^^^^ required by this bound in `bitflags::BitFlags::Bits`\n \n-error[E0308]: mismatched types\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n     |\n 115 | / bitflags! {\n@@ -26,15 +20,11 @@ error[E0308]: mismatched types\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-508 |                 Self { bits: MyInt(0) }\n-    |                              ++++++ +\n \n-error[E0308]: mismatched types\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n     |\n 115 | / bitflags! {\n@@ -44,15 +34,11 @@ error[E0308]: mismatched types\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-546 |                 if bits == MyInt(0) {\n-    |                            ++++++ +\n \n-error[E0277]: no implementation for `{integer} |= MyInt`\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n     |\n 115 | / bitflags! {\n@@ -62,12 +48,11 @@ error[E0277]: no implementation for `{integer} |= MyInt`\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ no implementation for `{integer} |= MyInt`\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = help: the trait `BitOrAssign<MyInt>` is not implemented for `{integer}`\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error[E0308]: mismatched types\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n     |\n 115 | / bitflags! {\n@@ -77,28 +62,6 @@ error[E0308]: mismatched types\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-561 |                 Self { bits: MyInt(truncated) }\n-    |                              ++++++         +\n-\n-error[E0308]: mismatched types\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n-    |\n-    = note: this error originates in the macro `__impl_all_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-409 |                 const $Flag: $T = MyInt(0);\n-    |                                   ++++++ +\ndiff --git a/tests/compile-fail/trait/custom_impl.stderr b/tests/compile-fail/trait/custom_impl.stderr\nindex 7f3b4b1e..d7e8d494 100644\n--- a/tests/compile-fail/trait/custom_impl.stderr\n+++ b/tests/compile-fail/trait/custom_impl.stderr\n@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `BootlegFlags: ImplementedByBitFlagsMacro` is not satisfied\n- --> $DIR/custom_impl.rs:5:6\n+ --> tests/compile-fail/trait/custom_impl.rs:5:6\n   |\n 5 | impl BitFlags for BootlegFlags {\n   |      ^^^^^^^^ the trait `ImplementedByBitFlagsMacro` is not implemented for `BootlegFlags`\n   |\n note: required by a bound in `BitFlags`\n- --> $DIR/bitflags_trait.rs:7:21\n+ --> src/bitflags_trait.rs\n   |\n-7 | pub trait BitFlags: ImplementedByBitFlagsMacro {\n+  | pub trait BitFlags: ImplementedByBitFlagsMacro {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `BitFlags`\ndiff --git a/tests/compile-fail/cfg/multi.rs b/tests/compile-pass/cfg/redefined-value.rs\nsimilarity index 70%\nrename from tests/compile-fail/cfg/multi.rs\nrename to tests/compile-pass/cfg/redefined-value.rs\nindex 461db914..6bb2b651 100644\n--- a/tests/compile-fail/cfg/multi.rs\n+++ b/tests/compile-pass/cfg/redefined-value.rs\n@@ -1,12 +1,11 @@\n #[macro_use]\n extern crate bitflags;\n \n-// NOTE: Ideally this would work, but our treatment of CFGs\n-// assumes flags may be missing but not redefined\n bitflags! {\n     pub struct Flags: u32 {\n         #[cfg(target_os = \"linux\")]\n         const FOO = 1;\n+\n         #[cfg(not(target_os = \"linux\"))]\n         const FOO = 2;\n     }\n@@ -20,6 +19,6 @@ fn main() {\n \n     #[cfg(not(target_os = \"linux\"))]\n     {\n-        assert_eq!(1, Flags::FOO.bits());\n+        assert_eq!(2, Flags::FOO.bits());\n     }\n }\ndiff --git a/tests/compile-pass/deprecated.rs b/tests/compile-pass/deprecated.rs\nnew file mode 100644\nindex 00000000..167ce44c\n--- /dev/null\n+++ b/tests/compile-pass/deprecated.rs\n@@ -0,0 +1,14 @@\n+#![deny(warnings)]\n+\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags: u32 {\n+        #[deprecated = \"Use something else\"]\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+    }\n+}\n+\n+fn main() {}\ndiff --git a/tests/compile-pass/non_snake_case.rs b/tests/compile-pass/non_snake_case.rs\nnew file mode 100644\nindex 00000000..5a3b8103\n--- /dev/null\n+++ b/tests/compile-pass/non_snake_case.rs\n@@ -0,0 +1,13 @@\n+#![deny(warnings)]\n+\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags: u32 {\n+        const CamelCase = 0b00000001;\n+        const B = 0b00000010;\n+    }\n+}\n+\n+fn main() {}\n", "problem_statement": "Debug formatting leads to less desireable output\n[Link to rust playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23%5Bmacro_use%5D%0Aextern%20crate%20bitflags%3B%0A%0Abitflags!%20%7B%0A%20%20%20%20struct%20Flags%3A%20u32%20%7B%0A%20%20%20%20%20%20%20%20const%20A%20%3D%200b00000001%3B%0A%20%20%20%20%20%20%20%20const%20B%20%3D%200b00000010%3B%0A%20%20%20%20%20%20%20%20const%20C%20%3D%200b00000100%3B%0A%20%20%20%20%20%20%20%20const%20ABC%20%3D%20Self%3A%3AA.bits%20%7C%20Self%3A%3AB.bits%20%7C%20Self%3A%3AC.bits%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20Flags%3A%3AA%20%7C%20Flags%3A%3AB%20%7C%20Flags%3A%3AC%20)%3B%0A%7D)\r\n\r\n```rust\r\n#[macro_use]\r\nextern crate bitflags;\r\n\r\nbitflags! {\r\n    struct Flags: u32 {\r\n        const A = 0b00000001;\r\n        const B = 0b00000010;\r\n        const C = 0b00000100;\r\n        const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\r\n    }\r\n}\r\n\r\nfn main() {\r\n    println!(\"{:?}\", Flags::A | Flags::B | Flags::C );\r\n}\r\n```\r\n\r\nprints:\r\n\r\n```bash\r\nA | B | C | ABC\r\n```\r\n\r\nI find it somewhat less helpful that both the expanded (`A | B | C`) and \"compressed\" form (`ABC`) are reported...\r\n\r\nIs there a reason behind this? Is this considered more correct for some reason?\n", "hints_text": "I think the current algorithm used for debug output is to loop over all flags and append identifiers that correspond to set bits. I think an alternative here that could work would be to short-circuit when we\u2019ve built a format that covers all the set bits. As an implementation note we wouldn\u2019t be able to work off a single source and just mask out bits as we see them, we\u2019ll need to use the whole set of bits to see if a flag is applicable and then a second set that\u2019s masked to see when we\u2019ve catered for all set bits. Otherwise something like this wouldn\u2019t work:\r\n\r\n```\r\nconst A: 0b00000100\r\nconst B: 0b00001100\r\n\r\nlet input = B;\r\n```\r\n\r\nwe\u2019d mask out bit 3 for `A` but then have one leftover for `B` that doesn\u2019t correspond to it. In that example we\u2019d end up writing `A | B` still, but wouldn\u2019t duplicate compound identifiers the same.\r\n\r\nIn general, I\u2019m not sure if there\u2019s a reasonable algorithm that would produce the smallest possible format for any given set of bits.", "created_at": "2022-05-03T06:59:46Z", "version": "1.3", "FAIL_TO_PASS": ["tests/compile-pass/cfg/redefined-value.rs", "tests/compile-pass/deprecated.rs", "tests/compile-pass/non_snake_case.rs"], "PASS_TO_PASS": ["tests::test_assignment_operators", "tests::submodule::test_private", "tests::test_binary", "tests::test_bits", "tests::test_const_fn", "tests::test_contains", "tests::test_debug", "tests::test_default", "tests::test_deprecated", "tests::test_disjoint_intersects", "tests::test_empty_bitflags", "tests::test_empty_does_not_intersect_with_full", "tests::test_extend", "tests::test_from_bits", "tests::test_from_bits_edge_cases", "tests::test_from_bits_truncate", "tests::test_from_bits_truncate_edge_cases", "tests::test_from_bits_unchecked", "tests::test_hash", "tests::test_in_function", "tests::test_insert", "tests::test_is_all", "tests::test_is_empty", "tests::test_iter", "tests::test_lowerhex", "tests::test_octal", "tests::test_lt", "tests::test_operators", "tests::test_operators_unchecked", "tests::test_ord", "tests::test_overlapping_intersects", "tests::test_pub_crate", "tests::test_pub_in_module", "tests::test_public", "tests::test_remove", "tests::test_serde_bitflags_deserialize", "tests::test_serde_bitflags_roundtrip", "tests::test_serde_bitflags_serialize", "tests::test_set_ops_basic", "tests::test_set_ops_const", "tests::test_set_ops_unchecked", "tests::test_u128_bitflags", "tests::test_upperhex", "tests::test_two_empties_do_not_intersect", "tests::test_zero_value_flags", "tests::test_set", "tests::test_from_iterator", "tests::test_set_ops_exhaustive", "basic", "tests/compile-pass/cfg/nested-value.rs", "tests/compile-pass/impls/convert.rs", "tests/compile-pass/impls/default.rs", "tests/compile-pass/impls/fmt.rs", "tests/compile-pass/impls/inherent_methods.rs", "tests/compile-pass/no_prelude.rs", "tests/compile-pass/redefinition/core.rs", "tests/compile-pass/redefinition/macros.rs", "tests/compile-pass/redefinition/result.rs", "tests/compile-pass/repr/c.rs", "tests/compile-pass/repr/transparent.rs", "tests/compile-pass/trait/precedence.rs", "tests/compile-pass/visibility/bits_field.rs", "tests/compile-pass/visibility/pub_in.rs"], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
{"repo": "bitflags/bitflags", "pull_number": 276, "instance_id": "bitflags__bitflags-276", "issue_numbers": ["275"], "base_commit": "0141a07e55184304857384b0093d00959f0acfa6", "patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex ab7656e7..b9d77f7c 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -559,10 +559,11 @@ macro_rules! __impl_bitflags {\n             /// representation contains bits that do not correspond to a flag.\n             #[inline]\n             pub const fn from_bits(bits: $T) -> $crate::_core::option::Option<Self> {\n-                if (bits & !Self::all().bits()) == 0 {\n-                    $crate::_core::option::Option::Some(Self { bits })\n+                let truncated = Self::from_bits_truncate(bits).bits;\n+                if truncated == bits {\n+                    Some(Self{ bits })\n                 } else {\n-                    $crate::_core::option::Option::None\n+                    None\n                 }\n             }\n \n@@ -570,7 +571,22 @@ macro_rules! __impl_bitflags {\n             /// that do not correspond to flags.\n             #[inline]\n             pub const fn from_bits_truncate(bits: $T) -> Self {\n-                Self { bits: bits & Self::all().bits }\n+                if bits == 0 {\n+                    return Self{ bits }\n+                }\n+\n+                #[allow(unused_mut)]\n+                let mut truncated = 0;\n+\n+                $(\n+                    #[allow(unused_doc_comments, unused_attributes)]\n+                    $(#[$attr $($args)*])*\n+                    if bits & Self::$Flag.bits == Self::$Flag.bits {\n+                        truncated |= Self::$Flag.bits\n+                    }\n+                )*\n+\n+                Self { bits: truncated }\n             }\n \n             /// Convert from underlying bit representation, preserving all\n@@ -1891,6 +1907,37 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_from_bits_edge_cases() {\n+        bitflags! {\n+            struct Flags: u8 {\n+                const A = 0b00000001;\n+                const BC = 0b00000110;\n+            }\n+        }\n+\n+\n+        let flags = Flags::from_bits(0b00000100);\n+        assert_eq!(flags, None);\n+        let flags = Flags::from_bits(0b00000101);\n+        assert_eq!(flags, None);\n+    }\n+\n+    #[test]\n+    fn test_from_bits_truncate_edge_cases() {\n+        bitflags! {\n+            struct Flags: u8 {\n+                const A = 0b00000001;\n+                const BC = 0b00000110;\n+            }\n+        }\n+\n+        let flags = Flags::from_bits_truncate(0b00000100);\n+        assert_eq!(flags, Flags::empty());\n+        let flags = Flags::from_bits_truncate(0b00000101);\n+        assert_eq!(flags, Flags::A);\n+    }\n+  \n     #[test]\n     fn test_iter() {\n         bitflags! {\n@@ -1924,22 +1971,4 @@ mod tests {\n         assert_eq!(iter.next().unwrap(), Flags::THREE);\n         assert_eq!(iter.next(), None);\n     }\n-\n-    #[test]\n-    fn test_iter_edge_cases() {\n-        bitflags! {\n-            struct Flags: u8 {\n-                const A = 0b00000001;\n-                const BC = 0b00000110;\n-            }\n-        }\n-\n-\n-        let flags = Flags::all();\n-        assert_eq!(flags.iter().count(), 2);\n-        let mut iter = flags.iter();\n-        assert_eq!(iter.next().unwrap(), Flags::A);\n-        assert_eq!(iter.next().unwrap(), Flags::BC);\n-        assert_eq!(iter.next(), None);\n-    }\n }\n", "test_patch": "diff --git a/tests/compile-fail/non_integer_base/all_defined.stderr.beta b/tests/compile-fail/non_integer_base/all_defined.stderr.beta\nindex 6fada425..0607f234 100644\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr.beta\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr.beta\n@@ -49,8 +49,41 @@ error[E0308]: mismatched types\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: try wrapping the expression in `MyInt`\n     |\n-562 |                 if (bits & !Self::all().bits()) == MyInt(0) {\n-    |                                                    ++++++ +\n+574 |                 if bits == MyInt(0) {\n+    |                            ++++++ +\n+\n+error[E0277]: no implementation for `{integer} |= MyInt`\n+   --> $DIR/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ no implementation for `{integer} |= MyInt`\n+    |\n+    = help: the trait `BitOrAssign<MyInt>` is not implemented for `{integer}`\n+    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0308]: mismatched types\n+   --> $DIR/all_defined.rs:115:1\n+    |\n+115 | / bitflags! {\n+116 | |     struct Flags128: MyInt {\n+117 | |         const A = MyInt(0b0000_0001u8);\n+118 | |         const B = MyInt(0b0000_0010u8);\n+119 | |         const C = MyInt(0b0000_0100u8);\n+120 | |     }\n+121 | | }\n+    | |_^ expected struct `MyInt`, found integer\n+    |\n+    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: try wrapping the expression in `MyInt`\n+    |\n+589 |                 Self { bits: MyInt(truncated) }\n+    |                              ++++++         +\n \n error[E0308]: mismatched types\n    --> $DIR/all_defined.rs:115:1\n", "problem_statement": "from_bits accepts non existing flags\n```rs\r\n    #[test]\r\n    fn test_from_bits_edge_cases() {\r\n        bitflags! {\r\n            struct Flags: u8 {\r\n                const A = 0b00000001;\r\n                const BC = 0b00000110;\r\n            }\r\n        }\r\n\r\n\r\n        let flags = Flags::from_bits(0b00000100);\r\n        assert!(flags.is_none());\r\n    }\r\n```\r\n\r\nUnless I'm missing something this test should pass but it fails cause from_bits accepts flags that are not declared. \r\n\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6fd4adbddc8b8740cbd35af2306073ca\r\n\r\nThis is related to this issue in the implementation of iterators in this PR https://github.com/bitflags/bitflags/pull/204#issuecomment-950304444 Using `from_bits` instead of `from_bits_unchecked` should allow to produce any valid flags that are not a combination of other flags but at the moment `from_bits` seems to accept any flag that is included in a combination even if it's not declared. I can try to send a PR. \n", "hints_text": "", "created_at": "2022-04-19T09:54:30Z", "version": "1.3", "FAIL_TO_PASS": [], "PASS_TO_PASS": ["tests::test_assignment_operators", "tests::test_const_fn", "tests::submodule::test_private", "tests::test_bits", "tests::test_binary", "tests::test_contains", "tests::test_debug", "tests::test_default", "tests::test_deprecated", "tests::test_disjoint_intersects", "tests::test_empty_bitflags", "tests::test_empty_does_not_intersect_with_full", "tests::test_extend", "tests::test_from_bits", "tests::test_from_bits_truncate", "tests::test_from_bits_unchecked", "tests::test_from_iterator", "tests::test_hash", "tests::test_in_function", "tests::test_insert", "tests::test_is_all", "tests::test_iter", "tests::test_is_empty", "tests::test_lowerhex", "tests::test_lt", "tests::test_octal", "tests::test_operators", "tests::test_operators_unchecked", "tests::test_ord", "tests::test_pub_crate", "tests::test_overlapping_intersects", "tests::test_pub_in_module", "tests::test_public", "tests::test_remove", "tests::test_serde_bitflags_deserialize", "tests::test_serde_bitflags_roundtrip", "tests::test_serde_bitflags_serialize", "tests::test_set", "tests::test_set_ops_basic", "tests::test_set_ops_const", "tests::test_zero_value_flags", "tests::test_u128_bitflags", "tests::test_upperhex", "tests::test_set_ops_unchecked", "tests::test_two_empties_do_not_intersect", "tests::test_set_ops_exhaustive", "basic", "tests/compile-pass/cfg/nested-value.rs", "tests/compile-pass/impls/convert.rs", "tests/compile-pass/impls/default.rs", "tests/compile-pass/impls/fmt.rs", "tests/compile-pass/impls/inherent_methods.rs", "tests/compile-pass/redefinition/core.rs", "tests/compile-pass/redefinition/macros.rs", "tests/compile-pass/redefinition/result.rs", "tests/compile-pass/repr/c.rs", "tests/compile-pass/repr/transparent.rs", "tests/compile-pass/trait/precedence.rs", "tests/compile-pass/visibility/bits_field.rs", "tests/compile-pass/visibility/pub_in.rs", "pass"], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
{"repo": "bitflags/bitflags", "pull_number": 268, "instance_id": "bitflags__bitflags-268", "issue_numbers": ["267"], "base_commit": "1aa25e1b3baf35d3d3840f12fe7e8b55adc0164a", "patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 617afea0..b24fb40b 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -494,8 +494,7 @@ macro_rules! __impl_bitflags {\n                         f.write_str(\" | \")?;\n                     }\n                     first = false;\n-                    f.write_str(\"0x\")?;\n-                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n+                    $crate::_core::write!(f, \"{:#x}\", extra_bits)?;\n                 }\n                 if first {\n                     f.write_str(\"(empty)\")?;\n", "test_patch": "diff --git a/tests/compile-fail/trait/custom_impl.rs b/tests/compile-fail/trait/custom_impl.rs\nindex 66875898..80be2f91 100644\n--- a/tests/compile-fail/trait/custom_impl.rs\n+++ b/tests/compile-fail/trait/custom_impl.rs\n@@ -62,4 +62,4 @@ impl BitFlags for BootlegFlags {\n     }\n }\n \n-fn main() { }\n+fn main() {}\ndiff --git a/tests/compile-pass/impls/convert.rs b/tests/compile-pass/impls/convert.rs\nindex 1f02982a..393ed8f8 100644\n--- a/tests/compile-pass/impls/convert.rs\n+++ b/tests/compile-pass/impls/convert.rs\n@@ -12,6 +12,4 @@ impl From<u32> for Flags {\n     }\n }\n \n-fn main() {\n-\n-}\n+fn main() {}\ndiff --git a/tests/compile-pass/impls/fmt.rs b/tests/compile-pass/impls/fmt.rs\nnew file mode 100644\nindex 00000000..567fd448\n--- /dev/null\n+++ b/tests/compile-pass/impls/fmt.rs\n@@ -0,0 +1,14 @@\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    struct Flags: u8 {\n+        const TWO = 0x2;\n+    }\n+}\n+\n+fn main() {\n+    // bug #267 (https://github.com/bitflags/bitflags/issues/267)\n+    let flags = unsafe { Flags::from_bits_unchecked(0b11) };\n+    assert_eq!(format!(\"{:?}\", flags), \"TWO | 0x1\");\n+    assert_eq!(format!(\"{:#?}\", flags), \"TWO | 0x1\");\n+}\ndiff --git a/tests/compile-pass/redefinition/stringify.rs b/tests/compile-pass/redefinition/macros.rs\nsimilarity index 52%\nrename from tests/compile-pass/redefinition/stringify.rs\nrename to tests/compile-pass/redefinition/macros.rs\nindex b04f2f6a..a9835124 100644\n--- a/tests/compile-pass/redefinition/stringify.rs\n+++ b/tests/compile-pass/redefinition/macros.rs\n@@ -7,6 +7,11 @@ macro_rules! stringify {\n     ($($t:tt)*) => { \"...\" };\n }\n \n+#[allow(unused_macros)]\n+macro_rules! write {\n+    ($($t:tt)*) => { \"...\" };\n+}\n+\n bitflags! {\n     struct Test: u8 {\n         const A = 1;\n@@ -14,6 +19,6 @@ bitflags! {\n }\n \n fn main() {\n-    // Just make sure we don't call the redefined `stringify` macro\n-    assert_eq!(format!(\"{:?}\", Test::A), \"A\");\n+    // Just make sure we don't call the redefined `stringify` or `write` macro\n+    assert_eq!(format!(\"{:?}\", unsafe { Test::from_bits_unchecked(0b11) }), \"A | 0x2\");\n }\n", "problem_statement": "Bug: debug pretty-printing unknown flags display 0x0x\nmain.rs\r\n```rust\r\nuse bitflags::bitflags;\r\n\r\nbitflags! {\r\n    struct Flags: u8 {\r\n        const TWO = 0x2;\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let value = 0b11;\r\n    let flags = unsafe { Flags::from_bits_unchecked(value) };\r\n    println!(\"{:?}\", flags);\r\n    println!(\"-----------\");\r\n    println!(\"{:#?}\", flags);\r\n}\r\n```\r\nwill print the following:\r\n```sh\r\nTWO | 0x1\r\n-----------\r\nTWO | 0x0x1\r\n```\r\n\r\nthe expected output would either be 0x1 for both, or 1, and 0x1 respectively\n", "hints_text": "", "created_at": "2022-01-02T17:22:14Z", "version": "1.3", "FAIL_TO_PASS": ["tests/compile-pass/impls/fmt.rs"], "PASS_TO_PASS": ["tests::submodule::test_private", "tests::test_assignment_operators", "tests::test_binary", "tests::test_bits", "tests::test_const_fn", "tests::test_contains", "tests::test_debug", "tests::test_default", "tests::test_deprecated", "tests::test_disjoint_intersects", "tests::test_empty_bitflags", "tests::test_empty_does_not_intersect_with_full", "tests::test_extend", "tests::test_from_bits", "tests::test_from_bits_unchecked", "tests::test_from_iterator", "tests::test_hash", "tests::test_is_all", "tests::test_lowerhex", "tests::test_is_empty", "tests::test_operators", "tests::test_operators_unchecked", "tests::test_overlapping_intersects", "tests::test_insert", "tests::test_lt", "tests::test_pub_crate", "tests::test_pub_in_module", "tests::test_remove", "tests::test_serde_bitflags_serialize", "tests::test_ord", "tests::test_serde_bitflags_roundtrip", "tests::test_serde_bitflags_deserialize", "tests::test_set", "tests::test_set_ops_basic", "tests::test_in_function", "tests::test_set_ops_const", "tests::test_public", "tests::test_octal", "tests::test_set_ops_unchecked", "tests::test_two_empties_do_not_intersect", "tests::test_u128_bitflags", "tests::test_upperhex", "tests::test_zero_value_flags", "tests::test_from_bits_truncate", "tests::test_set_ops_exhaustive", "basic", "tests/compile-pass/cfg/nested-value.rs", "tests/compile-pass/impls/convert.rs", "tests/compile-pass/impls/default.rs", "tests/compile-pass/impls/inherent_methods.rs", "tests/compile-pass/redefinition/core.rs", "tests/compile-pass/redefinition/macros.rs", "tests/compile-pass/repr/c.rs", "tests/compile-pass/repr/transparent.rs", "tests/compile-pass/trait/precedence.rs", "tests/compile-pass/visibility/bits_field.rs", "tests/compile-pass/visibility/pub_in.rs"], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
{"repo": "bitflags/bitflags", "pull_number": 266, "instance_id": "bitflags__bitflags-266", "issue_numbers": ["265"], "base_commit": "1aa25e1b3baf35d3d3840f12fe7e8b55adc0164a", "patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 617afea0..a4ca8429 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -500,7 +500,7 @@ macro_rules! __impl_bitflags {\n                 if first {\n                     f.write_str(\"(empty)\")?;\n                 }\n-                Ok(())\n+                $crate::_core::fmt::Result::Ok(())\n             }\n         }\n         impl $crate::_core::fmt::Binary for $BitFlags {\n", "test_patch": "diff --git a/tests/compile-pass/redefinition/result.rs b/tests/compile-pass/redefinition/result.rs\nnew file mode 100644\nindex 00000000..fe915d47\n--- /dev/null\n+++ b/tests/compile-pass/redefinition/result.rs\n@@ -0,0 +1,15 @@\n+use bitflags::bitflags;\n+\n+// Checks for possible errors caused by overriding names used by `bitflags!` internally.\n+\n+// bug #265 (https://github.com/bitflags/bitflags/issues/265)\n+\n+pub struct Ok<T>(T);\n+\n+bitflags! {\n+    pub struct Flags: u16{\n+        const FOO = 0x0001;\n+    }\n+}\n+\n+fn main() {}\n", "problem_statement": "The bitflags macro is not sanitary wrt. standard library types and enumerations\nThe `bitflags` macro, expanded in the prescence of a definition of the type/value `Ok` errors.\r\nReproduction code:\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3fda3e36c7c6a57e0f7a83c84e56df20\r\n\r\nInterestingly, the relevant function, the `fmt` function from the Debug impl, does use `::bitflags::_core::fmt::Result`, however, it merely returns the value `Ok(())`. \n", "hints_text": "", "created_at": "2021-12-16T09:38:14Z", "version": "1.3", "FAIL_TO_PASS": ["tests/compile-pass/redefinition/result.rs"], "PASS_TO_PASS": ["tests::submodule::test_private", "tests::test_assignment_operators", "tests::test_binary", "tests::test_bits", "tests::test_const_fn", "tests::test_contains", "tests::test_debug", "tests::test_default", "tests::test_deprecated", "tests::test_disjoint_intersects", "tests::test_empty_bitflags", "tests::test_extend", "tests::test_empty_does_not_intersect_with_full", "tests::test_from_bits", "tests::test_from_bits_truncate", "tests::test_from_bits_unchecked", "tests::test_from_iterator", "tests::test_hash", "tests::test_in_function", "tests::test_insert", "tests::test_is_all", "tests::test_is_empty", "tests::test_lowerhex", "tests::test_lt", "tests::test_octal", "tests::test_operators", "tests::test_operators_unchecked", "tests::test_ord", "tests::test_pub_crate", "tests::test_pub_in_module", "tests::test_public", "tests::test_remove", "tests::test_serde_bitflags_deserialize", "tests::test_serde_bitflags_roundtrip", "tests::test_set_ops_basic", "tests::test_set_ops_const", "tests::test_two_empties_do_not_intersect", "tests::test_set_ops_unchecked", "tests::test_u128_bitflags", "tests::test_upperhex", "tests::test_set", "tests::test_zero_value_flags", "tests::test_serde_bitflags_serialize", "tests::test_overlapping_intersects", "tests::test_set_ops_exhaustive", "basic", "tests/compile-pass/cfg/nested-value.rs", "tests/compile-pass/impls/convert.rs", "tests/compile-pass/impls/default.rs", "tests/compile-pass/impls/inherent_methods.rs", "tests/compile-pass/redefinition/core.rs", "tests/compile-pass/redefinition/stringify.rs", "tests/compile-pass/repr/c.rs", "tests/compile-pass/repr/transparent.rs", "tests/compile-pass/trait/precedence.rs", "tests/compile-pass/visibility/bits_field.rs", "tests/compile-pass/visibility/pub_in.rs"], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
