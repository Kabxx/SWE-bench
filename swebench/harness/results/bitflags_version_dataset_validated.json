{"repo": "bitflags/bitflags", "pull_number": 411, "instance_id": "bitflags__bitflags-411", "issue_numbers": ["406"], "base_commit": "9c4b93c931e34a5104f50e20be1bdd15bc593b0e", "patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 8f722591..b5e8911b 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -38,7 +38,7 @@ bitflags! {\n \n See the docs for the `bitflags` macro for the full syntax.\n \n-Also see the [`example_generated`] module for an example of what the `bitflags` macro generates for a flags type.\n+Also see the [`example_generated`](./example_generated/index.html) module for an example of what the `bitflags` macro generates for a flags type.\n \n ### Externally defined flags\n \n@@ -530,6 +530,7 @@ macro_rules! bitflags {\n         }\n     };\n     (\n+        $(#[$outer:meta])*\n         impl $BitFlags:ident: $T:ty {\n             $(\n                 $(#[$inner:ident $($args:tt)*])*\n@@ -561,6 +562,7 @@ macro_rules! bitflags {\n         )]\n         const _: () = {\n             $crate::__impl_public_bitflags! {\n+                $(#[$outer])*\n                 $BitFlags: $T, $BitFlags {\n                     $(\n                         $(#[$inner $($args)*])*\n@@ -593,6 +595,7 @@ macro_rules! bitflags {\n #[doc(hidden)]\n macro_rules! __impl_bitflags {\n     (\n+        $(#[$outer:meta])*\n         $PublicBitFlags:ident: $T:ty {\n             fn empty() $empty:block\n             fn all() $all:block\n@@ -617,6 +620,7 @@ macro_rules! __impl_bitflags {\n         }\n     ) => {\n         #[allow(dead_code, deprecated, unused_attributes)]\n+        $(#[$outer])*\n         impl $PublicBitFlags {\n             /// Get a flags value with all bits unset.\n             #[inline]\ndiff --git a/src/public.rs b/src/public.rs\nindex dc2d7267..feecdd67 100644\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -26,9 +26,11 @@ macro_rules! __declare_public_bitflags {\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_forward {\n     (\n+        $(#[$outer:meta])*\n         $PublicBitFlags:ident: $T:ty, $InternalBitFlags:ident\n     ) => {\n         $crate::__impl_bitflags! {\n+            $(#[$outer])*\n             $PublicBitFlags: $T {\n                 fn empty() {\n                     Self($InternalBitFlags::empty())\n@@ -128,6 +130,7 @@ macro_rules! __impl_public_bitflags_forward {\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags {\n     (\n+        $(#[$outer:meta])*\n         $BitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$inner:ident $($args:tt)*])*\n@@ -136,6 +139,7 @@ macro_rules! __impl_public_bitflags {\n         }\n     ) => {\n         $crate::__impl_bitflags! {\n+            $(#[$outer])*\n             $BitFlags: $T {\n                 fn empty() {\n                     Self(<$T as $crate::Bits>::EMPTY)\n@@ -271,7 +275,11 @@ macro_rules! __impl_public_bitflags {\n #[macro_export]\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_iter {\n-    ($BitFlags:ident: $T:ty, $PublicBitFlags:ident) => {\n+    (\n+        $(#[$outer:meta])*\n+        $BitFlags:ident: $T:ty, $PublicBitFlags:ident\n+    ) => {\n+        $(#[$outer])*\n         impl $BitFlags {\n             /// Yield a set of contained flags values.\n             ///\n@@ -300,6 +308,7 @@ macro_rules! __impl_public_bitflags_iter {\n             }\n         }\n \n+        $(#[$outer:meta])*\n         impl $crate::__private::core::iter::IntoIterator for $BitFlags {\n             type Item = $PublicBitFlags;\n             type IntoIter = $crate::iter::Iter<$PublicBitFlags>;\n@@ -315,7 +324,12 @@ macro_rules! __impl_public_bitflags_iter {\n #[macro_export]\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_ops {\n-    ($PublicBitFlags:ident) => {\n+    (\n+        $(#[$outer:meta])*\n+        $PublicBitFlags:ident\n+    ) => {\n+\n+        $(#[$outer])*\n         impl $crate::__private::core::fmt::Binary for $PublicBitFlags {\n             fn fmt(\n                 &self,\n@@ -326,6 +340,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::fmt::Octal for $PublicBitFlags {\n             fn fmt(\n                 &self,\n@@ -336,6 +351,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::fmt::LowerHex for $PublicBitFlags {\n             fn fmt(\n                 &self,\n@@ -346,6 +362,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::fmt::UpperHex for $PublicBitFlags {\n             fn fmt(\n                 &self,\n@@ -356,6 +373,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::BitOr for $PublicBitFlags {\n             type Output = Self;\n \n@@ -366,6 +384,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::BitOrAssign for $PublicBitFlags {\n             /// The bitwise or (`|`) of the bits in two flags values.\n             #[inline]\n@@ -374,6 +393,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::BitXor for $PublicBitFlags {\n             type Output = Self;\n \n@@ -384,6 +404,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::BitXorAssign for $PublicBitFlags {\n             /// The bitwise exclusive-or (`^`) of the bits in two flags values.\n             #[inline]\n@@ -392,6 +413,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::BitAnd for $PublicBitFlags {\n             type Output = Self;\n \n@@ -402,6 +424,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::BitAndAssign for $PublicBitFlags {\n             /// The bitwise and (`&`) of the bits in two flags values.\n             #[inline]\n@@ -410,6 +433,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::Sub for $PublicBitFlags {\n             type Output = Self;\n \n@@ -423,6 +447,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::SubAssign for $PublicBitFlags {\n             /// The intersection of a source flags value with the complement of a target flags value (`&!`).\n             ///\n@@ -434,6 +459,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::ops::Not for $PublicBitFlags {\n             type Output = Self;\n \n@@ -444,6 +470,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::iter::Extend<$PublicBitFlags> for $PublicBitFlags {\n             /// The bitwise or (`|`) of the bits in each flags value.\n             fn extend<T: $crate::__private::core::iter::IntoIterator<Item = Self>>(\n@@ -456,6 +483,7 @@ macro_rules! __impl_public_bitflags_ops {\n             }\n         }\n \n+        $(#[$outer])*\n         impl $crate::__private::core::iter::FromIterator<$PublicBitFlags> for $PublicBitFlags {\n             /// The bitwise or (`|`) of the bits in each flags value.\n             fn from_iter<T: $crate::__private::core::iter::IntoIterator<Item = Self>>(\n@@ -476,6 +504,7 @@ macro_rules! __impl_public_bitflags_ops {\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_consts {\n     (\n+        $(#[$outer:meta])*\n         $PublicBitFlags:ident: $T:ty {\n             $(\n                 $(#[$inner:ident $($args:tt)*])*\n@@ -483,6 +512,7 @@ macro_rules! __impl_public_bitflags_consts {\n             )*\n         }\n     ) => {\n+        $(#[$outer])*\n         impl $PublicBitFlags {\n             $(\n                 $crate::__bitflags_flag!({\n@@ -500,6 +530,7 @@ macro_rules! __impl_public_bitflags_consts {\n             )*\n         }\n \n+        $(#[$outer])*\n         impl $crate::Flags for $PublicBitFlags {\n             const FLAGS: &'static [$crate::Flag<$PublicBitFlags>] = &[\n                 $(\n", "test_patch": "diff --git a/tests/compile-pass/bitflags_impl_attrs.rs b/tests/compile-pass/bitflags_impl_attrs.rs\nnew file mode 100644\nindex 00000000..91d89823\n--- /dev/null\n+++ b/tests/compile-pass/bitflags_impl_attrs.rs\n@@ -0,0 +1,13 @@\n+extern crate bitflags;\n+\n+struct Example(u64);\n+\n+bitflags::bitflags! {\n+    /// Docs on the `impl` block.\n+    #[allow(dead_code)]\n+    impl Example: u64 {\n+        const flag = 0b01;\n+    }\n+}\n+\n+fn main() {}\n", "problem_statement": "Allow specifying attributes in `impl` mode\nI'm considering `cfg`-gating the use of `bitflags!` in my libraries, and to that end it would be nice if it was possible to apply attributes to the generated `impl`s as well.\r\n\r\nThe naive solution would be:\r\n```rust\r\npub struct Flags(u8);\r\n\r\n#[cfg(feature = \"bitflags\")]\r\nbitflags! {\r\n    impl Flags: u8 {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nHowever, that works poorly with the `doc_cfg` (and `doc_auto_cfg`) feature, as the attribute is only applied to the macro, and isn't passed down to each output item.\r\n\r\nInstead, I would like to be able to do the following:\r\n```rust\r\n#![feature(doc_cfg)]\r\n\r\npub struct Flags(u8);\r\n\r\n#[cfg(feature = \"bitflags\")]\r\nbitflags! {\r\n    #[doc(cfg(feature = \"bitflags\"))]\r\n    impl Flags: u8 {\r\n        // ...\r\n    }\r\n}\r\n```\n", "hints_text": "Thanks for the report @madsmtm! Anywhere attributes are allowed to be specified we should support in the macros as much as possible. I think this is just a missing piece of functionality for the impl mode.", "created_at": "2024-06-24T23:17:40Z", "version": "2.5", "FAIL_TO_PASS": ["tests/compile-pass/bitflags_impl_attrs.rs"], "PASS_TO_PASS": ["tests::complement::cases", "tests::bits::cases", "tests::all::cases", "tests::contains::cases", "tests::difference::cases", "tests::empty::cases", "tests::eq::cases", "tests::extend::cases", "tests::extend::external::cases", "tests::flags::external::cases", "tests::from_bits::cases", "tests::flags::cases", "tests::from_bits_retain::cases", "tests::from_name::cases", "tests::intersection::cases", "tests::insert::cases", "tests::intersects::cases", "tests::is_all::cases", "tests::is_empty::cases", "tests::iter::collect::cases", "tests::iter::iter::cases", "tests::iter::iter_names::cases", "tests::parser::from_str::invalid", "tests::from_bits_truncate::cases", "tests::parser::from_str::valid", "tests::parser::from_str_strict::invalid", "tests::parser::from_str_truncate::valid", "tests::parser::from_str_strict::valid", "tests::parser::to_writer_truncate::cases", "tests::remove::cases", "tests::parser::to_writer_strict::cases", "tests::union::cases", "tests::symmetric_difference::cases", "tests::fmt::cases", "tests::parser::to_writer::cases", "tests::iter::roundtrip", "tests::parser::roundtrip_truncate", "tests::parser::roundtrip", "tests::parser::roundtrip_strict", "tests/compile-pass/bitflags_impl_repr_packed.rs", "tests/compile-pass/bitflags_nested_value.rs", "tests/compile-pass/bitflags_redefined_value.rs", "tests/compile-pass/bitflags_self_in_value.rs", "tests/compile-pass/bitflags_trait_bound_flags.rs", "tests/compile-pass/bitflags_trait_generic_iter.rs", "tests/compile-pass/bitflags_trait_precedence.rs", "tests/compile-pass/bitflags_trait_supertrait.rs", "tests/compile-pass/bitflags_trait_to_flags.rs", "tests/compile-pass/bitflags_visibility.rs", "tests/compile-pass/deprecated.rs", "tests/compile-pass/doc_alias.rs", "tests/compile-pass/flags_trait_bound_bitflags.rs", "tests/compile-pass/flags_trait_generic_iter.rs", "tests/compile-pass/flags_trait_precedence.rs", "tests/compile-pass/flags_trait_supertrait.rs", "tests/compile-pass/impl_convert_from_bits.rs", "tests/compile-pass/impl_copy.rs", "tests/compile-pass/impl_default.rs", "tests/compile-pass/impl_eq.rs", "tests/compile-pass/impl_fmt.rs", "tests/compile-pass/impl_new.rs", "tests/compile-pass/into_iter_trait_wrapped.rs", "tests/compile-pass/item_positions.rs", "tests/compile-pass/large.rs", "tests/compile-pass/missing_docs.rs", "tests/compile-pass/no_prelude.rs", "tests/compile-pass/non_snake_case.rs", "tests/compile-pass/parser_strict_non_hex_bits.rs", "tests/compile-pass/path_based_bits.rs", "tests/compile-pass/repr_c.rs", "tests/compile-pass/repr_transparent.rs", "tests/compile-pass/shadow_core.rs", "tests/compile-pass/shadow_macros.rs", "tests/compile-pass/shadow_result.rs", "tests/compile-pass/unnamed.rs"], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
{"repo": "bitflags/bitflags", "pull_number": 355, "instance_id": "bitflags__bitflags-355", "issue_numbers": ["357"], "base_commit": "31d3e4afefc964045156d7fe3622733f48511353", "patch": "diff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\nindex 6ebd5a74..15d1f950 100644\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -81,6 +81,23 @@ jobs:\n       - name: Default features\n         run: cross test --target mips-unknown-linux-gnu\n \n+  clippy:\n+    name: Clippy\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout sources\n+        uses: actions/checkout@8e5e7e5ab8b370d6c329ec480221332ada57f0ab\n+\n+      - name: Install Clippy\n+        run: |\n+          rustup update beta\n+          rustup component add clippy --toolchain beta\n+\n+      - name: Default features\n+        run: |\n+          cd ./tests/smoke-test\n+          cargo +beta clippy\n+\n   embedded:\n     name: Build (embedded)\n     runs-on: ubuntu-latest\ndiff --git a/src/example_generated.rs b/src/example_generated.rs\nindex 0fda40c0..7f8a5c5d 100644\n--- a/src/example_generated.rs\n+++ b/src/example_generated.rs\n@@ -39,7 +39,7 @@ __impl_public_bitflags_forward! {\n }\n \n __impl_public_bitflags_iter! {\n-    Flags\n+    Flags: u32, Flags\n }\n \n __impl_public_bitflags_consts! {\ndiff --git a/src/external.rs b/src/external.rs\nindex f3fbac0d..103b5d1e 100644\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -19,7 +19,7 @@ Next, define a macro like so:\n #[cfg(feature = \"serde\")]\n macro_rules! __impl_external_bitflags_my_library {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\n@@ -35,7 +35,7 @@ macro_rules! __impl_external_bitflags_my_library {\n #[cfg(not(feature = \"my_library\"))]\n macro_rules! __impl_external_bitflags_my_library {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\n@@ -55,7 +55,7 @@ Now, we add our macro call to the `__impl_external_bitflags` macro body:\n \n ```rust\n __impl_external_bitflags_my_library! {\n-    $InternalBitFlags: $T {\n+    $InternalBitFlags: $T, $PublicBitFlags {\n         $(\n             $(#[$attr $($args)*])*\n             $Flag;\n@@ -76,6 +76,51 @@ pub(crate) mod __private {\n     pub use bytemuck;\n }\n \n+/// Implements traits from external libraries for the internal bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_external_bitflags {\n+    (\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n+    ) => {\n+        // Any new library traits impls should be added here\n+        // Use `serde` as an example: generate code when the feature is available,\n+        // and a no-op when it isn't\n+\n+        __impl_external_bitflags_serde! {\n+            $InternalBitFlags: $T, $PublicBitFlags {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n+\n+        __impl_external_bitflags_arbitrary! {\n+            $InternalBitFlags: $T, $PublicBitFlags {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n+\n+        __impl_external_bitflags_bytemuck! {\n+            $InternalBitFlags: $T, $PublicBitFlags {\n+                $(\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n+                )*\n+            }\n+        }\n+    };\n+}\n+\n #[cfg(feature = \"serde\")]\n pub mod serde;\n \n@@ -85,11 +130,11 @@ pub mod serde;\n #[cfg(feature = \"serde\")]\n macro_rules! __impl_external_bitflags_serde {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\n-                )*\n+            )*\n         }\n     ) => {\n         impl $crate::__private::serde::Serialize for $InternalBitFlags {\n@@ -98,7 +143,7 @@ macro_rules! __impl_external_bitflags_serde {\n                 serializer: S,\n             ) -> $crate::__private::core::result::Result<S::Ok, S::Error> {\n                 $crate::serde::serialize(\n-                    self,\n+                    &$PublicBitFlags::from_bits_retain(self.bits()),\n                     serializer,\n                 )\n             }\n@@ -108,9 +153,11 @@ macro_rules! __impl_external_bitflags_serde {\n             fn deserialize<D: $crate::__private::serde::Deserializer<'de>>(\n                 deserializer: D,\n             ) -> $crate::__private::core::result::Result<Self, D::Error> {\n-                $crate::serde::deserialize(\n+                let flags: $PublicBitFlags = $crate::serde::deserialize(\n                     deserializer,\n-                )\n+                )?;\n+\n+                Ok(flags.0)\n             }\n         }\n     };\n@@ -121,11 +168,11 @@ macro_rules! __impl_external_bitflags_serde {\n #[cfg(not(feature = \"serde\"))]\n macro_rules! __impl_external_bitflags_serde {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\n-                )*\n+            )*\n         }\n     ) => {};\n }\n@@ -136,58 +183,13 @@ pub mod arbitrary;\n #[cfg(feature = \"bytemuck\")]\n mod bytemuck;\n \n-/// Implements traits from external libraries for the internal bitflags type.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-macro_rules! __impl_external_bitflags {\n-    (\n-        $InternalBitFlags:ident: $T:ty {\n-            $(\n-                $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident;\n-            )*\n-        }\n-    ) => {\n-        // Any new library traits impls should be added here\n-        // Use `serde` as an example: generate code when the feature is available,\n-        // and a no-op when it isn't\n-\n-        __impl_external_bitflags_serde! {\n-            $InternalBitFlags: $T {\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    $Flag;\n-                )*\n-            }\n-        }\n-\n-        __impl_external_bitflags_arbitrary! {\n-            $InternalBitFlags: $T {\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    $Flag;\n-                )*\n-            }\n-        }\n-\n-        __impl_external_bitflags_bytemuck! {\n-            $InternalBitFlags: $T {\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    $Flag;\n-                )*\n-            }\n-        }\n-    };\n-}\n-\n /// Implement `Arbitrary` for the internal bitflags type.\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n #[cfg(feature = \"arbitrary\")]\n macro_rules! __impl_external_bitflags_arbitrary {\n     (\n-            $InternalBitFlags:ident: $T:ty {\n+            $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n                 $(\n                     $(#[$attr:ident $($args:tt)*])*\n                     $Flag:ident;\n@@ -198,7 +200,7 @@ macro_rules! __impl_external_bitflags_arbitrary {\n             fn arbitrary(\n                 u: &mut $crate::__private::arbitrary::Unstructured<'a>,\n             ) -> $crate::__private::arbitrary::Result<Self> {\n-                $crate::arbitrary::arbitrary(u)\n+                $crate::arbitrary::arbitrary::<$PublicBitFlags>(u).map(|flags| flags.0)\n             }\n         }\n     };\n@@ -209,12 +211,12 @@ macro_rules! __impl_external_bitflags_arbitrary {\n #[cfg(not(feature = \"arbitrary\"))]\n macro_rules! __impl_external_bitflags_arbitrary {\n     (\n-            $InternalBitFlags:ident: $T:ty {\n-                $(\n-                    $(#[$attr:ident $($args:tt)*])*\n-                    $Flag:ident;\n-                )*\n-            }\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n+        }\n     ) => {};\n }\n \n@@ -224,11 +226,11 @@ macro_rules! __impl_external_bitflags_arbitrary {\n #[cfg(feature = \"bytemuck\")]\n macro_rules! __impl_external_bitflags_bytemuck {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n-                    $Flag:ident;\n-                )*\n+                $Flag:ident;\n+            )*\n         }\n     ) => {\n         // SAFETY: $InternalBitFlags is guaranteed to have the same ABI as $T,\n@@ -256,11 +258,11 @@ macro_rules! __impl_external_bitflags_bytemuck {\n #[cfg(not(feature = \"bytemuck\"))]\n macro_rules! __impl_external_bitflags_bytemuck {\n     (\n-        $InternalBitFlags:ident: $T:ty {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n-                    $Flag:ident;\n-                )*\n+                $Flag:ident;\n+            )*\n         }\n     ) => {};\n }\ndiff --git a/src/internal.rs b/src/internal.rs\nindex 8347b03f..c4fb6533 100644\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -98,7 +98,7 @@ macro_rules! __impl_internal_bitflags {\n         // The internal flags type offers a similar API to the public one\n \n         __impl_public_bitflags! {\n-            $InternalBitFlags: $T {\n+            $InternalBitFlags: $T, $PublicBitFlags {\n                 $(\n                     $(#[$attr $($args)*])*\n                     $Flag;\n@@ -106,19 +106,8 @@ macro_rules! __impl_internal_bitflags {\n             }\n         }\n \n-        __impl_public_bitflags_consts! {\n-            $InternalBitFlags: $T {\n-                $(\n-                    $(#[$attr $($args)*])*\n-                    #[allow(\n-                        dead_code,\n-                        deprecated,\n-                        unused_attributes,\n-                        non_upper_case_globals\n-                    )]\n-                    $Flag = $value;\n-                )*\n-            }\n+        __impl_public_bitflags_iter! {\n+            $InternalBitFlags: $T, $PublicBitFlags\n         }\n \n         impl $InternalBitFlags {\n@@ -127,18 +116,6 @@ macro_rules! __impl_internal_bitflags {\n             pub fn bits_mut(&mut self) -> &mut $T {\n                 &mut self.0\n             }\n-\n-            /// Iterate over enabled flag values.\n-            #[inline]\n-            pub const fn iter(&self) -> $crate::iter::Iter<$PublicBitFlags> {\n-                $crate::iter::Iter::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.0), $PublicBitFlags::from_bits_retain(self.0))\n-            }\n-\n-            /// Iterate over enabled flag values with their stringified names.\n-            #[inline]\n-            pub const fn iter_names(&self) -> $crate::iter::IterNames<$PublicBitFlags> {\n-                $crate::iter::IterNames::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.0), $PublicBitFlags::from_bits_retain(self.0))\n-            }\n         }\n     };\n }\ndiff --git a/src/lib.rs b/src/lib.rs\nindex ab278406..9a0059f8 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -590,7 +590,8 @@ macro_rules! bitflags {\n             unused_attributes,\n             unused_mut,\n             unused_imports,\n-            non_upper_case_globals\n+            non_upper_case_globals,\n+            clippy::assign_op_pattern\n         )]\n         const _: () = {\n             // Declared in a \"hidden\" scope that can't be reached directly\n@@ -610,7 +611,7 @@ macro_rules! bitflags {\n \n             // This is where new library trait implementations can be added\n             __impl_external_bitflags! {\n-                InternalBitFlags: $T {\n+                InternalBitFlags: $T, $BitFlags {\n                     $(\n                         $(#[$inner $($args)*])*\n                         $Flag;\n@@ -623,7 +624,7 @@ macro_rules! bitflags {\n             }\n \n             __impl_public_bitflags_iter! {\n-                $BitFlags\n+                $BitFlags: $T, $BitFlags\n             }\n         };\n \n@@ -657,11 +658,12 @@ macro_rules! bitflags {\n             unused_attributes,\n             unused_mut,\n             unused_imports,\n-            non_upper_case_globals\n+            non_upper_case_globals,\n+            clippy::assign_op_pattern\n         )]\n         const _: () = {\n             __impl_public_bitflags! {\n-                $BitFlags: $T {\n+                $BitFlags: $T, $BitFlags {\n                     $(\n                         $(#[$inner $($args)*])*\n                         $Flag;\n@@ -670,7 +672,7 @@ macro_rules! bitflags {\n             }\n \n             __impl_public_bitflags_iter! {\n-                $BitFlags\n+                $BitFlags: $T, $BitFlags\n             }\n         };\n \ndiff --git a/src/public.rs b/src/public.rs\nindex d650fc43..57ab0ea8 100644\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -57,7 +57,7 @@ macro_rules! __impl_public_bitflags_forward {\n                     Self($InternalBitFlags::from_bits_retain(bits))\n                 }\n \n-                fn from_name(name){\n+                fn from_name(name) {\n                     match $InternalBitFlags::from_name(name) {\n                         $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n                         $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n@@ -130,7 +130,7 @@ macro_rules! __impl_public_bitflags_forward {\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags {\n     (\n-        $PublicBitFlags:ident: $T:ty {\n+        $BitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident;\n@@ -138,7 +138,7 @@ macro_rules! __impl_public_bitflags {\n         }\n     ) => {\n         __impl_bitflags! {\n-            $PublicBitFlags: $T {\n+            $BitFlags: $T {\n                 fn empty() {\n                     Self(<$T as $crate::Bits>::EMPTY)\n                 }\n@@ -260,7 +260,7 @@ macro_rules! __impl_public_bitflags {\n             }\n         }\n \n-        __impl_public_bitflags_ops!($PublicBitFlags);\n+        __impl_public_bitflags_ops!($BitFlags);\n     };\n }\n \n@@ -268,8 +268,8 @@ macro_rules! __impl_public_bitflags {\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_iter {\n-    ($PublicBitFlags:ident) => {\n-        impl $PublicBitFlags {\n+    ($BitFlags:ident: $T:ty, $PublicBitFlags:ident) => {\n+        impl $BitFlags {\n             /// Iterate over enabled flag values.\n             #[inline]\n             pub const fn iter(&self) -> $crate::iter::Iter<$PublicBitFlags> {\n@@ -283,8 +283,8 @@ macro_rules! __impl_public_bitflags_iter {\n             }\n         }\n \n-        impl $crate::__private::core::iter::IntoIterator for $PublicBitFlags {\n-            type Item = Self;\n+        impl $crate::__private::core::iter::IntoIterator for $BitFlags {\n+            type Item = $PublicBitFlags;\n             type IntoIter = $crate::iter::Iter<$PublicBitFlags>;\n \n             fn into_iter(self) -> Self::IntoIter {\n", "test_patch": "diff --git a/tests/compile-fail/bitflags_custom_bits.rs b/tests/compile-fail/bitflags_custom_bits.rs\nindex 46fde469..b719de4f 100644\n--- a/tests/compile-fail/bitflags_custom_bits.rs\n+++ b/tests/compile-fail/bitflags_custom_bits.rs\n@@ -19,7 +19,7 @@ use std::{\n     },\n };\n \n-use bitflags::{bitflags, Bits, parser::{ParseError, FromHex}};\n+use bitflags::{bitflags, Bits, parser::{ParseError, WriteHex, ParseHex}};\n \n // Ideally we'd actually want this to work, but currently need something like `num`'s `Zero`\n // With some design work it could be made possible\n@@ -117,12 +117,18 @@ impl Binary for MyInt {\n     }\n }\n \n-impl FromHex for MyInt {\n-    fn from_hex(input: &str) -> Result<Self, ParseError> {\n+impl ParseHex for MyInt {\n+    fn parse_hex(input: &str) -> Result<Self, ParseError> {\n         Ok(MyInt(u8::from_str_radix(input, 16).map_err(|_| ParseError::invalid_hex_flag(input))?))\n     }\n }\n \n+impl WriteHex for MyInt {\n+    fn write_hex<W: fmt::Write>(&self, writer: W) -> fmt::Result {\n+        LowerHex::fmt(&self.0, writer)\n+    }\n+}\n+\n bitflags! {\n     struct Flags128: MyInt {\n         const A = MyInt(0b0000_0001u8);\ndiff --git a/tests/compile-fail/bitflags_custom_bits.stderr b/tests/compile-fail/bitflags_custom_bits.stderr\nindex c74c27f0..86e0392b 100644\n--- a/tests/compile-fail/bitflags_custom_bits.stderr\n+++ b/tests/compile-fail/bitflags_custom_bits.stderr\n@@ -1,7 +1,7 @@\n error[E0277]: the trait bound `MyInt: bitflags::traits::Primitive` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:127:22\n+   --> tests/compile-fail/bitflags_custom_bits.rs:133:22\n     |\n-127 |     struct Flags128: MyInt {\n+133 |     struct Flags128: MyInt {\n     |                      ^^^^^ the trait `bitflags::traits::Primitive` is not implemented for `MyInt`\n     |\n     = help: the following other types implement trait `bitflags::traits::Primitive`:\n@@ -20,442 +20,457 @@ note: required by a bound in `PublicFlags::Primitive`\n     |     type Primitive: Primitive;\n     |                     ^^^^^^^^^ required by this bound in `PublicFlags::Primitive`\n \n+error[E0308]: mismatched types\n+   --> tests/compile-fail/bitflags_custom_bits.rs:128:32\n+    |\n+127 |     fn write_hex<W: fmt::Write>(&self, writer: W) -> fmt::Result {\n+    |                  - this type parameter\n+128 |         LowerHex::fmt(&self.0, writer)\n+    |         -------------          ^^^^^^ expected `&mut Formatter<'_>`, found type parameter `W`\n+    |         |\n+    |         arguments to this function are incorrect\n+    |\n+    = note: expected mutable reference `&mut Formatter<'_>`\n+                  found type parameter `W`\n+note: method defined here\n+   --> $RUST/core/src/fmt/mod.rs\n+\n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt | MyInt`\n     |\n     = help: the trait `~const BitOr` is not implemented for `MyInt`\n note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt | MyInt`\n     |\n     = help: the trait `~const BitOr` is not implemented for `MyInt`\n note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt == _`\n     |\n     = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt | MyInt`\n     |\n     = help: the trait `~const BitOr` is not implemented for `MyInt`\n note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt & MyInt`\n     |\n     = help: the trait `~const BitAnd` is not implemented for `MyInt`\n note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Not` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ the trait `~const Not` is not implemented for `MyInt`\n     |\n note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: BitXor` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ no implementation for `MyInt ^ MyInt`\n     |\n     = help: the trait `~const BitXor` is not implemented for `MyInt`\n note: the trait `BitXor` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `MyInt: Not` is not satisfied\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^ the trait `~const Not` is not implemented for `MyInt`\n     |\n note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n-    |\n-126 | / bitflags! {\n-127 | |     struct Flags128: MyInt {\n-128 | |         const A = MyInt(0b0000_0001u8);\n-129 | |         const B = MyInt(0b0000_0010u8);\n-130 | |         const C = MyInt(0b0000_0100u8);\n-131 | |     }\n-132 | | }\n+   --> tests/compile-fail/bitflags_custom_bits.rs:132:1\n+    |\n+132 | / bitflags! {\n+133 | |     struct Flags128: MyInt {\n+134 | |         const A = MyInt(0b0000_0001u8);\n+135 | |         const B = MyInt(0b0000_0010u8);\n+136 | |         const C = MyInt(0b0000_0100u8);\n+137 | |     }\n+138 | | }\n     | |_^\n     = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a/tests/compile-pass/bitflags_self_in_value.rs b/tests/compile-pass/bitflags_self_in_value.rs\nnew file mode 100644\nindex 00000000..2a9a4a56\n--- /dev/null\n+++ b/tests/compile-pass/bitflags_self_in_value.rs\n@@ -0,0 +1,15 @@\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    pub struct Flags: u32 {\n+        const SOME_FLAG = 1 << Self::SOME_FLAG_SHIFT;\n+    }\n+}\n+\n+impl Flags {\n+    const SOME_FLAG_SHIFT: u32 = 5;\n+}\n+\n+fn main() {\n+    \n+}\ndiff --git a/tests/smoke-test/src/main.rs b/tests/smoke-test/src/main.rs\nindex 9ff4305d..6f84ff33 100644\n--- a/tests/smoke-test/src/main.rs\n+++ b/tests/smoke-test/src/main.rs\n@@ -1,3 +1,5 @@\n+#![deny(warnings)]\n+\n use bitflags::bitflags;\n \n bitflags! {\n", "problem_statement": "Clippy warnings around \"manual implementation of an assign operation\"\nHi.\r\n\r\nI've run into a new clippy lint warnings such as the following:\r\n\r\n> manual implementation of an assign operation\r\n> for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\r\n> `#[warn(clippy::assign_op_pattern)]` on by default\r\n\r\nI'm following the example from the docs page for the use of the macro (more or less, as below). Can you enlighten me as to why this lint notification is appearing here and if there is some way to fix it? I know I can silence the warnings, it's just annoying to see it pop up whenever I run into it.\r\n\r\n```rust\r\nbitflags! {\r\n    pub struct MemoryAccess: u8 {\r\n        /// None.\r\n        const N = 1 << 0;\r\n        /// Public read.\r\n        const R = 1 << 1;\r\n        /// Public write.\r\n        const W = 1 << 2;\r\n        /// Private read.\r\n        const PR = 1 << 3;\r\n        /// Private write.\r\n        const PW = 1 << 4;\r\n        /// Execute.\r\n        const EX = 1 << 5;\r\n    }\r\n}\r\n```\r\n\r\nThanks!\n", "hints_text": "", "created_at": "2023-05-17T11:22:15Z", "version": "2.3", "FAIL_TO_PASS": ["tests/compile-pass/bitflags_self_in_value.rs"], "PASS_TO_PASS": ["tests::bits_types", "tests::into_iter_from_iter_roundtrip", "tests::submodule::test_private", "tests::test_assignment_operators", "tests::test_binary", "tests::test_bits", "tests::test_const_fn", "tests::test_contains", "tests::test_debug", "tests::test_deprecated", "tests::test_display_from_str_roundtrip", "tests::test_empty_does_not_intersect_with_full", "tests::test_empty_bitflags", "tests::test_default", "tests::test_from_bits_retain", "tests::test_from_bits_truncate", "tests::test_from_bits_truncate_edge_cases", "tests::test_from_iterator", "tests::test_from_name", "tests::test_from_str_err", "tests::test_hash", "tests::test_in_function", "tests::test_insert", "tests::test_is_all", "tests::test_is_empty", "tests::test_extend", "tests::test_from_bits_edge_cases", "tests::test_iter", "tests::test_from_bits", "tests::test_lt", "tests::test_lowerhex", "tests::test_octal", "tests::test_disjoint_intersects", "tests::test_operators", "tests::test_ord", "tests::test_overlapping_intersects", "tests::test_pub_crate", "tests::test_pub_in_module", "tests::test_public", "tests::test_set", "tests::test_remove", "tests::test_set_ops_basic", "tests::test_operators_unchecked", "tests::test_set_ops_const", "tests::test_upperhex", "tests::test_u128_bitflags", "tests::test_zero_value_flags", "tests::test_set_ops_unchecked", "tests::test_two_empties_do_not_intersect", "tests::test_set_ops_exhaustive", "basic", "tests/compile-pass/bitflags_nested_value.rs", "tests/compile-pass/bitflags_redefined_value.rs", "tests/compile-pass/bitflags_trait_bound_flags.rs", "tests/compile-pass/bitflags_trait_generic_iter.rs", "tests/compile-pass/bitflags_trait_precedence.rs", "tests/compile-pass/bitflags_trait_supertrait.rs", "tests/compile-pass/bitflags_trait_to_flags.rs", "tests/compile-pass/bitflags_visibility.rs", "tests/compile-pass/deprecated.rs", "tests/compile-pass/doc_alias.rs", "tests/compile-pass/flags_trait_bound_bitflags.rs", "tests/compile-pass/flags_trait_generic_iter.rs", "tests/compile-pass/flags_trait_precedence.rs", "tests/compile-pass/flags_trait_supertrait.rs", "tests/compile-pass/impl_convert_from_bits.rs", "tests/compile-pass/impl_copy.rs", "tests/compile-pass/impl_default.rs", "tests/compile-pass/impl_eq.rs", "tests/compile-pass/impl_fmt.rs", "tests/compile-pass/impl_new.rs", "tests/compile-pass/into_iter_trait_wrapped.rs", "tests/compile-pass/item_positions.rs", "tests/compile-pass/large.rs", "tests/compile-pass/no_prelude.rs", "tests/compile-pass/non_snake_case.rs", "tests/compile-pass/path_based_bits.rs", "tests/compile-pass/repr_c.rs", "tests/compile-pass/repr_transparent.rs", "tests/compile-pass/shadow_core.rs", "tests/compile-pass/shadow_macros.rs"], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
{"repo": "bitflags/bitflags", "pull_number": 351, "instance_id": "bitflags__bitflags-351", "issue_numbers": ["348"], "base_commit": "1d8388bf4ce18afde846d220ad8b6e0dc40aae94", "patch": "diff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\nindex a32e1d55..6ebd5a74 100644\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -10,40 +10,21 @@ permissions:\n \n jobs:\n   check:\n-    name: \"Tests / OS: ${{ matrix.os }} - ${{ matrix.channel }}-${{ matrix.rust_target }}\"\n-    runs-on: ${{ matrix.os }}\n+    name: \"Tests\"\n+    runs-on: ubuntu-latest\n     strategy:\n       matrix:\n-        exclude:\n-        - os: macos-10.15\n-          rust_target: x86_64-gnu\n-        - os: macos-10.15\n-          rust_target: x86_64-msvc\n-        - os: windows-2019\n-          rust_target: x86_64-apple-darwin\n-        - os: ubuntu-20.04\n-          rust_target: x86_64-msvc\n-        - os: ubuntu-20.04\n-          rust_target: x86_64-apple-darwin\n         channel:\n         - stable\n         - beta\n         - nightly\n-        os:\n-        - macos-10.15\n-        - windows-2019\n-        - ubuntu-20.04\n-        rust_target:\n-        - x86_64-gnu\n-        - x86_64-msvc\n-        - x86_64-apple-darwin\n \n     steps:\n     - name: Checkout repository\n       uses: actions/checkout@8e5e7e5ab8b370d6c329ec480221332ada57f0ab\n \n     - name: Install Rust Toolchain\n-      run: rustup default ${{ matrix.channel }}-${{ matrix.rust_target }}\n+      run: rustup default ${{ matrix.channel }}\n \n     - name: Install cargo-hack\n       run: cargo install cargo-hack\n@@ -87,6 +68,19 @@ jobs:\n           cd ./tests/smoke-test\n           cargo +$msrv build\n \n+  mips:\n+    name: Tests / MIPS (Big Endian)\n+    runs-on: ubuntu-latest\n+    steps:\n+      - name: Checkout sources\n+        uses: actions/checkout@8e5e7e5ab8b370d6c329ec480221332ada57f0ab\n+\n+      - name: Install Cross\n+        run: cargo install cross\n+\n+      - name: Default features\n+        run: cross test --target mips-unknown-linux-gnu\n+\n   embedded:\n     name: Build (embedded)\n     runs-on: ubuntu-latest\ndiff --git a/Cargo.toml b/Cargo.toml\nindex a2391324..5ff8cf23 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -32,6 +32,7 @@ rustversion = \"1.0\"\n serde_derive = \"1.0\"\n serde_json = \"1.0\"\n serde_test = \"1.0\"\n+zerocopy = \"0.6\"\n arbitrary = { version = \"1.0\", features = [\"derive\"] }\n bytemuck = { version = \"1.0\", features = [\"derive\"] }\n \ndiff --git a/examples/custom_bits_type.rs b/examples/custom_bits_type.rs\nnew file mode 100644\nindex 00000000..0364a2bd\n--- /dev/null\n+++ b/examples/custom_bits_type.rs\n@@ -0,0 +1,85 @@\n+use std::ops::{BitAnd, BitOr, BitXor, Not};\n+\n+use bitflags::{Flags, Flag, Bits};\n+\n+// Define a custom container that can be used in flags types\n+// Note custom bits types can't be used in `bitflags!`\n+// without making the trait impls `const`. This is currently\n+// unstable\n+#[derive(Clone, Copy, Debug)]\n+pub struct CustomBits([bool; 3]);\n+\n+impl Bits for CustomBits {\n+    const EMPTY: Self = CustomBits([false; 3]);\n+\n+    const ALL: Self = CustomBits([true; 3]);\n+}\n+\n+impl PartialEq for CustomBits {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.0 == other.0\n+    }\n+}\n+\n+impl BitAnd for CustomBits {\n+    type Output = Self;\n+\n+    fn bitand(self, other: Self) -> Self {\n+        CustomBits([self.0[0] & other.0[0], self.0[1] & other.0[1], self.0[2] & other.0[2]])\n+    }\n+}\n+\n+impl BitOr for CustomBits {\n+    type Output = Self;\n+\n+    fn bitor(self, other: Self) -> Self {\n+        CustomBits([self.0[0] | other.0[0], self.0[1] | other.0[1], self.0[2] | other.0[2]])\n+    }\n+}\n+\n+impl BitXor for CustomBits {\n+    type Output = Self;\n+\n+    fn bitxor(self, other: Self) -> Self {\n+        CustomBits([self.0[0] & other.0[0], self.0[1] & other.0[1], self.0[2] & other.0[2]])\n+    }\n+}\n+\n+impl Not for CustomBits {\n+    type Output = Self;\n+\n+    fn not(self) -> Self {\n+        CustomBits([!self.0[0], !self.0[1], !self.0[2]])\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct CustomFlags(CustomBits);\n+\n+impl CustomFlags {\n+    pub const A: Self = CustomFlags(CustomBits([true, false, false]));\n+    pub const B: Self = CustomFlags(CustomBits([false, true, false]));\n+    pub const C: Self = CustomFlags(CustomBits([false, false, true]));\n+}\n+\n+impl Flags for CustomFlags {\n+    const FLAGS: &'static [Flag<Self>] = &[\n+        Flag::new(\"A\", Self::A),\n+        Flag::new(\"B\", Self::B),\n+        Flag::new(\"C\", Self::C),\n+    ];\n+\n+    type Bits = CustomBits;\n+\n+    fn bits(&self) -> Self::Bits {\n+        self.0\n+    }\n+\n+    fn from_bits_retain(bits: Self::Bits) -> Self {\n+        CustomFlags(bits)\n+    }\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", CustomFlags::A.union(CustomFlags::C));\n+}\ndiff --git a/examples/custom_derive.rs b/examples/custom_derive.rs\nnew file mode 100644\nindex 00000000..5a85afb9\n--- /dev/null\n+++ b/examples/custom_derive.rs\n@@ -0,0 +1,23 @@\n+//! An example of implementing the `BitFlags` trait manually for a flags type.\n+\n+use std::str;\n+\n+use bitflags::bitflags;\n+\n+// Define a flags type outside of the `bitflags` macro as a newtype\n+// It can accept custom derives for libaries `bitflags` doesn't support natively\n+#[derive(zerocopy::AsBytes, zerocopy::FromBytes)]\n+#[repr(transparent)]\n+pub struct ManualFlags(u32);\n+\n+// Next: use `impl Flags` instead of `struct Flags`\n+bitflags! {\n+    impl ManualFlags: u32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+        const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n+    }\n+}\n+\n+fn main() {}\ndiff --git a/examples/fmt.rs b/examples/fmt.rs\nindex 3bb9b8c4..724b2074 100644\n--- a/examples/fmt.rs\n+++ b/examples/fmt.rs\n@@ -2,40 +2,40 @@\n \n use core::{fmt, str};\n \n-fn main() -> Result<(), bitflags::parser::ParseError> {\n-    bitflags::bitflags! {\n-        // You can `#[derive]` the `Debug` trait, but implementing it manually\n-        // can produce output like `A | B` instead of `Flags(A | B)`.\n-        // #[derive(Debug)]\n-        #[derive(PartialEq, Eq)]\n-        pub struct Flags: u32 {\n-            const A = 1;\n-            const B = 2;\n-            const C = 4;\n-            const D = 8;\n-        }\n+bitflags::bitflags! {\n+    // You can `#[derive]` the `Debug` trait, but implementing it manually\n+    // can produce output like `A | B` instead of `Flags(A | B)`.\n+    // #[derive(Debug)]\n+    #[derive(PartialEq, Eq)]\n+    pub struct Flags: u32 {\n+        const A = 1;\n+        const B = 2;\n+        const C = 4;\n+        const D = 8;\n     }\n+}\n \n-    impl fmt::Debug for Flags {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            fmt::Debug::fmt(&self.0, f)\n-        }\n+impl fmt::Debug for Flags {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        bitflags::parser::to_writer(self, f)\n     }\n+}\n \n-    impl fmt::Display for Flags {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            fmt::Display::fmt(&self.0, f)\n-        }\n+impl fmt::Display for Flags {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        bitflags::parser::to_writer(self, f)\n     }\n+}\n \n-    impl str::FromStr for Flags {\n-        type Err = bitflags::parser::ParseError;\n+impl str::FromStr for Flags {\n+    type Err = bitflags::parser::ParseError;\n \n-        fn from_str(flags: &str) -> Result<Self, Self::Err> {\n-            Ok(Self(flags.parse()?))\n-        }\n+    fn from_str(flags: &str) -> Result<Self, Self::Err> {\n+        bitflags::parser::from_str(flags)\n     }\n+}\n \n+fn main() -> Result<(), bitflags::parser::ParseError> {\n     let flags = Flags::A | Flags::B;\n \n     println!(\"{}\", flags);\ndiff --git a/examples/macro_free.rs b/examples/macro_free.rs\nnew file mode 100644\nindex 00000000..ec3a8cb5\n--- /dev/null\n+++ b/examples/macro_free.rs\n@@ -0,0 +1,58 @@\n+//! An example of implementing the `BitFlags` trait manually for a flags type.\n+//!\n+//! This example doesn't use any macros.\n+\n+use std::{fmt, str};\n+\n+use bitflags::{Flags, Flag};\n+\n+// First: Define your flags type. It just needs to be `Sized + 'static`.\n+pub struct ManualFlags(u32);\n+\n+// Not required: Define some constants for valid flags\n+impl ManualFlags {\n+    pub const A: ManualFlags = ManualFlags(0b00000001);\n+    pub const B: ManualFlags = ManualFlags(0b00000010);\n+    pub const C: ManualFlags = ManualFlags(0b00000100);\n+    pub const ABC: ManualFlags = ManualFlags(0b00000111);\n+}\n+\n+// Next: Implement the `BitFlags` trait, specifying your set of valid flags\n+// and iterators\n+impl Flags for ManualFlags {\n+    const FLAGS: &'static [Flag<Self>] = &[\n+        Flag::new(\"A\", Self::A),\n+        Flag::new(\"B\", Self::B),\n+        Flag::new(\"C\", Self::C),\n+    ];\n+\n+    type Bits = u32;\n+\n+    fn bits(&self) -> u32 {\n+        self.0\n+    }\n+\n+    fn from_bits_retain(bits: u32) -> Self {\n+        Self(bits)\n+    }\n+}\n+\n+// Not required: Add parsing support\n+impl str::FromStr for ManualFlags {\n+    type Err = bitflags::parser::ParseError;\n+\n+    fn from_str(input: &str) -> Result<Self, Self::Err> {\n+        bitflags::parser::from_str(input)\n+    }\n+}\n+\n+// Not required: Add formatting support\n+impl fmt::Display for ManualFlags {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        bitflags::parser::to_writer(self, f)\n+    }\n+}\n+\n+fn main() {\n+    println!(\"{}\", ManualFlags::A.union(ManualFlags::B).union(ManualFlags::C));\n+}\ndiff --git a/src/example_generated.rs b/src/example_generated.rs\nindex b7589014..0fda40c0 100644\n--- a/src/example_generated.rs\n+++ b/src/example_generated.rs\n@@ -9,30 +9,41 @@ __declare_public_bitflags! {\n     /// This is the same `Flags` struct defined in the [crate level example](../index.html#example).\n     /// Note that this struct is just for documentation purposes only, it must not be used outside\n     /// this crate.\n-    pub struct Flags;\n+    pub struct Flags\n }\n \n __declare_internal_bitflags! {\n-    pub struct Field0: u32;\n-    pub struct Iter;\n-    pub struct IterRaw;\n+    pub struct Field0: u32\n }\n \n __impl_internal_bitflags! {\n-    Field0: u32, Flags, Iter, IterRaw {\n-        A;\n-        B;\n-        C;\n-        ABC;\n+    Field0: u32, Flags {\n+        // Field `A`.\n+        ///\n+        /// This flag has the value `0b00000001`.\n+        A = 0b00000001;\n+        /// Field `B`.\n+        ///\n+        /// This flag has the value `0b00000010`.\n+        B = 0b00000010;\n+        /// Field `C`.\n+        ///\n+        /// This flag has the value `0b00000100`.\n+        C = 0b00000100;\n+        ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n     }\n }\n \n-__impl_public_bitflags! {\n-    Flags: u32, Field0, Iter, IterRaw;\n+__impl_public_bitflags_forward! {\n+    Flags: u32, Field0\n+}\n+\n+__impl_public_bitflags_iter! {\n+    Flags\n }\n \n __impl_public_bitflags_consts! {\n-    Flags {\n+    Flags: u32 {\n         /// Field `A`.\n         ///\n         /// This flag has the value `0b00000001`.\ndiff --git a/src/external.rs b/src/external.rs\nindex 6b07ff64..f3fbac0d 100644\n--- a/src/external.rs\n+++ b/src/external.rs\n@@ -5,7 +5,13 @@ How do I support a new external library?\n \n Let's say we want to add support for `my_library`.\n \n-First, we define a macro like so:\n+First, we create a module under `external`, like `serde` with any specialized code.\n+Ideally, any utilities in here should just work off the `Flags` trait and maybe a\n+few other assumed bounds.\n+\n+Next, re-export the library from the `__private` module here.\n+\n+Next, define a macro like so:\n \n ```rust\n #[macro_export(local_inner_macros)]\n@@ -57,27 +63,78 @@ __impl_external_bitflags_my_library! {\n     }\n }\n ```\n+*/\n \n-What about libraries that _must_ be supported through `#[derive]`?\n+pub(crate) mod __private {\n+    #[cfg(feature = \"serde\")]\n+    pub use serde;\n \n-In these cases, the attributes will need to be added to the `__declare_internal_bitflags` macro when\n-the internal type is declared.\n-*/\n+    #[cfg(feature = \"arbitrary\")]\n+    pub use arbitrary;\n+\n+    #[cfg(feature = \"bytemuck\")]\n+    pub use bytemuck;\n+}\n \n #[cfg(feature = \"serde\")]\n-pub mod serde_support;\n+pub mod serde;\n+\n+/// Implement `Serialize` and `Deserialize` for the internal bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n #[cfg(feature = \"serde\")]\n-pub use serde;\n+macro_rules! __impl_external_bitflags_serde {\n+    (\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+                )*\n+        }\n+    ) => {\n+        impl $crate::__private::serde::Serialize for $InternalBitFlags {\n+            fn serialize<S: $crate::__private::serde::Serializer>(\n+                &self,\n+                serializer: S,\n+            ) -> $crate::__private::core::result::Result<S::Ok, S::Error> {\n+                $crate::serde::serialize(\n+                    self,\n+                    serializer,\n+                )\n+            }\n+        }\n+\n+        impl<'de> $crate::__private::serde::Deserialize<'de> for $InternalBitFlags {\n+            fn deserialize<D: $crate::__private::serde::Deserializer<'de>>(\n+                deserializer: D,\n+            ) -> $crate::__private::core::result::Result<Self, D::Error> {\n+                $crate::serde::deserialize(\n+                    deserializer,\n+                )\n+            }\n+        }\n+    };\n+}\n+\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+#[cfg(not(feature = \"serde\"))]\n+macro_rules! __impl_external_bitflags_serde {\n+    (\n+        $InternalBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+                )*\n+        }\n+    ) => {};\n+}\n \n #[cfg(feature = \"arbitrary\")]\n-pub mod arbitrary_support;\n-#[cfg(feature = \"arbitrary\")]\n-pub use arbitrary;\n+pub mod arbitrary;\n \n #[cfg(feature = \"bytemuck\")]\n-pub mod bytemuck_support;\n-#[cfg(feature = \"bytemuck\")]\n-pub use bytemuck;\n+mod bytemuck;\n \n /// Implements traits from external libraries for the internal bitflags type.\n #[macro_export(local_inner_macros)]\n@@ -124,57 +181,6 @@ macro_rules! __impl_external_bitflags {\n     };\n }\n \n-/// Implement `Serialize` and `Deserialize` for the internal bitflags type.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-#[cfg(feature = \"serde\")]\n-macro_rules! __impl_external_bitflags_serde {\n-    (\n-        $InternalBitFlags:ident: $T:ty {\n-            $(\n-                $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident;\n-            )*\n-        }\n-    ) => {\n-        impl $crate::__private::serde::Serialize for $InternalBitFlags {\n-            fn serialize<S: $crate::__private::serde::Serializer>(\n-                &self,\n-                serializer: S,\n-            ) -> $crate::__private::core::result::Result<S::Ok, S::Error> {\n-                $crate::__private::serde_support::serialize_bits_default::<$InternalBitFlags, $T, S>(\n-                    &self,\n-                    serializer,\n-                )\n-            }\n-        }\n-\n-        impl<'de> $crate::__private::serde::Deserialize<'de> for $InternalBitFlags {\n-            fn deserialize<D: $crate::__private::serde::Deserializer<'de>>(\n-                deserializer: D,\n-            ) -> $crate::__private::core::result::Result<Self, D::Error> {\n-                $crate::__private::serde_support::deserialize_bits_default::<$InternalBitFlags, $T, D>(\n-                    deserializer,\n-                )\n-            }\n-        }\n-    };\n-}\n-\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-#[cfg(not(feature = \"serde\"))]\n-macro_rules! __impl_external_bitflags_serde {\n-    (\n-        $InternalBitFlags:ident: $T:ty {\n-            $(\n-                $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident;\n-            )*\n-        }\n-    ) => {};\n-}\n-\n /// Implement `Arbitrary` for the internal bitflags type.\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n@@ -192,7 +198,7 @@ macro_rules! __impl_external_bitflags_arbitrary {\n             fn arbitrary(\n                 u: &mut $crate::__private::arbitrary::Unstructured<'a>,\n             ) -> $crate::__private::arbitrary::Result<Self> {\n-                Self::from_bits(u.arbitrary()?).ok_or_else(|| $crate::__private::arbitrary::Error::IncorrectFormat)\n+                $crate::arbitrary::arbitrary(u)\n             }\n         }\n     };\ndiff --git a/src/external/arbitrary_support.rs b/src/external/arbitrary.rs\nsimilarity index 54%\nrename from src/external/arbitrary_support.rs\nrename to src/external/arbitrary.rs\nindex 56708f01..ae59677a 100644\n--- a/src/external/arbitrary_support.rs\n+++ b/src/external/arbitrary.rs\n@@ -1,3 +1,17 @@\n+//! Specialized fuzzing for flags types using `arbitrary`.\n+\n+use crate::Flags;\n+\n+/// Get a random known flags value.\n+pub fn arbitrary<'a, B: Flags>(\n+    u: &mut arbitrary::Unstructured<'a>,\n+) -> arbitrary::Result<B>\n+where\n+    B::Bits: arbitrary::Arbitrary<'a>\n+{\n+    B::from_bits(u.arbitrary()?).ok_or_else(|| arbitrary::Error::IncorrectFormat)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use arbitrary::Arbitrary;\ndiff --git a/src/external/bytemuck_support.rs b/src/external/bytemuck.rs\nsimilarity index 100%\nrename from src/external/bytemuck_support.rs\nrename to src/external/bytemuck.rs\ndiff --git a/src/external/serde_support.rs b/src/external/serde.rs\nsimilarity index 64%\nrename from src/external/serde_support.rs\nrename to src/external/serde.rs\nindex 7c202a29..bc1f2ece 100644\n--- a/src/external/serde_support.rs\n+++ b/src/external/serde.rs\n@@ -1,59 +1,66 @@\n+//! Specialized serialization for flags types using `serde`.\n+\n use core::{fmt, str};\n+use crate::{Flags, parser::{self, ParseHex, WriteHex}};\n use serde::{\n     de::{Error, Visitor},\n     Deserialize, Deserializer, Serialize, Serializer,\n };\n \n-pub fn serialize_bits_default<T: fmt::Display + AsRef<B>, B: Serialize, S: Serializer>(\n-    flags: &T,\n+/// Serialize a set of flags as a human-readable string or their underlying bits.\n+pub fn serialize<B: Flags, S: Serializer>(\n+    flags: &B,\n     serializer: S,\n-) -> Result<S::Ok, S::Error> {\n+) -> Result<S::Ok, S::Error>\n+where\n+    B::Bits: WriteHex + Serialize,\n+{\n     // Serialize human-readable flags as a string like `\"A | B\"`\n     if serializer.is_human_readable() {\n-        serializer.collect_str(flags)\n+        serializer.collect_str(&parser::AsDisplay(flags))\n     }\n     // Serialize non-human-readable flags directly as the underlying bits\n     else {\n-        flags.as_ref().serialize(serializer)\n+        flags.bits().serialize(serializer)\n     }\n }\n \n-pub fn deserialize_bits_default<\n+/// Deserialize a set of flags from a human-readable string or their underlying bits.\n+pub fn deserialize<\n     'de,\n-    T: str::FromStr + From<B>,\n-    B: Deserialize<'de>,\n+    B: Flags,\n     D: Deserializer<'de>,\n >(\n     deserializer: D,\n-) -> Result<T, D::Error>\n+) -> Result<B, D::Error>\n where\n-    <T as str::FromStr>::Err: fmt::Display,\n+    B::Bits: ParseHex + Deserialize<'de>,\n {\n     if deserializer.is_human_readable() {\n         // Deserialize human-readable flags by parsing them from strings like `\"A | B\"`\n-        struct FlagsVisitor<T>(core::marker::PhantomData<T>);\n+        struct FlagsVisitor<B>(core::marker::PhantomData<B>);\n \n-        impl<'de, T: str::FromStr> Visitor<'de> for FlagsVisitor<T>\n+        impl<'de, B: Flags> Visitor<'de> for FlagsVisitor<B>\n         where\n-            <T as str::FromStr>::Err: fmt::Display,\n+            B::Bits: ParseHex,\n         {\n-            type Value = T;\n+            type Value = B;\n \n             fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 formatter.write_str(\"a string value of `|` separated flags\")\n             }\n \n             fn visit_str<E: Error>(self, flags: &str) -> Result<Self::Value, E> {\n-                flags.parse().map_err(|e| E::custom(e))\n+                parser::from_str(flags).map_err(|e| E::custom(e))\n             }\n         }\n \n         deserializer.deserialize_str(FlagsVisitor(Default::default()))\n     } else {\n         // Deserialize non-human-readable flags directly from the underlying bits\n-        let bits = B::deserialize(deserializer)?;\n+        let bits = B::Bits::deserialize(deserializer)?;\n \n-        Ok(bits.into())\n+        Ok(B::from_bits_retain(bits))\n     }\n }\n \ndiff --git a/src/internal.rs b/src/internal.rs\nindex eca0a304..8347b03f 100644\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -10,29 +10,14 @@\n #[doc(hidden)]\n macro_rules! __declare_internal_bitflags {\n     (\n-        $vis:vis struct $InternalBitFlags:ident: $T:ty;\n-        $iter_vis:vis struct $Iter:ident;\n-        $iter_names_vis:vis struct $IterNames:ident;\n+        $vis:vis struct $InternalBitFlags:ident: $T:ty\n     ) => {\n         // NOTE: The ABI of this type is _guaranteed_ to be the same as `T`\n         // This is relied on by some external libraries like `bytemuck` to make\n         // its `unsafe` trait impls sound.\n         #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n         #[repr(transparent)]\n-        $vis struct $InternalBitFlags {\n-            bits: $T,\n-        }\n-\n-        $iter_vis struct $Iter {\n-            inner: $IterNames,\n-            done: bool,\n-        }\n-\n-        $iter_names_vis struct $IterNames {\n-            idx: usize,\n-            source: $InternalBitFlags,\n-            state: $InternalBitFlags,\n-        }\n+        $vis struct $InternalBitFlags($T);\n     };\n }\n \n@@ -44,14 +29,18 @@ macro_rules! __declare_internal_bitflags {\n #[doc(hidden)]\n macro_rules! __impl_internal_bitflags {\n     (\n-        $InternalBitFlags:ident: $T:ty, $BitFlags:ident, $Iter:ident, $IterNames:ident {\n+        $InternalBitFlags:ident: $T:ty, $PublicBitFlags:ident {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident;\n+                $Flag:ident = $value:expr;\n             )*\n         }\n     ) => {\n-        impl $crate::__private::PublicFlags for $BitFlags {\n+        // NOTE: This impl is also used to prevent using bits types from non-primitive types\n+        // in the `bitflags` macro. If this approach is changed, this guard will need to be\n+        // retained somehow\n+        impl $crate::__private::PublicFlags for $PublicBitFlags {\n+            type Primitive = $T;\n             type Internal = $InternalBitFlags;\n         }\n \n@@ -73,7 +62,7 @@ macro_rules! __impl_internal_bitflags {\n                     // We can remove this `0x0` and remain compatible with `FromStr`,\n                     // because an empty string will still parse to an empty set of flags,\n                     // just like `0x0` does.\n-                    $crate::__private::core::write!(f, \"{:#x}\", <$T as $crate::__private::Bits>::EMPTY)\n+                    $crate::__private::core::write!(f, \"{:#x}\", <$T as $crate::Bits>::EMPTY)\n                 } else {\n                     $crate::__private::core::fmt::Display::fmt(self, f)\n                 }\n@@ -82,489 +71,74 @@ macro_rules! __impl_internal_bitflags {\n \n         impl $crate::__private::core::fmt::Display for $InternalBitFlags {\n             fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter<'_>) -> $crate::__private::core::fmt::Result {\n-                // A formatter for bitflags that produces text output like:\n-                //\n-                // A | B | 0xf6\n-                //\n-                // The names of set flags are written in a bar-separated-format,\n-                // followed by a hex number of any remaining bits that are set\n-                // but don't correspond to any flags.\n-\n-                // Iterate over the valid flags\n-                let mut first = true;\n-                let mut iter = self.iter_names();\n-                for (name, _) in &mut iter {\n-                    if !first {\n-                        f.write_str(\" | \")?;\n-                    }\n-\n-                    first = false;\n-                    f.write_str(name)?;\n-                }\n-\n-                // Append any extra bits that correspond to flags to the end of the format\n-                let extra_bits = iter.state.bits();\n-                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n-                    if !first {\n-                        f.write_str(\" | \")?;\n-                    }\n-\n-                    $crate::__private::core::write!(f, \"{:#x}\", extra_bits)?;\n-                }\n-\n-                $crate::__private::core::fmt::Result::Ok(())\n+                $crate::parser::to_writer(&$PublicBitFlags(*self), f)\n             }\n         }\n \n-        // The impl for `FromStr` should parse anything produced by `Display`\n         impl $crate::__private::core::str::FromStr for $InternalBitFlags {\n             type Err = $crate::parser::ParseError;\n \n             fn from_str(s: &str) -> $crate::__private::core::result::Result<Self, Self::Err> {\n-                let s = s.trim();\n-\n-                let mut parsed_flags = Self::empty();\n-\n-                // If the input is empty then return an empty set of flags\n-                if s.is_empty() {\n-                    return $crate::__private::core::result::Result::Ok(parsed_flags);\n-                }\n-\n-                for flag in s.split('|') {\n-                    let flag = flag.trim();\n-\n-                    // If the flag is empty then we've got missing input\n-                    if flag.is_empty() {\n-                        return $crate::__private::core::result::Result::Err($crate::parser::ParseError::empty_flag());\n-                    }\n-\n-                    // If the flag starts with `0x` then it's a hex number\n-                    // Parse it directly to the underlying bits type\n-                    let parsed_flag = if let $crate::__private::core::option::Option::Some(flag) = flag.strip_prefix(\"0x\") {\n-                        let bits = <$T>::from_str_radix(flag, 16).map_err(|_| $crate::parser::ParseError::invalid_hex_flag(flag))?;\n-\n-                        Self::from_bits_retain(bits)\n-                    }\n-                    // Otherwise the flag is a name\n-                    // The generated flags type will determine whether\n-                    // or not it's a valid identifier\n-                    else {\n-                        Self::from_name(flag).ok_or_else(|| $crate::parser::ParseError::invalid_named_flag(flag))?\n-                    };\n-\n-                    parsed_flags.insert(parsed_flag);\n-                }\n-\n-                $crate::__private::core::result::Result::Ok(parsed_flags)\n-            }\n-        }\n-\n-        impl $crate::__private::core::fmt::Binary for $InternalBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Binary::fmt(&self.bits(), f)\n+                $crate::parser::from_str::<$PublicBitFlags>(s).map(|flags| flags.0)\n             }\n         }\n \n-        impl $crate::__private::core::fmt::Octal for $InternalBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Octal::fmt(&self.bits(), f)\n-            }\n-        }\n-\n-        impl $crate::__private::core::fmt::LowerHex for $InternalBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::LowerHex::fmt(&self.bits(), f)\n+        impl $crate::__private::core::convert::AsRef<$T> for $InternalBitFlags {\n+            fn as_ref(&self) -> &$T {\n+                &self.0\n             }\n         }\n \n-        impl $crate::__private::core::fmt::UpperHex for $InternalBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::UpperHex::fmt(&self.bits(), f)\n+        impl $crate::__private::core::convert::From<$T> for $InternalBitFlags {\n+            fn from(bits: $T) -> Self {\n+                Self::from_bits_retain(bits)\n             }\n         }\n \n-        impl $InternalBitFlags {\n-            #[inline]\n-            pub const fn empty() -> Self {\n-                Self { bits: <$T as $crate::__private::Bits>::EMPTY }\n-            }\n-\n-            #[inline]\n-            pub const fn all() -> Self {\n-                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)\n-            }\n-\n-            #[inline]\n-            pub const fn bits(&self) -> $T {\n-                self.bits\n-            }\n-\n-            #[inline]\n-            pub fn bits_mut(&mut self) -> &mut $T {\n-                &mut self.bits\n-            }\n-\n-            #[inline]\n-            pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n-                let truncated = Self::from_bits_truncate(bits).bits;\n-\n-                if truncated == bits {\n-                    $crate::__private::core::option::Option::Some(Self { bits })\n-                } else {\n-                    $crate::__private::core::option::Option::None\n-                }\n-            }\n-\n-            #[inline]\n-            pub const fn from_bits_truncate(bits: $T) -> Self {\n-                if bits == <$T as $crate::__private::Bits>::EMPTY {\n-                    return Self { bits }\n-                }\n-\n-                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n+        // The internal flags type offers a similar API to the public one\n \n+        __impl_public_bitflags! {\n+            $InternalBitFlags: $T {\n                 $(\n-                    __expr_safe_flags!(\n-                        $(#[$attr $($args)*])*\n-                        {\n-                            if bits & $BitFlags::$Flag.bits() == $BitFlags::$Flag.bits() {\n-                                truncated |= $BitFlags::$Flag.bits()\n-                            }\n-                        }\n-                    );\n+                    $(#[$attr $($args)*])*\n+                    $Flag;\n                 )*\n-\n-                Self { bits: truncated }\n-            }\n-\n-            #[inline]\n-            pub const fn from_bits_retain(bits: $T) -> Self {\n-                Self { bits }\n             }\n+        }\n \n-            #[inline]\n-            pub fn from_name(name: &str) -> $crate::__private::core::option::Option<Self> {\n+        __impl_public_bitflags_consts! {\n+            $InternalBitFlags: $T {\n                 $(\n-                    __expr_safe_flags!(\n-                        $(#[$attr $($args)*])*\n-                        {\n-                            if name == $crate::__private::core::stringify!($Flag) {\n-                                return $crate::__private::core::option::Option::Some(Self { bits: $BitFlags::$Flag.bits() });\n-                            }\n-                        }\n-                    );\n+                    $(#[$attr $($args)*])*\n+                    #[allow(\n+                        dead_code,\n+                        deprecated,\n+                        unused_attributes,\n+                        non_upper_case_globals\n+                    )]\n+                    $Flag = $value;\n                 )*\n-\n-                let _ = name;\n-                $crate::__private::core::option::Option::None\n-            }\n-\n-            #[inline]\n-            pub const fn iter(&self) -> $Iter {\n-                $Iter {\n-                    inner: self.iter_names(),\n-                    done: false,\n-                }\n-            }\n-\n-            #[inline]\n-            pub const fn iter_names(&self) -> $IterNames {\n-                $IterNames {\n-                    idx: 0,\n-                    source: *self,\n-                    state: *self,\n-                }\n-            }\n-\n-            #[inline]\n-            pub const fn is_empty(&self) -> bool {\n-                self.bits == Self::empty().bits\n-            }\n-\n-            #[inline]\n-            pub const fn is_all(&self) -> bool {\n-                Self::all().bits | self.bits == self.bits\n-            }\n-\n-            #[inline]\n-            pub const fn intersects(&self, other: Self) -> bool {\n-                !(Self { bits: self.bits & other.bits}).is_empty()\n-            }\n-\n-            #[inline]\n-            pub const fn contains(&self, other: Self) -> bool {\n-                (self.bits & other.bits) == other.bits\n-            }\n-\n-            #[inline]\n-            pub fn insert(&mut self, other: Self) {\n-                self.bits |= other.bits;\n-            }\n-\n-            #[inline]\n-            pub fn remove(&mut self, other: Self) {\n-                self.bits &= !other.bits;\n-            }\n-\n-            #[inline]\n-            pub fn toggle(&mut self, other: Self) {\n-                self.bits ^= other.bits;\n-            }\n-\n-            #[inline]\n-            pub fn set(&mut self, other: Self, value: bool) {\n-                if value {\n-                    self.insert(other);\n-                } else {\n-                    self.remove(other);\n-                }\n-            }\n-\n-            #[inline]\n-            #[must_use]\n-            pub const fn intersection(self, other: Self) -> Self {\n-                Self { bits: self.bits & other.bits }\n-            }\n-\n-            #[inline]\n-            #[must_use]\n-            pub const fn union(self, other: Self) -> Self {\n-                Self { bits: self.bits | other.bits }\n             }\n+        }\n \n+        impl $InternalBitFlags {\n+            /// Returns a mutable reference to the raw value of the flags currently stored.\n             #[inline]\n-            #[must_use]\n-            pub const fn difference(self, other: Self) -> Self {\n-                Self { bits: self.bits & !other.bits }\n+            pub fn bits_mut(&mut self) -> &mut $T {\n+                &mut self.0\n             }\n \n+            /// Iterate over enabled flag values.\n             #[inline]\n-            #[must_use]\n-            pub const fn symmetric_difference(self, other: Self) -> Self {\n-                Self { bits: self.bits ^ other.bits }\n+            pub const fn iter(&self) -> $crate::iter::Iter<$PublicBitFlags> {\n+                $crate::iter::Iter::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.0), $PublicBitFlags::from_bits_retain(self.0))\n             }\n \n+            /// Iterate over enabled flag values with their stringified names.\n             #[inline]\n-            #[must_use]\n-            pub const fn complement(self) -> Self {\n-                Self::from_bits_truncate(!self.bits)\n-            }\n-        }\n-\n-        impl $crate::__private::core::convert::AsRef<$T> for $InternalBitFlags {\n-            fn as_ref(&self) -> &$T {\n-                &self.bits\n-            }\n-        }\n-\n-        impl $crate::__private::core::convert::From<$T> for $InternalBitFlags {\n-            fn from(bits: $T) -> Self {\n-                Self::from_bits_retain(bits)\n-            }\n-        }\n-\n-        impl $crate::__private::core::iter::Iterator for $Iter {\n-            type Item = $BitFlags;\n-\n-            fn next(&mut self) -> $crate::__private::core::option::Option<Self::Item> {\n-                match self.inner.next().map(|(_, value)| value) {\n-                    $crate::__private::core::option::Option::Some(value) => $crate::__private::core::option::Option::Some(value),\n-                    $crate::__private::core::option::Option::None if !self.done => {\n-                        self.done = true;\n-\n-                        // After iterating through valid names, if there are any bits left over\n-                        // then return one final value that includes them. This makes `into_iter`\n-                        // and `from_iter` roundtrip\n-                        if self.inner.state != $InternalBitFlags::empty() {\n-                            $crate::__private::core::option::Option::Some($BitFlags::from_bits_retain(self.inner.state.bits()))\n-                        } else {\n-                            $crate::__private::core::option::Option::None\n-                        }\n-                    },\n-                    _ => $crate::__private::core::option::Option::None,\n-                }\n-            }\n-        }\n-\n-        impl $crate::__private::core::iter::Iterator for $IterNames {\n-            type Item = (&'static str, $BitFlags);\n-\n-            fn next(&mut self) -> $crate::__private::core::option::Option<Self::Item> {\n-                const NUM_FLAGS: usize = {\n-                    let mut num_flags = 0;\n-\n-                    $(\n-                        __expr_safe_flags!(\n-                            $(#[$attr $($args)*])*\n-                            {\n-                                { num_flags += 1; }\n-                            }\n-                        );\n-                    )*\n-\n-                    num_flags\n-                };\n-\n-                const OPTIONS: [$T; NUM_FLAGS] = [\n-                    $(\n-                        __expr_safe_flags!(\n-                            $(#[$attr $($args)*])*\n-                            {\n-                                $BitFlags::$Flag.bits()\n-                            }\n-                        ),\n-                    )*\n-                ];\n-\n-                const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n-                    $(\n-                        __expr_safe_flags!(\n-                            $(#[$attr $($args)*])*\n-                            {\n-                                $crate::__private::core::stringify!($Flag)\n-                            }\n-                        ),\n-                    )*\n-                ];\n-\n-                if self.state.is_empty() || NUM_FLAGS == 0 {\n-                    $crate::__private::core::option::Option::None\n-                } else {\n-                    #[allow(clippy::indexing_slicing)]\n-                    for (flag, flag_name) in OPTIONS[self.idx..NUM_FLAGS].iter().copied()\n-                        .zip(OPTIONS_NAMES[self.idx..NUM_FLAGS].iter().copied())\n-                    {\n-                        self.idx += 1;\n-\n-                        // NOTE: We check whether the flag exists in self, but remove it from\n-                        // a different value. This ensure that overlapping flags are handled\n-                        // properly. Take the following example:\n-                        //\n-                        // const A: 0b00000001;\n-                        // const B: 0b00000101;\n-                        //\n-                        // Given the bits 0b00000101, both A and B are set. But if we removed A\n-                        // as we encountered it we'd be left with 0b00000100, which doesn't\n-                        // correspond to a valid flag on its own.\n-                        if self.source.contains($InternalBitFlags { bits: flag }) {\n-                            self.state.remove($InternalBitFlags { bits: flag });\n-\n-                            return $crate::__private::core::option::Option::Some((flag_name, $BitFlags::from_bits_retain(flag)))\n-                        }\n-                    }\n-\n-                    $crate::__private::core::option::Option::None\n-                }\n+            pub const fn iter_names(&self) -> $crate::iter::IterNames<$PublicBitFlags> {\n+                $crate::iter::IterNames::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.0), $PublicBitFlags::from_bits_retain(self.0))\n             }\n         }\n     };\n }\n-\n-/// A macro that processed the input to `bitflags!` and shuffles attributes around\n-/// based on whether or not they're \"expression-safe\".\n-///\n-/// This macro is a token-tree muncher that works on 2 levels:\n-///\n-/// For each attribute, we explicitly match on its identifier, like `cfg` to determine\n-/// whether or not it should be considered expression-safe.\n-///\n-/// If you find yourself with an attribute that should be considered expression-safe\n-/// and isn't, it can be added here.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-macro_rules! __expr_safe_flags {\n-    // Entrypoint: Move all flags and all attributes into `unprocessed` lists\n-    // where they'll be munched one-at-a-time\n-    (\n-        $(#[$inner:ident $($args:tt)*])*\n-        { $e:expr }\n-    ) => {\n-        __expr_safe_flags! {\n-            expr: { $e },\n-            attrs: {\n-                // All attributes start here\n-                unprocessed: [$(#[$inner $($args)*])*],\n-                processed: {\n-                    // Attributes that are safe on expressions go here\n-                    expr: [],\n-                },\n-            },\n-        }\n-    };\n-    // Process the next attribute on the current flag\n-    // `cfg`: The next flag should be propagated to expressions\n-    // NOTE: You can copy this rules block and replace `cfg` with\n-    // your attribute name that should be considered expression-safe\n-    (\n-        expr: { $e:expr },\n-            attrs: {\n-            unprocessed: [\n-                // cfg matched here\n-                #[cfg $($args:tt)*]\n-                $($attrs_rest:tt)*\n-            ],\n-            processed: {\n-                expr: [$($expr:tt)*],\n-            },\n-        },\n-    ) => {\n-        __expr_safe_flags! {\n-            expr: { $e },\n-            attrs: {\n-                unprocessed: [\n-                    $($attrs_rest)*\n-                ],\n-                processed: {\n-                    expr: [\n-                        $($expr)*\n-                        // cfg added here\n-                        #[cfg $($args)*]\n-                    ],\n-                },\n-            },\n-        }\n-    };\n-    // Process the next attribute on the current flag\n-    // `$other`: The next flag should not be propagated to expressions\n-    (\n-        expr: { $e:expr },\n-            attrs: {\n-            unprocessed: [\n-                // $other matched here\n-                #[$other:ident $($args:tt)*]\n-                $($attrs_rest:tt)*\n-            ],\n-            processed: {\n-                expr: [$($expr:tt)*],\n-            },\n-        },\n-    ) => {\n-        __expr_safe_flags! {\n-            expr: { $e },\n-                attrs: {\n-                unprocessed: [\n-                    $($attrs_rest)*\n-                ],\n-                processed: {\n-                    expr: [\n-                        // $other not added here\n-                        $($expr)*\n-                    ],\n-                },\n-            },\n-        }\n-    };\n-    // Once all attributes on all flags are processed, generate the actual code\n-    (\n-        expr: { $e:expr },\n-        attrs: {\n-            unprocessed: [],\n-            processed: {\n-                expr: [$(#[$expr:ident $($exprargs:tt)*])*],\n-            },\n-        },\n-    ) => {\n-        $(#[$expr $($exprargs)*])*\n-        { $e }\n-    }\n-}\ndiff --git a/src/iter.rs b/src/iter.rs\nnew file mode 100644\nindex 00000000..4b6210e2\n--- /dev/null\n+++ b/src/iter.rs\n@@ -0,0 +1,133 @@\n+//! Iterating over set flag values.\n+\n+use crate::{Flags, Flag};\n+\n+/// An iterator over a set of flags.\n+///\n+/// Any bits that don't correspond to a valid flag will be yielded\n+/// as a final item from the iterator.\n+pub struct Iter<B: 'static> {\n+    inner: IterNames<B>,\n+    done: bool,\n+}\n+\n+impl<B: Flags> Iter<B> {\n+    /// Create a new iterator over the given set of flags.\n+    pub(crate) fn new(flags: &B) -> Self {\n+        Iter {\n+            inner: IterNames::new(flags),\n+            done: false,\n+        }\n+    }\n+}\n+\n+impl<B: 'static> Iter<B> {\n+    #[doc(hidden)]\n+    pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, state: B) -> Self {\n+        Iter {\n+            inner: IterNames::__private_const_new(flags, source, state),\n+            done: false,\n+        }\n+    }\n+}\n+\n+impl<B: Flags> Iterator for Iter<B> {\n+    type Item = B;\n+    \n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.inner.next() {\n+            Some((_, flag)) => Some(flag),\n+            None if !self.done => {\n+                self.done = true;\n+                \n+                // After iterating through valid names, if there are any bits left over\n+                // then return one final value that includes them. This makes `into_iter`\n+                // and `from_iter` roundtrip\n+                if !self.inner.remaining().is_empty() {\n+                    Some(B::from_bits_retain(self.inner.state.bits()))\n+                } else {\n+                    None\n+                }\n+            }\n+            None => None,\n+        }\n+    }\n+}\n+\n+/// An iterator over a set of flags and their names.\n+///\n+/// Any bits that don't correspond to a valid flag will be ignored.\n+pub struct IterNames<B: 'static> {\n+    flags: &'static [Flag<B>],\n+    idx: usize,\n+    source: B,\n+    state: B,\n+}\n+\n+impl<B: Flags> IterNames<B> {\n+    /// Create a new iterator over the given set of flags.\n+    pub(crate) fn new(flags: &B) -> Self {\n+        IterNames {\n+            flags: B::FLAGS,\n+            idx: 0,\n+            state: B::from_bits_retain(flags.bits()),\n+            source: B::from_bits_retain(flags.bits()),\n+        }\n+    }\n+}\n+\n+impl<B: 'static> IterNames<B> {\n+    #[doc(hidden)]\n+    pub const fn __private_const_new(flags: &'static [Flag<B>], source: B, state: B) -> Self {\n+        IterNames {\n+            flags,\n+            idx: 0,\n+            state,\n+            source,\n+        }\n+    }\n+\n+    /// Get the remaining (unyielded) flags.\n+    ///\n+    /// Once the iterator has finished, this method can be used to\n+    /// check whether or not there are any bits that didn't correspond\n+    /// to a valid flag remaining.\n+    pub fn remaining(&self) -> &B {\n+        &self.state\n+    }\n+}\n+\n+impl<B: Flags> Iterator for IterNames<B> {\n+    type Item = (&'static str, B);\n+    \n+    fn next(&mut self) -> Option<Self::Item> {\n+        while let Some(flag) = self.flags.get(self.idx) {\n+            // Short-circuit if our state is empty\n+            if self.state.is_empty() {\n+                return None;\n+            }\n+\n+            self.idx += 1;\n+\n+            let bits = flag.value().bits();\n+\n+            // NOTE: We check whether the flag exists in self, but remove it from\n+            // a different value. This ensure that overlapping flags are handled\n+            // properly. Take the following example:\n+            //\n+            // const A: 0b00000001;\n+            // const B: 0b00000101;\n+            //\n+            // Given the bits 0b00000101, both A and B are set. But if we removed A\n+            // as we encountered it we'd be left with 0b00000100, which doesn't\n+            // correspond to a valid flag on its own.\n+            if self.source.contains(B::from_bits_retain(bits)) {\n+                self.state.remove(B::from_bits_retain(bits));\n+\n+                return Some((flag.name(), B::from_bits_retain(bits)));\n+            }\n+        }\n+        \n+        None\n+    }\n+}\ndiff --git a/src/lib.rs b/src/lib.rs\nindex d28fd87f..2c29b64a 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -374,16 +374,16 @@\n //! }\n //! ```\n //!\n-//! [`from_bits`]: BitFlags::from_bits\n-//! [`from_bits_truncate`]: BitFlags::from_bits_truncate\n+//! [`from_bits`]: Flags::from_bits\n+//! [`from_bits_truncate`]: Flags::from_bits_truncate\n //!\n-//! # The `BitFlags` trait\n+//! # The `Flags` trait\n //!\n-//! This library defines a `BitFlags` trait that's implemented by all generated flags types.\n+//! This library defines a `Flags` trait that's implemented by all generated flags types.\n //! The trait makes it possible to work with flags types generically:\n //!\n //! ```\n-//! fn count_unset_flags<F: bitflags::BitFlags>(flags: &F) -> usize {\n+//! fn count_unset_flags<F: bitflags::Flags>(flags: &F) -> usize {\n //!     // Find out how many flags there are in total\n //!     let total = F::all().iter().count();\n //!\n@@ -422,22 +422,29 @@\n \n #![cfg_attr(not(any(feature = \"std\", test)), no_std)]\n #![cfg_attr(not(test), forbid(unsafe_code))]\n-\n #![doc(html_root_url = \"https://docs.rs/bitflags/2.2.1\")]\n \n #[doc(inline)]\n-pub use traits::BitFlags;\n+pub use traits::{Flags, Flag, Bits};\n \n+pub mod iter;\n pub mod parser;\n+\n mod traits;\n \n #[doc(hidden)]\n pub mod __private {\n-    pub use crate::{external::*, traits::*};\n+    pub use crate::{external::__private::*, traits::__private::*};\n \n     pub use core;\n }\n \n+#[allow(unused_imports)]\n+pub use external::*;\n+\n+#[allow(deprecated)]\n+pub use traits::BitFlags;\n+\n /*\n How does the bitflags crate work?\n \n@@ -563,20 +570,14 @@ macro_rules! bitflags {\n         // This type appears in the end-user's API\n         __declare_public_bitflags! {\n             $(#[$outer])*\n-            $vis struct $BitFlags;\n+            $vis struct $BitFlags\n         }\n \n         // Workaround for: https://github.com/bitflags/bitflags/issues/320\n         __impl_public_bitflags_consts! {\n-            $BitFlags {\n+            $BitFlags: $T {\n                 $(\n                     $(#[$inner $($args)*])*\n-                    #[allow(\n-                        dead_code,\n-                        deprecated,\n-                        unused_attributes,\n-                        non_upper_case_globals\n-                    )]\n                     $Flag = $value;\n                 )*\n             }\n@@ -595,16 +596,14 @@ macro_rules! bitflags {\n             // Declared in a \"hidden\" scope that can't be reached directly\n             // These types don't appear in the end-user's API\n             __declare_internal_bitflags! {\n-                $vis struct InternalBitFlags: $T;\n-                $vis struct Iter;\n-                $vis struct IterRaw;\n+                $vis struct InternalBitFlags: $T\n             }\n \n             __impl_internal_bitflags! {\n-                InternalBitFlags: $T, $BitFlags, Iter, IterRaw {\n+                InternalBitFlags: $T, $BitFlags {\n                     $(\n                         $(#[$inner $($args)*])*\n-                        $Flag;\n+                        $Flag = $value;\n                     )*\n                 }\n             }\n@@ -619,8 +618,59 @@ macro_rules! bitflags {\n                 }\n             }\n \n+            __impl_public_bitflags_forward! {\n+                $BitFlags: $T, InternalBitFlags\n+            }\n+\n+            __impl_public_bitflags_iter! {\n+                $BitFlags\n+            }\n+        };\n+\n+        bitflags! {\n+            $($t)*\n+        }\n+    };\n+    (\n+        impl $BitFlags:ident: $T:ty {\n+            $(\n+                $(#[$inner:ident $($args:tt)*])*\n+                const $Flag:ident = $value:expr;\n+            )*\n+        }\n+\n+        $($t:tt)*\n+    ) => {\n+        __impl_public_bitflags_consts! {\n+            $BitFlags: $T {\n+                $(\n+                    $(#[$inner $($args)*])*\n+                    $Flag = $value;\n+                )*\n+            }\n+        }\n+\n+        #[allow(\n+            dead_code,\n+            deprecated,\n+            unused_doc_comments,\n+            unused_attributes,\n+            unused_mut,\n+            unused_imports,\n+            non_upper_case_globals\n+        )]\n+        const _: () = {\n             __impl_public_bitflags! {\n-                $BitFlags: $T, InternalBitFlags, Iter, IterRaw;\n+                $BitFlags: $T {\n+                    $(\n+                        $(#[$inner $($args)*])*\n+                        $Flag;\n+                    )*\n+                }\n+            }\n+\n+            __impl_public_bitflags_iter! {\n+                $BitFlags\n             }\n         };\n \n@@ -631,6 +681,357 @@ macro_rules! bitflags {\n     () => {};\n }\n \n+/// Implement functions on bitflags types.\n+///\n+/// We need to be careful about adding new methods and trait implementations here because they\n+/// could conflict with items added by the end-user.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_bitflags {\n+    (\n+        $PublicBitFlags:ident: $T:ty {\n+            fn empty() $empty:block\n+            fn all() $all:block\n+            fn bits($bits0:ident) $bits:block\n+            fn from_bits($from_bits0:ident) $from_bits:block\n+            fn from_bits_truncate($from_bits_truncate0:ident) $from_bits_truncate:block\n+            fn from_bits_retain($from_bits_retain0:ident) $from_bits_retain:block\n+            fn from_name($from_name0:ident) $from_name:block\n+            fn is_empty($is_empty0:ident) $is_empty:block\n+            fn is_all($is_all0:ident) $is_all:block\n+            fn intersects($intersects0:ident, $intersects1:ident) $intersects:block\n+            fn contains($contains0:ident, $contains1:ident) $contains:block\n+            fn insert($insert0:ident, $insert1:ident) $insert:block\n+            fn remove($remove0:ident, $remove1:ident) $remove:block\n+            fn toggle($toggle0:ident, $toggle1:ident) $toggle:block\n+            fn set($set0:ident, $set1:ident, $set2:ident) $set:block\n+            fn intersection($intersection0:ident, $intersection1:ident) $intersection:block\n+            fn union($union0:ident, $union1:ident) $union:block\n+            fn difference($difference0:ident, $difference1:ident) $difference:block\n+            fn symmetric_difference($symmetric_difference0:ident, $symmetric_difference1:ident) $symmetric_difference:block\n+            fn complement($complement0:ident) $complement:block\n+        }\n+    ) => {\n+        #[allow(\n+            dead_code,\n+            deprecated,\n+            unused_attributes\n+        )]\n+        impl $PublicBitFlags {\n+            /// Returns an empty set of flags.\n+            #[inline]\n+            pub const fn empty() -> Self {\n+                $empty\n+            }\n+\n+            /// Returns the set containing all flags.\n+            #[inline]\n+            pub const fn all() -> Self {\n+                $all\n+            }\n+\n+            /// Returns the raw value of the flags currently stored.\n+            #[inline]\n+            pub const fn bits(&self) -> $T {\n+                let $bits0 = self;\n+                $bits\n+            }\n+\n+            /// Convert from underlying bit representation, unless that\n+            /// representation contains bits that do not correspond to a flag.\n+            #[inline]\n+            pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n+                let $from_bits0 = bits;\n+                $from_bits\n+            }\n+\n+            /// Convert from underlying bit representation, dropping any bits\n+            /// that do not correspond to flags.\n+            #[inline]\n+            pub const fn from_bits_truncate(bits: $T) -> Self {\n+                let $from_bits_truncate0 = bits;\n+                $from_bits_truncate\n+            }\n+\n+            /// Convert from underlying bit representation, preserving all\n+            /// bits (even those not corresponding to a defined flag).\n+            #[inline]\n+            pub const fn from_bits_retain(bits: $T) -> Self {\n+                let $from_bits_retain0 = bits;\n+                $from_bits_retain\n+            }\n+\n+            /// Get the value for a flag from its stringified name.\n+            ///\n+            /// Names are _case-sensitive_, so must correspond exactly to\n+            /// the identifier given to the flag.\n+            #[inline]\n+            pub fn from_name(name: &str) -> $crate::__private::core::option::Option<Self> {\n+                let $from_name0 = name;\n+                $from_name\n+            }\n+\n+            /// Returns `true` if no flags are currently stored.\n+            #[inline]\n+            pub const fn is_empty(&self) -> bool {\n+                let $is_empty0 = self;\n+                $is_empty\n+            }\n+\n+            /// Returns `true` if all flags are currently set.\n+            #[inline]\n+            pub const fn is_all(&self) -> bool {\n+                let $is_all0 = self;\n+                $is_all\n+            }\n+\n+            /// Returns `true` if there are flags common to both `self` and `other`.\n+            #[inline]\n+            pub const fn intersects(&self, other: Self) -> bool {\n+                let $intersects0 = self;\n+                let $intersects1 = other;\n+                $intersects\n+            }\n+\n+            /// Returns `true` if all of the flags in `other` are contained within `self`.\n+            #[inline]\n+            pub const fn contains(&self, other: Self) -> bool {\n+                let $contains0 = self;\n+                let $contains1 = other;\n+                $contains\n+            }\n+\n+            /// Inserts the specified flags in-place.\n+            #[inline]\n+            pub fn insert(&mut self, other: Self) {\n+                let $insert0 = self;\n+                let $insert1 = other;\n+                $insert\n+            }\n+\n+            /// Removes the specified flags in-place.\n+            #[inline]\n+            pub fn remove(&mut self, other: Self) {\n+                let $remove0 = self;\n+                let $remove1 = other;\n+                $remove\n+            }\n+\n+            /// Toggles the specified flags in-place.\n+            #[inline]\n+            pub fn toggle(&mut self, other: Self) {\n+                let $toggle0 = self;\n+                let $toggle1 = other;\n+                $toggle\n+            }\n+\n+            /// Inserts or removes the specified flags depending on the passed value.\n+            #[inline]\n+            pub fn set(&mut self, other: Self, value: bool) {\n+                let $set0 = self;\n+                let $set1 = other;\n+                let $set2 = value;\n+                $set\n+            }\n+\n+            /// Returns the intersection between the flags in `self` and\n+            /// `other`.\n+            ///\n+            /// Specifically, the returned set contains only the flags which are\n+            /// present in *both* `self` *and* `other`.\n+            ///\n+            /// This is equivalent to using the `&` operator (e.g.\n+            /// [`ops::BitAnd`]), as in `flags & other`.\n+            ///\n+            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n+            #[inline]\n+            #[must_use]\n+            pub const fn intersection(self, other: Self) -> Self {\n+                let $intersection0 = self;\n+                let $intersection1 = other;\n+                $intersection\n+            }\n+\n+            /// Returns the union of between the flags in `self` and `other`.\n+            ///\n+            /// Specifically, the returned set contains all flags which are\n+            /// present in *either* `self` *or* `other`, including any which are\n+            /// present in both (see [`Self::symmetric_difference`] if that\n+            /// is undesirable).\n+            ///\n+            /// This is equivalent to using the `|` operator (e.g.\n+            /// [`ops::BitOr`]), as in `flags | other`.\n+            ///\n+            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n+            #[inline]\n+            #[must_use]\n+            pub const fn union(self, other: Self) -> Self {\n+                let $union0 = self;\n+                let $union1 = other;\n+                $union\n+            }\n+\n+            /// Returns the difference between the flags in `self` and `other`.\n+            ///\n+            /// Specifically, the returned set contains all flags present in\n+            /// `self`, except for the ones present in `other`.\n+            ///\n+            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n+            /// `flags & !other` (and this syntax is also supported).\n+            ///\n+            /// This is equivalent to using the `-` operator (e.g.\n+            /// [`ops::Sub`]), as in `flags - other`.\n+            ///\n+            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n+            #[inline]\n+            #[must_use]\n+            pub const fn difference(self, other: Self) -> Self {\n+                let $difference0 = self;\n+                let $difference1 = other;\n+                $difference\n+            }\n+\n+            /// Returns the [symmetric difference][sym-diff] between the flags\n+            /// in `self` and `other`.\n+            ///\n+            /// Specifically, the returned set contains the flags present which\n+            /// are present in `self` or `other`, but that are not present in\n+            /// both. Equivalently, it contains the flags present in *exactly\n+            /// one* of the sets `self` and `other`.\n+            ///\n+            /// This is equivalent to using the `^` operator (e.g.\n+            /// [`ops::BitXor`]), as in `flags ^ other`.\n+            ///\n+            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n+            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n+            #[inline]\n+            #[must_use]\n+            pub const fn symmetric_difference(self, other: Self) -> Self {\n+                let $symmetric_difference0 = self;\n+                let $symmetric_difference1 = other;\n+                $symmetric_difference\n+            }\n+\n+            /// Returns the complement of this set of flags.\n+            ///\n+            /// Specifically, the returned set contains all the flags which are\n+            /// not set in `self`, but which are allowed for this type.\n+            ///\n+            /// Alternatively, it can be thought of as the set difference\n+            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n+            ///\n+            /// This is equivalent to using the `!` operator (e.g.\n+            /// [`ops::Not`]), as in `!flags`.\n+            ///\n+            /// [`Self::all()`]: Self::all\n+            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n+            #[inline]\n+            #[must_use]\n+            pub const fn complement(self) -> Self {\n+                let $complement0 = self;\n+                $complement\n+            }\n+        }\n+    };\n+}\n+\n+/// A macro that processed the input to `bitflags!` and shuffles attributes around\n+/// based on whether or not they're \"expression-safe\".\n+///\n+/// This macro is a token-tree muncher that works on 2 levels:\n+///\n+/// For each attribute, we explicitly match on its identifier, like `cfg` to determine\n+/// whether or not it should be considered expression-safe.\n+///\n+/// If you find yourself with an attribute that should be considered expression-safe\n+/// and isn't, it can be added here.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __bitflags_expr_safe_attrs {\n+    // Entrypoint: Move all flags and all attributes into `unprocessed` lists\n+    // where they'll be munched one-at-a-time\n+    (\n+        $(#[$inner:ident $($args:tt)*])*\n+        { $e:expr }\n+    ) => {\n+        __bitflags_expr_safe_attrs! {\n+            expr: { $e },\n+            attrs: {\n+                // All attributes start here\n+                unprocessed: [$(#[$inner $($args)*])*],\n+                // Attributes that are safe on expressions go here\n+                processed: [],\n+            },\n+        }\n+    };\n+    // Process the next attribute on the current flag\n+    // `cfg`: The next flag should be propagated to expressions\n+    // NOTE: You can copy this rules block and replace `cfg` with\n+    // your attribute name that should be considered expression-safe\n+    (\n+        expr: { $e:expr },\n+            attrs: {\n+            unprocessed: [\n+                // cfg matched here\n+                #[cfg $($args:tt)*]\n+                $($attrs_rest:tt)*\n+            ],\n+            processed: [$($expr:tt)*],\n+        },\n+    ) => {\n+        __bitflags_expr_safe_attrs! {\n+            expr: { $e },\n+            attrs: {\n+                unprocessed: [\n+                    $($attrs_rest)*\n+                ],\n+                processed: [\n+                    $($expr)*\n+                    // cfg added here\n+                    #[cfg $($args)*]\n+                ],\n+            },\n+        }\n+    };\n+    // Process the next attribute on the current flag\n+    // `$other`: The next flag should not be propagated to expressions\n+    (\n+        expr: { $e:expr },\n+            attrs: {\n+            unprocessed: [\n+                // $other matched here\n+                #[$other:ident $($args:tt)*]\n+                $($attrs_rest:tt)*\n+            ],\n+            processed: [$($expr:tt)*],\n+        },\n+    ) => {\n+        __bitflags_expr_safe_attrs! {\n+            expr: { $e },\n+                attrs: {\n+                unprocessed: [\n+                    $($attrs_rest)*\n+                ],\n+                processed: [\n+                    // $other not added here\n+                    $($expr)*\n+                ],\n+            },\n+        }\n+    };\n+    // Once all attributes on all flags are processed, generate the actual code\n+    (\n+        expr: { $e:expr },\n+        attrs: {\n+            unprocessed: [],\n+            processed: [$(#[$expr:ident $($exprargs:tt)*])*],\n+        },\n+    ) => {\n+        $(#[$expr $($exprargs)*])*\n+        { $e }\n+    }\n+}\n+\n #[macro_use]\n mod public;\n #[macro_use]\n@@ -650,6 +1051,9 @@ mod tests {\n         str,\n     };\n \n+    #[derive(Debug, PartialEq, Eq)]\n+    pub struct ManualFlags(u32);\n+\n     bitflags! {\n         #[doc = \"> The first principle is that you must not fool yourself \u2014 and\"]\n         #[doc = \"> you are the easiest person to fool.\"]\n@@ -686,6 +1090,17 @@ mod tests {\n         struct LongFlags: u32 {\n             const LONG_A = 0b1111111111111111;\n         }\n+\n+        impl ManualFlags: u32 {\n+            const A = 0b00000001;\n+            #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n+            const B = 0b00000010;\n+            const C = 0b00000100;\n+            #[doc = \"* cmr bed\"]\n+            #[doc = \"* strcat table\"]\n+            #[doc = \"<strcat> wait what?\"]\n+            const ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n+        }\n     }\n \n     bitflags! {\n@@ -724,6 +1139,8 @@ mod tests {\n         assert_eq!(Flags::A.bits(), 0b00000001);\n         assert_eq!(Flags::ABC.bits(), 0b00000111);\n \n+        assert_eq!(<Flags as crate::Flags>::bits(&Flags::ABC), 0b00000111);\n+\n         assert_eq!(AnotherSetOfFlags::empty().bits(), 0b00);\n         assert_eq!(AnotherSetOfFlags::ANOTHER_FLAG.bits(), !0_i8);\n \n@@ -738,6 +1155,8 @@ mod tests {\n         assert_eq!(Flags::from_bits(0b11), Some(Flags::A | Flags::B));\n         assert_eq!(Flags::from_bits(0b1000), None);\n \n+        assert_eq!(<Flags as crate::Flags>::from_bits(0b11), Some(Flags::A | Flags::B));\n+\n         assert_eq!(\n             AnotherSetOfFlags::from_bits(!0_i8),\n             Some(AnotherSetOfFlags::ANOTHER_FLAG)\n@@ -756,6 +1175,8 @@ mod tests {\n         assert_eq!(Flags::from_bits_truncate(0b1000), Flags::empty());\n         assert_eq!(Flags::from_bits_truncate(0b1001), Flags::A);\n \n+        assert_eq!(<Flags as crate::Flags>::from_bits_truncate(0b11), (Flags::A | Flags::B));\n+\n         assert_eq!(\n             AnotherSetOfFlags::from_bits_truncate(0_i8),\n             AnotherSetOfFlags::empty()\n@@ -776,6 +1197,8 @@ mod tests {\n         assert_eq!(Flags::from_bits_retain(0b1000), (extra | Flags::empty()));\n         assert_eq!(Flags::from_bits_retain(0b1001), (extra | Flags::A));\n \n+        assert_eq!(<Flags as crate::Flags>::from_bits_retain(0b11), (Flags::A | Flags::B));\n+\n         let extra = EmptyFlags::from_bits_retain(0b1000);\n         assert_eq!(\n             EmptyFlags::from_bits_retain(0b1000),\n@@ -789,6 +1212,8 @@ mod tests {\n         assert!(!Flags::A.is_empty());\n         assert!(!Flags::ABC.is_empty());\n \n+        assert!(!<Flags as crate::Flags>::is_empty(&Flags::ABC));\n+\n         assert!(!AnotherSetOfFlags::ANOTHER_FLAG.is_empty());\n \n         assert!(EmptyFlags::empty().is_empty());\n@@ -806,6 +1231,8 @@ mod tests {\n         assert!(!(Flags::A | extra).is_all());\n         assert!((Flags::ABC | extra).is_all());\n \n+        assert!(<Flags as crate::Flags>::is_all(&Flags::all()));\n+\n         assert!(AnotherSetOfFlags::ANOTHER_FLAG.is_all());\n \n         assert!(EmptyFlags::all().is_all());\n@@ -818,6 +1245,8 @@ mod tests {\n         let e2 = Flags::empty();\n         assert!(!e1.intersects(e2));\n \n+        assert!(!<Flags as crate::Flags>::intersects(&e1, e2));\n+\n         assert!(AnotherSetOfFlags::ANOTHER_FLAG.intersects(AnotherSetOfFlags::ANOTHER_FLAG));\n     }\n \n@@ -826,6 +1255,8 @@ mod tests {\n         let e1 = Flags::empty();\n         let e2 = Flags::ABC;\n         assert!(!e1.intersects(e2));\n+\n+        assert!(!<Flags as crate::Flags>::intersects(&e1, e2));\n     }\n \n     #[test]\n@@ -833,6 +1264,8 @@ mod tests {\n         let e1 = Flags::A;\n         let e2 = Flags::B;\n         assert!(!e1.intersects(e2));\n+\n+        assert!(!<Flags as crate::Flags>::intersects(&e1, e2));\n     }\n \n     #[test]\n@@ -840,6 +1273,8 @@ mod tests {\n         let e1 = Flags::A;\n         let e2 = Flags::A | Flags::B;\n         assert!(e1.intersects(e2));\n+\n+        assert!(<Flags as crate::Flags>::intersects(&e1, e2));\n     }\n \n     #[test]\n@@ -850,6 +1285,8 @@ mod tests {\n         assert!(e2.contains(e1));\n         assert!(Flags::ABC.contains(e2));\n \n+        assert!(<Flags as crate::Flags>::contains(&Flags::ABC, e2));\n+\n         assert!(AnotherSetOfFlags::ANOTHER_FLAG.contains(AnotherSetOfFlags::ANOTHER_FLAG));\n \n         assert!(EmptyFlags::empty().contains(EmptyFlags::empty()));\n@@ -862,6 +1299,11 @@ mod tests {\n         e1.insert(e2);\n         assert_eq!(e1, e2);\n \n+        let mut e1 = Flags::A;\n+        let e2 = Flags::A | Flags::B;\n+        <Flags as crate::Flags>::insert(&mut e1, e2);\n+        assert_eq!(e1, e2);\n+\n         let mut e3 = AnotherSetOfFlags::empty();\n         e3.insert(AnotherSetOfFlags::ANOTHER_FLAG);\n         assert_eq!(e3, AnotherSetOfFlags::ANOTHER_FLAG);\n@@ -874,6 +1316,11 @@ mod tests {\n         e1.remove(e2);\n         assert_eq!(e1, Flags::B);\n \n+        let mut e1 = Flags::A | Flags::B;\n+        let e2 = Flags::A | Flags::C;\n+        <Flags as crate::Flags>::remove(&mut e1, e2);\n+        assert_eq!(e1, Flags::B);\n+\n         let mut e3 = AnotherSetOfFlags::ANOTHER_FLAG;\n         e3.remove(AnotherSetOfFlags::ANOTHER_FLAG);\n         assert_eq!(e3, AnotherSetOfFlags::empty());\n@@ -926,6 +1373,8 @@ mod tests {\n         assert_eq!(ac, Flags::C.union(Flags::A));\n         assert_eq!(bc, Flags::C.union(Flags::B));\n \n+        assert_eq!(ac, <Flags as crate::Flags>::union(Flags::A, Flags::C));\n+\n         assert_eq!(ac, Flags::A | Flags::C);\n         assert_eq!(bc, Flags::B | Flags::C);\n         assert_eq!(ab.union(bc), Flags::ABC);\n@@ -941,15 +1390,24 @@ mod tests {\n         assert_eq!(ac.intersection(bc), Flags::C);\n         assert_eq!(bc.intersection(ac), Flags::C);\n \n+        assert_eq!(Flags::C, <Flags as crate::Flags>::intersection(ac, bc));\n+\n         assert_eq!(ac.difference(bc), ac - bc);\n         assert_eq!(bc.difference(ac), bc - ac);\n         assert_eq!(ac.difference(bc), Flags::A);\n         assert_eq!(bc.difference(ac), Flags::B);\n \n+        assert_eq!(bc, <Flags as crate::Flags>::difference(bc, Flags::A));\n+\n         assert_eq!(bc.complement(), !bc);\n         assert_eq!(bc.complement(), Flags::A);\n+\n+        assert_eq!(Flags::A, <Flags as crate::Flags>::complement(bc));\n+\n         assert_eq!(ac.symmetric_difference(bc), Flags::A.union(Flags::B));\n         assert_eq!(bc.symmetric_difference(ac), Flags::A.union(Flags::B));\n+\n+        assert_eq!(ab, <Flags as crate::Flags>::symmetric_difference(ac, bc));\n     }\n \n     #[test]\n@@ -1287,7 +1745,6 @@ mod tests {\n         parse_case(FmtFlags::empty(), \"\");\n         parse_case(FmtFlags::empty(), \" \\r\\n\\t\");\n         parse_case(FmtFlags::empty(), \"0x0\");\n-        parse_case(FmtFlags::empty(), \"0x0\");\n \n         parse_case(FmtFlags::\uace0\uc591\uc774, \"\uace0\uc591\uc774\");\n         parse_case(FmtFlags::\uace0\uc591\uc774, \"  \uace0\uc591\uc774  \");\ndiff --git a/src/parser.rs b/src/parser.rs\nindex 48f3c610..aac9042f 100644\n--- a/src/parser.rs\n+++ b/src/parser.rs\n@@ -28,7 +28,118 @@\n \n #![allow(clippy::let_unit_value)]\n \n-use core::fmt;\n+use core::fmt::{self, Write};\n+\n+use crate::{Flags, Bits};\n+\n+/// Write a set of flags to a writer.\n+///\n+/// Any bits that don't correspond to a valid flag will be formatted\n+/// as a hex number.\n+pub fn to_writer<B: Flags>(flags: &B, mut writer: impl Write) -> Result<(), fmt::Error>\n+where\n+    B::Bits: WriteHex,\n+{\n+    // A formatter for bitflags that produces text output like:\n+    //\n+    // A | B | 0xf6\n+    //\n+    // The names of set flags are written in a bar-separated-format,\n+    // followed by a hex number of any remaining bits that are set\n+    // but don't correspond to any flags.\n+\n+    // Iterate over the valid flags\n+    let mut first = true;\n+    let mut iter = flags.iter_names();\n+    for (name, _) in &mut iter {\n+        if !first {\n+            writer.write_str(\" | \")?;\n+        }\n+\n+        first = false;\n+        writer.write_str(name)?;\n+    }\n+\n+    // Append any extra bits that correspond to flags to the end of the format\n+    let remaining = iter.remaining().bits();\n+    if remaining != B::Bits::EMPTY {\n+        if !first {\n+            writer.write_str(\" | \")?;\n+        }\n+\n+        writer.write_str(\"0x\")?;\n+        remaining.write_hex(writer)?;\n+    }\n+\n+    fmt::Result::Ok(())\n+}\n+\n+pub(crate) struct AsDisplay<'a, B>(pub(crate) &'a B);\n+\n+impl<'a, B: Flags> fmt::Display for AsDisplay<'a, B>\n+where\n+    B::Bits: WriteHex,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        to_writer(self.0, f)\n+    }\n+}\n+\n+/// Parse a set of flags from text.\n+///\n+/// This function will fail on unknown flags rather than ignore them.\n+pub fn from_str<B: Flags>(input: &str) -> Result<B, ParseError>\n+where\n+    B::Bits: ParseHex,\n+{\n+    let mut parsed_flags = B::empty();\n+\n+    // If the input is empty then return an empty set of flags\n+    if input.trim().is_empty() {\n+        return Ok(parsed_flags);\n+    }\n+\n+    for flag in input.split('|') {\n+        let flag = flag.trim();\n+\n+        // If the flag is empty then we've got missing input\n+        if flag.is_empty() {\n+            return Err(ParseError::empty_flag());\n+        }\n+\n+        // If the flag starts with `0x` then it's a hex number\n+        // Parse it directly to the underlying bits type\n+        let parsed_flag = if let Some(flag) = flag.strip_prefix(\"0x\") {\n+            let bits = <B::Bits>::parse_hex(flag).map_err(|_| ParseError::invalid_hex_flag(flag))?;\n+\n+            B::from_bits_retain(bits)\n+        }\n+        // Otherwise the flag is a name\n+        // The generated flags type will determine whether\n+        // or not it's a valid identifier\n+        else {\n+            B::from_name(flag).ok_or_else(|| ParseError::invalid_named_flag(flag))?\n+        };\n+\n+        parsed_flags.insert(parsed_flag);\n+    }\n+\n+    Ok(parsed_flags)\n+}\n+\n+/// Encode a value as a hex number.\n+pub trait WriteHex {\n+    /// Write the value as hex.\n+    fn write_hex<W: fmt::Write>(&self, writer: W) -> fmt::Result;\n+}\n+\n+/// Parse a value from a number encoded as a hex string.\n+pub trait ParseHex {\n+    /// Parse the value from hex.\n+    fn parse_hex(input: &str) -> Result<Self, ParseError>\n+    where\n+        Self: Sized;\n+}\n \n /// An error encountered while parsing flags from text.\n #[derive(Debug)]\ndiff --git a/src/public.rs b/src/public.rs\nindex 643f8438..d650fc43 100644\n--- a/src/public.rs\n+++ b/src/public.rs\n@@ -11,10 +11,10 @@\n macro_rules! __declare_public_bitflags {\n     (\n         $(#[$outer:meta])*\n-        $vis:vis struct $BitFlags:ident;\n+        $vis:vis struct $PublicBitFlags:ident\n     ) => {\n         $(#[$outer])*\n-        $vis struct $BitFlags(<$BitFlags as $crate::__private::PublicFlags>::Internal);\n+        $vis struct $PublicBitFlags(<$PublicBitFlags as $crate::__private::PublicFlags>::Internal);\n     };\n }\n \n@@ -24,236 +24,302 @@ macro_rules! __declare_public_bitflags {\n /// could conflict with items added by the end-user.\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n-macro_rules! __impl_public_bitflags {\n+macro_rules! __impl_public_bitflags_forward {\n     (\n-        $PublicBitFlags:ident: $T:ty, $InternalBitFlags:ident, $Iter:ident, $IterNames:ident;\n+        $PublicBitFlags:ident: $T:ty, $InternalBitFlags:ident\n     ) => {\n-        impl $crate::__private::core::fmt::Binary for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Binary::fmt(&self.0, f)\n-            }\n-        }\n+        __impl_bitflags! {\n+            $PublicBitFlags: $T {\n+                fn empty() {\n+                    Self($InternalBitFlags::empty())\n+                }\n \n-        impl $crate::__private::core::fmt::Octal for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::Octal::fmt(&self.0, f)\n-            }\n-        }\n+                fn all() {\n+                    Self($InternalBitFlags::all())\n+                }\n \n-        impl $crate::__private::core::fmt::LowerHex for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::LowerHex::fmt(&self.0, f)\n+                fn bits(f) {\n+                    f.0.bits()\n+                }\n+\n+                fn from_bits(bits) {\n+                    match $InternalBitFlags::from_bits(bits) {\n+                        $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n+                        $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n+                    }\n+                }\n+\n+                fn from_bits_truncate(bits) {\n+                    Self($InternalBitFlags::from_bits_truncate(bits))\n+                }\n+\n+                fn from_bits_retain(bits) {\n+                    Self($InternalBitFlags::from_bits_retain(bits))\n+                }\n+\n+                fn from_name(name){\n+                    match $InternalBitFlags::from_name(name) {\n+                        $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n+                        $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n+                    }\n+                }\n+\n+                fn is_empty(f) {\n+                    f.0.is_empty()\n+                }\n+\n+                fn is_all(f) {\n+                    f.0.is_all()\n+                }\n+\n+                fn intersects(f, other) {\n+                    f.0.intersects(other.0)\n+                }\n+\n+                fn contains(f, other) {\n+                    f.0.contains(other.0)\n+                }\n+\n+                fn insert(f, other) {\n+                    f.0.insert(other.0)\n+                }\n+\n+                fn remove(f, other) {\n+                    f.0.remove(other.0)\n+                }\n+\n+                fn toggle(f, other) {\n+                    f.0.toggle(other.0)\n+                }\n+\n+                fn set(f, other, value) {\n+                    f.0.set(other.0, value)\n+                }\n+\n+                fn intersection(f, other) {\n+                    Self(f.0.intersection(other.0))\n+                }\n+\n+                fn union(f, other) {\n+                    Self(f.0.union(other.0))\n+                }\n+\n+                fn difference(f, other) {\n+                    Self(f.0.difference(other.0))\n+                }\n+\n+                fn symmetric_difference(f, other) {\n+                    Self(f.0.symmetric_difference(other.0))\n+                }\n+\n+                fn complement(f) {\n+                    Self(f.0.complement())\n+                }\n             }\n         }\n \n-        impl $crate::__private::core::fmt::UpperHex for $PublicBitFlags {\n-            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n-                $crate::__private::core::fmt::UpperHex::fmt(&self.0, f)\n-            }\n+        __impl_public_bitflags_ops!($PublicBitFlags);\n+    };\n+}\n+\n+/// Implement functions on the public (user-facing) bitflags type.\n+///\n+/// We need to be careful about adding new methods and trait implementations here because they\n+/// could conflict with items added by the end-user.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_public_bitflags {\n+    (\n+        $PublicBitFlags:ident: $T:ty {\n+            $(\n+                $(#[$attr:ident $($args:tt)*])*\n+                $Flag:ident;\n+            )*\n         }\n+    ) => {\n+        __impl_bitflags! {\n+            $PublicBitFlags: $T {\n+                fn empty() {\n+                    Self(<$T as $crate::Bits>::EMPTY)\n+                }\n \n-        impl $PublicBitFlags {\n-            /// Returns an empty set of flags.\n-            #[inline]\n-            pub const fn empty() -> Self {\n-                Self($InternalBitFlags::empty())\n-            }\n+                fn all() {\n+                    Self::from_bits_truncate(<$T as $crate::Bits>::ALL)\n+                }\n \n-            /// Returns the set containing all flags.\n-            #[inline]\n-            pub const fn all() -> Self {\n-                Self($InternalBitFlags::all())\n-            }\n+                fn bits(f) {\n+                    f.0\n+                }\n \n-            /// Returns the raw value of the flags currently stored.\n-            #[inline]\n-            pub const fn bits(&self) -> $T {\n-                self.0.bits()\n-            }\n+                fn from_bits(bits) {\n+                    let truncated = Self::from_bits_truncate(bits).0;\n \n-            /// Convert from underlying bit representation, unless that\n-            /// representation contains bits that do not correspond to a flag.\n-            #[inline]\n-            pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n-                match $InternalBitFlags::from_bits(bits) {\n-                    $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n-                    $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n+                    if truncated == bits {\n+                        $crate::__private::core::option::Option::Some(Self(bits))\n+                    } else {\n+                        $crate::__private::core::option::Option::None\n+                    }\n                 }\n-            }\n \n-            /// Convert from underlying bit representation, dropping any bits\n-            /// that do not correspond to flags.\n-            #[inline]\n-            pub const fn from_bits_truncate(bits: $T) -> Self {\n-                Self($InternalBitFlags::from_bits_truncate(bits))\n-            }\n+                fn from_bits_truncate(bits) {\n+                    if bits == <$T as $crate::Bits>::EMPTY {\n+                        return Self(bits)\n+                    }\n+\n+                    let mut truncated = <$T as $crate::Bits>::EMPTY;\n+\n+                    $(\n+                        __bitflags_expr_safe_attrs!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                if bits & $PublicBitFlags::$Flag.bits() == $PublicBitFlags::$Flag.bits() {\n+                                    truncated = truncated | $PublicBitFlags::$Flag.bits()\n+                                }\n+                            }\n+                        );\n+                    )*\n+\n+                    Self(truncated)\n+                }\n \n-            /// Convert from underlying bit representation, preserving all\n-            /// bits (even those not corresponding to a defined flag).\n-            #[inline]\n-            pub const fn from_bits_retain(bits: $T) -> Self {\n-                Self($InternalBitFlags::from_bits_retain(bits))\n-            }\n+                fn from_bits_retain(bits) {\n+                    Self(bits)\n+                }\n \n-            /// Get the value for a flag from its stringified name.\n-            ///\n-            /// Names are _case-sensitive_, so must correspond exactly to\n-            /// the identifier given to the flag.\n-            #[inline]\n-            pub fn from_name(name: &str) -> $crate::__private::core::option::Option<Self> {\n-                match $InternalBitFlags::from_name(name) {\n-                    $crate::__private::core::option::Option::Some(bits) => $crate::__private::core::option::Option::Some(Self(bits)),\n-                    $crate::__private::core::option::Option::None => $crate::__private::core::option::Option::None,\n+                fn from_name(name) {\n+                    $(\n+                        __bitflags_expr_safe_attrs!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                if name == $crate::__private::core::stringify!($Flag) {\n+                                    return $crate::__private::core::option::Option::Some(Self($PublicBitFlags::$Flag.bits()));\n+                                }\n+                            }\n+                        );\n+                    )*\n+\n+                    let _ = name;\n+                    $crate::__private::core::option::Option::None\n                 }\n-            }\n \n-            /// Iterate over enabled flag values.\n-            #[inline]\n-            pub const fn iter(&self) -> $Iter {\n-                self.0.iter()\n-            }\n+                fn is_empty(f) {\n+                    f.0 == Self::empty().0\n+                }\n \n-            /// Iterate over enabled flag values with their stringified names.\n-            #[inline]\n-            pub const fn iter_names(&self) -> $IterNames {\n-                self.0.iter_names()\n-            }\n+                fn is_all(f) {\n+                    Self::all().0 | f.0 == f.0\n+                }\n \n-            /// Returns `true` if no flags are currently stored.\n-            #[inline]\n-            pub const fn is_empty(&self) -> bool {\n-                self.0.is_empty()\n-            }\n+                fn intersects(f, other) {\n+                    !(Self(f.0 & other.0)).is_empty()\n+                }\n \n-            /// Returns `true` if all flags are currently set.\n-            #[inline]\n-            pub const fn is_all(&self) -> bool {\n-                self.0.is_all()\n-            }\n+                fn contains(f, other) {\n+                    (f.0 & other.0) == other.0\n+                }\n \n-            /// Returns `true` if there are flags common to both `self` and `other`.\n-            #[inline]\n-            pub const fn intersects(&self, other: Self) -> bool {\n-                self.0.intersects(other.0)\n-            }\n+                fn insert(f, other) {\n+                    f.0 = f.0 | other.0;\n+                }\n \n-            /// Returns `true` if all of the flags in `other` are contained within `self`.\n-            #[inline]\n-            pub const fn contains(&self, other: Self) -> bool {\n-                self.0.contains(other.0)\n-            }\n+                fn remove(f, other) {\n+                    f.0 = f.0 & !other.0;\n+                }\n \n-            /// Inserts the specified flags in-place.\n-            #[inline]\n-            pub fn insert(&mut self, other: Self) {\n-                self.0.insert(other.0)\n-            }\n+                fn toggle(f, other) {\n+                    f.0 = f.0 ^ other.0;\n+                }\n \n-            /// Removes the specified flags in-place.\n-            #[inline]\n-            pub fn remove(&mut self, other: Self) {\n-                self.0.remove(other.0)\n+                fn set(f, other, value) {\n+                    if value {\n+                        f.insert(other);\n+                    } else {\n+                        f.remove(other);\n+                    }\n+                }\n+\n+                fn intersection(f, other) {\n+                    Self(f.0 & other.0)\n+                }\n+\n+                fn union(f, other) {\n+                    Self(f.0 | other.0)\n+                }\n+\n+                fn difference(f, other) {\n+                    Self(f.0 & !other.0)\n+                }\n+\n+                fn symmetric_difference(f, other) {\n+                    Self(f.0 ^ other.0)\n+                }\n+\n+                fn complement(f) {\n+                    Self::from_bits_truncate(!f.0)\n+                }\n             }\n+        }\n+\n+        __impl_public_bitflags_ops!($PublicBitFlags);\n+    };\n+}\n \n-            /// Toggles the specified flags in-place.\n+/// Implement iterators on the public (user-facing) bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_public_bitflags_iter {\n+    ($PublicBitFlags:ident) => {\n+        impl $PublicBitFlags {\n+            /// Iterate over enabled flag values.\n             #[inline]\n-            pub fn toggle(&mut self, other: Self) {\n-                self.0.toggle(other.0)\n+            pub const fn iter(&self) -> $crate::iter::Iter<$PublicBitFlags> {\n+                $crate::iter::Iter::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.bits()), $PublicBitFlags::from_bits_retain(self.bits()))\n             }\n \n-            /// Inserts or removes the specified flags depending on the passed value.\n+            /// Iterate over enabled flag values with their stringified names.\n             #[inline]\n-            pub fn set(&mut self, other: Self, value: bool) {\n-                self.0.set(other.0, value)\n+            pub const fn iter_names(&self) -> $crate::iter::IterNames<$PublicBitFlags> {\n+                $crate::iter::IterNames::__private_const_new(<$PublicBitFlags as $crate::Flags>::FLAGS, $PublicBitFlags::from_bits_retain(self.bits()), $PublicBitFlags::from_bits_retain(self.bits()))\n             }\n+        }\n \n-            /// Returns the intersection between the flags in `self` and\n-            /// `other`.\n-            ///\n-            /// Specifically, the returned set contains only the flags which are\n-            /// present in *both* `self` *and* `other`.\n-            ///\n-            /// This is equivalent to using the `&` operator (e.g.\n-            /// [`ops::BitAnd`]), as in `flags & other`.\n-            ///\n-            /// [`ops::BitAnd`]: https://doc.rust-lang.org/std/ops/trait.BitAnd.html\n-            #[inline]\n-            #[must_use]\n-            pub const fn intersection(self, other: Self) -> Self {\n-                Self(self.0.intersection(other.0))\n+        impl $crate::__private::core::iter::IntoIterator for $PublicBitFlags {\n+            type Item = Self;\n+            type IntoIter = $crate::iter::Iter<$PublicBitFlags>;\n+\n+            fn into_iter(self) -> Self::IntoIter {\n+                self.iter()\n             }\n+        }\n+    };\n+}\n \n-            /// Returns the union of between the flags in `self` and `other`.\n-            ///\n-            /// Specifically, the returned set contains all flags which are\n-            /// present in *either* `self` *or* `other`, including any which are\n-            /// present in both (see [`Self::symmetric_difference`] if that\n-            /// is undesirable).\n-            ///\n-            /// This is equivalent to using the `|` operator (e.g.\n-            /// [`ops::BitOr`]), as in `flags | other`.\n-            ///\n-            /// [`ops::BitOr`]: https://doc.rust-lang.org/std/ops/trait.BitOr.html\n-            #[inline]\n-            #[must_use]\n-            pub const fn union(self, other: Self) -> Self {\n-                Self(self.0.union(other.0))\n+/// Implement traits on the public (user-facing) bitflags type.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __impl_public_bitflags_ops {\n+    ($PublicBitFlags:ident) => {\n+        impl $crate::__private::core::fmt::Binary for $PublicBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::Binary::fmt(&self.0, f)\n             }\n+        }\n \n-            /// Returns the difference between the flags in `self` and `other`.\n-            ///\n-            /// Specifically, the returned set contains all flags present in\n-            /// `self`, except for the ones present in `other`.\n-            ///\n-            /// It is also conceptually equivalent to the \"bit-clear\" operation:\n-            /// `flags & !other` (and this syntax is also supported).\n-            ///\n-            /// This is equivalent to using the `-` operator (e.g.\n-            /// [`ops::Sub`]), as in `flags - other`.\n-            ///\n-            /// [`ops::Sub`]: https://doc.rust-lang.org/std/ops/trait.Sub.html\n-            #[inline]\n-            #[must_use]\n-            pub const fn difference(self, other: Self) -> Self {\n-                Self(self.0.difference(other.0))\n+        impl $crate::__private::core::fmt::Octal for $PublicBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::Octal::fmt(&self.0, f)\n             }\n+        }\n \n-            /// Returns the [symmetric difference][sym-diff] between the flags\n-            /// in `self` and `other`.\n-            ///\n-            /// Specifically, the returned set contains the flags present which\n-            /// are present in `self` or `other`, but that are not present in\n-            /// both. Equivalently, it contains the flags present in *exactly\n-            /// one* of the sets `self` and `other`.\n-            ///\n-            /// This is equivalent to using the `^` operator (e.g.\n-            /// [`ops::BitXor`]), as in `flags ^ other`.\n-            ///\n-            /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n-            /// [`ops::BitXor`]: https://doc.rust-lang.org/std/ops/trait.BitXor.html\n-            #[inline]\n-            #[must_use]\n-            pub const fn symmetric_difference(self, other: Self) -> Self {\n-                Self(self.0.symmetric_difference(other.0))\n+        impl $crate::__private::core::fmt::LowerHex for $PublicBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::LowerHex::fmt(&self.0, f)\n             }\n+        }\n \n-            /// Returns the complement of this set of flags.\n-            ///\n-            /// Specifically, the returned set contains all the flags which are\n-            /// not set in `self`, but which are allowed for this type.\n-            ///\n-            /// Alternatively, it can be thought of as the set difference\n-            /// between [`Self::all()`] and `self` (e.g. `Self::all() - self`)\n-            ///\n-            /// This is equivalent to using the `!` operator (e.g.\n-            /// [`ops::Not`]), as in `!flags`.\n-            ///\n-            /// [`Self::all()`]: Self::all\n-            /// [`ops::Not`]: https://doc.rust-lang.org/std/ops/trait.Not.html\n-            #[inline]\n-            #[must_use]\n-            pub const fn complement(self) -> Self {\n-                Self(self.0.complement())\n+        impl $crate::__private::core::fmt::UpperHex for $PublicBitFlags {\n+            fn fmt(&self, f: &mut $crate::__private::core::fmt::Formatter) -> $crate::__private::core::fmt::Result {\n+                $crate::__private::core::fmt::UpperHex::fmt(&self.0, f)\n             }\n         }\n \n@@ -271,7 +337,7 @@ macro_rules! __impl_public_bitflags {\n             /// Adds the set of flags.\n             #[inline]\n             fn bitor_assign(&mut self, other: Self) {\n-                self.0 = self.0.union(other.0);\n+                self.0 = self.0 | other.0;\n             }\n         }\n \n@@ -289,7 +355,7 @@ macro_rules! __impl_public_bitflags {\n             /// Toggles the set of flags.\n             #[inline]\n             fn bitxor_assign(&mut self, other: Self) {\n-                self.0 = self.0.symmetric_difference(other.0);\n+                self.0 = self.0 ^ other.0\n             }\n         }\n \n@@ -307,7 +373,7 @@ macro_rules! __impl_public_bitflags {\n             /// Disables all flags disabled in the set.\n             #[inline]\n             fn bitand_assign(&mut self, other: Self) {\n-                self.0 = self.0.intersection(other.0);\n+                self.0 = self.0 & other.0;\n             }\n         }\n \n@@ -325,7 +391,7 @@ macro_rules! __impl_public_bitflags {\n             /// Disables all flags enabled in the set.\n             #[inline]\n             fn sub_assign(&mut self, other: Self) {\n-                self.0 = self.0.difference(other.0);\n+                self.0 = self.0 & !other.0;\n             }\n         }\n \n@@ -356,92 +422,6 @@ macro_rules! __impl_public_bitflags {\n                 result\n             }\n         }\n-\n-        impl $crate::__private::core::iter::IntoIterator for $PublicBitFlags {\n-            type Item = Self;\n-            type IntoIter = $Iter;\n-\n-            fn into_iter(self) -> Self::IntoIter {\n-                self.0.iter()\n-            }\n-        }\n-\n-        impl $crate::BitFlags for $PublicBitFlags {\n-            type Bits = $T;\n-\n-            type Iter = $Iter;\n-            type IterNames = $IterNames;\n-\n-            fn empty() -> Self {\n-                $PublicBitFlags::empty()\n-            }\n-\n-            fn all() -> Self {\n-                $PublicBitFlags::all()\n-            }\n-\n-            fn bits(&self) -> $T {\n-                $PublicBitFlags::bits(self)\n-            }\n-\n-            fn from_bits(bits: $T) -> $crate::__private::core::option::Option<$PublicBitFlags> {\n-                $PublicBitFlags::from_bits(bits)\n-            }\n-\n-            fn from_bits_truncate(bits: $T) -> $PublicBitFlags {\n-                $PublicBitFlags::from_bits_truncate(bits)\n-            }\n-\n-            fn from_bits_retain(bits: $T) -> $PublicBitFlags {\n-                $PublicBitFlags::from_bits_retain(bits)\n-            }\n-\n-            fn from_name(name: &str) -> $crate::__private::core::option::Option<$PublicBitFlags> {\n-                $PublicBitFlags::from_name(name)\n-            }\n-\n-            fn iter(&self) -> Self::Iter {\n-                $PublicBitFlags::iter(self)\n-            }\n-\n-            fn iter_names(&self) -> Self::IterNames {\n-                $PublicBitFlags::iter_names(self)\n-            }\n-\n-            fn is_empty(&self) -> bool {\n-                $PublicBitFlags::is_empty(self)\n-            }\n-\n-            fn is_all(&self) -> bool {\n-                $PublicBitFlags::is_all(self)\n-            }\n-\n-            fn intersects(&self, other: $PublicBitFlags) -> bool {\n-                $PublicBitFlags::intersects(self, other)\n-            }\n-\n-            fn contains(&self, other: $PublicBitFlags) -> bool {\n-                $PublicBitFlags::contains(self, other)\n-            }\n-\n-            fn insert(&mut self, other: $PublicBitFlags) {\n-                $PublicBitFlags::insert(self, other)\n-            }\n-\n-            fn remove(&mut self, other: $PublicBitFlags) {\n-                $PublicBitFlags::remove(self, other)\n-            }\n-\n-            fn toggle(&mut self, other: $PublicBitFlags) {\n-                $PublicBitFlags::toggle(self, other)\n-            }\n-\n-            fn set(&mut self, other: $PublicBitFlags, value: bool) {\n-                $PublicBitFlags::set(self, other, value)\n-            }\n-        }\n-\n-        impl $crate::__private::ImplementedByBitFlagsMacro for $PublicBitFlags {}\n     };\n }\n \n@@ -450,7 +430,7 @@ macro_rules! __impl_public_bitflags {\n #[doc(hidden)]\n macro_rules! __impl_public_bitflags_consts {\n     (\n-        $PublicBitFlags:ident {\n+        $PublicBitFlags:ident: $T:ty {\n             $(\n                 $(#[$attr:ident $($args:tt)*])*\n                 $Flag:ident = $value:expr;\n@@ -460,8 +440,39 @@ macro_rules! __impl_public_bitflags_consts {\n         impl $PublicBitFlags {\n             $(\n                 $(#[$attr $($args)*])*\n+                #[allow(\n+                    deprecated,\n+                    non_upper_case_globals,\n+                )]\n                 pub const $Flag: Self = Self::from_bits_retain($value);\n             )*\n         }\n+\n+        impl $crate::Flags for $PublicBitFlags {\n+            const FLAGS: &'static [$crate::Flag<$PublicBitFlags>] = &[\n+                $(\n+                    __bitflags_expr_safe_attrs!(\n+                        $(#[$attr $($args)*])*\n+                        {\n+                            #[allow(\n+                                deprecated,\n+                                non_upper_case_globals,\n+                            )]\n+                            $crate::Flag::new($crate::__private::core::stringify!($Flag), $PublicBitFlags::$Flag)\n+                        }\n+                    ),\n+                )*\n+            ];\n+\n+            type Bits = $T;\n+\n+            fn bits(&self) -> $T {\n+                $PublicBitFlags::bits(self)\n+            }\n+\n+            fn from_bits_retain(bits: $T) -> $PublicBitFlags {\n+                $PublicBitFlags::from_bits_retain(bits)\n+            }\n+        }\n     };\n }\ndiff --git a/src/traits.rs b/src/traits.rs\nindex 85503e64..f8fc7572 100644\n--- a/src/traits.rs\n+++ b/src/traits.rs\n@@ -1,23 +1,50 @@\n-use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};\n+use core::{fmt, ops::{BitAnd, BitOr, BitXor, Not}};\n \n-/// A trait that is automatically implemented for all bitflags.\n-///\n-/// It should not be implemented manually.\n-pub trait BitFlags: ImplementedByBitFlagsMacro {\n-    /// The underlying integer type.\n-    type Bits: Bits;\n+use crate::{parser::{ParseError, ParseHex, WriteHex}, iter};\n \n-    /// An iterator over enabled flags in an instance of the type.\n-    type Iter: Iterator<Item = Self>;\n+/// Metadata for an individual flag.\n+pub struct Flag<B> {\n+    name: &'static str,\n+    value: B,\n+}\n \n-    /// An iterator over the raw names and bits for enabled flags in an instance of the type.\n-    type IterNames: Iterator<Item = (&'static str, Self)>;\n+impl<B> Flag<B> {\n+    /// Create a new flag with the given name and value.\n+    pub const fn new(name: &'static str, value: B) -> Self {\n+        Flag { name, value }\n+    }\n+\n+    /// Get the name of this flag.\n+    pub const fn name(&self) -> &'static str {\n+        self.name\n+    }\n+\n+    /// Get the value of this flag.\n+    pub const fn value(&self) -> &B {\n+        &self.value\n+    }\n+}\n+\n+/// A set of flags.\n+///\n+/// This trait is automatically implemented for flags types defined using the `bitflags!` macro.\n+/// It can also be implemented manually for custom flags types.\n+pub trait Flags: Sized + 'static {\n+    /// The set of available flags and their names.\n+    const FLAGS: &'static [Flag<Self>];\n+\n+    /// The underlying storage type.\n+    type Bits: Bits;\n \n     /// Returns an empty set of flags.\n-    fn empty() -> Self;\n+    fn empty() -> Self {\n+        Self::from_bits_retain(Self::Bits::EMPTY)\n+    }\n \n     /// Returns the set containing all flags.\n-    fn all() -> Self;\n+    fn all() -> Self {\n+        Self::from_bits_truncate(Self::Bits::ALL)\n+    }\n \n     /// Returns the raw value of the flags currently stored.\n     fn bits(&self) -> Self::Bits;\n@@ -28,9 +55,15 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     /// Note that each [multi-bit flag] is treated as a unit for this comparison.\n     ///\n     /// [multi-bit flag]: index.html#multi-bit-flags\n-    fn from_bits(bits: Self::Bits) -> Option<Self>\n-    where\n-        Self: Sized;\n+    fn from_bits(bits: Self::Bits) -> Option<Self> {\n+        let truncated = Self::from_bits_truncate(bits);\n+\n+        if truncated.bits() == bits {\n+            Some(truncated)\n+        } else {\n+            None\n+        }\n+    }\n \n     /// Convert from underlying bit representation, dropping any bits\n     /// that do not correspond to flags.\n@@ -38,81 +71,181 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     /// Note that each [multi-bit flag] is treated as a unit for this comparison.\n     ///\n     /// [multi-bit flag]: index.html#multi-bit-flags\n-    fn from_bits_truncate(bits: Self::Bits) -> Self;\n+    fn from_bits_truncate(bits: Self::Bits) -> Self {\n+        if bits == Self::Bits::EMPTY {\n+            return Self::empty();\n+        }\n+\n+        let mut truncated = Self::Bits::EMPTY;\n+\n+        for flag in Self::FLAGS.iter() {\n+            let flag = flag.value();\n+\n+            if bits & flag.bits() == flag.bits() {\n+                truncated = truncated | flag.bits();\n+            }\n+        }\n+\n+        Self::from_bits_retain(truncated)\n+    }\n \n     /// Convert from underlying bit representation, preserving all\n     /// bits (even those not corresponding to a defined flag).\n     fn from_bits_retain(bits: Self::Bits) -> Self;\n \n     /// Get the flag for a particular name.\n-    fn from_name(name: &str) -> Option<Self>\n-    where\n-        Self: Sized;\n+    fn from_name(name: &str) -> Option<Self> {\n+        for flag in Self::FLAGS {\n+            if flag.name() == name {\n+                return Some(Self::from_bits_retain(flag.value().bits()))\n+            }\n+        }\n+\n+        None\n+    }\n \n     /// Iterate over enabled flag values.\n-    fn iter(&self) -> Self::Iter;\n+    fn iter(&self) -> iter::Iter<Self> {\n+        iter::Iter::new(self)\n+    }\n \n     /// Iterate over the raw names and bits for enabled flag values.\n-    fn iter_names(&self) -> Self::IterNames;\n+    fn iter_names(&self) -> iter::IterNames<Self> {\n+        iter::IterNames::new(self)\n+    }\n \n     /// Returns `true` if no flags are currently stored.\n-    fn is_empty(&self) -> bool;\n+    fn is_empty(&self) -> bool {\n+        self.bits() == Self::Bits::EMPTY\n+    }\n \n     /// Returns `true` if all flags are currently set.\n-    fn is_all(&self) -> bool;\n+    fn is_all(&self) -> bool {\n+        // NOTE: We check against `Self::all` here, not `Self::Bits::ALL`\n+        // because the set of all flags may not use all bits\n+        Self::all().bits() | self.bits() == self.bits()\n+    }\n \n     /// Returns `true` if there are flags common to both `self` and `other`.\n-    fn intersects(&self, other: Self) -> bool;\n+    fn intersects(&self, other: Self) -> bool\n+    where\n+        Self: Sized,\n+    {\n+        self.bits() & other.bits() != Self::Bits::EMPTY\n+    }\n \n     /// Returns `true` if all of the flags in `other` are contained within `self`.\n-    fn contains(&self, other: Self) -> bool;\n+    fn contains(&self, other: Self) -> bool\n+    where\n+        Self: Sized,\n+    {\n+        self.bits() & other.bits() == other.bits()\n+    }\n \n     /// Inserts the specified flags in-place.\n-    fn insert(&mut self, other: Self);\n+    fn insert(&mut self, other: Self)\n+    where\n+        Self: Sized,\n+    {\n+        *self = Self::from_bits_retain(self.bits() | other.bits());\n+    }\n \n     /// Removes the specified flags in-place.\n-    fn remove(&mut self, other: Self);\n+    fn remove(&mut self, other: Self)\n+    where\n+        Self: Sized,\n+    {\n+        *self = Self::from_bits_retain(self.bits() & !other.bits());\n+    }\n \n     /// Toggles the specified flags in-place.\n-    fn toggle(&mut self, other: Self);\n+    fn toggle(&mut self, other: Self)\n+    where\n+        Self: Sized,\n+    {\n+        *self = Self::from_bits_retain(self.bits() ^ other.bits());\n+    }\n \n     /// Inserts or removes the specified flags depending on the passed value.\n-    fn set(&mut self, other: Self, value: bool);\n-}\n+    fn set(&mut self, other: Self, value: bool)\n+    where\n+        Self: Sized,\n+    {\n+        if value {\n+            self.insert(other);\n+        } else {\n+            self.remove(other);\n+        }\n+    }\n \n-/// A marker trait that signals that an implementation of `BitFlags` came from the `bitflags!` macro.\n-///\n-/// There's nothing stopping an end-user from implementing this trait, but we don't guarantee their\n-/// manual implementations won't break between non-breaking releases.\n-#[doc(hidden)]\n-pub trait ImplementedByBitFlagsMacro {}\n+    /// Returns the intersection between the flags in `self` and\n+    /// `other`.\n+    ///\n+    /// Specifically, the returned set contains only the flags which are\n+    /// present in *both* `self` *and* `other`.\n+    #[must_use]\n+    fn intersection(self, other: Self) -> Self {\n+        Self::from_bits_retain(self.bits() & other.bits())\n+    }\n \n-// Not re-exported\n-pub trait Sealed {}\n+    /// Returns the union of between the flags in `self` and `other`.\n+    ///\n+    /// Specifically, the returned set contains all flags which are\n+    /// present in *either* `self` *or* `other`, including any which are\n+    /// present in both (see [`Self::symmetric_difference`] if that\n+    /// is undesirable).\n+    #[must_use]\n+    fn union(self, other: Self) -> Self {\n+        Self::from_bits_retain(self.bits() | other.bits())\n+    }\n \n-// Private implementation details\n-//\n-// The `Bits`, `PublicFlags`, and `InternalFlags` traits are implementation details of the `bitflags!`\n-// macro that we're free to change here. They work with the `bitflags!` macro to separate the generated\n-// code that belongs to end-users, and the generated code that belongs to this library.\n+    /// Returns the difference between the flags in `self` and `other`.\n+    ///\n+    /// Specifically, the returned set contains all flags present in\n+    /// `self`, except for the ones present in `other`.\n+    ///\n+    /// It is also conceptually equivalent to the \"bit-clear\" operation:\n+    /// `flags & !other` (and this syntax is also supported).\n+    #[must_use]\n+    fn difference(self, other: Self) -> Self {\n+        Self::from_bits_retain(self.bits() & !other.bits())\n+    }\n \n-/// A private trait that encodes the requirements of underlying bits types that can hold flags.\n-///\n-/// This trait may be made public at some future point, but it presents a compatibility hazard\n-/// so is left internal for now.\n-#[doc(hidden)]\n+    /// Returns the [symmetric difference][sym-diff] between the flags\n+    /// in `self` and `other`.\n+    ///\n+    /// Specifically, the returned set contains the flags present which\n+    /// are present in `self` or `other`, but that are not present in\n+    /// both. Equivalently, it contains the flags present in *exactly\n+    /// one* of the sets `self` and `other`.\n+    ///\n+    /// [sym-diff]: https://en.wikipedia.org/wiki/Symmetric_difference\n+    #[must_use]\n+    fn symmetric_difference(self, other: Self) -> Self {\n+        Self::from_bits_retain(self.bits() ^ other.bits())\n+    }\n+\n+    /// Returns the complement of this set of flags.\n+    ///\n+    /// Specifically, the returned set contains all the flags which are\n+    /// not set in `self`, but which are allowed for this type.\n+    #[must_use]\n+    fn complement(self) -> Self {\n+        Self::from_bits_truncate(!self.bits())\n+    }\n+}\n+\n+/// Underlying storage for a flags type.\n pub trait Bits:\n     Clone\n     + Copy\n-    + BitAnd\n-    + BitAndAssign\n-    + BitOr\n-    + BitOrAssign\n-    + BitXor\n-    + BitXorAssign\n-    + Not\n+    + PartialEq\n+    + BitAnd<Output = Self>\n+    + BitOr<Output = Self>\n+    + BitXor<Output = Self>\n+    + Not<Output = Self>\n     + Sized\n-    + Sealed\n+    + 'static\n {\n     /// The value of `Self` where no bits are set.\n     const EMPTY: Self;\n@@ -121,6 +254,10 @@ pub trait Bits:\n     const ALL: Self;\n }\n \n+// Not re-exported: prevent custom `Bits` impls being used in the `bitflags!` macro,\n+// or they may fail to compile based on crate features\n+pub trait Primitive {}\n+\n macro_rules! impl_bits {\n     ($($u:ty, $i:ty,)*) => {\n         $(\n@@ -134,8 +271,32 @@ macro_rules! impl_bits {\n                 const ALL: $i = <$u>::MAX as $i;\n             }\n \n-            impl Sealed for $u {}\n-            impl Sealed for $i {}\n+            impl ParseHex for $u {\n+                fn parse_hex(input: &str) -> Result<Self, ParseError> {\n+                    <$u>::from_str_radix(input, 16).map_err(|_| ParseError::invalid_hex_flag(input))\n+                }\n+            }\n+\n+            impl ParseHex for $i {\n+                fn parse_hex(input: &str) -> Result<Self, ParseError> {\n+                    <$i>::from_str_radix(input, 16).map_err(|_| ParseError::invalid_hex_flag(input))\n+                }\n+            }\n+\n+            impl WriteHex for $u {\n+                fn write_hex<W: fmt::Write>(&self, mut writer: W) -> fmt::Result {\n+                    write!(writer, \"{:x}\", self)\n+                }\n+            }\n+\n+            impl WriteHex for $i {\n+                fn write_hex<W: fmt::Write>(&self, mut writer: W) -> fmt::Result {\n+                    write!(writer, \"{:x}\", self)\n+                }\n+            }\n+\n+            impl Primitive for $i {}\n+            impl Primitive for $u {}\n         )*\n     }\n }\n@@ -152,6 +313,37 @@ impl_bits! {\n /// A trait for referencing the `bitflags`-owned internal type\n /// without exposing it publicly.\n pub trait PublicFlags {\n+    /// The type of the underlying storage.\n+    type Primitive: Primitive;\n+\n     /// The type of the internal field on the generated flags type.\n     type Internal;\n }\n+\n+#[deprecated(note = \"use the `Flags` trait instead\")]\n+pub trait BitFlags: ImplementedByBitFlagsMacro + Flags {\n+    /// An iterator over enabled flags in an instance of the type.\n+    type Iter: Iterator<Item = Self>;\n+\n+    /// An iterator over the raw names and bits for enabled flags in an instance of the type.\n+    type IterNames: Iterator<Item = (&'static str, Self)>;\n+}\n+\n+#[allow(deprecated)]\n+impl<B: Flags> BitFlags for B {\n+    type Iter = iter::Iter<Self>;\n+    type IterNames = iter::IterNames<Self>;\n+}\n+\n+impl<B: Flags> ImplementedByBitFlagsMacro for B {}\n+\n+/// A marker trait that signals that an implementation of `BitFlags` came from the `bitflags!` macro.\n+///\n+/// There's nothing stopping an end-user from implementing this trait, but we don't guarantee their\n+/// manual implementations won't break between non-breaking releases.\n+#[doc(hidden)]\n+pub trait ImplementedByBitFlagsMacro {}\n+\n+pub(crate) mod __private {\n+    pub use super::{ImplementedByBitFlagsMacro, PublicFlags};\n+}\n", "test_patch": "diff --git a/tests/compile-fail/visibility/private_flags.rs b/tests/compile-fail/access_outside_visibility.rs\nsimilarity index 100%\nrename from tests/compile-fail/visibility/private_flags.rs\nrename to tests/compile-fail/access_outside_visibility.rs\ndiff --git a/tests/compile-fail/visibility/private_flags.stderr b/tests/compile-fail/access_outside_visibility.stderr\nsimilarity index 54%\nrename from tests/compile-fail/visibility/private_flags.stderr\nrename to tests/compile-fail/access_outside_visibility.stderr\nindex 47a53c25..3106b9a2 100644\n--- a/tests/compile-fail/visibility/private_flags.stderr\n+++ b/tests/compile-fail/access_outside_visibility.stderr\n@@ -1,11 +1,11 @@\n error[E0603]: struct `Flags2` is private\n-  --> tests/compile-fail/visibility/private_flags.rs:17:22\n+  --> tests/compile-fail/access_outside_visibility.rs:17:22\n    |\n 17 |     let _ = example::Flags2::FLAG_B;\n    |                      ^^^^^^ private struct\n    |\n note: the struct `Flags2` is defined here\n-  --> tests/compile-fail/visibility/private_flags.rs:4:5\n+  --> tests/compile-fail/access_outside_visibility.rs:4:5\n    |\n 4  | /     bitflags! {\n 5  | |         pub struct Flags1: u32 {\n@@ -15,4 +15,4 @@ note: the struct `Flags2` is defined here\n 11 | |         }\n 12 | |     }\n    | |_____^\n-   = note: this error originates in the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the macro `__declare_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.rs b/tests/compile-fail/bitflags_custom_bits.rs\nsimilarity index 86%\nrename from tests/compile-fail/non_integer_base/all_defined.rs\nrename to tests/compile-fail/bitflags_custom_bits.rs\nindex c2856b10..46fde469 100644\n--- a/tests/compile-fail/non_integer_base/all_defined.rs\n+++ b/tests/compile-fail/bitflags_custom_bits.rs\n@@ -19,13 +19,18 @@ use std::{\n     },\n };\n \n-use bitflags::bitflags;\n+use bitflags::{bitflags, Bits, parser::{ParseError, FromHex}};\n \n // Ideally we'd actually want this to work, but currently need something like `num`'s `Zero`\n // With some design work it could be made possible\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n struct MyInt(u8);\n \n+impl Bits for MyInt {\n+    const EMPTY: Self = MyInt(u8::MIN);\n+    const ALL: Self = MyInt(u8::MAX);\n+}\n+\n impl BitAnd for MyInt {\n     type Output = Self;\n \n@@ -68,6 +73,14 @@ impl BitXorAssign for MyInt {\n     }\n }\n \n+impl Not for MyInt {\n+    type Output = MyInt;\n+\n+    fn not(self) -> Self {\n+        MyInt(!self.0)\n+    }\n+}\n+\n impl Debug for MyInt {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         Debug::fmt(&self.0, f)\n@@ -104,11 +117,9 @@ impl Binary for MyInt {\n     }\n }\n \n-impl Not for MyInt {\n-    type Output = MyInt;\n-\n-    fn not(self) -> Self {\n-        MyInt(!self.0)\n+impl FromHex for MyInt {\n+    fn from_hex(input: &str) -> Result<Self, ParseError> {\n+        Ok(MyInt(u8::from_str_radix(input, 16).map_err(|_| ParseError::invalid_hex_flag(input))?))\n     }\n }\n \ndiff --git a/tests/compile-fail/bitflags_custom_bits.stderr b/tests/compile-fail/bitflags_custom_bits.stderr\nnew file mode 100644\nindex 00000000..c74c27f0\n--- /dev/null\n+++ b/tests/compile-fail/bitflags_custom_bits.stderr\n@@ -0,0 +1,461 @@\n+error[E0277]: the trait bound `MyInt: bitflags::traits::Primitive` is not satisfied\n+   --> tests/compile-fail/bitflags_custom_bits.rs:127:22\n+    |\n+127 |     struct Flags128: MyInt {\n+    |                      ^^^^^ the trait `bitflags::traits::Primitive` is not implemented for `MyInt`\n+    |\n+    = help: the following other types implement trait `bitflags::traits::Primitive`:\n+              i128\n+              i16\n+              i32\n+              i64\n+              i8\n+              isize\n+              u128\n+              u16\n+            and $N others\n+note: required by a bound in `PublicFlags::Primitive`\n+   --> src/traits.rs\n+    |\n+    |     type Primitive: Primitive;\n+    |                     ^^^^^^^^^ required by this bound in `PublicFlags::Primitive`\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt & MyInt`\n+    |\n+    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n+note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt | MyInt`\n+    |\n+    = help: the trait `~const BitOr` is not implemented for `MyInt`\n+note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt | MyInt`\n+    |\n+    = help: the trait `~const BitOr` is not implemented for `MyInt`\n+note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt & MyInt`\n+    |\n+    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n+note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt & MyInt`\n+    |\n+    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n+note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: can't compare `MyInt` with `_` in const contexts\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt == _`\n+    |\n+    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n+note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt & MyInt`\n+    |\n+    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n+note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitOr` is not satisfied\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt | MyInt`\n+    |\n+    = help: the trait `~const BitOr` is not implemented for `MyInt`\n+note: the trait `BitOr` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitAnd` is not satisfied\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt & MyInt`\n+    |\n+    = help: the trait `~const BitAnd` is not implemented for `MyInt`\n+note: the trait `BitAnd` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: Not` is not satisfied\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ the trait `~const Not` is not implemented for `MyInt`\n+    |\n+note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: BitXor` is not satisfied\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ no implementation for `MyInt ^ MyInt`\n+    |\n+    = help: the trait `~const BitXor` is not implemented for `MyInt`\n+note: the trait `BitXor` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0277]: the trait bound `MyInt: Not` is not satisfied\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^ the trait `~const Not` is not implemented for `MyInt`\n+    |\n+note: the trait `Not` is implemented for `MyInt`, but that implementation is not `const`\n+   --> tests/compile-fail/bitflags_custom_bits.rs:126:1\n+    |\n+126 | / bitflags! {\n+127 | |     struct Flags128: MyInt {\n+128 | |         const A = MyInt(0b0000_0001u8);\n+129 | |         const B = MyInt(0b0000_0010u8);\n+130 | |         const C = MyInt(0b0000_0100u8);\n+131 | |     }\n+132 | | }\n+    | |_^\n+    = note: this error originates in the macro `__impl_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a/tests/compile-fail/syntax/missing_type.rs b/tests/compile-fail/bitflags_missing_type.rs\nsimilarity index 100%\nrename from tests/compile-fail/syntax/missing_type.rs\nrename to tests/compile-fail/bitflags_missing_type.rs\ndiff --git a/tests/compile-fail/bitflags_missing_type.stderr b/tests/compile-fail/bitflags_missing_type.stderr\nnew file mode 100644\nindex 00000000..dd9805b8\n--- /dev/null\n+++ b/tests/compile-fail/bitflags_missing_type.stderr\n@@ -0,0 +1,17 @@\n+error: no rules expected the token `{`\n+ --> tests/compile-fail/bitflags_missing_type.rs:5:23\n+  |\n+5 |     pub struct Flags1 {\n+  |                       ^ no rules expected this token in macro call\n+  |\n+note: while trying to match `:`\n+ --> src/lib.rs\n+  |\n+  |         $vis:vis struct $BitFlags:ident: $T:ty {\n+  |                                        ^\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+ --> tests/compile-fail/bitflags_missing_type.rs:8:2\n+  |\n+8 | }\n+  |  ^ consider adding a `main` function to `$DIR/tests/compile-fail/bitflags_missing_type.rs`\ndiff --git a/tests/compile-fail/syntax/missing_value.rs b/tests/compile-fail/bitflags_missing_value.rs\nsimilarity index 71%\nrename from tests/compile-fail/syntax/missing_value.rs\nrename to tests/compile-fail/bitflags_missing_value.rs\nindex c1221035..3e6c557b 100644\n--- a/tests/compile-fail/syntax/missing_value.rs\n+++ b/tests/compile-fail/bitflags_missing_value.rs\n@@ -2,7 +2,7 @@\n extern crate bitflags;\n \n bitflags! {\n-    pub struct Flags1 {\n+    pub struct Flags1: u32 {\n         const A;\n     }\n }\ndiff --git a/tests/compile-fail/bitflags_missing_value.stderr b/tests/compile-fail/bitflags_missing_value.stderr\nnew file mode 100644\nindex 00000000..8c17c97d\n--- /dev/null\n+++ b/tests/compile-fail/bitflags_missing_value.stderr\n@@ -0,0 +1,17 @@\n+error: no rules expected the token `;`\n+ --> tests/compile-fail/bitflags_missing_value.rs:6:16\n+  |\n+6 |         const A;\n+  |                ^ no rules expected this token in macro call\n+  |\n+note: while trying to match `=`\n+ --> src/lib.rs\n+  |\n+  |                 const $Flag:ident = $value:expr;\n+  |                                   ^\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+ --> tests/compile-fail/bitflags_missing_value.rs:8:2\n+  |\n+8 | }\n+  |  ^ consider adding a `main` function to `$DIR/tests/compile-fail/bitflags_missing_value.rs`\ndiff --git a/tests/compile-fail/visibility/pub_const.rs b/tests/compile-fail/bitflags_pub_const.rs\nsimilarity index 100%\nrename from tests/compile-fail/visibility/pub_const.rs\nrename to tests/compile-fail/bitflags_pub_const.rs\ndiff --git a/tests/compile-fail/visibility/pub_const.stderr b/tests/compile-fail/bitflags_pub_const.stderr\nsimilarity index 52%\nrename from tests/compile-fail/visibility/pub_const.stderr\nrename to tests/compile-fail/bitflags_pub_const.stderr\nindex b01122c7..3e5cedb8 100644\n--- a/tests/compile-fail/visibility/pub_const.stderr\n+++ b/tests/compile-fail/bitflags_pub_const.stderr\n@@ -1,5 +1,11 @@\n error: no rules expected the token `pub`\n- --> $DIR/pub_const.rs:5:9\n+ --> tests/compile-fail/bitflags_pub_const.rs:5:9\n   |\n 5 |         pub const FLAG_A = 0b00000001;\n   |         ^^^ no rules expected this token in macro call\n+  |\n+note: while trying to match `}`\n+ --> src/lib.rs\n+  |\n+  |         }\n+  |         ^\ndiff --git a/tests/compile-fail/redefined.rs b/tests/compile-fail/bitflags_redefined.rs\nsimilarity index 67%\nrename from tests/compile-fail/redefined.rs\nrename to tests/compile-fail/bitflags_redefined.rs\nindex 6d194d6c..07941f36 100644\n--- a/tests/compile-fail/redefined.rs\n+++ b/tests/compile-fail/bitflags_redefined.rs\n@@ -2,13 +2,13 @@\n extern crate bitflags;\n \n bitflags! {\n-    pub struct Flags1 {\n+    pub struct Flags1: u32 {\n         const A = 1;\n     }\n }\n \n bitflags! {\n-    pub struct Flags1 {\n+    pub struct Flags1: u32 {\n         const A = 1;\n     }\n }\ndiff --git a/tests/compile-fail/bitflags_redefined.stderr b/tests/compile-fail/bitflags_redefined.stderr\nnew file mode 100644\nindex 00000000..a1611a1c\n--- /dev/null\n+++ b/tests/compile-fail/bitflags_redefined.stderr\n@@ -0,0 +1,804 @@\n+error[E0428]: the name `Flags1` is defined multiple times\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ `Flags1` redefined here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- previous definition of the type `Flags1` here\n+   |\n+   = note: `Flags1` must be defined only once in the type namespace of this module\n+   = note: this error originates in the macro `__declare_public_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0601]: `main` function not found in crate `$CRATE`\n+  --> tests/compile-fail/bitflags_redefined.rs:14:2\n+   |\n+14 | }\n+   |  ^ consider adding a `main` function to `$DIR/tests/compile-fail/bitflags_redefined.rs`\n+\n+error[E0119]: conflicting implementations of trait `Flags` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_consts` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `PublicFlags` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `Binary` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `Octal` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `LowerHex` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `UpperHex` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `BitOr` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `BitOrAssign` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `BitXor` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `BitXorAssign` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `BitAnd` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `BitAndAssign` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `Sub` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `SubAssign` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `Not` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `Extend<Flags1>` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `FromIterator<Flags1>` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_ops` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0119]: conflicting implementations of trait `IntoIterator` for type `Flags1`\n+  --> tests/compile-fail/bitflags_redefined.rs:10:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_- first implementation here\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_^ conflicting implementation for `Flags1`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_iter` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `A`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `A`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `A`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_consts` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `empty`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `empty`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `empty`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `all`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `all`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `all`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `bits`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `bits`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `bits`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `from_bits`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `from_bits`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `from_bits`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `from_bits_truncate`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `from_bits_truncate`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `from_bits_truncate`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `from_bits_retain`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `from_bits_retain`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `from_bits_retain`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `from_name`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `from_name`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `from_name`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `is_empty`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `is_empty`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `is_empty`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `is_all`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `is_all`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `is_all`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `intersects`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `intersects`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `intersects`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `contains`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `contains`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `contains`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `insert`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `insert`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `insert`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `remove`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `remove`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `remove`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `toggle`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `toggle`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `toggle`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `set`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `set`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `set`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `intersection`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `intersection`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `intersection`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `union`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `union`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `union`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `difference`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `difference`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `difference`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `symmetric_difference`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `symmetric_difference`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `symmetric_difference`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `complement`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `complement`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `complement`\n+   |\n+   = note: this error originates in the macro `__impl_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `iter`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `iter`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `iter`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_iter` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0592]: duplicate definitions with name `iter_names`\n+  --> tests/compile-fail/bitflags_redefined.rs:4:1\n+   |\n+4  | / bitflags! {\n+5  | |     pub struct Flags1: u32 {\n+6  | |         const A = 1;\n+7  | |     }\n+8  | | }\n+   | |_^ duplicate definitions for `iter_names`\n+9  |\n+10 | / bitflags! {\n+11 | |     pub struct Flags1: u32 {\n+12 | |         const A = 1;\n+13 | |     }\n+14 | | }\n+   | |_- other definition for `iter_names`\n+   |\n+   = note: this error originates in the macro `__impl_public_bitflags_iter` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a/tests/compile-fail/bitflags_trait_custom.rs b/tests/compile-fail/bitflags_trait_custom.rs\nnew file mode 100644\nindex 00000000..945419c1\n--- /dev/null\n+++ b/tests/compile-fail/bitflags_trait_custom.rs\n@@ -0,0 +1,9 @@\n+use bitflags::BitFlags;\n+\n+pub struct BootlegFlags(u32);\n+\n+impl BitFlags for BootlegFlags {\n+    type Bits = u32;\n+}\n+\n+fn main() {}\ndiff --git a/tests/compile-fail/bitflags_trait_custom.stderr b/tests/compile-fail/bitflags_trait_custom.stderr\nnew file mode 100644\nindex 00000000..b42f471d\n--- /dev/null\n+++ b/tests/compile-fail/bitflags_trait_custom.stderr\n@@ -0,0 +1,31 @@\n+error[E0437]: type `Bits` is not a member of trait `BitFlags`\n+ --> tests/compile-fail/bitflags_trait_custom.rs:6:5\n+  |\n+6 |     type Bits = u32;\n+  |     ^^^^^^^^^^^^^^^^ not a member of trait `BitFlags`\n+\n+warning: use of deprecated trait `bitflags::BitFlags`: use the `Flags` trait instead\n+ --> tests/compile-fail/bitflags_trait_custom.rs:1:15\n+  |\n+1 | use bitflags::BitFlags;\n+  |               ^^^^^^^^\n+  |\n+  = note: `#[warn(deprecated)]` on by default\n+\n+warning: use of deprecated trait `bitflags::BitFlags`: use the `Flags` trait instead\n+ --> tests/compile-fail/bitflags_trait_custom.rs:5:6\n+  |\n+5 | impl BitFlags for BootlegFlags {\n+  |      ^^^^^^^^\n+\n+error[E0277]: the trait bound `BootlegFlags: Flags` is not satisfied\n+ --> tests/compile-fail/bitflags_trait_custom.rs:5:19\n+  |\n+5 | impl BitFlags for BootlegFlags {\n+  |                   ^^^^^^^^^^^^ the trait `Flags` is not implemented for `BootlegFlags`\n+  |\n+note: required by a bound in `BitFlags`\n+ --> src/traits.rs\n+  |\n+  | pub trait BitFlags: ImplementedByBitFlagsMacro + Flags {\n+  |                                                  ^^^^^ required by this bound in `BitFlags`\ndiff --git a/tests/compile-fail/bitflags_trait_deprecated.rs b/tests/compile-fail/bitflags_trait_deprecated.rs\nnew file mode 100644\nindex 00000000..d17464e5\n--- /dev/null\n+++ b/tests/compile-fail/bitflags_trait_deprecated.rs\n@@ -0,0 +1,5 @@\n+#![deny(warnings)]\n+\n+pub use bitflags::BitFlags;\n+\n+fn main() {}\ndiff --git a/tests/compile-fail/bitflags_trait_deprecated.stderr b/tests/compile-fail/bitflags_trait_deprecated.stderr\nnew file mode 100644\nindex 00000000..1c81656c\n--- /dev/null\n+++ b/tests/compile-fail/bitflags_trait_deprecated.stderr\n@@ -0,0 +1,12 @@\n+error: use of deprecated trait `bitflags::BitFlags`: use the `Flags` trait instead\n+ --> tests/compile-fail/bitflags_trait_deprecated.rs:3:19\n+  |\n+3 | pub use bitflags::BitFlags;\n+  |                   ^^^^^^^^\n+  |\n+note: the lint level is defined here\n+ --> tests/compile-fail/bitflags_trait_deprecated.rs:1:9\n+  |\n+1 | #![deny(warnings)]\n+  |         ^^^^^^^^\n+  = note: `#[deny(deprecated)]` implied by `#[deny(warnings)]`\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\ndeleted file mode 100644\nindex e477281c..00000000\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ /dev/null\n@@ -1,297 +0,0 @@\n-error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:116:22\n-    |\n-116 |     struct Flags128: MyInt {\n-    |                      ^^^^^ the trait `Bits` is not implemented for `MyInt`\n-    |\n-    = help: the following other types implement trait `Bits`:\n-              i128\n-              i16\n-              i32\n-              i64\n-              i8\n-              u128\n-              u16\n-              u32\n-            and 2 others\n-note: required by a bound in `bitflags::BitFlags::Bits`\n-   --> src/bitflags_trait.rs\n-    |\n-    |     type Bits: Bits;\n-    |                ^^^^ required by this bound in `bitflags::BitFlags::Bits`\n-\n-error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ the trait `Bits` is not implemented for `MyInt`\n-    |\n-    = help: the following other types implement trait `Bits`:\n-              i128\n-              i16\n-              i32\n-              i64\n-              i8\n-              u128\n-              u16\n-              u32\n-            and 2 others\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ the trait `Bits` is not implemented for `MyInt`\n-    |\n-    = help: the following other types implement trait `Bits`:\n-              i128\n-              i16\n-              i32\n-              i64\n-              i8\n-              u128\n-              u16\n-              u32\n-            and 2 others\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ the trait `Bits` is not implemented for `MyInt`\n-    |\n-    = help: the following other types implement trait `Bits`:\n-              i128\n-              i16\n-              i32\n-              i64\n-              i8\n-              u128\n-              u16\n-              u32\n-            and 2 others\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ the trait `Bits` is not implemented for `MyInt`\n-    |\n-    = help: the following other types implement trait `Bits`:\n-              i128\n-              i16\n-              i32\n-              i64\n-              i8\n-              u128\n-              u16\n-              u32\n-            and 2 others\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ the trait `Bits` is not implemented for `MyInt`\n-    |\n-    = help: the following other types implement trait `Bits`:\n-              i128\n-              i16\n-              i32\n-              i64\n-              i8\n-              u128\n-              u16\n-              u32\n-            and 2 others\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error[E0277]: can't compare `MyInt` with `_` in const contexts\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ no implementation for `MyInt == _`\n-    |\n-    = help: the trait `~const PartialEq<_>` is not implemented for `MyInt`\n-note: the trait `PartialEq<_>` is implemented for `MyInt`, but that implementation is not `const`\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^\n-    = note: this error originates in the macro `__impl_internal_bitflags` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a/tests/compile-fail/non_integer_base/all_missing.rs b/tests/compile-fail/non_integer_base/all_missing.rs\ndeleted file mode 100644\nindex fff6b2cc..00000000\n--- a/tests/compile-fail/non_integer_base/all_missing.rs\n+++ /dev/null\n@@ -1,13 +0,0 @@\n-use bitflags::bitflags;\n-\n-struct MyInt(u8);\n-\n-bitflags! {\n-    struct Flags128: MyInt {\n-        const A = MyInt(0b0000_0001);\n-        const B = MyInt(0b0000_0010);\n-        const C = MyInt(0b0000_0100);\n-    }\n-}\n-\n-fn main() {}\ndiff --git a/tests/compile-fail/non_integer_base/all_missing.stderr b/tests/compile-fail/non_integer_base/all_missing.stderr\ndeleted file mode 100644\nindex 7f047c68..00000000\n--- a/tests/compile-fail/non_integer_base/all_missing.stderr\n+++ /dev/null\n@@ -1,13 +0,0 @@\n-error[E0204]: the trait `Copy` may not be implemented for this type\n-  --> tests/compile-fail/non_integer_base/all_missing.rs:5:1\n-   |\n-5  | / bitflags! {\n-6  | |     struct Flags128: MyInt {\n-7  | |         const A = MyInt(0b0000_0001);\n-8  | |         const B = MyInt(0b0000_0010);\n-9  | |         const C = MyInt(0b0000_0100);\n-10 | |     }\n-11 | | }\n-   | |_^ this field does not implement `Copy`\n-   |\n-   = note: this error originates in the derive macro `Copy` which comes from the expansion of the macro `bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a/tests/compile-fail/redefined.stderr b/tests/compile-fail/redefined.stderr\ndeleted file mode 100644\nindex 85bc7f10..00000000\n--- a/tests/compile-fail/redefined.stderr\n+++ /dev/null\n@@ -1,17 +0,0 @@\n-error: no rules expected the token `{`\n- --> tests/compile-fail/redefined.rs:5:23\n-  |\n-5 |     pub struct Flags1 {\n-  |                       ^ no rules expected this token in macro call\n-\n-error: no rules expected the token `{`\n-  --> tests/compile-fail/redefined.rs:11:23\n-   |\n-11 |     pub struct Flags1 {\n-   |                       ^ no rules expected this token in macro call\n-\n-error[E0601]: `main` function not found in crate `$CRATE`\n-  --> tests/compile-fail/redefined.rs:14:2\n-   |\n-14 | }\n-   |  ^ consider adding a `main` function to `$DIR/tests/compile-fail/redefined.rs`\ndiff --git a/tests/compile-fail/syntax/missing_type.stderr b/tests/compile-fail/syntax/missing_type.stderr\ndeleted file mode 100644\nindex ed8c8ac4..00000000\n--- a/tests/compile-fail/syntax/missing_type.stderr\n+++ /dev/null\n@@ -1,11 +0,0 @@\n-error: no rules expected the token `{`\n- --> tests/compile-fail/syntax/missing_type.rs:5:23\n-  |\n-5 |     pub struct Flags1 {\n-  |                       ^ no rules expected this token in macro call\n-\n-error[E0601]: `main` function not found in crate `$CRATE`\n- --> tests/compile-fail/syntax/missing_type.rs:8:2\n-  |\n-8 | }\n-  |  ^ consider adding a `main` function to `$DIR/tests/compile-fail/syntax/missing_type.rs`\ndiff --git a/tests/compile-fail/syntax/missing_value.stderr b/tests/compile-fail/syntax/missing_value.stderr\ndeleted file mode 100644\nindex 6b1b46a1..00000000\n--- a/tests/compile-fail/syntax/missing_value.stderr\n+++ /dev/null\n@@ -1,11 +0,0 @@\n-error: no rules expected the token `{`\n- --> tests/compile-fail/syntax/missing_value.rs:5:23\n-  |\n-5 |     pub struct Flags1 {\n-  |                       ^ no rules expected this token in macro call\n-\n-error[E0601]: `main` function not found in crate `$CRATE`\n- --> tests/compile-fail/syntax/missing_value.rs:8:2\n-  |\n-8 | }\n-  |  ^ consider adding a `main` function to `$DIR/tests/compile-fail/syntax/missing_value.rs`\ndiff --git a/tests/compile-fail/trait/custom_impl.rs b/tests/compile-fail/trait/custom_impl.rs\ndeleted file mode 100644\nindex 55dd929d..00000000\n--- a/tests/compile-fail/trait/custom_impl.rs\n+++ /dev/null\n@@ -1,65 +0,0 @@\n-use bitflags::BitFlags;\n-\n-pub struct BootlegFlags(u32);\n-\n-impl BitFlags for BootlegFlags {\n-    type Bits = u32;\n-\n-    fn empty() -> Self {\n-        unimplemented!()\n-    }\n-\n-    fn all() -> Self {\n-        unimplemented!()\n-    }\n-\n-    fn bits(&self) -> u32 {\n-        unimplemented!()\n-    }\n-\n-    fn from_bits(_: u32) -> Option<BootlegFlags> {\n-        unimplemented!()\n-    }\n-\n-    fn from_bits_truncate(_: u32) -> BootlegFlags {\n-        unimplemented!()\n-    }\n-\n-    fn from_bits_retain(_: u32) -> BootlegFlags {\n-        unimplemented!()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        unimplemented!()\n-    }\n-\n-    fn is_all(&self) -> bool {\n-        unimplemented!()\n-    }\n-\n-    fn intersects(&self, _: BootlegFlags) -> bool {\n-        unimplemented!()\n-    }\n-\n-    fn contains(&self, _: BootlegFlags) -> bool {\n-        unimplemented!()\n-    }\n-\n-    fn insert(&mut self, _: BootlegFlags) {\n-        unimplemented!()\n-    }\n-\n-    fn remove(&mut self, _: BootlegFlags) {\n-        unimplemented!()\n-    }\n-\n-    fn toggle(&mut self, _: BootlegFlags) {\n-        unimplemented!()\n-    }\n-\n-    fn set(&mut self, _: BootlegFlags, value: bool) {\n-        unimplemented!()\n-    }\n-}\n-\n-fn main() {}\ndiff --git a/tests/compile-fail/trait/custom_impl.stderr b/tests/compile-fail/trait/custom_impl.stderr\ndeleted file mode 100644\nindex d7e8d494..00000000\n--- a/tests/compile-fail/trait/custom_impl.stderr\n+++ /dev/null\n@@ -1,11 +0,0 @@\n-error[E0277]: the trait bound `BootlegFlags: ImplementedByBitFlagsMacro` is not satisfied\n- --> tests/compile-fail/trait/custom_impl.rs:5:6\n-  |\n-5 | impl BitFlags for BootlegFlags {\n-  |      ^^^^^^^^ the trait `ImplementedByBitFlagsMacro` is not implemented for `BootlegFlags`\n-  |\n-note: required by a bound in `BitFlags`\n- --> src/bitflags_trait.rs\n-  |\n-  | pub trait BitFlags: ImplementedByBitFlagsMacro {\n-  |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `BitFlags`\ndiff --git a/tests/compile-pass/cfg/nested-value.rs b/tests/compile-pass/bitflags_nested_value.rs\nsimilarity index 100%\nrename from tests/compile-pass/cfg/nested-value.rs\nrename to tests/compile-pass/bitflags_nested_value.rs\ndiff --git a/tests/compile-pass/cfg/redefined-value.rs b/tests/compile-pass/bitflags_redefined_value.rs\nsimilarity index 100%\nrename from tests/compile-pass/cfg/redefined-value.rs\nrename to tests/compile-pass/bitflags_redefined_value.rs\ndiff --git a/tests/compile-pass/bitflags_trait_bound_flags.rs b/tests/compile-pass/bitflags_trait_bound_flags.rs\nnew file mode 100644\nindex 00000000..7a4d204a\n--- /dev/null\n+++ b/tests/compile-pass/bitflags_trait_bound_flags.rs\n@@ -0,0 +1,19 @@\n+#![allow(deprecated)]\n+\n+use bitflags::{BitFlags, Flags};\n+\n+pub trait MyCustomFlagsTrait {\n+    fn uses_flags<B: BitFlags>(flags: B);\n+}\n+\n+pub struct MyCustomFlags;\n+\n+impl MyCustomFlagsTrait for MyCustomFlags {\n+    fn uses_flags<B: Flags>(_: B) {\n+\n+    }\n+}\n+\n+fn main() {\n+\n+}\ndiff --git a/tests/compile-pass/trait/generic_iter.rs b/tests/compile-pass/bitflags_trait_generic_iter.rs\nsimilarity index 92%\nrename from tests/compile-pass/trait/generic_iter.rs\nrename to tests/compile-pass/bitflags_trait_generic_iter.rs\nindex 686a303f..1310bd01 100644\n--- a/tests/compile-pass/trait/generic_iter.rs\n+++ b/tests/compile-pass/bitflags_trait_generic_iter.rs\n@@ -1,3 +1,5 @@\n+#![allow(deprecated)]\n+\n use bitflags::{bitflags, BitFlags};\n \n bitflags! {\ndiff --git a/tests/compile-pass/trait/precedence.rs b/tests/compile-pass/bitflags_trait_precedence.rs\nsimilarity index 93%\nrename from tests/compile-pass/trait/precedence.rs\nrename to tests/compile-pass/bitflags_trait_precedence.rs\nindex f61db85d..a603233e 100644\n--- a/tests/compile-pass/trait/precedence.rs\n+++ b/tests/compile-pass/bitflags_trait_precedence.rs\n@@ -1,3 +1,5 @@\n+#![allow(deprecated)]\n+\n use bitflags::{bitflags, BitFlags};\n \n bitflags! {\ndiff --git a/tests/compile-pass/bitflags_trait_supertrait.rs b/tests/compile-pass/bitflags_trait_supertrait.rs\nnew file mode 100644\nindex 00000000..5f87dd91\n--- /dev/null\n+++ b/tests/compile-pass/bitflags_trait_supertrait.rs\n@@ -0,0 +1,80 @@\n+#![allow(deprecated)]\n+\n+// From: https://github.com/bitflags/bitflags/issues/293#issuecomment-1493296383\n+use core::{\n+    fmt::{Binary, LowerHex, Octal, UpperHex},\n+    ops::{\n+        Add, AddAssign, BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Div, DivAssign,\n+        Mul, MulAssign, Not, Rem, RemAssign, Shl, ShlAssign, Shr, ShrAssign, Sub, SubAssign,\n+    }\n+};\n+\n+use bitflags::{bitflags, BitFlags};\n+\n+pub trait BitFlagsExt {\n+    fn complement_retain(self) -> Self;\n+    fn has_uncorresponding_bits(self) -> bool;\n+}\n+impl<T, U> BitFlagsExt for T\n+where\n+    T: BitFlags<Bits = U>\n+        + BitAnd<Output = T>\n+        + BitAndAssign\n+        + BitOr<Output = T>\n+        + BitOrAssign\n+        + BitXor<Output = T>\n+        + BitXorAssign\n+        + Not<Output = T>\n+        + Sub<Output = T>\n+        + SubAssign\n+        + Extend<T>\n+        + FromIterator<T>\n+        + IntoIterator\n+        + Binary\n+        + LowerHex\n+        + Octal\n+        + UpperHex,\n+    U: BitAnd<Output = U>\n+        + BitAndAssign\n+        + BitOr<Output = U>\n+        + BitOrAssign\n+        + BitXor<Output = U>\n+        + BitXorAssign\n+        + Not<Output = U>\n+        + Shl<Output = U>\n+        + ShlAssign\n+        + Shr<Output = U>\n+        + ShrAssign\n+        + Add<Output = U>\n+        + AddAssign\n+        + Div<Output = U>\n+        + DivAssign\n+        + Mul<Output = U>\n+        + MulAssign\n+        + Rem<Output = U>\n+        + RemAssign\n+        + Sub<Output = U>\n+        + SubAssign,\n+{\n+    fn complement_retain(self) -> Self {\n+        Self::from_bits_retain(!self.bits())\n+    }\n+\n+    fn has_uncorresponding_bits(self) -> bool {\n+        !(self & Self::all().complement_retain()).is_empty()\n+    }\n+}\n+\n+bitflags! {\n+    struct Flags: u32 {\n+        const A = 0b00000001;\n+    }\n+}\n+\n+fn has_uncorresponding_bits<B: BitFlagsExt>(flags: B) -> bool {\n+    flags.has_uncorresponding_bits()\n+}\n+\n+fn main() {\n+    has_uncorresponding_bits(Flags::A);\n+}\ndiff --git a/tests/compile-pass/bitflags_trait_to_flags.rs b/tests/compile-pass/bitflags_trait_to_flags.rs\nnew file mode 100644\nindex 00000000..6a69d2d8\n--- /dev/null\n+++ b/tests/compile-pass/bitflags_trait_to_flags.rs\n@@ -0,0 +1,31 @@\n+#![allow(deprecated)]\n+\n+use bitflags::{bitflags, Flags, BitFlags};\n+\n+fn uses_flags1<B: Flags>(f: B) -> usize {\n+    uses_bitflags2(f)\n+}\n+\n+fn uses_bitflags1<B: BitFlags>(f: B) -> usize {\n+    uses_flags2(f)\n+}\n+\n+fn uses_flags2<B: Flags>(f: B) -> usize {\n+    f.iter().count()\n+}\n+\n+fn uses_bitflags2<B: BitFlags>(f: B) -> usize {\n+    f.iter().count()\n+}\n+\n+bitflags! {\n+    pub struct MyFlags: u32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+        const C = 0b00000100;\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(uses_flags1(MyFlags::A | MyFlags::B), uses_bitflags1(MyFlags::A | MyFlags::B));\n+}\ndiff --git a/tests/compile-pass/visibility/pub_in.rs b/tests/compile-pass/bitflags_visibility.rs\nsimilarity index 100%\nrename from tests/compile-pass/visibility/pub_in.rs\nrename to tests/compile-pass/bitflags_visibility.rs\ndiff --git a/tests/compile-pass/flags_trait_bound_bitflags.rs b/tests/compile-pass/flags_trait_bound_bitflags.rs\nnew file mode 100644\nindex 00000000..f0653b6a\n--- /dev/null\n+++ b/tests/compile-pass/flags_trait_bound_bitflags.rs\n@@ -0,0 +1,19 @@\n+#![allow(deprecated)]\n+\n+use bitflags::{BitFlags, Flags};\n+\n+pub trait MyCustomFlagsTrait {\n+    fn uses_flags<B: Flags>(flags: B);\n+}\n+\n+pub struct MyCustomFlags;\n+\n+impl MyCustomFlagsTrait for MyCustomFlags {\n+    fn uses_flags<B: BitFlags>(_: B) {\n+\n+    }\n+}\n+\n+fn main() {\n+\n+}\ndiff --git a/tests/compile-pass/flags_trait_generic_iter.rs b/tests/compile-pass/flags_trait_generic_iter.rs\nnew file mode 100644\nindex 00000000..988db416\n--- /dev/null\n+++ b/tests/compile-pass/flags_trait_generic_iter.rs\n@@ -0,0 +1,16 @@\n+use bitflags::{bitflags, Flags};\n+\n+bitflags! {\n+    struct MyFlags: u32 {\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+    }\n+}\n+\n+fn count_flags<F: Flags>(flags: &F) -> usize {\n+    flags.iter().count()\n+}\n+\n+fn main() {\n+    assert_eq!(2, count_flags(&(MyFlags::A | MyFlags::B)));\n+}\ndiff --git a/tests/compile-pass/flags_trait_precedence.rs b/tests/compile-pass/flags_trait_precedence.rs\nnew file mode 100644\nindex 00000000..08b44a0a\n--- /dev/null\n+++ b/tests/compile-pass/flags_trait_precedence.rs\n@@ -0,0 +1,16 @@\n+use bitflags::{bitflags, Flags};\n+\n+bitflags! {\n+    struct MyFlags: u32 {\n+        const A = 0b00000001;\n+    }\n+}\n+\n+fn all_from_trait<F: Flags>() {\n+    let _ = F::all();\n+}\n+\n+fn main() {\n+    all_from_trait::<MyFlags>();\n+    let _ = MyFlags::all();\n+}\ndiff --git a/tests/compile-pass/flags_trait_supertrait.rs b/tests/compile-pass/flags_trait_supertrait.rs\nnew file mode 100644\nindex 00000000..b4b9d6ca\n--- /dev/null\n+++ b/tests/compile-pass/flags_trait_supertrait.rs\n@@ -0,0 +1,80 @@\n+#![allow(deprecated)]\n+\n+// From: https://github.com/bitflags/bitflags/issues/293#issuecomment-1493296383\n+use core::{\n+    fmt::{Binary, LowerHex, Octal, UpperHex},\n+    ops::{\n+        Add, AddAssign, BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Div, DivAssign,\n+        Mul, MulAssign, Not, Rem, RemAssign, Shl, ShlAssign, Shr, ShrAssign, Sub, SubAssign,\n+    }\n+};\n+\n+use bitflags::{bitflags, Flags};\n+\n+pub trait FlagsExt {\n+    fn complement_retain(self) -> Self;\n+    fn has_uncorresponding_bits(self) -> bool;\n+}\n+impl<T, U> FlagsExt for T\n+where\n+    T: Flags<Bits = U>\n+        + BitAnd<Output = T>\n+        + BitAndAssign\n+        + BitOr<Output = T>\n+        + BitOrAssign\n+        + BitXor<Output = T>\n+        + BitXorAssign\n+        + Not<Output = T>\n+        + Sub<Output = T>\n+        + SubAssign\n+        + Extend<T>\n+        + FromIterator<T>\n+        + IntoIterator\n+        + Binary\n+        + LowerHex\n+        + Octal\n+        + UpperHex,\n+    U: BitAnd<Output = U>\n+        + BitAndAssign\n+        + BitOr<Output = U>\n+        + BitOrAssign\n+        + BitXor<Output = U>\n+        + BitXorAssign\n+        + Not<Output = U>\n+        + Shl<Output = U>\n+        + ShlAssign\n+        + Shr<Output = U>\n+        + ShrAssign\n+        + Add<Output = U>\n+        + AddAssign\n+        + Div<Output = U>\n+        + DivAssign\n+        + Mul<Output = U>\n+        + MulAssign\n+        + Rem<Output = U>\n+        + RemAssign\n+        + Sub<Output = U>\n+        + SubAssign,\n+{\n+    fn complement_retain(self) -> Self {\n+        Self::from_bits_retain(!self.bits())\n+    }\n+\n+    fn has_uncorresponding_bits(self) -> bool {\n+        !(self & Self::all().complement_retain()).is_empty()\n+    }\n+}\n+\n+bitflags! {\n+    struct MyFlags: u32 {\n+        const A = 0b00000001;\n+    }\n+}\n+\n+fn has_uncorresponding_bits<B: FlagsExt>(flags: B) -> bool {\n+    flags.has_uncorresponding_bits()\n+}\n+\n+fn main() {\n+    has_uncorresponding_bits(MyFlags::A);\n+}\ndiff --git a/tests/compile-pass/impls/convert.rs b/tests/compile-pass/impl_convert_from_bits.rs\nsimilarity index 100%\nrename from tests/compile-pass/impls/convert.rs\nrename to tests/compile-pass/impl_convert_from_bits.rs\ndiff --git a/tests/compile-pass/impls/copy.rs b/tests/compile-pass/impl_copy.rs\nsimilarity index 100%\nrename from tests/compile-pass/impls/copy.rs\nrename to tests/compile-pass/impl_copy.rs\ndiff --git a/tests/compile-pass/impls/default.rs b/tests/compile-pass/impl_default.rs\nsimilarity index 100%\nrename from tests/compile-pass/impls/default.rs\nrename to tests/compile-pass/impl_default.rs\ndiff --git a/tests/compile-pass/impls/eq.rs b/tests/compile-pass/impl_eq.rs\nsimilarity index 100%\nrename from tests/compile-pass/impls/eq.rs\nrename to tests/compile-pass/impl_eq.rs\ndiff --git a/tests/compile-pass/impls/fmt.rs b/tests/compile-pass/impl_fmt.rs\nsimilarity index 100%\nrename from tests/compile-pass/impls/fmt.rs\nrename to tests/compile-pass/impl_fmt.rs\ndiff --git a/tests/compile-pass/impls/inherent_methods.rs b/tests/compile-pass/impl_new.rs\nsimilarity index 100%\nrename from tests/compile-pass/impls/inherent_methods.rs\nrename to tests/compile-pass/impl_new.rs\ndiff --git a/tests/compile-pass/trait/wrapped_iter.rs b/tests/compile-pass/into_iter_trait_wrapped.rs\nsimilarity index 100%\nrename from tests/compile-pass/trait/wrapped_iter.rs\nrename to tests/compile-pass/into_iter_trait_wrapped.rs\ndiff --git a/tests/compile-pass/repr/c.rs b/tests/compile-pass/repr_c.rs\nsimilarity index 100%\nrename from tests/compile-pass/repr/c.rs\nrename to tests/compile-pass/repr_c.rs\ndiff --git a/tests/compile-pass/repr/transparent.rs b/tests/compile-pass/repr_transparent.rs\nsimilarity index 100%\nrename from tests/compile-pass/repr/transparent.rs\nrename to tests/compile-pass/repr_transparent.rs\ndiff --git a/tests/compile-pass/redefinition/core.rs b/tests/compile-pass/shadow_core.rs\nsimilarity index 100%\nrename from tests/compile-pass/redefinition/core.rs\nrename to tests/compile-pass/shadow_core.rs\ndiff --git a/tests/compile-pass/redefinition/macros.rs b/tests/compile-pass/shadow_macros.rs\nsimilarity index 100%\nrename from tests/compile-pass/redefinition/macros.rs\nrename to tests/compile-pass/shadow_macros.rs\ndiff --git a/tests/compile-pass/redefinition/result.rs b/tests/compile-pass/shadow_result.rs\nsimilarity index 100%\nrename from tests/compile-pass/redefinition/result.rs\nrename to tests/compile-pass/shadow_result.rs\ndiff --git a/tests/compile-pass/visibility/bits_field.rs b/tests/compile-pass/visibility/bits_field.rs\ndeleted file mode 100644\nindex 5b0c6e43..00000000\n--- a/tests/compile-pass/visibility/bits_field.rs\n+++ /dev/null\n@@ -1,11 +0,0 @@\n-use bitflags::bitflags;\n-\n-bitflags! {\n-    pub struct Flags1: u32 {\n-        const FLAG_A = 0b00000001;\n-    }\n-}\n-\n-fn main() {\n-    assert_eq!(0b00000001, Flags1::FLAG_A.bits());\n-}\ndiff --git a/tests/smoke-test/Cargo.toml b/tests/smoke-test/Cargo.toml\nindex f7265667..2d64659c 100644\n--- a/tests/smoke-test/Cargo.toml\n+++ b/tests/smoke-test/Cargo.toml\n@@ -6,3 +6,4 @@ publish = false\n \n [dependencies.bitflags]\n path = \"../../\"\n+all-features = true\n", "problem_statement": "Allow external impls of Bits and BitFlags\nThe `BitFlags` trait is currently sealed, and is only supported through the `bitflags!` macro. I think we should make this trait publicly implementable, and default most of its members. I spent some time hacking on this, and came up with this minimal implementation.\r\n\r\nGiven a flags type like:\r\n\r\n```rust\r\nbitflags! {\r\n    pub struct MyFlags: u32 {\r\n        const A = 0b0000_0001;\r\n        const B = 0b0000_0010;\r\n        const C = 0b0000_0100;\r\n    }\r\n};\r\n```\r\n\r\nYou can implement it manually with:\r\n\r\n```rust\r\npub struct MyFlags {\r\n    bits: u32,\r\n}\r\n\r\nimpl BitFlags for MyFlags {\r\n    const FLAGS: &'static [(&'static str, Self::Bits)] = &[\r\n        (\"A\", 0b0000_0001),\r\n        (\"B\", 0b0000_0010),\r\n        (\"C\", 0b0000_0100),\r\n    ];\r\n\r\n    type Bits = u32;\r\n    type Iter = bitflags::iter::Iter<Self>;\r\n    type IterNames = bitflags::iter::IterNames<Self>;\r\n\r\n    fn bits(&self) -> Self::Bits {\r\n        self.bits\r\n    }\r\n\r\n    fn from_bits_retain(bits: Self::Bits) -> Self {\r\n        Self {\r\n            bits\r\n        }\r\n    }\r\n\r\n    fn iter(&self) -> Self::Iter {\r\n        bitflags::iter::Iter::new(self)\r\n    }\r\n\r\n    fn iter_names(&self) -> Self::IterNames {\r\n        bitflags::iter::IterNames::new(self)\r\n    }\r\n}\r\n```\r\n\r\nI'm proposing we _don't_ do #293, so that the implementation of `BitFlags` doesn't call for a host of supertraits.\r\n\r\nThe `FLAGS` constant there is new, and drives the iteration-based methods like `from_bits_truncate`, `from_name`, and the implementations of `Iter` and `IterNames`. If you squint, it looks a lot like the body of the `bitflags` macro.\r\n\r\nI think doing this has a few benefits:\r\n\r\n1. It makes the trait \"real\", so you can implement it and work with it yourself.\r\n2. It moves most of the generated code out of macros where they don't need to use fully-qualified paths like `$crate::__private::core::option::Option::Some<T>`.\r\n3. It gives us a starting point for #347 and #339, where you might not be able to use the `bitflags!` macro, but with a small amount of effort, can cook up your own flags type with whatever shape you want, and still get the benefits of generated code.\r\n\r\nFor trait impls like `serde` and `arbitrary`, we can then expose utilities like that proposed `bitflags::iter` module that make manual impls of those traits with awareness that the type is a flags enum easy:\r\n\r\n```rust\r\nimpl Serialize for MyFlags {\r\n    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {\r\n        bitflags::serde::serialize(self, serializer)\r\n    }\r\n}\r\n```\r\n\r\nI'm keen to hear what people think of this.\n", "hints_text": "As for `Bits`, it can be reasonably reduced to:\r\n\r\n```rust\r\npub trait Bits:\r\n    Clone\r\n    + Copy\r\n    + BitAnd<Output = Self>\r\n    + BitOr<Output = Self>\r\n    + BitXor<Output = Self>\r\n    + Not<Output = Self>\r\n    + PartialEq\r\n    + Sized\r\n    + 'static\r\n{\r\n    /// The value of `Self` where no bits are set.\r\n    const EMPTY: Self;\r\n\r\n    /// The value of `Self` where all bits are set.\r\n    const ALL: Self;\r\n}\r\n```\r\n\r\nThe `Copy` and `'static` bounds are pretty limiting, but doesn't rule out _some_ more exotic backing storage like `[bool; N]`.\nThe main thing you don't get from just the `BitFlags` macro right now, and what stops us being able to immediately replace a lot of generated code with it, is the const definitions, and const versions of those trait functions. We could consider a few utility macros that we transition `bitflags!` to, that will define costs and impl operators for you:\r\n\r\n```rust\r\nimpl_consts! {\r\n    MyFlags: u32 {\r\n        const A = 0b0000_0001;\r\n        const B = 0b0000_0010;\r\n        const C = 0b0000_0100;\r\n    }\r\n}\r\n```\r\n\r\nwould generate:\r\n\r\n```rust\r\nimpl MyFlags {\r\n    const FLAGS: &'static [(&'static str, Self::Bits)] = &[\r\n        (\"A\", 0b0000_0001),\r\n        (\"B\", 0b0000_0010),\r\n        (\"C\", 0b0000_0100),\r\n    ];\r\n\r\n    pub const A: Self = Self::from_bits_retain(0b0000_0001);\r\n    pub const B: Self = Self::from_bits_retain(0b0000_0010);\r\n    pub const C: Self = Self::from_bits_retain(0b0000_0100);\r\n}\r\n```\r\n\r\nyou could then use `Self::FLAGS` as the basis for the const in the `BitFlags` trait, so there's still only a single definition of what those flags are.\nSome other open design questions are:\r\n\r\n1. Should we use slices like `&[(&str, T)]`, or some wrapper type, like `Flags` that also implements indexing.\r\n2. Should we use tuples like `(&str, T)`, or some flags type like `Flag`. Having a separate type would let us add metadata in the future, such as whether or not the flag is a composite of other flags.\r\n\r\nI'm happy with `&[(&str, T)]`, but open to trying a more encapsulated API if it doesn't affect ergonomics or create too many extra types. It's certainly more future proof.", "created_at": "2023-05-04T06:16:51Z", "version": "2.2", "FAIL_TO_PASS": ["tests/compile-pass/bitflags_trait_bound_flags.rs", "tests/compile-pass/bitflags_trait_to_flags.rs", "tests/compile-pass/flags_trait_bound_bitflags.rs", "tests/compile-pass/flags_trait_generic_iter.rs", "tests/compile-pass/flags_trait_precedence.rs", "tests/compile-pass/flags_trait_supertrait.rs"], "PASS_TO_PASS": ["tests::bits_types", "tests::submodule::test_private", "tests::test_assignment_operators", "tests::test_binary", "tests::into_iter_from_iter_roundtrip", "tests::test_bits", "tests::test_const_fn", "tests::test_contains", "tests::test_debug", "tests::test_default", "tests::test_deprecated", "tests::test_disjoint_intersects", "tests::test_extend", "tests::test_from_bits", "tests::test_from_bits_edge_cases", "tests::test_from_bits_retain", "tests::test_from_bits_truncate", "tests::test_from_bits_truncate_edge_cases", "tests::test_from_name", "tests::test_from_iterator", "tests::test_from_str_err", "tests::test_hash", "tests::test_in_function", "tests::test_insert", "tests::test_iter", "tests::test_is_empty", "tests::test_empty_does_not_intersect_with_full", "tests::test_empty_bitflags", "tests::test_display_from_str_roundtrip", "tests::test_lowerhex", "tests::test_octal", "tests::test_lt", "tests::test_is_all", "tests::test_operators", "tests::test_ord", "tests::test_overlapping_intersects", "tests::test_pub_crate", "tests::test_remove", "tests::test_set_ops_basic", "tests::test_set_ops_const", "tests::test_two_empties_do_not_intersect", "tests::test_operators_unchecked", "tests::test_set", "tests::test_public", "tests::test_pub_in_module", "tests::test_upperhex", "tests::test_zero_value_flags", "tests::test_set_ops_unchecked", "tests::test_u128_bitflags", "tests::test_set_ops_exhaustive", "basic", "tests/compile-pass/bitflags_nested_value.rs", "tests/compile-pass/bitflags_redefined_value.rs", "tests/compile-pass/bitflags_trait_generic_iter.rs", "tests/compile-pass/bitflags_trait_precedence.rs", "tests/compile-pass/bitflags_trait_supertrait.rs", "tests/compile-pass/bitflags_visibility.rs", "tests/compile-pass/deprecated.rs", "tests/compile-pass/doc_alias.rs", "tests/compile-pass/impl_convert_from_bits.rs", "tests/compile-pass/impl_copy.rs", "tests/compile-pass/impl_default.rs", "tests/compile-pass/impl_eq.rs", "tests/compile-pass/impl_fmt.rs", "tests/compile-pass/impl_new.rs", "tests/compile-pass/into_iter_trait_wrapped.rs", "tests/compile-pass/item_positions.rs", "tests/compile-pass/large.rs", "tests/compile-pass/no_prelude.rs", "tests/compile-pass/non_snake_case.rs", "tests/compile-pass/path_based_bits.rs", "tests/compile-pass/repr_c.rs", "tests/compile-pass/repr_transparent.rs", "tests/compile-pass/shadow_core.rs", "tests/compile-pass/shadow_macros.rs", "tests/compile-pass/shadow_result.rs"], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
{"repo": "bitflags/bitflags", "pull_number": 345, "instance_id": "bitflags__bitflags-345", "issue_numbers": ["344"], "base_commit": "cbcafa710fc31172511e62efa06ad9eb214e4734", "patch": "diff --git a/src/example_generated.rs b/src/example_generated.rs\nindex 9c1ba46a..b7589014 100644\n--- a/src/example_generated.rs\n+++ b/src/example_generated.rs\n@@ -33,8 +33,17 @@ __impl_public_bitflags! {\n \n __impl_public_bitflags_consts! {\n     Flags {\n+        /// Field `A`.\n+        ///\n+        /// This flag has the value `0b00000001`.\n         A = 0b00000001;\n+        /// Field `B`.\n+        ///\n+        /// This flag has the value `0b00000010`.\n         B = 0b00000010;\n+        /// Field `C`.\n+        ///\n+        /// This flag has the value `0b00000100`.\n         C = 0b00000100;\n         ABC = Self::A.bits() | Self::B.bits() | Self::C.bits();\n     }\ndiff --git a/src/internal.rs b/src/internal.rs\nindex 2a6590fe..eca0a304 100644\n--- a/src/internal.rs\n+++ b/src/internal.rs\n@@ -224,10 +224,14 @@ macro_rules! __impl_internal_bitflags {\n                 let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n \n                 $(\n-                    $(#[$attr $($args)*])*\n-                    if bits & $BitFlags::$Flag.bits() == $BitFlags::$Flag.bits() {\n-                        truncated |= $BitFlags::$Flag.bits()\n-                    }\n+                    __expr_safe_flags!(\n+                        $(#[$attr $($args)*])*\n+                        {\n+                            if bits & $BitFlags::$Flag.bits() == $BitFlags::$Flag.bits() {\n+                                truncated |= $BitFlags::$Flag.bits()\n+                            }\n+                        }\n+                    );\n                 )*\n \n                 Self { bits: truncated }\n@@ -240,13 +244,19 @@ macro_rules! __impl_internal_bitflags {\n \n             #[inline]\n             pub fn from_name(name: &str) -> $crate::__private::core::option::Option<Self> {\n-                match name {\n-                    $(\n+                $(\n+                    __expr_safe_flags!(\n                         $(#[$attr $($args)*])*\n-                        $crate::__private::core::stringify!($Flag) => $crate::__private::core::option::Option::Some(Self { bits: $BitFlags::$Flag.bits() }),\n-                    )*\n-                    _ => $crate::__private::core::option::Option::None,\n-                }\n+                        {\n+                            if name == $crate::__private::core::stringify!($Flag) {\n+                                return $crate::__private::core::option::Option::Some(Self { bits: $BitFlags::$Flag.bits() });\n+                            }\n+                        }\n+                    );\n+                )*\n+\n+                let _ = name;\n+                $crate::__private::core::option::Option::None\n             }\n \n             #[inline]\n@@ -384,10 +394,12 @@ macro_rules! __impl_internal_bitflags {\n                     let mut num_flags = 0;\n \n                     $(\n-                        $(#[$attr $($args)*])*\n-                        {\n-                            num_flags += 1;\n-                        }\n+                        __expr_safe_flags!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                { num_flags += 1; }\n+                            }\n+                        );\n                     )*\n \n                     num_flags\n@@ -395,15 +407,23 @@ macro_rules! __impl_internal_bitflags {\n \n                 const OPTIONS: [$T; NUM_FLAGS] = [\n                     $(\n-                        $(#[$attr $($args)*])*\n-                        $BitFlags::$Flag.bits(),\n+                        __expr_safe_flags!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                $BitFlags::$Flag.bits()\n+                            }\n+                        ),\n                     )*\n                 ];\n \n                 const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n                     $(\n-                        $(#[$attr $($args)*])*\n-                        $crate::__private::core::stringify!($Flag),\n+                        __expr_safe_flags!(\n+                            $(#[$attr $($args)*])*\n+                            {\n+                                $crate::__private::core::stringify!($Flag)\n+                            }\n+                        ),\n                     )*\n                 ];\n \n@@ -439,3 +459,112 @@ macro_rules! __impl_internal_bitflags {\n         }\n     };\n }\n+\n+/// A macro that processed the input to `bitflags!` and shuffles attributes around\n+/// based on whether or not they're \"expression-safe\".\n+///\n+/// This macro is a token-tree muncher that works on 2 levels:\n+///\n+/// For each attribute, we explicitly match on its identifier, like `cfg` to determine\n+/// whether or not it should be considered expression-safe.\n+///\n+/// If you find yourself with an attribute that should be considered expression-safe\n+/// and isn't, it can be added here.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __expr_safe_flags {\n+    // Entrypoint: Move all flags and all attributes into `unprocessed` lists\n+    // where they'll be munched one-at-a-time\n+    (\n+        $(#[$inner:ident $($args:tt)*])*\n+        { $e:expr }\n+    ) => {\n+        __expr_safe_flags! {\n+            expr: { $e },\n+            attrs: {\n+                // All attributes start here\n+                unprocessed: [$(#[$inner $($args)*])*],\n+                processed: {\n+                    // Attributes that are safe on expressions go here\n+                    expr: [],\n+                },\n+            },\n+        }\n+    };\n+    // Process the next attribute on the current flag\n+    // `cfg`: The next flag should be propagated to expressions\n+    // NOTE: You can copy this rules block and replace `cfg` with\n+    // your attribute name that should be considered expression-safe\n+    (\n+        expr: { $e:expr },\n+            attrs: {\n+            unprocessed: [\n+                // cfg matched here\n+                #[cfg $($args:tt)*]\n+                $($attrs_rest:tt)*\n+            ],\n+            processed: {\n+                expr: [$($expr:tt)*],\n+            },\n+        },\n+    ) => {\n+        __expr_safe_flags! {\n+            expr: { $e },\n+            attrs: {\n+                unprocessed: [\n+                    $($attrs_rest)*\n+                ],\n+                processed: {\n+                    expr: [\n+                        $($expr)*\n+                        // cfg added here\n+                        #[cfg $($args)*]\n+                    ],\n+                },\n+            },\n+        }\n+    };\n+    // Process the next attribute on the current flag\n+    // `$other`: The next flag should not be propagated to expressions\n+    (\n+        expr: { $e:expr },\n+            attrs: {\n+            unprocessed: [\n+                // $other matched here\n+                #[$other:ident $($args:tt)*]\n+                $($attrs_rest:tt)*\n+            ],\n+            processed: {\n+                expr: [$($expr:tt)*],\n+            },\n+        },\n+    ) => {\n+        __expr_safe_flags! {\n+            expr: { $e },\n+                attrs: {\n+                unprocessed: [\n+                    $($attrs_rest)*\n+                ],\n+                processed: {\n+                    expr: [\n+                        // $other not added here\n+                        $($expr)*\n+                    ],\n+                },\n+            },\n+        }\n+    };\n+    // Once all attributes on all flags are processed, generate the actual code\n+    (\n+        expr: { $e:expr },\n+        attrs: {\n+            unprocessed: [],\n+            processed: {\n+                expr: [$(#[$expr:ident $($exprargs:tt)*])*],\n+            },\n+        },\n+    ) => {\n+        $(#[$expr $($exprargs)*])*\n+        { $e }\n+    }\n+}\ndiff --git a/src/lib.rs b/src/lib.rs\nindex afc5b524..18138bf5 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -558,315 +558,6 @@ macro_rules! bitflags {\n         }\n \n         $($t:tt)*\n-    ) => {\n-        __declare_bitflags!(\n-            $(#[$outer])*\n-            $vis struct $BitFlags: $T {\n-                $(\n-                    $(#[$inner $($args)*])*\n-                    const $Flag = $value;\n-                )*\n-            }\n-        );\n-\n-        bitflags! {\n-            $($t)*\n-        }\n-    };\n-    () => {};\n-}\n-\n-/// A macro that processed the input to `bitflags!` and shuffles attributes around\n-/// based on whether or not they're \"expression-safe\".\n-///\n-/// This macro is a token-tree muncher that works on 2 levels:\n-///\n-/// 1. Each flag, like `#[cfg(true)] const A: 42`\n-/// 2. Each attribute on that flag, like `#[cfg(true)]`\n-///\n-/// Flags and attributes start in an \"unprocessed\" list, and are shifted one token\n-/// at a time into an appropriate processed list until the unprocessed lists are empty.\n-///\n-/// For each attribute, we explicitly match on its identifier, like `cfg` to determine\n-/// whether or not it should be considered expression-safe.\n-///\n-/// If you find yourself with an attribute that should be considered expression-safe\n-/// and isn't, it can be added here.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-macro_rules! __declare_bitflags {\n-    // Entrypoint: Move all flags and all attributes into `unprocessed` lists\n-    // where they'll be munched one-at-a-time\n-    (\n-        $(#[$outer:meta])*\n-        $vis:vis struct $BitFlags:ident: $T:ty {\n-            $(\n-                $(#[$inner:ident $($args:tt)*])*\n-                const $Flag:ident = $value:expr;\n-            )*\n-        }\n-    ) => {\n-        __declare_bitflags! {\n-            decl: {\n-                attrs: [$(#[$outer])*],\n-                vis: $vis,\n-                ident: $BitFlags,\n-                ty: $T,\n-            },\n-            flags: {\n-                // All flags start here\n-                unprocessed: [\n-                    $(\n-                        {\n-                            ident: $Flag,\n-                            value: $value,\n-                            attrs: {\n-                                // All attributes start here\n-                                unprocessed: [$(#[$inner $($args)*])*],\n-                                processed: {\n-                                    // Attributes that should be added to item declarations go here\n-                                    decl: [],\n-                                    // Attributes that are safe on expressions go here\n-                                    expr: [],\n-                                }\n-                            },\n-                        },\n-                    )*\n-                ],\n-                // Flags that have had their attributes sorted are pushed here\n-                processed: [],\n-            }\n-        }\n-    };\n-    // Process the next attribute on the current flag\n-    // `cfg`: The next flag should be propagated to expressions\n-    // NOTE: You can copy this rules block and replace `cfg` with\n-    // your attribute name that should be considered expression-safe\n-    (\n-        decl: {\n-            attrs: [$(#[$outer:meta])*],\n-            vis: $vis:vis,\n-            ident: $BitFlags:ident,\n-            ty: $T:ty,\n-        },\n-        flags: {\n-            unprocessed: [\n-                {\n-                    ident: $Flag:ident,\n-                    value: $value:expr,\n-                    attrs: {\n-                        unprocessed: [\n-                            // cfg matched here\n-                            #[cfg $($args:tt)*]\n-                            $($attrs_rest:tt)*\n-                        ],\n-                        processed: {\n-                            decl: [$($decl:tt)*],\n-                            expr: [$($expr:tt)*],\n-                        }\n-                    },\n-                },\n-                $($flags_rest:tt)*\n-            ],\n-            processed: [\n-                $($flags:tt)*\n-            ],\n-        }\n-    ) => {\n-        __declare_bitflags! {\n-            decl: {\n-                attrs: [$(#[$outer])*],\n-                vis: $vis,\n-                ident: $BitFlags,\n-                ty: $T,\n-            },\n-            flags: {\n-                unprocessed: [\n-                    {\n-                        ident: $Flag,\n-                        value: $value,\n-                        attrs: {\n-                            unprocessed: [\n-                                $($attrs_rest)*\n-                            ],\n-                            processed: {\n-                                decl: [\n-                                    // cfg added here\n-                                    #[cfg $($args)*]\n-                                    $($decl)*\n-                                ],\n-                                expr: [\n-                                    // cfg added here\n-                                    #[cfg $($args)*]\n-                                    $($expr)*\n-                                ],\n-                            }\n-                        },\n-                    },\n-                    $($flags_rest)*\n-                ],\n-                processed: [\n-                    $($flags)*\n-                ],\n-            }\n-        }\n-    };\n-    // Process the next attribute on the current flag\n-    // `$other`: The next flag should not be propagated to expressions\n-    (\n-        decl: {\n-            attrs: [$(#[$outer:meta])*],\n-            vis: $vis:vis,\n-            ident: $BitFlags:ident,\n-            ty: $T:ty,\n-        },\n-        flags: {\n-            unprocessed: [\n-                {\n-                    ident: $Flag:ident,\n-                    value: $value:expr,\n-                    attrs: {\n-                        unprocessed: [\n-                            // $other matched here\n-                            #[$other:ident $($args:tt)*]\n-                            $($attrs_rest:tt)*\n-                        ],\n-                        processed: {\n-                            decl: [$($decl:tt)*],\n-                            expr: [$($expr:tt)*],\n-                        }\n-                    },\n-                },\n-                $($flags_rest:tt)*\n-            ],\n-            processed: [\n-                $($flags:tt)*\n-            ],\n-        }\n-    ) => {\n-        __declare_bitflags! {\n-            decl: {\n-                attrs: [$(#[$outer])*],\n-                vis: $vis,\n-                ident: $BitFlags,\n-                ty: $T,\n-            },\n-            flags: {\n-                unprocessed: [\n-                    {\n-                        ident: $Flag,\n-                        value: $value,\n-                        attrs: {\n-                            unprocessed: [\n-                                $($attrs_rest)*\n-                            ],\n-                            processed: {\n-                                decl: [\n-                                    // $other added here\n-                                    #[$other $($args)*]\n-                                    $($decl)*\n-                                ],\n-                                expr: [\n-                                    // $other not added here\n-                                    $($expr)*\n-                                ],\n-                            }\n-                        },\n-                    },\n-                    $($flags_rest)*\n-                ],\n-                processed: [\n-                    $($flags)*\n-                ],\n-            }\n-        }\n-    };\n-    // Complete the current flag once there are no unprocessed attributes left\n-    (\n-        decl: {\n-            attrs: [$(#[$outer:meta])*],\n-            vis: $vis:vis,\n-            ident: $BitFlags:ident,\n-            ty: $T:ty,\n-        },\n-        flags: {\n-            unprocessed: [\n-                {\n-                    ident: $Flag:ident,\n-                    value: $value:expr,\n-                    attrs: {\n-                        unprocessed: [],\n-                        processed: {\n-                            decl: [$($decl:tt)*],\n-                            expr: [$($expr:tt)*],\n-                        }\n-                    },\n-                },\n-                $($flags_rest:tt)*\n-            ],\n-            processed: [\n-                $($flags:tt)*\n-            ],\n-        }\n-    ) => {\n-        __declare_bitflags! {\n-            decl: {\n-                attrs: [$(#[$outer])*],\n-                vis: $vis,\n-                ident: $BitFlags,\n-                ty: $T,\n-            },\n-            flags: {\n-                unprocessed: [\n-                    $($flags_rest)*\n-                ],\n-                processed: [\n-                    $($flags)*\n-                    {\n-                        ident: $Flag,\n-                        value: $value,\n-                        attrs: {\n-                            unprocessed: [],\n-                            processed: {\n-                                decl: [\n-                                    $($decl)*\n-                                ],\n-                                expr: [\n-                                    $($expr)*\n-                                ],\n-                            }\n-                        },\n-                    },\n-                ],\n-            }\n-        }\n-    };\n-    // Once all attributes on all flags are processed, generate the actual code\n-    (\n-        decl: {\n-            attrs: [$(#[$outer:meta])*],\n-            vis: $vis:vis,\n-            ident: $BitFlags:ident,\n-            ty: $T:ty,\n-        },\n-        flags: {\n-            unprocessed: [],\n-            processed: [\n-                $(\n-                    {\n-                        ident: $Flag:ident,\n-                        value: $value:expr,\n-                        attrs: {\n-                            unprocessed: [],\n-                            processed: {\n-                                decl: [$(#[$decl:ident $($declargs:tt)*])*],\n-                                expr: [$(#[$expr:ident $($exprargs:tt)*])*],\n-                            }\n-                        },\n-                    },\n-                )*\n-            ],\n-        }\n     ) => {\n         // Declared in the scope of the `bitflags!` call\n         // This type appears in the end-user's API\n@@ -879,7 +570,7 @@ macro_rules! __declare_bitflags {\n         __impl_public_bitflags_consts! {\n             $BitFlags {\n                 $(\n-                    $(#[$decl $($declargs)*])*\n+                    $(#[$inner $($args)*])*\n                     #[allow(\n                         dead_code,\n                         deprecated,\n@@ -912,7 +603,7 @@ macro_rules! __declare_bitflags {\n             __impl_internal_bitflags! {\n                 InternalBitFlags: $T, $BitFlags, Iter, IterRaw {\n                     $(\n-                        $(#[$expr $($exprargs)*])*\n+                        $(#[$inner $($args)*])*\n                         $Flag;\n                     )*\n                 }\n@@ -922,7 +613,7 @@ macro_rules! __declare_bitflags {\n             __impl_external_bitflags! {\n                 InternalBitFlags: $T {\n                     $(\n-                        $(#[$expr $($exprargs)*])*\n+                        $(#[$inner $($args)*])*\n                         $Flag;\n                     )*\n                 }\n@@ -932,7 +623,12 @@ macro_rules! __declare_bitflags {\n                 $BitFlags: $T, InternalBitFlags, Iter, IterRaw;\n             }\n         };\n-    }\n+\n+        bitflags! {\n+            $($t)*\n+        }\n+    };\n+    () => {};\n }\n \n #[macro_use]\n", "test_patch": "diff --git a/tests/compile-pass/large.rs b/tests/compile-pass/large.rs\nnew file mode 100644\nindex 00000000..a7519f2a\n--- /dev/null\n+++ b/tests/compile-pass/large.rs\n@@ -0,0 +1,311 @@\n+/*\n+Copyright (c) 2016 Anatoly Ikorsky\n+\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE.\n+*/\n+\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    /// Client capability flags\n+    #[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]\n+    pub struct CapabilityFlags: u32 {\n+        /// Use the improved version of Old Password Authentication. Assumed to be set since 4.1.1.\n+        const CLIENT_LONG_PASSWORD                  = 0x0000_0001;\n+    \n+        /// Send found rows instead of affected rows in EOF_Packet.\n+        const CLIENT_FOUND_ROWS                     = 0x0000_0002;\n+    \n+        /// Get all column flags.\n+        /// Longer flags in Protocol::ColumnDefinition320.\n+        ///\n+        /// ### Server\n+        /// Supports longer flags.\n+        ///\n+        /// ### Client\n+        /// Expects longer flags.\n+        const CLIENT_LONG_FLAG                      = 0x0000_0004;\n+    \n+        /// Database (schema) name can be specified on connect in Handshake Response Packet.\n+        /// ### Server\n+        /// Supports schema-name in Handshake Response Packet.\n+        ///\n+        /// ### Client\n+        /// Handshake Response Packet contains a schema-name.\n+        const CLIENT_CONNECT_WITH_DB                = 0x0000_0008;\n+    \n+        /// Don't allow database.table.column.\n+        const CLIENT_NO_SCHEMA                      = 0x0000_0010;\n+    \n+        /// Compression protocol supported.\n+        ///\n+        /// ### Server\n+        /// Supports compression.\n+        ///\n+        /// ### Client\n+        /// Switches to Compression compressed protocol after successful authentication.\n+        const CLIENT_COMPRESS                       = 0x0000_0020;\n+    \n+        /// Special handling of ODBC behavior.\n+        const CLIENT_ODBC                           = 0x0000_0040;\n+    \n+        /// Can use LOAD DATA LOCAL.\n+        ///\n+        /// ### Server\n+        /// Enables the LOCAL INFILE request of LOAD DATA|XML.\n+        ///\n+        /// ### Client\n+        /// Will handle LOCAL INFILE request.\n+        const CLIENT_LOCAL_FILES                    = 0x0000_0080;\n+    \n+        /// Ignore spaces before '('.\n+        ///\n+        /// ### Server\n+        /// Parser can ignore spaces before '('.\n+        ///\n+        /// ### Client\n+        /// Let the parser ignore spaces before '('.\n+        const CLIENT_IGNORE_SPACE                   = 0x0000_0100;\n+    \n+        const CLIENT_PROTOCOL_41                    = 0x0000_0200;\n+    \n+        /// This is an interactive client.\n+        /// Use System_variables::net_wait_timeout versus System_variables::net_interactive_timeout.\n+        ///\n+        /// ### Server\n+        /// Supports interactive and noninteractive clients.\n+        ///\n+        /// ### Client\n+        /// Client is interactive.\n+        const CLIENT_INTERACTIVE                    = 0x0000_0400;\n+    \n+        /// Use SSL encryption for the session.\n+        ///\n+        /// ### Server\n+        /// Supports SSL\n+        ///\n+        /// ### Client\n+        /// Switch to SSL after sending the capability-flags.\n+        const CLIENT_SSL                            = 0x0000_0800;\n+    \n+        /// Client only flag. Not used.\n+        ///\n+        /// ### Client\n+        /// Do not issue SIGPIPE if network failures occur (libmysqlclient only).\n+        const CLIENT_IGNORE_SIGPIPE                 = 0x0000_1000;\n+    \n+        /// Client knows about transactions.\n+        ///\n+        /// ### Server\n+        /// Can send status flags in OK_Packet / EOF_Packet.\n+        ///\n+        /// ### Client\n+        /// Expects status flags in OK_Packet / EOF_Packet.\n+        ///\n+        /// ### Note\n+        /// This flag is optional in 3.23, but always set by the server since 4.0.\n+        const CLIENT_TRANSACTIONS                   = 0x0000_2000;\n+    \n+        const CLIENT_RESERVED                       = 0x0000_4000;\n+    \n+        const CLIENT_SECURE_CONNECTION              = 0x0000_8000;\n+    \n+        /// Enable/disable multi-stmt support.\n+        /// Also sets CLIENT_MULTI_RESULTS. Currently not checked anywhere.\n+        ///\n+        /// ### Server\n+        /// Can handle multiple statements per COM_QUERY and COM_STMT_PREPARE.\n+        ///\n+        /// ### Client\n+        /// May send multiple statements per COM_QUERY and COM_STMT_PREPARE.\n+        const CLIENT_MULTI_STATEMENTS               = 0x0001_0000;\n+    \n+        /// Enable/disable multi-results.\n+        ///\n+        /// ### Server\n+        /// Can send multiple resultsets for COM_QUERY. Error if the server needs to send\n+        /// them and client does not support them.\n+        ///\n+        /// ### Client\n+        /// Can handle multiple resultsets for COM_QUERY.\n+        ///\n+        /// ### Requires\n+        /// `CLIENT_PROTOCOL_41`\n+        const CLIENT_MULTI_RESULTS                  = 0x0002_0000;\n+    \n+        /// Multi-results and OUT parameters in PS-protocol.\n+        ///\n+        /// ### Server\n+        /// Can send multiple resultsets for COM_STMT_EXECUTE.\n+        ///\n+        /// ### Client\n+        /// Can handle multiple resultsets for COM_STMT_EXECUTE.\n+        ///\n+        /// ### Requires\n+        /// `CLIENT_PROTOCOL_41`\n+        const CLIENT_PS_MULTI_RESULTS               = 0x0004_0000;\n+    \n+        /// Client supports plugin authentication.\n+        ///\n+        /// ### Server\n+        /// Sends extra data in Initial Handshake Packet and supports the pluggable\n+        /// authentication protocol.\n+        ///\n+        /// ### Client\n+        /// Supports authentication plugins.\n+        ///\n+        /// ### Requires\n+        /// `CLIENT_PROTOCOL_41`\n+        const CLIENT_PLUGIN_AUTH                    = 0x0008_0000;\n+    \n+        /// Client supports connection attributes.\n+        ///\n+        /// ### Server\n+        /// Permits connection attributes in Protocol::HandshakeResponse41.\n+        ///\n+        /// ### Client\n+        /// Sends connection attributes in Protocol::HandshakeResponse41.\n+        const CLIENT_CONNECT_ATTRS                  = 0x0010_0000;\n+    \n+        /// Enable authentication response packet to be larger than 255 bytes.\n+        /// When the ability to change default plugin require that the initial password\n+        /// field in the Protocol::HandshakeResponse41 paclet can be of arbitrary size.\n+        /// However, the 4.1 client-server protocol limits the length of the auth-data-field\n+        /// sent from client to server to 255 bytes. The solution is to change the type of\n+        /// the field to a true length encoded string and indicate the protocol change with\n+        /// this client capability flag.\n+        ///\n+        /// ### Server\n+        /// Understands length-encoded integer for auth response data in\n+        /// Protocol::HandshakeResponse41.\n+        ///\n+        /// ### Client\n+        /// Length of auth response data in Protocol::HandshakeResponse41 is a\n+        /// length-encoded integer.\n+        ///\n+        /// ### Note\n+        /// The flag was introduced in 5.6.6, but had the wrong value.\n+        const CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA = 0x0020_0000;\n+    \n+        /// Don't close the connection for a user account with expired password.\n+        ///\n+        /// ### Server\n+        /// Announces support for expired password extension.\n+        ///\n+        /// ### Client\n+        /// Can handle expired passwords.\n+        const CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS   = 0x0040_0000;\n+    \n+        /// Capable of handling server state change information.\n+        /// Its a hint to the server to include the state change information in OK_Packet.\n+        ///\n+        /// ### Server\n+        /// Can set SERVER_SESSION_STATE_CHANGED in the SERVER_STATUS_flags_enum and send\n+        /// Session State Information in a OK_Packet.\n+        ///\n+        /// ### Client\n+        /// Expects the server to send Session State Information in a OK_Packet.\n+        const CLIENT_SESSION_TRACK                  = 0x0080_0000;\n+    \n+        /// Client no longer needs EOF_Packet and will use OK_Packet instead.\n+        ///\n+        /// ### Server\n+        /// Can send OK after a Text Resultset.\n+        ///\n+        /// ### Client\n+        /// Expects an OK_Packet (instead of EOF_Packet) after the resultset\n+        /// rows of a Text Resultset.\n+        ///\n+        /// ### Background\n+        /// To support CLIENT_SESSION_TRACK, additional information must be sent after all\n+        /// successful commands. Although the OK_Packet is extensible, the EOF_Packet is\n+        /// not due to the overlap of its bytes with the content of the Text Resultset Row.\n+        ///\n+        /// Therefore, the EOF_Packet in the Text Resultset is replaced with an OK_Packet.\n+        /// EOF_Packet is deprecated as of MySQL 5.7.5.\n+        const CLIENT_DEPRECATE_EOF                  = 0x0100_0000;\n+    \n+        /// The client can handle optional metadata information in the resultset.\n+        const CLIENT_OPTIONAL_RESULTSET_METADATA    = 0x0200_0000;\n+    \n+        /// Compression protocol extended to support zstd compression method.\n+        ///\n+        /// This capability flag is used to send zstd compression level between client and server\n+        /// provided both client and server are enabled with this flag.\n+        ///\n+        /// # Server\n+        ///\n+        /// Server sets this flag when global variable protocol-compression-algorithms has zstd\n+        /// in its list of supported values.\n+        ///\n+        /// # Client\n+        ///\n+        /// Client sets this flag when it is configured to use zstd compression method.\n+        const CLIENT_ZSTD_COMPRESSION_ALGORITHM     = 0x0400_0000;\n+    \n+        /// Support optional extension for query parameters into the COM_QUERY\n+        /// and COM_STMT_EXECUTE packets.\n+        ///\n+        /// # Server\n+        ///\n+        /// Expects an optional part containing the query parameter set(s).\n+        /// Executes the query for each set of parameters or returns an error if more than 1 set\n+        /// of parameters is sent and the server can't execute it.\n+        ///\n+        /// # Client\n+        ///\n+        /// Can send the optional part containing the query parameter set(s).\n+        const CLIENT_QUERY_ATTRIBUTES               = 0x0800_0000;\n+    \n+        /// Support Multi factor authentication.\n+        ///\n+        /// # Server\n+        ///\n+        /// Server sends AuthNextFactor packet after every nth factor\n+        /// authentication method succeeds, except the last factor authentication.\n+        ///\n+        /// # Client\n+        ///\n+        /// Client reads AuthNextFactor packet sent by server\n+        /// and initiates next factor authentication method.\n+        const MULTI_FACTOR_AUTHENTICATION           = 0x1000_0000;\n+    \n+        /// Client or server supports progress reports within error packet.\n+        const CLIENT_PROGRESS_OBSOLETE              = 0x2000_0000;\n+    \n+        /// Verify server certificate. Client only flag.\n+        ///\n+        /// Deprecated in favor of \u2013ssl-mode.\n+        const CLIENT_SSL_VERIFY_SERVER_CERT         = 0x4000_0000;\n+    \n+        /// Don't reset the options after an unsuccessful connect. Client only flag.\n+        const CLIENT_REMEMBER_OPTIONS               = 0x8000_0000;\n+    }\n+}\n+\n+fn main() {\n+\n+}\n", "problem_statement": "Bitflags reverses order of multiline doc comments\nWhen compiling code like\r\n```\r\nbitflags! {\r\n    pub struct AdjustFlags: u32 {\r\n        /// Add buf.time to the current time. If buf.status includes the ADJ_NANO flag, then buf.time.tv_usec is interpreted as a nanosecond value;\r\n        /// otherwise it is interpreted as microseconds.\r\n        ///\r\n        /// The value of buf.time is the sum of its two fields, but the field buf.time.tv_usec must always be nonnegative.\r\n        /// The following example shows how to normalize a timeval with nanosecond resolution.\r\n        ///\r\n        /// ```C\r\n        /// while (buf.time.tv_usec < 0) {\r\n        ///     buf.time.tv_sec  -= 1;\r\n        ///     buf.time.tv_usec += 1000000000;\r\n        /// }\r\n        /// ```\r\n        const SETOFFSET = libc::ADJ_SETOFFSET;\r\n    }\r\n}\r\n```\r\n\r\nThe doc-comments order is reversed on compile, causing issues with generated docs and the doctest.\r\n\r\nThis bug only occurs on bitflags 2.2.0 and not on earlier versions\n", "hints_text": "This should be trivially fixed by swapping the order attributes are \"pushed\" in `__declare_bitflags`. We've already yanked `2.2.0` because it requires a lot more recursion, but will keep this open to make sure any new approach doesn't reverse the order of attributes.", "created_at": "2023-04-24T04:29:26Z", "version": "2.2", "FAIL_TO_PASS": ["tests/compile-pass/large.rs"], "PASS_TO_PASS": ["tests::bits_types", "tests::into_iter_from_iter_roundtrip", "tests::submodule::test_private", "tests::test_assignment_operators", "tests::test_binary", "tests::test_bits", "tests::test_const_fn", "tests::test_contains", "tests::test_debug", "tests::test_default", "tests::test_disjoint_intersects", "tests::test_empty_bitflags", "tests::test_empty_does_not_intersect_with_full", "tests::test_extend", "tests::test_from_bits", "tests::test_display_from_str_roundtrip", "tests::test_deprecated", "tests::test_from_bits_edge_cases", "tests::test_from_bits_truncate_edge_cases", "tests::test_from_bits_truncate", "tests::test_from_bits_retain", "tests::test_from_str_err", "tests::test_in_function", "tests::test_hash", "tests::test_insert", "tests::test_from_name", "tests::test_is_empty", "tests::test_iter", "tests::test_from_iterator", "tests::test_octal", "tests::test_is_all", "tests::test_lt", "tests::test_operators_unchecked", "tests::test_overlapping_intersects", "tests::test_lowerhex", "tests::test_operators", "tests::test_pub_crate", "tests::test_pub_in_module", "tests::test_ord", "tests::test_public", "tests::test_remove", "tests::test_set_ops_const", "tests::test_set", "tests::test_set_ops_basic", "tests::test_two_empties_do_not_intersect", "tests::test_u128_bitflags", "tests::test_upperhex", "tests::test_set_ops_unchecked", "tests::test_zero_value_flags", "tests::test_set_ops_exhaustive", "basic", "tests/compile-pass/cfg/nested-value.rs", "tests/compile-pass/cfg/redefined-value.rs", "tests/compile-pass/deprecated.rs", "tests/compile-pass/doc_alias.rs", "tests/compile-pass/impls/convert.rs", "tests/compile-pass/impls/copy.rs", "tests/compile-pass/impls/default.rs", "tests/compile-pass/impls/eq.rs", "tests/compile-pass/impls/fmt.rs", "tests/compile-pass/impls/inherent_methods.rs", "tests/compile-pass/item_positions.rs", "tests/compile-pass/no_prelude.rs", "tests/compile-pass/non_snake_case.rs", "tests/compile-pass/path_based_bits.rs", "tests/compile-pass/redefinition/core.rs", "tests/compile-pass/redefinition/macros.rs", "tests/compile-pass/redefinition/result.rs", "tests/compile-pass/repr/c.rs", "tests/compile-pass/repr/transparent.rs", "tests/compile-pass/trait/generic_iter.rs", "tests/compile-pass/trait/precedence.rs", "tests/compile-pass/trait/wrapped_iter.rs", "tests/compile-pass/visibility/bits_field.rs", "tests/compile-pass/visibility/pub_in.rs"], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
{"repo": "bitflags/bitflags", "pull_number": 341, "instance_id": "bitflags__bitflags-341", "issue_numbers": ["308"], "base_commit": "dc971042c8132a5381ab3e2165983ee7f9d44c63", "patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 7ba784c5..a4a40467 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -558,6 +558,315 @@ macro_rules! bitflags {\n         }\n \n         $($t:tt)*\n+    ) => {\n+        __declare_bitflags!(\n+            $(#[$outer])*\n+            $vis struct $BitFlags: $T {\n+                $(\n+                    $(#[$inner $($args)*])*\n+                    const $Flag = $value;\n+                )*\n+            }\n+        );\n+\n+        bitflags! {\n+            $($t)*\n+        }\n+    };\n+    () => {};\n+}\n+\n+/// A macro that processed the input to `bitflags!` and shuffles attributes around\n+/// based on whether or not they're \"expression-safe\".\n+///\n+/// This macro is a token-tree muncher that works on 2 levels:\n+///\n+/// 1. Each flag, like `#[cfg(true)] const A: 42`\n+/// 2. Each attribute on that flag, like `#[cfg(true)]`\n+///\n+/// Flags and attributes start in an \"unprocessed\" list, and are shifted one token\n+/// at a time into an appropriate processed list until the unprocessed lists are empty.\n+///\n+/// For each attribute, we explicitly match on its identifier, like `cfg` to determine\n+/// whether or not it should be considered expression-safe.\n+///\n+/// If you find yourself with an attribute that should be considered expression-safe\n+/// and isn't, it can be added here.\n+#[macro_export(local_inner_macros)]\n+#[doc(hidden)]\n+macro_rules! __declare_bitflags {\n+    // Entrypoint: Move all flags and all attributes into `unprocessed` lists\n+    // where they'll be munched one-at-a-time\n+    (\n+        $(#[$outer:meta])*\n+        $vis:vis struct $BitFlags:ident: $T:ty {\n+            $(\n+                $(#[$inner:ident $($args:tt)*])*\n+                const $Flag:ident = $value:expr;\n+            )*\n+        }\n+    ) => {\n+        __declare_bitflags! {\n+            decl: {\n+                attrs: [$(#[$outer])*],\n+                vis: $vis,\n+                ident: $BitFlags,\n+                ty: $T,\n+            },\n+            flags: {\n+                // All flags start here\n+                unprocessed: [\n+                    $(\n+                        {\n+                            ident: $Flag,\n+                            value: $value,\n+                            attrs: {\n+                                // All attributes start here\n+                                unprocessed: [$(#[$inner $($args)*])*],\n+                                processed: {\n+                                    // Attributes that should be added to item declarations go here\n+                                    decl: [],\n+                                    // Attributes that are safe on expressions go here\n+                                    expr: [],\n+                                }\n+                            },\n+                        },\n+                    )*\n+                ],\n+                // Flags that have had their attributes sorted are pushed here\n+                processed: [],\n+            }\n+        }\n+    };\n+    // Process the next attribute on the current flag\n+    // `cfg`: The next flag should be propagated to expressions\n+    // NOTE: You can copy this rules block and replace `cfg` with\n+    // your attribute name that should be considered expression-safe\n+    (\n+        decl: {\n+            attrs: [$(#[$outer:meta])*],\n+            vis: $vis:vis,\n+            ident: $BitFlags:ident,\n+            ty: $T:ty,\n+        },\n+        flags: {\n+            unprocessed: [\n+                {\n+                    ident: $Flag:ident,\n+                    value: $value:expr,\n+                    attrs: {\n+                        unprocessed: [\n+                            // cfg matched here\n+                            #[cfg $($args:tt)*]\n+                            $($attrs_rest:tt)*\n+                        ],\n+                        processed: {\n+                            decl: [$($decl:tt)*],\n+                            expr: [$($expr:tt)*],\n+                        }\n+                    },\n+                },\n+                $($flags_rest:tt)*\n+            ],\n+            processed: [\n+                $($flags:tt)*\n+            ],\n+        }\n+    ) => {\n+        __declare_bitflags! {\n+            decl: {\n+                attrs: [$(#[$outer])*],\n+                vis: $vis,\n+                ident: $BitFlags,\n+                ty: $T,\n+            },\n+            flags: {\n+                unprocessed: [\n+                    {\n+                        ident: $Flag,\n+                        value: $value,\n+                        attrs: {\n+                            unprocessed: [\n+                                $($attrs_rest)*\n+                            ],\n+                            processed: {\n+                                decl: [\n+                                    // cfg added here\n+                                    #[cfg $($args)*]\n+                                    $($decl)*\n+                                ],\n+                                expr: [\n+                                    // cfg added here\n+                                    #[cfg $($args)*]\n+                                    $($expr)*\n+                                ],\n+                            }\n+                        },\n+                    },\n+                    $($flags_rest)*\n+                ],\n+                processed: [\n+                    $($flags)*\n+                ],\n+            }\n+        }\n+    };\n+    // Process the next attribute on the current flag\n+    // `$other`: The next flag should not be propagated to expressions\n+    (\n+        decl: {\n+            attrs: [$(#[$outer:meta])*],\n+            vis: $vis:vis,\n+            ident: $BitFlags:ident,\n+            ty: $T:ty,\n+        },\n+        flags: {\n+            unprocessed: [\n+                {\n+                    ident: $Flag:ident,\n+                    value: $value:expr,\n+                    attrs: {\n+                        unprocessed: [\n+                            // $other matched here\n+                            #[$other:ident $($args:tt)*]\n+                            $($attrs_rest:tt)*\n+                        ],\n+                        processed: {\n+                            decl: [$($decl:tt)*],\n+                            expr: [$($expr:tt)*],\n+                        }\n+                    },\n+                },\n+                $($flags_rest:tt)*\n+            ],\n+            processed: [\n+                $($flags:tt)*\n+            ],\n+        }\n+    ) => {\n+        __declare_bitflags! {\n+            decl: {\n+                attrs: [$(#[$outer])*],\n+                vis: $vis,\n+                ident: $BitFlags,\n+                ty: $T,\n+            },\n+            flags: {\n+                unprocessed: [\n+                    {\n+                        ident: $Flag,\n+                        value: $value,\n+                        attrs: {\n+                            unprocessed: [\n+                                $($attrs_rest)*\n+                            ],\n+                            processed: {\n+                                decl: [\n+                                    // $other added here\n+                                    #[$other $($args)*]\n+                                    $($decl)*\n+                                ],\n+                                expr: [\n+                                    // $other not added here\n+                                    $($expr)*\n+                                ],\n+                            }\n+                        },\n+                    },\n+                    $($flags_rest)*\n+                ],\n+                processed: [\n+                    $($flags)*\n+                ],\n+            }\n+        }\n+    };\n+    // Complete the current flag once there are no unprocessed attributes left\n+    (\n+        decl: {\n+            attrs: [$(#[$outer:meta])*],\n+            vis: $vis:vis,\n+            ident: $BitFlags:ident,\n+            ty: $T:ty,\n+        },\n+        flags: {\n+            unprocessed: [\n+                {\n+                    ident: $Flag:ident,\n+                    value: $value:expr,\n+                    attrs: {\n+                        unprocessed: [],\n+                        processed: {\n+                            decl: [$($decl:tt)*],\n+                            expr: [$($expr:tt)*],\n+                        }\n+                    },\n+                },\n+                $($flags_rest:tt)*\n+            ],\n+            processed: [\n+                $($flags:tt)*\n+            ],\n+        }\n+    ) => {\n+        __declare_bitflags! {\n+            decl: {\n+                attrs: [$(#[$outer])*],\n+                vis: $vis,\n+                ident: $BitFlags,\n+                ty: $T,\n+            },\n+            flags: {\n+                unprocessed: [\n+                    $($flags_rest)*\n+                ],\n+                processed: [\n+                    $($flags)*\n+                    {\n+                        ident: $Flag,\n+                        value: $value,\n+                        attrs: {\n+                            unprocessed: [],\n+                            processed: {\n+                                decl: [\n+                                    $($decl)*\n+                                ],\n+                                expr: [\n+                                    $($expr)*\n+                                ],\n+                            }\n+                        },\n+                    },\n+                ],\n+            }\n+        }\n+    };\n+    // Once all attributes on all flags are processed, generate the actual code\n+    (\n+        decl: {\n+            attrs: [$(#[$outer:meta])*],\n+            vis: $vis:vis,\n+            ident: $BitFlags:ident,\n+            ty: $T:ty,\n+        },\n+        flags: {\n+            unprocessed: [],\n+            processed: [\n+                $(\n+                    {\n+                        ident: $Flag:ident,\n+                        value: $value:expr,\n+                        attrs: {\n+                            unprocessed: [],\n+                            processed: {\n+                                decl: [$(#[$decl:ident $($declargs:tt)*])*],\n+                                expr: [$(#[$expr:ident $($exprargs:tt)*])*],\n+                            }\n+                        },\n+                    },\n+                )*\n+            ],\n+        }\n     ) => {\n         // Declared in the scope of the `bitflags!` call\n         // This type appears in the end-user's API\n@@ -570,7 +879,7 @@ macro_rules! bitflags {\n         __impl_public_bitflags_consts! {\n             $BitFlags {\n                 $(\n-                    $(#[$inner $($args)*])*\n+                    $(#[$decl $($declargs)*])*\n                     #[allow(\n                         dead_code,\n                         deprecated,\n@@ -603,7 +912,7 @@ macro_rules! bitflags {\n             __impl_internal_bitflags! {\n                 InternalBitFlags: $T, $BitFlags, Iter, IterRaw {\n                     $(\n-                        $(#[$inner $($args)*])*\n+                        $(#[$expr $($exprargs)*])*\n                         $Flag;\n                     )*\n                 }\n@@ -613,7 +922,7 @@ macro_rules! bitflags {\n             __impl_external_bitflags! {\n                 InternalBitFlags: $T {\n                     $(\n-                        $(#[$inner $($args)*])*\n+                        $(#[$expr $($exprargs)*])*\n                         $Flag;\n                     )*\n                 }\n@@ -623,12 +932,7 @@ macro_rules! bitflags {\n                 $BitFlags: $T, InternalBitFlags, Iter, IterRaw;\n             }\n         };\n-\n-        bitflags! {\n-            $($t)*\n-        }\n-    };\n-    () => {};\n+    }\n }\n \n #[macro_use]\n", "test_patch": "diff --git a/tests/compile-pass/doc_alias.rs b/tests/compile-pass/doc_alias.rs\nnew file mode 100644\nindex 00000000..8fe1d900\n--- /dev/null\n+++ b/tests/compile-pass/doc_alias.rs\n@@ -0,0 +1,14 @@\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    #[doc(alias = \"FLAG\")]\n+    pub struct Flags: u8 {\n+        #[doc(alias = \"FLAG_A\")]\n+        const A = 1;\n+    }\n+}\n+\n+fn main() {\n+    \n+}\n", "problem_statement": "Cannot use `#[doc(alias)]`\nThe following code:\r\n```rs\r\nbitflags::bitflags! {\r\n  #[doc(alias = \"SYMBOLIC_LINK_FLAGS\")]\r\n  pub struct SymbolicLinkFlags:u32 {\r\n    #[doc(alias = \"SYMBOLIC_LINK_FLAG_DIRECTORY\")]\r\n    const DIRECTORY = 0x1;\r\n    #[doc(alias = \"SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE\")]\r\n    const ALLOW_UNPRIVILEGED_CREATE = 0x2;\r\n  }\r\n}\r\n```\r\nProduces the error:\r\n```\r\nerror: `#[doc(alias = \"...\")]` isn't allowed on expression\r\n  --> src\\fs.rs:67:15\r\n   |\r\n67 |         #[doc(alias = \"SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE\")]\r\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n```\n", "hints_text": "This is a general problem for attributes that can't be applied to expressions now. In methods like `from_name` we now generate code like this:\r\n\r\n```rust\r\n#[inline]\r\npub fn from_name(name: &str) -> ::bitflags::__private::core::option::Option<Self> {\r\n    match name {\r\n        #[doc(alias = \"SYMBOLIC_LINK_FLAG_DIRECTORY\")]\r\n        \"DIRECTORY\" => ::bitflags::__private::core::option::Option::Some(Self {\r\n            bits: SymbolicLinkFlags::DIRECTORY.bits(),\r\n        }),\r\n        #[doc(alias = \"SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE\")]\r\n        \"ALLOW_UNPRIVILEGED_CREATE\" => {\r\n            ::bitflags::__private::core::option::Option::Some(Self {\r\n                bits: SymbolicLinkFlags::ALLOW_UNPRIVILEGED_CREATE.bits(),\r\n            })\r\n        }\r\n        _ => ::bitflags::__private::core::option::Option::None,\r\n    }\r\n}\r\n```\r\n\r\nI think the quickest fix would be to introduce a helper macro that filtered out some attributes like `#[doc(..)]` for these match arms. Any more of these that come up in the future could be added to that macro.\nWhat kinds of attributes would be useful to apply there other than `cfg`?\nI can't really think of any besides maybe `#[allow]`, but we handle those on the item itself. I think it would be fair to flip this into an allow-list so only `cfg` attributes get propagated.", "created_at": "2023-04-18T00:36:26Z", "version": "2.1", "FAIL_TO_PASS": ["tests/compile-pass/doc_alias.rs"], "PASS_TO_PASS": ["tests::bits_types", "tests::into_iter_from_iter_roundtrip", "tests::submodule::test_private", "tests::test_assignment_operators", "tests::test_bits", "tests::test_binary", "tests::test_const_fn", "tests::test_contains", "tests::test_debug", "tests::test_default", "tests::test_deprecated", "tests::test_disjoint_intersects", "tests::test_display_from_str_roundtrip", "tests::test_empty_does_not_intersect_with_full", "tests::test_from_bits", "tests::test_extend", "tests::test_empty_bitflags", "tests::test_from_bits_edge_cases", "tests::test_from_bits_truncate_edge_cases", "tests::test_from_bits_retain", "tests::test_from_bits_truncate", "tests::test_from_name", "tests::test_from_iterator", "tests::test_from_str_err", "tests::test_hash", "tests::test_in_function", "tests::test_insert", "tests::test_is_all", "tests::test_is_empty", "tests::test_lowerhex", "tests::test_iter", "tests::test_lt", "tests::test_octal", "tests::test_operators", "tests::test_operators_unchecked", "tests::test_ord", "tests::test_overlapping_intersects", "tests::test_pub_crate", "tests::test_pub_in_module", "tests::test_public", "tests::test_remove", "tests::test_set", "tests::test_set_ops_basic", "tests::test_set_ops_const", "tests::test_set_ops_unchecked", "tests::test_two_empties_do_not_intersect", "tests::test_u128_bitflags", "tests::test_upperhex", "tests::test_zero_value_flags", "tests::test_set_ops_exhaustive", "basic", "tests/compile-pass/cfg/nested-value.rs", "tests/compile-pass/cfg/redefined-value.rs", "tests/compile-pass/deprecated.rs", "tests/compile-pass/impls/convert.rs", "tests/compile-pass/impls/copy.rs", "tests/compile-pass/impls/default.rs", "tests/compile-pass/impls/eq.rs", "tests/compile-pass/impls/fmt.rs", "tests/compile-pass/impls/inherent_methods.rs", "tests/compile-pass/item_positions.rs", "tests/compile-pass/no_prelude.rs", "tests/compile-pass/non_snake_case.rs", "tests/compile-pass/path_based_bits.rs", "tests/compile-pass/redefinition/core.rs", "tests/compile-pass/redefinition/macros.rs", "tests/compile-pass/redefinition/result.rs", "tests/compile-pass/repr/c.rs", "tests/compile-pass/repr/transparent.rs", "tests/compile-pass/trait/generic_iter.rs", "tests/compile-pass/trait/precedence.rs", "tests/compile-pass/trait/wrapped_iter.rs", "tests/compile-pass/visibility/bits_field.rs", "tests/compile-pass/visibility/pub_in.rs"], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
