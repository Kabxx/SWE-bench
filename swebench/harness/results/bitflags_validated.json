{"repo": "bitflags/bitflags", "pull_number": 281, "instance_id": "bitflags__bitflags-281", "issue_numbers": ["215"], "base_commit": "f38ce72d11ef3e264d4b62f360bd8a5597b916d9", "patch": "diff --git a/src/bitflags_trait.rs b/src/bitflags_trait.rs\nindex 0ffee465..440d5274 100644\n--- a/src/bitflags_trait.rs\n+++ b/src/bitflags_trait.rs\n@@ -1,3 +1,5 @@\n+use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};\n+\n #[doc(hidden)]\n pub trait ImplementedByBitFlagsMacro {}\n \n@@ -5,7 +7,8 @@ pub trait ImplementedByBitFlagsMacro {}\n ///\n /// It should not be implemented manually.\n pub trait BitFlags: ImplementedByBitFlagsMacro {\n-    type Bits;\n+    type Bits: Bits;\n+\n     /// Returns an empty set of flags.\n     fn empty() -> Self;\n     /// Returns the set containing all flags.\n@@ -15,7 +18,8 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     /// Convert from underlying bit representation, unless that\n     /// representation contains bits that do not correspond to a flag.\n     fn from_bits(bits: Self::Bits) -> Option<Self>\n-    where Self: Sized;\n+    where\n+        Self: Sized;\n     /// Convert from underlying bit representation, dropping any bits\n     /// that do not correspond to flags.\n     fn from_bits_truncate(bits: Self::Bits) -> Self;\n@@ -48,3 +52,58 @@ pub trait BitFlags: ImplementedByBitFlagsMacro {\n     /// Inserts or removes the specified flags depending on the passed value.\n     fn set(&mut self, other: Self, value: bool);\n }\n+\n+// Not re-exported\n+pub trait Sealed {}\n+\n+/// A private trait that encodes the requirements of underlying bits types that can hold flags.\n+///\n+/// This trait may be made public at some future point, but it presents a compatibility hazard\n+/// so is left internal for now.\n+#[doc(hidden)]\n+pub trait Bits:\n+    Clone\n+    + Copy\n+    + BitAnd\n+    + BitAndAssign\n+    + BitOr\n+    + BitOrAssign\n+    + BitXor\n+    + BitXorAssign\n+    + Not\n+    + Sized\n+    + Sealed\n+{\n+    /// The value of `Self` where no bits are set.\n+    const EMPTY: Self;\n+\n+    /// The value of `Self` where all bits are set.\n+    const ALL: Self;\n+}\n+\n+macro_rules! impl_bits {\n+    ($($u:ty, $i:ty,)*) => {\n+        $(\n+            impl Bits for $u {\n+                const EMPTY: $u = 0;\n+                const ALL: $u = <$u>::MAX;\n+            }\n+\n+            impl Bits for $i {\n+                const EMPTY: $i = 0;\n+                const ALL: $i = <$u>::MAX as $i;\n+            }\n+\n+            impl Sealed for $u {}\n+            impl Sealed for $i {}\n+        )*\n+    }\n+}\n+\n+impl_bits! {\n+    u8, i8,\n+    u16, i16,\n+    u32, i32,\n+    u64, i64,\n+    u128, i128,\n+}\ndiff --git a/src/lib.rs b/src/lib.rs\nindex a2d3193b..979ff918 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -285,8 +285,8 @@ mod bitflags_trait;\n \n #[doc(hidden)]\n pub mod __private {\n+    pub use crate::bitflags_trait::{Bits, ImplementedByBitFlagsMacro};\n     pub use core;\n-    pub use crate::bitflags_trait::ImplementedByBitFlagsMacro;\n }\n \n /// The macro used to generate the flag structure.\n@@ -389,45 +389,6 @@ macro_rules! bitflags {\n     () => {};\n }\n \n-// A helper macro to implement the `all` function.\n-#[macro_export(local_inner_macros)]\n-#[doc(hidden)]\n-macro_rules! __impl_all_bitflags {\n-    (\n-        $BitFlags:ident: $T:ty {\n-            $(\n-                $(#[$attr:ident $($args:tt)*])*\n-                $Flag:ident = $value:expr;\n-            )+\n-        }\n-    ) => {\n-        // See `Debug::fmt` for why this approach is taken.\n-        #[allow(non_snake_case)]\n-        trait __BitFlags {\n-            $(\n-                #[allow(deprecated)]\n-                const $Flag: $T = 0;\n-            )+\n-        }\n-        #[allow(non_snake_case)]\n-        impl __BitFlags for $BitFlags {\n-            $(\n-                __impl_bitflags! {\n-                    #[allow(deprecated)]\n-                    $(? #[$attr $($args)*])*\n-                    const $Flag: $T = Self::$Flag.bits;\n-                }\n-            )+\n-        }\n-        Self { bits: $(<Self as __BitFlags>::$Flag)|+ }\n-    };\n-    (\n-        $BitFlags:ident: $T:ty { }\n-    ) => {\n-        Self { bits: 0 }\n-    };\n-}\n-\n #[macro_export(local_inner_macros)]\n #[doc(hidden)]\n macro_rules! __impl_bitflags {\n@@ -455,7 +416,7 @@ macro_rules! __impl_bitflags {\n                 // Append any extra bits that correspond to flags to the end of the format\n                 let extra_bits = self.bits & !Self::all().bits();\n \n-                if extra_bits != 0 {\n+                if extra_bits != <$T as $crate::__private::Bits>::EMPTY {\n                     if !first {\n                         f.write_str(\" | \")?;\n                     }\n@@ -495,7 +456,14 @@ macro_rules! __impl_bitflags {\n             }\n         }\n \n-        #[allow(dead_code)]\n+        #[allow(\n+            dead_code,\n+            deprecated,\n+            unused_doc_comments,\n+            unused_attributes,\n+            unused_mut,\n+            non_upper_case_globals\n+        )]\n         impl $BitFlags {\n             $(\n                 $(#[$attr $($args)*])*\n@@ -505,20 +473,13 @@ macro_rules! __impl_bitflags {\n             /// Returns an empty set of flags.\n             #[inline]\n             pub const fn empty() -> Self {\n-                Self { bits: 0 }\n+                Self { bits: <$T as $crate::__private::Bits>::EMPTY }\n             }\n \n             /// Returns the set containing all flags.\n             #[inline]\n             pub const fn all() -> Self {\n-                __impl_all_bitflags! {\n-                    $BitFlags: $T {\n-                        $(\n-                            $(#[$attr $($args)*])*\n-                            $Flag = $value;\n-                        )*\n-                    }\n-                }\n+                Self::from_bits_truncate(<$T as $crate::__private::Bits>::ALL)\n             }\n \n             /// Returns the raw value of the flags currently stored.\n@@ -532,8 +493,9 @@ macro_rules! __impl_bitflags {\n             #[inline]\n             pub const fn from_bits(bits: $T) -> $crate::__private::core::option::Option<Self> {\n                 let truncated = Self::from_bits_truncate(bits).bits;\n+\n                 if truncated == bits {\n-                    $crate::__private::core::option::Option::Some(Self{ bits })\n+                    $crate::__private::core::option::Option::Some(Self { bits })\n                 } else {\n                     $crate::__private::core::option::Option::None\n                 }\n@@ -543,15 +505,13 @@ macro_rules! __impl_bitflags {\n             /// that do not correspond to flags.\n             #[inline]\n             pub const fn from_bits_truncate(bits: $T) -> Self {\n-                if bits == 0 {\n+                if bits == <$T as $crate::__private::Bits>::EMPTY {\n                     return Self { bits }\n                 }\n \n-                #[allow(unused_mut)]\n-                let mut truncated = 0;\n+                let mut truncated = <$T as $crate::__private::Bits>::EMPTY;\n \n                 $(\n-                    #[allow(unused_doc_comments, unused_attributes)]\n                     $(#[$attr $($args)*])*\n                     if bits & Self::$Flag.bits == Self::$Flag.bits {\n                         truncated |= Self::$Flag.bits\n@@ -719,15 +679,13 @@ macro_rules! __impl_bitflags {\n             }\n \n             /// Returns an iterator over set flags and their names.\n-            pub fn iter(mut self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, Self)> {\n+            pub fn iter(self) -> impl $crate::__private::core::iter::Iterator<Item = (&'static str, Self)> {\n                 use $crate::__private::core::iter::Iterator as _;\n \n                 const NUM_FLAGS: usize = {\n-                    #[allow(unused_mut)]\n                     let mut num_flags = 0;\n \n                     $(\n-                        #[allow(unused_doc_comments, unused_attributes)]\n                         $(#[$attr $($args)*])*\n                         {\n                             num_flags += 1;\n@@ -739,13 +697,11 @@ macro_rules! __impl_bitflags {\n \n                 const OPTIONS: [$BitFlags; NUM_FLAGS] = [\n                     $(\n-                        #[allow(unused_doc_comments, unused_attributes)]\n                         $(#[$attr $($args)*])*\n                         $BitFlags::$Flag,\n                     )*\n                 ];\n \n-                #[allow(unused_doc_comments, unused_attributes)]\n                 const OPTIONS_NAMES: [&'static str; NUM_FLAGS] = [\n                     $(\n                         $(#[$attr $($args)*])*\n@@ -754,17 +710,29 @@ macro_rules! __impl_bitflags {\n                 ];\n \n                 let mut start = 0;\n+                let mut state = self;\n \n                 $crate::__private::core::iter::from_fn(move || {\n-                    if self.is_empty() || NUM_FLAGS == 0 {\n+                    if state.is_empty() || NUM_FLAGS == 0 {\n                         $crate::__private::core::option::Option::None\n                     } else {\n                         for (flag, flag_name) in OPTIONS[start..NUM_FLAGS].iter().copied()\n                             .zip(OPTIONS_NAMES[start..NUM_FLAGS].iter().copied())\n                         {\n                             start += 1;\n+\n+                            // NOTE: We check whether the flag exists in self, but remove it from\n+                            // a different value. This ensure that overlapping flags are handled\n+                            // properly. Take the following example:\n+                            //\n+                            // const A: 0b00000001;\n+                            // const B: 0b00000101;\n+                            //\n+                            // Given the bits 0b00000101, both A and B are set. But if we removed A\n+                            // as we encountered it we'd be left with 0b00000100, which doesn't\n+                            // correspond to a valid flag on its own.\n                             if self.contains(flag) {\n-                                self.remove(flag);\n+                                state.remove(flag);\n \n                                 return $crate::__private::core::option::Option::Some((flag_name, flag))\n                             }\n@@ -1353,7 +1321,10 @@ mod tests {\n         assert_eq!(UNION, Flags::A | Flags::C);\n         assert_eq!(DIFFERENCE, Flags::all() - Flags::A);\n         assert_eq!(COMPLEMENT, !Flags::C);\n-        assert_eq!(SYM_DIFFERENCE, (Flags::A | Flags::C) ^ (Flags::all() - Flags::A));\n+        assert_eq!(\n+            SYM_DIFFERENCE,\n+            (Flags::A | Flags::C) ^ (Flags::all() - Flags::A)\n+        );\n     }\n \n     #[test]\n@@ -1609,13 +1580,15 @@ mod tests {\n         assert_eq!(format!(\"{:?}\", Flags::A | Flags::B), \"A | B\");\n         assert_eq!(format!(\"{:?}\", Flags::empty()), \"(empty)\");\n         assert_eq!(format!(\"{:?}\", Flags::ABC), \"A | B | C\");\n+\n         let extra = unsafe { Flags::from_bits_unchecked(0xb8) };\n+\n         assert_eq!(format!(\"{:?}\", extra), \"0xb8\");\n         assert_eq!(format!(\"{:?}\", Flags::A | extra), \"A | 0xb8\");\n \n         assert_eq!(\n             format!(\"{:?}\", Flags::ABC | extra),\n-            \"A | B | C | 0xb8\"\n+            \"A | B | C | ABC | 0xb8\"\n         );\n \n         assert_eq!(format!(\"{:?}\", EmptyFlags::empty()), \"(empty)\");\n@@ -1830,7 +1803,8 @@ mod tests {\n     fn test_serde_bitflags_roundtrip() {\n         let flags = SerdeFlags::A | SerdeFlags::B;\n \n-        let deserialized: SerdeFlags = serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n+        let deserialized: SerdeFlags =\n+            serde_json::from_str(&serde_json::to_string(&flags).unwrap()).unwrap();\n \n         assert_eq!(deserialized.bits, flags.bits);\n     }\n@@ -1854,7 +1828,6 @@ mod tests {\n             }\n         }\n \n-\n         let flags = Flags::from_bits(0b00000100);\n         assert_eq!(flags, None);\n         let flags = Flags::from_bits(0b00000101);\n@@ -1875,7 +1848,7 @@ mod tests {\n         let flags = Flags::from_bits_truncate(0b00000101);\n         assert_eq!(flags, Flags::A);\n     }\n-  \n+\n     #[test]\n     fn test_iter() {\n         bitflags! {\n@@ -1887,24 +1860,31 @@ mod tests {\n                 const FOUR_WIN = 0b1000;\n                 #[cfg(unix)]\n                 const FOUR_UNIX = 0b10000;\n+                const FIVE = 0b01000100;\n             }\n         }\n \n         let count = {\n             #[cfg(any(unix, windows))]\n             {\n-                4\n+                5\n             }\n \n             #[cfg(not(any(unix, windows)))]\n             {\n-                3\n+                4\n             }\n         };\n \n         let flags = Flags::all();\n         assert_eq!(flags.iter().count(), count);\n+\n+        for (_, flag) in flags.iter() {\n+            assert!(flags.contains(flag));\n+        }\n+\n         let mut iter = flags.iter();\n+\n         assert_eq!(iter.next().unwrap(), (\"ONE\", Flags::ONE));\n         assert_eq!(iter.next().unwrap(), (\"TWO\", Flags::TWO));\n         assert_eq!(iter.next().unwrap(), (\"THREE\", Flags::THREE));\n@@ -1918,6 +1898,8 @@ mod tests {\n             assert_eq!(iter.next().unwrap(), (\"FOUR_WIN\", Flags::FOUR_WIN));\n         }\n \n+        assert_eq!(iter.next().unwrap(), (\"FIVE\", Flags::FIVE));\n+\n         assert_eq!(iter.next(), None);\n \n         let flags = Flags::empty();\n@@ -1925,7 +1907,9 @@ mod tests {\n \n         let flags = Flags::ONE | Flags::THREE;\n         assert_eq!(flags.iter().count(), 2);\n+\n         let mut iter = flags.iter();\n+\n         assert_eq!(iter.next().unwrap(), (\"ONE\", Flags::ONE));\n         assert_eq!(iter.next().unwrap(), (\"THREE\", Flags::THREE));\n         assert_eq!(iter.next(), None);\n", "test_patch": "diff --git a/tests/compile-fail/cfg/multi.stderr b/tests/compile-fail/cfg/multi.stderr\ndeleted file mode 100644\nindex be9ba21c..00000000\n--- a/tests/compile-fail/cfg/multi.stderr\n+++ /dev/null\n@@ -1,17 +0,0 @@\n-error[E0428]: the name `FOO` is defined multiple times\n-  --> tests/compile-fail/cfg/multi.rs:6:1\n-   |\n-6  | / bitflags! {\n-7  | |     pub struct Flags: u32 {\n-8  | |         #[cfg(target_os = \"linux\")]\n-9  | |         const FOO = 1;\n-...  |\n-12 | |     }\n-13 | | }\n-   | | ^\n-   | | |\n-   | |_`FOO` redefined here\n-   |   previous definition of the value `FOO` here\n-   |\n-   = note: `FOO` must be defined only once in the value namespace of this trait\n-   = note: this error originates in the macro `__impl_all_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\ndiff --git a/tests/compile-fail/non_integer_base/all_defined.stderr b/tests/compile-fail/non_integer_base/all_defined.stderr\nindex fb9c2867..69d89dc5 100644\n--- a/tests/compile-fail/non_integer_base/all_defined.stderr\n+++ b/tests/compile-fail/non_integer_base/all_defined.stderr\n@@ -1,22 +1,16 @@\n-error[E0308]: mismatched types\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n+   --> tests/compile-fail/non_integer_base/all_defined.rs:116:22\n     |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+116 |     struct Flags128: MyInt {\n+    |                      ^^^^^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n+note: required by a bound in `bitflags::BitFlags::Bits`\n+   --> src/bitflags_trait.rs\n     |\n-458 |                 if extra_bits != MyInt(0) {\n-    |                                  ++++++ +\n+    |     type Bits: Bits;\n+    |                ^^^^ required by this bound in `bitflags::BitFlags::Bits`\n \n-error[E0308]: mismatched types\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n     |\n 115 | / bitflags! {\n@@ -26,15 +20,11 @@ error[E0308]: mismatched types\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-508 |                 Self { bits: MyInt(0) }\n-    |                              ++++++ +\n \n-error[E0308]: mismatched types\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n     |\n 115 | / bitflags! {\n@@ -44,15 +34,11 @@ error[E0308]: mismatched types\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-546 |                 if bits == MyInt(0) {\n-    |                            ++++++ +\n \n-error[E0277]: no implementation for `{integer} |= MyInt`\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n     |\n 115 | / bitflags! {\n@@ -62,12 +48,11 @@ error[E0277]: no implementation for `{integer} |= MyInt`\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ no implementation for `{integer} |= MyInt`\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n-    = help: the trait `BitOrAssign<MyInt>` is not implemented for `{integer}`\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error[E0308]: mismatched types\n+error[E0277]: the trait bound `MyInt: Bits` is not satisfied\n    --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n     |\n 115 | / bitflags! {\n@@ -77,28 +62,6 @@ error[E0308]: mismatched types\n 119 | |         const C = MyInt(0b0000_0100u8);\n 120 | |     }\n 121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n+    | |_^ the trait `Bits` is not implemented for `MyInt`\n     |\n     = note: this error originates in the macro `__impl_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-561 |                 Self { bits: MyInt(truncated) }\n-    |                              ++++++         +\n-\n-error[E0308]: mismatched types\n-   --> tests/compile-fail/non_integer_base/all_defined.rs:115:1\n-    |\n-115 | / bitflags! {\n-116 | |     struct Flags128: MyInt {\n-117 | |         const A = MyInt(0b0000_0001u8);\n-118 | |         const B = MyInt(0b0000_0010u8);\n-119 | |         const C = MyInt(0b0000_0100u8);\n-120 | |     }\n-121 | | }\n-    | |_^ expected struct `MyInt`, found integer\n-    |\n-    = note: this error originates in the macro `__impl_all_bitflags` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: try wrapping the expression in `MyInt`\n-    |\n-409 |                 const $Flag: $T = MyInt(0);\n-    |                                   ++++++ +\ndiff --git a/tests/compile-fail/trait/custom_impl.stderr b/tests/compile-fail/trait/custom_impl.stderr\nindex 7f3b4b1e..d7e8d494 100644\n--- a/tests/compile-fail/trait/custom_impl.stderr\n+++ b/tests/compile-fail/trait/custom_impl.stderr\n@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `BootlegFlags: ImplementedByBitFlagsMacro` is not satisfied\n- --> $DIR/custom_impl.rs:5:6\n+ --> tests/compile-fail/trait/custom_impl.rs:5:6\n   |\n 5 | impl BitFlags for BootlegFlags {\n   |      ^^^^^^^^ the trait `ImplementedByBitFlagsMacro` is not implemented for `BootlegFlags`\n   |\n note: required by a bound in `BitFlags`\n- --> $DIR/bitflags_trait.rs:7:21\n+ --> src/bitflags_trait.rs\n   |\n-7 | pub trait BitFlags: ImplementedByBitFlagsMacro {\n+  | pub trait BitFlags: ImplementedByBitFlagsMacro {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `BitFlags`\ndiff --git a/tests/compile-fail/cfg/multi.rs b/tests/compile-pass/cfg/redefined-value.rs\nsimilarity index 70%\nrename from tests/compile-fail/cfg/multi.rs\nrename to tests/compile-pass/cfg/redefined-value.rs\nindex 461db914..6bb2b651 100644\n--- a/tests/compile-fail/cfg/multi.rs\n+++ b/tests/compile-pass/cfg/redefined-value.rs\n@@ -1,12 +1,11 @@\n #[macro_use]\n extern crate bitflags;\n \n-// NOTE: Ideally this would work, but our treatment of CFGs\n-// assumes flags may be missing but not redefined\n bitflags! {\n     pub struct Flags: u32 {\n         #[cfg(target_os = \"linux\")]\n         const FOO = 1;\n+\n         #[cfg(not(target_os = \"linux\"))]\n         const FOO = 2;\n     }\n@@ -20,6 +19,6 @@ fn main() {\n \n     #[cfg(not(target_os = \"linux\"))]\n     {\n-        assert_eq!(1, Flags::FOO.bits());\n+        assert_eq!(2, Flags::FOO.bits());\n     }\n }\ndiff --git a/tests/compile-pass/deprecated.rs b/tests/compile-pass/deprecated.rs\nnew file mode 100644\nindex 00000000..167ce44c\n--- /dev/null\n+++ b/tests/compile-pass/deprecated.rs\n@@ -0,0 +1,14 @@\n+#![deny(warnings)]\n+\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags: u32 {\n+        #[deprecated = \"Use something else\"]\n+        const A = 0b00000001;\n+        const B = 0b00000010;\n+    }\n+}\n+\n+fn main() {}\ndiff --git a/tests/compile-pass/non_snake_case.rs b/tests/compile-pass/non_snake_case.rs\nnew file mode 100644\nindex 00000000..5a3b8103\n--- /dev/null\n+++ b/tests/compile-pass/non_snake_case.rs\n@@ -0,0 +1,13 @@\n+#![deny(warnings)]\n+\n+#[macro_use]\n+extern crate bitflags;\n+\n+bitflags! {\n+    pub struct Flags: u32 {\n+        const CamelCase = 0b00000001;\n+        const B = 0b00000010;\n+    }\n+}\n+\n+fn main() {}\n", "problem_statement": "Debug formatting leads to less desireable output\n[Link to rust playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23%5Bmacro_use%5D%0Aextern%20crate%20bitflags%3B%0A%0Abitflags!%20%7B%0A%20%20%20%20struct%20Flags%3A%20u32%20%7B%0A%20%20%20%20%20%20%20%20const%20A%20%3D%200b00000001%3B%0A%20%20%20%20%20%20%20%20const%20B%20%3D%200b00000010%3B%0A%20%20%20%20%20%20%20%20const%20C%20%3D%200b00000100%3B%0A%20%20%20%20%20%20%20%20const%20ABC%20%3D%20Self%3A%3AA.bits%20%7C%20Self%3A%3AB.bits%20%7C%20Self%3A%3AC.bits%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20Flags%3A%3AA%20%7C%20Flags%3A%3AB%20%7C%20Flags%3A%3AC%20)%3B%0A%7D)\r\n\r\n```rust\r\n#[macro_use]\r\nextern crate bitflags;\r\n\r\nbitflags! {\r\n    struct Flags: u32 {\r\n        const A = 0b00000001;\r\n        const B = 0b00000010;\r\n        const C = 0b00000100;\r\n        const ABC = Self::A.bits | Self::B.bits | Self::C.bits;\r\n    }\r\n}\r\n\r\nfn main() {\r\n    println!(\"{:?}\", Flags::A | Flags::B | Flags::C );\r\n}\r\n```\r\n\r\nprints:\r\n\r\n```bash\r\nA | B | C | ABC\r\n```\r\n\r\nI find it somewhat less helpful that both the expanded (`A | B | C`) and \"compressed\" form (`ABC`) are reported...\r\n\r\nIs there a reason behind this? Is this considered more correct for some reason?\n", "hints_text": "I think the current algorithm used for debug output is to loop over all flags and append identifiers that correspond to set bits. I think an alternative here that could work would be to short-circuit when we\u2019ve built a format that covers all the set bits. As an implementation note we wouldn\u2019t be able to work off a single source and just mask out bits as we see them, we\u2019ll need to use the whole set of bits to see if a flag is applicable and then a second set that\u2019s masked to see when we\u2019ve catered for all set bits. Otherwise something like this wouldn\u2019t work:\r\n\r\n```\r\nconst A: 0b00000100\r\nconst B: 0b00001100\r\n\r\nlet input = B;\r\n```\r\n\r\nwe\u2019d mask out bit 3 for `A` but then have one leftover for `B` that doesn\u2019t correspond to it. In that example we\u2019d end up writing `A | B` still, but wouldn\u2019t duplicate compound identifiers the same.\r\n\r\nIn general, I\u2019m not sure if there\u2019s a reasonable algorithm that would produce the smallest possible format for any given set of bits.", "created_at": "2022-05-03T06:59:46Z", "version": "1.3", "FAIL_TO_PASS": ["tests/compile-pass/cfg/redefined-value.rs", "tests/compile-pass/deprecated.rs", "tests/compile-pass/non_snake_case.rs"], "PASS_TO_PASS": ["tests::test_assignment_operators", "tests::submodule::test_private", "tests::test_binary", "tests::test_bits", "tests::test_const_fn", "tests::test_contains", "tests::test_debug", "tests::test_default", "tests::test_deprecated", "tests::test_disjoint_intersects", "tests::test_empty_bitflags", "tests::test_empty_does_not_intersect_with_full", "tests::test_extend", "tests::test_from_bits", "tests::test_from_bits_edge_cases", "tests::test_from_bits_truncate", "tests::test_from_bits_truncate_edge_cases", "tests::test_from_bits_unchecked", "tests::test_hash", "tests::test_in_function", "tests::test_insert", "tests::test_is_all", "tests::test_is_empty", "tests::test_iter", "tests::test_lowerhex", "tests::test_octal", "tests::test_lt", "tests::test_operators", "tests::test_operators_unchecked", "tests::test_ord", "tests::test_overlapping_intersects", "tests::test_pub_crate", "tests::test_pub_in_module", "tests::test_public", "tests::test_remove", "tests::test_serde_bitflags_deserialize", "tests::test_serde_bitflags_roundtrip", "tests::test_serde_bitflags_serialize", "tests::test_set_ops_basic", "tests::test_set_ops_const", "tests::test_set_ops_unchecked", "tests::test_u128_bitflags", "tests::test_upperhex", "tests::test_two_empties_do_not_intersect", "tests::test_zero_value_flags", "tests::test_set", "tests::test_from_iterator", "tests::test_set_ops_exhaustive", "basic", "tests/compile-pass/cfg/nested-value.rs", "tests/compile-pass/impls/convert.rs", "tests/compile-pass/impls/default.rs", "tests/compile-pass/impls/fmt.rs", "tests/compile-pass/impls/inherent_methods.rs", "tests/compile-pass/no_prelude.rs", "tests/compile-pass/redefinition/core.rs", "tests/compile-pass/redefinition/macros.rs", "tests/compile-pass/redefinition/result.rs", "tests/compile-pass/repr/c.rs", "tests/compile-pass/repr/transparent.rs", "tests/compile-pass/trait/precedence.rs", "tests/compile-pass/visibility/bits_field.rs", "tests/compile-pass/visibility/pub_in.rs"], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
{"repo": "bitflags/bitflags", "pull_number": 268, "instance_id": "bitflags__bitflags-268", "issue_numbers": ["267"], "base_commit": "1aa25e1b3baf35d3d3840f12fe7e8b55adc0164a", "patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 617afea0..b24fb40b 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -494,8 +494,7 @@ macro_rules! __impl_bitflags {\n                         f.write_str(\" | \")?;\n                     }\n                     first = false;\n-                    f.write_str(\"0x\")?;\n-                    $crate::_core::fmt::LowerHex::fmt(&extra_bits, f)?;\n+                    $crate::_core::write!(f, \"{:#x}\", extra_bits)?;\n                 }\n                 if first {\n                     f.write_str(\"(empty)\")?;\n", "test_patch": "diff --git a/tests/compile-fail/trait/custom_impl.rs b/tests/compile-fail/trait/custom_impl.rs\nindex 66875898..80be2f91 100644\n--- a/tests/compile-fail/trait/custom_impl.rs\n+++ b/tests/compile-fail/trait/custom_impl.rs\n@@ -62,4 +62,4 @@ impl BitFlags for BootlegFlags {\n     }\n }\n \n-fn main() { }\n+fn main() {}\ndiff --git a/tests/compile-pass/impls/convert.rs b/tests/compile-pass/impls/convert.rs\nindex 1f02982a..393ed8f8 100644\n--- a/tests/compile-pass/impls/convert.rs\n+++ b/tests/compile-pass/impls/convert.rs\n@@ -12,6 +12,4 @@ impl From<u32> for Flags {\n     }\n }\n \n-fn main() {\n-\n-}\n+fn main() {}\ndiff --git a/tests/compile-pass/impls/fmt.rs b/tests/compile-pass/impls/fmt.rs\nnew file mode 100644\nindex 00000000..567fd448\n--- /dev/null\n+++ b/tests/compile-pass/impls/fmt.rs\n@@ -0,0 +1,14 @@\n+use bitflags::bitflags;\n+\n+bitflags! {\n+    struct Flags: u8 {\n+        const TWO = 0x2;\n+    }\n+}\n+\n+fn main() {\n+    // bug #267 (https://github.com/bitflags/bitflags/issues/267)\n+    let flags = unsafe { Flags::from_bits_unchecked(0b11) };\n+    assert_eq!(format!(\"{:?}\", flags), \"TWO | 0x1\");\n+    assert_eq!(format!(\"{:#?}\", flags), \"TWO | 0x1\");\n+}\ndiff --git a/tests/compile-pass/redefinition/stringify.rs b/tests/compile-pass/redefinition/macros.rs\nsimilarity index 52%\nrename from tests/compile-pass/redefinition/stringify.rs\nrename to tests/compile-pass/redefinition/macros.rs\nindex b04f2f6a..a9835124 100644\n--- a/tests/compile-pass/redefinition/stringify.rs\n+++ b/tests/compile-pass/redefinition/macros.rs\n@@ -7,6 +7,11 @@ macro_rules! stringify {\n     ($($t:tt)*) => { \"...\" };\n }\n \n+#[allow(unused_macros)]\n+macro_rules! write {\n+    ($($t:tt)*) => { \"...\" };\n+}\n+\n bitflags! {\n     struct Test: u8 {\n         const A = 1;\n@@ -14,6 +19,6 @@ bitflags! {\n }\n \n fn main() {\n-    // Just make sure we don't call the redefined `stringify` macro\n-    assert_eq!(format!(\"{:?}\", Test::A), \"A\");\n+    // Just make sure we don't call the redefined `stringify` or `write` macro\n+    assert_eq!(format!(\"{:?}\", unsafe { Test::from_bits_unchecked(0b11) }), \"A | 0x2\");\n }\n", "problem_statement": "Bug: debug pretty-printing unknown flags display 0x0x\nmain.rs\r\n```rust\r\nuse bitflags::bitflags;\r\n\r\nbitflags! {\r\n    struct Flags: u8 {\r\n        const TWO = 0x2;\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let value = 0b11;\r\n    let flags = unsafe { Flags::from_bits_unchecked(value) };\r\n    println!(\"{:?}\", flags);\r\n    println!(\"-----------\");\r\n    println!(\"{:#?}\", flags);\r\n}\r\n```\r\nwill print the following:\r\n```sh\r\nTWO | 0x1\r\n-----------\r\nTWO | 0x0x1\r\n```\r\n\r\nthe expected output would either be 0x1 for both, or 1, and 0x1 respectively\n", "hints_text": "", "created_at": "2022-01-02T17:22:14Z", "version": "1.3", "FAIL_TO_PASS": ["tests/compile-pass/impls/fmt.rs"], "PASS_TO_PASS": ["tests::submodule::test_private", "tests::test_assignment_operators", "tests::test_binary", "tests::test_bits", "tests::test_const_fn", "tests::test_contains", "tests::test_debug", "tests::test_default", "tests::test_deprecated", "tests::test_disjoint_intersects", "tests::test_empty_bitflags", "tests::test_empty_does_not_intersect_with_full", "tests::test_extend", "tests::test_from_bits", "tests::test_from_bits_unchecked", "tests::test_from_iterator", "tests::test_hash", "tests::test_is_all", "tests::test_lowerhex", "tests::test_is_empty", "tests::test_operators", "tests::test_operators_unchecked", "tests::test_overlapping_intersects", "tests::test_insert", "tests::test_lt", "tests::test_pub_crate", "tests::test_pub_in_module", "tests::test_remove", "tests::test_serde_bitflags_serialize", "tests::test_ord", "tests::test_serde_bitflags_roundtrip", "tests::test_serde_bitflags_deserialize", "tests::test_set", "tests::test_set_ops_basic", "tests::test_in_function", "tests::test_set_ops_const", "tests::test_public", "tests::test_octal", "tests::test_set_ops_unchecked", "tests::test_two_empties_do_not_intersect", "tests::test_u128_bitflags", "tests::test_upperhex", "tests::test_zero_value_flags", "tests::test_from_bits_truncate", "tests::test_set_ops_exhaustive", "basic", "tests/compile-pass/cfg/nested-value.rs", "tests/compile-pass/impls/convert.rs", "tests/compile-pass/impls/default.rs", "tests/compile-pass/impls/inherent_methods.rs", "tests/compile-pass/redefinition/core.rs", "tests/compile-pass/redefinition/macros.rs", "tests/compile-pass/repr/c.rs", "tests/compile-pass/repr/transparent.rs", "tests/compile-pass/trait/precedence.rs", "tests/compile-pass/visibility/bits_field.rs", "tests/compile-pass/visibility/pub_in.rs"], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
{"repo": "bitflags/bitflags", "pull_number": 266, "instance_id": "bitflags__bitflags-266", "issue_numbers": ["265"], "base_commit": "1aa25e1b3baf35d3d3840f12fe7e8b55adc0164a", "patch": "diff --git a/src/lib.rs b/src/lib.rs\nindex 617afea0..a4ca8429 100644\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -500,7 +500,7 @@ macro_rules! __impl_bitflags {\n                 if first {\n                     f.write_str(\"(empty)\")?;\n                 }\n-                Ok(())\n+                $crate::_core::fmt::Result::Ok(())\n             }\n         }\n         impl $crate::_core::fmt::Binary for $BitFlags {\n", "test_patch": "diff --git a/tests/compile-pass/redefinition/result.rs b/tests/compile-pass/redefinition/result.rs\nnew file mode 100644\nindex 00000000..fe915d47\n--- /dev/null\n+++ b/tests/compile-pass/redefinition/result.rs\n@@ -0,0 +1,15 @@\n+use bitflags::bitflags;\n+\n+// Checks for possible errors caused by overriding names used by `bitflags!` internally.\n+\n+// bug #265 (https://github.com/bitflags/bitflags/issues/265)\n+\n+pub struct Ok<T>(T);\n+\n+bitflags! {\n+    pub struct Flags: u16{\n+        const FOO = 0x0001;\n+    }\n+}\n+\n+fn main() {}\n", "problem_statement": "The bitflags macro is not sanitary wrt. standard library types and enumerations\nThe `bitflags` macro, expanded in the prescence of a definition of the type/value `Ok` errors.\r\nReproduction code:\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=3fda3e36c7c6a57e0f7a83c84e56df20\r\n\r\nInterestingly, the relevant function, the `fmt` function from the Debug impl, does use `::bitflags::_core::fmt::Result`, however, it merely returns the value `Ok(())`. \n", "hints_text": "", "created_at": "2021-12-16T09:38:14Z", "version": "1.3", "FAIL_TO_PASS": ["tests/compile-pass/redefinition/result.rs"], "PASS_TO_PASS": ["tests::submodule::test_private", "tests::test_assignment_operators", "tests::test_binary", "tests::test_bits", "tests::test_const_fn", "tests::test_contains", "tests::test_debug", "tests::test_default", "tests::test_deprecated", "tests::test_disjoint_intersects", "tests::test_empty_bitflags", "tests::test_extend", "tests::test_empty_does_not_intersect_with_full", "tests::test_from_bits", "tests::test_from_bits_truncate", "tests::test_from_bits_unchecked", "tests::test_from_iterator", "tests::test_hash", "tests::test_in_function", "tests::test_insert", "tests::test_is_all", "tests::test_is_empty", "tests::test_lowerhex", "tests::test_lt", "tests::test_octal", "tests::test_operators", "tests::test_operators_unchecked", "tests::test_ord", "tests::test_pub_crate", "tests::test_pub_in_module", "tests::test_public", "tests::test_remove", "tests::test_serde_bitflags_deserialize", "tests::test_serde_bitflags_roundtrip", "tests::test_set_ops_basic", "tests::test_set_ops_const", "tests::test_two_empties_do_not_intersect", "tests::test_set_ops_unchecked", "tests::test_u128_bitflags", "tests::test_upperhex", "tests::test_set", "tests::test_zero_value_flags", "tests::test_serde_bitflags_serialize", "tests::test_overlapping_intersects", "tests::test_set_ops_exhaustive", "basic", "tests/compile-pass/cfg/nested-value.rs", "tests/compile-pass/impls/convert.rs", "tests/compile-pass/impls/default.rs", "tests/compile-pass/impls/inherent_methods.rs", "tests/compile-pass/redefinition/core.rs", "tests/compile-pass/redefinition/stringify.rs", "tests/compile-pass/repr/c.rs", "tests/compile-pass/repr/transparent.rs", "tests/compile-pass/trait/precedence.rs", "tests/compile-pass/visibility/bits_field.rs", "tests/compile-pass/visibility/pub_in.rs"], "FAIL_TO_FAIL": [], "PASS_TO_FAIL": []}
