[{"repo": "serde-rs/serde", "pull_number": 1363, "instance_id": "serde-rs__serde-1363", "issue_numbers": ["1362"], "base_commit": "c69a3e083fa865b7801a80db498e4fdc87435aad", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex e2ddfee1e..af5d5b0ca 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -30,8 +30,9 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<TokenStream\n     let ident = &cont.ident;\n     let params = Parameters::new(&cont);\n     let (de_impl_generics, _, ty_generics, where_clause) = split_with_de_lifetime(&params);\n+    let suffix = ident.to_string().trim_left_matches(\"r#\").to_owned();\n     let dummy_const = Ident::new(\n-        &format!(\"_IMPL_DESERIALIZE_FOR_{}\", ident),\n+        &format!(\"_IMPL_DESERIALIZE_FOR_{}\", suffix),\n         Span::call_site(),\n     );\n     let body = Stmts(deserialize_body(&cont, &params));\ndiff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex ede409db1..3f399ded9 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -90,6 +90,10 @@ pub struct Name {\n     deserialize: String,\n }\n \n+fn unraw(ident: &Ident) -> String {\n+    ident.to_string().trim_left_matches(\"r#\").to_owned()\n+}\n+\n impl Name {\n     /// Return the container name for the container when serializing.\n     pub fn serialize_name(&self) -> String {\n@@ -380,8 +384,8 @@ impl Container {\n \n         Container {\n             name: Name {\n-                serialize: ser_name.get().unwrap_or_else(|| item.ident.to_string()),\n-                deserialize: de_name.get().unwrap_or_else(|| item.ident.to_string()),\n+                serialize: ser_name.get().unwrap_or_else(|| unraw(&item.ident)),\n+                deserialize: de_name.get().unwrap_or_else(|| unraw(&item.ident)),\n             },\n             transparent: transparent.get(),\n             deny_unknown_fields: deny_unknown_fields.get(),\n@@ -697,8 +701,8 @@ impl Variant {\n         let de_renamed = de_name.is_some();\n         Variant {\n             name: Name {\n-                serialize: ser_name.unwrap_or_else(|| variant.ident.to_string()),\n-                deserialize: de_name.unwrap_or_else(|| variant.ident.to_string()),\n+                serialize: ser_name.unwrap_or_else(|| unraw(&variant.ident)),\n+                deserialize: de_name.unwrap_or_else(|| unraw(&variant.ident)),\n             },\n             ser_renamed: ser_renamed,\n             de_renamed: de_renamed,\n@@ -822,7 +826,7 @@ impl Field {\n         let mut flatten = BoolAttr::none(cx, \"flatten\");\n \n         let ident = match field.ident {\n-            Some(ref ident) => ident.to_string(),\n+            Some(ref ident) => unraw(ident),\n             None => index.to_string(),\n         };\n \ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 30c326d99..d5ae14019 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -26,7 +26,8 @@ pub fn expand_derive_serialize(input: &syn::DeriveInput) -> Result<TokenStream,\n     let ident = &cont.ident;\n     let params = Parameters::new(&cont);\n     let (impl_generics, ty_generics, where_clause) = params.generics.split_for_impl();\n-    let dummy_const = Ident::new(&format!(\"_IMPL_SERIALIZE_FOR_{}\", ident), Span::call_site());\n+    let suffix = ident.to_string().trim_left_matches(\"r#\").to_owned();\n+    let dummy_const = Ident::new(&format!(\"_IMPL_SERIALIZE_FOR_{}\", suffix), Span::call_site());\n     let body = Stmts(serialize_body(&cont, &params));\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n", "test_patch": "diff --git a/test_suite/tests/test_unstable.rs b/test_suite/tests/test_unstable.rs\nnew file mode 100644\nindex 000000000..ccc68c822\n--- /dev/null\n+++ b/test_suite/tests/test_unstable.rs\n@@ -0,0 +1,27 @@\n+// Copyright 2018 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(warnings)]\n+#![cfg_attr(feature = \"unstable\", feature(raw_identifiers))]\n+\n+#[cfg(feature = \"unstable\")]\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[cfg(feature = \"unstable\")]\n+extern crate serde;\n+#[cfg(feature = \"unstable\")]\n+extern crate serde_test;\n+\n+// This test target is convoluted with the actual #[test] in a separate file to\n+// get it so that the stable compiler does not need to parse the code of the\n+// test. If the test were written with #[cfg(feature = \"unstable\")] #[test]\n+// right here, the stable compiler would fail to parse those raw identifiers\n+// even if the cfg were not enabled.\n+#[cfg(feature = \"unstable\")]\n+mod unstable;\ndiff --git a/test_suite/tests/unstable/mod.rs b/test_suite/tests/unstable/mod.rs\nnew file mode 100644\nindex 000000000..0a8a3330f\n--- /dev/null\n+++ b/test_suite/tests/unstable/mod.rs\n@@ -0,0 +1,30 @@\n+// Copyright 2018 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use serde_test::{assert_tokens, Token};\n+\n+#[test]\n+fn test_raw_identifiers() {\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    #[allow(non_camel_case_types)]\n+    enum r#type {\n+        r#type {\n+            r#type: (),\n+        }\n+    }\n+\n+    assert_tokens(\n+        &r#type::r#type { r#type: () },\n+        &[\n+            Token::StructVariant { name: \"type\", variant: \"type\", len: 1 },\n+            Token::Str(\"type\"),\n+            Token::Unit,\n+            Token::StructVariantEnd,\n+        ],\n+    );\n+}\n", "problem_statement": "Raw identifier keywords\nRight now, `serde_derive` passes through the `r#` on [raw identifiers](https://rust-lang-nursery.github.io/edition-guide/rust-2018/module-system/raw-identifiers.html) when the identifier is a keyword.\r\n\r\nFor example ([playground link](https://play.rust-lang.org/?gist=0492ec75839fb4634b7a9ee6e9a1094f&version=nightly&mode=debug&edition=2018))\r\n```rust\r\n#[derive(Serialize)]\r\nstruct Foo {\r\n    r#type: i32,\r\n    r#bar: i32\r\n}\r\n\r\nfn main() {\r\n    let foo = Foo{ r#type: 3, r#bar: 12 };\r\n    println!(\"{}\", serde_json::to_string_pretty(&foo).unwrap());\r\n}\r\n```\r\n\r\nprints\r\n```\r\n{\r\n  \"r#type\": 3,\r\n  \"bar\": 12\r\n}\r\n```\r\n\r\nThat `r#` on the `r#type` seems like it shouldn't be exposed downstream of serde, since the current-list-of-keywords-in-Rust is an implementation detail that serialization probably shouldn't care about. Currently, a bunch of the data format libraries that work with serde (e.g. [ron](https://github.com/ron-rs/ron)) emit invalid data when provided with these raw identifiers, since they assume that field identifiers have a limited set of characters (that doesn't include `#`).\r\n\r\nUnfortunately, the root of this issue is probably upstream of serde, and even writing a test case for this in this repo is tricky (since the test code has to be Rust 2018).\n", "hints_text": "Interesting! This is a bug. That program should be printing `\"type\": 3` instead of `\"r#type\": 3`.\r\n\r\nWould you be interested in tracking down where this is going wrong and sending a PR? Otherwise I should be able to take a look later this week.\r\n\r\nAs a workaround, at least `serde(rename = \"...\")` seems to work but this shouldn't be necessary.\r\n\r\n```rust\r\n#[derive(Serialize)]\r\nstruct Foo {\r\n    #[serde(rename = \"type\")]\r\n    r#type: i32,\r\n    r#bar: i32\r\n}\r\n```", "created_at": "2018-08-23T01:10:37Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1323, "instance_id": "serde-rs__serde-1323", "issue_numbers": ["1319"], "base_commit": "d827b101d9a5896071013bc70f88be172cf0a550", "patch": "diff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex 0b21e5414..cb2739820 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -69,6 +69,15 @@ impl Serialize for String {\n     }\n }\n \n+impl<'a> Serialize for fmt::Arguments<'a> {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        serializer.collect_str(self)\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n \n #[cfg(feature = \"std\")]\n", "test_patch": "diff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex cd4ce6bf4..eff19069c 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -462,6 +462,11 @@ declare_tests! {\n             Token::SeqEnd,\n         ],\n     }\n+    test_fmt_arguments {\n+        format_args!(\"{}{}\", 1, 'a') => &[\n+            Token::Str(\"1a\"),\n+        ],\n+    }\n }\n \n declare_tests! {\n", "problem_statement": "impl<'a> Serialize for fmt::Arguments<'a>\nWould it make sense to impl<'a> Serialize for fmt::Arguments<'a> ?\r\n\r\nIt's a very handy type, and available in `core` library. Though I guess for best support, the `Serializer` would have to get a `serialize_fmt` method, so it is possible to write it out without allocating temporary strings, etc. That would probably be a breaking change, though maybe an implementation that serializes into temporary, and calls `serialize_str` or something would do.\n", "hints_text": "Well... We could add an impl of [`std::fmt::Write`](https://doc.rust-lang.org/std/fmt/trait.Write.html) for all `Serializer`s. I guess the `write_str` method could just forward to `serialize_str`:\r\n\r\nDISCLAIMER: all the code below is entirely untested and probably will not compile without some adjustments\r\n\r\n```rust\r\nimpl<S: Serializer> std::fmt::Write for S {\r\n    #[inline]\r\n    fn write_str(&mut self, s: &str) -> std::fmt::Result {\r\n        self.serialize_str(s).map_err(|_| std::fmt::Error)\r\n    }\r\n}\r\n```\r\n\r\nAlthough that would be a breaking change, because someone might have implemented `Write` for their serializer already.\r\n\r\nWe can still do this by adding a wrapper type for `Serializer`s that we then use inside the `Serialize` impl of `fmt::Arguments`\r\n\r\n```rust\r\nimpl<'a> Serialize for fmt::Arguments<'a> {\r\n    fn serialize<S: Serializer>(&self, s: &mut S) -> Result<(), S::Error> {\r\n        struct Wrapper<'b, S: Serializer>(&'b mut S, Option<S::Error>);\r\n        impl<'b, S: Serializer> std::fmt::Write for Wrapper<'b, S> {\r\n            #[inline]\r\n            fn write_str(&mut self, s: &str) -> std::fmt::Result {\r\n                self.0.serialize_str(s).map_err(|err| {\r\n                    assert!(self.1.is_none());\r\n                    self.1 = Some(err);\r\n                    std::fmt::Error\r\n                })\r\n            }\r\n        }\r\n        let mut wrapper = Wrapper(s);\r\n        match wrapper.write_fmt(*self) {\r\n            Ok(()) => Ok(()),\r\n            Err(std::fmt::Error) => Ok(wrapper.1.unwrap()),\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nUnfortunately this means you get a bunch of strings in the output, not sure how useful that is. What's the expected output format? A sequence of strings?\nThanks for response. I don't think serializaing this value to series of `serialize_str` is going to work, but I might be wrong.\r\n\r\n> What's the expected output format? A sequence of strings?\r\n\r\nIn my use-case (`slog` and logging in general) `fmt::Arguments` is just a string that wasn't yet \"put together\" (lazy-evalution-sort-of).  When logging, it's useful to take `&fmt::Arguments` because it's fast, and only if a given logging statement/value reaches logging output make a string out of it/write it out to output. So from my perspective `fmt::Arguments` == lazily evaluated `String`.\r\n\r\nI'm toying with some API re-designs where publicly accepted types would be `&dyn serde::Serailize`, and I'm loosing `fmt::Arguments` support because `serde` doesn't support it. I need to be able to do things like `impl<T> Something for T where T : serde:Serialize`, but without `serde` having `impl Serialize for fmt::Arguments`, this can't be done due to coherency conflicts. Well, I could just do impl for each single type that serde supports, but it's not perfect.\r\n\r\nIn ideal case `Serializer` would get a `serialize_fmt` that would be much like *one* call to `serialize_str`, but serializer would be responsible for either writing it directly to its output, or to temporary string. I am not sure if this is possible, especially without breaking backward compat. Maybe adding a method like that with default impl that writes it out to `String` and calls `write_str` would be OK for non-`no_std`, and in `no_std` it could just return error/do nothing.\r\n\r\n", "created_at": "2018-06-27T06:31:00Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1302, "instance_id": "serde-rs__serde-1302", "issue_numbers": ["544"], "base_commit": "0a71fe329c8898a28d03ddfb746707cf958c21e8", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 342ca3bea..579ee594e 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -49,6 +49,16 @@ impl<'de> Deserialize<'de> for () {\n     }\n }\n \n+#[cfg(feature = \"unstable\")]\n+impl<'de> Deserialize<'de> for ! {\n+    fn deserialize<D>(_deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        Err(Error::custom(\"cannot deserialize `!`\"))\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n \n struct BoolVisitor;\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 104271568..ec1ed5e86 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -98,6 +98,7 @@\n //!    - PathBuf\n //!    - Range\\<T\\>\n //!    - num::NonZero*\n+//!    - `!` *(unstable)*\n //!  - **Net types**:\n //!    - IpAddr\n //!    - Ipv4Addr\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 56ed7c57f..fe097042b 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -176,6 +176,48 @@ where\n \n ////////////////////////////////////////////////////////////////////////////////\n \n+/// A deserializer that cannot be instantiated.\n+#[cfg(feature = \"unstable\")]\n+pub struct NeverDeserializer<E> {\n+    never: !,\n+    marker: PhantomData<E>,\n+}\n+\n+#[cfg(feature = \"unstable\")]\n+impl<'de, E> IntoDeserializer<'de, E> for !\n+where\n+    E: de::Error,\n+{\n+    type Deserializer = NeverDeserializer<E>;\n+\n+    fn into_deserializer(self) -> Self::Deserializer {\n+        self\n+    }\n+}\n+\n+#[cfg(feature = \"unstable\")]\n+impl<'de, E> de::Deserializer<'de> for NeverDeserializer<E>\n+where\n+    E: de::Error,\n+{\n+    type Error = E;\n+\n+    fn deserialize_any<V>(self, _visitor: V) -> Result<V::Value, Self::Error>\n+    where\n+        V: de::Visitor<'de>,\n+    {\n+        self.never\n+    }\n+\n+    forward_to_deserialize_any! {\n+        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n+        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n+        tuple_struct map struct enum identifier ignored_any\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+\n macro_rules! primitive_deserializer {\n     ($ty:ty, $doc:tt, $name:ident, $method:ident $($cast:tt)*) => {\n         #[doc = \"A deserializer holding\"]\ndiff --git a/serde/src/lib.rs b/serde/src/lib.rs\nindex 9c1535a31..148e1ac44 100644\n--- a/serde/src/lib.rs\n+++ b/serde/src/lib.rs\n@@ -89,7 +89,7 @@\n // discussion of these features please refer to this issue:\n //\n //    https://github.com/serde-rs/serde/issues/812\n-#![cfg_attr(feature = \"unstable\", feature(specialization))]\n+#![cfg_attr(feature = \"unstable\", feature(specialization, never_type))]\n #![cfg_attr(feature = \"alloc\", feature(alloc))]\n #![cfg_attr(feature = \"cargo-clippy\", deny(clippy, clippy_pedantic))]\n // Whitelisted clippy lints\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex be07d061c..3a4a4efee 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -247,6 +247,16 @@ impl Serialize for () {\n     }\n }\n \n+#[cfg(feature = \"unstable\")]\n+impl Serialize for ! {\n+    fn serialize<S>(&self, _serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        *self\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n \n macro_rules! tuple_impls {\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex c5c9c423c..d1d4bd7fb 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -93,6 +93,7 @@\n //!    - PathBuf\n //!    - Range\\<T\\>\n //!    - num::NonZero*\n+//!    - `!` *(unstable)*\n //!  - **Net types**:\n //!    - IpAddr\n //!    - Ipv4Addr\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 6c1f3d82f..b4ca2e198 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -7,6 +7,7 @@\n // except according to those terms.\n \n #![cfg_attr(feature = \"cargo-clippy\", allow(decimal_literal_representation))]\n+#![cfg_attr(feature = \"unstable\", feature(never_type))]\n \n #[macro_use]\n extern crate serde_derive;\n@@ -984,6 +985,16 @@ declare_tests! {\n     }\n }\n \n+#[cfg(feature = \"unstable\")]\n+declare_tests! {\n+    test_never_result {\n+        Ok::<u8, !>(0) => &[\n+            Token::NewtypeVariant { name: \"Result\", variant: \"Ok\" },\n+            Token::U8(0),\n+        ],\n+    }\n+}\n+\n #[cfg(unix)]\n #[test]\n fn test_osstring() {\n@@ -1051,6 +1062,20 @@ fn test_cstr_internal_null_end() {\n     );\n }\n \n+#[cfg(feature = \"unstable\")]\n+#[test]\n+fn test_never_type() {\n+    assert_de_tokens_error::<!>(&[], \"cannot deserialize `!`\");\n+\n+    assert_de_tokens_error::<Result<u8, !>>(\n+        &[Token::NewtypeVariant {\n+            name: \"Result\",\n+            variant: \"Err\",\n+        }],\n+        \"cannot deserialize `!`\",\n+    );\n+}\n+\n declare_error_tests! {\n     test_unknown_field<StructDenyUnknown> {\n         &[\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex 21c641a7a..0d4a35de1 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -6,6 +6,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![cfg_attr(feature = \"unstable\", feature(never_type))]\n+\n #[macro_use]\n extern crate serde_derive;\n \n@@ -548,6 +550,16 @@ declare_tests! {\n     }\n }\n \n+#[cfg(feature = \"unstable\")]\n+declare_tests! {\n+    test_never_result {\n+        Ok::<u8, !>(0) => &[\n+            Token::NewtypeVariant { name: \"Result\", variant: \"Ok\" },\n+            Token::U8(0),\n+        ],\n+    }\n+}\n+\n #[test]\n #[cfg(unix)]\n fn test_cannot_serialize_paths() {\n", "problem_statement": "Impl Serialize/Deserialize for !\n`Serialize` is straightforward. As for `Deserialize`, I guess it would just panic? This is useful for me when serializing and deserializing types like `Result<T, !>`.\n\n", "hints_text": "If we do `Deserialize for !` it should error, not panic.\n\nIs `Result<T, !>` the only instance where you need this? Would it make more sense to specialize De/Serialize for `Result<T, !>` instead of implementing them for `!`? `Result<T, !>` is equivalent to T so we might as well serialize it the same way.\n\nThe `Result<T, !>` was actually a simplified example. My actual use case involves an error type where one variant is generic: the actual type being deserialized is `Result<T, Error<!>>`. Basically, if a user implements a service that can never return an application error, the application error is `!`, and the framework error is `Error<!>`.\n\nThat being said, it could definitely make sense to specialize the `Result<T, !>` case as well!\n", "created_at": "2018-06-03T07:23:07Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1297, "instance_id": "serde-rs__serde-1297", "issue_numbers": ["1168"], "base_commit": "dbaf2893e32a72f9564757b0f95bf9f7869bd900", "patch": "diff --git a/serde_derive/src/lib.rs b/serde_derive/src/lib.rs\nindex 708f3bf46..65886bf1e 100644\n--- a/serde_derive/src/lib.rs\n+++ b/serde_derive/src/lib.rs\n@@ -53,6 +53,7 @@ extern crate proc_macro2;\n \n mod internals;\n \n+use std::str::FromStr;\n use proc_macro::TokenStream;\n use syn::DeriveInput;\n \n@@ -71,7 +72,7 @@ pub fn derive_serialize(input: TokenStream) -> TokenStream {\n     let input: DeriveInput = syn::parse(input).unwrap();\n     match ser::expand_derive_serialize(&input) {\n         Ok(expanded) => expanded.into(),\n-        Err(msg) => panic!(msg),\n+        Err(msg) => quote! {compile_error!(#msg);}.into(),\n     }\n }\n \n@@ -80,6 +81,6 @@ pub fn derive_deserialize(input: TokenStream) -> TokenStream {\n     let input: DeriveInput = syn::parse(input).unwrap();\n     match de::expand_derive_deserialize(&input) {\n         Ok(expanded) => expanded.into(),\n-        Err(msg) => panic!(msg),\n+        Err(msg) => quote! {compile_error!(#msg);}.into(),\n     }\n }\n", "test_patch": "diff --git a/test_suite/tests/compile-fail/borrow/bad_lifetimes.rs b/test_suite/tests/compile-fail/borrow/bad_lifetimes.rs\nindex a33968f37..f2ab9de07 100644\n--- a/test_suite/tests/compile-fail/borrow/bad_lifetimes.rs\n+++ b/test_suite/tests/compile-fail/borrow/bad_lifetimes.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: failed to parse borrowed lifetimes: \"zzz\"\n struct Test<'a> {\n-    #[serde(borrow = \"zzz\")] //~^^ HELP: failed to parse borrowed lifetimes: \"zzz\"\n+    #[serde(borrow = \"zzz\")]\n     s: &'a str,\n }\n \ndiff --git a/test_suite/tests/compile-fail/borrow/duplicate_lifetime.rs b/test_suite/tests/compile-fail/borrow/duplicate_lifetime.rs\nindex 482a84118..e575e0703 100644\n--- a/test_suite/tests/compile-fail/borrow/duplicate_lifetime.rs\n+++ b/test_suite/tests/compile-fail/borrow/duplicate_lifetime.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: duplicate borrowed lifetime `'a`\n struct Test<'a> {\n-    #[serde(borrow = \"'a + 'a\")] //~^^ HELP: duplicate borrowed lifetime `'a`\n+    #[serde(borrow = \"'a + 'a\")]\n     s: &'a str,\n }\n \ndiff --git a/test_suite/tests/compile-fail/borrow/duplicate_variant.rs b/test_suite/tests/compile-fail/borrow/duplicate_variant.rs\nindex 5cc3ad3b3..07e286679 100644\n--- a/test_suite/tests/compile-fail/borrow/duplicate_variant.rs\n+++ b/test_suite/tests/compile-fail/borrow/duplicate_variant.rs\n@@ -12,9 +12,9 @@ extern crate serde_derive;\n #[derive(Deserialize)]\n struct Str<'a>(&'a str);\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 15:10: 15:21: duplicate serde attribute `borrow`\n enum Test<'a> {\n-    #[serde(borrow)] //~^^ HELP: duplicate serde attribute `borrow`\n+    #[serde(borrow)]\n     S(#[serde(borrow)] Str<'a>)\n }\n \ndiff --git a/test_suite/tests/compile-fail/borrow/empty_lifetimes.rs b/test_suite/tests/compile-fail/borrow/empty_lifetimes.rs\nindex 0aec052ba..a18c51770 100644\n--- a/test_suite/tests/compile-fail/borrow/empty_lifetimes.rs\n+++ b/test_suite/tests/compile-fail/borrow/empty_lifetimes.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: at least one lifetime must be borrowed\n struct Test<'a> {\n-    #[serde(borrow = \"\")] //~^^ HELP: at least one lifetime must be borrowed\n+    #[serde(borrow = \"\")]\n     s: &'a str,\n }\n \ndiff --git a/test_suite/tests/compile-fail/borrow/no_lifetimes.rs b/test_suite/tests/compile-fail/borrow/no_lifetimes.rs\nindex ca0f0409b..ee9d5fcd9 100644\n--- a/test_suite/tests/compile-fail/borrow/no_lifetimes.rs\n+++ b/test_suite/tests/compile-fail/borrow/no_lifetimes.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: field `s` has no lifetimes to borrow\n struct Test {\n-    #[serde(borrow)] //~^^ HELP: field `s` has no lifetimes to borrow\n+    #[serde(borrow)]\n     s: String,\n }\n \ndiff --git a/test_suite/tests/compile-fail/borrow/struct_variant.rs b/test_suite/tests/compile-fail/borrow/struct_variant.rs\nindex 5bab07171..b4827dec4 100644\n--- a/test_suite/tests/compile-fail/borrow/struct_variant.rs\n+++ b/test_suite/tests/compile-fail/borrow/struct_variant.rs\n@@ -12,9 +12,9 @@ extern crate serde_derive;\n #[derive(Deserialize)]\n struct Str<'a>(&'a str);\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 15:10: 15:21: #[serde(borrow)] may only be used on newtype variants\n enum Test<'a> {\n-    #[serde(borrow)] //~^^ HELP: #[serde(borrow)] may only be used on newtype variants\n+    #[serde(borrow)]\n     S { s: Str<'a> }\n }\n \ndiff --git a/test_suite/tests/compile-fail/borrow/wrong_lifetime.rs b/test_suite/tests/compile-fail/borrow/wrong_lifetime.rs\nindex 707cd1183..a42e90c4a 100644\n--- a/test_suite/tests/compile-fail/borrow/wrong_lifetime.rs\n+++ b/test_suite/tests/compile-fail/borrow/wrong_lifetime.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: field `s` does not have lifetime 'b\n struct Test<'a> {\n-    #[serde(borrow = \"'b\")] //~^^ HELP: field `s` does not have lifetime 'b\n+    #[serde(borrow = \"'b\")]\n     s: &'a str,\n }\n \ndiff --git a/test_suite/tests/compile-fail/conflict/adjacent-tag.rs b/test_suite/tests/compile-fail/conflict/adjacent-tag.rs\nindex 419afa4c7..c8c6fea1d 100644\n--- a/test_suite/tests/compile-fail/conflict/adjacent-tag.rs\n+++ b/test_suite/tests/compile-fail/conflict/adjacent-tag.rs\n@@ -9,9 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: enum tags `conflict` for type and content conflict with each other\n #[serde(tag = \"conflict\", content = \"conflict\")]\n-//~^^ HELP: enum tags `conflict` for type and content conflict with each other\n enum E {\n     A,\n     B,\ndiff --git a/test_suite/tests/compile-fail/conflict/flatten-newtype-struct.rs b/test_suite/tests/compile-fail/conflict/flatten-newtype-struct.rs\nindex 07566f8c7..bd5089abb 100644\n--- a/test_suite/tests/compile-fail/conflict/flatten-newtype-struct.rs\n+++ b/test_suite/tests/compile-fail/conflict/flatten-newtype-struct.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: #[serde(flatten)] cannot be used on newtype structs\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: #[serde(flatten)] cannot be used on newtype structs\n struct Foo(#[serde(flatten)] HashMap<String, String>);\n \n fn main() {}\ndiff --git a/test_suite/tests/compile-fail/conflict/flatten-skip-deserializing.rs b/test_suite/tests/compile-fail/conflict/flatten-skip-deserializing.rs\nindex 3ef4d38f4..0b10ea53b 100644\n--- a/test_suite/tests/compile-fail/conflict/flatten-skip-deserializing.rs\n+++ b/test_suite/tests/compile-fail/conflict/flatten-skip-deserializing.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: #[serde(flatten] can not be combined with #[serde(skip_deserializing)]\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: #[serde(flatten] can not be combined with #[serde(skip_deserializing)]\n struct Foo {\n     #[serde(flatten, skip_deserializing)]\n     other: Other,\ndiff --git a/test_suite/tests/compile-fail/conflict/flatten-skip-serializing-if.rs b/test_suite/tests/compile-fail/conflict/flatten-skip-serializing-if.rs\nindex 6a5fa9d62..273902e4e 100644\n--- a/test_suite/tests/compile-fail/conflict/flatten-skip-serializing-if.rs\n+++ b/test_suite/tests/compile-fail/conflict/flatten-skip-serializing-if.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: #[serde(flatten] can not be combined with #[serde(skip_serializing_if = \"...\")]\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: #[serde(flatten] can not be combined with #[serde(skip_serializing_if = \"...\")]\n struct Foo {\n     #[serde(flatten, skip_serializing_if=\"Option::is_none\")]\n     other: Option<Other>,\ndiff --git a/test_suite/tests/compile-fail/conflict/flatten-skip-serializing.rs b/test_suite/tests/compile-fail/conflict/flatten-skip-serializing.rs\nindex 204f9bf31..ba6ae7a77 100644\n--- a/test_suite/tests/compile-fail/conflict/flatten-skip-serializing.rs\n+++ b/test_suite/tests/compile-fail/conflict/flatten-skip-serializing.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: #[serde(flatten] can not be combined with #[serde(skip_serializing)]\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: #[serde(flatten] can not be combined with #[serde(skip_serializing)]\n struct Foo {\n     #[serde(flatten, skip_serializing)]\n     other: Other,\ndiff --git a/test_suite/tests/compile-fail/conflict/flatten-tuple-struct.rs b/test_suite/tests/compile-fail/conflict/flatten-tuple-struct.rs\nindex 167bdbdac..311ea37d3 100644\n--- a/test_suite/tests/compile-fail/conflict/flatten-tuple-struct.rs\n+++ b/test_suite/tests/compile-fail/conflict/flatten-tuple-struct.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: #[serde(flatten)] cannot be used on tuple structs\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: #[serde(flatten)] cannot be used on tuple structs\n struct Foo(u32, #[serde(flatten)] HashMap<String, String>);\n \n fn main() {}\ndiff --git a/test_suite/tests/compile-fail/conflict/internal-tag.rs b/test_suite/tests/compile-fail/conflict/internal-tag.rs\nindex 777718bc7..75941922f 100644\n--- a/test_suite/tests/compile-fail/conflict/internal-tag.rs\n+++ b/test_suite/tests/compile-fail/conflict/internal-tag.rs\n@@ -9,9 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: variant field name `conflict` conflicts with internal tag\n #[serde(tag = \"conflict\")]\n-//~^^ HELP: variant field name `conflict` conflicts with internal tag\n enum E {\n     A {\n         #[serde(rename = \"conflict\")]\ndiff --git a/test_suite/tests/compile-fail/default-attribute/enum.rs b/test_suite/tests/compile-fail/default-attribute/enum.rs\nindex 7b0649bbc..989519a0e 100644\n--- a/test_suite/tests/compile-fail/default-attribute/enum.rs\n+++ b/test_suite/tests/compile-fail/default-attribute/enum.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n-#[serde(default)] //~^ HELP: #[serde(default)] can only be used on structs\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: #[serde(default)] can only be used on structs with named fields\n+#[serde(default)]\n enum E {\n     S { f: u8 },\n }\ndiff --git a/test_suite/tests/compile-fail/default-attribute/nameless_struct_fields.rs b/test_suite/tests/compile-fail/default-attribute/nameless_struct_fields.rs\nindex 83aec668a..cff48b5c6 100644\n--- a/test_suite/tests/compile-fail/default-attribute/nameless_struct_fields.rs\n+++ b/test_suite/tests/compile-fail/default-attribute/nameless_struct_fields.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n-#[serde(default)] //~^ HELP: #[serde(default)] can only be used on structs\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: #[serde(default)] can only be used on structs with named fields\n+#[serde(default)]\n struct T(u8, u8);\n \n fn main() { }\ndiff --git a/test_suite/tests/compile-fail/duplicate-attribute/rename-and-ser.rs b/test_suite/tests/compile-fail/duplicate-attribute/rename-and-ser.rs\nindex cc94685c8..ac34d5cbd 100644\n--- a/test_suite/tests/compile-fail/duplicate-attribute/rename-and-ser.rs\n+++ b/test_suite/tests/compile-fail/duplicate-attribute/rename-and-ser.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: unknown serde field attribute `serialize`\n struct S {\n-    #[serde(rename=\"x\", serialize=\"y\")] //~^^ HELP: unknown serde field attribute `serialize`\n+    #[serde(rename=\"x\", serialize=\"y\")]\n     x: (),\n }\n \ndiff --git a/test_suite/tests/compile-fail/duplicate-attribute/rename-rename-de.rs b/test_suite/tests/compile-fail/duplicate-attribute/rename-rename-de.rs\nindex 9b02357ab..039b46ca3 100644\n--- a/test_suite/tests/compile-fail/duplicate-attribute/rename-rename-de.rs\n+++ b/test_suite/tests/compile-fail/duplicate-attribute/rename-rename-de.rs\n@@ -9,10 +9,10 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: duplicate serde attribute `rename`\n struct S {\n     #[serde(rename=\"x\")]\n-    #[serde(rename(deserialize=\"y\"))] //~^^^ HELP: duplicate serde attribute `rename`\n+    #[serde(rename(deserialize=\"y\"))]\n     x: (),\n }\n \ndiff --git a/test_suite/tests/compile-fail/duplicate-attribute/rename-ser-rename-ser.rs b/test_suite/tests/compile-fail/duplicate-attribute/rename-ser-rename-ser.rs\nindex b84344138..08efbe5fd 100644\n--- a/test_suite/tests/compile-fail/duplicate-attribute/rename-ser-rename-ser.rs\n+++ b/test_suite/tests/compile-fail/duplicate-attribute/rename-ser-rename-ser.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: duplicate serde attribute `rename`\n struct S {\n-    #[serde(rename(serialize=\"x\"), rename(serialize=\"y\"))] //~^^ HELP: duplicate serde attribute `rename`\n+    #[serde(rename(serialize=\"x\"), rename(serialize=\"y\"))]\n     x: (),\n }\n \ndiff --git a/test_suite/tests/compile-fail/duplicate-attribute/rename-ser-rename.rs b/test_suite/tests/compile-fail/duplicate-attribute/rename-ser-rename.rs\nindex 8aee51312..9e4b32d73 100644\n--- a/test_suite/tests/compile-fail/duplicate-attribute/rename-ser-rename.rs\n+++ b/test_suite/tests/compile-fail/duplicate-attribute/rename-ser-rename.rs\n@@ -9,10 +9,10 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: duplicate serde attribute `rename`\n struct S {\n     #[serde(rename(serialize=\"x\"))]\n-    #[serde(rename=\"y\")] //~^^^ HELP: duplicate serde attribute `rename`\n+    #[serde(rename=\"y\")]\n     x: (),\n }\n \ndiff --git a/test_suite/tests/compile-fail/duplicate-attribute/rename-ser-ser.rs b/test_suite/tests/compile-fail/duplicate-attribute/rename-ser-ser.rs\nindex 25c50fa2a..57d595d17 100644\n--- a/test_suite/tests/compile-fail/duplicate-attribute/rename-ser-ser.rs\n+++ b/test_suite/tests/compile-fail/duplicate-attribute/rename-ser-ser.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: duplicate serde attribute `rename`\n struct S {\n-    #[serde(rename(serialize=\"x\", serialize=\"y\"))] //~^^ HELP: duplicate serde attribute `rename`\n+    #[serde(rename(serialize=\"x\", serialize=\"y\"))]\n     x: (),\n }\n \ndiff --git a/test_suite/tests/compile-fail/duplicate-attribute/two-rename-ser.rs b/test_suite/tests/compile-fail/duplicate-attribute/two-rename-ser.rs\nindex 96a657323..313877b39 100644\n--- a/test_suite/tests/compile-fail/duplicate-attribute/two-rename-ser.rs\n+++ b/test_suite/tests/compile-fail/duplicate-attribute/two-rename-ser.rs\n@@ -9,10 +9,10 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: duplicate serde attribute `rename`\n struct S {\n     #[serde(rename(serialize=\"x\"))]\n-    #[serde(rename(serialize=\"y\"))] //~^^^ HELP: duplicate serde attribute `rename`\n+    #[serde(rename(serialize=\"y\"))]\n     x: (),\n }\n \ndiff --git a/test_suite/tests/compile-fail/duplicate-attribute/with-and-serialize-with.rs b/test_suite/tests/compile-fail/duplicate-attribute/with-and-serialize-with.rs\nindex 9ca989954..a6fe4f649 100644\n--- a/test_suite/tests/compile-fail/duplicate-attribute/with-and-serialize-with.rs\n+++ b/test_suite/tests/compile-fail/duplicate-attribute/with-and-serialize-with.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: duplicate serde attribute `serialize_with`\n struct S {\n-    #[serde(with = \"w\", serialize_with = \"s\")] //~^^ HELP: duplicate serde attribute `serialize_with`\n+    #[serde(with = \"w\", serialize_with = \"s\")]\n     x: (),\n }\n \ndiff --git a/test_suite/tests/compile-fail/enum-representation/internal-tuple-variant.rs b/test_suite/tests/compile-fail/enum-representation/internal-tuple-variant.rs\nindex 6b02bfd04..45b4f3d5b 100644\n--- a/test_suite/tests/compile-fail/enum-representation/internal-tuple-variant.rs\n+++ b/test_suite/tests/compile-fail/enum-representation/internal-tuple-variant.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-#[serde(tag = \"type\")] //~^ HELP: #[serde(tag = \"...\")] cannot be used with tuple variants\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: #[serde(tag = \"...\")] cannot be used with tuple variants\n+#[serde(tag = \"type\")]\n enum E {\n     Tuple(u8, u8),\n }\ndiff --git a/test_suite/tests/compile-fail/enum-representation/internally-tagged-struct.rs b/test_suite/tests/compile-fail/enum-representation/internally-tagged-struct.rs\nindex 31615ff6a..f88a46830 100644\n--- a/test_suite/tests/compile-fail/enum-representation/internally-tagged-struct.rs\n+++ b/test_suite/tests/compile-fail/enum-representation/internally-tagged-struct.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-#[serde(tag = \"type\")] //~^ HELP: #[serde(tag = \"...\")] can only be used on enums\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: #[serde(tag = \"...\")] can only be used on enums\n+#[serde(tag = \"type\")]\n struct S;\n \n fn main() {}\ndiff --git a/test_suite/tests/compile-fail/enum-representation/untagged-and-internal.rs b/test_suite/tests/compile-fail/enum-representation/untagged-and-internal.rs\nindex 4edbf0043..c7d419923 100644\n--- a/test_suite/tests/compile-fail/enum-representation/untagged-and-internal.rs\n+++ b/test_suite/tests/compile-fail/enum-representation/untagged-and-internal.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: enum cannot be both untagged and internally tagged\n #[serde(untagged)]\n-#[serde(tag = \"type\")] //~^^ HELP: enum cannot be both untagged and internally tagged\n+#[serde(tag = \"type\")]\n enum E {\n     A(u8),\n     B(String),\ndiff --git a/test_suite/tests/compile-fail/enum-representation/untagged-struct.rs b/test_suite/tests/compile-fail/enum-representation/untagged-struct.rs\nindex 3546748e2..784d0691a 100644\n--- a/test_suite/tests/compile-fail/enum-representation/untagged-struct.rs\n+++ b/test_suite/tests/compile-fail/enum-representation/untagged-struct.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-#[serde(untagged)] //~^ HELP: #[serde(untagged)] can only be used on enums\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: #[serde(untagged)] can only be used on enums\n+#[serde(untagged)]\n struct S;\n \n fn main() {}\ndiff --git a/test_suite/tests/compile-fail/identifier/both.rs b/test_suite/tests/compile-fail/identifier/both.rs\nindex 13a8d9175..c7b75f84d 100644\n--- a/test_suite/tests/compile-fail/identifier/both.rs\n+++ b/test_suite/tests/compile-fail/identifier/both.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n-#[serde(field_identifier, variant_identifier)] //~^ HELP: `field_identifier` and `variant_identifier` cannot both be set\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: `field_identifier` and `variant_identifier` cannot both be set\n+#[serde(field_identifier, variant_identifier)]\n enum F {\n     A,\n     B,\ndiff --git a/test_suite/tests/compile-fail/identifier/field_struct.rs b/test_suite/tests/compile-fail/identifier/field_struct.rs\nindex 79b380d94..dddcf1706 100644\n--- a/test_suite/tests/compile-fail/identifier/field_struct.rs\n+++ b/test_suite/tests/compile-fail/identifier/field_struct.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: `field_identifier` can only be used on an enum\n #[serde(field_identifier)]\n-struct S; //~^^ HELP: `field_identifier` can only be used on an enum\n+struct S;\n \n fn main() {}\ndiff --git a/test_suite/tests/compile-fail/identifier/field_tuple.rs b/test_suite/tests/compile-fail/identifier/field_tuple.rs\nindex 7b26885d2..b55925a78 100644\n--- a/test_suite/tests/compile-fail/identifier/field_tuple.rs\n+++ b/test_suite/tests/compile-fail/identifier/field_tuple.rs\n@@ -9,11 +9,11 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: field_identifier may only contain unit variants\n #[serde(field_identifier)]\n enum F {\n     A,\n-    B(u8, u8), //~^^^^ HELP: field_identifier may only contain unit variants\n+    B(u8, u8),\n }\n \n fn main() {}\ndiff --git a/test_suite/tests/compile-fail/identifier/newtype_not_last.rs b/test_suite/tests/compile-fail/identifier/newtype_not_last.rs\nindex f601be3e8..71d8ac3e8 100644\n--- a/test_suite/tests/compile-fail/identifier/newtype_not_last.rs\n+++ b/test_suite/tests/compile-fail/identifier/newtype_not_last.rs\n@@ -9,11 +9,11 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: `Other` must be the last variant\n #[serde(field_identifier)]\n enum F {\n     A,\n-    Other(String), //~^^^^ HELP: `Other` must be the last variant\n+    Other(String),\n     B,\n }\n \ndiff --git a/test_suite/tests/compile-fail/identifier/not_identifier.rs b/test_suite/tests/compile-fail/identifier/not_identifier.rs\nindex 3dd6d65f9..3bc961750 100644\n--- a/test_suite/tests/compile-fail/identifier/not_identifier.rs\n+++ b/test_suite/tests/compile-fail/identifier/not_identifier.rs\n@@ -9,10 +9,10 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: #[serde(other)] may only be used inside a field_identifier\n enum F {\n     A,\n-    #[serde(other)] //~^^^ HELP: #[serde(other)] may only be used inside a field_identifier\n+    #[serde(other)]\n     B,\n }\n \ndiff --git a/test_suite/tests/compile-fail/identifier/not_unit.rs b/test_suite/tests/compile-fail/identifier/not_unit.rs\nindex dfc65df2a..e94a05921 100644\n--- a/test_suite/tests/compile-fail/identifier/not_unit.rs\n+++ b/test_suite/tests/compile-fail/identifier/not_unit.rs\n@@ -9,11 +9,11 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: #[serde(other)] must be on a unit variant\n #[serde(field_identifier)]\n enum F {\n     A,\n-    #[serde(other)] //~^^^^ HELP: #[serde(other)] must be on a unit variant\n+    #[serde(other)]\n     Other(u8, u8),\n }\n \ndiff --git a/test_suite/tests/compile-fail/identifier/other_not_last.rs b/test_suite/tests/compile-fail/identifier/other_not_last.rs\nindex 481f47645..31e2675bf 100644\n--- a/test_suite/tests/compile-fail/identifier/other_not_last.rs\n+++ b/test_suite/tests/compile-fail/identifier/other_not_last.rs\n@@ -9,11 +9,11 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: #[serde(other)] must be the last variant\n #[serde(field_identifier)]\n enum F {\n     A,\n-    #[serde(other)] //~^^^^ HELP: #[serde(other)] must be the last variant\n+    #[serde(other)]\n     Other,\n     B,\n }\ndiff --git a/test_suite/tests/compile-fail/identifier/serialize.rs b/test_suite/tests/compile-fail/identifier/serialize.rs\nindex 1c928b3f8..33e7eb759 100644\n--- a/test_suite/tests/compile-fail/identifier/serialize.rs\n+++ b/test_suite/tests/compile-fail/identifier/serialize.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-#[serde(field_identifier)] //~^ HELP: field identifiers cannot be serialized\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: field identifiers cannot be serialized\n+#[serde(field_identifier)]\n enum F {\n     A,\n     B,\ndiff --git a/test_suite/tests/compile-fail/identifier/variant_struct.rs b/test_suite/tests/compile-fail/identifier/variant_struct.rs\nindex aeb37f9a5..b14edebd7 100644\n--- a/test_suite/tests/compile-fail/identifier/variant_struct.rs\n+++ b/test_suite/tests/compile-fail/identifier/variant_struct.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: `variant_identifier` can only be used on an enum\n #[serde(variant_identifier)]\n-struct S; //~^^ HELP: `variant_identifier` can only be used on an enum\n+struct S;\n \n fn main() {}\ndiff --git a/test_suite/tests/compile-fail/identifier/variant_tuple.rs b/test_suite/tests/compile-fail/identifier/variant_tuple.rs\nindex 9ea2ee2ec..597df1720 100644\n--- a/test_suite/tests/compile-fail/identifier/variant_tuple.rs\n+++ b/test_suite/tests/compile-fail/identifier/variant_tuple.rs\n@@ -9,11 +9,11 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: variant_identifier may only contain unit variants\n #[serde(variant_identifier)]\n enum F {\n     A,\n-    B(u8, u8), //~^^^^ HELP: variant_identifier may only contain unit variants\n+    B(u8, u8),\n }\n \n fn main() {}\ndiff --git a/test_suite/tests/compile-fail/precondition/deserialize_de_lifetime.rs b/test_suite/tests/compile-fail/precondition/deserialize_de_lifetime.rs\nindex 4ab2f6a3b..19ecdbaad 100644\n--- a/test_suite/tests/compile-fail/precondition/deserialize_de_lifetime.rs\n+++ b/test_suite/tests/compile-fail/precondition/deserialize_de_lifetime.rs\n@@ -9,7 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: cannot deserialize when there is a lifetime parameter called 'de\n struct S<'de> {\n-    s: &'de str, //~^^ HELP: cannot deserialize when there is a lifetime parameter called 'de\n+    s: &'de str,\n }\ndiff --git a/test_suite/tests/compile-fail/precondition/deserialize_dst.rs b/test_suite/tests/compile-fail/precondition/deserialize_dst.rs\nindex 243b998d7..ed12a0012 100644\n--- a/test_suite/tests/compile-fail/precondition/deserialize_dst.rs\n+++ b/test_suite/tests/compile-fail/precondition/deserialize_dst.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: cannot deserialize a dynamically sized struct\n struct S {\n     string: String,\n-    slice: [u8], //~^^^ HELP: cannot deserialize a dynamically sized struct\n+    slice: [u8],\n }\ndiff --git a/test_suite/tests/compile-fail/remote/bad_getter.rs b/test_suite/tests/compile-fail/remote/bad_getter.rs\nindex 7b01c9cfa..3d62d4b4e 100644\n--- a/test_suite/tests/compile-fail/remote/bad_getter.rs\n+++ b/test_suite/tests/compile-fail/remote/bad_getter.rs\n@@ -15,10 +15,10 @@ mod remote {\n     }\n }\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 18:10: 18:19: failed to parse path: \"~~~\"\n #[serde(remote = \"remote::S\")]\n struct S {\n-    #[serde(getter = \"~~~\")] //~^^^ HELP: failed to parse path: \"~~~\"\n+    #[serde(getter = \"~~~\")]\n     a: u8,\n }\n \ndiff --git a/test_suite/tests/compile-fail/remote/bad_remote.rs b/test_suite/tests/compile-fail/remote/bad_remote.rs\nindex a81627dbe..6fca32f85 100644\n--- a/test_suite/tests/compile-fail/remote/bad_remote.rs\n+++ b/test_suite/tests/compile-fail/remote/bad_remote.rs\n@@ -15,8 +15,8 @@ mod remote {\n     }\n }\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-#[serde(remote = \"~~~\")] //~^ HELP: failed to parse path: \"~~~\"\n+#[derive(Serialize)] //~ ERROR: 18:10: 18:19: failed to parse path: \"~~~\"\n+#[serde(remote = \"~~~\")]\n struct S {\n     a: u8,\n }\ndiff --git a/test_suite/tests/compile-fail/remote/enum_getter.rs b/test_suite/tests/compile-fail/remote/enum_getter.rs\nindex 016cfc031..603badce3 100644\n--- a/test_suite/tests/compile-fail/remote/enum_getter.rs\n+++ b/test_suite/tests/compile-fail/remote/enum_getter.rs\n@@ -15,11 +15,11 @@ mod remote {\n     }\n }\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 18:10: 18:19: #[serde(getter = \"...\")] is not allowed in an enum\n #[serde(remote = \"remote::E\")]\n pub enum E {\n     A {\n-        #[serde(getter = \"get_a\")] //~^^^^ HELP: #[serde(getter = \"...\")] is not allowed in an enum\n+        #[serde(getter = \"get_a\")]\n         a: u8,\n     }\n }\ndiff --git a/test_suite/tests/compile-fail/remote/nonremote_getter.rs b/test_suite/tests/compile-fail/remote/nonremote_getter.rs\nindex ce7539bef..fbd26ad6a 100644\n--- a/test_suite/tests/compile-fail/remote/nonremote_getter.rs\n+++ b/test_suite/tests/compile-fail/remote/nonremote_getter.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: #[serde(getter = \"...\")] can only be used in structs that have #[serde(remote = \"...\")]\n struct S {\n-    #[serde(getter = \"S::get\")] //~^^ HELP: #[serde(getter = \"...\")] can only be used in structs that have #[serde(remote = \"...\")]\n+    #[serde(getter = \"S::get\")]\n     a: u8,\n }\n \ndiff --git a/test_suite/tests/compile-fail/transparent/at_most_one.rs b/test_suite/tests/compile-fail/transparent/at_most_one.rs\nindex d5b7dae89..bade8ce8f 100644\n--- a/test_suite/tests/compile-fail/transparent/at_most_one.rs\n+++ b/test_suite/tests/compile-fail/transparent/at_most_one.rs\n@@ -9,10 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: #[serde(transparent)] requires struct to have at most one transparent field\n #[serde(transparent)]\n struct S {\n-    //~^^^ HELP: #[serde(transparent)] requires struct to have at most one transparent field\n     a: u8,\n     b: u8,\n }\ndiff --git a/test_suite/tests/compile-fail/transparent/de_at_least_one.rs b/test_suite/tests/compile-fail/transparent/de_at_least_one.rs\nindex a1abe4746..3de299249 100644\n--- a/test_suite/tests/compile-fail/transparent/de_at_least_one.rs\n+++ b/test_suite/tests/compile-fail/transparent/de_at_least_one.rs\n@@ -9,10 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: #[serde(transparent)] requires at least one field that is neither skipped nor has a default\n #[serde(transparent)]\n struct S {\n-    //~^^^ HELP: #[serde(transparent)] requires at least one field that is neither skipped nor has a default\n     #[serde(skip)]\n     a: u8,\n     #[serde(default)]\ndiff --git a/test_suite/tests/compile-fail/transparent/ser_at_least_one.rs b/test_suite/tests/compile-fail/transparent/ser_at_least_one.rs\nindex 19dd59c17..b13b1ee43 100644\n--- a/test_suite/tests/compile-fail/transparent/ser_at_least_one.rs\n+++ b/test_suite/tests/compile-fail/transparent/ser_at_least_one.rs\n@@ -9,10 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: #[serde(transparent)] requires at least one field that is not skipped\n #[serde(transparent)]\n struct S {\n-    //~^^^ HELP: #[serde(transparent)] requires at least one field that is not skipped\n     #[serde(skip)]\n     a: u8,\n }\ndiff --git a/test_suite/tests/compile-fail/type-attribute/from.rs b/test_suite/tests/compile-fail/type-attribute/from.rs\nindex 72e0f1de3..550d0973b 100644\n--- a/test_suite/tests/compile-fail/type-attribute/from.rs\n+++ b/test_suite/tests/compile-fail/type-attribute/from.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n-#[serde(from = \"Option<T\")] //~^ HELP: failed to parse type: from = \"Option<T\"\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: failed to parse type: from = \"Option<T\"\n+#[serde(from = \"Option<T\")]\n enum TestOne {\n     Testing,\n     One,\ndiff --git a/test_suite/tests/compile-fail/type-attribute/into.rs b/test_suite/tests/compile-fail/type-attribute/into.rs\nindex 8f6de4d42..f1b2ae577 100644\n--- a/test_suite/tests/compile-fail/type-attribute/into.rs\n+++ b/test_suite/tests/compile-fail/type-attribute/into.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-#[serde(into = \"Option<T\")] //~^ HELP: failed to parse type: into = \"Option<T\"\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: failed to parse type: into = \"Option<T\"\n+#[serde(into = \"Option<T\")]\n enum TestOne {\n     Testing,\n     One,\ndiff --git a/test_suite/tests/compile-fail/unknown-attribute/container.rs b/test_suite/tests/compile-fail/unknown-attribute/container.rs\nindex c60c99c1f..dfce43aab 100644\n--- a/test_suite/tests/compile-fail/unknown-attribute/container.rs\n+++ b/test_suite/tests/compile-fail/unknown-attribute/container.rs\n@@ -9,8 +9,8 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-#[serde(abc=\"xyz\")] //~^ HELP: unknown serde container attribute `abc`\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: unknown serde container attribute `abc`\n+#[serde(abc=\"xyz\")]\n struct A {\n     x: u32,\n }\ndiff --git a/test_suite/tests/compile-fail/unknown-attribute/field.rs b/test_suite/tests/compile-fail/unknown-attribute/field.rs\nindex 66c3a0a80..e4e96cbc8 100644\n--- a/test_suite/tests/compile-fail/unknown-attribute/field.rs\n+++ b/test_suite/tests/compile-fail/unknown-attribute/field.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: unknown serde field attribute `abc`\n struct C {\n-    #[serde(abc=\"xyz\")] //~^^ HELP: unknown serde field attribute `abc`\n+    #[serde(abc=\"xyz\")]\n     x: u32,\n }\n \ndiff --git a/test_suite/tests/compile-fail/unknown-attribute/variant.rs b/test_suite/tests/compile-fail/unknown-attribute/variant.rs\nindex 0cfac6275..9d179b205 100644\n--- a/test_suite/tests/compile-fail/unknown-attribute/variant.rs\n+++ b/test_suite/tests/compile-fail/unknown-attribute/variant.rs\n@@ -9,9 +9,9 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: unknown serde variant attribute `abc`\n enum E {\n-    #[serde(abc=\"xyz\")] //~^^ HELP: unknown serde variant attribute `abc`\n+    #[serde(abc=\"xyz\")]\n     V,\n }\n \ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_de_newtype_field.rs b/test_suite/tests/compile-fail/with-variant/skip_de_newtype_field.rs\nindex b198f9af3..f783ca8bc 100644\n--- a/test_suite/tests/compile-fail/with-variant/skip_de_newtype_field.rs\n+++ b/test_suite/tests/compile-fail/with-variant/skip_de_newtype_field.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: variant `Newtype` cannot have both #[serde(deserialize_with)] and a field 0 marked with #[serde(skip_deserializing)]\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: variant `Newtype` cannot have both #[serde(deserialize_with)] and a field 0 marked with #[serde(skip_deserializing)]\n enum Enum {\n     #[serde(deserialize_with = \"deserialize_some_newtype_variant\")]\n     Newtype(#[serde(skip_deserializing)] String),\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_de_struct_field.rs b/test_suite/tests/compile-fail/with-variant/skip_de_struct_field.rs\nindex 248389c94..eb96456f4 100644\n--- a/test_suite/tests/compile-fail/with-variant/skip_de_struct_field.rs\n+++ b/test_suite/tests/compile-fail/with-variant/skip_de_struct_field.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: variant `Struct` cannot have both #[serde(deserialize_with)] and a field `f1` marked with #[serde(skip_deserializing)]\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: variant `Struct` cannot have both #[serde(deserialize_with)] and a field `f1` marked with #[serde(skip_deserializing)]\n enum Enum {\n     #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n     Struct {\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_de_tuple_field.rs b/test_suite/tests/compile-fail/with-variant/skip_de_tuple_field.rs\nindex 7bdeddc45..5b5408d58 100644\n--- a/test_suite/tests/compile-fail/with-variant/skip_de_tuple_field.rs\n+++ b/test_suite/tests/compile-fail/with-variant/skip_de_tuple_field.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: variant `Tuple` cannot have both #[serde(deserialize_with)] and a field 0 marked with #[serde(skip_deserializing)]\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: variant `Tuple` cannot have both #[serde(deserialize_with)] and a field 0 marked with #[serde(skip_deserializing)]\n enum Enum {\n     #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n     Tuple(#[serde(skip_deserializing)] String, u8),\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_de_whole_variant.rs b/test_suite/tests/compile-fail/with-variant/skip_de_whole_variant.rs\nindex 2bf2b016c..d70b36a86 100644\n--- a/test_suite/tests/compile-fail/with-variant/skip_de_whole_variant.rs\n+++ b/test_suite/tests/compile-fail/with-variant/skip_de_whole_variant.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: variant `Unit` cannot have both #[serde(deserialize_with)] and #[serde(skip_deserializing)]\n+#[derive(Deserialize)] //~ ERROR: 12:10: 12:21: variant `Unit` cannot have both #[serde(deserialize_with)] and #[serde(skip_deserializing)]\n enum Enum {\n     #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n     #[serde(skip_deserializing)]\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field.rs\nindex 58e4b1b10..fbebcc842 100644\n--- a/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field.rs\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: variant `Newtype` cannot have both #[serde(serialize_with)] and a field 0 marked with #[serde(skip_serializing)]\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: variant `Newtype` cannot have both #[serde(serialize_with)] and a field 0 marked with #[serde(skip_serializing)]\n enum Enum {\n     #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n     Newtype(#[serde(skip_serializing)] String),\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field_if.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field_if.rs\nindex 61c3112f7..d46d2ccda 100644\n--- a/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field_if.rs\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field_if.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: variant `Newtype` cannot have both #[serde(serialize_with)] and a field 0 marked with #[serde(skip_serializing_if)]\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: variant `Newtype` cannot have both #[serde(serialize_with)] and a field 0 marked with #[serde(skip_serializing_if)]\n enum Enum {\n     #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n     Newtype(#[serde(skip_serializing_if = \"always\")] String),\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field.rs\nindex 0149553cf..29997d052 100644\n--- a/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field.rs\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: variant `Struct` cannot have both #[serde(serialize_with)] and a field `f1` marked with #[serde(skip_serializing)]\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: variant `Struct` cannot have both #[serde(serialize_with)] and a field `f1` marked with #[serde(skip_serializing)]\n enum Enum {\n     #[serde(serialize_with = \"serialize_some_other_variant\")]\n     Struct {\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field_if.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field_if.rs\nindex 5f94ff83d..6a2a58bce 100644\n--- a/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field_if.rs\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field_if.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: variant `Struct` cannot have both #[serde(serialize_with)] and a field `f1` marked with #[serde(skip_serializing_if)]\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: variant `Struct` cannot have both #[serde(serialize_with)] and a field `f1` marked with #[serde(skip_serializing_if)]\n enum Enum {\n     #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n     Struct {\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field.rs\nindex 51e2ce87e..eaf318ac0 100644\n--- a/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field.rs\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: variant `Tuple` cannot have both #[serde(serialize_with)] and a field 0 marked with #[serde(skip_serializing)]\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: variant `Tuple` cannot have both #[serde(serialize_with)] and a field 0 marked with #[serde(skip_serializing)]\n enum Enum {\n     #[serde(serialize_with = \"serialize_some_other_variant\")]\n     Tuple(#[serde(skip_serializing)] String, u8),\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field_if.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field_if.rs\nindex efd2e11e7..cae191a58 100644\n--- a/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field_if.rs\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field_if.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: variant `Tuple` cannot have both #[serde(serialize_with)] and a field 0 marked with #[serde(skip_serializing_if)]\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: variant `Tuple` cannot have both #[serde(serialize_with)] and a field 0 marked with #[serde(skip_serializing_if)]\n enum Enum {\n     #[serde(serialize_with = \"serialize_some_other_variant\")]\n     Tuple(#[serde(skip_serializing_if = \"always\")] String, u8),\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_whole_variant.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_whole_variant.rs\nindex 0446770e8..55c5d27dc 100644\n--- a/test_suite/tests/compile-fail/with-variant/skip_ser_whole_variant.rs\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_whole_variant.rs\n@@ -9,8 +9,7 @@\n #[macro_use]\n extern crate serde_derive;\n \n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: variant `Unit` cannot have both #[serde(serialize_with)] and #[serde(skip_serializing)]\n+#[derive(Serialize)] //~ ERROR: 12:10: 12:19: variant `Unit` cannot have both #[serde(serialize_with)] and #[serde(skip_serializing)]\n enum Enum {\n     #[serde(serialize_with = \"serialize_some_unit_variant\")]\n     #[serde(skip_serializing)]\n", "problem_statement": "Use compile_error macro to report invalid attribute errors\nCurrently we use [`Ctxt`](https://github.com/serde-rs/serde/blob/v1.0.27/serde_derive_internals/src/ctxt.rs) in `serde_derive_internals` to batch up errors detected during the attribute parsing step of `serde_derive`, then panic with the resulting message in [`derive_serialize` and `derive_deserialize`](https://github.com/serde-rs/serde/blob/v1.0.27/serde_derive/src/lib.rs).\r\n\r\n```rust\r\n#[derive(Serialize)]\r\nstruct S {\r\n    #[serde(typo, with = 1)]\r\n    field: String,\r\n}\r\n```\r\n\r\n```\r\nerror: proc-macro derive panicked\r\n --> src/main.rs:4:10\r\n  |\r\n4 | #[derive(Serialize)]\r\n  |          ^^^^^^^^^\r\n  |\r\n  = help: message: 2 errors:\r\n              # unknown serde field attribute `typo`\r\n              # expected serde with attribute to be a string: `with = \"...\"`\r\n```\r\n\r\nIt would be better to use [`std::compile_error!`](https://doc.rust-lang.org/std/macro.compile_error.html) instead of a panic. The resulting user-visible error message can be rendered more nicely.\r\n\r\nThe `compile_error!` macro was stabilized in Rust 1.20 and we currently support older Rust versions than that, but it would not be a breaking change to begin using `compile_error!` and I am comfortable doing so. In the worst case somebody's code failed to compile before the change and then fails to compile a slightly different way after the change.\n", "hints_text": "", "created_at": "2018-06-01T03:19:31Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1288, "instance_id": "serde-rs__serde-1288", "issue_numbers": ["1287"], "base_commit": "cd0b2d312c00dd9763aa62062180e3fba2a74b9d", "patch": "diff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex d08bae3b2..56ed7c57f 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -44,6 +44,22 @@ use ser;\n \n ////////////////////////////////////////////////////////////////////////////////\n \n+// For structs that contain a PhantomData. We do not want the trait\n+// bound `E: Clone` inferred by derive(Clone).\n+macro_rules! impl_copy_clone {\n+    ($ty:ident $(<$lifetime:tt>)*) => {\n+        impl<$($lifetime,)* E> Copy for $ty<$($lifetime,)* E> {}\n+\n+        impl<$($lifetime,)* E> Clone for $ty<$($lifetime,)* E> {\n+            fn clone(&self) -> Self {\n+                *self\n+            }\n+        }\n+    };\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// A minimal representation of all possible errors that can occur using the\n /// `IntoDeserializer` trait.\n #[derive(Clone, Debug, PartialEq)]\n@@ -124,11 +140,13 @@ where\n }\n \n /// A deserializer holding a `()`.\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct UnitDeserializer<E> {\n     marker: PhantomData<E>,\n }\n \n+impl_copy_clone!(UnitDeserializer);\n+\n impl<'de, E> de::Deserializer<'de> for UnitDeserializer<E>\n where\n     E: de::Error,\n@@ -162,12 +180,14 @@ macro_rules! primitive_deserializer {\n     ($ty:ty, $doc:tt, $name:ident, $method:ident $($cast:tt)*) => {\n         #[doc = \"A deserializer holding\"]\n         #[doc = $doc]\n-        #[derive(Clone, Debug)]\n+        #[derive(Debug)]\n         pub struct $name<E> {\n             value: $ty,\n             marker: PhantomData<E>\n         }\n \n+        impl_copy_clone!($name);\n+\n         impl<'de, E> IntoDeserializer<'de, E> for $ty\n         where\n             E: de::Error,\n@@ -224,12 +244,14 @@ serde_if_integer128! {\n }\n \n /// A deserializer holding a `u32`.\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct U32Deserializer<E> {\n     value: u32,\n     marker: PhantomData<E>,\n }\n \n+impl_copy_clone!(U32Deserializer);\n+\n impl<'de, E> IntoDeserializer<'de, E> for u32\n where\n     E: de::Error,\n@@ -296,12 +318,14 @@ where\n ////////////////////////////////////////////////////////////////////////////////\n \n /// A deserializer holding a `&str`.\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct StrDeserializer<'a, E> {\n     value: &'a str,\n     marker: PhantomData<E>,\n }\n \n+impl_copy_clone!(StrDeserializer<'de>);\n+\n impl<'de, 'a, E> IntoDeserializer<'de, E> for &'a str\n where\n     E: de::Error,\n@@ -369,12 +393,14 @@ where\n \n /// A deserializer holding a `&str` with a lifetime tied to another\n /// deserializer.\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct BorrowedStrDeserializer<'de, E> {\n     value: &'de str,\n     marker: PhantomData<E>,\n }\n \n+impl_copy_clone!(BorrowedStrDeserializer<'de>);\n+\n impl<'de, E> BorrowedStrDeserializer<'de, E> {\n     /// Create a new borrowed deserializer from the given string.\n     pub fn new(value: &'de str) -> BorrowedStrDeserializer<'de, E> {\n@@ -438,12 +464,22 @@ where\n \n /// A deserializer holding a `String`.\n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct StringDeserializer<E> {\n     value: String,\n     marker: PhantomData<E>,\n }\n \n+#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n+impl<E> Clone for StringDeserializer<E> {\n+    fn clone(&self) -> Self {\n+        StringDeserializer {\n+            value: self.value.clone(),\n+            marker: PhantomData,\n+        }\n+    }\n+}\n+\n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n impl<'de, E> IntoDeserializer<'de, E> for String\n where\n@@ -514,12 +550,22 @@ where\n \n /// A deserializer holding a `Cow<str>`.\n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct CowStrDeserializer<'a, E> {\n     value: Cow<'a, str>,\n     marker: PhantomData<E>,\n }\n \n+#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n+impl<'a, E> Clone for CowStrDeserializer<'a, E> {\n+    fn clone(&self) -> Self {\n+        CowStrDeserializer {\n+            value: self.value.clone(),\n+            marker: PhantomData,\n+        }\n+    }\n+}\n+\n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n impl<'de, 'a, E> IntoDeserializer<'de, E> for Cow<'a, str>\n where\n@@ -593,12 +639,14 @@ where\n \n /// A deserializer holding a `&[u8]` with a lifetime tied to another\n /// deserializer.\n-#[derive(Clone, Debug)]\n+#[derive(Debug)]\n pub struct BorrowedBytesDeserializer<'de, E> {\n     value: &'de [u8],\n     marker: PhantomData<E>,\n }\n \n+impl_copy_clone!(BorrowedBytesDeserializer<'de>);\n+\n impl<'de, E> BorrowedBytesDeserializer<'de, E> {\n     /// Create a new borrowed deserializer from the given byte slice.\n     pub fn new(value: &'de [u8]) -> BorrowedBytesDeserializer<'de, E> {\n", "test_patch": "diff --git a/test_suite/tests/test_value.rs b/test_suite/tests/test_value.rs\nindex 80554663c..d2d9e67c0 100644\n--- a/test_suite/tests/test_value.rs\n+++ b/test_suite/tests/test_value.rs\n@@ -32,14 +32,14 @@ fn test_integer128() {\n     let de_i128 = IntoDeserializer::<value::Error>::into_deserializer(1i128);\n \n     // u128 to u128\n-    assert_eq!(1u128, u128::deserialize(de_u128.clone()).unwrap());\n+    assert_eq!(1u128, u128::deserialize(de_u128).unwrap());\n \n     // u128 to i128\n-    assert_eq!(1i128, i128::deserialize(de_u128.clone()).unwrap());\n+    assert_eq!(1i128, i128::deserialize(de_u128).unwrap());\n \n     // i128 to u128\n-    assert_eq!(1u128, u128::deserialize(de_i128.clone()).unwrap());\n+    assert_eq!(1u128, u128::deserialize(de_i128).unwrap());\n \n     // i128 to i128\n-    assert_eq!(1i128, i128::deserialize(de_i128.clone()).unwrap());\n+    assert_eq!(1i128, i128::deserialize(de_i128).unwrap());\n }\n", "problem_statement": "Implement Copy for the primitive value deserializers\nhttps://docs.serde.rs/serde/de/value/index.html\r\n\r\nThe primitive deserializers (I8Deserializer, I16Deserializer, etc) only wrap only wrap a value of their primitive type and a phantom data for the error type, so it should be fine to allow copying.\n", "hints_text": "", "created_at": "2018-05-26T22:49:24Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1286, "instance_id": "serde-rs__serde-1286", "issue_numbers": ["1280"], "base_commit": "7407d71417bc7a72c0a61f2c2f595db517457de9", "patch": "diff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 101531b3d..d08bae3b2 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -218,6 +218,11 @@ primitive_deserializer!(f32, \"an `f32`.\", F32Deserializer, visit_f32);\n primitive_deserializer!(f64, \"an `f64`.\", F64Deserializer, visit_f64);\n primitive_deserializer!(char, \"a `char`.\", CharDeserializer, visit_char);\n \n+serde_if_integer128! {\n+    primitive_deserializer!(i128, \"an `i128`.\", I128Deserializer, visit_i128);\n+    primitive_deserializer!(u128, \"a `u128`.\", U128Deserializer, visit_u128);\n+}\n+\n /// A deserializer holding a `u32`.\n #[derive(Clone, Debug)]\n pub struct U32Deserializer<E> {\n", "test_patch": "diff --git a/test_suite/tests/test_value.rs b/test_suite/tests/test_value.rs\nindex acd3ddd6c..80554663c 100644\n--- a/test_suite/tests/test_value.rs\n+++ b/test_suite/tests/test_value.rs\n@@ -25,3 +25,21 @@ fn test_u32_to_enum() {\n     let e: E = E::deserialize(deserializer).unwrap();\n     assert_eq!(E::B, e);\n }\n+\n+#[test]\n+fn test_integer128() {\n+    let de_u128 = IntoDeserializer::<value::Error>::into_deserializer(1u128);\n+    let de_i128 = IntoDeserializer::<value::Error>::into_deserializer(1i128);\n+\n+    // u128 to u128\n+    assert_eq!(1u128, u128::deserialize(de_u128.clone()).unwrap());\n+\n+    // u128 to i128\n+    assert_eq!(1i128, i128::deserialize(de_u128.clone()).unwrap());\n+\n+    // i128 to u128\n+    assert_eq!(1u128, u128::deserialize(de_i128.clone()).unwrap());\n+\n+    // i128 to i128\n+    assert_eq!(1i128, i128::deserialize(de_i128.clone()).unwrap());\n+}\n", "problem_statement": "Implement IntoDeserializer for i128 and u128\n\n", "hints_text": "", "created_at": "2018-05-26T22:22:38Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1270, "instance_id": "serde-rs__serde-1270", "issue_numbers": ["1054"], "base_commit": "320897679b3bff07d2e54aa96525422237b6e832", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 875c941a7..ad105398d 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -15,7 +15,7 @@ use syn::{self, Ident, Index, Member};\n use bound;\n use fragment::{Expr, Fragment, Match, Stmts};\n use internals::ast::{Container, Data, Field, Style, Variant};\n-use internals::{attr, Ctxt};\n+use internals::{attr, Ctxt, Derive};\n use pretend;\n use try;\n \n@@ -23,7 +23,7 @@ use std::collections::BTreeSet;\n \n pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<TokenStream, String> {\n     let ctxt = Ctxt::new();\n-    let cont = Container::from_ast(&ctxt, input);\n+    let cont = Container::from_ast(&ctxt, input, Derive::Deserialize);\n     precondition(&ctxt, &cont);\n     try!(ctxt.check());\n \n@@ -269,7 +269,9 @@ fn borrowed_lifetimes(cont: &Container) -> BorrowedLifetimes {\n }\n \n fn deserialize_body(cont: &Container, params: &Parameters) -> Fragment {\n-    if let Some(type_from) = cont.attrs.type_from() {\n+    if cont.attrs.transparent() {\n+        deserialize_transparent(cont, params)\n+    } else if let Some(type_from) = cont.attrs.type_from() {\n         deserialize_from(type_from)\n     } else if let attr::Identifier::No = cont.attrs.identifier() {\n         match cont.data {\n@@ -298,7 +300,9 @@ fn deserialize_in_place_body(cont: &Container, params: &Parameters) -> Option<St\n     // deserialize_in_place for remote derives.\n     assert!(!params.has_getter);\n \n-    if cont.attrs.type_from().is_some() || cont.attrs.identifier().is_some()\n+    if cont.attrs.transparent()\n+        || cont.attrs.type_from().is_some()\n+        || cont.attrs.identifier().is_some()\n         || cont\n             .data\n             .all_fields()\n@@ -344,6 +348,41 @@ fn deserialize_in_place_body(_cont: &Container, _params: &Parameters) -> Option<\n     None\n }\n \n+fn deserialize_transparent(cont: &Container, params: &Parameters) -> Fragment {\n+    let fields = match cont.data {\n+        Data::Struct(_, ref fields) => fields,\n+        Data::Enum(_) => unreachable!(),\n+    };\n+\n+    let this = &params.this;\n+    let transparent_field = fields.iter().find(|f| f.attrs.transparent()).unwrap();\n+\n+    let path = match transparent_field.attrs.deserialize_with() {\n+        Some(path) => quote!(#path),\n+        None => quote!(_serde::Deserialize::deserialize),\n+    };\n+\n+    let assign = fields.iter().map(|field| {\n+        let member = &field.member;\n+        if field as *const Field == transparent_field as *const Field {\n+            quote!(#member: __transparent)\n+        } else {\n+            let value = match *field.attrs.default() {\n+                attr::Default::Default => quote!(_serde::export::Default::default()),\n+                attr::Default::Path(ref path) => quote!(#path()),\n+                attr::Default::None => quote!(_serde::export::PhantomData),\n+            };\n+            quote!(#member: #value)\n+        }\n+    });\n+\n+    quote_block! {\n+        _serde::export::Result::map(\n+            #path(__deserializer),\n+            |__transparent| #this { #(#assign),* })\n+    }\n+}\n+\n fn deserialize_from(type_from: &syn::Type) -> Fragment {\n     quote_block! {\n         _serde::export::Result::map(\ndiff --git a/serde_derive/src/internals/ast.rs b/serde_derive/src/internals/ast.rs\nindex 093910d77..ce1d3197f 100644\n--- a/serde_derive/src/internals/ast.rs\n+++ b/serde_derive/src/internals/ast.rs\n@@ -8,7 +8,7 @@\n \n use internals::attr;\n use internals::check;\n-use internals::Ctxt;\n+use internals::{Ctxt, Derive};\n use syn;\n use syn::punctuated::Punctuated;\n \n@@ -47,7 +47,7 @@ pub enum Style {\n }\n \n impl<'a> Container<'a> {\n-    pub fn from_ast(cx: &Ctxt, item: &'a syn::DeriveInput) -> Container<'a> {\n+    pub fn from_ast(cx: &Ctxt, item: &'a syn::DeriveInput, derive: Derive) -> Container<'a> {\n         let mut attrs = attr::Container::from_ast(cx, item);\n \n         let mut data = match item.data {\n@@ -86,13 +86,13 @@ impl<'a> Container<'a> {\n             attrs.mark_has_flatten();\n         }\n \n-        let item = Container {\n+        let mut item = Container {\n             ident: item.ident.clone(),\n             attrs: attrs,\n             data: data,\n             generics: &item.generics,\n         };\n-        check::check(cx, &item);\n+        check::check(cx, &mut item, derive);\n         item\n     }\n }\ndiff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex 43c689a0a..abfb005b5 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -105,6 +105,7 @@ impl Name {\n /// Represents container (e.g. struct) attribute information\n pub struct Container {\n     name: Name,\n+    transparent: bool,\n     deny_unknown_fields: bool,\n     default: Default,\n     rename_all: RenameRule,\n@@ -181,6 +182,7 @@ impl Container {\n     pub fn from_ast(cx: &Ctxt, item: &syn::DeriveInput) -> Self {\n         let mut ser_name = Attr::none(cx, \"rename\");\n         let mut de_name = Attr::none(cx, \"rename\");\n+        let mut transparent = BoolAttr::none(cx, \"transparent\");\n         let mut deny_unknown_fields = BoolAttr::none(cx, \"deny_unknown_fields\");\n         let mut default = Attr::none(cx, \"default\");\n         let mut rename_all = Attr::none(cx, \"rename_all\");\n@@ -228,6 +230,11 @@ impl Container {\n                         }\n                     }\n \n+                    // Parse `#[serde(transparent)]`\n+                    Meta(Word(ref word)) if word == \"transparent\" => {\n+                        transparent.set_true();\n+                    }\n+\n                     // Parse `#[serde(deny_unknown_fields)]`\n                     Meta(Word(ref word)) if word == \"deny_unknown_fields\" => {\n                         deny_unknown_fields.set_true();\n@@ -376,6 +383,7 @@ impl Container {\n                 serialize: ser_name.get().unwrap_or_else(|| item.ident.to_string()),\n                 deserialize: de_name.get().unwrap_or_else(|| item.ident.to_string()),\n             },\n+            transparent: transparent.get(),\n             deny_unknown_fields: deny_unknown_fields.get(),\n             default: default.get().unwrap_or(Default::None),\n             rename_all: rename_all.get().unwrap_or(RenameRule::None),\n@@ -398,6 +406,10 @@ impl Container {\n         &self.rename_all\n     }\n \n+    pub fn transparent(&self) -> bool {\n+        self.transparent\n+    }\n+\n     pub fn deny_unknown_fields(&self) -> bool {\n         self.deny_unknown_fields\n     }\n@@ -764,6 +776,7 @@ pub struct Field {\n     borrowed_lifetimes: BTreeSet<syn::Lifetime>,\n     getter: Option<syn::ExprPath>,\n     flatten: bool,\n+    transparent: bool,\n }\n \n /// Represents the default to use for a field when deserializing.\n@@ -777,7 +790,6 @@ pub enum Default {\n }\n \n impl Default {\n-    #[cfg(feature = \"deserialize_in_place\")]\n     pub fn is_none(&self) -> bool {\n         match *self {\n             Default::None => true,\n@@ -1066,6 +1078,7 @@ impl Field {\n             borrowed_lifetimes: borrowed_lifetimes,\n             getter: getter.get(),\n             flatten: flatten.get(),\n+            transparent: false,\n         }\n     }\n \n@@ -1125,6 +1138,14 @@ impl Field {\n     pub fn flatten(&self) -> bool {\n         self.flatten\n     }\n+\n+    pub fn transparent(&self) -> bool {\n+        self.transparent\n+    }\n+\n+    pub fn mark_transparent(&mut self) {\n+        self.transparent = true;\n+    }\n }\n \n type SerAndDe<T> = (Option<T>, Option<T>);\ndiff --git a/serde_derive/src/internals/check.rs b/serde_derive/src/internals/check.rs\nindex eac1c2293..0caa4b502 100644\n--- a/serde_derive/src/internals/check.rs\n+++ b/serde_derive/src/internals/check.rs\n@@ -8,18 +8,19 @@\n \n use internals::ast::{Container, Data, Field, Style};\n use internals::attr::{EnumTag, Identifier};\n-use internals::Ctxt;\n-use syn::Member;\n+use internals::{Ctxt, Derive};\n+use syn::{Member, Type};\n \n /// Cross-cutting checks that require looking at more than a single attrs\n /// object. Simpler checks should happen when parsing and building the attrs.\n-pub fn check(cx: &Ctxt, cont: &Container) {\n+pub fn check(cx: &Ctxt, cont: &mut Container, derive: Derive) {\n     check_getter(cx, cont);\n     check_flatten(cx, cont);\n     check_identifier(cx, cont);\n     check_variant_skip_attrs(cx, cont);\n     check_internal_tag_field_name_conflict(cx, cont);\n     check_adjacent_tag_conflict(cx, cont);\n+    check_transparent(cx, cont, derive);\n }\n \n /// Getters are only allowed inside structs (not enums) with the `remote`\n@@ -278,9 +279,75 @@ fn check_adjacent_tag_conflict(cx: &Ctxt, cont: &Container) {\n     }\n }\n \n+/// Enums and unit structs cannot be transparent.\n+fn check_transparent(cx: &Ctxt, cont: &mut Container, derive: Derive) {\n+    if !cont.attrs.transparent() {\n+        return;\n+    }\n+\n+    if cont.attrs.type_from().is_some() {\n+        cx.error(\"#[serde(transparent)] is not allowed with #[serde(from = \\\"...\\\")]\");\n+    }\n+\n+    if cont.attrs.type_into().is_some() {\n+        cx.error(\"#[serde(transparent)] is not allowed with #[serde(into = \\\"...\\\")]\");\n+    }\n+\n+    let fields = match cont.data {\n+        Data::Enum(_) => {\n+            cx.error(\"#[serde(transparent)] is not allowed on an enum\");\n+            return;\n+        }\n+        Data::Struct(Style::Unit, _) => {\n+            cx.error(\"#[serde(transparent)] is not allowed on a unit struct\");\n+            return;\n+        }\n+        Data::Struct(_, ref mut fields) => fields,\n+    };\n+\n+    let mut transparent_field = None;\n+\n+    for field in fields {\n+        if allow_transparent(field, derive) {\n+            if transparent_field.is_some() {\n+                cx.error(\"#[serde(transparent)] requires struct to have at most one transparent field\");\n+                return;\n+            }\n+            transparent_field = Some(field);\n+        }\n+    }\n+\n+    match transparent_field {\n+        Some(transparent_field) => transparent_field.attrs.mark_transparent(),\n+        None => match derive {\n+            Derive::Serialize => {\n+                cx.error(\"#[serde(transparent)] requires at least one field that is not skipped\");\n+            }\n+            Derive::Deserialize => {\n+                cx.error(\"#[serde(transparent)] requires at least one field that is neither skipped nor has a default\");\n+            }\n+        }\n+    }\n+}\n+\n fn member_message(member: &Member) -> String {\n     match *member {\n         Member::Named(ref ident) => format!(\"`{}`\", ident),\n         Member::Unnamed(ref i) => i.index.to_string(),\n     }\n }\n+\n+fn allow_transparent(field: &Field, derive: Derive) -> bool {\n+    if let Type::Path(ref ty) = *field.ty {\n+        if let Some(seg) = ty.path.segments.last() {\n+            if seg.into_value().ident == \"PhantomData\" {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    match derive {\n+        Derive::Serialize => !field.attrs.skip_serializing(),\n+        Derive::Deserialize => !field.attrs.skip_deserializing() && field.attrs.default().is_none(),\n+    }\n+}\ndiff --git a/serde_derive/src/internals/mod.rs b/serde_derive/src/internals/mod.rs\nindex f68462c9e..7a39688da 100644\n--- a/serde_derive/src/internals/mod.rs\n+++ b/serde_derive/src/internals/mod.rs\n@@ -14,3 +14,9 @@ pub use self::ctxt::Ctxt;\n \n mod case;\n mod check;\n+\n+#[derive(Copy, Clone)]\n+pub enum Derive {\n+    Serialize,\n+    Deserialize,\n+}\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 11e5b4835..c78237bf9 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -13,13 +13,13 @@ use syn::{self, Ident, Index, Member};\n use bound;\n use fragment::{Fragment, Match, Stmts};\n use internals::ast::{Container, Data, Field, Style, Variant};\n-use internals::{attr, Ctxt};\n+use internals::{attr, Ctxt, Derive};\n use pretend;\n use try;\n \n pub fn expand_derive_serialize(input: &syn::DeriveInput) -> Result<TokenStream, String> {\n     let ctxt = Ctxt::new();\n-    let cont = Container::from_ast(&ctxt, input);\n+    let cont = Container::from_ast(&ctxt, input, Derive::Serialize);\n     precondition(&ctxt, &cont);\n     try!(ctxt.check());\n \n@@ -166,7 +166,9 @@ fn needs_serialize_bound(field: &attr::Field, variant: Option<&attr::Variant>) -\n }\n \n fn serialize_body(cont: &Container, params: &Parameters) -> Fragment {\n-    if let Some(type_into) = cont.attrs.type_into() {\n+    if cont.attrs.transparent() {\n+        serialize_transparent(cont, params)\n+    } else if let Some(type_into) = cont.attrs.type_into() {\n         serialize_into(params, type_into)\n     } else {\n         match cont.data {\n@@ -185,6 +187,26 @@ fn serialize_body(cont: &Container, params: &Parameters) -> Fragment {\n     }\n }\n \n+fn serialize_transparent(cont: &Container, params: &Parameters) -> Fragment {\n+    let fields = match cont.data {\n+        Data::Struct(_, ref fields) => fields,\n+        Data::Enum(_) => unreachable!(),\n+    };\n+\n+    let self_var = &params.self_var;\n+    let transparent_field = fields.iter().find(|f| f.attrs.transparent()).unwrap();\n+    let member = &transparent_field.member;\n+\n+    let path = match transparent_field.attrs.serialize_with() {\n+        Some(path) => quote!(#path),\n+        None => quote!(_serde::Serialize::serialize),\n+    };\n+\n+    quote_block! {\n+        #path(&#self_var.#member, __serializer)\n+    }\n+}\n+\n fn serialize_into(params: &Parameters, type_into: &syn::Type) -> Fragment {\n     let self_var = &params.self_var;\n     quote_block! {\n", "test_patch": "diff --git a/test_suite/tests/compile-fail/transparent/at_most_one.rs b/test_suite/tests/compile-fail/transparent/at_most_one.rs\nnew file mode 100644\nindex 000000000..d5b7dae89\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/transparent/at_most_one.rs\n@@ -0,0 +1,20 @@\n+// Copyright 2018 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[serde(transparent)]\n+struct S {\n+    //~^^^ HELP: #[serde(transparent)] requires struct to have at most one transparent field\n+    a: u8,\n+    b: u8,\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/transparent/de_at_least_one.rs b/test_suite/tests/compile-fail/transparent/de_at_least_one.rs\nnew file mode 100644\nindex 000000000..a1abe4746\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/transparent/de_at_least_one.rs\n@@ -0,0 +1,22 @@\n+// Copyright 2018 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+#[serde(transparent)]\n+struct S {\n+    //~^^^ HELP: #[serde(transparent)] requires at least one field that is neither skipped nor has a default\n+    #[serde(skip)]\n+    a: u8,\n+    #[serde(default)]\n+    b: u8,\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/transparent/ser_at_least_one.rs b/test_suite/tests/compile-fail/transparent/ser_at_least_one.rs\nnew file mode 100644\nindex 000000000..19dd59c17\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/transparent/ser_at_least_one.rs\n@@ -0,0 +1,20 @@\n+// Copyright 2018 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[serde(transparent)]\n+struct S {\n+    //~^^^ HELP: #[serde(transparent)] requires at least one field that is not skipped\n+    #[serde(skip)]\n+    a: u8,\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex 5b82ad88d..aea692cba 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -15,6 +15,7 @@ extern crate serde;\n use self::serde::de::{self, Unexpected};\n use self::serde::{Deserialize, Deserializer, Serialize, Serializer};\n use std::collections::HashMap;\n+use std::marker::PhantomData;\n \n extern crate serde_test;\n use self::serde_test::{\n@@ -2161,3 +2162,41 @@ fn test_flatten_option() {\n         &[Token::Map { len: None }, Token::MapEnd],\n     );\n }\n+\n+#[test]\n+fn test_transparent_struct() {\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    #[serde(transparent)]\n+    struct Transparent {\n+        #[serde(skip)]\n+        a: bool,\n+        b: u32,\n+        #[serde(skip)]\n+        c: bool,\n+        d: PhantomData<()>,\n+    }\n+\n+    assert_tokens(\n+        &Transparent {\n+            a: false,\n+            b: 1,\n+            c: false,\n+            d: PhantomData,\n+        },\n+        &[Token::U32(1)],\n+    );\n+}\n+\n+#[test]\n+fn test_transparent_tuple_struct() {\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    #[serde(transparent)]\n+    struct Transparent(\n+        #[serde(skip)] bool,\n+        u32,\n+        #[serde(skip)] bool,\n+        PhantomData<()>,\n+    );\n+\n+    assert_tokens(&Transparent(false, 1, false, PhantomData), &[Token::U32(1)]);\n+}\ndiff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex ffb73210a..ef301b590 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -653,6 +653,14 @@ fn test_gen() {\n             X,\n         ),\n     }\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(transparent)]\n+    struct TransparentWith {\n+        #[serde(serialize_with = \"ser_x\")]\n+        #[serde(deserialize_with = \"de_x\")]\n+        x: X,\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Attribute to specify that type representation is the same as its only field\nBy analogy with [`#[repr(transparent)]`](https://github.com/rust-lang/rfcs/blob/master/text/1758-repr-transparent.md).\r\n\r\n```rust\r\n// This should serialize and deserialize directly as String, rather than as newtype.\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(transparent)]\r\nstruct Transparent(String);\r\n\r\n// Generated code.\r\nimpl Serialize for Transparent {\r\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\r\n        where S: Serializer\r\n    {\r\n        self.0.serialize(serializer)\r\n    }\r\n}\r\n\r\nimpl<'de> Deserialize<'de> for Transparent {\r\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\r\n        where D: Deserializer<'de>\r\n    {\r\n        Deserialize::deserialize(deserializer).map(Transparent)\r\n    }\r\n}\r\n```\r\n\r\nShould also work for structs with one field, and structs and tuple structs with all but one skipped field.\r\n\r\n@bluss \r\n\n", "hints_text": "Can this attribute also be used to inline the fields of a struct member type into the parent struct for the purpose of (de)serialization?\r\n\r\nLike this:\r\n```rust\r\n#[derive(Serialize, Deserialize)]\r\nstruct Common {\r\n    a: i32,\r\n}\r\n\r\n#[derive(Serialize, Deserialize)]\r\nstruct Foo {\r\n    #[serde(transparent)]\r\n    common: Common,\r\n    foo: u8,\r\n}\r\n\r\n#[derive(Serialize, Deserialize)]\r\nstruct Bar {\r\n    #[serde(transparent)]\r\n    common: Common,\r\n    bar: u64,\r\n}\r\n```\nAh, nvm, I found out that it's `#[serde(flatten)]`..", "created_at": "2018-05-20T20:54:37Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1269, "instance_id": "serde-rs__serde-1269", "issue_numbers": ["1268"], "base_commit": "f09320b2932972e55317bf2899f69cab038f4377", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 40a5d1050..3cce5f071 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -1802,10 +1802,8 @@ fn deserialize_untagged_newtype_variant(\n         }\n         Some(path) => {\n             quote_block! {\n-                let __value: #field_ty = _serde::export::Result::map(\n-                    #path(#deserializer),\n-                    #this::#variant_ident);\n-                __value\n+                let __value: _serde::export::Result<#field_ty, _> = #path(#deserializer);\n+                _serde::export::Result::map(__value, #this::#variant_ident)\n             }\n         }\n     }\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 7888f2d82..ffb73210a 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -643,6 +643,16 @@ fn test_gen() {\n     struct ImpliciltyBorrowedOption<'a> {\n         option: std::option::Option<&'a str>,\n     }\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(untagged)]\n+    enum UntaggedNewtypeVariantWith {\n+        Newtype(\n+            #[serde(serialize_with = \"ser_x\")]\n+            #[serde(deserialize_with = \"de_x\")]\n+            X,\n+        ),\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "serde_derive deserialize_with untagged enum regression\nI still need to create a simple reproduction for the issue, and not sure if this is covered by another issue report, but effectively...\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\n#[serde(untagged)]\r\nenum E {\r\n    Variant(\r\n        #[serde(deserialize_with=\"...\")]\r\n        Ty\r\n    ),\r\n}\r\n```\r\n\r\nNow fails to compile with a type mismatch error where it used to work properly. Moving the attribute outside of the variant (`#[serde(deserialize_with=\"...\")] Variant(Ty)`) seems to work on both and I believe should be equivalent and a valid workaround for now? Tested with serde_derive v1.0.29 (worked) and v1.0.57 (broken).\n", "hints_text": "", "created_at": "2018-05-20T00:21:09Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1256, "instance_id": "serde-rs__serde-1256", "issue_numbers": ["1255"], "base_commit": "35aae92b5609dc0707bea73a890ed0beb5c8cac0", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex b13800dca..59f667ed7 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -529,6 +529,14 @@ where\n     {\n         T::deserialize(deserializer).map(Some)\n     }\n+\n+    #[doc(hidden)]\n+    fn __private_visit_untagged_option<D>(self, deserializer: D) -> Result<Self::Value, ()>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        Ok(T::deserialize(deserializer).ok())\n+    }\n }\n \n impl<'de, T> Deserialize<'de> for Option<T>\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 826662dfa..fbc24016e 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -1529,6 +1529,15 @@ pub trait Visitor<'de>: Sized {\n         let _ = data;\n         Err(Error::invalid_type(Unexpected::Enum, &self))\n     }\n+\n+    // Used when deserializing a flattened Option field. Not public API.\n+    #[doc(hidden)]\n+    fn __private_visit_untagged_option<D>(self, _: D) -> Result<Self::Value, ()>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        Err(())\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\ndiff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex dcf5008f5..fab85534c 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -2645,10 +2645,7 @@ impl<'a, 'de, E> FlatMapDeserializer<'a, 'de, E>\n where\n     E: Error,\n {\n-    fn deserialize_other<V>(self, _: V) -> Result<V::Value, E>\n-    where\n-        V: Visitor<'de>,\n-    {\n+    fn deserialize_other<V>() -> Result<V, E> {\n         Err(Error::custom(\"can only flatten structs and maps\"))\n     }\n }\n@@ -2657,11 +2654,11 @@ where\n macro_rules! forward_to_deserialize_other {\n     ($($func:ident ( $($arg:ty),* ))*) => {\n         $(\n-            fn $func<V>(self, $(_: $arg,)* visitor: V) -> Result<V::Value, Self::Error>\n+            fn $func<V>(self, $(_: $arg,)* _visitor: V) -> Result<V::Value, Self::Error>\n             where\n                 V: Visitor<'de>,\n             {\n-                self.deserialize_other(visitor)\n+                Self::deserialize_other()\n             }\n         )*\n     }\n@@ -2741,6 +2738,16 @@ where\n         visitor.visit_newtype_struct(self)\n     }\n \n+    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        match visitor.__private_visit_untagged_option(self) {\n+            Ok(value) => Ok(value),\n+            Err(()) => Self::deserialize_other(),\n+        }\n+    }\n+\n     forward_to_deserialize_other! {\n         deserialize_bool()\n         deserialize_i8()\n@@ -2758,7 +2765,6 @@ where\n         deserialize_string()\n         deserialize_bytes()\n         deserialize_byte_buf()\n-        deserialize_option()\n         deserialize_unit()\n         deserialize_unit_struct(&'static str)\n         deserialize_seq()\ndiff --git a/serde/src/private/ser.rs b/serde/src/private/ser.rs\nindex 54bb4ce02..c21de1635 100644\n--- a/serde/src/private/ser.rs\n+++ b/serde/src/private/ser.rs\n@@ -1122,14 +1122,14 @@ where\n     }\n \n     fn serialize_none(self) -> Result<Self::Ok, Self::Error> {\n-        Err(self.bad_type(Unsupported::Optional))\n+        Ok(())\n     }\n \n-    fn serialize_some<T: ?Sized>(self, _: &T) -> Result<Self::Ok, Self::Error>\n+    fn serialize_some<T: ?Sized>(self, value: &T) -> Result<Self::Ok, Self::Error>\n     where\n         T: Serialize,\n     {\n-        Err(self.bad_type(Unsupported::Optional))\n+        value.serialize(self)\n     }\n \n     fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {\n", "test_patch": "diff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex 248e42118..7aaa97d5b 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -2095,3 +2095,84 @@ fn test_flatten_untagged_enum() {\n         ],\n     );\n }\n+\n+#[test]\n+fn test_flatten_option() {\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    struct Outer {\n+        #[serde(flatten)]\n+        inner1: Option<Inner1>,\n+        #[serde(flatten)]\n+        inner2: Option<Inner2>,\n+    }\n+\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    struct Inner1 {\n+        inner1: i32,\n+    }\n+\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    struct Inner2 {\n+        inner2: i32,\n+    }\n+\n+    assert_tokens(\n+        &Outer {\n+            inner1: Some(Inner1 {\n+                inner1: 1,\n+            }),\n+            inner2: Some(Inner2 {\n+                inner2: 2,\n+            }),\n+        },\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"inner1\"),\n+            Token::I32(1),\n+            Token::Str(\"inner2\"),\n+            Token::I32(2),\n+            Token::MapEnd,\n+        ],\n+    );\n+\n+    assert_tokens(\n+        &Outer {\n+            inner1: Some(Inner1 {\n+                inner1: 1,\n+            }),\n+            inner2: None,\n+        },\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"inner1\"),\n+            Token::I32(1),\n+            Token::MapEnd,\n+        ],\n+    );\n+\n+    assert_tokens(\n+        &Outer {\n+            inner1: None,\n+            inner2: Some(Inner2 {\n+                inner2: 2,\n+            }),\n+        },\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"inner2\"),\n+            Token::I32(2),\n+            Token::MapEnd,\n+        ],\n+    );\n+\n+    assert_tokens(\n+        &Outer {\n+            inner1: None,\n+            inner2: None,\n+        },\n+        &[\n+            Token::Map { len: None },\n+            Token::MapEnd,\n+        ],\n+    );\n+}\n", "problem_statement": "Allow flattened untagged Options in struct fields\nI have a small use case for `#[serde(flatten)]` that did not work as I expected due to the intermediary presence of an `Option` type. Here's what I mean:\r\n\r\n```\r\n#[derive(Serialize, Deserialize)]\r\nenum Quux {\r\n    A,\r\n    B,\r\n    C,\r\n}\r\n\r\n#[derive(Serialize, Deserialize)]\r\nstruct Bar {\r\n    quux: Quux,\r\n}\r\n\r\n#[derive(Serialize, Deserialize)]\r\nstruct Foo {\r\n    baz: i32,\r\n    #[serde(flatten)]\r\n    bar: Option<Bar>,\r\n}\r\n\r\nfn main() {\r\n    let f : Foo = serde_json::from_str(r#\"{\r\n        \"baz\": 10,\r\n        \"quux\": \"A\"\r\n    }\"#).unwrap();  // panics unwrapping 'Error(\"can only flatten structs and maps\", line: 4, column: 5)'\r\n}\r\n\r\n```\r\n\r\nI'm able to get around this problem by using my own untagged `Option` type.\r\n\r\n```\r\n#[derive(Serialize, Deserialize)]\r\nenum Quux {\r\n    A,\r\n    B,\r\n    C,\r\n}\r\n\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(untagged)]\r\nenum OptBar {\r\n    Some(Bar),\r\n    None,\r\n}\r\n\r\n#[derive(Serialize, Deserialize)]\r\nstruct Bar {\r\n    quux: Quux,\r\n}\r\n\r\n#[derive(Serialize, Deserialize)]\r\nstruct Foo {\r\n    baz: i32,\r\n    #[serde(flatten)]\r\n    bar: OptBar,\r\n}\r\n\r\nfn main() {\r\n    let f : Foo = serde_json::from_str(r#\"{\r\n        \"n\": 10,\r\n        \"quux\": \"A\"\r\n    }\"#).unwrap();  // returns a 'Foo { n: 10, bar: Some(Bar { quux: A }) }'\r\n}\r\n```\r\n\r\nIs there any way to get around this otherwise? Continuing to use the standard `Option` type allows some more straightforward checking of `Foo.bar`, which is quite useful. Worst case scenario I can change my data representation.\n", "hints_text": "", "created_at": "2018-05-12T05:14:42Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1252, "instance_id": "serde-rs__serde-1252", "issue_numbers": ["830"], "base_commit": "536bdd77a0725fff5ae4e55e1c4905d957c5eb94", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 42dbe3860..b0953450b 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -15,15 +15,16 @@ use syn::{self, Ident, Index, Member};\n use bound;\n use fragment::{Expr, Fragment, Match, Stmts};\n use internals::ast::{Container, Data, Field, Style, Variant};\n-use internals::{self, attr};\n+use internals::{attr, Ctxt};\n use pretend;\n use try;\n \n use std::collections::BTreeSet;\n \n pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<Tokens, String> {\n-    let ctxt = internals::Ctxt::new();\n+    let ctxt = Ctxt::new();\n     let cont = Container::from_ast(&ctxt, input);\n+    precondition(&ctxt, &cont);\n     try!(ctxt.check());\n \n     let ident = cont.ident;\n@@ -80,6 +81,16 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<Tokens, Str\n     Ok(generated)\n }\n \n+fn precondition(cx: &Ctxt, cont: &Container) {\n+    if let Data::Struct(_, ref fields) = cont.data {\n+        if let Some(last) = fields.last() {\n+            if let syn::Type::Slice(_) = *last.ty {\n+                cx.error(\"cannot deserialize a dynamically sized struct\");\n+            }\n+        }\n+    }\n+}\n+\n struct Parameters {\n     /// Name of the type the `derive` is on.\n     local: syn::Ident,\n", "test_patch": "diff --git a/test_suite/tests/compile-fail/precondition/deserialize_dst.rs b/test_suite/tests/compile-fail/precondition/deserialize_dst.rs\nnew file mode 100644\nindex 000000000..243b998d7\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/precondition/deserialize_dst.rs\n@@ -0,0 +1,16 @@\n+// Copyright 2018 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+struct S {\n+    string: String,\n+    slice: [u8], //~^^^ HELP: cannot deserialize a dynamically sized struct\n+}\n", "problem_statement": "Deserialize for dynamically sized struct generates invalid code\n```rust\r\nextern crate serde;\r\n\r\n#[macro_use]\r\nextern crate serde_derive;\r\n\r\n#[derive(Deserialize)]\r\nstruct S {\r\n    last: [u8],\r\n}\r\n```\r\n\r\n```\r\nerror[E0277]: the trait bound `[u8]: std::marker::Sized` is not satisfied in `S`\r\n --> src/main.rs:6:10\r\n  |\r\n6 | #[derive(Deserialize)]\r\n  |          ^^^^^^^^^^^ within `S`, the trait `std::marker::Sized` is not implemented for `[u8]`\r\n  |\r\n  = note: `[u8]` does not have a constant size known at compile-time\r\n  = note: required because it appears within the type `S`\r\n  = note: required by `serde::Deserialize`\r\n```\n", "hints_text": "There is no way to implement a working Deserialize for this type because Deserialize requires Self: Sized, but it would be nice to at least detect the case of dynamically sized slice as the last field and fail with a message rather than generating broken code.", "created_at": "2018-05-07T18:28:17Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1251, "instance_id": "serde-rs__serde-1251", "issue_numbers": ["186"], "base_commit": "dc921892be95f07914fff21410c12310a8305158", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 5a53a418e..aa4ede6c4 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -1474,6 +1474,44 @@ where\n \n ////////////////////////////////////////////////////////////////////////////////\n \n+/// This impl requires the [`\"rc\"`] Cargo feature of Serde. The resulting\n+/// `Weak<T>` has a reference count of 0 and cannot be upgraded.\n+///\n+/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n+#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\n+impl<'de, T: ?Sized> Deserialize<'de> for RcWeak<T>\n+where\n+    T: Deserialize<'de>,\n+{\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        try!(Option::<T>::deserialize(deserializer));\n+        Ok(RcWeak::new())\n+    }\n+}\n+\n+/// This impl requires the [`\"rc\"`] Cargo feature of Serde. The resulting\n+/// `Weak<T>` has a reference count of 0 and cannot be upgraded.\n+///\n+/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n+#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\n+impl<'de, T: ?Sized> Deserialize<'de> for ArcWeak<T>\n+where\n+    T: Deserialize<'de>,\n+{\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        try!(Option::<T>::deserialize(deserializer));\n+        Ok(ArcWeak::new())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+\n #[cfg(all(feature = \"unstable\", feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\n macro_rules! box_forwarded_impl {\n     (\ndiff --git a/serde/src/lib.rs b/serde/src/lib.rs\nindex 923b7596c..ce0c3326f 100644\n--- a/serde/src/lib.rs\n+++ b/serde/src/lib.rs\n@@ -179,14 +179,14 @@ mod lib {\n     pub use std::boxed::Box;\n \n     #[cfg(all(feature = \"rc\", feature = \"alloc\", not(feature = \"std\")))]\n-    pub use alloc::rc::Rc;\n+    pub use alloc::rc::{Rc, Weak as RcWeak};\n     #[cfg(all(feature = \"rc\", feature = \"std\"))]\n-    pub use std::rc::Rc;\n+    pub use std::rc::{Rc, Weak as RcWeak};\n \n     #[cfg(all(feature = \"rc\", feature = \"alloc\", not(feature = \"std\")))]\n-    pub use alloc::arc::Arc;\n+    pub use alloc::arc::{Arc, Weak as ArcWeak};\n     #[cfg(all(feature = \"rc\", feature = \"std\"))]\n-    pub use std::sync::Arc;\n+    pub use std::sync::{Arc, Weak as ArcWeak};\n \n     #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n     pub use alloc::{BTreeMap, BTreeSet, BinaryHeap, LinkedList, VecDeque};\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex f2de28222..fbe057cdd 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -374,6 +374,40 @@ deref_impl!(<'a, T: ?Sized> Serialize for Cow<'a, T> where T: Serialize + ToOwne\n \n ////////////////////////////////////////////////////////////////////////////////\n \n+/// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n+///\n+/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n+#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\n+impl<T: ?Sized> Serialize for RcWeak<T>\n+where\n+    T: Serialize,\n+{\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        self.upgrade().serialize(serializer)\n+    }\n+}\n+\n+/// This impl requires the [`\"rc\"`] Cargo feature of Serde.\n+///\n+/// [`\"rc\"`]: https://serde.rs/feature-flags.html#-features-rc\n+#[cfg(all(feature = \"rc\", any(feature = \"std\", feature = \"alloc\")))]\n+impl<T: ?Sized> Serialize for ArcWeak<T>\n+where\n+    T: Serialize,\n+{\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        self.upgrade().serialize(serializer)\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+\n #[cfg(feature = \"unstable\")]\n #[allow(deprecated)]\n impl<T> Serialize for NonZero<T>\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 3a8fcc448..a7eedba3f 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -17,15 +17,15 @@ use std::ffi::{CString, OsString};\n use std::net;\n use std::num::Wrapping;\n use std::path::{Path, PathBuf};\n-use std::rc::Rc;\n-use std::sync::Arc;\n+use std::rc::{Rc, Weak as RcWeak};\n+use std::sync::{Arc, Weak as ArcWeak};\n use std::time::{Duration, UNIX_EPOCH};\n \n #[cfg(feature = \"unstable\")]\n use std::ffi::CStr;\n \n extern crate serde;\n-use serde::Deserialize;\n+use serde::{Deserialize, Deserializer};\n \n extern crate fnv;\n use self::fnv::FnvHasher;\n@@ -182,6 +182,27 @@ macro_rules! declare_error_tests {\n     }\n }\n \n+#[derive(Debug)]\n+struct SkipPartialEq<T>(T);\n+\n+impl<'de, T> Deserialize<'de> for SkipPartialEq<T>\n+where\n+    T: Deserialize<'de>,\n+{\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        T::deserialize(deserializer).map(SkipPartialEq)\n+    }\n+}\n+\n+impl<T> PartialEq for SkipPartialEq<T> {\n+    fn eq(&self, _other: &Self) -> bool {\n+        true\n+    }\n+}\n+\n fn assert_de_tokens_ignore(ignorable_tokens: &[Token]) {\n     #[derive(PartialEq, Debug, Deserialize)]\n     struct IgnoreBase {\n@@ -788,11 +809,33 @@ declare_tests! {\n             Token::Bool(true),\n         ],\n     }\n+    test_rc_weak_some {\n+        SkipPartialEq(RcWeak::<bool>::new()) => &[\n+            Token::Some,\n+            Token::Bool(true),\n+        ],\n+    }\n+    test_rc_weak_none {\n+        SkipPartialEq(RcWeak::<bool>::new()) => &[\n+            Token::None,\n+        ],\n+    }\n     test_arc {\n         Arc::new(true) => &[\n             Token::Bool(true),\n         ],\n     }\n+    test_arc_weak_some {\n+        SkipPartialEq(ArcWeak::<bool>::new()) => &[\n+            Token::Some,\n+            Token::Bool(true),\n+        ],\n+    }\n+    test_arc_weak_none {\n+        SkipPartialEq(ArcWeak::<bool>::new()) => &[\n+            Token::None,\n+        ],\n+    }\n     test_wrapping {\n         Wrapping(1usize) => &[\n             Token::U32(1),\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex dbc42da63..d677fe351 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -11,11 +11,12 @@ extern crate serde_derive;\n \n use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n use std::ffi::CString;\n+use std::mem;\n use std::net;\n use std::num::Wrapping;\n use std::path::{Path, PathBuf};\n-use std::rc::Rc;\n-use std::sync::Arc;\n+use std::rc::{Rc, Weak as RcWeak};\n+use std::sync::{Arc, Weak as ArcWeak};\n use std::time::{Duration, UNIX_EPOCH};\n \n #[cfg(unix)]\n@@ -398,11 +399,41 @@ declare_tests! {\n             Token::Bool(true),\n         ],\n     }\n+    test_rc_weak_some {\n+        {\n+            let rc = Rc::new(true);\n+            mem::forget(rc.clone());\n+            Rc::downgrade(&rc)\n+        } => &[\n+            Token::Some,\n+            Token::Bool(true),\n+        ],\n+    }\n+    test_rc_weak_none {\n+        RcWeak::<bool>::new() => &[\n+            Token::None,\n+        ],\n+    }\n     test_arc {\n         Arc::new(true) => &[\n             Token::Bool(true),\n         ],\n     }\n+    test_arc_weak_some {\n+        {\n+            let arc = Arc::new(true);\n+            mem::forget(arc.clone());\n+            Arc::downgrade(&arc)\n+        } => &[\n+            Token::Some,\n+            Token::Bool(true),\n+        ],\n+    }\n+    test_arc_weak_none {\n+        ArcWeak::<bool>::new() => &[\n+            Token::None,\n+        ],\n+    }\n     test_wrapping {\n         Wrapping(1usize) => &[\n             Token::U64(1),\n", "problem_statement": "No way to serialize Weak pointers\nAs mentioned on [reddit](https://www.reddit.com/r/rust/comments/3u4ri0/serde_serializing_weak/). Open question: What do we do if the value the `Weak` pointer is pointing at has been destroyed? Should we serialize them as an `Option` pointer?\n\n", "hints_text": "It's also not clear what we should do for deserialization.\n\nI'd serialize it as an `Option` pointer and during deserialization, in case it's `None`, just create an `Rc`, make a `Weak` from that and `drop` the `Rc`.\n\n@oli-obk: I suppose that would work, but it seems sad that we wouldn't actually be able to deserialize these weak types. I wonder if a better idea would be to get a `impl Default` implemented for `Weak` types, that defaults to it not being defined.\n\nI think it doesn't really make sense to put more time into this until #194 is resolved somehow. For Weak pointers the failure modes mentioned in #194 are even worse.\n\nNevertheless, getting a default impl for Weak into rust seems smart.\n\nrust-lang/rust#30467 added a `Weak::new` method, though it is unstable.\n\n`Weak::new` is now (1.10) stable: https://github.com/rust-lang/rust/issues/30425#issuecomment-219836269\n\nMy point about #194 being unresolved remains I'm afraid, tho of course I'm happy Weak::new is stable now\n", "created_at": "2018-05-07T17:41:10Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1249, "instance_id": "serde-rs__serde-1249", "issue_numbers": ["1247"], "base_commit": "9dc05c36f0fa9efc66e4bb0ae59822d475c3b0a0", "patch": "diff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 987cc53ae..38b03eece 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -645,7 +645,7 @@ fn serialize_adjacently_tagged_variant(\n \n     let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n \n-    let wrapper_generics = if let Style::Unit = variant.style {\n+    let wrapper_generics = if fields_ident.is_empty() {\n         params.generics.clone()\n     } else {\n         bound::with_lifetime_bound(&params.generics, \"'__a\")\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex d6921e148..f0255bad3 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -567,6 +567,17 @@ fn test_gen() {\n     }\n \n     assert::<AssocDeriveMulti<i32, NoSerdeImpl>>();\n+\n+    #[derive(Serialize)]\n+    #[serde(tag = \"t\", content = \"c\")]\n+    enum EmptyAdjacentlyTagged {\n+        #[allow(dead_code)]\n+        Struct {},\n+        #[allow(dead_code)]\n+        Tuple(),\n+    }\n+\n+    assert_ser::<EmptyAdjacentlyTagged>();\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Adjacently tagged empty tuple variant or struct variant generates broken Serialize\n```rust\r\n#[derive(Serialize)]\r\n#[serde(tag = \"t\", content = \"c\")]\r\nenum E {\r\n    A {}, // same for `A()`\r\n}\r\n```\r\n\r\n```\r\nerror[E0392]: parameter `'__a` is never used\r\n  --> src/main.rs:68:10\r\n   |\r\n68 | #[derive(Serialize)]\r\n   |          ^^^^^^^^^ unused type parameter\r\n   |\r\n   = help: consider removing `'__a` or using a marker such as `std::marker::PhantomData`\r\n```\n", "hints_text": "", "created_at": "2018-05-07T04:50:07Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1248, "instance_id": "serde-rs__serde-1248", "issue_numbers": ["1206"], "base_commit": "5098609935f236a30d9c42356d2941d847c699f6", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex f1a37b854..e3197fcf4 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -838,6 +838,10 @@ fn deserialize_struct(\n         quote! {\n             _serde::Deserializer::deserialize_any(#deserializer, #visitor_expr)\n         }\n+    } else if is_enum && cattrs.has_flatten() {\n+        quote! {\n+            _serde::de::VariantAccess::newtype_variant_seed(__variant, #visitor_expr)\n+        }\n     } else if is_enum {\n         quote! {\n             _serde::de::VariantAccess::struct_variant(__variant, FIELDS, #visitor_expr)\n@@ -875,6 +879,23 @@ fn deserialize_struct(\n         _ => None,\n     };\n \n+    let visitor_seed = if is_enum && cattrs.has_flatten() {\n+        Some(quote! {\n+            impl #de_impl_generics _serde::de::DeserializeSeed<#delife> for __Visitor #de_ty_generics #where_clause {\n+                type Value = #this #ty_generics;\n+\n+                fn deserialize<__D>(self, __deserializer: __D) -> _serde::export::Result<Self::Value, __D::Error>\n+                where\n+                    __D: _serde::Deserializer<'de>,\n+                {\n+                    _serde::Deserializer::deserialize_map(__deserializer, self)\n+                }\n+            }\n+        })\n+    } else {\n+        None\n+    };\n+\n     quote_block! {\n         #field_visitor\n \n@@ -901,6 +922,8 @@ fn deserialize_struct(\n             }\n         }\n \n+        #visitor_seed\n+\n         #fields_stmt\n \n         #dispatch\n@@ -1738,7 +1761,7 @@ fn deserialize_generated_identifier(\n     let this = quote!(__Field);\n     let field_idents: &Vec<_> = &fields.iter().map(|&(_, ref ident)| ident).collect();\n \n-    let (ignore_variant, fallthrough) = if cattrs.has_flatten() {\n+    let (ignore_variant, fallthrough) = if !is_variant && cattrs.has_flatten() {\n         let ignore_variant = quote!(__other(_serde::private::de::Content<'de>),);\n         let fallthrough = quote!(_serde::export::Ok(__Field::__other(__value)));\n         (Some(ignore_variant), Some(fallthrough))\n@@ -1755,10 +1778,10 @@ fn deserialize_generated_identifier(\n         fields,\n         is_variant,\n         fallthrough,\n-        cattrs.has_flatten(),\n+        !is_variant && cattrs.has_flatten(),\n     ));\n \n-    let lifetime = if cattrs.has_flatten() {\n+    let lifetime = if !is_variant && cattrs.has_flatten() {\n         Some(quote!(<'de>))\n     } else {\n         None\ndiff --git a/serde_derive/src/internals/check.rs b/serde_derive/src/internals/check.rs\nindex 639f95e9d..00188ac6e 100644\n--- a/serde_derive/src/internals/check.rs\n+++ b/serde_derive/src/internals/check.rs\n@@ -6,7 +6,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use internals::ast::{Container, Data, Style};\n+use internals::ast::{Container, Data, Field, Style};\n use internals::attr::{EnumTag, Identifier};\n use internals::Ctxt;\n \n@@ -44,46 +44,52 @@ fn check_getter(cx: &Ctxt, cont: &Container) {\n /// Flattening has some restrictions we can test.\n fn check_flatten(cx: &Ctxt, cont: &Container) {\n     match cont.data {\n-        Data::Enum(_) => {\n-            if cont.attrs.has_flatten() {\n-                cx.error(\"#[serde(flatten)] cannot be used within enums\");\n+        Data::Enum(ref variants) => {\n+            for variant in variants {\n+                for field in &variant.fields {\n+                    check_flatten_field(cx, variant.style, field);\n+                }\n             }\n         }\n-        Data::Struct(style, _) => {\n-            for field in cont.data.all_fields() {\n-                if !field.attrs.flatten() {\n-                    continue;\n-                }\n-                match style {\n-                    Style::Tuple => {\n-                        cx.error(\"#[serde(flatten)] cannot be used on tuple structs\");\n-                    }\n-                    Style::Newtype => {\n-                        cx.error(\"#[serde(flatten)] cannot be used on newtype structs\");\n-                    }\n-                    _ => {}\n-                }\n-                if field.attrs.skip_serializing() {\n-                    cx.error(\n-                        \"#[serde(flatten] can not be combined with \\\n-                         #[serde(skip_serializing)]\",\n-                    );\n-                } else if field.attrs.skip_serializing_if().is_some() {\n-                    cx.error(\n-                        \"#[serde(flatten] can not be combined with \\\n-                         #[serde(skip_serializing_if = \\\"...\\\")]\",\n-                    );\n-                } else if field.attrs.skip_deserializing() {\n-                    cx.error(\n-                        \"#[serde(flatten] can not be combined with \\\n-                         #[serde(skip_deserializing)]\",\n-                    );\n-                }\n+        Data::Struct(style, ref fields) => {\n+            for field in fields {\n+                check_flatten_field(cx, style, field);\n             }\n         }\n     }\n }\n \n+fn check_flatten_field(cx: &Ctxt, style: Style, field: &Field) {\n+    if !field.attrs.flatten() {\n+        return;\n+    }\n+    match style {\n+        Style::Tuple => {\n+            cx.error(\"#[serde(flatten)] cannot be used on tuple structs\");\n+        }\n+        Style::Newtype => {\n+            cx.error(\"#[serde(flatten)] cannot be used on newtype structs\");\n+        }\n+        _ => {}\n+    }\n+    if field.attrs.skip_serializing() {\n+        cx.error(\n+            \"#[serde(flatten] can not be combined with \\\n+             #[serde(skip_serializing)]\",\n+        );\n+    } else if field.attrs.skip_serializing_if().is_some() {\n+        cx.error(\n+            \"#[serde(flatten] can not be combined with \\\n+             #[serde(skip_serializing_if = \\\"...\\\")]\",\n+        );\n+    } else if field.attrs.skip_deserializing() {\n+        cx.error(\n+            \"#[serde(flatten] can not be combined with \\\n+             #[serde(skip_deserializing)]\",\n+        );\n+    }\n+}\n+\n /// The `other` attribute must be used at most once and it must be the last\n /// variant of an enum that has the `field_identifier` attribute.\n ///\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex e40ed46d6..987cc53ae 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -789,6 +789,10 @@ fn serialize_struct_variant<'a>(\n     fields: &[Field],\n     name: &str,\n ) -> Fragment {\n+    if fields.iter().any(|field| field.attrs.flatten()) {\n+        return serialize_struct_variant_with_flatten(context, params, fields, name);\n+    }\n+\n     let struct_trait = match context {\n         StructVariant::ExternallyTagged { .. } => (StructTrait::SerializeStructVariant),\n         StructVariant::InternallyTagged { .. } | StructVariant::Untagged => {\n@@ -863,6 +867,92 @@ fn serialize_struct_variant<'a>(\n     }\n }\n \n+fn serialize_struct_variant_with_flatten<'a>(\n+    context: StructVariant<'a>,\n+    params: &Parameters,\n+    fields: &[Field],\n+    name: &str,\n+) -> Fragment {\n+    let struct_trait = StructTrait::SerializeMap;\n+    let serialize_fields = serialize_struct_visitor(fields, params, true, &struct_trait);\n+\n+    let mut serialized_fields = fields\n+        .iter()\n+        .filter(|&field| !field.attrs.skip_serializing())\n+        .peekable();\n+\n+    let let_mut = mut_if(serialized_fields.peek().is_some());\n+\n+    match context {\n+        StructVariant::ExternallyTagged {\n+            variant_index,\n+            variant_name,\n+        } => {\n+            let this = &params.this;\n+            let fields_ty = fields.iter().map(|f| &f.ty);\n+            let fields_ident = &fields.iter().map(|f| f.ident).collect::<Vec<_>>();\n+\n+            let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n+            let wrapper_generics = bound::with_lifetime_bound(&params.generics, \"'__a\");\n+            let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n+\n+            quote_block! {\n+                struct __EnumFlatten #wrapper_generics #where_clause {\n+                    data: (#(&'__a #fields_ty,)*),\n+                    phantom: _serde::export::PhantomData<#this #ty_generics>,\n+                }\n+\n+                impl #wrapper_impl_generics _serde::Serialize for __EnumFlatten #wrapper_ty_generics #where_clause {\n+                    fn serialize<__S>(&self, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n+                    where\n+                        __S: _serde::Serializer,\n+                    {\n+                        let (#(#fields_ident,)*) = self.data;\n+                        let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(\n+                            __serializer,\n+                            _serde::export::None));\n+                        #(#serialize_fields)*\n+                        _serde::ser::SerializeMap::end(__serde_state)\n+                    }\n+                }\n+\n+                _serde::Serializer::serialize_newtype_variant(\n+                    __serializer,\n+                    #name,\n+                    #variant_index,\n+                    #variant_name,\n+                    &__EnumFlatten {\n+                        data: (#(#fields_ident,)*),\n+                        phantom: _serde::export::PhantomData::<#this #ty_generics>,\n+                    })\n+            }\n+        }\n+        StructVariant::InternallyTagged { tag, variant_name } => {\n+            quote_block! {\n+                let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(\n+                    __serializer,\n+                    _serde::export::None));\n+                try!(_serde::ser::SerializeMap::serialize_entry(\n+                    &mut __serde_state,\n+                    #tag,\n+                    #variant_name,\n+                ));\n+                #(#serialize_fields)*\n+                _serde::ser::SerializeMap::end(__serde_state)\n+            }\n+        }\n+        StructVariant::Untagged => {\n+            quote_block! {\n+                let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(\n+                    __serializer,\n+                    _serde::export::None));\n+                #(#serialize_fields)*\n+                _serde::ser::SerializeMap::end(__serde_state)\n+            }\n+        }\n+    }\n+}\n+\n fn serialize_tuple_struct_visitor(\n     fields: &[Field],\n     params: &Parameters,\n", "test_patch": "diff --git a/test_suite/tests/compile-fail/conflict/flatten-within-enum.rs b/test_suite/tests/compile-fail/conflict/flatten-within-enum.rs\ndeleted file mode 100644\nindex d2e007d26..000000000\n--- a/test_suite/tests/compile-fail/conflict/flatten-within-enum.rs\n+++ /dev/null\n@@ -1,21 +0,0 @@\n-// Copyright 2018 Serde Developers\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[macro_use]\n-extern crate serde_derive;\n-\n-#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n-//~^ HELP: #[serde(flatten)] cannot be used within enums\n-enum Foo {\n-    A {\n-        #[serde(flatten)]\n-        fields: HashMap<String, String>,\n-    }\n-}\n-\n-fn main() {}\ndiff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex 815a47b6a..d33ad93e1 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -1839,3 +1839,158 @@ fn test_flatten_internally_tagged() {\n         ],\n     );\n }\n+\n+#[test]\n+fn test_externally_tagged_enum_containing_flatten() {\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    enum Data {\n+        A {\n+            a: i32,\n+            #[serde(flatten)]\n+            flat: Flat,\n+        }\n+    }\n+\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    struct Flat {\n+        b: i32,\n+    }\n+\n+    let data = Data::A {\n+        a: 0,\n+        flat: Flat {\n+            b: 0,\n+        }\n+    };\n+\n+    assert_tokens(\n+        &data,\n+        &[\n+            Token::NewtypeVariant { name: \"Data\", variant: \"A\" },\n+            Token::Map { len: None },\n+            Token::Str(\"a\"),\n+            Token::I32(0),\n+            Token::Str(\"b\"),\n+            Token::I32(0),\n+            Token::MapEnd,\n+        ],\n+    );\n+}\n+\n+#[test]\n+fn test_internally_tagged_enum_containing_flatten() {\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    #[serde(tag = \"t\")]\n+    enum Data {\n+        A {\n+            a: i32,\n+            #[serde(flatten)]\n+            flat: Flat,\n+        }\n+    }\n+\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    struct Flat {\n+        b: i32,\n+    }\n+\n+    let data = Data::A {\n+        a: 0,\n+        flat: Flat {\n+            b: 0,\n+        }\n+    };\n+\n+    assert_tokens(\n+        &data,\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"t\"),\n+            Token::Str(\"A\"),\n+            Token::Str(\"a\"),\n+            Token::I32(0),\n+            Token::Str(\"b\"),\n+            Token::I32(0),\n+            Token::MapEnd,\n+        ],\n+    );\n+}\n+\n+#[test]\n+fn test_adjacently_tagged_enum_containing_flatten() {\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    #[serde(tag = \"t\", content = \"c\")]\n+    enum Data {\n+        A {\n+            a: i32,\n+            #[serde(flatten)]\n+            flat: Flat,\n+        }\n+    }\n+\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    struct Flat {\n+        b: i32,\n+    }\n+\n+    let data = Data::A {\n+        a: 0,\n+        flat: Flat {\n+            b: 0,\n+        }\n+    };\n+\n+    assert_tokens(\n+        &data,\n+        &[\n+            Token::Struct { name: \"Data\", len: 2 },\n+            Token::Str(\"t\"),\n+            Token::Str(\"A\"),\n+            Token::Str(\"c\"),\n+            Token::Map { len: None },\n+            Token::Str(\"a\"),\n+            Token::I32(0),\n+            Token::Str(\"b\"),\n+            Token::I32(0),\n+            Token::MapEnd,\n+            Token::StructEnd,\n+        ],\n+    );\n+}\n+\n+#[test]\n+fn test_untagged_enum_containing_flatten() {\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    #[serde(untagged)]\n+    enum Data {\n+        A {\n+            a: i32,\n+            #[serde(flatten)]\n+            flat: Flat,\n+        }\n+    }\n+\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    struct Flat {\n+        b: i32,\n+    }\n+\n+    let data = Data::A {\n+        a: 0,\n+        flat: Flat {\n+            b: 0,\n+        }\n+    };\n+\n+    assert_tokens(\n+        &data,\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"a\"),\n+            Token::I32(0),\n+            Token::Str(\"b\"),\n+            Token::I32(0),\n+            Token::MapEnd,\n+        ],\n+    );\n+}\n", "problem_statement": "Support flatten within struct variant\n```rust\r\n#[derive(Serialize, Deserialize)]\r\nenum Foo {\r\n    A {\r\n        #[serde(flatten)]\r\n        fields: HashMap<String, String>,\r\n    }\r\n}\r\n```\r\n\r\n```\r\nerror: proc-macro derive panicked\r\n --> src/main.rs:6:21\r\n  |\r\n6 | #[derive(Serialize, Deserialize)]\r\n  |                     ^^^^^^^^^^^\r\n  |\r\n  = help: message: #[serde(flatten)] cannot be used within enums\r\n```\n", "hints_text": "", "created_at": "2018-05-07T04:24:19Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1245, "instance_id": "serde-rs__serde-1245", "issue_numbers": ["1189"], "base_commit": "ed425b3a6f1854a9058902aee57263972321fa87", "patch": "diff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 826662dfa..0a5c487d7 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -1132,6 +1132,18 @@ pub trait Deserializer<'de>: Sized {\n     fn is_human_readable(&self) -> bool {\n         true\n     }\n+\n+    // Not public API.\n+    #[doc(hidden)]\n+    fn private_deserialize_internally_tagged_enum<V>(\n+        self,\n+        visitor: V,\n+    ) -> Result<V::Value, Self::Error>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        self.deserialize_any(visitor)\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\ndiff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex b05ecb962..58972f883 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -2715,6 +2715,20 @@ where\n         byte_buf option unit unit_struct seq tuple tuple_struct identifier\n         ignored_any\n     }\n+\n+    fn private_deserialize_internally_tagged_enum<V>(\n+        self,\n+        visitor: V,\n+    ) -> Result<V::Value, Self::Error>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        visitor.visit_map(FlatInternallyTaggedAccess {\n+            iter: self.0.iter_mut(),\n+            pending: None,\n+            _marker: PhantomData,\n+        })\n+    }\n }\n \n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n@@ -2786,3 +2800,44 @@ where\n         }\n     }\n }\n+\n+#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n+pub struct FlatInternallyTaggedAccess<'a, 'de: 'a, E> {\n+    iter: slice::IterMut<'a, Option<(Content<'de>, Content<'de>)>>,\n+    pending: Option<&'a Content<'de>>,\n+    _marker: PhantomData<E>,\n+}\n+\n+#[cfg(any(feature = \"std\", feature = \"alloc\"))]\n+impl<'a, 'de, E> MapAccess<'de> for FlatInternallyTaggedAccess<'a, 'de, E>\n+where\n+    E: Error,\n+{\n+    type Error = E;\n+\n+    fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+    where\n+        T: DeserializeSeed<'de>,\n+    {\n+        while let Some(item) = self.iter.next() {\n+            // Do not take(), instead borrow this entry. The internally tagged\n+            // enum does its own buffering so we can't tell whether this entry\n+            // is going to be consumed. Borrowing here leaves the entry\n+            // available for later flattened fields.\n+            let (ref key, ref content) = *item.as_ref().unwrap();\n+            self.pending = Some(content);\n+            return seed.deserialize(ContentRefDeserializer::new(key)).map(Some);\n+        }\n+        Ok(None)\n+    }\n+\n+    fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n+    where\n+        T: DeserializeSeed<'de>,\n+    {\n+        match self.pending.take() {\n+            Some(value) => seed.deserialize(ContentRefDeserializer::new(value)),\n+            None => panic!(\"value is missing\"),\n+        }\n+    }\n+}\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex d8970090e..f1a37b854 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -1193,7 +1193,7 @@ fn deserialize_internally_tagged_enum(\n \n         #variants_stmt\n \n-        let __tagged = try!(_serde::Deserializer::deserialize_any(\n+        let __tagged = try!(_serde::Deserializer::private_deserialize_internally_tagged_enum(\n             __deserializer,\n             _serde::private::de::TaggedContentVisitor::<__Field>::new(#tag)));\n \n", "test_patch": "diff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex 5e38ad34a..815a47b6a 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -1793,3 +1793,49 @@ fn test_flatten_enum_newtype() {\n         ],\n     );\n }\n+\n+#[test]\n+fn test_flatten_internally_tagged() {\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    struct S {\n+        #[serde(flatten)]\n+        x: X,\n+        #[serde(flatten)]\n+        y: Y,\n+    }\n+\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    #[serde(tag = \"typeX\")]\n+    enum X {\n+        A { a: i32 },\n+        B { b: i32 },\n+    }\n+\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    #[serde(tag = \"typeY\")]\n+    enum Y {\n+        C { c: i32 },\n+        D { d: i32 },\n+    }\n+\n+    let s = S {\n+        x: X::B { b: 1 },\n+        y: Y::D { d: 2 },\n+    };\n+\n+    assert_tokens(\n+        &s,\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"typeX\"),\n+            Token::Str(\"B\"),\n+            Token::Str(\"b\"),\n+            Token::I32(1),\n+            Token::Str(\"typeY\"),\n+            Token::Str(\"D\"),\n+            Token::Str(\"d\"),\n+            Token::I32(2),\n+            Token::MapEnd,\n+        ],\n+    );\n+}\n", "problem_statement": "Support deserializing a flattened internally tagged enum\nThis would be valuable to support if possible. Serialization already works but deserialization does not.\r\n\r\n```rust\r\n#[macro_use]\r\nextern crate serde_derive;\r\n\r\nextern crate serde;\r\nextern crate serde_json;\r\n\r\n#[derive(Serialize, Deserialize, Debug)]\r\nstruct Data {\r\n    id: i32,\r\n    #[serde(flatten)]\r\n    payload: Enum,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Debug)]\r\n#[serde(tag = \"type\")]\r\nenum Enum {\r\n    A(A),\r\n    B(B),\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Debug)]\r\nstruct A {\r\n    field_a: i32,\r\n}\r\n\r\n#[derive(Serialize, Deserialize, Debug)]\r\nstruct B {\r\n    field_b: i32,\r\n}\r\n\r\nfn main() {\r\n    let data = Data {\r\n        id: 0,\r\n        payload: Enum::A(A { field_a: 0 }),\r\n    };\r\n\r\n    let j = serde_json::to_string(&data).unwrap();\r\n    println!(\"{}\", j);\r\n\r\n    println!(\"{}\", serde_json::from_str::<Data>(&j).unwrap_err());\r\n}\r\n```\r\n\r\n```\r\n{\"id\":0,\"type\":\"A\",\"field_a\":0}\r\ncan only flatten structs and maps at line 1 column 31\r\n```\n", "hints_text": "", "created_at": "2018-05-06T04:43:11Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1241, "instance_id": "serde-rs__serde-1241", "issue_numbers": ["976"], "base_commit": "893c0578ddf4b692d10a44053805fad67fae2fdb", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex af3d3693e..1ad97006d 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -16,6 +16,7 @@ use bound;\n use fragment::{Expr, Fragment, Match, Stmts};\n use internals::ast::{Container, Data, Field, Style, Variant};\n use internals::{self, attr};\n+use pretend;\n use try;\n \n use std::collections::BTreeSet;\n@@ -37,11 +38,13 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<Tokens, Str\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n         let vis = &input.vis;\n+        let used = pretend::pretend_used(&cont);\n         quote! {\n             impl #de_impl_generics #ident #ty_generics #where_clause {\n                 #vis fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<#remote #ty_generics, __D::Error>\n                     where __D: _serde::Deserializer<#delife>\n                 {\n+                    #used\n                     #body\n                 }\n             }\ndiff --git a/serde_derive/src/lib.rs b/serde_derive/src/lib.rs\nindex e885968c1..2718f5f85 100644\n--- a/serde_derive/src/lib.rs\n+++ b/serde_derive/src/lib.rs\n@@ -49,6 +49,7 @@ mod bound;\n mod fragment;\n \n mod de;\n+mod pretend;\n mod ser;\n mod try;\n \ndiff --git a/serde_derive/src/pretend.rs b/serde_derive/src/pretend.rs\nnew file mode 100644\nindex 000000000..0af1b65c3\n--- /dev/null\n+++ b/serde_derive/src/pretend.rs\n@@ -0,0 +1,145 @@\n+use proc_macro2::Span;\n+use quote::Tokens;\n+use syn::Ident;\n+\n+use internals::ast::{Container, Data, Field, Style};\n+\n+// Suppress dead_code warnings that would otherwise appear when using a remote\n+// derive. Other than this pretend code, a struct annotated with remote derive\n+// never has its fields referenced and an enum annotated with remote derive\n+// never has its variants constructed.\n+//\n+//     warning: field is never used: `i`\n+//      --> src/main.rs:4:20\n+//       |\n+//     4 | struct StructDef { i: i32 }\n+//       |                    ^^^^^^\n+//\n+//     warning: variant is never constructed: `V`\n+//      --> src/main.rs:8:16\n+//       |\n+//     8 | enum EnumDef { V }\n+//       |                ^\n+//\n+pub fn pretend_used(cont: &Container) -> Tokens {\n+    let pretend_fields = pretend_fields_used(cont);\n+    let pretend_variants = pretend_variants_used(cont);\n+\n+    quote! {\n+        #pretend_fields\n+        #pretend_variants\n+    }\n+}\n+\n+// For structs with named fields, expands to:\n+//\n+//     match None::<T> {\n+//         Some(T { a: ref __v0, b: ref __v1 }) => {}\n+//         _ => {}\n+//     }\n+//\n+// For enums, expands to the following but only including struct variants:\n+//\n+//     match None::<T> {\n+//         Some(T::A { a: ref __v0 }) => {}\n+//         Some(T::B { b: ref __v0 }) => {}\n+//         _ => {}\n+//     }\n+//\n+// The `ref` is important in case the user has written a Drop impl on their\n+// type. Rust does not allow destructuring a struct or enum that has a Drop\n+// impl.\n+fn pretend_fields_used(cont: &Container) -> Tokens {\n+    let type_ident = cont.ident;\n+    let (_, ty_generics, _) = cont.generics.split_for_impl();\n+\n+    let patterns = match cont.data {\n+        Data::Enum(ref variants) => {\n+            variants.iter()\n+                .filter_map(|variant| match variant.style {\n+                    Style::Struct => {\n+                        let variant_ident = variant.ident;\n+                        let pat = struct_pattern(&variant.fields);\n+                        Some(quote!(#type_ident::#variant_ident #pat))\n+                    }\n+                    _ => None,\n+                })\n+                .collect::<Vec<_>>()\n+        }\n+        Data::Struct(Style::Struct, ref fields) => {\n+            let pat = struct_pattern(fields);\n+            vec![quote!(#type_ident #pat)]\n+        }\n+        Data::Struct(_, _) => {\n+            return quote!();\n+        }\n+    };\n+\n+    quote! {\n+        match _serde::export::None::<#type_ident #ty_generics> {\n+            #(\n+                _serde::export::Some(#patterns) => {}\n+            )*\n+            _ => {}\n+        }\n+    }\n+}\n+\n+// Expands to one of these per enum variant:\n+//\n+//     match None {\n+//         Some((__v0, __v1,)) => {\n+//             let _ = E::V { a: __v0, b: __v1 };\n+//         }\n+//         _ => {}\n+//     }\n+//\n+fn pretend_variants_used(cont: &Container) -> Tokens {\n+    let variants = match cont.data {\n+        Data::Enum(ref variants) => variants,\n+        Data::Struct(_, _) => {\n+            return quote!();\n+        }\n+    };\n+\n+    let type_ident = cont.ident;\n+    let (_, ty_generics, _) = cont.generics.split_for_impl();\n+    let turbofish = ty_generics.as_turbofish();\n+\n+    let cases = variants.iter()\n+        .map(|variant| {\n+            let variant_ident = variant.ident;\n+            let ref placeholders = (0..variant.fields.len())\n+                .map(|i| Ident::new(&format!(\"__v{}\", i), Span::call_site()))\n+                .collect::<Vec<_>>();\n+\n+            let pat = match variant.style {\n+                Style::Struct => {\n+                    let names = variant.fields.iter().map(|field| field.ident);\n+                    quote!({ #(#names: #placeholders),* })\n+                }\n+                Style::Tuple | Style::Newtype => {\n+                    quote!(( #(#placeholders),* ))\n+                }\n+                Style::Unit => quote!(),\n+            };\n+\n+            quote! {\n+                match _serde::export::None {\n+                    _serde::export::Some((#(#placeholders,)*)) => {\n+                        let _ = #type_ident::#variant_ident #turbofish #pat;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        });\n+\n+    quote!(#(#cases)*)\n+}\n+\n+fn struct_pattern(fields: &[Field]) -> Tokens {\n+    let names = fields.iter().map(|field| field.ident);\n+    let placeholders = (0..fields.len())\n+        .map(|i| Ident::new(&format!(\"__v{}\", i), Span::call_site()));\n+    quote!({ #(#names: ref #placeholders),* })\n+}\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 802aaf5cd..21c630a56 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -15,6 +15,7 @@ use bound;\n use fragment::{Fragment, Match, Stmts};\n use internals::ast::{Container, Data, Field, Style, Variant};\n use internals::{attr, Ctxt};\n+use pretend;\n use try;\n \n use std::u32;\n@@ -33,11 +34,13 @@ pub fn expand_derive_serialize(input: &syn::DeriveInput) -> Result<Tokens, Strin\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n         let vis = &input.vis;\n+        let used = pretend::pretend_used(&cont);\n         quote! {\n             impl #impl_generics #ident #ty_generics #where_clause {\n                 #vis fn serialize<__S>(__self: &#remote #ty_generics, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n                     where __S: _serde::Serializer\n                 {\n+                    #used\n                     #body\n                 }\n             }\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex e06ec5a88..d6921e148 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -333,9 +333,7 @@ fn test_gen() {\n     #[derive(Serialize, Deserialize)]\n     #[serde(untagged, remote = \"Or\")]\n     enum OrDef<A, B> {\n-        #[allow(dead_code)]\n         A(A),\n-        #[allow(dead_code)]\n         B(B),\n     }\n \ndiff --git a/test_suite/tests/test_remote.rs b/test_suite/tests/test_remote.rs\nindex da38ab1a1..e485bae32 100644\n--- a/test_suite/tests/test_remote.rs\n+++ b/test_suite/tests/test_remote.rs\n@@ -160,10 +160,8 @@ struct StructPrivDef {\n #[derive(Serialize, Deserialize)]\n #[serde(remote = \"remote::StructPub\")]\n struct StructPubDef {\n-    #[allow(dead_code)]\n     a: u8,\n \n-    #[allow(dead_code)]\n     #[serde(with = \"UnitDef\")]\n     b: remote::Unit,\n }\n", "problem_statement": "Types used in remote derive are dead code\nRemote derive structs exist only to tell serde_derive what are the fields of the real struct. As such, no code uses the fields of the remote derive struct.\r\n\r\n```rust\r\n#[macro_use]\r\nextern crate serde_derive;\r\n\r\nextern crate serde;\r\n\r\n#[derive(Serialize)]\r\n#[serde(remote = \"S\")]\r\nstruct SDef {\r\n    a: u32,\r\n}\r\n\r\nstruct S {\r\n    a: u32,\r\n}\r\n\r\n#[derive(Serialize)]\r\nstruct W {\r\n    #[serde(with = \"SDef\")]\r\n    s: S,\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\n```\r\nwarning: field is never used: `a`\r\n --> src/main.rs:9:5\r\n  |\r\n9 |     a: u32,\r\n  |     ^^^^^^\r\n  |\r\n  = note: #[warn(dead_code)] on by default\r\n```\r\n\r\nLet's emit some silly code along with the derive to use each field so the user doesn't need to put `#[allow(dead_code)]` on every remote derive struct.\n", "hints_text": "Things to be careful about:\r\n\r\n- Should work for non-public structs.\r\n- Should work for structs with fields of non-public type.\r\n- Should work for structs with generic type parameters.\r\n- Should work for structs with type parameters bound by a non-public trait.\r\n- Should work for structs with lifetime parameters.\r\n- All of the above but for enums.", "created_at": "2018-05-02T20:30:26Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1213, "instance_id": "serde-rs__serde-1213", "issue_numbers": ["1208"], "base_commit": "5efb22ebee128f1ec4a755556230bdd66c3f2026", "patch": "diff --git a/serde_derive/src/bound.rs b/serde_derive/src/bound.rs\nindex 4e7c7d71b..1506a9ba2 100644\n--- a/serde_derive/src/bound.rs\n+++ b/serde_derive/src/bound.rs\n@@ -50,18 +50,39 @@ pub fn with_where_predicates(\n     generics\n }\n \n-pub fn with_where_predicates_from_fields<F>(\n+pub fn with_where_predicates_from_fields<F, W>(\n     cont: &Container,\n     generics: &syn::Generics,\n+    trait_bound: &syn::Path,\n     from_field: F,\n+    gen_bound_where: W,\n ) -> syn::Generics\n where\n     F: Fn(&attr::Field) -> Option<&[syn::WherePredicate]>,\n+    W: Fn(&attr::Field) -> bool,\n {\n     let predicates = cont.data\n         .all_fields()\n-        .flat_map(|field| from_field(&field.attrs))\n-        .flat_map(|predicates| predicates.to_vec());\n+        .flat_map(|field| {\n+            let field_ty = field.ty;\n+            let matching_generic = |t: &syn::PathSegment, g: &syn::GenericParam| match *g {\n+                syn::GenericParam::Type(ref generic_ty)\n+                    if generic_ty.ident == t.ident => true,\n+                _ => false\n+            };\n+\n+            let mut field_bound: Option<syn::WherePredicate> = None;\n+            if let syn::Type::Path(ref ty_path) = *field_ty {\n+                field_bound = match (gen_bound_where(&field.attrs), ty_path.path.segments.first()) {\n+                    (true, Some(syn::punctuated::Pair::Punctuated(ref t, _))) =>\n+                        if generics.params.iter().any(|g| matching_generic(t, g)) {\n+                            Some(parse_quote!(#field_ty: #trait_bound))\n+                        } else {None},\n+                    (_, _) => None\n+                };\n+            }\n+            field_bound.into_iter().chain(from_field(&field.attrs).into_iter().flat_map(|predicates| predicates.to_vec()))\n+        });\n \n     let mut generics = generics.clone();\n     generics.make_where_clause()\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 941c624a1..f929397cd 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -124,7 +124,15 @@ impl Parameters {\n fn build_generics(cont: &Container, borrowed: &BorrowedLifetimes) -> syn::Generics {\n     let generics = bound::without_defaults(cont.generics);\n \n-    let generics = bound::with_where_predicates_from_fields(cont, &generics, attr::Field::de_bound);\n+    let delife = borrowed.de_lifetime();\n+    let de_bound = parse_quote!(_serde::Deserialize<#delife>);\n+    let generics = bound::with_where_predicates_from_fields(\n+        cont,\n+        &generics,\n+        &de_bound,\n+        attr::Field::de_bound,\n+        |field| field.deserialize_with().is_none() && !field.skip_deserializing()\n+    );\n \n     match cont.attrs.de_bound() {\n         Some(predicates) => bound::with_where_predicates(&generics, predicates),\n@@ -136,12 +144,11 @@ fn build_generics(cont: &Container, borrowed: &BorrowedLifetimes) -> syn::Generi\n                 attr::Default::None | attr::Default::Path(_) => generics,\n             };\n \n-            let delife = borrowed.de_lifetime();\n             let generics = bound::with_bound(\n                 cont,\n                 &generics,\n                 needs_deserialize_bound,\n-                &parse_quote!(_serde::Deserialize<#delife>),\n+                &de_bound,\n             );\n \n             bound::with_bound(\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 8bcacd6a4..7e37ca6b4 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -130,8 +130,14 @@ impl Parameters {\n fn build_generics(cont: &Container) -> syn::Generics {\n     let generics = bound::without_defaults(cont.generics);\n \n-    let generics =\n-        bound::with_where_predicates_from_fields(cont, &generics, attr::Field::ser_bound);\n+    let trait_bound = parse_quote!(_serde::Serialize);\n+    let generics = bound::with_where_predicates_from_fields(\n+        cont,\n+        &generics,\n+        &trait_bound,\n+        attr::Field::ser_bound,\n+        |field| field.serialize_with().is_none() && !field.skip_serializing()\n+    );\n \n     match cont.attrs.ser_bound() {\n         Some(predicates) => bound::with_where_predicates(&generics, predicates),\n@@ -139,7 +145,7 @@ fn build_generics(cont: &Container) -> syn::Generics {\n             cont,\n             &generics,\n             needs_serialize_bound,\n-            &parse_quote!(_serde::Serialize),\n+            &trait_bound\n         ),\n     }\n }\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 368403e77..aa5e0c4c8 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -539,6 +539,30 @@ fn test_gen() {\n         array: [u8; 256],\n     }\n     assert_ser::<BigArray>();\n+\n+    trait AssocSerde {\n+        type Assoc;\n+    }\n+\n+    struct NoSerdeImpl;\n+    impl AssocSerde for NoSerdeImpl {\n+        type Assoc = u32;\n+    }\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct AssocDerive<T: AssocSerde> {\n+        assoc: T::Assoc\n+    }\n+\n+    assert::<AssocDerive<NoSerdeImpl>>();\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct AssocDeriveMulti<S, T: AssocSerde> {\n+        s: S,\n+        assoc: T::Assoc,\n+    }\n+\n+    assert::<AssocDeriveMulti<i32, NoSerdeImpl>>();\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Infer correct trait bounds for use of a type parameter associated type\nThe following expands to `impl<T: Trait> Serialize for Struct<T>` which fails to compile.\r\n\r\n```rust\r\ntrait Trait {\r\n    type Assoc;\r\n}\r\n\r\n#[derive(Serialize)]\r\nstruct Struct<T: Trait> {\r\n    assoc: T::Assoc,\r\n}\r\n```\r\n\r\nThe builtin derives already get this partially right. For example `#[derive(Debug)]` on the above expands to `impl<T: Debug + Trait> Debug for Struct<T> where T::Assoc: Debug`. This is partially right because it has `T::Assoc: Debug`, but wrong because it also has `T: Debug`.\n", "hints_text": "", "created_at": "2018-04-10T15:26:14Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1205, "instance_id": "serde-rs__serde-1205", "issue_numbers": ["1188"], "base_commit": "9c659d9d869c2a175595cd62ea9460009df392c4", "patch": "diff --git a/serde_derive_internals/src/check.rs b/serde_derive_internals/src/check.rs\nindex 31980a398..6db99a173 100644\n--- a/serde_derive_internals/src/check.rs\n+++ b/serde_derive_internals/src/check.rs\n@@ -47,11 +47,20 @@ fn check_flatten(cx: &Ctxt, cont: &Container) {\n         Data::Enum(_) => {\n             assert!(!cont.attrs.has_flatten());\n         }\n-        Data::Struct(_, _) => {\n+        Data::Struct(style, _) => {\n             for field in cont.data.all_fields() {\n                 if !field.attrs.flatten() {\n                     continue;\n                 }\n+                match style {\n+                    Style::Tuple => {\n+                        cx.error(\"#[serde(flatten)] cannot be used on tuple structs\");\n+                    }\n+                    Style::Newtype => {\n+                        cx.error(\"#[serde(flatten)] cannot be used on newtype structs\");\n+                    }\n+                    _ => {}\n+                }\n                 if field.attrs.skip_serializing() {\n                     cx.error(\n                         \"#[serde(flatten] can not be combined with \\\n", "test_patch": "diff --git a/test_suite/tests/compile-fail/conflict/flatten-newtype-struct.rs b/test_suite/tests/compile-fail/conflict/flatten-newtype-struct.rs\nnew file mode 100644\nindex 000000000..07566f8c7\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/conflict/flatten-newtype-struct.rs\n@@ -0,0 +1,16 @@\n+// Copyright 2018 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: #[serde(flatten)] cannot be used on newtype structs\n+struct Foo(#[serde(flatten)] HashMap<String, String>);\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/conflict/flatten-tuple-struct.rs b/test_suite/tests/compile-fail/conflict/flatten-tuple-struct.rs\nnew file mode 100644\nindex 000000000..167bdbdac\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/conflict/flatten-tuple-struct.rs\n@@ -0,0 +1,16 @@\n+// Copyright 2018 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: #[serde(flatten)] cannot be used on tuple structs\n+struct Foo(u32, #[serde(flatten)] HashMap<String, String>);\n+\n+fn main() {}\n", "problem_statement": "Assertion failed: !cattrs.has_flatten()\nThis should have a better error message, ideally detected by serde_derive_internals.\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\nstruct Mitsuhiko(#[serde(flatten)] HashMap<String, String>);\r\n```\r\n\r\n```\r\nerror: proc-macro derive panicked\r\n  --> src/main.rs:18:10\r\n   |\r\n18 | #[derive(Deserialize)]\r\n   |          ^^^^^^^^^^^\r\n   |\r\n   = help: message: assertion failed: !cattrs.has_flatten()\r\n```\n", "hints_text": "", "created_at": "2018-04-01T20:12:09Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1204, "instance_id": "serde-rs__serde-1204", "issue_numbers": ["1185"], "base_commit": "9c659d9d869c2a175595cd62ea9460009df392c4", "patch": "diff --git a/serde_derive_internals/src/ast.rs b/serde_derive_internals/src/ast.rs\nindex fd531d8c7..fd742c9e5 100644\n--- a/serde_derive_internals/src/ast.rs\n+++ b/serde_derive_internals/src/ast.rs\n@@ -68,6 +68,9 @@ impl<'a> Container<'a> {\n             Data::Enum(ref mut variants) => for variant in variants {\n                 variant.attrs.rename_by_rule(attrs.rename_all());\n                 for field in &mut variant.fields {\n+                    if field.attrs.flatten() {\n+                        has_flatten = true;\n+                    }\n                     field.attrs.rename_by_rule(variant.attrs.rename_all());\n                 }\n             },\ndiff --git a/serde_derive_internals/src/check.rs b/serde_derive_internals/src/check.rs\nindex 31980a398..f6e1e2ff2 100644\n--- a/serde_derive_internals/src/check.rs\n+++ b/serde_derive_internals/src/check.rs\n@@ -45,7 +45,9 @@ fn check_getter(cx: &Ctxt, cont: &Container) {\n fn check_flatten(cx: &Ctxt, cont: &Container) {\n     match cont.data {\n         Data::Enum(_) => {\n-            assert!(!cont.attrs.has_flatten());\n+            if cont.attrs.has_flatten() {\n+                cx.error(\"#[serde(flatten)] cannot be used within enums\");\n+            }\n         }\n         Data::Struct(_, _) => {\n             for field in cont.data.all_fields() {\n", "test_patch": "diff --git a/test_suite/tests/compile-fail/conflict/flatten-within-enum.rs b/test_suite/tests/compile-fail/conflict/flatten-within-enum.rs\nnew file mode 100644\nindex 000000000..d2e007d26\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/conflict/flatten-within-enum.rs\n@@ -0,0 +1,21 @@\n+// Copyright 2018 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: #[serde(flatten)] cannot be used within enums\n+enum Foo {\n+    A {\n+        #[serde(flatten)]\n+        fields: HashMap<String, String>,\n+    }\n+}\n+\n+fn main() {}\n", "problem_statement": "Flatten inside a struct variant produces broken Serialize code\n```rust\r\n#[derive(Serialize)]\r\nenum Mitsuhiko {\r\n    A {\r\n        #[serde(flatten)]\r\n        fields: HashMap<String, String>,\r\n    }\r\n}\r\n```\r\n\r\n```\r\nerror[E0277]: the trait bound `<__S as _IMPL_SERIALIZE_FOR_Mitsuhiko::_serde::Serializer>::SerializeStructVariant: _IMPL_SERIALIZE_FOR_Mitsuhiko::_serde::ser::SerializeMap` is not satisfied\r\n --> src/main.rs:6:10\r\n  |\r\n6 | #[derive(Serialize)]\r\n  |          ^^^^^^^^^ the trait `_IMPL_SERIALIZE_FOR_Mitsuhiko::_serde::ser::SerializeMap` is not implemented for `<__S as _IMPL_SERIALIZE_FOR_Mitsuhiko::_serde::Serializer>::SerializeStructVariant`\r\n  |\r\n  = help: consider adding a `where <__S as _IMPL_SERIALIZE_FOR_Mitsuhiko::_serde::Serializer>::SerializeStructVariant: _IMPL_SERIALIZE_FOR_Mitsuhiko::_serde::ser::SerializeMap` bound\r\n  = note: required because of the requirements on the impl of `_IMPL_SERIALIZE_FOR_Mitsuhiko::_serde::Serializer` for `_IMPL_SERIALIZE_FOR_Mitsuhiko::_serde::private::ser::FlatMapSerializer<'_, <__S as _IMPL_SERIALIZE_FOR_Mitsuhiko::_serde::Serializer>::SerializeStructVariant>`\r\n  = note: required by `_IMPL_SERIALIZE_FOR_Mitsuhiko::_serde::Serialize::serialize`\r\n```\r\n\r\ncc @mitsuhiko \n", "hints_text": "", "created_at": "2018-04-01T20:02:11Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1140, "instance_id": "serde-rs__serde-1140", "issue_numbers": ["1139"], "base_commit": "16bc9fb99e20438f9f9cf5ea7aa7b8958f12d696", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex c9154321a..1e78d52af 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -6,7 +6,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syn::{self, Ident, Member};\n+use syn::{self, Ident, Index, Member};\n use syn::punctuated::Punctuated;\n use quote::{ToTokens, Tokens};\n use proc_macro2::{Literal, Span, Term};\n@@ -32,9 +32,10 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<Tokens, Str\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n         let vis = &input.vis;\n+        let fun = quote_spanned!(Span::call_site()=> deserialize);\n         quote! {\n             impl #de_impl_generics #ident #ty_generics #where_clause {\n-                #vis fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<#remote #ty_generics, __D::Error>\n+                #vis fn #fun<__D>(__deserializer: __D) -> _serde::export::Result<#remote #ty_generics, __D::Error>\n                     where __D: _serde::Deserializer<#delife>\n                 {\n                     #body\n@@ -562,14 +563,16 @@ fn deserialize_seq(\n         }\n     });\n \n+    // FIXME: parentheses around field values are because of\n+    // https://github.com/rust-lang/rust/issues/47311\n     let mut result = if is_struct {\n         let names = fields.iter().map(|f| &f.ident);\n-        quote! {\n-            #type_path { #( #names: #vars ),* }\n+        quote_spanned! {Span::call_site()=>\n+            #type_path { #( #names: (#vars) ),* }\n         }\n     } else {\n-        quote! {\n-            #type_path ( #(#vars),* )\n+        quote_spanned! {Span::call_site()=>\n+            #type_path ( #((#vars)),* )\n         }\n     };\n \n@@ -624,12 +627,16 @@ fn deserialize_seq_in_place(\n             let field_name = field\n                 .ident\n                 .map(Member::Named)\n-                .unwrap_or_else(|| Member::Unnamed(field_index.into()));\n+                .unwrap_or_else(|| Member::Unnamed(Index {\n+                    index: field_index as u32,\n+                    span: Span::call_site(),\n+                }));\n \n+            let dot = quote_spanned!(Span::call_site()=> .);\n             if field.attrs.skip_deserializing() {\n                 let default = Expr(expr_is_missing(field, cattrs));\n                 quote! {\n-                    self.place.#field_name = #default;\n+                    self.place #dot #field_name = #default;\n                 }\n             } else {\n                 let return_invalid_length = quote! {\n@@ -639,7 +646,7 @@ fn deserialize_seq_in_place(\n                     None => {\n                         quote! {\n                             if let _serde::export::None = try!(_serde::de::SeqAccess::next_element_seed(&mut __seq,\n-                                _serde::private::de::InPlaceSeed(&mut self.place.#field_name)))\n+                                _serde::private::de::InPlaceSeed(&mut self.place #dot #field_name)))\n                             {\n                                 #return_invalid_length\n                             }\n@@ -652,7 +659,7 @@ fn deserialize_seq_in_place(\n                             #wrapper\n                             match try!(_serde::de::SeqAccess::next_element::<#wrapper_ty>(&mut __seq)) {\n                                 _serde::export::Some(__wrap) => {\n-                                    self.place.#field_name = __wrap.value;\n+                                    self.place #dot #field_name = __wrap.value;\n                                 }\n                                 _serde::export::None => {\n                                     #return_invalid_length\n@@ -708,7 +715,9 @@ fn deserialize_newtype_struct(type_path: &Tokens, params: &Parameters, field: &F\n         }\n     };\n \n-    let mut result = quote!(#type_path(#value));\n+    // FIXME: parentheses around field values are because of\n+    // https://github.com/rust-lang/rust/issues/47311\n+    let mut result = quote_spanned!(Span::call_site()=> #type_path((#value)));\n     if params.has_getter {\n         let this = &params.this;\n         result = quote! {\n@@ -733,12 +742,13 @@ fn deserialize_newtype_struct_in_place(params: &Parameters, field: &Field) -> To\n \n     let delife = params.borrowed.de_lifetime();\n \n+    let elem = quote_spanned!(Span::call_site()=> .0);\n     quote! {\n         #[inline]\n         fn visit_newtype_struct<__E>(self, __e: __E) -> _serde::export::Result<Self::Value, __E::Error>\n             where __E: _serde::Deserializer<#delife>\n         {\n-            _serde::Deserialize::deserialize_in_place(__e, &mut self.place.0)\n+            _serde::Deserialize::deserialize_in_place(__e, &mut self.place #elem)\n         }\n     }\n }\n@@ -2039,13 +2049,15 @@ fn deserialize_map(\n             }\n         });\n \n+    // FIXME: parentheses around field values are because of\n+    // https://github.com/rust-lang/rust/issues/47311\n     let result = fields_names.iter().map(|&(field, ref name)| {\n         let ident = field.ident.expect(\"struct contains unnamed fields\");\n         if field.attrs.skip_deserializing() {\n             let value = Expr(expr_is_missing(field, cattrs));\n-            quote!(#ident: #value)\n+            quote_spanned!(Span::call_site()=> #ident: (#value))\n         } else {\n-            quote!(#ident: #name)\n+            quote_spanned!(Span::call_site()=> #ident: (#name))\n         }\n     });\n \n@@ -2063,7 +2075,7 @@ fn deserialize_map(\n         }\n     };\n \n-    let mut result = quote!(#struct_path { #(#result),* });\n+    let mut result = quote_spanned!(Span::call_site()=> #struct_path { #(#result),* });\n     if params.has_getter {\n         let this = &params.this;\n         result = quote! {\n@@ -2314,7 +2326,10 @@ fn wrap_deserialize_variant_with(\n     let (wrapper, wrapper_ty) =\n         wrap_deserialize_with(params, &quote!((#(#field_tys),*)), deserialize_with);\n \n-    let field_access = (0..variant.fields.len()).map(|n| Member::Unnamed(n.into()));\n+    let field_access = (0..variant.fields.len()).map(|n| Member::Unnamed(Index {\n+        index: n as u32,\n+        span: Span::call_site(),\n+    }));\n     let unwrap_fn = match variant.style {\n         Style::Struct => {\n             let field_idents = variant\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 32a6b1d40..55b33f73b 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -6,7 +6,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syn::{self, Ident, Member};\n+use syn::{self, Ident, Index, Member};\n use quote::Tokens;\n use proc_macro2::Span;\n \n@@ -31,9 +31,10 @@ pub fn expand_derive_serialize(input: &syn::DeriveInput) -> Result<Tokens, Strin\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n         let vis = &input.vis;\n+        let fun = quote_spanned!(Span::call_site()=> serialize);\n         quote! {\n             impl #impl_generics #ident #ty_generics #where_clause {\n-                #vis fn serialize<__S>(__self: &#remote #ty_generics, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n+                #vis fn #fun<__S>(__self: &#remote #ty_generics, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n                     where __S: _serde::Serializer\n                 {\n                     #body\n@@ -202,7 +203,10 @@ fn serialize_newtype_struct(\n ) -> Fragment {\n     let type_name = cattrs.name().serialize_name();\n \n-    let mut field_expr = get_member(params, field, &Member::Unnamed(0.into()));\n+    let mut field_expr = get_member(params, field, &Member::Unnamed(Index {\n+        index: 0,\n+        span: Span::call_site(),\n+    }));\n     if let Some(path) = field.attrs.serialize_with() {\n         field_expr = wrap_serialize_field_with(params, field.ty, path, &field_expr);\n     }\n@@ -817,7 +821,10 @@ fn serialize_tuple_struct_visitor(\n                 let id = Ident::new(&format!(\"__field{}\", i), Span::def_site());\n                 quote!(#id)\n             } else {\n-                get_member(params, field, &Member::Unnamed(i.into()))\n+                get_member(params, field, &Member::Unnamed(Index {\n+                    index: i as u32,\n+                    span: Span::call_site(),\n+                }))\n             };\n \n             let skip = field\n@@ -940,7 +947,10 @@ fn wrap_serialize_with(\n     };\n     let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n \n-    let field_access = (0..field_exprs.len()).map(|n| Member::Unnamed(n.into()));\n+    let field_access = (0..field_exprs.len()).map(|n| Member::Unnamed(Index {\n+        index: n as u32,\n+        span: Span::call_site(),\n+    }));\n \n     quote!({\n         struct __SerializeWith #wrapper_impl_generics #where_clause {\n@@ -981,11 +991,12 @@ fn get_member(params: &Parameters, field: &Field, member: &Member) -> Tokens {\n     let self_var = &params.self_var;\n     match (params.is_remote, field.attrs.getter()) {\n         (false, None) => {\n-            quote!(&#self_var.#member)\n+            quote_spanned!(Span::call_site()=> &#self_var.#member)\n         }\n         (true, None) => {\n+            let inner = quote_spanned!(Span::call_site()=> &#self_var.#member);\n             let ty = field.ty;\n-            quote!(_serde::private::ser::constrain::<#ty>(&#self_var.#member))\n+            quote!(_serde::private::ser::constrain::<#ty>(#inner))\n         }\n         (true, Some(getter)) => {\n             let ty = field.ty;\ndiff --git a/serde_derive_internals/Cargo.toml b/serde_derive_internals/Cargo.toml\nindex ac6011909..74888f379 100644\n--- a/serde_derive_internals/Cargo.toml\n+++ b/serde_derive_internals/Cargo.toml\n@@ -12,6 +12,7 @@ readme = \"README.md\"\n include = [\"Cargo.toml\", \"src/**/*.rs\", \"README.md\", \"LICENSE-APACHE\", \"LICENSE-MIT\"]\n \n [dependencies]\n+proc-macro2 = \"0.2\"\n syn = { version = \"0.12\", default-features = false, features = [\"derive\", \"parsing\", \"clone-impls\"] }\n \n [badges]\ndiff --git a/serde_derive_internals/src/attr.rs b/serde_derive_internals/src/attr.rs\nindex bfb7811ec..af1fbdecd 100644\n--- a/serde_derive_internals/src/attr.rs\n+++ b/serde_derive_internals/src/attr.rs\n@@ -8,12 +8,14 @@\n \n use Ctxt;\n use syn;\n+use syn::Ident;\n use syn::Meta::{List, NameValue, Word};\n use syn::NestedMeta::{Literal, Meta};\n use syn::punctuated::Punctuated;\n use syn::synom::Synom;\n use std::collections::BTreeSet;\n use std::str::FromStr;\n+use proc_macro2::Span;\n \n // This module handles parsing of `#[serde(...)]` attributes. The entrypoints\n // are `attr::Container::from_ast`, `attr::Variant::from_ast`, and\n@@ -577,10 +579,10 @@ impl Variant {\n                     Meta(NameValue(ref m)) if m.ident == \"with\" => {\n                         if let Ok(path) = parse_lit_into_path(cx, m.ident.as_ref(), &m.lit) {\n                             let mut ser_path = path.clone();\n-                            ser_path.segments.push(\"serialize\".into());\n+                            ser_path.segments.push(Ident::new(\"serialize\", Span::call_site()).into());\n                             serialize_with.set(ser_path);\n                             let mut de_path = path;\n-                            de_path.segments.push(\"deserialize\".into());\n+                            de_path.segments.push(Ident::new(\"deserialize\", Span::call_site()).into());\n                             deserialize_with.set(de_path);\n                         }\n                     }\n@@ -819,10 +821,10 @@ impl Field {\n                     Meta(NameValue(ref m)) if m.ident == \"with\" => {\n                         if let Ok(path) = parse_lit_into_path(cx, m.ident.as_ref(), &m.lit) {\n                             let mut ser_path = path.clone();\n-                            ser_path.segments.push(\"serialize\".into());\n+                            ser_path.segments.push(Ident::new(\"serialize\", Span::call_site()).into());\n                             serialize_with.set(ser_path);\n                             let mut de_path = path;\n-                            de_path.segments.push(\"deserialize\".into());\n+                            de_path.segments.push(Ident::new(\"deserialize\", Span::call_site()).into());\n                             deserialize_with.set(de_path);\n                         }\n                     }\n@@ -911,10 +913,24 @@ impl Field {\n             //     impl<'de: 'a, 'a> Deserialize<'de> for Cow<'a, str>\n             //     impl<'de: 'a, 'a> Deserialize<'de> for Cow<'a, [u8]>\n             if is_cow(&field.ty, is_str) {\n-                let path = syn::parse_str(\"_serde::private::de::borrow_cow_str\").unwrap();\n+                let mut path = syn::Path {\n+                    leading_colon: None,\n+                    segments: Punctuated::new(),\n+                };\n+                path.segments.push(Ident::new(\"_serde\", Span::def_site()).into());\n+                path.segments.push(Ident::new(\"private\", Span::def_site()).into());\n+                path.segments.push(Ident::new(\"de\", Span::def_site()).into());\n+                path.segments.push(Ident::new(\"borrow_cow_str\", Span::def_site()).into());\n                 deserialize_with.set_if_none(path);\n             } else if is_cow(&field.ty, is_slice_u8) {\n-                let path = syn::parse_str(\"_serde::private::de::borrow_cow_bytes\").unwrap();\n+                let mut path = syn::Path {\n+                    leading_colon: None,\n+                    segments: Punctuated::new(),\n+                };\n+                path.segments.push(Ident::new(\"_serde\", Span::def_site()).into());\n+                path.segments.push(Ident::new(\"private\", Span::def_site()).into());\n+                path.segments.push(Ident::new(\"de\", Span::def_site()).into());\n+                path.segments.push(Ident::new(\"borrow_cow_bytes\", Span::def_site()).into());\n                 deserialize_with.set_if_none(path);\n             }\n         } else if is_rptr(&field.ty, is_str) || is_rptr(&field.ty, is_slice_u8) {\ndiff --git a/serde_derive_internals/src/lib.rs b/serde_derive_internals/src/lib.rs\nindex dd19ecaf4..c1630a9e7 100644\n--- a/serde_derive_internals/src/lib.rs\n+++ b/serde_derive_internals/src/lib.rs\n@@ -12,6 +12,8 @@\n #[macro_use]\n extern crate syn;\n \n+extern crate proc_macro2;\n+\n pub mod ast;\n pub mod attr;\n \ndiff --git a/travis.sh b/travis.sh\nindex c498462ee..4ef4931b7 100755\n--- a/travis.sh\n+++ b/travis.sh\n@@ -55,6 +55,7 @@ else\n     channel build\n     cd \"$DIR/test_suite\"\n     channel test --features unstable\n+    channel build --tests --features proc-macro2/nightly\n     if [ -z \"${APPVEYOR}\" ]; then\n         cd \"$DIR/test_suite/no_std\"\n         channel build\n", "test_patch": "diff --git a/test_suite/Cargo.toml b/test_suite/Cargo.toml\nindex 50e10e360..23a9fd79d 100644\n--- a/test_suite/Cargo.toml\n+++ b/test_suite/Cargo.toml\n@@ -9,6 +9,7 @@ unstable = [\"serde/unstable\", \"compiletest_rs\"]\n \n [dev-dependencies]\n fnv = \"1.0\"\n+proc-macro2 = \"0.2\"\n rustc-serialize = \"0.3.16\"\n serde = { path = \"../serde\", features = [\"rc\"] }\n serde_derive = { path = \"../serde_derive\", features = [\"deserialize_in_place\"] }\n", "problem_statement": "Tuple structs with private fields do not work with proc-macro2/nightly\nThe test suite does not compile, lots of errors like this:\r\n\r\n```rust\r\n#[derive(Serialize)]\r\nstruct S(u8);\r\n```\r\n\r\n```\r\nerror[E0611]: field `0` of tuple-struct `S` is private\r\n --> src/main.rs:8:10\r\n  |\r\n8 | #[derive(Serialize)]\r\n  |          ^^^^^^^^^\r\n```\n", "hints_text": "", "created_at": "2018-01-10T06:23:55Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1124, "instance_id": "serde-rs__serde-1124", "issue_numbers": ["1122"], "base_commit": "0b89bc920e6052c05483c8b56661e859caae9d25", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 87aa6c684..ddd1997cd 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -15,7 +15,7 @@ use de::{Deserialize, Deserializer, EnumAccess, Error, SeqAccess, Unexpected, Va\n use de::MapAccess;\n \n use de::from_primitive::FromPrimitive;\n-use private::de::DeserializeFromSeed;\n+use private::de::InPlaceSeed;\n \n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n use private::de::size_hint;\n@@ -213,7 +213,7 @@ impl<'de> Deserialize<'de> for char {\n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n struct StringVisitor;\n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n-struct StringFromVisitor<'a>(&'a mut String);\n+struct StringInPlaceVisitor<'a>(&'a mut String);\n \n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n impl<'de> Visitor<'de> for StringVisitor {\n@@ -259,7 +259,7 @@ impl<'de> Visitor<'de> for StringVisitor {\n }\n \n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n-impl<'a, 'de> Visitor<'de> for StringFromVisitor<'a> {\n+impl<'a, 'de> Visitor<'de> for StringInPlaceVisitor<'a> {\n     type Value = ();\n \n     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n@@ -320,11 +320,11 @@ impl<'de> Deserialize<'de> for String {\n         deserializer.deserialize_string(StringVisitor)\n     }\n \n-    fn deserialize_from<D>(&mut self, deserializer: D) -> Result<(), D::Error>\n+    fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n     where\n         D: Deserializer<'de>,\n     {\n-        deserializer.deserialize_string(StringFromVisitor(self))\n+        deserializer.deserialize_string(StringInPlaceVisitor(place))\n     }\n }\n \n@@ -533,10 +533,10 @@ where\n     }\n \n     // The Some variant's repr is opaque, so we can't play cute tricks with its\n-    // tag to have deserialize_from build the content in place unconditionally.\n+    // tag to have deserialize_in_place build the content in place unconditionally.\n     //\n     // FIXME: investigate whether branching on the old value being Some to\n-    // deserialize_from the value is profitable (probably data-dependent?)\n+    // deserialize_in_place the value is profitable (probably data-dependent?)\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -627,13 +627,13 @@ macro_rules! seq_impl {\n                 deserializer.deserialize_seq(visitor)\n             }\n \n-            fn deserialize_from<D>(&mut self, deserializer: D) -> Result<(), D::Error>\n+            fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n             where\n                 D: Deserializer<'de>,\n             {\n-                struct SeqVisitor<'a, T: 'a $(, $typaram: 'a)*>(&'a mut $ty<T $(, $typaram)*>);\n+                struct SeqInPlaceVisitor<'a, T: 'a $(, $typaram: 'a)*>(&'a mut $ty<T $(, $typaram)*>);\n \n-                impl<'a, 'de, T $(, $typaram)*> Visitor<'de> for SeqVisitor<'a, T $(, $typaram)*>\n+                impl<'a, 'de, T $(, $typaram)*> Visitor<'de> for SeqInPlaceVisitor<'a, T $(, $typaram)*>\n                 where\n                     T: Deserialize<'de> $(+ $tbound1 $(+ $tbound2)*)*,\n                     $($typaram: $bound1 $(+ $bound2)*,)*\n@@ -661,7 +661,7 @@ macro_rules! seq_impl {\n                     }\n                 }\n \n-                deserializer.deserialize_seq(SeqVisitor(self))\n+                deserializer.deserialize_seq(SeqInPlaceVisitor(place))\n             }\n         }\n     }\n@@ -736,7 +736,7 @@ seq_impl!(\n struct ArrayVisitor<A> {\n     marker: PhantomData<A>,\n }\n-struct ArrayFromVisitor<'a, A: 'a>(&'a mut A);\n+struct ArrayInPlaceVisitor<'a, A: 'a>(&'a mut A);\n \n impl<A> ArrayVisitor<A> {\n     fn new() -> Self {\n@@ -799,7 +799,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            impl<'a, 'de, T> Visitor<'de> for ArrayFromVisitor<'a, [T; $len]>\n+            impl<'a, 'de, T> Visitor<'de> for ArrayInPlaceVisitor<'a, [T; $len]>\n             where\n                 T: Deserialize<'de>,\n             {\n@@ -816,7 +816,7 @@ macro_rules! array_impls {\n                 {\n                     let mut fail_idx = None;\n                     for (idx, dest) in self.0[..].iter_mut().enumerate() {\n-                        if try!(seq.next_element_seed(DeserializeFromSeed(dest))).is_none() {\n+                        if try!(seq.next_element_seed(InPlaceSeed(dest))).is_none() {\n                             fail_idx = Some(idx);\n                             break;\n                         }\n@@ -839,11 +839,11 @@ macro_rules! array_impls {\n                     deserializer.deserialize_tuple($len, ArrayVisitor::<[T; $len]>::new())\n                 }\n \n-                fn deserialize_from<D>(&mut self, deserializer: D) -> Result<(), D::Error>\n+                fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n                 where\n                     D: Deserializer<'de>,\n                 {\n-                    deserializer.deserialize_tuple($len, ArrayFromVisitor(self))\n+                    deserializer.deserialize_tuple($len, ArrayInPlaceVisitor(place))\n                 }\n             }\n         )+\n@@ -928,13 +928,13 @@ macro_rules! tuple_impls {\n                 }\n \n                 #[inline]\n-                fn deserialize_from<D>(&mut self, deserializer: D) -> Result<(), D::Error>\n+                fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n                 where\n                     D: Deserializer<'de>,\n                 {\n-                    struct TupleVisitor<'a, $($name: 'a,)+>(&'a mut ($($name,)+));\n+                    struct TupleInPlaceVisitor<'a, $($name: 'a,)+>(&'a mut ($($name,)+));\n \n-                    impl<'a, 'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleVisitor<'a, $($name,)+> {\n+                    impl<'a, 'de, $($name: Deserialize<'de>),+> Visitor<'de> for TupleInPlaceVisitor<'a, $($name,)+> {\n                         type Value = ();\n \n                         fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n@@ -948,7 +948,7 @@ macro_rules! tuple_impls {\n                             A: SeqAccess<'de>,\n                         {\n                             $(\n-                                if try!(seq.next_element_seed(DeserializeFromSeed(&mut (self.0).$n))).is_none() {\n+                                if try!(seq.next_element_seed(InPlaceSeed(&mut (self.0).$n))).is_none() {\n                                     return Err(Error::invalid_length($n, &self));\n                                 }\n                             )+\n@@ -957,7 +957,7 @@ macro_rules! tuple_impls {\n                         }\n                     }\n \n-                    deserializer.deserialize_tuple($len, TupleVisitor(self))\n+                    deserializer.deserialize_tuple($len, TupleInPlaceVisitor(place))\n                 }\n             }\n         )+\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 219907bda..0403e5d16 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -518,18 +518,18 @@ pub trait Deserialize<'de>: Sized {\n     /// when the next deserialization occurs.\n     ///\n     /// If you manually implement this, your recursive deserializations should\n-    /// use `deserialize_from`.\n+    /// use `deserialize_in_place`.\n     ///\n     /// This method is stable and an official public API, but hidden from the\n     /// documentation because it is almost never what newbies are looking for.\n     /// Showing it in rustdoc would cause it to be featured more prominently\n     /// than it deserves.\n     #[doc(hidden)]\n-    fn deserialize_from<D>(&mut self, deserializer: D) -> Result<(), D::Error>\n+    fn deserialize_in_place<D>(deserializer: D, place: &mut Self) -> Result<(), D::Error>\n         where D: Deserializer<'de>\n     {\n         // Default implementation just delegates to `deserialize` impl.\n-        *self = Deserialize::deserialize(deserializer)?;\n+        *place = Deserialize::deserialize(deserializer)?;\n         Ok(())\n     }\n }\ndiff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex a3134e69f..884dd70b6 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -2010,12 +2010,12 @@ where\n     }\n }\n \n-/// A DeserializeSeed helper for implementing deserialize_from Visitors.\n+/// A DeserializeSeed helper for implementing deserialize_in_place Visitors.\n ///\n-/// Wraps a mutable reference and calls deserialize_from on it.\n-pub struct DeserializeFromSeed<'a, T: 'a>(pub &'a mut T);\n+/// Wraps a mutable reference and calls deserialize_in_place on it.\n+pub struct InPlaceSeed<'a, T: 'a>(pub &'a mut T);\n \n-impl<'a, 'de, T> DeserializeSeed<'de> for DeserializeFromSeed<'a, T>\n+impl<'a, 'de, T> DeserializeSeed<'de> for InPlaceSeed<'a, T>\n     where T: Deserialize<'de>,\n {\n     type Value = ();\n@@ -2023,6 +2023,6 @@ impl<'a, 'de, T> DeserializeSeed<'de> for DeserializeFromSeed<'a, T>\n     where\n         D: Deserializer<'de>,\n     {\n-       self.0.deserialize_from(deserializer)\n+        T::deserialize_in_place(deserializer, self.0)\n     }\n }\ndiff --git a/serde_derive/Cargo.toml b/serde_derive/Cargo.toml\nindex a93411c14..79a540372 100644\n--- a/serde_derive/Cargo.toml\n+++ b/serde_derive/Cargo.toml\n@@ -16,7 +16,7 @@ travis-ci = { repository = \"serde-rs/serde\" }\n \n [features]\n default = []\n-deserialize_from = []\n+deserialize_in_place = []\n \n [lib]\n name = \"serde_derive\"\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex dbe5a1934..1c985211a 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -40,7 +40,7 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<Tokens, Str\n             }\n         }\n     } else {\n-        let fn_deserialize_from = deserialize_from_body(&cont, &params);\n+        let fn_deserialize_in_place = deserialize_in_place_body(&cont, &params);\n \n         quote! {\n             #[automatically_derived]\n@@ -51,7 +51,7 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<Tokens, Str\n                     #body\n                 }\n \n-                #fn_deserialize_from\n+                #fn_deserialize_in_place\n             }\n         }\n     };\n@@ -249,10 +249,10 @@ fn deserialize_body(cont: &Container, params: &Parameters) -> Fragment {\n     }\n }\n \n-#[cfg(feature = \"deserialize_from\")]\n-fn deserialize_from_body(cont: &Container, params: &Parameters) -> Option<Stmts> {\n-    // Only remote derives have getters, and we do not generate deserialize_from\n-    // for remote derives.\n+#[cfg(feature = \"deserialize_in_place\")]\n+fn deserialize_in_place_body(cont: &Container, params: &Parameters) -> Option<Stmts> {\n+    // Only remote derives have getters, and we do not generate\n+    // deserialize_in_place for remote derives.\n     assert!(!params.has_getter);\n \n     if cont.attrs.from_type().is_some()\n@@ -264,11 +264,11 @@ fn deserialize_from_body(cont: &Container, params: &Parameters) -> Option<Stmts>\n \n     let code = match cont.body {\n         Body::Struct(Style::Struct, ref fields) => {\n-            deserialize_from_struct(None, params, fields, &cont.attrs, None, Untagged::No)\n+            deserialize_struct_in_place(None, params, fields, &cont.attrs, None, Untagged::No)\n         }\n         Body::Struct(Style::Tuple, ref fields) |\n         Body::Struct(Style::Newtype, ref fields) => {\n-            deserialize_from_tuple(None, params, fields, &cont.attrs, None)\n+            deserialize_tuple_in_place(None, params, fields, &cont.attrs, None)\n         }\n         Body::Enum(_) | Body::Struct(Style::Unit, _) => {\n             return None;\n@@ -278,19 +278,19 @@ fn deserialize_from_body(cont: &Container, params: &Parameters) -> Option<Stmts>\n     let delife = params.borrowed.de_lifetime();\n     let stmts = Stmts(code);\n \n-    let fn_deserialize_from = quote_block! {\n-        fn deserialize_from<__D>(&mut self, __deserializer: __D) -> _serde::export::Result<(), __D::Error>\n+    let fn_deserialize_in_place = quote_block! {\n+        fn deserialize_in_place<__D>(__deserializer: __D, __place: &mut Self) -> _serde::export::Result<(), __D::Error>\n             where __D: _serde::Deserializer<#delife>\n         {\n             #stmts\n         }\n     };\n \n-    Some(Stmts(fn_deserialize_from))\n+    Some(Stmts(fn_deserialize_in_place))\n }\n \n-#[cfg(not(feature = \"deserialize_from\"))]\n-fn deserialize_from_body(_cont: &Container, _params: &Parameters) -> Option<Stmts> {\n+#[cfg(not(feature = \"deserialize_in_place\"))]\n+fn deserialize_in_place_body(_cont: &Container, _params: &Parameters) -> Option<Stmts> {\n     None\n }\n \n@@ -425,8 +425,8 @@ fn deserialize_tuple(\n     }\n }\n \n-#[cfg(feature = \"deserialize_from\")]\n-fn deserialize_from_tuple(\n+#[cfg(feature = \"deserialize_in_place\")]\n+fn deserialize_tuple_in_place(\n     variant_ident: Option<&syn::Ident>,\n     params: &Parameters,\n     fields: &[Field],\n@@ -446,16 +446,16 @@ fn deserialize_from_tuple(\n     let nfields = fields.len();\n \n     let visit_newtype_struct = if !is_enum && nfields == 1 {\n-        Some(deserialize_from_newtype_struct(params, &fields[0]))\n+        Some(deserialize_newtype_struct_in_place(params, &fields[0]))\n     } else {\n         None\n     };\n \n-    let visit_seq = Stmts(deserialize_from_seq(params, fields, cattrs));\n+    let visit_seq = Stmts(deserialize_seq_in_place(params, fields, cattrs));\n \n     let visitor_expr = quote! {\n         __Visitor {\n-            dest: self,\n+            place: __place,\n             lifetime: _serde::export::PhantomData,\n         }\n     };\n@@ -481,17 +481,17 @@ fn deserialize_from_tuple(\n         quote!(mut __seq)\n     };\n \n-    let de_from_impl_generics = de_impl_generics.with_dest();\n-    let de_from_ty_generics = de_ty_generics.with_dest();\n-    let dest_life = dest_lifetime();\n+    let in_place_impl_generics = de_impl_generics.in_place();\n+    let in_place_ty_generics = de_ty_generics.in_place();\n+    let place_life = place_lifetime();\n \n     quote_block! {\n-        struct __Visitor #de_from_impl_generics #where_clause {\n-            dest: &#dest_life mut #this #ty_generics,\n+        struct __Visitor #in_place_impl_generics #where_clause {\n+            place: &#place_life mut #this #ty_generics,\n             lifetime: _serde::export::PhantomData<&#delife ()>,\n         }\n \n-        impl #de_from_impl_generics _serde::de::Visitor<#delife> for __Visitor #de_from_ty_generics #where_clause {\n+        impl #in_place_impl_generics _serde::de::Visitor<#delife> for __Visitor #in_place_ty_generics #where_clause {\n             type Value = ();\n \n             fn expecting(&self, formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n@@ -612,8 +612,8 @@ fn deserialize_seq(\n     }\n }\n \n-#[cfg(feature = \"deserialize_from\")]\n-fn deserialize_from_seq(\n+#[cfg(feature = \"deserialize_in_place\")]\n+fn deserialize_seq_in_place(\n     params: &Parameters,\n     fields: &[Field],\n     cattrs: &attr::Container,\n@@ -636,7 +636,7 @@ fn deserialize_from_seq(\n             if field.attrs.skip_deserializing() {\n                 let default = Expr(expr_is_missing(&field, cattrs));\n                 quote! {\n-                    self.dest.#field_name = #default;\n+                    self.place.#field_name = #default;\n                 }\n             } else {\n                 let return_invalid_length = quote! {\n@@ -646,7 +646,7 @@ fn deserialize_from_seq(\n                     None => {\n                         quote! {\n                             if let _serde::export::None = try!(_serde::de::SeqAccess::next_element_seed(&mut __seq,\n-                                _serde::private::de::DeserializeFromSeed(&mut self.dest.#field_name)))\n+                                _serde::private::de::InPlaceSeed(&mut self.place.#field_name)))\n                             {\n                                 #return_invalid_length\n                             }\n@@ -659,7 +659,7 @@ fn deserialize_from_seq(\n                             #wrapper\n                             match try!(_serde::de::SeqAccess::next_element::<#wrapper_ty>(&mut __seq)) {\n                                 _serde::export::Some(__wrap) => {\n-                                    self.dest.#field_name = __wrap.value;\n+                                    self.place.#field_name = __wrap.value;\n                                 }\n                                 _serde::export::None => {\n                                     #return_invalid_length\n@@ -741,12 +741,12 @@ fn deserialize_newtype_struct(type_path: &Tokens, params: &Parameters, field: &F\n     }\n }\n \n-#[cfg(feature = \"deserialize_from\")]\n-fn deserialize_from_newtype_struct(\n+#[cfg(feature = \"deserialize_in_place\")]\n+fn deserialize_newtype_struct_in_place(\n     params: &Parameters,\n     field: &Field\n ) -> Tokens {\n-    // We do not generate deserialize_from if every field has a deserialize_with.\n+    // We do not generate deserialize_in_place if every field has a deserialize_with.\n     assert!(field.attrs.deserialize_with().is_none());\n \n     let delife = params.borrowed.de_lifetime();\n@@ -756,7 +756,7 @@ fn deserialize_from_newtype_struct(\n         fn visit_newtype_struct<__E>(self, __e: __E) -> _serde::export::Result<Self::Value, __E::Error>\n             where __E: _serde::Deserializer<#delife>\n         {\n-            _serde::Deserialize::deserialize_from(&mut self.dest.0, __e)\n+            _serde::Deserialize::deserialize_in_place(__e, &mut self.place.0)\n         }\n     }\n }\n@@ -883,8 +883,8 @@ fn deserialize_struct(\n     }\n }\n \n-#[cfg(feature = \"deserialize_from\")]\n-fn deserialize_from_struct(\n+#[cfg(feature = \"deserialize_in_place\")]\n+fn deserialize_struct_in_place(\n     variant_ident: Option<&syn::Ident>,\n     params: &Parameters,\n     fields: &[Field],\n@@ -903,17 +903,17 @@ fn deserialize_from_struct(\n         None => format!(\"struct {}\", params.type_name()),\n     };\n \n-    let visit_seq = Stmts(deserialize_from_seq(params, fields, cattrs));\n+    let visit_seq = Stmts(deserialize_seq_in_place(params, fields, cattrs));\n \n     let (field_visitor, fields_stmt, visit_map) =\n-        deserialize_from_struct_visitor(params, fields, cattrs);\n+        deserialize_struct_in_place_visitor(params, fields, cattrs);\n     let field_visitor = Stmts(field_visitor);\n     let fields_stmt = Stmts(fields_stmt);\n     let visit_map = Stmts(visit_map);\n \n     let visitor_expr = quote! {\n         __Visitor {\n-            dest: self,\n+            place: __place,\n             lifetime: _serde::export::PhantomData,\n         }\n     };\n@@ -958,19 +958,19 @@ fn deserialize_from_struct(\n         }\n     };\n \n-    let de_from_impl_generics = de_impl_generics.with_dest();\n-    let de_from_ty_generics = de_ty_generics.with_dest();\n-    let dest_life = dest_lifetime();\n+    let in_place_impl_generics = de_impl_generics.in_place();\n+    let in_place_ty_generics = de_ty_generics.in_place();\n+    let place_life = place_lifetime();\n \n     quote_block! {\n         #field_visitor\n \n-        struct __Visitor #de_from_impl_generics #where_clause {\n-            dest: &#dest_life mut #this #ty_generics,\n+        struct __Visitor #in_place_impl_generics #where_clause {\n+            place: &#place_life mut #this #ty_generics,\n             lifetime: _serde::export::PhantomData<&#delife ()>,\n         }\n \n-        impl #de_from_impl_generics _serde::de::Visitor<#delife> for __Visitor #de_from_ty_generics #where_clause {\n+        impl #in_place_impl_generics _serde::de::Visitor<#delife> for __Visitor #in_place_ty_generics #where_clause {\n             type Value = ();\n \n             fn expecting(&self, formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n@@ -2121,8 +2121,8 @@ fn deserialize_map(\n     }\n }\n \n-#[cfg(feature = \"deserialize_from\")]\n-fn deserialize_from_struct_visitor(\n+#[cfg(feature = \"deserialize_in_place\")]\n+fn deserialize_struct_in_place_visitor(\n     params: &Parameters,\n     fields: &[Field],\n     cattrs: &attr::Container,\n@@ -2143,13 +2143,13 @@ fn deserialize_from_struct_visitor(\n \n     let field_visitor = deserialize_generated_identifier(field_names_idents, cattrs, false);\n \n-    let visit_map = deserialize_from_map(params, fields, cattrs);\n+    let visit_map = deserialize_map_in_place(params, fields, cattrs);\n \n     (field_visitor, fields_stmt, visit_map)\n }\n \n-#[cfg(feature = \"deserialize_from\")]\n-fn deserialize_from_map(\n+#[cfg(feature = \"deserialize_in_place\")]\n+fn deserialize_map_in_place(\n     params: &Parameters,\n     fields: &[Field],\n     cattrs: &attr::Container,\n@@ -2161,7 +2161,7 @@ fn deserialize_from_map(\n         .map(|(i, field)| (field, field_i(i)))\n         .collect();\n \n-    // For deserialize_from, declare booleans for each field that will be deserialized.\n+    // For deserialize_in_place, declare booleans for each field that will be deserialized.\n     let let_flags = fields_names\n         .iter()\n         .filter(|&&(field, _)| !field.attrs.skip_deserializing())\n@@ -2183,7 +2183,7 @@ fn deserialize_from_map(\n             let visit = match field.attrs.deserialize_with() {\n                 None => {\n                     quote! {\n-                        try!(_serde::de::MapAccess::next_value_seed(&mut __map, _serde::private::de::DeserializeFromSeed(&mut self.dest.#field_name)))\n+                        try!(_serde::de::MapAccess::next_value_seed(&mut __map, _serde::private::de::InPlaceSeed(&mut self.place.#field_name)))\n                     }\n                 }\n                 Some(path) => {\n@@ -2191,7 +2191,7 @@ fn deserialize_from_map(\n                         params, field.ty, path);\n                     quote!({\n                         #wrapper\n-                        self.dest.#field_name = try!(_serde::de::MapAccess::next_value::<#wrapper_ty>(&mut __map)).value\n+                        self.place.#field_name = try!(_serde::de::MapAccess::next_value::<#wrapper_ty>(&mut __map)).value\n                     })\n                 }\n             };\n@@ -2245,7 +2245,7 @@ fn deserialize_from_map(\n             |&(field, ref name)| {\n                 let missing_expr = expr_is_missing(&field, cattrs);\n                 // If missing_expr unconditionally returns an error, don't try\n-                // to assign its value to self.dest. Maybe this could be handled\n+                // to assign its value to self.place. Maybe this could be handled\n                 // more elegantly.\n                 if missing_expr.as_ref().as_str().starts_with(\"return \") {\n                     let missing_expr = Stmts(missing_expr);\n@@ -2259,7 +2259,7 @@ fn deserialize_from_map(\n                     let missing_expr = Expr(missing_expr);\n                     quote! {\n                         if !#name {\n-                            self.dest.#field_name = #missing_expr;\n+                            self.place.#field_name = #missing_expr;\n                         };\n                     }\n                 }\n@@ -2442,8 +2442,8 @@ fn expr_is_missing(field: &Field, cattrs: &attr::Container) -> Fragment {\n }\n \n struct DeImplGenerics<'a>(&'a Parameters);\n-#[cfg(feature = \"deserialize_from\")]\n-struct DeFromImplGenerics<'a>(&'a Parameters);\n+#[cfg(feature = \"deserialize_in_place\")]\n+struct InPlaceImplGenerics<'a>(&'a Parameters);\n \n impl<'a> ToTokens for DeImplGenerics<'a> {\n     fn to_tokens(&self, tokens: &mut Tokens) {\n@@ -2456,20 +2456,20 @@ impl<'a> ToTokens for DeImplGenerics<'a> {\n     }\n }\n \n-#[cfg(feature = \"deserialize_from\")]\n-impl<'a> ToTokens for DeFromImplGenerics<'a> {\n+#[cfg(feature = \"deserialize_in_place\")]\n+impl<'a> ToTokens for InPlaceImplGenerics<'a> {\n     fn to_tokens(&self, tokens: &mut Tokens) {\n-        let dest_lifetime = dest_lifetime();\n+        let place_lifetime = place_lifetime();\n         let mut generics = self.0.generics.clone();\n \n-        // Add lifetime for `&'dest mut Self, and `'a: 'dest`\n+        // Add lifetime for `&'place mut Self, and `'a: 'place`\n         for lifetime in &mut generics.lifetimes {\n-            lifetime.bounds.push(dest_lifetime.lifetime.clone());\n+            lifetime.bounds.push(place_lifetime.lifetime.clone());\n         }\n         for generic in &mut generics.ty_params {\n-            generic.bounds.push(syn::TyParamBound::Region(dest_lifetime.lifetime.clone()));\n+            generic.bounds.push(syn::TyParamBound::Region(place_lifetime.lifetime.clone()));\n         }\n-        generics.lifetimes.insert(0, dest_lifetime);\n+        generics.lifetimes.insert(0, place_lifetime);\n         if let Some(de_lifetime) = self.0.borrowed.de_lifetime_def() {\n             generics.lifetimes.insert(0, de_lifetime);\n         }\n@@ -2478,16 +2478,16 @@ impl<'a> ToTokens for DeFromImplGenerics<'a> {\n     }\n }\n \n-#[cfg(feature = \"deserialize_from\")]\n+#[cfg(feature = \"deserialize_in_place\")]\n impl<'a> DeImplGenerics<'a> {\n-    fn with_dest(self) -> DeFromImplGenerics<'a> {\n-        DeFromImplGenerics(self.0)\n+    fn in_place(self) -> InPlaceImplGenerics<'a> {\n+        InPlaceImplGenerics(self.0)\n     }\n }\n \n struct DeTyGenerics<'a>(&'a Parameters);\n-#[cfg(feature = \"deserialize_from\")]\n-struct DeFromTyGenerics<'a>(&'a Parameters);\n+#[cfg(feature = \"deserialize_in_place\")]\n+struct InPlaceTyGenerics<'a>(&'a Parameters);\n \n impl<'a> ToTokens for DeTyGenerics<'a> {\n     fn to_tokens(&self, tokens: &mut Tokens) {\n@@ -2502,11 +2502,11 @@ impl<'a> ToTokens for DeTyGenerics<'a> {\n     }\n }\n \n-#[cfg(feature = \"deserialize_from\")]\n-impl<'a> ToTokens for DeFromTyGenerics<'a> {\n+#[cfg(feature = \"deserialize_in_place\")]\n+impl<'a> ToTokens for InPlaceTyGenerics<'a> {\n     fn to_tokens(&self, tokens: &mut Tokens) {\n         let mut generics = self.0.generics.clone();\n-        generics.lifetimes.insert(0, dest_lifetime());\n+        generics.lifetimes.insert(0, place_lifetime());\n \n         if self.0.borrowed.de_lifetime_def().is_some() {\n             generics\n@@ -2518,16 +2518,16 @@ impl<'a> ToTokens for DeFromTyGenerics<'a> {\n     }\n }\n \n-#[cfg(feature = \"deserialize_from\")]\n+#[cfg(feature = \"deserialize_in_place\")]\n impl<'a> DeTyGenerics<'a> {\n-    fn with_dest(self) -> DeFromTyGenerics<'a> {\n-        DeFromTyGenerics(self.0)\n+    fn in_place(self) -> InPlaceTyGenerics<'a> {\n+        InPlaceTyGenerics(self.0)\n     }\n }\n \n-#[cfg(feature = \"deserialize_from\")]\n-fn dest_lifetime() -> syn::LifetimeDef {\n-    syn::LifetimeDef::new(\"'dest\")\n+#[cfg(feature = \"deserialize_in_place\")]\n+fn place_lifetime() -> syn::LifetimeDef {\n+    syn::LifetimeDef::new(\"'place\")\n }\n \n fn split_with_de_lifetime(params: &Parameters,)\n", "test_patch": "diff --git a/serde_test/src/assert.rs b/serde_test/src/assert.rs\nindex 903a56164..821014097 100644\n--- a/serde_test/src/assert.rs\n+++ b/serde_test/src/assert.rs\n@@ -195,15 +195,15 @@ where\n         panic!(\"{} remaining tokens\", de.remaining());\n     }\n \n-    // Do the same thing for deserialize_from. This isn't *great* because a no-op\n-    // impl of deserialize_from can technically succeed here. Still, this should\n-    // catch a lot of junk.\n+    // Do the same thing for deserialize_in_place. This isn't *great* because a\n+    // no-op impl of deserialize_in_place can technically succeed here. Still,\n+    // this should catch a lot of junk.\n     let mut de = Deserializer::new(tokens);\n-    match deserialized_val.deserialize_from(&mut de) {\n+    match T::deserialize_in_place(&mut de, &mut deserialized_val) {\n         Ok(()) => {\n             assert_eq!(deserialized_val, *value);\n         }\n-        Err(e) => panic!(\"tokens failed to deserialize_from: {}\", e),\n+        Err(e) => panic!(\"tokens failed to deserialize_in_place: {}\", e),\n     }\n     if de.remaining() > 0 {\n         panic!(\"{} remaining tokens\", de.remaining());\ndiff --git a/test_suite/Cargo.toml b/test_suite/Cargo.toml\nindex 1bd4a99c6..50e10e360 100644\n--- a/test_suite/Cargo.toml\n+++ b/test_suite/Cargo.toml\n@@ -11,7 +11,7 @@ unstable = [\"serde/unstable\", \"compiletest_rs\"]\n fnv = \"1.0\"\n rustc-serialize = \"0.3.16\"\n serde = { path = \"../serde\", features = [\"rc\"] }\n-serde_derive = { path = \"../serde_derive\", features = [\"deserialize_from\"] }\n+serde_derive = { path = \"../serde_derive\", features = [\"deserialize_in_place\"] }\n serde_test = { path = \"../serde_test\" }\n \n [dependencies]\n", "problem_statement": "Is deserialize_from really more like into\nInsightful comment from @nox in #servo:\r\n\r\n> **\\<nox>** Yeah but I\u2019m curious about the name.\r\n> **\\<nox>** The idea I heard was more like deserialize_into than deserialize_from.\r\n\n", "hints_text": "The naming is meant to align with the relatively obscure Clone::clone_from --\r\n\r\n```rust\r\ntrait Clone {\r\n    fn clone(&self) -> Self;\r\n    fn clone_from(&mut self, source: &Self);\r\n}\r\n```\r\n\r\n```rust\r\ntrait Deserialize<'de> {\r\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>;\r\n    fn deserialize_from<D>(&mut self, deserializer: D) -> Result<(), D::Error>;\r\n}\r\n```\r\n\r\nThese follow a pretty similar pattern. The non-`from` method takes 1 argument which is the source of data. The `from` method takes 2, a &mut destination and a source of data.\r\n\r\nThat said, I do think the `_from` naming seems to work better for Clone.\r\n\r\n```rust\r\nlet mut x = v1.clone();\r\nx.clone_from(&v2);\r\n\r\n// They both clearly deserialize \"from\" the one argument. Neither\r\n// seems any more \"from\" than the other.\r\nlet mut x = T::deserialize(de1)?;\r\nx.deserialize_from(de2)?;\r\n```\nMy original idea for this feature was:\r\n\r\n```rust\r\ntrait Deserialize<'de> {\r\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>;\r\n    fn deserialize_into<D>(dest: &mut Self, deserializer: D) -> Result<(), D::Error>;\r\n}\r\n```\nI agree deserialize_from is a bad name. deserialize_into might be better... it's a bit weird to not use &mut self tho? I have also considered \"redeserialize\" as a possible thing.\nTranscribing a discussion from IRC: I think `clone_from` is not necessarily named correctly and is not a great model to name `deserialize_from` after unless we have other compelling reasons.\r\n\r\nI find it easier to see that `clone_from` is wrong when written in Swift argument label syntax, but I believe the same conclusion applies to Rust naming.\r\n\r\n```swift\r\n// Clones x.\r\nx.clone()\r\n\r\n// Clones v, not x. You would not want this method to be called x.clone.\r\nx.clone(from: v)\r\n```\r\n\r\nIn comparison:\r\n\r\n```swift\r\n// Both of these clone x.\r\n// The destination is different (return value vs existing value).\r\nx.clone()\r\nx.clone(into: v)\r\n```\nI believe these are the constraints:\r\n\r\n- For technical reasons, given that we don't want specialization involved, this functionality must be provided by a method on the Deserialize trait.\r\n- The method must take one argument of type `D: Deserializer<'de>`.\r\n- The method must take one argument of type `&mut Self`, which may be the receiver.\r\n- The two arguments may be in either order.\r\n- The method must be a public API so that data types can provide more efficient implementations.\r\n\r\nThat is not a lot of flexibility. However I realized that we don't necessarily need this method to be the main way that this functionality is exposed, except to data types. We could keep the method on Deserialize hidden and expose it through a different trait. Something like this is possible, if not the best design:\r\n\r\n```rust\r\ntrait DeserializeInto<'de>: Deserializer<'de> {\r\n    fn deserialize_into<T>(self, into: &mut T) -> Result<(), Self::Error>\r\n        where T: Deserialize<'de>\r\n    {\r\n        Deserialize::deserialize_from(into, self)\r\n    }\r\n}\r\n\r\nimpl<'de, D> DeserializeInto<'de> for D where D: Deserializer<'de> {}\r\n```\r\n\r\n```rust\r\nlet mut i = 0i32;\r\nlet mut de = serde_json::Deserializer::from_str(\"2\");\r\n\r\n// Pretty clear code.\r\nde.deserialize_into(&mut i)?;\r\n\r\nprintln!(\"{}\", i);\r\n```\nOh sorry forgot to follow up: I tried to ask some of the libs team members about it this week at the mozilla all hands and like basically no one cares. So no need to try to mirror clone_from.\r\n\r\nNot sure why this trait `DeserializeInto: Deserializer` is desirable?\n- If the method on Deserialize has a receiver, then it must behave like `deserialize_from` which we were not happy with.\r\n\r\n    ```rust\r\n    v.deserialize_from(&mut de)?;\r\n    ```\r\n\r\n    This may still be the best choice with the right name. I think your idea of `redeserialize` is in the right direction.\r\n\r\n- If the method on Deserialize does not have a receiver, then it takes two arguments and the argument order is arbitrary which is a shame. It also necessitates stating the type redundantly or using `Deserialize::` or `<_>::`.\r\n\r\n    ```rust\r\n    i32::deserialize_into(&mut de, &mut v)?;\r\n    i32::deserialize_into(&mut v, &mut de)?;\r\n    Deserialize::deserialize_into(&mut de, &mut v)?;\r\n    <_>::deserialize_into(&mut de, &mut v)?;\r\n    ```\r\n\r\n- An extension trait addresses all of those things.\r\n\r\n    ```rust\r\n    de.deserialize_into(&mut v)?;\r\n    ```\nAnother possibility: have a DeserializeSeed be the primary API for this.\r\n\r\n```rust\r\nInPlace(&mut v).deserialize(&mut de)?;\r\n```\nThere ultimately needs to be a method on Deserialize for this. As such I would suggest redeserialize with no other frills. It also better explains why you\u2019d use it.\nI like `redeserialize` better than `deserialize_from` but I find it a bit misleading -- to me \"redeserialize\" would mean same data -> different object. For example you might \"deserialize\" some JSON to `serde_json::Value` and then \"redeserialize\" all or part of that Value to some struct. Instead the method we have here is different data -> same object.\nWhat do people think of `fn deserialize_in_place<D>(deserializer: D, place: &mut Self)`? Too much conflict with [placement-in](https://github.com/rust-lang/rust/issues/27779) and [`std::ops::InPlace`](https://doc.rust-lang.org/std/ops/trait.InPlace.html)? Or just similar enough in principle that it makes sense?\n`fn deserialize_assign<D>(&mut self, deserializer: D)` may also make sense as a binary operation that modifies one of its arguments in-place, mirroring `OpAssign` family of traits in `std::ops`.", "created_at": "2017-12-17T19:00:22Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1104, "instance_id": "serde-rs__serde-1104", "issue_numbers": ["1103"], "base_commit": "c650a92bf7773af66e41add39d79c226f982ff08", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 71326b84f..bfa18b000 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -418,8 +418,8 @@ fn deserialize_seq(\n                 };\n                 let assign = quote! {\n                     let #var = match #visit {\n-                        Some(__value) => __value,\n-                        None => {\n+                        _serde::export::Some(__value) => __value,\n+                        _serde::export::None => {\n                             return _serde::export::Err(_serde::de::Error::invalid_length(#index_in_seq, &#expecting));\n                         }\n                     };\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 6f4022cb3..4a4cbc9f4 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -23,6 +23,7 @@ use self::serde::de::{DeserializeOwned, Deserializer};\n \n use std::borrow::Cow;\n use std::marker::PhantomData;\n+use std::option::Option as StdOption;\n use std::result::Result as StdResult;\n \n // Try to trip up the generated code if it fails to use fully qualified paths.\n@@ -32,6 +33,12 @@ struct Result;\n struct Ok;\n #[allow(dead_code)]\n struct Err;\n+#[allow(dead_code)]\n+struct Option;\n+#[allow(dead_code)]\n+struct Some;\n+#[allow(dead_code)]\n+struct None;\n \n //////////////////////////////////////////////////////////////////////////\n \n@@ -56,7 +63,7 @@ fn test_gen() {\n     #[derive(Serialize, Deserialize)]\n     struct WithRef<'a, T: 'a> {\n         #[serde(skip_deserializing)]\n-        t: Option<&'a T>,\n+        t: StdOption<&'a T>,\n         #[serde(serialize_with=\"ser_x\", deserialize_with=\"de_x\")]\n         x: X,\n     }\n@@ -77,9 +84,9 @@ fn test_gen() {\n     #[derive(Serialize, Deserialize)]\n     struct NoBounds<T> {\n         t: T,\n-        option: Option<T>,\n+        option: StdOption<T>,\n         boxed: Box<T>,\n-        option_boxed: Option<Box<T>>,\n+        option_boxed: StdOption<Box<T>>,\n     }\n     assert::<NoBounds<i32>>();\n \n@@ -175,8 +182,8 @@ fn test_gen() {\n \n     #[derive(Serialize)]\n     struct OptionStatic<'a> {\n-        a: Option<&'a str>,\n-        b: Option<&'static str>,\n+        a: StdOption<&'a str>,\n+        b: StdOption<&'static str>,\n     }\n     assert_ser::<OptionStatic>();\n \n", "problem_statement": "Warning at #[derive(Deserialize)] when compiling without prelude\nHi,\r\n\r\nWhen using #[derive(Deserialize)] when compiling with #![no_implicit_prelude], there is a warning about \"None\". This will be hidden, if `use std::option::Option::None;` is used, but this shouldn't be required.\r\n\r\n```\r\nwarning: variable `None` should have a snake case name such as `none`\r\n   --> [...].rs:212:88\r\n    |\r\n212 | #[derive(Serialize, Deserialize)]\r\n    |                     ^^^^^^^^^^^\r\n```\r\n\r\nUpdate: there is also an error with `Option::Some`.\n", "hints_text": "", "created_at": "2017-11-30T03:46:26Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1083, "instance_id": "serde-rs__serde-1083", "issue_numbers": ["1081"], "base_commit": "ab68132b1f945b8a1174e58ff68f7591144d4e2a", "patch": "diff --git a/serde_derive/src/bound.rs b/serde_derive/src/bound.rs\nindex 5f6e94c02..5dc68a0f1 100644\n--- a/serde_derive/src/bound.rs\n+++ b/serde_derive/src/bound.rs\n@@ -116,6 +116,14 @@ where\n             }\n             visit::walk_path(self, path);\n         }\n+\n+        // Type parameter should not be considered used by a macro path.\n+        //\n+        //     struct TypeMacro<T> {\n+        //         mac: T!(),\n+        //         marker: PhantomData<T>,\n+        //     }\n+        fn visit_mac(&mut self, _mac: &syn::Mac) {}\n     }\n \n     let all_ty_params: HashSet<_> = generics\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 50cd13b70..c6a68213b 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -519,6 +519,17 @@ fn test_gen() {\n         other: isize,\n     }\n     assert::<SkippedStaticStr>();\n+\n+    macro_rules! T {\n+        () => { () }\n+    }\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct TypeMacro<T> {\n+        mac: T!(),\n+        marker: PhantomData<T>,\n+    }\n+    assert::<TypeMacro<X>>();\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Wrong bounds for macro named the same as a type parameter\n```rust\r\nuse std::marker::PhantomData;\r\n\r\n#[macro_use]\r\nextern crate serde_derive;\r\n\r\nmacro_rules! T {\r\n    () => { () };\r\n}\r\n\r\n// generates impl<T> Serialize for A<T>\r\n#[derive(Serialize)]\r\nstruct A<T> {\r\n    f: (),\r\n    t: PhantomData<T>,\r\n}\r\n\r\n// generates impl<T> Serialize for A<T> where T: Serialize\r\n#[derive(Serialize)]\r\nstruct B<T> {\r\n    f: T!(),\r\n    t: PhantomData<T>,\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\nWhen expanding B\\<T\\> we see `T` being used as a \"path\" in the macro and mistakenly conclude that the type parameter needs to be serializable.\n", "hints_text": "", "created_at": "2017-11-05T20:20:03Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1082, "instance_id": "serde-rs__serde-1082", "issue_numbers": ["929"], "base_commit": "ab68132b1f945b8a1174e58ff68f7591144d4e2a", "patch": "diff --git a/serde_derive_internals/src/ast.rs b/serde_derive_internals/src/ast.rs\nindex 818d301bd..dce1acc17 100644\n--- a/serde_derive_internals/src/ast.rs\n+++ b/serde_derive_internals/src/ast.rs\n@@ -51,7 +51,7 @@ impl<'a> Container<'a> {\n         let mut body = match item.body {\n             syn::Body::Enum(ref variants) => Body::Enum(enum_from_ast(cx, variants)),\n             syn::Body::Struct(ref variant_data) => {\n-                let (style, fields) = struct_from_ast(cx, variant_data);\n+                let (style, fields) = struct_from_ast(cx, variant_data, None);\n                 Body::Struct(style, fields)\n             }\n         };\n@@ -103,10 +103,11 @@ fn enum_from_ast<'a>(cx: &Ctxt, variants: &'a [syn::Variant]) -> Vec<Variant<'a>\n         .iter()\n         .map(\n             |variant| {\n-                let (style, fields) = struct_from_ast(cx, &variant.data);\n+                let attrs = attr::Variant::from_ast(cx, variant);\n+                let (style, fields) = struct_from_ast(cx, &variant.data, Some(&attrs));\n                 Variant {\n                     ident: variant.ident.clone(),\n-                    attrs: attr::Variant::from_ast(cx, variant),\n+                    attrs: attrs,\n                     style: style,\n                     fields: fields,\n                 }\n@@ -115,18 +116,18 @@ fn enum_from_ast<'a>(cx: &Ctxt, variants: &'a [syn::Variant]) -> Vec<Variant<'a>\n         .collect()\n }\n \n-fn struct_from_ast<'a>(cx: &Ctxt, data: &'a syn::VariantData) -> (Style, Vec<Field<'a>>) {\n+fn struct_from_ast<'a>(cx: &Ctxt, data: &'a syn::VariantData, attrs: Option<&attr::Variant>) -> (Style, Vec<Field<'a>>) {\n     match *data {\n-        syn::VariantData::Struct(ref fields) => (Style::Struct, fields_from_ast(cx, fields)),\n+        syn::VariantData::Struct(ref fields) => (Style::Struct, fields_from_ast(cx, fields, attrs)),\n         syn::VariantData::Tuple(ref fields) if fields.len() == 1 => {\n-            (Style::Newtype, fields_from_ast(cx, fields))\n+            (Style::Newtype, fields_from_ast(cx, fields, attrs))\n         }\n-        syn::VariantData::Tuple(ref fields) => (Style::Tuple, fields_from_ast(cx, fields)),\n+        syn::VariantData::Tuple(ref fields) => (Style::Tuple, fields_from_ast(cx, fields, attrs)),\n         syn::VariantData::Unit => (Style::Unit, Vec::new()),\n     }\n }\n \n-fn fields_from_ast<'a>(cx: &Ctxt, fields: &'a [syn::Field]) -> Vec<Field<'a>> {\n+fn fields_from_ast<'a>(cx: &Ctxt, fields: &'a [syn::Field], attrs: Option<&attr::Variant>) -> Vec<Field<'a>> {\n     fields\n         .iter()\n         .enumerate()\n@@ -134,7 +135,7 @@ fn fields_from_ast<'a>(cx: &Ctxt, fields: &'a [syn::Field]) -> Vec<Field<'a>> {\n             |(i, field)| {\n                 Field {\n                     ident: field.ident.clone(),\n-                    attrs: attr::Field::from_ast(cx, i, field),\n+                    attrs: attr::Field::from_ast(cx, i, field, attrs),\n                     ty: &field.ty,\n                 }\n             },\ndiff --git a/serde_derive_internals/src/attr.rs b/serde_derive_internals/src/attr.rs\nindex 454b8b59c..7baeb59bb 100644\n--- a/serde_derive_internals/src/attr.rs\n+++ b/serde_derive_internals/src/attr.rs\n@@ -512,6 +512,7 @@ pub struct Variant {\n     other: bool,\n     serialize_with: Option<syn::Path>,\n     deserialize_with: Option<syn::Path>,\n+    borrow: Option<syn::MetaItem>,\n }\n \n impl Variant {\n@@ -524,6 +525,7 @@ impl Variant {\n         let mut other = BoolAttr::none(cx, \"other\");\n         let mut serialize_with = Attr::none(cx, \"serialize_with\");\n         let mut deserialize_with = Attr::none(cx, \"deserialize_with\");\n+        let mut borrow = Attr::none(cx, \"borrow\");\n \n         for meta_items in variant.attrs.iter().filter_map(get_serde_meta_items) {\n             for meta_item in meta_items {\n@@ -599,6 +601,18 @@ impl Variant {\n                         }\n                     }\n \n+                    // Defer `#[serde(borrow)]` and `#[serde(borrow = \"'a + 'b\")]`\n+                    MetaItem(ref mi) if mi.name() == \"borrow\" => {\n+                        match variant.data {\n+                            syn::VariantData::Tuple(ref fields) if fields.len() == 1 => {\n+                                borrow.set(mi.clone());\n+                            }\n+                            _ => {\n+                                cx.error(\"#[serde(borrow)] may only be used on newtype variants\");\n+                            }\n+                        }\n+                    }\n+\n                     MetaItem(ref meta_item) => {\n                         cx.error(format!(\"unknown serde variant attribute `{}`\", meta_item.name()));\n                     }\n@@ -627,6 +641,7 @@ impl Variant {\n             other: other.get(),\n             serialize_with: serialize_with.get(),\n             deserialize_with: deserialize_with.get(),\n+            borrow: borrow.get(),\n         }\n     }\n \n@@ -699,7 +714,7 @@ pub enum Default {\n \n impl Field {\n     /// Extract out the `#[serde(...)]` attributes from a struct field.\n-    pub fn from_ast(cx: &Ctxt, index: usize, field: &syn::Field) -> Self {\n+    pub fn from_ast(cx: &Ctxt, index: usize, field: &syn::Field, attrs: Option<&Variant>) -> Self {\n         let mut ser_name = Attr::none(cx, \"rename\");\n         let mut de_name = Attr::none(cx, \"rename\");\n         let mut skip_serializing = BoolAttr::none(cx, \"skip_serializing\");\n@@ -718,7 +733,13 @@ impl Field {\n             None => index.to_string(),\n         };\n \n-        for meta_items in field.attrs.iter().filter_map(get_serde_meta_items) {\n+        let variant_borrow = attrs\n+            .map(|variant| &variant.borrow)\n+            .unwrap_or(&None)\n+            .as_ref()\n+            .map(|borrow| vec![MetaItem(borrow.clone())]);\n+\n+        for meta_items in field.attrs.iter().filter_map(get_serde_meta_items).chain(variant_borrow) {\n             for meta_item in meta_items {\n                 match meta_item {\n                     // Parse `#[serde(rename = \"foo\")]`\n", "test_patch": "diff --git a/test_suite/tests/compile-fail/borrow/duplicate_variant.rs b/test_suite/tests/compile-fail/borrow/duplicate_variant.rs\nnew file mode 100644\nindex 000000000..5cc3ad3b3\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/borrow/duplicate_variant.rs\n@@ -0,0 +1,21 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)]\n+struct Str<'a>(&'a str);\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+enum Test<'a> {\n+    #[serde(borrow)] //~^^ HELP: duplicate serde attribute `borrow`\n+    S(#[serde(borrow)] Str<'a>)\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/borrow/struct_variant.rs b/test_suite/tests/compile-fail/borrow/struct_variant.rs\nnew file mode 100644\nindex 000000000..5bab07171\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/borrow/struct_variant.rs\n@@ -0,0 +1,21 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)]\n+struct Str<'a>(&'a str);\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+enum Test<'a> {\n+    #[serde(borrow)] //~^^ HELP: #[serde(borrow)] may only be used on newtype variants\n+    S { s: Str<'a> }\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 50cd13b70..515c2f823 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -357,6 +357,12 @@ fn test_gen() {\n         s: Str<'a>,\n     }\n \n+    #[derive(Serialize, Deserialize)]\n+    enum BorrowVariant<'a> {\n+        #[serde(borrow, with = \"StrDef\")]\n+        S(Str<'a>),\n+    }\n+\n     mod vis {\n         pub struct S;\n \n", "problem_statement": "Support borrow attribute on newtype variants\nThis is ugly:\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\nenum RelData<'a> {\r\n    Single(#[serde(borrow)] RelObject<'a>),\r\n    Many(#[serde(borrow)] Vec<RelObject<'a>>),\r\n}\r\n```\r\n\r\nFor newtype variants, the following should be supported:\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\nenum RelData<'a> {\r\n    #[serde(borrow)]\r\n    Single(RelObject<'a>),\r\n    #[serde(borrow)]\r\n    Many(Vec<RelObject<'a>>),\r\n}\r\n```\n", "hints_text": "", "created_at": "2017-11-05T20:09:27Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1079, "instance_id": "serde-rs__serde-1079", "issue_numbers": ["1078"], "base_commit": "2a557a1e36317dd0689bd978a39e254bca454d44", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 44ed7fa0e..71326b84f 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -203,7 +203,9 @@ impl BorrowedLifetimes {\n fn borrowed_lifetimes(cont: &Container) -> BorrowedLifetimes {\n     let mut lifetimes = BTreeSet::new();\n     for field in cont.body.all_fields() {\n-        lifetimes.extend(field.attrs.borrowed_lifetimes().iter().cloned());\n+        if !field.attrs.skip_deserializing() {\n+            lifetimes.extend(field.attrs.borrowed_lifetimes().iter().cloned());\n+        }\n     }\n     if lifetimes.iter().any(|b| b.ident == \"'static\") {\n         BorrowedLifetimes::Static\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex f9143099a..50cd13b70 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -511,6 +511,14 @@ fn test_gen() {\n         Tuple(&'a str, &'static str),\n         Newtype(&'static str),\n     }\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct SkippedStaticStr {\n+        #[serde(skip_deserializing)]\n+        skipped: &'static str,\n+        other: isize,\n+    }\n+    assert::<SkippedStaticStr>();\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Lifetime errors with skipped `&'static` variable\nI needed to evolve my format, so I went from (simplified)\r\n```rust\r\n#[derive(Debug, PartialEq)]\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(deny_unknown_fields)]\r\npub struct SassOptions {\r\n    #[serde(skip)]\r\n    pub import_dir: &'static str,\r\n    pub style: SassOutputStyle,\r\n}\r\n\r\nimpl Default for SassOptions {\r\n    fn default() -> SassOptions {\r\n        ...\r\n    }\r\n}\r\n\r\n#[derive(Debug, PartialEq)]\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(deny_unknown_fields, default)]\r\npub struct ConfigBuilder {\r\n    #[serde(skip)]\r\n    pub root: path::PathBuf,\r\n    pub source: String,\r\n    pub destination: String,\r\n    pub sass: sass::SassOptions,\r\n}\r\n```\r\nto\r\n```rust\r\n#[derive(Debug, PartialEq)]\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(deny_unknown_fields)]\r\npub struct SassOptions {\r\n    #[serde(skip)]\r\n    pub import_dir: &'static str,\r\n    pub style: SassOutputStyle,\r\n}\r\n\r\nimpl Default for SassOptions {\r\n    fn default() -> SassOptions {\r\n        ...\r\n    }\r\n}\r\n\r\n#[derive(Debug, PartialEq, Default)] \r\n#[derive(Serialize, Deserialize)]    \r\n#[serde(deny_unknown_fields)]        \r\npub struct AssetsBuilder {           \r\n    pub sass: sass::SassOptions,     \r\n}                                    \r\n\r\n#[derive(Debug, PartialEq)]\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(deny_unknown_fields, default)]\r\npub struct ConfigBuilder {\r\n    #[serde(skip)]\r\n    pub root: path::PathBuf,\r\n    pub source: String,\r\n    pub destination: String,\r\n    pub assets: AssetsBuilder,\r\n}\r\n```\r\n\r\nand I started getting lifetime errors\r\n```\r\nerror[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'de` due to conflicting requirements\r\n  --> src/config.rs:95:21\r\n   |\r\n95 | #[derive(Serialize, Deserialize)]\r\n   |                     ^^^^^^^^^^^\r\n   |\r\nnote: first, the lifetime cannot outlive the lifetime 'de as defined on the impl at 95:21...\r\n  --> src/config.rs:95:21\r\n   |\r\n95 | #[derive(Serialize, Deserialize)]\r\n   |                     ^^^^^^^^^^^\r\nnote: ...so that types are compatible (expected std::convert::From<<__A as serde::de::MapAccess<'_>>::Error>, found std::convert::From<<__A as serde::de::MapAccess<'de>>::Error>)\r\n  --> src/config.rs:95:21\r\n   |\r\n95 | #[derive(Serialize, Deserialize)]\r\n   |                     ^^^^^^^^^^^\r\n   = note: but, the lifetime must be valid for the static lifetime...\r\nnote: ...so that types are compatible (expected serde::Deserialize<'_>, found serde::Deserialize<'static>)\r\n  --> src/config.rs:95:21\r\n   |\r\n95 | #[derive(Serialize, Deserialize)]\r\n   |                     ^^^^^^^^^^^\r\n   = note: this error originates in a macro outside of the current crate\r\n\r\nerror: aborting due to 2 previous errors\r\n\r\nerror: Could not compile `cobalt-bin`.\r\n```\r\n\r\nSituations\r\n- Adding a layer caused the warning\r\n- Switching `import_dir` to `String` removed the error\r\n- Adding a member to `AssetsBuilder` did not fix things.\r\n\r\nOriginal source: https://github.com/cobalt-org/cobalt.rs\r\nBroken source: not uploaded at the moment\n", "hints_text": "Broken source: https://github.com/epage/cobalt.rs/tree/serde-broken", "created_at": "2017-11-03T17:08:32Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1053, "instance_id": "serde-rs__serde-1053", "issue_numbers": ["1051"], "base_commit": "c3eced410fd3cb82122187f5844a54fe6948a1ea", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex aedbf3323..05b952aa1 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -1428,7 +1428,7 @@ fn deserialize_identifier(\n                     #variant_indices => _serde::export::Ok(#constructors),\n                 )*\n                 _ => _serde::export::Err(_serde::de::Error::invalid_value(\n-                            _serde::de::Unexpected::Unsigned(__value as u64),\n+                            _serde::de::Unexpected::Unsigned(__value),\n                             &#fallthrough_msg))\n             }\n         }\n", "test_patch": "diff --git a/test_suite/tests/test_macros.rs b/test_suite/tests/test_macros.rs\nindex f2b478e84..66e72f237 100644\n--- a/test_suite/tests/test_macros.rs\n+++ b/test_suite/tests/test_macros.rs\n@@ -6,6 +6,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(trivial_numeric_casts)]\n+\n #[macro_use]\n extern crate serde_derive;\n \n", "problem_statement": "v1.0.13 introduced an error if `trivial_numeric_casts` is denied\nHi,\r\n\r\nI updated `cargo update`d on my machine and got the new serde versions:\r\n\r\n```\r\n    Updating serde v1.0.12 -> v1.0.13\r\n    Updating serde_derive v1.0.12 -> v1.0.13\r\n    Updating serde_derive_internals v0.15.1 -> v0.16.0\r\n```\r\n\r\nand now my code fails to compile because I turned on `trivial_numeric_casts` denying:\r\n\r\n```\r\n\r\nerror: trivial numeric cast: `u64` as `u64`. Cast can be replaced by coercion, this might require type ascription or a temporary variable\r\n  --> src/file_abstraction/stdio/mapper/json.rs:35:17\r\n   |\r\n35 | #[derive(Debug, Deserialize, Serialize)]\r\n   |                 ^^^^^^^^^^^\r\n   |\r\nnote: lint level defined here\r\n  --> src/lib.rs:27:5\r\n   |\r\n27 |     trivial_numeric_casts,\r\n   |     ^^^^^^^^^^^^^^^^^^^^^\r\n\r\nerror: trivial numeric cast: `u64` as `u64`. Cast can be replaced by coercion, this might require type ascription or a temporary variable\r\n  --> src/file_abstraction/stdio/mapper/json.rs:55:17\r\n   |\r\n55 | #[derive(Debug, Deserialize, Serialize)]\r\n   |                 ^^^^^^^^^^^\r\n\r\nerror: aborting due to 2 previous errors\r\n\r\nerror: Could not compile `libimagstore`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n\r\nThe repository of my code [is here](https://github.com/matthiasbeyer/imag).\n", "hints_text": "", "created_at": "2017-09-09T19:37:42Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1052, "instance_id": "serde-rs__serde-1052", "issue_numbers": ["975"], "base_commit": "c3eced410fd3cb82122187f5844a54fe6948a1ea", "patch": "diff --git a/serde_derive/src/bound.rs b/serde_derive/src/bound.rs\nindex 0160fa85c..5f6e94c02 100644\n--- a/serde_derive/src/bound.rs\n+++ b/serde_derive/src/bound.rs\n@@ -15,7 +15,7 @@ use internals::attr;\n \n macro_rules! path {\n     ($($path:tt)+) => {\n-        syn::parse_path(stringify!($($path)+)).unwrap()\n+        syn::parse_path(quote!($($path)+).as_str()).unwrap()\n     };\n }\n \ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex aedbf3323..aa8f58ca9 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -26,13 +26,14 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<Tokens, Str\n     let (de_impl_generics, _, ty_generics, where_clause) = split_with_de_lifetime(&params);\n     let dummy_const = Ident::new(format!(\"_IMPL_DESERIALIZE_FOR_{}\", ident));\n     let body = Stmts(deserialize_body(&cont, &params));\n+    let delife = params.borrowed.de_lifetime();\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n         let vis = &input.vis;\n         quote! {\n             impl #de_impl_generics #ident #ty_generics #where_clause {\n                 #vis fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<#remote #ty_generics, __D::Error>\n-                    where __D: _serde::Deserializer<'de>\n+                    where __D: _serde::Deserializer<#delife>\n                 {\n                     #body\n                 }\n@@ -41,9 +42,9 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<Tokens, Str\n     } else {\n         quote! {\n             #[automatically_derived]\n-            impl #de_impl_generics _serde::Deserialize<'de> for #ident #ty_generics #where_clause {\n+            impl #de_impl_generics _serde::Deserialize<#delife> for #ident #ty_generics #where_clause {\n                 fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>\n-                    where __D: _serde::Deserializer<'de>\n+                    where __D: _serde::Deserializer<#delife>\n                 {\n                     #body\n                 }\n@@ -75,7 +76,7 @@ struct Parameters {\n \n     /// Lifetimes borrowed from the deserializer. These will become bounds on\n     /// the `'de` lifetime of the deserializer.\n-    borrowed: BTreeSet<syn::Lifetime>,\n+    borrowed: BorrowedLifetimes,\n \n     /// At least one field has a serde(getter) attribute, implying that the\n     /// remote type has a private field.\n@@ -89,8 +90,8 @@ impl Parameters {\n             Some(remote) => remote.clone(),\n             None => cont.ident.clone().into(),\n         };\n-        let generics = build_generics(cont);\n         let borrowed = borrowed_lifetimes(cont);\n+        let generics = build_generics(cont, &borrowed);\n         let has_getter = cont.body.has_getter();\n \n         Parameters {\n@@ -107,20 +108,12 @@ impl Parameters {\n     fn type_name(&self) -> &str {\n         self.this.segments.last().unwrap().ident.as_ref()\n     }\n-\n-    fn de_lifetime_def(&self) -> syn::LifetimeDef {\n-        syn::LifetimeDef {\n-            attrs: Vec::new(),\n-            lifetime: syn::Lifetime::new(\"'de\"),\n-            bounds: self.borrowed.iter().cloned().collect(),\n-        }\n-    }\n }\n \n // All the generics in the input, plus a bound `T: Deserialize` for each generic\n // field type that will be deserialized by us, plus a bound `T: Default` for\n // each generic field type that will be set to a default value.\n-fn build_generics(cont: &Container) -> syn::Generics {\n+fn build_generics(cont: &Container, borrowed: &BorrowedLifetimes) -> syn::Generics {\n     let generics = bound::without_defaults(cont.generics);\n \n     let generics = bound::with_where_predicates_from_fields(cont, &generics, attr::Field::de_bound);\n@@ -136,11 +129,12 @@ fn build_generics(cont: &Container) -> syn::Generics {\n                 attr::Default::Path(_) => generics,\n             };\n \n+            let delife = borrowed.de_lifetime();\n             let generics = bound::with_bound(\n                 cont,\n                 &generics,\n                 needs_deserialize_bound,\n-                &path!(_serde::Deserialize<'de>),\n+                &path!(_serde::Deserialize<#delife>),\n             );\n \n             bound::with_bound(\n@@ -170,18 +164,52 @@ fn requires_default(field: &attr::Field, _variant: Option<&attr::Variant>) -> bo\n     field.default() == &attr::Default::Default\n }\n \n+enum BorrowedLifetimes {\n+    Borrowed(BTreeSet<syn::Lifetime>),\n+    Static,\n+}\n+\n+impl BorrowedLifetimes {\n+    fn de_lifetime(&self) -> syn::Lifetime {\n+        match *self {\n+            BorrowedLifetimes::Borrowed(_) => syn::Lifetime::new(\"'de\"),\n+            BorrowedLifetimes::Static => syn::Lifetime::new(\"'static\"),\n+        }\n+    }\n+\n+    fn de_lifetime_def(&self) -> Option<syn::LifetimeDef> {\n+        match *self {\n+            BorrowedLifetimes::Borrowed(ref bounds) => {\n+                Some(syn::LifetimeDef {\n+                    attrs: Vec::new(),\n+                    lifetime: syn::Lifetime::new(\"'de\"),\n+                    bounds: bounds.iter().cloned().collect(),\n+                })\n+            }\n+            BorrowedLifetimes::Static => None,\n+        }\n+    }\n+}\n+\n // The union of lifetimes borrowed by each field of the container.\n //\n // These turn into bounds on the `'de` lifetime of the Deserialize impl. If\n // lifetimes `'a` and `'b` are borrowed but `'c` is not, the impl is:\n //\n //     impl<'de: 'a + 'b, 'a, 'b, 'c> Deserialize<'de> for S<'a, 'b, 'c>\n-fn borrowed_lifetimes(cont: &Container) -> BTreeSet<syn::Lifetime> {\n+//\n+// If any borrowed lifetime is `'static`, then `'de: 'static` would be redundant\n+// and we use plain `'static` instead of `'de`.\n+fn borrowed_lifetimes(cont: &Container) -> BorrowedLifetimes {\n     let mut lifetimes = BTreeSet::new();\n     for field in cont.body.all_fields() {\n         lifetimes.extend(field.attrs.borrowed_lifetimes().iter().cloned());\n     }\n-    lifetimes\n+    if lifetimes.iter().any(|b| b.ident == \"'static\") {\n+        BorrowedLifetimes::Static\n+    } else {\n+        BorrowedLifetimes::Borrowed(lifetimes)\n+    }\n }\n \n fn deserialize_body(cont: &Container, params: &Parameters) -> Fragment {\n@@ -260,6 +288,7 @@ fn deserialize_tuple(\n ) -> Fragment {\n     let this = &params.this;\n     let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params,);\n+    let delife = params.borrowed.de_lifetime();\n \n     // If there are getters (implying private fields), construct the local type\n     // and use an `Into` conversion to get the remote type. If there are no\n@@ -321,10 +350,10 @@ fn deserialize_tuple(\n     quote_block! {\n         struct __Visitor #de_impl_generics #where_clause {\n             marker: _serde::export::PhantomData<#this #ty_generics>,\n-            lifetime: _serde::export::PhantomData<&'de ()>,\n+            lifetime: _serde::export::PhantomData<&#delife ()>,\n         }\n \n-        impl #de_impl_generics _serde::de::Visitor<'de> for __Visitor #de_ty_generics #where_clause {\n+        impl #de_impl_generics _serde::de::Visitor<#delife> for __Visitor #de_ty_generics #where_clause {\n             type Value = #this #ty_generics;\n \n             fn expecting(&self, formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n@@ -335,7 +364,7 @@ fn deserialize_tuple(\n \n             #[inline]\n             fn visit_seq<__A>(self, #visitor_var: __A) -> _serde::export::Result<Self::Value, __A::Error>\n-                where __A: _serde::de::SeqAccess<'de>\n+                where __A: _serde::de::SeqAccess<#delife>\n             {\n                 #visit_seq\n             }\n@@ -423,6 +452,8 @@ fn deserialize_seq(\n }\n \n fn deserialize_newtype_struct(type_path: &Tokens, params: &Parameters, field: &Field) -> Tokens {\n+    let delife = params.borrowed.de_lifetime();\n+\n     let value = match field.attrs.deserialize_with() {\n         None => {\n             let field_ty = &field.ty;\n@@ -450,7 +481,7 @@ fn deserialize_newtype_struct(type_path: &Tokens, params: &Parameters, field: &F\n     quote! {\n         #[inline]\n         fn visit_newtype_struct<__E>(self, __e: __E) -> _serde::export::Result<Self::Value, __E::Error>\n-            where __E: _serde::Deserializer<'de>\n+            where __E: _serde::Deserializer<#delife>\n         {\n             _serde::export::Ok(#result)\n         }\n@@ -469,6 +500,7 @@ fn deserialize_struct(\n \n     let this = &params.this;\n     let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params,);\n+    let delife = params.borrowed.de_lifetime();\n \n     // If there are getters (implying private fields), construct the local type\n     // and use an `Into` conversion to get the remote type. If there are no\n@@ -534,7 +566,7 @@ fn deserialize_struct(\n         Some(quote! {\n             #[inline]\n             fn visit_seq<__A>(self, #visitor_var: __A) -> _serde::export::Result<Self::Value, __A::Error>\n-                where __A: _serde::de::SeqAccess<'de>\n+                where __A: _serde::de::SeqAccess<#delife>\n             {\n                 #visit_seq\n             }\n@@ -546,10 +578,10 @@ fn deserialize_struct(\n \n         struct __Visitor #de_impl_generics #where_clause {\n             marker: _serde::export::PhantomData<#this #ty_generics>,\n-            lifetime: _serde::export::PhantomData<&'de ()>,\n+            lifetime: _serde::export::PhantomData<&#delife ()>,\n         }\n \n-        impl #de_impl_generics _serde::de::Visitor<'de> for __Visitor #de_ty_generics #where_clause {\n+        impl #de_impl_generics _serde::de::Visitor<#delife> for __Visitor #de_ty_generics #where_clause {\n             type Value = #this #ty_generics;\n \n             fn expecting(&self, formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n@@ -560,7 +592,7 @@ fn deserialize_struct(\n \n             #[inline]\n             fn visit_map<__A>(self, mut __map: __A) -> _serde::export::Result<Self::Value, __A::Error>\n-                where __A: _serde::de::MapAccess<'de>\n+                where __A: _serde::de::MapAccess<#delife>\n             {\n                 #visit_map\n             }\n@@ -597,6 +629,7 @@ fn deserialize_externally_tagged_enum(\n ) -> Fragment {\n     let this = &params.this;\n     let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params,);\n+    let delife = params.borrowed.de_lifetime();\n \n     let type_name = cattrs.name().deserialize_name();\n \n@@ -662,10 +695,10 @@ fn deserialize_externally_tagged_enum(\n \n         struct __Visitor #de_impl_generics #where_clause {\n             marker: _serde::export::PhantomData<#this #ty_generics>,\n-            lifetime: _serde::export::PhantomData<&'de ()>,\n+            lifetime: _serde::export::PhantomData<&#delife ()>,\n         }\n \n-        impl #de_impl_generics _serde::de::Visitor<'de> for __Visitor #de_ty_generics #where_clause {\n+        impl #de_impl_generics _serde::de::Visitor<#delife> for __Visitor #de_ty_generics #where_clause {\n             type Value = #this #ty_generics;\n \n             fn expecting(&self, formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n@@ -673,7 +706,7 @@ fn deserialize_externally_tagged_enum(\n             }\n \n             fn visit_enum<__A>(self, __data: __A) -> _serde::export::Result<Self::Value, __A::Error>\n-                where __A: _serde::de::EnumAccess<'de>\n+                where __A: _serde::de::EnumAccess<#delife>\n             {\n                 #match_variant\n             }\n@@ -754,6 +787,7 @@ fn deserialize_adjacently_tagged_enum(\n ) -> Fragment {\n     let this = &params.this;\n     let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params,);\n+    let delife = params.borrowed.de_lifetime();\n \n     let variant_names_idents: Vec<_> = variants\n         .iter()\n@@ -913,14 +947,14 @@ fn deserialize_adjacently_tagged_enum(\n         struct __Seed #de_impl_generics #where_clause {\n             field: __Field,\n             marker: _serde::export::PhantomData<#this #ty_generics>,\n-            lifetime: _serde::export::PhantomData<&'de ()>,\n+            lifetime: _serde::export::PhantomData<&#delife ()>,\n         }\n \n-        impl #de_impl_generics _serde::de::DeserializeSeed<'de> for __Seed #de_ty_generics #where_clause {\n+        impl #de_impl_generics _serde::de::DeserializeSeed<#delife> for __Seed #de_ty_generics #where_clause {\n             type Value = #this #ty_generics;\n \n             fn deserialize<__D>(self, __deserializer: __D) -> _serde::export::Result<Self::Value, __D::Error>\n-                where __D: _serde::Deserializer<'de>\n+                where __D: _serde::Deserializer<#delife>\n             {\n                 match self.field {\n                     #(#variant_arms)*\n@@ -930,10 +964,10 @@ fn deserialize_adjacently_tagged_enum(\n \n         struct __Visitor #de_impl_generics #where_clause {\n             marker: _serde::export::PhantomData<#this #ty_generics>,\n-            lifetime: _serde::export::PhantomData<&'de ()>,\n+            lifetime: _serde::export::PhantomData<&#delife ()>,\n         }\n \n-        impl #de_impl_generics _serde::de::Visitor<'de> for __Visitor #de_ty_generics #where_clause {\n+        impl #de_impl_generics _serde::de::Visitor<#delife> for __Visitor #de_ty_generics #where_clause {\n             type Value = #this #ty_generics;\n \n             fn expecting(&self, formatter: &mut _serde::export::Formatter) -> _serde::export::fmt::Result {\n@@ -941,7 +975,7 @@ fn deserialize_adjacently_tagged_enum(\n             }\n \n             fn visit_map<__A>(self, mut __map: __A) -> _serde::export::Result<Self::Value, __A::Error>\n-                where __A: _serde::de::MapAccess<'de>\n+                where __A: _serde::de::MapAccess<#delife>\n             {\n                 // Visit the first relevant key.\n                 match #next_relevant_key {\n@@ -1005,7 +1039,7 @@ fn deserialize_adjacently_tagged_enum(\n             }\n \n             fn visit_seq<__A>(self, mut __seq: __A) -> _serde::export::Result<Self::Value, __A::Error>\n-                where __A: _serde::de::SeqAccess<'de>\n+                where __A: _serde::de::SeqAccess<#delife>\n             {\n                 // Visit the first element - the tag.\n                 match try!(_serde::de::SeqAccess::next_element(&mut __seq)) {\n@@ -1366,6 +1400,7 @@ fn deserialize_custom_identifier(\n     };\n \n     let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params,);\n+    let delife = params.borrowed.de_lifetime();\n     let visitor_impl =\n         Stmts(deserialize_identifier(this.clone(), &names_idents, is_variant, fallthrough),);\n \n@@ -1374,10 +1409,10 @@ fn deserialize_custom_identifier(\n \n         struct __FieldVisitor #de_impl_generics #where_clause {\n             marker: _serde::export::PhantomData<#this #ty_generics>,\n-            lifetime: _serde::export::PhantomData<&'de ()>,\n+            lifetime: _serde::export::PhantomData<&#delife ()>,\n         }\n \n-        impl #de_impl_generics _serde::de::Visitor<'de> for __FieldVisitor #de_ty_generics #where_clause {\n+        impl #de_impl_generics _serde::de::Visitor<#delife> for __FieldVisitor #de_ty_generics #where_clause {\n             type Value = #this #ty_generics;\n \n             #visitor_impl\n@@ -1694,17 +1729,18 @@ fn wrap_deserialize_with(\n ) -> (Tokens, Tokens) {\n     let this = &params.this;\n     let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params,);\n+    let delife = params.borrowed.de_lifetime();\n \n     let wrapper = quote! {\n         struct __DeserializeWith #de_impl_generics #where_clause {\n             value: #value_ty,\n             phantom: _serde::export::PhantomData<#this #ty_generics>,\n-            lifetime: _serde::export::PhantomData<&'de ()>,\n+            lifetime: _serde::export::PhantomData<&#delife ()>,\n         }\n \n-        impl #de_impl_generics _serde::Deserialize<'de> for __DeserializeWith #de_ty_generics #where_clause {\n+        impl #de_impl_generics _serde::Deserialize<#delife> for __DeserializeWith #de_ty_generics #where_clause {\n             fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>\n-                where __D: _serde::Deserializer<'de>\n+                where __D: _serde::Deserializer<#delife>\n             {\n                 _serde::export::Ok(__DeserializeWith {\n                     value: try!(#deserialize_with(__deserializer)),\n@@ -1822,20 +1858,24 @@ struct DeImplGenerics<'a>(&'a Parameters);\n impl<'a> ToTokens for DeImplGenerics<'a> {\n     fn to_tokens(&self, tokens: &mut Tokens) {\n         let mut generics = self.0.generics.clone();\n-        generics.lifetimes.insert(0, self.0.de_lifetime_def());\n+        if let Some(de_lifetime) = self.0.borrowed.de_lifetime_def() {\n+            generics.lifetimes.insert(0, de_lifetime);\n+        }\n         let (impl_generics, _, _) = generics.split_for_impl();\n         impl_generics.to_tokens(tokens);\n     }\n }\n \n-struct DeTyGenerics<'a>(&'a syn::Generics);\n+struct DeTyGenerics<'a>(&'a Parameters);\n \n impl<'a> ToTokens for DeTyGenerics<'a> {\n     fn to_tokens(&self, tokens: &mut Tokens) {\n-        let mut generics = self.0.clone();\n-        generics\n-            .lifetimes\n-            .insert(0, syn::LifetimeDef::new(\"'de\"));\n+        let mut generics = self.0.generics.clone();\n+        if self.0.borrowed.de_lifetime_def().is_some() {\n+            generics\n+                .lifetimes\n+                .insert(0, syn::LifetimeDef::new(\"'de\"));\n+        }\n         let (_, ty_generics, _) = generics.split_for_impl();\n         ty_generics.to_tokens(tokens);\n     }\n@@ -1844,7 +1884,7 @@ impl<'a> ToTokens for DeTyGenerics<'a> {\n fn split_with_de_lifetime(params: &Parameters,)\n     -> (DeImplGenerics, DeTyGenerics, syn::TyGenerics, &syn::WhereClause) {\n     let de_impl_generics = DeImplGenerics(&params);\n-    let de_ty_generics = DeTyGenerics(&params.generics);\n+    let de_ty_generics = DeTyGenerics(&params);\n     let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n     (de_impl_generics, de_ty_generics, ty_generics, where_clause)\n }\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 76c57db8a..fc7b40f2e 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -10,6 +10,8 @@\n // successfully when there are a variety of generics and non-(de)serializable\n // types involved.\n \n+#![deny(warnings)]\n+\n #![cfg_attr(feature = \"unstable\", feature(non_ascii_idents))]\n \n // Clippy false positive\n@@ -491,6 +493,28 @@ fn test_gen() {\n         Unit,\n     }\n     assert_ser::<UntaggedVariantWith>();\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct StaticStrStruct<'a> {\n+        a: &'a str,\n+        b: &'static str,\n+    }\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct StaticStrTupleStruct<'a>(&'a str, &'static str);\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct StaticStrNewtypeStruct(&'static str);\n+\n+    #[derive(Serialize, Deserialize)]\n+    enum StaticStrEnum<'a> {\n+        Struct {\n+            a: &'a str,\n+            b: &'static str,\n+        },\n+        Tuple(&'a str, &'static str),\n+        Newtype(&'static str),\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Notice 'static lifetime\nFrom #974:\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\nstruct S {\r\n    s: &'static str,\r\n}\r\n```\r\n\r\nWe treat `'static` the same as any other lifetime so this expands to:\r\n\r\n```rust\r\nimpl<'de: 'static> Deserialize<'de> for S {\r\n    /* ... */\r\n}\r\n```\r\n\r\n```\r\nwarning: unnecessary lifetime parameter `'de`\r\n  |\r\n  | #[derive(Deserialize)]\r\n  |          ^^^^^^^^^^^\r\n  |\r\n  = help: you can use the `'static` lifetime directly, in place of `'de`\r\n```\r\n\r\nInstead it should expand to:\r\n\r\n```rust\r\nimpl Deserialize<'static> for S {\r\n    /* ... */\r\n}\r\n```\n", "hints_text": "", "created_at": "2017-09-09T19:31:19Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1044, "instance_id": "serde-rs__serde-1044", "issue_numbers": ["790"], "base_commit": "ea1a7290881508406ff0e704507d98a1fc7d6803", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex ef3e20e6a..c48d02a75 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -869,37 +869,204 @@ map_impl!(\n ////////////////////////////////////////////////////////////////////////////////\n \n #[cfg(feature = \"std\")]\n-macro_rules! parse_impl {\n-    ($ty:ty) => {\n+macro_rules! parse_ip_impl {\n+    ($ty:ty; $size: expr) => {\n         impl<'de> Deserialize<'de> for $ty {\n             fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n             where\n                 D: Deserializer<'de>,\n             {\n-                let s = try!(String::deserialize(deserializer));\n-                s.parse().map_err(Error::custom)\n+                if deserializer.is_human_readable() {\n+                    let s = try!(String::deserialize(deserializer));\n+                    s.parse().map_err(Error::custom)\n+                } else {\n+                    <[u8; $size]>::deserialize(deserializer).map(<$ty>::from)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! variant_identifier {\n+    (\n+        $name_kind: ident ( $($variant: ident; $bytes: expr; $index: expr),* )\n+        $expecting_message: expr,\n+        $variants_name: ident\n+    ) => {\n+        enum $name_kind {\n+            $( $variant ),*\n+        }\n+\n+        static $variants_name: &'static [&'static str] = &[ $( stringify!($variant) ),*];\n+\n+        impl<'de> Deserialize<'de> for $name_kind {\n+            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+            where\n+                D: Deserializer<'de>,\n+            {\n+                struct KindVisitor;\n+\n+                impl<'de> Visitor<'de> for KindVisitor {\n+                    type Value = $name_kind;\n+\n+                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                        formatter.write_str($expecting_message)\n+                    }\n+\n+                    fn visit_u32<E>(self, value: u32) -> Result<Self::Value, E>\n+                    where\n+                        E: Error,\n+                    {\n+                        match value {\n+                            $(\n+                                $index => Ok($name_kind :: $variant),\n+                            )*\n+                            _ => Err(Error::invalid_value(Unexpected::Unsigned(value as u64), &self),),\n+                        }\n+                    }\n+\n+                    fn visit_str<E>(self, value: &str) -> Result<Self::Value, E>\n+                    where\n+                        E: Error,\n+                    {\n+                        match value {\n+                            $(\n+                                stringify!($variant) => Ok($name_kind :: $variant),\n+                            )*\n+                            _ => Err(Error::unknown_variant(value, $variants_name)),\n+                        }\n+                    }\n+\n+                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Self::Value, E>\n+                    where\n+                        E: Error,\n+                    {\n+                        match value {\n+                            $(\n+                                $bytes => Ok($name_kind :: $variant),\n+                            )*\n+                            _ => {\n+                                match str::from_utf8(value) {\n+                                    Ok(value) => Err(Error::unknown_variant(value, $variants_name)),\n+                                    Err(_) => Err(Error::invalid_value(Unexpected::Bytes(value), &self)),\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                deserializer.deserialize_identifier(KindVisitor)\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! deserialize_enum {\n+    (\n+        $name: ident $name_kind: ident ( $($variant: ident; $bytes: expr; $index: expr),* )\n+        $expecting_message: expr,\n+        $deserializer: expr\n+    ) => {\n+        variant_identifier!{\n+            $name_kind ( $($variant; $bytes; $index),* )\n+            $expecting_message,\n+            VARIANTS\n+        }\n+\n+        struct EnumVisitor;\n+        impl<'de> Visitor<'de> for EnumVisitor {\n+            type Value = $name;\n+\n+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                formatter.write_str(concat!(\"a \", stringify!($name)))\n+            }\n+\n+\n+            fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n+            where\n+                A: EnumAccess<'de>,\n+            {\n+                match try!(data.variant()) {\n+                    $(\n+                        ($name_kind :: $variant, v) => v.newtype_variant().map($name :: $variant),\n+                    )*\n+                }\n+            }\n+        }\n+        $deserializer.deserialize_enum(stringify!($name), VARIANTS, EnumVisitor)\n+    }\n+}\n+\n+#[cfg(feature = \"std\")]\n+impl<'de> Deserialize<'de> for net::IpAddr {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        if deserializer.is_human_readable() {\n+            let s = try!(String::deserialize(deserializer));\n+            s.parse().map_err(Error::custom)\n+        } else {\n+            use lib::net::IpAddr;\n+            deserialize_enum!{\n+                IpAddr IpAddrKind (V4; b\"V4\"; 0, V6; b\"V6\"; 1)\n+                \"`V4` or `V6`\",\n+                deserializer\n             }\n         }\n     }\n }\n \n #[cfg(feature = \"std\")]\n-parse_impl!(net::IpAddr);\n+parse_ip_impl!(net::Ipv4Addr; 4);\n \n #[cfg(feature = \"std\")]\n-parse_impl!(net::Ipv4Addr);\n+parse_ip_impl!(net::Ipv6Addr; 16);\n \n #[cfg(feature = \"std\")]\n-parse_impl!(net::Ipv6Addr);\n+macro_rules! parse_socket_impl {\n+    ($ty:ty, $new: expr) => {\n+        impl<'de> Deserialize<'de> for $ty {\n+            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+            where\n+                D: Deserializer<'de>,\n+            {\n+                if deserializer.is_human_readable() {\n+                    let s = try!(String::deserialize(deserializer));\n+                    s.parse().map_err(Error::custom)\n+                } else {\n+                    <(_, u16)>::deserialize(deserializer).map(|(ip, port)| $new(ip, port))\n+                }\n+            }\n+        }\n+    }\n+}\n \n #[cfg(feature = \"std\")]\n-parse_impl!(net::SocketAddr);\n+impl<'de> Deserialize<'de> for net::SocketAddr {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        if deserializer.is_human_readable() {\n+            let s = try!(String::deserialize(deserializer));\n+            s.parse().map_err(Error::custom)\n+        } else {\n+            use lib::net::SocketAddr;\n+            deserialize_enum!{\n+                SocketAddr SocketAddrKind (V4; b\"V4\"; 0, V6; b\"V6\"; 1)\n+                \"`V4` or `V6`\",\n+                deserializer\n+            }\n+        }\n+    }\n+}\n \n #[cfg(feature = \"std\")]\n-parse_impl!(net::SocketAddrV4);\n+parse_socket_impl!(net::SocketAddrV4, net::SocketAddrV4::new);\n \n #[cfg(feature = \"std\")]\n-parse_impl!(net::SocketAddrV6);\n+parse_socket_impl!(net::SocketAddrV6, |ip, port| net::SocketAddrV6::new(ip, port, 0, 0));\n \n ////////////////////////////////////////////////////////////////////////////////\n \n@@ -984,70 +1151,10 @@ impl<'de> Deserialize<'de> for PathBuf {\n //    #[derive(Deserialize)]\n //    #[serde(variant_identifier)]\n #[cfg(all(feature = \"std\", any(unix, windows)))]\n-enum OsStringKind {\n-    Unix,\n-    Windows,\n-}\n-\n-#[cfg(all(feature = \"std\", any(unix, windows)))]\n-static OSSTR_VARIANTS: &'static [&'static str] = &[\"Unix\", \"Windows\"];\n-\n-#[cfg(all(feature = \"std\", any(unix, windows)))]\n-impl<'de> Deserialize<'de> for OsStringKind {\n-    fn deserialize<D>(deserializer: D) -> Result<OsStringKind, D::Error>\n-    where\n-        D: Deserializer<'de>,\n-    {\n-        struct KindVisitor;\n-\n-        impl<'de> Visitor<'de> for KindVisitor {\n-            type Value = OsStringKind;\n-\n-            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n-                formatter.write_str(\"`Unix` or `Windows`\")\n-            }\n-\n-            fn visit_u32<E>(self, value: u32) -> Result<OsStringKind, E>\n-            where\n-                E: Error,\n-            {\n-                match value {\n-                    0 => Ok(OsStringKind::Unix),\n-                    1 => Ok(OsStringKind::Windows),\n-                    _ => Err(Error::invalid_value(Unexpected::Unsigned(value as u64), &self),),\n-                }\n-            }\n-\n-            fn visit_str<E>(self, value: &str) -> Result<OsStringKind, E>\n-            where\n-                E: Error,\n-            {\n-                match value {\n-                    \"Unix\" => Ok(OsStringKind::Unix),\n-                    \"Windows\" => Ok(OsStringKind::Windows),\n-                    _ => Err(Error::unknown_variant(value, OSSTR_VARIANTS)),\n-                }\n-            }\n-\n-            fn visit_bytes<E>(self, value: &[u8]) -> Result<OsStringKind, E>\n-            where\n-                E: Error,\n-            {\n-                match value {\n-                    b\"Unix\" => Ok(OsStringKind::Unix),\n-                    b\"Windows\" => Ok(OsStringKind::Windows),\n-                    _ => {\n-                        match str::from_utf8(value) {\n-                            Ok(value) => Err(Error::unknown_variant(value, OSSTR_VARIANTS)),\n-                            Err(_) => Err(Error::invalid_value(Unexpected::Bytes(value), &self)),\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        deserializer.deserialize_identifier(KindVisitor)\n-    }\n+variant_identifier!{\n+    OsStringKind (Unix; b\"Unix\"; 0, Windows; b\"Windows\"; 1)\n+    \"`Unix` or `Windows`\",\n+    OSSTR_VARIANTS\n }\n \n #[cfg(all(feature = \"std\", any(unix, windows)))]\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex e90ced27f..71a707efc 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -1011,6 +1011,15 @@ pub trait Deserializer<'de>: Sized {\n     fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: Visitor<'de>;\n+\n+    /// Returns whether the serialized data is human readable or not.\n+    ///\n+    /// Some formats are not intended to be human readable. For these formats\n+    /// a type being serialized may opt to serialize into a more compact form.\n+    ///\n+    /// NOTE: Implementing this method and returning `false` is considered a breaking\n+    /// change as it may alter how any given type tries to deserialize itself.\n+    fn is_human_readable(&self) -> bool { true }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex ea59b78dd..3fa2ad9cc 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -506,9 +506,18 @@ impl Serialize for net::IpAddr {\n     where\n         S: Serializer,\n     {\n-        match *self {\n-            net::IpAddr::V4(ref a) => a.serialize(serializer),\n-            net::IpAddr::V6(ref a) => a.serialize(serializer),\n+        if serializer.is_human_readable() {\n+            match *self {\n+                net::IpAddr::V4(ref a) => a.serialize(serializer),\n+                net::IpAddr::V6(ref a) => a.serialize(serializer),\n+            }\n+        } else {\n+            match *self {\n+                net::IpAddr::V4(ref a) => \n+                    serializer.serialize_newtype_variant(\"IpAddr\", 0, \"V4\", a),\n+                net::IpAddr::V6(ref a) =>\n+                    serializer.serialize_newtype_variant(\"IpAddr\", 1, \"V6\", a),\n+            }\n         }\n     }\n }\n@@ -519,9 +528,13 @@ impl Serialize for net::Ipv4Addr {\n     where\n         S: Serializer,\n     {\n-        /// \"101.102.103.104\".len()\n-        const MAX_LEN: usize = 15;\n-        serialize_display_bounded_length!(self, MAX_LEN, serializer)\n+        if serializer.is_human_readable() {\n+            /// \"101.102.103.104\".len()\n+            const MAX_LEN: usize = 15;\n+            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n+        } else {\n+            self.octets().serialize(serializer)\n+        }\n     }\n }\n \n@@ -531,9 +544,13 @@ impl Serialize for net::Ipv6Addr {\n     where\n         S: Serializer,\n     {\n-        /// \"1000:1002:1003:1004:1005:1006:1007:1008\".len()\n-        const MAX_LEN: usize = 39;\n-        serialize_display_bounded_length!(self, MAX_LEN, serializer)\n+        if serializer.is_human_readable() {\n+            /// \"1000:1002:1003:1004:1005:1006:1007:1008\".len()\n+            const MAX_LEN: usize = 39;\n+            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n+        } else {\n+            self.octets().serialize(serializer)\n+        }\n     }\n }\n \n@@ -543,9 +560,18 @@ impl Serialize for net::SocketAddr {\n     where\n         S: Serializer,\n     {\n-        match *self {\n-            net::SocketAddr::V4(ref addr) => addr.serialize(serializer),\n-            net::SocketAddr::V6(ref addr) => addr.serialize(serializer),\n+        if serializer.is_human_readable() {\n+            match *self {\n+                net::SocketAddr::V4(ref addr) => addr.serialize(serializer),\n+                net::SocketAddr::V6(ref addr) => addr.serialize(serializer),\n+            }\n+        } else {\n+            match *self {\n+                net::SocketAddr::V4(ref addr) =>\n+                    serializer.serialize_newtype_variant(\"SocketAddr\", 0, \"V4\", addr),\n+                net::SocketAddr::V6(ref addr) =>\n+                    serializer.serialize_newtype_variant(\"SocketAddr\", 1, \"V6\", addr),\n+            }\n         }\n     }\n }\n@@ -556,9 +582,13 @@ impl Serialize for net::SocketAddrV4 {\n     where\n         S: Serializer,\n     {\n-        /// \"101.102.103.104:65000\".len()\n-        const MAX_LEN: usize = 21;\n-        serialize_display_bounded_length!(self, MAX_LEN, serializer)\n+        if serializer.is_human_readable() {\n+            /// \"101.102.103.104:65000\".len()\n+            const MAX_LEN: usize = 21;\n+            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n+        } else {\n+            (self.ip(), self.port()).serialize(serializer)\n+        }\n     }\n }\n \n@@ -568,9 +598,13 @@ impl Serialize for net::SocketAddrV6 {\n     where\n         S: Serializer,\n     {\n-        /// \"[1000:1002:1003:1004:1005:1006:1007:1008]:65000\".len()\n-        const MAX_LEN: usize = 47;\n-        serialize_display_bounded_length!(self, MAX_LEN, serializer)\n+        if serializer.is_human_readable() {\n+            /// \"[1000:1002:1003:1004:1005:1006:1007:1008]:65000\".len()\n+            const MAX_LEN: usize = 47;\n+            serialize_display_bounded_length!(self, MAX_LEN, serializer)\n+        } else {\n+            (self.ip(), self.port()).serialize(serializer)\n+        }\n     }\n }\n \ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 4356f9303..bbcceac7f 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -1363,6 +1363,15 @@ pub trait Serializer: Sized {\n     fn collect_str<T: ?Sized>(self, value: &T) -> Result<Self::Ok, Self::Error>\n     where\n         T: Display;\n+\n+    /// Returns wheter the data format is human readable or not.\n+    ///\n+    /// Some formats are not intended to be human readable. For these formats\n+    /// a type being serialized may opt to serialize into a more compact form.\n+    ///\n+    /// NOTE: Implementing this method and returning `false` is considered a breaking\n+    /// change as it may alter how any given type tries to serialize itself.\n+    fn is_human_readable(&self) -> bool { true }\n }\n \n /// Returned from `Serializer::serialize_seq`.\n", "test_patch": "diff --git a/serde_test/src/assert.rs b/serde_test/src/assert.rs\nindex 2af2ebf59..7a4b1d4db 100644\n--- a/serde_test/src/assert.rs\n+++ b/serde_test/src/assert.rs\n@@ -47,8 +47,20 @@ pub fn assert_tokens<'de, T>(value: &T, tokens: &'de [Token])\n where\n     T: Serialize + Deserialize<'de> + PartialEq + Debug,\n {\n-    assert_ser_tokens(value, tokens);\n-    assert_de_tokens(value, tokens);\n+    assert_tokens_readable(value, tokens, true);\n+}\n+\n+// Not public API\n+#[doc(hidden)]\n+/// Runs both `assert_ser_tokens` and `assert_de_tokens`.\n+///\n+/// See: `assert_tokens`\n+pub fn assert_tokens_readable<'de, T>(value: &T, tokens: &'de [Token], human_readable: bool)\n+where\n+    T: Serialize + Deserialize<'de> + PartialEq + Debug,\n+{\n+    assert_ser_tokens_readable(value, tokens, human_readable);\n+    assert_de_tokens_readable(value, tokens, human_readable);\n }\n \n /// Asserts that `value` serializes to the given `tokens`.\n@@ -84,7 +96,19 @@ pub fn assert_ser_tokens<T>(value: &T, tokens: &[Token])\n where\n     T: Serialize,\n {\n-    let mut ser = Serializer::new(tokens);\n+    assert_ser_tokens_readable(value, tokens, true)\n+}\n+\n+// Not public API\n+#[doc(hidden)]\n+/// Asserts that `value` serializes to the given `tokens`.\n+///\n+/// See: `assert_ser_tokens`\n+pub fn assert_ser_tokens_readable<T>(value: &T, tokens: &[Token], human_readable: bool)\n+where\n+    T: Serialize,\n+{\n+    let mut ser = Serializer::readable(tokens, human_readable);\n     match value.serialize(&mut ser) {\n         Ok(_) => {}\n         Err(err) => panic!(\"value failed to serialize: {}\", err),\n@@ -183,7 +207,16 @@ pub fn assert_de_tokens<'de, T>(value: &T, tokens: &'de [Token])\n where\n     T: Deserialize<'de> + PartialEq + Debug,\n {\n-    let mut de = Deserializer::new(tokens);\n+    assert_de_tokens_readable(value, tokens, true)\n+}\n+\n+// Not public API\n+#[doc(hidden)]\n+pub fn assert_de_tokens_readable<'de, T>(value: &T, tokens: &'de [Token], human_readable: bool)\n+where\n+    T: Deserialize<'de> + PartialEq + Debug,\n+{\n+    let mut de = Deserializer::readable(tokens, human_readable);\n     match T::deserialize(&mut de) {\n         Ok(v) => assert_eq!(v, *value),\n         Err(e) => panic!(\"tokens failed to deserialize: {}\", e),\ndiff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 9e465a739..8a281d9da 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -16,6 +16,7 @@ use token::Token;\n #[derive(Debug)]\n pub struct Deserializer<'de> {\n     tokens: &'de [Token],\n+    is_human_readable: bool,\n }\n \n macro_rules! assert_next_token {\n@@ -48,7 +49,13 @@ macro_rules! end_of_tokens {\n \n impl<'de> Deserializer<'de> {\n     pub fn new(tokens: &'de [Token]) -> Self {\n-        Deserializer { tokens: tokens }\n+        Deserializer::readable(tokens, true)\n+    }\n+\n+    // Not public API\n+    #[doc(hidden)]\n+    pub fn readable(tokens: &'de [Token], is_human_readable: bool) -> Self {\n+        Deserializer { tokens: tokens, is_human_readable: is_human_readable }\n     }\n \n     fn peek_token_opt(&self) -> Option<Token> {\n@@ -364,6 +371,10 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n             _ => self.deserialize_any(visitor),\n         }\n     }\n+\n+    fn is_human_readable(&self) -> bool {\n+        self.is_human_readable\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////\ndiff --git a/serde_test/src/lib.rs b/serde_test/src/lib.rs\nindex 391837d16..7833d942d 100644\n--- a/serde_test/src/lib.rs\n+++ b/serde_test/src/lib.rs\n@@ -168,8 +168,12 @@ mod token;\n mod assert;\n \n pub use token::Token;\n-pub use assert::{assert_tokens, assert_ser_tokens, assert_ser_tokens_error, assert_de_tokens,\n-                 assert_de_tokens_error};\n+pub use assert::{assert_tokens, assert_ser_tokens, assert_ser_tokens_error,\n+                 assert_de_tokens, assert_de_tokens_error};\n+\n+// Not public API.\n+#[doc(hidden)]\n+pub use assert::{assert_tokens_readable, assert_de_tokens_readable, assert_ser_tokens_readable};\n \n // Not public API.\n #[doc(hidden)]\ndiff --git a/serde_test/src/ser.rs b/serde_test/src/ser.rs\nindex 31ba72eec..a25ade9af 100644\n--- a/serde_test/src/ser.rs\n+++ b/serde_test/src/ser.rs\n@@ -15,12 +15,19 @@ use token::Token;\n #[derive(Debug)]\n pub struct Serializer<'a> {\n     tokens: &'a [Token],\n+    is_human_readable: bool,\n }\n \n impl<'a> Serializer<'a> {\n     /// Creates the serializer.\n     pub fn new(tokens: &'a [Token]) -> Self {\n-        Serializer { tokens: tokens }\n+        Serializer::readable(tokens, true)\n+    }\n+\n+    // Not public API\n+    #[doc(hidden)]\n+    pub fn readable(tokens: &'a [Token], is_human_readable: bool) -> Self {\n+        Serializer { tokens: tokens, is_human_readable: is_human_readable }\n     }\n \n     /// Pulls the next token off of the serializer, ignoring it.\n@@ -282,6 +289,10 @@ impl<'s, 'a> ser::Serializer for &'s mut Serializer<'a> {\n             Ok(Variant { ser: self, end: Token::StructVariantEnd })\n         }\n     }\n+\n+    fn is_human_readable(&self) -> bool {\n+        self.is_human_readable\n+    }\n }\n \n pub struct Variant<'s, 'a: 's> {\ndiff --git a/test_suite/tests/macros/mod.rs b/test_suite/tests/macros/mod.rs\nindex 4f6ea66e9..9a917bcf4 100644\n--- a/test_suite/tests/macros/mod.rs\n+++ b/test_suite/tests/macros/mod.rs\n@@ -73,3 +73,29 @@ macro_rules! hashmap {\n         }\n     }\n }\n+\n+macro_rules! seq_impl {\n+    (seq $first:expr,) => {\n+        seq_impl!(seq $first)\n+    };\n+    ($first:expr,) => {\n+        seq_impl!($first)\n+    };\n+    (seq $first:expr) => {\n+        $first.into_iter()\n+    };\n+    ($first:expr) => {\n+        Some($first).into_iter()\n+    };\n+    (seq $first:expr , $( $elem: tt)*) => {\n+        $first.into_iter().chain(seq!( $($elem)* ))\n+    };\n+    ($first:expr , $($elem: tt)*) => {\n+        Some($first).into_iter().chain(seq!( $($elem)* ))\n+    }\n+}\n+macro_rules! seq {\n+    ($($tt: tt)*) => {\n+        seq_impl!($($tt)*).collect::<Vec<_>>()\n+    };\n+}\ndiff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 9fbfed46c..5318fd88f 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -28,7 +28,7 @@ extern crate fnv;\n use self::fnv::FnvHasher;\n \n extern crate serde_test;\n-use self::serde_test::{Token, assert_de_tokens, assert_de_tokens_error};\n+use self::serde_test::{Token, assert_de_tokens, assert_de_tokens_error, assert_de_tokens_readable};\n \n #[macro_use]\n mod macros;\n@@ -110,15 +110,15 @@ enum EnumSkipAll {\n //////////////////////////////////////////////////////////////////////////\n \n macro_rules! declare_test {\n-    ($name:ident { $($value:expr => $tokens:expr,)+ }) => {\n+    ($name:ident $readable: ident { $($value:expr => $tokens:expr,)+ }) => {\n         #[test]\n         fn $name() {\n             $(\n                 // Test ser/de roundtripping\n-                assert_de_tokens(&$value, $tokens);\n+                assert_de_tokens_readable(&$value, $tokens, $readable);\n \n                 // Test that the tokens are ignorable\n-                assert_de_tokens_ignore($tokens);\n+                assert_de_tokens_ignore($tokens, true);\n             )+\n         }\n     }\n@@ -127,7 +127,7 @@ macro_rules! declare_test {\n macro_rules! declare_tests {\n     ($($name:ident { $($value:expr => $tokens:expr,)+ })+) => {\n         $(\n-            declare_test!($name { $($value => $tokens,)+ });\n+            declare_test!($name true { $($value => $tokens,)+ });\n         )+\n     }\n }\n@@ -143,7 +143,16 @@ macro_rules! declare_error_tests {\n     }\n }\n \n-fn assert_de_tokens_ignore(ignorable_tokens: &[Token]) {\n+macro_rules! declare_non_human_readable_tests {\n+    ($($name:ident { $($value:expr => $tokens:expr,)+ })+) => {\n+        $(\n+            declare_test!($name false { $($value => $tokens,)+ });\n+        )+\n+    }\n+}\n+\n+\n+fn assert_de_tokens_ignore(ignorable_tokens: &[Token], readable: bool) {\n     #[derive(PartialEq, Debug, Deserialize)]\n     struct IgnoreBase {\n         a: i32,\n@@ -163,7 +172,7 @@ fn assert_de_tokens_ignore(ignorable_tokens: &[Token]) {\n             .chain(vec![Token::MapEnd].into_iter())\n             .collect();\n \n-    let mut de = serde_test::Deserializer::new(&concated_tokens);\n+    let mut de = serde_test::Deserializer::readable(&concated_tokens, readable);\n     let base = IgnoreBase::deserialize(&mut de).unwrap();\n     assert_eq!(base, IgnoreBase { a: 1 });\n }\n@@ -754,6 +763,70 @@ declare_tests! {\n     }\n }\n \n+declare_non_human_readable_tests!{\n+    test_non_human_readable_net_ipv4addr {\n+        net::Ipv4Addr::from(*b\"1234\") => &seq![\n+            Token::Tuple { len: 4 },\n+            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd\n+        ],\n+    }\n+    test_non_human_readable_net_ipv6addr {\n+        net::Ipv6Addr::from(*b\"1234567890123456\") => &seq![\n+            Token::Tuple { len: 4 },\n+            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd\n+        ],\n+\n+    }\n+    test_non_human_readable_net_socketaddr {\n+        net::SocketAddr::from((*b\"1234567890123456\", 1234)) => &seq![\n+            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V6\" },\n+\n+            Token::Tuple { len: 2 },\n+\n+            Token::Tuple { len: 16 },\n+            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd,\n+\n+            Token::U16(1234),\n+            Token::TupleEnd\n+        ],\n+        net::SocketAddr::from((*b\"1234\", 1234)) => &seq![\n+            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V4\" },\n+\n+            Token::Tuple { len: 2 },\n+\n+            Token::Tuple { len: 4 },\n+            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd,\n+\n+            Token::U16(1234),\n+            Token::TupleEnd\n+        ],\n+        net::SocketAddrV4::new(net::Ipv4Addr::from(*b\"1234\"), 1234) => &seq![\n+            Token::Tuple { len: 2 },\n+\n+            Token::Tuple { len: 4 },\n+            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd,\n+\n+            Token::U16(1234),\n+            Token::TupleEnd\n+        ],\n+        net::SocketAddrV6::new(net::Ipv6Addr::from(*b\"1234567890123456\"), 1234, 0, 0) => &seq![\n+            Token::Tuple { len: 2 },\n+\n+            Token::Tuple { len: 16 },\n+            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd,\n+\n+            Token::U16(1234),\n+            Token::TupleEnd\n+        ],\n+    }\n+}\n+\n #[cfg(feature = \"unstable\")]\n declare_tests! {\n     test_rc_dst {\n@@ -795,7 +868,7 @@ fn test_osstring() {\n     ];\n \n     assert_de_tokens(&value, &tokens);\n-    assert_de_tokens_ignore(&tokens);\n+    assert_de_tokens_ignore(&tokens, true);\n }\n \n #[cfg(windows)]\n@@ -815,7 +888,7 @@ fn test_osstring() {\n     ];\n \n     assert_de_tokens(&value, &tokens);\n-    assert_de_tokens_ignore(&tokens);\n+    assert_de_tokens_ignore(&tokens, true);\n }\n \n #[cfg(feature = \"unstable\")]\n@@ -1078,3 +1151,39 @@ declare_error_tests! {\n         \"invalid type: sequence, expected unit struct UnitStruct\",\n     }\n }\n+\n+#[derive(Debug, PartialEq)]\n+struct CompactBinary((u8, u8));\n+\n+impl<'de> serde::Deserialize<'de> for CompactBinary {\n+    fn deserialize<D>(deserializer: D) -> Result<CompactBinary, D::Error>\n+    where\n+        D: serde::Deserializer<'de>,\n+    {\n+        if deserializer.is_human_readable() {\n+            <(u8, u8)>::deserialize(deserializer).map(CompactBinary)\n+        } else {\n+            <&[u8]>::deserialize(deserializer).map(|bytes| {\n+                CompactBinary((bytes[0], bytes[1]))\n+            })\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_human_readable() {\n+    assert_de_tokens(\n+        &CompactBinary((1, 2)),\n+        &[\n+            Token::Tuple { len: 2},\n+            Token::U8(1),\n+            Token::U8(2),\n+            Token::TupleEnd,\n+        ],\n+    );\n+    assert_de_tokens_readable(\n+        &CompactBinary((1, 2)),\n+        &[Token::BorrowedBytes(&[1, 2])],\n+        false,\n+    );\n+}\ndiff --git a/test_suite/tests/test_roundtrip.rs b/test_suite/tests/test_roundtrip.rs\nnew file mode 100644\nindex 000000000..eee7e83cd\n--- /dev/null\n+++ b/test_suite/tests/test_roundtrip.rs\n@@ -0,0 +1,45 @@\n+extern crate serde_test;\n+use self::serde_test::{Token, assert_tokens_readable};\n+\n+use std::net;\n+\n+#[macro_use]\n+#[allow(unused_macros)]\n+mod macros;\n+\n+#[test]\n+fn ip_addr_roundtrip() {\n+\n+    assert_tokens_readable(\n+        &net::IpAddr::from(*b\"1234\"),\n+        &seq![\n+            Token::NewtypeVariant { name: \"IpAddr\", variant: \"V4\" },\n+\n+            Token::Tuple { len: 4 },\n+            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd,\n+        ],\n+        false,\n+    );\n+}\n+\n+#[test]\n+fn socked_addr_roundtrip() {\n+\n+    assert_tokens_readable(\n+        &net::SocketAddr::from((*b\"1234567890123456\", 1234)),\n+        &seq![\n+            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V6\" },\n+\n+            Token::Tuple { len: 2 },\n+\n+            Token::Tuple { len: 16 },\n+            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd,\n+\n+            Token::U16(1234),\n+            Token::TupleEnd,\n+        ],\n+        false,\n+    );\n+}\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex 9dfb70532..3f3fa61c5 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -23,7 +23,8 @@ use std::str;\n extern crate serde;\n \n extern crate serde_test;\n-use self::serde_test::{Token, assert_ser_tokens, assert_ser_tokens_error};\n+use self::serde_test::{Token, assert_ser_tokens, assert_ser_tokens_error,\n+                       assert_ser_tokens_readable};\n \n extern crate fnv;\n use self::fnv::FnvHasher;\n@@ -77,6 +78,19 @@ macro_rules! declare_tests {\n     }\n }\n \n+macro_rules! declare_non_human_readable_tests {\n+    ($($name:ident { $($value:expr => $tokens:expr,)+ })+) => {\n+        $(\n+            #[test]\n+            fn $name() {\n+                $(\n+                    assert_ser_tokens_readable(&$value, $tokens, false);\n+                )+\n+            }\n+        )+\n+    }\n+}\n+\n declare_tests! {\n     test_unit {\n         () => &[Token::Unit],\n@@ -397,6 +411,66 @@ declare_tests! {\n     }\n }\n \n+declare_non_human_readable_tests!{\n+    test_non_human_readable_net_ipv4addr {\n+        net::Ipv4Addr::from(*b\"1234\") => &seq![\n+            Token::Tuple { len: 4 },\n+            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd,\n+        ],\n+    }\n+    test_non_human_readable_net_ipv6addr {\n+        net::Ipv6Addr::from(*b\"1234567890123456\") => &seq![\n+            Token::Tuple { len: 16 },\n+            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd,\n+        ],\n+    }\n+    test_non_human_readable_net_ipaddr {\n+        net::IpAddr::from(*b\"1234\") => &seq![\n+            Token::NewtypeVariant { name: \"IpAddr\", variant: \"V4\" },\n+\n+            Token::Tuple { len: 4 },\n+            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd,\n+        ],\n+    }\n+    test_non_human_readable_net_socketaddr {\n+        net::SocketAddr::from((*b\"1234567890123456\", 1234)) => &seq![\n+            Token::NewtypeVariant { name: \"SocketAddr\", variant: \"V6\" },\n+\n+            Token::Tuple { len: 2 },\n+\n+            Token::Tuple { len: 16 },\n+            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd,\n+\n+            Token::U16(1234),\n+            Token::TupleEnd,\n+        ],\n+        net::SocketAddrV4::new(net::Ipv4Addr::from(*b\"1234\"), 1234) => &seq![\n+            Token::Tuple { len: 2 },\n+\n+            Token::Tuple { len: 4 },\n+            seq b\"1234\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd,\n+\n+            Token::U16(1234),\n+            Token::TupleEnd,\n+        ],\n+        net::SocketAddrV6::new(net::Ipv6Addr::from(*b\"1234567890123456\"), 1234, 0, 0) => &seq![\n+            Token::Tuple { len: 2 },\n+\n+            Token::Tuple { len: 16 },\n+            seq b\"1234567890123456\".iter().map(|&b| Token::U8(b)),\n+            Token::TupleEnd,\n+\n+            Token::U16(1234),\n+            Token::TupleEnd,\n+        ],\n+    }\n+}\n+\n // Serde's implementation is not unstable, but the constructors are.\n #[cfg(feature = \"unstable\")]\n declare_tests! {\n@@ -474,3 +548,26 @@ fn test_enum_skipped() {\n         \"the enum variant Enum::SkippedMap cannot be serialized\",\n     );\n }\n+\n+struct CompactBinary(String);\n+\n+impl serde::Serialize for CompactBinary {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: serde::Serializer\n+    {\n+        if serializer.is_human_readable() {\n+            serializer.serialize_str(&self.0)\n+        } else {\n+            serializer.serialize_bytes(self.0.as_bytes())\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_human_readable() {\n+    let value = CompactBinary(\"test\".to_string());\n+    assert_ser_tokens(&value, &[Token::String(\"test\")]);\n+\n+    assert_ser_tokens_readable(&value, &[Token::Bytes(b\"test\")], false);\n+}\n", "problem_statement": "Allow representation to differ between human-readable and binary formats\nAs an initial brainstormed approach to give an example of what I have in mind:\r\n\r\n```rust\r\ntrait Serializer {\r\n    /* existing associated types and methods */\r\n\r\n    fn serialize_readable_or_compact<T>(self, t: T) -> Result<Self::Ok, Self::Error>\r\n        where T: SerializeReadable + SerializeCompact;\r\n}\r\n\r\ntrait SerializeReadable { /* just like Serialize */ }\r\ntrait SerializeCompact { /* just like Serialize */ }\r\n```\r\n\r\n... and similar for deserialization.\r\n\r\nThe idea is that chrono::DateTime, std::net::IpAddr etc can serialize themselves as a string in JSON and YAML but compact bytes in Bincode. Currently a SocketAddrV6 takes up to 55 bytes to represent in Bincode but should only be 18 bytes.\n", "hints_text": "I think I'd describe data in this form as a \"blob;\" formats like JSON can only store arbitrary data as strings, whereas formats like bincode can store any arbitrary bytes. I have an idea for how I'd implement this and I'll post it later once I write it up.\nPerhaps like this?\r\n\r\n```\r\ntrait Serializer {\r\n    // existing stuff\r\n    fn serialize_blob<T>(self, t: T) -> Result<Self::Ok, Self::Error> where T: SerializeBlob;\r\n}\r\n\r\ntrait SerializeBlob: Display {\r\n    fn fmt_bytes<W>(&self, writer: W) -> io::Result<()> where W: io::Write {\r\n        write!(writer, \"{}\", self)\r\n    }\r\n}\r\n```\r\n\r\nI'm open for ideas on how to do this without requiring libstd. I'd rather it not be too complicated, though.\nWhat do you see as the advantages of that approach? Here are some disadvantages:\r\n\r\n- If you are calling serialize_blob, you want the representation to be different in bytes form vs string form so the default implementation of fmt_bytes is never what you want. Otherwise you would just use collect_str instead of serialize_blob.\r\n- Only supports string/byte representations rather than a more general concept of readable and compact, which may be a non-string in the readable case (for example a map) and non-bytes in the compact case (for example a tuple of integers for an IP address).\r\n\nOf course here is the KISS approach:\r\n\r\n```rust\r\ntrait Serializer {\r\n    /* existing associated types and methods */\r\n\r\n    #[inline]\r\n    fn is_human_readable() -> bool { true }\r\n}\r\n```\r\n\r\n```rust\r\nfn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\r\n    where S: Serializer\r\n{\r\n    if S::is_human_readable() {\r\n        serializer.collect_str(self)\r\n    } else {\r\n        serializer.serialize_bytes(self.as_bytes())\r\n    }\r\n}\r\n```\nI like it, although I think that it'd be nice to have a method that enables the user to test both branches without having to change anything in the serializer.\r\n\r\nPerhaps we could add a separate `serialize_binary` method that defaults to delegating to `serialize` and is called by the serializer if appropriate?", "created_at": "2017-09-07T14:16:40Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1022, "instance_id": "serde-rs__serde-1022", "issue_numbers": ["960"], "base_commit": "d4042872f5afa48a25fea933bfb749388f76dd8d", "patch": "diff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 4356f9303..e934adb96 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -1727,6 +1727,13 @@ pub trait SerializeStruct {\n     where\n         T: Serialize;\n \n+    /// Indicate that a struct field has been skipped.\n+    #[inline]\n+    fn skip_field(&mut self, key: &'static str) -> Result<(), Self::Error> {\n+        let _ = key;\n+        Ok(())\n+    }\n+\n     /// Finish serializing a struct.\n     fn end(self) -> Result<Self::Ok, Self::Error>;\n }\n@@ -1772,6 +1779,13 @@ pub trait SerializeStructVariant {\n     where\n         T: Serialize;\n \n+    /// Indicate that a struct variant field has been skipped.\n+    #[inline]\n+    fn skip_field(&mut self, key: &'static str) -> Result<(), Self::Error> {\n+        let _ = key;\n+        Ok(())\n+    }\n+\n     /// Finish serializing a struct variant.\n     fn end(self) -> Result<Self::Ok, Self::Error>;\n }\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 5ab6d0a9b..8f6f717ba 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -1384,26 +1384,27 @@ fn deserialize_identifier(\n         \"field identifier\"\n     };\n \n-    let visit_index = if is_variant {\n-        let variant_indices = 0u32..;\n-        let fallthrough_msg = format!(\"variant index 0 <= i < {}\", fields.len());\n-        let visit_index = quote! {\n-            fn visit_u32<__E>(self, __value: u32) -> _serde::export::Result<Self::Value, __E>\n-                where __E: _serde::de::Error\n-            {\n-                match __value {\n-                    #(\n-                        #variant_indices => _serde::export::Ok(#constructors),\n-                    )*\n-                    _ => _serde::export::Err(_serde::de::Error::invalid_value(\n-                                _serde::de::Unexpected::Unsigned(__value as u64),\n-                                &#fallthrough_msg))\n-                }\n-            }\n-        };\n-        Some(visit_index)\n+    let index_expecting = if is_variant {\n+        \"variant\"\n     } else {\n-        None\n+        \"field\"\n+    };\n+\n+    let variant_indices = 0u32..;\n+    let fallthrough_msg = format!(\"{} index 0 <= i < {}\", index_expecting, fields.len());\n+    let visit_index = quote! {\n+        fn visit_u32<__E>(self, __value: u32) -> _serde::export::Result<Self::Value, __E>\n+            where __E: _serde::de::Error\n+        {\n+            match __value {\n+                #(\n+                    #variant_indices => _serde::export::Ok(#constructors),\n+                )*\n+                _ => _serde::export::Err(_serde::de::Error::invalid_value(\n+                            _serde::de::Unexpected::Unsigned(__value as u64),\n+                            &#fallthrough_msg))\n+            }\n+        }\n     };\n \n     let bytes_to_str = if fallthrough.is_some() {\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 9be9bddca..9c3310be5 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -242,6 +242,7 @@ fn serialize_struct(params: &Parameters, fields: &[Field], cattrs: &attr::Contai\n         params,\n         false,\n         quote!(_serde::ser::SerializeStruct::serialize_field),\n+        quote!(_serde::ser::SerializeStruct::skip_field),\n     );\n \n     let type_name = cattrs.name().serialize_name();\n@@ -707,15 +708,23 @@ fn serialize_struct_variant<'a>(\n     fields: &[Field],\n     name: &str,\n ) -> Fragment {\n-    let method = match context {\n+    let (method, skip_method) = match context {\n         StructVariant::ExternallyTagged { .. } => {\n-            quote!(_serde::ser::SerializeStructVariant::serialize_field)\n+            (\n+                quote!(_serde::ser::SerializeStructVariant::serialize_field),\n+                quote!(_serde::ser::SerializeStructVariant::skip_field),\n+            )\n         }\n         StructVariant::InternallyTagged { .. } |\n-        StructVariant::Untagged => quote!(_serde::ser::SerializeStruct::serialize_field),\n+        StructVariant::Untagged => {\n+            (\n+                quote!(_serde::ser::SerializeStruct::serialize_field),\n+                quote!(_serde::ser::SerializeStruct::skip_field),\n+            )\n+        }\n     };\n \n-    let serialize_fields = serialize_struct_visitor(fields, params, true, method);\n+    let serialize_fields = serialize_struct_visitor(fields, params, true, method, skip_method);\n \n     let mut serialized_fields = fields\n         .iter()\n@@ -829,6 +838,7 @@ fn serialize_struct_visitor(\n     params: &Parameters,\n     is_enum: bool,\n     func: Tokens,\n+    skip_func: Tokens,\n ) -> Vec<Tokens> {\n     fields\n         .iter()\n@@ -859,7 +869,15 @@ fn serialize_struct_visitor(\n \n                 match skip {\n                     None => ser,\n-                    Some(skip) => quote!(if !#skip { #ser }),\n+                    Some(skip) => {\n+                        quote! {\n+                            if !#skip {\n+                                #ser\n+                            } else {\n+                                try!(#skip_func(&mut __serde_state, #key_expr));\n+                            }\n+                        }\n+                    }\n                 }\n             },\n         )\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 9fbfed46c..da7232a51 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -521,6 +521,15 @@ declare_tests! {\n                 Token::I32(2),\n             Token::MapEnd,\n         ],\n+        Struct { a: 1, b: 2, c: 0 } => &[\n+            Token::Map { len: Some(3) },\n+                Token::U32(0),\n+                Token::I32(1),\n+\n+                Token::U32(1),\n+                Token::I32(2),\n+            Token::MapEnd,\n+        ],\n         Struct { a: 1, b: 2, c: 0 } => &[\n             Token::Struct { name: \"Struct\", len: 3 },\n                 Token::Str(\"a\"),\n", "problem_statement": "Pass field index to SerializeStruct::serialize_field\nSimilar to how `Serializer::serialize_*_variant` receives both the index and name of the variant. This would enable CBOR to deserialize correctly from a packed representation (integer keys) with fields that are conditionally skipped - https://github.com/pyfisch/cbor/issues/37.\n", "hints_text": "Possible approach:\r\n\r\n```rust\r\npub trait SerializeStruct {\r\n    type Ok;\r\n    type Error: Error;\r\n    fn serialize_field<T: ?Sized>(\r\n        &mut self, \r\n        key: &'static str, \r\n        value: &T\r\n    ) -> Result<(), Self::Error>\r\n    where\r\n        T: Serialize;\r\n\r\n    fn serialize_indexed_field<T: ?Sized>(\r\n        &mut self,\r\n        key: &'static str,\r\n        key_index: u32,\r\n        value: &T\r\n    ) -> Result<(), Self::Error>\r\n    where\r\n        T: Serialize\r\n    {\r\n        self.serialize_field(key, value)\r\n    }\r\n\r\n    fn end(self) -> Result<Self::Ok, Self::Error>;\r\n}\r\n```\r\n\r\nSerializers that care about packed encodings would override both methods and everything else could ignore serialize_indexed_field. serde_derive would call into serialize_indexed_field, assuming it can force a bump of serde along side it which seems reasonable.\nA different approach:\r\n\r\n```rust\r\n// SerializeStruct\r\nfn skip_field(&mut self, key: &'static str) -> Result<(), Self::Error> {\r\n    Ok(())\r\n}\r\n\r\n// Serialize\r\nif $skip_serializing(&self.x) {\r\n    s.skip_field(\"x\")?;\r\n} else {\r\n    s.serialize_field(\"x\", &self.x)?;\r\n}\r\n```\r\n\r\n- No longer exposes the possibility of serializing fields out of numerical order, as in https://github.com/serde-rs/serde/pull/961#issuecomment-310588663.\r\n- Bincode and friends can return an error on skipped fields with zero overhead when there are no skipped fields.\r\n- Serializers that require a field index don't need to awkwardly override both `serialize_field` and `serialize_indexed_field`.\r\n- Serializers receive the name of skipped fields for better error messages.\r\n\r\nThoughts?\nThat sounds like a good approach - not having to deal with both `serialize_field` and `serialize_indexed_field` is nice.", "created_at": "2017-08-19T17:30:50Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1015, "instance_id": "serde-rs__serde-1015", "issue_numbers": ["1013"], "base_commit": "0681cd50032a548f1ee060110c957997769a14b7", "patch": "diff --git a/serde_derive/src/bound.rs b/serde_derive/src/bound.rs\nindex 77e7824a4..0160fa85c 100644\n--- a/serde_derive/src/bound.rs\n+++ b/serde_derive/src/bound.rs\n@@ -10,7 +10,7 @@ use std::collections::HashSet;\n \n use syn::{self, visit};\n \n-use internals::ast::Container;\n+use internals::ast::{Body, Container};\n use internals::attr;\n \n macro_rules! path {\n@@ -88,7 +88,7 @@ pub fn with_bound<F>(\n     bound: &syn::Path,\n ) -> syn::Generics\n where\n-    F: Fn(&attr::Field) -> bool,\n+    F: Fn(&attr::Field, Option<&attr::Variant>) -> bool,\n {\n     struct FindTyParams {\n         // Set of all generic type parameters on the current struct (A, B, C in\n@@ -124,17 +124,27 @@ where\n         .map(|ty_param| ty_param.ident.clone())\n         .collect();\n \n-    let relevant_tys = cont.body\n-        .all_fields()\n-        .filter(|&field| filter(&field.attrs))\n-        .map(|field| &field.ty);\n-\n     let mut visitor = FindTyParams {\n         all_ty_params: all_ty_params,\n         relevant_ty_params: HashSet::new(),\n     };\n-    for ty in relevant_tys {\n-        visit::walk_ty(&mut visitor, ty);\n+    match cont.body {\n+        Body::Enum(ref variants) => {\n+            for variant in variants.iter() {\n+                let relevant_fields = variant\n+                    .fields\n+                    .iter()\n+                    .filter(|field| filter(&field.attrs, Some(&variant.attrs)));\n+                for field in relevant_fields {\n+                    visit::walk_ty(&mut visitor, field.ty);\n+                }\n+            }\n+        }\n+        Body::Struct(_, ref fields) => {\n+            for field in fields.iter().filter(|field| filter(&field.attrs, None)) {\n+                visit::walk_ty(&mut visitor, field.ty);\n+            }\n+        }\n     }\n \n     let new_predicates = generics\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 5ab6d0a9b..b3589f557 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -157,14 +157,17 @@ fn build_generics(cont: &Container) -> syn::Generics {\n // deserialized by us so we do not generate a bound. Fields with a `bound`\n // attribute specify their own bound so we do not generate one. All other fields\n // may need a `T: Deserialize` bound where T is the type of the field.\n-fn needs_deserialize_bound(attrs: &attr::Field) -> bool {\n-    !attrs.skip_deserializing() && attrs.deserialize_with().is_none() && attrs.de_bound().is_none()\n+fn needs_deserialize_bound(field: &attr::Field, variant: Option<&attr::Variant>) -> bool {\n+    !field.skip_deserializing() &&\n+    field.deserialize_with().is_none() &&\n+    field.de_bound().is_none() &&\n+    variant.map_or(true, |variant| variant.deserialize_with().is_none())\n }\n \n // Fields with a `default` attribute (not `default=...`), and fields with a\n // `skip_deserializing` attribute that do not also have `default=...`.\n-fn requires_default(attrs: &attr::Field) -> bool {\n-    attrs.default() == &attr::Default::Default\n+fn requires_default(field: &attr::Field, _variant: Option<&attr::Variant>) -> bool {\n+    field.default() == &attr::Default::Default\n }\n \n // The union of lifetimes borrowed by each field of the container.\n@@ -372,7 +375,7 @@ fn deserialize_seq(\n                         quote!(try!(_serde::de::SeqAccess::next_element::<#field_ty>(&mut __seq)))\n                     }\n                     Some(path) => {\n-                        let (wrapper, wrapper_ty) = wrap_deserialize_with(\n+                        let (wrapper, wrapper_ty) = wrap_deserialize_field_with(\n                             params, field.ty, path);\n                         quote!({\n                             #wrapper\n@@ -428,7 +431,7 @@ fn deserialize_newtype_struct(type_path: &Tokens, params: &Parameters, field: &F\n             }\n         }\n         Some(path) => {\n-            let (wrapper, wrapper_ty) = wrap_deserialize_with(params, field.ty, path);\n+            let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n             quote!({\n                 #wrapper\n                 try!(<#wrapper_ty as _serde::Deserialize>::deserialize(__e)).value\n@@ -1084,6 +1087,16 @@ fn deserialize_externally_tagged_variant(\n     variant: &Variant,\n     cattrs: &attr::Container,\n ) -> Fragment {\n+    if let Some(path) = variant.attrs.deserialize_with() {\n+        let (wrapper, wrapper_ty, unwrap_fn) =\n+            wrap_deserialize_variant_with(params, &variant, path);\n+        return quote_block! {\n+            #wrapper\n+            _serde::export::Result::map(\n+                _serde::de::VariantAccess::newtype_variant::<#wrapper_ty>(__variant), #unwrap_fn)\n+        };\n+    }\n+\n     let variant_ident = &variant.ident;\n \n     match variant.style {\n@@ -1112,6 +1125,10 @@ fn deserialize_internally_tagged_variant(\n     cattrs: &attr::Container,\n     deserializer: Tokens,\n ) -> Fragment {\n+    if variant.attrs.deserialize_with().is_some() {\n+        return deserialize_untagged_variant(params, variant, cattrs, deserializer);\n+    }\n+\n     let variant_ident = &variant.ident;\n \n     match variant.style {\n@@ -1137,6 +1154,16 @@ fn deserialize_untagged_variant(\n     cattrs: &attr::Container,\n     deserializer: Tokens,\n ) -> Fragment {\n+    if let Some(path) = variant.attrs.deserialize_with() {\n+        let (wrapper, wrapper_ty, unwrap_fn) =\n+            wrap_deserialize_variant_with(params, &variant, path);\n+        return quote_block! {\n+            #wrapper\n+            _serde::export::Result::map(\n+                <#wrapper_ty as _serde::Deserialize>::deserialize(#deserializer), #unwrap_fn)\n+        };\n+    }\n+\n     let variant_ident = &variant.ident;\n \n     match variant.style {\n@@ -1198,7 +1225,7 @@ fn deserialize_externally_tagged_newtype_variant(\n             }\n         }\n         Some(path) => {\n-            let (wrapper, wrapper_ty) = wrap_deserialize_with(params, field.ty, path);\n+            let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n             quote_block! {\n                 #wrapper\n                 _serde::export::Result::map(\n@@ -1226,7 +1253,7 @@ fn deserialize_untagged_newtype_variant(\n             }\n         }\n         Some(path) => {\n-            let (wrapper, wrapper_ty) = wrap_deserialize_with(params, field.ty, path);\n+            let (wrapper, wrapper_ty) = wrap_deserialize_field_with(params, field.ty, path);\n             quote_block! {\n                 #wrapper\n                 _serde::export::Result::map(\n@@ -1528,7 +1555,7 @@ fn deserialize_map(\n                     }\n                 }\n                 Some(path) => {\n-                    let (wrapper, wrapper_ty) = wrap_deserialize_with(\n+                    let (wrapper, wrapper_ty) = wrap_deserialize_field_with(\n                         params, field.ty, path);\n                     quote!({\n                         #wrapper\n@@ -1661,7 +1688,7 @@ fn field_i(i: usize) -> Ident {\n /// in a trait to prevent it from accessing the internal `Deserialize` state.\n fn wrap_deserialize_with(\n     params: &Parameters,\n-    field_ty: &syn::Ty,\n+    value_ty: Tokens,\n     deserialize_with: &syn::Path,\n ) -> (Tokens, Tokens) {\n     let this = &params.this;\n@@ -1669,7 +1696,7 @@ fn wrap_deserialize_with(\n \n     let wrapper = quote! {\n         struct __DeserializeWith #de_impl_generics #where_clause {\n-            value: #field_ty,\n+            value: #value_ty,\n             phantom: _serde::export::PhantomData<#this #ty_generics>,\n             lifetime: _serde::export::PhantomData<&'de ()>,\n         }\n@@ -1692,6 +1719,68 @@ fn wrap_deserialize_with(\n     (wrapper, wrapper_ty)\n }\n \n+fn wrap_deserialize_field_with(\n+    params: &Parameters,\n+    field_ty: &syn::Ty,\n+    deserialize_with: &syn::Path,\n+) -> (Tokens, Tokens) {\n+    wrap_deserialize_with(params, quote!(#field_ty), deserialize_with)\n+}\n+\n+fn wrap_deserialize_variant_with(\n+    params: &Parameters,\n+    variant: &Variant,\n+    deserialize_with: &syn::Path,\n+) -> (Tokens, Tokens, Tokens) {\n+    let this = &params.this;\n+    let variant_ident = &variant.ident;\n+\n+    let field_tys = variant.fields.iter().map(|field| field.ty);\n+    let (wrapper, wrapper_ty) =\n+        wrap_deserialize_with(params, quote!((#(#field_tys),*)), deserialize_with);\n+\n+    let field_access = (0..variant.fields.len()).map(|n| Ident::new(format!(\"{}\", n)));\n+    let unwrap_fn = match variant.style {\n+        Style::Struct => {\n+            let field_idents = variant.fields.iter().map(|field| field.ident.as_ref().unwrap());\n+            quote! {\n+                {\n+                    |__wrap| {\n+                        #this::#variant_ident { #(#field_idents: __wrap.value.#field_access),* }\n+                    }\n+                }\n+            }\n+        }\n+        Style::Tuple => {\n+            quote! {\n+                {\n+                    |__wrap| {\n+                        #this::#variant_ident(#(__wrap.value.#field_access),*)\n+                    }\n+                }\n+            }\n+        }\n+        Style::Newtype => {\n+            quote! {\n+                {\n+                    |__wrap| {\n+                        #this::#variant_ident(__wrap.value)\n+                    }\n+                }\n+            }\n+        }\n+        Style::Unit => {\n+            quote! {\n+                {\n+                    |__wrap| { #this::#variant_ident }\n+                }\n+            }\n+        }\n+    };\n+\n+    (wrapper, wrapper_ty, unwrap_fn)\n+}\n+\n fn expr_is_missing(field: &Field, cattrs: &attr::Container) -> Fragment {\n     match *field.attrs.default() {\n         attr::Default::Default => {\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 9be9bddca..c904c45e7 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -143,12 +143,16 @@ fn build_generics(cont: &Container) -> syn::Generics {\n     }\n }\n \n-// Fields with a `skip_serializing` or `serialize_with` attribute are not\n-// serialized by us so we do not generate a bound. Fields with a `bound`\n-// attribute specify their own bound so we do not generate one. All other fields\n-// may need a `T: Serialize` bound where T is the type of the field.\n-fn needs_serialize_bound(attrs: &attr::Field) -> bool {\n-    !attrs.skip_serializing() && attrs.serialize_with().is_none() && attrs.ser_bound().is_none()\n+// Fields with a `skip_serializing` or `serialize_with` attribute, or which\n+// belong to a variant with a `serialize_with` attribute, are not serialized by\n+// us so we do not generate a bound. Fields with a `bound` attribute specify\n+// their own bound so we do not generate one. All other fields may need a `T:\n+// Serialize` bound where T is the type of the field.\n+fn needs_serialize_bound(field: &attr::Field, variant: Option<&attr::Variant>) -> bool {\n+    !field.skip_serializing() &&\n+    field.serialize_with().is_none() &&\n+    field.ser_bound().is_none() &&\n+    variant.map_or(true, |variant| variant.serialize_with().is_none())\n }\n \n fn serialize_body(cont: &Container, params: &Parameters) -> Fragment {\n@@ -203,7 +207,7 @@ fn serialize_newtype_struct(\n \n     let mut field_expr = get_field(params, field, 0);\n     if let Some(path) = field.attrs.serialize_with() {\n-        field_expr = wrap_serialize_with(params, field.ty, path, field_expr);\n+        field_expr = wrap_serialize_field_with(params, field.ty, path, field_expr);\n     }\n \n     quote_expr! {\n@@ -395,6 +399,19 @@ fn serialize_externally_tagged_variant(\n     let type_name = cattrs.name().serialize_name();\n     let variant_name = variant.attrs.name().serialize_name();\n \n+    if let Some(path) = variant.attrs.serialize_with() {\n+        let ser = wrap_serialize_variant_with(params, path, &variant);\n+        return quote_expr! {\n+            _serde::Serializer::serialize_newtype_variant(\n+                __serializer,\n+                #type_name,\n+                #variant_index,\n+                #variant_name,\n+                #ser,\n+            )\n+        };\n+    }\n+\n     match variant.style {\n         Style::Unit => {\n             quote_expr! {\n@@ -410,7 +427,7 @@ fn serialize_externally_tagged_variant(\n             let field = &variant.fields[0];\n             let mut field_expr = quote!(__field0);\n             if let Some(path) = field.attrs.serialize_with() {\n-                field_expr = wrap_serialize_with(params, field.ty, path, field_expr);\n+                field_expr = wrap_serialize_field_with(params, field.ty, path, field_expr);\n             }\n \n             quote_expr! {\n@@ -460,6 +477,20 @@ fn serialize_internally_tagged_variant(\n     let enum_ident_str = params.type_name();\n     let variant_ident_str = variant.ident.as_ref();\n \n+    if let Some(path) = variant.attrs.serialize_with() {\n+        let ser = wrap_serialize_variant_with(params, path, &variant);\n+        return quote_expr! {\n+            _serde::private::ser::serialize_tagged_newtype(\n+                __serializer,\n+                #enum_ident_str,\n+                #variant_ident_str,\n+                #tag,\n+                #variant_name,\n+                #ser,\n+            )\n+        };\n+    }\n+\n     match variant.style {\n         Style::Unit => {\n             quote_block! {\n@@ -474,7 +505,7 @@ fn serialize_internally_tagged_variant(\n             let field = &variant.fields[0];\n             let mut field_expr = quote!(__field0);\n             if let Some(path) = field.attrs.serialize_with() {\n-                field_expr = wrap_serialize_with(params, field.ty, path, field_expr);\n+                field_expr = wrap_serialize_field_with(params, field.ty, path, field_expr);\n             }\n \n             quote_expr! {\n@@ -515,44 +546,57 @@ fn serialize_adjacently_tagged_variant(\n     let variant_name = variant.attrs.name().serialize_name();\n \n     let inner = Stmts(\n-        match variant.style {\n-            Style::Unit => {\n-                return quote_block! {\n-                    let mut __struct = try!(_serde::Serializer::serialize_struct(\n-                        __serializer, #type_name, 1));\n-                    try!(_serde::ser::SerializeStruct::serialize_field(\n-                        &mut __struct, #tag, #variant_name));\n-                    _serde::ser::SerializeStruct::end(__struct)\n-                };\n+        if let Some(path) = variant.attrs.serialize_with() {\n+            let ser = wrap_serialize_variant_with(params, path, &variant);\n+            quote_expr! {\n+                _serde::Serialize::serialize(#ser, __serializer)\n             }\n-            Style::Newtype => {\n-                let field = &variant.fields[0];\n-                let mut field_expr = quote!(__field0);\n-                if let Some(path) = field.attrs.serialize_with() {\n-                    field_expr = wrap_serialize_with(params, field.ty, path, field_expr);\n+        } else {\n+            match variant.style {\n+                Style::Unit => {\n+                    return quote_block! {\n+                        let mut __struct = try!(_serde::Serializer::serialize_struct(\n+                            __serializer, #type_name, 1));\n+                        try!(_serde::ser::SerializeStruct::serialize_field(\n+                            &mut __struct, #tag, #variant_name));\n+                        _serde::ser::SerializeStruct::end(__struct)\n+                    };\n                 }\n+                Style::Newtype => {\n+                    let field = &variant.fields[0];\n+                    let mut field_expr = quote!(__field0);\n+                    if let Some(path) = field.attrs.serialize_with() {\n+                        field_expr = wrap_serialize_field_with(params, field.ty, path, field_expr);\n+                    }\n \n-                quote_expr! {\n-                    _serde::Serialize::serialize(#field_expr, __serializer)\n+                    quote_expr! {\n+                        _serde::Serialize::serialize(#field_expr, __serializer)\n+                    }\n+                }\n+                Style::Tuple => {\n+                    serialize_tuple_variant(TupleVariant::Untagged, params, &variant.fields)\n+                }\n+                Style::Struct => {\n+                    serialize_struct_variant(\n+                        StructVariant::Untagged,\n+                        params,\n+                        &variant.fields,\n+                        &variant_name,\n+                    )\n                 }\n-            }\n-            Style::Tuple => {\n-                serialize_tuple_variant(TupleVariant::Untagged, params, &variant.fields)\n-            }\n-            Style::Struct => {\n-                serialize_struct_variant(\n-                    StructVariant::Untagged,\n-                    params,\n-                    &variant.fields,\n-                    &variant_name,\n-                )\n             }\n         },\n     );\n \n     let fields_ty = variant.fields.iter().map(|f| &f.ty);\n     let ref fields_ident: Vec<_> = match variant.style {\n-        Style::Unit => unreachable!(),\n+        Style::Unit => {\n+            if variant.attrs.serialize_with().is_some() {\n+                vec![]\n+            } else {\n+                unreachable!()\n+            }\n+        }\n         Style::Newtype => vec![Ident::new(\"__field0\")],\n         Style::Tuple => {\n             (0..variant.fields.len())\n@@ -576,7 +620,11 @@ fn serialize_adjacently_tagged_variant(\n \n     let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n \n-    let wrapper_generics = bound::with_lifetime_bound(&params.generics, \"'__a\");\n+    let wrapper_generics = if let Style::Unit = variant.style {\n+        params.generics.clone()\n+    } else {\n+        bound::with_lifetime_bound(&params.generics, \"'__a\")\n+    };\n     let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n \n     quote_block! {\n@@ -612,6 +660,13 @@ fn serialize_untagged_variant(\n     variant: &Variant,\n     cattrs: &attr::Container,\n ) -> Fragment {\n+    if let Some(path) = variant.attrs.serialize_with() {\n+        let ser = wrap_serialize_variant_with(params, path, &variant);\n+        return quote_expr! {\n+            _serde::Serialize::serialize(#ser, __serializer)\n+        };\n+    }\n+\n     match variant.style {\n         Style::Unit => {\n             quote_expr! {\n@@ -622,7 +677,7 @@ fn serialize_untagged_variant(\n             let field = &variant.fields[0];\n             let mut field_expr = quote!(__field0);\n             if let Some(path) = field.attrs.serialize_with() {\n-                field_expr = wrap_serialize_with(params, field.ty, path, field_expr);\n+                field_expr = wrap_serialize_field_with(params, field.ty, path, field_expr);\n             }\n \n             quote_expr! {\n@@ -808,7 +863,7 @@ fn serialize_tuple_struct_visitor(\n                     .map(|path| quote!(#path(#field_expr)));\n \n                 if let Some(path) = field.attrs.serialize_with() {\n-                    field_expr = wrap_serialize_with(params, field.ty, path, field_expr);\n+                    field_expr = wrap_serialize_field_with(params, field.ty, path, field_expr);\n                 }\n \n                 let ser = quote! {\n@@ -850,7 +905,7 @@ fn serialize_struct_visitor(\n                     .map(|path| quote!(#path(#field_expr)));\n \n                 if let Some(path) = field.attrs.serialize_with() {\n-                    field_expr = wrap_serialize_with(params, field.ty, path, field_expr)\n+                    field_expr = wrap_serialize_field_with(params, field.ty, path, field_expr);\n                 }\n \n                 let ser = quote! {\n@@ -866,21 +921,56 @@ fn serialize_struct_visitor(\n         .collect()\n }\n \n-fn wrap_serialize_with(\n+fn wrap_serialize_field_with(\n     params: &Parameters,\n     field_ty: &syn::Ty,\n     serialize_with: &syn::Path,\n-    value: Tokens,\n+    field_expr: Tokens,\n+) -> Tokens {\n+    wrap_serialize_with(params,\n+                        serialize_with,\n+                        &[field_ty],\n+                        &[quote!(#field_expr)])\n+}\n+\n+fn wrap_serialize_variant_with(\n+    params: &Parameters,\n+    serialize_with: &syn::Path,\n+    variant: &Variant,\n+) -> Tokens {\n+    let field_tys: Vec<_> = variant.fields.iter().map(|field| field.ty).collect();\n+    let field_exprs: Vec<_> = variant.fields.iter()\n+        .enumerate()\n+        .map(|(i, field)| {\n+            let id = field.ident.as_ref().map_or_else(|| Ident::new(format!(\"__field{}\", i)),\n+                                                      |id| id.clone());\n+            quote!(#id)\n+        })\n+        .collect();\n+    wrap_serialize_with(params, serialize_with, field_tys.as_slice(), field_exprs.as_slice())\n+}\n+\n+fn wrap_serialize_with(\n+    params: &Parameters,\n+    serialize_with: &syn::Path,\n+    field_tys: &[&syn::Ty],\n+    field_exprs: &[Tokens],\n ) -> Tokens {\n     let this = &params.this;\n     let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n \n-    let wrapper_generics = bound::with_lifetime_bound(&params.generics, \"'__a\");\n+    let wrapper_generics = if field_exprs.len() == 0 {\n+        params.generics.clone()\n+    } else {\n+        bound::with_lifetime_bound(&params.generics, \"'__a\")\n+    };\n     let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n \n+    let field_access = (0..field_exprs.len()).map(|n| Ident::new(format!(\"{}\", n)));\n+\n     quote!({\n         struct __SerializeWith #wrapper_impl_generics #where_clause {\n-            value: &'__a #field_ty,\n+            values: (#(&'__a #field_tys, )*),\n             phantom: _serde::export::PhantomData<#this #ty_generics>,\n         }\n \n@@ -888,12 +978,12 @@ fn wrap_serialize_with(\n             fn serialize<__S>(&self, __s: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n                 where __S: _serde::Serializer\n             {\n-                #serialize_with(self.value, __s)\n+                #serialize_with(#(self.values.#field_access, )* __s)\n             }\n         }\n \n         &__SerializeWith {\n-            value: #value,\n+            values: (#(#field_exprs, )*),\n             phantom: _serde::export::PhantomData::<#this #ty_generics>,\n         }\n     })\ndiff --git a/serde_derive_internals/src/attr.rs b/serde_derive_internals/src/attr.rs\nindex caf306cfa..2803da9d7 100644\n--- a/serde_derive_internals/src/attr.rs\n+++ b/serde_derive_internals/src/attr.rs\n@@ -510,6 +510,8 @@ pub struct Variant {\n     skip_deserializing: bool,\n     skip_serializing: bool,\n     other: bool,\n+    serialize_with: Option<syn::Path>,\n+    deserialize_with: Option<syn::Path>,\n }\n \n impl Variant {\n@@ -520,6 +522,8 @@ impl Variant {\n         let mut skip_serializing = BoolAttr::none(cx, \"skip_serializing\");\n         let mut rename_all = Attr::none(cx, \"rename_all\");\n         let mut other = BoolAttr::none(cx, \"other\");\n+        let mut serialize_with = Attr::none(cx, \"serialize_with\");\n+        let mut deserialize_with = Attr::none(cx, \"deserialize_with\");\n \n         for meta_items in variant.attrs.iter().filter_map(get_serde_meta_items) {\n             for meta_item in meta_items {\n@@ -569,6 +573,20 @@ impl Variant {\n                         other.set_true();\n                     }\n \n+                    // Parse `#[serde(serialize_with = \"...\")]`\n+                    MetaItem(NameValue(ref name, ref lit)) if name == \"serialize_with\" => {\n+                        if let Ok(path) = parse_lit_into_path(cx, name.as_ref(), lit) {\n+                            serialize_with.set(path);\n+                        }\n+                    }\n+\n+                    // Parse `#[serde(deserialize_with = \"...\")]`\n+                    MetaItem(NameValue(ref name, ref lit)) if name == \"deserialize_with\" => {\n+                        if let Ok(path) = parse_lit_into_path(cx, name.as_ref(), lit) {\n+                            deserialize_with.set(path);\n+                        }\n+                    }\n+\n                     MetaItem(ref meta_item) => {\n                         cx.error(format!(\"unknown serde variant attribute `{}`\", meta_item.name()));\n                     }\n@@ -595,6 +613,8 @@ impl Variant {\n             skip_deserializing: skip_deserializing.get(),\n             skip_serializing: skip_serializing.get(),\n             other: other.get(),\n+            serialize_with: serialize_with.get(),\n+            deserialize_with: deserialize_with.get(),\n         }\n     }\n \n@@ -626,6 +646,14 @@ impl Variant {\n     pub fn other(&self) -> bool {\n         self.other\n     }\n+\n+    pub fn serialize_with(&self) -> Option<&syn::Path> {\n+        self.serialize_with.as_ref()\n+    }\n+\n+    pub fn deserialize_with(&self) -> Option<&syn::Path> {\n+        self.deserialize_with.as_ref()\n+    }\n }\n \n /// Represents field attribute information\ndiff --git a/serde_derive_internals/src/check.rs b/serde_derive_internals/src/check.rs\nindex 84c958ea9..5d6a76ff8 100644\n--- a/serde_derive_internals/src/check.rs\n+++ b/serde_derive_internals/src/check.rs\n@@ -15,6 +15,7 @@ use Ctxt;\n pub fn check(cx: &Ctxt, cont: &Container) {\n     check_getter(cx, cont);\n     check_identifier(cx, cont);\n+    check_variant_skip_attrs(cx, cont);\n }\n \n /// Getters are only allowed inside structs (not enums) with the `remote`\n@@ -94,3 +95,58 @@ fn check_identifier(cx: &Ctxt, cont: &Container) {\n         }\n     }\n }\n+\n+/// Skip-(de)serializing attributes are not allowed on variants marked\n+/// (de)serialize_with.\n+fn check_variant_skip_attrs(cx: &Ctxt, cont: &Container) {\n+    let variants = match cont.body {\n+        Body::Enum(ref variants) => variants,\n+        Body::Struct(_, _) => {\n+            return;\n+        }\n+    };\n+\n+    for variant in variants.iter() {\n+        if variant.attrs.serialize_with().is_some() {\n+            if variant.attrs.skip_serializing() {\n+                cx.error(format!(\"variant `{}` cannot have both #[serde(serialize_with)] and \\\n+                                  #[serde(skip_serializing)]\", variant.ident));\n+            }\n+\n+            for (i, field) in variant.fields.iter().enumerate() {\n+                let ident = field.ident.as_ref().map_or_else(|| format!(\"{}\", i),\n+                                                             |ident| format!(\"`{}`\", ident));\n+\n+                if field.attrs.skip_serializing() {\n+                    cx.error(format!(\"variant `{}` cannot have both #[serde(serialize_with)] and \\\n+                                      a field {} marked with #[serde(skip_serializing)]\",\n+                                     variant.ident, ident));\n+                }\n+\n+                if field.attrs.skip_serializing_if().is_some() {\n+                    cx.error(format!(\"variant `{}` cannot have both #[serde(serialize_with)] and \\\n+                                      a field {} marked with #[serde(skip_serializing_if)]\",\n+                                     variant.ident, ident));\n+                }\n+            }\n+        }\n+\n+        if variant.attrs.deserialize_with().is_some() {\n+            if variant.attrs.skip_deserializing() {\n+                cx.error(format!(\"variant `{}` cannot have both #[serde(deserialize_with)] and \\\n+                                  #[serde(skip_deserializing)]\", variant.ident));\n+            }\n+\n+            for (i, field) in variant.fields.iter().enumerate() {\n+                if field.attrs.skip_deserializing() {\n+                    let ident = field.ident.as_ref().map_or_else(|| format!(\"{}\", i),\n+                                                                 |ident| format!(\"`{}`\", ident));\n+\n+                    cx.error(format!(\"variant `{}` cannot have both #[serde(deserialize_with)] \\\n+                                      and a field {} marked with #[serde(skip_deserializing)]\",\n+                                     variant.ident, ident));\n+                }\n+            }\n+        }\n+    }\n+}\n", "test_patch": "diff --git a/test_suite/tests/compile-fail/with-variant/skip_de_newtype_field.rs b/test_suite/tests/compile-fail/with-variant/skip_de_newtype_field.rs\nnew file mode 100644\nindex 000000000..391af1baa\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/with-variant/skip_de_newtype_field.rs\n@@ -0,0 +1,25 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: variant `Newtype` cannot have both #[serde(deserialize_with)] and a field 0 marked with #[serde(skip_deserializing)]\n+enum Enum {\n+    #[serde(deserialize_with = \"deserialize_some_newtype_variant\")]\n+    Newtype(#[serde(skip_deserializing)] String),\n+}\n+\n+fn deserialize_some_newtype_variant<'de, D>(_: D) -> StdResult<String, D::Error>\n+    where D: Deserializer<'de>,\n+{\n+    unimplemented!()\n+}\n+\n+fn main() { }\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_de_struct_field.rs b/test_suite/tests/compile-fail/with-variant/skip_de_struct_field.rs\nnew file mode 100644\nindex 000000000..7c563a8af\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/with-variant/skip_de_struct_field.rs\n@@ -0,0 +1,29 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: variant `Struct` cannot have both #[serde(deserialize_with)] and a field `f1` marked with #[serde(skip_deserializing)]\n+enum Enum {\n+    #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n+    Struct {\n+        #[serde(skip_deserializing)]\n+        f1: String,\n+        f2: u8,\n+    },\n+}\n+\n+fn deserialize_some_other_variant<'de, D>(_: D) -> StdResult<(String, u8), D::Error>\n+    where D: Deserializer<'de>,\n+{\n+    unimplemented!()\n+}\n+\n+fn main() { }\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_de_tuple_field.rs b/test_suite/tests/compile-fail/with-variant/skip_de_tuple_field.rs\nnew file mode 100644\nindex 000000000..44fd09581\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/with-variant/skip_de_tuple_field.rs\n@@ -0,0 +1,25 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: variant `Tuple` cannot have both #[serde(deserialize_with)] and a field 0 marked with #[serde(skip_deserializing)]\n+enum Enum {\n+    #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n+    Tuple(#[serde(skip_deserializing)] String, u8),\n+}\n+\n+fn deserialize_some_other_variant<'de, D>(_: D) -> StdResult<(String, u8), D::Error>\n+    where D: Deserializer<'de>,\n+{\n+    unimplemented!()\n+}\n+\n+fn main() { }\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_de_whole_variant.rs b/test_suite/tests/compile-fail/with-variant/skip_de_whole_variant.rs\nnew file mode 100644\nindex 000000000..68c015a28\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/with-variant/skip_de_whole_variant.rs\n@@ -0,0 +1,26 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: variant `Unit` cannot have both #[serde(deserialize_with)] and #[serde(skip_deserializing)]\n+enum Enum {\n+    #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n+    #[serde(skip_deserializing)]\n+    Unit,\n+}\n+\n+fn deserialize_some_unit_variant<'de, D>(_: D) -> StdResult<(), D::Error>\n+    where D: Deserializer<'de>,\n+{\n+    unimplemented!()\n+}\n+\n+fn main() { }\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field.rs\nnew file mode 100644\nindex 000000000..162812d40\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field.rs\n@@ -0,0 +1,25 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: variant `Newtype` cannot have both #[serde(serialize_with)] and a field 0 marked with #[serde(skip_serializing)]\n+enum Enum {\n+    #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n+    Newtype(#[serde(skip_serializing)] String),\n+}\n+\n+fn serialize_some_newtype_variant<S>(_: &String) -> StdResult<S::Ok, S::Error>\n+    where S: Serializer,\n+{\n+    unimplemented!()\n+}\n+\n+fn main() { }\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field_if.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field_if.rs\nnew file mode 100644\nindex 000000000..065ca20dc\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_newtype_field_if.rs\n@@ -0,0 +1,27 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: variant `Newtype` cannot have both #[serde(serialize_with)] and a field 0 marked with #[serde(skip_serializing_if)]\n+enum Enum {\n+    #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n+    Newtype(#[serde(skip_serializing_if = \"always\")] String),\n+}\n+\n+fn serialize_some_newtype_variant<S>(_: &String) -> StdResult<S::Ok, S::Error>\n+    where S: Serializer,\n+{\n+    unimplemented!()\n+}\n+\n+fn always<T>(_: &T) -> bool { true }\n+\n+fn main() { }\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field.rs\nnew file mode 100644\nindex 000000000..dc046b86a\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field.rs\n@@ -0,0 +1,29 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: variant `Struct` cannot have both #[serde(serialize_with)] and a field `f1` marked with #[serde(skip_serializing)]\n+enum Enum {\n+    #[serde(serialize_with = \"serialize_some_other_variant\")]\n+    Struct {\n+        #[serde(skip_serializing)]\n+        f1: String,\n+        f2: u8,\n+    },\n+}\n+\n+fn serialize_some_other_variant<S>(_: &String, _: Option<&u8>, _: S) -> StdResult<S::Ok, S::Error>\n+    where S: Serializer,\n+{\n+    unimplemented!()\n+}\n+\n+fn main() { }\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field_if.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field_if.rs\nnew file mode 100644\nindex 000000000..fd42947d2\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_struct_field_if.rs\n@@ -0,0 +1,31 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: variant `Struct` cannot have both #[serde(serialize_with)] and a field `f1` marked with #[serde(skip_serializing_if)]\n+enum Enum {\n+    #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n+    Struct {\n+        #[serde(skip_serializing_if = \"always\")]\n+        f1: String,\n+        f2: u8,\n+    },\n+}\n+\n+fn serialize_some_other_variant<S>(_: &String, _: Option<&u8>, _: S) -> StdResult<S::Ok, S::Error>\n+    where S: Serializer,\n+{\n+    unimplemented!()\n+}\n+\n+fn always<T>(_: &T) -> bool { true }\n+\n+fn main() { }\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field.rs\nnew file mode 100644\nindex 000000000..56cbfa450\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field.rs\n@@ -0,0 +1,25 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: variant `Tuple` cannot have both #[serde(serialize_with)] and a field 0 marked with #[serde(skip_serializing)]\n+enum Enum {\n+    #[serde(serialize_with = \"serialize_some_other_variant\")]\n+    Tuple(#[serde(skip_serializing)] String, u8),\n+}\n+\n+fn serialize_some_other_variant<S>(_: &String, _: Option<&u8>, _: S) -> StdResult<S::Ok, S::Error>\n+    where S: Serializer,\n+{\n+    unimplemented!()\n+}\n+\n+fn main() { }\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field_if.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field_if.rs\nnew file mode 100644\nindex 000000000..c85db63d0\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_tuple_field_if.rs\n@@ -0,0 +1,27 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: variant `Tuple` cannot have both #[serde(serialize_with)] and a field 0 marked with #[serde(skip_serializing_if)]\n+enum Enum {\n+    #[serde(serialize_with = \"serialize_some_other_variant\")]\n+    Tuple(#[serde(skip_serializing_if = \"always\")] String, u8),\n+}\n+\n+fn serialize_some_other_variant<S>(_: &String, _: Option<&u8>, _: S) -> StdResult<S::Ok, S::Error>\n+    where S: Serializer,\n+{\n+    unimplemented!()\n+}\n+\n+fn always<T>(_: &T) -> bool { true }\n+\n+fn main() { }\ndiff --git a/test_suite/tests/compile-fail/with-variant/skip_ser_whole_variant.rs b/test_suite/tests/compile-fail/with-variant/skip_ser_whole_variant.rs\nnew file mode 100644\nindex 000000000..8e3291e3e\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/with-variant/skip_ser_whole_variant.rs\n@@ -0,0 +1,26 @@\n+// Copyright 2017 Serde Developers\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+//~^ HELP: variant `Unit` cannot have both #[serde(serialize_with)] and #[serde(skip_serializing)]\n+enum Enum {\n+    #[serde(serialize_with = \"serialize_some_unit_variant\")]\n+    #[serde(skip_serializing)]\n+    Unit,\n+}\n+\n+fn serialize_some_unit_variant<S>(_: S) -> StdResult<S::Ok, S::Error>\n+    where S: Serializer,\n+{\n+    unimplemented!()\n+}\n+\n+fn main() { }\ndiff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex cb9642e8f..fb7961110 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -11,6 +11,7 @@ extern crate serde_derive;\n \n extern crate serde;\n use self::serde::{Serialize, Serializer, Deserialize, Deserializer};\n+use self::serde::de::{self, Unexpected};\n \n extern crate serde_test;\n use self::serde_test::{Token, assert_tokens, assert_ser_tokens, assert_de_tokens,\n@@ -811,6 +812,145 @@ fn test_serialize_with_enum() {\n     );\n }\n \n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+enum WithVariant {\n+    #[serde(serialize_with=\"serialize_unit_variant_as_i8\")]\n+    #[serde(deserialize_with=\"deserialize_i8_as_unit_variant\")]\n+    Unit,\n+\n+    #[serde(serialize_with=\"SerializeWith::serialize_with\")]\n+    #[serde(deserialize_with=\"DeserializeWith::deserialize_with\")]\n+    Newtype(i32),\n+\n+    #[serde(serialize_with=\"serialize_variant_as_string\")]\n+    #[serde(deserialize_with=\"deserialize_string_as_variant\")]\n+    Tuple(String, u8),\n+\n+    #[serde(serialize_with=\"serialize_variant_as_string\")]\n+    #[serde(deserialize_with=\"deserialize_string_as_variant\")]\n+    Struct {\n+        f1: String,\n+        f2: u8,\n+    },\n+}\n+\n+fn serialize_unit_variant_as_i8<S>(serializer: S) -> Result<S::Ok, S::Error>\n+    where S: Serializer,\n+{\n+    serializer.serialize_i8(0)\n+}\n+\n+fn deserialize_i8_as_unit_variant<'de, D>(deserializer: D) -> Result<(), D::Error>\n+    where D: Deserializer<'de>,\n+{\n+    let n = i8::deserialize(deserializer)?;\n+    match n {\n+        0 => Ok(()),\n+        _ => Err(de::Error::invalid_value(Unexpected::Signed(n as i64), &\"0\")),\n+    }\n+}\n+\n+fn serialize_variant_as_string<S>(f1: &str,\n+                                  f2: &u8,\n+                                  serializer: S)\n+                                  -> Result<S::Ok, S::Error>\n+    where S: Serializer,\n+{\n+    serializer.serialize_str(format!(\"{};{:?}\", f1, f2).as_str())\n+}\n+\n+fn deserialize_string_as_variant<'de, D>(deserializer: D) -> Result<(String, u8), D::Error>\n+    where D: Deserializer<'de>,\n+{\n+    let s = String::deserialize(deserializer)?;\n+    let mut pieces = s.split(';');\n+    let f1 = match pieces.next() {\n+        Some(x) => x,\n+        None => return Err(de::Error::invalid_length(0, &\"2\")),\n+    };\n+    let f2 = match pieces.next() {\n+        Some(x) => x,\n+        None => return Err(de::Error::invalid_length(1, &\"2\")),\n+    };\n+    let f2 = match f2.parse() {\n+        Ok(n) => n,\n+        Err(_) => {\n+            return Err(de::Error::invalid_value(Unexpected::Str(f2), &\"an 8-bit signed integer\"));\n+        }\n+    };\n+    Ok((f1.into(), f2))\n+}\n+\n+#[test]\n+fn test_serialize_with_variant() {\n+    assert_ser_tokens(\n+        &WithVariant::Unit,\n+        &[\n+            Token::NewtypeVariant { name: \"WithVariant\", variant: \"Unit\" },\n+            Token::I8(0),\n+        ],\n+    );\n+\n+    assert_ser_tokens(\n+        &WithVariant::Newtype(123),\n+        &[\n+            Token::NewtypeVariant { name: \"WithVariant\", variant: \"Newtype\" },\n+            Token::Bool(true),\n+        ],\n+    );\n+\n+    assert_ser_tokens(\n+        &WithVariant::Tuple(\"hello\".into(), 0),\n+        &[\n+            Token::NewtypeVariant { name: \"WithVariant\", variant: \"Tuple\" },\n+            Token::Str(\"hello;0\"),\n+        ],\n+    );\n+\n+    assert_ser_tokens(\n+        &WithVariant::Struct { f1: \"world\".into(), f2: 1 },\n+        &[\n+            Token::NewtypeVariant { name: \"WithVariant\", variant: \"Struct\" },\n+            Token::Str(\"world;1\"),\n+        ],\n+    );\n+}\n+\n+#[test]\n+fn test_deserialize_with_variant() {\n+    assert_de_tokens(\n+        &WithVariant::Unit,\n+        &[\n+            Token::NewtypeVariant { name: \"WithVariant\", variant: \"Unit\" },\n+            Token::I8(0),\n+        ],\n+    );\n+\n+    assert_de_tokens(\n+        &WithVariant::Newtype(123),\n+        &[\n+            Token::NewtypeVariant { name: \"WithVariant\", variant: \"Newtype\" },\n+            Token::Bool(true),\n+        ],\n+    );\n+\n+    assert_de_tokens(\n+        &WithVariant::Tuple(\"hello\".into(), 0),\n+        &[\n+            Token::NewtypeVariant { name: \"WithVariant\", variant: \"Tuple\" },\n+            Token::Str(\"hello;0\"),\n+        ],\n+    );\n+\n+    assert_de_tokens(\n+        &WithVariant::Struct { f1: \"world\".into(), f2: 1 },\n+        &[\n+            Token::NewtypeVariant { name: \"WithVariant\", variant: \"Struct\" },\n+            Token::Str(\"world;1\"),\n+        ],\n+    );\n+}\n+\n #[derive(Debug, PartialEq, Deserialize)]\n struct DeserializeWithStruct<B>\n where\ndiff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 5d708014b..76c57db8a 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -373,6 +373,124 @@ fn test_gen() {\n         #[serde(with = \"vis::SDef\")]\n         s: vis::S,\n     }\n+\n+    #[derive(Serialize, Deserialize)]\n+    enum ExternallyTaggedVariantWith {\n+        #[allow(dead_code)]\n+        Normal { f1: String },\n+\n+        #[serde(serialize_with = \"ser_x\")]\n+        #[serde(deserialize_with = \"de_x\")]\n+        #[allow(dead_code)]\n+        Newtype(X),\n+\n+        #[serde(serialize_with = \"serialize_some_other_variant\")]\n+        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n+        #[allow(dead_code)]\n+        Tuple(String, u8),\n+\n+        #[serde(serialize_with = \"serialize_some_other_variant\")]\n+        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n+        #[allow(dead_code)]\n+        Struct {\n+            f1: String,\n+            f2: u8,\n+        },\n+\n+        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n+        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n+        #[allow(dead_code)]\n+        Unit,\n+    }\n+    assert_ser::<ExternallyTaggedVariantWith>();\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(tag = \"t\")]\n+    enum InternallyTaggedVariantWith {\n+        #[allow(dead_code)]\n+        Normal { f1: String },\n+\n+        #[serde(serialize_with = \"ser_x\")]\n+        #[serde(deserialize_with = \"de_x\")]\n+        #[allow(dead_code)]\n+        Newtype(X),\n+\n+        #[serde(serialize_with = \"serialize_some_other_variant\")]\n+        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n+        #[allow(dead_code)]\n+        Struct {\n+            f1: String,\n+            f2: u8,\n+        },\n+\n+        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n+        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n+        #[allow(dead_code)]\n+        Unit,\n+    }\n+    assert_ser::<InternallyTaggedVariantWith>();\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(tag = \"t\", content = \"c\")]\n+    enum AdjacentlyTaggedVariantWith {\n+        #[allow(dead_code)]\n+        Normal { f1: String },\n+\n+        #[serde(serialize_with = \"ser_x\")]\n+        #[serde(deserialize_with = \"de_x\")]\n+        #[allow(dead_code)]\n+        Newtype(X),\n+\n+        #[serde(serialize_with = \"serialize_some_other_variant\")]\n+        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n+        #[allow(dead_code)]\n+        Tuple(String, u8),\n+\n+        #[serde(serialize_with = \"serialize_some_other_variant\")]\n+        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n+        #[allow(dead_code)]\n+        Struct {\n+            f1: String,\n+            f2: u8,\n+        },\n+\n+        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n+        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n+        #[allow(dead_code)]\n+        Unit,\n+    }\n+    assert_ser::<AdjacentlyTaggedVariantWith>();\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(untagged)]\n+    enum UntaggedVariantWith {\n+        #[allow(dead_code)]\n+        Normal { f1: String },\n+\n+        #[serde(serialize_with = \"ser_x\")]\n+        #[serde(deserialize_with = \"de_x\")]\n+        #[allow(dead_code)]\n+        Newtype(X),\n+\n+        #[serde(serialize_with = \"serialize_some_other_variant\")]\n+        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n+        #[allow(dead_code)]\n+        Tuple(String, u8),\n+\n+        #[serde(serialize_with = \"serialize_some_other_variant\")]\n+        #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n+        #[allow(dead_code)]\n+        Struct {\n+            f1: String,\n+            f2: u8,\n+        },\n+\n+        #[serde(serialize_with = \"serialize_some_unit_variant\")]\n+        #[serde(deserialize_with = \"deserialize_some_unit_variant\")]\n+        #[allow(dead_code)]\n+        Unit,\n+    }\n+    assert_ser::<UntaggedVariantWith>();\n }\n \n //////////////////////////////////////////////////////////////////////////\n@@ -414,3 +532,29 @@ impl DeserializeWith for X {\n         unimplemented!()\n     }\n }\n+\n+pub fn serialize_some_unit_variant<S>(_: S) -> StdResult<S::Ok, S::Error>\n+    where S: Serializer,\n+{\n+    unimplemented!()\n+}\n+\n+pub fn deserialize_some_unit_variant<'de, D>(_: D) -> StdResult<(), D::Error>\n+    where D: Deserializer<'de>,\n+{\n+    unimplemented!()\n+}\n+\n+pub fn serialize_some_other_variant<S>(_: &str, _: &u8, _: S) -> StdResult<S::Ok, S::Error>\n+    where S: Serializer,\n+{\n+    unimplemented!()\n+}\n+\n+pub fn deserialize_some_other_variant<'de, D>(_: D) -> StdResult<(String, u8), D::Error>\n+    where D: Deserializer<'de>,\n+{\n+    unimplemented!()\n+}\n+\n+pub fn is_zero(n: &u8) -> bool { *n == 0 }\n", "problem_statement": "Allow de/serialize_with on enum variants\nThis still needs to be fleshed out some more, but the idea would be to support things like empty_struct from https://github.com/serde-rs/serde/pull/1008 implemented in user code rather than in Serde.\r\n\r\n```rust\r\n#[derive(Serialize)]\r\n#[serde(tag = \"t\", content = \"c\")]\r\nenum E {\r\n    Hello { foo: String },\r\n\r\n    // serialize as `{ \"t\": \"World\", \"c\": {} }`\r\n    #[serde(serialize_with = \"empty_struct\")]\r\n    World,\r\n}\r\n\r\nfn empty_struct<signature TBD> { /* ... */ }\r\n```\n", "hints_text": "@spinda may be interested in working on a design.\nI would like to propose the following (\"design A\"):\r\n\r\n```rust\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(tag = \"t\", content = \"c\")]\r\nenum E {\r\n    // normal variant (de)serialization\r\n    Hello { world: String },\r\n\r\n    // (de)serialize_with can be used to add special behavior to variants;\r\n    // for tuple structs, each inner value is passed in order to the serialize\r\n    // function, and the deserialize function produces a tuple (see below)\r\n    #[serde(serialize_with = \"my_special_serializer\")]\r\n    #[serde(deserialize_with = \"my_special_deserializer\")]\r\n    Quux(String, u8),\r\n\r\n    // struct variants are also supported, and are treated in the same way as\r\n    // tuple variants, with inner values ordered by how they appear in the\r\n    // definition\r\n    #[serde(serialize_with = \"my_special_serializer\")]\r\n    #[serde(deserialize_with = \"my_special_deserializer\")]\r\n    Xyzzy {\r\n        foo: String,\r\n        bar: u8,\r\n    },\r\n\r\n    // for unit variants, the serialize function is passed only the serializer,\r\n    // and the deserialize function is expected to produce ()\r\n    #[serde(serialize_with = \"serialize_empty_struct\")]\r\n    #[serde(deserialize_with = \"deserialize_empty_struct\")]\r\n    Baz,\r\n}\r\n\r\nfn my_special_serializer<S>(foo: &String, bar: &u8, serializer: S) -> Result<S::Ok, S::Error>\r\n    where S: Serializer,\r\n{\r\n    unimplemented!()\r\n}\r\n\r\nfn my_special_deserializer<'de, D>(deserializer: D) -> Result<(String, u8), D::Error>\r\n    where D: Deserializer<'de>,\r\n{\r\n    unimplemented!()\r\n}\r\n\r\nfn serialize_empty_struct<S>(serializer: S) -> Result<S::Ok, S::Error>\r\n    where S: Serializer,\r\n{\r\n    unimplemented!()\r\n}\r\n\r\nfn deserialize_empty_struct<'de, D>(deserializer: D) -> Result<(), D::Error>\r\n    where D: Deserializer<'de>,\r\n{\r\n    unimplemented!()\r\n}\r\n```\r\n\r\nThe alternative, I believe, would be to pass the enumeration type in as a single argument to the serialize function and expect it as the output of the deserialize function (\"design B\"). Compared:\r\n\r\n- Design A has the drawback of requiring long type signatures for variants with a lot of fields/inner types, while design B couldn't result in that situation. This could be avoided under design A by turning such a variant into a newtype variant wrapping around a separately-defined freestanding struct type. One might call this good practice in general, as variants that are so long they easily be pattern-matched are harder to manipulate elsewhere.\r\n\r\n- If your (de)serialize functions only need to apply to one variant in an enum, Design B requires matching on the enum type and then either panicking or emitting an error on the alternate cases to make the totality checker happy. Design A avoids this.\r\n\r\n- The simple fact that Design B would allow for producing a *different* variant of the enum type than the one which was annotated with `deserialize_with` seems ripe for confusion in my mind.\r\n\r\n- Design A is more flexible with regard to reusability of the (de)serialize functions. For example, a single implementation of (de)serialize_empty_struct could be reused across multiple variants and multiple enum types. Design B requires that such functions be tied to a specific enum type and, in the case of deserializing, a specific variant of that enum: if multiple variants of your enum need the empty_struct behavior, a single deserialize function couldn't know which variant to produce.\nSounds good to me. I agree with all of your points and design A seems like a good path forward.", "created_at": "2017-08-08T02:10:34Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1001, "instance_id": "serde-rs__serde-1001", "issue_numbers": ["1000"], "base_commit": "e6487cf6fa216c303491983aa3d74ea76f3215b6", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 03e265af4..647281c01 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -28,9 +28,10 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<Tokens, Str\n     let body = Stmts(deserialize_body(&cont, &params));\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n+        let vis = &input.vis;\n         quote! {\n             impl #de_impl_generics #ident #ty_generics #where_clause {\n-                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<#remote #ty_generics, __D::Error>\n+                #vis fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<#remote #ty_generics, __D::Error>\n                     where __D: _serde::Deserializer<'de>\n                 {\n                     #body\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 66603d8d3..9be9bddca 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -29,9 +29,10 @@ pub fn expand_derive_serialize(input: &syn::DeriveInput) -> Result<Tokens, Strin\n     let body = Stmts(serialize_body(&cont, &params));\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n+        let vis = &input.vis;\n         quote! {\n             impl #impl_generics #ident #ty_generics #where_clause {\n-                fn serialize<__S>(__self: &#remote #ty_generics, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n+                #vis fn serialize<__S>(__self: &#remote #ty_generics, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n                     where __S: _serde::Serializer\n                 {\n                     #body\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex a82801b91..5d708014b 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -358,6 +358,21 @@ fn test_gen() {\n         #[serde(borrow, with = \"StrDef\")]\n         s: Str<'a>,\n     }\n+\n+    mod vis {\n+        pub struct S;\n+\n+        #[derive(Serialize, Deserialize)]\n+        #[serde(remote = \"S\")]\n+        pub struct SDef;\n+    }\n+\n+    // This would not work if SDef::serialize / deserialize are private.\n+    #[derive(Serialize, Deserialize)]\n+    struct RemoteVisibility {\n+        #[serde(with = \"vis::SDef\")]\n+        s: vis::S,\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Remote type visibility\nThe `#[serde(remote)]` attribute generates `deserialize` and `serialize` methods in an impl for the local type but they're private - this prevents a remote \"Def\" type in a module from being exported outside of it. There are workarounds (newtype or redefine proxy functions) but would there be any disadvantage to just marking these `pub`?\r\n\r\nOr maybe traits could be used?\r\n\r\n```rust\r\ntrait DeserializeInto<'de> {\r\n    type Output;\r\n\r\n    fn deserialize_into<D: Deserializer<'de>>(d: D) -> Result<Self::Output, D::Error>;\r\n}\r\n\r\ntrait SerializeFrom {\r\n    type Input;\r\n\r\n    fn serialize_from<S: Serializer>(value: &Self::Input, s: S) -> Result<S::Ok, S::Error>;\r\n}\r\n```\r\n\r\n(something like that, could be named `RemoteDeserialize` instead and I didn't really consider type parameters vs associates types)\r\n\n", "hints_text": "", "created_at": "2017-07-26T06:56:06Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 995, "instance_id": "serde-rs__serde-995", "issue_numbers": ["988"], "base_commit": "1c2a4bff1c01d0c84b653f2f4313f15621aa3168", "patch": "diff --git a/Cargo.toml b/Cargo.toml\nindex 29db37d3b..cb35f8543 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -5,5 +5,4 @@ members = [\n     \"serde_derive_internals\",\n     \"serde_test\",\n     \"test_suite\",\n-    \"test_suite/no_std\",\n ]\ndiff --git a/travis.sh b/travis.sh\nindex ddfbc3339..c43cb55f9 100755\n--- a/travis.sh\n+++ b/travis.sh\n@@ -41,6 +41,7 @@ if [ -n \"${CLIPPY}\" ]; then\n     cargo clippy -- -Dclippy\n else\n     CHANNEL=nightly\n+    cd \"$DIR\"\n     cargo clean\n     cd \"$DIR/serde\"\n     channel build\n@@ -55,6 +56,7 @@ else\n     channel build\n \n     CHANNEL=beta\n+    cd \"$DIR\"\n     cargo clean\n     cd \"$DIR/serde\"\n     channel build --features rc\n@@ -62,6 +64,7 @@ else\n     channel test\n \n     CHANNEL=stable\n+    cd \"$DIR\"\n     cargo clean\n     cd \"$DIR/serde\"\n     channel build --features rc\n@@ -71,6 +74,7 @@ else\n     channel test\n \n     CHANNEL=1.13.0\n+    cd \"$DIR\"\n     cargo clean\n     cd \"$DIR/serde\"\n     channel build --features rc\n", "test_patch": "diff --git a/test_suite/no_std/Cargo.toml b/test_suite/no_std/Cargo.toml\nindex 80bb6ed2a..7c0040666 100644\n--- a/test_suite/no_std/Cargo.toml\n+++ b/test_suite/no_std/Cargo.toml\n@@ -7,3 +7,5 @@ publish = false\n libc = { version = \"0.2\", default-features = false }\n serde = { path = \"../../serde\", default-features = false }\n serde_derive = { path = \"../../serde_derive\" }\n+\n+[workspace]\n", "problem_statement": "No bin target named `serde_derive_tests_no_std`\nIn the test_suite directory, `cargo clippy` fails with this message.\r\n\r\n```\r\nerror: no bin target named `serde_derive_tests_no_std`\r\n```\r\n\r\nAs though it sees that bin target in test_suite/no_std/Cargo.toml but tries to build that bin target against test_suite/Cargo.toml.\r\n\r\n@oli-obk I don't think we changed anything significant on our end so this seems like a Clippy or Cargo regression.\n", "hints_text": "", "created_at": "2017-07-21T07:09:16Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 971, "instance_id": "serde-rs__serde-971", "issue_numbers": ["972"], "base_commit": "4fdba725fe30dc30658b8e71bead7d9b83ab9b0f", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 20ccb696f..03e265af4 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -23,15 +23,14 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<Tokens, Str\n \n     let ident = &cont.ident;\n     let params = Parameters::new(&cont);\n+    let (de_impl_generics, _, ty_generics, where_clause) = split_with_de_lifetime(&params);\n     let dummy_const = Ident::new(format!(\"_IMPL_DESERIALIZE_FOR_{}\", ident));\n     let body = Stmts(deserialize_body(&cont, &params));\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n-        let (impl_generics, ty_generics, where_clause) = cont.generics.split_for_impl();\n-        let de_lifetime = params.de_lifetime_def();\n         quote! {\n-            impl #impl_generics #ident #ty_generics #where_clause {\n-                fn deserialize<#de_lifetime, __D>(__deserializer: __D) -> _serde::export::Result<#remote #ty_generics, __D::Error>\n+            impl #de_impl_generics #ident #ty_generics #where_clause {\n+                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<#remote #ty_generics, __D::Error>\n                     where __D: _serde::Deserializer<'de>\n                 {\n                     #body\n@@ -39,7 +38,6 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<Tokens, Str\n             }\n         }\n     } else {\n-        let (de_impl_generics, _, ty_generics, where_clause) = split_with_de_lifetime(&params);\n         quote! {\n             #[automatically_derived]\n             impl #de_impl_generics _serde::Deserialize<'de> for #ident #ty_generics #where_clause {\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 2f3d6299a..a82801b91 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -330,6 +330,34 @@ fn test_gen() {\n     struct EmptyArray {\n         empty: [X; 0],\n     }\n+\n+    enum Or<A, B> {\n+        A(A),\n+        B(B),\n+    }\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(untagged, remote = \"Or\")]\n+    enum OrDef<A, B> {\n+        #[allow(dead_code)]\n+        A(A),\n+        #[allow(dead_code)]\n+        B(B),\n+    }\n+\n+    struct Str<'a>(&'a str);\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(remote = \"Str\")]\n+    struct StrDef<'a>(&'a str);\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct Remote<'a> {\n+        #[serde(with = \"OrDef\")]\n+        or: Or<u8, bool>,\n+        #[serde(borrow, with = \"StrDef\")]\n+        s: Str<'a>,\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Deriving Deserialize for a remote generic enum fails\nI'm attempting to derive `Deserialize` and `Serialize` for the [`Or` enum from the `or` crate](https://docs.rs/or/0.0.1/or/enum.Or.html).\r\n\r\nDeriving `Serialize` works fine:\r\n```rust\r\n#[derive(Serialize)] #[serde(untagged, remote = \"Or\")] enum OrDef<A, B> { A(A), B(B) }\r\n```\r\nbut deriving `Deserialize` doesn't:\r\n```rust\r\n#[derive(Deserialize)] #[serde(untagged, remote = \"Or\")] enum OrDef<A, B> { A(A), B(B) }\r\n```\r\n\r\n`serde_derive` should be able to automatically write the type bounds for it's `impl`, but it is omitting them.\r\n\r\nWhat's even stranger (and helps show the issue) is that, when we remove the `remote = \"Or\"`, it compiles just fine:\r\n```rust\r\n#[derive(Deserialize)] #[serde(untagged)] enum Or<A, B> { A(A), B(B) }\r\n```\r\n---\r\n```toml\r\n[dependencies]\r\nor = \"*\"\r\nserde = \"1.0.8\"\r\nserde_derive = \"1.0.8\"\r\n```\n", "hints_text": "", "created_at": "2017-06-30T03:13:43Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 963, "instance_id": "serde-rs__serde-963", "issue_numbers": ["962"], "base_commit": "4fdba725fe30dc30658b8e71bead7d9b83ab9b0f", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 20ccb696f..741baec77 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -1387,10 +1387,10 @@ fn deserialize_identifier(\n     };\n \n     let visit_index = if is_variant {\n-        let variant_indices = 0u32..;\n+        let variant_indices = 0u64..;\n         let fallthrough_msg = format!(\"variant index 0 <= i < {}\", fields.len());\n         let visit_index = quote! {\n-            fn visit_u32<__E>(self, __value: u32) -> _serde::export::Result<Self::Value, __E>\n+            fn visit_u64<__E>(self, __value: u64) -> _serde::export::Result<Self::Value, __E>\n                 where __E: _serde::de::Error\n             {\n                 match __value {\n", "test_patch": "diff --git a/test_suite/tests/test_identifier.rs b/test_suite/tests/test_identifier.rs\nindex 76f1cffae..83a0d3b17 100644\n--- a/test_suite/tests/test_identifier.rs\n+++ b/test_suite/tests/test_identifier.rs\n@@ -23,7 +23,10 @@ fn test_variant_identifier() {\n         Bbb,\n     }\n \n+    assert_de_tokens(&V::Aaa, &[Token::U8(0)]);\n+    assert_de_tokens(&V::Aaa, &[Token::U16(0)]);\n     assert_de_tokens(&V::Aaa, &[Token::U32(0)]);\n+    assert_de_tokens(&V::Aaa, &[Token::U64(0)]);\n     assert_de_tokens(&V::Aaa, &[Token::Str(\"Aaa\")]);\n     assert_de_tokens(&V::Aaa, &[Token::Bytes(b\"Aaa\")]);\n }\n", "problem_statement": "Numeric variant identifier deserialization only handles u32\nEven if the identifier is serialized as a u32, some formats like CBOR store numeric values in a variable length encoding. Small variant numbers are then deserialized as an e.g. u8. Unfortunately, the generated visitor only implements `visit_u32`, but `visit_u8` etc delegate directly to `visit_u64`.\r\n\r\nIt seems like `visit_u64` (and maybe `visit_i64`?) should be implemented instead.\n", "hints_text": "", "created_at": "2017-06-20T03:22:48Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 949, "instance_id": "serde-rs__serde-949", "issue_numbers": ["535"], "base_commit": "fd3d1396d33a49200daaaf8bf17eba78fe4183d8", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 13f5c9966..1a48f8031 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -1364,6 +1364,132 @@ impl<'de> Deserialize<'de> for Duration {\n \n ////////////////////////////////////////////////////////////////////////////////\n \n+#[cfg(feature = \"std\")]\n+impl<'de> Deserialize<'de> for SystemTime {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        // Reuse duration\n+        enum Field {\n+            Secs,\n+            Nanos,\n+        };\n+\n+        impl<'de> Deserialize<'de> for Field {\n+            fn deserialize<D>(deserializer: D) -> Result<Field, D::Error>\n+            where\n+                D: Deserializer<'de>,\n+            {\n+                struct FieldVisitor;\n+\n+                impl<'de> Visitor<'de> for FieldVisitor {\n+                    type Value = Field;\n+\n+                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                        formatter.write_str(\"`secs_since_epoch` or `nanos_since_epoch`\")\n+                    }\n+\n+                    fn visit_str<E>(self, value: &str) -> Result<Field, E>\n+                    where\n+                        E: Error,\n+                    {\n+                        match value {\n+                            \"secs_since_epoch\" => Ok(Field::Secs),\n+                            \"nanos_since_epoch\" => Ok(Field::Nanos),\n+                            _ => Err(Error::unknown_field(value, FIELDS)),\n+                        }\n+                    }\n+\n+                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Field, E>\n+                    where\n+                        E: Error,\n+                    {\n+                        match value {\n+                            b\"secs_since_epoch\" => Ok(Field::Secs),\n+                            b\"nanos_since_epoch\" => Ok(Field::Nanos),\n+                            _ => {\n+                                let value = String::from_utf8_lossy(value);\n+                                Err(Error::unknown_field(&value, FIELDS))\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                deserializer.deserialize_identifier(FieldVisitor)\n+            }\n+        }\n+\n+        struct DurationVisitor;\n+\n+        impl<'de> Visitor<'de> for DurationVisitor {\n+            type Value = Duration;\n+\n+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                formatter.write_str(\"struct SystemTime\")\n+            }\n+\n+            fn visit_seq<A>(self, mut seq: A) -> Result<Duration, A::Error>\n+            where\n+                A: SeqAccess<'de>,\n+            {\n+                let secs: u64 = match try!(seq.next_element()) {\n+                    Some(value) => value,\n+                    None => {\n+                        return Err(Error::invalid_length(0, &self));\n+                    }\n+                };\n+                let nanos: u32 = match try!(seq.next_element()) {\n+                    Some(value) => value,\n+                    None => {\n+                        return Err(Error::invalid_length(1, &self));\n+                    }\n+                };\n+                Ok(Duration::new(secs, nanos))\n+            }\n+\n+            fn visit_map<A>(self, mut map: A) -> Result<Duration, A::Error>\n+            where\n+                A: MapAccess<'de>,\n+            {\n+                let mut secs: Option<u64> = None;\n+                let mut nanos: Option<u32> = None;\n+                while let Some(key) = try!(map.next_key()) {\n+                    match key {\n+                        Field::Secs => {\n+                            if secs.is_some() {\n+                                return Err(<A::Error as Error>::duplicate_field(\"secs_since_epoch\"));\n+                            }\n+                            secs = Some(try!(map.next_value()));\n+                        }\n+                        Field::Nanos => {\n+                            if nanos.is_some() {\n+                                return Err(<A::Error as Error>::duplicate_field(\"nanos_since_epoch\"));\n+                            }\n+                            nanos = Some(try!(map.next_value()));\n+                        }\n+                    }\n+                }\n+                let secs = match secs {\n+                    Some(secs) => secs,\n+                    None => return Err(<A::Error as Error>::missing_field(\"secs_since_epoch\")),\n+                };\n+                let nanos = match nanos {\n+                    Some(nanos) => nanos,\n+                    None => return Err(<A::Error as Error>::missing_field(\"nanos_since_epoch\")),\n+                };\n+                Ok(Duration::new(secs, nanos))\n+            }\n+        }\n+\n+        const FIELDS: &'static [&'static str] = &[\"secs_since_epoch\", \"nanos_since_epoch\"];\n+        let duration = try!(deserializer.deserialize_struct(\"SystemTime\", FIELDS, DurationVisitor));\n+        Ok(UNIX_EPOCH + duration)\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+\n // Similar to:\n //\n //     #[derive(Deserialize)]\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex dd5f09daf..cd16e4628 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -94,6 +94,7 @@\n //!    - OsString\n //!  - **Miscellaneous standard library types**:\n //!    - Duration\n+//!    - SystemTime\n //!    - Path\n //!    - PathBuf\n //!    - Range\\<T\\>\ndiff --git a/serde/src/lib.rs b/serde/src/lib.rs\nindex fe8258a9b..fc2c3c271 100644\n--- a/serde/src/lib.rs\n+++ b/serde/src/lib.rs\n@@ -187,7 +187,7 @@ mod lib {\n     #[cfg(feature = \"std\")]\n     pub use std::path::{Path, PathBuf};\n     #[cfg(feature = \"std\")]\n-    pub use std::time::Duration;\n+    pub use std::time::{Duration, SystemTime, UNIX_EPOCH};\n     #[cfg(feature = \"std\")]\n     pub use std::sync::{Mutex, RwLock};\n \ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex 92f55c77a..b26a8bd09 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -455,6 +455,23 @@ impl Serialize for Duration {\n \n ////////////////////////////////////////////////////////////////////////////////\n \n+#[cfg(feature = \"std\")]\n+impl Serialize for SystemTime {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        use super::SerializeStruct;\n+        let duration_since_epoch = self.duration_since(UNIX_EPOCH).expect(\"SystemTime must be later than UNIX_EPOCH\");\n+        let mut state = try!(serializer.serialize_struct(\"SystemTime\", 2));\n+        try!(state.serialize_field(\"secs_since_epoch\", &duration_since_epoch.as_secs()));\n+        try!(state.serialize_field(\"nanos_since_epoch\", &duration_since_epoch.subsec_nanos()));\n+        state.end()\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// Serialize a value that implements `Display` as a string, when that string is\n /// statically known to never have more than a constant `MAX_LEN` bytes.\n ///\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 13137b3b8..87307bb2c 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -89,6 +89,7 @@\n //!    - OsString\n //!  - **Miscellaneous standard library types**:\n //!    - Duration\n+//!    - SystemTime\n //!    - Path\n //!    - PathBuf\n //!    - Range\\<T\\>\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex d1bddfaf4..b915fba76 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -14,7 +14,7 @@ extern crate serde_derive;\n use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n use std::net;\n use std::path::{Path, PathBuf};\n-use std::time::Duration;\n+use std::time::{Duration, UNIX_EPOCH};\n use std::default::Default;\n use std::ffi::{CString, OsString};\n \n@@ -682,6 +682,23 @@ declare_tests! {\n             Token::SeqEnd,\n         ],\n     }\n+    test_system_time {\n+        UNIX_EPOCH + Duration::new(1, 2) => &[\n+            Token::Struct { name: \"SystemTime\", len: 2 },\n+                Token::Str(\"secs_since_epoch\"),\n+                Token::U64(1),\n+\n+                Token::Str(\"nanos_since_epoch\"),\n+                Token::U32(2),\n+            Token::StructEnd,\n+        ],\n+        UNIX_EPOCH + Duration::new(1, 2) => &[\n+            Token::Seq { len: Some(2) },\n+                Token::I64(1),\n+                Token::I64(2),\n+            Token::SeqEnd,\n+        ],\n+    }\n     test_range {\n         1u32..2u32 => &[\n             Token::Struct { name: \"Range\", len: 2 },\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex ae10b26b6..35ed33c55 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -12,7 +12,7 @@ extern crate serde_derive;\n use std::collections::{BTreeMap, HashMap, HashSet};\n use std::net;\n use std::path::{Path, PathBuf};\n-use std::time::Duration;\n+use std::time::{Duration, UNIX_EPOCH};\n use std::ffi::CString;\n \n #[cfg(unix)]\n@@ -319,6 +319,17 @@ declare_tests! {\n             Token::StructEnd,\n         ],\n     }\n+    test_system_time {\n+        UNIX_EPOCH + Duration::new(1, 2) => &[\n+            Token::Struct { name: \"SystemTime\", len: 2 },\n+                Token::Str(\"secs_since_epoch\"),\n+                Token::U64(1),\n+\n+                Token::Str(\"nanos_since_epoch\"),\n+                Token::U32(2),\n+            Token::StructEnd,\n+        ],\n+    }\n     test_range {\n         1u32..2u32 => &[\n             Token::Struct { name: \"Range\", len: 2 },\n", "problem_statement": "impl Serialize and Deserialize for std::time::SystemTime\nIf there is a different type that is better suited for timestamps in serialized data that's already supported by serde, I'd be happy to know about it. The serialized format should probably be [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601).\n\n", "hints_text": ":+1: We're going to have to use this approach mentioned in the documentation:\n\n> Although a `SystemTime` cannot be directly inspected, the `UNIX_EPOCH` constant is provided in this module as an anchor in time to learn information about a `SystemTime`. By calculating the duration from this fixed point in time, a SystemTime can be converted to a human-readable time, or perhaps some other string representation.\n\n@jplatte for now can you use [`chrono::DateTime`](https://lifthrasiir.github.io/rust-chrono/chrono/datetime/struct.DateTime.html) which already supports Serde serialization to ISO 8601?\n\n@dtolnay Thanks for the pointer, I actually like the explicitness of that API, I'll happily use it, not just temporarily. However, it doesn't seem to be supported in the latest crates.io release of serde (0.8.6), I get\n\n```\nthe trait bound `chrono::DateTime<chrono::Local>: serde::Deserialize` is not satisfied\n```\n\n(same if I try UTC)\n\n@jplatte they make you opt into Serde support because not everybody wants it:\n\nhttps://github.com/lifthrasiir/rust-chrono/blob/6cc5d1869641f75bda2135e58aef60f333df4227/Cargo.toml#L21\n\n``` toml\n[dependencies]\nchrono = { version = \"0.2\", features = [\"serde\"] }\n```\n\nAh, thanks again, now it works! :)\n\nWould also be nice to support [`std::time::Instant`](https://doc.rust-lang.org/std/time/struct.Instant.html) as well.", "created_at": "2017-06-04T08:40:20Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 935, "instance_id": "serde-rs__serde-935", "issue_numbers": ["931"], "base_commit": "4d5e450054431abb44e35c9d0c73d89b5741f05b", "patch": "diff --git a/serde_derive_internals/src/attr.rs b/serde_derive_internals/src/attr.rs\nindex f60219103..caf306cfa 100644\n--- a/serde_derive_internals/src/attr.rs\n+++ b/serde_derive_internals/src/attr.rs\n@@ -719,6 +719,12 @@ impl Field {\n                         skip_deserializing.set_true();\n                     }\n \n+                    // Parse `#[serde(skip)]`\n+                    MetaItem(Word(ref name)) if name == \"skip\" => {\n+                        skip_serializing.set_true();\n+                        skip_deserializing.set_true();\n+                    },\n+\n                     // Parse `#[serde(skip_serializing_if = \"...\")]`\n                     MetaItem(NameValue(ref name, ref lit)) if name == \"skip_serializing_if\" => {\n                         if let Ok(path) = parse_lit_into_path(cx, name.as_ref(), lit) {\n", "test_patch": "diff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex f2604d456..cb9642e8f 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -580,6 +580,41 @@ fn test_skip_serializing_struct() {\n     );\n }\n \n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+struct SkipStruct<B>\n+{\n+    a: i8,\n+    #[serde(skip)]\n+    b: B,\n+}\n+\n+#[test]\n+fn test_skip_struct() {\n+    assert_ser_tokens(\n+        &SkipStruct { a: 1, b: 2 },\n+        &[\n+            Token::Struct { name: \"SkipStruct\", len: 1 },\n+\n+            Token::Str(\"a\"),\n+            Token::I8(1),\n+\n+            Token::StructEnd,\n+        ],\n+    );\n+\n+    assert_de_tokens(\n+        &SkipStruct { a: 1, b: 0 },\n+        &[\n+            Token::Struct { name: \"SkipStruct\", len: 1 },\n+\n+            Token::Str(\"a\"),\n+            Token::I8(1),\n+\n+            Token::StructEnd,\n+        ],\n+    );\n+}\n+\n #[derive(Debug, PartialEq, Serialize)]\n enum SkipSerializingEnum<'a, B, C>\n where\n", "problem_statement": "Warn when using only one of skip_serializing and skip_deserializing\nI used the `skip_serializing` attribute for a field, but forgot to add `skip_deserializing` too. After serializing my data to a binary format (with `bincode`), I tried to deserialize it but got an error which took a long time to track down.\r\n\r\n```\r\n/* Example code */\r\n#[derive(Serialize, Deserialize)]\r\npub struct Data {\r\n    #[serde(skip_serializing)] // forgot skip_deserializing\r\n    foo: u32,\r\n    //...\r\n}\r\n```\r\n\r\nIf `Serialize` and `Deserialize` are both derived, then it never makes sense to use only one of `skip_serializing` and `skip_deserializing` -- I expect a derived serializer to always be compatible with the derived deserializer.\r\n\r\nHere are some ways to prevent this:\r\n\r\n  - Warn when both `Serialize` and `Deserialize` and derived but only one of `skip_serializing` and `skip_deserializing` is used.\r\n  - Make `skip_serializing` imply `skip_deserializing` and vice versa.\r\n  - Replace `skip_serializing` and `skip_deserializing` with a single attribute that means both.\r\n  - (As a last resort: in the documentation for `skip_serializing`, add the warning \"You may want to use `skip_deserializing` too.\", and vice versa.)\r\n\r\nThis issue also applies to:\r\n\r\n  - The `skip_serializing` and `skip_deserializing` variant attributes.\r\n  - The `serialize_with` and `deserialize_with` field attributes.\r\n\r\nWhat do you think?\r\n\n", "hints_text": "From some quick github searches it looks like having one but not both of `skip_serializing` and `skip_deserializing` on a type that derives both `Serialize` and `Deserialize` is fairly uncommon but there are some legitimate use cases. I would be on board with adding a single attribute that means both, and improving the documentation. Would you be interested in tackling this with a PR? It would probably look a lot like #765.\r\n\r\nHaving one but not both of `serialize_with` and `deserialize_with` on a type that derives both `Serialize` and `Deserialize` is more common. Here is a sample of some:\r\n\r\n- [fac-rs](https://github.com/Arnavion/fac-rs/blob/51b34261aa9f21ef4c926bed8302feab84619235/src/config.rs#L6)\r\n- [rusoto](https://github.com/rusoto/rusoto/blob/8dbe7ef0022e926f43fe5d2965babcce63b530ca/service_crategen/src/cargo.rs#L10)\r\n- [rustc-perf](https://github.com/rust-lang-nursery/rustc-perf/blob/ffb2326fe3b8ec05d3da14e6cdb7150024761110/src/server.rs#L283)\r\n- [rustiful](https://github.com/blakepettersson/rustiful/blob/3ddfac5db399fe5e58e220d8a14417579d74dcdb/rustiful-derive/src/json.rs#L164)\r\n- [mastodon-rs](https://github.com/tinaun/mastodon-rs/blob/9b034358527ce3ccfa230b4fe8b05f7f94184fda/src/entities.rs#L86)\r\n- [ganbare](https://github.com/golddranks/ganbare/blob/79a849e1f1eda8266b70d6b5b118d66ceeecb169/ganbare_backend/src/models.rs#L307)", "created_at": "2017-05-16T09:39:16Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 933, "instance_id": "serde-rs__serde-933", "issue_numbers": ["932"], "base_commit": "c68b95969679a4d67180d14cf3b200dc9ce34de1", "patch": "diff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex 2c5648cd5..19736a14b 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -1082,7 +1082,7 @@ mod content {\n                     }\n                     (variant, Some(value))\n                 }\n-                Content::String(variant) => (Content::String(variant), None),\n+                s @ Content::String(_) | s @ Content::Str(_) => (s, None),\n                 other => {\n                     return Err(de::Error::invalid_type(other.unexpected(), &\"string or map\"),);\n                 }\n@@ -1476,7 +1476,7 @@ mod content {\n                     }\n                     (variant, Some(value))\n                 }\n-                ref s @ Content::String(_) => (s, None),\n+                ref s @ Content::String(_) | ref s @ Content::Str(_) => (s, None),\n                 ref other => {\n                     return Err(de::Error::invalid_type(other.unexpected(), &\"string or map\"),);\n                 }\n", "test_patch": "diff --git a/test_suite/tests/test_macros.rs b/test_suite/tests/test_macros.rs\nindex 651bcfea1..c4c615664 100644\n--- a/test_suite/tests/test_macros.rs\n+++ b/test_suite/tests/test_macros.rs\n@@ -695,6 +695,35 @@ fn test_internally_tagged_enum() {\n     );\n }\n \n+#[test]\n+fn test_internally_tagged_struct_variant_containing_unit_variant() {\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    pub enum Level {\n+        Info,\n+    }\n+\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    #[serde(tag = \"action\")]\n+    pub enum Message {\n+        Log { level: Level },\n+    }\n+\n+    assert_de_tokens(\n+        &Message::Log { level: Level::Info },\n+        &[\n+            Token::Struct { name: \"Message\", len: 2 },\n+\n+            Token::Str(\"action\"),\n+            Token::Str(\"Log\"),\n+\n+            Token::Str(\"level\"),\n+            Token::BorrowedStr(\"Info\"),\n+\n+            Token::StructEnd,\n+        ],\n+    );\n+}\n+\n #[test]\n fn test_internally_tagged_borrow() {\n     #[derive(Debug, PartialEq, Serialize, Deserialize)]\n", "problem_statement": "Regression deserializing string Enums between 1.0.3 and 1.0.4\nThe example in https://gist.github.com/anonymous/440028c896809d8b3b51d8333cb6d2f9 works for me with `serde = \"=1.0.3\"`, `serde_json = \"1.0.2\"` and `serde_derive = \"1.0.4\"` and current stable rust, but errors when specifying `serde = \"=1.0.4\"` (or less precisely, just setting all those things to `= 1`.\r\n\r\nThe output I see is:\r\n```\r\n{\"action\":\"log\",\"level\":\"INFO\"}\r\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ErrorImpl { code: Message(\"invalid type: string \\\"INFO\\\", expected string or map\"), line: 0, column: 0 }', /checkout/src/libcore/result.rs:859\r\n```\n", "hints_text": "", "created_at": "2017-05-14T19:30:53Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 926, "instance_id": "serde-rs__serde-926", "issue_numbers": ["906"], "base_commit": "58e30eaee4f62acc621ce95635fa7c7f8fe5c123", "patch": "diff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex 45b383fb0..2c5648cd5 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -233,7 +233,7 @@ mod content {\n     ///\n     /// Not public API. Use serde-value instead.\n     #[derive(Debug)]\n-    pub enum Content {\n+    pub enum Content<'de> {\n         Bool(bool),\n \n         U8(u8),\n@@ -251,18 +251,20 @@ mod content {\n \n         Char(char),\n         String(String),\n-        Bytes(Vec<u8>),\n+        Str(&'de str),\n+        ByteBuf(Vec<u8>),\n+        Bytes(&'de [u8]),\n \n         None,\n-        Some(Box<Content>),\n+        Some(Box<Content<'de>>),\n \n         Unit,\n-        Newtype(Box<Content>),\n-        Seq(Vec<Content>),\n-        Map(Vec<(Content, Content)>),\n+        Newtype(Box<Content<'de>>),\n+        Seq(Vec<Content<'de>>),\n+        Map(Vec<(Content<'de>, Content<'de>)>),\n     }\n \n-    impl Content {\n+    impl<'de> Content<'de> {\n         fn unexpected(&self) -> Unexpected {\n             match *self {\n                 Content::Bool(b) => Unexpected::Bool(b),\n@@ -278,7 +280,9 @@ mod content {\n                 Content::F64(f) => Unexpected::Float(f),\n                 Content::Char(c) => Unexpected::Char(c),\n                 Content::String(ref s) => Unexpected::Str(s),\n-                Content::Bytes(ref b) => Unexpected::Bytes(b),\n+                Content::Str(s) => Unexpected::Str(s),\n+                Content::ByteBuf(ref b) => Unexpected::Bytes(b),\n+                Content::Bytes(b) => Unexpected::Bytes(b),\n                 Content::None | Content::Some(_) => Unexpected::Option,\n                 Content::Unit => Unexpected::Unit,\n                 Content::Newtype(_) => Unexpected::NewtypeStruct,\n@@ -288,21 +292,30 @@ mod content {\n         }\n     }\n \n-    impl<'de> Deserialize<'de> for Content {\n+    impl<'de> Deserialize<'de> for Content<'de> {\n         fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n         where\n             D: Deserializer<'de>,\n         {\n             // Untagged and internally tagged enums are only supported in\n             // self-describing formats.\n-            deserializer.deserialize_any(ContentVisitor)\n+            let visitor = ContentVisitor { value: PhantomData };\n+            deserializer.deserialize_any(visitor)\n         }\n     }\n \n-    struct ContentVisitor;\n+    struct ContentVisitor<'de> {\n+        value: PhantomData<Content<'de>>,\n+    }\n \n-    impl<'de> Visitor<'de> for ContentVisitor {\n-        type Value = Content;\n+    impl<'de> ContentVisitor<'de> {\n+        fn new() -> Self {\n+            ContentVisitor { value: PhantomData }\n+        }\n+    }\n+\n+    impl<'de> Visitor<'de> for ContentVisitor<'de> {\n+        type Value = Content<'de>;\n \n         fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n             fmt.write_str(\"any value\")\n@@ -399,6 +412,13 @@ mod content {\n             Ok(Content::String(value.into()))\n         }\n \n+        fn visit_borrowed_str<F>(self, value: &'de str) -> Result<Self::Value, F>\n+        where\n+            F: de::Error,\n+        {\n+            Ok(Content::Str(value))\n+        }\n+\n         fn visit_string<F>(self, value: String) -> Result<Self::Value, F>\n         where\n             F: de::Error,\n@@ -410,16 +430,23 @@ mod content {\n         where\n             F: de::Error,\n         {\n-            Ok(Content::Bytes(value.into()))\n+            Ok(Content::ByteBuf(value.into()))\n         }\n \n-        fn visit_byte_buf<F>(self, value: Vec<u8>) -> Result<Self::Value, F>\n+        fn visit_borrowed_bytes<F>(self, value: &'de [u8]) -> Result<Self::Value, F>\n         where\n             F: de::Error,\n         {\n             Ok(Content::Bytes(value))\n         }\n \n+        fn visit_byte_buf<F>(self, value: Vec<u8>) -> Result<Self::Value, F>\n+        where\n+            F: de::Error,\n+        {\n+            Ok(Content::ByteBuf(value))\n+        }\n+\n         fn visit_unit<F>(self) -> Result<Self::Value, F>\n         where\n             F: de::Error,\n@@ -481,23 +508,24 @@ mod content {\n     /// This is the type of the map keys in an internally tagged enum.\n     ///\n     /// Not public API.\n-    pub enum TagOrContent {\n+    pub enum TagOrContent<'de> {\n         Tag,\n-        Content(Content),\n+        Content(Content<'de>),\n     }\n \n-    struct TagOrContentVisitor {\n+    struct TagOrContentVisitor<'de> {\n         name: &'static str,\n+        value: PhantomData<TagOrContent<'de>>,\n     }\n \n-    impl TagOrContentVisitor {\n+    impl<'de> TagOrContentVisitor<'de> {\n         fn new(name: &'static str) -> Self {\n-            TagOrContentVisitor { name: name }\n+            TagOrContentVisitor { name: name, value: PhantomData }\n         }\n     }\n \n-    impl<'de> DeserializeSeed<'de> for TagOrContentVisitor {\n-        type Value = TagOrContent;\n+    impl<'de> DeserializeSeed<'de> for TagOrContentVisitor<'de> {\n+        type Value = TagOrContent<'de>;\n \n         fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n         where\n@@ -509,8 +537,8 @@ mod content {\n         }\n     }\n \n-    impl<'de> Visitor<'de> for TagOrContentVisitor {\n-        type Value = TagOrContent;\n+    impl<'de> Visitor<'de> for TagOrContentVisitor<'de> {\n+        type Value = TagOrContent<'de>;\n \n         fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n             write!(fmt, \"a type tag `{}` or any other value\", self.name)\n@@ -520,7 +548,7 @@ mod content {\n         where\n             F: de::Error,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_bool(value)\n                 .map(TagOrContent::Content)\n         }\n@@ -529,14 +557,14 @@ mod content {\n         where\n             F: de::Error,\n         {\n-            ContentVisitor.visit_i8(value).map(TagOrContent::Content)\n+            ContentVisitor::new().visit_i8(value).map(TagOrContent::Content)\n         }\n \n         fn visit_i16<F>(self, value: i16) -> Result<Self::Value, F>\n         where\n             F: de::Error,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_i16(value)\n                 .map(TagOrContent::Content)\n         }\n@@ -545,7 +573,7 @@ mod content {\n         where\n             F: de::Error,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_i32(value)\n                 .map(TagOrContent::Content)\n         }\n@@ -554,7 +582,7 @@ mod content {\n         where\n             F: de::Error,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_i64(value)\n                 .map(TagOrContent::Content)\n         }\n@@ -563,14 +591,14 @@ mod content {\n         where\n             F: de::Error,\n         {\n-            ContentVisitor.visit_u8(value).map(TagOrContent::Content)\n+            ContentVisitor::new().visit_u8(value).map(TagOrContent::Content)\n         }\n \n         fn visit_u16<F>(self, value: u16) -> Result<Self::Value, F>\n         where\n             F: de::Error,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_u16(value)\n                 .map(TagOrContent::Content)\n         }\n@@ -579,7 +607,7 @@ mod content {\n         where\n             F: de::Error,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_u32(value)\n                 .map(TagOrContent::Content)\n         }\n@@ -588,7 +616,7 @@ mod content {\n         where\n             F: de::Error,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_u64(value)\n                 .map(TagOrContent::Content)\n         }\n@@ -597,7 +625,7 @@ mod content {\n         where\n             F: de::Error,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_f32(value)\n                 .map(TagOrContent::Content)\n         }\n@@ -606,7 +634,7 @@ mod content {\n         where\n             F: de::Error,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_f64(value)\n                 .map(TagOrContent::Content)\n         }\n@@ -615,7 +643,7 @@ mod content {\n         where\n             F: de::Error,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_char(value)\n                 .map(TagOrContent::Content)\n         }\n@@ -627,12 +655,25 @@ mod content {\n             if value == self.name {\n                 Ok(TagOrContent::Tag)\n             } else {\n-                ContentVisitor\n+                ContentVisitor::new()\n                     .visit_str(value)\n                     .map(TagOrContent::Content)\n             }\n         }\n \n+        fn visit_borrowed_str<F>(self, value: &'de str) -> Result<Self::Value, F>\n+        where\n+            F: de::Error,\n+        {\n+            if value == self.name {\n+                Ok(TagOrContent::Tag)\n+            } else {\n+                ContentVisitor::new()\n+                    .visit_borrowed_str(value)\n+                    .map(TagOrContent::Content)\n+            }\n+        }\n+\n         fn visit_string<F>(self, value: String) -> Result<Self::Value, F>\n         where\n             F: de::Error,\n@@ -640,7 +681,7 @@ mod content {\n             if value == self.name {\n                 Ok(TagOrContent::Tag)\n             } else {\n-                ContentVisitor\n+                ContentVisitor::new()\n                     .visit_string(value)\n                     .map(TagOrContent::Content)\n             }\n@@ -653,12 +694,25 @@ mod content {\n             if value == self.name.as_bytes() {\n                 Ok(TagOrContent::Tag)\n             } else {\n-                ContentVisitor\n+                ContentVisitor::new()\n                     .visit_bytes(value)\n                     .map(TagOrContent::Content)\n             }\n         }\n \n+        fn visit_borrowed_bytes<F>(self, value: &'de [u8]) -> Result<Self::Value, F>\n+        where\n+            F: de::Error,\n+        {\n+            if value == self.name.as_bytes() {\n+                Ok(TagOrContent::Tag)\n+            } else {\n+                ContentVisitor::new()\n+                    .visit_borrowed_bytes(value)\n+                    .map(TagOrContent::Content)\n+            }\n+        }\n+\n         fn visit_byte_buf<F>(self, value: Vec<u8>) -> Result<Self::Value, F>\n         where\n             F: de::Error,\n@@ -666,7 +720,7 @@ mod content {\n             if value == self.name.as_bytes() {\n                 Ok(TagOrContent::Tag)\n             } else {\n-                ContentVisitor\n+                ContentVisitor::new()\n                     .visit_byte_buf(value)\n                     .map(TagOrContent::Content)\n             }\n@@ -676,21 +730,21 @@ mod content {\n         where\n             F: de::Error,\n         {\n-            ContentVisitor.visit_unit().map(TagOrContent::Content)\n+            ContentVisitor::new().visit_unit().map(TagOrContent::Content)\n         }\n \n         fn visit_none<F>(self) -> Result<Self::Value, F>\n         where\n             F: de::Error,\n         {\n-            ContentVisitor.visit_none().map(TagOrContent::Content)\n+            ContentVisitor::new().visit_none().map(TagOrContent::Content)\n         }\n \n         fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n         where\n             D: Deserializer<'de>,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_some(deserializer)\n                 .map(TagOrContent::Content)\n         }\n@@ -699,7 +753,7 @@ mod content {\n         where\n             D: Deserializer<'de>,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_newtype_struct(deserializer)\n                 .map(TagOrContent::Content)\n         }\n@@ -708,7 +762,7 @@ mod content {\n         where\n             V: SeqAccess<'de>,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_seq(visitor)\n                 .map(TagOrContent::Content)\n         }\n@@ -717,7 +771,7 @@ mod content {\n         where\n             V: MapAccess<'de>,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_map(visitor)\n                 .map(TagOrContent::Content)\n         }\n@@ -726,7 +780,7 @@ mod content {\n         where\n             V: EnumAccess<'de>,\n         {\n-            ContentVisitor\n+            ContentVisitor::new()\n                 .visit_enum(visitor)\n                 .map(TagOrContent::Content)\n         }\n@@ -735,33 +789,33 @@ mod content {\n     /// Used by generated code to deserialize an internally tagged enum.\n     ///\n     /// Not public API.\n-    pub struct TaggedContent<T> {\n+    pub struct TaggedContent<'de, T> {\n         pub tag: T,\n-        pub content: Content,\n+        pub content: Content<'de>,\n     }\n \n     /// Not public API.\n-    pub struct TaggedContentVisitor<T> {\n+    pub struct TaggedContentVisitor<'de, T> {\n         tag_name: &'static str,\n-        tag: PhantomData<T>,\n+        value: PhantomData<TaggedContent<'de, T>>,\n     }\n \n-    impl<T> TaggedContentVisitor<T> {\n+    impl<'de, T> TaggedContentVisitor<'de, T> {\n         /// Visitor for the content of an internally tagged enum with the given tag\n         /// name.\n         pub fn new(name: &'static str) -> Self {\n             TaggedContentVisitor {\n                 tag_name: name,\n-                tag: PhantomData,\n+                value: PhantomData,\n             }\n         }\n     }\n \n-    impl<'de, T> DeserializeSeed<'de> for TaggedContentVisitor<T>\n+    impl<'de, T> DeserializeSeed<'de> for TaggedContentVisitor<'de, T>\n     where\n         T: Deserialize<'de>,\n     {\n-        type Value = TaggedContent<T>;\n+        type Value = TaggedContent<'de, T>;\n \n         fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n         where\n@@ -773,11 +827,11 @@ mod content {\n         }\n     }\n \n-    impl<'de, T> Visitor<'de> for TaggedContentVisitor<T>\n+    impl<'de, T> Visitor<'de> for TaggedContentVisitor<'de, T>\n     where\n         T: Deserialize<'de>,\n     {\n-        type Value = TaggedContent<T>;\n+        type Value = TaggedContent<'de, T>;\n \n         fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n             fmt.write_str(\"any value\")\n@@ -913,14 +967,14 @@ mod content {\n     }\n \n     /// Not public API\n-    pub struct ContentDeserializer<E> {\n-        content: Content,\n+    pub struct ContentDeserializer<'de, E> {\n+        content: Content<'de>,\n         err: PhantomData<E>,\n     }\n \n     /// Used when deserializing an internally tagged enum because the content will\n     /// be used exactly once.\n-    impl<'de, E> Deserializer<'de> for ContentDeserializer<E>\n+    impl<'de, E> Deserializer<'de> for ContentDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n@@ -944,6 +998,9 @@ mod content {\n                 Content::F64(v) => visitor.visit_f64(v),\n                 Content::Char(v) => visitor.visit_char(v),\n                 Content::String(v) => visitor.visit_string(v),\n+                Content::Str(v) => visitor.visit_borrowed_str(v),\n+                Content::ByteBuf(v) => visitor.visit_byte_buf(v),\n+                Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n                 Content::Unit => visitor.visit_unit(),\n                 Content::None => visitor.visit_none(),\n                 Content::Some(v) => visitor.visit_some(ContentDeserializer::new(*v)),\n@@ -965,7 +1022,6 @@ mod content {\n                     try!(map_visitor.end());\n                     Ok(value)\n                 }\n-                Content::Bytes(v) => visitor.visit_byte_buf(v),\n             }\n         }\n \n@@ -1048,9 +1104,9 @@ mod content {\n         }\n     }\n \n-    impl<E> ContentDeserializer<E> {\n+    impl<'de, E> ContentDeserializer<'de, E> {\n         /// private API, don't use\n-        pub fn new(content: Content) -> Self {\n+        pub fn new(content: Content<'de>) -> Self {\n             ContentDeserializer {\n                 content: content,\n                 err: PhantomData,\n@@ -1058,21 +1114,21 @@ mod content {\n         }\n     }\n \n-    struct EnumDeserializer<E>\n+    struct EnumDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n-        variant: Content,\n-        value: Option<Content>,\n+        variant: Content<'de>,\n+        value: Option<Content<'de>>,\n         err: PhantomData<E>,\n     }\n \n-    impl<'de, E> de::EnumAccess<'de> for EnumDeserializer<E>\n+    impl<'de, E> de::EnumAccess<'de> for EnumDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n         type Error = E;\n-        type Variant = VariantDeserializer<Self::Error>;\n+        type Variant = VariantDeserializer<'de, Self::Error>;\n \n         fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), E>\n         where\n@@ -1087,15 +1143,15 @@ mod content {\n         }\n     }\n \n-    struct VariantDeserializer<E>\n+    struct VariantDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n-        value: Option<Content>,\n+        value: Option<Content<'de>>,\n         err: PhantomData<E>,\n     }\n \n-    impl<'de, E> de::VariantAccess<'de> for VariantDeserializer<E>\n+    impl<'de, E> de::VariantAccess<'de> for VariantDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n@@ -1151,19 +1207,19 @@ mod content {\n         }\n     }\n \n-    struct SeqDeserializer<E>\n+    struct SeqDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n-        iter: <Vec<Content> as IntoIterator>::IntoIter,\n+        iter: <Vec<Content<'de>> as IntoIterator>::IntoIter,\n         err: PhantomData<E>,\n     }\n \n-    impl<E> SeqDeserializer<E>\n+    impl<'de, E> SeqDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n-        fn new(vec: Vec<Content>) -> Self {\n+        fn new(vec: Vec<Content<'de>>) -> Self {\n             SeqDeserializer {\n                 iter: vec.into_iter(),\n                 err: PhantomData,\n@@ -1171,7 +1227,7 @@ mod content {\n         }\n     }\n \n-    impl<'de, E> de::Deserializer<'de> for SeqDeserializer<E>\n+    impl<'de, E> de::Deserializer<'de> for SeqDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n@@ -1203,7 +1259,7 @@ mod content {\n         }\n     }\n \n-    impl<'de, E> de::SeqAccess<'de> for SeqDeserializer<E>\n+    impl<'de, E> de::SeqAccess<'de> for SeqDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n@@ -1227,20 +1283,20 @@ mod content {\n         }\n     }\n \n-    struct MapDeserializer<E>\n+    struct MapDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n-        iter: <Vec<(Content, Content)> as IntoIterator>::IntoIter,\n-        value: Option<Content>,\n+        iter: <Vec<(Content<'de>, Content<'de>)> as IntoIterator>::IntoIter,\n+        value: Option<Content<'de>>,\n         err: PhantomData<E>,\n     }\n \n-    impl<E> MapDeserializer<E>\n+    impl<'de, E> MapDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n-        fn new(map: Vec<(Content, Content)>) -> Self {\n+        fn new(map: Vec<(Content<'de>, Content<'de>)>) -> Self {\n             MapDeserializer {\n                 iter: map.into_iter(),\n                 value: None,\n@@ -1249,7 +1305,7 @@ mod content {\n         }\n     }\n \n-    impl<'de, E> de::MapAccess<'de> for MapDeserializer<E>\n+    impl<'de, E> de::MapAccess<'de> for MapDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n@@ -1283,7 +1339,7 @@ mod content {\n         }\n     }\n \n-    impl<'de, E> de::Deserializer<'de> for MapDeserializer<E>\n+    impl<'de, E> de::Deserializer<'de> for MapDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n@@ -1305,14 +1361,14 @@ mod content {\n     }\n \n     /// Not public API.\n-    pub struct ContentRefDeserializer<'a, E> {\n-        content: &'a Content,\n+    pub struct ContentRefDeserializer<'a, 'de: 'a, E> {\n+        content: &'a Content<'de>,\n         err: PhantomData<E>,\n     }\n \n     /// Used when deserializing an untagged enum because the content may need to be\n     /// used more than once.\n-    impl<'de, 'a, E> Deserializer<'de> for ContentRefDeserializer<'a, E>\n+    impl<'de, 'a, E> Deserializer<'de> for ContentRefDeserializer<'a, 'de, E>\n     where\n         E: de::Error,\n     {\n@@ -1336,6 +1392,9 @@ mod content {\n                 Content::F64(v) => visitor.visit_f64(v),\n                 Content::Char(v) => visitor.visit_char(v),\n                 Content::String(ref v) => visitor.visit_str(v),\n+                Content::Str(v) => visitor.visit_borrowed_str(v),\n+                Content::ByteBuf(ref v) => visitor.visit_bytes(v),\n+                Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n                 Content::Unit => visitor.visit_unit(),\n                 Content::None => visitor.visit_none(),\n                 Content::Some(ref v) => visitor.visit_some(ContentRefDeserializer::new(v)),\n@@ -1361,7 +1420,6 @@ mod content {\n                     try!(map_visitor.end());\n                     Ok(value)\n                 }\n-                Content::Bytes(ref v) => visitor.visit_bytes(v),\n             }\n         }\n \n@@ -1440,9 +1498,9 @@ mod content {\n         }\n     }\n \n-    impl<'a, E> ContentRefDeserializer<'a, E> {\n+    impl<'a, 'de, E> ContentRefDeserializer<'a, 'de, E> {\n         /// private API, don't use\n-        pub fn new(content: &'a Content) -> Self {\n+        pub fn new(content: &'a Content<'de>) -> Self {\n             ContentRefDeserializer {\n                 content: content,\n                 err: PhantomData,\n@@ -1450,21 +1508,21 @@ mod content {\n         }\n     }\n \n-    struct EnumRefDeserializer<'a, E>\n+    struct EnumRefDeserializer<'a, 'de: 'a, E>\n     where\n         E: de::Error,\n     {\n-        variant: &'a Content,\n-        value: Option<&'a Content>,\n+        variant: &'a Content<'de>,\n+        value: Option<&'a Content<'de>>,\n         err: PhantomData<E>,\n     }\n \n-    impl<'de, 'a, E> de::EnumAccess<'de> for EnumRefDeserializer<'a, E>\n+    impl<'de, 'a, E> de::EnumAccess<'de> for EnumRefDeserializer<'a, 'de, E>\n     where\n         E: de::Error,\n     {\n         type Error = E;\n-        type Variant = VariantRefDeserializer<'a, Self::Error>;\n+        type Variant = VariantRefDeserializer<'a, 'de, Self::Error>;\n \n         fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n         where\n@@ -1479,15 +1537,15 @@ mod content {\n         }\n     }\n \n-    struct VariantRefDeserializer<'a, E>\n+    struct VariantRefDeserializer<'a, 'de: 'a, E>\n     where\n         E: de::Error,\n     {\n-        value: Option<&'a Content>,\n+        value: Option<&'a Content<'de>>,\n         err: PhantomData<E>,\n     }\n \n-    impl<'de, 'a, E> de::VariantAccess<'de> for VariantRefDeserializer<'a, E>\n+    impl<'de, 'a, E> de::VariantAccess<'de> for VariantRefDeserializer<'a, 'de, E>\n     where\n         E: de::Error,\n     {\n@@ -1543,19 +1601,19 @@ mod content {\n         }\n     }\n \n-    struct SeqRefDeserializer<'a, E>\n+    struct SeqRefDeserializer<'a, 'de: 'a, E>\n     where\n         E: de::Error,\n     {\n-        iter: <&'a [Content] as IntoIterator>::IntoIter,\n+        iter: <&'a [Content<'de>] as IntoIterator>::IntoIter,\n         err: PhantomData<E>,\n     }\n \n-    impl<'a, E> SeqRefDeserializer<'a, E>\n+    impl<'a, 'de, E> SeqRefDeserializer<'a, 'de, E>\n     where\n         E: de::Error,\n     {\n-        fn new(vec: &'a [Content]) -> Self {\n+        fn new(vec: &'a [Content<'de>]) -> Self {\n             SeqRefDeserializer {\n                 iter: vec.into_iter(),\n                 err: PhantomData,\n@@ -1563,7 +1621,7 @@ mod content {\n         }\n     }\n \n-    impl<'de, 'a, E> de::Deserializer<'de> for SeqRefDeserializer<'a, E>\n+    impl<'de, 'a, E> de::Deserializer<'de> for SeqRefDeserializer<'a, 'de, E>\n     where\n         E: de::Error,\n     {\n@@ -1595,7 +1653,7 @@ mod content {\n         }\n     }\n \n-    impl<'de, 'a, E> de::SeqAccess<'de> for SeqRefDeserializer<'a, E>\n+    impl<'de, 'a, E> de::SeqAccess<'de> for SeqRefDeserializer<'a, 'de, E>\n     where\n         E: de::Error,\n     {\n@@ -1619,20 +1677,20 @@ mod content {\n         }\n     }\n \n-    struct MapRefDeserializer<'a, E>\n+    struct MapRefDeserializer<'a, 'de: 'a, E>\n     where\n         E: de::Error,\n     {\n-        iter: <&'a [(Content, Content)] as IntoIterator>::IntoIter,\n-        value: Option<&'a Content>,\n+        iter: <&'a [(Content<'de>, Content<'de>)] as IntoIterator>::IntoIter,\n+        value: Option<&'a Content<'de>>,\n         err: PhantomData<E>,\n     }\n \n-    impl<'a, E> MapRefDeserializer<'a, E>\n+    impl<'a, 'de, E> MapRefDeserializer<'a, 'de, E>\n     where\n         E: de::Error,\n     {\n-        fn new(map: &'a [(Content, Content)]) -> Self {\n+        fn new(map: &'a [(Content<'de>, Content<'de>)]) -> Self {\n             MapRefDeserializer {\n                 iter: map.into_iter(),\n                 value: None,\n@@ -1641,7 +1699,7 @@ mod content {\n         }\n     }\n \n-    impl<'de, 'a, E> de::MapAccess<'de> for MapRefDeserializer<'a, E>\n+    impl<'de, 'a, E> de::MapAccess<'de> for MapRefDeserializer<'a, 'de, E>\n     where\n         E: de::Error,\n     {\n@@ -1676,7 +1734,7 @@ mod content {\n         }\n     }\n \n-    impl<'de, 'a, E> de::Deserializer<'de> for MapRefDeserializer<'a, E>\n+    impl<'de, 'a, E> de::Deserializer<'de> for MapRefDeserializer<'a, 'de, E>\n     where\n         E: de::Error,\n     {\n@@ -1697,7 +1755,7 @@ mod content {\n         }\n     }\n \n-    impl<'de, E> de::IntoDeserializer<'de, E> for ContentDeserializer<E>\n+    impl<'de, E> de::IntoDeserializer<'de, E> for ContentDeserializer<'de, E>\n     where\n         E: de::Error,\n     {\n@@ -1708,7 +1766,7 @@ mod content {\n         }\n     }\n \n-    impl<'de, 'a, E> de::IntoDeserializer<'de, E> for ContentRefDeserializer<'a, E>\n+    impl<'de, 'a, E> de::IntoDeserializer<'de, E> for ContentRefDeserializer<'a, 'de, E>\n     where\n         E: de::Error,\n     {\n", "test_patch": "diff --git a/test_suite/tests/test_macros.rs b/test_suite/tests/test_macros.rs\nindex 6c7e4b2ab..651bcfea1 100644\n--- a/test_suite/tests/test_macros.rs\n+++ b/test_suite/tests/test_macros.rs\n@@ -695,6 +695,30 @@ fn test_internally_tagged_enum() {\n     );\n }\n \n+#[test]\n+fn test_internally_tagged_borrow() {\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    #[serde(tag = \"type\")]\n+    pub enum Input<'a> {\n+        Package { name: &'a str },\n+    }\n+\n+    assert_tokens(\n+        &Input::Package { name: \"borrowed\" },\n+        &[\n+            Token::Struct { name: \"Input\", len: 2 },\n+\n+            Token::BorrowedStr(\"type\"),\n+            Token::BorrowedStr(\"Package\"),\n+\n+            Token::BorrowedStr(\"name\"),\n+            Token::BorrowedStr(\"borrowed\"),\n+\n+            Token::StructEnd,\n+        ],\n+    );\n+}\n+\n #[test]\n fn test_adjacently_tagged_enum() {\n     #[derive(Debug, PartialEq, Serialize, Deserialize)]\n", "problem_statement": "Support borrowing within internally tagged enum\nSerde panics when trying to deserialize an struct which has a borrowed field, which also contains a borrowed field. For example, the following code compiles fine:\r\n\r\n**EDIT:** fixed the example\r\n```rust\r\n#[macro_use]\r\nextern crate serde_derive;\r\n\r\nextern crate serde;\r\nextern crate serde_json;\r\n\r\n#[derive(Deserialize, Debug)]\r\n#[serde(tag = \"type\")]\r\npub enum Input<'a> {\r\n    Package { name: &'a str },\r\n}\r\n\r\nfn main() {\r\n    let j = r#\"{\"type\":\"Package\",\"name\":\"\"}\"#;\r\n    println!(\"{}\", serde_json::from_str::<Input>(j).unwrap_err());\r\n}\r\n```\r\n\r\nBut you get the following panic:\r\n\r\n```\r\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error { inner: ErrorInner { kind: Custom, line: None, col: 0, message: \"invalid type: string \\\"bye\\\", expected a borrowed string\", key: [\"input\"] } }', /buildslave/rust-buildbot/slave/stable-dist-rustc-linux/build/src/libcore/result.rs:868\r\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\r\n```\n", "hints_text": "I don't think this is correctly minimized from what you showed in IRC earlier. [It gives a different error.](http://play.integer32.com/?gist=29b4a709bd0aecba7a5aa19024619778) Side note: the panic is coming from your code not Serde, because you unwrap the error. :wink: \nI minimized it to this:\r\n\r\n```rust\r\n#[macro_use]\r\nextern crate serde_derive;\r\n\r\nextern crate serde;\r\nextern crate serde_json;\r\n\r\n#[derive(Deserialize, Debug)]\r\n#[serde(tag = \"type\")]\r\npub enum Input<'a> {\r\n    Package { name: &'a str },\r\n}\r\n\r\nfn main() {\r\n    let j = r#\"{\"type\":\"Package\",\"name\":\"\"}\"#;\r\n    println!(\"{}\", serde_json::from_str::<Input>(j).unwrap_err());\r\n}\r\n```\r\n\r\n```\r\ninvalid type: string \"\", expected a borrowed string\r\n```\nOh sorry, the code in the link is indeed wrong. I think it has saved changes I made after pasting it in IRC...\r\nAnd yes, that's _real_ minimization what you have done.", "created_at": "2017-05-11T02:57:59Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2802, "instance_id": "serde-rs__serde-2802", "issue_numbers": ["2801"], "base_commit": "1b4da41f970555e111f471633205bbcb4dadbc63", "patch": "diff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex c402d2c66..c146539ee 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -2710,6 +2710,17 @@ where\n         visitor.visit_unit()\n     }\n \n+    fn deserialize_unit_struct<V>(\n+        self,\n+        _name: &'static str,\n+        visitor: V,\n+    ) -> Result<V::Value, Self::Error>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        visitor.visit_unit()\n+    }\n+\n     fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: Visitor<'de>,\n@@ -2734,7 +2745,6 @@ where\n         deserialize_string()\n         deserialize_bytes()\n         deserialize_byte_buf()\n-        deserialize_unit_struct(&'static str)\n         deserialize_seq()\n         deserialize_tuple(usize)\n         deserialize_tuple_struct(&'static str, usize)\ndiff --git a/serde/src/private/ser.rs b/serde/src/private/ser.rs\nindex 9570629e9..ebfeba97e 100644\n--- a/serde/src/private/ser.rs\n+++ b/serde/src/private/ser.rs\n@@ -51,8 +51,6 @@ enum Unsupported {\n     String,\n     ByteArray,\n     Optional,\n-    #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n-    UnitStruct,\n     Sequence,\n     Tuple,\n     TupleStruct,\n@@ -69,8 +67,6 @@ impl Display for Unsupported {\n             Unsupported::String => formatter.write_str(\"a string\"),\n             Unsupported::ByteArray => formatter.write_str(\"a byte array\"),\n             Unsupported::Optional => formatter.write_str(\"an optional\"),\n-            #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n-            Unsupported::UnitStruct => formatter.write_str(\"unit struct\"),\n             Unsupported::Sequence => formatter.write_str(\"a sequence\"),\n             Unsupported::Tuple => formatter.write_str(\"a tuple\"),\n             Unsupported::TupleStruct => formatter.write_str(\"a tuple struct\"),\n@@ -1092,7 +1088,7 @@ where\n     }\n \n     fn serialize_unit_struct(self, _: &'static str) -> Result<Self::Ok, Self::Error> {\n-        Err(Self::bad_type(Unsupported::UnitStruct))\n+        Ok(())\n     }\n \n     fn serialize_unit_variant(\n", "test_patch": "diff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex 1174be6d2..63cb3dd1b 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -1815,6 +1815,32 @@ fn test_flatten_unit() {\n     );\n }\n \n+#[test]\n+fn test_flatten_unit_struct() {\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    struct Response<T> {\n+        #[serde(flatten)]\n+        data: T,\n+        status: usize,\n+    }\n+\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    struct Unit;\n+\n+    assert_tokens(\n+        &Response {\n+            data: Unit,\n+            status: 0,\n+        },\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"status\"),\n+            Token::U64(0),\n+            Token::MapEnd,\n+        ],\n+    );\n+}\n+\n #[test]\n fn test_flatten_unsupported_type() {\n     #[derive(Debug, PartialEq, Serialize, Deserialize)]\n", "problem_statement": "Flattening a unit struct should work like flattening unit itself\nhttps://github.com/serde-rs/serde/pull/1874 landed support for flattening the unit type after a report in https://github.com/serde-rs/serde/issues/1873. However, it did not override `deserialize_unit_struct` and `serialize_unit_struct`, so while flattening `()` now works, flattening `struct Unit;` does not. It's not clear whether this was intentional or not, though it seems reasonable to support unit structs the same as unit here.\n", "hints_text": "", "created_at": "2024-08-15T13:51:17Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2791, "instance_id": "serde-rs__serde-2791", "issue_numbers": ["2789"], "base_commit": "e08c5de5dd62571a5687f77d99609f9d9e60784e", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex e3b737c61..c5861d9bc 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -2480,7 +2480,10 @@ fn deserialize_map(\n         });\n \n     // Collect contents for flatten fields into a buffer\n-    let let_collect = if cattrs.has_flatten() {\n+    let has_flatten = fields\n+        .iter()\n+        .any(|field| field.attrs.flatten() && !field.attrs.skip_deserializing());\n+    let let_collect = if has_flatten {\n         Some(quote! {\n             let mut __collect = _serde::__private::Vec::<_serde::__private::Option<(\n                 _serde::__private::de::Content,\n@@ -2532,7 +2535,7 @@ fn deserialize_map(\n         });\n \n     // Visit ignored values to consume them\n-    let ignored_arm = if cattrs.has_flatten() {\n+    let ignored_arm = if has_flatten {\n         Some(quote! {\n             __Field::__other(__name) => {\n                 __collect.push(_serde::__private::Some((\n@@ -2602,7 +2605,7 @@ fn deserialize_map(\n             }\n         });\n \n-    let collected_deny_unknown_fields = if cattrs.has_flatten() && cattrs.deny_unknown_fields() {\n+    let collected_deny_unknown_fields = if has_flatten && cattrs.deny_unknown_fields() {\n         Some(quote! {\n             if let _serde::__private::Some(_serde::__private::Some((__key, _))) =\n                 __collect.into_iter().filter(_serde::__private::Option::is_some).next()\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex f8d577bb8..3dacf00ab 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -4,6 +4,7 @@\n \n #![deny(warnings)]\n #![allow(\n+    confusable_idents,\n     unknown_lints,\n     mixed_script_confusables,\n     clippy::derive_partial_eq_without_eq,\n@@ -19,6 +20,7 @@\n     clippy::trivially_copy_pass_by_ref,\n     clippy::type_repetition_in_bounds\n )]\n+#![deny(clippy::collection_is_never_read)]\n \n use serde::de::{Deserialize, DeserializeOwned, Deserializer};\n use serde::ser::{Serialize, Serializer};\n@@ -724,6 +726,19 @@ fn test_gen() {\n         flat: T,\n     }\n \n+    #[derive(Serialize, Deserialize)]\n+    #[serde(untagged)]\n+    pub enum Inner<T> {\n+        Builder {\n+            s: T,\n+            #[serde(flatten)]\n+            o: T,\n+        },\n+        Default {\n+            s: T,\n+        },\n+    }\n+\n     // https://github.com/serde-rs/serde/issues/1804\n     #[derive(Serialize, Deserialize)]\n     pub enum Message {\n", "problem_statement": "`error: collection is never read` on `#[derive(Deserialize)]`\nOn both current stable 1.80.0 and nightly 1.82.0-nightly (2024-08-06 60d146580c10036ce89e)\r\n\r\nsample code:\r\n\r\n```rust\r\n#![deny(clippy::collection_is_never_read)]\r\n\r\nuse serde::Deserialize;\r\n\r\n#[derive(Deserialize)]\r\nstruct Options {\r\n    a: bool,\r\n}\r\n\r\n#[derive(Deserialize)]\r\n#[serde(untagged)]\r\nenum Inner<'a> {\r\n    Default {\r\n        s: &'a str,\r\n    },\r\n    Builder {\r\n        s: &'a str,\r\n        #[serde(flatten)]\r\n        o: Options,\r\n    },\r\n}\r\n```\r\n\r\nGetting:\r\n\r\n\r\n```text\r\nerror: collection is never read\r\n  --> src/lib.rs:10:10\r\n   |\r\n10 | #[derive(Deserialize)]\r\n   |          ^^^^^^^^^^^\r\n   |\r\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#collection_is_never_read\r\nnote: the lint level is defined here\r\n  --> src/lib.rs:1:9\r\n   |\r\n1  | #![deny(clippy::collection_is_never_read)]\r\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n   = note: this error originates in the derive macro `Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\r\n```\r\n\r\n[Playground link](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d82d6da1e402e39a9c4b30b72b5a6074)\n", "hints_text": "", "created_at": "2024-08-08T01:47:34Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2709, "instance_id": "serde-rs__serde-2709", "issue_numbers": ["2708"], "base_commit": "5b24f88e73caa9c607527b5b4696fc34263cd238", "patch": "diff --git a/serde/build.rs b/serde/build.rs\nindex fe5486a7a..0074df63f 100644\n--- a/serde/build.rs\n+++ b/serde/build.rs\n@@ -64,6 +64,12 @@ fn main() {\n     if minor < 64 {\n         println!(\"cargo:rustc-cfg=no_core_cstr\");\n     }\n+\n+    // Support for core::num::Saturating and std::num::Saturating stabilized in Rust 1.74\n+    // https://blog.rust-lang.org/2023/11/16/Rust-1.74.0.html#stabilized-apis\n+    if minor < 74 {\n+        println!(\"cargo:rustc-cfg=no_core_num_saturating\");\n+    }\n }\n \n fn rustc_minor_version() -> Option<u32> {\ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex d89f1872b..9ccb3ce69 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -387,6 +387,73 @@ impl_deserialize_num! {\n     num_as_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n }\n \n+#[cfg(not(no_core_num_saturating))]\n+macro_rules! visit_saturating {\n+    ($primitive:ident, $ty:ident : $visit:ident) => {\n+        #[inline]\n+        fn $visit<E>(self, v: $ty) -> Result<Saturating<$primitive>, E>\n+        where\n+            E: Error,\n+        {\n+            let out: $primitive = core::convert::TryFrom::<$ty>::try_from(v).unwrap_or_else(|_| {\n+                #[allow(unused_comparisons)]\n+                if v < 0 {\n+                    // never true for unsigned values\n+                    $primitive::MIN\n+                } else {\n+                    $primitive::MAX\n+                }\n+            });\n+            Ok(Saturating(out))\n+        }\n+    };\n+}\n+\n+macro_rules! impl_deserialize_saturating_num {\n+    ($primitive:ident, $deserialize:ident ) => {\n+        #[cfg(not(no_core_num_saturating))]\n+        impl<'de> Deserialize<'de> for Saturating<$primitive> {\n+            #[inline]\n+            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+            where\n+                D: Deserializer<'de>,\n+            {\n+                struct SaturatingVisitor;\n+\n+                impl<'de> Visitor<'de> for SaturatingVisitor {\n+                    type Value = Saturating<$primitive>;\n+\n+                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                        formatter.write_str(\"An integer with support for saturating semantics\")\n+                    }\n+\n+                    visit_saturating!($primitive, u8:visit_u8);\n+                    visit_saturating!($primitive, u16:visit_u16);\n+                    visit_saturating!($primitive, u32:visit_u32);\n+                    visit_saturating!($primitive, u64:visit_u64);\n+                    visit_saturating!($primitive, i8:visit_i8);\n+                    visit_saturating!($primitive, i16:visit_i16);\n+                    visit_saturating!($primitive, i32:visit_i32);\n+                    visit_saturating!($primitive, i64:visit_i64);\n+                }\n+\n+                deserializer.$deserialize(SaturatingVisitor)\n+            }\n+        }\n+    };\n+}\n+\n+impl_deserialize_saturating_num!(u8, deserialize_u8);\n+impl_deserialize_saturating_num!(u16, deserialize_u16);\n+impl_deserialize_saturating_num!(u32, deserialize_u32);\n+impl_deserialize_saturating_num!(u64, deserialize_u64);\n+impl_deserialize_saturating_num!(usize, deserialize_u64);\n+impl_deserialize_saturating_num!(i8, deserialize_i8);\n+impl_deserialize_saturating_num!(i16, deserialize_i16);\n+impl_deserialize_saturating_num!(i32, deserialize_i32);\n+impl_deserialize_saturating_num!(i64, deserialize_i64);\n+impl_deserialize_saturating_num!(isize, deserialize_i64);\n+\n macro_rules! num_128 {\n     ($ty:ident : $visit:ident) => {\n         fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\ndiff --git a/serde/src/lib.rs b/serde/src/lib.rs\nindex 5cf44c1c1..dc6d392bd 100644\n--- a/serde/src/lib.rs\n+++ b/serde/src/lib.rs\n@@ -274,6 +274,9 @@ mod lib {\n     pub use std::sync::atomic::{AtomicI64, AtomicU64};\n     #[cfg(all(feature = \"std\", not(no_target_has_atomic), target_has_atomic = \"ptr\"))]\n     pub use std::sync::atomic::{AtomicIsize, AtomicUsize};\n+\n+    #[cfg(not(no_core_num_saturating))]\n+    pub use self::core::num::Saturating;\n }\n \n // None of this crate's error handling needs the `From::from` error conversion\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex 7aa11621c..ffc4c70f9 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -1026,6 +1026,20 @@ where\n     }\n }\n \n+#[cfg(not(no_core_num_saturating))]\n+impl<T> Serialize for Saturating<T>\n+where\n+    T: Serialize,\n+{\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        self.0.serialize(serializer)\n+    }\n+}\n+\n impl<T> Serialize for Reverse<T>\n where\n     T: Serialize,\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 3ca0fde36..8a7310cd2 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -23,7 +23,7 @@ use std::iter;\n use std::net;\n use std::num::{\n     NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize, NonZeroU128,\n-    NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize, Wrapping,\n+    NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize, Saturating, Wrapping,\n };\n use std::ops::Bound;\n use std::path::{Path, PathBuf};\n@@ -2065,6 +2065,43 @@ fn test_wrapping() {\n     test(Wrapping(1usize), &[Token::U64(1)]);\n }\n \n+#[test]\n+fn test_saturating() {\n+    test(Saturating(1usize), &[Token::U32(1)]);\n+    test(Saturating(1usize), &[Token::U64(1)]);\n+    test(Saturating(0u8), &[Token::I8(0)]);\n+    test(Saturating(0u16), &[Token::I16(0)]);\n+\n+    // saturate input values at the minimum or maximum value\n+    test(Saturating(u8::MAX), &[Token::U16(u16::MAX)]);\n+    test(Saturating(u8::MAX), &[Token::U16(u8::MAX as u16 + 1)]);\n+    test(Saturating(u16::MAX), &[Token::U32(u32::MAX)]);\n+    test(Saturating(u32::MAX), &[Token::U64(u64::MAX)]);\n+    test(Saturating(u8::MIN), &[Token::I8(i8::MIN)]);\n+    test(Saturating(u16::MIN), &[Token::I16(i16::MIN)]);\n+    test(Saturating(u32::MIN), &[Token::I32(i32::MIN)]);\n+    test(Saturating(i8::MIN), &[Token::I16(i16::MIN)]);\n+    test(Saturating(i16::MIN), &[Token::I32(i32::MIN)]);\n+    test(Saturating(i32::MIN), &[Token::I64(i64::MIN)]);\n+\n+    test(Saturating(u8::MIN), &[Token::I8(-1)]);\n+    test(Saturating(u16::MIN), &[Token::I16(-1)]);\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    {\n+        test(Saturating(usize::MIN), &[Token::U64(u64::MIN)]);\n+        test(Saturating(usize::MAX), &[Token::U64(u64::MAX)]);\n+        test(Saturating(isize::MIN), &[Token::I64(i64::MIN)]);\n+        test(Saturating(isize::MAX), &[Token::I64(i64::MAX)]);\n+        test(Saturating(0usize), &[Token::I64(i64::MIN)]);\n+\n+        test(\n+            Saturating(9_223_372_036_854_775_807usize),\n+            &[Token::I64(i64::MAX)],\n+        );\n+    }\n+}\n+\n #[test]\n fn test_rc_dst() {\n     test(Rc::<str>::from(\"s\"), &[Token::Str(\"s\")]);\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex 71ec3bc57..b60d03ab2 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -8,7 +8,7 @@ use std::cell::RefCell;\n use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n use std::ffi::CString;\n use std::net;\n-use std::num::Wrapping;\n+use std::num::{Saturating, Wrapping};\n use std::ops::Bound;\n use std::path::{Path, PathBuf};\n use std::rc::{Rc, Weak as RcWeak};\n@@ -624,6 +624,11 @@ fn test_wrapping() {\n     assert_ser_tokens(&Wrapping(1usize), &[Token::U64(1)]);\n }\n \n+#[test]\n+fn test_saturating() {\n+    assert_ser_tokens(&Saturating(1usize), &[Token::U64(1)]);\n+}\n+\n #[test]\n fn test_rc_dst() {\n     assert_ser_tokens(&Rc::<str>::from(\"s\"), &[Token::Str(\"s\")]);\n", "problem_statement": "Impl Serialize/Deserialize for std::num::Saturating<T>\nIt would be nice if we could get\r\n\r\n```\r\nuse std::num::Saturating;\r\n\r\nimpl Deserialize for Saturating<T: Deserialize> { ... }\r\nimpl Serialize for Saturating<T: Serialize> { ... }\r\n```\r\n\r\nso that it is possible to handle wrapped types, that already support those traits.\n", "hints_text": "Edit: I mixed up `Wrapping` and `Saturating`. However, I still want to link to the implementations for [Serialize](https://github.com/serde-rs/serde/blob/89139e2c11c9e975753ebe82745071acb47ecb03/serde/src/ser/impls.rs#L1016-L1027) and [Deserialize](https://github.com/serde-rs/serde/blob/89139e2c11c9e975753ebe82745071acb47ecb03/serde/src/de/impls.rs#L2995-L3005) for `Wrapping<T>`, because the future implementations for `Saturating<T>`  will probably be very similar.", "created_at": "2024-03-04T18:04:22Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2592, "instance_id": "serde-rs__serde-2592", "issue_numbers": ["2591"], "base_commit": "d593215ef703d1fe343b62b00e21880dfe501007", "patch": "diff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 1f67f0430..a2cab263c 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -409,9 +409,9 @@ fn serialize_enum(params: &Parameters, variants: &[Variant], cattrs: &attr::Cont\n         })\n         .collect();\n \n-    if cattrs.non_exhaustive() {\n+    if cattrs.remote().is_some() && cattrs.non_exhaustive() {\n         arms.push(quote! {\n-            unrecognized => _serde::__private::Err(_serde::ser::Error::custom(_serde::__private::ser::CannotSerializeVariant(unrecognized))),\n+            ref unrecognized => _serde::__private::Err(_serde::ser::Error::custom(_serde::__private::ser::CannotSerializeVariant(unrecognized))),\n         });\n     }\n \n", "test_patch": "diff --git a/test_suite/tests/test_remote.rs b/test_suite/tests/test_remote.rs\nindex 7069cf9b6..c1f152eb8 100644\n--- a/test_suite/tests/test_remote.rs\n+++ b/test_suite/tests/test_remote.rs\n@@ -127,7 +127,7 @@ struct Test {\n     enum_concrete: remote::EnumGeneric<u8>,\n \n     #[serde(with = \"ErrorKindDef\")]\n-    io_error_kind: std::io::ErrorKind,\n+    io_error_kind: ErrorKind,\n }\n \n #[derive(Serialize, Deserialize)]\n@@ -200,8 +200,16 @@ enum EnumConcrete {\n     Variant(u8),\n }\n \n+#[derive(Debug)]\n+enum ErrorKind {\n+    NotFound,\n+    PermissionDenied,\n+    #[allow(dead_code)]\n+    ConnectionRefused,\n+}\n+\n #[derive(Serialize, Deserialize)]\n-#[serde(remote = \"std::io::ErrorKind\")]\n+#[serde(remote = \"ErrorKind\")]\n #[non_exhaustive]\n enum ErrorKindDef {\n     NotFound,\n", "problem_statement": " 1.0.184 might be causing a compilation error.\nI got a compilation error which doesn't occur with `serde 1.0.183`. Is it a some breaking change?\r\n\r\n[example project](https://github.com/tacogips/serde_184_error)\r\n\r\nCargo.toml\r\n```\r\n[package]\r\nname = \"serde_184_error\"\r\nversion = \"0.1.0\"\r\nedition = \"2021\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\nsentry = \"0.31.5\"\r\n\r\n#The compile error not occured on serde = \"= 1.0.183\"\r\nserde = \"1.0.184\"\r\n\r\n```\r\n\r\nError message\r\n```\r\n    Updating crates.io index\r\n    Checking sentry-types v0.31.5\r\nerror[E0507]: cannot move out of `*self` which is behind a shared reference\r\n    --> /g/cargo/registry/src/index.crates.io-6f17d22bba15001f/sentry-types-0.31.5/src/protocol/v7.rs:1083:10\r\n     |\r\n1083 | #[derive(Serialize, Deserialize, Debug, Clone, Parti...\r\n     |          ^^^^^^^^^\r\n     |          |\r\n     |          data moved here\r\n     |          move occurs because `unrecognized` has type `v7::Context`, which does not implement the `Copy` trait\r\n     |\r\n     = note: this error originates in the derive macro `Serialize` (in Nightly builds, run with -Z macro-backtrace for moreinfo)\r\nhelp: consider borrowing here\r\n     |\r\n1083 | #[derive(&Serialize, Deserialize, Debug, Clone, PartialEq)]\r\n     |          +\r\n\r\nFor more information about this error, try `rustc --explain E0507`.\r\nerror: could not compile `sentry-types` (lib) due to previouserror\r\n```\r\n\n", "hints_text": "", "created_at": "2023-08-21T04:37:53Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2570, "instance_id": "serde-rs__serde-2570", "issue_numbers": ["2361"], "base_commit": "45271c36760c59a86a59d2a80eae58efd87ae577", "patch": "diff --git a/serde/src/private/ser.rs b/serde/src/private/ser.rs\nindex 7876542ee..50bcb251e 100644\n--- a/serde/src/private/ser.rs\n+++ b/serde/src/private/ser.rs\n@@ -1370,3 +1370,16 @@ impl Serialize for AdjacentlyTaggedEnumVariant {\n         serializer.serialize_unit_variant(self.enum_name, self.variant_index, self.variant_name)\n     }\n }\n+\n+// Error when Serialize for a non_exhaustive remote enum encounters a variant\n+// that is not recognized.\n+pub struct CannotSerializeVariant<T>(pub T);\n+\n+impl<T> Display for CannotSerializeVariant<T>\n+where\n+    T: Debug,\n+{\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        write!(formatter, \"enum variant cannot be serialized: {:?}\", self.0)\n+    }\n+}\ndiff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex d5512348b..0b25c7c0d 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -221,6 +221,7 @@ pub struct Container {\n     is_packed: bool,\n     /// Error message generated when type can't be deserialized\n     expecting: Option<String>,\n+    non_exhaustive: bool,\n }\n \n /// Styles of representing an enum.\n@@ -306,9 +307,12 @@ impl Container {\n         let mut variant_identifier = BoolAttr::none(cx, VARIANT_IDENTIFIER);\n         let mut serde_path = Attr::none(cx, CRATE);\n         let mut expecting = Attr::none(cx, EXPECTING);\n+        let mut non_exhaustive = false;\n \n         for attr in &item.attrs {\n             if attr.path() != SERDE {\n+                non_exhaustive |=\n+                    matches!(&attr.meta, syn::Meta::Path(path) if path == NON_EXHAUSTIVE);\n                 continue;\n             }\n \n@@ -587,6 +591,7 @@ impl Container {\n             serde_path: serde_path.get(),\n             is_packed,\n             expecting: expecting.get(),\n+            non_exhaustive,\n         }\n     }\n \n@@ -672,6 +677,10 @@ impl Container {\n     pub fn expecting(&self) -> Option<&str> {\n         self.expecting.as_ref().map(String::as_ref)\n     }\n+\n+    pub fn non_exhaustive(&self) -> bool {\n+        self.non_exhaustive\n+    }\n }\n \n fn decide_tag(\ndiff --git a/serde_derive/src/internals/symbol.rs b/serde_derive/src/internals/symbol.rs\nindex 68091fb85..572391a80 100644\n--- a/serde_derive/src/internals/symbol.rs\n+++ b/serde_derive/src/internals/symbol.rs\n@@ -19,6 +19,7 @@ pub const FLATTEN: Symbol = Symbol(\"flatten\");\n pub const FROM: Symbol = Symbol(\"from\");\n pub const GETTER: Symbol = Symbol(\"getter\");\n pub const INTO: Symbol = Symbol(\"into\");\n+pub const NON_EXHAUSTIVE: Symbol = Symbol(\"non_exhaustive\");\n pub const OTHER: Symbol = Symbol(\"other\");\n pub const REMOTE: Symbol = Symbol(\"remote\");\n pub const RENAME: Symbol = Symbol(\"rename\");\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex dc02466f5..1f67f0430 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -401,7 +401,7 @@ fn serialize_enum(params: &Parameters, variants: &[Variant], cattrs: &attr::Cont\n \n     let self_var = &params.self_var;\n \n-    let arms: Vec<_> = variants\n+    let mut arms: Vec<_> = variants\n         .iter()\n         .enumerate()\n         .map(|(variant_index, variant)| {\n@@ -409,6 +409,12 @@ fn serialize_enum(params: &Parameters, variants: &[Variant], cattrs: &attr::Cont\n         })\n         .collect();\n \n+    if cattrs.non_exhaustive() {\n+        arms.push(quote! {\n+            unrecognized => _serde::__private::Err(_serde::ser::Error::custom(_serde::__private::ser::CannotSerializeVariant(unrecognized))),\n+        });\n+    }\n+\n     quote_expr! {\n         match *#self_var {\n             #(#arms)*\n", "test_patch": "diff --git a/test_suite/tests/test_remote.rs b/test_suite/tests/test_remote.rs\nindex 2a37909fd..7069cf9b6 100644\n--- a/test_suite/tests/test_remote.rs\n+++ b/test_suite/tests/test_remote.rs\n@@ -125,6 +125,9 @@ struct Test {\n \n     #[serde(with = \"EnumConcrete\")]\n     enum_concrete: remote::EnumGeneric<u8>,\n+\n+    #[serde(with = \"ErrorKindDef\")]\n+    io_error_kind: std::io::ErrorKind,\n }\n \n #[derive(Serialize, Deserialize)]\n@@ -197,6 +200,15 @@ enum EnumConcrete {\n     Variant(u8),\n }\n \n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"std::io::ErrorKind\")]\n+#[non_exhaustive]\n+enum ErrorKindDef {\n+    NotFound,\n+    PermissionDenied,\n+    // ...\n+}\n+\n impl From<PrimitivePrivDef> for remote::PrimitivePriv {\n     fn from(def: PrimitivePrivDef) -> Self {\n         remote::PrimitivePriv::new(def.0)\n", "problem_statement": "Add exhaustive match arm in `#[derive(Serialize)]` expansion\nCloses #2360\n", "hints_text": "", "created_at": "2023-08-14T04:18:08Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2567, "instance_id": "serde-rs__serde-2567", "issue_numbers": ["1904", "2792"], "base_commit": "9b868ef831c95f50dd4bde51a7eb52e3b9ee265a", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex c5861d9bc..ef85385f6 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -281,11 +281,21 @@ fn deserialize_body(cont: &Container, params: &Parameters) -> Fragment {\n     } else if let attr::Identifier::No = cont.attrs.identifier() {\n         match &cont.data {\n             Data::Enum(variants) => deserialize_enum(params, variants, &cont.attrs),\n-            Data::Struct(Style::Struct, fields) => {\n-                deserialize_struct(params, fields, &cont.attrs, StructForm::Struct)\n-            }\n+            Data::Struct(Style::Struct, fields) => deserialize_struct(\n+                params,\n+                fields,\n+                &cont.attrs,\n+                cont.attrs.has_flatten(),\n+                StructForm::Struct,\n+            ),\n             Data::Struct(Style::Tuple, fields) | Data::Struct(Style::Newtype, fields) => {\n-                deserialize_tuple(params, fields, &cont.attrs, TupleForm::Tuple)\n+                deserialize_tuple(\n+                    params,\n+                    fields,\n+                    &cont.attrs,\n+                    cont.attrs.has_flatten(),\n+                    TupleForm::Tuple,\n+                )\n             }\n             Data::Struct(Style::Unit, _) => deserialize_unit_struct(params, &cont.attrs),\n         }\n@@ -459,9 +469,13 @@ fn deserialize_tuple(\n     params: &Parameters,\n     fields: &[Field],\n     cattrs: &attr::Container,\n+    has_flatten: bool,\n     form: TupleForm,\n ) -> Fragment {\n-    assert!(!cattrs.has_flatten());\n+    assert!(\n+        !has_flatten,\n+        \"tuples and tuple variants cannot have flatten fields\"\n+    );\n \n     let field_count = fields\n         .iter()\n@@ -579,7 +593,10 @@ fn deserialize_tuple_in_place(\n     fields: &[Field],\n     cattrs: &attr::Container,\n ) -> Fragment {\n-    assert!(!cattrs.has_flatten());\n+    assert!(\n+        !cattrs.has_flatten(),\n+        \"tuples and tuple variants cannot have flatten fields\"\n+    );\n \n     let field_count = fields\n         .iter()\n@@ -910,6 +927,7 @@ fn deserialize_struct(\n     params: &Parameters,\n     fields: &[Field],\n     cattrs: &attr::Container,\n+    has_flatten: bool,\n     form: StructForm,\n ) -> Fragment {\n     let this_type = &params.this_type;\n@@ -958,13 +976,13 @@ fn deserialize_struct(\n             )\n         })\n         .collect();\n-    let field_visitor = deserialize_field_identifier(&field_names_idents, cattrs);\n+    let field_visitor = deserialize_field_identifier(&field_names_idents, cattrs, has_flatten);\n \n     // untagged struct variants do not get a visit_seq method. The same applies to\n     // structs that only have a map representation.\n     let visit_seq = match form {\n         StructForm::Untagged(..) => None,\n-        _ if cattrs.has_flatten() => None,\n+        _ if has_flatten => None,\n         _ => {\n             let mut_seq = if field_names_idents.is_empty() {\n                 quote!(_)\n@@ -987,10 +1005,16 @@ fn deserialize_struct(\n             })\n         }\n     };\n-    let visit_map = Stmts(deserialize_map(&type_path, params, fields, cattrs));\n+    let visit_map = Stmts(deserialize_map(\n+        &type_path,\n+        params,\n+        fields,\n+        cattrs,\n+        has_flatten,\n+    ));\n \n     let visitor_seed = match form {\n-        StructForm::ExternallyTagged(..) if cattrs.has_flatten() => Some(quote! {\n+        StructForm::ExternallyTagged(..) if has_flatten => Some(quote! {\n             impl #de_impl_generics _serde::de::DeserializeSeed<#delife> for __Visitor #de_ty_generics #where_clause {\n                 type Value = #this_type #ty_generics;\n \n@@ -1005,7 +1029,7 @@ fn deserialize_struct(\n         _ => None,\n     };\n \n-    let fields_stmt = if cattrs.has_flatten() {\n+    let fields_stmt = if has_flatten {\n         None\n     } else {\n         let field_names = field_names_idents\n@@ -1025,7 +1049,7 @@ fn deserialize_struct(\n         }\n     };\n     let dispatch = match form {\n-        StructForm::Struct if cattrs.has_flatten() => quote! {\n+        StructForm::Struct if has_flatten => quote! {\n             _serde::Deserializer::deserialize_map(__deserializer, #visitor_expr)\n         },\n         StructForm::Struct => {\n@@ -1034,7 +1058,7 @@ fn deserialize_struct(\n                 _serde::Deserializer::deserialize_struct(__deserializer, #type_name, FIELDS, #visitor_expr)\n             }\n         }\n-        StructForm::ExternallyTagged(_) if cattrs.has_flatten() => quote! {\n+        StructForm::ExternallyTagged(_) if has_flatten => quote! {\n             _serde::de::VariantAccess::newtype_variant_seed(__variant, #visitor_expr)\n         },\n         StructForm::ExternallyTagged(_) => quote! {\n@@ -1116,7 +1140,7 @@ fn deserialize_struct_in_place(\n         })\n         .collect();\n \n-    let field_visitor = deserialize_field_identifier(&field_names_idents, cattrs);\n+    let field_visitor = deserialize_field_identifier(&field_names_idents, cattrs, false);\n \n     let mut_seq = if field_names_idents.is_empty() {\n         quote!(_)\n@@ -1210,10 +1234,7 @@ fn deserialize_homogeneous_enum(\n     }\n }\n \n-fn prepare_enum_variant_enum(\n-    variants: &[Variant],\n-    cattrs: &attr::Container,\n-) -> (TokenStream, Stmts) {\n+fn prepare_enum_variant_enum(variants: &[Variant]) -> (TokenStream, Stmts) {\n     let mut deserialized_variants = variants\n         .iter()\n         .enumerate()\n@@ -1247,7 +1268,7 @@ fn prepare_enum_variant_enum(\n \n     let variant_visitor = Stmts(deserialize_generated_identifier(\n         &variant_names_idents,\n-        cattrs,\n+        false, // variant identifiers does not depend on the presence of flatten fields\n         true,\n         None,\n         fallthrough,\n@@ -1270,7 +1291,7 @@ fn deserialize_externally_tagged_enum(\n     let expecting = format!(\"enum {}\", params.type_name());\n     let expecting = cattrs.expecting().unwrap_or(&expecting);\n \n-    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n+    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants);\n \n     // Match arms to extract a variant from a string\n     let variant_arms = variants\n@@ -1355,7 +1376,7 @@ fn deserialize_internally_tagged_enum(\n     cattrs: &attr::Container,\n     tag: &str,\n ) -> Fragment {\n-    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n+    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants);\n \n     // Match arms to extract a variant from a string\n     let variant_arms = variants\n@@ -1409,7 +1430,7 @@ fn deserialize_adjacently_tagged_enum(\n         split_with_de_lifetime(params);\n     let delife = params.borrowed.de_lifetime();\n \n-    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n+    let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants);\n \n     let variant_arms: &Vec<_> = &variants\n         .iter()\n@@ -1810,12 +1831,14 @@ fn deserialize_externally_tagged_variant(\n             params,\n             &variant.fields,\n             cattrs,\n+            variant.attrs.has_flatten(),\n             TupleForm::ExternallyTagged(variant_ident),\n         ),\n         Style::Struct => deserialize_struct(\n             params,\n             &variant.fields,\n             cattrs,\n+            variant.attrs.has_flatten(),\n             StructForm::ExternallyTagged(variant_ident),\n         ),\n     }\n@@ -1859,6 +1882,7 @@ fn deserialize_internally_tagged_variant(\n             params,\n             &variant.fields,\n             cattrs,\n+            variant.attrs.has_flatten(),\n             StructForm::InternallyTagged(variant_ident, deserializer),\n         ),\n         Style::Tuple => unreachable!(\"checked in serde_derive_internals\"),\n@@ -1909,12 +1933,14 @@ fn deserialize_untagged_variant(\n             params,\n             &variant.fields,\n             cattrs,\n+            variant.attrs.has_flatten(),\n             TupleForm::Untagged(variant_ident, deserializer),\n         ),\n         Style::Struct => deserialize_struct(\n             params,\n             &variant.fields,\n             cattrs,\n+            variant.attrs.has_flatten(),\n             StructForm::Untagged(variant_ident, deserializer),\n         ),\n     }\n@@ -1985,7 +2011,7 @@ fn deserialize_untagged_newtype_variant(\n \n fn deserialize_generated_identifier(\n     fields: &[(&str, Ident, &BTreeSet<String>)],\n-    cattrs: &attr::Container,\n+    has_flatten: bool,\n     is_variant: bool,\n     ignore_variant: Option<TokenStream>,\n     fallthrough: Option<TokenStream>,\n@@ -1999,11 +2025,11 @@ fn deserialize_generated_identifier(\n         is_variant,\n         fallthrough,\n         None,\n-        !is_variant && cattrs.has_flatten(),\n+        !is_variant && has_flatten,\n         None,\n     ));\n \n-    let lifetime = if !is_variant && cattrs.has_flatten() {\n+    let lifetime = if !is_variant && has_flatten {\n         Some(quote!(<'de>))\n     } else {\n         None\n@@ -2043,8 +2069,9 @@ fn deserialize_generated_identifier(\n fn deserialize_field_identifier(\n     fields: &[(&str, Ident, &BTreeSet<String>)],\n     cattrs: &attr::Container,\n+    has_flatten: bool,\n ) -> Stmts {\n-    let (ignore_variant, fallthrough) = if cattrs.has_flatten() {\n+    let (ignore_variant, fallthrough) = if has_flatten {\n         let ignore_variant = quote!(__other(_serde::__private::de::Content<'de>),);\n         let fallthrough = quote!(_serde::__private::Ok(__Field::__other(__value)));\n         (Some(ignore_variant), Some(fallthrough))\n@@ -2058,7 +2085,7 @@ fn deserialize_field_identifier(\n \n     Stmts(deserialize_generated_identifier(\n         fields,\n-        cattrs,\n+        has_flatten,\n         false,\n         ignore_variant,\n         fallthrough,\n@@ -2460,6 +2487,7 @@ fn deserialize_map(\n     params: &Parameters,\n     fields: &[Field],\n     cattrs: &attr::Container,\n+    has_flatten: bool,\n ) -> Fragment {\n     // Create the field names for the fields.\n     let fields_names: Vec<_> = fields\n@@ -2480,9 +2508,6 @@ fn deserialize_map(\n         });\n \n     // Collect contents for flatten fields into a buffer\n-    let has_flatten = fields\n-        .iter()\n-        .any(|field| field.attrs.flatten() && !field.attrs.skip_deserializing());\n     let let_collect = if has_flatten {\n         Some(quote! {\n             let mut __collect = _serde::__private::Vec::<_serde::__private::Option<(\n@@ -2681,7 +2706,10 @@ fn deserialize_map_in_place(\n     fields: &[Field],\n     cattrs: &attr::Container,\n ) -> Fragment {\n-    assert!(!cattrs.has_flatten());\n+    assert!(\n+        !cattrs.has_flatten(),\n+        \"inplace deserialization of maps doesn't support flatten fields\"\n+    );\n \n     // Create the field names for the fields.\n     let fields_names: Vec<_> = fields\ndiff --git a/serde_derive/src/internals/ast.rs b/serde_derive/src/internals/ast.rs\nindex a28d3ae7e..4ec709952 100644\n--- a/serde_derive/src/internals/ast.rs\n+++ b/serde_derive/src/internals/ast.rs\n@@ -85,6 +85,7 @@ impl<'a> Container<'a> {\n                     for field in &mut variant.fields {\n                         if field.attrs.flatten() {\n                             has_flatten = true;\n+                            variant.attrs.mark_has_flatten();\n                         }\n                         field.attrs.rename_by_rules(\n                             variant\ndiff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex 0cfb23bf1..5064d079a 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -216,6 +216,22 @@ pub struct Container {\n     type_into: Option<syn::Type>,\n     remote: Option<syn::Path>,\n     identifier: Identifier,\n+    /// `true` if container is a `struct` and it has a field with `#[serde(flatten)]`\n+    /// attribute or it is an `enum` with a struct variant which has a field with\n+    /// `#[serde(flatten)]` attribute. Examples:\n+    ///\n+    /// ```ignore\n+    /// struct Container {\n+    ///     #[serde(flatten)]\n+    ///     some_field: (),\n+    /// }\n+    /// enum Container {\n+    ///     Variant {\n+    ///         #[serde(flatten)]\n+    ///         some_field: (),\n+    ///     },\n+    /// }\n+    /// ```\n     has_flatten: bool,\n     serde_path: Option<syn::Path>,\n     is_packed: bool,\n@@ -794,6 +810,18 @@ pub struct Variant {\n     rename_all_rules: RenameAllRules,\n     ser_bound: Option<Vec<syn::WherePredicate>>,\n     de_bound: Option<Vec<syn::WherePredicate>>,\n+    /// `true` if variant is a struct variant which contains a field with `#[serde(flatten)]`\n+    /// attribute. Examples:\n+    ///\n+    /// ```ignore\n+    /// enum Enum {\n+    ///     Variant {\n+    ///         #[serde(flatten)]\n+    ///         some_field: (),\n+    ///     },\n+    /// }\n+    /// ```\n+    has_flatten: bool,\n     skip_deserializing: bool,\n     skip_serializing: bool,\n     other: bool,\n@@ -963,6 +991,7 @@ impl Variant {\n             },\n             ser_bound: ser_bound.get(),\n             de_bound: de_bound.get(),\n+            has_flatten: false,\n             skip_deserializing: skip_deserializing.get(),\n             skip_serializing: skip_serializing.get(),\n             other: other.get(),\n@@ -1005,6 +1034,14 @@ impl Variant {\n         self.de_bound.as_ref().map(|vec| &vec[..])\n     }\n \n+    pub fn has_flatten(&self) -> bool {\n+        self.has_flatten\n+    }\n+\n+    pub fn mark_has_flatten(&mut self) {\n+        self.has_flatten = true;\n+    }\n+\n     pub fn skip_deserializing(&self) -> bool {\n         self.skip_deserializing\n     }\n", "test_patch": "diff --git a/test_suite/tests/regression/issue1904.rs b/test_suite/tests/regression/issue1904.rs\nnew file mode 100644\nindex 000000000..99736c078\n--- /dev/null\n+++ b/test_suite/tests/regression/issue1904.rs\n@@ -0,0 +1,65 @@\n+#![allow(dead_code)] // we do not read enum fields\n+use serde_derive::Deserialize;\n+\n+#[derive(Deserialize)]\n+pub struct Nested;\n+\n+#[derive(Deserialize)]\n+pub enum ExternallyTagged1 {\n+    Tuple(f64, String),\n+    Flatten {\n+        #[serde(flatten)]\n+        nested: Nested,\n+    },\n+}\n+\n+#[derive(Deserialize)]\n+pub enum ExternallyTagged2 {\n+    Flatten {\n+        #[serde(flatten)]\n+        nested: Nested,\n+    },\n+    Tuple(f64, String),\n+}\n+\n+// Internally tagged enums cannot contain tuple variants so not tested here\n+\n+#[derive(Deserialize)]\n+#[serde(tag = \"tag\", content = \"content\")]\n+pub enum AdjacentlyTagged1 {\n+    Tuple(f64, String),\n+    Flatten {\n+        #[serde(flatten)]\n+        nested: Nested,\n+    },\n+}\n+\n+#[derive(Deserialize)]\n+#[serde(tag = \"tag\", content = \"content\")]\n+pub enum AdjacentlyTagged2 {\n+    Flatten {\n+        #[serde(flatten)]\n+        nested: Nested,\n+    },\n+    Tuple(f64, String),\n+}\n+\n+#[derive(Deserialize)]\n+#[serde(untagged)]\n+pub enum Untagged1 {\n+    Tuple(f64, String),\n+    Flatten {\n+        #[serde(flatten)]\n+        nested: Nested,\n+    },\n+}\n+\n+#[derive(Deserialize)]\n+#[serde(untagged)]\n+pub enum Untagged2 {\n+    Flatten {\n+        #[serde(flatten)]\n+        nested: Nested,\n+    },\n+    Tuple(f64, String),\n+}\ndiff --git a/test_suite/tests/regression/issue2565.rs b/test_suite/tests/regression/issue2565.rs\nnew file mode 100644\nindex 000000000..65cbb0a31\n--- /dev/null\n+++ b/test_suite/tests/regression/issue2565.rs\n@@ -0,0 +1,41 @@\n+use serde_derive::{Serialize, Deserialize};\n+use serde_test::{assert_tokens, Token};\n+\n+#[derive(Serialize, Deserialize, Debug, PartialEq)]\n+enum Enum {\n+    Simple {\n+        a: i32,\n+    },\n+    Flatten {\n+        #[serde(flatten)]\n+        flatten: (),\n+        a: i32,\n+    },\n+}\n+\n+#[test]\n+fn simple_variant() {\n+    assert_tokens(\n+        &Enum::Simple { a: 42 },\n+        &[\n+            Token::StructVariant { name: \"Enum\", variant: \"Simple\", len: 1 },\n+            Token::Str(\"a\"),\n+            Token::I32(42),\n+            Token::StructVariantEnd,\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn flatten_variant() {\n+    assert_tokens(\n+        &Enum::Flatten { flatten: (), a: 42 },\n+        &[\n+            Token::NewtypeVariant { name: \"Enum\", variant: \"Flatten\" },\n+            Token::Map { len: None },\n+            Token::Str(\"a\"),\n+            Token::I32(42),\n+            Token::MapEnd,\n+        ]\n+    );\n+}\ndiff --git a/test_suite/tests/regression/issue2792.rs b/test_suite/tests/regression/issue2792.rs\nnew file mode 100644\nindex 000000000..13c0b7103\n--- /dev/null\n+++ b/test_suite/tests/regression/issue2792.rs\n@@ -0,0 +1,16 @@\n+#![allow(dead_code)] // we do not read enum fields\n+use serde_derive::Deserialize;\n+\n+#[derive(Deserialize)]\n+#[serde(deny_unknown_fields)]\n+pub enum A {\n+    B {\n+        c: String,\n+    },\n+    D {\n+        #[serde(flatten)]\n+        e: E,\n+    },\n+}\n+#[derive(Deserialize)]\n+pub struct E {}\ndiff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex 566f7d43f..1488c8364 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -2380,6 +2380,56 @@ fn test_partially_untagged_enum_desugared() {\n     );\n }\n \n+/// Regression test for https://github.com/serde-rs/serde/issues/1904\n+#[test]\n+fn test_enum_tuple_and_struct_with_flatten() {\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    enum Outer {\n+        Tuple(f64, i32),\n+        Flatten {\n+            #[serde(flatten)]\n+            nested: Nested,\n+        },\n+    }\n+\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    struct Nested {\n+        a: i32,\n+        b: i32,\n+    }\n+\n+    assert_tokens(\n+        &Outer::Tuple(1.2, 3),\n+        &[\n+            Token::TupleVariant {\n+                name: \"Outer\",\n+                variant: \"Tuple\",\n+                len: 2,\n+            },\n+            Token::F64(1.2),\n+            Token::I32(3),\n+            Token::TupleVariantEnd,\n+        ],\n+    );\n+    assert_tokens(\n+        &Outer::Flatten {\n+            nested: Nested { a: 1, b: 2 },\n+        },\n+        &[\n+            Token::NewtypeVariant {\n+                name: \"Outer\",\n+                variant: \"Flatten\",\n+            },\n+            Token::Map { len: None },\n+            Token::Str(\"a\"),\n+            Token::I32(1),\n+            Token::Str(\"b\"),\n+            Token::I32(2),\n+            Token::MapEnd,\n+        ],\n+    );\n+}\n+\n #[test]\n fn test_partially_untagged_internally_tagged_enum() {\n     #[derive(Serialize, Deserialize, PartialEq, Debug)]\n", "problem_statement": "Deserialize failed to derive on enums with tuple variant and flatten struct variant\n[Instead of thousand of words](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=f1ea8c90736214e52d74c4ca0cab973b)\r\n\r\nThis code is failed to compile due to panic in serde derive:\r\n```rust\r\n#[derive(Deserialize)]\r\nenum Failed {\r\n    Tuple(f64, String),\r\n    Flatten {\r\n        #[serde(flatten)]\r\n        nested: Nested,\r\n    },\r\n}\r\n```\r\nOutput:\r\n```bash\r\n   Compiling playground v0.0.1 (/playground)\r\nerror: proc-macro derive panicked\r\n  --> src/lib.rs:30:10\r\n   |\r\n30 | #[derive(Deserialize)]\r\n   |          ^^^^^^^^^^^\r\n   |\r\n   = help: message: assertion failed: !cattrs.has_flatten()\r\n\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n\r\nEach variant individually and `Serialize` derive works well, problem is only in combination of tuple variant and struct variant, when struct variant contains flattened field.\n`deny_unknown_fields` can break in 1.0.205\nThe following (reduction of a less artificial example)\r\n```rust\r\n#[derive(serde::Deserialize)]\r\n#[serde(deny_unknown_fields)]\r\nenum A {\r\n    B {\r\n        c: String,\r\n    },\r\n    D {\r\n        #[serde(flatten)]\r\n        e: E,\r\n    },\r\n}\r\n#[derive(serde::Deserialize)]\r\nstruct E {}\r\n\r\n```\r\ncompiles fine with 1.0.204 but produces the following error in 1.0.205:\r\n```\r\nerror[E0004]: non-exhaustive patterns: `<_::<impl Deserialize<'de> for A>::deserialize::__Visitor<'de> as Visitor<'de>>::visit_enum::__Field::__other(_)` not covered\r\n --> src/main.rs:1:10\r\n  |\r\n1 | #[derive(serde::Deserialize)]\r\n  |          ^^^^^^^^^^^^^^^^^^ pattern `<_::<impl Deserialize<'de> for A>::deserialize::__Visitor<'de> as Visitor<'de>>::visit_enum::__Field::__other(_)` not covered\r\n  |\r\nnote: `<_::<impl Deserialize<'de> for A>::deserialize::__Visitor<'de> as Visitor<'de>>::visit_enum::__Field<'_>` defined here\r\n --> src/main.rs:1:10\r\n  |\r\n1 | #[derive(serde::Deserialize)]\r\n  |          ^^^^^^^^^^^^^^^^^^\r\n  |          |\r\n  |          not covered\r\n  = note: the matched value is of type `<_::<impl Deserialize<'de> for A>::deserialize::__Visitor<'de> as Visitor<'de>>::visit_enum::__Field<'_>`\r\n  = note: this error originates in the derive macro `serde::Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\r\n```\r\n\r\nI have bisected the changes, and the issue appears in 32958dec3bf3886961166ec651194d6f0243a497\n", "hints_text": "\n", "created_at": "2023-08-10T22:04:01Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2499, "instance_id": "serde-rs__serde-2499", "issue_numbers": ["2242"], "base_commit": "3fb5e71c33279500f7e29e2512efafa64fe07e96", "patch": "diff --git a/serde_derive/Cargo.toml b/serde_derive/Cargo.toml\nindex 1897cb1a6..46246bb60 100644\n--- a/serde_derive/Cargo.toml\n+++ b/serde_derive/Cargo.toml\n@@ -24,7 +24,7 @@ proc-macro = true\n [dependencies]\n proc-macro2 = \"1.0\"\n quote = \"1.0\"\n-syn = \"2.0.24\"\n+syn = \"2.0.25\"\n \n [dev-dependencies]\n serde = { version = \"1.0\", path = \"../serde\" }\ndiff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex bff82191b..42212a64d 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -1418,6 +1418,13 @@ fn get_lit_str2(\n         ..\n     }) = value\n     {\n+        let suffix = lit.suffix();\n+        if !suffix.is_empty() {\n+            cx.error_spanned_by(\n+                lit,\n+                format!(\"unexpected suffix `{}` on string literal\", suffix),\n+            );\n+        }\n         Ok(Some(lit.clone()))\n     } else {\n         cx.error_spanned_by(\ndiff --git a/serde_derive_internals/Cargo.toml b/serde_derive_internals/Cargo.toml\nindex 703a43cbb..eb084af67 100644\n--- a/serde_derive_internals/Cargo.toml\n+++ b/serde_derive_internals/Cargo.toml\n@@ -17,7 +17,7 @@ path = \"lib.rs\"\n [dependencies]\n proc-macro2 = \"1.0\"\n quote = \"1.0\"\n-syn = { version = \"2.0.24\", default-features = false, features = [\"clone-impls\", \"derive\", \"parsing\", \"printing\"] }\n+syn = { version = \"2.0.25\", default-features = false, features = [\"clone-impls\", \"derive\", \"parsing\", \"printing\"] }\n \n [package.metadata.docs.rs]\n targets = [\"x86_64-unknown-linux-gnu\"]\n", "test_patch": "diff --git a/test_suite/tests/ui/malformed/str_suffix.rs b/test_suite/tests/ui/malformed/str_suffix.rs\nnew file mode 100644\nindex 000000000..836842ee6\n--- /dev/null\n+++ b/test_suite/tests/ui/malformed/str_suffix.rs\n@@ -0,0 +1,10 @@\n+use serde::Serialize;\n+\n+#[derive(Serialize)]\n+#[serde(bound = \"\"huh)]\n+pub struct Struct {\n+    #[serde(rename = \"\"what)]\n+    pub field: i32,\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/ui/malformed/str_suffix.stderr b/test_suite/tests/ui/malformed/str_suffix.stderr\nnew file mode 100644\nindex 000000000..3d4beae65\n--- /dev/null\n+++ b/test_suite/tests/ui/malformed/str_suffix.stderr\n@@ -0,0 +1,11 @@\n+error: unexpected suffix `huh` on string literal\n+ --> tests/ui/malformed/str_suffix.rs:4:17\n+  |\n+4 | #[serde(bound = \"\"huh)]\n+  |                 ^^^^^\n+\n+error: unexpected suffix `what` on string literal\n+ --> tests/ui/malformed/str_suffix.rs:6:22\n+  |\n+6 |     #[serde(rename = \"\"what)]\n+  |                      ^^^^^^\n", "problem_statement": "Proc macro rename attribute ignores trailing content\nI just had an interesting bug where I made a spelling error for the `rename` attribute. When I discovered it, I thought the proc macro could probably catch this.\r\n\r\nWhat I did by accident was:\r\n```rust\r\n#[derive(Deserialize)]\r\nstruct SomeStruct {\r\n    #[serde(rename = \"\"value)] // This should have been `rename = \"value\"`\r\n    pub a: i32\r\n} \r\n```\r\n\r\nThe second `\"` went in front of the rename value, instead of behind. Apparently, the proc macro accepts this input and only takes `\"\"`, ignoring the `value`. If there is a space between it (like `#[serde(rename = \"\" value)]`), it'll fail properly, telling about the unknown attribute `value`.\n", "hints_text": "", "created_at": "2023-07-09T18:13:51Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2422, "instance_id": "serde-rs__serde-2422", "issue_numbers": ["2415", "2421"], "base_commit": "acfd19cb463ea77d2146d637c35d8751601dae75", "patch": "diff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex 9875b6606..b0a7d08a2 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -307,6 +307,12 @@ impl Container {\n                 continue;\n             }\n \n+            if let syn::Meta::List(meta) = &attr.meta {\n+                if meta.tokens.is_empty() {\n+                    continue;\n+                }\n+            }\n+\n             if let Err(err) = attr.parse_nested_meta(|meta| {\n                 if meta.path == RENAME {\n                     // #[serde(rename = \"foo\")]\n@@ -762,6 +768,12 @@ impl Variant {\n                 continue;\n             }\n \n+            if let syn::Meta::List(meta) = &attr.meta {\n+                if meta.tokens.is_empty() {\n+                    continue;\n+                }\n+            }\n+\n             if let Err(err) = attr.parse_nested_meta(|meta| {\n                 if meta.path == RENAME {\n                     // #[serde(rename = \"foo\")]\n@@ -1033,6 +1045,12 @@ impl Field {\n                 continue;\n             }\n \n+            if let syn::Meta::List(meta) = &attr.meta {\n+                if meta.tokens.is_empty() {\n+                    continue;\n+                }\n+            }\n+\n             if let Err(err) = attr.parse_nested_meta(|meta| {\n                 if meta.path == RENAME {\n                     // #[serde(rename = \"foo\")]\n", "test_patch": "diff --git a/test_suite/tests/regression/issue2415.rs b/test_suite/tests/regression/issue2415.rs\nnew file mode 100644\nindex 000000000..31c522709\n--- /dev/null\n+++ b/test_suite/tests/regression/issue2415.rs\n@@ -0,0 +1,5 @@\n+use serde_derive::Serialize;\n+\n+#[derive(Serialize)]\n+#[serde()]\n+pub struct S;\n", "problem_statement": "Possible semver breaking change in serde 1.0.157\nWhen pinning the version of `serde` in Cargo.toml to `1.0.156`, my crate compiles, switching to `1.0.157` results in an error in my `influxdb2` dependency:\r\n```bash\r\nerror: unexpected end of input, unexpected token in nested attribute, expected ident\r\n  --> /home/midas/.cargo/registry/src/github.com-1ecc6299db9ec823/influxdb2-0.3.5/src/models/ast/dialect.rs:16:13\r\n   |\r\n16 |     #[serde()]\r\n   |             ^\r\n\r\n   Compiling opentelemetry-otlp v0.11.0\r\nerror[E0277]: the trait bound `Dialect: buckets::_::_serde::Serialize` is not satisfied\r\n    --> /home/midas/.cargo/registry/src/github.com-1ecc6299db9ec823/influxdb2-0.3.5/src/models/query.rs:10:35\r\n     |\r\n10   | #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\r\n     |                                   ^^^^^^^^^ the trait `buckets::_::_serde::Serialize` is not implemented for `Dialect`\r\n...\r\n20   |     /// Dialect\r\n     |     ----------- required by a bound introduced by this call\r\n     |\r\n     = help: the following other types implement trait `buckets::_::_serde::Serialize`:\r\n               &'a T\r\n               &'a mut T\r\n               ()\r\n               (T0, T1)\r\n               (T0, T1, T2)\r\n               (T0, T1, T2, T3)\r\n               (T0, T1, T2, T3, T4)\r\n               (T0, T1, T2, T3, T4, T5)\r\n             and 208 others\r\n     = note: required for `std::option::Option<Dialect>` to implement `buckets::_::_serde::Serialize`\r\nnote: required by a bound in `buckets::_::_serde::ser::SerializeStruct::serialize_field`\r\n    --> /home/midas/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.157/src/ser/mod.rs:1901:12\r\n     |\r\n1901 |         T: Serialize;\r\n     |            ^^^^^^^^^ required by this bound in `buckets::_::_serde::ser::SerializeStruct::serialize_field`\r\n\r\nerror[E0277]: the trait bound `Dialect: buckets::_::_serde::Deserialize<'_>` is not satisfied\r\n    --> /home/midas/.cargo/registry/src/github.com-1ecc6299db9ec823/influxdb2-0.3.5/src/models/query.rs:22:18\r\n     |\r\n22   |     pub dialect: Option<crate::models::ast::Dialect>,\r\n     |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `buckets::_::_serde::Deserialize<'_>` is not implemented for `Dialect`\r\n     |\r\n     = help: the following other types implement trait `buckets::_::_serde::Deserialize<'de>`:\r\n               &'a Path\r\n               &'a [u8]\r\n               &'a serde_json::value::RawValue\r\n               &'a str\r\n               ()\r\n               (T0, T1)\r\n               (T0, T1, T2)\r\n               (T0, T1, T2, T3)\r\n             and 219 others\r\n     = note: required for `std::option::Option<Dialect>` to implement `buckets::_::_serde::Deserialize<'_>`\r\nnote: required by a bound in `next_element`\r\n    --> /home/midas/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.157/src/de/mod.rs:1729:12\r\n     |\r\n1729 |         T: Deserialize<'de>,\r\n     |            ^^^^^^^^^^^^^^^^ required by this bound in `next_element`\r\n\r\nerror[E0277]: the trait bound `Dialect: buckets::_::_serde::Deserialize<'_>` is not satisfied\r\n    --> /home/midas/.cargo/registry/src/github.com-1ecc6299db9ec823/influxdb2-0.3.5/src/models/query.rs:22:18\r\n     |\r\n22   |     pub dialect: Option<crate::models::ast::Dialect>,\r\n     |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `buckets::_::_serde::Deserialize<'_>` is not implemented for `Dialect`\r\n     |\r\n     = help: the following other types implement trait `buckets::_::_serde::Deserialize<'de>`:\r\n               &'a Path\r\n               &'a [u8]\r\n               &'a serde_json::value::RawValue\r\n               &'a str\r\n               ()\r\n               (T0, T1)\r\n               (T0, T1, T2)\r\n               (T0, T1, T2, T3)\r\n             and 219 others\r\n     = note: required for `std::option::Option<Dialect>` to implement `buckets::_::_serde::Deserialize<'_>`\r\nnote: required by a bound in `next_value`\r\n    --> /home/midas/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.157/src/de/mod.rs:1868:12\r\n     |\r\n1868 |         V: Deserialize<'de>,\r\n     |            ^^^^^^^^^^^^^^^^ required by this bound in `next_value`\r\n\r\nerror[E0277]: the trait bound `Dialect: buckets::_::_serde::Deserialize<'_>` is not satisfied\r\n  --> /home/midas/.cargo/registry/src/github.com-1ecc6299db9ec823/influxdb2-0.3.5/src/models/query.rs:20:5\r\n   |\r\n20 |     /// Dialect\r\n   |     ^^^^^^^^^^^ the trait `buckets::_::_serde::Deserialize<'_>` is not implemented for `Dialect`\r\n   |\r\n   = help: the following other types implement trait `buckets::_::_serde::Deserialize<'de>`:\r\n             &'a Path\r\n             &'a [u8]\r\n             &'a serde_json::value::RawValue\r\n             &'a str\r\n             ()\r\n             (T0, T1)\r\n             (T0, T1, T2)\r\n             (T0, T1, T2, T3)\r\n           and 219 others\r\n   = note: required for `std::option::Option<Dialect>` to implement `buckets::_::_serde::Deserialize<'_>`\r\nnote: required by a bound in `buckets::_::_serde::__private::de::missing_field`\r\n  --> /home/midas/.cargo/registry/src/github.com-1ecc6299db9ec823/serde-1.0.157/src/private/de.rs:22:8\r\n   |\r\n22 |     V: Deserialize<'de>,\r\n   |        ^^^^^^^^^^^^^^^^ required by this bound in `buckets::_::_serde::__private::de::missing_field`\r\n```\r\n\r\nLooking at the [changes](https://github.com/serde-rs/serde/compare/v1.0.156...v1.0.157), I don't really understand what's going on, so I'm not able to tell whether this is an unexpected issue coming from `serde` or if `influxdb2` was misusing `serde` before.\r\nBut from what I can tell it seems that putting an attribute inside a derive macro was allowed first, but not anymore, i.e.:\r\n```\r\n#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]\r\n#[serde(rename_all = \"camelCase\")]\r\npub struct Dialect {\r\n    #[serde()]\r\n    pub annotations: Vec<Annotations>,\r\n}\r\n```\ntest: test for empty serde args\n# Potential regression\r\n\r\nToday I came acrossed with this error:\r\n![image](https://user-images.githubusercontent.com/15936231/228110002-90a3cc11-9b85-4471-8232-5b1ef7972e72.png)\r\n\r\nAnd I found [it uses `#[serde()]`][l1] all over the place, and I also found [Possible semver breaking change in serde 1.0.157][l2], , is this the expected behavier? if so, I added a test for it, if not, I will change the test and fix it\r\n\r\n\r\n\r\nref: oxidecomputer/progenitor/issues/394\r\n\r\n\r\n[l1]: https://github.com/oxidecomputer/third-party-api-clients/blob/main/github/src/types.rs#L257\r\n[l2]: https://github.com/serde-rs/serde/issues/2415\n", "hints_text": "\n", "created_at": "2023-03-28T05:02:10Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2410, "instance_id": "serde-rs__serde-2410", "issue_numbers": ["2409"], "base_commit": "479a00a215cd291e9c0b0ad0373e26694018bf1c", "patch": "diff --git a/serde_derive/Cargo.toml b/serde_derive/Cargo.toml\nindex f2a3e37cf..b824bb993 100644\n--- a/serde_derive/Cargo.toml\n+++ b/serde_derive/Cargo.toml\n@@ -24,7 +24,7 @@ proc-macro = true\n [dependencies]\n proc-macro2 = \"1.0\"\n quote = \"1.0\"\n-syn = \"2.0\"\n+syn = \"2.0.3\"\n \n [dev-dependencies]\n serde = { version = \"1.0\", path = \"../serde\" }\ndiff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex d541e3a9f..9875b6606 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -1381,21 +1381,26 @@ fn get_lit_str2(\n     meta_item_name: Symbol,\n     meta: &ParseNestedMeta,\n ) -> syn::Result<Option<syn::LitStr>> {\n-    match meta.value()?.parse()? {\n-        syn::Expr::Lit(syn::ExprLit {\n-            lit: syn::Lit::Str(lit),\n-            ..\n-        }) => Ok(Some(lit)),\n-        expr => {\n-            cx.error_spanned_by(\n-                expr,\n-                format!(\n-                    \"expected serde {} attribute to be a string: `{} = \\\"...\\\"`\",\n-                    attr_name, meta_item_name\n-                ),\n-            );\n-            Ok(None)\n-        }\n+    let expr: syn::Expr = meta.value()?.parse()?;\n+    let mut value = &expr;\n+    while let syn::Expr::Group(e) = value {\n+        value = &e.expr;\n+    }\n+    if let syn::Expr::Lit(syn::ExprLit {\n+        lit: syn::Lit::Str(lit),\n+        ..\n+    }) = value\n+    {\n+        Ok(Some(lit.clone()))\n+    } else {\n+        cx.error_spanned_by(\n+            expr,\n+            format!(\n+                \"expected serde {} attribute to be a string: `{} = \\\"...\\\"`\",\n+                attr_name, meta_item_name\n+            ),\n+        );\n+        Ok(None)\n     }\n }\n \n", "test_patch": "diff --git a/test_suite/tests/regression/issue2409.rs b/test_suite/tests/regression/issue2409.rs\nnew file mode 100644\nindex 000000000..2e3936691\n--- /dev/null\n+++ b/test_suite/tests/regression/issue2409.rs\n@@ -0,0 +1,11 @@\n+use serde::Deserialize;\n+\n+macro_rules! bug {\n+    ($serde_path:literal) => {\n+        #[derive(Deserialize)]\n+        #[serde(crate = $serde_path)]\n+        pub struct Struct;\n+    };\n+}\n+\n+bug!(\"serde\");\n", "problem_statement": "Regression in serde 1.0.157 when a proc macro enables syn's full feature\nWith https://github.com/nox/serde-none-group, the command `cargo build --features syn-full` fails while the command `cargo build` succeeds. The only difference is that the failing command enables the \"full\" feature of the crate `syn` from a proc macro.\r\n\r\nThe build failure is:\r\n\r\n```\r\n\u00b1 cargo build --features syn-full\r\n   Compiling syn v2.0.2\r\n   Compiling serde_derive v1.0.157\r\n   Compiling another-proc-macro v0.1.67 (/Users/nox/src/serde-none-group/another-proc-macro)\r\n   Compiling serde v1.0.157\r\n   Compiling serde-none-group v0.1.0 (/Users/nox/src/serde-none-group)\r\nerror: expected serde crate attribute to be a string: `crate = \"...\"`\r\n  --> src/lib.rs:4:25\r\n   |\r\n4  |           #[serde(crate = $serde_path)]\r\n   |                           ^^^^^^^^^^^\r\n...\r\n9  | / bug_if_async_trait! {\r\n10 | |     \"serde\"\r\n11 | | }\r\n   | |_- in this macro invocation\r\n   |\r\n   = note: this error originates in the macro `bug_if_async_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\r\n```\r\n\r\nI've debugged it and the reason is that serde_derive sees a None-delimited group instead of a bare literal, but only when the \"full\" feature of syn is enabled.\n", "hints_text": "", "created_at": "2023-03-20T11:04:16Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2403, "instance_id": "serde-rs__serde-2403", "issue_numbers": ["1402"], "base_commit": "acfd19cb463ea77d2146d637c35d8751601dae75", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex d4238f13e..0b86cde6f 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -1165,6 +1165,32 @@ fn deserialize_enum(\n     params: &Parameters,\n     variants: &[Variant],\n     cattrs: &attr::Container,\n+) -> Fragment {\n+    // The variants have already been checked (in ast.rs) that all untagged variants appear at the end\n+    match variants\n+        .iter()\n+        .enumerate()\n+        .find(|(_, var)| var.attrs.untagged())\n+    {\n+        Some((variant_idx, _)) => {\n+            let (tagged, untagged) = variants.split_at(variant_idx);\n+            let tagged_frag = Expr(deserialize_homogeneous_enum(params, tagged, cattrs));\n+            let tagged_frag = |deserializer| {\n+                Some(Expr(quote_block! {\n+                    let __deserializer = #deserializer;\n+                    #tagged_frag\n+                }))\n+            };\n+            deserialize_untagged_enum_after(params, untagged, cattrs, tagged_frag)\n+        }\n+        None => deserialize_homogeneous_enum(params, variants, cattrs),\n+    }\n+}\n+\n+fn deserialize_homogeneous_enum(\n+    params: &Parameters,\n+    variants: &[Variant],\n+    cattrs: &attr::Container,\n ) -> Fragment {\n     match cattrs.tag() {\n         attr::TagType::External => deserialize_externally_tagged_enum(params, variants, cattrs),\n@@ -1661,6 +1687,17 @@ fn deserialize_untagged_enum(\n     variants: &[Variant],\n     cattrs: &attr::Container,\n ) -> Fragment {\n+    deserialize_untagged_enum_after(params, variants, cattrs, |_| None)\n+}\n+\n+fn deserialize_untagged_enum_after(\n+    params: &Parameters,\n+    variants: &[Variant],\n+    cattrs: &attr::Container,\n+    first_attempt: impl FnOnce(TokenStream) -> Option<Expr>,\n+) -> Fragment {\n+    let deserializer =\n+        quote!(_serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content));\n     let attempts = variants\n         .iter()\n         .filter(|variant| !variant.attrs.skip_deserializing())\n@@ -1669,12 +1706,12 @@ fn deserialize_untagged_enum(\n                 params,\n                 variant,\n                 cattrs,\n-                quote!(\n-                    _serde::__private::de::ContentRefDeserializer::<__D::Error>::new(&__content)\n-                ),\n+                deserializer.clone(),\n             ))\n         });\n-\n+    let attempts = first_attempt(deserializer.clone())\n+        .into_iter()\n+        .chain(attempts);\n     // TODO this message could be better by saving the errors from the failed\n     // attempts. The heuristic used by TOML was to count the number of fields\n     // processed before an error, and use the error that happened after the\ndiff --git a/serde_derive/src/internals/ast.rs b/serde_derive/src/internals/ast.rs\nindex 2a6950b2a..ca3dd33ad 100644\n--- a/serde_derive/src/internals/ast.rs\n+++ b/serde_derive/src/internals/ast.rs\n@@ -140,6 +140,7 @@ fn enum_from_ast<'a>(\n     variants: &'a Punctuated<syn::Variant, Token![,]>,\n     container_default: &attr::Default,\n ) -> Vec<Variant<'a>> {\n+    let mut seen_untagged = false;\n     variants\n         .iter()\n         .map(|variant| {\n@@ -153,8 +154,12 @@ fn enum_from_ast<'a>(\n                 fields,\n                 original: variant,\n             }\n-        })\n-        .collect()\n+        }).inspect(|variant| {\n+            if !variant.attrs.untagged() && seen_untagged {\n+                cx.error_spanned_by(&variant.ident, \"all variants with the #[serde(untagged)] attribute must be placed at the end of the enum\")\n+            }\n+            seen_untagged = variant.attrs.untagged()\n+        }).collect()\n }\n \n fn struct_from_ast<'a>(\ndiff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex 9875b6606..f0192259f 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -734,6 +734,7 @@ pub struct Variant {\n     serialize_with: Option<syn::ExprPath>,\n     deserialize_with: Option<syn::ExprPath>,\n     borrow: Option<BorrowAttribute>,\n+    untagged: bool,\n }\n \n struct BorrowAttribute {\n@@ -756,6 +757,7 @@ impl Variant {\n         let mut serialize_with = Attr::none(cx, SERIALIZE_WITH);\n         let mut deserialize_with = Attr::none(cx, DESERIALIZE_WITH);\n         let mut borrow = Attr::none(cx, BORROW);\n+        let mut untagged = BoolAttr::none(cx, UNTAGGED);\n \n         for attr in &variant.attrs {\n             if attr.path() != SERDE {\n@@ -867,6 +869,8 @@ impl Variant {\n                             cx.error_spanned_by(variant, msg);\n                         }\n                     }\n+                } else if meta.path == UNTAGGED {\n+                    untagged.set_true(&meta.path);\n                 } else {\n                     let path = meta.path.to_token_stream().to_string().replace(' ', \"\");\n                     return Err(\n@@ -893,6 +897,7 @@ impl Variant {\n             serialize_with: serialize_with.get(),\n             deserialize_with: deserialize_with.get(),\n             borrow: borrow.get(),\n+            untagged: untagged.get(),\n         }\n     }\n \n@@ -944,6 +949,10 @@ impl Variant {\n     pub fn deserialize_with(&self) -> Option<&syn::ExprPath> {\n         self.deserialize_with.as_ref()\n     }\n+\n+    pub fn untagged(&self) -> bool {\n+        self.untagged\n+    }\n }\n \n /// Represents field attribute information\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 43695dd0c..3b49b86c2 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -477,17 +477,17 @@ fn serialize_variant(\n             }\n         };\n \n-        let body = Match(match cattrs.tag() {\n-            attr::TagType::External => {\n+        let body = Match(match (cattrs.tag(), variant.attrs.untagged()) {\n+            (attr::TagType::External, false) => {\n                 serialize_externally_tagged_variant(params, variant, variant_index, cattrs)\n             }\n-            attr::TagType::Internal { tag } => {\n+            (attr::TagType::Internal { tag }, false) => {\n                 serialize_internally_tagged_variant(params, variant, cattrs, tag)\n             }\n-            attr::TagType::Adjacent { tag, content } => {\n+            (attr::TagType::Adjacent { tag, content }, false) => {\n                 serialize_adjacently_tagged_variant(params, variant, cattrs, tag, content)\n             }\n-            attr::TagType::None => serialize_untagged_variant(params, variant, cattrs),\n+            (attr::TagType::None, _) | (_, true) => serialize_untagged_variant(params, variant, cattrs),\n         });\n \n         quote! {\n", "test_patch": "diff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex 8ff725e01..2b8bed664 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -2395,6 +2395,159 @@ fn test_untagged_enum_containing_flatten() {\n     );\n }\n \n+#[test]\n+fn test_partially_untagged_enum() {\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    enum Exp {\n+        Lambda(u32, Box<Exp>),\n+        #[serde(untagged)]\n+        App(Box<Exp>, Box<Exp>),\n+        #[serde(untagged)]\n+        Var(u32),\n+    }\n+    use Exp::*;\n+\n+    let data = Lambda(0, Box::new(App(Box::new(Var(0)), Box::new(Var(0)))));\n+    assert_tokens(\n+        &data,\n+        &[\n+            Token::TupleVariant {\n+                name: \"Exp\",\n+                variant: \"Lambda\",\n+                len: 2,\n+            },\n+            Token::U32(0),\n+            Token::Tuple { len: 2 },\n+            Token::U32(0),\n+            Token::U32(0),\n+            Token::TupleEnd,\n+            Token::TupleVariantEnd,\n+        ],\n+    );\n+}\n+\n+#[test]\n+fn test_partially_untagged_enum_generic() {\n+    trait Trait<T> {\n+        type Assoc;\n+        type Assoc2;\n+    }\n+\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    enum E<A, B, C> where A: Trait<C, Assoc2=B> {\n+        A(A::Assoc),\n+        #[serde(untagged)]\n+        B(A::Assoc2),\n+    }\n+\n+    impl<T> Trait<T> for () {\n+        type Assoc = T;\n+        type Assoc2 = bool;\n+    }\n+\n+    type MyE = E<(), bool, u32>;\n+    use E::*;\n+\n+    assert_tokens::<MyE>(&B(true), &[Token::Bool(true)]);\n+\n+    assert_tokens::<MyE>(\n+        &A(5),\n+        &[\n+            Token::NewtypeVariant {\n+                name: \"E\",\n+                variant: \"A\",\n+            },\n+            Token::U32(5),\n+        ],\n+    );\n+}\n+\n+#[test]\n+fn test_partially_untagged_enum_desugared() {\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    enum Test {\n+        A(u32, u32),\n+        B(u32),\n+        #[serde(untagged)]\n+        C(u32),\n+        #[serde(untagged)]\n+        D(u32, u32),\n+    }\n+    use Test::*;\n+\n+    mod desugared {\n+        use super::*;\n+        #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+        pub(super) enum Test {\n+            A(u32, u32),\n+            B(u32),\n+        }\n+    }\n+    use desugared::Test as TestTagged;\n+\n+    #[derive(Serialize, Deserialize, PartialEq, Debug)]\n+    #[serde(untagged)]\n+    enum TestUntagged {\n+        Tagged(TestTagged),\n+        C(u32),\n+        D(u32, u32),\n+    }\n+\n+    impl From<Test> for TestUntagged {\n+        fn from(test: Test) -> Self {\n+            match test {\n+                A(x, y) => TestUntagged::Tagged(TestTagged::A(x, y)),\n+                B(x) => TestUntagged::Tagged(TestTagged::B(x)),\n+                C(x) => TestUntagged::C(x),\n+                D(x, y) => TestUntagged::D(x, y),\n+            }\n+        }\n+    }\n+\n+    fn assert_tokens_desugared(value: Test, tokens: &[Token]) {\n+        assert_tokens(&value, tokens);\n+        let desugared: TestUntagged = value.into();\n+        assert_tokens(&desugared, tokens);\n+    }\n+\n+    assert_tokens_desugared(\n+        A(0, 1),\n+        &[\n+            Token::TupleVariant {\n+                name: \"Test\",\n+                variant: \"A\",\n+                len: 2,\n+            },\n+            Token::U32(0),\n+            Token::U32(1),\n+            Token::TupleVariantEnd,\n+        ],\n+    );\n+\n+    assert_tokens_desugared(\n+        B(1),\n+        &[\n+            Token::NewtypeVariant {\n+                name: \"Test\",\n+                variant: \"B\",\n+            },\n+            Token::U32(1),\n+        ],\n+    );\n+\n+    assert_tokens_desugared(C(2), &[Token::U32(2)]);\n+\n+    assert_tokens_desugared(\n+        D(3, 5),\n+        &[\n+            Token::Tuple { len: 2 },\n+            Token::U32(3),\n+            Token::U32(5),\n+            Token::TupleEnd,\n+        ],\n+    );\n+}\n+\n #[test]\n fn test_flatten_untagged_enum() {\n     #[derive(Serialize, Deserialize, PartialEq, Debug)]\ndiff --git a/test_suite/tests/ui/enum-representation/partially_tagged_wrong_order.rs b/test_suite/tests/ui/enum-representation/partially_tagged_wrong_order.rs\nnew file mode 100644\nindex 000000000..a33398cae\n--- /dev/null\n+++ b/test_suite/tests/ui/enum-representation/partially_tagged_wrong_order.rs\n@@ -0,0 +1,10 @@\n+use serde_derive::Serialize;\n+\n+#[derive(Serialize)]\n+enum E {\n+    #[serde(untagged)]\n+    A(u8),\n+    B(String),\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/ui/enum-representation/partially_tagged_wrong_order.stderr b/test_suite/tests/ui/enum-representation/partially_tagged_wrong_order.stderr\nnew file mode 100644\nindex 000000000..17d3c3f93\n--- /dev/null\n+++ b/test_suite/tests/ui/enum-representation/partially_tagged_wrong_order.stderr\n@@ -0,0 +1,5 @@\n+error: all variants with the #[serde(untagged)] attribute must be placed at the end of the enum\n+ --> tests/ui/enum-representation/partially_tagged_wrong_order.rs:7:5\n+  |\n+7 |     B(String),\n+  |     ^\n", "problem_statement": "#[serde(flatten)] attribute support for enum variants\nHi!\r\n\r\nI have the following use-case for a feature similar to `#[serde(flatten)]`, but for enum variants rather than struct fields. Generally happy to dive into `serde_derive` myself in case you think this would be worth having, but it could also be that I'm trying to model this the wrong way.\r\n\r\nI'm trying to parse JSON values in the [estree format](https://github.com/estree/estree). The format specifies an ECMAScript syntax tree using an inhertance relationship, where generally only the nodes at the bottom of the hierarchy are tagged.\r\n\r\nFor example, one type of node is `Expression`, but there doesn't exist any node with the \"Expression\" tag, because the tag is assigned to the \"concrete\" expression nodes such as `Identifier` or `Literal`. The representation of the `Expression` node is basically just a union of all possible JSON representations of its descendant node types.\r\n\r\nSo far, I've been modelling it like this, which has been working fine for the most part:\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\n#[serde(tag = \"type\")]\r\npub enum Expression {\r\n    Identifier { name: String },\r\n    Literal { value: Value },\r\n    ...\r\n}\r\n```\r\n\r\nNow, the difficulty I've been having comes in when I try to mix types that are at the bottom of the node hierarchy with node types that have sub-types (such as `Expression`):\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\n#[serde(tag = \"type\")]\r\npub enum ForStatementInit {\r\n    VariableDeclaration { kind: String, ... },\r\n    Expression(Expression),\r\n}\r\n```\r\n\r\nIn this case, what I really want is for the `ForStatementInit` type to be the result of \"adding\" the node of type `VariableDeclaration` to the set of representations for `Expression`. What ends up happening though of course is that it expects a value tagged with either `VariableDeclaration` or `Expression`.\r\n\r\nI can work around this by either nesting `VariableDeclaration` into a single-variant enum, and using `#[serde(untagged)]` on the `ForStatementInit` enum, or by manually \"flattening\" the expression types, like so:\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\n#[serde(tag = \"type\")]\r\npub enum ForStatementInit {\r\n    VariableDeclaration { kind: String, ... },\r\n    // Expression\r\n    Identifier { name: String },\r\n    Literal { value: Value },\r\n}\r\n```\r\n\r\nHowever, what I think would be really useful is to be able to do something like this instead, which would apply the same \"flattening\" transformation in the example above:\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\n#[serde(tag = \"type\")]\r\npub enum ForStatementInit {\r\n    VariableDeclaration { kind: String, ... },\r\n    #[serde(flatten)]\r\n    Expression(Expression),\r\n}\r\n```\r\n\r\nHope this makes somewhat sense, keen to hear if this is something that you think is worth solving in serde itself!\n", "hints_text": "It looks like this is similar to #1350 where you suggest manually flattening, but that would be fairly cumbersome in this case (`Expression` might have a couple dozen variants) and I guess I'm still curious whether there's a \"better\" way to do this.\nSeems reasonable! I would be interested in supporting this better. I have also occasionally wanted `serde(untagged)` to work as a variant attribute which would have a similar effect in this case.\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\n#[serde(tag = \"type\")]\r\npub enum ForStatementInit {\r\n    VariableDeclaration { kind: String, ... },\r\n    #[serde(untagged)]\r\n    Expression(Expression),\r\n}\r\n```\n@dtolnay, what would it take to implement `untagged` for variants? I have need for such a feature and may be interested in implementing it.\nI haven't thought through how the feature would work. I would first want to see a handwritten Deserialize impl that behaves the way we would want the code generated for an untagged enum variant to behave. I would schedule 2-6 hours to put together some fully fleshed out handwritten impls to discover any edge cases, depending on your level of familiarity with the deserialization API.\n> a handwritten Deserialize impl that behaves the way we would want the code generated for an untagged enum variant to behave\r\n\r\nMeaning a Deserialize impl that enables it without any variant macro? Would tweaking serde-yaml in a branch be sufficient?\n@dtolnay, did you see my previous questions?\nCorrect, handwritten meaning without a macro involved. There shouldn't need to be changes to serde-yaml or any other format because you would be touching the enum's Deserialize impl only.\nAhh, my mistake. I was thinking `Deserializer`\n@dtolnay, I threw together [a few Deserialize impls](https://play.rust-lang.org/?version=beta&mode=debug&edition=2018&gist=bfec6caddd282bef6eaa74dc9e81f388). What edge cases am I lacking? \nTrait bounds make this somewhat more complicated. For example:\r\n\r\n```rust\r\ntrait Trait<T> {\r\n    type Associated;\r\n}\r\n\r\nenum E<A, B, C> where A: Trait<C> {\r\n    A(A::Associated),\r\n    // #[serde(untagged)]\r\n    B(B),\r\n}\r\n\r\n// not a legal type\r\n#[allow(non_snake_case)]\r\nstruct AHelper<A, B, C> where A: Trait<C> {\r\n    A: A::Associated,\r\n}\r\n```\r\n\r\nOtherwise looks good to me.", "created_at": "2023-03-16T17:02:17Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2387, "instance_id": "serde-rs__serde-2387", "issue_numbers": ["1504"], "base_commit": "a13c6382b6a4644be01b9b6c331b0cc32d32bc58", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex a703adaf7..679086e61 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -2400,7 +2400,8 @@ fn deserialize_struct_as_struct_visitor(\n         .collect();\n \n     let fields_stmt = {\n-        let field_names = field_names_idents.iter().map(|(name, _, _)| name);\n+        let field_names = field_names_idents.iter().flat_map(|(_, _, aliases)| aliases);\n+\n         quote_block! {\n             const FIELDS: &'static [&'static str] = &[ #(#field_names),* ];\n         }\n", "test_patch": "diff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex f32c22c1a..8ff725e01 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -642,7 +642,7 @@ fn test_unknown_field_rename_struct() {\n             Token::Str(\"a4\"),\n             Token::I32(3),\n         ],\n-        \"unknown field `a4`, expected one of `a1`, `a2`, `a6`\",\n+        \"unknown field `a4`, expected one of `a1`, `a3`, `a2`, `a5`, `a6`\",\n     );\n }\n \n@@ -780,7 +780,7 @@ fn test_rename_enum() {\n             Token::StructVariant {\n                 name: \"AliasEnum\",\n                 variant: \"sailor_moon\",\n-                len: 3,\n+                len: 5,\n             },\n             Token::Str(\"a\"),\n             Token::I8(0),\n@@ -798,7 +798,7 @@ fn test_rename_enum() {\n             Token::StructVariant {\n                 name: \"AliasEnum\",\n                 variant: \"usagi_tsukino\",\n-                len: 3,\n+                len: 5,\n             },\n             Token::Str(\"a\"),\n             Token::I8(0),\n@@ -827,7 +827,7 @@ fn test_unknown_field_rename_enum() {\n             Token::StructVariant {\n                 name: \"AliasEnum\",\n                 variant: \"usagi_tsukino\",\n-                len: 3,\n+                len: 5,\n             },\n             Token::Str(\"a\"),\n             Token::I8(0),\n@@ -836,7 +836,7 @@ fn test_unknown_field_rename_enum() {\n             Token::Str(\"d\"),\n             Token::I8(2),\n         ],\n-        \"unknown field `d`, expected one of `a`, `b`, `f`\",\n+        \"unknown field `d`, expected one of `a`, `c`, `b`, `e`, `f`\",\n     );\n }\n \n@@ -2658,6 +2658,68 @@ fn test_flatten_any_after_flatten_struct() {\n     );\n }\n \n+#[test]\n+fn test_alias_in_flatten_context() {\n+    #[derive(Debug, PartialEq, Deserialize)]\n+    struct Outer {\n+        #[serde(flatten)]\n+        a: AliasStruct,\n+        b: i32,\n+    }\n+\n+    assert_de_tokens(\n+        &Outer {\n+            a: AliasStruct {\n+                a1: 1,\n+                a2: 2,\n+                a4: 4,\n+            },\n+            b: 7,\n+        },\n+        &[\n+            Token::Struct {\n+                name: \"Outer\",\n+                len: 4,\n+            },\n+            Token::Str(\"a1\"),\n+            Token::I32(1),\n+            Token::Str(\"a2\"),\n+            Token::I32(2),\n+            Token::Str(\"a5\"),\n+            Token::I32(4),\n+            Token::Str(\"b\"),\n+            Token::I32(7),\n+            Token::StructEnd,\n+        ],\n+    );\n+\n+    assert_de_tokens(\n+        &Outer {\n+            a: AliasStruct {\n+                a1: 1,\n+                a2: 2,\n+                a4: 4,\n+            },\n+            b: 7,\n+        },\n+        &[\n+            Token::Struct {\n+                name: \"Outer\",\n+                len: 4,\n+            },\n+            Token::Str(\"a1\"),\n+            Token::I32(1),\n+            Token::Str(\"a2\"),\n+            Token::I32(2),\n+            Token::Str(\"a6\"),\n+            Token::I32(4),\n+            Token::Str(\"b\"),\n+            Token::I32(7),\n+            Token::StructEnd,\n+        ],\n+    );\n+}\n+\n #[test]\n fn test_expecting_message() {\n     #[derive(Deserialize, PartialEq, Debug)]\n", "problem_statement": "Field aliases do not work in combination with `flatten`\nField aliases as introduced in https://github.com/serde-rs/serde/pull/1458 do not work when deserializing \"flattened\" structures.\r\n\r\n\r\n### Expected behavior\r\n\r\nField aliases should work when deserializing \"flattened\" structures.\r\n\r\n### Observed behavior\r\n\r\nField aliases do not work when deserializing \"flattened\" structures.\r\n\r\n### How to reproduce\r\n\r\nThe following code can be used to reproduce the problem, also available as Rust Playground snippet [here](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=2a24a58747f7c27840774e2492fa5d1e).\r\n\r\n```\r\nuse serde::{Deserialize, Serialize};\r\nuse serde_json;\r\n\r\n#[derive(Serialize, Deserialize)]\r\npub struct A {\r\n    #[serde(rename = \"y\", alias = \"z\")]\r\n    x: i64,\r\n}\r\n\r\n#[derive(Serialize, Deserialize)]\r\npub struct B {\r\n    #[serde(flatten)]\r\n    a: A,\r\n}\r\n\r\nfn main() -> Result<(),Box<std::error::Error>> {\r\n     let i = r#\"{ \"z\": 12 }\"#; // using r#\"{ \"y\": 12 }\"# will work.\r\n     let b: B = serde_json::from_str(i)?;\r\n     assert_eq!(b.a.x,12);\r\n     Ok(())\r\n}\r\n```\r\n\n", "hints_text": "I just got bitten by this too.\nThis is a bug -- I would accept a PR to fix this.\nI'll try to give it a shot, but first time poking at serde_derive, so no promises :)\r\n\nYeah, I just got bit by this too.  \r\nI was using variants, so I thought it was related to that.  \r\nI can take a try at fixing this if there's been no progress.\r\n\r\n```rust\r\nuse serde::Deserialize;\r\nuse serde_json::from_str;\r\n\r\n#[derive(Debug, Deserialize)]\r\nstruct Value {\r\n\t#[serde(flatten)]\r\n\tdata: Ser,\r\n}\r\n\r\n#[derive(Debug, Deserialize)]\r\nenum Ser {\r\n\t#[serde(rename = \"var\", alias = \"def\")]\r\n\tVariant(u8)\r\n}\r\n\r\nfn main() {\r\n\tlet input = r#\"{ \"def\": 0 }\"#;\r\n\tprintln!(\"{:?}\", from_str::<Ser>(input).unwrap());\r\n\tprintln!(\"{:?}\", from_str::<Value>(input).unwrap());\r\n}\r\n```\nAfter hunting around, I found the issue.\r\n\r\nWe pass an array of valid variants directly into the [`deserialize_enum`](https://github.com/serde-rs/serde/blob/master/serde/src/de/mod.rs#L1127).  \r\nThe aliases aren't counted as variants, and so aren't added to the list.  \r\nWe could add the aliases to the [generated array](https://github.com/serde-rs/serde/blob/master/serde_derive/src/de.rs#L1176-L1181), but I don't know if that might break other things.\r\n\r\nI'm open to ideas.\r\n\r\nEDIT: I forgot that structs have this issue as well.\r\nWe pass in an [array of field names](https://github.com/serde-rs/serde/blob/master/serde/src/de/mod.rs#L1116) (non-aliased).\r\n\r\nWe could add the aliased names to the arrays, and then internally, when it actually goes to deserialise it, sort out which one to use, etc, like normal.\r\n\nTwo years later, I just got bitten by this bug. A fix would be very appreciated.\nJust got bitten by this too \ud83d\ude2d\nWas also just bitten by this.\nI just ran into the same issue.", "created_at": "2023-03-05T07:27:53Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2383, "instance_id": "serde-rs__serde-2383", "issue_numbers": ["2371"], "base_commit": "a13c6382b6a4644be01b9b6c331b0cc32d32bc58", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex a703adaf7..c0701625f 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -954,6 +954,7 @@ fn deserialize_struct(\n             lifetime: _serde::__private::PhantomData,\n         }\n     };\n+    let need_seed = deserializer.is_none();\n     let dispatch = if let Some(deserializer) = deserializer {\n         quote! {\n             _serde::Deserializer::deserialize_any(#deserializer, #visitor_expr)\n@@ -999,14 +1000,14 @@ fn deserialize_struct(\n         _ => None,\n     };\n \n-    let visitor_seed = if is_enum && cattrs.has_flatten() {\n+    let visitor_seed = if need_seed && is_enum && cattrs.has_flatten() {\n         Some(quote! {\n             impl #de_impl_generics _serde::de::DeserializeSeed<#delife> for __Visitor #de_ty_generics #where_clause {\n                 type Value = #this_type #ty_generics;\n \n                 fn deserialize<__D>(self, __deserializer: __D) -> _serde::__private::Result<Self::Value, __D::Error>\n                 where\n-                    __D: _serde::Deserializer<'de>,\n+                    __D: _serde::Deserializer<#delife>,\n                 {\n                     _serde::Deserializer::deserialize_map(__deserializer, self)\n                 }\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex c053d6903..f6782f68f 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -892,3 +892,53 @@ pub struct RemotePackedNonCopyDef {\n impl Drop for RemotePackedNonCopyDef {\n     fn drop(&mut self) {}\n }\n+\n+//////////////////////////////////////////////////////////////////////////\n+\n+/// Regression tests for <https://github.com/serde-rs/serde/issues/2371>\n+#[allow(dead_code)]\n+mod static_and_flatten {\n+    use super::*;\n+\n+    #[derive(Deserialize)]\n+    struct Nested;\n+\n+    #[derive(Deserialize)]\n+    enum ExternallyTagged {\n+        Flatten {\n+            #[serde(flatten)]\n+            nested: Nested,\n+            string: &'static str,\n+        },\n+    }\n+\n+    #[derive(Deserialize)]\n+    #[serde(tag = \"tag\")]\n+    enum InternallyTagged {\n+        Flatten {\n+            #[serde(flatten)]\n+            nested: Nested,\n+            string: &'static str,\n+        },\n+    }\n+\n+    #[derive(Deserialize)]\n+    #[serde(tag = \"tag\", content = \"content\")]\n+    enum AdjacentlyTagged {\n+        Flatten {\n+            #[serde(flatten)]\n+            nested: Nested,\n+            string: &'static str,\n+        },\n+    }\n+\n+    #[derive(Deserialize)]\n+    #[serde(untagged)]\n+    enum UntaggedWorkaround {\n+        Flatten {\n+            #[serde(flatten)]\n+            nested: Nested,\n+            string: &'static str,\n+        },\n+    }\n+}\n", "problem_statement": "\"undeclared lifetime\" when derive `Deserialize` for an enum with both `flatten` and `'static` fields\nThe following code panics with the error:\r\n```rust\r\nuse serde::Deserialize;\r\n\r\n#[derive(Deserialize)]\r\nstruct Nested {\r\n    float: f64,\r\n}\r\n\r\n#[derive(Deserialize)]\r\n#[serde(tag = \"tag\")]\r\nenum InternallyTagged {\r\n    Flatten {\r\n        #[serde(flatten)]\r\n        nested: Nested,\r\n        string: &'static str,\r\n    },\r\n}\r\n```\r\nCommenting out any of fields lead to successful compilation.\r\n\r\nOutput:\r\n```\r\nCompiling playground v0.0.1 (/playground)\r\nerror[E0261]: use of undeclared lifetime name `'de`\r\n --> src/lib.rs:8:10\r\n  |\r\n8 | #[derive(Deserialize)]\r\n  |          ^^^^^^^^^^^\r\n  |          |\r\n  |          undeclared lifetime\r\n  |          lifetime `'de` is missing in item created through this procedural macro\r\n  |\r\n  = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\r\n  = note: this error originates in the derive macro `Deserialize` (in Nightly builds, run with -Z macro-backtrace for more info)\r\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\r\n  |\r\n8 | #[derive(for<'de> Deserialize)]\r\n  |          ++++++++\r\nhelp: consider making the bound lifetime-generic with a new `'de` lifetime\r\n  |\r\n8 | #[derive(for<'de> Deserialize)]\r\n  |          ++++++++\r\nhelp: consider introducing lifetime `'de` here\r\n  |\r\n8 | #[derive(Deserialize<'de>)]\r\n  |                     +++++\r\n\r\nFor more information about this error, try `rustc --explain E0261`.\r\nerror: could not compile `playground` due to previous error\r\n```\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b3e592812a43c300e2d247c9ac0b0033\n", "hints_text": "Since `&'static str` usually represents a string embedded in the binary of your program I don't think it's possible to or even makes sense to `Deserialize` one? Surely what you want to do is this:\r\n```rs\r\n#[derive(Deserialize)]\r\n#[serde(tag = \"tag\")]\r\nenum InternallyTagged<'a> {\r\n    Flatten {\r\n        #[serde(flatten)]\r\n        nested: Nested,\r\n        string: &'a str,\r\n    },\r\n}\r\n```\nOf course, this will not work, but serde in that case usually returns an error from `Deserialize::deserialize` phase instead of incorrect code generation. Moreover, as I said, if you comment `nested` field, this code is compiled.\r\n\r\nSo I think it should either:\r\n- always generate compiler error when you try to implement `Deserialize` with `'static` fields\r\n- or never generate such an error\n> Of course, this will not work\r\n\r\nActually, I'm not right here. Of course, this will work if you try to deserialize a static string into a type (i.e. you just create a read-only struct around read-only string embedded in binary). This will not work if you try to deserialize heap-allocated string.\nThe problem in the `DeserializeSeed` implementation for the visitor for the deserialized type. The derive generates the following code:\r\n```rust\r\nimpl DeserializeSeed<'static> for Visitor {\r\n    type Value = InternallyTagged;\r\n\r\n    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\r\n    where\r\n        D: Deserializer<'de>,// <-- Error here\r\n    {\r\n        deserializer.deserialize_map(self)\r\n    }\r\n}\r\n```\r\nThe cleaned generated code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6c5e32bd6cef06756b0806be7447f827", "created_at": "2023-02-25T17:19:12Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2330, "instance_id": "serde-rs__serde-2330", "issue_numbers": ["2327"], "base_commit": "fabbd2b0970084fe8f85bf850f8cd295dd12b305", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex ef7a2dee2..a703adaf7 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -712,8 +712,9 @@ fn deserialize_seq(\n \n     if params.has_getter {\n         let this_type = &params.this_type;\n+        let (_, ty_generics, _) = params.generics.split_for_impl();\n         result = quote! {\n-            _serde::__private::Into::<#this_type>::into(#result)\n+            _serde::__private::Into::<#this_type #ty_generics>::into(#result)\n         };\n     }\n \n@@ -856,8 +857,9 @@ fn deserialize_newtype_struct(\n     let mut result = quote!(#type_path(__field0));\n     if params.has_getter {\n         let this_type = &params.this_type;\n+        let (_, ty_generics, _) = params.generics.split_for_impl();\n         result = quote! {\n-            _serde::__private::Into::<#this_type>::into(#result)\n+            _serde::__private::Into::<#this_type #ty_generics>::into(#result)\n         };\n     }\n \n@@ -2629,8 +2631,9 @@ fn deserialize_map(\n     let mut result = quote!(#struct_path { #(#result),* });\n     if params.has_getter {\n         let this_type = &params.this_type;\n+        let (_, ty_generics, _) = params.generics.split_for_impl();\n         result = quote! {\n-            _serde::__private::Into::<#this_type>::into(#result)\n+            _serde::__private::Into::<#this_type #ty_generics>::into(#result)\n         };\n     }\n \n", "test_patch": "diff --git a/test_suite/tests/test_remote.rs b/test_suite/tests/test_remote.rs\nindex c6d276e10..d997f0f01 100644\n--- a/test_suite/tests/test_remote.rs\n+++ b/test_suite/tests/test_remote.rs\n@@ -79,6 +79,13 @@ mod remote {\n         pub value: T,\n     }\n \n+    impl<T> StructGeneric<T> {\n+        #[allow(dead_code)]\n+        pub fn get_value(&self) -> &T {\n+            &self.value\n+        }\n+    }\n+\n     pub enum EnumGeneric<T> {\n         Variant(T),\n     }\n@@ -171,6 +178,13 @@ struct StructPubDef {\n     b: remote::Unit,\n }\n \n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"remote::StructGeneric\")]\n+struct StructGenericWithGetterDef<T> {\n+    #[serde(getter = \"remote::StructGeneric::get_value\")]\n+    value: T,\n+}\n+\n #[derive(Serialize, Deserialize)]\n #[serde(remote = \"remote::StructGeneric<u8>\")]\n struct StructConcrete {\n@@ -206,3 +220,9 @@ impl From<StructPrivDef> for remote::StructPriv {\n         remote::StructPriv::new(def.a, def.b)\n     }\n }\n+\n+impl<T> From<StructGenericWithGetterDef<T>> for remote::StructGeneric<T> {\n+    fn from(def: StructGenericWithGetterDef<T>) -> Self {\n+        remote::StructGeneric { value: def.value }\n+    }\n+}\n", "problem_statement": "Deriving Serialize for a struct from external crate which uses generics\nHello, \r\nI'm trying to implement Serialize for [nom_locate's](https://docs.rs/nom_locate/latest/nom_locate/) [`LocatedSpan`](https://docs.rs/nom_locate/latest/nom_locate/struct.LocatedSpan.html). It's a struct that encapsulates a token with some location information.  can't figure out how to implement Serialize for it. \r\n\r\nI created a `WrappedSpan` to build the bridge with `LocatedSpan`, but the derive macro doesn't chew up the passed-in generic. Is there a way around this? \r\n\r\n```rust\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(remote = \"LocatedSpan<T>\")] // <= This <T> produces an un-parseable token\r\nstruct WrappedSpan<T: AsBytes>{\r\n    #[serde(getter = \"LocatedSpan::location_offset\")]\r\n    offset: usize,\r\n    #[serde(getter = \"LocatedSpan::location_line\")]\r\n    line: u32,\r\n    #[serde(getter = \"LocatedSpan::fragment\")]\r\n    fragment: T,\r\n};\r\n\r\n// Provide a conversion to construct the remote type.\r\nimpl <T: AsBytes>From<WrappedSpan<T>> for LocatedSpan<T> {\r\n    fn from(def: WrappedSpan<T>) -> LocatedSpan<T> {\r\n        LocatedSpan{\r\n            offset: def.offset,\r\n            line: def.line,\r\n            fragment: def.fragment,\r\n            extra: (),\r\n        }\r\n    }\r\n}\r\n```\r\n\n", "hints_text": "", "created_at": "2022-11-28T01:18:49Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2159, "instance_id": "serde-rs__serde-2159", "issue_numbers": ["2158"], "base_commit": "bc66aeb0d316d608e43061372d6bd400aad2d393", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex d7c57568a..c5aaca723 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -81,8 +81,34 @@ impl<'de> Deserialize<'de> for bool {\n ////////////////////////////////////////////////////////////////////////////////\n \n macro_rules! impl_deserialize_num {\n-    ($ty:ident, $deserialize:ident $($methods:tt)*) => {\n-        impl<'de> Deserialize<'de> for $ty {\n+    ($primitive:ident, $nonzero:ident $(cfg($($cfg:tt)*))*, $deserialize:ident $($method:ident!($($val:ident : $visit:ident)*);)*) => {\n+        impl_deserialize_num!($primitive, $deserialize $($method!($($val : $visit)*);)*);\n+\n+        #[cfg(all(not(no_num_nonzero), $($($cfg)*)*))]\n+        impl<'de> Deserialize<'de> for num::$nonzero {\n+            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+            where\n+                D: Deserializer<'de>,\n+            {\n+                struct NonZeroVisitor;\n+\n+                impl<'de> Visitor<'de> for NonZeroVisitor {\n+                    type Value = num::$nonzero;\n+\n+                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                        formatter.write_str(concat!(\"a nonzero \", stringify!($primitive)))\n+                    }\n+\n+                    $($($method!(nonzero $primitive $val : $visit);)*)*\n+                }\n+\n+                deserializer.$deserialize(NonZeroVisitor)\n+            }\n+        }\n+    };\n+\n+    ($primitive:ident, $deserialize:ident $($method:ident!($($val:ident : $visit:ident)*);)*) => {\n+        impl<'de> Deserialize<'de> for $primitive {\n             #[inline]\n             fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n             where\n@@ -91,13 +117,13 @@ macro_rules! impl_deserialize_num {\n                 struct PrimitiveVisitor;\n \n                 impl<'de> Visitor<'de> for PrimitiveVisitor {\n-                    type Value = $ty;\n+                    type Value = $primitive;\n \n                     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n-                        formatter.write_str(stringify!($ty))\n+                        formatter.write_str(stringify!($primitive))\n                     }\n \n-                    $($methods)*\n+                    $($($method!($val : $visit);)*)*\n                 }\n \n                 deserializer.$deserialize(PrimitiveVisitor)\n@@ -116,85 +142,149 @@ macro_rules! num_self {\n             Ok(v)\n         }\n     };\n+\n+    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n+        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n+        where\n+            E: Error,\n+        {\n+            if let Some(nonzero) = Self::Value::new(v) {\n+                Ok(nonzero)\n+            } else {\n+                Err(Error::invalid_value(Unexpected::Unsigned(0), &self))\n+            }\n+        }\n+    };\n }\n \n macro_rules! num_as_self {\n-    ($($ty:ident : $visit:ident)*) => {\n-        $(\n-            #[inline]\n-            fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n-            where\n-                E: Error,\n-            {\n-                Ok(v as Self::Value)\n+    ($ty:ident : $visit:ident) => {\n+        #[inline]\n+        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n+        where\n+            E: Error,\n+        {\n+            Ok(v as Self::Value)\n+        }\n+    };\n+\n+    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n+        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n+        where\n+            E: Error,\n+        {\n+            if let Some(nonzero) = Self::Value::new(v as $primitive) {\n+                Ok(nonzero)\n+            } else {\n+                Err(Error::invalid_value(Unexpected::Unsigned(0), &self))\n             }\n-        )*\n+        }\n     };\n }\n \n macro_rules! int_to_int {\n-    ($($ty:ident : $visit:ident)*) => {\n-        $(\n-            #[inline]\n-            fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n-            where\n-                E: Error,\n+    ($ty:ident : $visit:ident) => {\n+        #[inline]\n+        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n+        where\n+            E: Error,\n+        {\n+            if Self::Value::min_value() as i64 <= v as i64\n+                && v as i64 <= Self::Value::max_value() as i64\n             {\n-                if Self::Value::min_value() as i64 <= v as i64 && v as i64 <= Self::Value::max_value() as i64 {\n-                    Ok(v as Self::Value)\n-                } else {\n-                    Err(Error::invalid_value(Unexpected::Signed(v as i64), &self))\n+                Ok(v as Self::Value)\n+            } else {\n+                Err(Error::invalid_value(Unexpected::Signed(v as i64), &self))\n+            }\n+        }\n+    };\n+\n+    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n+        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n+        where\n+            E: Error,\n+        {\n+            if $primitive::min_value() as i64 <= v as i64\n+                && v as i64 <= $primitive::max_value() as i64\n+            {\n+                if let Some(nonzero) = Self::Value::new(v as $primitive) {\n+                    return Ok(nonzero);\n                 }\n             }\n-        )*\n+            Err(Error::invalid_value(Unexpected::Signed(v as i64), &self))\n+        }\n     };\n }\n \n macro_rules! int_to_uint {\n-    ($($ty:ident : $visit:ident)*) => {\n-        $(\n-            #[inline]\n-            fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n-            where\n-                E: Error,\n-            {\n-                if 0 <= v && v as u64 <= Self::Value::max_value() as u64 {\n-                    Ok(v as Self::Value)\n-                } else {\n-                    Err(Error::invalid_value(Unexpected::Signed(v as i64), &self))\n+    ($ty:ident : $visit:ident) => {\n+        #[inline]\n+        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n+        where\n+            E: Error,\n+        {\n+            if 0 <= v && v as u64 <= Self::Value::max_value() as u64 {\n+                Ok(v as Self::Value)\n+            } else {\n+                Err(Error::invalid_value(Unexpected::Signed(v as i64), &self))\n+            }\n+        }\n+    };\n+\n+    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n+        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n+        where\n+            E: Error,\n+        {\n+            if 0 < v && v as u64 <= $primitive::max_value() as u64 {\n+                if let Some(nonzero) = Self::Value::new(v as $primitive) {\n+                    return Ok(nonzero);\n                 }\n             }\n-        )*\n+            Err(Error::invalid_value(Unexpected::Signed(v as i64), &self))\n+        }\n     };\n }\n \n macro_rules! uint_to_self {\n-    ($($ty:ident : $visit:ident)*) => {\n-        $(\n-            #[inline]\n-            fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n-            where\n-                E: Error,\n-            {\n-                if v as u64 <= Self::Value::max_value() as u64 {\n-                    Ok(v as Self::Value)\n-                } else {\n-                    Err(Error::invalid_value(Unexpected::Unsigned(v as u64), &self))\n+    ($ty:ident : $visit:ident) => {\n+        #[inline]\n+        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n+        where\n+            E: Error,\n+        {\n+            if v as u64 <= Self::Value::max_value() as u64 {\n+                Ok(v as Self::Value)\n+            } else {\n+                Err(Error::invalid_value(Unexpected::Unsigned(v as u64), &self))\n+            }\n+        }\n+    };\n+\n+    (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n+        fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n+        where\n+            E: Error,\n+        {\n+            if v as u64 <= $primitive::max_value() as u64 {\n+                if let Some(nonzero) = Self::Value::new(v as $primitive) {\n+                    return Ok(nonzero);\n                 }\n             }\n-        )*\n+            Err(Error::invalid_value(Unexpected::Unsigned(v as u64), &self))\n+        }\n     };\n }\n \n impl_deserialize_num! {\n-    i8, deserialize_i8\n+    i8, NonZeroI8 cfg(not(no_num_nonzero_signed)), deserialize_i8\n     num_self!(i8:visit_i8);\n     int_to_int!(i16:visit_i16 i32:visit_i32 i64:visit_i64);\n     uint_to_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n }\n \n impl_deserialize_num! {\n-    i16, deserialize_i16\n+    i16, NonZeroI16 cfg(not(no_num_nonzero_signed)), deserialize_i16\n     num_self!(i16:visit_i16);\n     num_as_self!(i8:visit_i8);\n     int_to_int!(i32:visit_i32 i64:visit_i64);\n@@ -202,7 +292,7 @@ impl_deserialize_num! {\n }\n \n impl_deserialize_num! {\n-    i32, deserialize_i32\n+    i32, NonZeroI32 cfg(not(no_num_nonzero_signed)), deserialize_i32\n     num_self!(i32:visit_i32);\n     num_as_self!(i8:visit_i8 i16:visit_i16);\n     int_to_int!(i64:visit_i64);\n@@ -210,28 +300,28 @@ impl_deserialize_num! {\n }\n \n impl_deserialize_num! {\n-    i64, deserialize_i64\n+    i64, NonZeroI64 cfg(not(no_num_nonzero_signed)), deserialize_i64\n     num_self!(i64:visit_i64);\n     num_as_self!(i8:visit_i8 i16:visit_i16 i32:visit_i32);\n     uint_to_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n }\n \n impl_deserialize_num! {\n-    isize, deserialize_i64\n+    isize, NonZeroIsize cfg(not(no_num_nonzero_signed)), deserialize_i64\n     num_as_self!(i8:visit_i8 i16:visit_i16);\n     int_to_int!(i32:visit_i32 i64:visit_i64);\n     uint_to_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n }\n \n impl_deserialize_num! {\n-    u8, deserialize_u8\n+    u8, NonZeroU8, deserialize_u8\n     num_self!(u8:visit_u8);\n     int_to_uint!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n     uint_to_self!(u16:visit_u16 u32:visit_u32 u64:visit_u64);\n }\n \n impl_deserialize_num! {\n-    u16, deserialize_u16\n+    u16, NonZeroU16, deserialize_u16\n     num_self!(u16:visit_u16);\n     num_as_self!(u8:visit_u8);\n     int_to_uint!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n@@ -239,7 +329,7 @@ impl_deserialize_num! {\n }\n \n impl_deserialize_num! {\n-    u32, deserialize_u32\n+    u32, NonZeroU32, deserialize_u32\n     num_self!(u32:visit_u32);\n     num_as_self!(u8:visit_u8 u16:visit_u16);\n     int_to_uint!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n@@ -247,14 +337,14 @@ impl_deserialize_num! {\n }\n \n impl_deserialize_num! {\n-    u64, deserialize_u64\n+    u64, NonZeroU64, deserialize_u64\n     num_self!(u64:visit_u64);\n     num_as_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32);\n     int_to_uint!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n }\n \n impl_deserialize_num! {\n-    usize, deserialize_u64\n+    usize, NonZeroUsize, deserialize_u64\n     num_as_self!(u8:visit_u8 u16:visit_u16);\n     int_to_uint!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n     uint_to_self!(u32:visit_u32 u64:visit_u64);\n@@ -277,42 +367,62 @@ impl_deserialize_num! {\n }\n \n serde_if_integer128! {\n+    macro_rules! num_128 {\n+        ($ty:ident : $visit:ident) => {\n+            fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n+            where\n+                E: Error,\n+            {\n+                if v as i128 >= Self::Value::min_value() as i128\n+                    && v as u128 <= Self::Value::max_value() as u128\n+                {\n+                    Ok(v as Self::Value)\n+                } else {\n+                    Err(Error::invalid_value(\n+                        Unexpected::Other(stringify!($ty)),\n+                        &self,\n+                    ))\n+                }\n+            }\n+        };\n+\n+        (nonzero $primitive:ident $ty:ident : $visit:ident) => {\n+            fn $visit<E>(self, v: $ty) -> Result<Self::Value, E>\n+            where\n+                E: Error,\n+            {\n+                if v as i128 >= $primitive::min_value() as i128\n+                    && v as u128 <= $primitive::max_value() as u128\n+                {\n+                    if let Some(nonzero) = Self::Value::new(v as $primitive) {\n+                        Ok(nonzero)\n+                    } else {\n+                        Err(Error::invalid_value(Unexpected::Unsigned(0), &self))\n+                    }\n+                } else {\n+                    Err(Error::invalid_value(\n+                        Unexpected::Other(stringify!($ty)),\n+                        &self,\n+                    ))\n+                }\n+            }\n+        };\n+    }\n+\n     impl_deserialize_num! {\n-        i128, deserialize_i128\n+        i128, NonZeroI128 cfg(not(no_num_nonzero_signed)), deserialize_i128\n         num_self!(i128:visit_i128);\n         num_as_self!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n         num_as_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n-\n-        #[inline]\n-        fn visit_u128<E>(self, v: u128) -> Result<Self::Value, E>\n-        where\n-            E: Error,\n-        {\n-            if v <= i128::max_value() as u128 {\n-                Ok(v as i128)\n-            } else {\n-                Err(Error::invalid_value(Unexpected::Other(\"u128\"), &self))\n-            }\n-        }\n+        num_128!(u128:visit_u128);\n     }\n \n     impl_deserialize_num! {\n-        u128, deserialize_u128\n+        u128, NonZeroU128, deserialize_u128\n         num_self!(u128:visit_u128);\n         num_as_self!(u8:visit_u8 u16:visit_u16 u32:visit_u32 u64:visit_u64);\n         int_to_uint!(i8:visit_i8 i16:visit_i16 i32:visit_i32 i64:visit_i64);\n-\n-        #[inline]\n-        fn visit_i128<E>(self, v: i128) -> Result<Self::Value, E>\n-        where\n-            E: Error,\n-        {\n-            if 0 <= v {\n-                Ok(v as u128)\n-            } else {\n-                Err(Error::invalid_value(Unexpected::Other(\"i128\"), &self))\n-            }\n-        }\n+        num_128!(i128:visit_i128);\n     }\n }\n \n@@ -2431,58 +2541,6 @@ where\n \n ////////////////////////////////////////////////////////////////////////////////\n \n-macro_rules! nonzero_integers {\n-    ( $( $T: ident, )+ ) => {\n-        $(\n-            #[cfg(not(no_num_nonzero))]\n-            impl<'de> Deserialize<'de> for num::$T {\n-                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-                where\n-                    D: Deserializer<'de>,\n-                {\n-                    let value = try!(Deserialize::deserialize(deserializer));\n-                    match <num::$T>::new(value) {\n-                        Some(nonzero) => Ok(nonzero),\n-                        None => Err(Error::custom(\"expected a non-zero value\")),\n-                    }\n-                }\n-            }\n-        )+\n-    };\n-}\n-\n-nonzero_integers! {\n-    NonZeroU8,\n-    NonZeroU16,\n-    NonZeroU32,\n-    NonZeroU64,\n-    NonZeroUsize,\n-}\n-\n-#[cfg(not(no_num_nonzero_signed))]\n-nonzero_integers! {\n-    NonZeroI8,\n-    NonZeroI16,\n-    NonZeroI32,\n-    NonZeroI64,\n-    NonZeroIsize,\n-}\n-\n-// Currently 128-bit integers do not work on Emscripten targets so we need an\n-// additional `#[cfg]`\n-serde_if_integer128! {\n-    nonzero_integers! {\n-        NonZeroU128,\n-    }\n-\n-    #[cfg(not(no_num_nonzero_signed))]\n-    nonzero_integers! {\n-        NonZeroI128,\n-    }\n-}\n-\n-////////////////////////////////////////////////////////////////////////////////\n-\n impl<'de, T, E> Deserialize<'de> for Result<T, E>\n where\n     T: Deserialize<'de>,\n", "test_patch": "diff --git a/test_suite/tests/test_de_error.rs b/test_suite/tests/test_de_error.rs\nindex da6e7656c..db534e983 100644\n--- a/test_suite/tests/test_de_error.rs\n+++ b/test_suite/tests/test_de_error.rs\n@@ -379,57 +379,81 @@ fn test_nonzero_i8() {\n     let test = assert_de_tokens_error::<NonZeroI8>;\n \n     // from zero\n-    test(&[Token::I8(0)], \"expected a non-zero value\");\n-    test(&[Token::I16(0)], \"expected a non-zero value\");\n-    test(&[Token::I32(0)], \"expected a non-zero value\");\n-    test(&[Token::I64(0)], \"expected a non-zero value\");\n-    test(&[Token::U8(0)], \"expected a non-zero value\");\n-    test(&[Token::U16(0)], \"expected a non-zero value\");\n-    test(&[Token::U32(0)], \"expected a non-zero value\");\n-    test(&[Token::U64(0)], \"expected a non-zero value\");\n+    test(\n+        &[Token::I8(0)],\n+        \"invalid value: integer `0`, expected a nonzero i8\",\n+    );\n+    test(\n+        &[Token::I16(0)],\n+        \"invalid value: integer `0`, expected a nonzero i8\",\n+    );\n+    test(\n+        &[Token::I32(0)],\n+        \"invalid value: integer `0`, expected a nonzero i8\",\n+    );\n+    test(\n+        &[Token::I64(0)],\n+        \"invalid value: integer `0`, expected a nonzero i8\",\n+    );\n+    test(\n+        &[Token::U8(0)],\n+        \"invalid value: integer `0`, expected a nonzero i8\",\n+    );\n+    test(\n+        &[Token::U16(0)],\n+        \"invalid value: integer `0`, expected a nonzero i8\",\n+    );\n+    test(\n+        &[Token::U32(0)],\n+        \"invalid value: integer `0`, expected a nonzero i8\",\n+    );\n+    test(\n+        &[Token::U64(0)],\n+        \"invalid value: integer `0`, expected a nonzero i8\",\n+    );\n \n     // from signed\n     test(\n         &[Token::I16(-129)],\n-        \"invalid value: integer `-129`, expected i8\",\n+        \"invalid value: integer `-129`, expected a nonzero i8\",\n     );\n     test(\n         &[Token::I32(-129)],\n-        \"invalid value: integer `-129`, expected i8\",\n+        \"invalid value: integer `-129`, expected a nonzero i8\",\n     );\n     test(\n         &[Token::I64(-129)],\n-        \"invalid value: integer `-129`, expected i8\",\n+        \"invalid value: integer `-129`, expected a nonzero i8\",\n     );\n     test(\n         &[Token::I16(128)],\n-        \"invalid value: integer `128`, expected i8\",\n+        \"invalid value: integer `128`, expected a nonzero i8\",\n     );\n     test(\n         &[Token::I32(128)],\n-        \"invalid value: integer `128`, expected i8\",\n+        \"invalid value: integer `128`, expected a nonzero i8\",\n     );\n     test(\n         &[Token::I64(128)],\n-        \"invalid value: integer `128`, expected i8\",\n+        \"invalid value: integer `128`, expected a nonzero i8\",\n     );\n \n     // from unsigned\n     test(\n         &[Token::U8(128)],\n-        \"invalid value: integer `128`, expected i8\",\n+        \"invalid value: integer `128`, expected a nonzero i8\",\n     );\n     test(\n         &[Token::U16(128)],\n-        \"invalid value: integer `128`, expected i8\",\n+        \"invalid value: integer `128`, expected a nonzero i8\",\n     );\n     test(\n         &[Token::U32(128)],\n-        \"invalid value: integer `128`, expected i8\",\n+        \"invalid value: integer `128`, expected a nonzero i8\",\n     );\n     test(\n         &[Token::U64(128)],\n-        \"invalid value: integer `128`, expected i8\",\n+        \"invalid value: integer `128`, expected a nonzero i8\",\n     );\n }\n \n@@ -438,45 +462,69 @@ fn test_nonzero_i16() {\n     let test = assert_de_tokens_error::<NonZeroI16>;\n \n     // from zero\n-    test(&[Token::I8(0)], \"expected a non-zero value\");\n-    test(&[Token::I16(0)], \"expected a non-zero value\");\n-    test(&[Token::I32(0)], \"expected a non-zero value\");\n-    test(&[Token::I64(0)], \"expected a non-zero value\");\n-    test(&[Token::U8(0)], \"expected a non-zero value\");\n-    test(&[Token::U16(0)], \"expected a non-zero value\");\n-    test(&[Token::U32(0)], \"expected a non-zero value\");\n-    test(&[Token::U64(0)], \"expected a non-zero value\");\n+    test(\n+        &[Token::I8(0)],\n+        \"invalid value: integer `0`, expected a nonzero i16\",\n+    );\n+    test(\n+        &[Token::I16(0)],\n+        \"invalid value: integer `0`, expected a nonzero i16\",\n+    );\n+    test(\n+        &[Token::I32(0)],\n+        \"invalid value: integer `0`, expected a nonzero i16\",\n+    );\n+    test(\n+        &[Token::I64(0)],\n+        \"invalid value: integer `0`, expected a nonzero i16\",\n+    );\n+    test(\n+        &[Token::U8(0)],\n+        \"invalid value: integer `0`, expected a nonzero i16\",\n+    );\n+    test(\n+        &[Token::U16(0)],\n+        \"invalid value: integer `0`, expected a nonzero i16\",\n+    );\n+    test(\n+        &[Token::U32(0)],\n+        \"invalid value: integer `0`, expected a nonzero i16\",\n+    );\n+    test(\n+        &[Token::U64(0)],\n+        \"invalid value: integer `0`, expected a nonzero i16\",\n+    );\n \n     // from signed\n     test(\n         &[Token::I32(-32769)],\n-        \"invalid value: integer `-32769`, expected i16\",\n+        \"invalid value: integer `-32769`, expected a nonzero i16\",\n     );\n     test(\n         &[Token::I64(-32769)],\n-        \"invalid value: integer `-32769`, expected i16\",\n+        \"invalid value: integer `-32769`, expected a nonzero i16\",\n     );\n     test(\n         &[Token::I32(32768)],\n-        \"invalid value: integer `32768`, expected i16\",\n+        \"invalid value: integer `32768`, expected a nonzero i16\",\n     );\n     test(\n         &[Token::I64(32768)],\n-        \"invalid value: integer `32768`, expected i16\",\n+        \"invalid value: integer `32768`, expected a nonzero i16\",\n     );\n \n     // from unsigned\n     test(\n         &[Token::U16(32768)],\n-        \"invalid value: integer `32768`, expected i16\",\n+        \"invalid value: integer `32768`, expected a nonzero i16\",\n     );\n     test(\n         &[Token::U32(32768)],\n-        \"invalid value: integer `32768`, expected i16\",\n+        \"invalid value: integer `32768`, expected a nonzero i16\",\n     );\n     test(\n         &[Token::U64(32768)],\n-        \"invalid value: integer `32768`, expected i16\",\n+        \"invalid value: integer `32768`, expected a nonzero i16\",\n     );\n }\n \n@@ -485,33 +533,57 @@ fn test_nonzero_i32() {\n     let test = assert_de_tokens_error::<NonZeroI32>;\n \n     // from zero\n-    test(&[Token::I8(0)], \"expected a non-zero value\");\n-    test(&[Token::I16(0)], \"expected a non-zero value\");\n-    test(&[Token::I32(0)], \"expected a non-zero value\");\n-    test(&[Token::I64(0)], \"expected a non-zero value\");\n-    test(&[Token::U8(0)], \"expected a non-zero value\");\n-    test(&[Token::U16(0)], \"expected a non-zero value\");\n-    test(&[Token::U32(0)], \"expected a non-zero value\");\n-    test(&[Token::U64(0)], \"expected a non-zero value\");\n+    test(\n+        &[Token::I8(0)],\n+        \"invalid value: integer `0`, expected a nonzero i32\",\n+    );\n+    test(\n+        &[Token::I16(0)],\n+        \"invalid value: integer `0`, expected a nonzero i32\",\n+    );\n+    test(\n+        &[Token::I32(0)],\n+        \"invalid value: integer `0`, expected a nonzero i32\",\n+    );\n+    test(\n+        &[Token::I64(0)],\n+        \"invalid value: integer `0`, expected a nonzero i32\",\n+    );\n+    test(\n+        &[Token::U8(0)],\n+        \"invalid value: integer `0`, expected a nonzero i32\",\n+    );\n+    test(\n+        &[Token::U16(0)],\n+        \"invalid value: integer `0`, expected a nonzero i32\",\n+    );\n+    test(\n+        &[Token::U32(0)],\n+        \"invalid value: integer `0`, expected a nonzero i32\",\n+    );\n+    test(\n+        &[Token::U64(0)],\n+        \"invalid value: integer `0`, expected a nonzero i32\",\n+    );\n \n     // from signed\n     test(\n         &[Token::I64(-2147483649)],\n-        \"invalid value: integer `-2147483649`, expected i32\",\n+        \"invalid value: integer `-2147483649`, expected a nonzero i32\",\n     );\n     test(\n         &[Token::I64(2147483648)],\n-        \"invalid value: integer `2147483648`, expected i32\",\n+        \"invalid value: integer `2147483648`, expected a nonzero i32\",\n     );\n \n     // from unsigned\n     test(\n         &[Token::U32(2147483648)],\n-        \"invalid value: integer `2147483648`, expected i32\",\n+        \"invalid value: integer `2147483648`, expected a nonzero i32\",\n     );\n     test(\n         &[Token::U64(2147483648)],\n-        \"invalid value: integer `2147483648`, expected i32\",\n+        \"invalid value: integer `2147483648`, expected a nonzero i32\",\n     );\n }\n \n@@ -520,19 +592,43 @@ fn test_nonzero_i64() {\n     let test = assert_de_tokens_error::<NonZeroI64>;\n \n     // from zero\n-    test(&[Token::I8(0)], \"expected a non-zero value\");\n-    test(&[Token::I16(0)], \"expected a non-zero value\");\n-    test(&[Token::I32(0)], \"expected a non-zero value\");\n-    test(&[Token::I64(0)], \"expected a non-zero value\");\n-    test(&[Token::U8(0)], \"expected a non-zero value\");\n-    test(&[Token::U16(0)], \"expected a non-zero value\");\n-    test(&[Token::U32(0)], \"expected a non-zero value\");\n-    test(&[Token::U64(0)], \"expected a non-zero value\");\n+    test(\n+        &[Token::I8(0)],\n+        \"invalid value: integer `0`, expected a nonzero i64\",\n+    );\n+    test(\n+        &[Token::I16(0)],\n+        \"invalid value: integer `0`, expected a nonzero i64\",\n+    );\n+    test(\n+        &[Token::I32(0)],\n+        \"invalid value: integer `0`, expected a nonzero i64\",\n+    );\n+    test(\n+        &[Token::I64(0)],\n+        \"invalid value: integer `0`, expected a nonzero i64\",\n+    );\n+    test(\n+        &[Token::U8(0)],\n+        \"invalid value: integer `0`, expected a nonzero i64\",\n+    );\n+    test(\n+        &[Token::U16(0)],\n+        \"invalid value: integer `0`, expected a nonzero i64\",\n+    );\n+    test(\n+        &[Token::U32(0)],\n+        \"invalid value: integer `0`, expected a nonzero i64\",\n+    );\n+    test(\n+        &[Token::U64(0)],\n+        \"invalid value: integer `0`, expected a nonzero i64\",\n+    );\n \n     // from unsigned\n     test(\n         &[Token::U64(9223372036854775808)],\n-        \"invalid value: integer `9223372036854775808`, expected i64\",\n+        \"invalid value: integer `9223372036854775808`, expected a nonzero i64\",\n     );\n }\n \n@@ -541,14 +637,38 @@ fn test_nonzero_i128() {\n     let test = assert_de_tokens_error::<NonZeroI128>;\n \n     // from zero\n-    test(&[Token::I8(0)], \"expected a non-zero value\");\n-    test(&[Token::I16(0)], \"expected a non-zero value\");\n-    test(&[Token::I32(0)], \"expected a non-zero value\");\n-    test(&[Token::I64(0)], \"expected a non-zero value\");\n-    test(&[Token::U8(0)], \"expected a non-zero value\");\n-    test(&[Token::U16(0)], \"expected a non-zero value\");\n-    test(&[Token::U32(0)], \"expected a non-zero value\");\n-    test(&[Token::U64(0)], \"expected a non-zero value\");\n+    test(\n+        &[Token::I8(0)],\n+        \"invalid value: integer `0`, expected a nonzero i128\",\n+    );\n+    test(\n+        &[Token::I16(0)],\n+        \"invalid value: integer `0`, expected a nonzero i128\",\n+    );\n+    test(\n+        &[Token::I32(0)],\n+        \"invalid value: integer `0`, expected a nonzero i128\",\n+    );\n+    test(\n+        &[Token::I64(0)],\n+        \"invalid value: integer `0`, expected a nonzero i128\",\n+    );\n+    test(\n+        &[Token::U8(0)],\n+        \"invalid value: integer `0`, expected a nonzero i128\",\n+    );\n+    test(\n+        &[Token::U16(0)],\n+        \"invalid value: integer `0`, expected a nonzero i128\",\n+    );\n+    test(\n+        &[Token::U32(0)],\n+        \"invalid value: integer `0`, expected a nonzero i128\",\n+    );\n+    test(\n+        &[Token::U64(0)],\n+        \"invalid value: integer `0`, expected a nonzero i128\",\n+    );\n }\n \n #[test]\n@@ -556,14 +676,38 @@ fn test_nonzero_isize() {\n     let test = assert_de_tokens_error::<NonZeroIsize>;\n \n     // from zero\n-    test(&[Token::I8(0)], \"expected a non-zero value\");\n-    test(&[Token::I16(0)], \"expected a non-zero value\");\n-    test(&[Token::I32(0)], \"expected a non-zero value\");\n-    test(&[Token::I64(0)], \"expected a non-zero value\");\n-    test(&[Token::U8(0)], \"expected a non-zero value\");\n-    test(&[Token::U16(0)], \"expected a non-zero value\");\n-    test(&[Token::U32(0)], \"expected a non-zero value\");\n-    test(&[Token::U64(0)], \"expected a non-zero value\");\n+    test(\n+        &[Token::I8(0)],\n+        \"invalid value: integer `0`, expected a nonzero isize\",\n+    );\n+    test(\n+        &[Token::I16(0)],\n+        \"invalid value: integer `0`, expected a nonzero isize\",\n+    );\n+    test(\n+        &[Token::I32(0)],\n+        \"invalid value: integer `0`, expected a nonzero isize\",\n+    );\n+    test(\n+        &[Token::I64(0)],\n+        \"invalid value: integer `0`, expected a nonzero isize\",\n+    );\n+    test(\n+        &[Token::U8(0)],\n+        \"invalid value: integer `0`, expected a nonzero isize\",\n+    );\n+    test(\n+        &[Token::U16(0)],\n+        \"invalid value: integer `0`, expected a nonzero isize\",\n+    );\n+    test(\n+        &[Token::U32(0)],\n+        \"invalid value: integer `0`, expected a nonzero isize\",\n+    );\n+    test(\n+        &[Token::U64(0)],\n+        \"invalid value: integer `0`, expected a nonzero isize\",\n+    );\n }\n \n #[test]\n@@ -571,54 +715,81 @@ fn test_nonzero_u8() {\n     let test = assert_de_tokens_error::<NonZeroU8>;\n \n     // from zero\n-    test(&[Token::I8(0)], \"expected a non-zero value\");\n-    test(&[Token::I16(0)], \"expected a non-zero value\");\n-    test(&[Token::I32(0)], \"expected a non-zero value\");\n-    test(&[Token::I64(0)], \"expected a non-zero value\");\n-    test(&[Token::U8(0)], \"expected a non-zero value\");\n-    test(&[Token::U16(0)], \"expected a non-zero value\");\n-    test(&[Token::U32(0)], \"expected a non-zero value\");\n-    test(&[Token::U64(0)], \"expected a non-zero value\");\n+    test(\n+        &[Token::I8(0)],\n+        \"invalid value: integer `0`, expected a nonzero u8\",\n+    );\n+    test(\n+        &[Token::I16(0)],\n+        \"invalid value: integer `0`, expected a nonzero u8\",\n+    );\n+    test(\n+        &[Token::I32(0)],\n+        \"invalid value: integer `0`, expected a nonzero u8\",\n+    );\n+    test(\n+        &[Token::I64(0)],\n+        \"invalid value: integer `0`, expected a nonzero u8\",\n+    );\n+    test(\n+        &[Token::U8(0)],\n+        \"invalid value: integer `0`, expected a nonzero u8\",\n+    );\n+    test(\n+        &[Token::U16(0)],\n+        \"invalid value: integer `0`, expected a nonzero u8\",\n+    );\n+    test(\n+        &[Token::U32(0)],\n+        \"invalid value: integer `0`, expected a nonzero u8\",\n+    );\n+    test(\n+        &[Token::U64(0)],\n+        \"invalid value: integer `0`, expected a nonzero u8\",\n+    );\n \n     // from signed\n-    test(&[Token::I8(-1)], \"invalid value: integer `-1`, expected u8\");\n+    test(\n+        &[Token::I8(-1)],\n+        \"invalid value: integer `-1`, expected a nonzero u8\",\n+    );\n     test(\n         &[Token::I16(-1)],\n-        \"invalid value: integer `-1`, expected u8\",\n+        \"invalid value: integer `-1`, expected a nonzero u8\",\n     );\n     test(\n         &[Token::I32(-1)],\n-        \"invalid value: integer `-1`, expected u8\",\n+        \"invalid value: integer `-1`, expected a nonzero u8\",\n     );\n     test(\n         &[Token::I64(-1)],\n-        \"invalid value: integer `-1`, expected u8\",\n+        \"invalid value: integer `-1`, expected a nonzero u8\",\n     );\n     test(\n         &[Token::I16(256)],\n-        \"invalid value: integer `256`, expected u8\",\n+        \"invalid value: integer `256`, expected a nonzero u8\",\n     );\n     test(\n         &[Token::I32(256)],\n-        \"invalid value: integer `256`, expected u8\",\n+        \"invalid value: integer `256`, expected a nonzero u8\",\n     );\n     test(\n         &[Token::I64(256)],\n-        \"invalid value: integer `256`, expected u8\",\n+        \"invalid value: integer `256`, expected a nonzero u8\",\n     );\n \n     // from unsigned\n     test(\n         &[Token::U16(256)],\n-        \"invalid value: integer `256`, expected u8\",\n+        \"invalid value: integer `256`, expected a nonzero u8\",\n     );\n     test(\n         &[Token::U32(256)],\n-        \"invalid value: integer `256`, expected u8\",\n+        \"invalid value: integer `256`, expected a nonzero u8\",\n     );\n     test(\n         &[Token::U64(256)],\n-        \"invalid value: integer `256`, expected u8\",\n+        \"invalid value: integer `256`, expected a nonzero u8\",\n     );\n }\n \n@@ -627,49 +798,73 @@ fn test_nonzero_u16() {\n     let test = assert_de_tokens_error::<NonZeroU16>;\n \n     // from zero\n-    test(&[Token::I8(0)], \"expected a non-zero value\");\n-    test(&[Token::I16(0)], \"expected a non-zero value\");\n-    test(&[Token::I32(0)], \"expected a non-zero value\");\n-    test(&[Token::I64(0)], \"expected a non-zero value\");\n-    test(&[Token::U8(0)], \"expected a non-zero value\");\n-    test(&[Token::U16(0)], \"expected a non-zero value\");\n-    test(&[Token::U32(0)], \"expected a non-zero value\");\n-    test(&[Token::U64(0)], \"expected a non-zero value\");\n+    test(\n+        &[Token::I8(0)],\n+        \"invalid value: integer `0`, expected a nonzero u16\",\n+    );\n+    test(\n+        &[Token::I16(0)],\n+        \"invalid value: integer `0`, expected a nonzero u16\",\n+    );\n+    test(\n+        &[Token::I32(0)],\n+        \"invalid value: integer `0`, expected a nonzero u16\",\n+    );\n+    test(\n+        &[Token::I64(0)],\n+        \"invalid value: integer `0`, expected a nonzero u16\",\n+    );\n+    test(\n+        &[Token::U8(0)],\n+        \"invalid value: integer `0`, expected a nonzero u16\",\n+    );\n+    test(\n+        &[Token::U16(0)],\n+        \"invalid value: integer `0`, expected a nonzero u16\",\n+    );\n+    test(\n+        &[Token::U32(0)],\n+        \"invalid value: integer `0`, expected a nonzero u16\",\n+    );\n+    test(\n+        &[Token::U64(0)],\n+        \"invalid value: integer `0`, expected a nonzero u16\",\n+    );\n \n     // from signed\n     test(\n         &[Token::I8(-1)],\n-        \"invalid value: integer `-1`, expected u16\",\n+        \"invalid value: integer `-1`, expected a nonzero u16\",\n     );\n     test(\n         &[Token::I16(-1)],\n-        \"invalid value: integer `-1`, expected u16\",\n+        \"invalid value: integer `-1`, expected a nonzero u16\",\n     );\n     test(\n         &[Token::I32(-1)],\n-        \"invalid value: integer `-1`, expected u16\",\n+        \"invalid value: integer `-1`, expected a nonzero u16\",\n     );\n     test(\n         &[Token::I64(-1)],\n-        \"invalid value: integer `-1`, expected u16\",\n+        \"invalid value: integer `-1`, expected a nonzero u16\",\n     );\n     test(\n         &[Token::I32(65536)],\n-        \"invalid value: integer `65536`, expected u16\",\n+        \"invalid value: integer `65536`, expected a nonzero u16\",\n     );\n     test(\n         &[Token::I64(65536)],\n-        \"invalid value: integer `65536`, expected u16\",\n+        \"invalid value: integer `65536`, expected a nonzero u16\",\n     );\n \n     // from unsigned\n     test(\n         &[Token::U32(65536)],\n-        \"invalid value: integer `65536`, expected u16\",\n+        \"invalid value: integer `65536`, expected a nonzero u16\",\n     );\n     test(\n         &[Token::U64(65536)],\n-        \"invalid value: integer `65536`, expected u16\",\n+        \"invalid value: integer `65536`, expected a nonzero u16\",\n     );\n }\n \n@@ -678,41 +873,65 @@ fn test_nonzero_u32() {\n     let test = assert_de_tokens_error::<NonZeroU32>;\n \n     // from zero\n-    test(&[Token::I8(0)], \"expected a non-zero value\");\n-    test(&[Token::I16(0)], \"expected a non-zero value\");\n-    test(&[Token::I32(0)], \"expected a non-zero value\");\n-    test(&[Token::I64(0)], \"expected a non-zero value\");\n-    test(&[Token::U8(0)], \"expected a non-zero value\");\n-    test(&[Token::U16(0)], \"expected a non-zero value\");\n-    test(&[Token::U32(0)], \"expected a non-zero value\");\n-    test(&[Token::U64(0)], \"expected a non-zero value\");\n+    test(\n+        &[Token::I8(0)],\n+        \"invalid value: integer `0`, expected a nonzero u32\",\n+    );\n+    test(\n+        &[Token::I16(0)],\n+        \"invalid value: integer `0`, expected a nonzero u32\",\n+    );\n+    test(\n+        &[Token::I32(0)],\n+        \"invalid value: integer `0`, expected a nonzero u32\",\n+    );\n+    test(\n+        &[Token::I64(0)],\n+        \"invalid value: integer `0`, expected a nonzero u32\",\n+    );\n+    test(\n+        &[Token::U8(0)],\n+        \"invalid value: integer `0`, expected a nonzero u32\",\n+    );\n+    test(\n+        &[Token::U16(0)],\n+        \"invalid value: integer `0`, expected a nonzero u32\",\n+    );\n+    test(\n+        &[Token::U32(0)],\n+        \"invalid value: integer `0`, expected a nonzero u32\",\n+    );\n+    test(\n+        &[Token::U64(0)],\n+        \"invalid value: integer `0`, expected a nonzero u32\",\n+    );\n \n     // from signed\n     test(\n         &[Token::I8(-1)],\n-        \"invalid value: integer `-1`, expected u32\",\n+        \"invalid value: integer `-1`, expected a nonzero u32\",\n     );\n     test(\n         &[Token::I16(-1)],\n-        \"invalid value: integer `-1`, expected u32\",\n+        \"invalid value: integer `-1`, expected a nonzero u32\",\n     );\n     test(\n         &[Token::I32(-1)],\n-        \"invalid value: integer `-1`, expected u32\",\n+        \"invalid value: integer `-1`, expected a nonzero u32\",\n     );\n     test(\n         &[Token::I64(-1)],\n-        \"invalid value: integer `-1`, expected u32\",\n+        \"invalid value: integer `-1`, expected a nonzero u32\",\n     );\n     test(\n         &[Token::I64(4294967296)],\n-        \"invalid value: integer `4294967296`, expected u32\",\n+        \"invalid value: integer `4294967296`, expected a nonzero u32\",\n     );\n \n     // from unsigned\n     test(\n         &[Token::U64(4294967296)],\n-        \"invalid value: integer `4294967296`, expected u32\",\n+        \"invalid value: integer `4294967296`, expected a nonzero u32\",\n     );\n }\n \n@@ -721,31 +940,55 @@ fn test_nonzero_u64() {\n     let test = assert_de_tokens_error::<NonZeroU64>;\n \n     // from zero\n-    test(&[Token::I8(0)], \"expected a non-zero value\");\n-    test(&[Token::I16(0)], \"expected a non-zero value\");\n-    test(&[Token::I32(0)], \"expected a non-zero value\");\n-    test(&[Token::I64(0)], \"expected a non-zero value\");\n-    test(&[Token::U8(0)], \"expected a non-zero value\");\n-    test(&[Token::U16(0)], \"expected a non-zero value\");\n-    test(&[Token::U32(0)], \"expected a non-zero value\");\n-    test(&[Token::U64(0)], \"expected a non-zero value\");\n+    test(\n+        &[Token::I8(0)],\n+        \"invalid value: integer `0`, expected a nonzero u64\",\n+    );\n+    test(\n+        &[Token::I16(0)],\n+        \"invalid value: integer `0`, expected a nonzero u64\",\n+    );\n+    test(\n+        &[Token::I32(0)],\n+        \"invalid value: integer `0`, expected a nonzero u64\",\n+    );\n+    test(\n+        &[Token::I64(0)],\n+        \"invalid value: integer `0`, expected a nonzero u64\",\n+    );\n+    test(\n+        &[Token::U8(0)],\n+        \"invalid value: integer `0`, expected a nonzero u64\",\n+    );\n+    test(\n+        &[Token::U16(0)],\n+        \"invalid value: integer `0`, expected a nonzero u64\",\n+    );\n+    test(\n+        &[Token::U32(0)],\n+        \"invalid value: integer `0`, expected a nonzero u64\",\n+    );\n+    test(\n+        &[Token::U64(0)],\n+        \"invalid value: integer `0`, expected a nonzero u64\",\n+    );\n \n     // from signed\n     test(\n         &[Token::I8(-1)],\n-        \"invalid value: integer `-1`, expected u64\",\n+        \"invalid value: integer `-1`, expected a nonzero u64\",\n     );\n     test(\n         &[Token::I16(-1)],\n-        \"invalid value: integer `-1`, expected u64\",\n+        \"invalid value: integer `-1`, expected a nonzero u64\",\n     );\n     test(\n         &[Token::I32(-1)],\n-        \"invalid value: integer `-1`, expected u64\",\n+        \"invalid value: integer `-1`, expected a nonzero u64\",\n     );\n     test(\n         &[Token::I64(-1)],\n-        \"invalid value: integer `-1`, expected u64\",\n+        \"invalid value: integer `-1`, expected a nonzero u64\",\n     );\n }\n \n@@ -754,31 +997,55 @@ fn test_nonzero_u128() {\n     let test = assert_de_tokens_error::<NonZeroU128>;\n \n     // from zero\n-    test(&[Token::I8(0)], \"expected a non-zero value\");\n-    test(&[Token::I16(0)], \"expected a non-zero value\");\n-    test(&[Token::I32(0)], \"expected a non-zero value\");\n-    test(&[Token::I64(0)], \"expected a non-zero value\");\n-    test(&[Token::U8(0)], \"expected a non-zero value\");\n-    test(&[Token::U16(0)], \"expected a non-zero value\");\n-    test(&[Token::U32(0)], \"expected a non-zero value\");\n-    test(&[Token::U64(0)], \"expected a non-zero value\");\n+    test(\n+        &[Token::I8(0)],\n+        \"invalid value: integer `0`, expected a nonzero u128\",\n+    );\n+    test(\n+        &[Token::I16(0)],\n+        \"invalid value: integer `0`, expected a nonzero u128\",\n+    );\n+    test(\n+        &[Token::I32(0)],\n+        \"invalid value: integer `0`, expected a nonzero u128\",\n+    );\n+    test(\n+        &[Token::I64(0)],\n+        \"invalid value: integer `0`, expected a nonzero u128\",\n+    );\n+    test(\n+        &[Token::U8(0)],\n+        \"invalid value: integer `0`, expected a nonzero u128\",\n+    );\n+    test(\n+        &[Token::U16(0)],\n+        \"invalid value: integer `0`, expected a nonzero u128\",\n+    );\n+    test(\n+        &[Token::U32(0)],\n+        \"invalid value: integer `0`, expected a nonzero u128\",\n+    );\n+    test(\n+        &[Token::U64(0)],\n+        \"invalid value: integer `0`, expected a nonzero u128\",\n+    );\n \n     // from signed\n     test(\n         &[Token::I8(-1)],\n-        \"invalid value: integer `-1`, expected u128\",\n+        \"invalid value: integer `-1`, expected a nonzero u128\",\n     );\n     test(\n         &[Token::I16(-1)],\n-        \"invalid value: integer `-1`, expected u128\",\n+        \"invalid value: integer `-1`, expected a nonzero u128\",\n     );\n     test(\n         &[Token::I32(-1)],\n-        \"invalid value: integer `-1`, expected u128\",\n+        \"invalid value: integer `-1`, expected a nonzero u128\",\n     );\n     test(\n         &[Token::I64(-1)],\n-        \"invalid value: integer `-1`, expected u128\",\n+        \"invalid value: integer `-1`, expected a nonzero u128\",\n     );\n }\n \n@@ -787,31 +1054,55 @@ fn test_nonzero_usize() {\n     let test = assert_de_tokens_error::<NonZeroUsize>;\n \n     // from zero\n-    test(&[Token::I8(0)], \"expected a non-zero value\");\n-    test(&[Token::I16(0)], \"expected a non-zero value\");\n-    test(&[Token::I32(0)], \"expected a non-zero value\");\n-    test(&[Token::I64(0)], \"expected a non-zero value\");\n-    test(&[Token::U8(0)], \"expected a non-zero value\");\n-    test(&[Token::U16(0)], \"expected a non-zero value\");\n-    test(&[Token::U32(0)], \"expected a non-zero value\");\n-    test(&[Token::U64(0)], \"expected a non-zero value\");\n+    test(\n+        &[Token::I8(0)],\n+        \"invalid value: integer `0`, expected a nonzero usize\",\n+    );\n+    test(\n+        &[Token::I16(0)],\n+        \"invalid value: integer `0`, expected a nonzero usize\",\n+    );\n+    test(\n+        &[Token::I32(0)],\n+        \"invalid value: integer `0`, expected a nonzero usize\",\n+    );\n+    test(\n+        &[Token::I64(0)],\n+        \"invalid value: integer `0`, expected a nonzero usize\",\n+    );\n+    test(\n+        &[Token::U8(0)],\n+        \"invalid value: integer `0`, expected a nonzero usize\",\n+    );\n+    test(\n+        &[Token::U16(0)],\n+        \"invalid value: integer `0`, expected a nonzero usize\",\n+    );\n+    test(\n+        &[Token::U32(0)],\n+        \"invalid value: integer `0`, expected a nonzero usize\",\n+    );\n+    test(\n+        &[Token::U64(0)],\n+        \"invalid value: integer `0`, expected a nonzero usize\",\n+    );\n \n     // from signed\n     test(\n         &[Token::I8(-1)],\n-        \"invalid value: integer `-1`, expected usize\",\n+        \"invalid value: integer `-1`, expected a nonzero usize\",\n     );\n     test(\n         &[Token::I16(-1)],\n-        \"invalid value: integer `-1`, expected usize\",\n+        \"invalid value: integer `-1`, expected a nonzero usize\",\n     );\n     test(\n         &[Token::I32(-1)],\n-        \"invalid value: integer `-1`, expected usize\",\n+        \"invalid value: integer `-1`, expected a nonzero usize\",\n     );\n     test(\n         &[Token::I64(-1)],\n-        \"invalid value: integer `-1`, expected usize\",\n+        \"invalid value: integer `-1`, expected a nonzero usize\",\n     );\n }\n \n", "problem_statement": "Improve errors upon deserializing NonZero*\nDeserializing errors on NonZero* could definitely be improved, not sure if this is possible, but somehow the normal numerical  types have better information attached to them - is this fault of the wrappers - probably not.\r\n\r\n<details>\r\n  <summary> silly example code </summary>\r\n\r\n```\r\n#[derive(Deserialize)]\r\nstruct Example {\r\n    a: i32,\r\n    b: i32,\r\n    c: i32,\r\n    d: i32,\r\n    e: i32,\r\n    f: i32,\r\n    g: i32,\r\n    h: i32,\r\n    i: i32,\r\n    j: i32,\r\n    k: i32,\r\n    l: i32,\r\n    m: i32,\r\n    n: i32,\r\n    non_zero_usize: NonZeroUsize,\r\n    usize: usize,\r\n}\r\n\r\n#[derive(Deserialize)]\r\nstruct Parent {\r\n    example: Example,\r\n}\r\n\r\n#[test]\r\nfn test() {\r\n    let x = r#\"\r\nexample:\r\n  a: 0\r\n  b: 0\r\n  c: 0\r\n  d: 0\r\n  e: 0\r\n  f: 0\r\n  g: 0\r\n  h: 0\r\n  i: 0\r\n  j: 0\r\n  k: 0\r\n  l: 0\r\n  m: 0\r\n  n: 0\r\n  non_zero_usize: 1\r\n  usize: 1\r\n\"#;\r\n    let parsed: Parent = serde_yaml::from_str(x).unwrap();\r\n}\r\n```\r\n\r\n</details>\r\n\r\nWhen setting the non_zero_usize to '0' - misleading error.\r\n```\r\nexpected a non-zero value\", Some(Pos { marker: Marker { index: 13, line: 3, col: 3 }, path: \"example\" })\r\n```\r\n\r\nWhen setting the usize to '-1' - Nice error!\r\n```\r\n\"invalid value: integer `-1`, expected usize\", Some(Pos { marker: Marker { index: 137, line: 18, col: 9 }, path: \"example.usize\" })\r\n```\r\n\r\nAs you can passing zero to non_zero_usize causes serde not to deserialize as expected but errors are hard to diagnose.\r\nFollowing area could be improved:\r\n1) Path of the last node is swallowed, ( it says just example - unlike for usize where it says example.usize )\r\n2) The line is pointing at  god knows what confusing readers.\r\n\r\nWhen a person that has no access to the codebase encounters those errors it's almost impossible to guess what's the cause of the problem\r\n\n", "hints_text": "", "created_at": "2022-01-21T06:01:53Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 2079, "instance_id": "serde-rs__serde-2079", "issue_numbers": ["2078"], "base_commit": "55fdbea20bbcb0f0fa7e9545ec0ea10c87a6643d", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 0903a084c..7f4d7c441 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -36,7 +36,7 @@ pub fn expand_derive_deserialize(\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n         let vis = &input.vis;\n-        let used = pretend::pretend_used(&cont);\n+        let used = pretend::pretend_used(&cont, params.is_packed);\n         quote! {\n             impl #de_impl_generics #ident #ty_generics #where_clause {\n                 #vis fn deserialize<__D>(__deserializer: __D) -> #serde::__private::Result<#remote #ty_generics, __D::Error>\n@@ -125,6 +125,9 @@ struct Parameters {\n     /// At least one field has a serde(getter) attribute, implying that the\n     /// remote type has a private field.\n     has_getter: bool,\n+\n+    /// Type has a repr(packed) attribute.\n+    is_packed: bool,\n }\n \n impl Parameters {\n@@ -137,6 +140,7 @@ impl Parameters {\n         let borrowed = borrowed_lifetimes(cont);\n         let generics = build_generics(cont, &borrowed);\n         let has_getter = cont.data.has_getter();\n+        let is_packed = cont.attrs.is_packed();\n \n         Parameters {\n             local,\n@@ -144,6 +148,7 @@ impl Parameters {\n             generics,\n             borrowed,\n             has_getter,\n+            is_packed,\n         }\n     }\n \ndiff --git a/serde_derive/src/pretend.rs b/serde_derive/src/pretend.rs\nindex 955ce3d1c..7ec894446 100644\n--- a/serde_derive/src/pretend.rs\n+++ b/serde_derive/src/pretend.rs\n@@ -20,8 +20,8 @@ use internals::ast::{Container, Data, Field, Style};\n //     8 | enum EnumDef { V }\n //       |                ^\n //\n-pub fn pretend_used(cont: &Container) -> TokenStream {\n-    let pretend_fields = pretend_fields_used(cont);\n+pub fn pretend_used(cont: &Container, is_packed: bool) -> TokenStream {\n+    let pretend_fields = pretend_fields_used(cont, is_packed);\n     let pretend_variants = pretend_variants_used(cont);\n \n     quote! {\n@@ -48,7 +48,7 @@ pub fn pretend_used(cont: &Container) -> TokenStream {\n // The `ref` is important in case the user has written a Drop impl on their\n // type. Rust does not allow destructuring a struct or enum that has a Drop\n // impl.\n-fn pretend_fields_used(cont: &Container) -> TokenStream {\n+fn pretend_fields_used(cont: &Container, is_packed: bool) -> TokenStream {\n     let type_ident = &cont.ident;\n     let (_, ty_generics, _) = cont.generics.split_for_impl();\n \n@@ -58,14 +58,14 @@ fn pretend_fields_used(cont: &Container) -> TokenStream {\n             .filter_map(|variant| match variant.style {\n                 Style::Struct => {\n                     let variant_ident = &variant.ident;\n-                    let pat = struct_pattern(&variant.fields);\n+                    let pat = struct_pattern(&variant.fields, is_packed);\n                     Some(quote!(#type_ident::#variant_ident #pat))\n                 }\n                 _ => None,\n             })\n             .collect::<Vec<_>>(),\n         Data::Struct(Style::Struct, fields) => {\n-            let pat = struct_pattern(fields);\n+            let pat = struct_pattern(fields, is_packed);\n             vec![quote!(#type_ident #pat)]\n         }\n         Data::Struct(_, _) => {\n@@ -132,9 +132,14 @@ fn pretend_variants_used(cont: &Container) -> TokenStream {\n     quote!(#(#cases)*)\n }\n \n-fn struct_pattern(fields: &[Field]) -> TokenStream {\n+fn struct_pattern(fields: &[Field], is_packed: bool) -> TokenStream {\n     let members = fields.iter().map(|field| &field.member);\n     let placeholders =\n         (0..fields.len()).map(|i| Ident::new(&format!(\"__v{}\", i), Span::call_site()));\n-    quote!({ #(#members: ref #placeholders),* })\n+    let take_reference = if is_packed {\n+        None\n+    } else {\n+        Some(quote!(ref))\n+    };\n+    quote!({ #(#members: #take_reference #placeholders),* })\n }\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 4f3e5ff08..529a20d79 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -30,7 +30,7 @@ pub fn expand_derive_serialize(\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n         let vis = &input.vis;\n-        let used = pretend::pretend_used(&cont);\n+        let used = pretend::pretend_used(&cont, params.is_packed);\n         quote! {\n             impl #impl_generics #ident #ty_generics #where_clause {\n                 #vis fn serialize<__S>(__self: &#remote #ty_generics, __serializer: __S) -> #serde::__private::Result<__S::Ok, __S::Error>\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 93d5cd3a5..3e19d3c4b 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -846,3 +846,19 @@ where\n {\n     T::deserialize(deserializer)\n }\n+\n+//////////////////////////////////////////////////////////////////////////\n+\n+#[repr(packed)]\n+pub struct RemotePacked {\n+    pub a: u8,\n+    pub b: u16,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[repr(packed)]\n+#[serde(remote = \"RemotePacked\")]\n+pub struct RemotePackedDef {\n+    a: u8,\n+    b: u16,\n+}\n", "problem_statement": "Unaligned reference warnings on packed structures\nI'm getting `unaligned_references` warnings using `serde_derive` on packed  structures.  From #1747 and #1813 it seems like this should have been fixed since these structures also impl's `Copy`.  \r\n\r\nHere's a minimal example that reproduces what I'm seeing w/ serde 1.0.127\r\n\r\n```rust\r\nuse serde;\r\n\r\nmod other {\r\n    #[repr(C, packed)]\r\n    #[derive(Debug, Copy, Clone, PartialEq, Default)]\r\n    pub struct paramval<'a> {\r\n        pub val_or_len: i32,\r\n        pub places: u8,\r\n        pub type_: u8,\r\n        pub buf: &'a [u8],\r\n    }\r\n}\r\n\r\n\r\n#[derive(serde::Serialize, serde::Deserialize)]\r\n#[serde(remote = \"other::paramval\")]\r\nstruct ParamVal<'a> {\r\n    val_or_len: i32,\r\n    places: u8,\r\n    type_: u8,\r\n    buf: &'a [u8]\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\n```shell\r\ncargo build\r\n \r\n\u28ff\r\nStandard Error\r\n\r\n   Compiling playground v0.0.1 (/playground)\r\nwarning: reference to packed field is unaligned\r\n  --> src/main.rs:15:10\r\n   |\r\n15 | #[derive(serde::Serialize, serde::Deserialize)]\r\n   |          ^^^^^^^^^^^^^^^^\r\n   |\r\n   = note: `#[warn(unaligned_references)]` on by default\r\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\r\n   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\r\n   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\r\n   = note: this warning originates in the derive macro `serde::Serialize` (in Nightly builds, run with -Z macro-backtrace for more info)\r\n\r\nwarning: reference to packed field is unaligned\r\n  --> src/main.rs:15:10\r\n   |\r\n15 | #[derive(serde::Serialize, serde::Deserialize)]\r\n   |          ^^^^^^^^^^^^^^^^\r\n   |\r\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\r\n   = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>\r\n   = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\r\n   = note: this warning originates in the derive macro `serde::Serialize` (in Nightly builds, run with -Z macro-backtrace for more info)\r\n\r\nwarning: struct is never constructed: `ParamVal`\r\n  --> src/main.rs:17:8\r\n   |\r\n17 | struct ParamVal<'a> {\r\n   |        ^^^^^^^^\r\n   |\r\n   = note: `#[warn(dead_code)]` on by default\r\n\r\nwarning: 3 warnings emitted\r\n\r\n    Finished dev [unoptimized + debuginfo] target(s) in 1.09s\r\n     Running `target/debug/playground`\r\n\r\n```\r\n[playground link](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0df4eb5c563283282805bce559ee0024)\r\n\r\nThe packed structures are generated using bindgen and represent data received via a serialport stream.  I could drop the `packed` repr generation in bindgen but that would prevent other users from using direct memory transmutes if they wanted to skip over the serde bindings.\r\n\n", "hints_text": "", "created_at": "2021-08-23T17:19:46Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1997, "instance_id": "serde-rs__serde-1997", "issue_numbers": ["1996"], "base_commit": "c26101532509477132721a8c56b7024891aaf1b4", "patch": "diff --git a/serde/build.rs b/serde/build.rs\nindex ca991a5d2..d9fd94074 100644\n--- a/serde/build.rs\n+++ b/serde/build.rs\n@@ -76,12 +76,14 @@ fn main() {\n         println!(\"cargo:rustc-cfg=serde_derive\");\n     }\n \n-    // TryFrom, Atomic types, and non-zero signed integers stabilized in Rust 1.34:\n+    // TryFrom, Atomic types, non-zero signed integers, and `SystemTime::checked_add`\n+    // stabilized in Rust 1.34:\n     // https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#tryfrom-and-tryinto\n     // https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html#library-stabilizations\n     if minor >= 34 {\n         println!(\"cargo:rustc-cfg=core_try_from\");\n         println!(\"cargo:rustc-cfg=num_nonzero_signed\");\n+        println!(\"cargo:rustc-cfg=systemtime_checked_add\");\n \n         // Whitelist of archs that support std::sync::atomic module. Ideally we\n         // would use #[cfg(target_has_atomic = \"...\")] but it is not stable yet.\ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 409f6cbc0..bd10f7fe7 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -2046,6 +2046,17 @@ impl<'de> Deserialize<'de> for SystemTime {\n             }\n         }\n \n+        fn check_overflow<E>(secs: u64, nanos: u32) -> Result<(), E>\n+        where\n+            E: Error,\n+        {\n+            static NANOS_PER_SEC: u32 = 1_000_000_000;\n+            match secs.checked_add((nanos / NANOS_PER_SEC) as u64) {\n+                Some(_) => Ok(()),\n+                None => Err(E::custom(\"overflow deserializing SystemTime epoch offset\")),\n+            }\n+        }\n+\n         struct DurationVisitor;\n \n         impl<'de> Visitor<'de> for DurationVisitor {\n@@ -2071,6 +2082,7 @@ impl<'de> Deserialize<'de> for SystemTime {\n                         return Err(Error::invalid_length(1, &self));\n                     }\n                 };\n+                try!(check_overflow(secs, nanos));\n                 Ok(Duration::new(secs, nanos))\n             }\n \n@@ -2108,13 +2120,20 @@ impl<'de> Deserialize<'de> for SystemTime {\n                     Some(nanos) => nanos,\n                     None => return Err(<A::Error as Error>::missing_field(\"nanos_since_epoch\")),\n                 };\n+                try!(check_overflow(secs, nanos));\n                 Ok(Duration::new(secs, nanos))\n             }\n         }\n \n         const FIELDS: &'static [&'static str] = &[\"secs_since_epoch\", \"nanos_since_epoch\"];\n         let duration = try!(deserializer.deserialize_struct(\"SystemTime\", FIELDS, DurationVisitor));\n-        Ok(UNIX_EPOCH + duration)\n+        #[cfg(systemtime_checked_add)]\n+        let ret = UNIX_EPOCH\n+            .checked_add(duration)\n+            .ok_or(D::Error::custom(\"overflow deserializing SystemTime\"));\n+        #[cfg(not(systemtime_checked_add))]\n+        let ret = Ok(UNIX_EPOCH + duration);\n+        ret\n     }\n }\n \n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex cb861374f..fb77f8d91 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -15,7 +15,7 @@ use std::sync::atomic::{\n     AtomicUsize, Ordering,\n };\n use std::sync::{Arc, Weak as ArcWeak};\n-use std::time::{Duration, UNIX_EPOCH};\n+use std::time::{Duration, SystemTime, UNIX_EPOCH};\n \n #[cfg(target_arch = \"x86_64\")]\n use std::sync::atomic::{AtomicI64, AtomicU64};\n@@ -199,6 +199,19 @@ macro_rules! declare_error_tests {\n                 assert_de_tokens_error::<$target>($tokens, $expected);\n             }\n         )+\n+    };\n+\n+    ($(\n+        $(#[$cfg:meta])*\n+        $name:ident<$target:ty> { $tokens:expr, $expected:expr, }\n+    )+) => {\n+        $(\n+            $(#[$cfg])*\n+            #[test]\n+            fn $name() {\n+                assert_de_tokens_error::<$target>($tokens, $expected);\n+            }\n+        )+\n     }\n }\n \n@@ -1614,4 +1627,35 @@ declare_error_tests! {\n         ],\n         \"overflow deserializing Duration\",\n     }\n+    test_systemtime_overflow_seq<SystemTime> {\n+        &[\n+            Token::Seq { len: Some(2) },\n+                Token::U64(u64::max_value()),\n+                Token::U32(1_000_000_000),\n+            Token::SeqEnd,\n+        ],\n+        \"overflow deserializing SystemTime epoch offset\",\n+    }\n+    test_systemtime_overflow_struct<SystemTime> {\n+        &[\n+            Token::Struct { name: \"SystemTime\", len: 2 },\n+                Token::Str(\"secs_since_epoch\"),\n+                Token::U64(u64::max_value()),\n+\n+                Token::Str(\"nanos_since_epoch\"),\n+                Token::U32(1_000_000_000),\n+            Token::StructEnd,\n+        ],\n+        \"overflow deserializing SystemTime epoch offset\",\n+    }\n+    #[cfg(systemtime_checked_add)]\n+    test_systemtime_overflow<SystemTime> {\n+        &[\n+            Token::Seq { len: Some(2) },\n+                Token::U64(u64::max_value()),\n+                Token::U32(0),\n+            Token::SeqEnd,\n+        ],\n+        \"overflow deserializing SystemTime\",\n+    }\n }\n", "problem_statement": "Serde panics when deserializing a malformed SystemTime\n`SystemTime` is deserialized by deserializing a duration and adding it to `UNIX_EPOCH`. The documentation states that this can panic `if the resulting point in time cannot be represented by the underlying data structure`.\r\n\r\nAlso, `SystemTime` panics in the same situations as described for `Duration` in #1993.\n", "hints_text": "", "created_at": "2021-03-06T01:17:16Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1970, "instance_id": "serde-rs__serde-1970", "issue_numbers": ["1969"], "base_commit": "b054ea41053ea4047882cc33970d2257cdfe04ac", "patch": "diff --git a/serde_derive/src/lib.rs b/serde_derive/src/lib.rs\nindex f10baac01..8d1464ec8 100644\n--- a/serde_derive/src/lib.rs\n+++ b/serde_derive/src/lib.rs\n@@ -79,8 +79,8 @@ mod try;\n \n #[proc_macro_derive(Serialize, attributes(serde))]\n pub fn derive_serialize(input: TokenStream) -> TokenStream {\n-    let input = parse_macro_input!(input as DeriveInput);\n-    ser::expand_derive_serialize(&input)\n+    let mut input = parse_macro_input!(input as DeriveInput);\n+    ser::expand_derive_serialize(&mut input)\n         .unwrap_or_else(to_compile_errors)\n         .into()\n }\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 91154dc6a..c663c3b02 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -6,10 +6,14 @@ use bound;\n use dummy;\n use fragment::{Fragment, Match, Stmts};\n use internals::ast::{Container, Data, Field, Style, Variant};\n-use internals::{attr, Ctxt, Derive};\n+use internals::{attr, replace_receiver, Ctxt, Derive};\n use pretend;\n \n-pub fn expand_derive_serialize(input: &syn::DeriveInput) -> Result<TokenStream, Vec<syn::Error>> {\n+pub fn expand_derive_serialize(\n+    input: &mut syn::DeriveInput,\n+) -> Result<TokenStream, Vec<syn::Error>> {\n+    replace_receiver(input);\n+\n     let ctxt = Ctxt::new();\n     let cont = match Container::from_ast(&ctxt, input, Derive::Serialize) {\n         Some(cont) => cont,\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 73f7fa50f..002885ead 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -7,6 +7,7 @@\n #![allow(\n     unknown_lints,\n     mixed_script_confusables,\n+    clippy::ptr_arg,\n     clippy::trivially_copy_pass_by_ref\n )]\n \n@@ -735,6 +736,12 @@ fn test_gen() {\n         #[serde(borrow = \"'a\")]\n         f: mac!(Cow<'a, str>),\n     }\n+\n+    #[derive(Serialize)]\n+    struct Struct {\n+        #[serde(serialize_with = \"vec_first_element\")]\n+        vec: Vec<Self>,\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////\n@@ -808,3 +815,11 @@ where\n pub fn is_zero(n: &u8) -> bool {\n     *n == 0\n }\n+\n+fn vec_first_element<T, S>(vec: &Vec<T>, serializer: S) -> StdResult<S::Ok, S::Error>\n+where\n+    T: Serialize,\n+    S: Serializer,\n+{\n+    vec.first().serialize(serializer)\n+}\n", "problem_statement": "`Self` does not work in a field with serialize_with\nClosely related to #1506, #1565, #1830.\r\n\r\n```rust\r\nuse serde::{Serialize, Serializer};\r\n\r\n#[derive(Serialize)]\r\nstruct Struct {\r\n    #[serde(serialize_with = \"vec_first_element\")]\r\n    vec: Vec<Self>,  // works if written as Vec<Struct>\r\n}\r\n\r\nfn vec_first_element<S>(vec: &Vec<Struct>, serializer: S) -> Result<S::Ok, S::Error>\r\nwhere\r\n    S: Serializer,\r\n{\r\n    vec.first().serialize(serializer)\r\n}\r\n```\r\n\r\n```console\r\nerror[E0308]: mismatched types\r\n --> src/main.rs:3:10\r\n  |\r\n3 | #[derive(Serialize)]\r\n  |          ^^^^^^^^^ expected struct `__SerializeWith`, found struct `Struct`\r\n  |\r\n  = note: expected reference `&Vec<__SerializeWith<'_>>`\r\n             found reference `&Vec<Struct>`\r\n  = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\r\n\r\nerror[E0308]: mismatched types\r\n --> src/main.rs:3:10\r\n  |\r\n3 | #[derive(Serialize)]\r\n  |          ^^^^^^^^^ expected struct `Struct`, found struct `__SerializeWith`\r\n  |\r\n  = note: expected reference `&Vec<Struct>`\r\n             found reference `&'__a Vec<__SerializeWith<'__a>>`\r\n  = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\r\n```\n", "hints_text": "", "created_at": "2021-01-25T21:27:57Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1961, "instance_id": "serde-rs__serde-1961", "issue_numbers": ["1928"], "base_commit": "eaccae2c464eb096c115be38a1930539f5698ce3", "patch": "diff --git a/serde_derive/src/internals/case.rs b/serde_derive/src/internals/case.rs\nindex 199fd4bcb..554505160 100644\n--- a/serde_derive/src/internals/case.rs\n+++ b/serde_derive/src/internals/case.rs\n@@ -5,7 +5,7 @@\n #[allow(deprecated, unused_imports)]\n use std::ascii::AsciiExt;\n \n-use std::fmt::{self, Display};\n+use std::fmt::{self, Debug, Display};\n \n use self::RenameRule::*;\n \n@@ -120,11 +120,16 @@ pub struct ParseError<'a> {\n \n impl<'a> Display for ParseError<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(\n-            f,\n-            \"unknown rename rule for #[serde(rename_all = {:?})]\",\n-            self.unknown,\n-        )\n+        f.write_str(\"unknown rename rule `rename_all = \")?;\n+        Debug::fmt(self.unknown, f)?;\n+        f.write_str(\"`, expected one of \")?;\n+        for (i, (name, _rule)) in RENAME_RULES.iter().enumerate() {\n+            if i > 0 {\n+                f.write_str(\", \")?;\n+            }\n+            Debug::fmt(name, f)?;\n+        }\n+        Ok(())\n     }\n }\n \n", "test_patch": "diff --git a/test_suite/tests/ui/rename/container_unknown_rename_rule.stderr b/test_suite/tests/ui/rename/container_unknown_rename_rule.stderr\nindex 728d71ca2..3fd68f3f3 100644\n--- a/test_suite/tests/ui/rename/container_unknown_rename_rule.stderr\n+++ b/test_suite/tests/ui/rename/container_unknown_rename_rule.stderr\n@@ -1,4 +1,4 @@\n-error: unknown rename rule for #[serde(rename_all = \"abc\")]\n+error: unknown rename rule `rename_all = \"abc\"`, expected one of \"lowercase\", \"UPPERCASE\", \"PascalCase\", \"camelCase\", \"snake_case\", \"SCREAMING_SNAKE_CASE\", \"kebab-case\", \"SCREAMING-KEBAB-CASE\"\n  --> $DIR/container_unknown_rename_rule.rs:4:22\n   |\n 4 | #[serde(rename_all = \"abc\")]\ndiff --git a/test_suite/tests/ui/rename/variant_unknown_rename_rule.stderr b/test_suite/tests/ui/rename/variant_unknown_rename_rule.stderr\nindex 7a52f37a8..48f53f893 100644\n--- a/test_suite/tests/ui/rename/variant_unknown_rename_rule.stderr\n+++ b/test_suite/tests/ui/rename/variant_unknown_rename_rule.stderr\n@@ -1,4 +1,4 @@\n-error: unknown rename rule for #[serde(rename_all = \"abc\")]\n+error: unknown rename rule `rename_all = \"abc\"`, expected one of \"lowercase\", \"UPPERCASE\", \"PascalCase\", \"camelCase\", \"snake_case\", \"SCREAMING_SNAKE_CASE\", \"kebab-case\", \"SCREAMING-KEBAB-CASE\"\n  --> $DIR/variant_unknown_rename_rule.rs:5:26\n   |\n 5 |     #[serde(rename_all = \"abc\")]\n", "problem_statement": "add a list of possible rename rules upon an error\nAn implementation of https://github.com/serde-rs/serde/issues/1923\n", "hints_text": "", "created_at": "2021-01-23T22:42:17Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1958, "instance_id": "serde-rs__serde-1958", "issue_numbers": ["1933"], "base_commit": "398fba9b1ee6d27a2e556f8d6cd6d1a82315ee9a", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex fd77ddf1f..7f0b5d907 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -1849,6 +1849,17 @@ impl<'de> Deserialize<'de> for Duration {\n             }\n         }\n \n+        fn check_overflow<E>(secs: u64, nanos: u32) -> Result<(), E>\n+        where\n+            E: Error,\n+        {\n+            static NANOS_PER_SEC: u32 = 1_000_000_000;\n+            match secs.checked_add((nanos / NANOS_PER_SEC) as u64) {\n+                Some(_) => Ok(()),\n+                None => Err(E::custom(\"overflow deserializing Duration\")),\n+            }\n+        }\n+\n         struct DurationVisitor;\n \n         impl<'de> Visitor<'de> for DurationVisitor {\n@@ -1874,6 +1885,7 @@ impl<'de> Deserialize<'de> for Duration {\n                         return Err(Error::invalid_length(1, &self));\n                     }\n                 };\n+                try!(check_overflow(secs, nanos));\n                 Ok(Duration::new(secs, nanos))\n             }\n \n@@ -1907,6 +1919,7 @@ impl<'de> Deserialize<'de> for Duration {\n                     Some(nanos) => nanos,\n                     None => return Err(<A::Error as Error>::missing_field(\"nanos\")),\n                 };\n+                try!(check_overflow(secs, nanos));\n                 Ok(Duration::new(secs, nanos))\n             }\n         }\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 025d87b09..a0261bd35 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -1452,4 +1452,25 @@ declare_error_tests! {\n         ],\n         \"invalid value: integer `65536`, expected u16\",\n     }\n+    test_duration_overflow_seq<Duration> {\n+        &[\n+            Token::Seq { len: Some(2) },\n+                Token::U64(u64::max_value()),\n+                Token::U32(1_000_000_000),\n+            Token::SeqEnd,\n+        ],\n+        \"overflow deserializing Duration\",\n+    }\n+    test_duration_overflow_struct<Duration> {\n+        &[\n+            Token::Struct { name: \"Duration\", len: 2 },\n+                Token::Str(\"secs\"),\n+                Token::U64(u64::max_value()),\n+\n+                Token::Str(\"nanos\"),\n+                Token::U32(1_000_000_000),\n+            Token::StructEnd,\n+        ],\n+        \"overflow deserializing Duration\",\n+    }\n }\n", "problem_statement": "Serde panics when deserializing malformed Duration\nThe documentation for `std::time::Duration::new` states that it panics if `nanos` overflows and causes `secs` to overflow.\n\nThis should cause a deserialization error instead of causing the application to panic.\n", "hints_text": "", "created_at": "2021-01-20T19:48:24Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1916, "instance_id": "serde-rs__serde-1916", "issue_numbers": ["1883"], "base_commit": "8084258a3edc1dc4007e8df7f24b022d015b5fb0", "patch": "diff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex bcb964a9c..e3b685e88 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -824,15 +824,17 @@ mod content {\n     /// Not public API.\n     pub struct TaggedContentVisitor<'de, T> {\n         tag_name: &'static str,\n+        expecting: &'static str,\n         value: PhantomData<TaggedContent<'de, T>>,\n     }\n \n     impl<'de, T> TaggedContentVisitor<'de, T> {\n         /// Visitor for the content of an internally tagged enum with the given\n         /// tag name.\n-        pub fn new(name: &'static str) -> Self {\n+        pub fn new(name: &'static str, expecting: &'static str) -> Self {\n             TaggedContentVisitor {\n                 tag_name: name,\n+                expecting: expecting,\n                 value: PhantomData,\n             }\n         }\n@@ -861,7 +863,7 @@ mod content {\n         type Value = TaggedContent<'de, T>;\n \n         fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-            fmt.write_str(\"internally tagged enum\")\n+            fmt.write_str(self.expecting)\n         }\n \n         fn visit_seq<S>(self, mut seq: S) -> Result<Self::Value, S::Error>\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 1f5733a6d..071db57bc 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -399,6 +399,7 @@ fn deserialize_unit_struct(params: &Parameters, cattrs: &attr::Container) -> Fra\n     let type_name = cattrs.name().deserialize_name();\n \n     let expecting = format!(\"unit struct {}\", params.type_name());\n+    let expecting = cattrs.expecting().unwrap_or(&expecting);\n \n     quote_block! {\n         struct __Visitor;\n@@ -456,6 +457,7 @@ fn deserialize_tuple(\n         Some(variant_ident) => format!(\"tuple variant {}::{}\", params.type_name(), variant_ident),\n         None => format!(\"tuple struct {}\", params.type_name()),\n     };\n+    let expecting = cattrs.expecting().unwrap_or(&expecting);\n \n     let nfields = fields.len();\n \n@@ -542,6 +544,7 @@ fn deserialize_tuple_in_place(\n         Some(variant_ident) => format!(\"tuple variant {}::{}\", params.type_name(), variant_ident),\n         None => format!(\"tuple struct {}\", params.type_name()),\n     };\n+    let expecting = cattrs.expecting().unwrap_or(&expecting);\n \n     let nfields = fields.len();\n \n@@ -630,6 +633,7 @@ fn deserialize_seq(\n     } else {\n         format!(\"{} with {} elements\", expecting, deserialized_count)\n     };\n+    let expecting = cattrs.expecting().unwrap_or(&expecting);\n \n     let mut index_in_seq = 0_usize;\n     let let_values = vars.clone().zip(fields).map(|(var, field)| {\n@@ -732,6 +736,7 @@ fn deserialize_seq_in_place(\n     } else {\n         format!(\"{} with {} elements\", expecting, deserialized_count)\n     };\n+    let expecting = cattrs.expecting().unwrap_or(&expecting);\n \n     let mut index_in_seq = 0usize;\n     let write_values = fields.iter().map(|field| {\n@@ -907,6 +912,7 @@ fn deserialize_struct(\n         Some(variant_ident) => format!(\"struct variant {}::{}\", params.type_name(), variant_ident),\n         None => format!(\"struct {}\", params.type_name()),\n     };\n+    let expecting = cattrs.expecting().unwrap_or(&expecting);\n \n     let visit_seq = Stmts(deserialize_seq(\n         &type_path, params, fields, true, cattrs, &expecting,\n@@ -1048,6 +1054,7 @@ fn deserialize_struct_in_place(\n         Some(variant_ident) => format!(\"struct variant {}::{}\", params.type_name(), variant_ident),\n         None => format!(\"struct {}\", params.type_name()),\n     };\n+    let expecting = cattrs.expecting().unwrap_or(&expecting);\n \n     let visit_seq = Stmts(deserialize_seq_in_place(params, fields, cattrs, &expecting));\n \n@@ -1200,6 +1207,7 @@ fn deserialize_externally_tagged_enum(\n \n     let type_name = cattrs.name().deserialize_name();\n     let expecting = format!(\"enum {}\", params.type_name());\n+    let expecting = cattrs.expecting().unwrap_or(&expecting);\n \n     let (variants_stmt, variant_visitor) = prepare_enum_variant_enum(variants, cattrs);\n \n@@ -1309,6 +1317,9 @@ fn deserialize_internally_tagged_enum(\n             }\n         });\n \n+    let expecting = format!(\"internally tagged enum {}\", params.type_name());\n+    let expecting = cattrs.expecting().unwrap_or(&expecting);\n+\n     quote_block! {\n         #variant_visitor\n \n@@ -1316,7 +1327,7 @@ fn deserialize_internally_tagged_enum(\n \n         let __tagged = try!(_serde::Deserializer::deserialize_any(\n             __deserializer,\n-            _serde::private::de::TaggedContentVisitor::<__Field>::new(#tag)));\n+            _serde::private::de::TaggedContentVisitor::<__Field>::new(#tag, #expecting)));\n \n         match __tagged.tag {\n             #(#variant_arms)*\n@@ -1359,6 +1370,7 @@ fn deserialize_adjacently_tagged_enum(\n         .collect();\n \n     let expecting = format!(\"adjacently tagged enum {}\", params.type_name());\n+    let expecting = cattrs.expecting().unwrap_or(&expecting);\n     let type_name = cattrs.name().deserialize_name();\n     let deny_unknown_fields = cattrs.deny_unknown_fields();\n \n@@ -1648,6 +1660,7 @@ fn deserialize_untagged_enum(\n         \"data did not match any variant of untagged enum {}\",\n         params.type_name()\n     );\n+    let fallthrough_msg = cattrs.expecting().unwrap_or(&fallthrough_msg);\n \n     quote_block! {\n         let __content = try!(<_serde::private::de::Content as _serde::Deserialize>::deserialize(__deserializer));\n@@ -1905,6 +1918,7 @@ fn deserialize_generated_identifier(\n         is_variant,\n         fallthrough,\n         !is_variant && cattrs.has_flatten(),\n+        None,\n     ));\n \n     let lifetime = if !is_variant && cattrs.has_flatten() {\n@@ -2012,6 +2026,7 @@ fn deserialize_custom_identifier(\n         is_variant,\n         fallthrough,\n         false,\n+        cattrs.expecting(),\n     ));\n \n     quote_block! {\n@@ -2042,6 +2057,7 @@ fn deserialize_identifier(\n     is_variant: bool,\n     fallthrough: Option<TokenStream>,\n     collect_other_fields: bool,\n+    expecting: Option<&str>,\n ) -> Fragment {\n     let mut flat_fields = Vec::new();\n     for (_, ident, aliases) in fields {\n@@ -2066,11 +2082,11 @@ fn deserialize_identifier(\n         .map(|(_, ident, _)| quote!(#this::#ident))\n         .collect();\n \n-    let expecting = if is_variant {\n+    let expecting = expecting.unwrap_or(if is_variant {\n         \"variant identifier\"\n     } else {\n         \"field identifier\"\n-    };\n+    });\n \n     let index_expecting = if is_variant { \"variant\" } else { \"field\" };\n \ndiff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex e6f72dfe7..fc523d16d 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -223,6 +223,8 @@ pub struct Container {\n     has_flatten: bool,\n     serde_path: Option<syn::Path>,\n     is_packed: bool,\n+    /// Error message generated when type can't be deserialized\n+    expecting: Option<String>,\n }\n \n /// Styles of representing an enum.\n@@ -305,6 +307,7 @@ impl Container {\n         let mut field_identifier = BoolAttr::none(cx, FIELD_IDENTIFIER);\n         let mut variant_identifier = BoolAttr::none(cx, VARIANT_IDENTIFIER);\n         let mut serde_path = Attr::none(cx, CRATE);\n+        let mut expecting = Attr::none(cx, EXPECTING);\n \n         for meta_item in item\n             .attrs\n@@ -575,6 +578,13 @@ impl Container {\n                     }\n                 }\n \n+                // Parse `#[serde(expecting = \"a message\")]`\n+                Meta(NameValue(m)) if m.path == EXPECTING => {\n+                    if let Ok(s) = get_lit_str(cx, EXPECTING, &m.lit) {\n+                        expecting.set(&m.path, s.value());\n+                    }\n+                }\n+\n                 Meta(meta_item) => {\n                     let path = meta_item\n                         .path()\n@@ -627,6 +637,7 @@ impl Container {\n             has_flatten: false,\n             serde_path: serde_path.get(),\n             is_packed,\n+            expecting: expecting.get(),\n         }\n     }\n \n@@ -702,6 +713,12 @@ impl Container {\n         self.custom_serde_path()\n             .map_or_else(|| Cow::Owned(parse_quote!(_serde)), Cow::Borrowed)\n     }\n+\n+    /// Error message generated when type can't be deserialized.\n+    /// If `None`, default message will be used\n+    pub fn expecting(&self) -> Option<&str> {\n+        self.expecting.as_ref().map(String::as_ref)\n+    }\n }\n \n fn decide_tag(\ndiff --git a/serde_derive/src/internals/symbol.rs b/serde_derive/src/internals/symbol.rs\nindex 318b81bbb..1fedd2754 100644\n--- a/serde_derive/src/internals/symbol.rs\n+++ b/serde_derive/src/internals/symbol.rs\n@@ -35,6 +35,7 @@ pub const TRY_FROM: Symbol = Symbol(\"try_from\");\n pub const UNTAGGED: Symbol = Symbol(\"untagged\");\n pub const VARIANT_IDENTIFIER: Symbol = Symbol(\"variant_identifier\");\n pub const WITH: Symbol = Symbol(\"with\");\n+pub const EXPECTING: Symbol = Symbol(\"expecting\");\n \n impl PartialEq<Symbol> for Ident {\n     fn eq(&self, word: &Symbol) -> bool {\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex c9bcee5b3..a1d62758e 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -250,9 +250,7 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n             {\n                 visitor.visit_enum(DeserializerEnumVisitor { de: self })\n             }\n-            _ => {\n-                unexpected!(self.next_token());\n-            }\n+            _ => self.deserialize_any(visitor)\n         }\n     }\n \ndiff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex 7604fe031..10d81ad4b 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -2633,3 +2633,200 @@ fn test_flatten_any_after_flatten_struct() {\n         ],\n     );\n }\n+\n+/// https://github.com/serde-rs/serde/issues/1883\n+#[test]\n+fn test_expecting_message() {\n+    #[derive(Deserialize, PartialEq, Debug)]\n+    #[serde(expecting = \"something strange...\")]\n+    struct Unit;\n+\n+    #[derive(Deserialize)]\n+    #[serde(expecting = \"something strange...\")]\n+    struct Newtype(bool);\n+\n+    #[derive(Deserialize)]\n+    #[serde(expecting = \"something strange...\")]\n+    struct Tuple(u32, bool);\n+\n+    #[derive(Deserialize)]\n+    #[serde(expecting = \"something strange...\")]\n+    struct Struct {\n+        question: String,\n+        answer: u32,\n+    }\n+\n+    assert_de_tokens_error::<Unit>(\n+        &[Token::Str(\"Unit\")],\n+        r#\"invalid type: string \"Unit\", expected something strange...\"#\n+    );\n+\n+    assert_de_tokens_error::<Newtype>(\n+        &[Token::Str(\"Newtype\")],\n+        r#\"invalid type: string \"Newtype\", expected something strange...\"#\n+    );\n+\n+    assert_de_tokens_error::<Tuple>(\n+        &[Token::Str(\"Tuple\")],\n+        r#\"invalid type: string \"Tuple\", expected something strange...\"#\n+    );\n+\n+    assert_de_tokens_error::<Struct>(\n+        &[Token::Str(\"Struct\")],\n+        r#\"invalid type: string \"Struct\", expected something strange...\"#\n+    );\n+}\n+\n+#[test]\n+fn test_expecting_message_externally_tagged_enum() {\n+    #[derive(Deserialize)]\n+    #[serde(expecting = \"something strange...\")]\n+    enum Enum {\n+        ExternallyTagged,\n+    }\n+\n+    assert_de_tokens_error::<Enum>(\n+        &[\n+            Token::Str(\"ExternallyTagged\"),\n+        ],\n+        r#\"invalid type: string \"ExternallyTagged\", expected something strange...\"#\n+    );\n+\n+    // Check that #[serde(expecting = \"...\")] doesn't affect variant identifier error message\n+    assert_de_tokens_error::<Enum>(\n+        &[\n+            Token::Enum { name: \"Enum\" },\n+            Token::Unit,\n+        ],\n+        r#\"invalid type: unit value, expected variant identifier\"#\n+    );\n+}\n+\n+#[test]\n+fn test_expecting_message_internally_tagged_enum() {\n+    #[derive(Deserialize)]\n+    #[serde(tag = \"tag\")]\n+    #[serde(expecting = \"something strange...\")]\n+    enum Enum {\n+        InternallyTagged,\n+    }\n+\n+    assert_de_tokens_error::<Enum>(\n+        &[\n+            Token::Str(\"InternallyTagged\"),\n+        ],\n+        r#\"invalid type: string \"InternallyTagged\", expected something strange...\"#\n+    );\n+\n+    // Check that #[serde(expecting = \"...\")] doesn't affect variant identifier error message\n+    assert_de_tokens_error::<Enum>(\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"tag\"),\n+            Token::Unit,\n+        ],\n+        r#\"invalid type: unit value, expected variant identifier\"#\n+    );\n+}\n+\n+#[test]\n+fn test_expecting_message_adjacently_tagged_enum() {\n+    #[derive(Deserialize)]\n+    #[serde(tag = \"tag\", content = \"content\")]\n+    #[serde(expecting = \"something strange...\")]\n+    enum Enum {\n+        AdjacentlyTagged,\n+    }\n+\n+    assert_de_tokens_error::<Enum>(\n+        &[\n+            Token::Str(\"AdjacentlyTagged\"),\n+        ],\n+        r#\"invalid type: string \"AdjacentlyTagged\", expected something strange...\"#\n+    );\n+\n+    assert_de_tokens_error::<Enum>(\n+        &[\n+            Token::Map { len: None },\n+            Token::Unit,\n+        ],\n+        r#\"invalid type: unit value, expected \"tag\", \"content\", or other ignored fields\"#\n+    );\n+\n+    // Check that #[serde(expecting = \"...\")] doesn't affect variant identifier error message\n+    assert_de_tokens_error::<Enum>(\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"tag\"),\n+            Token::Unit,\n+        ],\n+        r#\"invalid type: unit value, expected variant identifier\"#\n+    );\n+}\n+\n+#[test]\n+fn test_expecting_message_untagged_tagged_enum() {\n+    #[derive(Deserialize)]\n+    #[serde(untagged)]\n+    #[serde(expecting = \"something strange...\")]\n+    enum Enum {\n+        Untagged,\n+    }\n+\n+    assert_de_tokens_error::<Enum>(\n+        &[\n+            Token::Str(\"Untagged\"),\n+        ],\n+        r#\"something strange...\"#\n+    );\n+}\n+\n+#[test]\n+fn test_expecting_message_identifier_enum() {\n+    #[derive(Deserialize)]\n+    #[serde(field_identifier)]\n+    #[serde(expecting = \"something strange...\")]\n+    enum FieldEnum {\n+        Field,\n+    }\n+\n+    #[derive(Deserialize)]\n+    #[serde(variant_identifier)]\n+    #[serde(expecting = \"something strange...\")]\n+    enum VariantEnum {\n+        Variant,\n+    }\n+\n+    assert_de_tokens_error::<FieldEnum>(\n+        &[\n+            Token::Unit,\n+        ],\n+        r#\"invalid type: unit value, expected something strange...\"#\n+    );\n+\n+    assert_de_tokens_error::<FieldEnum>(\n+        &[\n+            Token::Enum { name: \"FieldEnum\" },\n+            Token::Str(\"Unknown\"),\n+            Token::None,\n+        ],\n+        r#\"invalid type: map, expected something strange...\"#\n+    );\n+\n+\n+    assert_de_tokens_error::<VariantEnum>(\n+        &[\n+            Token::Unit,\n+        ],\n+        r#\"invalid type: unit value, expected something strange...\"#\n+    );\n+\n+    assert_de_tokens_error::<VariantEnum>(\n+        &[\n+            Token::Enum { name: \"VariantEnum\" },\n+            Token::Str(\"Unknown\"),\n+            Token::None,\n+        ],\n+        r#\"invalid type: map, expected something strange...\"#\n+    );\n+}\ndiff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex d8def742b..b5c12d606 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -723,6 +723,55 @@ fn test_gen() {\n     }\n \n     deriving!(&'a str);\n+\n+    // https://github.com/serde-rs/serde/issues/1883\n+    #[derive(Deserialize)]\n+    #[serde(expecting = \"a message\")]\n+    struct CustomMessageUnit;\n+\n+    #[derive(Deserialize)]\n+    #[serde(expecting = \"a message\")]\n+    struct CustomMessageNewtype(bool);\n+\n+    #[derive(Deserialize)]\n+    #[serde(expecting = \"a message\")]\n+    struct CustomMessageTuple(u32, bool);\n+\n+    #[derive(Deserialize)]\n+    #[serde(expecting = \"a message\")]\n+    struct CustomMessageStruct {\n+        question: String,\n+        answer: u32,\n+    }\n+\n+    #[derive(Deserialize)]\n+    #[serde(expecting = \"a message\")]\n+    enum CustomMessageExternallyTaggedEnum {}\n+\n+    #[derive(Deserialize)]\n+    #[serde(tag = \"tag\")]\n+    #[serde(expecting = \"a message\")]\n+    enum CustomMessageInternallyTaggedEnum {}\n+\n+    #[derive(Deserialize)]\n+    #[serde(tag = \"tag\", content = \"content\")]\n+    #[serde(expecting = \"a message\")]\n+    enum CustomMessageAdjacentlyTaggedEnum {}\n+\n+    #[derive(Deserialize)]\n+    #[serde(untagged)]\n+    #[serde(expecting = \"a message\")]\n+    enum CustomMessageUntaggedEnum {}\n+\n+    #[derive(Deserialize)]\n+    #[serde(field_identifier)]\n+    #[serde(expecting = \"a message\")]\n+    enum CustomMessageFieldIdentifierEnum {}\n+\n+    #[derive(Deserialize)]\n+    #[serde(variant_identifier)]\n+    #[serde(expecting = \"a message\")]\n+    enum CustomMessageVariantIdentifierEnum {}\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Provide an easy way to customize only the error message\n**EDIT** After thinking about it some more, I feel it would be better to improve this error message rather than add API surface area. #1544 gets close, but I believe those errors are still too opaque for Cargo's purposes, and it's hidden behind a flag. Anyway, my original post:\r\n\r\n-----------------\r\n\r\nI have an untagged union:\r\n\r\n```rust\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(untagged)]\r\nenum MyEnum {\r\n  Foo(Vec<String>),\r\n  Bar(usize)\r\n}\r\n```\r\n\r\nIf all variants fail, you get this error message:\r\n\r\nhttps://github.com/serde-rs/serde/blob/9f331cc25753edd71ad7ab0ea08a430fefaa90e1/serde_derive/src/de.rs#L1648\r\n\r\nIs there a good way to customize the error message but keep the default `#[derive(Deserialize)]` implementation? Perhaps a new attribute?:\r\n\r\n```rust\r\n#[serde(untagged, expecting = \"a number or a list of strings\")]\r\nenum MyEnum {\r\n  ...\r\n}\r\n```\r\n\r\n## Advantages:\r\n\r\n- You don't have to reimplement `Deserialize`\r\n- Concise\r\n\r\n## Disadvantages\r\n\r\n- How common is this use-case? We have to do this a couple of times [within Cargo](https://github.com/rust-lang/cargo/commit/cb53e1b2056a02bd1eb83d926e1cc37e56180368).\r\n- Is there a better solution I am overlooking?\n", "hints_text": "", "created_at": "2020-10-22T20:11:56Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1874, "instance_id": "serde-rs__serde-1874", "issue_numbers": ["1873"], "base_commit": "53b9871b172c1c29a16e66138f108bf4155444fe", "patch": "diff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex eb5424cc8..bcb964a9c 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -2763,6 +2763,13 @@ where\n         }\n     }\n \n+    fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        visitor.visit_unit()\n+    }\n+\n     forward_to_deserialize_other! {\n         deserialize_bool()\n         deserialize_i8()\n@@ -2780,7 +2787,6 @@ where\n         deserialize_string()\n         deserialize_bytes()\n         deserialize_byte_buf()\n-        deserialize_unit()\n         deserialize_unit_struct(&'static str)\n         deserialize_seq()\n         deserialize_tuple(usize)\ndiff --git a/serde/src/private/ser.rs b/serde/src/private/ser.rs\nindex 70f338181..eb8cfc988 100644\n--- a/serde/src/private/ser.rs\n+++ b/serde/src/private/ser.rs\n@@ -1124,7 +1124,7 @@ where\n     }\n \n     fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {\n-        Err(Self::bad_type(Unsupported::Unit))\n+        Ok(())\n     }\n \n     fn serialize_unit_struct(self, _: &'static str) -> Result<Self::Ok, Self::Error> {\n", "test_patch": "diff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex 06c485dff..7604fe031 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -1967,6 +1967,29 @@ fn test_flatten_map_twice() {\n     );\n }\n \n+#[test]\n+fn test_flatten_unit() {\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    struct Response<T> {\n+        #[serde(flatten)]\n+        data: T,\n+        status: usize,\n+    }\n+\n+    assert_tokens(\n+        &Response {\n+            data: (),\n+            status: 0,\n+        },\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"status\"),\n+            Token::U64(0),\n+            Token::MapEnd,\n+        ],\n+    );\n+}\n+\n #[test]\n fn test_flatten_unsupported_type() {\n     #[derive(Debug, PartialEq, Serialize, Deserialize)]\n", "problem_statement": "Flattening a Unit aka () should produce no extra fields\nI'm designing an http api where every response is json and has diffferent fields depending on the api call, but always has a status and code field. I am acomplishing this through the Response struct:\r\n```rust\r\n#[derive(Debug, Serialize)]\r\npub struct Response<T> {\r\n    #[serde(flatten)]\r\n    data: T,\r\n    status: Status,\r\n}\r\n```\r\n\r\nIn situations where I just want to return a status, I intended on constructing a `Response<()>`, but that gives me this error:\r\n```thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error(\"can only flatten structs and maps (got unit)\", line: 0, column: 0)', src/libcore/result.rs:1189:5```\r\n\r\nI expected that flattening a Unit would just add no fields. I could make a struct with no fields and make a `Response<NoFields>`, but that seems unidiomatic and requires adding an extra type that doesn't do anything. Is there a reason that you can't flatten a Unit?\n", "hints_text": "", "created_at": "2020-08-10T22:07:47Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1831, "instance_id": "serde-rs__serde-1831", "issue_numbers": ["1562"], "base_commit": "8084258a3edc1dc4007e8df7f24b022d015b5fb0", "patch": "diff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex e6f72dfe7..d59e681a0 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -1,6 +1,6 @@\n use internals::symbol::*;\n use internals::{ungroup, Ctxt};\n-use proc_macro2::{Group, Span, TokenStream, TokenTree};\n+use proc_macro2::{Group, Spacing, Span, TokenStream, TokenTree};\n use quote::ToTokens;\n use std::borrow::Cow;\n use std::collections::BTreeSet;\n@@ -1921,17 +1921,40 @@ fn collect_lifetimes(ty: &syn::Type, out: &mut BTreeSet<syn::Lifetime>) {\n         syn::Type::Group(ty) => {\n             collect_lifetimes(&ty.elem, out);\n         }\n+        syn::Type::Macro(ty) => {\n+            collect_lifetimes_from_tokens(ty.mac.tokens.clone(), out);\n+        }\n         syn::Type::BareFn(_)\n         | syn::Type::Never(_)\n         | syn::Type::TraitObject(_)\n         | syn::Type::ImplTrait(_)\n         | syn::Type::Infer(_)\n-        | syn::Type::Macro(_)\n         | syn::Type::Verbatim(_)\n         | _ => {}\n     }\n }\n \n+fn collect_lifetimes_from_tokens(tokens: TokenStream, out: &mut BTreeSet<syn::Lifetime>) {\n+    let mut iter = tokens.into_iter();\n+    while let Some(tt) = iter.next() {\n+        match &tt {\n+            TokenTree::Punct(op) if op.as_char() == '\\'' && op.spacing() == Spacing::Joint => {\n+                if let Some(TokenTree::Ident(ident)) = iter.next() {\n+                    out.insert(syn::Lifetime {\n+                        apostrophe: op.span(),\n+                        ident,\n+                    });\n+                }\n+            }\n+            TokenTree::Group(group) => {\n+                let tokens = group.stream();\n+                collect_lifetimes_from_tokens(tokens, out);\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n fn parse_lit_str<T>(s: &syn::LitStr) -> parse::Result<T>\n where\n     T: Parse,\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex d8def742b..73f7fa50f 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -723,6 +723,18 @@ fn test_gen() {\n     }\n \n     deriving!(&'a str);\n+\n+    macro_rules! mac {\n+        ($($tt:tt)*) => {\n+            $($tt)*\n+        };\n+    }\n+\n+    #[derive(Deserialize)]\n+    struct BorrowLifetimeInsideMacro<'a> {\n+        #[serde(borrow = \"'a\")]\n+        f: mac!(Cow<'a, str>),\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Error: \"field has no lifetimes to borrow\" if type is behind a macro\n```Rust\r\nuse serde::Deserialize;\r\nuse std::borrow::Cow;\r\n\r\nmacro_rules! t {\r\n    ($t:ty) => { $t }\r\n}\r\n\r\n#[derive(Deserialize)]\r\nstruct B<'a> {\r\n    #[serde(borrow=\"'a\")]\r\n    f: t!(Cow<'a , str>)\r\n}\r\n```\r\n\r\nThis generates error:\r\n```\r\nerror: field `f` has no lifetimes to borrow\r\n  --> src\\main.rs:10:5\r\n   |\r\n10 | /     #[serde(borrow=\"'a\")]\r\n11 | |     f: t!(Cow<'a , str>)\r\n   | |________________________^\r\n```\r\n\r\nbut If I manually substitute type that macro expands to then everything works fine.\n", "hints_text": "Thanks! I would accept a PR to fix this.", "created_at": "2020-06-07T11:15:57Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1830, "instance_id": "serde-rs__serde-1830", "issue_numbers": ["1565"], "base_commit": "f6e7366b46f767c427ca0423ae4cc69531213498", "patch": "diff --git a/serde_derive/Cargo.toml b/serde_derive/Cargo.toml\nindex 185fe9787..5b6fa4344 100644\n--- a/serde_derive/Cargo.toml\n+++ b/serde_derive/Cargo.toml\n@@ -22,7 +22,7 @@ proc-macro = true\n [dependencies]\n proc-macro2 = \"1.0\"\n quote = \"1.0\"\n-syn = { version = \"1.0.58\", features = [\"visit\"] }\n+syn = { version = \"1.0.58\", features = [\"visit\", \"visit-mut\"] }\n \n [dev-dependencies]\n serde = { version = \"1.0\", path = \"../serde\" }\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 90d0ab7c1..3daa9d1e6 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -8,13 +8,17 @@ use bound;\n use dummy;\n use fragment::{Expr, Fragment, Match, Stmts};\n use internals::ast::{Container, Data, Field, Style, Variant};\n-use internals::{attr, ungroup, Ctxt, Derive};\n+use internals::{attr, replace_receiver, ungroup, Ctxt, Derive};\n use pretend;\n \n use std::collections::BTreeSet;\n use std::ptr;\n \n-pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<TokenStream, Vec<syn::Error>> {\n+pub fn expand_derive_deserialize(\n+    input: &mut syn::DeriveInput,\n+) -> Result<TokenStream, Vec<syn::Error>> {\n+    replace_receiver(input);\n+\n     let ctxt = Ctxt::new();\n     let cont = match Container::from_ast(&ctxt, input, Derive::Deserialize) {\n         Some(cont) => cont,\ndiff --git a/serde_derive/src/internals/mod.rs b/serde_derive/src/internals/mod.rs\nindex d36b6e45c..5e9f416c4 100644\n--- a/serde_derive/src/internals/mod.rs\n+++ b/serde_derive/src/internals/mod.rs\n@@ -4,8 +4,12 @@ pub mod attr;\n mod ctxt;\n pub use self::ctxt::Ctxt;\n \n+mod receiver;\n+pub use self::receiver::replace_receiver;\n+\n mod case;\n mod check;\n+mod respan;\n mod symbol;\n \n use syn::Type;\ndiff --git a/serde_derive/src/internals/receiver.rs b/serde_derive/src/internals/receiver.rs\nnew file mode 100644\nindex 000000000..1aaddb8bd\n--- /dev/null\n+++ b/serde_derive/src/internals/receiver.rs\n@@ -0,0 +1,190 @@\n+use super::respan::respan;\n+use proc_macro2::{Group, Spacing, Span, TokenStream, TokenTree};\n+use quote::{quote, quote_spanned};\n+use std::{iter::FromIterator, mem};\n+use syn::{\n+    parse_quote,\n+    punctuated::Punctuated,\n+    visit_mut::{self, VisitMut},\n+    DeriveInput, ExprPath, Macro, Path, PathArguments, QSelf, Type, TypePath,\n+};\n+\n+pub fn replace_receiver(input: &mut DeriveInput) {\n+    let self_ty = {\n+        let ident = &input.ident;\n+        let ty_generics = input.generics.split_for_impl().1;\n+        parse_quote!(#ident #ty_generics)\n+    };\n+    let mut visitor = ReplaceReceiver(&self_ty);\n+    visitor.visit_generics_mut(&mut input.generics);\n+    visitor.visit_data_mut(&mut input.data);\n+}\n+\n+struct ReplaceReceiver<'a>(&'a TypePath);\n+\n+impl ReplaceReceiver<'_> {\n+    fn self_ty(&self, span: Span) -> TypePath {\n+        respan(self.0, span)\n+    }\n+\n+    fn self_to_qself(&self, qself: &mut Option<QSelf>, path: &mut Path) {\n+        if path.leading_colon.is_some() {\n+            return;\n+        }\n+\n+        // Make borrow checker happy\n+        {\n+            let first = &path.segments[0];\n+            if first.ident != \"Self\" || !first.arguments.is_empty() {\n+                return;\n+            }\n+        }\n+\n+        if path.segments.len() == 1 {\n+            self.self_to_expr_path(path);\n+            return;\n+        }\n+\n+        let span = path.segments[0].ident.span();\n+        *qself = Some(QSelf {\n+            lt_token: Token![<](span),\n+            ty: Box::new(self.self_ty(span).into()),\n+            position: 0,\n+            as_token: None,\n+            gt_token: Token![>](span),\n+        });\n+\n+        path.leading_colon = Some(**path.segments.pairs().next().unwrap().punct().unwrap());\n+\n+        let segments = mem::replace(&mut path.segments, Punctuated::new());\n+        path.segments = segments.into_pairs().skip(1).collect();\n+    }\n+\n+    fn self_to_expr_path(&self, path: &mut Path) {\n+        if path.leading_colon.is_some() {\n+            return;\n+        }\n+\n+        // Make borrow checker happy\n+        {\n+            let first = &path.segments[0];\n+            if first.ident != \"Self\" || !first.arguments.is_empty() {\n+                return;\n+            }\n+        }\n+\n+        let self_ty = self.self_ty(path.segments[0].ident.span());\n+        let variant = mem::replace(path, self_ty.path);\n+        for segment in &mut path.segments {\n+            if let PathArguments::AngleBracketed(bracketed) = &mut segment.arguments {\n+                if bracketed.colon2_token.is_none() && !bracketed.args.is_empty() {\n+                    bracketed.colon2_token = Some(<Token![::]>::default());\n+                }\n+            }\n+        }\n+        if variant.segments.len() > 1 {\n+            path.segments.push_punct(<Token![::]>::default());\n+            path.segments.extend(variant.segments.into_pairs().skip(1));\n+        }\n+    }\n+\n+    fn visit_token_stream(&self, tokens: &mut TokenStream) -> bool {\n+        let mut out = Vec::new();\n+        let mut modified = false;\n+        let mut iter = tokens.clone().into_iter().peekable();\n+        while let Some(tt) = iter.next() {\n+            match tt {\n+                TokenTree::Ident(ident) => {\n+                    if ident == \"Self\" {\n+                        modified = true;\n+                        let self_ty = self.self_ty(ident.span());\n+                        match iter.peek() {\n+                            Some(TokenTree::Punct(p))\n+                                if p.as_char() == ':' && p.spacing() == Spacing::Joint => {}\n+                            _ => {\n+                                out.extend(quote!(#self_ty));\n+                                continue;\n+                            }\n+                        }\n+                        let next = iter.next().unwrap();\n+                        match iter.peek() {\n+                            Some(TokenTree::Punct(p)) if p.as_char() == ':' => {\n+                                let span = ident.span();\n+                                out.extend(quote_spanned!(span=> <#self_ty>));\n+                            }\n+                            _ => out.extend(quote!(#self_ty)),\n+                        }\n+                        out.push(next);\n+                    } else {\n+                        out.push(TokenTree::Ident(ident));\n+                    }\n+                }\n+                TokenTree::Group(group) => {\n+                    let mut content = group.stream();\n+                    modified |= self.visit_token_stream(&mut content);\n+                    let mut new = Group::new(group.delimiter(), content);\n+                    new.set_span(group.span());\n+                    out.push(TokenTree::Group(new));\n+                }\n+                other => out.push(other),\n+            }\n+        }\n+        if modified {\n+            *tokens = TokenStream::from_iter(out);\n+        }\n+        modified\n+    }\n+}\n+\n+impl VisitMut for ReplaceReceiver<'_> {\n+    // `Self` -> `Receiver`\n+    fn visit_type_mut(&mut self, ty: &mut Type) {\n+        let span = if let Type::Path(node) = ty {\n+            if node.qself.is_none() && node.path.is_ident(\"Self\") {\n+                node.path.segments[0].ident.span()\n+            } else {\n+                self.visit_type_path_mut(node);\n+                return;\n+            }\n+        } else {\n+            visit_mut::visit_type_mut(self, ty);\n+            return;\n+        };\n+        *ty = self.self_ty(span).into();\n+    }\n+\n+    // `Self::Assoc` -> `<Receiver>::Assoc`\n+    fn visit_type_path_mut(&mut self, ty: &mut TypePath) {\n+        if ty.qself.is_none() {\n+            self.self_to_qself(&mut ty.qself, &mut ty.path);\n+        }\n+        visit_mut::visit_type_path_mut(self, ty);\n+    }\n+\n+    // `Self::method` -> `<Receiver>::method`\n+    fn visit_expr_path_mut(&mut self, expr: &mut ExprPath) {\n+        if expr.qself.is_none() {\n+            self.self_to_qself(&mut expr.qself, &mut expr.path);\n+        }\n+        visit_mut::visit_expr_path_mut(self, expr);\n+    }\n+\n+    fn visit_macro_mut(&mut self, mac: &mut Macro) {\n+        // We can't tell in general whether `self` inside a macro invocation\n+        // refers to the self in the argument list or a different self\n+        // introduced within the macro. Heuristic: if the macro input contains\n+        // `fn`, then `self` is more likely to refer to something other than the\n+        // outer function's self argument.\n+        if !contains_fn(mac.tokens.clone()) {\n+            self.visit_token_stream(&mut mac.tokens);\n+        }\n+    }\n+}\n+\n+fn contains_fn(tokens: TokenStream) -> bool {\n+    tokens.into_iter().any(|tt| match tt {\n+        TokenTree::Ident(ident) => ident == \"fn\",\n+        TokenTree::Group(group) => contains_fn(group.stream()),\n+        _ => false,\n+    })\n+}\ndiff --git a/serde_derive/src/internals/respan.rs b/serde_derive/src/internals/respan.rs\nnew file mode 100644\nindex 000000000..38f6612c4\n--- /dev/null\n+++ b/serde_derive/src/internals/respan.rs\n@@ -0,0 +1,22 @@\n+use proc_macro2::{Span, TokenStream};\n+use quote::ToTokens;\n+use syn::parse::Parse;\n+\n+pub(crate) fn respan<T>(node: &T, span: Span) -> T\n+where\n+    T: ToTokens + Parse,\n+{\n+    let tokens = node.to_token_stream();\n+    let respanned = respan_tokens(tokens, span);\n+    syn::parse2(respanned).unwrap()\n+}\n+\n+fn respan_tokens(tokens: TokenStream, span: Span) -> TokenStream {\n+    tokens\n+        .into_iter()\n+        .map(|mut token| {\n+            token.set_span(span);\n+            token\n+        })\n+        .collect()\n+}\ndiff --git a/serde_derive/src/lib.rs b/serde_derive/src/lib.rs\nindex 3b4f28817..c34f00722 100644\n--- a/serde_derive/src/lib.rs\n+++ b/serde_derive/src/lib.rs\n@@ -86,8 +86,8 @@ pub fn derive_serialize(input: TokenStream) -> TokenStream {\n \n #[proc_macro_derive(Deserialize, attributes(serde))]\n pub fn derive_deserialize(input: TokenStream) -> TokenStream {\n-    let input = parse_macro_input!(input as DeriveInput);\n-    de::expand_derive_deserialize(&input)\n+    let mut input = parse_macro_input!(input as DeriveInput);\n+    de::expand_derive_deserialize(&mut input)\n         .unwrap_or_else(to_compile_errors)\n         .into()\n }\ndiff --git a/serde_derive_internals/Cargo.toml b/serde_derive_internals/Cargo.toml\nindex 64ee1c629..6e9214558 100644\n--- a/serde_derive_internals/Cargo.toml\n+++ b/serde_derive_internals/Cargo.toml\n@@ -16,7 +16,7 @@ path = \"lib.rs\"\n [dependencies]\n proc-macro2 = \"1.0\"\n quote = \"1.0\"\n-syn = { version = \"1.0.33\", default-features = false, features = [\"derive\", \"parsing\", \"printing\", \"clone-impls\"] }\n+syn = { version = \"1.0.33\", default-features = false, features = [\"derive\", \"parsing\", \"printing\", \"clone-impls\", \"visit-mut\"] }\n \n [package.metadata.docs.rs]\n targets = [\"x86_64-unknown-linux-gnu\"]\n", "test_patch": "diff --git a/test_suite/tests/test_self.rs b/test_suite/tests/test_self.rs\nnew file mode 100644\nindex 000000000..d2241749c\n--- /dev/null\n+++ b/test_suite/tests/test_self.rs\n@@ -0,0 +1,101 @@\n+use serde::{Deserialize, Serialize};\n+\n+#[test]\n+fn test_self() {\n+    macro_rules! mac {\n+        ($($tt:tt)*) => {\n+            $($tt)*\n+        };\n+    }\n+\n+    pub trait Trait {\n+        type Assoc;\n+    }\n+\n+    #[derive(Deserialize, Serialize)]\n+    pub struct Generics<T: Trait<Assoc = Self>>\n+    where\n+        Self: Trait<Assoc = Self>,\n+        <Self as Trait>::Assoc: Sized,\n+        mac!(Self): Trait<Assoc = mac!(Self)>,\n+    {\n+        _f: T,\n+    }\n+\n+    impl<T: Trait<Assoc = Self>> Trait for Generics<T> {\n+        type Assoc = Self;\n+    }\n+\n+    #[derive(Deserialize, Serialize)]\n+    pub struct Struct {\n+        _f1: Box<Self>,\n+        _f2: Box<<Self as Trait>::Assoc>,\n+        _f3: Box<mac!(Self)>,\n+        _f4: [(); Self::ASSOC],\n+        _f5: [(); Self::assoc()],\n+        _f6: [(); mac!(Self::assoc())],\n+    }\n+\n+    impl Struct {\n+        const ASSOC: usize = 1;\n+        const fn assoc() -> usize {\n+            0\n+        }\n+    }\n+\n+    impl Trait for Struct {\n+        type Assoc = Self;\n+    }\n+\n+    #[derive(Deserialize, Serialize)]\n+    struct Tuple(\n+        Box<Self>,\n+        Box<<Self as Trait>::Assoc>,\n+        Box<mac!(Self)>,\n+        [(); Self::ASSOC],\n+        [(); Self::assoc()],\n+        [(); mac!(Self::assoc())],\n+    );\n+\n+    impl Tuple {\n+        const ASSOC: usize = 1;\n+        const fn assoc() -> usize {\n+            0\n+        }\n+    }\n+\n+    impl Trait for Tuple {\n+        type Assoc = Self;\n+    }\n+\n+    #[derive(Deserialize, Serialize)]\n+    enum Enum {\n+        Struct {\n+            _f1: Box<Self>,\n+            _f2: Box<<Self as Trait>::Assoc>,\n+            _f3: Box<mac!(Self)>,\n+            _f4: [(); Self::ASSOC],\n+            _f5: [(); Self::assoc()],\n+            _f6: [(); mac!(Self::assoc())],\n+        },\n+        Tuple(\n+            Box<Self>,\n+            Box<<Self as Trait>::Assoc>,\n+            Box<mac!(Self)>,\n+            [(); Self::ASSOC],\n+            [(); Self::assoc()],\n+            [(); mac!(Self::assoc())],\n+        ),\n+    }\n+\n+    impl Enum {\n+        const ASSOC: usize = 1;\n+        const fn assoc() -> usize {\n+            0\n+        }\n+    }\n+\n+    impl Trait for Enum {\n+        type Assoc = Self;\n+    }\n+}\n", "problem_statement": "Derive Deserialize: Self in recursive type is not supported\nAs the code and errors below show, deriving `Deserialize` on a recursive enum with a `Self` reference does not work.\r\n\r\nNote: `Serialize` works fine.\r\n\r\n\r\n```rust\r\n// Works fine:\r\n\r\n#[derive(serde_derive::Deserialize)]\r\nenum E {\r\n    Nested(Vec<E>),\r\n}\r\n\r\n// Fails with ERROR: \r\n\r\n#[derive(serde_derive::Deserialize)]\r\nenum E {\r\n    Nested(Vec<Self>),\r\n}\r\n```\r\n\r\n```\r\n  Compiling playground v0.0.1 (/playground)\r\nerror[E0277]: the trait bound `_IMPL_DESERIALIZE_FOR_E::<impl _IMPL_DESERIALIZE_FOR_E::_serde::Deserialize<'de> for E>::deserialize::__Visitor<'de>: _IMPL_DESERIALIZE_FOR_E::_serde::Deserialize<'_>` is not satisfied\r\n --> src/lib.rs:5:12\r\n  |\r\n5 |     Nested(Vec<Self>),\r\n  |            ^^^ the trait `_IMPL_DESERIALIZE_FOR_E::_serde::Deserialize<'_>` is not implemented for `_IMPL_DESERIALIZE_FOR_E::<impl _IMPL_DESERIALIZE_FOR_E::_serde::Deserialize<'de> for E>::deserialize::__Visitor<'de>`\r\n  |\r\n  = note: required because of the requirements on the impl of `_IMPL_DESERIALIZE_FOR_E::_serde::Deserialize<'_>` for `std::vec::Vec<_IMPL_DESERIALIZE_FOR_E::<impl _IMPL_DESERIALIZE_FOR_E::_serde::Deserialize<'de> for E>::deserialize::__Visitor<'de>>`\r\n  = note: required by `_IMPL_DESERIALIZE_FOR_E::_serde::de::VariantAccess::newtype_variant`\r\n\r\nerror[E0631]: type mismatch in function arguments\r\n --> src/lib.rs:3:10\r\n  |\r\n3 | #[derive(serde_derive::Deserialize)]\r\n  |          ^^^^^^^^^^^^^^^^^^^^^^^^^ expected signature of `fn(std::vec::Vec<_IMPL_DESERIALIZE_FOR_E::<impl _IMPL_DESERIALIZE_FOR_E::_serde::Deserialize<'de> for E>::deserialize::__Visitor<'_>>) -> _`\r\n4 | enum E {\r\n5 |     Nested(Vec<Self>),\r\n  |     ----------------- found signature of `fn(std::vec::Vec<E>) -> _`\r\n  |\r\n  = note: required by `std::result::Result::<T, E>::map`\r\n\r\nerror: aborting due to 2 previous errors\r\n\r\nFor more information about this error, try `rustc --explain E0277`.\r\nerror: Could not compile `playground`.\r\n```\n", "hints_text": "Thanks! This is a bug. I would accept a PR to fix this.\nI assume this just boils down to special casing `Self` in the derive code?\r\n\r\nI'll take a look.\nYeah, I imagine what happens is that the field type is referred to from somewhere outside of the Deserialize impl itself, such as from a Visitor impl where Self would refer to the visitor struct and not the output type. Check `cargo expand` to identify where that happens. In that code, we will need to replace `Self` with either the type name (`E` in this case, but making sure to fill in generic parameters if there are any) or a convenient associated type like `Self::Value` if there is already one available that means the right thing. I believe there already is some code for recursively replacing `Self` in types, but if not, the easiest way would be with a syn Fold or VisitMut impl that walks the type and performs the replacement.", "created_at": "2020-06-07T09:37:23Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1827, "instance_id": "serde-rs__serde-1827", "issue_numbers": ["1683"], "base_commit": "6980727d74e1b4fd0f2bff85e824e2c47ca08ba3", "patch": "diff --git a/serde_derive/Cargo.toml b/serde_derive/Cargo.toml\nindex 879a65199..2e90c0b91 100644\n--- a/serde_derive/Cargo.toml\n+++ b/serde_derive/Cargo.toml\n@@ -9,7 +9,7 @@ repository = \"https://github.com/serde-rs/serde\"\n documentation = \"https://serde.rs/derive.html\"\n keywords = [\"serde\", \"serialization\", \"no_std\"]\n readme = \"crates-io.md\"\n-include = [\"src/**/*.rs\", \"crates-io.md\", \"README.md\", \"LICENSE-APACHE\", \"LICENSE-MIT\"]\n+include = [\"build.rs\", \"src/**/*.rs\", \"crates-io.md\", \"README.md\", \"LICENSE-APACHE\", \"LICENSE-MIT\"]\n \n [features]\n default = []\ndiff --git a/serde_derive/build.rs b/serde_derive/build.rs\nnew file mode 100644\nindex 000000000..a2c481a4a\n--- /dev/null\n+++ b/serde_derive/build.rs\n@@ -0,0 +1,30 @@\n+use std::env;\n+use std::process::Command;\n+use std::str;\n+\n+// The rustc-cfg strings below are *not* public API. Please let us know by\n+// opening a GitHub issue if your build environment requires some way to enable\n+// these cfgs other than by executing our build script.\n+fn main() {\n+    let minor = match rustc_minor_version() {\n+        Some(minor) => minor,\n+        None => return,\n+    };\n+\n+    // Underscore const names stabilized in Rust 1.37:\n+    // https://github.com/rust-lang/rust/pull/61347\n+    if minor >= 37 {\n+        println!(\"cargo:rustc-cfg=underscore_consts\");\n+    }\n+}\n+\n+fn rustc_minor_version() -> Option<u32> {\n+    let rustc = env::var_os(\"RUSTC\")?;\n+    let output = Command::new(rustc).arg(\"--version\").output().ok()?;\n+    let version = str::from_utf8(&output.stdout).ok()?;\n+    let mut pieces = version.split('.');\n+    if pieces.next() != Some(\"rustc 1\") {\n+        return None;\n+    }\n+    pieces.next()?.parse().ok()\n+}\ndiff --git a/serde_derive/src/dummy.rs b/serde_derive/src/dummy.rs\nindex d55baf29c..9a4e5f085 100644\n--- a/serde_derive/src/dummy.rs\n+++ b/serde_derive/src/dummy.rs\n@@ -1,4 +1,5 @@\n-use proc_macro2::{Ident, Span, TokenStream};\n+use proc_macro2::{Ident, TokenStream};\n+use quote::format_ident;\n \n use syn;\n use try;\n@@ -11,10 +12,11 @@ pub fn wrap_in_const(\n ) -> TokenStream {\n     let try_replacement = try::replacement();\n \n-    let dummy_const = Ident::new(\n-        &format!(\"_IMPL_{}_FOR_{}\", trait_, unraw(ty)),\n-        Span::call_site(),\n-    );\n+    let dummy_const = if cfg!(underscore_consts) {\n+        format_ident!(\"_\")\n+    } else {\n+        format_ident!(\"_IMPL_{}_FOR_{}\", trait_, unraw(ty))\n+    };\n \n     let use_serde = match serde_path {\n         Some(path) => quote! {\n", "test_patch": "diff --git a/test_suite/tests/expand/de_enum.expanded.rs b/test_suite/tests/expand/de_enum.expanded.rs\nindex 58d40459b..a4ba24911 100644\n--- a/test_suite/tests/expand/de_enum.expanded.rs\n+++ b/test_suite/tests/expand/de_enum.expanded.rs\n@@ -9,7 +9,7 @@ enum DeEnum<B, C, D> {\n }\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_SERIALIZE_FOR_DeEnum: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\n@@ -261,7 +261,7 @@ const _IMPL_SERIALIZE_FOR_DeEnum: () = {\n };\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_DESERIALIZE_FOR_DeEnum: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\ndiff --git a/test_suite/tests/expand/default_ty_param.expanded.rs b/test_suite/tests/expand/default_ty_param.expanded.rs\nindex 23c243bc0..8aaa3ab43 100644\n--- a/test_suite/tests/expand/default_ty_param.expanded.rs\n+++ b/test_suite/tests/expand/default_ty_param.expanded.rs\n@@ -10,7 +10,7 @@ struct DefaultTyParam<T: AssociatedType<X = i32> = i32> {\n }\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_SERIALIZE_FOR_DefaultTyParam: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\n@@ -45,7 +45,7 @@ const _IMPL_SERIALIZE_FOR_DefaultTyParam: () = {\n };\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_DESERIALIZE_FOR_DefaultTyParam: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\ndiff --git a/test_suite/tests/expand/generic_enum.expanded.rs b/test_suite/tests/expand/generic_enum.expanded.rs\nindex 899e4fea2..add7c510d 100644\n--- a/test_suite/tests/expand/generic_enum.expanded.rs\n+++ b/test_suite/tests/expand/generic_enum.expanded.rs\n@@ -7,7 +7,7 @@ pub enum GenericEnum<T, U> {\n }\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_SERIALIZE_FOR_GenericEnum: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\n@@ -110,7 +110,7 @@ const _IMPL_SERIALIZE_FOR_GenericEnum: () = {\n };\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_DESERIALIZE_FOR_GenericEnum: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\ndiff --git a/test_suite/tests/expand/generic_struct.expanded.rs b/test_suite/tests/expand/generic_struct.expanded.rs\nindex 1331e7e96..59d2e51d7 100644\n--- a/test_suite/tests/expand/generic_struct.expanded.rs\n+++ b/test_suite/tests/expand/generic_struct.expanded.rs\n@@ -4,7 +4,7 @@ pub struct GenericStruct<T> {\n }\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_SERIALIZE_FOR_GenericStruct: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\n@@ -38,7 +38,7 @@ const _IMPL_SERIALIZE_FOR_GenericStruct: () = {\n };\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_DESERIALIZE_FOR_GenericStruct: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\n@@ -400,7 +400,7 @@ const _IMPL_DESERIALIZE_FOR_GenericStruct: () = {\n pub struct GenericNewTypeStruct<T>(T);\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_SERIALIZE_FOR_GenericNewTypeStruct: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\n@@ -422,7 +422,7 @@ const _IMPL_SERIALIZE_FOR_GenericNewTypeStruct: () = {\n };\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_DESERIALIZE_FOR_GenericNewTypeStruct: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\ndiff --git a/test_suite/tests/expand/generic_tuple_struct.expanded.rs b/test_suite/tests/expand/generic_tuple_struct.expanded.rs\nindex 508667387..8eaf0e7ef 100644\n--- a/test_suite/tests/expand/generic_tuple_struct.expanded.rs\n+++ b/test_suite/tests/expand/generic_tuple_struct.expanded.rs\n@@ -2,7 +2,7 @@ use serde::{Deserialize, Serialize};\n pub struct GenericTupleStruct<T, U>(T, U);\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_DESERIALIZE_FOR_GenericTupleStruct: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\ndiff --git a/test_suite/tests/expand/lifetimes.expanded.rs b/test_suite/tests/expand/lifetimes.expanded.rs\nindex 6916ac905..9840d4401 100644\n--- a/test_suite/tests/expand/lifetimes.expanded.rs\n+++ b/test_suite/tests/expand/lifetimes.expanded.rs\n@@ -7,7 +7,7 @@ enum Lifetimes<'a> {\n }\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_SERIALIZE_FOR_Lifetimes: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\n@@ -91,7 +91,7 @@ const _IMPL_SERIALIZE_FOR_Lifetimes: () = {\n };\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_DESERIALIZE_FOR_Lifetimes: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\ndiff --git a/test_suite/tests/expand/named_map.expanded.rs b/test_suite/tests/expand/named_map.expanded.rs\nindex 5283993ec..ce43b6634 100644\n--- a/test_suite/tests/expand/named_map.expanded.rs\n+++ b/test_suite/tests/expand/named_map.expanded.rs\n@@ -6,7 +6,7 @@ struct SerNamedMap<'a, 'b, A: 'a, B: 'b, C> {\n }\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_SERIALIZE_FOR_SerNamedMap: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\n@@ -59,7 +59,7 @@ struct DeNamedMap<A, B, C> {\n }\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_DESERIALIZE_FOR_DeNamedMap: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\ndiff --git a/test_suite/tests/expand/named_tuple.expanded.rs b/test_suite/tests/expand/named_tuple.expanded.rs\nindex 2966c295e..8b5e4eee0 100644\n--- a/test_suite/tests/expand/named_tuple.expanded.rs\n+++ b/test_suite/tests/expand/named_tuple.expanded.rs\n@@ -2,7 +2,7 @@ use serde::{Deserialize, Serialize};\n struct SerNamedTuple<'a, 'b, A: 'a, B: 'b, C>(&'a A, &'b mut B, C);\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_SERIALIZE_FOR_SerNamedTuple: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\n@@ -51,7 +51,7 @@ const _IMPL_SERIALIZE_FOR_SerNamedTuple: () = {\n struct DeNamedTuple<A, B, C>(A, B, C);\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_DESERIALIZE_FOR_DeNamedTuple: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\ndiff --git a/test_suite/tests/expand/named_unit.expanded.rs b/test_suite/tests/expand/named_unit.expanded.rs\nindex f100688a2..dfe44ddd0 100644\n--- a/test_suite/tests/expand/named_unit.expanded.rs\n+++ b/test_suite/tests/expand/named_unit.expanded.rs\n@@ -2,7 +2,7 @@ use serde::{Deserialize, Serialize};\n struct NamedUnit;\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_SERIALIZE_FOR_NamedUnit: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\n@@ -17,7 +17,7 @@ const _IMPL_SERIALIZE_FOR_NamedUnit: () = {\n };\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_DESERIALIZE_FOR_NamedUnit: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\ndiff --git a/test_suite/tests/expand/ser_enum.expanded.rs b/test_suite/tests/expand/ser_enum.expanded.rs\nindex cd2723fae..3f4db97d9 100644\n--- a/test_suite/tests/expand/ser_enum.expanded.rs\n+++ b/test_suite/tests/expand/ser_enum.expanded.rs\n@@ -12,7 +12,7 @@ where\n }\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_SERIALIZE_FOR_SerEnum: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\ndiff --git a/test_suite/tests/expand/void.expanded.rs b/test_suite/tests/expand/void.expanded.rs\nindex e7db4ac2f..fb98c321a 100644\n--- a/test_suite/tests/expand/void.expanded.rs\n+++ b/test_suite/tests/expand/void.expanded.rs\n@@ -2,7 +2,7 @@ use serde::{Deserialize, Serialize};\n enum Void {}\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_SERIALIZE_FOR_Void: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\n@@ -17,7 +17,7 @@ const _IMPL_SERIALIZE_FOR_Void: () = {\n };\n #[doc(hidden)]\n #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-const _IMPL_DESERIALIZE_FOR_Void: () = {\n+const _: () = {\n     #[allow(rust_2018_idioms, clippy::useless_attribute)]\n     extern crate serde as _serde;\n     #[automatically_derived]\n", "problem_statement": "Use underscore consts on rustc 1.37+\nhttps://blog.rust-lang.org/2019/08/15/Rust-1.37.0.html#using-unnamed-const-items-for-macros\r\n\r\nThis would tend to produce more readable error messages, because the paths currently emitted by rustc in error messages are silly (https://github.com/rust-lang/rust/issues/46991).\r\n\r\nIt will require adding a build.rs script to serde_derive similar to the one that exists in serde.\n", "hints_text": "", "created_at": "2020-06-07T00:17:10Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1805, "instance_id": "serde-rs__serde-1805", "issue_numbers": ["1804"], "base_commit": "099fa25b86524f07d86852ea2de071e8dd2a653f", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 5ccd38a8f..74df11df7 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -1153,10 +1153,13 @@ fn prepare_enum_variant_enum(\n     variants: &[Variant],\n     cattrs: &attr::Container,\n ) -> (TokenStream, Stmts) {\n-    let variant_names_idents: Vec<_> = variants\n+    let mut deserialized_variants = variants\n         .iter()\n         .enumerate()\n-        .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n+        .filter(|&(_, variant)| !variant.attrs.skip_deserializing());\n+\n+    let variant_names_idents: Vec<_> = deserialized_variants\n+        .clone()\n         .map(|(i, variant)| {\n             (\n                 variant.attrs.name().deserialize_name(),\n@@ -1166,7 +1169,7 @@ fn prepare_enum_variant_enum(\n         })\n         .collect();\n \n-    let other_idx = variants.iter().position(|variant| variant.attrs.other());\n+    let other_idx = deserialized_variants.position(|(_, variant)| variant.attrs.other());\n \n     let variants_stmt = {\n         let variant_names = variant_names_idents.iter().map(|(name, _, _)| name);\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 92bb0ae1f..c429500c1 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -691,6 +691,16 @@ fn test_gen() {\n         #[serde(flatten, skip_deserializing)]\n         flat: T,\n     }\n+\n+    // https://github.com/serde-rs/serde/issues/1804\n+    #[derive(Serialize, Deserialize)]\n+    enum Message {\n+        #[serde(skip)]\n+        #[allow(dead_code)]\n+        String(String),\n+        #[serde(other)]\n+        Unknown,\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "derive(Deserialize) panics with index out of bounds for `#[serde(skip)]`\nObserved in this commit\r\n\r\nhttps://github.com/matklad/cargo_metadata/commit/0b1c8d85c860fe9fb3488fea5990d659780065fc\r\n\r\n```\r\n   Compiling cargo_metadata v0.9.1 (/home/matklad/projects/cargo_metadata)\r\nerror: proc-macro derive panicked\r\n  --> src/messages.rs:99:35\r\n   |\r\n99 | #[derive(Debug, Clone, Serialize, Deserialize)]\r\n   |                                   ^^^^^^^^^^^\r\n   |\r\n   = help: message: index out of bounds: the len is 5 but the index is 5\r\n\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `cargo_metadata`.\r\n```\r\n\r\nI think I am doing something very stupid with this skip, which is a bug in my code, *but* I think serde still should not panic, but rather explain me that I am holding it wrong? \r\n\r\nserde_derive version = \"1.0.106\"\n", "hints_text": "", "created_at": "2020-05-08T22:40:13Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1706, "instance_id": "serde-rs__serde-1706", "issue_numbers": ["1553"], "base_commit": "a81968af3caea9528e8e935a9a19ccad19a16778", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 64113a603..c3b779bf9 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -1379,42 +1379,37 @@ fn deserialize_adjacently_tagged_enum(\n         }\n     };\n \n-    fn is_unit(variant: &Variant) -> bool {\n-        match variant.style {\n-            Style::Unit => true,\n-            Style::Struct | Style::Tuple | Style::Newtype => false,\n-        }\n-    }\n+    let arms = variants\n+        .iter()\n+        .enumerate()\n+        .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n+        .filter_map(|(i, variant)| {\n+            let variant_index = field_i(i);\n+            let variant_ident = &variant.ident;\n \n-    let mut missing_content = quote! {\n-        _serde::export::Err(<__A::Error as _serde::de::Error>::missing_field(#content))\n-    };\n-    if variants.iter().any(is_unit) {\n-        let fallthrough = if variants.iter().all(is_unit) {\n-            None\n-        } else {\n+            let arm = match variant.style {\n+                Style::Unit => quote! {\n+                    _serde::export::Ok(#this::#variant_ident)\n+                },\n+                Style::Newtype if variant.attrs.deserialize_with().is_none() => {\n+                    let span = variant.original.span();\n+                    let func = quote_spanned!(span=> _serde::private::de::missing_field);\n+                    quote! {\n+                        #func(#content).map(#this::#variant_ident)\n+                    }\n+                }\n+                _ => return None,\n+            };\n             Some(quote! {\n-                _ => #missing_content\n+                __Field::#variant_index => #arm,\n             })\n-        };\n-        let arms = variants\n-            .iter()\n-            .enumerate()\n-            .filter(|&(_, variant)| !variant.attrs.skip_deserializing() && is_unit(variant))\n-            .map(|(i, variant)| {\n-                let variant_index = field_i(i);\n-                let variant_ident = &variant.ident;\n-                quote! {\n-                    __Field::#variant_index => _serde::export::Ok(#this::#variant_ident),\n-                }\n-            });\n-        missing_content = quote! {\n-            match __field {\n-                #(#arms)*\n-                #fallthrough\n-            }\n-        };\n-    }\n+        });\n+    let missing_content = quote! {\n+        match __field {\n+            #(#arms)*\n+            _ => _serde::export::Err(<__A::Error as _serde::de::Error>::missing_field(#content))\n+        }\n+    };\n \n     // Advance the map by one key, returning early in case of error.\n     let next_key = quote! {\n", "test_patch": "diff --git a/test_suite/tests/test_macros.rs b/test_suite/tests/test_macros.rs\nindex d4456bed7..c0c807ec7 100644\n--- a/test_suite/tests/test_macros.rs\n+++ b/test_suite/tests/test_macros.rs\n@@ -1145,6 +1145,20 @@ fn test_adjacently_tagged_enum() {\n         ],\n     );\n \n+    // optional newtype with no content field\n+    assert_de_tokens(\n+        &AdjacentlyTagged::Newtype::<Option<u8>>(None),\n+        &[\n+            Token::Struct {\n+                name: \"AdjacentlyTagged\",\n+                len: 1,\n+            },\n+            Token::Str(\"t\"),\n+            Token::Str(\"Newtype\"),\n+            Token::StructEnd,\n+        ],\n+    );\n+\n     // tuple with tag first\n     assert_tokens(\n         &AdjacentlyTagged::Tuple::<u8>(1, 1),\n", "problem_statement": "Optional content for enum variants?\nHi!\r\nI need to de/serialize JSON messages such as the following:\r\n```javascript\r\n{ ...,  \"command\": \"cmd1\", \"arguments\": { <command-dependent> } }\r\n```\r\nSo far so good, this fits the adjacently tagged enum representation.   \r\nThe wrinkle is that for some commands the `arguments` field may be optional.   I tried modelling this as \r\n```rust\r\n#[serde(tag = \"command\", content = \"arguments\")]\r\nenum Command {\r\n    cmd1(Option<Cmd1Arguments>)\r\n    ...\r\n}\r\n```\r\nbut Serde is not liking it and complains about \"missing field \\`arguments\\`\".\r\n\r\nAny suggestions? (besides custom serialization)\n", "hints_text": "", "created_at": "2020-01-06T21:07:44Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1695, "instance_id": "serde-rs__serde-1695", "issue_numbers": ["1061"], "base_commit": "ad94aed75398d43d174368aa8c4869332bb94e33", "patch": "diff --git a/serde_derive/src/internals/ast.rs b/serde_derive/src/internals/ast.rs\nindex 8bcb0ecd1..75b28c969 100644\n--- a/serde_derive/src/internals/ast.rs\n+++ b/serde_derive/src/internals/ast.rs\n@@ -88,9 +88,12 @@ impl<'a> Container<'a> {\n                         if field.attrs.flatten() {\n                             has_flatten = true;\n                         }\n-                        field\n-                            .attrs\n-                            .rename_by_rules(variant.attrs.rename_all_rules());\n+                        field.attrs.rename_by_rules(\n+                            variant\n+                                .attrs\n+                                .rename_all_rules()\n+                                .or(attrs.rename_all_fields_rules()),\n+                        );\n                     }\n                 }\n             }\ndiff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex 42212a64d..133299564 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -193,11 +193,23 @@ impl Name {\n     }\n }\n \n+#[derive(Copy, Clone)]\n pub struct RenameAllRules {\n     serialize: RenameRule,\n     deserialize: RenameRule,\n }\n \n+impl RenameAllRules {\n+    /// Returns a new `RenameAllRules` with the individual rules of `self` and\n+    /// `other_rules` joined by `RenameRules::or`.\n+    pub fn or(self, other_rules: Self) -> Self {\n+        Self {\n+            serialize: self.serialize.or(other_rules.serialize),\n+            deserialize: self.deserialize.or(other_rules.deserialize),\n+        }\n+    }\n+}\n+\n /// Represents struct or enum attribute information.\n pub struct Container {\n     name: Name,\n@@ -205,6 +217,7 @@ pub struct Container {\n     deny_unknown_fields: bool,\n     default: Default,\n     rename_all_rules: RenameAllRules,\n+    rename_all_fields_rules: RenameAllRules,\n     ser_bound: Option<Vec<syn::WherePredicate>>,\n     de_bound: Option<Vec<syn::WherePredicate>>,\n     tag: TagType,\n@@ -288,6 +301,8 @@ impl Container {\n         let mut default = Attr::none(cx, DEFAULT);\n         let mut rename_all_ser_rule = Attr::none(cx, RENAME_ALL);\n         let mut rename_all_de_rule = Attr::none(cx, RENAME_ALL);\n+        let mut rename_all_fields_ser_rule = Attr::none(cx, RENAME_ALL_FIELDS);\n+        let mut rename_all_fields_de_rule = Attr::none(cx, RENAME_ALL_FIELDS);\n         let mut ser_bound = Attr::none(cx, BOUND);\n         let mut de_bound = Attr::none(cx, BOUND);\n         let mut untagged = BoolAttr::none(cx, UNTAGGED);\n@@ -341,6 +356,44 @@ impl Container {\n                             }\n                         }\n                     }\n+                } else if meta.path == RENAME_ALL_FIELDS {\n+                    // #[serde(rename_all_fields = \"foo\")]\n+                    // #[serde(rename_all_fields(serialize = \"foo\", deserialize = \"bar\"))]\n+                    let one_name = meta.input.peek(Token![=]);\n+                    let (ser, de) = get_renames(cx, RENAME_ALL_FIELDS, &meta)?;\n+\n+                    match item.data {\n+                        syn::Data::Enum(_) => {\n+                            if let Some(ser) = ser {\n+                                match RenameRule::from_str(&ser.value()) {\n+                                    Ok(rename_rule) => {\n+                                        rename_all_fields_ser_rule.set(&meta.path, rename_rule);\n+                                    }\n+                                    Err(err) => cx.error_spanned_by(ser, err),\n+                                }\n+                            }\n+                            if let Some(de) = de {\n+                                match RenameRule::from_str(&de.value()) {\n+                                    Ok(rename_rule) => {\n+                                        rename_all_fields_de_rule.set(&meta.path, rename_rule);\n+                                    }\n+                                    Err(err) => {\n+                                        if !one_name {\n+                                            cx.error_spanned_by(de, err);\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        syn::Data::Struct(_) => {\n+                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n+                            cx.error_spanned_by(&meta.path, msg);\n+                        }\n+                        syn::Data::Union(_) => {\n+                            let msg = \"#[serde(rename_all_fields)] can only be used on enums\";\n+                            cx.error_spanned_by(&meta.path, msg);\n+                        }\n+                    }\n                 } else if meta.path == TRANSPARENT {\n                     // #[serde(transparent)]\n                     transparent.set_true(meta.path);\n@@ -528,6 +581,10 @@ impl Container {\n                 serialize: rename_all_ser_rule.get().unwrap_or(RenameRule::None),\n                 deserialize: rename_all_de_rule.get().unwrap_or(RenameRule::None),\n             },\n+            rename_all_fields_rules: RenameAllRules {\n+                serialize: rename_all_fields_ser_rule.get().unwrap_or(RenameRule::None),\n+                deserialize: rename_all_fields_de_rule.get().unwrap_or(RenameRule::None),\n+            },\n             ser_bound: ser_bound.get(),\n             de_bound: de_bound.get(),\n             tag: decide_tag(cx, item, untagged, internal_tag, content),\n@@ -547,8 +604,12 @@ impl Container {\n         &self.name\n     }\n \n-    pub fn rename_all_rules(&self) -> &RenameAllRules {\n-        &self.rename_all_rules\n+    pub fn rename_all_rules(&self) -> RenameAllRules {\n+        self.rename_all_rules\n+    }\n+\n+    pub fn rename_all_fields_rules(&self) -> RenameAllRules {\n+        self.rename_all_fields_rules\n     }\n \n     pub fn transparent(&self) -> bool {\n@@ -921,7 +982,7 @@ impl Variant {\n         self.name.deserialize_aliases()\n     }\n \n-    pub fn rename_by_rules(&mut self, rules: &RenameAllRules) {\n+    pub fn rename_by_rules(&mut self, rules: RenameAllRules) {\n         if !self.name.serialize_renamed {\n             self.name.serialize = rules.serialize.apply_to_variant(&self.name.serialize);\n         }\n@@ -930,8 +991,8 @@ impl Variant {\n         }\n     }\n \n-    pub fn rename_all_rules(&self) -> &RenameAllRules {\n-        &self.rename_all_rules\n+    pub fn rename_all_rules(&self) -> RenameAllRules {\n+        self.rename_all_rules\n     }\n \n     pub fn ser_bound(&self) -> Option<&[syn::WherePredicate]> {\n@@ -1260,7 +1321,7 @@ impl Field {\n         self.name.deserialize_aliases()\n     }\n \n-    pub fn rename_by_rules(&mut self, rules: &RenameAllRules) {\n+    pub fn rename_by_rules(&mut self, rules: RenameAllRules) {\n         if !self.name.serialize_renamed {\n             self.name.serialize = rules.serialize.apply_to_field(&self.name.serialize);\n         }\ndiff --git a/serde_derive/src/internals/case.rs b/serde_derive/src/internals/case.rs\nindex 554505160..e769462cd 100644\n--- a/serde_derive/src/internals/case.rs\n+++ b/serde_derive/src/internals/case.rs\n@@ -59,8 +59,8 @@ impl RenameRule {\n     }\n \n     /// Apply a renaming rule to an enum variant, returning the version expected in the source.\n-    pub fn apply_to_variant(&self, variant: &str) -> String {\n-        match *self {\n+    pub fn apply_to_variant(self, variant: &str) -> String {\n+        match self {\n             None | PascalCase => variant.to_owned(),\n             LowerCase => variant.to_ascii_lowercase(),\n             UpperCase => variant.to_ascii_uppercase(),\n@@ -84,8 +84,8 @@ impl RenameRule {\n     }\n \n     /// Apply a renaming rule to a struct field, returning the version expected in the source.\n-    pub fn apply_to_field(&self, field: &str) -> String {\n-        match *self {\n+    pub fn apply_to_field(self, field: &str) -> String {\n+        match self {\n             None | LowerCase | SnakeCase => field.to_owned(),\n             UpperCase => field.to_ascii_uppercase(),\n             PascalCase => {\n@@ -112,6 +112,14 @@ impl RenameRule {\n             ScreamingKebabCase => ScreamingSnakeCase.apply_to_field(field).replace('_', \"-\"),\n         }\n     }\n+\n+    /// Returns the `RenameRule` if it is not `None`, `rule_b` otherwise.\n+    pub fn or(self, rule_b: Self) -> Self {\n+        match self {\n+            None => rule_b,\n+            _ => self,\n+        }\n+    }\n }\n \n pub struct ParseError<'a> {\ndiff --git a/serde_derive/src/internals/symbol.rs b/serde_derive/src/internals/symbol.rs\nindex 9606edb5f..68091fb85 100644\n--- a/serde_derive/src/internals/symbol.rs\n+++ b/serde_derive/src/internals/symbol.rs\n@@ -23,6 +23,7 @@ pub const OTHER: Symbol = Symbol(\"other\");\n pub const REMOTE: Symbol = Symbol(\"remote\");\n pub const RENAME: Symbol = Symbol(\"rename\");\n pub const RENAME_ALL: Symbol = Symbol(\"rename_all\");\n+pub const RENAME_ALL_FIELDS: Symbol = Symbol(\"rename_all_fields\");\n pub const REPR: Symbol = Symbol(\"repr\");\n pub const SERDE: Symbol = Symbol(\"serde\");\n pub const SERIALIZE: Symbol = Symbol(\"serialize\");\n", "test_patch": "diff --git a/test_suite/tests/test_macros.rs b/test_suite/tests/test_macros.rs\nindex 0594d8d45..d95fa928f 100644\n--- a/test_suite/tests/test_macros.rs\n+++ b/test_suite/tests/test_macros.rs\n@@ -1924,6 +1924,62 @@ fn test_rename_all() {\n     );\n }\n \n+#[test]\n+fn test_rename_all_fields() {\n+    #[derive(Serialize, Deserialize, Debug, PartialEq)]\n+    #[serde(rename_all_fields = \"kebab-case\")]\n+    enum E {\n+        V1,\n+        V2(bool),\n+        V3 {\n+            a_field: bool,\n+            another_field: bool,\n+            #[serde(rename = \"last-field\")]\n+            yet_another_field: bool,\n+        },\n+        #[serde(rename_all = \"snake_case\")]\n+        V4 {\n+            a_field: bool,\n+        },\n+    }\n+\n+    assert_tokens(\n+        &E::V3 {\n+            a_field: true,\n+            another_field: true,\n+            yet_another_field: true,\n+        },\n+        &[\n+            Token::StructVariant {\n+                name: \"E\",\n+                variant: \"V3\",\n+                len: 3,\n+            },\n+            Token::Str(\"a-field\"),\n+            Token::Bool(true),\n+            Token::Str(\"another-field\"),\n+            Token::Bool(true),\n+            Token::Str(\"last-field\"),\n+            Token::Bool(true),\n+            Token::StructVariantEnd,\n+        ],\n+    );\n+\n+    assert_tokens(\n+        &E::V4 { a_field: true },\n+        &[\n+            Token::StructVariant {\n+                name: \"E\",\n+                variant: \"V4\",\n+                len: 1,\n+            },\n+            Token::Str(\"a_field\"),\n+            Token::Bool(true),\n+            Token::StructVariantEnd,\n+        ],\n+    );\n+}\n+\n #[test]\n fn test_untagged_newtype_variant_containing_unit_struct_not_map() {\n     #[derive(Debug, PartialEq, Serialize, Deserialize)]\n", "problem_statement": "Apply rename_all to enum member \"fields\"\nWhen using enums with struct-like members it would be useful if `rename_all` on the enclosing enum could apply to the members, too. For example:\r\n\r\n```rust\r\n#[serde(untagged, rename_all = \"camelCase\" )]\r\npub enum Value {\r\n  Null { null_value: () },\r\n  String { string_value: String },\r\n  Boolean { boolean_value: bool },\r\n}\r\n```\r\ncould do\r\n\r\n```json\r\nValue::String(\"foo\".to_string())\r\n=> \r\n{ \"stringValue\": \"foo\" }\r\n  ------^-----\r\n        |\r\nThis here is what I want\r\n```\r\n\r\nCurrently the annotation has to be placed on the fields in addition:\r\n\r\n```rust\r\n#[serde(untagged)]\r\npub enum Value {\r\n    Null {\r\n        #[serde(rename = \"nullValue\")]\r\n        null_value: ()\r\n    },\r\n    String {\r\n        #[serde(rename = \"stringValue\")]\r\n        string_value: String\r\n    },\r\n    /* etc. */\r\n}\r\n```\r\n\r\n(If you're wondering what is going on with this type, it's [Google Datastore](https://cloud.google.com/datastore/docs/reference/rest/v1/projects/runQuery#Value)).\n", "hints_text": "Seems reasonable. Do you have a suggestion for how this should work? Simplify changing the meaning of `rename_all` would be a breaking change.\r\n\r\nSide note: representing the datastore value the following way may be more convenient. This avoids restating the type twice in Rust code -- <code>Value::<b>Boolean</b>(true)</code> instead of <code>Value::<b>Boolean</b> { <b>boolean</b>_value: true }</code>.\r\n\r\n```rust\r\n#[derive(Serialize, Deserialize)]\r\nenum Value {\r\n    #[serde(rename = \"nullValue\", with = \"null\")]\r\n    Null,\r\n    #[serde(rename = \"stringValue\")]\r\n    String(String),\r\n    #[serde(rename = \"booleanValue\")]\r\n    Boolean(bool),\r\n}\r\n\r\n// Serialize the unit variant `Value::Null` as `{\"nullValue\":null}` rather\r\n// than the default `\"nullValue\"`.\r\nmod null {\r\n    use serde::{Serialize, Serializer, Deserialize, Deserializer};\r\n\r\n    pub fn serialize<S>(serializer: S) -> Result<S::Ok, S::Error>\r\n        where S: Serializer\r\n    {\r\n        ().serialize(serializer)\r\n    }\r\n    \r\n    pub fn deserialize<'de, D>(deserializer: D) -> Result<(), D::Error>\r\n        where D: Deserializer<'de>\r\n    {\r\n        <()>::deserialize(deserializer)\r\n    }\r\n}\r\n```\nThanks for a quick reply! I'm really enjoying `serde` btw, easily the most pleasant serialisation lib I've worked with so far :-)\r\n\r\n----------------\r\n\r\n> Do you have a suggestion for how this should work? Simplify changing the meaning of rename_all would be a breaking change.\r\n\r\nAgreed, maybe it's sensible to have a separate `rename_fields` for this that would both apply to `struct` and `enum`-member fields?\r\n\r\n---------------\r\n\r\n> Side note: representing the datastore value the following way may be more convenient\r\n\r\nThe problem is that the enum is \"key-tagged\", i.e. it's adjacent to other keys inside of a different struct and the *key* that contains the `Value` determines its type.\r\n\r\nI haven't found a better way than the current `untagged` solution, but I also really need to stop thinking about this for today and find a nearby bed! ;-)\nMaybe instead of `rename_all` we should have had distinct `rename_fields` and `rename_variants` attributes, so that you can write both to get the desired effect.\r\n\r\nIt may be confusing to add those now and *not* have `rename_all` mean rename both fields and variants.\nI would be willing to consider a pull request that adds a `serde(rename_all_fields = \"...\")` attribute for enums that applies a rename rule to every field of every variant.", "created_at": "2019-12-15T18:14:14Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1656, "instance_id": "serde-rs__serde-1656", "issue_numbers": ["1633"], "base_commit": "cf314185558f92fecc4f81ea98b3648967bfc8ea", "patch": "diff --git a/serde/build.rs b/serde/build.rs\nindex e36ed62f5..a78b6d79a 100644\n--- a/serde/build.rs\n+++ b/serde/build.rs\n@@ -29,8 +29,9 @@ fn main() {\n         println!(\"cargo:rustc-cfg=core_reverse\");\n     }\n \n-    // CString::into_boxed_c_str stabilized in Rust 1.20:\n+    // CString::into_boxed_c_str and PathBuf::into_boxed_path stabilized in Rust 1.20:\n     // https://doc.rust-lang.org/std/ffi/struct.CString.html#method.into_boxed_c_str\n+    // https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.into_boxed_path\n     if minor >= 20 {\n         println!(\"cargo:rustc-cfg=de_boxed_c_str\");\n     }\ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex e96314809..cffe05900 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -1580,6 +1580,24 @@ impl<'de> Visitor<'de> for PathBufVisitor {\n     {\n         Ok(From::from(v))\n     }\n+\n+    fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n+    where\n+        E: Error,\n+    {\n+        str::from_utf8(v)\n+            .map(From::from)\n+            .map_err(|_| Error::invalid_value(Unexpected::Bytes(v), &self))\n+    }\n+\n+    fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n+    where\n+        E: Error,\n+    {\n+        String::from_utf8(v)\n+            .map(From::from)\n+            .map_err(|e| Error::invalid_value(Unexpected::Bytes(&e.into_bytes()), &self))\n+    }\n }\n \n #[cfg(feature = \"std\")]\n@@ -1592,6 +1610,9 @@ impl<'de> Deserialize<'de> for PathBuf {\n     }\n }\n \n+#[cfg(all(feature = \"std\", de_boxed_c_str))]\n+forwarded_impl!((), Box<Path>, PathBuf::into_boxed_path);\n+\n ////////////////////////////////////////////////////////////////////////////////\n \n // If this were outside of the serde crate, it would just use:\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 16628efd6..025d87b09 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -889,11 +889,37 @@ declare_tests! {\n         Path::new(\"/usr/local/lib\") => &[\n             Token::BorrowedStr(\"/usr/local/lib\"),\n         ],\n+        Path::new(\"/usr/local/lib\") => &[\n+            Token::BorrowedBytes(b\"/usr/local/lib\"),\n+        ],\n     }\n     test_path_buf {\n         PathBuf::from(\"/usr/local/lib\") => &[\n+            Token::Str(\"/usr/local/lib\"),\n+        ],\n+        PathBuf::from(\"/usr/local/lib\") => &[\n+            Token::String(\"/usr/local/lib\"),\n+        ],\n+        PathBuf::from(\"/usr/local/lib\") => &[\n+            Token::Bytes(b\"/usr/local/lib\"),\n+        ],\n+        PathBuf::from(\"/usr/local/lib\") => &[\n+            Token::ByteBuf(b\"/usr/local/lib\"),\n+        ],\n+    }\n+    test_boxed_path {\n+        PathBuf::from(\"/usr/local/lib\").into_boxed_path() => &[\n+            Token::Str(\"/usr/local/lib\"),\n+        ],\n+        PathBuf::from(\"/usr/local/lib\").into_boxed_path() => &[\n             Token::String(\"/usr/local/lib\"),\n         ],\n+        PathBuf::from(\"/usr/local/lib\").into_boxed_path() => &[\n+            Token::Bytes(b\"/usr/local/lib\"),\n+        ],\n+        PathBuf::from(\"/usr/local/lib\").into_boxed_path() => &[\n+            Token::ByteBuf(b\"/usr/local/lib\"),\n+        ],\n     }\n     test_cstring {\n         CString::new(\"abc\").unwrap() => &[\n", "problem_statement": "Support deserializing Box<Path>\nI've tried to derive `Deserialize` for a `Rc<Path>` field, which fails.\r\n\r\nIf I understand the code correctly, it's missing a\r\n```\r\nforwarded_impl!((), Box<Path>, PathBuf::into_boxed_path);\r\n```\r\nso the `Rc<Path>` forwards to `Box<Path>` forwards to `PathBuf`.\n", "hints_text": "Thanks, I would accept a PR to fix this.", "created_at": "2019-10-22T20:59:50Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1622, "instance_id": "serde-rs__serde-1622", "issue_numbers": ["1396"], "base_commit": "4cea81f93f12473e0ccbdad2ddecff1f7ea85402", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex acc6dfb70..d54309c85 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -1689,6 +1689,24 @@ fn deserialize_externally_tagged_variant(\n             }\n         }\n         Style::Newtype => {\n+            if variant.fields[0].attrs.skip_deserializing() {\n+                let this = &params.this;\n+                let let_default = match variant.fields[0].attrs.default() {\n+                    attr::Default::Default => quote!(\n+                        _serde::export::Default::default()\n+                    ),\n+                    attr::Default::Path(ref path) => quote!(\n+                        #path()\n+                    ),\n+                    attr::Default::None => unimplemented!(),\n+                };\n+\n+\n+                return quote_block! {\n+                    try!(_serde::de::VariantAccess::unit_variant(__variant));\n+                    _serde::export::Ok(#this::#variant_ident(#let_default))\n+                };   \n+            }\n             deserialize_externally_tagged_newtype_variant(variant_ident, params, &variant.fields[0])\n         }\n         Style::Tuple => {\n@@ -1839,6 +1857,21 @@ fn deserialize_untagged_newtype_variant(\n     let field_ty = field.ty;\n     match field.attrs.deserialize_with() {\n         None => {\n+            if field.attrs.skip_deserializing() {\n+                let let_default = match field.attrs.default() {\n+                    attr::Default::Default => quote!(\n+                        _serde::export::Default::default()\n+                    ),\n+                    attr::Default::Path(ref path) => quote!(\n+                        #path()\n+                    ),\n+                    attr::Default::None => unimplemented!(),\n+                };\n+\n+                return quote_expr! {\n+                    _serde::export::Ok(#this::#variant_ident(#let_default))\n+                };\n+            }\n             let span = field.original.span();\n             let func = quote_spanned!(span=> <#field_ty as _serde::Deserialize>::deserialize);\n             quote_expr! {\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 57caaaff5..e79b8e7eb 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -522,6 +522,16 @@ fn serialize_externally_tagged_variant(\n         }\n         Style::Newtype => {\n             let field = &variant.fields[0];\n+            if field.attrs.skip_serializing() {\n+                return quote_expr! {\n+                    _serde::Serializer::serialize_unit_variant(\n+                        __serializer,\n+                        #type_name,\n+                        #variant_index,\n+                        #variant_name,\n+                    )\n+                }\n+            }\n             let mut field_expr = quote!(__field0);\n             if let Some(path) = field.attrs.serialize_with() {\n                 field_expr = wrap_serialize_field_with(params, field.ty, path, &field_expr);\n@@ -598,6 +608,15 @@ fn serialize_internally_tagged_variant(\n         }\n         Style::Newtype => {\n             let field = &variant.fields[0];\n+            if field.attrs.skip_serializing() {\n+                return quote_block! {\n+                    let mut __struct = try!(_serde::Serializer::serialize_struct(\n+                        __serializer, #type_name, 1));\n+                    try!(_serde::ser::SerializeStruct::serialize_field(\n+                        &mut __struct, #tag, #variant_name));\n+                    _serde::ser::SerializeStruct::end(__struct)\n+                };\n+            }\n             let mut field_expr = quote!(__field0);\n             if let Some(path) = field.attrs.serialize_with() {\n                 field_expr = wrap_serialize_field_with(params, field.ty, path, &field_expr);\n@@ -658,6 +677,15 @@ fn serialize_adjacently_tagged_variant(\n             }\n             Style::Newtype => {\n                 let field = &variant.fields[0];\n+                if field.attrs.skip_serializing() {\n+                     return quote_block! {\n+                        let mut __struct = try!(_serde::Serializer::serialize_struct(\n+                            __serializer, #type_name, 1));\n+                        try!(_serde::ser::SerializeStruct::serialize_field(\n+                            &mut __struct, #tag, #variant_name));\n+                        _serde::ser::SerializeStruct::end(__struct)\n+                    };   \n+                }\n                 let mut field_expr = quote!(__field0);\n                 if let Some(path) = field.attrs.serialize_with() {\n                     field_expr = wrap_serialize_field_with(params, field.ty, path, &field_expr);\n@@ -761,6 +789,11 @@ fn serialize_untagged_variant(\n         }\n         Style::Newtype => {\n             let field = &variant.fields[0];\n+            if field.attrs.skip_serializing() {\n+                return quote_expr! {\n+                    _serde::Serializer::serialize_unit(__serializer)\n+                };\n+            }\n             let mut field_expr = quote!(__field0);\n             if let Some(path) = field.attrs.serialize_with() {\n                 field_expr = wrap_serialize_field_with(params, field.ty, path, &field_expr);\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 3946865b8..16628efd6 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -104,6 +104,9 @@ struct StructSkipAllDenyUnknown {\n     a: i32,\n }\n \n+#[derive(Default, PartialEq, Debug)]\n+struct NotDeserializable;\n+\n #[derive(PartialEq, Debug, Deserialize)]\n enum Enum {\n     #[allow(dead_code)]\n@@ -117,6 +120,7 @@ enum Enum {\n         b: i32,\n         c: i32,\n     },\n+    SimpleWithSkipped(#[serde(skip_deserializing)] NotDeserializable),\n }\n \n #[derive(PartialEq, Debug, Deserialize)]\n@@ -728,6 +732,11 @@ declare_tests! {\n             Token::I32(1),\n         ],\n     }\n+    test_enum_simple_with_skipped {\n+        Enum::SimpleWithSkipped(NotDeserializable) => &[\n+            Token::UnitVariant { name: \"Enum\", variant: \"SimpleWithSkipped\" },\n+        ],\n+    }\n     test_enum_seq {\n         Enum::Seq(1, 2, 3) => &[\n             Token::TupleVariant { name: \"Enum\", variant: \"Seq\", len: 3 },\n@@ -1217,13 +1226,13 @@ declare_error_tests! {\n         &[\n             Token::UnitVariant { name: \"Enum\", variant: \"Foo\" },\n         ],\n-        \"unknown variant `Foo`, expected one of `Unit`, `Simple`, `Seq`, `Map`\",\n+        \"unknown variant `Foo`, expected one of `Unit`, `Simple`, `Seq`, `Map`, `SimpleWithSkipped`\",\n     }\n     test_enum_skipped_variant<Enum> {\n         &[\n             Token::UnitVariant { name: \"Enum\", variant: \"Skipped\" },\n         ],\n-        \"unknown variant `Skipped`, expected one of `Unit`, `Simple`, `Seq`, `Map`\",\n+        \"unknown variant `Skipped`, expected one of `Unit`, `Simple`, `Seq`, `Map`, `SimpleWithSkipped`\",\n     }\n     test_enum_skip_all<EnumSkipAll> {\n         &[\n@@ -1254,10 +1263,10 @@ declare_error_tests! {\n     test_enum_out_of_range<Enum> {\n         &[\n             Token::Enum { name: \"Enum\" },\n-            Token::U32(4),\n+            Token::U32(5),\n             Token::Unit,\n         ],\n-        \"invalid value: integer `4`, expected variant index 0 <= i < 4\",\n+        \"invalid value: integer `5`, expected variant index 0 <= i < 5\",\n     }\n     test_short_tuple<(u8, u8, u8)> {\n         &[\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex 719e987d8..68293f5a1 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -44,6 +44,9 @@ struct Struct {\n     c: i32,\n }\n \n+#[derive(PartialEq, Debug)]\n+struct NotSerializable;\n+\n #[derive(Serialize, PartialEq, Debug)]\n enum Enum {\n     Unit,\n@@ -64,6 +67,7 @@ enum Enum {\n         _a: i32,\n         _b: i32,\n     },\n+    OneWithSkipped(#[serde(skip_serializing)] NotSerializable),\n }\n \n //////////////////////////////////////////////////////////////////////////\n@@ -326,6 +330,7 @@ declare_tests! {\n                 Token::I32(2),\n             Token::StructVariantEnd,\n         ],\n+        Enum::OneWithSkipped(NotSerializable) => &[Token::UnitVariant {name: \"Enum\", variant: \"OneWithSkipped\" }],\n     }\n     test_box {\n         Box::new(0i32) => &[Token::I32(0)],\n", "problem_statement": "#[serde(skip)] in tuple enum variants silently ignored\n```rust\r\n#[macro_use]\r\nextern crate serde_derive; // 1.0.78\r\nextern crate serde; // 1.0.78\r\n\r\nstruct S;\r\n\r\n#[derive(Serialize)]\r\nenum E {\r\n    V(#[serde(skip)] S),\r\n}\r\n\r\n```\r\n\r\n```\r\nerror[E0277]: the trait bound `S: serde::Serialize` is not satisfied\r\n --> src/lib.rs:7:10\r\n  |\r\n7 | #[derive(Serialize)]\r\n  |          ^^^^^^^^^ the trait `serde::Serialize` is not implemented for `S`\r\n  |\r\n  = note: required by `serde::Serializer::serialize_newtype_variant`\r\n\r\nerror: aborting due to previous error\r\n```\r\n\r\n[Playground](https://play.rust-lang.org/?gist=52468306cc60f55fd62d11eba4a1ca45&version=stable&mode=debug&edition=2015)\r\n\r\nThe attribute should either work (thus serializing like `enum E { V() }` or give an error/warning that it has no meaning in this position.\n", "hints_text": "Just ran into this today. Changing the variant into \r\n```rust\r\nenum E { \r\n   V { #[serde(skip)] v: S } \r\n}\r\n```\r\nmakes it work as expected. I think should just work instead of an error. This is likely a bug. \nThis also applies to tuple structs (e.g. `struct Ignore(#[serde(skip)] Foo);`).\nMight be related to why `#[serde(default)]` is also ignored: https://github.com/serde-rs/serde/issues/1418.", "created_at": "2019-09-07T09:28:37Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1572, "instance_id": "serde-rs__serde-1572", "issue_numbers": ["1496"], "base_commit": "ce89adecc12b909e32548b1b929d443d62647029", "patch": "diff --git a/serde/build.rs b/serde/build.rs\nindex e27e2f34f..ae0f98690 100644\n--- a/serde/build.rs\n+++ b/serde/build.rs\n@@ -68,6 +68,10 @@ fn main() {\n     if minor >= 28 {\n         println!(\"cargo:rustc-cfg=num_nonzero\");\n     }\n+\n+    if minor >= 34 {\n+        println!(\"cargo:rustc-cfg=std_integer_atomics\");\n+    }\n }\n \n fn rustc_minor_version() -> Option<u32> {\ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 1d4c31878..0a28c43ed 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -2543,3 +2543,56 @@ where\n         Deserialize::deserialize(deserializer).map(Wrapping)\n     }\n }\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+use std::sync::atomic;\n+\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+macro_rules! atomic_impl {\n+    ($ty:path, $primitive:ident) => {\n+        impl<'de> Deserialize<'de> for $ty\n+        {\n+            #[inline]\n+            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+                where D: Deserializer<'de>\n+            {\n+                let val = $primitive::deserialize(deserializer)?;\n+                Ok(Self::new(val))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicBool, bool);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicI8, i8);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicI16, i16);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicI32, i32);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicI64, i64);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicIsize, isize);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicU8, u8);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicU16, u16);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicU32, u32);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicU64, u64);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicUsize, usize);\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex fb0449a75..59b54117f 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -839,3 +839,55 @@ where\n         self.0.serialize(serializer)\n     }\n }\n+\n+////////////////////////////////////////////////////////////////////////////////\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+use std::sync::atomic;\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+macro_rules! atomic_impl {\n+    ($ty:path, $method:ident $($cast:tt)*) => {\n+        impl Serialize for $ty {\n+            #[inline]\n+            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+            where\n+                S: Serializer,\n+            {\n+                serializer.$method(self.load(atomic::Ordering::SeqCst) $($cast)*)\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicBool, serialize_bool);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicI8, serialize_i8);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicI16, serialize_i16);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicI32, serialize_i32);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicI64, serialize_i64);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicIsize, serialize_i64 as i64);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicU8, serialize_u8);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicU16, serialize_u16);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicU32, serialize_u32);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicU64, serialize_u64);\n+\n+#[cfg(all(feature=\"std\", std_integer_atomics))]\n+atomic_impl!(atomic::AtomicUsize, serialize_u64 as u64);\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 90e0f3951..c970b8de8 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -9,6 +9,7 @@ use std::num::Wrapping;\n use std::ops::Bound;\n use std::path::{Path, PathBuf};\n use std::rc::{Rc, Weak as RcWeak};\n+use std::sync::atomic;\n use std::sync::{Arc, Weak as ArcWeak};\n use std::time::{Duration, UNIX_EPOCH};\n \n@@ -1140,6 +1141,81 @@ fn test_never_type() {\n     );\n }\n \n+macro_rules! assert_de_tokens_atomic {\n+    ($ty:ty, $val:expr, $tokens:expr) => {\n+        let mut de = serde_test::Deserializer::new($tokens);\n+        match <$ty>::deserialize(&mut de) {\n+            Ok(v) => {\n+                let loaded = v.load(atomic::Ordering::SeqCst);\n+                assert_eq!($val, loaded);\n+            },\n+            Err(e) => panic!(\"tokens failed to deserialize: {}\", e)\n+        };\n+        if de.remaining() > 0 {\n+            panic!(\"{} remaining tokens\", de.remaining());\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_atomics() {\n+    assert_de_tokens_atomic!(\n+        atomic::AtomicBool,\n+        true,\n+        &[Token::Bool(true)]\n+    );\n+    assert_de_tokens_atomic!(\n+        atomic::AtomicI8,\n+        -127,\n+        &[Token::I8(-127i8)]\n+    );\n+    assert_de_tokens_atomic!(\n+        atomic::AtomicI16,\n+        -510,\n+        &[Token::I16(-510i16)]\n+    );\n+    assert_de_tokens_atomic!(\n+        atomic::AtomicI32,\n+        -131072,\n+        &[Token::I32(-131072i32)]\n+    );\n+    assert_de_tokens_atomic!(\n+        atomic::AtomicI64,\n+        -8589934592,\n+        &[Token::I64(-8589934592)]\n+    );\n+    assert_de_tokens_atomic!(\n+        atomic::AtomicIsize,\n+        -131072isize,\n+        &[Token::I32(-131072)]\n+    );\n+    assert_de_tokens_atomic!(\n+        atomic::AtomicU8,\n+        127,\n+        &[Token::U8(127u8)]\n+    );\n+    assert_de_tokens_atomic!(\n+        atomic::AtomicU16,\n+        510u16,\n+        &[Token::U16(510u16)]\n+    );\n+    assert_de_tokens_atomic!(\n+        atomic::AtomicU32,\n+        131072u32,\n+        &[Token::U32(131072u32)]\n+    );\n+    assert_de_tokens_atomic!(\n+        atomic::AtomicU64,\n+        8589934592u64,\n+        &[Token::U64(8589934592)]\n+    );\n+    assert_de_tokens_atomic!(\n+        atomic::AtomicUsize,\n+        131072usize,\n+        &[Token::U32(131072)]\n+    );\n+}\n+\n declare_error_tests! {\n     test_unknown_field<StructDenyUnknown> {\n         &[\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex 55be98004..88e349ae2 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -10,6 +10,7 @@ use std::ops::Bound;\n use std::path::{Path, PathBuf};\n use std::rc::{Rc, Weak as RcWeak};\n use std::sync::{Arc, Weak as ArcWeak};\n+use std::sync::atomic;\n use std::time::{Duration, UNIX_EPOCH};\n \n #[cfg(unix)]\n@@ -483,6 +484,20 @@ declare_tests! {\n             Token::Str(\"1a\"),\n         ],\n     }\n+    test_atomic {\n+        atomic::AtomicBool::new(false) => &[Token::Bool(false)],\n+        atomic::AtomicBool::new(true) => &[Token::Bool(true)],\n+        atomic::AtomicI8::new(63i8) => &[Token::I8(63i8)],\n+        atomic::AtomicI16::new(-318i16) => &[Token::I16(-318i16)],\n+        atomic::AtomicI32::new(65792i32) => &[Token::I32(65792i32)],\n+        atomic::AtomicI64::new(-4295032832i64) => &[Token::I64(-4295032832i64)],\n+        atomic::AtomicIsize::new(-65792isize) => &[Token::I64(-65792i64)],\n+        atomic::AtomicU8::new(192u8) => &[Token::U8(192u8)],\n+        atomic::AtomicU16::new(510u16) => &[Token::U16(510u16)],\n+        atomic::AtomicU32::new(131072u32) => &[Token::U32(131072u32)],\n+        atomic::AtomicU64::new(12884901888u64) => &[Token::U64(12884901888u64)],\n+        atomic::AtomicUsize::new(655360usize) => &[Token::U64(655360u64)],\n+    }\n }\n \n declare_tests! {\n", "problem_statement": "Support for atomics data types?\nHi,\r\n\r\nit seems like there is no Serialize support for atomic data type: https://doc.rust-lang.org/core/sync/atomic/index.html\r\n\r\nIs there any reason for this?\r\n\r\nA first implementation would be to simply load them using `Ordering::Relaxed` and that should be quite enough.\n", "hints_text": "I would prefer to match Debug which uses Ordering::SeqCst.\r\nhttps://github.com/rust-lang/rust/blob/1.33.0/src/libcore/sync/atomic.rs#L1137-L1141\r\n\r\nI would be prepared to consider a PR adding impls that use SeqCst.\nSeqCst is the strongest guarantee possible. This is ok and maybe even desiderable in debugging code, but I am not sure is desiderable on production code.\r\n\r\nWhat is your take on this? \r\n\r\nDo you believe performance won't be a concern? I am not sure of the performance characteristics of serde (never used) so I am really asking a little more feedback on your thoughts!\r\n\r\nCheers\nIf someone observes serialization of atomics as a bottleneck, they can use a `serialize_with` attribute to substitute in a Serialize impl with a weaker guarantee. SeqCst is a safe default with the least surprises and frequently no different performance.\nI am not sure if I got the time to do this anyway, I don't believe in the next few weeks at the very least.\r\n\r\nIf anybody wants to jump on it feel free to just implement it!", "created_at": "2019-07-12T01:19:39Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1559, "instance_id": "serde-rs__serde-1559", "issue_numbers": ["1558"], "base_commit": "4cb13b33e069c4e65f1dd66224b328928b5d9b1e", "patch": "diff --git a/serde/src/de/ignored_any.rs b/serde/src/de/ignored_any.rs\nindex 855d68e1a..68a644e0d 100644\n--- a/serde/src/de/ignored_any.rs\n+++ b/serde/src/de/ignored_any.rs\n@@ -1,6 +1,8 @@\n use lib::*;\n \n-use de::{Deserialize, Deserializer, Error, MapAccess, SeqAccess, Visitor};\n+use de::{\n+    Deserialize, Deserializer, EnumAccess, Error, MapAccess, SeqAccess, VariantAccess, Visitor,\n+};\n \n /// An efficient way of discarding data from a deserializer.\n ///\n@@ -205,6 +207,13 @@ impl<'de> Visitor<'de> for IgnoredAny {\n         let _ = bytes;\n         Ok(IgnoredAny)\n     }\n+\n+    fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n+    where\n+        A: EnumAccess<'de>,\n+    {\n+        data.variant::<IgnoredAny>()?.1.newtype_variant()\n+    }\n }\n \n impl<'de> Deserialize<'de> for IgnoredAny {\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex f1f7739d0..90e0f3951 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -124,6 +124,19 @@ enum EnumOther {\n     Other,\n }\n \n+#[derive(PartialEq, Debug)]\n+struct IgnoredAny;\n+\n+impl<'de> Deserialize<'de> for IgnoredAny {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        serde::de::IgnoredAny::deserialize(deserializer)?;\n+        Ok(IgnoredAny)\n+    }\n+}\n+\n //////////////////////////////////////////////////////////////////////////\n \n macro_rules! declare_tests {\n@@ -929,6 +942,21 @@ declare_tests! {\n             Token::SeqEnd,\n         ],\n     }\n+    test_ignored_any {\n+        IgnoredAny => &[\n+            Token::Str(\"s\"),\n+        ],\n+        IgnoredAny => &[\n+            Token::Seq { len: Some(1) },\n+            Token::Bool(true),\n+            Token::SeqEnd,\n+        ],\n+        IgnoredAny => &[\n+            Token::Enum { name: \"E\" },\n+            Token::Str(\"Rust\"),\n+            Token::Unit,\n+        ],\n+    }\n }\n \n declare_tests! {\ndiff --git a/test_suite/tests/test_ignored_any.rs b/test_suite/tests/test_ignored_any.rs\nnew file mode 100644\nindex 000000000..921cdfc79\n--- /dev/null\n+++ b/test_suite/tests/test_ignored_any.rs\n@@ -0,0 +1,104 @@\n+use serde::de::value::{Error, MapDeserializer, SeqDeserializer};\n+use serde::de::{\n+    DeserializeSeed, EnumAccess, IgnoredAny, IntoDeserializer, VariantAccess, Visitor,\n+};\n+use serde::{forward_to_deserialize_any, Deserialize, Deserializer};\n+\n+#[derive(PartialEq, Debug, Deserialize)]\n+enum Target {\n+    Unit,\n+    Newtype(i32),\n+    Tuple(i32, i32),\n+    Struct { a: i32 },\n+}\n+\n+struct Enum(&'static str);\n+\n+impl<'de> Deserializer<'de> for Enum {\n+    type Error = Error;\n+\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        visitor.visit_enum(self)\n+    }\n+\n+    forward_to_deserialize_any! {\n+        bool i8 i16 i32 i64 i128 u8 u16 u32 u64 u128 f32 f64 char str string\n+        bytes byte_buf option unit unit_struct newtype_struct seq tuple\n+        tuple_struct map struct enum identifier ignored_any\n+    }\n+}\n+\n+impl<'de> EnumAccess<'de> for Enum {\n+    type Error = Error;\n+    type Variant = Self;\n+\n+    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n+    where\n+        V: DeserializeSeed<'de>,\n+    {\n+        let v = seed.deserialize(self.0.into_deserializer())?;\n+        Ok((v, self))\n+    }\n+}\n+\n+impl<'de> VariantAccess<'de> for Enum {\n+    type Error = Error;\n+\n+    fn unit_variant(self) -> Result<(), Self::Error> {\n+        Ok(())\n+    }\n+\n+    fn newtype_variant_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n+    where\n+        T: DeserializeSeed<'de>,\n+    {\n+        seed.deserialize(10i32.into_deserializer())\n+    }\n+\n+    fn tuple_variant<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        let seq = SeqDeserializer::new(vec![1i32, 2].into_iter());\n+        visitor.visit_seq(seq)\n+    }\n+\n+    fn struct_variant<V>(\n+        self,\n+        _fields: &'static [&'static str],\n+        visitor: V,\n+    ) -> Result<V::Value, Self::Error>\n+    where\n+        V: Visitor<'de>,\n+    {\n+        let map = MapDeserializer::new(vec![(\"a\", 10i32)].into_iter());\n+        visitor.visit_map(map)\n+    }\n+}\n+\n+#[test]\n+fn test_deserialize_enum() {\n+    // First just make sure the Deserializer impl works\n+    assert_eq!(Target::Unit, Target::deserialize(Enum(\"Unit\")).unwrap());\n+    assert_eq!(\n+        Target::Newtype(10),\n+        Target::deserialize(Enum(\"Newtype\")).unwrap()\n+    );\n+    assert_eq!(\n+        Target::Tuple(1, 2),\n+        Target::deserialize(Enum(\"Tuple\")).unwrap()\n+    );\n+    assert_eq!(\n+        Target::Struct { a: 10 },\n+        Target::deserialize(Enum(\"Struct\")).unwrap()\n+    );\n+\n+    // Now try IgnoredAny\n+    IgnoredAny::deserialize(Enum(\"Unit\")).unwrap();\n+    IgnoredAny::deserialize(Enum(\"Newtype\")).unwrap();\n+    IgnoredAny::deserialize(Enum(\"Tuple\")).unwrap();\n+    IgnoredAny::deserialize(Enum(\"Struct\")).unwrap();\n+}\n", "problem_statement": "IgnoredAny doesn't handle enums, leading to a confusing error message\nIf IgnoredAny gets an enum, serde outputs the error message \"invalid type: enum, expected anything at all\", which doesn't make much sense. This is because IgnoredAny doesn't have a visit_enum impl. I think the intent might make sense if IgnoredAny doesn't know how to deserialize the enum. But \"expected anything at all\" doesn't really make sense as an error when an enum is clearly something.\n", "hints_text": "Actually, after thinking about it, I think this is always buggy behavior. If you agree I'd be happy to open a quick PR.", "created_at": "2019-06-27T17:32:56Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1521, "instance_id": "serde-rs__serde-1521", "issue_numbers": ["1513"], "base_commit": "28ce892617573d8da6d86bcb8a504aa1d8097b07", "patch": "diff --git a/.travis.yml b/.travis.yml\nindex f0e62b81e..7a2a44a42 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -26,8 +26,6 @@ matrix:\n         - cargo build --no-default-features --features alloc\n         - cargo build --no-default-features --features rc,alloc\n         - cargo test --features derive,rc,unstable\n-        - cd \"${TRAVIS_BUILD_DIR}/test_suite/deps\"\n-        - cargo build\n         - cd \"${TRAVIS_BUILD_DIR}/test_suite\"\n         - cargo test --features unstable\n         - cd \"${TRAVIS_BUILD_DIR}/test_suite/no_std\"\ndiff --git a/appveyor.yml b/appveyor.yml\nindex 1f99a9607..9fccc8dac 100644\n--- a/appveyor.yml\n+++ b/appveyor.yml\n@@ -35,7 +35,5 @@ for:\n       - cargo build --no-default-features --features alloc\n       - cargo build --no-default-features --features rc,alloc\n       - cargo test --features derive,rc,unstable\n-      - cd %APPVEYOR_BUILD_FOLDER%\\test_suite\\deps\n-      - cargo build\n       - cd %APPVEYOR_BUILD_FOLDER%\\test_suite\n       - cargo test --features unstable\n", "test_patch": "diff --git a/test_suite/Cargo.toml b/test_suite/Cargo.toml\nindex 4e793cb54..dbc8578bd 100644\n--- a/test_suite/Cargo.toml\n+++ b/test_suite/Cargo.toml\n@@ -7,14 +7,12 @@ publish = false\n \n [features]\n unstable = [\"serde/unstable\"]\n-compiletest = [\"compiletest_rs\"]\n \n [dev-dependencies]\n fnv = \"1.0\"\n rustc-serialize = \"0.3.16\"\n+select-rustc = \"0.1\"\n serde = { path = \"../serde\", features = [\"rc\", \"derive\"] }\n serde_derive = { path = \"../serde_derive\", features = [\"deserialize_in_place\"] }\n serde_test = { path = \"../serde_test\" }\n-\n-[dependencies]\n-compiletest_rs = { version = \"0.3\", optional = true, features = [\"stable\"] }\n+trybuild = \"1.0\"\ndiff --git a/test_suite/deps/Cargo.toml b/test_suite/deps/Cargo.toml\ndeleted file mode 100644\nindex fbe2f2cda..000000000\n--- a/test_suite/deps/Cargo.toml\n+++ /dev/null\n@@ -1,11 +0,0 @@\n-[package]\n-name = \"serde_test_suite_deps\"\n-version = \"0.0.0\"\n-authors = [\"David Tolnay <dtolnay@gmail.com>\"]\n-publish = false\n-\n-[workspace]\n-\n-[dependencies]\n-serde = { path = \"../../serde\" }\n-serde_derive = { path = \"../../serde_derive\" }\ndiff --git a/test_suite/deps/src/lib.rs b/test_suite/deps/src/lib.rs\ndeleted file mode 100644\nindex e63ee9d43..000000000\n--- a/test_suite/deps/src/lib.rs\n+++ /dev/null\n@@ -1,3 +0,0 @@\n-#![feature(/*=============================================]\n-#![===  Serde test suite requires a nightly compiler.  ===]\n-#![====================================================*/)]\ndiff --git a/test_suite/tests/compiletest.rs b/test_suite/tests/compiletest.rs\nindex 1b70621f7..214d43678 100644\n--- a/test_suite/tests/compiletest.rs\n+++ b/test_suite/tests/compiletest.rs\n@@ -1,21 +1,6 @@\n-#![cfg(feature = \"compiletest\")]\n-\n-use compiletest_rs as compiletest;\n-\n+#[rustc::attr(not(nightly), ignore)]\n #[test]\n fn ui() {\n-    compiletest::run_tests(&compiletest::Config {\n-        mode: compiletest::common::Mode::Ui,\n-        src_base: std::path::PathBuf::from(\"tests/ui\"),\n-        target_rustcflags: Some(String::from(\n-            \"\\\n-             --edition=2018 \\\n-             -L deps/target/debug/deps \\\n-             -Z unstable-options \\\n-             --extern serde_derive \\\n-             \",\n-        )),\n-        build_base: std::path::PathBuf::from(\"../target/ui\"),\n-        ..Default::default()\n-    });\n+    let t = trybuild::TestCases::new();\n+    t.compile_fail(\"tests/ui/**/*.rs\");\n }\ndiff --git a/test_suite/tests/ui/borrow/bad_lifetimes.stderr b/test_suite/tests/ui/borrow/bad_lifetimes.stderr\nindex 1adc34a59..5b2984977 100644\n--- a/test_suite/tests/ui/borrow/bad_lifetimes.stderr\n+++ b/test_suite/tests/ui/borrow/bad_lifetimes.stderr\n@@ -3,6 +3,3 @@ error: failed to parse borrowed lifetimes: \"zzz\"\n   |\n 5 |     #[serde(borrow = \"zzz\")]\n   |                      ^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/borrow/duplicate_lifetime.stderr b/test_suite/tests/ui/borrow/duplicate_lifetime.stderr\nindex 57c9690a5..f9916fd02 100644\n--- a/test_suite/tests/ui/borrow/duplicate_lifetime.stderr\n+++ b/test_suite/tests/ui/borrow/duplicate_lifetime.stderr\n@@ -3,6 +3,3 @@ error: duplicate borrowed lifetime `'a`\n   |\n 5 |     #[serde(borrow = \"'a + 'a\")]\n   |                      ^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/borrow/duplicate_variant.stderr b/test_suite/tests/ui/borrow/duplicate_variant.stderr\nindex 7ff995a67..bae8e5fde 100644\n--- a/test_suite/tests/ui/borrow/duplicate_variant.stderr\n+++ b/test_suite/tests/ui/borrow/duplicate_variant.stderr\n@@ -3,6 +3,3 @@ error: duplicate serde attribute `borrow`\n   |\n 8 |     #[serde(borrow)]\n   |             ^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/borrow/empty_lifetimes.stderr b/test_suite/tests/ui/borrow/empty_lifetimes.stderr\nindex 01d79b3ba..2d6f042cd 100644\n--- a/test_suite/tests/ui/borrow/empty_lifetimes.stderr\n+++ b/test_suite/tests/ui/borrow/empty_lifetimes.stderr\n@@ -3,6 +3,3 @@ error: at least one lifetime must be borrowed\n   |\n 5 |     #[serde(borrow = \"\")]\n   |                      ^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/borrow/no_lifetimes.stderr b/test_suite/tests/ui/borrow/no_lifetimes.stderr\nindex 04bcc852e..52601e975 100644\n--- a/test_suite/tests/ui/borrow/no_lifetimes.stderr\n+++ b/test_suite/tests/ui/borrow/no_lifetimes.stderr\n@@ -4,6 +4,3 @@ error: field `s` has no lifetimes to borrow\n 5 | /     #[serde(borrow)]\n 6 | |     s: String,\n   | |_____________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/borrow/struct_variant.stderr b/test_suite/tests/ui/borrow/struct_variant.stderr\nindex 758e6343e..5624d2077 100644\n--- a/test_suite/tests/ui/borrow/struct_variant.stderr\n+++ b/test_suite/tests/ui/borrow/struct_variant.stderr\n@@ -4,6 +4,3 @@ error: #[serde(borrow)] may only be used on newtype variants\n 8 | /     #[serde(borrow)]\n 9 | |     S { s: Str<'a> },\n   | |____________________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/borrow/wrong_lifetime.stderr b/test_suite/tests/ui/borrow/wrong_lifetime.stderr\nindex 356595520..f282e124e 100644\n--- a/test_suite/tests/ui/borrow/wrong_lifetime.stderr\n+++ b/test_suite/tests/ui/borrow/wrong_lifetime.stderr\n@@ -4,6 +4,3 @@ error: field `s` does not have lifetime 'b\n 5 | /     #[serde(borrow = \"'b\")]\n 6 | |     s: &'a str,\n   | |______________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/conflict/adjacent-tag.stderr b/test_suite/tests/ui/conflict/adjacent-tag.stderr\nindex 6045f5f56..ad4967958 100644\n--- a/test_suite/tests/ui/conflict/adjacent-tag.stderr\n+++ b/test_suite/tests/ui/conflict/adjacent-tag.stderr\n@@ -7,6 +7,3 @@ error: enum tags `conflict` for type and content conflict with each other\n 7 | |     B,\n 8 | | }\n   | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/conflict/flatten-newtype-struct.stderr b/test_suite/tests/ui/conflict/flatten-newtype-struct.stderr\nindex 86e9501aa..aeacefb9c 100644\n--- a/test_suite/tests/ui/conflict/flatten-newtype-struct.stderr\n+++ b/test_suite/tests/ui/conflict/flatten-newtype-struct.stderr\n@@ -3,6 +3,3 @@ error: #[serde(flatten)] cannot be used on newtype structs\n   |\n 6 | struct Foo(#[serde(flatten)] HashMap<String, String>);\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/conflict/flatten-tuple-struct.stderr b/test_suite/tests/ui/conflict/flatten-tuple-struct.stderr\nindex ecdb987cd..e1999344c 100644\n--- a/test_suite/tests/ui/conflict/flatten-tuple-struct.stderr\n+++ b/test_suite/tests/ui/conflict/flatten-tuple-struct.stderr\n@@ -3,6 +3,3 @@ error: #[serde(flatten)] cannot be used on tuple structs\n   |\n 6 | struct Foo(u32, #[serde(flatten)] HashMap<String, String>);\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/conflict/internal-tag-alias.stderr b/test_suite/tests/ui/conflict/internal-tag-alias.stderr\nindex 2fcaa18d4..7a57f427c 100644\n--- a/test_suite/tests/ui/conflict/internal-tag-alias.stderr\n+++ b/test_suite/tests/ui/conflict/internal-tag-alias.stderr\n@@ -9,6 +9,3 @@ error: variant field name `conflict` conflicts with internal tag\n 9  | |     },\n 10 | | }\n    | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/conflict/internal-tag.stderr b/test_suite/tests/ui/conflict/internal-tag.stderr\nindex d98c3874f..f1ae4579a 100644\n--- a/test_suite/tests/ui/conflict/internal-tag.stderr\n+++ b/test_suite/tests/ui/conflict/internal-tag.stderr\n@@ -9,6 +9,3 @@ error: variant field name `conflict` conflicts with internal tag\n 9  | |     },\n 10 | | }\n    | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/default-attribute/enum.stderr b/test_suite/tests/ui/default-attribute/enum.stderr\nindex 9f2a26180..a3b7a0277 100644\n--- a/test_suite/tests/ui/default-attribute/enum.stderr\n+++ b/test_suite/tests/ui/default-attribute/enum.stderr\n@@ -3,6 +3,3 @@ error: #[serde(default)] can only be used on structs with named fields\n   |\n 5 | enum E {\n   | ^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/default-attribute/enum_path.stderr b/test_suite/tests/ui/default-attribute/enum_path.stderr\nindex 9a9a8ecbb..c6523c9ec 100644\n--- a/test_suite/tests/ui/default-attribute/enum_path.stderr\n+++ b/test_suite/tests/ui/default-attribute/enum_path.stderr\n@@ -3,6 +3,3 @@ error: #[serde(default = \"...\")] can only be used on structs with named fields\n   |\n 5 | enum E {\n   | ^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/default-attribute/nameless_struct_fields.stderr b/test_suite/tests/ui/default-attribute/nameless_struct_fields.stderr\nindex 3e8d07087..3557946a2 100644\n--- a/test_suite/tests/ui/default-attribute/nameless_struct_fields.stderr\n+++ b/test_suite/tests/ui/default-attribute/nameless_struct_fields.stderr\n@@ -3,6 +3,3 @@ error: #[serde(default)] can only be used on structs with named fields\n   |\n 5 | struct T(u8, u8);\n   |         ^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/default-attribute/nameless_struct_fields_path.stderr b/test_suite/tests/ui/default-attribute/nameless_struct_fields_path.stderr\nindex 9197807b0..db5fa4b8d 100644\n--- a/test_suite/tests/ui/default-attribute/nameless_struct_fields_path.stderr\n+++ b/test_suite/tests/ui/default-attribute/nameless_struct_fields_path.stderr\n@@ -3,6 +3,3 @@ error: #[serde(default = \"...\")] can only be used on structs with named fields\n   |\n 5 | struct T(u8, u8);\n   |         ^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/duplicate-attribute/rename-and-ser.stderr b/test_suite/tests/ui/duplicate-attribute/rename-and-ser.stderr\nindex 74f730fd3..34ecd735c 100644\n--- a/test_suite/tests/ui/duplicate-attribute/rename-and-ser.stderr\n+++ b/test_suite/tests/ui/duplicate-attribute/rename-and-ser.stderr\n@@ -3,6 +3,3 @@ error: unknown serde field attribute `serialize`\n   |\n 5 |     #[serde(rename = \"x\", serialize = \"y\")]\n   |                           ^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/duplicate-attribute/rename-ser-rename-ser.stderr b/test_suite/tests/ui/duplicate-attribute/rename-ser-rename-ser.stderr\nindex 04e67b13e..979f97385 100644\n--- a/test_suite/tests/ui/duplicate-attribute/rename-ser-rename-ser.stderr\n+++ b/test_suite/tests/ui/duplicate-attribute/rename-ser-rename-ser.stderr\n@@ -3,6 +3,3 @@ error: duplicate serde attribute `rename`\n   |\n 5 |     #[serde(rename(serialize = \"x\"), rename(serialize = \"y\"))]\n   |                                      ^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/duplicate-attribute/rename-ser-rename.stderr b/test_suite/tests/ui/duplicate-attribute/rename-ser-rename.stderr\nindex d9cb3650b..866b2372f 100644\n--- a/test_suite/tests/ui/duplicate-attribute/rename-ser-rename.stderr\n+++ b/test_suite/tests/ui/duplicate-attribute/rename-ser-rename.stderr\n@@ -3,6 +3,3 @@ error: duplicate serde attribute `rename`\n   |\n 6 |     #[serde(rename = \"y\")]\n   |             ^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/duplicate-attribute/rename-ser-ser.stderr b/test_suite/tests/ui/duplicate-attribute/rename-ser-ser.stderr\nindex c5526c710..e6e3b3843 100644\n--- a/test_suite/tests/ui/duplicate-attribute/rename-ser-ser.stderr\n+++ b/test_suite/tests/ui/duplicate-attribute/rename-ser-ser.stderr\n@@ -3,6 +3,3 @@ error: duplicate serde attribute `rename`\n   |\n 5 |     #[serde(rename(serialize = \"x\", serialize = \"y\"))]\n   |                                     ^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/duplicate-attribute/two-rename-ser.stderr b/test_suite/tests/ui/duplicate-attribute/two-rename-ser.stderr\nindex 3934ac9d9..9973b4a87 100644\n--- a/test_suite/tests/ui/duplicate-attribute/two-rename-ser.stderr\n+++ b/test_suite/tests/ui/duplicate-attribute/two-rename-ser.stderr\n@@ -3,6 +3,3 @@ error: duplicate serde attribute `rename`\n   |\n 6 |     #[serde(rename(serialize = \"y\"))]\n   |             ^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/duplicate-attribute/with-and-serialize-with.stderr b/test_suite/tests/ui/duplicate-attribute/with-and-serialize-with.stderr\nindex 27e3a0bf6..62e29d574 100644\n--- a/test_suite/tests/ui/duplicate-attribute/with-and-serialize-with.stderr\n+++ b/test_suite/tests/ui/duplicate-attribute/with-and-serialize-with.stderr\n@@ -3,6 +3,3 @@ error: duplicate serde attribute `serialize_with`\n   |\n 5 |     #[serde(with = \"w\", serialize_with = \"s\")]\n   |                         ^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/enum-representation/content-no-tag.stderr b/test_suite/tests/ui/enum-representation/content-no-tag.stderr\nindex ad7186e57..ea3602816 100644\n--- a/test_suite/tests/ui/enum-representation/content-no-tag.stderr\n+++ b/test_suite/tests/ui/enum-representation/content-no-tag.stderr\n@@ -3,6 +3,3 @@ error: #[serde(tag = \"...\", content = \"...\")] must be used together\n   |\n 4 | #[serde(content = \"c\")]\n   |         ^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/enum-representation/internal-tuple-variant.stderr b/test_suite/tests/ui/enum-representation/internal-tuple-variant.stderr\nindex 8d133689d..cbe2cf851 100644\n--- a/test_suite/tests/ui/enum-representation/internal-tuple-variant.stderr\n+++ b/test_suite/tests/ui/enum-representation/internal-tuple-variant.stderr\n@@ -3,6 +3,3 @@ error: #[serde(tag = \"...\")] cannot be used with tuple variants\n   |\n 6 |     Tuple(u8, u8),\n   |     ^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/enum-representation/untagged-and-adjacent.stderr b/test_suite/tests/ui/enum-representation/untagged-and-adjacent.stderr\nindex 367a55fe5..9f42b51b3 100644\n--- a/test_suite/tests/ui/enum-representation/untagged-and-adjacent.stderr\n+++ b/test_suite/tests/ui/enum-representation/untagged-and-adjacent.stderr\n@@ -15,6 +15,3 @@ error: untagged enum cannot have #[serde(tag = \"...\", content = \"...\")]\n   |\n 5 | #[serde(tag = \"t\", content = \"c\")]\n   |                    ^^^^^^^\n-\n-error: aborting due to 3 previous errors\n-\ndiff --git a/test_suite/tests/ui/enum-representation/untagged-and-content.stderr b/test_suite/tests/ui/enum-representation/untagged-and-content.stderr\nindex 847579ac9..467d6c27a 100644\n--- a/test_suite/tests/ui/enum-representation/untagged-and-content.stderr\n+++ b/test_suite/tests/ui/enum-representation/untagged-and-content.stderr\n@@ -9,6 +9,3 @@ error: untagged enum cannot have #[serde(content = \"...\")]\n   |\n 5 | #[serde(content = \"c\")]\n   |         ^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\ndiff --git a/test_suite/tests/ui/enum-representation/untagged-and-internal.stderr b/test_suite/tests/ui/enum-representation/untagged-and-internal.stderr\nindex 2bb43502c..78fed3dab 100644\n--- a/test_suite/tests/ui/enum-representation/untagged-and-internal.stderr\n+++ b/test_suite/tests/ui/enum-representation/untagged-and-internal.stderr\n@@ -9,6 +9,3 @@ error: enum cannot be both untagged and internally tagged\n   |\n 5 | #[serde(tag = \"type\")]\n   |         ^^^\n-\n-error: aborting due to 2 previous errors\n-\ndiff --git a/test_suite/tests/ui/enum-representation/untagged-struct.stderr b/test_suite/tests/ui/enum-representation/untagged-struct.stderr\nindex 49f77bc62..8a065d9b0 100644\n--- a/test_suite/tests/ui/enum-representation/untagged-struct.stderr\n+++ b/test_suite/tests/ui/enum-representation/untagged-struct.stderr\n@@ -3,6 +3,3 @@ error: #[serde(untagged)] can only be used on enums\n   |\n 5 | struct S;\n   | ^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/expected-string/boolean.stderr b/test_suite/tests/ui/expected-string/boolean.stderr\nindex 4396e4b15..f14bc7e65 100644\n--- a/test_suite/tests/ui/expected-string/boolean.stderr\n+++ b/test_suite/tests/ui/expected-string/boolean.stderr\n@@ -3,6 +3,3 @@ error: expected serde rename attribute to be a string: `rename = \"...\"`\n   |\n 5 |     #[serde(rename = true)]\n   |                      ^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/expected-string/byte_character.stderr b/test_suite/tests/ui/expected-string/byte_character.stderr\nindex 3ebf6f275..3b801dcb2 100644\n--- a/test_suite/tests/ui/expected-string/byte_character.stderr\n+++ b/test_suite/tests/ui/expected-string/byte_character.stderr\n@@ -3,6 +3,3 @@ error: expected serde rename attribute to be a string: `rename = \"...\"`\n   |\n 5 |     #[serde(rename = b'a')]\n   |                      ^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/expected-string/byte_string.stderr b/test_suite/tests/ui/expected-string/byte_string.stderr\nindex 7b5be122f..a16b0b92a 100644\n--- a/test_suite/tests/ui/expected-string/byte_string.stderr\n+++ b/test_suite/tests/ui/expected-string/byte_string.stderr\n@@ -3,6 +3,3 @@ error: expected serde rename attribute to be a string: `rename = \"...\"`\n   |\n 5 |     #[serde(rename = b\"byte string\")]\n   |                      ^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/expected-string/character.stderr b/test_suite/tests/ui/expected-string/character.stderr\nindex ff6849115..4524c07fa 100644\n--- a/test_suite/tests/ui/expected-string/character.stderr\n+++ b/test_suite/tests/ui/expected-string/character.stderr\n@@ -3,6 +3,3 @@ error: expected serde rename attribute to be a string: `rename = \"...\"`\n   |\n 5 |     #[serde(rename = 'a')]\n   |                      ^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/expected-string/float.stderr b/test_suite/tests/ui/expected-string/float.stderr\nindex a8106cb68..f8c78c466 100644\n--- a/test_suite/tests/ui/expected-string/float.stderr\n+++ b/test_suite/tests/ui/expected-string/float.stderr\n@@ -3,6 +3,3 @@ error: expected serde rename attribute to be a string: `rename = \"...\"`\n   |\n 5 |     #[serde(rename = 3.14)]\n   |                      ^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/expected-string/integer.stderr b/test_suite/tests/ui/expected-string/integer.stderr\nindex cce9ebaeb..0d26e6087 100644\n--- a/test_suite/tests/ui/expected-string/integer.stderr\n+++ b/test_suite/tests/ui/expected-string/integer.stderr\n@@ -3,6 +3,3 @@ error: expected serde rename attribute to be a string: `rename = \"...\"`\n   |\n 5 |     #[serde(rename = 100)]\n   |                      ^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/identifier/both.stderr b/test_suite/tests/ui/identifier/both.stderr\nindex c26741753..7cc3e86ea 100644\n--- a/test_suite/tests/ui/identifier/both.stderr\n+++ b/test_suite/tests/ui/identifier/both.stderr\n@@ -9,6 +9,3 @@ error: #[serde(field_identifier)] and #[serde(variant_identifier)] cannot both b\n   |\n 4 | #[serde(field_identifier, variant_identifier)]\n   |                           ^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n-\ndiff --git a/test_suite/tests/ui/identifier/field_struct.stderr b/test_suite/tests/ui/identifier/field_struct.stderr\nindex 49013343f..c87dd3bd5 100644\n--- a/test_suite/tests/ui/identifier/field_struct.stderr\n+++ b/test_suite/tests/ui/identifier/field_struct.stderr\n@@ -3,6 +3,3 @@ error: #[serde(field_identifier)] can only be used on an enum\n   |\n 5 | struct S;\n   | ^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/identifier/field_tuple.stderr b/test_suite/tests/ui/identifier/field_tuple.stderr\nindex 2710d0b8c..5c2465a9d 100644\n--- a/test_suite/tests/ui/identifier/field_tuple.stderr\n+++ b/test_suite/tests/ui/identifier/field_tuple.stderr\n@@ -3,6 +3,3 @@ error: #[serde(field_identifier)] may only contain unit variants\n   |\n 7 |     B(u8, u8),\n   |     ^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/identifier/newtype_not_last.stderr b/test_suite/tests/ui/identifier/newtype_not_last.stderr\nindex 3a30c9a90..d4af4203c 100644\n--- a/test_suite/tests/ui/identifier/newtype_not_last.stderr\n+++ b/test_suite/tests/ui/identifier/newtype_not_last.stderr\n@@ -3,6 +3,3 @@ error: `Other` must be the last variant\n   |\n 7 |     Other(String),\n   |     ^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/identifier/not_unit.stderr b/test_suite/tests/ui/identifier/not_unit.stderr\nindex 26b7e0a7b..612bfc630 100644\n--- a/test_suite/tests/ui/identifier/not_unit.stderr\n+++ b/test_suite/tests/ui/identifier/not_unit.stderr\n@@ -4,6 +4,3 @@ error: #[serde(other)] must be on a unit variant\n 7 | /     #[serde(other)]\n 8 | |     Other(u8, u8),\n   | |_________________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/identifier/other_not_last.stderr b/test_suite/tests/ui/identifier/other_not_last.stderr\nindex a470f48fa..4a0525d67 100644\n--- a/test_suite/tests/ui/identifier/other_not_last.stderr\n+++ b/test_suite/tests/ui/identifier/other_not_last.stderr\n@@ -4,6 +4,3 @@ error: #[serde(other)] must be on the last variant\n 7 | /     #[serde(other)]\n 8 | |     Other,\n   | |_________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/identifier/other_untagged.stderr b/test_suite/tests/ui/identifier/other_untagged.stderr\nindex f6068adef..ddcf7b5a2 100644\n--- a/test_suite/tests/ui/identifier/other_untagged.stderr\n+++ b/test_suite/tests/ui/identifier/other_untagged.stderr\n@@ -4,6 +4,3 @@ error: #[serde(other)] cannot appear on untagged enum\n 6 | /     #[serde(other)]\n 7 | |     Other,\n   | |_________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/identifier/other_variant.stderr b/test_suite/tests/ui/identifier/other_variant.stderr\nindex 900a71a03..d9089d7f0 100644\n--- a/test_suite/tests/ui/identifier/other_variant.stderr\n+++ b/test_suite/tests/ui/identifier/other_variant.stderr\n@@ -4,6 +4,3 @@ error: #[serde(other)] may not be used on a variant identifier\n 6 | /     #[serde(other)]\n 7 | |     Other,\n   | |_________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/identifier/variant_struct.stderr b/test_suite/tests/ui/identifier/variant_struct.stderr\nindex d4760ddbc..ba8ed0672 100644\n--- a/test_suite/tests/ui/identifier/variant_struct.stderr\n+++ b/test_suite/tests/ui/identifier/variant_struct.stderr\n@@ -3,6 +3,3 @@ error: #[serde(variant_identifier)] can only be used on an enum\n   |\n 5 | struct S;\n   | ^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/identifier/variant_tuple.stderr b/test_suite/tests/ui/identifier/variant_tuple.stderr\nindex ba25c76ff..9fb0a7fb3 100644\n--- a/test_suite/tests/ui/identifier/variant_tuple.stderr\n+++ b/test_suite/tests/ui/identifier/variant_tuple.stderr\n@@ -3,6 +3,3 @@ error: #[serde(variant_identifier)] may only contain unit variants\n   |\n 7 |     B(u8, u8),\n   |     ^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/malformed/bound.stderr b/test_suite/tests/ui/malformed/bound.stderr\nindex 6f65801c4..59537de1d 100644\n--- a/test_suite/tests/ui/malformed/bound.stderr\n+++ b/test_suite/tests/ui/malformed/bound.stderr\n@@ -3,6 +3,3 @@ error: malformed bound attribute, expected `bound(serialize = ..., deserialize =\n   |\n 5 |     #[serde(bound(unknown))]\n   |                   ^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/malformed/rename.stderr b/test_suite/tests/ui/malformed/rename.stderr\nindex 104bfba59..a2e244f56 100644\n--- a/test_suite/tests/ui/malformed/rename.stderr\n+++ b/test_suite/tests/ui/malformed/rename.stderr\n@@ -3,6 +3,3 @@ error: malformed rename attribute, expected `rename(serialize = ..., deserialize\n   |\n 5 |     #[serde(rename(unknown))]\n   |                    ^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/precondition/deserialize_de_lifetime.stderr b/test_suite/tests/ui/precondition/deserialize_de_lifetime.stderr\nindex 7cb0c1b82..642f3f1c8 100644\n--- a/test_suite/tests/ui/precondition/deserialize_de_lifetime.stderr\n+++ b/test_suite/tests/ui/precondition/deserialize_de_lifetime.stderr\n@@ -3,6 +3,3 @@ error: cannot deserialize when there is a lifetime parameter called 'de\n   |\n 4 | struct S<'de> {\n   |          ^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/precondition/deserialize_dst.stderr b/test_suite/tests/ui/precondition/deserialize_dst.stderr\nindex f037310b9..923864561 100644\n--- a/test_suite/tests/ui/precondition/deserialize_dst.stderr\n+++ b/test_suite/tests/ui/precondition/deserialize_dst.stderr\n@@ -6,6 +6,3 @@ error: cannot deserialize a dynamically sized struct\n 6 | |     slice: [u8],\n 7 | | }\n   | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/precondition/serialize_field_identifier.stderr b/test_suite/tests/ui/precondition/serialize_field_identifier.stderr\nindex bd102f368..9b59f4f84 100644\n--- a/test_suite/tests/ui/precondition/serialize_field_identifier.stderr\n+++ b/test_suite/tests/ui/precondition/serialize_field_identifier.stderr\n@@ -7,6 +7,3 @@ error: field identifiers cannot be serialized\n 7 | |     B,\n 8 | | }\n   | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/precondition/serialize_variant_identifier.stderr b/test_suite/tests/ui/precondition/serialize_variant_identifier.stderr\nindex 244a4f2ca..4641f35fd 100644\n--- a/test_suite/tests/ui/precondition/serialize_variant_identifier.stderr\n+++ b/test_suite/tests/ui/precondition/serialize_variant_identifier.stderr\n@@ -7,6 +7,3 @@ error: variant identifiers cannot be serialized\n 7 | |     B,\n 8 | | }\n   | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/remote/bad_getter.stderr b/test_suite/tests/ui/remote/bad_getter.stderr\nindex 955a6caf4..871509269 100644\n--- a/test_suite/tests/ui/remote/bad_getter.stderr\n+++ b/test_suite/tests/ui/remote/bad_getter.stderr\n@@ -3,6 +3,3 @@ error: failed to parse path: \"~~~\"\n    |\n 12 |     #[serde(getter = \"~~~\")]\n    |                      ^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/remote/bad_remote.stderr b/test_suite/tests/ui/remote/bad_remote.stderr\nindex e275d14ad..dc985564c 100644\n--- a/test_suite/tests/ui/remote/bad_remote.stderr\n+++ b/test_suite/tests/ui/remote/bad_remote.stderr\n@@ -3,6 +3,3 @@ error: failed to parse path: \"~~~\"\n    |\n 10 | #[serde(remote = \"~~~\")]\n    |                  ^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/remote/enum_getter.stderr b/test_suite/tests/ui/remote/enum_getter.stderr\nindex 14ffc9a4a..77edefc57 100644\n--- a/test_suite/tests/ui/remote/enum_getter.stderr\n+++ b/test_suite/tests/ui/remote/enum_getter.stderr\n@@ -9,6 +9,3 @@ error: #[serde(getter = \"...\")] is not allowed in an enum\n 15 | |     },\n 16 | | }\n    | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/remote/missing_field.stderr b/test_suite/tests/ui/remote/missing_field.stderr\nindex d79fb380d..e3566253e 100644\n--- a/test_suite/tests/ui/remote/missing_field.stderr\n+++ b/test_suite/tests/ui/remote/missing_field.stderr\n@@ -4,6 +4,4 @@ error[E0063]: missing field `b` in initializer of `remote::S`\n 11 | #[serde(remote = \"remote::S\")]\n    |                  ^^^^^^^^^^^ missing `b`\n \n-error: aborting due to previous error\n-\n For more information about this error, try `rustc --explain E0063`.\ndiff --git a/test_suite/tests/ui/remote/nonremote_getter.stderr b/test_suite/tests/ui/remote/nonremote_getter.stderr\nindex 446f523cd..60d6d48ed 100644\n--- a/test_suite/tests/ui/remote/nonremote_getter.stderr\n+++ b/test_suite/tests/ui/remote/nonremote_getter.stderr\n@@ -6,6 +6,3 @@ error: #[serde(getter = \"...\")] can only be used in structs that have #[serde(re\n 6 | |     a: u8,\n 7 | | }\n   | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/remote/unknown_field.stderr b/test_suite/tests/ui/remote/unknown_field.stderr\nindex 03b367e53..6a8d11ba0 100644\n--- a/test_suite/tests/ui/remote/unknown_field.stderr\n+++ b/test_suite/tests/ui/remote/unknown_field.stderr\n@@ -10,7 +10,5 @@ error[E0560]: struct `remote::S` has no field named `b`\n 12 |     b: u8,\n    |     ^ help: a field with a similar name exists: `a`\n \n-error: aborting due to 2 previous errors\n-\n Some errors have detailed explanations: E0560, E0609.\n For more information about an error, try `rustc --explain E0560`.\ndiff --git a/test_suite/tests/ui/remote/wrong_de.stderr b/test_suite/tests/ui/remote/wrong_de.stderr\nindex 9c95ee614..85281862b 100644\n--- a/test_suite/tests/ui/remote/wrong_de.stderr\n+++ b/test_suite/tests/ui/remote/wrong_de.stderr\n@@ -3,11 +3,5 @@ error[E0308]: mismatched types\n   |\n 7 | #[derive(Deserialize)]\n   |          ^^^^^^^^^^^ expected u16, found u8\n-help: you can cast an `u8` to `u16`, which will zero-extend the source value\n-  |\n-7 | #[derive(Deserialize.into())]\n-  |          ^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0308`.\ndiff --git a/test_suite/tests/ui/remote/wrong_getter.stderr b/test_suite/tests/ui/remote/wrong_getter.stderr\nindex 4c1614051..177933666 100644\n--- a/test_suite/tests/ui/remote/wrong_getter.stderr\n+++ b/test_suite/tests/ui/remote/wrong_getter.stderr\n@@ -7,6 +7,4 @@ error[E0308]: mismatched types\n    = note: expected type `&u8`\n               found type `&u16`\n \n-error: aborting due to previous error\n-\n For more information about this error, try `rustc --explain E0308`.\ndiff --git a/test_suite/tests/ui/remote/wrong_ser.stderr b/test_suite/tests/ui/remote/wrong_ser.stderr\nindex 76a35f4ed..547409256 100644\n--- a/test_suite/tests/ui/remote/wrong_ser.stderr\n+++ b/test_suite/tests/ui/remote/wrong_ser.stderr\n@@ -7,6 +7,4 @@ error[E0308]: mismatched types\n   = note: expected type `&u8`\n              found type `&u16`\n \n-error: aborting due to previous error\n-\n For more information about this error, try `rustc --explain E0308`.\ndiff --git a/test_suite/tests/ui/rename/container_unknown_rename_rule.stderr b/test_suite/tests/ui/rename/container_unknown_rename_rule.stderr\nindex 6728b612f..728d71ca2 100644\n--- a/test_suite/tests/ui/rename/container_unknown_rename_rule.stderr\n+++ b/test_suite/tests/ui/rename/container_unknown_rename_rule.stderr\n@@ -3,6 +3,3 @@ error: unknown rename rule for #[serde(rename_all = \"abc\")]\n   |\n 4 | #[serde(rename_all = \"abc\")]\n   |                      ^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/rename/variant_unknown_rename_rule.stderr b/test_suite/tests/ui/rename/variant_unknown_rename_rule.stderr\nindex f31e1abe7..7a52f37a8 100644\n--- a/test_suite/tests/ui/rename/variant_unknown_rename_rule.stderr\n+++ b/test_suite/tests/ui/rename/variant_unknown_rename_rule.stderr\n@@ -3,6 +3,3 @@ error: unknown rename rule for #[serde(rename_all = \"abc\")]\n   |\n 5 |     #[serde(rename_all = \"abc\")]\n   |                          ^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/struct-representation/internally-tagged-tuple.stderr b/test_suite/tests/ui/struct-representation/internally-tagged-tuple.stderr\nindex 52b3f77b0..7cf179895 100644\n--- a/test_suite/tests/ui/struct-representation/internally-tagged-tuple.stderr\n+++ b/test_suite/tests/ui/struct-representation/internally-tagged-tuple.stderr\n@@ -3,6 +3,3 @@ error: #[serde(tag = \"...\")] can only be used on enums and structs with named fi\n   |\n 5 | struct S(u8, u8);\n   |         ^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/struct-representation/internally-tagged-unit.stderr b/test_suite/tests/ui/struct-representation/internally-tagged-unit.stderr\nindex 31fca0004..47b4de8ab 100644\n--- a/test_suite/tests/ui/struct-representation/internally-tagged-unit.stderr\n+++ b/test_suite/tests/ui/struct-representation/internally-tagged-unit.stderr\n@@ -3,6 +3,3 @@ error: #[serde(tag = \"...\")] can only be used on enums and structs with named fi\n   |\n 3 | #[derive(Serialize)]\n   |          ^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/transparent/at_most_one.stderr b/test_suite/tests/ui/transparent/at_most_one.stderr\nindex dcdbfa9b2..b6a234c01 100644\n--- a/test_suite/tests/ui/transparent/at_most_one.stderr\n+++ b/test_suite/tests/ui/transparent/at_most_one.stderr\n@@ -7,6 +7,3 @@ error: #[serde(transparent)] requires struct to have at most one transparent fie\n 7 | |     b: u8,\n 8 | | }\n   | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/transparent/de_at_least_one.stderr b/test_suite/tests/ui/transparent/de_at_least_one.stderr\nindex aa9d4ea75..42a02c0b7 100644\n--- a/test_suite/tests/ui/transparent/de_at_least_one.stderr\n+++ b/test_suite/tests/ui/transparent/de_at_least_one.stderr\n@@ -9,6 +9,3 @@ error: #[serde(transparent)] requires at least one field that is neither skipped\n 9  | |     b: u8,\n 10 | | }\n    | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/transparent/enum.stderr b/test_suite/tests/ui/transparent/enum.stderr\nindex d1ee11ad1..2181fa8ba 100644\n--- a/test_suite/tests/ui/transparent/enum.stderr\n+++ b/test_suite/tests/ui/transparent/enum.stderr\n@@ -4,6 +4,3 @@ error: #[serde(transparent)] is not allowed on an enum\n 4 | / #[serde(transparent)]\n 5 | | enum E {}\n   | |_________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/transparent/ser_at_least_one.stderr b/test_suite/tests/ui/transparent/ser_at_least_one.stderr\nindex bf1b9a203..6e1c01b54 100644\n--- a/test_suite/tests/ui/transparent/ser_at_least_one.stderr\n+++ b/test_suite/tests/ui/transparent/ser_at_least_one.stderr\n@@ -7,6 +7,3 @@ error: #[serde(transparent)] requires at least one field that is not skipped\n 7 | |     a: u8,\n 8 | | }\n   | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/transparent/unit_struct.stderr b/test_suite/tests/ui/transparent/unit_struct.stderr\nindex 82956cf36..d6371efac 100644\n--- a/test_suite/tests/ui/transparent/unit_struct.stderr\n+++ b/test_suite/tests/ui/transparent/unit_struct.stderr\n@@ -4,6 +4,3 @@ error: #[serde(transparent)] is not allowed on a unit struct\n 4 | / #[serde(transparent)]\n 5 | | struct S;\n   | |_________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/transparent/with_from.stderr b/test_suite/tests/ui/transparent/with_from.stderr\nindex 3fd789b79..fd031d436 100644\n--- a/test_suite/tests/ui/transparent/with_from.stderr\n+++ b/test_suite/tests/ui/transparent/with_from.stderr\n@@ -6,6 +6,3 @@ error: #[serde(transparent)] is not allowed with #[serde(from = \"...\")]\n 6 | |     a: u8,\n 7 | | }\n   | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/transparent/with_into.stderr b/test_suite/tests/ui/transparent/with_into.stderr\nindex 816a42768..c8f72a376 100644\n--- a/test_suite/tests/ui/transparent/with_into.stderr\n+++ b/test_suite/tests/ui/transparent/with_into.stderr\n@@ -6,6 +6,3 @@ error: #[serde(transparent)] is not allowed with #[serde(into = \"...\")]\n 6 | |     a: u8,\n 7 | | }\n   | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/type-attribute/from.stderr b/test_suite/tests/ui/type-attribute/from.stderr\nindex 06cafcd63..1aae4c4db 100644\n--- a/test_suite/tests/ui/type-attribute/from.stderr\n+++ b/test_suite/tests/ui/type-attribute/from.stderr\n@@ -3,6 +3,3 @@ error: failed to parse type: from = \"Option<T\"\n   |\n 4 | #[serde(from = \"Option<T\")]\n   |                ^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/type-attribute/into.stderr b/test_suite/tests/ui/type-attribute/into.stderr\nindex bcf9569e4..0e9d0fed6 100644\n--- a/test_suite/tests/ui/type-attribute/into.stderr\n+++ b/test_suite/tests/ui/type-attribute/into.stderr\n@@ -3,6 +3,3 @@ error: failed to parse type: into = \"Option<T\"\n   |\n 4 | #[serde(into = \"Option<T\")]\n   |                ^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/unexpected-literal/container.stderr b/test_suite/tests/ui/unexpected-literal/container.stderr\nindex bf2ab2f02..4d0c687c2 100644\n--- a/test_suite/tests/ui/unexpected-literal/container.stderr\n+++ b/test_suite/tests/ui/unexpected-literal/container.stderr\n@@ -3,6 +3,3 @@ error: unexpected literal in serde container attribute\n   |\n 4 | #[serde(\"literal\")]\n   |         ^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/unexpected-literal/field.stderr b/test_suite/tests/ui/unexpected-literal/field.stderr\nindex 57954031e..3895a660f 100644\n--- a/test_suite/tests/ui/unexpected-literal/field.stderr\n+++ b/test_suite/tests/ui/unexpected-literal/field.stderr\n@@ -3,6 +3,3 @@ error: unexpected literal in serde field attribute\n   |\n 5 |     #[serde(\"literal\")]\n   |             ^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/unexpected-literal/variant.stderr b/test_suite/tests/ui/unexpected-literal/variant.stderr\nindex 6c4904b07..b7b2165c5 100644\n--- a/test_suite/tests/ui/unexpected-literal/variant.stderr\n+++ b/test_suite/tests/ui/unexpected-literal/variant.stderr\n@@ -3,6 +3,3 @@ error: unexpected literal in serde variant attribute\n   |\n 5 |     #[serde(\"literal\")]\n   |             ^^^^^^^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/unknown-attribute/container.stderr b/test_suite/tests/ui/unknown-attribute/container.stderr\nindex dbb589c1b..402a1b603 100644\n--- a/test_suite/tests/ui/unknown-attribute/container.stderr\n+++ b/test_suite/tests/ui/unknown-attribute/container.stderr\n@@ -3,6 +3,3 @@ error: unknown serde container attribute `abc`\n   |\n 4 | #[serde(abc = \"xyz\")]\n   |         ^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/unknown-attribute/field.stderr b/test_suite/tests/ui/unknown-attribute/field.stderr\nindex d95e280ba..b13754a36 100644\n--- a/test_suite/tests/ui/unknown-attribute/field.stderr\n+++ b/test_suite/tests/ui/unknown-attribute/field.stderr\n@@ -3,6 +3,3 @@ error: unknown serde field attribute `abc`\n   |\n 5 |     #[serde(abc = \"xyz\")]\n   |             ^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/unknown-attribute/variant.stderr b/test_suite/tests/ui/unknown-attribute/variant.stderr\nindex a3d586075..64254f857 100644\n--- a/test_suite/tests/ui/unknown-attribute/variant.stderr\n+++ b/test_suite/tests/ui/unknown-attribute/variant.stderr\n@@ -3,6 +3,3 @@ error: unknown serde variant attribute `abc`\n   |\n 5 |     #[serde(abc = \"xyz\")]\n   |             ^^^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/unsupported/union_de.stderr b/test_suite/tests/ui/unsupported/union_de.stderr\nindex 4f674e0d3..b7892d490 100644\n--- a/test_suite/tests/ui/unsupported/union_de.stderr\n+++ b/test_suite/tests/ui/unsupported/union_de.stderr\n@@ -6,6 +6,3 @@ error: Serde does not support derive for unions\n 6 | |     y: (),\n 7 | | }\n   | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/unsupported/union_ser.stderr b/test_suite/tests/ui/unsupported/union_ser.stderr\nindex 9535cc8ee..78d87c71e 100644\n--- a/test_suite/tests/ui/unsupported/union_ser.stderr\n+++ b/test_suite/tests/ui/unsupported/union_ser.stderr\n@@ -6,6 +6,3 @@ error: Serde does not support derive for unions\n 6 | |     y: (),\n 7 | | }\n   | |_^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/update-references.sh b/test_suite/tests/ui/update-references.sh\ndeleted file mode 100755\nindex 725943295..000000000\n--- a/test_suite/tests/ui/update-references.sh\n+++ /dev/null\n@@ -1,38 +0,0 @@\n-#!/bin/bash\n-#\n-# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-# A script to update the references for particular tests. The idea is\n-# that you do a run, which will generate files in the build directory\n-# containing the (normalized) actual output of the compiler. This\n-# script will then copy that output and replace the \"expected output\"\n-# files. You can then commit the changes.\n-#\n-# If you find yourself manually editing a foo.stderr file, you're\n-# doing it wrong.\n-\n-cd \"$(dirname \"${BASH_SOURCE[0]}\")\"\n-BUILD_DIR=\"../../../target/ui\"\n-\n-for testcase in */*.rs; do\n-    STDERR_NAME=\"${testcase/%.rs/.stderr}\"\n-    STDOUT_NAME=\"${testcase/%.rs/.stdout}\"\n-    if [ -f \"$BUILD_DIR/$STDOUT_NAME\" ] && \\\n-           ! (diff \"$BUILD_DIR/$STDOUT_NAME\" \"$STDOUT_NAME\" >& /dev/null); then\n-        echo \"updating $STDOUT_NAME\"\n-        cp \"$BUILD_DIR/$STDOUT_NAME\" \"$STDOUT_NAME\"\n-    fi\n-    if [ -f \"$BUILD_DIR/$STDERR_NAME\" ] && \\\n-           ! (diff \"$BUILD_DIR/$STDERR_NAME\" \"$STDERR_NAME\" >& /dev/null); then\n-        echo \"updating $STDERR_NAME\"\n-        cp \"$BUILD_DIR/$STDERR_NAME\" \"$STDERR_NAME\"\n-    fi\n-done\ndiff --git a/test_suite/tests/ui/with-variant/skip_de_newtype_field.stderr b/test_suite/tests/ui/with-variant/skip_de_newtype_field.stderr\nindex 1b5f15cd0..d3ff8c6e8 100644\n--- a/test_suite/tests/ui/with-variant/skip_de_newtype_field.stderr\n+++ b/test_suite/tests/ui/with-variant/skip_de_newtype_field.stderr\n@@ -4,6 +4,3 @@ error: variant `Newtype` cannot have both #[serde(deserialize_with)] and a field\n 5 | /     #[serde(deserialize_with = \"deserialize_some_newtype_variant\")]\n 6 | |     Newtype(#[serde(skip_deserializing)] String),\n   | |________________________________________________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/with-variant/skip_de_struct_field.stderr b/test_suite/tests/ui/with-variant/skip_de_struct_field.stderr\nindex 7b3649c60..ee7e37918 100644\n--- a/test_suite/tests/ui/with-variant/skip_de_struct_field.stderr\n+++ b/test_suite/tests/ui/with-variant/skip_de_struct_field.stderr\n@@ -8,6 +8,3 @@ error: variant `Struct` cannot have both #[serde(deserialize_with)] and a field\n 9  | |         f2: u8,\n 10 | |     },\n    | |_____^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/with-variant/skip_de_tuple_field.stderr b/test_suite/tests/ui/with-variant/skip_de_tuple_field.stderr\nindex 5c3e44e18..f2cc90e80 100644\n--- a/test_suite/tests/ui/with-variant/skip_de_tuple_field.stderr\n+++ b/test_suite/tests/ui/with-variant/skip_de_tuple_field.stderr\n@@ -4,6 +4,3 @@ error: variant `Tuple` cannot have both #[serde(deserialize_with)] and a field #\n 5 | /     #[serde(deserialize_with = \"deserialize_some_other_variant\")]\n 6 | |     Tuple(#[serde(skip_deserializing)] String, u8),\n   | |__________________________________________________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/with-variant/skip_de_whole_variant.stderr b/test_suite/tests/ui/with-variant/skip_de_whole_variant.stderr\nindex 2d5ac0643..8f1be1632 100644\n--- a/test_suite/tests/ui/with-variant/skip_de_whole_variant.stderr\n+++ b/test_suite/tests/ui/with-variant/skip_de_whole_variant.stderr\n@@ -5,6 +5,3 @@ error: variant `Unit` cannot have both #[serde(deserialize_with)] and #[serde(sk\n 6 | |     #[serde(skip_deserializing)]\n 7 | |     Unit,\n   | |________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/with-variant/skip_ser_newtype_field.stderr b/test_suite/tests/ui/with-variant/skip_ser_newtype_field.stderr\nindex 3298c5272..5741bc4fc 100644\n--- a/test_suite/tests/ui/with-variant/skip_ser_newtype_field.stderr\n+++ b/test_suite/tests/ui/with-variant/skip_ser_newtype_field.stderr\n@@ -4,6 +4,3 @@ error: variant `Newtype` cannot have both #[serde(serialize_with)] and a field #\n 5 | /     #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n 6 | |     Newtype(#[serde(skip_serializing)] String),\n   | |______________________________________________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/with-variant/skip_ser_newtype_field_if.stderr b/test_suite/tests/ui/with-variant/skip_ser_newtype_field_if.stderr\nindex 09c7ba431..8103680f6 100644\n--- a/test_suite/tests/ui/with-variant/skip_ser_newtype_field_if.stderr\n+++ b/test_suite/tests/ui/with-variant/skip_ser_newtype_field_if.stderr\n@@ -4,6 +4,3 @@ error: variant `Newtype` cannot have both #[serde(serialize_with)] and a field #\n 5 | /     #[serde(serialize_with = \"serialize_some_newtype_variant\")]\n 6 | |     Newtype(#[serde(skip_serializing_if = \"always\")] String),\n   | |____________________________________________________________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/with-variant/skip_ser_struct_field.stderr b/test_suite/tests/ui/with-variant/skip_ser_struct_field.stderr\nindex fca04c58f..5b1e2301a 100644\n--- a/test_suite/tests/ui/with-variant/skip_ser_struct_field.stderr\n+++ b/test_suite/tests/ui/with-variant/skip_ser_struct_field.stderr\n@@ -8,6 +8,3 @@ error: variant `Struct` cannot have both #[serde(serialize_with)] and a field `f\n 9  | |         f2: u8,\n 10 | |     },\n    | |_____^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/with-variant/skip_ser_struct_field_if.stderr b/test_suite/tests/ui/with-variant/skip_ser_struct_field_if.stderr\nindex a999665ac..4fc89d6a5 100644\n--- a/test_suite/tests/ui/with-variant/skip_ser_struct_field_if.stderr\n+++ b/test_suite/tests/ui/with-variant/skip_ser_struct_field_if.stderr\n@@ -8,6 +8,3 @@ error: variant `Struct` cannot have both #[serde(serialize_with)] and a field `f\n 9  | |         f2: u8,\n 10 | |     },\n    | |_____^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/with-variant/skip_ser_tuple_field.stderr b/test_suite/tests/ui/with-variant/skip_ser_tuple_field.stderr\nindex 828c4aaab..4ea2dda59 100644\n--- a/test_suite/tests/ui/with-variant/skip_ser_tuple_field.stderr\n+++ b/test_suite/tests/ui/with-variant/skip_ser_tuple_field.stderr\n@@ -4,6 +4,3 @@ error: variant `Tuple` cannot have both #[serde(serialize_with)] and a field #0\n 5 | /     #[serde(serialize_with = \"serialize_some_other_variant\")]\n 6 | |     Tuple(#[serde(skip_serializing)] String, u8),\n   | |________________________________________________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/with-variant/skip_ser_tuple_field_if.stderr b/test_suite/tests/ui/with-variant/skip_ser_tuple_field_if.stderr\nindex f83801157..1f8a81493 100644\n--- a/test_suite/tests/ui/with-variant/skip_ser_tuple_field_if.stderr\n+++ b/test_suite/tests/ui/with-variant/skip_ser_tuple_field_if.stderr\n@@ -4,6 +4,3 @@ error: variant `Tuple` cannot have both #[serde(serialize_with)] and a field #0\n 5 | /     #[serde(serialize_with = \"serialize_some_other_variant\")]\n 6 | |     Tuple(#[serde(skip_serializing_if = \"always\")] String, u8),\n   | |______________________________________________________________^\n-\n-error: aborting due to previous error\n-\ndiff --git a/test_suite/tests/ui/with-variant/skip_ser_whole_variant.stderr b/test_suite/tests/ui/with-variant/skip_ser_whole_variant.stderr\nindex 5b3f74774..20decdc43 100644\n--- a/test_suite/tests/ui/with-variant/skip_ser_whole_variant.stderr\n+++ b/test_suite/tests/ui/with-variant/skip_ser_whole_variant.stderr\n@@ -5,6 +5,3 @@ error: variant `Unit` cannot have both #[serde(serialize_with)] and #[serde(skip\n 6 | |     #[serde(skip_serializing)]\n 7 | |     Unit,\n   | |________^\n-\n-error: aborting due to previous error\n-\n", "problem_statement": "Re-enable compile-fail tests\nDisabled temporarily in #1512 due to libserde now appearing in the nightly sysroot and causing a conflict. We will need to figure out how else to run these tests.\n", "hints_text": "I think the solution will involve factoring out the test runner from https://github.com/dtolnay/proc-macro-workshop and dropping compiletest_rs in favor of that. It is a more robust approach based on Cargo rather than direct rustc invocations. I have found that it works very reliably and in particular would not have this class of problem.\r\n\r\nUpstream issue: https://github.com/dtolnay/proc-macro-workshop/issues/14\nHere's the clippy workaround: https://github.com/rust-lang/rust-clippy/pull/4017 ", "created_at": "2019-05-06T16:59:53Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1499, "instance_id": "serde-rs__serde-1499", "issue_numbers": ["1487"], "base_commit": "295730ba1e8ccfb58afad836ea4907b951698aae", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 7fa1030b1..df76ec631 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -27,15 +27,16 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<TokenStream\n     let (de_impl_generics, _, ty_generics, where_clause) = split_with_de_lifetime(&params);\n     let body = Stmts(deserialize_body(&cont, &params));\n     let delife = params.borrowed.de_lifetime();\n+    let serde = cont.attrs.serde_path();\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n         let vis = &input.vis;\n         let used = pretend::pretend_used(&cont);\n         quote! {\n             impl #de_impl_generics #ident #ty_generics #where_clause {\n-                #vis fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<#remote #ty_generics, __D::Error>\n+                #vis fn deserialize<__D>(__deserializer: __D) -> #serde::export::Result<#remote #ty_generics, __D::Error>\n                 where\n-                    __D: _serde::Deserializer<#delife>,\n+                    __D: #serde::Deserializer<#delife>,\n                 {\n                     #used\n                     #body\n@@ -47,10 +48,10 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<TokenStream\n \n         quote! {\n             #[automatically_derived]\n-            impl #de_impl_generics _serde::Deserialize<#delife> for #ident #ty_generics #where_clause {\n-                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>\n+            impl #de_impl_generics #serde::Deserialize<#delife> for #ident #ty_generics #where_clause {\n+                fn deserialize<__D>(__deserializer: __D) -> #serde::export::Result<Self, __D::Error>\n                 where\n-                    __D: _serde::Deserializer<#delife>,\n+                    __D: #serde::Deserializer<#delife>,\n                 {\n                     #body\n                 }\n@@ -60,7 +61,7 @@ pub fn expand_derive_deserialize(input: &syn::DeriveInput) -> Result<TokenStream\n         }\n     };\n \n-    Ok(dummy::wrap_in_const(\"DESERIALIZE\", ident, impl_block))\n+    Ok(dummy::wrap_in_const(cont.attrs.custom_serde_path(), \"DESERIALIZE\", ident, impl_block))\n }\n \n fn precondition(cx: &Ctxt, cont: &Container) {\ndiff --git a/serde_derive/src/dummy.rs b/serde_derive/src/dummy.rs\nindex c265f03ea..a4e0e038b 100644\n--- a/serde_derive/src/dummy.rs\n+++ b/serde_derive/src/dummy.rs\n@@ -1,8 +1,9 @@\n use proc_macro2::{Ident, Span, TokenStream};\n \n+use syn;\n use try;\n \n-pub fn wrap_in_const(trait_: &str, ty: &Ident, code: TokenStream) -> TokenStream {\n+pub fn wrap_in_const(serde_path: Option<&syn::Path>, trait_: &str, ty: &Ident, code: TokenStream) -> TokenStream {\n     let try_replacement = try::replacement();\n \n     let dummy_const = Ident::new(\n@@ -10,13 +11,21 @@ pub fn wrap_in_const(trait_: &str, ty: &Ident, code: TokenStream) -> TokenStream\n         Span::call_site(),\n     );\n \n-    quote! {\n-        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-        const #dummy_const: () = {\n+    let use_serde = serde_path.map(|path| {\n+        quote!(use #path as _serde;)\n+    }).unwrap_or_else(|| {\n+        quote! {\n             #[allow(unknown_lints)]\n             #[cfg_attr(feature = \"cargo-clippy\", allow(useless_attribute))]\n             #[allow(rust_2018_idioms)]\n             extern crate serde as _serde;\n+        }\n+    });\n+\n+    quote! {\n+        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n+        const #dummy_const: () = {\n+            #use_serde\n             #try_replacement\n             #code\n         };\ndiff --git a/serde_derive/src/internals/attr.rs b/serde_derive/src/internals/attr.rs\nindex b95d490f2..db763e22c 100644\n--- a/serde_derive/src/internals/attr.rs\n+++ b/serde_derive/src/internals/attr.rs\n@@ -1,6 +1,7 @@\n use internals::Ctxt;\n use proc_macro2::{Group, Span, TokenStream, TokenTree};\n use quote::ToTokens;\n+use std::borrow::Cow;\n use std::collections::BTreeSet;\n use std::str::FromStr;\n use syn;\n@@ -218,6 +219,7 @@ pub struct Container {\n     remote: Option<syn::Path>,\n     identifier: Identifier,\n     has_flatten: bool,\n+    serde_path: Option<syn::Path>,\n }\n \n /// Styles of representing an enum.\n@@ -298,6 +300,7 @@ impl Container {\n         let mut remote = Attr::none(cx, \"remote\");\n         let mut field_identifier = BoolAttr::none(cx, \"field_identifier\");\n         let mut variant_identifier = BoolAttr::none(cx, \"variant_identifier\");\n+        let mut serde_path = Attr::none(cx, \"crate\");\n \n         for meta_items in item.attrs.iter().filter_map(get_serde_meta_items) {\n             for meta_item in meta_items {\n@@ -582,6 +585,13 @@ impl Container {\n                         variant_identifier.set_true(word);\n                     }\n \n+                    // Parse `#[serde(crate = \"foo\")]`\n+                    Meta(NameValue(ref m)) if m.ident == \"crate\" => {\n+                        if let Ok(path) = parse_lit_into_path(cx, &m.ident, &m.lit) {\n+                            serde_path.set(&m.ident, path)\n+                        }\n+                    }\n+\n                     Meta(ref meta_item) => {\n                         cx.error_spanned_by(\n                             meta_item.name(),\n@@ -613,6 +623,7 @@ impl Container {\n             remote: remote.get(),\n             identifier: decide_identifier(cx, item, field_identifier, variant_identifier),\n             has_flatten: false,\n+            serde_path: serde_path.get(),\n         }\n     }\n \n@@ -671,6 +682,16 @@ impl Container {\n     pub fn mark_has_flatten(&mut self) {\n         self.has_flatten = true;\n     }\n+\n+    pub fn custom_serde_path(&self) -> Option<&syn::Path> {\n+        self.serde_path.as_ref()\n+    }\n+\n+    pub fn serde_path(&self) -> Cow<syn::Path> {\n+        self.custom_serde_path()\n+            .map(Cow::Borrowed)\n+            .unwrap_or_else(|| Cow::Owned(parse_quote!(_serde)))\n+    }\n }\n \n fn decide_tag(\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 4d1f680db..d5c83bc64 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -22,15 +22,16 @@ pub fn expand_derive_serialize(input: &syn::DeriveInput) -> Result<TokenStream,\n     let params = Parameters::new(&cont);\n     let (impl_generics, ty_generics, where_clause) = params.generics.split_for_impl();\n     let body = Stmts(serialize_body(&cont, &params));\n+    let serde = cont.attrs.serde_path();\n \n     let impl_block = if let Some(remote) = cont.attrs.remote() {\n         let vis = &input.vis;\n         let used = pretend::pretend_used(&cont);\n         quote! {\n             impl #impl_generics #ident #ty_generics #where_clause {\n-                #vis fn serialize<__S>(__self: &#remote #ty_generics, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n+                #vis fn serialize<__S>(__self: &#remote #ty_generics, __serializer: __S) -> #serde::export::Result<__S::Ok, __S::Error>\n                 where\n-                    __S: _serde::Serializer,\n+                    __S: #serde::Serializer,\n                 {\n                     #used\n                     #body\n@@ -40,10 +41,10 @@ pub fn expand_derive_serialize(input: &syn::DeriveInput) -> Result<TokenStream,\n     } else {\n         quote! {\n             #[automatically_derived]\n-            impl #impl_generics _serde::Serialize for #ident #ty_generics #where_clause {\n-                fn serialize<__S>(&self, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n+            impl #impl_generics #serde::Serialize for #ident #ty_generics #where_clause {\n+                fn serialize<__S>(&self, __serializer: __S) -> #serde::export::Result<__S::Ok, __S::Error>\n                 where\n-                    __S: _serde::Serializer,\n+                    __S: #serde::Serializer,\n                 {\n                     #body\n                 }\n@@ -51,7 +52,7 @@ pub fn expand_derive_serialize(input: &syn::DeriveInput) -> Result<TokenStream,\n         }\n     };\n \n-    Ok(dummy::wrap_in_const(\"SERIALIZE\", ident, impl_block))\n+    Ok(dummy::wrap_in_const(cont.attrs.custom_serde_path(), \"SERIALIZE\", ident, impl_block))\n }\n \n fn precondition(cx: &Ctxt, cont: &Container) {\n", "test_patch": "diff --git a/test_suite/tests/test_serde_path.rs b/test_suite/tests/test_serde_path.rs\nnew file mode 100644\nindex 000000000..4de436733\n--- /dev/null\n+++ b/test_suite/tests/test_serde_path.rs\n@@ -0,0 +1,39 @@\n+#[test]\n+fn test_gen_custom_serde() {\n+    #[derive(serde::Serialize, serde::Deserialize)]\n+    #[serde(crate = \"fake_serde\")]\n+    struct Foo;\n+\n+    // Would be overlapping if serde::Serialize were implemented\n+    impl AssertNotSerdeSerialize for Foo {}\n+    // Would be overlapping if serde::Deserialize were implemented\n+    impl<'a> AssertNotSerdeDeserialize<'a> for Foo {}\n+\n+    fake_serde::assert::<Foo>();\n+}\n+\n+mod fake_serde {\n+    pub use serde::*;\n+\n+    pub fn assert<T>()\n+    where\n+        T: Serialize,\n+        T: for<'a> Deserialize<'a>,\n+    {}\n+\n+    pub trait Serialize {\n+        fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error>;\n+    }\n+\n+    pub trait Deserialize<'a>: Sized {\n+        fn deserialize<D: Deserializer<'a>>(deserializer: D) -> Result<Self, D::Error>;\n+    }\n+}\n+\n+trait AssertNotSerdeSerialize {}\n+\n+impl<T: serde::Serialize> AssertNotSerdeSerialize for T {}\n+\n+trait AssertNotSerdeDeserialize<'a> {}\n+\n+impl<'a, T: serde::Deserialize<'a>> AssertNotSerdeDeserialize<'a> for T {}\n", "problem_statement": "Allow specifying `serde` path and avoid injecting `extern crate serde as _serde`.\n[tower-web](https://github.com/carllerche/tower-web/) provides a `#[derive(Response)]` macro. This macro is a shim on top of serde's `derive(Serialize)`. It works by catching HTTP specific attributes and leaving any serde attributes. It then generates a \"shadow\" version of the struct that has the actual `derive(Serialize)`.\r\n\r\nThe problem is that the user must add `serde` to their `Cargo.toml` even if they do not interact with any serde APIs directly.\r\n\r\n`tower-web` re-exports `serde` in the crate. I propose to have a serde attribute that allows specifying the path to `serde`. If this attribute is set, the `extern crate serde as _serde` is omitted.\r\n\r\n[This](https://gist.github.com/carllerche/6e2351e1c3f968792cb898c08a726d96) gist illustrates the problem. `hello.rs` is very basic. I also included the expanded code.\r\n\r\nIn short, I would like [this](https://gist.github.com/carllerche/6e2351e1c3f968792cb898c08a726d96#file-hello-expanded-rs-L70) line omitted and all references to `_serde` replaced with `__tw::codegen::serde`.\r\n\r\nOne way to expose the API is as an attribute:\r\n\r\n```rust\r\n#[derive(Serialize)]\r\n#[serde(serde_path = \"__tw::codegen::serde\")]\r\nstruct Routes {\r\n// ....\r\n}\r\n```\r\n\r\nIf you like this strategy, I could attempt a PR.\n", "hints_text": "Seems reasonable. Please send a PR.\r\n\r\nYou will need to decide whether the given path is a `use` path or a relative path i.e. whether the expanded code is:\r\n\r\n```rust\r\nuse __tw::codegen::serde;\r\nimpl serde::Serialize for T\r\n```\r\n\r\nor this:\r\n\r\n```rust\r\nimpl __tw::codegen::serde::Serialize for T\r\n```\r\n\r\nThose would have different behavior in 2015 edition.\nI'm pretty sure `use` doesn't work in the anon const scope thing. Since tower-web generates in a const scope, it cannot do option 1.\r\n\r\nMy thought is that whatever is set in `#[serde(serde_path = \"__tw::codegen::serde\")]` is used verbatim in the generated code. i.e. option 2.\r\n\r\nDo you have thoughts on this? Also, do you have thoughts on what the attr should be?\nGentle ping :)\r\n\r\nWhen you are +1 on the path, I can try to put together a PR (since it will probably be non-trivial, I'm hoping to get approval on the direction first).\nThanks for the reminder. I would accept a PR for option 2 using:\r\n\r\n```rust\r\n#[serde(crate = \"__tw::codegen::serde\")]\r\n```\r\n\r\nas the attribute.", "created_at": "2019-03-18T21:21:21Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1474, "instance_id": "serde-rs__serde-1474", "issue_numbers": ["1468"], "base_commit": "c8e39594357bdecb9dfee889dbdfced735033469", "patch": "diff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 1dacdc05a..e87ddee80 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -289,37 +289,41 @@ fn serialize_struct(params: &Parameters, fields: &[Field], cattrs: &attr::Contai\n     }\n }\n \n+fn serialize_struct_tag_field(\n+    cattrs: &attr::Container,\n+    struct_trait: &StructTrait,\n+) -> TokenStream {\n+    match *cattrs.tag() {\n+        attr::TagType::Internal { ref tag } => {\n+            let type_name = cattrs.name().serialize_name();\n+            let func = struct_trait.serialize_field(Span::call_site());\n+            quote! {\n+                try!(#func(&mut __serde_state, #tag, #type_name));\n+            }\n+        }\n+        _ => quote!{}\n+    }\n+}\n+\n fn serialize_struct_as_struct(\n     params: &Parameters,\n     fields: &[Field],\n     cattrs: &attr::Container,\n ) -> Fragment {\n-    let mut serialize_fields =\n+    let serialize_fields =\n         serialize_struct_visitor(fields, params, false, &StructTrait::SerializeStruct);\n \n     let type_name = cattrs.name().serialize_name();\n \n-    let additional_field_count: usize = match *cattrs.tag() {\n-        attr::TagType::Internal { ref tag } => {\n-            let func = StructTrait::SerializeStruct.serialize_field(Span::call_site());\n-            serialize_fields.insert(\n-                0,\n-                quote! {\n-                    try!(#func(&mut __serde_state, #tag, #type_name));\n-                },\n-            );\n-\n-            1\n-        }\n-        _ => 0,\n-    };\n+    let tag_field = serialize_struct_tag_field(cattrs, &StructTrait::SerializeStruct);\n+    let tag_field_exists = !tag_field.is_empty();\n \n     let mut serialized_fields = fields\n         .iter()\n         .filter(|&field| !field.attrs.skip_serializing())\n         .peekable();\n \n-    let let_mut = mut_if(serialized_fields.peek().is_some() || additional_field_count > 0);\n+    let let_mut = mut_if(serialized_fields.peek().is_some() || tag_field_exists);\n \n     let len = serialized_fields\n         .map(|field| match field.attrs.skip_serializing_if() {\n@@ -330,12 +334,13 @@ fn serialize_struct_as_struct(\n             }\n         })\n         .fold(\n-            quote!(#additional_field_count),\n+            quote!(#tag_field_exists as usize),\n             |sum, expr| quote!(#sum + #expr),\n         );\n \n     quote_block! {\n         let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct(__serializer, #type_name, #len));\n+        #tag_field\n         #(#serialize_fields)*\n         _serde::ser::SerializeStruct::end(__serde_state)\n     }\n@@ -349,12 +354,15 @@ fn serialize_struct_as_map(\n     let serialize_fields =\n         serialize_struct_visitor(fields, params, false, &StructTrait::SerializeMap);\n \n+    let tag_field = serialize_struct_tag_field(cattrs, &StructTrait::SerializeMap);\n+    let tag_field_exists = !tag_field.is_empty();\n+\n     let mut serialized_fields = fields\n         .iter()\n         .filter(|&field| !field.attrs.skip_serializing())\n         .peekable();\n \n-    let let_mut = mut_if(serialized_fields.peek().is_some());\n+    let let_mut = mut_if(serialized_fields.peek().is_some() || tag_field_exists);\n \n     let len = if cattrs.has_flatten() {\n         quote!(_serde::export::None)\n@@ -367,12 +375,16 @@ fn serialize_struct_as_map(\n                     quote!(if #path(#field_expr) { 0 } else { 1 })\n                 }\n             })\n-            .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n+            .fold(\n+                quote!(#tag_field_exists as usize),\n+                |sum, expr| quote!(#sum + #expr)\n+            );\n         quote!(_serde::export::Some(#len))\n     };\n \n     quote_block! {\n         let #let_mut __serde_state = try!(_serde::Serializer::serialize_map(__serializer, #len));\n+        #tag_field\n         #(#serialize_fields)*\n         _serde::ser::SerializeMap::end(__serde_state)\n     }\n", "test_patch": "diff --git a/test_suite/tests/test_macros.rs b/test_suite/tests/test_macros.rs\nindex 280f00439..dd9591370 100644\n--- a/test_suite/tests/test_macros.rs\n+++ b/test_suite/tests/test_macros.rs\n@@ -1424,6 +1424,48 @@ fn test_internally_tagged_braced_struct_with_zero_fields() {\n     );\n }\n \n+#[test]\n+fn test_internally_tagged_struct_with_flattened_field() {\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    #[serde(tag=\"tag_struct\")]\n+    pub struct Struct {\n+        #[serde(flatten)]\n+        pub flat: Enum\n+    }\n+\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    #[serde(tag=\"tag_enum\", content=\"content\")]\n+    pub enum Enum {\n+        A(u64),\n+    }\n+\n+    assert_tokens(\n+        &Struct{flat: Enum::A(0)},\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"tag_struct\"),\n+            Token::Str(\"Struct\"),\n+            Token::Str(\"tag_enum\"),\n+            Token::Str(\"A\"),\n+            Token::Str(\"content\"),\n+            Token::U64(0),\n+            Token::MapEnd\n+        ]\n+    );\n+\n+    assert_de_tokens(\n+        &Struct{flat: Enum::A(0)},\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"tag_enum\"),\n+            Token::Str(\"A\"),\n+            Token::Str(\"content\"),\n+            Token::U64(0),\n+            Token::MapEnd\n+        ]\n+    );\n+}\n+\n #[test]\n fn test_enum_in_untagged_enum() {\n     #[derive(Debug, PartialEq, Serialize, Deserialize)]\n", "problem_statement": "Marking a struct field as flattened makes the struct ignore its tag\nIf I define a struct with a tag and add a field with the \"flatten\" attribute to this struct. The structs's tag seems to be ignored.\r\n\r\n```rust\r\nextern crate serde; // 1.0.84\r\n#[macro_use]\r\nextern crate serde_derive; // 1.0.84\r\n#[macro_use]\r\nextern crate serde_json; // 1.0.34\r\n\r\n\r\n#[derive(Serialize, Debug)]\r\n#[serde(tag=\"type\")]\r\npub struct Program {\r\n    #[serde(flatten)]\r\n    pub body: ProgramType\r\n}\r\n\r\n#[derive(Serialize, Debug)]\r\n#[serde(tag=\"sourceType\", content=\"body\")]\r\npub enum ProgramType {\r\n    #[serde(rename=\"script\")]\r\n    Script(u64),\r\n}\r\n\r\n\r\nfn main() {\r\n    let p = Program{body: ProgramType::Script(0)};\r\n    // This assert fails, output:\r\n    //  left: `Object({\"body\": Number(0), \"sourceType\": String(\"script\")})`,\r\n    //  right: `Object({\"body\": Number(0), \"sourceType\": String(\"script\"), \"type\": String(\"Program\")})`\r\n    assert_eq!(serde_json::to_value(p).unwrap(),\r\n                json!({\"type\": \"Program\", \"sourceType\": \"script\", \"body\": 0}))\r\n}\r\n```\n", "hints_text": "Thanks! This looks like a bug. Would you be interested in sending a PR to fix it?\nSure. I implemented the tagged structs in the first place so I guess it's only fair if I have to do the bug fixing :D But it might take a few days.", "created_at": "2019-02-03T01:17:53Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1390, "instance_id": "serde-rs__serde-1390", "issue_numbers": ["1366"], "base_commit": "2cf10a600370b987a35136d21216d5dc29f7ecba", "patch": "diff --git a/travis.sh b/travis.sh\nindex 11c9556f5..9002e3e5c 100755\n--- a/travis.sh\n+++ b/travis.sh\n@@ -53,6 +53,7 @@ elif [ -n \"${EMSCRIPTEN}\" ]; then\n     chmod +x ~/.cargo/bin/cargo-web\n \n     cd \"$DIR/test_suite\"\n+    cargo web test --target=asmjs-unknown-emscripten --nodejs\n     cargo web test --target=wasm32-unknown-emscripten --nodejs\n else\n     CHANNEL=nightly\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 0df7fd69f..60bd0b413 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -272,7 +272,7 @@ declare_tests! {\n         0f32 => &[Token::F32(0.)],\n         0f64 => &[Token::F64(0.)],\n     }\n-    #[cfg(not(target_arch = \"wasm32\"))]\n+    #[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n     test_small_int_to_128 {\n         1i128 => &[Token::I8(1)],\n         1i128 => &[Token::I16(1)],\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex 231b6ee7c..81129540f 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -618,7 +618,7 @@ fn test_enum_skipped() {\n     );\n }\n \n-#[cfg(not(target_arch = \"wasm32\"))]\n+#[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n #[test]\n fn test_integer128() {\n     assert_ser_tokens_error(&1i128, &[], \"i128 is not supported\");\ndiff --git a/test_suite/tests/test_value.rs b/test_suite/tests/test_value.rs\nindex d351ed540..180e72f28 100644\n--- a/test_suite/tests/test_value.rs\n+++ b/test_suite/tests/test_value.rs\n@@ -26,7 +26,7 @@ fn test_u32_to_enum() {\n     assert_eq!(E::B, e);\n }\n \n-#[cfg(not(target_arch = \"wasm32\"))]\n+#[cfg(not(any(target_arch = \"asmjs\", target_arch = \"wasm32\")))]\n #[test]\n fn test_integer128() {\n     let de_u128 = IntoDeserializer::<value::Error>::into_deserializer(1u128);\n", "problem_statement": "Set up CI build on Emscripten target\n@koute do you know of any existing projects that test every commit on Emscripten? I would have liked to catch #1365 in CI. Is it as simple as just passing a `--target` to Cargo? Does that only let us test cross-compilation or is there a way to run our test suite as well?\n", "hints_text": "> @koute do you know of any existing projects that test every commit on Emscripten?\r\n\r\nYes! My [stdweb](https://github.com/koute/stdweb) does. (: In fact, this is how I caught this - suddenly my builds on stable started failing, and after more thorough investigation the culprit was the newest version of `serde_json` which switched to `ryu`.\r\n\r\n> Is it as simple as just passing a --target to Cargo? Does that only let us test cross-compilation or is there a way to run our test suite as well?\r\n\r\nMostly, yes, however you need to manually install Emscripten (`rustup` doesn't install it for you) and manually run the test file yourself (or set a runner in `.cargo/config`). I don't know if that's still the case though, but there was also a bug where after a fresh installation of Emscripten you had to \"warm\" it up (basically the first compilation after installing Emscripten produces no artifacts but no error is generated).\r\n\r\nYou can either do it manually, or you can use my [cargo-web](https://github.com/koute/cargo-web) to automate it. It will automatically install the target through `rustup`, download Emscripten for you and work around the post install bug.\r\n\r\nBasically, you can run this on Travis to install a precompiled binary of `cargo-web`:\r\n\r\n```\r\nCARGO_WEB_RELEASE=$(curl -L -s -H 'Accept: application/json' https://github.com/koute/cargo-web/releases/latest)\r\nCARGO_WEB_VERSION=$(echo $CARGO_WEB_RELEASE | sed -e 's/.*\"tag_name\":\"\\([^\"]*\\)\".*/\\1/')\r\nCARGO_WEB_URL=\"https://github.com/koute/cargo-web/releases/download/$CARGO_WEB_VERSION/cargo-web-x86_64-unknown-linux-gnu.gz\"\r\n\r\necho \"Downloading cargo-web from: $CARGO_WEB_URL\"\r\ncurl -L $CARGO_WEB_URL | gzip -d > cargo-web\r\nchmod +x cargo-web\r\n\r\nmkdir -p ~/.cargo/bin\r\nmv cargo-web ~/.cargo/bin\r\n```\r\n\r\nAnd then simply:\r\n\r\n```\r\n# Install Node.js\r\nnvm install 9\r\n\r\n# Run the tests.\r\ncargo web test --target=asmjs-unknown-emscripten --nodejs\r\ncargo web test --target=wasm32-unknown-emscripten --nodejs\r\n```\r\n\r\n(By default it runs the tests in a headless Chromium, but that's not necessary for projects which aren't strictly Web-related so `--nodejs` will make it run through Node.js.)\nAmazing! Thanks, we'll get this set up and stop breaking your builds.\nI couldn't get asmjs working because of\r\n\r\n```console\r\nerror[E0463]: can't find crate for `proc_macro`\r\n  --> /home/travis/.cargo/registry/src/github.com-1ecc6299db9ec823/proc-macro2-0.4.16/src/lib.rs:53:1\r\n   |\r\n53 | extern crate proc_macro;\r\n   | ^^^^^^^^^^^^^^^^^^^^^^^^ can't find crate\r\n```\r\n\r\nbut I added a wasm32-unknown-emscripten builder in #1373.\n@dtolnay It cannot find the `proc_macro` crate on the `asmjs-unknown-emscripten` as `proc_macro` seems to not be shipped by Rust for that target. (Which does make sense.)\r\n\r\nIf you remove `proc-macro2 = \"0.4\"` from the `[dev-dependencies]` of `serde_test_suite` then the `asmjs-unknown-unknown` will work. (Although you'd still need to extend the `#[cfg]`s in `tests/test_de.rs` `tests/test_ser.rs` and `tests/test_value.rs` to also handle `asmjs`, as they currently only match `wasm32`.)", "created_at": "2018-09-15T22:15:44Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1380, "instance_id": "serde-rs__serde-1380", "issue_numbers": ["1379"], "base_commit": "108cca687c7851973cc6cb1ad06de620ab8fae4d", "patch": "diff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex 51c7035a3..4b0f2c4c2 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -2916,18 +2916,17 @@ where\n     where\n         T: DeserializeSeed<'de>,\n     {\n-        match self.iter.next() {\n-            Some(item) => {\n+        while let Some(item) = self.iter.next() {\n+            if let Some((ref key, ref content)) = *item {\n                 // Do not take(), instead borrow this entry. The internally tagged\n                 // enum does its own buffering so we can't tell whether this entry\n                 // is going to be consumed. Borrowing here leaves the entry\n                 // available for later flattened fields.\n-                let (ref key, ref content) = *item.as_ref().unwrap();\n                 self.pending = Some(content);\n-                seed.deserialize(ContentRefDeserializer::new(key)).map(Some)\n+                return seed.deserialize(ContentRefDeserializer::new(key)).map(Some);\n             }\n-            None => Ok(None),\n         }\n+        Ok(None)\n     }\n \n     fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n", "test_patch": "diff --git a/test_suite/tests/test_annotations.rs b/test_suite/tests/test_annotations.rs\nindex 87eda5015..bf8af8052 100644\n--- a/test_suite/tests/test_annotations.rs\n+++ b/test_suite/tests/test_annotations.rs\n@@ -12,9 +12,11 @@\n extern crate serde_derive;\n \n extern crate serde;\n-use self::serde::de::{self, Unexpected};\n+use self::serde::de::{self, Visitor, MapAccess, Unexpected};\n use self::serde::{Deserialize, Deserializer, Serialize, Serializer};\n+\n use std::collections::{BTreeMap, HashMap};\n+use std::fmt;\n use std::marker::PhantomData;\n \n extern crate serde_test;\n@@ -2311,3 +2313,66 @@ fn test_flattened_internally_tagged_unit_enum_with_unknown_fields() {\n         ],\n     );\n }\n+\n+#[test]\n+fn test_flatten_any_after_flatten_struct() {\n+    #[derive(PartialEq, Debug)]\n+    struct Any;\n+\n+    impl<'de> Deserialize<'de> for Any {\n+        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+        where\n+            D: Deserializer<'de>,\n+        {\n+            struct AnyVisitor;\n+\n+            impl<'de> Visitor<'de> for AnyVisitor {\n+                type Value = Any;\n+\n+                fn expecting(&self, _formatter: &mut fmt::Formatter) -> fmt::Result {\n+                    unimplemented!()\n+                }\n+\n+                fn visit_map<M>(self, mut map: M) -> Result<Self::Value, M::Error>\n+                where\n+                    M: MapAccess<'de>,\n+                {\n+                    while let Some((Any, Any)) = map.next_entry()? {}\n+                    Ok(Any)\n+                }\n+            }\n+\n+            deserializer.deserialize_any(AnyVisitor)\n+        }\n+    }\n+\n+    #[derive(Deserialize, PartialEq, Debug)]\n+    struct Outer {\n+        #[serde(flatten)]\n+        inner: Inner,\n+        #[serde(flatten)]\n+        extra: Any,\n+    }\n+\n+    #[derive(Deserialize, PartialEq, Debug)]\n+    struct Inner {\n+        inner: i32,\n+    }\n+\n+    let s = Outer {\n+        inner: Inner {\n+            inner: 0,\n+        },\n+        extra: Any,\n+    };\n+\n+    assert_de_tokens(\n+        &s,\n+        &[\n+            Token::Map { len: None },\n+            Token::Str(\"inner\"),\n+            Token::I32(0),\n+            Token::MapEnd,\n+        ],\n+    );\n+}\n", "problem_statement": "Serde panics when flattening struct and Value\nWhen trying to deserialize a struct which contains another struct with the `#[serde(flatten)]` annotation and a field with the `#[serde(flatten)]` annotation and the type `toml::Value` (same with `serde_yaml` or `serde_json`), serde will panic.\r\n\r\nA minimal example for reproducing this:\r\n```rust\r\nextern crate serde;\r\n#[macro_use]\r\nextern crate serde_derive;\r\nextern crate toml;\r\n\r\n#[derive(Debug, Deserialize)]\r\nstruct Test {\r\n    text: Option<String>,\r\n    #[serde(flatten)]\r\n    settings: Settings,\r\n    #[serde(flatten)]\r\n    extra: toml::Value,\r\n}\r\n\r\n#[derive(Debug, Deserialize)]\r\nstruct Settings {\r\n    width: Option<u8>,\r\n}\r\n\r\nfn main() {\r\n    let file = \"text = \\\"test\\\"\\nwidth = 8\";\r\n    let test: Test = toml::from_str(file).unwrap();\r\n}\r\n```\r\n[playground](https://play.rust-lang.org/?gist=b5fd8d4d24cd319f76c3fa439c36ca8d&version=stable&mode=debug&edition=2015)\r\n\r\nThis will result in the following error:\r\n```\r\nthread 'main' panicked at 'called `Option::unwrap()` on a `None` value'\r\n```\n", "hints_text": "", "created_at": "2018-09-08T23:56:07Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 1373, "instance_id": "serde-rs__serde-1373", "issue_numbers": ["1366"], "base_commit": "d23a40c1bbd938830126db65ef83b99a8c64467e", "patch": "diff --git a/.travis.yml b/.travis.yml\nindex 87d36ff77..9124ebbbf 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -18,5 +18,8 @@ matrix:\n   include:\n     - rust: nightly\n       env: CLIPPY=true\n+    - rust: nightly\n+      env: EMSCRIPTEN=true\n+      script: nvm install 9 && ./travis.sh\n \n script: ./travis.sh\ndiff --git a/travis.sh b/travis.sh\nindex 8626e3e66..55b795084 100755\n--- a/travis.sh\n+++ b/travis.sh\n@@ -42,6 +42,18 @@ if [ -n \"${CLIPPY}\" ]; then\n \n     cd \"$DIR/test_suite/no_std\"\n     cargo clippy -- -Dclippy\n+elif [ -n \"${EMSCRIPTEN}\" ]; then\n+    CARGO_WEB_RELEASE=$(curl -L -s -H 'Accept: application/json' https://github.com/koute/cargo-web/releases/latest)\n+    CARGO_WEB_VERSION=$(echo \"${CARGO_WEB_RELEASE}\" | sed -e 's/.*\"tag_name\":\"\\([^\"]*\\)\".*/\\1/')\n+    CARGO_WEB_URL=\"https://github.com/koute/cargo-web/releases/download/${CARGO_WEB_VERSION}/cargo-web-x86_64-unknown-linux-gnu.gz\"\n+\n+    mkdir -p ~/.cargo/bin\n+    echo \"Downloading cargo-web from: ${CARGO_WEB_URL}\"\n+    curl -L \"${CARGO_WEB_URL}\" | gzip -d > ~/.cargo/bin/cargo-web\n+    chmod +x ~/.cargo/bin/cargo-web\n+\n+    cd \"$DIR/test_suite\"\n+    cargo web test --target=wasm32-unknown-emscripten --nodejs\n else\n     CHANNEL=nightly\n     cd \"$DIR\"\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 95b419e26..4897abd05 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -156,8 +156,12 @@ macro_rules! declare_tests {\n         )+\n     };\n \n-    ($($name:ident { $($value:expr => $tokens:expr,)+ })+) => {\n+    ($(\n+        $(#[$cfg:meta])*\n+        $name:ident { $($value:expr => $tokens:expr,)+ }\n+    )+) => {\n         $(\n+            $(#[$cfg])*\n             #[test]\n             fn $name() {\n                 $(\n@@ -260,6 +264,7 @@ declare_tests! {\n         0f32 => &[Token::F32(0.)],\n         0f64 => &[Token::F64(0.)],\n     }\n+    #[cfg(not(target_arch = \"wasm32\"))]\n     test_small_int_to_128 {\n         1i128 => &[Token::I8(1)],\n         1i128 => &[Token::I16(1)],\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex 086029b56..231b6ee7c 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -618,6 +618,7 @@ fn test_enum_skipped() {\n     );\n }\n \n+#[cfg(not(target_arch = \"wasm32\"))]\n #[test]\n fn test_integer128() {\n     assert_ser_tokens_error(&1i128, &[], \"i128 is not supported\");\ndiff --git a/test_suite/tests/test_value.rs b/test_suite/tests/test_value.rs\nindex d2d9e67c0..d351ed540 100644\n--- a/test_suite/tests/test_value.rs\n+++ b/test_suite/tests/test_value.rs\n@@ -26,6 +26,7 @@ fn test_u32_to_enum() {\n     assert_eq!(E::B, e);\n }\n \n+#[cfg(not(target_arch = \"wasm32\"))]\n #[test]\n fn test_integer128() {\n     let de_u128 = IntoDeserializer::<value::Error>::into_deserializer(1u128);\n", "problem_statement": "Set up CI build on Emscripten target\n@koute do you know of any existing projects that test every commit on Emscripten? I would have liked to catch #1365 in CI. Is it as simple as just passing a `--target` to Cargo? Does that only let us test cross-compilation or is there a way to run our test suite as well?\n", "hints_text": "> @koute do you know of any existing projects that test every commit on Emscripten?\r\n\r\nYes! My [stdweb](https://github.com/koute/stdweb) does. (: In fact, this is how I caught this - suddenly my builds on stable started failing, and after more thorough investigation the culprit was the newest version of `serde_json` which switched to `ryu`.\r\n\r\n> Is it as simple as just passing a --target to Cargo? Does that only let us test cross-compilation or is there a way to run our test suite as well?\r\n\r\nMostly, yes, however you need to manually install Emscripten (`rustup` doesn't install it for you) and manually run the test file yourself (or set a runner in `.cargo/config`). I don't know if that's still the case though, but there was also a bug where after a fresh installation of Emscripten you had to \"warm\" it up (basically the first compilation after installing Emscripten produces no artifacts but no error is generated).\r\n\r\nYou can either do it manually, or you can use my [cargo-web](https://github.com/koute/cargo-web) to automate it. It will automatically install the target through `rustup`, download Emscripten for you and work around the post install bug.\r\n\r\nBasically, you can run this on Travis to install a precompiled binary of `cargo-web`:\r\n\r\n```\r\nCARGO_WEB_RELEASE=$(curl -L -s -H 'Accept: application/json' https://github.com/koute/cargo-web/releases/latest)\r\nCARGO_WEB_VERSION=$(echo $CARGO_WEB_RELEASE | sed -e 's/.*\"tag_name\":\"\\([^\"]*\\)\".*/\\1/')\r\nCARGO_WEB_URL=\"https://github.com/koute/cargo-web/releases/download/$CARGO_WEB_VERSION/cargo-web-x86_64-unknown-linux-gnu.gz\"\r\n\r\necho \"Downloading cargo-web from: $CARGO_WEB_URL\"\r\ncurl -L $CARGO_WEB_URL | gzip -d > cargo-web\r\nchmod +x cargo-web\r\n\r\nmkdir -p ~/.cargo/bin\r\nmv cargo-web ~/.cargo/bin\r\n```\r\n\r\nAnd then simply:\r\n\r\n```\r\n# Install Node.js\r\nnvm install 9\r\n\r\n# Run the tests.\r\ncargo web test --target=asmjs-unknown-emscripten --nodejs\r\ncargo web test --target=wasm32-unknown-emscripten --nodejs\r\n```\r\n\r\n(By default it runs the tests in a headless Chromium, but that's not necessary for projects which aren't strictly Web-related so `--nodejs` will make it run through Node.js.)\nAmazing! Thanks, we'll get this set up and stop breaking your builds.", "created_at": "2018-09-02T19:34:54Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 566, "instance_id": "serde-rs__serde-566", "issue_numbers": ["565"], "base_commit": "8b7b886036c5a58aa9b30e777612ef0f1c4f6d7a", "patch": "diff --git a/serde_derive/Cargo.toml b/serde_derive/Cargo.toml\nindex 51985b25b..329609646 100644\n--- a/serde_derive/Cargo.toml\n+++ b/serde_derive/Cargo.toml\n@@ -21,6 +21,7 @@ default-features = false\n features = [\"with-syn\"]\n \n [dev-dependencies]\n+compiletest_rs = \"^0.2.0\"\n fnv = \"1.0\"\n serde = { version = \"0.8.10\", path = \"../serde\" }\n serde_test = { version = \"0.8.10\", path = \"../serde_test\" }\ndiff --git a/serde_macros/.cargo/config b/serde_macros/.cargo/config\ndeleted file mode 100644\nindex 7f1ab8d35..000000000\n--- a/serde_macros/.cargo/config\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-# To prevent compiletest from seeing two versions of serde\n-paths = [\"../serde\"]\ndiff --git a/serde_macros/.gitignore b/serde_macros/.gitignore\ndeleted file mode 100644\nindex 4fffb2f89..000000000\n--- a/serde_macros/.gitignore\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-/target\n-/Cargo.lock\ndiff --git a/serde_macros/Cargo.toml b/serde_macros/Cargo.toml\ndeleted file mode 100644\nindex 62b5e6823..000000000\n--- a/serde_macros/Cargo.toml\n+++ /dev/null\n@@ -1,41 +0,0 @@\n-[package]\n-name = \"serde_macros\"\n-version = \"0.8.9\"\n-authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n-license = \"MIT/Apache-2.0\"\n-description = \"Macros to auto-generate implementations for the serde framework\"\n-homepage = \"https://serde.rs\"\n-repository = \"https://github.com/serde-rs/serde\"\n-documentation = \"https://serde.rs/codegen.html\"\n-keywords = [\"serde\", \"serialization\"]\n-include = [\"Cargo.toml\", \"src/**/*.rs\"]\n-\n-[lib]\n-name = \"serde_macros\"\n-plugin = true\n-\n-[features]\n-unstable-testing = [\n-    \"clippy\",\n-    \"serde/unstable-testing\",\n-    \"serde_codegen/unstable-testing\"\n-]\n-\n-[dependencies]\n-clippy = { version = \"^0.*\", optional = true }\n-serde_codegen = { version = \"=0.8.9\", default-features = false, features = [\"unstable\"], path = \"../serde_codegen\" }\n-\n-[dev-dependencies]\n-compiletest_rs = \"^0.2.0\"\n-fnv = \"1.0\"\n-rustc-serialize = \"^0.3.16\"\n-serde = { version = \"0.8.9\", path = \"../serde\" }\n-serde_test = { version = \"0.8.9\", path = \"../serde_test\" }\n-\n-[[test]]\n-name = \"test\"\n-path = \"tests/test.rs\"\n-\n-[[bench]]\n-name = \"bench\"\n-path = \"benches/bench.rs\"\ndiff --git a/serde_macros/benches/bench.rs b/serde_macros/benches/bench.rs\ndeleted file mode 100644\nindex ec15c18c7..000000000\n--- a/serde_macros/benches/bench.rs\n+++ /dev/null\n@@ -1,9 +0,0 @@\n-#![feature(custom_attribute, custom_derive, plugin, test)]\n-#![cfg_attr(feature = \"clippy\", plugin(clippy))]\n-#![plugin(serde_macros)]\n-\n-extern crate rustc_serialize;\n-extern crate serde;\n-extern crate test;\n-\n-include!(\"../../testing/benches/bench.rs.in\");\ndiff --git a/serde_macros/src/lib.rs b/serde_macros/src/lib.rs\ndeleted file mode 100644\nindex 077fdccf1..000000000\n--- a/serde_macros/src/lib.rs\n+++ /dev/null\n@@ -1,12 +0,0 @@\n-#![feature(plugin_registrar, rustc_private)]\n-#![cfg_attr(feature = \"clippy\", feature(plugin))]\n-#![cfg_attr(feature = \"clippy\", plugin(clippy))]\n-\n-extern crate serde_codegen;\n-extern crate rustc_plugin;\n-\n-#[plugin_registrar]\n-#[doc(hidden)]\n-pub fn plugin_registrar(reg: &mut rustc_plugin::Registry) {\n-    serde_codegen::register(reg);\n-}\n", "test_patch": "diff --git a/serde_derive/tests/compile-fail/duplicate-attribute/rename-and-ser.rs b/serde_derive/tests/compile-fail/duplicate-attribute/rename-and-ser.rs\nnew file mode 100644\nindex 000000000..312583af1\n--- /dev/null\n+++ b/serde_derive/tests/compile-fail/duplicate-attribute/rename-and-ser.rs\n@@ -0,0 +1,12 @@\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+struct S {\n+    #[serde(rename=\"x\", serialize=\"y\")] //~^^ HELP: unknown serde field attribute `serialize`\n+    x: (),\n+}\n+\n+fn main() {}\ndiff --git a/serde_derive/tests/compile-fail/duplicate-attribute/rename-rename-de.rs b/serde_derive/tests/compile-fail/duplicate-attribute/rename-rename-de.rs\nnew file mode 100644\nindex 000000000..e6d6876a0\n--- /dev/null\n+++ b/serde_derive/tests/compile-fail/duplicate-attribute/rename-rename-de.rs\n@@ -0,0 +1,13 @@\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+struct S {\n+    #[serde(rename=\"x\")]\n+    #[serde(rename(deserialize=\"y\"))] //~^^^ HELP: duplicate serde attribute `rename`\n+    x: (),\n+}\n+\n+fn main() {}\ndiff --git a/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename-ser.rs b/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename-ser.rs\nnew file mode 100644\nindex 000000000..d6937559a\n--- /dev/null\n+++ b/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename-ser.rs\n@@ -0,0 +1,12 @@\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+struct S {\n+    #[serde(rename(serialize=\"x\"), rename(serialize=\"y\"))] //~^^ HELP: duplicate serde attribute `rename`\n+    x: (),\n+}\n+\n+fn main() {}\ndiff --git a/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename.rs b/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename.rs\nnew file mode 100644\nindex 000000000..dcb0f69e0\n--- /dev/null\n+++ b/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename.rs\n@@ -0,0 +1,13 @@\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+struct S {\n+    #[serde(rename(serialize=\"x\"))]\n+    #[serde(rename=\"y\")] //~^^^ HELP: duplicate serde attribute `rename`\n+    x: (),\n+}\n+\n+fn main() {}\ndiff --git a/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-ser.rs b/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-ser.rs\nnew file mode 100644\nindex 000000000..af9116e53\n--- /dev/null\n+++ b/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-ser.rs\n@@ -0,0 +1,12 @@\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+struct S {\n+    #[serde(rename(serialize=\"x\", serialize=\"y\"))] //~^^ HELP: duplicate serde attribute `rename`\n+    x: (),\n+}\n+\n+fn main() {}\ndiff --git a/serde_derive/tests/compile-fail/duplicate-attribute/two-rename-ser.rs b/serde_derive/tests/compile-fail/duplicate-attribute/two-rename-ser.rs\nnew file mode 100644\nindex 000000000..a518839d4\n--- /dev/null\n+++ b/serde_derive/tests/compile-fail/duplicate-attribute/two-rename-ser.rs\n@@ -0,0 +1,13 @@\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+struct S {\n+    #[serde(rename(serialize=\"x\"))]\n+    #[serde(rename(serialize=\"y\"))] //~^^^ HELP: duplicate serde attribute `rename`\n+    x: (),\n+}\n+\n+fn main() {}\ndiff --git a/serde_derive/tests/compile-fail/str_ref_deser.rs b/serde_derive/tests/compile-fail/str_ref_deser.rs\nnew file mode 100644\nindex 000000000..9a99e72b4\n--- /dev/null\n+++ b/serde_derive/tests/compile-fail/str_ref_deser.rs\n@@ -0,0 +1,11 @@\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize, Deserialize)] //~ ERROR: custom derive attribute panicked\n+struct Test<'a> {\n+    s: &'a str, //~^^ HELP: Serde does not support deserializing fields of type &str\n+}\n+\n+fn main() {}\ndiff --git a/serde_derive/tests/compile-fail/unknown-attribute/container.rs b/serde_derive/tests/compile-fail/unknown-attribute/container.rs\nnew file mode 100644\nindex 000000000..2b0e1cb22\n--- /dev/null\n+++ b/serde_derive/tests/compile-fail/unknown-attribute/container.rs\n@@ -0,0 +1,12 @@\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+#[serde(abc=\"xyz\")] //~^ HELP: unknown serde container attribute `abc`\n+struct A {\n+    x: u32,\n+}\n+\n+fn main() { }\ndiff --git a/serde_derive/tests/compile-fail/unknown-attribute/field.rs b/serde_derive/tests/compile-fail/unknown-attribute/field.rs\nnew file mode 100644\nindex 000000000..1b2d8e6c1\n--- /dev/null\n+++ b/serde_derive/tests/compile-fail/unknown-attribute/field.rs\n@@ -0,0 +1,12 @@\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+struct C {\n+    #[serde(abc=\"xyz\")] //~^^ HELP: unknown serde field attribute `abc`\n+    x: u32,\n+}\n+\n+fn main() { }\ndiff --git a/serde_derive/tests/compile-fail/unknown-attribute/variant.rs b/serde_derive/tests/compile-fail/unknown-attribute/variant.rs\nnew file mode 100644\nindex 000000000..239fcc89d\n--- /dev/null\n+++ b/serde_derive/tests/compile-fail/unknown-attribute/variant.rs\n@@ -0,0 +1,12 @@\n+#![feature(rustc_macro)]\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+enum E {\n+    #[serde(abc=\"xyz\")] //~^^ HELP: unknown serde variant attribute `abc`\n+    V,\n+}\n+\n+fn main() { }\ndiff --git a/serde_macros/tests/compile_tests.rs b/serde_derive/tests/compile_tests.rs\nsimilarity index 100%\nrename from serde_macros/tests/compile_tests.rs\nrename to serde_derive/tests/compile_tests.rs\ndiff --git a/serde_macros/tests/run-pass/identity-op.rs b/serde_derive/tests/run-pass/identity-op.rs\nsimilarity index 80%\nrename from serde_macros/tests/run-pass/identity-op.rs\nrename to serde_derive/tests/run-pass/identity-op.rs\nindex dcf8117a3..47e2c750a 100644\n--- a/serde_macros/tests/run-pass/identity-op.rs\n+++ b/serde_derive/tests/run-pass/identity-op.rs\n@@ -1,8 +1,9 @@\n-#![feature(custom_derive, plugin)]\n-#![plugin(serde_macros, clippy)]\n-\n+#![feature(rustc_macro)]\n #![deny(identity_op)]\n \n+#[macro_use]\n+extern crate serde_derive;\n+\n // The derived implementation uses 0+1 to add up the number of fields\n // serialized, which Clippy warns about. If the expansion info is registered\n // correctly, the Clippy lint is not triggered.\ndiff --git a/serde_derive/tests/test.rs b/serde_derive/tests/test.rs\nindex ff8ac572c..80239edf9 100644\n--- a/serde_derive/tests/test.rs\n+++ b/serde_derive/tests/test.rs\n@@ -6,3 +6,5 @@ extern crate serde_derive;\n extern crate test;\n \n include!(\"../../testing/tests/test.rs.in\");\n+\n+mod compile_tests;\ndiff --git a/serde_macros/tests/compile-fail/duplicate_attributes.rs b/serde_macros/tests/compile-fail/duplicate_attributes.rs\ndeleted file mode 100644\nindex 61c986979..000000000\n--- a/serde_macros/tests/compile-fail/duplicate_attributes.rs\n+++ /dev/null\n@@ -1,32 +0,0 @@\n-#![feature(custom_attribute, custom_derive, plugin)]\n-#![plugin(serde_macros)]\n-\n-#[derive(Serialize)] //~ ERROR: 6 errors:\n-struct S {\n-    #[serde(rename(serialize=\"x\"))]\n-    #[serde(rename(serialize=\"y\"))] // ERROR: duplicate serde attribute `rename`\n-    a: (),\n-\n-    #[serde(rename(serialize=\"x\"))]\n-    #[serde(rename=\"y\")] // ERROR: duplicate serde attribute `rename`\n-    b: (),\n-\n-    #[serde(rename(serialize=\"x\"))]\n-    #[serde(rename(deserialize=\"y\"))] // ok\n-    c: (),\n-\n-    #[serde(rename=\"x\")]\n-    #[serde(rename(deserialize=\"y\"))] // ERROR: duplicate serde attribute `rename`\n-    d: (),\n-\n-    #[serde(rename(serialize=\"x\", serialize=\"y\"))] // ERROR: duplicate serde attribute `rename`\n-    e: (),\n-\n-    #[serde(rename=\"x\", serialize=\"y\")] // ERROR: unknown serde field attribute `serialize`\n-    f: (),\n-\n-    #[serde(rename(serialize=\"x\"), rename(serialize=\"y\"))] // ERROR: duplicate serde attribute `rename`\n-    g: (),\n-}\n-\n-fn main() {}\ndiff --git a/serde_macros/tests/compile-fail/reject-unknown-attributes.rs b/serde_macros/tests/compile-fail/reject-unknown-attributes.rs\ndeleted file mode 100644\nindex 3295b3ad0..000000000\n--- a/serde_macros/tests/compile-fail/reject-unknown-attributes.rs\n+++ /dev/null\n@@ -1,30 +0,0 @@\n-#![feature(custom_attribute, custom_derive, plugin)]\n-#![plugin(serde_macros)]\n-\n-extern crate serde;\n-\n-#[derive(Serialize)] //~ unknown serde container attribute `abc`\n-#[serde(abc=\"xyz\")]\n-struct A {\n-    x: u32,\n-}\n-\n-#[derive(Deserialize)] //~ unknown serde container attribute `abc`\n-#[serde(abc=\"xyz\")]\n-struct B {\n-    x: u32,\n-}\n-\n-#[derive(Serialize)] //~ unknown serde field attribute `abc`\n-struct C {\n-    #[serde(abc=\"xyz\")]\n-    x: u32,\n-}\n-\n-#[derive(Deserialize)] //~ unknown serde field attribute `abc`\n-struct D {\n-    #[serde(abc=\"xyz\")]\n-    x: u32,\n-}\n-\n-fn main() { }\ndiff --git a/serde_macros/tests/compile-fail/str_ref_deser.rs b/serde_macros/tests/compile-fail/str_ref_deser.rs\ndeleted file mode 100644\nindex 610ed680e..000000000\n--- a/serde_macros/tests/compile-fail/str_ref_deser.rs\n+++ /dev/null\n@@ -1,9 +0,0 @@\n-#![feature(custom_attribute, custom_derive, plugin)]\n-#![plugin(serde_macros)]\n-\n-#[derive(Serialize, Deserialize)] //~ ERROR: Serde does not support deserializing fields of type &str\n-struct Test<'a> {\n-    s: &'a str,\n-}\n-\n-fn main() {}\ndiff --git a/serde_macros/tests/test.rs b/serde_macros/tests/test.rs\ndeleted file mode 100644\nindex e04627877..000000000\n--- a/serde_macros/tests/test.rs\n+++ /dev/null\n@@ -1,8 +0,0 @@\n-#![feature(test, custom_attribute, custom_derive, plugin)]\n-#![plugin(serde_macros)]\n-\n-extern crate test;\n-\n-include!(\"../../testing/tests/test.rs.in\");\n-\n-mod compile_tests;\n", "problem_statement": "Delete serde_macros\nThis requires moving the compile-tests over to the serde_derive crate.\n\n", "hints_text": "", "created_at": "2016-09-28T19:00:08Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 558, "instance_id": "serde-rs__serde-558", "issue_numbers": ["557"], "base_commit": "429de89276f056b132cda2115e5f122c035e0a88", "patch": "diff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex d4883e8ec..7023c9b65 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -230,9 +230,9 @@ fn serialize_tuple_struct(\n     let let_mut = mut_if(cx, len > 0);\n \n     quote_block!(cx, {\n-        let $let_mut state = try!(_serializer.serialize_tuple_struct($type_name, $len));\n+        let $let_mut __serde_state = try!(_serializer.serialize_tuple_struct($type_name, $len));\n         $serialize_stmts\n-        _serializer.serialize_tuple_struct_end(state)\n+        _serializer.serialize_tuple_struct_end(__serde_state)\n     }).unwrap()\n }\n \n@@ -275,9 +275,9 @@ fn serialize_struct(\n         .fold(quote_expr!(cx, 0), |sum, expr| quote_expr!(cx, $sum + $expr));\n \n     quote_block!(cx, {\n-        let $let_mut state = try!(_serializer.serialize_struct($type_name, $len));\n+        let $let_mut __serde_state = try!(_serializer.serialize_struct($type_name, $len));\n         $serialize_fields\n-        _serializer.serialize_struct_end(state)\n+        _serializer.serialize_struct_end(__serde_state)\n     }).unwrap()\n }\n \n@@ -469,9 +469,13 @@ fn serialize_tuple_variant(\n     let let_mut = mut_if(cx, len > 0);\n \n     quote_block!(cx, {\n-        let $let_mut state = try!(_serializer.serialize_tuple_variant($type_name, $variant_index, $variant_name, $len));\n+        let $let_mut __serde_state = try!(_serializer.serialize_tuple_variant(\n+            $type_name,\n+            $variant_index,\n+            $variant_name,\n+            $len));\n         $serialize_stmts\n-        _serializer.serialize_tuple_variant_end(state)\n+        _serializer.serialize_tuple_variant_end(__serde_state)\n     }).unwrap()\n }\n \n@@ -517,14 +521,14 @@ fn serialize_struct_variant(\n         .fold(quote_expr!(cx, 0), |sum, expr| quote_expr!(cx, $sum + $expr));\n \n     quote_block!(cx, {\n-        let $let_mut state = try!(_serializer.serialize_struct_variant(\n+        let $let_mut __serde_state = try!(_serializer.serialize_struct_variant(\n             $item_name,\n             $variant_index,\n             $variant_name,\n             $len,\n         ));\n         $serialize_fields\n-        _serializer.serialize_struct_variant_end(state)\n+        _serializer.serialize_struct_variant_end(__serde_state)\n     }).unwrap()\n }\n \n@@ -555,7 +559,7 @@ fn serialize_tuple_struct_visitor(\n             }\n \n             let ser = quote_expr!(cx,\n-                try!(_serializer.$func(&mut state, $field_expr));\n+                try!(_serializer.$func(&mut __serde_state, $field_expr));\n             );\n \n             match skip {\n@@ -596,7 +600,7 @@ fn serialize_struct_visitor(\n             }\n \n             let ser = quote_expr!(cx,\n-                try!(_serializer.$func(&mut state, $key_expr, $field_expr));\n+                try!(_serializer.$func(&mut __serde_state, $key_expr, $field_expr));\n             );\n \n             match skip {\n@@ -659,8 +663,8 @@ fn name_expr(\n \n // Serialization of an empty struct results in code like:\n //\n-//     let mut state = try!(serializer.serialize_struct(\"S\", 0));\n-//     serializer.serialize_struct_end(state)\n+//     let mut __serde_state = try!(serializer.serialize_struct(\"S\", 0));\n+//     serializer.serialize_struct_end(__serde_state)\n //\n // where we want to omit the `mut` to avoid a warning.\n fn mut_if(cx: &ExtCtxt, is_mut: bool) -> Vec<TokenTree> {\n", "test_patch": "diff --git a/testing/tests/test_macros.rs b/testing/tests/test_macros.rs\nindex a6b1d167c..6e5e1d823 100644\n--- a/testing/tests/test_macros.rs\n+++ b/testing/tests/test_macros.rs\n@@ -600,3 +600,28 @@ fn test_default_ty_param() {\n         ]\n     );\n }\n+\n+#[test]\n+fn test_enum_state_field() {\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    enum SomeEnum {\n+        Key { key: char, state: bool },\n+    }\n+\n+    assert_tokens(\n+        &SomeEnum::Key { key: 'a', state: true },\n+        &[\n+            Token::EnumMapStart(\"SomeEnum\", \"Key\", 2),\n+\n+            Token::EnumMapSep,\n+            Token::Str(\"key\"),\n+            Token::Char('a'),\n+\n+            Token::EnumMapSep,\n+            Token::Str(\"state\"),\n+            Token::Bool(true),\n+\n+            Token::EnumMapEnd,\n+        ]\n+    );\n+}\n", "problem_statement": "Using the word \"state\" breaks Serde.\nThis breaks serde:\n\n```\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum SomeEnum {\n    Key { key: char, state: bool },\n}\n```\n\nI get this error:\n\n```\nerror[E0277]: the trait bound `<__S as message::_IMPL_SERIALIZE_FOR_SurfaceId::_serde::Serializer>::StructVariantState: message::_IMPL_SERIALIZE_FOR_SurfaceId::_serde::Serialize` is not satisfied\n --> src/message.rs:36:19\n  |\n36| #[derive(Serialize, Deserialize, Debug, Clone)]\n  |                   ^ trait `<__S as message::_IMPL_SERIALIZE_FOR_SurfaceId::_serde::Serializer>::StructVariantState: message::_IMPL_SERIALIZE_FOR_SurfaceId::_serde::Serialize` not satisfied\n  |\n  = help: consider adding a `where <__S as message::_IMPL_SERIALIZE_FOR_SurfaceId::_serde::Serializer>::StructVariantState: message::_IMPL_SERIALIZE_FOR_SurfaceId::_serde::Serialize` bound\n```\n\nIt works fine without the Serialize derive (no errors or warnings):\n\n```\n#[derive(Deserialize, Debug, Clone)]\npub enum SomeEnum {\n    Key { key: char, state: bool },\n}\n```\n\nAnother way to fix it is by changing one letter to make `state` into `stata`:\n\n```\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum SomeEnum {\n    Key { key: char, stata: bool },\n}\n```\n\nThe presence of the member `state` breaks #[derive(Serialize)].\n\nAccording to aatch on the Rust IRC, it was likely due to [this](https://github.com/serde-rs/serde/blob/master/serde_codegen/src/ser.rs#L520).\n\nI don't know how to fix this myself, but this should point somebody in the right direction.\n\n", "hints_text": "Workin on it.\n", "created_at": "2016-09-27T04:12:00Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 536, "instance_id": "serde-rs__serde-536", "issue_numbers": ["534"], "base_commit": "248d937f9a969a5dec5ffef7ae0e100e3c3fec5f", "patch": "diff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex 266dc4826..1639d067a 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -4,6 +4,7 @@ use syntax::ast::{self, Ident, MetaItem};\n use syntax::codemap::Span;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ptr::P;\n+use syntax::tokenstream::TokenTree;\n \n use bound;\n use span;\n@@ -226,9 +227,10 @@ fn serialize_tuple_struct(\n \n     let type_name = name_expr(builder, item_attrs.name());\n     let len = serialize_stmts.len();\n+    let let_mut = mut_if(cx, len > 0);\n \n     quote_block!(cx, {\n-        let mut state = try!(_serializer.serialize_tuple_struct($type_name, $len));\n+        let $let_mut state = try!(_serializer.serialize_tuple_struct($type_name, $len));\n         $serialize_stmts\n         _serializer.serialize_tuple_struct_end(state)\n     }).unwrap()\n@@ -253,8 +255,14 @@ fn serialize_struct(\n     );\n \n     let type_name = name_expr(builder, item_attrs.name());\n-    let len = fields.iter()\n+\n+    let mut serialized_fields = fields.iter()\n         .filter(|&field| !field.attrs.skip_serializing())\n+        .peekable();\n+\n+    let let_mut = mut_if(cx, serialized_fields.peek().is_some());\n+\n+    let len = serialized_fields\n         .map(|field| {\n             let ident = field.ident.expect(\"struct has unnamed fields\");\n             let field_expr = quote_expr!(cx, &self.$ident);\n@@ -267,7 +275,7 @@ fn serialize_struct(\n         .fold(quote_expr!(cx, 0), |sum, expr| quote_expr!(cx, $sum + $expr));\n \n     quote_block!(cx, {\n-        let mut state = try!(_serializer.serialize_struct($type_name, $len));\n+        let $let_mut state = try!(_serializer.serialize_struct($type_name, $len));\n         $serialize_fields\n         _serializer.serialize_struct_end(state)\n     }).unwrap()\n@@ -458,9 +466,10 @@ fn serialize_tuple_variant(\n     );\n \n     let len = serialize_stmts.len();\n+    let let_mut = mut_if(cx, len > 0);\n \n     quote_block!(cx, {\n-        let mut state = try!(_serializer.serialize_tuple_variant($type_name, $variant_index, $variant_name, $len));\n+        let $let_mut state = try!(_serializer.serialize_tuple_variant($type_name, $variant_index, $variant_name, $len));\n         $serialize_stmts\n         _serializer.serialize_tuple_variant_end(state)\n     }).unwrap()\n@@ -488,8 +497,14 @@ fn serialize_struct_variant(\n     );\n \n     let item_name = name_expr(builder, item_attrs.name());\n-    let len = fields.iter()\n+\n+    let mut serialized_fields = fields.iter()\n         .filter(|&field| !field.attrs.skip_serializing())\n+        .peekable();\n+\n+    let let_mut = mut_if(cx, serialized_fields.peek().is_some());\n+\n+    let len = serialized_fields\n         .map(|field| {\n             let ident = field.ident.expect(\"struct has unnamed fields\");\n             let field_expr = quote_expr!(cx, $ident);\n@@ -502,7 +517,7 @@ fn serialize_struct_variant(\n         .fold(quote_expr!(cx, 0), |sum, expr| quote_expr!(cx, $sum + $expr));\n \n     quote_block!(cx, {\n-        let mut state = try!(_serializer.serialize_struct_variant(\n+        let $let_mut state = try!(_serializer.serialize_struct_variant(\n             $item_name,\n             $variant_index,\n             $variant_name,\n@@ -637,3 +652,17 @@ fn name_expr(\n ) -> P<ast::Expr> {\n     builder.expr().str(name.serialize_name())\n }\n+\n+// Serialization of an empty struct results in code like:\n+//\n+//     let mut state = try!(serializer.serialize_struct(\"S\", 0));\n+//     serializer.serialize_struct_end(state)\n+//\n+// where we want to omit the `mut` to avoid a warning.\n+fn mut_if(cx: &ExtCtxt, is_mut: bool) -> Vec<TokenTree> {\n+    if is_mut {\n+        quote_tokens!(cx, mut)\n+    } else {\n+        Vec::new()\n+    }\n+}\n", "test_patch": "diff --git a/testing/tests/test_gen.rs b/testing/tests/test_gen.rs\nindex 7d648f57d..3e2fe3823 100644\n--- a/testing/tests/test_gen.rs\n+++ b/testing/tests/test_gen.rs\n@@ -187,6 +187,16 @@ fn test_gen() {\n     #[serde(bound(deserialize = \"T::Owned: Deserialize\"))]\n     struct CowT<'a, T: ?Sized + 'a + ToOwned>(Cow<'a, T>);\n     assert::<CowT<str>>();\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct EmptyStruct {}\n+    assert::<EmptyStruct>();\n+\n+    #[derive(Serialize, Deserialize)]\n+    enum EmptyEnumVariant {\n+        EmptyStruct {},\n+    }\n+    assert::<EmptyEnumVariant>();\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "`struct S {}`: variable does not need to be mutable\n``` rust\n#![feature(plugin, custom_derive)]\n#![plugin(serde_macros)]\n\n#[derive(Serialize)]\nstruct S {}\n\nfn main() {\n    let _ = S {};\n}\n```\n\n```\nwarning: variable does not need to be mutable, #[warn(unused_mut)] on by default\n --> src/main.rs:4:10\n  |\n4 | #[derive(Serialize)]\n  |          ^^^^^^^^^^\n```\n\n", "hints_text": "The generated code looks like:\n\n``` rust\nimpl Serialize for S {\n    fn serialize<__S>(&self, serializer: &mut __S) -> Result<(), __S::Error>\n        where __S: Serializer\n    {\n        let mut state = try!(serializer.serialize_struct(\"S\", 0));\n        serializer.serialize_struct_end(state)\n    }\n}\n```\n", "created_at": "2016-09-02T18:43:30Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 523, "instance_id": "serde-rs__serde-523", "issue_numbers": ["521"], "base_commit": "ad34c14c8c62e0a0c1aa7ed94751934adeed229a", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 8cad930a3..b6c67451a 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -65,7 +65,6 @@ use core::num::Zero;\n use de::{\n     Deserialize,\n     Deserializer,\n-    EnumVisitor,\n     Error,\n     MapVisitor,\n     SeqVisitor,\n@@ -1122,7 +1121,7 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n             {\n                 struct FieldVisitor;\n \n-                impl ::de::Visitor for FieldVisitor {\n+                impl Visitor for FieldVisitor {\n                     type Value = Field;\n \n                     #[cfg(any(feature = \"std\", feature = \"collections\"))]\n@@ -1171,15 +1170,15 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n             }\n         }\n \n-        struct Visitor<T, E>(PhantomData<Result<T, E>>);\n+        struct ResultVisitor<T, E>(PhantomData<Result<T, E>>);\n \n-        impl<T, E> EnumVisitor for Visitor<T, E>\n+        impl<T, E> Visitor for ResultVisitor<T, E>\n             where T: Deserialize,\n                   E: Deserialize\n         {\n             type Value = Result<T, E>;\n \n-            fn visit<V>(&mut self, mut visitor: V) -> Result<Result<T, E>, V::Error>\n+            fn visit_enum<V>(&mut self, mut visitor: V) -> Result<Result<T, E>, V::Error>\n                 where V: VariantVisitor\n             {\n                 match try!(visitor.visit_variant()) {\n@@ -1197,7 +1196,7 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n \n         const VARIANTS: &'static [&'static str] = &[\"Ok\", \"Err\"];\n \n-        deserializer.deserialize_enum(\"Result\", VARIANTS, Visitor(PhantomData))\n+        deserializer.deserialize_enum(\"Result\", VARIANTS, ResultVisitor(PhantomData))\n     }\n }\n \ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 210b36b03..e356bc94d 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -169,6 +169,9 @@ pub enum Type {\n     /// Represents a unit variant.\n     UnitVariant,\n \n+    /// Represents a newtype variant.\n+    NewtypeVariant,\n+\n     /// Represents a `&[u8]` type.\n     Bytes,\n }\n@@ -176,38 +179,39 @@ pub enum Type {\n impl fmt::Display for Type {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         let display = match *self {\n-            Type::Bool          => \"bool\",\n-            Type::Usize         => \"usize\",\n-            Type::U8            => \"u8\",\n-            Type::U16           => \"u16\",\n-            Type::U32           => \"u32\",\n-            Type::U64           => \"u64\",\n-            Type::Isize         => \"isize\",\n-            Type::I8            => \"i8\",\n-            Type::I16           => \"i16\",\n-            Type::I32           => \"i32\",\n-            Type::I64           => \"i64\",\n-            Type::F32           => \"f32\",\n-            Type::F64           => \"f64\",\n-            Type::Char          => \"char\",\n-            Type::Str           => \"str\",\n-            Type::String        => \"string\",\n-            Type::Unit          => \"unit\",\n-            Type::Option        => \"option\",\n-            Type::Seq           => \"seq\",\n-            Type::Map           => \"map\",\n-            Type::UnitStruct    => \"unit struct\",\n-            Type::NewtypeStruct => \"newtype struct\",\n-            Type::TupleStruct   => \"tuple struct\",\n-            Type::Struct        => \"struct\",\n-            Type::FieldName     => \"field name\",\n-            Type::Tuple         => \"tuple\",\n-            Type::Enum          => \"enum\",\n-            Type::VariantName   => \"variant name\",\n-            Type::StructVariant => \"struct variant\",\n-            Type::TupleVariant  => \"tuple variant\",\n-            Type::UnitVariant   => \"unit variant\",\n-            Type::Bytes         => \"bytes\",\n+            Type::Bool           => \"bool\",\n+            Type::Usize          => \"usize\",\n+            Type::U8             => \"u8\",\n+            Type::U16            => \"u16\",\n+            Type::U32            => \"u32\",\n+            Type::U64            => \"u64\",\n+            Type::Isize          => \"isize\",\n+            Type::I8             => \"i8\",\n+            Type::I16            => \"i16\",\n+            Type::I32            => \"i32\",\n+            Type::I64            => \"i64\",\n+            Type::F32            => \"f32\",\n+            Type::F64            => \"f64\",\n+            Type::Char           => \"char\",\n+            Type::Str            => \"str\",\n+            Type::String         => \"string\",\n+            Type::Unit           => \"unit\",\n+            Type::Option         => \"option\",\n+            Type::Seq            => \"seq\",\n+            Type::Map            => \"map\",\n+            Type::UnitStruct     => \"unit struct\",\n+            Type::NewtypeStruct  => \"newtype struct\",\n+            Type::TupleStruct    => \"tuple struct\",\n+            Type::Struct         => \"struct\",\n+            Type::FieldName      => \"field name\",\n+            Type::Tuple          => \"tuple\",\n+            Type::Enum           => \"enum\",\n+            Type::VariantName    => \"variant name\",\n+            Type::StructVariant  => \"struct variant\",\n+            Type::TupleVariant   => \"tuple variant\",\n+            Type::UnitVariant    => \"unit variant\",\n+            Type::NewtypeVariant => \"newtype variant\",\n+            Type::Bytes          => \"bytes\",\n         };\n         display.fmt(formatter)\n     }\n@@ -399,7 +403,7 @@ pub trait Deserializer {\n                            name: &'static str,\n                            variants: &'static [&'static str],\n                            visitor: V) -> Result<V::Value, Self::Error>\n-        where V: EnumVisitor;\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type needs to deserialize a value whose type\n     /// doesn't matter because it is ignored.\n@@ -591,6 +595,14 @@ pub trait Visitor {\n         Err(Error::invalid_type(Type::Map))\n     }\n \n+    /// `visit_enum` deserializes a `VariantVisitor` into a `Value`.\n+    fn visit_enum<V>(&mut self, visitor: V) -> Result<Self::Value, V::Error>\n+        where V: VariantVisitor,\n+    {\n+        let _ = visitor;\n+        Err(Error::invalid_type(Type::Enum))\n+    }\n+\n     /// `visit_bytes` deserializes a `&[u8]` into a `Value`.\n     fn visit_bytes<E>(&mut self, v: &[u8]) -> Result<Self::Value, E>\n         where E: Error,\n@@ -743,19 +755,6 @@ impl<'a, V_> MapVisitor for &'a mut V_ where V_: MapVisitor {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-/// `EnumVisitor` is a visitor that is created by the `Deserialize` and passed to the\n-/// `Deserializer` in order to deserialize enums.\n-pub trait EnumVisitor {\n-    /// The value produced by this visitor.\n-    type Value;\n-\n-    /// Visit the specific variant with the `VariantVisitor`.\n-    fn visit<V>(&mut self, visitor: V) -> Result<Self::Value, V::Error>\n-        where V: VariantVisitor;\n-}\n-\n-///////////////////////////////////////////////////////////////////////////////\n-\n /// `VariantVisitor` is a visitor that is created by the `Deserializer` and passed to the\n /// `Deserialize` in order to deserialize a specific enum variant.\n pub trait VariantVisitor {\n@@ -767,9 +766,7 @@ pub trait VariantVisitor {\n         where V: Deserialize;\n \n     /// `visit_unit` is called when deserializing a variant with no values.\n-    fn visit_unit(&mut self) -> Result<(), Self::Error> {\n-        Err(Error::invalid_type(Type::UnitVariant))\n-    }\n+    fn visit_unit(&mut self) -> Result<(), Self::Error>;\n \n     /// `visit_newtype` is called when deserializing a variant with a single value.\n     /// A good default is often to use the `visit_tuple` method to deserialize a `(value,)`.\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 00b07107e..def6814e5 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -286,9 +286,9 @@ impl<'a, E> de::Deserializer for StrDeserializer<'a, E>\n                      _name: &str,\n                      _variants: &'static [&'static str],\n                      mut visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::EnumVisitor,\n+        where V: de::Visitor,\n     {\n-        visitor.visit(self)\n+        visitor.visit_enum(self)\n     }\n \n     forward_to_deserialize! {\n@@ -316,8 +316,7 @@ impl<'a, E> de::VariantVisitor for StrDeserializer<'a, E>\n     fn visit_newtype<T>(&mut self) -> Result<T, Self::Error>\n         where T: super::Deserialize,\n     {\n-        let (value,) = try!(self.visit_tuple(1, super::impls::TupleVisitor1::new()));\n-        Ok(value)\n+        Err(super::Error::invalid_type(super::Type::NewtypeVariant))\n     }\n \n     fn visit_tuple<V>(&mut self,\n@@ -373,9 +372,9 @@ impl<E> de::Deserializer for StringDeserializer<E>\n                      _name: &str,\n                      _variants: &'static [&'static str],\n                      mut visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::EnumVisitor,\n+        where V: de::Visitor,\n     {\n-        visitor.visit(self)\n+        visitor.visit_enum(self)\n     }\n \n     forward_to_deserialize! {\n@@ -404,8 +403,7 @@ impl<'a, E> de::VariantVisitor for StringDeserializer<E>\n     fn visit_newtype<T>(&mut self) -> Result<T, Self::Error>\n         where T: super::Deserialize,\n     {\n-        let (value,) = try!(self.visit_tuple(1, super::impls::TupleVisitor1::new()));\n-        Ok(value)\n+        Err(super::Error::invalid_type(super::Type::NewtypeVariant))\n     }\n \n     fn visit_tuple<V>(&mut self,\n@@ -462,9 +460,9 @@ impl<'a, E> de::Deserializer for CowStrDeserializer<'a, E>\n                      _name: &str,\n                      _variants: &'static [&'static str],\n                      mut visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::EnumVisitor,\n+        where V: de::Visitor,\n     {\n-        visitor.visit(self)\n+        visitor.visit_enum(self)\n     }\n \n     forward_to_deserialize! {\n@@ -493,8 +491,7 @@ impl<'a, E> de::VariantVisitor for CowStrDeserializer<'a, E>\n     fn visit_newtype<T>(&mut self) -> Result<T, Self::Error>\n         where T: super::Deserialize,\n     {\n-        let (value,) = try!(self.visit_tuple(1, super::impls::TupleVisitor1::new()));\n-        Ok(value)\n+        Err(super::Error::invalid_type(super::Type::NewtypeVariant))\n     }\n \n     fn visit_tuple<V>(&mut self,\ndiff --git a/serde/src/macros.rs b/serde/src/macros.rs\nindex 6064c87ee..d8673ca4d 100644\n--- a/serde/src/macros.rs\n+++ b/serde/src/macros.rs\n@@ -26,34 +26,6 @@ macro_rules! forward_to_deserialize_method {\n     };\n }\n \n-#[cfg(feature = \"std\")]\n-#[doc(hidden)]\n-#[macro_export]\n-macro_rules! forward_to_deserialize_enum {\n-    () => {\n-        #[inline]\n-        fn deserialize_enum<__V>(&mut self, _: &str, _: &[&str], _: __V) -> ::std::result::Result<__V::Value, Self::Error>\n-            where __V: $crate::de::EnumVisitor\n-        {\n-            Err($crate::de::Error::invalid_type($crate::de::Type::Enum))\n-        }\n-    };\n-}\n-\n-#[cfg(not(feature = \"std\"))]\n-#[doc(hidden)]\n-#[macro_export]\n-macro_rules! forward_to_deserialize_enum {\n-    () => {\n-        #[inline]\n-        fn deserialize_enum<__V>(&mut self, _: &str, _: &[&str], _: __V) -> ::core::result::Result<__V::Value, Self::Error>\n-            where __V: $crate::de::EnumVisitor\n-        {\n-            Err($crate::de::Error::invalid_type($crate::de::Type::Enum))\n-        }\n-    };\n-}\n-\n #[doc(hidden)]\n #[macro_export]\n macro_rules! forward_to_deserialize_helper {\n@@ -141,12 +113,12 @@ macro_rules! forward_to_deserialize_helper {\n     (tuple) => {\n         forward_to_deserialize_method!{deserialize_tuple(usize)}\n     };\n+    (enum) => {\n+        forward_to_deserialize_method!{deserialize_enum(&'static str, &'static [&'static str])}\n+    };\n     (ignored_any) => {\n         forward_to_deserialize_method!{deserialize_ignored_any()}\n     };\n-    (enum) => {\n-        forward_to_deserialize_enum!();\n-    };\n }\n \n /// Helper to forward `Deserializer` methods to `Deserializer::deserialize`.\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex 877b6a052..6088aa0d4 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -545,10 +545,10 @@ fn deserialize_item_enum(\n \n         #visitor_item\n \n-        impl #impl_generics _serde::de::EnumVisitor for #visitor_ty #where_clause {\n+        impl #impl_generics _serde::de::Visitor for #visitor_ty #where_clause {\n             type Value = #ty;\n \n-            fn visit<__V>(&mut self, mut visitor: __V) -> ::std::result::Result<#ty, __V::Error>\n+            fn visit_enum<__V>(&mut self, mut visitor: __V) -> ::std::result::Result<#ty, __V::Error>\n                 where __V: _serde::de::VariantVisitor,\n             {\n                 match try!(visitor.visit_variant()) {\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 121dcd3db..30180943e 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -3,7 +3,6 @@ use std::iter;\n use serde::de::{\n     self,\n     Deserialize,\n-    EnumVisitor,\n     MapVisitor,\n     SeqVisitor,\n     VariantVisitor,\n@@ -268,13 +267,13 @@ impl<I> de::Deserializer for Deserializer<I>\n                      name: &str,\n                      _variants: &'static [&'static str],\n                      mut visitor: V) -> Result<V::Value, Error>\n-        where V: EnumVisitor,\n+        where V: Visitor,\n     {\n         match self.tokens.peek() {\n             Some(&Token::EnumStart(n)) if name == n => {\n                 self.tokens.next();\n \n-                visitor.visit(DeserializerVariantVisitor {\n+                visitor.visit_enum(DeserializerVariantVisitor {\n                     de: self,\n                 })\n             }\n@@ -282,7 +281,7 @@ impl<I> de::Deserializer for Deserializer<I>\n             | Some(&Token::EnumNewType(n, _))\n             | Some(&Token::EnumSeqStart(n, _, _))\n             | Some(&Token::EnumMapStart(n, _, _)) if name == n => {\n-                visitor.visit(DeserializerVariantVisitor {\n+                visitor.visit_enum(DeserializerVariantVisitor {\n                     de: self,\n                 })\n             }\n", "problem_statement": "Make deserialize_enum less of a special case\n`deserialize_enum` is the only Deserializer method that does not take a Visitor argument. Can we find a way to make this API more consistent?\n\n", "hints_text": "", "created_at": "2016-08-24T01:34:12Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 510, "instance_id": "serde-rs__serde-510", "issue_numbers": ["500", "505"], "base_commit": "7aba920decb5fae1cc30819f50793efd6b49a8a0", "patch": "diff --git a/serde/Cargo.toml b/serde/Cargo.toml\nindex 1e7419365..30b89fbc1 100644\n--- a/serde/Cargo.toml\n+++ b/serde/Cargo.toml\n@@ -18,7 +18,7 @@ std = []\n unstable = []\n alloc = [\"unstable\"]\n collections = [\"alloc\"]\n-unstable-testing = [\"unstable\", \"std\"]\n+unstable-testing = [\"clippy\", \"unstable\", \"std\"]\n \n [dependencies]\n clippy = { version = \"^0.*\", optional = true }\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex f8e98bf8f..9a74f9e0c 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -128,7 +128,7 @@ impl fmt::Display for Error {\n                 write!(formatter, \"Unknown variant: {}\", variant)\n             }\n             Error::UnknownField(ref field) => write!(formatter, \"Unknown field: {}\", field),\n-            Error::MissingField(ref field) => write!(formatter, \"Missing field: {}\", field),\n+            Error::MissingField(field) => write!(formatter, \"Missing field: {}\", field),\n         }\n     }\n }\ndiff --git a/serde_codegen/Cargo.toml b/serde_codegen/Cargo.toml\nindex f5b20603b..1395ca4f9 100644\n--- a/serde_codegen/Cargo.toml\n+++ b/serde_codegen/Cargo.toml\n@@ -14,7 +14,7 @@ include = [\"Cargo.toml\", \"build.rs\", \"src/**/*.rs\", \"src/lib.rs.in\"]\n [features]\n default = [\"with-syntex\"]\n unstable = [\"quasi_macros\"]\n-unstable-testing = []\n+unstable-testing = [\"clippy\"]\n with-syntex = [\n     \"quasi/with-syntex\",\n     \"quasi_codegen\",\ndiff --git a/serde_codegen_internals/Cargo.toml b/serde_codegen_internals/Cargo.toml\nindex 3181eb195..62b24f2e4 100644\n--- a/serde_codegen_internals/Cargo.toml\n+++ b/serde_codegen_internals/Cargo.toml\n@@ -12,7 +12,7 @@ include = [\"Cargo.toml\", \"src/**/*.rs\"]\n \n [features]\n default = [\"with-syntex\"]\n-unstable-testing = []\n+unstable-testing = [\"clippy\"]\n with-syntex = [\"syntex_syntax\", \"syntex_errors\"]\n \n [dependencies]\ndiff --git a/serde_codegen_internals/src/attr.rs b/serde_codegen_internals/src/attr.rs\nindex 0b2ebf727..8d8d595ba 100644\n--- a/serde_codegen_internals/src/attr.rs\n+++ b/serde_codegen_internals/src/attr.rs\n@@ -449,12 +449,14 @@ impl Field {\n     }\n }\n \n+type SerAndDe<T> = (Option<Spanned<T>>, Option<Spanned<T>>);\n+\n fn get_ser_and_de<T, F>(\n     cx: &ExtCtxt,\n     attribute: &'static str,\n     items: &[P<ast::MetaItem>],\n     f: F\n-) -> Result<(Option<Spanned<T>>, Option<Spanned<T>>), ()>\n+) -> Result<SerAndDe<T>, ()>\n     where F: Fn(&ExtCtxt, &str, &ast::Lit) -> Result<T, ()>,\n {\n     let mut ser_item = Attr::none(cx, attribute);\n@@ -492,21 +494,21 @@ fn get_ser_and_de<T, F>(\n fn get_renames(\n     cx: &ExtCtxt,\n     items: &[P<ast::MetaItem>],\n-) -> Result<(Option<Spanned<InternedString>>, Option<Spanned<InternedString>>), ()> {\n+) -> Result<SerAndDe<InternedString>, ()> {\n     get_ser_and_de(cx, \"rename\", items, get_str_from_lit)\n }\n \n fn get_where_predicates(\n     cx: &ExtCtxt,\n     items: &[P<ast::MetaItem>],\n-) -> Result<(Option<Spanned<Vec<ast::WherePredicate>>>, Option<Spanned<Vec<ast::WherePredicate>>>), ()> {\n+) -> Result<SerAndDe<Vec<ast::WherePredicate>>, ()> {\n     get_ser_and_de(cx, \"bound\", items, parse_lit_into_where)\n }\n \n pub fn get_serde_meta_items(attr: &ast::Attribute) -> Option<&[P<ast::MetaItem>]> {\n     match attr.node.value.node {\n         ast::MetaItemKind::List(ref name, ref items) if name == &\"serde\" => {\n-            attr::mark_used(&attr);\n+            attr::mark_used(attr);\n             Some(items)\n         }\n         _ => None\n@@ -570,7 +572,7 @@ fn get_str_from_lit(cx: &ExtCtxt, name: &str, lit: &ast::Lit) -> Result<Interned\n                          name,\n                          lit_to_string(lit)));\n \n-            return Err(());\n+            Err(())\n         }\n     }\n }\ndiff --git a/serde_macros/Cargo.toml b/serde_macros/Cargo.toml\nindex 4f41e676f..07e851104 100644\n--- a/serde_macros/Cargo.toml\n+++ b/serde_macros/Cargo.toml\n@@ -17,6 +17,7 @@ plugin = true\n \n [features]\n unstable-testing = [\n+    \"clippy\",\n     \"skeptic\",\n     \"serde_json\",\n     \"serde/unstable-testing\",\n", "test_patch": "diff --git a/serde_macros/tests/run-pass/identity-op.rs b/serde_macros/tests/run-pass/identity-op.rs\nindex a82f100da..dcf8117a3 100644\n--- a/serde_macros/tests/run-pass/identity-op.rs\n+++ b/serde_macros/tests/run-pass/identity-op.rs\n@@ -1,5 +1,5 @@\n #![feature(custom_derive, plugin)]\n-#![plugin(serde_macros)]\n+#![plugin(serde_macros, clippy)]\n \n #![deny(identity_op)]\n \ndiff --git a/testing/Cargo.toml b/testing/Cargo.toml\nindex 471ac26de..2604154cf 100644\n--- a/testing/Cargo.toml\n+++ b/testing/Cargo.toml\n@@ -12,7 +12,7 @@ keywords = [\"serialization\"]\n build = \"build.rs\"\n \n [features]\n-unstable-testing = [\"serde/unstable-testing\", \"serde_codegen/unstable-testing\"]\n+unstable-testing = [\"clippy\", \"serde/unstable-testing\", \"serde_codegen/unstable-testing\"]\n \n [build-dependencies]\n serde_codegen = { path = \"../serde_codegen\", features = [\"with-syntex\"] }\n", "problem_statement": "Useless attribute: #[allow(unused_imports)]\nI see hundreds of these in the Travis output.\n\n```\nwarning: useless lint attribute, #[warn(useless_attribute)] on by default\n    --> /home/travis/build/serde-rs/serde/testing/target/debug/build/serde_codegen-603f0181a943aed4/out/lib.rs:3456:159\n     |\n3456 |                       #[allow(unused_imports)]\n     |                       ^^^^^^^^^^^^^^^^^^^^^^^^\n/home/travis/build/serde-rs/serde/serde_codegen/src/lib.rs:33:1: 33:47 note: in this expansion of include!\n     |\nhelp: if you just forgot a `!`, use\n     |                       #![allow(unused_imports)]\n     = help: for further information visit https://github.com/Manishearth/rust-clippy/wiki#useless_attribute\n```\n\nRe-enable clippy\n[This commit](https://github.com/serde-rs/serde/pull/498/commits/2bc1d62e50b799e06b51742a8490b546395e04ec) needs to be reverted after https://github.com/Manishearth/rust-clippy/pull/1174 is fixed and Clippy compiles on nightly.\n\n", "hints_text": "why do we have that attribute anyway?\n\nsomething with old rust version support?\n\nso our codebase has the `unused_imports` character sequence exactly once, and that one is not linting. It's all in the generated code. Is aster/syntex generating those?\n\nquasi generates those `unused_imports`: https://github.com/serde-rs/quasi/blob/d554e9eee0f0ef48a07a3825414f28806a77bbb9/quasi_codegen/src/lib.rs#L747\n\nsince that is the only useful lint attribute on a `use` that I can think of, I'll just whitelist it.\n\n", "created_at": "2016-08-19T16:49:23Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 509, "instance_id": "serde-rs__serde-509", "issue_numbers": ["507"], "base_commit": "6723da67b33a6e01bafbf98785e631ee1991b40b", "patch": "diff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex bbcb30e9e..b630ede0c 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -192,7 +192,7 @@ fn deserialize_visitor(\n     builder: &aster::AstBuilder,\n     generics: &ast::Generics,\n ) -> (P<ast::Item>, P<ast::Ty>, P<ast::Expr>) {\n-    if generics.ty_params.is_empty() {\n+    if generics.lifetimes.is_empty() && generics.ty_params.is_empty() {\n         (\n             builder.item().unit_struct(\"__Visitor\"),\n             builder.ty().id(\"__Visitor\"),\n", "test_patch": "diff --git a/testing/tests/test_gen.rs b/testing/tests/test_gen.rs\nindex 0acfdb36c..7d648f57d 100644\n--- a/testing/tests/test_gen.rs\n+++ b/testing/tests/test_gen.rs\n@@ -6,6 +6,7 @@ extern crate serde;\n use self::serde::ser::{Serialize, Serializer};\n use self::serde::de::{Deserialize, Deserializer};\n \n+use std::borrow::Cow;\n use std::marker::PhantomData;\n \n //////////////////////////////////////////////////////////////////////////\n@@ -177,6 +178,15 @@ fn test_gen() {\n         e: E,\n     }\n     assert::<WithTraits2<X, X>>();\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct CowStr<'a>(Cow<'a, str>);\n+    assert::<CowStr>();\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(bound(deserialize = \"T::Owned: Deserialize\"))]\n+    struct CowT<'a, T: ?Sized + 'a + ToOwned>(Cow<'a, T>);\n+    assert::<CowT<str>>();\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Deriving Deserialize for structs with Cow<'a, str> fails\nConsider the following code:\n\n``` rust\n#[derive(Deserialize)]\nstruct S<'a>(Cow<'a, str>);\n```\n\nThis fails with a cryptic error message:\n\n```\nerror[E0207]: the lifetime parameter `'a` is not constrained by the impl trait, self type, or predicates\n --> <quote expansion>:1:2\n  |\n1 | <'a>\n  |  ^^ unconstrained lifetime parameter\n```\n\nI believe `Deserialize` is implemented for `Cow<'a, str>`, so I think this should work.\n\n", "hints_text": "The buggy generated code looks like this:\n\n``` rust\n    struct __Visitor;\n    impl<'a> _serde::de::Visitor for __Visitor {\n//       ^^ unconstrained lifetime parameter\n        type Value = S<'a>;\n```\n\nwe can assume that any lifetimes during deserialization are `'static` and thus simply replace them. They should be coercible to the target lifetime. If/When we get a deserialization strategy that borrows the object that it deserializes from, we can revise this.\n\nInterestingly this works and I can deserialize `S<str>`:\n\n``` rust\n#[derive(Deserialize)]\n#[serde(bound = \"T::Owned: Deserialize\")]\nstruct S<'a, T: ?Sized + 'a + ToOwned>(Cow<'a, T>);\n```\n\nbecause it generates this code:\n\n``` rust\nstruct __Visitor<'a, T: ?Sized + 'a + ToOwned>(::std::marker::PhantomData<&'a ()>,\n                                               ::std::marker::PhantomData<T>)\n    where T::Owned: Deserialize;\nimpl<'a, T: ?Sized + 'a + ToOwned> _serde::de::Visitor for __Visitor<'a, T>\n    where T::Owned: Deserialize\n{\n    type Value = S<'a, T>;\n```\n\n@oli-obk maybe we should stick with this `PhantomData<&'a ()>` approach and just make it work when there are no type parameters.\n\n> Interestingly this works\n\namusing.\n\n> maybe we should stick with this PhantomData<&'a ()> approach and just make it work when there are no type parameters.\n\nYea, we probably just need to take out a few things from the bound-attribute code path\n", "created_at": "2016-08-19T15:13:12Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 476, "instance_id": "serde-rs__serde-476", "issue_numbers": ["339"], "base_commit": "b289edd4a436e1a1a0edb5428929760e2138c865", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex e2319d17d..0c33ec5f1 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -53,6 +53,9 @@ use alloc::arc::Arc;\n #[cfg(all(feature = \"unstable\", feature = \"alloc\", not(feature = \"std\")))]\n use alloc::boxed::Box;\n \n+#[cfg(feature = \"std\")]\n+use std::time::Duration;\n+\n #[cfg(feature = \"unstable\")]\n use core::nonzero::{NonZero, Zeroable};\n \n@@ -982,6 +985,135 @@ impl<'a, T: ?Sized> Deserialize for Cow<'a, T> where T: ToOwned, T::Owned: Deser\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+// This is a cleaned-up version of the impl generated by:\n+//\n+//     #[derive(Deserialize)]\n+//     #[serde(deny_unknown_fields)]\n+//     struct Duration {\n+//         secs: u64,\n+//         nanos: u32,\n+//     }\n+#[cfg(feature = \"std\")]\n+impl Deserialize for Duration {\n+    fn deserialize<D>(deserializer: &mut D) -> Result<Self, D::Error>\n+        where D: Deserializer,\n+    {\n+        enum Field { Secs, Nanos };\n+\n+        impl Deserialize for Field {\n+            fn deserialize<D>(deserializer: &mut D) -> Result<Field, D::Error>\n+                where D: Deserializer,\n+            {\n+                struct FieldVisitor;\n+\n+                impl Visitor for FieldVisitor {\n+                    type Value = Field;\n+\n+                    fn visit_usize<E>(&mut self, value: usize) -> Result<Field, E>\n+                        where E: Error,\n+                    {\n+                        match value {\n+                            0usize => Ok(Field::Secs),\n+                            1usize => Ok(Field::Nanos),\n+                            _ => Err(Error::invalid_value(\"expected a field\")),\n+                        }\n+                    }\n+\n+                    fn visit_str<E>(&mut self, value: &str) -> Result<Field, E>\n+                        where E: Error,\n+                    {\n+                        match value {\n+                            \"secs\" => Ok(Field::Secs),\n+                            \"nanos\" => Ok(Field::Nanos),\n+                            _ => Err(Error::unknown_field(value)),\n+                        }\n+                    }\n+\n+                    fn visit_bytes<E>(&mut self, value: &[u8]) -> Result<Field, E>\n+                        where E: Error,\n+                    {\n+                        match value {\n+                            b\"secs\" => Ok(Field::Secs),\n+                            b\"nanos\" => Ok(Field::Nanos),\n+                            _ => {\n+                                let value = String::from_utf8_lossy(value);\n+                                Err(Error::unknown_field(&value))\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                deserializer.deserialize_struct_field(FieldVisitor)\n+            }\n+        }\n+\n+        struct DurationVisitor;\n+\n+        impl Visitor for DurationVisitor {\n+            type Value = Duration;\n+\n+            fn visit_seq<V>(&mut self, mut visitor: V) -> Result<Duration, V::Error>\n+                where V: SeqVisitor,\n+            {\n+                let secs: u64 = match try!(visitor.visit()) {\n+                    Some(value) => value,\n+                    None => {\n+                        try!(visitor.end());\n+                        return Err(Error::invalid_length(0));\n+                    }\n+                };\n+                let nanos: u32 = match try!(visitor.visit()) {\n+                    Some(value) => value,\n+                    None => {\n+                        try!(visitor.end());\n+                        return Err(Error::invalid_length(1));\n+                    }\n+                };\n+                try!(visitor.end());\n+                Ok(Duration::new(secs, nanos))\n+            }\n+\n+            fn visit_map<V>(&mut self, mut visitor: V) -> Result<Duration, V::Error>\n+                where V: MapVisitor,\n+            {\n+                let mut secs: Option<u64> = None;\n+                let mut nanos: Option<u32> = None;\n+                while let Some(key) = try!(visitor.visit_key::<Field>()) {\n+                    match key {\n+                        Field::Secs => {\n+                            if secs.is_some() {\n+                                return Err(<V::Error as Error>::duplicate_field(\"secs\"));\n+                            }\n+                            secs = Some(try!(visitor.visit_value()));\n+                        }\n+                        Field::Nanos => {\n+                            if nanos.is_some() {\n+                                return Err(<V::Error as Error>::duplicate_field(\"nanos\"));\n+                            }\n+                            nanos = Some(try!(visitor.visit_value()));\n+                        }\n+                    }\n+                }\n+                try!(visitor.end());\n+                let secs = match secs {\n+                    Some(secs) => secs,\n+                    None => try!(visitor.missing_field(\"secs\")),\n+                };\n+                let nanos = match nanos {\n+                    Some(nanos) => nanos,\n+                    None => try!(visitor.missing_field(\"nanos\")),\n+                };\n+                Ok(Duration::new(secs, nanos))\n+            }\n+        }\n+\n+        const FIELDS: &'static [&'static str] = &[\"secs\", \"nanos\"];\n+        deserializer.deserialize_struct(\"Duration\", FIELDS, DurationVisitor)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n #[cfg(feature = \"unstable\")]\n impl<T> Deserialize for NonZero<T> where T: Deserialize + PartialEq + Zeroable + Zero {\n     fn deserialize<D>(deserializer: &mut D) -> Result<NonZero<T>, D::Error> where D: Deserializer {\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex 374ea6276..6679d2f34 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -50,6 +50,8 @@ use std::path;\n use std::rc::Rc;\n #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n use alloc::rc::Rc;\n+#[cfg(feature = \"std\")]\n+use std::time::Duration;\n \n #[cfg(feature = \"std\")]\n use std::sync::Arc;\n@@ -624,6 +626,20 @@ impl<T, E> Serialize for Result<T, E> where T: Serialize, E: Serialize {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+#[cfg(feature = \"std\")]\n+impl Serialize for Duration {\n+    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+        where S: Serializer,\n+    {\n+        let mut state = try!(serializer.serialize_struct(\"Duration\", 2));\n+        try!(serializer.serialize_struct_elt(&mut state, \"secs\", self.as_secs()));\n+        try!(serializer.serialize_struct_elt(&mut state, \"nanos\", self.subsec_nanos()));\n+        serializer.serialize_struct_end(state)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n #[cfg(all(feature = \"std\", feature = \"unstable\"))]\n impl Serialize for net::IpAddr {\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n", "test_patch": "diff --git a/testing/tests/test_de.rs b/testing/tests/test_de.rs\nindex 63b6b6f7d..162bf0166 100644\n--- a/testing/tests/test_de.rs\n+++ b/testing/tests/test_de.rs\n@@ -1,6 +1,7 @@\n use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n use std::net;\n use std::path::PathBuf;\n+use std::time::Duration;\n \n use serde::Deserialize;\n \n@@ -745,6 +746,28 @@ declare_tests! {\n             Token::SeqEnd,\n         ],\n     }\n+    test_duration {\n+        Duration::new(1, 2) => &[\n+            Token::StructStart(\"Duration\", 2),\n+                Token::StructSep,\n+                Token::Str(\"secs\"),\n+                Token::U64(1),\n+\n+                Token::StructSep,\n+                Token::Str(\"nanos\"),\n+                Token::U32(2),\n+            Token::StructEnd,\n+        ],\n+        Duration::new(1, 2) => &[\n+            Token::SeqStart(Some(2)),\n+                Token::SeqSep,\n+                Token::I64(1),\n+\n+                Token::SeqSep,\n+                Token::I64(2),\n+            Token::SeqEnd,\n+        ],\n+    }\n     test_net_ipv4addr {\n         \"1.2.3.4\".parse::<net::Ipv4Addr>().unwrap() => &[Token::Str(\"1.2.3.4\")],\n     }\ndiff --git a/testing/tests/test_ser.rs b/testing/tests/test_ser.rs\nindex 5fc7bf127..525735339 100644\n--- a/testing/tests/test_ser.rs\n+++ b/testing/tests/test_ser.rs\n@@ -2,6 +2,7 @@ use std::collections::{BTreeMap, HashMap, HashSet};\n use std::net;\n use std::path::{Path, PathBuf};\n use std::str;\n+use std::time::Duration;\n \n extern crate serde_test;\n use self::serde_test::{\n@@ -324,6 +325,19 @@ declare_ser_tests! {\n             Token::SeqEnd,\n         ],\n     }\n+    test_duration {\n+        Duration::new(1, 2) => &[\n+            Token::StructStart(\"Duration\", 2),\n+                Token::StructSep,\n+                Token::Str(\"secs\"),\n+                Token::U64(1),\n+\n+                Token::StructSep,\n+                Token::Str(\"nanos\"),\n+                Token::U32(2),\n+            Token::StructEnd,\n+        ],\n+    }\n     test_net_ipv4addr {\n         \"1.2.3.4\".parse::<net::Ipv4Addr>().unwrap() => &[Token::Str(\"1.2.3.4\")],\n     }\n", "problem_statement": "impl Serialize and Deserialize for std::time::Duration\n\n", "hints_text": "Do you have a particular format in mind for this?\n\nI don't, but visiting the fields -- seconds and nanos -- seems like a reasonable option.\n", "created_at": "2016-08-04T00:24:00Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 475, "instance_id": "serde-rs__serde-475", "issue_numbers": ["474"], "base_commit": "84fa3fba58a8f55d15eae7bfbf4ba70d29a6391d", "patch": "diff --git a/README.md b/README.md\nindex 31b97bc11..3c136b84f 100644\n--- a/README.md\n+++ b/README.md\n@@ -356,11 +356,8 @@ impl serde::Serialize for i32 {\n ```\n \n As you can see it's pretty simple. More complex types like `BTreeMap` need to\n-pass a\n-[MapVisitor](http://serde-rs.github.io/serde/serde/serde/ser/trait.MapVisitor.html)\n-to the\n-[Serializer](http://serde-rs.github.io/serde/serde/serde/ser/trait.Serializer.html)\n-in order to walk through the type:\n+use a multi-step process (init, elements, end) in order to walk through the\n+type:\n \n ```rust,ignore\n impl<K, V> Serialize for BTreeMap<K, V>\n@@ -371,55 +368,17 @@ impl<K, V> Serialize for BTreeMap<K, V>\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n         where S: Serializer,\n     {\n-        serializer.serialize_map(MapIteratorVisitor::new(self.iter(), Some(self.len())))\n-    }\n-}\n-\n-pub struct MapIteratorVisitor<Iter> {\n-    iter: Iter,\n-    len: Option<usize>,\n-}\n-\n-impl<K, V, Iter> MapIteratorVisitor<Iter>\n-    where Iter: Iterator<Item=(K, V)>\n-{\n-    #[inline]\n-    pub fn new(iter: Iter, len: Option<usize>) -> MapIteratorVisitor<Iter> {\n-        MapIteratorVisitor {\n-            iter: iter,\n-            len: len,\n-        }\n-    }\n-}\n-\n-impl<K, V, I> MapVisitor for MapIteratorVisitor<I>\n-    where K: Serialize,\n-          V: Serialize,\n-          I: Iterator<Item=(K, V)>,\n-{\n-    #[inline]\n-    fn visit<S>(&mut self, serializer: &mut S) -> Result<Option<()>, S::Error>\n-        where S: Serializer,\n-    {\n-        match self.iter.next() {\n-            Some((key, value)) => {\n-                let value = try!(serializer.serialize_map_elt(key, value));\n-                Ok(Some(value))\n-            }\n-            None => Ok(None)\n+        let mut state = try!(serializer.serialize_map(Some(self.len())));\n+        for (k, v) in self {\n+            try!(serializer.serialize_map_elt(&mut state, k, v));\n         }\n-    }\n-\n-    #[inline]\n-    fn len(&self) -> Option<usize> {\n-        self.len\n+        serializer.serialize_map_end(state)\n     }\n }\n ```\n \n Serializing structs follow this same pattern. In fact, structs are represented\n-as a named map. Its visitor uses a simple state machine to iterate through all\n-the fields:\n+as a named map, with a known length.\n \n ```rust\n extern crate serde;\n@@ -434,35 +393,10 @@ impl serde::Serialize for Point {\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n         where S: serde::Serializer\n     {\n-        serializer.serialize_struct(\"Point\", PointMapVisitor {\n-            value: self,\n-            state: 0,\n-        })\n-    }\n-}\n-\n-struct PointMapVisitor<'a> {\n-    value: &'a Point,\n-    state: u8,\n-}\n-\n-impl<'a> serde::ser::MapVisitor for PointMapVisitor<'a> {\n-    fn visit<S>(&mut self, serializer: &mut S) -> Result<Option<()>, S::Error>\n-        where S: serde::Serializer\n-    {\n-        match self.state {\n-            0 => {\n-                self.state += 1;\n-                Ok(Some(try!(serializer.serialize_struct_elt(\"x\", &self.value.x))))\n-            }\n-            1 => {\n-                self.state += 1;\n-                Ok(Some(try!(serializer.serialize_struct_elt(\"y\", &self.value.y))))\n-            }\n-            _ => {\n-                Ok(None)\n-            }\n-        }\n+        let mut state = try!(serializer.serialize_struct(\"Point\", 2));\n+        try!(serializer.serialize_struct_elt(&mut state, \"x\", &self.x));\n+        try!(serializer.serialize_struct_elt(&mut state, \"y\", &self.y));\n+        serializer.serialize_struct_end(state)\n     }\n }\n \ndiff --git a/serde_macros/Cargo.toml b/serde_macros/Cargo.toml\nindex aafbfe055..4791f416d 100644\n--- a/serde_macros/Cargo.toml\n+++ b/serde_macros/Cargo.toml\n@@ -8,17 +8,29 @@ repository = \"https://github.com/serde-rs/serde\"\n documentation = \"https://github.com/serde-rs/serde\"\n keywords = [\"serde\", \"serialization\"]\n include = [\"Cargo.toml\", \"src/**/*.rs\"]\n+build = \"build.rs\"\n \n [lib]\n name = \"serde_macros\"\n plugin = true\n \n [features]\n-unstable-testing = [\"clippy\", \"serde/unstable-testing\", \"serde_codegen/unstable-testing\"]\n+unstable-testing = [\n+    \"clippy\",\n+    \"skeptic\",\n+    \"serde_json\",\n+    \"serde/unstable-testing\",\n+    \"serde_codegen/unstable-testing\"\n+]\n+\n+[build-dependencies]\n+skeptic = { version = \"^0.6.0\", optional = true }\n \n [dependencies]\n clippy = { version = \"^0.*\", optional = true }\n serde_codegen = { version = \"=0.8.0\", default-features = false, features = [\"unstable\"] }\n+skeptic = { version = \"^0.6.0\", optional = true }\n+serde_json = { version = \"0.8.0\", optional = true }\n \n [dev-dependencies]\n clippy = \"^0.*\"\n@@ -32,6 +44,10 @@ serde_test = \"0.8.0\"\n name = \"test\"\n path = \"tests/test.rs\"\n \n+[[test]]\n+name = \"skeptic\"\n+path = \"tests/skeptic.rs\"\n+\n [[bench]]\n name = \"bench\"\n path = \"benches/bench.rs\"\ndiff --git a/serde_macros/build.rs b/serde_macros/build.rs\nnew file mode 100644\nindex 000000000..0f5455004\n--- /dev/null\n+++ b/serde_macros/build.rs\n@@ -0,0 +1,18 @@\n+#[cfg(feature = \"unstable-testing\")]\n+mod inner {\n+    extern crate skeptic;\n+\n+    pub fn main() {\n+        println!(\"cargo:rerun-if-changed=../README.md\");\n+        skeptic::generate_doc_tests(&[\"../README.md\"]);\n+    }\n+}\n+\n+#[cfg(not(feature = \"unstable-testing\"))]\n+mod inner {\n+    pub fn main() {}\n+}\n+\n+fn main() {\n+    inner::main()\n+}\n", "test_patch": "diff --git a/serde_macros/tests/skeptic.rs b/serde_macros/tests/skeptic.rs\nnew file mode 100644\nindex 000000000..47e632d0f\n--- /dev/null\n+++ b/serde_macros/tests/skeptic.rs\n@@ -0,0 +1,3 @@\n+#![cfg(feature = \"unstable-testing\")]\n+\n+include!(concat!(env!(\"OUT_DIR\"), \"/skeptic-tests.rs\"));\ndiff --git a/serde_macros/tests/test.rs b/serde_macros/tests/test.rs\nindex e04627877..94d8338ba 100644\n--- a/serde_macros/tests/test.rs\n+++ b/serde_macros/tests/test.rs\n@@ -6,3 +6,4 @@ extern crate test;\n include!(\"../../testing/tests/test.rs.in\");\n \n mod compile_tests;\n+mod skeptic;\n", "problem_statement": "Update examples without macros in README for 0.8\nIt seems that the example for https://github.com/serde-rs/serde#serialization-without-macros and possibly deserialization do not work in 0.8.\n\nThere is no `serde::ser::MapVisitor` for example\n\n", "hints_text": "", "created_at": "2016-08-03T14:07:11Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 456, "instance_id": "serde-rs__serde-456", "issue_numbers": ["435", "443"], "base_commit": "49ff56aa15f14c9aa26d5f3b24c917ba4d604241", "patch": "diff --git a/serde_codegen/src/bound.rs b/serde_codegen/src/bound.rs\nindex ea7da8e9b..0f4219592 100644\n--- a/serde_codegen/src/bound.rs\n+++ b/serde_codegen/src/bound.rs\n@@ -1,7 +1,8 @@\n+use std::collections::HashSet;\n+\n use aster::AstBuilder;\n \n use syntax::ast;\n-use syntax::ptr::P;\n use syntax::visit;\n \n use internals::ast::Item;\n@@ -47,6 +48,17 @@ pub fn with_where_predicates_from_fields<F>(\n         .build()\n }\n \n+// Puts the given bound on any generic type parameters that are used in fields\n+// for which filter returns true.\n+//\n+// For example, the following struct needs the bound `A: Serialize, B: Serialize`.\n+//\n+//     struct S<'b, A, B: 'b, C> {\n+//         a: A,\n+//         b: Option<&'b B>\n+//         #[serde(skip_serializing)]\n+//         c: C,\n+//     }\n pub fn with_bound<F>(\n     builder: &AstBuilder,\n     item: &Item,\n@@ -56,95 +68,53 @@ pub fn with_bound<F>(\n ) -> ast::Generics\n     where F: Fn(&attr::Field) -> bool,\n {\n-    builder.from_generics(generics.clone())\n-        .with_predicates(\n-            item.body.all_fields()\n-                .filter(|&field| filter(&field.attrs))\n-                .map(|field| &field.ty)\n-                .filter(|ty| !contains_recursion(ty, item.ident))\n-                .map(|ty| strip_reference(ty))\n-                .map(|ty| builder.where_predicate()\n-                    // the type that is being bounded e.g. T\n-                    .bound().build(ty.clone())\n-                    // the bound e.g. Serialize\n-                    .bound().trait_(bound.clone()).build()\n-                    .build()))\n-        .build()\n-}\n-\n-// We do not attempt to generate any bounds based on field types that are\n-// directly recursive, as in:\n-//\n-//    struct Test<D> {\n-//        next: Box<Test<D>>,\n-//    }\n-//\n-// This does not catch field types that are mutually recursive with some other\n-// type. For those, we require bounds to be specified by a `bound` attribute if\n-// the inferred ones are not correct.\n-//\n-//    struct Test<D> {\n-//        #[serde(bound=\"D: Serialize + Deserialize\")]\n-//        next: Box<Other<D>>,\n-//    }\n-//    struct Other<D> {\n-//        #[serde(bound=\"D: Serialize + Deserialize\")]\n-//        next: Box<Test<D>>,\n-//    }\n-fn contains_recursion(ty: &ast::Ty, ident: ast::Ident) -> bool {\n-    struct FindRecursion {\n-        ident: ast::Ident,\n-        found_recursion: bool,\n+    struct FindTyParams {\n+        // Set of all generic type parameters on the current struct (A, B, C in\n+        // the example). Initialized up front.\n+        all_ty_params: HashSet<ast::Name>,\n+        // Set of generic type parameters used in fields for which filter\n+        // returns true (A and B in the example). Filled in as the visitor sees\n+        // them.\n+        relevant_ty_params: HashSet<ast::Name>,\n     }\n-    impl visit::Visitor for FindRecursion {\n+    impl visit::Visitor for FindTyParams {\n         fn visit_path(&mut self, path: &ast::Path, _id: ast::NodeId) {\n-            if !path.global\n-                    && path.segments.len() == 1\n-                    && path.segments[0].identifier == self.ident {\n-                self.found_recursion = true;\n-            } else {\n-                visit::walk_path(self, path);\n+            if !path.global && path.segments.len() == 1 {\n+                let id = path.segments[0].identifier.name;\n+                if self.all_ty_params.contains(&id) {\n+                    self.relevant_ty_params.insert(id);\n+                }\n             }\n+            visit::walk_path(self, path);\n         }\n     }\n \n-    let mut visitor = FindRecursion {\n-        ident: ident,\n-        found_recursion: false,\n-    };\n-    visit::walk_ty(&mut visitor, ty);\n-    visitor.found_recursion\n-}\n+    let all_ty_params: HashSet<_> = generics.ty_params.iter()\n+        .map(|ty_param| ty_param.ident.name)\n+        .collect();\n \n-// This is required to handle types that use both a reference and a value of\n-// the same type, as in:\n-//\n-//    enum Test<'a, T> where T: 'a {\n-//        Lifetime(&'a T),\n-//        NoLifetime(T),\n-//    }\n-//\n-// Preserving references, we would generate an impl like:\n-//\n-//    impl<'a, T> Serialize for Test<'a, T>\n-//        where &'a T: Serialize,\n-//              T: Serialize { ... }\n-//\n-// And taking a reference to one of the elements would fail with:\n-//\n-//    error: cannot infer an appropriate lifetime for pattern due\n-//    to conflicting requirements [E0495]\n-//        Test::NoLifetime(ref v) => { ... }\n-//                         ^~~~~\n-//\n-// Instead, we strip references before adding `T: Serialize` bounds in order to\n-// generate:\n-//\n-//    impl<'a, T> Serialize for Test<'a, T>\n-//        where T: Serialize { ... }\n-fn strip_reference(mut ty: &P<ast::Ty>) -> &P<ast::Ty> {\n-    while let ast::TyKind::Rptr(_, ref mut_ty) = ty.node {\n-        ty = &mut_ty.ty;\n+    let relevant_tys = item.body.all_fields()\n+        .filter(|&field| filter(&field.attrs))\n+        .map(|field| &field.ty);\n+\n+    let mut visitor = FindTyParams {\n+        all_ty_params: all_ty_params,\n+        relevant_ty_params: HashSet::new(),\n+    };\n+    for ty in relevant_tys {\n+        visit::walk_ty(&mut visitor, ty);\n     }\n-    ty\n+\n+    builder.from_generics(generics.clone())\n+        .with_predicates(\n+            generics.ty_params.iter()\n+                .map(|ty_param| ty_param.ident.name)\n+                .filter(|id| visitor.relevant_ty_params.contains(id))\n+                .map(|id| builder.where_predicate()\n+                    // the type parameter that is being bounded e.g. T\n+                    .bound().build(builder.ty().id(id))\n+                    // the bound e.g. Serialize\n+                    .bound().trait_(bound.clone()).build()\n+                    .build()))\n+        .build()\n }\n", "test_patch": "diff --git a/testing/tests/test_gen.rs b/testing/tests/test_gen.rs\nindex fcc4b7e42..cff40bf8b 100644\n--- a/testing/tests/test_gen.rs\n+++ b/testing/tests/test_gen.rs\n@@ -92,6 +92,35 @@ struct ListNode<D> {\n     next: Box<ListNode<D>>,\n }\n \n+#[derive(Serialize, Deserialize)]\n+struct RecursiveA {\n+    b: Box<RecursiveB>,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+enum RecursiveB {\n+    A(RecursiveA),\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+struct RecursiveGenericA<T> {\n+    t: T,\n+    b: Box<RecursiveGenericB<T>>,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+enum RecursiveGenericB<T> {\n+    T(T),\n+    A(RecursiveGenericA<T>),\n+}\n+\n+#[derive(Serialize)]\n+#[allow(dead_code)]\n+struct OptionStatic<'a> {\n+    a: Option<&'a str>,\n+    b: Option<&'static str>,\n+}\n+\n #[derive(Serialize, Deserialize)]\n #[serde(bound=\"D: SerializeWith + DeserializeWith\")]\n struct WithTraits1<D, E> {\n@@ -132,4 +161,3 @@ trait DeserializeWith: Sized {\n struct X;\n fn ser_x<S: Serializer>(_: &X, _: &mut S) -> Result<(), S::Error> { panic!() }\n fn de_x<D: Deserializer>(_: &mut D) -> Result<X, D::Error> { panic!() }\n-\n", "problem_statement": "Generated code triggers private_in_public future compatibility warnings.\nIf a private field of a public type contains a private type, the generated bounds result in warnings such as (example from Servo):\n\n``` rust\n<quote expansion>:1:12: 1:22 warning: private type in public interface, #[warn(private_in_public)] on by default\n<quote expansion>:1  where Vec<GlyphEntry>: _serde::ser::Serialize,\n                               ^~~~~~~~~~\n<quote expansion>:1:12: 1:22 warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n<quote expansion>:1:12: 1:22 note: for more information, see the explanation for E0446 (`--explain E0446`)\n```\n\nSee https://github.com/rust-lang/rfcs/pull/1671#issuecomment-231555393 for more on the possible future of private types in bounds (i.e. no action may be necessary in the future if that RFC gets through).\n\nderive(Serialize) regression with lifetimes\nThis used to work around version `0.7.10` of serde_codegen...\n\n``` rust\n#[derive(Serialize)]\nstruct S<'a> {\n    a: Option<&'static str>,\n    b: Option<&'a str>,\n}\n```\n\n```\nerror: mismatched types [E0308]\n#[derive(Serialize)]\nhelp: run `rustc --explain E0308` to see a detailed explanation\nnote: expected type `serde::Serialize`\nnote:    found type `serde::Serialize`\nnote: the lifetime 'a as defined on the impl at 31:9...\n#[derive(Serialize)]\nnote: ...does not necessarily outlive the static lifetime\n```\n\n", "hints_text": "\nI started looking into this. We generate code like the following:\n\n``` rust\nimpl<'a> Serialize for S<'a>\n    where Option<&'static str>: Serialize,\n          Option<&'a str>: Serialize,\n{\n    fn serialize<SER>(&self, _ser: &mut SER) -> Result<(), SER::Error>\n        where SER: Serializer,\n    {\n        unimplemented!()\n    }\n}\n```\n\nThe error message is coming from `Option<&'static str>: Serialize`. I need to figure out why, because that seems like a reasonable bound.\n\nThe option impl looks like this:\n\n``` rust\nimpl<T> Serialize for Option<T> where T: Serialize { /* ... */ }\n```\n\nThe ref impl looks like this:\n\n``` rust\nimpl<'a, T: ?Sized> Serialize for &'a T where T: Serialize { /* ... */ }\n```\n\nAnd the str impl looks like this:\n\n``` rust\nimpl Serialize for str { /* ... */ }\n```\n\nSo it seems like `Option<&'static str>: Serialize` should be fine. Possibly a compiler issue? I will continue debugging after work.\n", "created_at": "2016-07-22T06:07:43Z"}, {"repo": "serde-rs/serde", "pull_number": 452, "instance_id": "serde-rs__serde-452", "issue_numbers": ["219"], "base_commit": "d751b4c39a956f3b36dd967d940a2f6fd0c2718e", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 4096fa8fb..1680312b0 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -593,7 +593,7 @@ macro_rules! array_impls {\n                 fn deserialize<D>(deserializer: &mut D) -> Result<[T; $len], D::Error>\n                     where D: Deserializer,\n                 {\n-                    deserializer.deserialize_fixed_size_array($len, $visitor::new())\n+                    deserializer.deserialize_seq_fixed_size($len, $visitor::new())\n                 }\n             }\n         )+\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 47033dde2..c9eea5543 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -10,6 +10,73 @@ use collections::{String, Vec};\n \n use core::fmt;\n \n+///////////////////////////////////////////////////////////////////////////////\n+/// Macro helper to not have to re-implement all the defaulted methods.\n+/// Every given method ignores all arguments and forwards to `deserialize`.\n+/// Note that `deserialize_enum` simply returns an `Error::invalid_type`.\n+macro_rules! de_forward_to_deserialize {\n+    ($($func:ident),*) => {\n+        $(de_forward_to_deserialize!{func: $func})*\n+    };\n+    (func: deserialize_unit_struct) => {\n+        de_forward_to_deserialize!{named: deserialize_unit_struct}\n+    };\n+    (func: deserialize_newtype_struct) => {\n+        de_forward_to_deserialize!{named: deserialize_newtype_struct}\n+    };\n+    (func: deserialize_tuple) => {\n+        de_forward_to_deserialize!{tup_fn: deserialize_tuple}\n+    };\n+    (func: deserialize_seq_fixed_size) => {\n+        de_forward_to_deserialize!{tup_fn: deserialize_seq_fixed_size}\n+    };\n+    (func: deserialize_tuple_struct) => {\n+        #[inline]\n+        fn deserialize_tuple_struct<__V>(&mut self, _: &str, _: usize, visitor: __V) -> Result<__V::Value, Self::Error>\n+            where __V: $crate::de::Visitor {\n+            self.deserialize(visitor)\n+        }\n+    };\n+    (func: deserialize_struct) => {\n+        #[inline]\n+        fn deserialize_struct<__V>(&mut self, _: &str, _: &[&str], visitor: __V) -> Result<__V::Value, Self::Error>\n+            where __V: $crate::de::Visitor {\n+            self.deserialize(visitor)\n+        }\n+    };\n+    (func: deserialize_enum) => {\n+        #[inline]\n+        fn deserialize_enum<__V>(&mut self, _: &str, _: &[&str], _: __V) -> Result<__V::Value, Self::Error>\n+            where __V: $crate::de::EnumVisitor {\n+            Err($crate::de::Error::invalid_type($crate::de::Type::Enum))\n+        }\n+    };\n+    (named: $func:ident) => {\n+        #[inline]\n+        fn $func<__V>(&mut self, _: &str, visitor: __V) -> Result<__V::Value, Self::Error>\n+            where __V: $crate::de::Visitor {\n+            self.deserialize(visitor)\n+        }\n+    };\n+    (tup_fn: $func: ident) => {\n+        #[inline]\n+        fn $func<__V>(&mut self, _: usize, visitor: __V) -> Result<__V::Value, Self::Error>\n+            where __V: $crate::de::Visitor {\n+            self.deserialize(visitor)\n+        }\n+    };\n+    (func: $func:ident) => {\n+        #[inline]\n+        fn $func<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+            where __V: $crate::de::Visitor {\n+            self.deserialize(visitor)\n+        }\n+    };\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// modules come after macros\n+\n pub mod impls;\n pub mod value;\n mod from_primitive;\n@@ -243,278 +310,166 @@ pub trait Deserializer {\n         where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a `bool` value.\n-    #[inline]\n     fn deserialize_bool<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an `usize` value.\n-    #[inline]\n+    /// A reasonable default is to forward to `deserialize_u64`.\n     fn deserialize_usize<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_u64(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an `u8` value.\n-    #[inline]\n+    /// A reasonable default is to forward to `deserialize_u64`.\n     fn deserialize_u8<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_u64(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an `u16` value.\n-    #[inline]\n+    /// A reasonable default is to forward to `deserialize_u64`.\n     fn deserialize_u16<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_u64(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an `u32` value.\n-    #[inline]\n+    /// A reasonable default is to forward to `deserialize_u64`.\n     fn deserialize_u32<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_u64(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an `u64` value.\n-    #[inline]\n     fn deserialize_u64<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an `isize` value.\n-    #[inline]\n+    /// A reasonable default is to forward to `deserialize_i64`.\n     fn deserialize_isize<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_i64(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an `i8` value.\n-    #[inline]\n+    /// A reasonable default is to forward to `deserialize_i64`.\n     fn deserialize_i8<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_i64(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an `i16` value.\n-    #[inline]\n+    /// A reasonable default is to forward to `deserialize_i64`.\n     fn deserialize_i16<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_i64(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an `i32` value.\n-    #[inline]\n+    /// A reasonable default is to forward to `deserialize_i64`.\n     fn deserialize_i32<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_i64(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an `i64` value.\n-    #[inline]\n     fn deserialize_i64<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a `f32` value.\n-    #[inline]\n+    /// A reasonable default is to forward to `deserialize_f64`.\n     fn deserialize_f32<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_f64(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a `f64` value.\n-    #[inline]\n     fn deserialize_f64<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a `char` value.\n-    #[inline]\n     fn deserialize_char<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a `&str` value.\n-    #[inline]\n     fn deserialize_str<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a `String` value.\n-    #[inline]\n     fn deserialize_string<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_str(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an `unit` value.\n-    #[inline]\n     fn deserialize_unit<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an `Option` value. This allows\n     /// deserializers that encode an optional value as a nullable value to convert the null value\n     /// into a `None`, and a regular value as `Some(value)`.\n-    #[inline]\n     fn deserialize_option<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a sequence value. This allows\n     /// deserializers to parse sequences that aren't tagged as sequences.\n-    #[inline]\n     fn deserialize_seq<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a fixed size array. This allows\n     /// deserializers to parse arrays that aren't tagged as arrays.\n-    ///\n-    /// By default, this deserializes arrays from a sequence.\n-    #[inline]\n-    fn deserialize_fixed_size_array<V>(&mut self,\n+    fn deserialize_seq_fixed_size<V>(&mut self,\n                                        _len: usize,\n                                        visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a `Vec<u8>`. This allows\n     /// deserializers that provide a custom byte vector serialization to properly deserialize the\n     /// type.\n-    #[inline]\n     fn deserialize_bytes<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_seq(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a map of values. This allows\n     /// deserializers to parse sequences that aren't tagged as maps.\n-    #[inline]\n     fn deserialize_map<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a unit struct. This allows\n     /// deserializers to a unit struct that aren't tagged as a unit struct.\n-    #[inline]\n     fn deserialize_unit_struct<V>(&mut self,\n                                   _name: &'static str,\n                                   visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_unit(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a newtype struct. This allows\n     /// deserializers to a newtype struct that aren't tagged as a newtype struct.\n-    #[inline]\n+    /// A reasonable default is to simply deserialize the expected value directly.\n     fn deserialize_newtype_struct<V>(&mut self,\n                                      name: &'static str,\n                                      visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_tuple_struct(name, 1, visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a tuple struct. This allows\n     /// deserializers to parse sequences that aren't tagged as sequences.\n-    #[inline]\n     fn deserialize_tuple_struct<V>(&mut self,\n                                    _name: &'static str,\n                                    len: usize,\n                                    visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_tuple(len, visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a struct. This allows\n     /// deserializers to parse sequences that aren't tagged as maps.\n-    #[inline]\n     fn deserialize_struct<V>(&mut self,\n                              _name: &'static str,\n                              _fields: &'static [&'static str],\n                              visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_map(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting some sort of struct field\n     /// name.  This allows deserializers to choose between &str, usize, or &[u8] to properly\n     /// deserialize a struct field.\n-    #[inline]\n     fn deserialize_struct_field<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting a tuple value. This allows\n     /// deserializers that provide a custom tuple serialization to properly deserialize the type.\n-    #[inline]\n     fn deserialize_tuple<V>(&mut self, _len: usize, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor,\n-    {\n-        self.deserialize_seq(visitor)\n-    }\n+        where V: Visitor;\n \n     /// This method hints that the `Deserialize` type is expecting an enum value. This allows\n     /// deserializers that provide a custom enumeration serialization to properly deserialize the\n     /// type.\n-    #[inline]\n     fn deserialize_enum<V>(&mut self,\n                            _enum: &'static str,\n                            _variants: &'static [&'static str],\n                            _visitor: V) -> Result<V::Value, Self::Error>\n-        where V: EnumVisitor,\n-    {\n-        Err(Error::invalid_type(Type::Enum))\n-    }\n+        where V: EnumVisitor;\n \n     /// This method hints that the `Deserialize` type needs to deserialize a value whose type\n     /// doesn't matter because it is ignored.\n-    #[inline]\n     fn deserialize_ignored_any<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor\n-    {\n-        self.deserialize(visitor)\n-    }\n+        where V: Visitor;\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -870,33 +825,26 @@ pub trait VariantVisitor {\n         Err(Error::invalid_type(Type::UnitVariant))\n     }\n \n-    /// `visit_newtype` is called when deserializing a variant with a single value. By default this\n-    /// uses the `visit_tuple` method to deserialize the value.\n-    #[inline]\n+    /// `visit_newtype` is called when deserializing a variant with a single value.\n+    /// A good default is often to use the `visit_tuple` method to deserialize a `(value,)`.\n     fn visit_newtype<T>(&mut self) -> Result<T, Self::Error>\n-        where T: Deserialize,\n-    {\n-        let (value,) = try!(self.visit_tuple(1, impls::TupleVisitor1::new()));\n-        Ok(value)\n-    }\n+        where T: Deserialize;\n \n     /// `visit_tuple` is called when deserializing a tuple-like variant.\n+    /// If no tuple variants are expected, yield a\n+    /// `Err(serde::de::Error::invalid_type(serde::de::Type::TupleVariant))`\n     fn visit_tuple<V>(&mut self,\n                       _len: usize,\n                       _visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor\n-    {\n-        Err(Error::invalid_type(Type::TupleVariant))\n-    }\n+        where V: Visitor;\n \n     /// `visit_struct` is called when deserializing a struct-like variant.\n+    /// If no struct variants are expected, yield a\n+    /// `Err(serde::de::Error::invalid_type(serde::de::Type::StructVariant))`\n     fn visit_struct<V>(&mut self,\n                        _fields: &'static [&'static str],\n                        _visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor\n-    {\n-        Err(Error::invalid_type(Type::StructVariant))\n-    }\n+        where V: Visitor;\n }\n \n impl<'a, T> VariantVisitor for &'a mut T where T: VariantVisitor {\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 65499ee3b..f8e98bf8f 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -174,6 +174,22 @@ impl<E> de::Deserializer for UnitDeserializer<E>\n {\n     type Error = E;\n \n+    de_forward_to_deserialize!{\n+        deserialize_bool,\n+        deserialize_f64, deserialize_f32,\n+        deserialize_u8, deserialize_u16, deserialize_u32, deserialize_u64, deserialize_usize,\n+        deserialize_i8, deserialize_i16, deserialize_i32, deserialize_i64, deserialize_isize,\n+        deserialize_char, deserialize_str, deserialize_string,\n+        deserialize_ignored_any,\n+        deserialize_bytes,\n+        deserialize_unit_struct, deserialize_unit,\n+        deserialize_seq, deserialize_seq_fixed_size,\n+        deserialize_map, deserialize_newtype_struct, deserialize_struct_field,\n+        deserialize_tuple,\n+        deserialize_enum,\n+        deserialize_struct, deserialize_tuple_struct\n+    }\n+\n     fn deserialize<V>(&mut self, mut visitor: V) -> Result<V::Value, Self::Error>\n         where V: de::Visitor,\n     {\n@@ -209,6 +225,23 @@ macro_rules! primitive_deserializer {\n         {\n             type Error = E;\n \n+            de_forward_to_deserialize!{\n+                deserialize_bool,\n+                deserialize_f64, deserialize_f32,\n+                deserialize_u8, deserialize_u16, deserialize_u32, deserialize_u64, deserialize_usize,\n+                deserialize_i8, deserialize_i16, deserialize_i32, deserialize_i64, deserialize_isize,\n+                deserialize_char, deserialize_str, deserialize_string,\n+                deserialize_ignored_any,\n+                deserialize_bytes,\n+                deserialize_unit_struct, deserialize_unit,\n+                deserialize_seq, deserialize_seq_fixed_size,\n+                deserialize_map, deserialize_newtype_struct, deserialize_struct_field,\n+                deserialize_tuple,\n+                deserialize_enum,\n+                deserialize_struct, deserialize_tuple_struct,\n+                deserialize_option\n+            }\n+\n             fn deserialize<V>(&mut self, mut visitor: V) -> Result<V::Value, Self::Error>\n                 where V: de::Visitor,\n             {\n@@ -273,6 +306,22 @@ impl<'a, E> de::Deserializer for StrDeserializer<'a, E>\n     {\n         visitor.visit(self)\n     }\n+\n+    de_forward_to_deserialize!{\n+        deserialize_bool,\n+        deserialize_f64, deserialize_f32,\n+        deserialize_u8, deserialize_u16, deserialize_u32, deserialize_u64, deserialize_usize,\n+        deserialize_i8, deserialize_i16, deserialize_i32, deserialize_i64, deserialize_isize,\n+        deserialize_char, deserialize_str, deserialize_string,\n+        deserialize_ignored_any,\n+        deserialize_bytes,\n+        deserialize_unit_struct, deserialize_unit,\n+        deserialize_seq, deserialize_seq_fixed_size,\n+        deserialize_map, deserialize_newtype_struct, deserialize_struct_field,\n+        deserialize_tuple,\n+        deserialize_struct, deserialize_tuple_struct,\n+        deserialize_option\n+    }\n }\n \n impl<'a, E> de::VariantVisitor for StrDeserializer<'a, E>\n@@ -289,6 +338,29 @@ impl<'a, E> de::VariantVisitor for StrDeserializer<'a, E>\n     fn visit_unit(&mut self) -> Result<(), Self::Error> {\n         Ok(())\n     }\n+\n+    fn visit_newtype<T>(&mut self) -> Result<T, Self::Error>\n+        where T: super::Deserialize,\n+    {\n+        let (value,) = try!(self.visit_tuple(1, super::impls::TupleVisitor1::new()));\n+        Ok(value)\n+    }\n+\n+    fn visit_tuple<V>(&mut self,\n+                      _len: usize,\n+                      _visitor: V) -> Result<V::Value, Self::Error>\n+        where V: super::Visitor\n+    {\n+        Err(super::Error::invalid_type(super::Type::TupleVariant))\n+    }\n+\n+    fn visit_struct<V>(&mut self,\n+                       _fields: &'static [&'static str],\n+                       _visitor: V) -> Result<V::Value, Self::Error>\n+        where V: super::Visitor\n+    {\n+        Err(super::Error::invalid_type(super::Type::StructVariant))\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -331,6 +403,22 @@ impl<E> de::Deserializer for StringDeserializer<E>\n     {\n         visitor.visit(self)\n     }\n+\n+    de_forward_to_deserialize!{\n+        deserialize_bool,\n+        deserialize_f64, deserialize_f32,\n+        deserialize_u8, deserialize_u16, deserialize_u32, deserialize_u64, deserialize_usize,\n+        deserialize_i8, deserialize_i16, deserialize_i32, deserialize_i64, deserialize_isize,\n+        deserialize_char, deserialize_str, deserialize_string,\n+        deserialize_ignored_any,\n+        deserialize_bytes,\n+        deserialize_unit_struct, deserialize_unit,\n+        deserialize_seq, deserialize_seq_fixed_size,\n+        deserialize_map, deserialize_newtype_struct, deserialize_struct_field,\n+        deserialize_tuple,\n+        deserialize_struct, deserialize_tuple_struct,\n+        deserialize_option\n+    }\n }\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n@@ -348,6 +436,29 @@ impl<'a, E> de::VariantVisitor for StringDeserializer<E>\n     fn visit_unit(&mut self) -> Result<(), Self::Error> {\n         Ok(())\n     }\n+\n+    fn visit_newtype<T>(&mut self) -> Result<T, Self::Error>\n+        where T: super::Deserialize,\n+    {\n+        let (value,) = try!(self.visit_tuple(1, super::impls::TupleVisitor1::new()));\n+        Ok(value)\n+    }\n+\n+    fn visit_tuple<V>(&mut self,\n+                      _len: usize,\n+                      _visitor: V) -> Result<V::Value, Self::Error>\n+        where V: super::Visitor\n+    {\n+        Err(super::Error::invalid_type(super::Type::TupleVariant))\n+    }\n+\n+    fn visit_struct<V>(&mut self,\n+                       _fields: &'static [&'static str],\n+                       _visitor: V) -> Result<V::Value, Self::Error>\n+        where V: super::Visitor\n+    {\n+        Err(super::Error::invalid_type(super::Type::StructVariant))\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -384,6 +495,23 @@ impl<I, T, E> de::Deserializer for SeqDeserializer<I, E>\n     {\n         visitor.visit_seq(self)\n     }\n+\n+    de_forward_to_deserialize!{\n+        deserialize_bool,\n+        deserialize_f64, deserialize_f32,\n+        deserialize_u8, deserialize_u16, deserialize_u32, deserialize_u64, deserialize_usize,\n+        deserialize_i8, deserialize_i16, deserialize_i32, deserialize_i64, deserialize_isize,\n+        deserialize_char, deserialize_str, deserialize_string,\n+        deserialize_ignored_any,\n+        deserialize_bytes,\n+        deserialize_unit_struct, deserialize_unit,\n+        deserialize_seq, deserialize_seq_fixed_size,\n+        deserialize_map, deserialize_newtype_struct, deserialize_struct_field,\n+        deserialize_tuple,\n+        deserialize_enum,\n+        deserialize_struct, deserialize_tuple_struct,\n+        deserialize_option\n+    }\n }\n \n impl<I, T, E> de::SeqVisitor for SeqDeserializer<I, E>\n@@ -490,6 +618,23 @@ impl<V_, E> de::Deserializer for SeqVisitorDeserializer<V_, E>\n     fn deserialize<V: de::Visitor>(&mut self, mut visitor: V) -> Result<V::Value, Self::Error> {\n         visitor.visit_seq(&mut self.visitor)\n     }\n+\n+    de_forward_to_deserialize!{\n+        deserialize_bool,\n+        deserialize_f64, deserialize_f32,\n+        deserialize_u8, deserialize_u16, deserialize_u32, deserialize_u64, deserialize_usize,\n+        deserialize_i8, deserialize_i16, deserialize_i32, deserialize_i64, deserialize_isize,\n+        deserialize_char, deserialize_str, deserialize_string,\n+        deserialize_ignored_any,\n+        deserialize_bytes,\n+        deserialize_unit_struct, deserialize_unit,\n+        deserialize_seq, deserialize_seq_fixed_size,\n+        deserialize_map, deserialize_newtype_struct, deserialize_struct_field,\n+        deserialize_tuple,\n+        deserialize_enum,\n+        deserialize_struct, deserialize_tuple_struct,\n+        deserialize_option\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -537,6 +682,23 @@ impl<I, K, V, E> de::Deserializer for MapDeserializer<I, K, V, E>\n     {\n         visitor.visit_map(self)\n     }\n+\n+    de_forward_to_deserialize!{\n+        deserialize_bool,\n+        deserialize_f64, deserialize_f32,\n+        deserialize_u8, deserialize_u16, deserialize_u32, deserialize_u64, deserialize_usize,\n+        deserialize_i8, deserialize_i16, deserialize_i32, deserialize_i64, deserialize_isize,\n+        deserialize_char, deserialize_str, deserialize_string,\n+        deserialize_ignored_any,\n+        deserialize_bytes,\n+        deserialize_unit_struct, deserialize_unit,\n+        deserialize_seq, deserialize_seq_fixed_size,\n+        deserialize_map, deserialize_newtype_struct, deserialize_struct_field,\n+        deserialize_tuple,\n+        deserialize_enum,\n+        deserialize_struct, deserialize_tuple_struct,\n+        deserialize_option\n+    }\n }\n \n impl<I, K, V, E> de::MapVisitor for MapDeserializer<I, K, V, E>\n@@ -648,6 +810,23 @@ impl<V_, E> de::Deserializer for MapVisitorDeserializer<V_, E>\n     fn deserialize<V: de::Visitor>(&mut self, mut visitor: V) -> Result<V::Value, Self::Error> {\n         visitor.visit_map(&mut self.visitor)\n     }\n+\n+    de_forward_to_deserialize!{\n+        deserialize_bool,\n+        deserialize_f64, deserialize_f32,\n+        deserialize_u8, deserialize_u16, deserialize_u32, deserialize_u64, deserialize_usize,\n+        deserialize_i8, deserialize_i16, deserialize_i32, deserialize_i64, deserialize_isize,\n+        deserialize_char, deserialize_str, deserialize_string,\n+        deserialize_ignored_any,\n+        deserialize_bytes,\n+        deserialize_unit_struct, deserialize_unit,\n+        deserialize_seq, deserialize_seq_fixed_size,\n+        deserialize_map, deserialize_newtype_struct, deserialize_struct_field,\n+        deserialize_tuple,\n+        deserialize_enum,\n+        deserialize_struct, deserialize_tuple_struct,\n+        deserialize_option\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -678,6 +857,23 @@ impl<'a, E> de::Deserializer for BytesDeserializer<'a, E>\n             None => Err(de::Error::end_of_stream()),\n         }\n     }\n+\n+    de_forward_to_deserialize!{\n+        deserialize_bool,\n+        deserialize_f64, deserialize_f32,\n+        deserialize_u8, deserialize_u16, deserialize_u32, deserialize_u64, deserialize_usize,\n+        deserialize_i8, deserialize_i16, deserialize_i32, deserialize_i64, deserialize_isize,\n+        deserialize_char, deserialize_str, deserialize_string,\n+        deserialize_ignored_any,\n+        deserialize_bytes,\n+        deserialize_unit_struct, deserialize_unit,\n+        deserialize_seq, deserialize_seq_fixed_size,\n+        deserialize_map, deserialize_newtype_struct, deserialize_struct_field,\n+        deserialize_tuple,\n+        deserialize_enum,\n+        deserialize_struct, deserialize_tuple_struct,\n+        deserialize_option\n+    }\n }\n \n \n@@ -712,4 +908,21 @@ impl<E> de::Deserializer for ByteBufDeserializer<E>\n             None => Err(de::Error::end_of_stream()),\n         }\n     }\n+\n+    de_forward_to_deserialize!{\n+        deserialize_bool,\n+        deserialize_f64, deserialize_f32,\n+        deserialize_u8, deserialize_u16, deserialize_u32, deserialize_u64, deserialize_usize,\n+        deserialize_i8, deserialize_i16, deserialize_i32, deserialize_i64, deserialize_isize,\n+        deserialize_char, deserialize_str, deserialize_string,\n+        deserialize_ignored_any,\n+        deserialize_bytes,\n+        deserialize_unit_struct, deserialize_unit,\n+        deserialize_seq, deserialize_seq_fixed_size,\n+        deserialize_map, deserialize_newtype_struct, deserialize_struct_field,\n+        deserialize_tuple,\n+        deserialize_enum,\n+        deserialize_struct, deserialize_tuple_struct,\n+        deserialize_option\n+    }\n }\n", "test_patch": "diff --git a/serde_macros/tests/test.rs b/serde_macros/tests/test.rs\nindex e92112185..e04627877 100644\n--- a/serde_macros/tests/test.rs\n+++ b/serde_macros/tests/test.rs\n@@ -1,7 +1,6 @@\n #![feature(test, custom_attribute, custom_derive, plugin)]\n #![plugin(serde_macros)]\n \n-extern crate serde;\n extern crate test;\n \n include!(\"../../testing/tests/test.rs.in\");\ndiff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 24dabe194..121dcd3db 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -110,6 +110,95 @@ impl<I> de::Deserializer for Deserializer<I>\n {\n     type Error = Error;\n \n+    fn deserialize_seq<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_struct_field<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_map<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_unit<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_bytes<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_ignored_any<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_string<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_str<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_char<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_i64<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_i32<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_i16<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_i8<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_u64<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_u32<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_u16<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_u8<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_f32<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_f64<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_bool<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_usize<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_isize<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+\n     fn deserialize<V>(&mut self, mut visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n@@ -241,7 +330,7 @@ impl<I> de::Deserializer for Deserializer<I>\n         }\n     }\n \n-    fn deserialize_fixed_size_array<V>(&mut self,\n+    fn deserialize_seq_fixed_size<V>(&mut self,\n                                        len: usize,\n                                        visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\ndiff --git a/testing/tests/test.rs.in b/testing/tests/test.rs.in\nindex 32c000544..fca1ff465 100644\n--- a/testing/tests/test.rs.in\n+++ b/testing/tests/test.rs.in\n@@ -1,3 +1,5 @@\n+extern crate serde;\n+\n #[macro_use]\n mod macros;\n \ndiff --git a/testing/tests/test_bytes.rs b/testing/tests/test_bytes.rs\nindex b2e21b2e8..cc30f1499 100644\n--- a/testing/tests/test_bytes.rs\n+++ b/testing/tests/test_bytes.rs\n@@ -1,20 +1,21 @@\n use std::fmt;\n use std::error;\n \n-extern crate serde;\n-use self::serde::Serialize;\n-use self::serde::bytes::{ByteBuf, Bytes};\n+use serde::{Serialize, Serializer, Deserialize, Deserializer};\n+use serde::bytes::{ByteBuf, Bytes};\n+use serde::ser;\n+use serde::de;\n \n ///////////////////////////////////////////////////////////////////////////////\n \n #[derive(Debug, PartialEq)]\n struct Error;\n \n-impl serde::ser::Error for Error {\n+impl ser::Error for Error {\n     fn custom<T: Into<String>>(_: T) -> Error { Error }\n }\n \n-impl serde::de::Error for Error {\n+impl de::Error for Error {\n     fn custom<T: Into<String>>(_: T) -> Error { Error }\n \n     fn end_of_stream() -> Error { Error }\n@@ -50,7 +51,7 @@ impl BytesSerializer {\n     }\n }\n \n-impl serde::Serializer for BytesSerializer {\n+impl Serializer for BytesSerializer {\n     type Error = Error;\n     type SeqState = ();\n     type MapState = ();\n@@ -137,19 +138,19 @@ impl serde::Serializer for BytesSerializer {\n     }\n \n     fn serialize_some<V>(&mut self, _value: V) -> Result<(), Error>\n-        where V: serde::Serialize,\n+        where V: Serialize,\n     {\n         Err(Error)\n     }\n \n     fn serialize_newtype_struct<V>(&mut self, _: &'static str, _value: V) -> Result<(), Error>\n-        where V: serde::Serialize,\n+        where V: Serialize,\n     {\n         Err(Error)\n     }\n \n     fn serialize_newtype_variant<V>(&mut self, _: &'static str, _: usize, _: &'static str, _value: V) -> Result<(), Error>\n-        where V: serde::Serialize,\n+        where V: Serialize,\n     {\n         Err(Error)\n     }\n@@ -165,7 +166,7 @@ impl serde::Serializer for BytesSerializer {\n     }\n \n     fn serialize_seq_elt<T>(&mut self, _: &mut (), _value: T) -> Result<(), Error>\n-        where T: serde::Serialize\n+        where T: Serialize\n     {\n         Err(Error)\n     }\n@@ -181,7 +182,7 @@ impl serde::Serializer for BytesSerializer {\n     }\n \n     fn serialize_tuple_elt<T>(&mut self, _: &mut (), _value: T) -> Result<(), Error>\n-        where T: serde::Serialize\n+        where T: Serialize\n     {\n         Err(Error)\n     }\n@@ -197,7 +198,7 @@ impl serde::Serializer for BytesSerializer {\n     }\n \n     fn serialize_tuple_struct_elt<T>(&mut self, _: &mut (), _value: T) -> Result<(), Error>\n-        where T: serde::Serialize\n+        where T: Serialize\n     {\n         Err(Error)\n     }\n@@ -213,7 +214,7 @@ impl serde::Serializer for BytesSerializer {\n     }\n \n     fn serialize_tuple_variant_elt<T>(&mut self, _: &mut (), _value: T) -> Result<(), Error>\n-        where T: serde::Serialize\n+        where T: Serialize\n     {\n         Err(Error)\n     }\n@@ -229,8 +230,8 @@ impl serde::Serializer for BytesSerializer {\n     }\n \n     fn serialize_map_elt<K, V>(&mut self, _: &mut (), _key: K, _value: V) -> Result<(), Error>\n-        where K: serde::Serialize,\n-              V: serde::Serialize,\n+        where K: Serialize,\n+              V: Serialize,\n     {\n         Err(Error)\n     }\n@@ -246,7 +247,7 @@ impl serde::Serializer for BytesSerializer {\n     }\n \n     fn serialize_struct_elt<V>(&mut self, _: &mut (), _key: &'static str, _value: V) -> Result<(), Error>\n-        where V: serde::Serialize,\n+        where V: Serialize,\n     {\n         Err(Error)\n     }\n@@ -262,7 +263,7 @@ impl serde::Serializer for BytesSerializer {\n     }\n \n     fn serialize_struct_variant_elt<V>(&mut self, _: &mut (), _key: &'static str, _value: V) -> Result<(), Error>\n-        where V: serde::Serialize,\n+        where V: Serialize,\n     {\n         Err(Error)\n     }\n@@ -292,20 +293,137 @@ impl BytesDeserializer {\n     }\n }\n \n-impl serde::Deserializer for BytesDeserializer {\n+impl Deserializer for BytesDeserializer {\n     type Error = Error;\n \n     fn deserialize<V>(&mut self, _visitor: V) -> Result<V::Value, Error>\n-        where V: serde::de::Visitor,\n+        where V: de::Visitor,\n     {\n         Err(Error)\n     }\n \n     fn deserialize_bytes<V>(&mut self, mut visitor: V) -> Result<V::Value, Error>\n-        where V: serde::de::Visitor,\n+        where V: de::Visitor,\n     {\n         visitor.visit_byte_buf(self.bytes.take().unwrap())\n     }\n+\n+    fn deserialize_seq<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_struct_field<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_map<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_unit<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_ignored_any<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_string<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_str<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_char<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_i64<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_i32<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_i16<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_i8<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_u64<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_u32<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_u16<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_u8<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_f32<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_f64<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_bool<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_usize<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_isize<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_option<__V>(&mut self, visitor: __V)\n+     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_seq_fixed_size<__V>(&mut self, _: usize, visitor: __V)\n+     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_unit_struct<__V>(&mut self, _: &str, visitor: __V)\n+     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_newtype_struct<__V>(&mut self, _: &str, visitor: __V)\n+     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_tuple_struct<__V>(&mut self, _: &str, _: usize, visitor: __V)\n+     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_struct<__V>(&mut self, _: &str, _: &[&str], visitor: __V)\n+     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_tuple<__V>(&mut self, _: usize, visitor: __V)\n+     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n+    fn deserialize_enum<__V>(&mut self, _: &str, _: &[&str], _visitor: __V)\n+     -> Result<__V::Value, Self::Error> where __V: de::EnumVisitor {\n+        Err(Error)\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -328,10 +446,10 @@ fn test_bytes_ser_bytes() {\n #[test]\n fn test_byte_buf_de_bytes() {\n     let mut de = BytesDeserializer::new(vec![]);\n-    let bytes = serde::Deserialize::deserialize(&mut de);\n+    let bytes = Deserialize::deserialize(&mut de);\n     assert_eq!(bytes, Ok(ByteBuf::new()));\n \n     let mut de = BytesDeserializer::new(vec![1, 2, 3]);\n-    let bytes = serde::Deserialize::deserialize(&mut de);\n+    let bytes = Deserialize::deserialize(&mut de);\n     assert_eq!(bytes, Ok(ByteBuf::from(vec![1, 2, 3])));\n }\ndiff --git a/testing/tests/test_de.rs b/testing/tests/test_de.rs\nindex 8a73bf380..63b6b6f7d 100644\n--- a/testing/tests/test_de.rs\n+++ b/testing/tests/test_de.rs\n@@ -2,8 +2,7 @@ use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n use std::net;\n use std::path::PathBuf;\n \n-extern crate serde;\n-use self::serde::Deserialize;\n+use serde::Deserialize;\n \n extern crate fnv;\n use self::fnv::FnvHasher;\n", "problem_statement": "Serializer and Deserializer should be pure interface\nFor now the Serializer and Deserializer traits contain many functions, but many of them have default implementations. A problem is, the default implementations make too many assumption about the serializing protocol, probably based on json. Though them may be convenient for implementing a json serializer, or other text protocols, but most of them do not suit for a binary protocol. The point is, Serializer and Deserializer are so big, that when implementing a concrete serializer/deserializer it is quite possible to accidentally miss some functions. So it is better to remove the default implementations,    and make the Serializer and Deserializer traits a 'checklist', the compiler can help checking the implemention. In addition, the current default implementations can be moved to some JsonlikeSerializer or CommonTextSerializer sub-traits.\n\n", "hints_text": "I agree. This \"magic\" has caused me some headache debugging, so I ended up replacing all of them manually.\n\n+1. I think magic layers are more appropriate for Deserialize/Serialize sugar, which are types that many serde users need to interact with. The -er types are relatively rarely implemented, and harder for an author to get complete ambient test coverage of via their own client code, so sacrificing sugar for correctness feels appropriate.\n\nI can get behind this. One downside though with making this always pure is that any new hint we add would trigger a major release, or we just add a default implementation for that method. Would everyone be okay with this?\n\n@erickt adding a default implementation when adding a hint seems preferable to a major release. It's entirely backwards compatible this way, and formats which need the hinting can start using it immediately. Since this is all about getting rid of default impls, issues should be added to remove the default impl come the next major version.\n", "created_at": "2016-07-20T08:47:40Z"}, {"repo": "serde-rs/serde", "pull_number": 446, "instance_id": "serde-rs__serde-446", "issue_numbers": ["404"], "base_commit": "6c18896cf592238ba643aa9050e536e64d4a732c", "patch": "diff --git a/.travis.yml b/.travis.yml\nindex 7e3e0d3b9..19a2d6929 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -18,15 +18,15 @@ before_script:\n script:\n - (cd serde && travis-cargo build)\n - (cd serde && travis-cargo --skip nightly test)\n-- (cd serde && travis-cargo --only nightly test -- --features nightly-testing)\n+- (cd serde && travis-cargo --only nightly test -- --features unstable-testing)\n - (cd serde && travis-cargo build -- --no-default-features)\n - (cd serde && travis-cargo --only nightly build -- --no-default-features --features alloc)\n - (cd serde && travis-cargo --only nightly build -- --no-default-features --features collections)\n - (cd testing && travis-cargo --skip nightly test)\n-- (cd testing && travis-cargo --only nightly test -- --features nightly-testing)\n-- (cd serde_macros && travis-cargo --only nightly test -- --features nightly-testing)\n+- (cd testing && travis-cargo --only nightly test -- --features unstable-testing)\n+- (cd serde_macros && travis-cargo --only nightly test -- --features unstable-testing)\n #- (cd examples/serde-syntex-example && travis-cargo --skip nightly run)\n-#- (cd examples/serde-syntex-example && travis-cargo --only nightly run -- --no-default-features --features nightly)\n+#- (cd examples/serde-syntex-example && travis-cargo --only nightly run -- --no-default-features --features unstable)\n - (cd serde && travis-cargo --only stable doc)\n after_success:\n - (cd serde && travis-cargo --only stable doc-upload)\ndiff --git a/examples/serde-syntex-example/Cargo.toml b/examples/serde-syntex-example/Cargo.toml\nindex 7e87e8339..73b813b29 100644\n--- a/examples/serde-syntex-example/Cargo.toml\n+++ b/examples/serde-syntex-example/Cargo.toml\n@@ -6,7 +6,7 @@ build = \"build.rs\"\n \n [features]\n default = [\"serde_codegen\"]\n-nightly = [\"serde_macros\"]\n+unstable = [\"serde_macros\"]\n \n [build-dependencies]\n serde_codegen = { version = \"^0.7\", optional = true }\ndiff --git a/serde/Cargo.toml b/serde/Cargo.toml\nindex e8e8d8588..fbb53b199 100644\n--- a/serde/Cargo.toml\n+++ b/serde/Cargo.toml\n@@ -2,7 +2,7 @@\n name = \"serde\"\n # DO NOT RELEASE ANY MORE 0.7 RELEASES FROM THIS BRANCH\n # USE THE 0.7.x BRANCH\n-version = \"0.8.0-rc1\"\n+version = \"0.8.0-rc2\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"A generic serialization/deserialization framework\"\n@@ -16,10 +16,10 @@ include = [\"Cargo.toml\", \"src/**/*.rs\"]\n default = [\"std\"]\n \n std = []\n-nightly = []\n-alloc = [\"nightly\"]\n+unstable = []\n+alloc = [\"unstable\"]\n collections = [\"alloc\"]\n-nightly-testing = [\"clippy\", \"nightly\", \"std\"]\n+unstable-testing = [\"clippy\", \"unstable\", \"std\"]\n \n [dependencies]\n clippy = { version = \"^0.*\", optional = true }\ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex d4591690b..4096fa8fb 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -2,7 +2,7 @@\n \n #[cfg(feature = \"std\")]\n use std::borrow::Cow;\n-#[cfg(all(feature = \"nightly\", feature = \"collections\", not(feature = \"std\")))]\n+#[cfg(all(feature = \"unstable\", feature = \"collections\", not(feature = \"std\")))]\n use collections::borrow::Cow;\n \n #[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n@@ -27,9 +27,9 @@ use std::collections::{\n     VecDeque,\n };\n \n-#[cfg(all(feature = \"nightly\", feature = \"collections\"))]\n+#[cfg(all(feature = \"unstable\", feature = \"collections\"))]\n use collections::enum_set::{CLike, EnumSet};\n-#[cfg(all(feature = \"nightly\", feature = \"collections\"))]\n+#[cfg(all(feature = \"unstable\", feature = \"collections\"))]\n use collections::borrow::ToOwned;\n \n use core::hash::{Hash, BuildHasher};\n@@ -42,21 +42,21 @@ use core::str;\n \n #[cfg(feature = \"std\")]\n use std::rc::Rc;\n-#[cfg(all(feature = \"nightly\", feature = \"alloc\", not(feature = \"std\")))]\n+#[cfg(all(feature = \"unstable\", feature = \"alloc\", not(feature = \"std\")))]\n use alloc::rc::Rc;\n \n #[cfg(feature = \"std\")]\n use std::sync::Arc;\n-#[cfg(all(feature = \"nightly\", feature = \"alloc\", not(feature = \"std\")))]\n+#[cfg(all(feature = \"unstable\", feature = \"alloc\", not(feature = \"std\")))]\n use alloc::arc::Arc;\n \n-#[cfg(all(feature = \"nightly\", feature = \"alloc\", not(feature = \"std\")))]\n+#[cfg(all(feature = \"unstable\", feature = \"alloc\", not(feature = \"std\")))]\n use alloc::boxed::Box;\n \n-#[cfg(feature = \"nightly\")]\n+#[cfg(feature = \"unstable\")]\n use core::nonzero::{NonZero, Zeroable};\n \n-#[cfg(feature = \"nightly\")]\n+#[cfg(feature = \"unstable\")]\n use core::num::Zero;\n \n use de::{\n@@ -461,7 +461,7 @@ seq_impl!(\n     BTreeSet::new(),\n     BTreeSet::insert);\n \n-#[cfg(all(feature = \"nightly\", feature = \"collections\"))]\n+#[cfg(all(feature = \"unstable\", feature = \"collections\"))]\n seq_impl!(\n     EnumSet<T>,\n     EnumSetVisitor<T: Deserialize + CLike>,\n@@ -806,7 +806,7 @@ map_impl!(\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-#[cfg(all(feature = \"nightly\", feature = \"std\"))]\n+#[cfg(all(feature = \"unstable\", feature = \"std\"))]\n impl Deserialize for net::IpAddr {\n     fn deserialize<D>(deserializer: &mut D) -> Result<Self, D::Error>\n         where D: Deserializer,\n@@ -972,7 +972,7 @@ impl<'a, T: ?Sized> Deserialize for Cow<'a, T> where T: ToOwned, T::Owned: Deser\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-#[cfg(feature = \"nightly\")]\n+#[cfg(feature = \"unstable\")]\n impl<T> Deserialize for NonZero<T> where T: Deserialize + PartialEq + Zeroable + Zero {\n     fn deserialize<D>(deserializer: &mut D) -> Result<NonZero<T>, D::Error> where D: Deserializer {\n         let value = try!(Deserialize::deserialize(deserializer));\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex b2349a17c..65499ee3b 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -25,7 +25,7 @@ use collections::{\n     vec,\n };\n \n-#[cfg(all(feature = \"nightly\", feature = \"collections\"))]\n+#[cfg(all(feature = \"unstable\", feature = \"collections\"))]\n use collections::borrow::ToOwned;\n \n use core::hash::Hash;\ndiff --git a/serde/src/error.rs b/serde/src/error.rs\nindex 9852e1f28..7e5fef72f 100644\n--- a/serde/src/error.rs\n+++ b/serde/src/error.rs\n@@ -4,7 +4,7 @@ use core::fmt::{Debug, Display};\n \n \n /// A stand-in for `std::error::Error`, which requires no allocation.\n-#[cfg(feature = \"nightly\")]\n+#[cfg(feature = \"unstable\")]\n pub trait Error: Debug + Display + ::core::marker::Reflect {\n     /// A short description of the error.\n     ///\n@@ -24,7 +24,7 @@ pub trait Error: Debug + Display + ::core::marker::Reflect {\n }\n \n /// A stand-in for `std::error::Error`, which requires no allocation.\n-#[cfg(not(feature = \"nightly\"))]\n+#[cfg(not(feature = \"unstable\"))]\n pub trait Error: Debug + Display {\n     /// A short description of the error.\n     ///\ndiff --git a/serde/src/lib.rs b/serde/src/lib.rs\nindex e98741c60..808d50cf7 100644\n--- a/serde/src/lib.rs\n+++ b/serde/src/lib.rs\n@@ -11,29 +11,29 @@\n \n #![doc(html_root_url=\"https://serde-rs.github.io/serde/serde\")]\n #![cfg_attr(not(feature = \"std\"), no_std)]\n-#![cfg_attr(feature = \"nightly\", feature(reflect_marker, unicode, nonzero, plugin, step_trait, zero_one))]\n+#![cfg_attr(feature = \"unstable\", feature(reflect_marker, unicode, nonzero, plugin, step_trait, zero_one))]\n #![cfg_attr(feature = \"alloc\", feature(alloc))]\n #![cfg_attr(feature = \"collections\", feature(collections, enumset))]\n-#![cfg_attr(feature = \"nightly-testing\", plugin(clippy))]\n-#![cfg_attr(feature = \"nightly-testing\", allow(linkedlist))]\n+#![cfg_attr(feature = \"clippy\", plugin(clippy))]\n+#![cfg_attr(feature = \"clippy\", allow(linkedlist))]\n \n-#![cfg_attr(any(not(feature = \"std\"), feature = \"nightly\"), allow(unused_variables, unused_imports, unused_features, dead_code))]\n+#![cfg_attr(any(not(feature = \"std\"), feature = \"unstable\"), allow(unused_variables, unused_imports, unused_features, dead_code))]\n \n #![deny(missing_docs)]\n \n-#[cfg(all(feature = \"nightly\", feature = \"collections\"))]\n+#[cfg(all(feature = \"unstable\", feature = \"collections\"))]\n extern crate collections;\n \n-#[cfg(all(feature = \"nightly\", feature = \"alloc\"))]\n+#[cfg(all(feature = \"unstable\", feature = \"alloc\"))]\n extern crate alloc;\n \n #[cfg(feature = \"std\")]\n mod core {\n     pub use std::{ops, hash, fmt, cmp, marker, mem, i8, i16, i32, i64, u8, u16, u32, u64, isize,\n             usize, f32, f64, char, str, num, slice, iter};\n-    #[cfg(feature = \"nightly\")]\n+    #[cfg(feature = \"unstable\")]\n     extern crate core;\n-    #[cfg(feature = \"nightly\")]\n+    #[cfg(feature = \"unstable\")]\n     pub use self::core::nonzero;\n }\n \ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex a8876c958..89078df54 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -26,19 +26,19 @@ use collections::{\n     Vec,\n };\n \n-#[cfg(all(feature = \"nightly\", feature = \"collections\"))]\n+#[cfg(all(feature = \"unstable\", feature = \"collections\"))]\n use collections::enum_set::{CLike, EnumSet};\n-#[cfg(all(feature = \"nightly\", feature = \"collections\"))]\n+#[cfg(all(feature = \"unstable\", feature = \"collections\"))]\n use collections::borrow::ToOwned;\n \n use core::hash::{Hash, BuildHasher};\n-#[cfg(feature = \"nightly\")]\n+#[cfg(feature = \"unstable\")]\n use core::iter;\n #[cfg(feature = \"std\")]\n use std::net;\n-#[cfg(feature = \"nightly\")]\n+#[cfg(feature = \"unstable\")]\n use core::num;\n-#[cfg(feature = \"nightly\")]\n+#[cfg(feature = \"unstable\")]\n use core::ops;\n #[cfg(feature = \"std\")]\n use std::path;\n@@ -57,7 +57,7 @@ use alloc::boxed::Box;\n \n use core::marker::PhantomData;\n \n-#[cfg(feature = \"nightly\")]\n+#[cfg(feature = \"unstable\")]\n use core::nonzero::{NonZero, Zeroable};\n \n use super::{\n@@ -244,7 +244,7 @@ impl<T> Serialize for BTreeSet<T>\n     serialize_seq!();\n }\n \n-#[cfg(all(feature = \"nightly\", feature = \"collections\"))]\n+#[cfg(all(feature = \"unstable\", feature = \"collections\"))]\n impl<T> Serialize for EnumSet<T>\n     where T: Serialize + CLike\n {\n@@ -276,7 +276,7 @@ impl<T> Serialize for VecDeque<T> where T: Serialize {\n     serialize_seq!();\n }\n \n-#[cfg(feature = \"nightly\")]\n+#[cfg(feature = \"unstable\")]\n impl<A> Serialize for ops::Range<A>\n     where A: Serialize + Clone + iter::Step + num::One,\n           for<'a> &'a A: ops::Add<&'a A, Output = A>,\n@@ -619,7 +619,7 @@ impl<T, E> Serialize for Result<T, E> where T: Serialize, E: Serialize {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-#[cfg(all(feature = \"std\", feature = \"nightly\"))]\n+#[cfg(all(feature = \"std\", feature = \"unstable\"))]\n impl Serialize for net::IpAddr {\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n         where S: Serializer,\n@@ -704,7 +704,7 @@ impl Serialize for path::PathBuf {\n     }\n }\n \n-#[cfg(feature = \"nightly\")]\n+#[cfg(feature = \"unstable\")]\n impl<T> Serialize for NonZero<T> where T: Serialize + Zeroable {\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error> where S: Serializer {\n         (**self).serialize(serializer)\ndiff --git a/serde_codegen/Cargo.toml b/serde_codegen/Cargo.toml\nindex 5e2d3a850..d13a36106 100644\n--- a/serde_codegen/Cargo.toml\n+++ b/serde_codegen/Cargo.toml\n@@ -2,7 +2,7 @@\n name = \"serde_codegen\"\n # DO NOT RELEASE ANY MORE 0.7 RELEASES FROM THIS BRANCH\n # USE THE 0.7.x BRANCH\n-version = \"0.8.0-rc1\"\n+version = \"0.8.0-rc2\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"Macros to auto-generate implementations for the serde framework\"\n@@ -14,8 +14,8 @@ include = [\"Cargo.toml\", \"build.rs\", \"src/**/*.rs\", \"src/lib.rs.in\"]\n \n [features]\n default = [\"with-syntex\"]\n-nightly = [\"quasi_macros\"]\n-nightly-testing = [\"clippy\"]\n+unstable = [\"quasi_macros\"]\n+unstable-testing = [\"clippy\"]\n with-syntex = [\n     \"quasi/with-syntex\",\n     \"quasi_codegen\",\n@@ -34,6 +34,6 @@ aster = { version = \"^0.21.1\", default-features = false }\n clippy = { version = \"^0.*\", optional = true }\n quasi = { version = \"^0.15.0\", default-features = false }\n quasi_macros = { version = \"^0.15.0\", optional = true }\n-serde_codegen_internals = { version = \"^0.3.0\", default-features = false }\n+serde_codegen_internals = { version = \"0.4.0-rc1\", default-features = false }\n syntex = { version = \"^0.38.0\", optional = true }\n syntex_syntax = { version = \"^0.38.0\", optional = true }\ndiff --git a/serde_codegen/src/lib.rs b/serde_codegen/src/lib.rs\nindex 258015707..5cc90efa8 100644\n--- a/serde_codegen/src/lib.rs\n+++ b/serde_codegen/src/lib.rs\n@@ -1,7 +1,7 @@\n-#![cfg_attr(feature = \"nightly-testing\", plugin(clippy))]\n-#![cfg_attr(feature = \"nightly-testing\", feature(plugin))]\n-#![cfg_attr(feature = \"nightly-testing\", allow(too_many_arguments))]\n-#![cfg_attr(feature = \"nightly-testing\", allow(used_underscore_binding))]\n+#![cfg_attr(feature = \"clippy\", plugin(clippy))]\n+#![cfg_attr(feature = \"clippy\", feature(plugin))]\n+#![cfg_attr(feature = \"clippy\", allow(too_many_arguments))]\n+#![cfg_attr(feature = \"clippy\", allow(used_underscore_binding))]\n #![cfg_attr(not(feature = \"with-syntex\"), feature(rustc_private, plugin))]\n #![cfg_attr(not(feature = \"with-syntex\"), plugin(quasi_macros))]\n \ndiff --git a/serde_codegen_internals/Cargo.toml b/serde_codegen_internals/Cargo.toml\nindex a6b135230..9a19e65e6 100644\n--- a/serde_codegen_internals/Cargo.toml\n+++ b/serde_codegen_internals/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_codegen_internals\"\n-version = \"0.3.0\"\n+version = \"0.4.0-rc1\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"AST representation used by Serde codegen. Unstable.\"\n@@ -11,7 +11,7 @@ include = [\"Cargo.toml\", \"src/**/*.rs\"]\n \n [features]\n default = [\"with-syntex\"]\n-nightly-testing = [\"clippy\"]\n+unstable-testing = [\"clippy\"]\n with-syntex = [\"syntex_syntax\", \"syntex_errors\"]\n \n [dependencies]\ndiff --git a/serde_codegen_internals/src/lib.rs b/serde_codegen_internals/src/lib.rs\nindex 4d347f167..89f20aa6a 100644\n--- a/serde_codegen_internals/src/lib.rs\n+++ b/serde_codegen_internals/src/lib.rs\n@@ -1,5 +1,5 @@\n-#![cfg_attr(feature = \"nightly-testing\", plugin(clippy))]\n-#![cfg_attr(feature = \"nightly-testing\", feature(plugin))]\n+#![cfg_attr(feature = \"clippy\", plugin(clippy))]\n+#![cfg_attr(feature = \"clippy\", feature(plugin))]\n #![cfg_attr(not(feature = \"with-syntex\"), feature(rustc_private, plugin))]\n \n #[cfg(feature = \"with-syntex\")]\ndiff --git a/serde_macros/Cargo.toml b/serde_macros/Cargo.toml\nindex 9ed8b6cfe..5381d4996 100644\n--- a/serde_macros/Cargo.toml\n+++ b/serde_macros/Cargo.toml\n@@ -2,7 +2,7 @@\n name = \"serde_macros\"\n # DO NOT RELEASE ANY MORE 0.7 RELEASES FROM THIS BRANCH\n # USE THE 0.7.x BRANCH\n-version = \"0.8.0-rc1\"\n+version = \"0.8.0-rc2\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"Macros to auto-generate implementations for the serde framework\"\n@@ -16,19 +16,19 @@ name = \"serde_macros\"\n plugin = true\n \n [features]\n-nightly-testing = [\"clippy\", \"serde/nightly-testing\", \"serde_codegen/nightly-testing\"]\n+unstable-testing = [\"clippy\", \"serde/unstable-testing\", \"serde_codegen/unstable-testing\"]\n \n [dependencies]\n clippy = { version = \"^0.*\", optional = true }\n-serde_codegen = { version = \"^0.8.0-rc1\", default-features = false, features = [\"nightly\"] }\n+serde_codegen = { version = \"^0.8.0-rc2\", default-features = false, features = [\"unstable\"] }\n \n [dev-dependencies]\n clippy = \"^0.*\"\n compiletest_rs = \"^0.2.0\"\n fnv = \"1.0\"\n rustc-serialize = \"^0.3.16\"\n-serde = \"0.8.0-rc1\"\n-serde_test = \"0.8.0-rc1\"\n+serde = \"0.8.0-rc2\"\n+serde_test = \"0.8.0-rc2\"\n \n [[test]]\n name = \"test\"\n", "test_patch": "diff --git a/serde_test/Cargo.toml b/serde_test/Cargo.toml\nindex 38d167027..9855d12fd 100644\n--- a/serde_test/Cargo.toml\n+++ b/serde_test/Cargo.toml\n@@ -2,7 +2,7 @@\n name = \"serde_test\"\n # DO NOT RELEASE ANY MORE 0.7 RELEASES FROM THIS BRANCH\n # USE THE 0.7.x BRANCH\n-version = \"0.8.0-rc1\"\n+version = \"0.8.0-rc2\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"Token De/Serializer for testing De/Serialize implementations\"\n@@ -13,4 +13,4 @@ keywords = [\"serde\", \"serialization\"]\n include = [\"Cargo.toml\", \"src/**/*.rs\"]\n \n [dependencies]\n-serde = \"0.8.0-rc1\"\n+serde = \"0.8.0-rc2\"\ndiff --git a/testing/Cargo.toml b/testing/Cargo.toml\nindex efae4b416..fd7fa5149 100644\n--- a/testing/Cargo.toml\n+++ b/testing/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_testing\"\n-version = \"0.8.0-rc1\"\n+version = \"0.8.0-rc2\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"A generic serialization/deserialization framework\"\n@@ -11,16 +11,16 @@ keywords = [\"serialization\"]\n build = \"build.rs\"\n \n [features]\n-nightly-testing = [\"clippy\", \"serde/nightly-testing\", \"serde_codegen/nightly-testing\"]\n+unstable-testing = [\"clippy\", \"serde/unstable-testing\", \"serde_codegen/unstable-testing\"]\n \n [build-dependencies]\n-serde_codegen = { version = \"*\", features = [\"with-syntex\"] }\n+serde_codegen = { path = \"../serde_codegen\", features = [\"with-syntex\"] }\n \n [dev-dependencies]\n fnv = \"1.0\"\n rustc-serialize = \"^0.3.16\"\n-serde = \"*\"\n-serde_test = \"*\"\n+serde = { path = \"../serde\" }\n+serde_test = { path = \"../serde_test\" }\n \n [dependencies]\n clippy = { version = \"^0.*\", optional = true }\ndiff --git a/testing/benches/bench.rs b/testing/benches/bench.rs\nindex d83323ae4..e5b10c57f 100644\n--- a/testing/benches/bench.rs\n+++ b/testing/benches/bench.rs\n@@ -1,6 +1,6 @@\n #![feature(test)]\n-#![cfg_attr(feature = \"nightly\", feature(plugin))]\n-#![cfg_attr(feature = \"nightly\", plugin(clippy))]\n+#![cfg_attr(feature = \"clippy\", feature(plugin))]\n+#![cfg_attr(feature = \"clippy\", plugin(clippy))]\n \n extern crate rustc_serialize;\n extern crate serde;\ndiff --git a/testing/tests/test.rs b/testing/tests/test.rs\nindex cd90cf1ea..43b89f446 100644\n--- a/testing/tests/test.rs\n+++ b/testing/tests/test.rs\n@@ -1,4 +1,4 @@\n-#![cfg_attr(feature = \"nightly\", feature(plugin))]\n-#![cfg_attr(feature = \"nightly\", plugin(clippy))]\n+#![cfg_attr(feature = \"clippy\", feature(plugin))]\n+#![cfg_attr(feature = \"clippy\", plugin(clippy))]\n \n include!(concat!(env!(\"OUT_DIR\"), \"/test.rs\"));\ndiff --git a/testing/tests/test_de.rs b/testing/tests/test_de.rs\nindex 08c06af6c..8a73bf380 100644\n--- a/testing/tests/test_de.rs\n+++ b/testing/tests/test_de.rs\n@@ -764,7 +764,7 @@ declare_tests! {\n     }\n }\n \n-#[cfg(feature = \"nightly\")]\n+#[cfg(feature = \"unstable\")]\n #[test]\n fn test_net_ipaddr() {\n     assert_de_tokens(\ndiff --git a/testing/tests/test_ser.rs b/testing/tests/test_ser.rs\nindex e772e05ed..5fc7bf127 100644\n--- a/testing/tests/test_ser.rs\n+++ b/testing/tests/test_ser.rs\n@@ -347,7 +347,7 @@ declare_ser_tests! {\n     }\n }\n \n-#[cfg(feature = \"nightly\")]\n+#[cfg(feature = \"unstable\")]\n #[test]\n fn test_net_ipaddr() {\n     assert_ser_tokens(\n", "problem_statement": "Rename feature \"nightly-testing\" to \"unstable-testing\"\nFrom what I understand, the community has started to use the feature `unstable*` instead of `nightly*` for things that may depend on the nightly compiler. If this is the case, when we do 0.8, we should consider renaming this feature.\n\n", "hints_text": "", "created_at": "2016-07-17T20:18:29Z"}, {"repo": "serde-rs/serde", "pull_number": 437, "instance_id": "serde-rs__serde-437", "issue_numbers": ["386"], "base_commit": "ed603d4580154bc09af94964c2aca8b42f268274", "patch": "diff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex d0ac49bc9..a8876c958 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -64,8 +64,6 @@ use super::{\n     Error,\n     Serialize,\n     Serializer,\n-    SeqVisitor,\n-    MapVisitor,\n };\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -133,26 +131,6 @@ impl<T> Serialize for Option<T> where T: Serialize {\n     }\n }\n \n-impl<T> SeqVisitor for Option<T> where T: Serialize {\n-    #[inline]\n-    fn visit<S>(&mut self, serializer: &mut S) -> Result<Option<()>, S::Error>\n-        where S: Serializer,\n-    {\n-        match self.take() {\n-            Some(value) => {\n-                try!(serializer.serialize_seq_elt(value));\n-                Ok(Some(()))\n-            }\n-            None => Ok(None),\n-        }\n-    }\n-\n-    #[inline]\n-    fn len(&self) -> Option<usize> {\n-        Some(if self.is_some() { 1 } else { 0 })\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////////\n \n impl<T> Serialize for PhantomData<T> {\n@@ -164,69 +142,6 @@ impl<T> Serialize for PhantomData<T> {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////////\n-\n-/// A `serde::Visitor` for sequence iterators.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use serde::{Serialize, Serializer};\n-/// use serde::ser::impls::SeqIteratorVisitor;\n-///\n-/// struct Seq(Vec<u32>);\n-///\n-/// impl Serialize for Seq {\n-///     fn serialize<S>(&self, ser: &mut S) -> Result<(), S::Error>\n-///         where S: Serializer,\n-///     {\n-///         ser.serialize_seq(SeqIteratorVisitor::new(\n-///             self.0.iter(),\n-///             Some(self.0.len()),\n-///         ))\n-///     }\n-/// }\n-/// ```\n-pub struct SeqIteratorVisitor<Iter> {\n-    iter: Iter,\n-    len: Option<usize>,\n-}\n-\n-impl<T, Iter> SeqIteratorVisitor<Iter>\n-    where Iter: Iterator<Item=T>\n-{\n-    /// Construct a new `SeqIteratorVisitor<Iter>`.\n-    #[inline]\n-    pub fn new(iter: Iter, len: Option<usize>) -> SeqIteratorVisitor<Iter> {\n-        SeqIteratorVisitor {\n-            iter: iter,\n-            len: len,\n-        }\n-    }\n-}\n-\n-impl<T, Iter> SeqVisitor for SeqIteratorVisitor<Iter>\n-    where T: Serialize,\n-          Iter: Iterator<Item=T>,\n-{\n-    #[inline]\n-    fn visit<S>(&mut self, serializer: &mut S) -> Result<Option<()>, S::Error>\n-        where S: Serializer,\n-    {\n-        match self.iter.next() {\n-            Some(value) => {\n-                try!(serializer.serialize_seq_elt(value));\n-                Ok(Some(()))\n-            }\n-            None => Ok(None),\n-        }\n-    }\n-\n-    #[inline]\n-    fn len(&self) -> Option<usize> {\n-        self.len\n-    }\n-}\n \n ///////////////////////////////////////////////////////////////////////////////\n \n@@ -237,7 +152,11 @@ impl<T> Serialize for [T]\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n         where S: Serializer,\n     {\n-        serializer.serialize_seq(SeqIteratorVisitor::new(self.iter(), Some(self.len())))\n+        let mut state = try!(serializer.serialize_seq(Some(self.len())));\n+        for e in self.iter() {\n+            try!(serializer.serialize_seq_elt(&mut state, e));\n+        }\n+        serializer.serialize_seq_end(state)\n     }\n }\n \n@@ -250,8 +169,11 @@ macro_rules! array_impls {\n             fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n                 where S: Serializer,\n             {\n-                let visitor = SeqIteratorVisitor::new(self.iter(), Some($len));\n-                serializer.serialize_fixed_size_array(visitor)\n+                let mut state = try!(serializer.serialize_seq_fixed_size($len));\n+                for e in self.iter() {\n+                    try!(serializer.serialize_seq_elt(&mut state, e));\n+                }\n+                serializer.serialize_seq_end(state)\n             }\n         }\n     }\n@@ -293,40 +215,40 @@ array_impls!(32);\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+macro_rules! serialize_seq {\n+    () => {\n+        #[inline]\n+        fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+            where S: Serializer,\n+        {\n+            let mut state = try!(serializer.serialize_seq(Some(self.len())));\n+            for e in self {\n+                try!(serializer.serialize_seq_elt(&mut state, e));\n+            }\n+            serializer.serialize_seq_end(state)\n+        }\n+    }\n+}\n+\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<T> Serialize for BinaryHeap<T>\n     where T: Serialize + Ord\n {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n-        where S: Serializer,\n-    {\n-        serializer.serialize_seq(SeqIteratorVisitor::new(self.iter(), Some(self.len())))\n-    }\n+    serialize_seq!();\n }\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<T> Serialize for BTreeSet<T>\n     where T: Serialize + Ord,\n {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n-        where S: Serializer,\n-    {\n-        serializer.serialize_seq(SeqIteratorVisitor::new(self.iter(), Some(self.len())))\n-    }\n+    serialize_seq!();\n }\n \n #[cfg(all(feature = \"nightly\", feature = \"collections\"))]\n impl<T> Serialize for EnumSet<T>\n     where T: Serialize + CLike\n {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n-        where S: Serializer,\n-    {\n-        serializer.serialize_seq(SeqIteratorVisitor::new(self.iter(), Some(self.len())))\n-    }\n+    serialize_seq!();\n }\n \n #[cfg(feature = \"std\")]\n@@ -334,57 +256,41 @@ impl<T, H> Serialize for HashSet<T, H>\n     where T: Serialize + Eq + Hash,\n           H: BuildHasher,\n {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n-        where S: Serializer,\n-    {\n-        serializer.serialize_seq(SeqIteratorVisitor::new(self.iter(), Some(self.len())))\n-    }\n+    serialize_seq!();\n }\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<T> Serialize for LinkedList<T>\n     where T: Serialize,\n {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n-        where S: Serializer,\n-    {\n-        serializer.serialize_seq(SeqIteratorVisitor::new(self.iter(), Some(self.len())))\n-    }\n-}\n-\n-#[cfg(feature = \"nightly\")]\n-impl<A> Serialize for ops::Range<A>\n-    where A: Serialize + Clone + iter::Step + num::One,\n-          for<'a> &'a A: ops::Add<&'a A, Output = A>,\n-{\n-    #[inline]\n-    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n-        where S: Serializer,\n-    {\n-        let len = iter::Step::steps_between(&self.start, &self.end, &A::one());\n-        serializer.serialize_seq(SeqIteratorVisitor::new(self.clone(), len))\n-    }\n+    serialize_seq!();\n }\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<T> Serialize for Vec<T> where T: Serialize {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n-        where S: Serializer,\n-    {\n-        (&self[..]).serialize(serializer)\n-    }\n+    serialize_seq!();\n }\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<T> Serialize for VecDeque<T> where T: Serialize {\n+    serialize_seq!();\n+}\n+\n+#[cfg(feature = \"nightly\")]\n+impl<A> Serialize for ops::Range<A>\n+    where A: Serialize + Clone + iter::Step + num::One,\n+          for<'a> &'a A: ops::Add<&'a A, Output = A>,\n+{\n     #[inline]\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n         where S: Serializer,\n     {\n-        serializer.serialize_seq(SeqIteratorVisitor::new(self.iter(), Some(self.len())))\n+        let len = iter::Step::steps_between(&self.start, &self.end, &A::one());\n+        let mut state = try!(serializer.serialize_seq(len));\n+        for e in self.clone() {\n+            try!(serializer.serialize_seq_elt(&mut state, e));\n+        }\n+        serializer.serialize_seq_end(state)\n     }\n }\n \n@@ -413,52 +319,18 @@ macro_rules! tuple_impls {\n         }\n     )+) => {\n         $(\n-            /// A tuple visitor.\n-            pub struct $TupleVisitor<'a, $($T: 'a),+> {\n-                tuple: &'a ($($T,)+),\n-                state: u8,\n-            }\n-\n-            impl<'a, $($T: 'a),+> $TupleVisitor<'a, $($T),+> {\n-                /// Construct a new, empty `TupleVisitor`.\n-                pub fn new(tuple: &'a ($($T,)+)) -> $TupleVisitor<'a, $($T),+> {\n-                    $TupleVisitor {\n-                        tuple: tuple,\n-                        state: 0,\n-                    }\n-                }\n-            }\n-\n-            impl<'a, $($T),+> SeqVisitor for $TupleVisitor<'a, $($T),+>\n-                where $($T: Serialize),+\n-            {\n-                fn visit<S>(&mut self, serializer: &mut S) -> Result<Option<()>, S::Error>\n-                    where S: Serializer,\n-                {\n-                    match self.state {\n-                        $(\n-                            $state => {\n-                                self.state += 1;\n-                                Ok(Some(try!(serializer.serialize_tuple_elt(&e!(self.tuple.$idx)))))\n-                            }\n-                        )+\n-                        _ => {\n-                            Ok(None)\n-                        }\n-                    }\n-                }\n-\n-                fn len(&self) -> Option<usize> {\n-                    Some($len)\n-                }\n-            }\n-\n             impl<$($T),+> Serialize for ($($T,)+)\n                 where $($T: Serialize),+\n             {\n                 #[inline]\n-                fn serialize<S: Serializer>(&self, serializer: &mut S) -> Result<(), S::Error> {\n-                    serializer.serialize_tuple($TupleVisitor::new(self))\n+                fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+                    where S: Serializer,\n+                {\n+                    let mut state = try!(serializer.serialize_tuple($len));\n+                    $(\n+                        try!(serializer.serialize_tuple_elt(&mut state, &e!(self.$idx)));\n+                    )+\n+                    serializer.serialize_tuple_end(state)\n                 }\n             }\n         )+\n@@ -638,83 +510,27 @@ tuple_impls! {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-/// A `serde::Visitor` for (key, value) map iterators.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::collections::HashMap;\n-/// use serde::{Serialize, Serializer};\n-/// use serde::ser::impls::MapIteratorVisitor;\n-///\n-/// struct Map(HashMap<u32, u32>);\n-///\n-/// impl Serialize for Map {\n-///     fn serialize<S>(&self, ser: &mut S) -> Result<(), S::Error>\n-///         where S: Serializer,\n-///     {\n-///         ser.serialize_map(MapIteratorVisitor::new(\n-///             self.0.iter(),\n-///             Some(self.0.len()),\n-///         ))\n-///     }\n-/// }\n-/// ```\n-pub struct MapIteratorVisitor<Iter> {\n-    iter: Iter,\n-    len: Option<usize>,\n-}\n-\n-impl<K, V, Iter> MapIteratorVisitor<Iter>\n-    where Iter: Iterator<Item=(K, V)>\n-{\n-    /// Construct a new `MapIteratorVisitor<Iter>`.\n-    #[inline]\n-    pub fn new(iter: Iter, len: Option<usize>) -> MapIteratorVisitor<Iter> {\n-        MapIteratorVisitor {\n-            iter: iter,\n-            len: len,\n-        }\n-    }\n-}\n-\n-impl<K, V, I> MapVisitor for MapIteratorVisitor<I>\n-    where K: Serialize,\n-          V: Serialize,\n-          I: Iterator<Item=(K, V)>,\n-{\n-    #[inline]\n-    fn visit<S>(&mut self, serializer: &mut S) -> Result<Option<()>, S::Error>\n-        where S: Serializer,\n-    {\n-        match self.iter.next() {\n-            Some((key, value)) => {\n-                try!(serializer.serialize_map_elt(key, value));\n-                Ok(Some(()))\n+macro_rules! serialize_map {\n+    () => {\n+        #[inline]\n+        fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+            where S: Serializer,\n+        {\n+            let mut state = try!(serializer.serialize_map(Some(self.len())));\n+            for (k, v) in self {\n+                try!(serializer.serialize_map_elt(&mut state, k, v));\n             }\n-            None => Ok(None)\n+            serializer.serialize_map_end(state)\n         }\n     }\n-\n-    #[inline]\n-    fn len(&self) -> Option<usize> {\n-        self.len\n-    }\n }\n \n-///////////////////////////////////////////////////////////////////////////////\n-\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<K, V> Serialize for BTreeMap<K, V>\n     where K: Serialize + Ord,\n           V: Serialize,\n {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n-        where S: Serializer,\n-    {\n-        serializer.serialize_map(MapIteratorVisitor::new(self.iter(), Some(self.len())))\n-    }\n+    serialize_map!();\n }\n \n #[cfg(feature = \"std\")]\n@@ -723,12 +539,7 @@ impl<K, V, H> Serialize for HashMap<K, V, H>\n           V: Serialize,\n           H: BuildHasher,\n {\n-    #[inline]\n-    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n-        where S: Serializer,\n-    {\n-        serializer.serialize_map(MapIteratorVisitor::new(self.iter(), Some(self.len())))\n-    }\n+    serialize_map!();\n }\n \n ///////////////////////////////////////////////////////////////////////////////\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 6040ea111..3e6bc244b 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -45,339 +45,323 @@ pub trait Serializer {\n     /// The error type that can be returned if some error occurs during serialization.\n     type Error: Error;\n \n+    /// A state object that is initialized by `serialize_seq`, passed to\n+    /// `serialize_seq_elt`, and consumed by `serialize_seq_end`. Use `()` if no\n+    /// state is required.\n+    type SeqState;\n+    /// A state object that is initialized by `serialize_tuple`, passed to\n+    /// `serialize_tuple_elt`, and consumed by `serialize_tuple_end`. Use `()`\n+    /// if no state is required.\n+    type TupleState;\n+    /// A state object that is initialized by `serialize_tuple_struct`, passed\n+    /// to `serialize_tuple_struct_elt`, and consumed by\n+    /// `serialize_tuple_struct_end`. Use `()` if no state is required.\n+    type TupleStructState;\n+    /// A state object that is initialized by `serialize_tuple_variant`, passed\n+    /// to `serialize_tuple_variant_elt`, and consumed by\n+    /// `serialize_tuple_variant_end`. Use `()` if no state is required.\n+    type TupleVariantState;\n+    /// A state object that is initialized by `serialize_map`, passed to\n+    /// `serialize_map_elt`, and consumed by `serialize_map_end`. Use `()` if no\n+    /// state is required.\n+    type MapState;\n+    /// A state object that is initialized by `serialize_struct`, passed to\n+    /// `serialize_struct_elt`, and consumed by `serialize_struct_end`. Use `()`\n+    /// if no state is required.\n+    type StructState;\n+    /// A state object that is initialized by `serialize_struct_variant`, passed\n+    /// to `serialize_struct_variant_elt`, and consumed by\n+    /// `serialize_struct_variant_end`. Use `()` if no state is required.\n+    type StructVariantState;\n+\n     /// Serializes a `bool` value.\n     fn serialize_bool(&mut self, v: bool) -> Result<(), Self::Error>;\n \n-    /// Serializes a `isize` value. By default it casts the value to a `i64` and\n-    /// passes it to the `serialize_i64` method.\n-    #[inline]\n-    fn serialize_isize(&mut self, v: isize) -> Result<(), Self::Error> {\n-        self.serialize_i64(v as i64)\n-    }\n+    /// Serializes an `isize` value. If the format does not differentiate\n+    /// between `isize` and `i64`, a reasonable implementation would be to cast\n+    /// the value to `i64` and forward to `serialize_i64`.\n+    fn serialize_isize(&mut self, v: isize) -> Result<(), Self::Error>;\n \n-    /// Serializes a `i8` value. By default it casts the value to a `i64` and\n-    /// passes it to the `serialize_i64` method.\n-    #[inline]\n-    fn serialize_i8(&mut self, v: i8) -> Result<(), Self::Error> {\n-        self.serialize_i64(v as i64)\n-    }\n+    /// Serializes an `i8` value. If the format does not differentiate between\n+    /// `i8` and `i64`, a reasonable implementation would be to cast the value\n+    /// to `i64` and forward to `serialize_i64`.\n+    fn serialize_i8(&mut self, v: i8) -> Result<(), Self::Error>;\n \n-    /// Serializes a `i16` value. By default it casts the value to a `i64` and\n-    /// passes it to the `serialize_i64` method.\n-    #[inline]\n-    fn serialize_i16(&mut self, v: i16) -> Result<(), Self::Error> {\n-        self.serialize_i64(v as i64)\n-    }\n+    /// Serializes an `i16` value. If the format does not differentiate between\n+    /// `i16` and `i64`, a reasonable implementation would be to cast the value\n+    /// to `i64` and forward to `serialize_i64`.\n+    fn serialize_i16(&mut self, v: i16) -> Result<(), Self::Error>;\n \n-    /// Serializes a `i32` value. By default it casts the value to a `i64` and\n-    /// passes it to the `serialize_i64` method.\n-    #[inline]\n-    fn serialize_i32(&mut self, v: i32) -> Result<(), Self::Error> {\n-        self.serialize_i64(v as i64)\n-    }\n+    /// Serializes an `i32` value. If the format does not differentiate between\n+    /// `i32` and `i64`, a reasonable implementation would be to cast the value\n+    /// to `i64` and forward to `serialize_i64`.\n+    fn serialize_i32(&mut self, v: i32) -> Result<(), Self::Error>;\n \n-    /// Serializes a `i64` value.\n-    #[inline]\n+    /// Serializes an `i64` value.\n     fn serialize_i64(&mut self, v: i64) -> Result<(), Self::Error>;\n \n-    /// Serializes a `usize` value. By default it casts the value to a `u64` and\n-    /// passes it to the `serialize_u64` method.\n-    #[inline]\n-    fn serialize_usize(&mut self, v: usize) -> Result<(), Self::Error> {\n-        self.serialize_u64(v as u64)\n-    }\n+    /// Serializes a `usize` value. If the format does not differentiate between\n+    /// `usize` and `u64`, a reasonable implementation would be to cast the\n+    /// value to `u64` and forward to `serialize_u64`.\n+    fn serialize_usize(&mut self, v: usize) -> Result<(), Self::Error>;\n \n-    /// Serializes a `u8` value. By default it casts the value to a `u64` and passes\n-    /// it to the `serialize_u64` method.\n-    #[inline]\n-    fn serialize_u8(&mut self, v: u8) -> Result<(), Self::Error> {\n-        self.serialize_u64(v as u64)\n-    }\n+    /// Serializes a `u8` value. If the format does not differentiate between\n+    /// `u8` and `u64`, a reasonable implementation would be to cast the value\n+    /// to `u64` and forward to `serialize_u64`.\n+    fn serialize_u8(&mut self, v: u8) -> Result<(), Self::Error>;\n \n-    /// Serializes a `u32` value. By default it casts the value to a `u64` and passes\n-    /// it to the `serialize_u64` method.\n-    #[inline]\n-    fn serialize_u16(&mut self, v: u16) -> Result<(), Self::Error> {\n-        self.serialize_u64(v as u64)\n-    }\n+    /// Serializes a `u16` value. If the format does not differentiate between\n+    /// `u16` and `u64`, a reasonable implementation would be to cast the value\n+    /// to `u64` and forward to `serialize_u64`.\n+    fn serialize_u16(&mut self, v: u16) -> Result<(), Self::Error>;\n \n-    /// Serializes a `u32` value. By default it casts the value to a `u64` and passes\n-    /// it to the `serialize_u64` method.\n-    #[inline]\n-    fn serialize_u32(&mut self, v: u32) -> Result<(), Self::Error> {\n-        self.serialize_u64(v as u64)\n-    }\n+    /// Serializes a `u32` value. If the format does not differentiate between\n+    /// `u32` and `u64`, a reasonable implementation would be to cast the value\n+    /// to `u64` and forward to `serialize_u64`.\n+    fn serialize_u32(&mut self, v: u32) -> Result<(), Self::Error>;\n \n     /// `Serializes a `u64` value.\n-    #[inline]\n     fn serialize_u64(&mut self, v: u64) -> Result<(), Self::Error>;\n \n-    /// Serializes a `f32` value. By default it casts the value to a `f64` and passes\n-    /// it to the `serialize_f64` method.\n-    #[inline]\n-    fn serialize_f32(&mut self, v: f32) -> Result<(), Self::Error> {\n-        self.serialize_f64(v as f64)\n-    }\n+    /// Serializes an `f32` value. If the format does not differentiate between\n+    /// `f32` and `f64`, a reasonable implementation would be to cast the value\n+    /// to `f64` and forward to `serialize_f64`.\n+    fn serialize_f32(&mut self, v: f32) -> Result<(), Self::Error>;\n \n-    /// Serializes a `f64` value.\n+    /// Serializes an `f64` value.\n     fn serialize_f64(&mut self, v: f64) -> Result<(), Self::Error>;\n \n-    /// Serializes a character. By default it serializes it as a `&str` containing a\n-    /// single character.\n-    #[inline]\n-    fn serialize_char(&mut self, v: char) -> Result<(), Self::Error> {\n-        self.serialize_str(::utils::encode_utf8(v).as_str())\n-    }\n+    /// Serializes a character.\n+    fn serialize_char(&mut self, v: char) -> Result<(), Self::Error>;\n \n     /// Serializes a `&str`.\n     fn serialize_str(&mut self, value: &str) -> Result<(), Self::Error>;\n \n-    /// Enables those serialization formats that support serializing\n-    /// byte slices separately from generic arrays. By default it serializes as a regular array.\n-    #[inline]\n-    fn serialize_bytes(&mut self, value: &[u8]) -> Result<(), Self::Error> {\n-        self.serialize_seq(impls::SeqIteratorVisitor::new(value.iter(), Some(value.len())))\n-    }\n+    /// Enables serializers to serialize byte slices more compactly or more\n+    /// efficiently than other types of slices. If no efficient implementation\n+    /// is available, a reasonable implementation would be to forward to\n+    /// `serialize_seq`.\n+    fn serialize_bytes(&mut self, value: &[u8]) -> Result<(), Self::Error>;\n \n     /// Serializes a `()` value.\n     fn serialize_unit(&mut self) -> Result<(), Self::Error>;\n \n-    /// Serializes a unit struct value.\n-    ///\n-    /// By default, unit structs are serialized as a `()`.\n-    #[inline]\n-    fn serialize_unit_struct(&mut self, _name: &'static str) -> Result<(), Self::Error> {\n-        self.serialize_unit()\n-    }\n-\n-    /// Serializes a unit variant, otherwise known as a variant with no arguments.\n-    ///\n-    /// By default, unit variants are serialized as a `()`.\n-    #[inline]\n-    fn serialize_unit_variant(&mut self,\n-                              _name: &'static str,\n-                              _variant_index: usize,\n-                              _variant: &'static str) -> Result<(), Self::Error> {\n-        self.serialize_unit()\n-    }\n-\n-    /// Allows a tuple struct with a single element, also known as a\n-    /// newtyped value, to be more efficiently serialized than a tuple struct with multiple items.\n-    /// By default it just serializes the value as a tuple struct sequence.\n-    #[inline]\n-    fn serialize_newtype_struct<T>(&mut self,\n-                                   name: &'static str,\n-                                   value: T) -> Result<(), Self::Error>\n-        where T: Serialize,\n-    {\n-        self.serialize_tuple_struct(name, Some(value))\n-    }\n-\n-    /// Allows a variant with a single item to be more efficiently\n-    /// serialized than a variant with multiple items. By default it just serializes the value as a\n-    /// tuple variant sequence.\n-    #[inline]\n-    fn serialize_newtype_variant<T>(&mut self,\n-                                    name: &'static str,\n-                                    variant_index: usize,\n-                                    variant: &'static str,\n-                                    value: T) -> Result<(), Self::Error>\n-        where T: Serialize,\n-    {\n-        self.serialize_tuple_variant(\n-            name,\n-            variant_index,\n-            variant,\n-            Some(value))\n-    }\n-\n-    /// Serializes a `None` value..serialize\n+    /// Serializes a unit struct value. A reasonable implementation would be to\n+    /// forward to `serialize_unit`.\n+    fn serialize_unit_struct(\n+        &mut self,\n+        name: &'static str,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Serializes a unit variant, otherwise known as a variant with no\n+    /// arguments. A reasonable implementation would be to forward to\n+    /// `serialize_unit`.\n+    fn serialize_unit_variant(\n+        &mut self,\n+        name: &'static str,\n+        variant_index: usize,\n+        variant: &'static str,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Allows a tuple struct with a single element, also known as a newtype\n+    /// struct, to be more efficiently serialized than a tuple struct with\n+    /// multiple items. A reasonable implementation would be to forward to\n+    /// `serialize_tuple_struct`.\n+    fn serialize_newtype_struct<T: Serialize>(\n+        &mut self,\n+        name: &'static str,\n+        value: T,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Allows a variant with a single item to be more efficiently serialized\n+    /// than a variant with multiple items. A reasonable implementation would be\n+    /// to forward to `serialize_tuple_variant`.\n+    fn serialize_newtype_variant<T: Serialize>(\n+        &mut self,\n+        name: &'static str,\n+        variant_index: usize,\n+        variant: &'static str,\n+        value: T,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Serializes a `None` value.\n     fn serialize_none(&mut self) -> Result<(), Self::Error>;\n \n     /// Serializes a `Some(...)` value.\n-    fn serialize_some<V>(&mut self, value: V) -> Result<(), Self::Error>\n-        where V: Serialize;\n-\n-    /// Serializes a sequence.\n-    ///\n-    /// Callees of this method need to construct a `SeqVisitor`, which iterates through each item\n-    /// in the sequence.\n-    fn serialize_seq<V>(&mut self, visitor: V) -> Result<(), Self::Error>\n-        where V: SeqVisitor;\n-\n-    /// Serializes a sequence element.\n-    fn serialize_seq_elt<T>(&mut self, value: T) -> Result<(), Self::Error>\n-        where T: Serialize;\n-\n-    /// Serializes a tuple.\n-    ///\n-    /// By default this serializes a tuple as a sequence.\n-    #[inline]\n-    fn serialize_tuple<V>(&mut self, visitor: V) -> Result<(), Self::Error>\n-        where V: SeqVisitor,\n-    {\n-        self.serialize_seq(visitor)\n-    }\n-\n-    /// Serializes a tuple element.\n-    ///\n-    /// By default, tuples are serialized as a sequence.\n-    #[inline]\n-    fn serialize_tuple_elt<T>(&mut self, value: T) -> Result<(), Self::Error>\n-        where T: Serialize\n-    {\n-        self.serialize_seq_elt(value)\n-    }\n-\n-    /// Serializes a fixed-size array.\n-    ///\n-    /// By default this serializes an array as a sequence.\n-    #[inline]\n-    fn serialize_fixed_size_array<V>(&mut self, visitor: V) -> Result<(), Self::Error>\n-        where V: SeqVisitor,\n-    {\n-        self.serialize_seq(visitor)\n-    }\n-\n-    /// Serializes a tuple struct.\n-    ///\n-    /// By default, tuple structs are serialized as a tuple.\n-    #[inline]\n-    fn serialize_tuple_struct<V>(&mut self,\n-                                 _name: &'static str,\n-                                 visitor: V) -> Result<(), Self::Error>\n-        where V: SeqVisitor,\n-    {\n-        self.serialize_tuple(visitor)\n-    }\n-\n-    /// Serializes a tuple struct element.\n-    ///\n-    /// By default, tuple struct elements are serialized as a tuple element.\n-    #[inline]\n-    fn serialize_tuple_struct_elt<T>(&mut self, value: T) -> Result<(), Self::Error>\n-        where T: Serialize\n-    {\n-        self.serialize_tuple_elt(value)\n-    }\n-\n-    /// Serializes a tuple variant.\n-    ///\n-    /// By default, tuple variants are serialized as a tuple struct.\n-    #[inline]\n-    fn serialize_tuple_variant<V>(&mut self,\n-                                  _name: &'static str,\n-                                  _variant_index: usize,\n-                                  variant: &'static str,\n-                                  visitor: V) -> Result<(), Self::Error>\n-        where V: SeqVisitor,\n-    {\n-        self.serialize_tuple_struct(variant, visitor)\n-    }\n-\n-    /// Serializes a tuple element.\n-    ///\n-    /// By default, tuples are serialized as a sequence.\n-    #[inline]\n-    fn serialize_tuple_variant_elt<T>(&mut self, value: T) -> Result<(), Self::Error>\n-        where T: Serialize\n-    {\n-        self.serialize_tuple_struct_elt(value)\n-    }\n-\n-    /// Serializes a map.\n-    ///\n-    /// Callees of this method need to construct a `MapVisitor`, which iterates through each item\n-    /// in the map.\n-    fn serialize_map<V>(&mut self, visitor: V) -> Result<(), Self::Error>\n-        where V: MapVisitor;\n-\n-    /// Serializes a map element (key-value pair).\n-    fn serialize_map_elt<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error>\n-        where K: Serialize,\n-              V: Serialize;\n-\n-    /// Serializes a struct.\n-    ///\n-    /// By default, structs are serialized as a map with the field name as the key.\n-    #[inline]\n-    fn serialize_struct<V>(&mut self,\n-                           _name: &'static str,\n-                           visitor: V) -> Result<(), Self::Error>\n-        where V: MapVisitor,\n-    {\n-        self.serialize_map(visitor)\n-    }\n-\n-    /// Serializes an element of a struct.\n-    ///\n-    /// By default, struct elements are serialized as a map element with the field name as the key.\n-    #[inline]\n-    fn serialize_struct_elt<V>(&mut self,\n-                               key: &'static str,\n-                               value: V) -> Result<(), Self::Error>\n-        where V: Serialize,\n-    {\n-        self.serialize_map_elt(key, value)\n-    }\n-\n-    /// Serializes a struct variant.\n-    ///\n-    /// By default, struct variants are serialized as a struct.\n-    #[inline]\n-    fn serialize_struct_variant<V>(&mut self,\n-                                   _name: &'static str,\n-                                   _variant_index: usize,\n-                                   variant: &'static str,\n-                                   visitor: V) -> Result<(), Self::Error>\n-        where V: MapVisitor,\n-    {\n-        self.serialize_struct(variant, visitor)\n-    }\n-\n-    /// Serializes an element of a struct variant.\n-    ///\n-    /// By default, struct variant elements are serialized as a struct element.\n-    #[inline]\n-    fn serialize_struct_variant_elt<V>(&mut self,\n-                                       key: &'static str,\n-                                       value: V) -> Result<(), Self::Error>\n-        where V: Serialize,\n-    {\n-        self.serialize_struct_elt(key, value)\n-    }\n-}\n-\n-/// A trait that is used by a `Serialize` to iterate through a sequence.\n-#[cfg_attr(feature = \"nightly-testing\", allow(len_without_is_empty))]\n-pub trait SeqVisitor {\n-    /// Serializes a sequence item in the serializer.\n-    ///\n-    /// This returns `Ok(Some(()))` when there are more items to serialize, or `Ok(None)` when\n-    /// complete.\n-    fn visit<S>(&mut self, serializer: &mut S) -> Result<Option<()>, S::Error>\n-        where S: Serializer;\n-\n-    /// Return the length of the sequence if known.\n-    #[inline]\n-    fn len(&self) -> Option<usize> {\n-        None\n-    }\n-}\n-\n-/// A trait that is used by a `Serialize` to iterate through a map.\n-#[cfg_attr(feature = \"nightly-testing\", allow(len_without_is_empty))]\n-pub trait MapVisitor {\n-    /// Serializes a map item in the serializer.\n-    ///\n-    /// This returns `Ok(Some(()))` when there are more items to serialize, or `Ok(None)` when\n-    /// complete.\n-    fn visit<S>(&mut self, serializer: &mut S) -> Result<Option<()>, S::Error>\n-        where S: Serializer;\n-\n-    /// Return the length of the map if known.\n-    #[inline]\n-    fn len(&self) -> Option<usize> {\n-        None\n-    }\n+    fn serialize_some<T: Serialize>(\n+        &mut self,\n+        value: T,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Begins to serialize a sequence. This call must be followed by zero or\n+    /// more calls to `serialize_seq_elt`, then a call to `serialize_seq_end`.\n+    fn serialize_seq(\n+        &mut self,\n+        len: Option<usize>,\n+    ) -> Result<Self::SeqState, Self::Error>;\n+\n+    /// Serializes a sequence element. Must have previously called\n+    /// `serialize_seq`.\n+    fn serialize_seq_elt<T: Serialize>(\n+        &mut self,\n+        state: &mut Self::SeqState,\n+        value: T,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Finishes serializing a sequence.\n+    fn serialize_seq_end(\n+        &mut self,\n+        state: Self::SeqState,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Begins to serialize a sequence whose length will be known at\n+    /// deserialization time. This call must be followed by zero or more calls\n+    /// to `serialize_seq_elt`, then a call to `serialize_seq_end`. A reasonable\n+    /// implementation would be to forward to `serialize_seq`.\n+    fn serialize_seq_fixed_size(\n+        &mut self,\n+        size: usize,\n+    ) -> Result<Self::SeqState, Self::Error>;\n+\n+    /// Begins to serialize a tuple. This call must be followed by zero or more\n+    /// calls to `serialize_tuple_elt`, then a call to `serialize_tuple_end`. A\n+    /// reasonable implementation would be to forward to `serialize_seq`.\n+    fn serialize_tuple(\n+        &mut self,\n+        len: usize,\n+    ) -> Result<Self::TupleState, Self::Error>;\n+\n+    /// Serializes a tuple element. Must have previously called\n+    /// `serialize_tuple`.\n+    fn serialize_tuple_elt<T: Serialize>(\n+        &mut self,\n+        state: &mut Self::TupleState,\n+        value: T,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Finishes serializing a tuple.\n+    fn serialize_tuple_end(\n+        &mut self,\n+        state: Self::TupleState,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Begins to serialize a tuple struct. This call must be followed by zero\n+    /// or more calls to `serialize_tuple_struct_elt`, then a call to\n+    /// `serialize_tuple_struct_end`. A reasonable implementation would be to\n+    /// forward to `serialize_tuple`.\n+    fn serialize_tuple_struct(\n+        &mut self,\n+        name: &'static str,\n+        len: usize,\n+    ) -> Result<Self::TupleStructState, Self::Error>;\n+\n+    /// Serializes a tuple struct element. Must have previously called\n+    /// `serialize_tuple_struct`.\n+    fn serialize_tuple_struct_elt<T: Serialize>(\n+        &mut self,\n+        state: &mut Self::TupleStructState,\n+        value: T,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Finishes serializing a tuple struct.\n+    fn serialize_tuple_struct_end(\n+        &mut self,\n+        state: Self::TupleStructState,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Begins to serialize a tuple variant. This call must be followed by zero\n+    /// or more calls to `serialize_tuple_variant_elt`, then a call to\n+    /// `serialize_tuple_variant_end`. A reasonable implementation would be to\n+    /// forward to `serialize_tuple_struct`.\n+    fn serialize_tuple_variant(\n+        &mut self,\n+        name: &'static str,\n+        variant_index: usize,\n+        variant: &'static str,\n+        len: usize,\n+    ) -> Result<Self::TupleVariantState, Self::Error>;\n+\n+    /// Serializes a tuple variant element. Must have previously called\n+    /// `serialize_tuple_variant`.\n+    fn serialize_tuple_variant_elt<T: Serialize>(\n+        &mut self,\n+        state: &mut Self::TupleVariantState,\n+        value: T,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Finishes serializing a tuple variant.\n+    fn serialize_tuple_variant_end(\n+        &mut self,\n+        state: Self::TupleVariantState,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Begins to serialize a map. This call must be followed by zero or more\n+    /// calls to `serialize_map_elt`, then a call to `serialize_map_end`.\n+    fn serialize_map(\n+        &mut self,\n+        len: Option<usize>,\n+    ) -> Result<Self::MapState, Self::Error>;\n+\n+    /// Serialize a map element. Must have previously called `serialize_map`.\n+    fn serialize_map_elt<K: Serialize, V: Serialize>(\n+        &mut self,\n+        state: &mut Self::MapState,\n+        key: K,\n+        value: V,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Finishes serializing a map.\n+    fn serialize_map_end(\n+        &mut self,\n+        state: Self::MapState,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Begins to serialize a struct. This call must be followed by zero or more\n+    /// calls to `serialize_struct_elt`, then a call to `serialize_struct_end`.\n+    fn serialize_struct(\n+        &mut self,\n+        name: &'static str,\n+        len: usize,\n+    ) -> Result<Self::StructState, Self::Error>;\n+\n+    /// Serializes a struct field. Must have previously called\n+    /// `serialize_struct`.\n+    fn serialize_struct_elt<V: Serialize>(\n+        &mut self,\n+        state: &mut Self::StructState,\n+        key: &'static str,\n+        value: V,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Finishes serializing a struct.\n+    fn serialize_struct_end(\n+        &mut self,\n+        state: Self::StructState,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Begins to serialize a struct variant. This call must be followed by zero\n+    /// or more calls to `serialize_struct_variant_elt`, then a call to\n+    /// `serialize_struct_variant_end`.\n+    fn serialize_struct_variant(\n+        &mut self,\n+        name: &'static str,\n+        variant_index: usize,\n+        variant: &'static str,\n+        len: usize,\n+    ) -> Result<Self::StructVariantState, Self::Error>;\n+\n+    /// Serialize a struct variant element. Must have previously called\n+    /// `serialize_struct_variant`.\n+    fn serialize_struct_variant_elt<V: Serialize>(\n+        &mut self,\n+        state: &mut Self::StructVariantState,\n+        key: &'static str,\n+        value: V,\n+    ) -> Result<(), Self::Error>;\n+\n+    /// Finishes serializing a struct variant.\n+    fn serialize_struct_variant_end(\n+        &mut self,\n+        state: Self::StructVariantState,\n+    ) -> Result<(), Self::Error>;\n }\ndiff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex 3f549c0ff..9937c33bb 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -216,30 +216,23 @@ fn serialize_tuple_struct(\n     fields: &[Field],\n     item_attrs: &attr::Item,\n ) -> P<ast::Expr> {\n-    let (visitor_struct, visitor_impl) = serialize_tuple_struct_visitor(\n+    let serialize_stmts = serialize_tuple_struct_visitor(\n         cx,\n         builder,\n         ty.clone(),\n-        builder.ty()\n-            .ref_()\n-            .lifetime(\"'__a\")\n-            .build_ty(ty.clone()),\n-        builder.id(\"serialize_tuple_struct_elt\"),\n         fields,\n         impl_generics,\n         false,\n+        cx.ident_of(\"serialize_tuple_struct_elt\"),\n     );\n \n     let type_name = name_expr(builder, item_attrs.name());\n+    let len = serialize_stmts.len();\n \n     quote_expr!(cx, {\n-        $visitor_struct\n-        $visitor_impl\n-        _serializer.serialize_tuple_struct($type_name, Visitor {\n-            value: self,\n-            state: 0,\n-            _structure_ty: ::std::marker::PhantomData::<&$ty>,\n-        })\n+        let mut state = try!(_serializer.serialize_tuple_struct($type_name, $len));\n+        $serialize_stmts\n+        _serializer.serialize_tuple_struct_end(state)\n     })\n }\n \n@@ -251,30 +244,34 @@ fn serialize_struct(\n     fields: &[Field],\n     item_attrs: &attr::Item,\n ) -> P<ast::Expr> {\n-    let (visitor_struct, visitor_impl) = serialize_struct_visitor(\n+    let serialize_fields = serialize_struct_visitor(\n         cx,\n         builder,\n         ty.clone(),\n-        builder.ty()\n-            .ref_()\n-            .lifetime(\"'__a\")\n-            .build_ty(ty.clone()),\n-        builder.id(\"serialize_struct_elt\"),\n         fields,\n         impl_generics,\n         false,\n+        cx.ident_of(\"serialize_struct_elt\"),\n     );\n \n     let type_name = name_expr(builder, item_attrs.name());\n+    let len = fields.iter()\n+        .filter(|&field| !field.attrs.skip_serializing())\n+        .map(|field| {\n+            let ident = field.ident.expect(\"struct has unnamed fields\");\n+            let field_expr = quote_expr!(cx, &self.$ident);\n+\n+            match field.attrs.skip_serializing_if() {\n+                Some(path) => quote_expr!(cx, if $path($field_expr) { 0 } else { 1 }),\n+                None => quote_expr!(cx, 1),\n+            }\n+         })\n+        .fold(quote_expr!(cx, 0), |sum, expr| quote_expr!(cx, $sum + $expr));\n \n     quote_expr!(cx, {\n-        $visitor_struct\n-        $visitor_impl\n-        _serializer.serialize_struct($type_name, Visitor {\n-            value: self,\n-            state: 0,\n-            _structure_ty: ::std::marker::PhantomData::<&$ty>,\n-        })\n+        let mut state = try!(_serializer.serialize_struct($type_name, $len));\n+        $serialize_fields\n+        _serializer.serialize_struct_end(state)\n     })\n }\n \n@@ -377,7 +374,6 @@ fn serialize_variant(\n                 generics,\n                 ty,\n                 &variant.fields,\n-                field_names,\n             );\n \n             quote_arm!(cx,\n@@ -385,27 +381,19 @@ fn serialize_variant(\n             )\n         }\n         Style::Struct => {\n-            let field_names: Vec<_> = (0 .. variant.fields.len())\n-                .map(|i| builder.id(format!(\"__field{}\", i)))\n-                .collect();\n-\n-            let pat = builder.pat().struct_()\n-                .id(type_ident).id(variant_ident).build()\n-                .with_pats(\n-                    field_names.iter()\n-                        .zip(variant.fields.iter())\n-                        .map(|(id, field)| {\n-                            let name = match field.ident {\n-                                Some(name) => name,\n-                                None => {\n-                                    cx.span_bug(field.span, \"struct variant has unnamed fields\")\n-                                }\n-                            };\n-\n-                            (name, builder.pat().ref_id(id))\n-                        })\n-                )\n-                .build();\n+            let mut pat = builder.pat().struct_().id(type_ident).id(variant_ident).build();\n+            for field in variant.fields.iter() {\n+                let name = match field.ident {\n+                    Some(name) => name,\n+                    None => cx.span_bug(field.span, \"struct variant has unnamed fields\"),\n+                };\n+                pat = pat.with_field_pat(ast::FieldPat {\n+                    ident: name,\n+                    pat: builder.pat().ref_id(name),\n+                    is_shorthand: true,\n+                });\n+            }\n+            let pat = pat.build();\n \n             let expr = serialize_struct_variant(\n                 cx,\n@@ -415,7 +403,6 @@ fn serialize_variant(\n                 generics,\n                 ty,\n                 &variant.fields,\n-                field_names,\n                 item_attrs,\n             );\n \n@@ -462,46 +449,23 @@ fn serialize_tuple_variant(\n     generics: &ast::Generics,\n     structure_ty: P<ast::Ty>,\n     fields: &[Field],\n-    field_names: Vec<Ident>,\n ) -> P<ast::Expr> {\n-    let variant_ty = builder.ty().tuple()\n-        .with_tys(\n-            fields.iter().map(|field| {\n-                builder.ty()\n-                    .ref_()\n-                    .lifetime(\"'__a\")\n-                    .build_ty(field.ty.clone())\n-            })\n-        )\n-        .build();\n-\n-    let (visitor_struct, visitor_impl) = serialize_tuple_struct_visitor(\n+    let serialize_stmts = serialize_tuple_struct_visitor(\n         cx,\n         builder,\n-        structure_ty.clone(),\n-        variant_ty,\n-        builder.id(\"serialize_tuple_variant_elt\"),\n+        structure_ty,\n         fields,\n         generics,\n         true,\n+        cx.ident_of(\"serialize_tuple_variant_elt\"),\n     );\n \n-    let value_expr = builder.expr().tuple()\n-        .with_exprs(\n-            field_names.iter().map(|field| {\n-                builder.expr().id(field)\n-            })\n-        )\n-        .build();\n+    let len = serialize_stmts.len();\n \n     quote_expr!(cx, {\n-        $visitor_struct\n-        $visitor_impl\n-        _serializer.serialize_tuple_variant($type_name, $variant_index, $variant_name, Visitor {\n-            value: $value_expr,\n-            state: 0,\n-            _structure_ty: ::std::marker::PhantomData::<&$structure_ty>,\n-        })\n+        let mut state = try!(_serializer.serialize_tuple_variant($type_name, $variant_index, $variant_name, $len));\n+        $serialize_stmts\n+        _serializer.serialize_tuple_variant_end(state)\n     })\n }\n \n@@ -513,83 +477,42 @@ fn serialize_struct_variant(\n     generics: &ast::Generics,\n     ty: P<ast::Ty>,\n     fields: &[Field],\n-    field_names: Vec<Ident>,\n     item_attrs: &attr::Item,\n ) -> P<ast::Expr> {\n-    let variant_generics = builder.generics()\n-        .with(generics.clone())\n-        .add_lifetime_bound(\"'__serde_variant\")\n-        .lifetime_name(\"'__serde_variant\")\n-        .build();\n-\n-    let variant_struct = builder.item().struct_(\"__VariantStruct\")\n-        .with_generics(variant_generics.clone())\n-        .with_fields(\n-            fields.iter().map(|field| {\n-                builder.struct_field(field.ident.expect(\"struct has unnamed fields\"))\n-                    .ty()\n-                    .ref_()\n-                    .lifetime(\"'__serde_variant\")\n-                    .build_ty(field.ty.clone())\n-            })\n-        )\n-        .field(\"__serde_container_ty\")\n-            .ty().phantom_data().build(ty.clone())\n-        .build();\n-\n-    let variant_expr = builder.expr().struct_id(\"__VariantStruct\")\n-        .with_id_exprs(\n-            fields.iter()\n-                .zip(field_names.iter())\n-                .map(|(field, field_name)| {\n-                    (\n-                        field.ident.expect(\"struct has unnamed fields\"),\n-                        builder.expr().id(field_name),\n-                    )\n-                })\n-        )\n-        .field(\"__serde_container_ty\").path()\n-            .global()\n-            .id(\"std\").id(\"marker\")\n-            .segment(\"PhantomData\")\n-                .with_ty(ty.clone())\n-                .build()\n-            .build()\n-        .build();\n-\n-    let variant_ty = builder.ty().path()\n-        .segment(\"__VariantStruct\")\n-            .with_generics(variant_generics.clone())\n-            .build()\n-        .build();\n \n-    let (visitor_struct, visitor_impl) = serialize_struct_visitor(\n+    let serialize_fields = serialize_struct_visitor(\n         cx,\n         builder,\n-        variant_ty.clone(),\n-        variant_ty.clone(),\n-        builder.id(\"serialize_struct_variant_elt\"),\n+        ty.clone(),\n         fields,\n-        &variant_generics,\n+        &generics,\n         true,\n+        cx.ident_of(\"serialize_struct_variant_elt\"),\n     );\n \n     let item_name = name_expr(builder, item_attrs.name());\n+    let len = fields.iter()\n+        .filter(|&field| !field.attrs.skip_serializing())\n+        .map(|field| {\n+            let ident = field.ident.expect(\"struct has unnamed fields\");\n+            let field_expr = quote_expr!(cx, $ident);\n+\n+            match field.attrs.skip_serializing_if() {\n+                Some(path) => quote_expr!(cx, if $path($field_expr) { 0 } else { 1 }),\n+                None => quote_expr!(cx, 1),\n+            }\n+         })\n+        .fold(quote_expr!(cx, 0), |sum, expr| quote_expr!(cx, $sum + $expr));\n \n     quote_expr!(cx, {\n-        $variant_struct\n-        $visitor_struct\n-        $visitor_impl\n-        _serializer.serialize_struct_variant(\n+        let mut state = try!(_serializer.serialize_struct_variant(\n             $item_name,\n             $variant_index,\n             $variant_name,\n-            Visitor {\n-                value: $variant_expr,\n-                state: 0,\n-                _structure_ty: ::std::marker::PhantomData,\n-            },\n-        )\n+            $len,\n+        ));\n+        $serialize_fields\n+        _serializer.serialize_struct_variant_end(state)\n     })\n }\n \n@@ -597,187 +520,75 @@ fn serialize_tuple_struct_visitor(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n     structure_ty: P<ast::Ty>,\n-    variant_ty: P<ast::Ty>,\n-    serializer_method: ast::Ident,\n     fields: &[Field],\n     generics: &ast::Generics,\n     is_enum: bool,\n-) -> (P<ast::Item>, P<ast::Item>) {\n-    let arms: Vec<_> = fields.iter()\n+    func: ast::Ident,\n+) -> Vec<ast::Stmt> {\n+    fields.iter()\n         .enumerate()\n         .map(|(i, field)| {\n-            let mut field_expr = builder.expr().tup_field(i).field(\"value\").self_();\n-            if !is_enum {\n-                field_expr = quote_expr!(cx, &$field_expr);\n-            }\n+            let mut field_expr = if is_enum {\n+                builder.expr().path().id(format!(\"__field{}\", i)).build()\n+            } else {\n+                builder.expr().ref_().tup_field(i).self_()\n+            };\n \n-            let continue_if_skip = field.attrs.skip_serializing_if()\n-                .map(|path| quote_stmt!(cx, if $path($field_expr) { continue }));\n+            let skip = field.attrs.skip_serializing_if()\n+                .map(|path| quote_expr!(cx, $path($field_expr)))\n+                .unwrap_or(quote_expr!(cx, false));\n \n             if let Some(path) = field.attrs.serialize_with() {\n                 field_expr = wrap_serialize_with(cx, builder,\n                     &structure_ty, generics, &field.ty, path, field_expr);\n             }\n \n-            quote_arm!(cx,\n-                $i => {\n-                    self.state += 1;\n-                    $continue_if_skip\n-                    Ok(Some(try!(_serializer.$serializer_method($field_expr))))\n+            quote_stmt!(cx,\n+                if !$skip {\n+                    try!(_serializer.$func(&mut state, $field_expr));\n                 }\n-            )\n+            ).unwrap()\n         })\n-        .collect();\n-\n-    let visitor_impl_generics = builder.from_generics(generics.clone())\n-        .add_lifetime_bound(\"'__a\")\n-        .lifetime_name(\"'__a\")\n-        .build();\n-\n-    let where_clause = &visitor_impl_generics.where_clause;\n-\n-    let visitor_generics = builder.from_generics(visitor_impl_generics.clone())\n-        .strip_bounds()\n-        .build();\n-\n-    let nfields = fields.len();\n-\n-    (\n-        quote_item!(cx,\n-            struct Visitor $visitor_impl_generics $where_clause {\n-                state: usize,\n-                value: $variant_ty,\n-                _structure_ty: ::std::marker::PhantomData<&'__a $structure_ty>,\n-            }\n-        ).unwrap(),\n-\n-        quote_item!(cx,\n-            impl $visitor_impl_generics _serde::ser::SeqVisitor\n-            for Visitor $visitor_generics\n-            $where_clause {\n-                #[inline]\n-                fn visit<__S>(&mut self, _serializer: &mut __S) -> ::std::result::Result<Option<()>, __S::Error>\n-                    where __S: _serde::ser::Serializer\n-                {\n-                    match self.state {\n-                        $arms\n-                        _ => Ok(None)\n-                    }\n-                }\n-\n-                #[inline]\n-                fn len(&self) -> Option<usize> {\n-                    Some($nfields)\n-                }\n-            }\n-        ).unwrap(),\n-    )\n+        .collect()\n }\n \n fn serialize_struct_visitor(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n     structure_ty: P<ast::Ty>,\n-    variant_ty: P<ast::Ty>,\n-    serializer_method: ast::Ident,\n     fields: &[Field],\n     generics: &ast::Generics,\n     is_enum: bool,\n-) -> (P<ast::Item>, P<ast::Item>) {\n-    let arms: Vec<ast::Arm> = fields.iter()\n+    func: ast::Ident,\n+) -> Vec<ast::Stmt> {\n+    fields.iter()\n         .filter(|&field| !field.attrs.skip_serializing())\n-        .enumerate()\n-        .map(|(i, field)| {\n+        .map(|field| {\n             let ident = field.ident.expect(\"struct has unnamed field\");\n-            let mut field_expr = quote_expr!(cx, self.value.$ident);\n-            if !is_enum {\n-                field_expr = quote_expr!(cx, &$field_expr);\n-            }\n+            let mut field_expr = if is_enum {\n+                quote_expr!(cx, $ident)\n+            } else {\n+                quote_expr!(cx, &self.$ident)\n+            };\n \n             let key_expr = name_expr(builder, field.attrs.name());\n \n-            let continue_if_skip = field.attrs.skip_serializing_if()\n-                .map(|path| quote_stmt!(cx, if $path($field_expr) { continue }));\n+            let skip = field.attrs.skip_serializing_if()\n+                .map(|path| quote_expr!(cx, $path($field_expr)))\n+                .unwrap_or(quote_expr!(cx, false));\n \n             if let Some(path) = field.attrs.serialize_with() {\n                 field_expr = wrap_serialize_with(cx, builder,\n                     &structure_ty, generics, &field.ty, path, field_expr)\n             }\n \n-            let expr = quote_expr!(cx,\n-                _serializer.$serializer_method($key_expr, $field_expr)\n-            );\n-\n-            quote_arm!(cx,\n-                $i => {\n-                    self.state += 1;\n-                    $continue_if_skip\n-                    return Ok(Some(try!($expr)));\n+            quote_stmt!(cx,\n+                if !$skip {\n+                    try!(_serializer.$func(&mut state, $key_expr, $field_expr));\n                 }\n-            )\n+            ).unwrap()\n         })\n-        .collect();\n-\n-    let visitor_impl_generics = builder.from_generics(generics.clone())\n-        .add_lifetime_bound(\"'__a\")\n-        .lifetime_name(\"'__a\")\n-        .build();\n-\n-    let where_clause = &visitor_impl_generics.where_clause;\n-\n-    let visitor_generics = builder.from_generics(visitor_impl_generics.clone())\n-        .strip_bounds()\n-        .build();\n-\n-    let len = fields.iter()\n-        .filter(|&field| !field.attrs.skip_serializing())\n-        .map(|field| {\n-            let ident = field.ident.expect(\"struct has unnamed fields\");\n-            let mut field_expr = quote_expr!(cx, self.value.$ident);\n-            if !is_enum {\n-                field_expr = quote_expr!(cx, &$field_expr);\n-            }\n-\n-            match field.attrs.skip_serializing_if() {\n-                Some(path) => quote_expr!(cx, if $path($field_expr) { 0 } else { 1 }),\n-                None => quote_expr!(cx, 1),\n-            }\n-        })\n-        .fold(quote_expr!(cx, 0), |sum, expr| quote_expr!(cx, $sum + $expr));\n-\n-    (\n-        quote_item!(cx,\n-            struct Visitor $visitor_impl_generics $where_clause {\n-                state: usize,\n-                value: $variant_ty,\n-                _structure_ty: ::std::marker::PhantomData<&'__a $structure_ty>,\n-            }\n-        ).unwrap(),\n-\n-        quote_item!(cx,\n-            impl $visitor_impl_generics\n-            _serde::ser::MapVisitor\n-            for Visitor $visitor_generics\n-            $where_clause {\n-                #[inline]\n-                fn visit<__S>(&mut self, _serializer: &mut __S) -> ::std::result::Result<Option<()>, __S::Error>\n-                    where __S: _serde::ser::Serializer,\n-                {\n-                    loop {\n-                        match self.state {\n-                            $arms\n-                            _ => { return Ok(None); }\n-                        }\n-                    }\n-                }\n-\n-                #[inline]\n-                fn len(&self) -> Option<usize> {\n-                    Some($len)\n-                }\n-            }\n-        ).unwrap(),\n-    )\n+        .collect()\n }\n \n fn wrap_serialize_with(\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex a2d4c3d7d..24dabe194 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -135,15 +135,18 @@ impl<I> de::Deserializer for Deserializer<I>\n             Some(Token::Option(true)) => visitor.visit_some(self),\n             Some(Token::Unit) => visitor.visit_unit(),\n             Some(Token::UnitStruct(name)) => visitor.visit_unit_struct(name),\n-            Some(Token::SeqStart(len)) | Some(Token::TupleStructStart(_, len)) => {\n+            Some(Token::SeqStart(len)) => {\n                 self.visit_seq(len, visitor)\n             }\n-            Some(Token::SeqArrayStart(len)) => {\n+            Some(Token::SeqArrayStart(len))| Some(Token::TupleStructStart(_, len)) => {\n                 self.visit_seq(Some(len), visitor)\n             }\n-            Some(Token::MapStart(len)) | Some(Token::StructStart(_, len)) => {\n+            Some(Token::MapStart(len)) => {\n                 self.visit_map(len, visitor)\n             }\n+            Some(Token::StructStart(_, len)) => {\n+                self.visit_map(Some(len), visitor)\n+            }\n             Some(token) => Err(Error::UnexpectedToken(token)),\n             None => Err(Error::EndOfStream),\n         }\n@@ -745,7 +748,7 @@ impl<'a, I> VariantVisitor for DeserializerVariantVisitor<'a, I>\n         where V: Visitor,\n     {\n         match self.de.tokens.peek() {\n-            Some(&Token::EnumSeqStart(_, _, Some(enum_len))) => {\n+            Some(&Token::EnumSeqStart(_, _, enum_len)) => {\n                 let token = self.de.tokens.next().unwrap();\n \n                 if len == enum_len {\n@@ -776,7 +779,7 @@ impl<'a, I> VariantVisitor for DeserializerVariantVisitor<'a, I>\n         where V: Visitor,\n     {\n         match self.de.tokens.peek() {\n-            Some(&Token::EnumMapStart(_, _, Some(enum_len))) => {\n+            Some(&Token::EnumMapStart(_, _, enum_len)) => {\n                 let token = self.de.tokens.next().unwrap();\n \n                 if fields.len() == enum_len {\ndiff --git a/serde_test/src/ser.rs b/serde_test/src/ser.rs\nindex 2f028d3b2..aa0f81860 100644\n--- a/serde_test/src/ser.rs\n+++ b/serde_test/src/ser.rs\n@@ -2,8 +2,6 @@ use std::marker::PhantomData;\n \n use serde::ser::{\n     self,\n-    MapVisitor,\n-    SeqVisitor,\n     Serialize,\n };\n \n@@ -30,32 +28,19 @@ impl<'a, I> Serializer<'a, I>\n     pub fn next_token(&mut self) -> Option<&'a Token<'a>> {\n         self.tokens.next()\n     }\n-\n-    fn visit_seq<V>(&mut self, mut visitor: V) -> Result<(), Error>\n-        where V: SeqVisitor\n-    {\n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::SeqEnd));\n-\n-        Ok(())\n-    }\n-\n-    fn visit_map<V>(&mut self, mut visitor: V) -> Result<(), Error>\n-        where V: MapVisitor\n-    {\n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::MapEnd));\n-\n-        Ok(())\n-    }\n }\n \n impl<'a, I> ser::Serializer for Serializer<'a, I>\n     where I: Iterator<Item=&'a Token<'a>>,\n {\n     type Error = Error;\n+    type MapState = ();\n+    type SeqState = ();\n+    type TupleState = ();\n+    type TupleStructState = ();\n+    type TupleVariantState = ();\n+    type StructState = ();\n+    type StructVariantState = ();\n \n     fn serialize_unit(&mut self) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::Unit));\n@@ -174,177 +159,162 @@ impl<'a, I> ser::Serializer for Serializer<'a, I>\n         value.serialize(self)\n     }\n \n-\n-    fn serialize_seq<V>(&mut self, visitor: V) -> Result<(), Error>\n-        where V: SeqVisitor\n+    fn serialize_seq<'b>(&'b mut self, len: Option<usize>) -> Result<(), Error>\n     {\n-        let len = visitor.len();\n-\n         assert_eq!(self.tokens.next(), Some(&Token::SeqStart(len)));\n-\n-        self.visit_seq(visitor)\n-    }\n-\n-    fn serialize_fixed_size_array<V>(&mut self, visitor: V) -> Result<(), Error>\n-        where V: SeqVisitor\n-    {\n-        let len = visitor.len().expect(\"arrays must have a length\");\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::SeqArrayStart(len)));\n-\n-        self.visit_seq(visitor)\n+        Ok(())\n     }\n \n-    fn serialize_seq_elt<T>(&mut self, value: T) -> Result<(), Error>\n+    fn serialize_seq_elt<T>(&mut self, _: &mut (), value: T) -> Result<(), Error>\n         where T: Serialize\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::SeqSep));\n         value.serialize(self)\n     }\n \n-    fn serialize_tuple<V>(&mut self, mut visitor: V) -> Result<(), Error>\n-        where V: SeqVisitor\n+    fn serialize_seq_end(&mut self, _: ()) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::SeqEnd));\n+        Ok(())\n+    }\n+\n+    fn serialize_seq_fixed_size(&mut self, len: usize) -> Result<(), Error>\n     {\n-        let len = visitor.len().expect(\"arrays must have a length\");\n+        assert_eq!(self.tokens.next(), Some(&Token::SeqArrayStart(len)));\n+        Ok(())\n+    }\n \n+    fn serialize_tuple(&mut self, len: usize) -> Result<(), Error>\n+    {\n         assert_eq!(self.tokens.next(), Some(&Token::TupleStart(len)));\n-\n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::TupleEnd));\n-\n         Ok(())\n     }\n \n-    fn serialize_tuple_elt<T>(&mut self, value: T) -> Result<(), Error>\n+    fn serialize_tuple_elt<T>(&mut self, _: &mut (), value: T) -> Result<(), Error>\n         where T: Serialize\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::TupleSep));\n         value.serialize(self)\n     }\n \n+    fn serialize_tuple_end(&mut self, _: ()) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleEnd));\n+        Ok(())\n+    }\n+\n     fn serialize_newtype_struct<T>(&mut self,\n-                               name: &'static str,\n-                               value: T) -> Result<(), Error>\n+                                   name: &'static str,\n+                                   value: T) -> Result<(), Error>\n         where T: Serialize,\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::StructNewType(name)));\n         value.serialize(self)\n     }\n \n-    fn serialize_tuple_struct<V>(&mut self, name: &str, mut visitor: V) -> Result<(), Error>\n-        where V: SeqVisitor\n+    fn serialize_tuple_struct(&mut self, name: &'static str, len: usize) -> Result<(), Error>\n     {\n-        let len = visitor.len();\n-\n         assert_eq!(self.tokens.next(), Some(&Token::TupleStructStart(name, len)));\n \n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::TupleStructEnd));\n-\n         Ok(())\n     }\n \n-    fn serialize_tuple_struct_elt<T>(&mut self, value: T) -> Result<(), Error>\n-        where T: Serialize,\n+    fn serialize_tuple_struct_elt<T>(&mut self, _: &mut (), value: T) -> Result<(), Error>\n+        where T: Serialize\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::TupleStructSep));\n         value.serialize(self)\n     }\n \n-    fn serialize_tuple_variant<V>(&mut self,\n-                                  name: &str,\n-                                  _variant_index: usize,\n-                                  variant: &str,\n-                                  mut visitor: V) -> Result<(), Error>\n-        where V: SeqVisitor\n-    {\n-        let len = visitor.len();\n+    fn serialize_tuple_struct_end(&mut self, _: ()) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleStructEnd));\n+        Ok(())\n+    }\n \n+    fn serialize_tuple_variant(&mut self,\n+                               name: &str,\n+                               _variant_index: usize,\n+                               variant: &str,\n+                               len: usize) -> Result<(), Error>\n+    {\n         assert_eq!(self.tokens.next(), Some(&Token::EnumSeqStart(name, variant, len)));\n \n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::EnumSeqEnd));\n-\n         Ok(())\n     }\n \n-    fn serialize_tuple_variant_elt<T>(&mut self, value: T) -> Result<(), Error>\n-        where T: Serialize,\n+    fn serialize_tuple_variant_elt<T>(&mut self, _: &mut (), value: T) -> Result<(), Error>\n+        where T: Serialize\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::EnumSeqSep));\n         value.serialize(self)\n     }\n \n-    fn serialize_map<V>(&mut self, visitor: V) -> Result<(), Error>\n-        where V: MapVisitor\n-    {\n-        let len = visitor.len();\n+    fn serialize_tuple_variant_end(&mut self, _: ()) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::EnumSeqEnd));\n+        Ok(())\n+    }\n \n+    fn serialize_map(&mut self, len: Option<usize>) -> Result<(), Error>\n+    {\n         assert_eq!(self.tokens.next(), Some(&Token::MapStart(len)));\n \n-        self.visit_map(visitor)\n+        Ok(())\n     }\n \n-    fn serialize_map_elt<K, V>(&mut self, key: K, value: V) -> Result<(), Error>\n-        where K: Serialize,\n-              V: Serialize,\n-    {\n+    fn serialize_map_elt<K, V>(&mut self, _: &mut (), key: K, value: V) -> Result<(), Self::Error> where K: Serialize, V: Serialize {\n         assert_eq!(self.tokens.next(), Some(&Token::MapSep));\n-\n         try!(key.serialize(self));\n         value.serialize(self)\n     }\n \n-    fn serialize_struct<V>(&mut self, name: &str, mut visitor: V) -> Result<(), Error>\n-        where V: MapVisitor\n-    {\n-        let len = visitor.len();\n+    fn serialize_map_end(&mut self, _: ()) -> Result<(), Self::Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::MapEnd));\n+        Ok(())\n+    }\n \n+    fn serialize_struct(&mut self, name: &str, len: usize) -> Result<(), Error>\n+    {\n         assert_eq!(self.tokens.next(), Some(&Token::StructStart(name, len)));\n \n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::StructEnd));\n-\n         Ok(())\n     }\n \n-    fn serialize_struct_elt<T>(&mut self, key: &'static str, value: T) -> Result<(), Error>\n-        where T: Serialize,\n-    {\n+    fn serialize_struct_elt<V>(&mut self, _: &mut (), key: &'static str, value: V) -> Result<(), Self::Error> where V: Serialize {\n         assert_eq!(self.tokens.next(), Some(&Token::StructSep));\n-\n         try!(key.serialize(self));\n         value.serialize(self)\n     }\n \n-    fn serialize_struct_variant<V>(&mut self,\n-                                   name: &str,\n-                                   _variant_index: usize,\n-                                   variant: &str,\n-                                   mut visitor: V) -> Result<(), Error>\n-        where V: MapVisitor\n-    {\n-        let len = visitor.len();\n+    fn serialize_struct_end(&mut self, _: ()) -> Result<(), Self::Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::StructEnd));\n+        Ok(())\n+    }\n \n+    fn serialize_struct_variant(&mut self,\n+                                name: &str,\n+                                _variant_index: usize,\n+                                variant: &str,\n+                                len: usize) -> Result<(), Error>\n+    {\n         assert_eq!(self.tokens.next(), Some(&Token::EnumMapStart(name, variant, len)));\n \n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::EnumMapEnd));\n-\n         Ok(())\n     }\n \n-    fn serialize_struct_variant_elt<T>(&mut self, key: &'static str, value: T) -> Result<(), Error>\n-        where T: Serialize,\n-    {\n+    fn serialize_struct_variant_elt<V>(&mut self, _: &mut (), key: &'static str, value: V) -> Result<(), Self::Error> where V: Serialize {\n         assert_eq!(self.tokens.next(), Some(&Token::EnumMapSep));\n-\n         try!(key.serialize(self));\n         value.serialize(self)\n     }\n+\n+    fn serialize_struct_variant_end(&mut self, _: ()) -> Result<(), Self::Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::EnumMapEnd));\n+        Ok(())\n+    }\n+\n+    fn serialize_bytes(&mut self, value: &[u8]) -> Result<(), Self::Error> {\n+        let mut state = try!(self.serialize_seq(Some(value.len())));\n+        for c in value {\n+            try!(self.serialize_seq_elt(&mut state, c));\n+        }\n+        self.serialize_seq_end(state)\n+    }\n }\ndiff --git a/serde_test/src/token.rs b/serde_test/src/token.rs\nindex dcb1137f3..e4b3a8253 100644\n--- a/serde_test/src/token.rs\n+++ b/serde_test/src/token.rs\n@@ -38,7 +38,7 @@ pub enum Token<'a> {\n     TupleSep,\n     TupleEnd,\n \n-    TupleStructStart(&'a str, Option<usize>),\n+    TupleStructStart(&'a str, usize),\n     TupleStructSep,\n     TupleStructEnd,\n \n@@ -46,15 +46,15 @@ pub enum Token<'a> {\n     MapSep,\n     MapEnd,\n \n-    StructStart(&'a str, Option<usize>),\n+    StructStart(&'a str, usize),\n     StructSep,\n     StructEnd,\n \n-    EnumSeqStart(&'a str, &'a str, Option<usize>),\n+    EnumSeqStart(&'a str, &'a str, usize),\n     EnumSeqSep,\n     EnumSeqEnd,\n \n-    EnumMapStart(&'a str, &'a str, Option<usize>),\n+    EnumMapStart(&'a str, &'a str, usize),\n     EnumMapSep,\n     EnumMapEnd,\n }\ndiff --git a/testing/tests/test_annotations.rs b/testing/tests/test_annotations.rs\nindex a18a4b82b..ba77f8f92 100644\n--- a/testing/tests/test_annotations.rs\n+++ b/testing/tests/test_annotations.rs\n@@ -82,7 +82,7 @@ fn test_default_struct() {\n     assert_de_tokens(\n         &DefaultStruct { a1: 1, a2: 2, a3: 3, a4: 0, a5: 123 },\n         &[\n-            Token::StructStart(\"DefaultStruct\", Some(3)),\n+            Token::StructStart(\"DefaultStruct\", 3),\n \n             Token::StructSep,\n             Token::Str(\"a1\"),\n@@ -111,7 +111,7 @@ fn test_default_struct() {\n     assert_de_tokens(\n         &DefaultStruct { a1: 1, a2: 0, a3: 123, a4: 0, a5: 123 },\n         &[\n-            Token::StructStart(\"DefaultStruct\", Some(1)),\n+            Token::StructStart(\"DefaultStruct\", 1),\n \n             Token::StructSep,\n             Token::Str(\"a1\"),\n@@ -145,7 +145,7 @@ fn test_default_enum() {\n     assert_de_tokens(\n         &DefaultEnum::Struct { a1: 1, a2: 2, a3: 3, a4: 0, a5: 123 },\n         &[\n-            Token::EnumMapStart(\"DefaultEnum\", \"Struct\", Some(5)),\n+            Token::EnumMapStart(\"DefaultEnum\", \"Struct\", 5),\n \n             Token::EnumMapSep,\n             Token::Str(\"a1\"),\n@@ -174,7 +174,7 @@ fn test_default_enum() {\n     assert_de_tokens(\n         &DefaultEnum::Struct { a1: 1, a2: 0, a3: 123, a4: 0, a5: 123 },\n         &[\n-            Token::EnumMapStart(\"DefaultEnum\", \"Struct\", Some(5)),\n+            Token::EnumMapStart(\"DefaultEnum\", \"Struct\", 5),\n \n             Token::EnumMapSep,\n             Token::Str(\"a1\"),\n@@ -208,7 +208,7 @@ fn test_no_std_default() {\n     assert_de_tokens(\n         &ContainsNoStdDefault { a: NoStdDefault(123) },\n         &[\n-            Token::StructStart(\"ContainsNoStdDefault\", Some(1)),\n+            Token::StructStart(\"ContainsNoStdDefault\", 1),\n             Token::StructEnd,\n         ]\n     );\n@@ -216,7 +216,7 @@ fn test_no_std_default() {\n     assert_de_tokens(\n         &ContainsNoStdDefault { a: NoStdDefault(8) },\n         &[\n-            Token::StructStart(\"ContainsNoStdDefault\", Some(1)),\n+            Token::StructStart(\"ContainsNoStdDefault\", 1),\n \n             Token::StructSep,\n             Token::Str(\"a\"),\n@@ -281,7 +281,7 @@ fn test_elt_not_deserialize() {\n             e: NotDeserializeEnum::Trouble,\n         },\n         &[\n-            Token::StructStart(\"ContainsNotDeserialize\", Some(3)),\n+            Token::StructStart(\"ContainsNotDeserialize\", 3),\n             Token::StructEnd,\n         ]\n     );\n@@ -299,7 +299,7 @@ fn test_ignore_unknown() {\n     assert_de_tokens(\n         &DefaultStruct { a1: 1, a2: 2, a3: 3, a4: 0, a5: 123 },\n         &[\n-            Token::StructStart(\"DefaultStruct\", Some(5)),\n+            Token::StructStart(\"DefaultStruct\", 5),\n \n             Token::StructSep,\n             Token::Str(\"whoops1\"),\n@@ -334,7 +334,7 @@ fn test_ignore_unknown() {\n \n     assert_de_tokens_error::<DenyUnknown>(\n         &[\n-            Token::StructStart(\"DenyUnknown\", Some(2)),\n+            Token::StructStart(\"DenyUnknown\", 2),\n \n             Token::StructSep,\n             Token::Str(\"a1\"),\n@@ -368,7 +368,7 @@ fn test_rename_struct() {\n     assert_tokens(\n         &RenameStruct { a1: 1, a2: 2 },\n         &[\n-            Token::StructStart(\"Superhero\", Some(2)),\n+            Token::StructStart(\"Superhero\", 2),\n \n             Token::StructSep,\n             Token::Str(\"a1\"),\n@@ -385,7 +385,7 @@ fn test_rename_struct() {\n     assert_ser_tokens(\n         &RenameStructSerializeDeserialize { a1: 1, a2: 2 },\n         &[\n-            Token::StructStart(\"SuperheroSer\", Some(2)),\n+            Token::StructStart(\"SuperheroSer\", 2),\n \n             Token::StructSep,\n             Token::Str(\"a1\"),\n@@ -402,7 +402,7 @@ fn test_rename_struct() {\n     assert_de_tokens(\n         &RenameStructSerializeDeserialize { a1: 1, a2: 2 },\n         &[\n-            Token::StructStart(\"SuperheroDe\", Some(2)),\n+            Token::StructStart(\"SuperheroDe\", 2),\n \n             Token::StructSep,\n             Token::Str(\"a1\"),\n@@ -465,7 +465,7 @@ fn test_rename_enum() {\n     assert_tokens(\n         &RenameEnum::WonderWoman(0, 1),\n         &[\n-            Token::EnumSeqStart(\"Superhero\", \"diana_prince\", Some(2)),\n+            Token::EnumSeqStart(\"Superhero\", \"diana_prince\", 2),\n \n             Token::EnumSeqSep,\n             Token::I8(0),\n@@ -480,7 +480,7 @@ fn test_rename_enum() {\n     assert_tokens(\n         &RenameEnum::Flash { a: 1 },\n         &[\n-            Token::EnumMapStart(\"Superhero\", \"barry_allan\", Some(1)),\n+            Token::EnumMapStart(\"Superhero\", \"barry_allan\", 1),\n \n             Token::EnumMapSep,\n             Token::Str(\"b\"),\n@@ -496,7 +496,7 @@ fn test_rename_enum() {\n             b: String::new(),\n         },\n         &[\n-            Token::EnumMapStart(\"SuperheroSer\", \"dick_grayson\", Some(2)),\n+            Token::EnumMapStart(\"SuperheroSer\", \"dick_grayson\", 2),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -516,7 +516,7 @@ fn test_rename_enum() {\n             b: String::new(),\n         },\n         &[\n-            Token::EnumMapStart(\"SuperheroDe\", \"jason_todd\", Some(2)),\n+            Token::EnumMapStart(\"SuperheroDe\", \"jason_todd\", 2),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -550,7 +550,7 @@ fn test_skip_serializing_struct() {\n             c: 3,\n         },\n         &[\n-            Token::StructStart(\"SkipSerializingStruct\", Some(2)),\n+            Token::StructStart(\"SkipSerializingStruct\", 2),\n \n             Token::StructSep,\n             Token::Str(\"a\"),\n@@ -571,7 +571,7 @@ fn test_skip_serializing_struct() {\n             c: 123,\n         },\n         &[\n-            Token::StructStart(\"SkipSerializingStruct\", Some(1)),\n+            Token::StructStart(\"SkipSerializingStruct\", 1),\n \n             Token::StructSep,\n             Token::Str(\"a\"),\n@@ -603,7 +603,7 @@ fn test_skip_serializing_enum() {\n             c: 3,\n         },\n         &[\n-            Token::EnumMapStart(\"SkipSerializingEnum\", \"Struct\", Some(2)),\n+            Token::EnumMapStart(\"SkipSerializingEnum\", \"Struct\", 2),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -624,7 +624,7 @@ fn test_skip_serializing_enum() {\n             c: 123,\n         },\n         &[\n-            Token::EnumMapStart(\"SkipSerializingEnum\", \"Struct\", Some(1)),\n+            Token::EnumMapStart(\"SkipSerializingEnum\", \"Struct\", 1),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -671,7 +671,7 @@ fn test_elt_not_serialize() {\n             d: NotSerializeEnum::Trouble,\n         },\n         &[\n-            Token::StructStart(\"ContainsNotSerialize\", Some(2)),\n+            Token::StructStart(\"ContainsNotSerialize\", 2),\n \n             Token::StructSep,\n             Token::Str(\"a\"),\n@@ -703,7 +703,7 @@ fn test_serialize_with_struct() {\n             b: 2,\n         },\n         &[\n-            Token::StructStart(\"SerializeWithStruct\", Some(2)),\n+            Token::StructStart(\"SerializeWithStruct\", 2),\n \n             Token::StructSep,\n             Token::Str(\"a\"),\n@@ -723,7 +723,7 @@ fn test_serialize_with_struct() {\n             b: 123,\n         },\n         &[\n-            Token::StructStart(\"SerializeWithStruct\", Some(2)),\n+            Token::StructStart(\"SerializeWithStruct\", 2),\n \n             Token::StructSep,\n             Token::Str(\"a\"),\n@@ -756,7 +756,7 @@ fn test_serialize_with_enum() {\n             b: 2,\n         },\n         &[\n-            Token::EnumMapStart(\"SerializeWithEnum\", \"Struct\", Some(2)),\n+            Token::EnumMapStart(\"SerializeWithEnum\", \"Struct\", 2),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -776,7 +776,7 @@ fn test_serialize_with_enum() {\n             b: 123,\n         },\n         &[\n-            Token::EnumMapStart(\"SerializeWithEnum\", \"Struct\", Some(2)),\n+            Token::EnumMapStart(\"SerializeWithEnum\", \"Struct\", 2),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -806,7 +806,7 @@ fn test_deserialize_with_struct() {\n             b: 2,\n         },\n         &[\n-            Token::StructStart(\"DeserializeWithStruct\", Some(2)),\n+            Token::StructStart(\"DeserializeWithStruct\", 2),\n \n             Token::StructSep,\n             Token::Str(\"a\"),\n@@ -826,7 +826,7 @@ fn test_deserialize_with_struct() {\n             b: 123,\n         },\n         &[\n-            Token::StructStart(\"DeserializeWithStruct\", Some(2)),\n+            Token::StructStart(\"DeserializeWithStruct\", 2),\n \n             Token::StructSep,\n             Token::Str(\"a\"),\n@@ -858,7 +858,7 @@ fn test_deserialize_with_enum() {\n             b: 2,\n         },\n         &[\n-            Token::EnumMapStart(\"DeserializeWithEnum\", \"Struct\", Some(2)),\n+            Token::EnumMapStart(\"DeserializeWithEnum\", \"Struct\", 2),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -878,7 +878,7 @@ fn test_deserialize_with_enum() {\n             b: 123,\n         },\n         &[\n-            Token::EnumMapStart(\"DeserializeWithEnum\", \"Struct\", Some(2)),\n+            Token::EnumMapStart(\"DeserializeWithEnum\", \"Struct\", 2),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -897,7 +897,7 @@ fn test_deserialize_with_enum() {\n fn test_missing_renamed_field_struct() {\n     assert_de_tokens_error::<RenameStruct>(\n         &[\n-            Token::StructStart(\"Superhero\", Some(2)),\n+            Token::StructStart(\"Superhero\", 2),\n \n             Token::StructSep,\n             Token::Str(\"a1\"),\n@@ -910,7 +910,7 @@ fn test_missing_renamed_field_struct() {\n \n     assert_de_tokens_error::<RenameStructSerializeDeserialize>(\n         &[\n-            Token::StructStart(\"SuperheroDe\", Some(2)),\n+            Token::StructStart(\"SuperheroDe\", 2),\n \n             Token::StructSep,\n             Token::Str(\"a1\"),\n@@ -926,7 +926,7 @@ fn test_missing_renamed_field_struct() {\n fn test_missing_renamed_field_enum() {\n     assert_de_tokens_error::<RenameEnum>(\n         &[\n-            Token::EnumMapStart(\"Superhero\", \"barry_allan\", Some(1)),\n+            Token::EnumMapStart(\"Superhero\", \"barry_allan\", 1),\n \n             Token::EnumMapEnd,\n         ],\n@@ -935,7 +935,7 @@ fn test_missing_renamed_field_enum() {\n \n     assert_de_tokens_error::<RenameEnumSerializeDeserialize<i8>>(\n         &[\n-            Token::EnumMapStart(\"SuperheroDe\", \"jason_todd\", Some(2)),\n+            Token::EnumMapStart(\"SuperheroDe\", \"jason_todd\", 2),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -957,7 +957,7 @@ enum InvalidLengthEnum {\n fn test_invalid_length_enum() {\n     assert_de_tokens_error::<InvalidLengthEnum>(\n         &[\n-            Token::EnumSeqStart(\"InvalidLengthEnum\", \"A\", Some(3)),\n+            Token::EnumSeqStart(\"InvalidLengthEnum\", \"A\", 3),\n                 Token::EnumSeqSep,\n                 Token::I32(1),\n             Token::EnumSeqEnd,\n@@ -966,7 +966,7 @@ fn test_invalid_length_enum() {\n     );\n     assert_de_tokens_error::<InvalidLengthEnum>(\n         &[\n-            Token::EnumSeqStart(\"InvalidLengthEnum\", \"B\", Some(3)),\n+            Token::EnumSeqStart(\"InvalidLengthEnum\", \"B\", 3),\n                 Token::EnumSeqSep,\n                 Token::I32(1),\n             Token::EnumSeqEnd,\ndiff --git a/testing/tests/test_bytes.rs b/testing/tests/test_bytes.rs\nindex 7a9906a4a..b2e21b2e8 100644\n--- a/testing/tests/test_bytes.rs\n+++ b/testing/tests/test_bytes.rs\n@@ -52,15 +52,62 @@ impl BytesSerializer {\n \n impl serde::Serializer for BytesSerializer {\n     type Error = Error;\n+    type SeqState = ();\n+    type MapState = ();\n+    type TupleState = ();\n+    type TupleStructState = ();\n+    type TupleVariantState = ();\n+    type StructState = ();\n+    type StructVariantState = ();\n \n     fn serialize_unit(&mut self) -> Result<(), Error> {\n         Err(Error)\n     }\n \n+    fn serialize_unit_struct(&mut self, _name: &'static str) -> Result<(), Error> {\n+        Err(Error)\n+    }\n+\n+    fn serialize_unit_variant(&mut self, _: &'static str, _: usize, _: &'static str) -> Result<(), Error> {\n+        Err(Error)\n+    }\n+\n     fn serialize_bool(&mut self, _v: bool) -> Result<(), Error> {\n         Err(Error)\n     }\n \n+    fn serialize_isize(&mut self, _v: isize) -> Result<(), Error> {\n+        Err(Error)\n+    }\n+\n+    fn serialize_usize(&mut self, _v: usize) -> Result<(), Error> {\n+        Err(Error)\n+    }\n+\n+    fn serialize_i8(&mut self, _v: i8) -> Result<(), Error> {\n+        Err(Error)\n+    }\n+\n+    fn serialize_u8(&mut self, _v: u8) -> Result<(), Error> {\n+        Err(Error)\n+    }\n+\n+    fn serialize_i16(&mut self, _v: i16) -> Result<(), Error> {\n+        Err(Error)\n+    }\n+\n+    fn serialize_u16(&mut self, _v: u16) -> Result<(), Error> {\n+        Err(Error)\n+    }\n+\n+    fn serialize_i32(&mut self, _v: i32) -> Result<(), Error> {\n+        Err(Error)\n+    }\n+\n+    fn serialize_u32(&mut self, _v: u32) -> Result<(), Error> {\n+        Err(Error)\n+    }\n+\n     fn serialize_i64(&mut self, _v: i64) -> Result<(), Error> {\n         Err(Error)\n     }\n@@ -95,31 +142,136 @@ impl serde::Serializer for BytesSerializer {\n         Err(Error)\n     }\n \n-    fn serialize_seq<V>(&mut self, _visitor: V) -> Result<(), Error>\n-        where V: serde::ser::SeqVisitor,\n+    fn serialize_newtype_struct<V>(&mut self, _: &'static str, _value: V) -> Result<(), Error>\n+        where V: serde::Serialize,\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_newtype_variant<V>(&mut self, _: &'static str, _: usize, _: &'static str, _value: V) -> Result<(), Error>\n+        where V: serde::Serialize,\n     {\n         Err(Error)\n     }\n \n-    fn serialize_seq_elt<T>(&mut self, _value: T) -> Result<(), Error>\n+    fn serialize_seq(&mut self, _len: Option<usize>) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_seq_fixed_size(&mut self, _len: usize) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_seq_elt<T>(&mut self, _: &mut (), _value: T) -> Result<(), Error>\n         where T: serde::Serialize\n     {\n         Err(Error)\n     }\n \n-    fn serialize_map<V>(&mut self, _visitor: V) -> Result<(), Error>\n-        where V: serde::ser::MapVisitor,\n+    fn serialize_seq_end(&mut self, _: ()) -> Result<(), Error>\n     {\n         Err(Error)\n     }\n \n-    fn serialize_map_elt<K, V>(&mut self, _key: K, _value: V) -> Result<(), Error>\n+    fn serialize_tuple(&mut self, _len: usize) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_tuple_elt<T>(&mut self, _: &mut (), _value: T) -> Result<(), Error>\n+        where T: serde::Serialize\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_tuple_end(&mut self, _: ()) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_tuple_struct(&mut self, _: &'static str, _len: usize) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_tuple_struct_elt<T>(&mut self, _: &mut (), _value: T) -> Result<(), Error>\n+        where T: serde::Serialize\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_tuple_struct_end(&mut self, _: ()) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_tuple_variant(&mut self, _: &'static str, _: usize, _: &'static str, _len: usize) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_tuple_variant_elt<T>(&mut self, _: &mut (), _value: T) -> Result<(), Error>\n+        where T: serde::Serialize\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_tuple_variant_end(&mut self, _: ()) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_map(&mut self, _: Option<usize>) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_map_elt<K, V>(&mut self, _: &mut (), _key: K, _value: V) -> Result<(), Error>\n         where K: serde::Serialize,\n               V: serde::Serialize,\n     {\n         Err(Error)\n     }\n \n+    fn serialize_map_end(&mut self, _: ()) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_struct(&mut self, _: &'static str, _: usize) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_struct_elt<V>(&mut self, _: &mut (), _key: &'static str, _value: V) -> Result<(), Error>\n+        where V: serde::Serialize,\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_struct_end(&mut self, _: ()) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_struct_variant(&mut self, _: &'static str, _: usize, _: &'static str, _: usize) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_struct_variant_elt<V>(&mut self, _: &mut (), _key: &'static str, _value: V) -> Result<(), Error>\n+        where V: serde::Serialize,\n+    {\n+        Err(Error)\n+    }\n+\n+    fn serialize_struct_variant_end(&mut self, _: ()) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n     fn serialize_bytes(&mut self, bytes: &[u8]) -> Result<(), Error> {\n         assert_eq!(self.bytes, bytes);\n         Ok(())\ndiff --git a/testing/tests/test_de.rs b/testing/tests/test_de.rs\nindex fcd174480..08c06af6c 100644\n--- a/testing/tests/test_de.rs\n+++ b/testing/tests/test_de.rs\n@@ -81,9 +81,9 @@ fn assert_de_tokens_ignore(ignorable_tokens: &[Token<'static>]) {\n     struct IgnoreBase {\n         a: i32,\n     }\n- \n+\n     let expected = IgnoreBase{a: 1};\n- \n+\n     // Embed the tokens to be ignored in the normal token\n     // stream for an IgnoreBase type\n     let concated_tokens : Vec<Token<'static>> = vec![\n@@ -91,7 +91,7 @@ fn assert_de_tokens_ignore(ignorable_tokens: &[Token<'static>]) {\n                 Token::MapSep,\n                 Token::Str(\"a\"),\n                 Token::I32(1),\n- \n+\n                 Token::MapSep,\n                 Token::Str(\"ignored\")\n         ]\n@@ -101,17 +101,17 @@ fn assert_de_tokens_ignore(ignorable_tokens: &[Token<'static>]) {\n             Token::MapEnd,\n         ].into_iter())\n         .collect();\n- \n+\n     let mut de = serde_test::Deserializer::new(concated_tokens.into_iter());\n     let v: Result<IgnoreBase, Error> = Deserialize::deserialize(&mut de);\n- \n+\n     // We run this test on every token stream for convenience, but\n     // some token streams don't make sense embedded as a map value,\n     // so we ignore those. SyntaxError is the real sign of trouble.\n     if let Err(Error::UnexpectedToken(_)) = v {\n         return;\n     }\n- \n+\n     assert_eq!(v.as_ref(), Ok(&expected));\n     assert_eq!(de.next_token(), None);\n }\n@@ -197,7 +197,7 @@ declare_tests! {\n             Token::SeqEnd,\n         ],\n         () => &[\n-            Token::TupleStructStart(\"Anything\", Some(0)),\n+            Token::TupleStructStart(\"Anything\", 0),\n             Token::SeqEnd,\n         ],\n     }\n@@ -241,7 +241,7 @@ declare_tests! {\n             Token::SeqEnd,\n         ],\n         TupleStruct(1, 2, 3) => &[\n-            Token::TupleStructStart(\"TupleStruct\", Some(3)),\n+            Token::TupleStructStart(\"TupleStruct\", 3),\n                 Token::TupleStructSep,\n                 Token::I32(1),\n \n@@ -253,7 +253,7 @@ declare_tests! {\n             Token::TupleStructEnd,\n         ],\n         TupleStruct(1, 2, 3) => &[\n-            Token::TupleStructStart(\"TupleStruct\", None),\n+            Token::TupleStructStart(\"TupleStruct\", 3),\n                 Token::TupleStructSep,\n                 Token::I32(1),\n \n@@ -299,7 +299,7 @@ declare_tests! {\n             Token::UnitStruct(\"Anything\"),\n         ],\n         BTreeSet::<isize>::new() => &[\n-            Token::TupleStructStart(\"Anything\", Some(0)),\n+            Token::TupleStructStart(\"Anything\", 0),\n             Token::SeqEnd,\n         ],\n     }\n@@ -327,7 +327,7 @@ declare_tests! {\n             Token::UnitStruct(\"Anything\"),\n         ],\n         HashSet::<isize>::new() => &[\n-            Token::TupleStructStart(\"Anything\", Some(0)),\n+            Token::TupleStructStart(\"Anything\", 0),\n             Token::SeqEnd,\n         ],\n         hashset![FnvHasher @ 1, 2, 3] => &[\n@@ -377,7 +377,7 @@ declare_tests! {\n             Token::UnitStruct(\"Anything\"),\n         ],\n         Vec::<isize>::new() => &[\n-            Token::TupleStructStart(\"Anything\", Some(0)),\n+            Token::TupleStructStart(\"Anything\", 0),\n             Token::SeqEnd,\n         ],\n     }\n@@ -441,7 +441,7 @@ declare_tests! {\n             Token::UnitStruct(\"Anything\"),\n         ],\n         [0; 0] => &[\n-            Token::TupleStructStart(\"Anything\", Some(0)),\n+            Token::TupleStructStart(\"Anything\", 0),\n             Token::SeqEnd,\n         ],\n     }\n@@ -533,7 +533,7 @@ declare_tests! {\n             Token::UnitStruct(\"Anything\"),\n         ],\n         BTreeMap::<isize, isize>::new() => &[\n-            Token::StructStart(\"Anything\", Some(0)),\n+            Token::StructStart(\"Anything\", 0),\n             Token::MapEnd,\n         ],\n     }\n@@ -587,7 +587,7 @@ declare_tests! {\n             Token::UnitStruct(\"Anything\"),\n         ],\n         HashMap::<isize, isize>::new() => &[\n-            Token::StructStart(\"Anything\", Some(0)),\n+            Token::StructStart(\"Anything\", 0),\n             Token::MapEnd,\n         ],\n         hashmap![FnvHasher @ 1 => 2, 3 => 4] => &[\n@@ -615,7 +615,7 @@ declare_tests! {\n             Token::MapEnd,\n         ],\n         Struct { a: 1, b: 2, c: 0 } => &[\n-            Token::StructStart(\"Struct\", Some(3)),\n+            Token::StructStart(\"Struct\", 3),\n                 Token::StructSep,\n                 Token::Str(\"a\"),\n                 Token::I32(1),\n@@ -656,7 +656,7 @@ declare_tests! {\n             Token::MapEnd,\n         ],\n         Struct { a: 1, b: 2, c: 0 } => &[\n-            Token::StructStart(\"Struct\", Some(3)),\n+            Token::StructStart(\"Struct\", 3),\n                 Token::StructSep,\n                 Token::Str(\"a\"),\n                 Token::I32(1),\n@@ -688,7 +688,7 @@ declare_tests! {\n     }\n     test_enum_seq {\n         Enum::Seq(1, 2, 3) => &[\n-            Token::EnumSeqStart(\"Enum\", \"Seq\", Some(3)),\n+            Token::EnumSeqStart(\"Enum\", \"Seq\", 3),\n                 Token::EnumSeqSep,\n                 Token::I32(1),\n \n@@ -702,7 +702,7 @@ declare_tests! {\n     }\n     test_enum_map {\n         Enum::Map { a: 1, b: 2, c: 3 } => &[\n-            Token::EnumMapStart(\"Enum\", \"Map\", Some(3)),\n+            Token::EnumMapStart(\"Enum\", \"Map\", 3),\n                 Token::EnumMapSep,\n                 Token::Str(\"a\"),\n                 Token::I32(1),\n@@ -803,7 +803,7 @@ declare_error_tests! {\n     }\n     test_duplicate_field_enum<Enum> {\n         &[\n-            Token::EnumMapStart(\"Enum\", \"Map\", Some(3)),\n+            Token::EnumMapStart(\"Enum\", \"Map\", 3),\n                 Token::EnumMapSep,\n                 Token::Str(\"a\"),\n                 Token::I32(1),\ndiff --git a/testing/tests/test_macros.rs b/testing/tests/test_macros.rs\nindex ca4dffaa7..58ddfeabb 100644\n--- a/testing/tests/test_macros.rs\n+++ b/testing/tests/test_macros.rs\n@@ -174,7 +174,7 @@ fn test_ser_named_tuple() {\n     assert_ser_tokens(\n         &SerNamedTuple(&a, &mut b, c),\n         &[\n-            Token::TupleStructStart(\"SerNamedTuple\", Some(3)),\n+            Token::TupleStructStart(\"SerNamedTuple\", 3),\n             Token::TupleStructSep,\n             Token::I32(5),\n \n@@ -211,7 +211,7 @@ fn test_de_named_tuple() {\n     assert_de_tokens(\n         &DeNamedTuple(5, 6, 7),\n         &[\n-            Token::TupleStructStart(\"DeNamedTuple\", Some(3)),\n+            Token::TupleStructStart(\"DeNamedTuple\", 3),\n             Token::TupleStructSep,\n             Token::I32(5),\n \n@@ -239,7 +239,7 @@ fn test_ser_named_map() {\n             c: c,\n         },\n         &[\n-            Token::StructStart(\"SerNamedMap\", Some(3)),\n+            Token::StructStart(\"SerNamedMap\", 3),\n \n             Token::StructSep,\n             Token::Str(\"a\"),\n@@ -267,7 +267,7 @@ fn test_de_named_map() {\n             c: 7,\n         },\n         &[\n-            Token::StructStart(\"DeNamedMap\", Some(3)),\n+            Token::StructStart(\"DeNamedMap\", 3),\n \n             Token::StructSep,\n             Token::Str(\"a\"),\n@@ -315,7 +315,7 @@ fn test_ser_enum_seq() {\n             //f,\n         ),\n         &[\n-            Token::EnumSeqStart(\"SerEnum\", \"Seq\", Some(4)),\n+            Token::EnumSeqStart(\"SerEnum\", \"Seq\", 4),\n \n             Token::EnumSeqSep,\n             Token::I8(1),\n@@ -353,7 +353,7 @@ fn test_ser_enum_map() {\n             //f: f,\n         },\n         &[\n-            Token::EnumMapStart(\"SerEnum\", \"Map\", Some(4)),\n+            Token::EnumMapStart(\"SerEnum\", \"Map\", 4),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -405,7 +405,7 @@ fn test_de_enum_seq() {\n             //f,\n         ),\n         &[\n-            Token::EnumSeqStart(\"DeEnum\", \"Seq\", Some(4)),\n+            Token::EnumSeqStart(\"DeEnum\", \"Seq\", 4),\n \n             Token::EnumSeqSep,\n             Token::I8(1),\n@@ -443,7 +443,7 @@ fn test_de_enum_map() {\n             //f: f,\n         },\n         &[\n-            Token::EnumMapStart(\"DeEnum\", \"Map\", Some(4)),\n+            Token::EnumMapStart(\"DeEnum\", \"Map\", 4),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -489,7 +489,7 @@ fn test_lifetimes() {\n     assert_ser_tokens(\n         &Lifetimes::LifetimeMap { a: &value },\n         &[\n-            Token::EnumMapStart(\"Lifetimes\", \"LifetimeMap\", Some(1)),\n+            Token::EnumMapStart(\"Lifetimes\", \"LifetimeMap\", 1),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -502,7 +502,7 @@ fn test_lifetimes() {\n     assert_ser_tokens(\n         &Lifetimes::NoLifetimeMap { a: 5 },\n         &[\n-            Token::EnumMapStart(\"Lifetimes\", \"NoLifetimeMap\", Some(1)),\n+            Token::EnumMapStart(\"Lifetimes\", \"NoLifetimeMap\", 1),\n \n             Token::EnumMapSep,\n             Token::Str(\"a\"),\n@@ -518,7 +518,7 @@ fn test_generic_struct() {\n     assert_tokens(\n         &GenericStruct { x: 5u32 },\n         &[\n-            Token::StructStart(\"GenericStruct\", Some(1)),\n+            Token::StructStart(\"GenericStruct\", 1),\n \n             Token::StructSep,\n             Token::Str(\"x\"),\n@@ -545,7 +545,7 @@ fn test_generic_tuple_struct() {\n     assert_tokens(\n         &GenericTupleStruct(5u32, 6u32),\n         &[\n-            Token::TupleStructStart(\"GenericTupleStruct\", Some(2)),\n+            Token::TupleStructStart(\"GenericTupleStruct\", 2),\n \n             Token::TupleStructSep,\n             Token::U32(5),\n@@ -584,7 +584,7 @@ fn test_generic_enum_seq() {\n     assert_tokens(\n         &GenericEnum::Seq::<u32, u32>(5, 6),\n         &[\n-            Token::EnumSeqStart(\"GenericEnum\", \"Seq\", Some(2)),\n+            Token::EnumSeqStart(\"GenericEnum\", \"Seq\", 2),\n \n             Token::EnumSeqSep,\n             Token::U32(5),\n@@ -602,7 +602,7 @@ fn test_generic_enum_map() {\n     assert_tokens(\n         &GenericEnum::Map::<u32, u32> { x: 5, y: 6 },\n         &[\n-            Token::EnumMapStart(\"GenericEnum\", \"Map\", Some(2)),\n+            Token::EnumMapStart(\"GenericEnum\", \"Map\", 2),\n \n             Token::EnumMapSep,\n             Token::Str(\"x\"),\n@@ -622,7 +622,7 @@ fn test_default_ty_param() {\n     assert_tokens(\n         &DefaultTyParam::<i32> { phantom: PhantomData },\n         &[\n-            Token::StructStart(\"DefaultTyParam\", Some(1)),\n+            Token::StructStart(\"DefaultTyParam\", 1),\n \n             Token::StructSep,\n             Token::Str(\"phantom\"),\ndiff --git a/testing/tests/test_ser.rs b/testing/tests/test_ser.rs\nindex 981ddb86e..e772e05ed 100644\n--- a/testing/tests/test_ser.rs\n+++ b/testing/tests/test_ser.rs\n@@ -256,7 +256,7 @@ declare_ser_tests! {\n     }\n     test_tuple_struct {\n         TupleStruct(1, 2, 3) => &[\n-            Token::TupleStructStart(\"TupleStruct\", Some(3)),\n+            Token::TupleStructStart(\"TupleStruct\", 3),\n                 Token::TupleStructSep,\n                 Token::I32(1),\n \n@@ -270,7 +270,7 @@ declare_ser_tests! {\n     }\n     test_struct {\n         Struct { a: 1, b: 2, c: 3 } => &[\n-            Token::StructStart(\"Struct\", Some(3)),\n+            Token::StructStart(\"Struct\", 3),\n                 Token::StructSep,\n                 Token::Str(\"a\"),\n                 Token::I32(1),\n@@ -289,7 +289,7 @@ declare_ser_tests! {\n         Enum::Unit => &[Token::EnumUnit(\"Enum\", \"Unit\")],\n         Enum::One(42) => &[Token::EnumNewType(\"Enum\", \"One\"), Token::I32(42)],\n         Enum::Seq(1, 2) => &[\n-            Token::EnumSeqStart(\"Enum\", \"Seq\", Some(2)),\n+            Token::EnumSeqStart(\"Enum\", \"Seq\", 2),\n                 Token::EnumSeqSep,\n                 Token::I32(1),\n \n@@ -298,7 +298,7 @@ declare_ser_tests! {\n             Token::EnumSeqEnd,\n         ],\n         Enum::Map { a: 1, b: 2 } => &[\n-            Token::EnumMapStart(\"Enum\", \"Map\", Some(2)),\n+            Token::EnumMapStart(\"Enum\", \"Map\", 2),\n                 Token::EnumMapSep,\n                 Token::Str(\"a\"),\n                 Token::I32(1),\n", "problem_statement": "Unable to serialize sequence without knowing all elements.\nIn the logging library I'm working on, I would like to serialize map elements, provided by user API calls. However at any given time, I have only one `key: value` pair.\n\nSo I can't efficiently serialize a map:\n\n```\n    fn serialize_map<V>(&mut self, visitor: V) -> Result<(), Self::Error> where V: MapVisitor;\n    fn serialize_map_elt<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error> where K: Serialize, V: Serialize;\n```\n\nAs I have to build a Visitor\n\nIf the API would be returning some kind of `Visitor` that one can call to serialize field after field, then both my and currently-supported use cases would work. Would it be worse in some aspect that I'm missing?\n\n", "hints_text": "Have you seen https://serde-rs.github.io/serde/serde/ser/impls/struct.MapIteratorVisitor.html ? Either that fits your use case or I don't understand your situation (please elaborate with some code in that case).\n\n@oli-obk: This visitor is taking an iterator. I can't provide an iterator since I don't have a collection of map elements. I only have one pair (key, value) at the time.\n\nExample module:\n\n```\nstruct Logger {\n    serializer : serde::Serializer,\n}\n\nimpl Logger {\n    pub fn start() {}\n\n    pub fn write_one(key : &str, val :&str) {\n         self.serializer.emit_map_elt(key, val);\n   }\n\n   pub fn end() {}\n}\n```\n\nThe user of this library will cal `write_one` couple of times with some borrowed elements that are valid for the lifetime of `write_one`, but not necessarily for the lifetime of whole `Logger`. As in the above implementation, I can emit them one at the time, but I can't emit the whole map they belong to, as I can't build the whole map/Visitor at once.\n\nThat's a tough one. I don't think serde can work with this setup. Even if you'd use threads, it would get messy due to the lifetimes.\n\nIf you are willing to turn the `&str` into `String`, then you could send them over a channel and implement a `MapVisitor` that iterates over the receiving end of the channel. In another thread you'd create the serializer and call `serialize_map` on your custom `MapVisitor`.\n\nThat kind of heavy workaround. I have eventually rewritten everything using macros etc. to solve all the issues I've reported, so I'm OK with this not being immediately solvable.\n\nI am keep hitting this problem. The more I look at it, the more I'm convinced that that the `Visitor` pattern is backwards (inversion of control). The `Visitor` should be returned by `serialize_map`, and not taken. The whole `Serializer` API is \"push\"-y - meaning you call methods from the outside for each element you have, and suddenly, when you want to serialize map, it becomes \"pull\"-y - serde is calling into custom struct (`Visitor`) to ask about all elements. It forces you to create weird `struct MyVistior` and implement error-prone logic, play with lifetimes etc., where all you wanted to do is to go through all elements of your collection and serialize them one by one.\n\nI guess the problem is that lack of abstract return types... :(\n\nI have investigated this before by playing with closures. I'll have a look whether this can be refactored somewhat. We might be able to add a new associated type to the serializer\n\nI actually tried with associated types\n\n```\npub trait MapSerializer : Sized {\n    type Error : Error;\n    /// Serializes an element of a map (key-value pair).\n    fn serialize_elt<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error>\n        where K: Serialize,\n              V: Serialize\n}\n\npub trait SeqSerializer : Sized {\n    type Error : Error;\n    /// Serializes an element of a sequence.\n    fn serialize_elt<T>(&mut self, value: T) -> Result<(), Self::Error>\n        where T: Serialize,\n}\n\n pub trait Serializer {\n     type SeqSerializer : SeqSerializer+Sized+'static;\n     type MapSerializer : SeqSerializer+Sized+'static;\n\n(...)\n    /// Serialize a map.\n    fn serialize_map<V>(&mut self) -> Result<MapSerializer, Self::Error>;\n\n(...)\n}\n```\n\nAs far as I understand, it's not possible to return  `Result<MapSerializer, Self::Error>;` as it's called \"abstract return types\". But it is kind of getting merged in already: https://github.com/rust-lang/rfcs/pull/1522 so maybe it would be possible already.\n\nShould work. Abstract return types are sth different\n\nNote: you might have name clashes. Use `Self::MapSerializer`\n\nOh, you might be right about the clashes. That's how I confused myself.\n", "created_at": "2016-07-12T13:45:46Z", "version": "0.7"}, {"repo": "serde-rs/serde", "pull_number": 418, "instance_id": "serde-rs__serde-418", "issue_numbers": ["350"], "base_commit": "5deba439c3e44b5646cef22d34ccc412cbcb23f3", "patch": "diff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex c875848cb..69d70bc37 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -8,6 +8,7 @@ use syntax::ptr::P;\n use syntax::tokenstream::TokenTree;\n \n use bound;\n+use span;\n use internals::ast::{Body, Field, Item, Style, Variant};\n use internals::{attr, Error};\n \n@@ -44,7 +45,7 @@ pub fn expand_derive_deserialize(\n     let builder = aster::AstBuilder::new().span(span);\n \n     let impl_item = deserialize_item(cx, &builder, &item);\n-    push(Annotatable::Item(impl_item))\n+    push(span::record_expansion(cx, impl_item, \"Deserialize\"))\n }\n \n fn deserialize_item(\ndiff --git a/serde_codegen/src/lib.rs.in b/serde_codegen/src/lib.rs.in\nindex 497268515..08dd5d3cc 100644\n--- a/serde_codegen/src/lib.rs.in\n+++ b/serde_codegen/src/lib.rs.in\n@@ -1,3 +1,4 @@\n mod bound;\n mod de;\n mod ser;\n+mod span;\ndiff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex 0369ee21a..3f549c0ff 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -6,6 +6,7 @@ use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ptr::P;\n \n use bound;\n+use span;\n use internals::ast::{Body, Field, Item, Style, Variant};\n use internals::{attr, Error};\n \n@@ -38,7 +39,7 @@ pub fn expand_derive_serialize(\n     let builder = aster::AstBuilder::new().span(span);\n \n     let impl_item = serialize_item(cx, &builder, &item);\n-    push(Annotatable::Item(impl_item))\n+    push(span::record_expansion(cx, impl_item, \"Serialize\"))\n }\n \n fn serialize_item(\ndiff --git a/serde_codegen/src/span.rs b/serde_codegen/src/span.rs\nnew file mode 100644\nindex 000000000..5421868d1\n--- /dev/null\n+++ b/serde_codegen/src/span.rs\n@@ -0,0 +1,43 @@\n+use syntax::ast;\n+use syntax::codemap::{self, ExpnId, Span};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n+use syntax::fold::{self, Folder};\n+use syntax::parse::token::intern;\n+use syntax::ptr::P;\n+\n+pub fn record_expansion(\n+    cx: &ExtCtxt,\n+    item: P<ast::Item>,\n+    derive: &str,\n+) -> Annotatable {\n+    let info = codemap::ExpnInfo {\n+        call_site: codemap::DUMMY_SP,\n+        callee: codemap::NameAndSpan {\n+            format: codemap::MacroAttribute(intern(&format!(\"derive({})\", derive))),\n+            span: None,\n+            allow_internal_unstable: false,\n+        },\n+    };\n+    let expn_id = cx.codemap().record_expansion(info);\n+\n+    let mut respanner = Respanner { expn_id: expn_id };\n+    let item = item.map(|item| respanner.fold_item_simple(item));\n+    Annotatable::Item(item)\n+}\n+\n+struct Respanner {\n+    expn_id: ExpnId,\n+}\n+\n+impl Folder for Respanner {\n+    fn new_span(&mut self, span: Span) -> Span {\n+        Span {\n+            expn_id: self.expn_id,\n+            .. span\n+        }\n+    }\n+\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(mac, self)\n+    }\n+}\ndiff --git a/serde_macros/Cargo.toml b/serde_macros/Cargo.toml\nindex 3b6b8a95a..cd61e2842 100644\n--- a/serde_macros/Cargo.toml\n+++ b/serde_macros/Cargo.toml\n@@ -21,6 +21,7 @@ clippy = { version = \"^0.*\", optional = true }\n serde_codegen = { version = \"^0.7.12\", path = \"../serde_codegen\", default-features = false, features = [\"nightly\"] }\n \n [dev-dependencies]\n+clippy = \"^0.0.78\"\n compiletest_rs = \"^0.2.0\"\n fnv = \"1.0\"\n rustc-serialize = \"^0.3.16\"\n", "test_patch": "diff --git a/serde_macros/tests/compile_tests.rs b/serde_macros/tests/compile_tests.rs\nindex 27c212b4d..419425226 100644\n--- a/serde_macros/tests/compile_tests.rs\n+++ b/serde_macros/tests/compile_tests.rs\n@@ -20,6 +20,11 @@ fn run_mode(mode: &'static str) {\n }\n \n #[test]\n-fn compile_test() {\n+fn compile_fail() {\n     run_mode(\"compile-fail\");\n }\n+\n+#[test]\n+fn run_pass() {\n+    run_mode(\"run-pass\");\n+}\ndiff --git a/serde_macros/tests/run-pass/identity-op.rs b/serde_macros/tests/run-pass/identity-op.rs\nnew file mode 100644\nindex 000000000..dcf8117a3\n--- /dev/null\n+++ b/serde_macros/tests/run-pass/identity-op.rs\n@@ -0,0 +1,12 @@\n+#![feature(custom_derive, plugin)]\n+#![plugin(serde_macros, clippy)]\n+\n+#![deny(identity_op)]\n+\n+// The derived implementation uses 0+1 to add up the number of fields\n+// serialized, which Clippy warns about. If the expansion info is registered\n+// correctly, the Clippy lint is not triggered.\n+#[derive(Serialize)]\n+struct A { b: u8 }\n+\n+fn main() {}\n", "problem_statement": "serde_macros spans need add expansion info\nclippy can't detect whether the code was expanded or not without that info\n\ncc https://github.com/Manishearth/rust-clippy/issues/969\n\n", "hints_text": "", "created_at": "2016-07-03T17:54:02Z", "version": "0.7"}, {"repo": "serde-rs/serde", "pull_number": 412, "instance_id": "serde-rs__serde-412", "issue_numbers": ["411"], "base_commit": "6ab508a93c8163a12315729f00fce4c539dfebd5", "patch": "diff --git a/.travis.yml b/.travis.yml\nindex ff56c4826..de282ca26 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -22,15 +22,15 @@ script:\n - (cd serde && travis-cargo build -- --no-default-features)\n - (cd serde && travis-cargo --only nightly build -- --no-default-features --features alloc)\n - (cd serde && travis-cargo --only nightly build -- --no-default-features --features collections)\n-- (cd serde_tests && travis-cargo --skip nightly test)\n-- (cd serde_tests && travis-cargo --only nightly test -- --features nightly-testing)\n+- (cd testing && travis-cargo --skip nightly test)\n+- (cd testing && travis-cargo --only nightly test -- --features nightly-testing)\n - (cd serde_macros && travis-cargo --only nightly test -- --features nightly-testing)\n - (cd examples/serde-syntex-example && travis-cargo --skip nightly run)\n - (cd examples/serde-syntex-example && travis-cargo --only nightly run -- --no-default-features --features nightly)\n - (cd serde && travis-cargo --only stable doc)\n after_success:\n - (cd serde && travis-cargo --only stable doc-upload)\n-- (cd serde_tests && travis-cargo --only stable coveralls --no-sudo)\n+- (cd testing && travis-cargo --only stable coveralls --no-sudo)\n env:\n   global:\n   - TRAVIS_CARGO_NIGHTLY_FEATURE=\"\"\ndiff --git a/serde_macros/Cargo.toml b/serde_macros/Cargo.toml\nindex cec301bdc..53b7d4437 100644\n--- a/serde_macros/Cargo.toml\n+++ b/serde_macros/Cargo.toml\n@@ -25,6 +25,7 @@ compiletest_rs = \"^0.2.0\"\n fnv = \"1.0\"\n rustc-serialize = \"^0.3.16\"\n serde = { version = \"^0.7.11\", path = \"../serde\" }\n+serde_test = { version = \"^0.7.11\", path = \"../serde_test\" }\n \n [[test]]\n name = \"test\"\ndiff --git a/serde_macros/benches/bench.rs b/serde_macros/benches/bench.rs\nindex 089bc8526..ec15c18c7 100644\n--- a/serde_macros/benches/bench.rs\n+++ b/serde_macros/benches/bench.rs\n@@ -6,4 +6,4 @@ extern crate rustc_serialize;\n extern crate serde;\n extern crate test;\n \n-include!(\"../../serde_tests/benches/bench.rs.in\");\n+include!(\"../../testing/benches/bench.rs.in\");\n", "test_patch": "diff --git a/serde_macros/tests/test.rs b/serde_macros/tests/test.rs\nindex f2e785a56..e92112185 100644\n--- a/serde_macros/tests/test.rs\n+++ b/serde_macros/tests/test.rs\n@@ -4,6 +4,6 @@\n extern crate serde;\n extern crate test;\n \n-include!(\"../../serde_tests/tests/test.rs.in\");\n+include!(\"../../testing/tests/test.rs.in\");\n \n mod compile_tests;\ndiff --git a/serde_test/Cargo.toml b/serde_test/Cargo.toml\nnew file mode 100644\nindex 000000000..055c3d9ff\n--- /dev/null\n+++ b/serde_test/Cargo.toml\n@@ -0,0 +1,14 @@\n+[package]\n+name = \"serde_test\"\n+version = \"0.7.11\"\n+authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n+license = \"MIT/Apache-2.0\"\n+description = \"Token De/Serializer for testing De/Serialize implementations\"\n+repository = \"https://github.com/serde-rs/serde\"\n+documentation = \"https://serde-rs.github.io/serde/serde/\"\n+readme = \"../README.md\"\n+keywords = [\"serde\", \"serialization\"]\n+include = [\"Cargo.toml\", \"src/**/*.rs\"]\n+\n+[dependencies]\n+serde = { version = \"0.7.11\", path = \"../serde\" }\ndiff --git a/serde_test/src/assert.rs b/serde_test/src/assert.rs\nnew file mode 100644\nindex 000000000..b5e03f52e\n--- /dev/null\n+++ b/serde_test/src/assert.rs\n@@ -0,0 +1,54 @@\n+use serde::{Serialize, Deserialize};\n+\n+use de::Deserializer;\n+use error::Error;\n+use ser::Serializer;\n+use token::Token;\n+\n+use std::fmt::Debug;\n+\n+pub fn assert_tokens<T>(value: &T, tokens: &[Token<'static>])\n+    where T: Serialize + Deserialize + PartialEq + Debug,\n+{\n+    assert_ser_tokens(value, tokens);\n+    assert_de_tokens(value, tokens);\n+}\n+\n+pub fn assert_ser_tokens<T>(value: &T, tokens: &[Token])\n+    where T: Serialize,\n+{\n+    let mut ser = Serializer::new(tokens.iter());\n+    assert_eq!(Serialize::serialize(value, &mut ser), Ok(()));\n+    assert_eq!(ser.next_token(), None);\n+}\n+\n+/// Expect an error serializing `T`.\n+pub fn assert_ser_tokens_error<T>(value: &T, tokens: &[Token], error: Error)\n+    where T: Serialize + PartialEq + Debug,\n+{\n+    let mut ser = Serializer::new(tokens.iter());\n+    let v: Result<(), Error> = Serialize::serialize(value, &mut ser);\n+    assert_eq!(v.as_ref(), Err(&error));\n+    assert_eq!(ser.next_token(), None);\n+}\n+\n+pub fn assert_de_tokens<T>(value: &T, tokens: &[Token<'static>])\n+    where T: Deserialize + PartialEq + Debug,\n+{\n+    let mut de = Deserializer::new(tokens.to_vec().into_iter());\n+    let v: Result<T, Error> = Deserialize::deserialize(&mut de);\n+    assert_eq!(v.as_ref(), Ok(value));\n+    assert_eq!(de.next_token(), None);\n+}\n+\n+/// Expect an error deserializing tokens into a `T`.\n+pub fn assert_de_tokens_error<T>(tokens: &[Token<'static>], error: Error)\n+    where T: Deserialize + PartialEq + Debug,\n+{\n+    let mut de = Deserializer::new(tokens.to_vec().into_iter());\n+    let v: Result<T, Error> = Deserialize::deserialize(&mut de);\n+    assert_eq!(v, Err(error));\n+    // There may be one token left if a peek caused the error\n+    de.next_token();\n+    assert_eq!(de.next_token(), None);\n+}\ndiff --git a/serde_tests/tests/token.rs b/serde_test/src/de.rs\nsimilarity index 52%\nrename from serde_tests/tests/token.rs\nrename to serde_test/src/de.rs\nindex bd20a9824..a2d4c3d7d 100644\n--- a/serde_tests/tests/token.rs\n+++ b/serde_test/src/de.rs\n@@ -1,493 +1,39 @@\n-use std::fmt;\n use std::iter;\n-use std::error;\n-\n-extern crate serde;\n-use self::serde::ser::{self, Serialize};\n-use self::serde::de;\n-use self::serde::de::value::{self, ValueDeserializer};\n-\n-#[derive(Clone, PartialEq, Debug)]\n-pub enum Token<'a> {\n-    Bool(bool),\n-    Isize(isize),\n-    I8(i8),\n-    I16(i16),\n-    I32(i32),\n-    I64(i64),\n-    Usize(usize),\n-    U8(u8),\n-    U16(u16),\n-    U32(u32),\n-    U64(u64),\n-    F32(f32),\n-    F64(f64),\n-    Char(char),\n-    Str(&'a str),\n-    String(String),\n-    Bytes(&'a [u8]),\n-\n-    Option(bool),\n-\n-    Unit,\n-    UnitStruct(&'a str),\n-\n-    StructNewType(&'a str),\n-\n-    EnumStart(&'a str),\n-    EnumUnit(&'a str, &'a str),\n-    EnumNewType(&'a str, &'a str),\n-\n-    SeqStart(Option<usize>),\n-    SeqArrayStart(usize),\n-    SeqSep,\n-    SeqEnd,\n-\n-    TupleStart(usize),\n-    TupleSep,\n-    TupleEnd,\n-\n-    TupleStructStart(&'a str, Option<usize>),\n-    TupleStructSep,\n-    TupleStructEnd,\n-\n-    MapStart(Option<usize>),\n-    MapSep,\n-    MapEnd,\n-\n-    StructStart(&'a str, Option<usize>),\n-    StructSep,\n-    StructEnd,\n-\n-    EnumSeqStart(&'a str, &'a str, Option<usize>),\n-    EnumSeqSep,\n-    EnumSeqEnd,\n-\n-    EnumMapStart(&'a str, &'a str, Option<usize>),\n-    EnumMapSep,\n-    EnumMapEnd,\n-}\n-\n-//////////////////////////////////////////////////////////////////////////////\n-\n-pub struct Serializer<I> {\n-    tokens: I,\n-}\n-\n-impl<'a, I> Serializer<I>\n-    where I: Iterator<Item=&'a Token<'a>>\n-{\n-    pub fn new(tokens: I) -> Serializer<I> {\n-        Serializer {\n-            tokens: tokens,\n-        }\n-    }\n-\n-    fn visit_sequence<V>(&mut self, mut visitor: V) -> Result<(), Error>\n-        where V: ser::SeqVisitor\n-    {\n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::SeqEnd));\n-\n-        Ok(())\n-    }\n \n-    fn visit_mapping<V>(&mut self, mut visitor: V) -> Result<(), Error>\n-        where V: ser::MapVisitor\n-    {\n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::MapEnd));\n+use serde::de::{\n+    self,\n+    Deserialize,\n+    EnumVisitor,\n+    MapVisitor,\n+    SeqVisitor,\n+    VariantVisitor,\n+    Visitor,\n+};\n \n-        Ok(())\n-    }\n-}\n+use error::Error;\n+use token::Token;\n \n-impl<'a, I> ser::Serializer for Serializer<I>\n-    where I: Iterator<Item=&'a Token<'a>>,\n+pub struct Deserializer<I>\n+    where I: Iterator<Item=Token<'static>>,\n {\n-    type Error = Error;\n-\n-    fn serialize_unit(&mut self) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::Unit));\n-        Ok(())\n-    }\n-\n-    fn serialize_newtype_variant<T>(&mut self,\n-                                name: &str,\n-                                _variant_index: usize,\n-                                variant: &str,\n-                                value: T) -> Result<(), Error>\n-        where T: ser::Serialize,\n-    {\n-        assert_eq!(self.tokens.next(), Some(&Token::EnumNewType(name, variant)));\n-        value.serialize(self)\n-    }\n-\n-    fn serialize_unit_struct(&mut self, name: &str) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::UnitStruct(name)));\n-        Ok(())\n-    }\n-\n-    fn serialize_unit_variant(&mut self,\n-                          name: &str,\n-                          _variant_index: usize,\n-                          variant: &str) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::EnumUnit(name, variant)));\n-\n-        Ok(())\n-    }\n-\n-    fn serialize_bool(&mut self, v: bool) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::Bool(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_isize(&mut self, v: isize) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::Isize(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_i8(&mut self, v: i8) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::I8(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_i16(&mut self, v: i16) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::I16(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_i32(&mut self, v: i32) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::I32(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_i64(&mut self, v: i64) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::I64(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_usize(&mut self, v: usize) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::Usize(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_u8(&mut self, v: u8) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::U8(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_u16(&mut self, v: u16) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::U16(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_u32(&mut self, v: u32) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::U32(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_u64(&mut self, v: u64) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::U64(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_f32(&mut self, v: f32) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::F32(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_f64(&mut self, v: f64) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::F64(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_char(&mut self, v: char) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::Char(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_str(&mut self, v: &str) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::Str(v)));\n-        Ok(())\n-    }\n-\n-    fn serialize_none(&mut self) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::Option(false)));\n-        Ok(())\n-    }\n-\n-    fn serialize_some<V>(&mut self, value: V) -> Result<(), Error>\n-        where V: ser::Serialize,\n-    {\n-        assert_eq!(self.tokens.next(), Some(&Token::Option(true)));\n-        value.serialize(self)\n-    }\n-\n-\n-    fn serialize_seq<V>(&mut self, visitor: V) -> Result<(), Error>\n-        where V: ser::SeqVisitor\n-    {\n-        let len = visitor.len();\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::SeqStart(len)));\n-\n-        self.visit_sequence(visitor)\n-    }\n-\n-    fn serialize_fixed_size_array<V>(&mut self, visitor: V) -> Result<(), Error>\n-        where V: ser::SeqVisitor\n-    {\n-        let len = visitor.len().expect(\"arrays must have a length\");\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::SeqArrayStart(len)));\n-\n-        self.visit_sequence(visitor)\n-    }\n-\n-    fn serialize_seq_elt<T>(&mut self, value: T) -> Result<(), Error>\n-        where T: ser::Serialize\n-    {\n-        assert_eq!(self.tokens.next(), Some(&Token::SeqSep));\n-        value.serialize(self)\n-    }\n-\n-    fn serialize_tuple<V>(&mut self, mut visitor: V) -> Result<(), Error>\n-        where V: ser::SeqVisitor\n-    {\n-        let len = visitor.len().expect(\"arrays must have a length\");\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::TupleStart(len)));\n-\n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::TupleEnd));\n-\n-        Ok(())\n-    }\n-\n-    fn serialize_tuple_elt<T>(&mut self, value: T) -> Result<(), Error>\n-        where T: ser::Serialize\n-    {\n-        assert_eq!(self.tokens.next(), Some(&Token::TupleSep));\n-        value.serialize(self)\n-    }\n-\n-    fn serialize_newtype_struct<T>(&mut self,\n-                               name: &'static str,\n-                               value: T) -> Result<(), Error>\n-        where T: ser::Serialize,\n-    {\n-        assert_eq!(self.tokens.next(), Some(&Token::StructNewType(name)));\n-        value.serialize(self)\n-    }\n-\n-    fn serialize_tuple_struct<V>(&mut self, name: &str, mut visitor: V) -> Result<(), Error>\n-        where V: ser::SeqVisitor\n-    {\n-        let len = visitor.len();\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::TupleStructStart(name, len)));\n-\n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::TupleStructEnd));\n-\n-        Ok(())\n-    }\n-\n-    fn serialize_tuple_struct_elt<T>(&mut self, value: T) -> Result<(), Error>\n-        where T: ser::Serialize,\n-    {\n-        assert_eq!(self.tokens.next(), Some(&Token::TupleStructSep));\n-        value.serialize(self)\n-    }\n-\n-    fn serialize_tuple_variant<V>(&mut self,\n-                                  name: &str,\n-                                  _variant_index: usize,\n-                                  variant: &str,\n-                                  mut visitor: V) -> Result<(), Error>\n-        where V: ser::SeqVisitor\n-    {\n-        let len = visitor.len();\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::EnumSeqStart(name, variant, len)));\n-\n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::EnumSeqEnd));\n-\n-        Ok(())\n-    }\n-\n-    fn serialize_tuple_variant_elt<T>(&mut self, value: T) -> Result<(), Error>\n-        where T: ser::Serialize,\n-    {\n-        assert_eq!(self.tokens.next(), Some(&Token::EnumSeqSep));\n-        value.serialize(self)\n-    }\n-\n-    fn serialize_map<V>(&mut self, visitor: V) -> Result<(), Error>\n-        where V: ser::MapVisitor\n-    {\n-        let len = visitor.len();\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::MapStart(len)));\n-\n-        self.visit_mapping(visitor)\n-    }\n-\n-    fn serialize_map_elt<K, V>(&mut self, key: K, value: V) -> Result<(), Error>\n-        where K: ser::Serialize,\n-              V: ser::Serialize,\n-    {\n-        assert_eq!(self.tokens.next(), Some(&Token::MapSep));\n-\n-        try!(key.serialize(self));\n-        value.serialize(self)\n-    }\n-\n-    fn serialize_struct<V>(&mut self, name: &str, mut visitor: V) -> Result<(), Error>\n-        where V: ser::MapVisitor\n-    {\n-        let len = visitor.len();\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::StructStart(name, len)));\n-\n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::StructEnd));\n-\n-        Ok(())\n-    }\n-\n-    fn serialize_struct_elt<T>(&mut self, key: &'static str, value: T) -> Result<(), Error>\n-        where T: ser::Serialize,\n-    {\n-        assert_eq!(self.tokens.next(), Some(&Token::StructSep));\n-\n-        try!(key.serialize(self));\n-        value.serialize(self)\n-    }\n-\n-    fn serialize_struct_variant<V>(&mut self,\n-                                   name: &str,\n-                                   _variant_index: usize,\n-                                   variant: &str,\n-                                   mut visitor: V) -> Result<(), Error>\n-        where V: ser::MapVisitor\n-    {\n-        let len = visitor.len();\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::EnumMapStart(name, variant, len)));\n-\n-        while let Some(()) = try!(visitor.visit(self)) { }\n-\n-        assert_eq!(self.tokens.next(), Some(&Token::EnumMapEnd));\n-\n-        Ok(())\n-    }\n-\n-    fn serialize_struct_variant_elt<T>(&mut self, key: &'static str, value: T) -> Result<(), Error>\n-        where T: ser::Serialize,\n-    {\n-        assert_eq!(self.tokens.next(), Some(&Token::EnumMapSep));\n-\n-        try!(key.serialize(self));\n-        value.serialize(self)\n-    }\n-}\n-\n-//////////////////////////////////////////////////////////////////////////////\n-\n-#[derive(Clone, PartialEq, Debug)]\n-pub enum Error {\n-    SyntaxError,\n-    EndOfStreamError,\n-    UnknownFieldError(String),\n-    UnknownVariantError(String),\n-    MissingFieldError(&'static str),\n-    DuplicateFieldError(&'static str),\n-    InvalidName(&'static str),\n-    InvalidValue(String),\n-    UnexpectedToken(Token<'static>),\n-    ValueError(value::Error),\n-}\n-\n-impl ser::Error for Error {\n-    fn custom<T: Into<String>>(_: T) -> Error { Error::SyntaxError }\n-\n-    fn invalid_value(msg: &str) -> Error {\n-        Error::InvalidValue(msg.to_owned())\n-    }\n-}\n-\n-impl de::Error for Error {\n-    fn custom<T: Into<String>>(_: T) -> Error { Error::SyntaxError }\n-\n-    fn end_of_stream() -> Error { Error::EndOfStreamError }\n-\n-    fn invalid_value(msg: &str) -> Error {\n-        Error::InvalidValue(msg.to_owned())\n-    }\n-\n-    fn unknown_field(field: &str) -> Error {\n-        Error::UnknownFieldError(field.to_owned())\n-    }\n-\n-    fn unknown_variant(variant: &str) -> Error {\n-        Error::UnknownVariantError(variant.to_owned())\n-    }\n-\n-    fn missing_field(field: &'static str) -> Error {\n-        Error::MissingFieldError(field)\n-    }\n-\n-    fn duplicate_field(field: &'static str) -> Error {\n-        Error::DuplicateFieldError(field)\n-    }\n-}\n-\n-impl fmt::Display for Error {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        formatter.write_str(format!(\"{:?}\", self).as_ref())\n-    }\n-}\n-\n-impl error::Error for Error {\n-    fn description(&self) -> &str {\n-        \"Serde Deserialization Error\"\n-    }\n-\n-    fn cause(&self) -> Option<&error::Error> {\n-        None\n-    }\n-}\n-\n-impl From<value::Error> for Error {\n-    fn from(error: value::Error) -> Error {\n-        Error::ValueError(error)\n-    }\n-}\n-\n-struct Deserializer<I> where I: Iterator<Item=Token<'static>> {\n     tokens: iter::Peekable<I>,\n }\n \n impl<I> Deserializer<I>\n-    where I: Iterator<Item=Token<'static>>\n+    where I: Iterator<Item=Token<'static>>,\n {\n-    fn new(tokens: I) -> Deserializer<I> {\n+    pub fn new(tokens: I) -> Deserializer<I> {\n         Deserializer {\n             tokens: tokens.peekable(),\n         }\n     }\n \n+    pub fn next_token(&mut self) -> Option<Token<'static>> {\n+        self.tokens.next()\n+    }\n+\n     fn visit_seq<V>(&mut self, len: Option<usize>, mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         visitor.visit_seq(DeserializerSeqVisitor {\n             de: self,\n@@ -496,7 +42,7 @@ impl<I> Deserializer<I>\n     }\n \n     fn visit_array<V>(&mut self, len: usize, mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         visitor.visit_seq(DeserializerArrayVisitor {\n             de: self,\n@@ -505,7 +51,7 @@ impl<I> Deserializer<I>\n     }\n \n     fn visit_tuple<V>(&mut self, len: usize, mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         visitor.visit_seq(DeserializerTupleVisitor {\n             de: self,\n@@ -514,7 +60,7 @@ impl<I> Deserializer<I>\n     }\n \n     fn visit_tuple_struct<V>(&mut self, len: usize, mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         visitor.visit_seq(DeserializerTupleStructVisitor {\n             de: self,\n@@ -523,7 +69,7 @@ impl<I> Deserializer<I>\n     }\n \n     fn visit_variant_seq<V>(&mut self, len: Option<usize>, mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         visitor.visit_seq(DeserializerVariantSeqVisitor {\n             de: self,\n@@ -532,7 +78,7 @@ impl<I> Deserializer<I>\n     }\n \n     fn visit_map<V>(&mut self, len: Option<usize>, mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         visitor.visit_map(DeserializerMapVisitor {\n             de: self,\n@@ -541,7 +87,7 @@ impl<I> Deserializer<I>\n     }\n \n     fn visit_struct<V>(&mut self, len: Option<usize>, mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         visitor.visit_map(DeserializerStructVisitor {\n             de: self,\n@@ -550,7 +96,7 @@ impl<I> Deserializer<I>\n     }\n \n     fn visit_variant_map<V>(&mut self, len: Option<usize>, mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         visitor.visit_map(DeserializerVariantMapVisitor {\n             de: self,\n@@ -560,12 +106,12 @@ impl<I> Deserializer<I>\n }\n \n impl<I> de::Deserializer for Deserializer<I>\n-    where I: Iterator<Item=Token<'static>>\n+    where I: Iterator<Item=Token<'static>>,\n {\n     type Error = Error;\n \n     fn deserialize<V>(&mut self, mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         match self.tokens.next() {\n             Some(Token::Bool(v)) => visitor.visit_bool(v),\n@@ -599,14 +145,14 @@ impl<I> de::Deserializer for Deserializer<I>\n                 self.visit_map(len, visitor)\n             }\n             Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n     /// Hook into `Option` deserializing so we can treat `Unit` as a\n     /// `None`, or a regular value as `Some(value)`.\n     fn deserialize_option<V>(&mut self, mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         match self.tokens.peek() {\n             Some(&Token::Option(false)) => {\n@@ -622,7 +168,7 @@ impl<I> de::Deserializer for Deserializer<I>\n                 visitor.visit_none()\n             }\n             Some(_) => visitor.visit_some(self),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -630,7 +176,7 @@ impl<I> de::Deserializer for Deserializer<I>\n                      name: &str,\n                      _variants: &'static [&'static str],\n                      mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::EnumVisitor,\n+        where V: EnumVisitor,\n     {\n         match self.tokens.peek() {\n             Some(&Token::EnumStart(n)) if name == n => {\n@@ -652,12 +198,12 @@ impl<I> de::Deserializer for Deserializer<I>\n                 let token = self.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => { return Err(Error::EndOfStreamError); }\n+            None => { return Err(Error::EndOfStream); }\n         }\n     }\n \n     fn deserialize_unit_struct<V>(&mut self, name: &str, mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         match self.tokens.peek() {\n             Some(&Token::UnitStruct(n)) => {\n@@ -669,14 +215,14 @@ impl<I> de::Deserializer for Deserializer<I>\n                 }\n             }\n             Some(_) => self.deserialize(visitor),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n     fn deserialize_newtype_struct<V>(&mut self,\n                                      name: &str,\n                                      mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         match self.tokens.peek() {\n             Some(&Token::StructNewType(n)) => {\n@@ -688,14 +234,14 @@ impl<I> de::Deserializer for Deserializer<I>\n                 }\n             }\n             Some(_) => self.deserialize(visitor),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n     fn deserialize_fixed_size_array<V>(&mut self,\n                                        len: usize,\n                                        visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         match self.tokens.peek() {\n             Some(&Token::SeqArrayStart(_)) => {\n@@ -703,14 +249,14 @@ impl<I> de::Deserializer for Deserializer<I>\n                 self.visit_array(len, visitor)\n             }\n             Some(_) => self.deserialize(visitor),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n     fn deserialize_tuple<V>(&mut self,\n                             len: usize,\n                             mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         match self.tokens.peek() {\n             Some(&Token::Unit) => {\n@@ -738,7 +284,7 @@ impl<I> de::Deserializer for Deserializer<I>\n                 self.visit_tuple_struct(len, visitor)\n             }\n             Some(_) => self.deserialize(visitor),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -746,7 +292,7 @@ impl<I> de::Deserializer for Deserializer<I>\n                                    name: &str,\n                                    len: usize,\n                                    mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         match self.tokens.peek() {\n             Some(&Token::Unit) => {\n@@ -782,7 +328,7 @@ impl<I> de::Deserializer for Deserializer<I>\n                 }\n             }\n             Some(_) => self.deserialize(visitor),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -790,7 +336,7 @@ impl<I> de::Deserializer for Deserializer<I>\n                              name: &str,\n                              fields: &'static [&'static str],\n                              visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         match self.tokens.peek() {\n             Some(&Token::StructStart(n, _)) => {\n@@ -806,7 +352,7 @@ impl<I> de::Deserializer for Deserializer<I>\n                 self.visit_map(Some(fields.len()), visitor)\n             }\n             Some(_) => self.deserialize(visitor),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n }\n@@ -818,26 +364,26 @@ struct DeserializerSeqVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>>\n     len: Option<usize>,\n }\n \n-impl<'a, I> de::SeqVisitor for DeserializerSeqVisitor<'a, I>\n+impl<'a, I> SeqVisitor for DeserializerSeqVisitor<'a, I>\n     where I: Iterator<Item=Token<'static>>,\n {\n     type Error = Error;\n \n     fn visit<T>(&mut self) -> Result<Option<T>, Error>\n-        where T: de::Deserialize,\n+        where T: Deserialize,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::SeqSep) => {\n                 self.de.tokens.next();\n                 self.len = self.len.map(|len| len - 1);\n-                Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n+                Ok(Some(try!(Deserialize::deserialize(self.de))))\n             }\n             Some(&Token::SeqEnd) => Ok(None),\n             Some(_) => {\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -846,7 +392,7 @@ impl<'a, I> de::SeqVisitor for DeserializerSeqVisitor<'a, I>\n         match self.de.tokens.next() {\n             Some(Token::SeqEnd) => Ok(()),\n             Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -863,26 +409,26 @@ struct DeserializerArrayVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>\n     len: usize,\n }\n \n-impl<'a, I> de::SeqVisitor for DeserializerArrayVisitor<'a, I>\n+impl<'a, I> SeqVisitor for DeserializerArrayVisitor<'a, I>\n     where I: Iterator<Item=Token<'static>>,\n {\n     type Error = Error;\n \n     fn visit<T>(&mut self) -> Result<Option<T>, Error>\n-        where T: de::Deserialize,\n+        where T: Deserialize,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::SeqSep) => {\n                 self.de.tokens.next();\n                 self.len -= 1;\n-                Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n+                Ok(Some(try!(Deserialize::deserialize(self.de))))\n             }\n             Some(&Token::SeqEnd) => Ok(None),\n             Some(_) => {\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -891,7 +437,7 @@ impl<'a, I> de::SeqVisitor for DeserializerArrayVisitor<'a, I>\n         match self.de.tokens.next() {\n             Some(Token::SeqEnd) => Ok(()),\n             Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -907,26 +453,26 @@ struct DeserializerTupleVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>\n     len: usize,\n }\n \n-impl<'a, I> de::SeqVisitor for DeserializerTupleVisitor<'a, I>\n+impl<'a, I> SeqVisitor for DeserializerTupleVisitor<'a, I>\n     where I: Iterator<Item=Token<'static>>,\n {\n     type Error = Error;\n \n     fn visit<T>(&mut self) -> Result<Option<T>, Error>\n-        where T: de::Deserialize,\n+        where T: Deserialize,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::TupleSep) => {\n                 self.de.tokens.next();\n                 self.len -= 1;\n-                Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n+                Ok(Some(try!(Deserialize::deserialize(self.de))))\n             }\n             Some(&Token::TupleEnd) => Ok(None),\n             Some(_) => {\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -935,7 +481,7 @@ impl<'a, I> de::SeqVisitor for DeserializerTupleVisitor<'a, I>\n         match self.de.tokens.next() {\n             Some(Token::TupleEnd) => Ok(()),\n             Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -951,26 +497,26 @@ struct DeserializerTupleStructVisitor<'a, I: 'a> where I: Iterator<Item=Token<'s\n     len: usize,\n }\n \n-impl<'a, I> de::SeqVisitor for DeserializerTupleStructVisitor<'a, I>\n+impl<'a, I> SeqVisitor for DeserializerTupleStructVisitor<'a, I>\n     where I: Iterator<Item=Token<'static>>,\n {\n     type Error = Error;\n \n     fn visit<T>(&mut self) -> Result<Option<T>, Error>\n-        where T: de::Deserialize,\n+        where T: Deserialize,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::TupleStructSep) => {\n                 self.de.tokens.next();\n                 self.len -= 1;\n-                Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n+                Ok(Some(try!(Deserialize::deserialize(self.de))))\n             }\n             Some(&Token::TupleStructEnd) => Ok(None),\n             Some(_) => {\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -979,7 +525,7 @@ impl<'a, I> de::SeqVisitor for DeserializerTupleStructVisitor<'a, I>\n         match self.de.tokens.next() {\n             Some(Token::TupleStructEnd) => Ok(()),\n             Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -995,26 +541,26 @@ struct DeserializerVariantSeqVisitor<'a, I: 'a> where I: Iterator<Item=Token<'st\n     len: Option<usize>,\n }\n \n-impl<'a, I> de::SeqVisitor for DeserializerVariantSeqVisitor<'a, I>\n+impl<'a, I> SeqVisitor for DeserializerVariantSeqVisitor<'a, I>\n     where I: Iterator<Item=Token<'static>>,\n {\n     type Error = Error;\n \n     fn visit<T>(&mut self) -> Result<Option<T>, Error>\n-        where T: de::Deserialize,\n+        where T: Deserialize,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumSeqSep) => {\n                 self.de.tokens.next();\n                 self.len = self.len.map(|len| len - 1);\n-                Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n+                Ok(Some(try!(Deserialize::deserialize(self.de))))\n             }\n             Some(&Token::EnumSeqEnd) => Ok(None),\n             Some(_) => {\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -1023,7 +569,7 @@ impl<'a, I> de::SeqVisitor for DeserializerVariantSeqVisitor<'a, I>\n         match self.de.tokens.next() {\n             Some(Token::EnumSeqEnd) => Ok(()),\n             Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -1040,33 +586,33 @@ struct DeserializerMapVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>>\n     len: Option<usize>,\n }\n \n-impl<'a, I> de::MapVisitor for DeserializerMapVisitor<'a, I>\n+impl<'a, I> MapVisitor for DeserializerMapVisitor<'a, I>\n     where I: Iterator<Item=Token<'static>>,\n {\n     type Error = Error;\n \n     fn visit_key<K>(&mut self) -> Result<Option<K>, Error>\n-        where K: de::Deserialize,\n+        where K: Deserialize,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::MapSep) => {\n                 self.de.tokens.next();\n                 self.len = self.len.map(|len| if len > 0 { len - 1} else { 0 });\n-                Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n+                Ok(Some(try!(Deserialize::deserialize(self.de))))\n             }\n             Some(&Token::MapEnd) => Ok(None),\n             Some(_) => {\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n     fn visit_value<V>(&mut self) -> Result<V, Error>\n-        where V: de::Deserialize,\n+        where V: Deserialize,\n     {\n-        Ok(try!(de::Deserialize::deserialize(self.de)))\n+        Ok(try!(Deserialize::deserialize(self.de)))\n     }\n \n     fn end(&mut self) -> Result<(), Error> {\n@@ -1074,7 +620,7 @@ impl<'a, I> de::MapVisitor for DeserializerMapVisitor<'a, I>\n         match self.de.tokens.next() {\n             Some(Token::MapEnd) => Ok(()),\n             Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -1091,33 +637,33 @@ struct DeserializerStructVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static\n     len: Option<usize>,\n }\n \n-impl<'a, I> de::MapVisitor for DeserializerStructVisitor<'a, I>\n+impl<'a, I> MapVisitor for DeserializerStructVisitor<'a, I>\n     where I: Iterator<Item=Token<'static>>,\n {\n     type Error = Error;\n \n     fn visit_key<K>(&mut self) -> Result<Option<K>, Error>\n-        where K: de::Deserialize,\n+        where K: Deserialize,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::StructSep) => {\n                 self.de.tokens.next();\n                 self.len = self.len.map(|len| if len > 0 { len - 1} else { 0 });\n-                Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n+                Ok(Some(try!(Deserialize::deserialize(self.de))))\n             }\n             Some(&Token::StructEnd) => Ok(None),\n             Some(_) => {\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n     fn visit_value<V>(&mut self) -> Result<V, Error>\n-        where V: de::Deserialize,\n+        where V: Deserialize,\n     {\n-        Ok(try!(de::Deserialize::deserialize(self.de)))\n+        Ok(try!(Deserialize::deserialize(self.de)))\n     }\n \n     fn end(&mut self) -> Result<(), Error> {\n@@ -1125,7 +671,7 @@ impl<'a, I> de::MapVisitor for DeserializerStructVisitor<'a, I>\n         match self.de.tokens.next() {\n             Some(Token::StructEnd) => Ok(()),\n             Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -1141,27 +687,27 @@ struct DeserializerVariantVisitor<'a, I: 'a> where I: Iterator<Item=Token<'stati\n     de: &'a mut Deserializer<I>,\n }\n \n-impl<'a, I> de::VariantVisitor for DeserializerVariantVisitor<'a, I>\n+impl<'a, I> VariantVisitor for DeserializerVariantVisitor<'a, I>\n     where I: Iterator<Item=Token<'static>>,\n {\n     type Error = Error;\n \n     fn visit_variant<V>(&mut self) -> Result<V, Error>\n-        where V: de::Deserialize,\n+        where V: Deserialize,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumUnit(_, v))\n             | Some(&Token::EnumNewType(_, v))\n             | Some(&Token::EnumSeqStart(_, v, _))\n             | Some(&Token::EnumMapStart(_, v, _)) => {\n-                let mut de = ValueDeserializer::<Error>::into_deserializer(v);\n-                let value = try!(de::Deserialize::deserialize(&mut de));\n+                let mut de = de::value::ValueDeserializer::<Error>::into_deserializer(v);\n+                let value = try!(Deserialize::deserialize(&mut de));\n                 Ok(value)\n             }\n             Some(_) => {\n-                de::Deserialize::deserialize(self.de)\n+                Deserialize::deserialize(self.de)\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -1172,31 +718,31 @@ impl<'a, I> de::VariantVisitor for DeserializerVariantVisitor<'a, I>\n                 Ok(())\n             }\n             Some(_) => {\n-                de::Deserialize::deserialize(self.de)\n+                Deserialize::deserialize(self.de)\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n     fn visit_newtype<T>(&mut self) -> Result<T, Self::Error>\n-        where T: de::Deserialize,\n+        where T: Deserialize,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumNewType(_, _)) => {\n                 self.de.tokens.next();\n-                de::Deserialize::deserialize(self.de)\n+                Deserialize::deserialize(self.de)\n             }\n             Some(_) => {\n-                de::Deserialize::deserialize(self.de)\n+                Deserialize::deserialize(self.de)\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n     fn visit_tuple<V>(&mut self,\n                       len: usize,\n                       visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumSeqStart(_, _, Some(enum_len))) => {\n@@ -1218,16 +764,16 @@ impl<'a, I> de::VariantVisitor for DeserializerVariantVisitor<'a, I>\n                 }\n             }\n             Some(_) => {\n-                de::Deserialize::deserialize(self.de)\n+                Deserialize::deserialize(self.de)\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n     fn visit_struct<V>(&mut self,\n                        fields: &'static [&'static str],\n                        visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n+        where V: Visitor,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumMapStart(_, _, Some(enum_len))) => {\n@@ -1249,9 +795,9 @@ impl<'a, I> de::VariantVisitor for DeserializerVariantVisitor<'a, I>\n                 }\n             }\n             Some(_) => {\n-                de::Deserialize::deserialize(self.de)\n+                Deserialize::deserialize(self.de)\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n }\n@@ -1263,33 +809,33 @@ struct DeserializerVariantMapVisitor<'a, I: 'a> where I: Iterator<Item=Token<'st\n     len: Option<usize>,\n }\n \n-impl<'a, I> de::MapVisitor for DeserializerVariantMapVisitor<'a, I>\n+impl<'a, I> MapVisitor for DeserializerVariantMapVisitor<'a, I>\n     where I: Iterator<Item=Token<'static>>,\n {\n     type Error = Error;\n \n     fn visit_key<K>(&mut self) -> Result<Option<K>, Error>\n-        where K: de::Deserialize,\n+        where K: Deserialize,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumMapSep) => {\n                 self.de.tokens.next();\n                 self.len = self.len.map(|len| if len > 0 { len - 1} else { 0 });\n-                Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n+                Ok(Some(try!(Deserialize::deserialize(self.de))))\n             }\n             Some(&Token::EnumMapEnd) => Ok(None),\n             Some(_) => {\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n     fn visit_value<V>(&mut self) -> Result<V, Error>\n-        where V: de::Deserialize,\n+        where V: Deserialize,\n     {\n-        Ok(try!(de::Deserialize::deserialize(self.de)))\n+        Ok(try!(Deserialize::deserialize(self.de)))\n     }\n \n     fn end(&mut self) -> Result<(), Error> {\n@@ -1297,7 +843,7 @@ impl<'a, I> de::MapVisitor for DeserializerVariantMapVisitor<'a, I>\n         match self.de.tokens.next() {\n             Some(Token::EnumMapEnd) => Ok(()),\n             Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStreamError),\n+            None => Err(Error::EndOfStream),\n         }\n     }\n \n@@ -1306,89 +852,3 @@ impl<'a, I> de::MapVisitor for DeserializerVariantMapVisitor<'a, I>\n         (len, self.len)\n     }\n }\n-\n-//////////////////////////////////////////////////////////////////////////////\n-\n-pub fn assert_ser_tokens<T>(value: &T, tokens: &[Token])\n-    where T: ser::Serialize,\n-{\n-    let mut ser = Serializer::new(tokens.iter());\n-    assert_eq!(ser::Serialize::serialize(value, &mut ser), Ok(()));\n-    assert_eq!(ser.tokens.next(), None);\n-}\n-\n-// Expect an error deserializing tokens into a T\n-pub fn assert_ser_tokens_error<T>(value: &T, tokens: &[Token], error: Error)\n-    where T: ser::Serialize + PartialEq + fmt::Debug,\n-{\n-    let mut ser = Serializer::new(tokens.iter());\n-    let v: Result<(), Error> = ser::Serialize::serialize(value, &mut ser);\n-    assert_eq!(v.as_ref(), Err(&error));\n-}\n-\n-pub fn assert_de_tokens<T>(value: &T, tokens: Vec<Token<'static>>)\n-    where T: de::Deserialize + PartialEq + fmt::Debug,\n-{\n-    let mut de = Deserializer::new(tokens.into_iter());\n-    let v: Result<T, Error> = de::Deserialize::deserialize(&mut de);\n-    assert_eq!(v.as_ref(), Ok(value));\n-    assert_eq!(de.tokens.next(), None);\n-}\n-\n-// Expect an error deserializing tokens into a T\n-pub fn assert_de_tokens_error<T>(tokens: Vec<Token<'static>>, error: Error)\n-    where T: de::Deserialize + PartialEq + fmt::Debug,\n-{\n-    let mut de = Deserializer::new(tokens.into_iter());\n-    let v: Result<T, Error> = de::Deserialize::deserialize(&mut de);\n-    assert_eq!(v, Err(error));\n-}\n-\n-// Tests that the given token stream is ignorable when embedded in\n-// an otherwise normal struct\n-pub fn assert_de_tokens_ignore(ignorable_tokens: Vec<Token<'static>>) {\n-    #[derive(PartialEq, Debug, Deserialize)]\n-    struct IgnoreBase {\n-        a: i32,\n-    }\n-\n-    let expected = IgnoreBase{a: 1};\n-\n-    // Embed the tokens to be ignored in the normal token\n-    // stream for an IgnoreBase type\n-    let concated_tokens : Vec<Token<'static>> = vec![\n-            Token::MapStart(Some(2)),\n-                Token::MapSep,\n-                Token::Str(\"a\"),\n-                Token::I32(1),\n-\n-                Token::MapSep,\n-                Token::Str(\"ignored\")\n-        ]\n-        .into_iter()\n-        .chain(ignorable_tokens.into_iter())\n-        .chain(vec![\n-            Token::MapEnd,\n-        ].into_iter())\n-        .collect();\n-\n-    let mut de = Deserializer::new(concated_tokens.into_iter());\n-    let v: Result<IgnoreBase, Error> = de::Deserialize::deserialize(&mut de);\n-\n-    // We run this test on every token stream for convenience, but\n-    // some token streams don't make sense embedded as a map value,\n-    // so we ignore those. SyntaxError is the real sign of trouble.\n-    if let Err(Error::UnexpectedToken(_)) = v {\n-        return;\n-    }\n-\n-    assert_eq!(v.as_ref(), Ok(&expected));\n-    assert_eq!(de.tokens.next(), None);\n-}\n-\n-pub fn assert_tokens<T>(value: &T, tokens: Vec<Token<'static>>)\n-    where T: ser::Serialize + de::Deserialize + PartialEq + fmt::Debug,\n-{\n-    assert_ser_tokens(value, &tokens[..]);\n-    assert_de_tokens(value, tokens);\n-}\ndiff --git a/serde_test/src/error.rs b/serde_test/src/error.rs\nnew file mode 100644\nindex 000000000..d5c4c6e72\n--- /dev/null\n+++ b/serde_test/src/error.rs\n@@ -0,0 +1,87 @@\n+use std::{error, fmt};\n+\n+use serde::{ser, de};\n+\n+use token::Token;\n+\n+#[derive(Clone, PartialEq, Debug)]\n+pub enum Error {\n+    // Shared\n+    Custom(String),\n+    InvalidValue(String),\n+\n+    // De\n+    EndOfStream,\n+    InvalidType(de::Type),\n+    InvalidLength(usize),\n+    UnknownVariant(String),\n+    UnknownField(String),\n+    MissingField(&'static str),\n+    DuplicateField(&'static str),\n+    InvalidName(&'static str),\n+    UnexpectedToken(Token<'static>),\n+}\n+\n+impl ser::Error for Error {\n+    fn custom<T: Into<String>>(msg: T) -> Error {\n+        Error::Custom(msg.into())\n+    }\n+\n+    fn invalid_value(msg: &str) -> Error {\n+        Error::InvalidValue(msg.to_owned())\n+    }\n+}\n+\n+impl de::Error for Error {\n+    fn custom<T: Into<String>>(msg: T) -> Error {\n+        Error::Custom(msg.into())\n+    }\n+\n+    fn end_of_stream() -> Error {\n+        Error::EndOfStream\n+    }\n+\n+    fn invalid_type(ty: de::Type) -> Error {\n+        Error::InvalidType(ty)\n+    }\n+\n+    fn invalid_value(msg: &str) -> Error {\n+        Error::InvalidValue(msg.to_owned())\n+    }\n+\n+    fn invalid_length(len: usize) -> Error {\n+        Error::InvalidLength(len)\n+    }\n+\n+    fn unknown_variant(variant: &str) -> Error {\n+        Error::UnknownVariant(variant.to_owned())\n+    }\n+\n+    fn unknown_field(field: &str) -> Error {\n+        Error::UnknownField(field.to_owned())\n+    }\n+\n+    fn missing_field(field: &'static str) -> Error {\n+        Error::MissingField(field)\n+    }\n+\n+    fn duplicate_field(field: &'static str) -> Error {\n+        Error::DuplicateField(field)\n+    }\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        formatter.write_str(format!(\"{:?}\", self).as_ref())\n+    }\n+}\n+\n+impl error::Error for Error {\n+    fn description(&self) -> &str {\n+        \"Serde Error\"\n+    }\n+\n+    fn cause(&self) -> Option<&error::Error> {\n+        None\n+    }\n+}\ndiff --git a/serde_test/src/lib.rs b/serde_test/src/lib.rs\nnew file mode 100644\nindex 000000000..945262c02\n--- /dev/null\n+++ b/serde_test/src/lib.rs\n@@ -0,0 +1,22 @@\n+extern crate serde;\n+\n+mod assert;\n+pub use assert::{\n+    assert_tokens,\n+    assert_ser_tokens,\n+    assert_ser_tokens_error,\n+    assert_de_tokens,\n+    assert_de_tokens_error,\n+};\n+\n+mod ser;\n+pub use ser::Serializer;\n+\n+mod de;\n+pub use de::Deserializer;\n+\n+mod token;\n+pub use token::Token;\n+\n+mod error;\n+pub use error::Error;\ndiff --git a/serde_test/src/ser.rs b/serde_test/src/ser.rs\nnew file mode 100644\nindex 000000000..2f028d3b2\n--- /dev/null\n+++ b/serde_test/src/ser.rs\n@@ -0,0 +1,350 @@\n+use std::marker::PhantomData;\n+\n+use serde::ser::{\n+    self,\n+    MapVisitor,\n+    SeqVisitor,\n+    Serialize,\n+};\n+\n+use error::Error;\n+use token::Token;\n+\n+pub struct Serializer<'a, I>\n+    where I: Iterator<Item=&'a Token<'a>>,\n+{\n+    tokens: I,\n+    phantom: PhantomData<&'a Token<'a>>,\n+}\n+\n+impl<'a, I> Serializer<'a, I>\n+    where I: Iterator<Item=&'a Token<'a>>,\n+{\n+    pub fn new(tokens: I) -> Serializer<'a, I> {\n+        Serializer {\n+            tokens: tokens,\n+            phantom: PhantomData,\n+        }\n+    }\n+\n+    pub fn next_token(&mut self) -> Option<&'a Token<'a>> {\n+        self.tokens.next()\n+    }\n+\n+    fn visit_seq<V>(&mut self, mut visitor: V) -> Result<(), Error>\n+        where V: SeqVisitor\n+    {\n+        while let Some(()) = try!(visitor.visit(self)) { }\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::SeqEnd));\n+\n+        Ok(())\n+    }\n+\n+    fn visit_map<V>(&mut self, mut visitor: V) -> Result<(), Error>\n+        where V: MapVisitor\n+    {\n+        while let Some(()) = try!(visitor.visit(self)) { }\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::MapEnd));\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, I> ser::Serializer for Serializer<'a, I>\n+    where I: Iterator<Item=&'a Token<'a>>,\n+{\n+    type Error = Error;\n+\n+    fn serialize_unit(&mut self) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::Unit));\n+        Ok(())\n+    }\n+\n+    fn serialize_newtype_variant<T>(&mut self,\n+                                name: &str,\n+                                _variant_index: usize,\n+                                variant: &str,\n+                                value: T) -> Result<(), Error>\n+        where T: Serialize,\n+    {\n+        assert_eq!(self.tokens.next(), Some(&Token::EnumNewType(name, variant)));\n+        value.serialize(self)\n+    }\n+\n+    fn serialize_unit_struct(&mut self, name: &str) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::UnitStruct(name)));\n+        Ok(())\n+    }\n+\n+    fn serialize_unit_variant(&mut self,\n+                          name: &str,\n+                          _variant_index: usize,\n+                          variant: &str) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::EnumUnit(name, variant)));\n+\n+        Ok(())\n+    }\n+\n+    fn serialize_bool(&mut self, v: bool) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::Bool(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_isize(&mut self, v: isize) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::Isize(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_i8(&mut self, v: i8) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::I8(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_i16(&mut self, v: i16) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::I16(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_i32(&mut self, v: i32) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::I32(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_i64(&mut self, v: i64) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::I64(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_usize(&mut self, v: usize) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::Usize(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_u8(&mut self, v: u8) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::U8(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_u16(&mut self, v: u16) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::U16(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_u32(&mut self, v: u32) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::U32(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_u64(&mut self, v: u64) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::U64(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_f32(&mut self, v: f32) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::F32(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_f64(&mut self, v: f64) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::F64(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_char(&mut self, v: char) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::Char(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_str(&mut self, v: &str) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::Str(v)));\n+        Ok(())\n+    }\n+\n+    fn serialize_none(&mut self) -> Result<(), Error> {\n+        assert_eq!(self.tokens.next(), Some(&Token::Option(false)));\n+        Ok(())\n+    }\n+\n+    fn serialize_some<V>(&mut self, value: V) -> Result<(), Error>\n+        where V: Serialize,\n+    {\n+        assert_eq!(self.tokens.next(), Some(&Token::Option(true)));\n+        value.serialize(self)\n+    }\n+\n+\n+    fn serialize_seq<V>(&mut self, visitor: V) -> Result<(), Error>\n+        where V: SeqVisitor\n+    {\n+        let len = visitor.len();\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::SeqStart(len)));\n+\n+        self.visit_seq(visitor)\n+    }\n+\n+    fn serialize_fixed_size_array<V>(&mut self, visitor: V) -> Result<(), Error>\n+        where V: SeqVisitor\n+    {\n+        let len = visitor.len().expect(\"arrays must have a length\");\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::SeqArrayStart(len)));\n+\n+        self.visit_seq(visitor)\n+    }\n+\n+    fn serialize_seq_elt<T>(&mut self, value: T) -> Result<(), Error>\n+        where T: Serialize\n+    {\n+        assert_eq!(self.tokens.next(), Some(&Token::SeqSep));\n+        value.serialize(self)\n+    }\n+\n+    fn serialize_tuple<V>(&mut self, mut visitor: V) -> Result<(), Error>\n+        where V: SeqVisitor\n+    {\n+        let len = visitor.len().expect(\"arrays must have a length\");\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleStart(len)));\n+\n+        while let Some(()) = try!(visitor.visit(self)) { }\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleEnd));\n+\n+        Ok(())\n+    }\n+\n+    fn serialize_tuple_elt<T>(&mut self, value: T) -> Result<(), Error>\n+        where T: Serialize\n+    {\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleSep));\n+        value.serialize(self)\n+    }\n+\n+    fn serialize_newtype_struct<T>(&mut self,\n+                               name: &'static str,\n+                               value: T) -> Result<(), Error>\n+        where T: Serialize,\n+    {\n+        assert_eq!(self.tokens.next(), Some(&Token::StructNewType(name)));\n+        value.serialize(self)\n+    }\n+\n+    fn serialize_tuple_struct<V>(&mut self, name: &str, mut visitor: V) -> Result<(), Error>\n+        where V: SeqVisitor\n+    {\n+        let len = visitor.len();\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleStructStart(name, len)));\n+\n+        while let Some(()) = try!(visitor.visit(self)) { }\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleStructEnd));\n+\n+        Ok(())\n+    }\n+\n+    fn serialize_tuple_struct_elt<T>(&mut self, value: T) -> Result<(), Error>\n+        where T: Serialize,\n+    {\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleStructSep));\n+        value.serialize(self)\n+    }\n+\n+    fn serialize_tuple_variant<V>(&mut self,\n+                                  name: &str,\n+                                  _variant_index: usize,\n+                                  variant: &str,\n+                                  mut visitor: V) -> Result<(), Error>\n+        where V: SeqVisitor\n+    {\n+        let len = visitor.len();\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::EnumSeqStart(name, variant, len)));\n+\n+        while let Some(()) = try!(visitor.visit(self)) { }\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::EnumSeqEnd));\n+\n+        Ok(())\n+    }\n+\n+    fn serialize_tuple_variant_elt<T>(&mut self, value: T) -> Result<(), Error>\n+        where T: Serialize,\n+    {\n+        assert_eq!(self.tokens.next(), Some(&Token::EnumSeqSep));\n+        value.serialize(self)\n+    }\n+\n+    fn serialize_map<V>(&mut self, visitor: V) -> Result<(), Error>\n+        where V: MapVisitor\n+    {\n+        let len = visitor.len();\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::MapStart(len)));\n+\n+        self.visit_map(visitor)\n+    }\n+\n+    fn serialize_map_elt<K, V>(&mut self, key: K, value: V) -> Result<(), Error>\n+        where K: Serialize,\n+              V: Serialize,\n+    {\n+        assert_eq!(self.tokens.next(), Some(&Token::MapSep));\n+\n+        try!(key.serialize(self));\n+        value.serialize(self)\n+    }\n+\n+    fn serialize_struct<V>(&mut self, name: &str, mut visitor: V) -> Result<(), Error>\n+        where V: MapVisitor\n+    {\n+        let len = visitor.len();\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::StructStart(name, len)));\n+\n+        while let Some(()) = try!(visitor.visit(self)) { }\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::StructEnd));\n+\n+        Ok(())\n+    }\n+\n+    fn serialize_struct_elt<T>(&mut self, key: &'static str, value: T) -> Result<(), Error>\n+        where T: Serialize,\n+    {\n+        assert_eq!(self.tokens.next(), Some(&Token::StructSep));\n+\n+        try!(key.serialize(self));\n+        value.serialize(self)\n+    }\n+\n+    fn serialize_struct_variant<V>(&mut self,\n+                                   name: &str,\n+                                   _variant_index: usize,\n+                                   variant: &str,\n+                                   mut visitor: V) -> Result<(), Error>\n+        where V: MapVisitor\n+    {\n+        let len = visitor.len();\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::EnumMapStart(name, variant, len)));\n+\n+        while let Some(()) = try!(visitor.visit(self)) { }\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::EnumMapEnd));\n+\n+        Ok(())\n+    }\n+\n+    fn serialize_struct_variant_elt<T>(&mut self, key: &'static str, value: T) -> Result<(), Error>\n+        where T: Serialize,\n+    {\n+        assert_eq!(self.tokens.next(), Some(&Token::EnumMapSep));\n+\n+        try!(key.serialize(self));\n+        value.serialize(self)\n+    }\n+}\ndiff --git a/serde_test/src/token.rs b/serde_test/src/token.rs\nnew file mode 100644\nindex 000000000..dcb1137f3\n--- /dev/null\n+++ b/serde_test/src/token.rs\n@@ -0,0 +1,60 @@\n+#[derive(Clone, PartialEq, Debug)]\n+pub enum Token<'a> {\n+    Bool(bool),\n+    Isize(isize),\n+    I8(i8),\n+    I16(i16),\n+    I32(i32),\n+    I64(i64),\n+    Usize(usize),\n+    U8(u8),\n+    U16(u16),\n+    U32(u32),\n+    U64(u64),\n+    F32(f32),\n+    F64(f64),\n+    Char(char),\n+    Str(&'a str),\n+    String(String),\n+    Bytes(&'a [u8]),\n+\n+    Option(bool),\n+\n+    Unit,\n+    UnitStruct(&'a str),\n+\n+    StructNewType(&'a str),\n+\n+    EnumStart(&'a str),\n+    EnumUnit(&'a str, &'a str),\n+    EnumNewType(&'a str, &'a str),\n+\n+    SeqStart(Option<usize>),\n+    SeqArrayStart(usize),\n+    SeqSep,\n+    SeqEnd,\n+\n+    TupleStart(usize),\n+    TupleSep,\n+    TupleEnd,\n+\n+    TupleStructStart(&'a str, Option<usize>),\n+    TupleStructSep,\n+    TupleStructEnd,\n+\n+    MapStart(Option<usize>),\n+    MapSep,\n+    MapEnd,\n+\n+    StructStart(&'a str, Option<usize>),\n+    StructSep,\n+    StructEnd,\n+\n+    EnumSeqStart(&'a str, &'a str, Option<usize>),\n+    EnumSeqSep,\n+    EnumSeqEnd,\n+\n+    EnumMapStart(&'a str, &'a str, Option<usize>),\n+    EnumMapSep,\n+    EnumMapEnd,\n+}\ndiff --git a/serde_tests/Cargo.toml b/testing/Cargo.toml\nsimilarity index 91%\nrename from serde_tests/Cargo.toml\nrename to testing/Cargo.toml\nindex 2f28417ad..a32b2f9f7 100644\n--- a/serde_tests/Cargo.toml\n+++ b/testing/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"serde_tests\"\n+name = \"serde_testing\"\n version = \"0.7.11\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n@@ -20,6 +20,7 @@ serde_codegen = { version = \"*\", path = \"../serde_codegen\", features = [\"with-sy\n fnv = \"1.0\"\n rustc-serialize = \"^0.3.16\"\n serde = { version = \"*\", path = \"../serde\" }\n+serde_test = { version = \"*\", path = \"../serde_test\" }\n \n [dependencies]\n clippy = { version = \"^0.*\", optional = true }\ndiff --git a/serde_tests/benches/bench.rs b/testing/benches/bench.rs\nsimilarity index 100%\nrename from serde_tests/benches/bench.rs\nrename to testing/benches/bench.rs\ndiff --git a/serde_tests/benches/bench.rs.in b/testing/benches/bench.rs.in\nsimilarity index 100%\nrename from serde_tests/benches/bench.rs.in\nrename to testing/benches/bench.rs.in\ndiff --git a/serde_tests/benches/bench_enum.rs b/testing/benches/bench_enum.rs\nsimilarity index 100%\nrename from serde_tests/benches/bench_enum.rs\nrename to testing/benches/bench_enum.rs\ndiff --git a/serde_tests/benches/bench_map.rs b/testing/benches/bench_map.rs\nsimilarity index 100%\nrename from serde_tests/benches/bench_map.rs\nrename to testing/benches/bench_map.rs\ndiff --git a/serde_tests/benches/bench_struct.rs b/testing/benches/bench_struct.rs\nsimilarity index 100%\nrename from serde_tests/benches/bench_struct.rs\nrename to testing/benches/bench_struct.rs\ndiff --git a/serde_tests/benches/bench_vec.rs b/testing/benches/bench_vec.rs\nsimilarity index 100%\nrename from serde_tests/benches/bench_vec.rs\nrename to testing/benches/bench_vec.rs\ndiff --git a/serde_tests/build.rs b/testing/build.rs\nsimilarity index 100%\nrename from serde_tests/build.rs\nrename to testing/build.rs\ndiff --git a/serde_tests/tests/macros.rs b/testing/tests/macros.rs\nsimilarity index 96%\nrename from serde_tests/tests/macros.rs\nrename to testing/tests/macros.rs\nindex 2446150ba..8ed4bf1d8 100644\n--- a/serde_tests/tests/macros.rs\n+++ b/testing/tests/macros.rs\n@@ -5,7 +5,7 @@ macro_rules! declare_ser_tests {\n             #[test]\n             fn $name() {\n                 $(\n-                    ::token::assert_ser_tokens(&$value, $tokens);\n+                    assert_ser_tokens(&$value, $tokens);\n                 )+\n             }\n         )+\ndiff --git a/serde_tests/tests/test.rs b/testing/tests/test.rs\nsimilarity index 100%\nrename from serde_tests/tests/test.rs\nrename to testing/tests/test.rs\ndiff --git a/serde_tests/tests/test.rs.in b/testing/tests/test.rs.in\nsimilarity index 91%\nrename from serde_tests/tests/test.rs.in\nrename to testing/tests/test.rs.in\nindex f64b84c18..32c000544 100644\n--- a/serde_tests/tests/test.rs.in\n+++ b/testing/tests/test.rs.in\n@@ -1,8 +1,6 @@\n #[macro_use]\n mod macros;\n \n-mod token;\n-\n mod test_annotations;\n mod test_bytes;\n mod test_de;\ndiff --git a/serde_tests/tests/test_annotations.rs b/testing/tests/test_annotations.rs\nsimilarity index 97%\nrename from serde_tests/tests/test_annotations.rs\nrename to testing/tests/test_annotations.rs\nindex 79e1683b3..0a7957250 100644\n--- a/serde_tests/tests/test_annotations.rs\n+++ b/testing/tests/test_annotations.rs\n@@ -1,7 +1,8 @@\n extern crate serde;\n use self::serde::{Serialize, Serializer, Deserialize, Deserializer};\n \n-use token::{\n+extern crate serde_test;\n+use self::serde_test::{\n     Error,\n     Token,\n     assert_tokens,\n@@ -80,7 +81,7 @@ struct DefaultStruct<A, B, C, D, E>\n fn test_default_struct() {\n     assert_de_tokens(\n         &DefaultStruct { a1: 1, a2: 2, a3: 3, a4: 0, a5: 123 },\n-        vec![\n+        &[\n             Token::StructStart(\"DefaultStruct\", Some(3)),\n \n             Token::StructSep,\n@@ -109,7 +110,7 @@ fn test_default_struct() {\n \n     assert_de_tokens(\n         &DefaultStruct { a1: 1, a2: 0, a3: 123, a4: 0, a5: 123 },\n-        vec![\n+        &[\n             Token::StructStart(\"DefaultStruct\", Some(1)),\n \n             Token::StructSep,\n@@ -143,7 +144,7 @@ enum DefaultEnum<A, B, C, D, E>\n fn test_default_enum() {\n     assert_de_tokens(\n         &DefaultEnum::Struct { a1: 1, a2: 2, a3: 3, a4: 0, a5: 123 },\n-        vec![\n+        &[\n             Token::EnumMapStart(\"DefaultEnum\", \"Struct\", Some(5)),\n \n             Token::EnumMapSep,\n@@ -172,7 +173,7 @@ fn test_default_enum() {\n \n     assert_de_tokens(\n         &DefaultEnum::Struct { a1: 1, a2: 0, a3: 123, a4: 0, a5: 123 },\n-        vec![\n+        &[\n             Token::EnumMapStart(\"DefaultEnum\", \"Struct\", Some(5)),\n \n             Token::EnumMapSep,\n@@ -206,7 +207,7 @@ struct ContainsNoStdDefault<A: MyDefault> {\n fn test_no_std_default() {\n     assert_de_tokens(\n         &ContainsNoStdDefault { a: NoStdDefault(123) },\n-        vec![\n+        &[\n             Token::StructStart(\"ContainsNoStdDefault\", Some(1)),\n             Token::StructEnd,\n         ]\n@@ -214,7 +215,7 @@ fn test_no_std_default() {\n \n     assert_de_tokens(\n         &ContainsNoStdDefault { a: NoStdDefault(8) },\n-        vec![\n+        &[\n             Token::StructStart(\"ContainsNoStdDefault\", Some(1)),\n \n             Token::StructSep,\n@@ -279,7 +280,7 @@ fn test_elt_not_deserialize() {\n             c: NotDeserializeStruct(123),\n             e: NotDeserializeEnum::Trouble,\n         },\n-        vec![\n+        &[\n             Token::StructStart(\"ContainsNotDeserialize\", Some(3)),\n             Token::StructEnd,\n         ]\n@@ -297,7 +298,7 @@ fn test_ignore_unknown() {\n     // 'Default' allows unknown. Basic smoke test of ignore...\n     assert_de_tokens(\n         &DefaultStruct { a1: 1, a2: 2, a3: 3, a4: 0, a5: 123 },\n-        vec![\n+        &[\n             Token::StructStart(\"DefaultStruct\", Some(5)),\n \n             Token::StructSep,\n@@ -332,7 +333,7 @@ fn test_ignore_unknown() {\n     );\n \n     assert_de_tokens_error::<DenyUnknown>(\n-        vec![\n+        &[\n             Token::StructStart(\"DenyUnknown\", Some(2)),\n \n             Token::StructSep,\n@@ -341,11 +342,8 @@ fn test_ignore_unknown() {\n \n             Token::StructSep,\n             Token::Str(\"whoops\"),\n-            Token::I32(2),\n-\n-            Token::StructEnd,\n         ],\n-        Error::UnknownFieldError(\"whoops\".to_owned())\n+        Error::UnknownField(\"whoops\".to_owned())\n     );\n }\n \n@@ -369,7 +367,7 @@ struct RenameStructSerializeDeserialize {\n fn test_rename_struct() {\n     assert_tokens(\n         &RenameStruct { a1: 1, a2: 2 },\n-        vec![\n+        &[\n             Token::StructStart(\"Superhero\", Some(2)),\n \n             Token::StructSep,\n@@ -403,7 +401,7 @@ fn test_rename_struct() {\n \n     assert_de_tokens(\n         &RenameStructSerializeDeserialize { a1: 1, a2: 2 },\n-        vec![\n+        &[\n             Token::StructStart(\"SuperheroDe\", Some(2)),\n \n             Token::StructSep,\n@@ -451,14 +449,14 @@ enum RenameEnumSerializeDeserialize<A> {\n fn test_rename_enum() {\n     assert_tokens(\n         &RenameEnum::Batman,\n-        vec![\n+        &[\n             Token::EnumUnit(\"Superhero\", \"bruce_wayne\"),\n         ]\n     );\n \n     assert_tokens(\n         &RenameEnum::Superman(0),\n-        vec![\n+        &[\n             Token::EnumNewType(\"Superhero\", \"clark_kent\"),\n             Token::I8(0),\n         ]\n@@ -466,7 +464,7 @@ fn test_rename_enum() {\n \n     assert_tokens(\n         &RenameEnum::WonderWoman(0, 1),\n-        vec![\n+        &[\n             Token::EnumSeqStart(\"Superhero\", \"diana_prince\", Some(2)),\n \n             Token::EnumSeqSep,\n@@ -481,7 +479,7 @@ fn test_rename_enum() {\n \n     assert_tokens(\n         &RenameEnum::Flash { a: 1 },\n-        vec![\n+        &[\n             Token::EnumMapStart(\"Superhero\", \"barry_allan\", Some(1)),\n \n             Token::EnumMapSep,\n@@ -517,7 +515,7 @@ fn test_rename_enum() {\n             a: 0,\n             b: String::new(),\n         },\n-        vec![\n+        &[\n             Token::EnumMapStart(\"SuperheroDe\", \"jason_todd\", Some(2)),\n \n             Token::EnumMapSep,\n@@ -807,7 +805,7 @@ fn test_deserialize_with_struct() {\n             a: 1,\n             b: 2,\n         },\n-        vec![\n+        &[\n             Token::StructStart(\"DeserializeWithStruct\", Some(2)),\n \n             Token::StructSep,\n@@ -827,7 +825,7 @@ fn test_deserialize_with_struct() {\n             a: 1,\n             b: 123,\n         },\n-        vec![\n+        &[\n             Token::StructStart(\"DeserializeWithStruct\", Some(2)),\n \n             Token::StructSep,\n@@ -859,7 +857,7 @@ fn test_deserialize_with_enum() {\n             a: 1,\n             b: 2,\n         },\n-        vec![\n+        &[\n             Token::EnumMapStart(\"DeserializeWithEnum\", \"Struct\", Some(2)),\n \n             Token::EnumMapSep,\n@@ -879,7 +877,7 @@ fn test_deserialize_with_enum() {\n             a: 1,\n             b: 123,\n         },\n-        vec![\n+        &[\n             Token::EnumMapStart(\"DeserializeWithEnum\", \"Struct\", Some(2)),\n \n             Token::EnumMapSep,\n@@ -898,7 +896,7 @@ fn test_deserialize_with_enum() {\n #[test]\n fn test_missing_renamed_field_struct() {\n     assert_de_tokens_error::<RenameStruct>(\n-        vec![\n+        &[\n             Token::StructStart(\"Superhero\", Some(2)),\n \n             Token::StructSep,\n@@ -907,11 +905,11 @@ fn test_missing_renamed_field_struct() {\n \n             Token::StructEnd,\n         ],\n-        Error::MissingFieldError(\"a3\"),\n+        Error::MissingField(\"a3\"),\n     );\n \n     assert_de_tokens_error::<RenameStructSerializeDeserialize>(\n-        vec![\n+        &[\n             Token::StructStart(\"SuperheroDe\", Some(2)),\n \n             Token::StructSep,\n@@ -920,23 +918,23 @@ fn test_missing_renamed_field_struct() {\n \n             Token::StructEnd,\n         ],\n-        Error::MissingFieldError(\"a5\"),\n+        Error::MissingField(\"a5\"),\n     );\n }\n \n #[test]\n fn test_missing_renamed_field_enum() {\n     assert_de_tokens_error::<RenameEnum>(\n-        vec![\n+        &[\n             Token::EnumMapStart(\"Superhero\", \"barry_allan\", Some(1)),\n \n             Token::EnumMapEnd,\n         ],\n-        Error::MissingFieldError(\"b\"),\n+        Error::MissingField(\"b\"),\n     );\n \n     assert_de_tokens_error::<RenameEnumSerializeDeserialize<i8>>(\n-        vec![\n+        &[\n             Token::EnumMapStart(\"SuperheroDe\", \"jason_todd\", Some(2)),\n \n             Token::EnumMapSep,\n@@ -945,6 +943,6 @@ fn test_missing_renamed_field_enum() {\n \n             Token::EnumMapEnd,\n         ],\n-        Error::MissingFieldError(\"d\"),\n+        Error::MissingField(\"d\"),\n     );\n }\ndiff --git a/serde_tests/tests/test_bytes.rs b/testing/tests/test_bytes.rs\nsimilarity index 100%\nrename from serde_tests/tests/test_bytes.rs\nrename to testing/tests/test_bytes.rs\ndiff --git a/serde_tests/tests/test_de.rs b/testing/tests/test_de.rs\nsimilarity index 74%\nrename from serde_tests/tests/test_de.rs\nrename to testing/tests/test_de.rs\nindex 2b9d00359..fcd174480 100644\n--- a/serde_tests/tests/test_de.rs\n+++ b/testing/tests/test_de.rs\n@@ -2,14 +2,17 @@ use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n use std::net;\n use std::path::PathBuf;\n \n+extern crate serde;\n+use self::serde::Deserialize;\n+\n extern crate fnv;\n use self::fnv::FnvHasher;\n \n-use token::{\n+extern crate serde_test;\n+use self::serde_test::{\n     Error,\n     Token,\n     assert_de_tokens,\n-    assert_de_tokens_ignore,\n     assert_de_tokens_error,\n };\n \n@@ -73,107 +76,147 @@ macro_rules! declare_error_tests {\n     }\n }\n \n+fn assert_de_tokens_ignore(ignorable_tokens: &[Token<'static>]) {\n+    #[derive(PartialEq, Debug, Deserialize)]\n+    struct IgnoreBase {\n+        a: i32,\n+    }\n+ \n+    let expected = IgnoreBase{a: 1};\n+ \n+    // Embed the tokens to be ignored in the normal token\n+    // stream for an IgnoreBase type\n+    let concated_tokens : Vec<Token<'static>> = vec![\n+            Token::MapStart(Some(2)),\n+                Token::MapSep,\n+                Token::Str(\"a\"),\n+                Token::I32(1),\n+ \n+                Token::MapSep,\n+                Token::Str(\"ignored\")\n+        ]\n+        .into_iter()\n+        .chain(ignorable_tokens.to_vec().into_iter())\n+        .chain(vec![\n+            Token::MapEnd,\n+        ].into_iter())\n+        .collect();\n+ \n+    let mut de = serde_test::Deserializer::new(concated_tokens.into_iter());\n+    let v: Result<IgnoreBase, Error> = Deserialize::deserialize(&mut de);\n+ \n+    // We run this test on every token stream for convenience, but\n+    // some token streams don't make sense embedded as a map value,\n+    // so we ignore those. SyntaxError is the real sign of trouble.\n+    if let Err(Error::UnexpectedToken(_)) = v {\n+        return;\n+    }\n+ \n+    assert_eq!(v.as_ref(), Ok(&expected));\n+    assert_eq!(de.next_token(), None);\n+}\n+\n //////////////////////////////////////////////////////////////////////////\n \n declare_tests! {\n     test_bool {\n-        true => vec![Token::Bool(true)],\n-        false => vec![Token::Bool(false)],\n+        true => &[Token::Bool(true)],\n+        false => &[Token::Bool(false)],\n     }\n     test_isize {\n-        0isize => vec![Token::Isize(0)],\n-        0isize => vec![Token::I8(0)],\n-        0isize => vec![Token::I16(0)],\n-        0isize => vec![Token::I32(0)],\n-        0isize => vec![Token::I64(0)],\n-        0isize => vec![Token::Usize(0)],\n-        0isize => vec![Token::U8(0)],\n-        0isize => vec![Token::U16(0)],\n-        0isize => vec![Token::U32(0)],\n-        0isize => vec![Token::U64(0)],\n-        0isize => vec![Token::F32(0.)],\n-        0isize => vec![Token::F64(0.)],\n+        0isize => &[Token::Isize(0)],\n+        0isize => &[Token::I8(0)],\n+        0isize => &[Token::I16(0)],\n+        0isize => &[Token::I32(0)],\n+        0isize => &[Token::I64(0)],\n+        0isize => &[Token::Usize(0)],\n+        0isize => &[Token::U8(0)],\n+        0isize => &[Token::U16(0)],\n+        0isize => &[Token::U32(0)],\n+        0isize => &[Token::U64(0)],\n+        0isize => &[Token::F32(0.)],\n+        0isize => &[Token::F64(0.)],\n     }\n     test_ints {\n-        0isize => vec![Token::Isize(0)],\n-        0i8 => vec![Token::I8(0)],\n-        0i16 => vec![Token::I16(0)],\n-        0i32 => vec![Token::I32(0)],\n-        0i64 => vec![Token::I64(0)],\n+        0isize => &[Token::Isize(0)],\n+        0i8 => &[Token::I8(0)],\n+        0i16 => &[Token::I16(0)],\n+        0i32 => &[Token::I32(0)],\n+        0i64 => &[Token::I64(0)],\n     }\n     test_uints {\n-        0usize => vec![Token::Usize(0)],\n-        0u8 => vec![Token::U8(0)],\n-        0u16 => vec![Token::U16(0)],\n-        0u32 => vec![Token::U32(0)],\n-        0u64 => vec![Token::U64(0)],\n+        0usize => &[Token::Usize(0)],\n+        0u8 => &[Token::U8(0)],\n+        0u16 => &[Token::U16(0)],\n+        0u32 => &[Token::U32(0)],\n+        0u64 => &[Token::U64(0)],\n     }\n     test_floats {\n-        0f32 => vec![Token::F32(0.)],\n-        0f64 => vec![Token::F64(0.)],\n+        0f32 => &[Token::F32(0.)],\n+        0f64 => &[Token::F64(0.)],\n     }\n     test_char {\n-        'a' => vec![Token::Char('a')],\n-        'a' => vec![Token::Str(\"a\")],\n-        'a' => vec![Token::String(\"a\".to_owned())],\n+        'a' => &[Token::Char('a')],\n+        'a' => &[Token::Str(\"a\")],\n+        'a' => &[Token::String(\"a\".to_owned())],\n     }\n     test_string {\n-        \"abc\".to_owned() => vec![Token::Str(\"abc\")],\n-        \"abc\".to_owned() => vec![Token::String(\"abc\".to_owned())],\n-        \"a\".to_owned() => vec![Token::Char('a')],\n+        \"abc\".to_owned() => &[Token::Str(\"abc\")],\n+        \"abc\".to_owned() => &[Token::String(\"abc\".to_owned())],\n+        \"a\".to_owned() => &[Token::Char('a')],\n     }\n     test_option {\n-        None::<i32> => vec![Token::Unit],\n-        None::<i32> => vec![Token::Option(false)],\n-        Some(1) => vec![Token::I32(1)],\n-        Some(1) => vec![\n+        None::<i32> => &[Token::Unit],\n+        None::<i32> => &[Token::Option(false)],\n+        Some(1) => &[Token::I32(1)],\n+        Some(1) => &[\n             Token::Option(true),\n             Token::I32(1),\n         ],\n     }\n     test_result {\n-        Ok::<i32, i32>(0) => vec![\n+        Ok::<i32, i32>(0) => &[\n             Token::EnumStart(\"Result\"),\n             Token::Str(\"Ok\"),\n             Token::I32(0),\n         ],\n-        Err::<i32, i32>(1) => vec![\n+        Err::<i32, i32>(1) => &[\n             Token::EnumStart(\"Result\"),\n             Token::Str(\"Err\"),\n             Token::I32(1),\n         ],\n     }\n     test_unit {\n-        () => vec![Token::Unit],\n-        () => vec![\n+        () => &[Token::Unit],\n+        () => &[\n             Token::SeqStart(Some(0)),\n             Token::SeqEnd,\n         ],\n-        () => vec![\n+        () => &[\n             Token::SeqStart(None),\n             Token::SeqEnd,\n         ],\n-        () => vec![\n+        () => &[\n             Token::TupleStructStart(\"Anything\", Some(0)),\n             Token::SeqEnd,\n         ],\n     }\n     test_unit_struct {\n-        UnitStruct => vec![Token::Unit],\n-        UnitStruct => vec![\n+        UnitStruct => &[Token::Unit],\n+        UnitStruct => &[\n             Token::UnitStruct(\"UnitStruct\"),\n         ],\n-        UnitStruct => vec![\n+        UnitStruct => &[\n             Token::SeqStart(Some(0)),\n             Token::SeqEnd,\n         ],\n-        UnitStruct => vec![\n+        UnitStruct => &[\n             Token::SeqStart(None),\n             Token::SeqEnd,\n         ],\n     }\n     test_tuple_struct {\n-        TupleStruct(1, 2, 3) => vec![\n+        TupleStruct(1, 2, 3) => &[\n             Token::SeqStart(Some(3)),\n                 Token::SeqSep,\n                 Token::I32(1),\n@@ -185,7 +228,7 @@ declare_tests! {\n                 Token::I32(3),\n             Token::SeqEnd,\n         ],\n-        TupleStruct(1, 2, 3) => vec![\n+        TupleStruct(1, 2, 3) => &[\n             Token::SeqStart(None),\n                 Token::SeqSep,\n                 Token::I32(1),\n@@ -197,7 +240,7 @@ declare_tests! {\n                 Token::I32(3),\n             Token::SeqEnd,\n         ],\n-        TupleStruct(1, 2, 3) => vec![\n+        TupleStruct(1, 2, 3) => &[\n             Token::TupleStructStart(\"TupleStruct\", Some(3)),\n                 Token::TupleStructSep,\n                 Token::I32(1),\n@@ -209,7 +252,7 @@ declare_tests! {\n                 Token::I32(3),\n             Token::TupleStructEnd,\n         ],\n-        TupleStruct(1, 2, 3) => vec![\n+        TupleStruct(1, 2, 3) => &[\n             Token::TupleStructStart(\"TupleStruct\", None),\n                 Token::TupleStructSep,\n                 Token::I32(1),\n@@ -223,14 +266,14 @@ declare_tests! {\n         ],\n     }\n     test_btreeset {\n-        BTreeSet::<isize>::new() => vec![\n+        BTreeSet::<isize>::new() => &[\n             Token::Unit,\n         ],\n-        BTreeSet::<isize>::new() => vec![\n+        BTreeSet::<isize>::new() => &[\n             Token::SeqStart(Some(0)),\n             Token::SeqEnd,\n         ],\n-        btreeset![btreeset![], btreeset![1], btreeset![2, 3]] => vec![\n+        btreeset![btreeset![], btreeset![1], btreeset![2, 3]] => &[\n             Token::SeqStart(Some(3)),\n                 Token::SeqSep,\n                 Token::SeqStart(Some(0)),\n@@ -252,23 +295,23 @@ declare_tests! {\n                 Token::SeqEnd,\n             Token::SeqEnd,\n         ],\n-        BTreeSet::<isize>::new() => vec![\n+        BTreeSet::<isize>::new() => &[\n             Token::UnitStruct(\"Anything\"),\n         ],\n-        BTreeSet::<isize>::new() => vec![\n+        BTreeSet::<isize>::new() => &[\n             Token::TupleStructStart(\"Anything\", Some(0)),\n             Token::SeqEnd,\n         ],\n     }\n     test_hashset {\n-        HashSet::<isize>::new() => vec![\n+        HashSet::<isize>::new() => &[\n             Token::Unit,\n         ],\n-        HashSet::<isize>::new() => vec![\n+        HashSet::<isize>::new() => &[\n             Token::SeqStart(Some(0)),\n             Token::SeqEnd,\n         ],\n-        hashset![1, 2, 3] => vec![\n+        hashset![1, 2, 3] => &[\n             Token::SeqStart(Some(3)),\n                 Token::SeqSep,\n                 Token::I32(1),\n@@ -280,14 +323,14 @@ declare_tests! {\n                 Token::I32(3),\n             Token::SeqEnd,\n         ],\n-        HashSet::<isize>::new() => vec![\n+        HashSet::<isize>::new() => &[\n             Token::UnitStruct(\"Anything\"),\n         ],\n-        HashSet::<isize>::new() => vec![\n+        HashSet::<isize>::new() => &[\n             Token::TupleStructStart(\"Anything\", Some(0)),\n             Token::SeqEnd,\n         ],\n-        hashset![FnvHasher @ 1, 2, 3] => vec![\n+        hashset![FnvHasher @ 1, 2, 3] => &[\n             Token::SeqStart(Some(3)),\n                 Token::SeqSep,\n                 Token::I32(1),\n@@ -301,14 +344,14 @@ declare_tests! {\n         ],\n     }\n     test_vec {\n-        Vec::<isize>::new() => vec![\n+        Vec::<isize>::new() => &[\n             Token::Unit,\n         ],\n-        Vec::<isize>::new() => vec![\n+        Vec::<isize>::new() => &[\n             Token::SeqStart(Some(0)),\n             Token::SeqEnd,\n         ],\n-        vec![vec![], vec![1], vec![2, 3]] => vec![\n+        vec![vec![], vec![1], vec![2, 3]] => &[\n             Token::SeqStart(Some(3)),\n                 Token::SeqSep,\n                 Token::SeqStart(Some(0)),\n@@ -330,27 +373,27 @@ declare_tests! {\n                 Token::SeqEnd,\n             Token::SeqEnd,\n         ],\n-        Vec::<isize>::new() => vec![\n+        Vec::<isize>::new() => &[\n             Token::UnitStruct(\"Anything\"),\n         ],\n-        Vec::<isize>::new() => vec![\n+        Vec::<isize>::new() => &[\n             Token::TupleStructStart(\"Anything\", Some(0)),\n             Token::SeqEnd,\n         ],\n     }\n     test_array {\n-        [0; 0] => vec![\n+        [0; 0] => &[\n             Token::Unit,\n         ],\n-        [0; 0] => vec![\n+        [0; 0] => &[\n             Token::SeqStart(Some(0)),\n             Token::SeqEnd,\n         ],\n-        [0; 0] => vec![\n+        [0; 0] => &[\n             Token::SeqArrayStart(0),\n             Token::SeqEnd,\n         ],\n-        ([0; 0], [1], [2, 3]) => vec![\n+        ([0; 0], [1], [2, 3]) => &[\n             Token::SeqStart(Some(3)),\n                 Token::SeqSep,\n                 Token::SeqStart(Some(0)),\n@@ -372,7 +415,7 @@ declare_tests! {\n                 Token::SeqEnd,\n             Token::SeqEnd,\n         ],\n-        ([0; 0], [1], [2, 3]) => vec![\n+        ([0; 0], [1], [2, 3]) => &[\n             Token::SeqArrayStart(3),\n                 Token::SeqSep,\n                 Token::SeqArrayStart(0),\n@@ -394,22 +437,22 @@ declare_tests! {\n                 Token::SeqEnd,\n             Token::SeqEnd,\n         ],\n-        [0; 0] => vec![\n+        [0; 0] => &[\n             Token::UnitStruct(\"Anything\"),\n         ],\n-        [0; 0] => vec![\n+        [0; 0] => &[\n             Token::TupleStructStart(\"Anything\", Some(0)),\n             Token::SeqEnd,\n         ],\n     }\n     test_tuple {\n-        (1,) => vec![\n+        (1,) => &[\n             Token::SeqStart(Some(1)),\n                 Token::SeqSep,\n                 Token::I32(1),\n             Token::SeqEnd,\n         ],\n-        (1, 2, 3) => vec![\n+        (1, 2, 3) => &[\n             Token::SeqStart(Some(3)),\n                 Token::SeqSep,\n                 Token::I32(1),\n@@ -421,13 +464,13 @@ declare_tests! {\n                 Token::I32(3),\n             Token::SeqEnd,\n         ],\n-        (1,) => vec![\n+        (1,) => &[\n             Token::TupleStart(1),\n                 Token::TupleSep,\n                 Token::I32(1),\n             Token::TupleEnd,\n         ],\n-        (1, 2, 3) => vec![\n+        (1, 2, 3) => &[\n             Token::TupleStart(3),\n                 Token::TupleSep,\n                 Token::I32(1),\n@@ -441,21 +484,21 @@ declare_tests! {\n         ],\n     }\n     test_btreemap {\n-        BTreeMap::<isize, isize>::new() => vec![\n+        BTreeMap::<isize, isize>::new() => &[\n             Token::Unit,\n         ],\n-        BTreeMap::<isize, isize>::new() => vec![\n+        BTreeMap::<isize, isize>::new() => &[\n             Token::MapStart(Some(0)),\n             Token::MapEnd,\n         ],\n-        btreemap![1 => 2] => vec![\n+        btreemap![1 => 2] => &[\n             Token::MapStart(Some(1)),\n                 Token::MapSep,\n                 Token::I32(1),\n                 Token::I32(2),\n             Token::MapEnd,\n         ],\n-        btreemap![1 => 2, 3 => 4] => vec![\n+        btreemap![1 => 2, 3 => 4] => &[\n             Token::MapStart(Some(2)),\n                 Token::MapSep,\n                 Token::I32(1),\n@@ -466,7 +509,7 @@ declare_tests! {\n                 Token::I32(4),\n             Token::MapEnd,\n         ],\n-        btreemap![1 => btreemap![], 2 => btreemap![3 => 4, 5 => 6]] => vec![\n+        btreemap![1 => btreemap![], 2 => btreemap![3 => 4, 5 => 6]] => &[\n             Token::MapStart(Some(2)),\n                 Token::MapSep,\n                 Token::I32(1),\n@@ -486,30 +529,30 @@ declare_tests! {\n                 Token::MapEnd,\n             Token::MapEnd,\n         ],\n-        BTreeMap::<isize, isize>::new() => vec![\n+        BTreeMap::<isize, isize>::new() => &[\n             Token::UnitStruct(\"Anything\"),\n         ],\n-        BTreeMap::<isize, isize>::new() => vec![\n+        BTreeMap::<isize, isize>::new() => &[\n             Token::StructStart(\"Anything\", Some(0)),\n             Token::MapEnd,\n         ],\n     }\n     test_hashmap {\n-        HashMap::<isize, isize>::new() => vec![\n+        HashMap::<isize, isize>::new() => &[\n             Token::Unit,\n         ],\n-        HashMap::<isize, isize>::new() => vec![\n+        HashMap::<isize, isize>::new() => &[\n             Token::MapStart(Some(0)),\n             Token::MapEnd,\n         ],\n-        hashmap![1 => 2] => vec![\n+        hashmap![1 => 2] => &[\n             Token::MapStart(Some(1)),\n                 Token::MapSep,\n                 Token::I32(1),\n                 Token::I32(2),\n             Token::MapEnd,\n         ],\n-        hashmap![1 => 2, 3 => 4] => vec![\n+        hashmap![1 => 2, 3 => 4] => &[\n             Token::MapStart(Some(2)),\n                 Token::MapSep,\n                 Token::I32(1),\n@@ -520,7 +563,7 @@ declare_tests! {\n                 Token::I32(4),\n             Token::MapEnd,\n         ],\n-        hashmap![1 => hashmap![], 2 => hashmap![3 => 4, 5 => 6]] => vec![\n+        hashmap![1 => hashmap![], 2 => hashmap![3 => 4, 5 => 6]] => &[\n             Token::MapStart(Some(2)),\n                 Token::MapSep,\n                 Token::I32(1),\n@@ -540,14 +583,14 @@ declare_tests! {\n                 Token::MapEnd,\n             Token::MapEnd,\n         ],\n-        HashMap::<isize, isize>::new() => vec![\n+        HashMap::<isize, isize>::new() => &[\n             Token::UnitStruct(\"Anything\"),\n         ],\n-        HashMap::<isize, isize>::new() => vec![\n+        HashMap::<isize, isize>::new() => &[\n             Token::StructStart(\"Anything\", Some(0)),\n             Token::MapEnd,\n         ],\n-        hashmap![FnvHasher @ 1 => 2, 3 => 4] => vec![\n+        hashmap![FnvHasher @ 1 => 2, 3 => 4] => &[\n             Token::MapStart(Some(2)),\n                 Token::MapSep,\n                 Token::I32(1),\n@@ -560,7 +603,7 @@ declare_tests! {\n         ],\n     }\n     test_struct {\n-        Struct { a: 1, b: 2, c: 0 } => vec![\n+        Struct { a: 1, b: 2, c: 0 } => &[\n             Token::MapStart(Some(3)),\n                 Token::MapSep,\n                 Token::Str(\"a\"),\n@@ -571,7 +614,7 @@ declare_tests! {\n                 Token::I32(2),\n             Token::MapEnd,\n         ],\n-        Struct { a: 1, b: 2, c: 0 } => vec![\n+        Struct { a: 1, b: 2, c: 0 } => &[\n             Token::StructStart(\"Struct\", Some(3)),\n                 Token::StructSep,\n                 Token::Str(\"a\"),\n@@ -582,7 +625,7 @@ declare_tests! {\n                 Token::I32(2),\n             Token::StructEnd,\n         ],\n-        Struct { a: 1, b: 2, c: 0 } => vec![\n+        Struct { a: 1, b: 2, c: 0 } => &[\n             Token::SeqStart(Some(3)),\n                 Token::SeqSep,\n                 Token::I32(1),\n@@ -593,7 +636,7 @@ declare_tests! {\n         ],\n     }\n     test_struct_with_skip {\n-        Struct { a: 1, b: 2, c: 0 } => vec![\n+        Struct { a: 1, b: 2, c: 0 } => &[\n             Token::MapStart(Some(3)),\n                 Token::MapSep,\n                 Token::Str(\"a\"),\n@@ -612,7 +655,7 @@ declare_tests! {\n                 Token::I32(4),\n             Token::MapEnd,\n         ],\n-        Struct { a: 1, b: 2, c: 0 } => vec![\n+        Struct { a: 1, b: 2, c: 0 } => &[\n             Token::StructStart(\"Struct\", Some(3)),\n                 Token::StructSep,\n                 Token::Str(\"a\"),\n@@ -633,18 +676,18 @@ declare_tests! {\n         ],\n     }\n     test_enum_unit {\n-        Enum::Unit => vec![\n+        Enum::Unit => &[\n             Token::EnumUnit(\"Enum\", \"Unit\"),\n         ],\n     }\n     test_enum_simple {\n-        Enum::Simple(1) => vec![\n+        Enum::Simple(1) => &[\n             Token::EnumNewType(\"Enum\", \"Simple\"),\n             Token::I32(1),\n         ],\n     }\n     test_enum_seq {\n-        Enum::Seq(1, 2, 3) => vec![\n+        Enum::Seq(1, 2, 3) => &[\n             Token::EnumSeqStart(\"Enum\", \"Seq\", Some(3)),\n                 Token::EnumSeqSep,\n                 Token::I32(1),\n@@ -658,7 +701,7 @@ declare_tests! {\n         ],\n     }\n     test_enum_map {\n-        Enum::Map { a: 1, b: 2, c: 3 } => vec![\n+        Enum::Map { a: 1, b: 2, c: 3 } => &[\n             Token::EnumMapStart(\"Enum\", \"Map\", Some(3)),\n                 Token::EnumMapSep,\n                 Token::Str(\"a\"),\n@@ -675,24 +718,24 @@ declare_tests! {\n         ],\n     }\n     test_enum_unit_usize {\n-        Enum::Unit => vec![\n+        Enum::Unit => &[\n             Token::EnumStart(\"Enum\"),\n             Token::Usize(0),\n             Token::Unit,\n         ],\n     }\n     test_enum_unit_bytes {\n-        Enum::Unit => vec![\n+        Enum::Unit => &[\n             Token::EnumStart(\"Enum\"),\n             Token::Bytes(b\"Unit\"),\n             Token::Unit,\n         ],\n     }\n     test_box {\n-        Box::new(0i32) => vec![Token::I32(0)],\n+        Box::new(0i32) => &[Token::I32(0)],\n     }\n     test_boxed_slice {\n-        Box::new([0, 1, 2]) => vec![\n+        Box::new([0, 1, 2]) => &[\n             Token::SeqStart(Some(3)),\n             Token::SeqSep,\n             Token::I32(0),\n@@ -704,18 +747,18 @@ declare_tests! {\n         ],\n     }\n     test_net_ipv4addr {\n-        \"1.2.3.4\".parse::<net::Ipv4Addr>().unwrap() => vec![Token::Str(\"1.2.3.4\")],\n+        \"1.2.3.4\".parse::<net::Ipv4Addr>().unwrap() => &[Token::Str(\"1.2.3.4\")],\n     }\n     test_net_ipv6addr {\n-        \"::1\".parse::<net::Ipv6Addr>().unwrap() => vec![Token::Str(\"::1\")],\n+        \"::1\".parse::<net::Ipv6Addr>().unwrap() => &[Token::Str(\"::1\")],\n     }\n     test_net_socketaddr {\n-        \"1.2.3.4:1234\".parse::<net::SocketAddr>().unwrap() => vec![Token::Str(\"1.2.3.4:1234\")],\n-        \"1.2.3.4:1234\".parse::<net::SocketAddrV4>().unwrap() => vec![Token::Str(\"1.2.3.4:1234\")],\n-        \"[::1]:1234\".parse::<net::SocketAddrV6>().unwrap() => vec![Token::Str(\"[::1]:1234\")],\n+        \"1.2.3.4:1234\".parse::<net::SocketAddr>().unwrap() => &[Token::Str(\"1.2.3.4:1234\")],\n+        \"1.2.3.4:1234\".parse::<net::SocketAddrV4>().unwrap() => &[Token::Str(\"1.2.3.4:1234\")],\n+        \"[::1]:1234\".parse::<net::SocketAddrV6>().unwrap() => &[Token::Str(\"[::1]:1234\")],\n     }\n     test_path_buf {\n-        PathBuf::from(\"/usr/local/lib\") => vec![\n+        PathBuf::from(\"/usr/local/lib\") => &[\n             Token::String(\"/usr/local/lib\".to_owned()),\n         ],\n     }\n@@ -726,30 +769,28 @@ declare_tests! {\n fn test_net_ipaddr() {\n     assert_de_tokens(\n         \"1.2.3.4\".parse::<net::IpAddr>().unwrap(),\n-        vec![Token::Str(\"1.2.3.4\")],\n+        &[Token::Str(\"1.2.3.4\")],\n     );\n }\n \n declare_error_tests! {\n     test_unknown_variant<Enum> {\n-        vec![\n+        &[\n             Token::EnumUnit(\"Enum\", \"Foo\"),\n         ],\n-        Error::UnknownVariantError(\"Foo\".to_owned()),\n+        Error::UnknownVariant(\"Foo\".to_owned()),\n     }\n     test_struct_seq_too_long<Struct> {\n-        vec![\n+        &[\n             Token::SeqStart(Some(4)),\n                 Token::SeqSep, Token::I32(1),\n                 Token::SeqSep, Token::I32(2),\n                 Token::SeqSep, Token::I32(3),\n-                Token::SeqSep, Token::I32(4),\n-            Token::SeqEnd,\n         ],\n         Error::UnexpectedToken(Token::SeqSep),\n     }\n     test_duplicate_field_struct<Struct> {\n-        vec![\n+        &[\n             Token::MapStart(Some(3)),\n                 Token::MapSep,\n                 Token::Str(\"a\"),\n@@ -757,13 +798,11 @@ declare_error_tests! {\n \n                 Token::MapSep,\n                 Token::Str(\"a\"),\n-                Token::I32(3),\n-            Token::MapEnd,\n         ],\n-        Error::DuplicateFieldError(\"a\"),\n+        Error::DuplicateField(\"a\"),\n     }\n     test_duplicate_field_enum<Enum> {\n-        vec![\n+        &[\n             Token::EnumMapStart(\"Enum\", \"Map\", Some(3)),\n                 Token::EnumMapSep,\n                 Token::Str(\"a\"),\n@@ -771,9 +810,7 @@ declare_error_tests! {\n \n                 Token::EnumMapSep,\n                 Token::Str(\"a\"),\n-                Token::I32(3),\n-            Token::EnumMapEnd,\n         ],\n-        Error::DuplicateFieldError(\"a\"),\n+        Error::DuplicateField(\"a\"),\n     }\n }\ndiff --git a/serde_tests/tests/test_gen.rs b/testing/tests/test_gen.rs\nsimilarity index 100%\nrename from serde_tests/tests/test_gen.rs\nrename to testing/tests/test_gen.rs\ndiff --git a/serde_tests/tests/test_macros.rs b/testing/tests/test_macros.rs\nsimilarity index 97%\nrename from serde_tests/tests/test_macros.rs\nrename to testing/tests/test_macros.rs\nindex 491acca20..ca4dffaa7 100644\n--- a/serde_tests/tests/test_macros.rs\n+++ b/testing/tests/test_macros.rs\n@@ -1,11 +1,12 @@\n-use std::marker::PhantomData;\n-use token::{Token, assert_tokens, assert_ser_tokens, assert_de_tokens};\n+extern crate serde_test;\n+use self::serde_test::{\n+    Token,\n+    assert_tokens,\n+    assert_ser_tokens,\n+    assert_de_tokens,\n+};\n \n-/*\n-trait Trait {\n-    type Type;\n-}\n-*/\n+use std::marker::PhantomData;\n \n // That tests that the derived Serialize implementation doesn't trigger\n // any warning about `serializer` not being used, in case of empty enums.\n@@ -161,7 +162,7 @@ struct DefaultTyParam<T: AssociatedType<X=i32> = i32> {\n fn test_named_unit() {\n     assert_tokens(\n         &NamedUnit,\n-        vec![Token::UnitStruct(\"NamedUnit\")]\n+        &[Token::UnitStruct(\"NamedUnit\")]\n     );\n }\n \n@@ -192,7 +193,7 @@ fn test_ser_named_tuple() {\n fn test_de_named_tuple() {\n     assert_de_tokens(\n         &DeNamedTuple(5, 6, 7),\n-        vec![\n+        &[\n             Token::SeqStart(Some(3)),\n             Token::SeqSep,\n             Token::I32(5),\n@@ -209,7 +210,7 @@ fn test_de_named_tuple() {\n \n     assert_de_tokens(\n         &DeNamedTuple(5, 6, 7),\n-        vec![\n+        &[\n             Token::TupleStructStart(\"DeNamedTuple\", Some(3)),\n             Token::TupleStructSep,\n             Token::I32(5),\n@@ -265,7 +266,7 @@ fn test_de_named_map() {\n             b: 6,\n             c: 7,\n         },\n-        vec![\n+        &[\n             Token::StructStart(\"DeNamedMap\", Some(3)),\n \n             Token::StructSep,\n@@ -379,7 +380,7 @@ fn test_ser_enum_map() {\n fn test_de_enum_unit() {\n     assert_tokens(\n         &DeEnum::Unit::<u32, u32, u32>,\n-        vec![\n+        &[\n             Token::EnumUnit(\"DeEnum\", \"Unit\"),\n         ],\n     );\n@@ -403,7 +404,7 @@ fn test_de_enum_seq() {\n             e,\n             //f,\n         ),\n-        vec![\n+        &[\n             Token::EnumSeqStart(\"DeEnum\", \"Seq\", Some(4)),\n \n             Token::EnumSeqSep,\n@@ -441,7 +442,7 @@ fn test_de_enum_map() {\n             e: e,\n             //f: f,\n         },\n-        vec![\n+        &[\n             Token::EnumMapStart(\"DeEnum\", \"Map\", Some(4)),\n \n             Token::EnumMapSep,\n@@ -516,7 +517,7 @@ fn test_lifetimes() {\n fn test_generic_struct() {\n     assert_tokens(\n         &GenericStruct { x: 5u32 },\n-        vec![\n+        &[\n             Token::StructStart(\"GenericStruct\", Some(1)),\n \n             Token::StructSep,\n@@ -532,7 +533,7 @@ fn test_generic_struct() {\n fn test_generic_newtype_struct() {\n     assert_tokens(\n         &GenericNewTypeStruct(5u32),\n-        vec![\n+        &[\n             Token::StructNewType(\"GenericNewTypeStruct\"),\n             Token::U32(5),\n         ]\n@@ -543,7 +544,7 @@ fn test_generic_newtype_struct() {\n fn test_generic_tuple_struct() {\n     assert_tokens(\n         &GenericTupleStruct(5u32, 6u32),\n-        vec![\n+        &[\n             Token::TupleStructStart(\"GenericTupleStruct\", Some(2)),\n \n             Token::TupleStructSep,\n@@ -561,7 +562,7 @@ fn test_generic_tuple_struct() {\n fn test_generic_enum_unit() {\n     assert_tokens(\n         &GenericEnum::Unit::<u32, u32>,\n-        vec![\n+        &[\n             Token::EnumUnit(\"GenericEnum\", \"Unit\"),\n         ]\n     );\n@@ -571,7 +572,7 @@ fn test_generic_enum_unit() {\n fn test_generic_enum_newtype() {\n     assert_tokens(\n         &GenericEnum::NewType::<u32, u32>(5),\n-        vec![\n+        &[\n             Token::EnumNewType(\"GenericEnum\", \"NewType\"),\n             Token::U32(5),\n         ]\n@@ -582,7 +583,7 @@ fn test_generic_enum_newtype() {\n fn test_generic_enum_seq() {\n     assert_tokens(\n         &GenericEnum::Seq::<u32, u32>(5, 6),\n-        vec![\n+        &[\n             Token::EnumSeqStart(\"GenericEnum\", \"Seq\", Some(2)),\n \n             Token::EnumSeqSep,\n@@ -600,7 +601,7 @@ fn test_generic_enum_seq() {\n fn test_generic_enum_map() {\n     assert_tokens(\n         &GenericEnum::Map::<u32, u32> { x: 5, y: 6 },\n-        vec![\n+        &[\n             Token::EnumMapStart(\"GenericEnum\", \"Map\", Some(2)),\n \n             Token::EnumMapSep,\n@@ -620,7 +621,7 @@ fn test_generic_enum_map() {\n fn test_default_ty_param() {\n     assert_tokens(\n         &DefaultTyParam::<i32> { phantom: PhantomData },\n-        vec![\n+        &[\n             Token::StructStart(\"DefaultTyParam\", Some(1)),\n \n             Token::StructSep,\ndiff --git a/serde_tests/tests/test_ser.rs b/testing/tests/test_ser.rs\nsimilarity index 96%\nrename from serde_tests/tests/test_ser.rs\nrename to testing/tests/test_ser.rs\nindex 5b3f215b9..981ddb86e 100644\n--- a/serde_tests/tests/test_ser.rs\n+++ b/testing/tests/test_ser.rs\n@@ -3,7 +3,13 @@ use std::net;\n use std::path::{Path, PathBuf};\n use std::str;\n \n-use token::{self, Token};\n+extern crate serde_test;\n+use self::serde_test::{\n+    Error,\n+    Token,\n+    assert_ser_tokens,\n+    assert_ser_tokens_error,\n+};\n \n extern crate fnv;\n use self::fnv::FnvHasher;\n@@ -355,16 +361,16 @@ fn test_cannot_serialize_paths() {\n     let path = unsafe {\n         str::from_utf8_unchecked(b\"Hello \\xF0\\x90\\x80World\")\n     };\n-    token::assert_ser_tokens_error(\n+    assert_ser_tokens_error(\n         &Path::new(path),\n-        &[Token::Str(\"Hello \ufffdWorld\")],\n-        token::Error::InvalidValue(\"Path contains invalid UTF-8 characters\".to_owned()));\n+        &[],\n+        Error::InvalidValue(\"Path contains invalid UTF-8 characters\".to_owned()));\n \n     let mut path_buf = PathBuf::new();\n     path_buf.push(path);\n \n-    token::assert_ser_tokens_error(\n+    assert_ser_tokens_error(\n         &path_buf,\n-        &[Token::Str(\"Hello \ufffdWorld\")],\n-        token::Error::InvalidValue(\"Path contains invalid UTF-8 characters\".to_owned()));\n+        &[],\n+        Error::InvalidValue(\"Path contains invalid UTF-8 characters\".to_owned()));\n }\n", "problem_statement": "Publish a serde_test crate containing the Token De/Serializer.\n[This Serializer and Deserializer](https://github.com/serde-rs/serde/blob/6ab508a93c8163a12315729f00fce4c539dfebd5/serde_tests/tests/token.rs) would be really useful for writing tests in other crates that implement Serialize/Deserialize for their types.\n\n", "hints_text": "", "created_at": "2016-06-29T05:26:15Z", "version": "0.7"}, {"repo": "serde-rs/serde", "pull_number": 371, "instance_id": "serde-rs__serde-371", "issue_numbers": ["369"], "base_commit": "84a573c92699ef13f27758c543d8b8038964d960", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex ed727aa23..bdd547c7f 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -32,7 +32,7 @@ use collections::enum_set::{CLike, EnumSet};\n #[cfg(all(feature = \"nightly\", feature = \"collections\"))]\n use collections::borrow::ToOwned;\n \n-use core::hash::Hash;\n+use core::hash::{Hash, BuildHasher};\n use core::marker::PhantomData;\n #[cfg(feature = \"std\")]\n use std::net;\n@@ -381,29 +381,30 @@ impl<T> Deserialize for PhantomData<T> where T: Deserialize {\n macro_rules! seq_impl {\n     (\n         $ty:ty,\n-        < $($constraints:ident),* >,\n-        $visitor_name:ident,\n+        $visitor_ty:ident < $($typaram:ident : $bound1:ident $(+ $bound2:ident)*),* >,\n         $visitor:ident,\n         $ctor:expr,\n         $with_capacity:expr,\n         $insert:expr\n     ) => {\n         /// A visitor that produces a sequence.\n-        pub struct $visitor_name<T> {\n-            marker: PhantomData<T>,\n+        pub struct $visitor_ty<$($typaram),*> {\n+            marker: PhantomData<$ty>,\n         }\n \n-        impl<T> $visitor_name<T> {\n+        impl<$($typaram),*> $visitor_ty<$($typaram),*>\n+            where $($typaram: $bound1 $(+ $bound2)*),*\n+        {\n             /// Construct a new sequence visitor.\n             pub fn new() -> Self {\n-                $visitor_name {\n+                $visitor_ty {\n                     marker: PhantomData,\n                 }\n             }\n         }\n \n-        impl<T> Visitor for $visitor_name<T>\n-            where T: $($constraints +)*,\n+        impl<$($typaram),*> Visitor for $visitor_ty<$($typaram),*>\n+            where $($typaram: $bound1 $(+ $bound2)*),*\n         {\n             type Value = $ty;\n \n@@ -430,13 +431,13 @@ macro_rules! seq_impl {\n             }\n         }\n \n-        impl<T> Deserialize for $ty\n-            where T: $($constraints +)*,\n+        impl<$($typaram),*> Deserialize for $ty\n+            where $($typaram: $bound1 $(+ $bound2)*),*\n         {\n             fn deserialize<D>(deserializer: &mut D) -> Result<$ty, D::Error>\n                 where D: Deserializer,\n             {\n-                deserializer.deserialize_seq($visitor_name::new())\n+                deserializer.deserialize_seq($visitor_ty::new())\n             }\n         }\n     }\n@@ -445,8 +446,7 @@ macro_rules! seq_impl {\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n seq_impl!(\n     BinaryHeap<T>,\n-    <Deserialize, Ord>,\n-    BinaryHeapVisitor,\n+    BinaryHeapVisitor<T: Deserialize + Ord>,\n     visitor,\n     BinaryHeap::new(),\n     BinaryHeap::with_capacity(visitor.size_hint().0),\n@@ -455,8 +455,7 @@ seq_impl!(\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n seq_impl!(\n     BTreeSet<T>,\n-    <Deserialize, Eq, Ord>,\n-    BTreeSetVisitor,\n+    BTreeSetVisitor<T: Deserialize + Eq + Ord>,\n     visitor,\n     BTreeSet::new(),\n     BTreeSet::new(),\n@@ -465,8 +464,7 @@ seq_impl!(\n #[cfg(all(feature = \"nightly\", feature = \"collections\"))]\n seq_impl!(\n     EnumSet<T>,\n-    <Deserialize, CLike>,\n-    EnumSetVisitor,\n+    EnumSetVisitor<T: Deserialize + CLike>,\n     visitor,\n     EnumSet::new(),\n     EnumSet::new(),\n@@ -475,8 +473,7 @@ seq_impl!(\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n seq_impl!(\n     LinkedList<T>,\n-    <Deserialize>,\n-    LinkedListVisitor,\n+    LinkedListVisitor<T: Deserialize>,\n     visitor,\n     LinkedList::new(),\n     LinkedList::new(),\n@@ -484,19 +481,18 @@ seq_impl!(\n \n #[cfg(feature = \"std\")]\n seq_impl!(\n-    HashSet<T>,\n-    <Deserialize, Eq, Hash>,\n-    HashSetVisitor,\n+    HashSet<T, S>,\n+    HashSetVisitor<T: Deserialize + Eq + Hash,\n+                   S: BuildHasher + Default>,\n     visitor,\n-    HashSet::new(),\n-    HashSet::with_capacity(visitor.size_hint().0),\n+    HashSet::with_hasher(S::default()),\n+    HashSet::with_capacity_and_hasher(visitor.size_hint().0, S::default()),\n     HashSet::insert);\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n seq_impl!(\n     Vec<T>,\n-    <Deserialize>,\n-    VecVisitor,\n+    VecVisitor<T: Deserialize>,\n     visitor,\n     Vec::new(),\n     Vec::with_capacity(visitor.size_hint().0),\n@@ -505,8 +501,7 @@ seq_impl!(\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n seq_impl!(\n     VecDeque<T>,\n-    <Deserialize>,\n-    VecDequeVisitor,\n+    VecDequeVisitor<T: Deserialize>,\n     visitor,\n     VecDeque::new(),\n     VecDeque::with_capacity(visitor.size_hint().0),\n@@ -726,30 +721,29 @@ tuple_impls! {\n macro_rules! map_impl {\n     (\n         $ty:ty,\n-        < $($constraints:ident),* >,\n-        $visitor_name:ident,\n+        $visitor_ty:ident < $($typaram:ident : $bound1:ident $(+ $bound2:ident)*),* >,\n         $visitor:ident,\n         $ctor:expr,\n-        $with_capacity:expr,\n-        $insert:expr\n+        $with_capacity:expr\n     ) => {\n         /// A visitor that produces a map.\n-        pub struct $visitor_name<K, V> {\n+        pub struct $visitor_ty<$($typaram),*> {\n             marker: PhantomData<$ty>,\n         }\n \n-        impl<K, V> $visitor_name<K, V> {\n+        impl<$($typaram),*> $visitor_ty<$($typaram),*>\n+            where $($typaram: $bound1 $(+ $bound2)*),*\n+        {\n             /// Construct a `MapVisitor*<T>`.\n             pub fn new() -> Self {\n-                $visitor_name {\n+                $visitor_ty {\n                     marker: PhantomData,\n                 }\n             }\n         }\n \n-        impl<K, V> Visitor for $visitor_name<K, V>\n-            where K: $($constraints +)*,\n-                  V: Deserialize,\n+        impl<$($typaram),*> Visitor for $visitor_ty<$($typaram),*>\n+            where $($typaram: $bound1 $(+ $bound2)*),*\n         {\n             type Value = $ty;\n \n@@ -767,7 +761,7 @@ macro_rules! map_impl {\n                 let mut values = $with_capacity;\n \n                 while let Some((key, value)) = try!($visitor.visit()) {\n-                    $insert(&mut values, key, value);\n+                    values.insert(key, value);\n                 }\n \n                 try!($visitor.end());\n@@ -776,14 +770,13 @@ macro_rules! map_impl {\n             }\n         }\n \n-        impl<K, V> Deserialize for $ty\n-            where K: $($constraints +)*,\n-                  V: Deserialize,\n+        impl<$($typaram),*> Deserialize for $ty\n+            where $($typaram: $bound1 $(+ $bound2)*),*\n         {\n             fn deserialize<D>(deserializer: &mut D) -> Result<$ty, D::Error>\n                 where D: Deserializer,\n             {\n-                deserializer.deserialize_map($visitor_name::new())\n+                deserializer.deserialize_map($visitor_ty::new())\n             }\n         }\n     }\n@@ -792,22 +785,21 @@ macro_rules! map_impl {\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n map_impl!(\n     BTreeMap<K, V>,\n-    <Deserialize, Eq, Ord>,\n-    BTreeMapVisitor,\n+    BTreeMapVisitor<K: Deserialize + Eq + Ord,\n+                    V: Deserialize>,\n     visitor,\n     BTreeMap::new(),\n-    BTreeMap::new(),\n-    BTreeMap::insert);\n+    BTreeMap::new());\n \n #[cfg(feature = \"std\")]\n map_impl!(\n-    HashMap<K, V>,\n-    <Deserialize, Eq, Hash>,\n-    HashMapVisitor,\n+    HashMap<K, V, S>,\n+    HashMapVisitor<K: Deserialize + Eq + Hash,\n+                   V: Deserialize,\n+                   S: BuildHasher + Default>,\n     visitor,\n-    HashMap::new(),\n-    HashMap::with_capacity(visitor.size_hint().0),\n-    HashMap::insert);\n+    HashMap::with_hasher(S::default()),\n+    HashMap::with_capacity_and_hasher(visitor.size_hint().0, S::default()));\n \n ///////////////////////////////////////////////////////////////////////////////\n \ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex b51226a95..dbc58cc34 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -31,7 +31,7 @@ use collections::enum_set::{CLike, EnumSet};\n #[cfg(all(feature = \"nightly\", feature = \"collections\"))]\n use collections::borrow::ToOwned;\n \n-use core::hash::Hash;\n+use core::hash::{Hash, BuildHasher};\n #[cfg(feature = \"nightly\")]\n use core::iter;\n #[cfg(feature = \"std\")]\n@@ -330,8 +330,9 @@ impl<T> Serialize for EnumSet<T>\n }\n \n #[cfg(feature = \"std\")]\n-impl<T> Serialize for HashSet<T>\n+impl<T, H> Serialize for HashSet<T, H>\n     where T: Serialize + Eq + Hash,\n+          H: BuildHasher,\n {\n     #[inline]\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n@@ -651,9 +652,10 @@ impl<K, V> Serialize for BTreeMap<K, V>\n }\n \n #[cfg(feature = \"std\")]\n-impl<K, V> Serialize for HashMap<K, V>\n+impl<K, V, H> Serialize for HashMap<K, V, H>\n     where K: Serialize + Eq + Hash,\n           V: Serialize,\n+          H: BuildHasher,\n {\n     #[inline]\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\ndiff --git a/serde_macros/Cargo.toml b/serde_macros/Cargo.toml\nindex 6ed3af892..dc72e77bc 100644\n--- a/serde_macros/Cargo.toml\n+++ b/serde_macros/Cargo.toml\n@@ -22,6 +22,7 @@ serde_codegen = { version = \"^0.7.10\", path = \"../serde_codegen\", default-featur\n \n [dev-dependencies]\n compiletest_rs = \"^0.1.1\"\n+fnv = \"1.0\"\n rustc-serialize = \"^0.3.16\"\n serde = { version = \"^0.7.9\", path = \"../serde\" }\n \n", "test_patch": "diff --git a/serde_tests/Cargo.toml b/serde_tests/Cargo.toml\nindex adb7a9401..477921763 100644\n--- a/serde_tests/Cargo.toml\n+++ b/serde_tests/Cargo.toml\n@@ -19,6 +19,7 @@ syntex_syntax = { version = \"^0.35.0\" }\n serde_codegen = { version = \"*\", path = \"../serde_codegen\", features = [\"with-syntex\"] }\n \n [dev-dependencies]\n+fnv = \"1.0\"\n rustc-serialize = \"^0.3.16\"\n serde = { version = \"*\", path = \"../serde\" }\n syntex = \"^0.35.0\"\ndiff --git a/serde_tests/tests/macros.rs b/serde_tests/tests/macros.rs\nindex 069d4f262..2446150ba 100644\n--- a/serde_tests/tests/macros.rs\n+++ b/serde_tests/tests/macros.rs\n@@ -62,6 +62,14 @@ macro_rules! hashset {\n             $(set.insert($value);)+\n             set\n         }\n+    };\n+    ($hasher:ident @ $($value:expr),+) => {\n+        {\n+            use std::hash::BuildHasherDefault;\n+            let mut set = HashSet::with_hasher(BuildHasherDefault::<$hasher>::default());\n+            $(set.insert($value);)+\n+            set\n+        }\n     }\n }\n \n@@ -75,5 +83,13 @@ macro_rules! hashmap {\n             $(map.insert($key, $value);)+\n             map\n         }\n+    };\n+    ($hasher:ident @ $($key:expr => $value:expr),+) => {\n+        {\n+            use std::hash::BuildHasherDefault;\n+            let mut map = HashMap::with_hasher(BuildHasherDefault::<$hasher>::default());\n+            $(map.insert($key, $value);)+\n+            map\n+        }\n     }\n }\ndiff --git a/serde_tests/tests/test_de.rs b/serde_tests/tests/test_de.rs\nindex 932b4b10b..2b9d00359 100644\n--- a/serde_tests/tests/test_de.rs\n+++ b/serde_tests/tests/test_de.rs\n@@ -2,6 +2,9 @@ use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n use std::net;\n use std::path::PathBuf;\n \n+extern crate fnv;\n+use self::fnv::FnvHasher;\n+\n use token::{\n     Error,\n     Token,\n@@ -284,6 +287,18 @@ declare_tests! {\n             Token::TupleStructStart(\"Anything\", Some(0)),\n             Token::SeqEnd,\n         ],\n+        hashset![FnvHasher @ 1, 2, 3] => vec![\n+            Token::SeqStart(Some(3)),\n+                Token::SeqSep,\n+                Token::I32(1),\n+\n+                Token::SeqSep,\n+                Token::I32(2),\n+\n+                Token::SeqSep,\n+                Token::I32(3),\n+            Token::SeqEnd,\n+        ],\n     }\n     test_vec {\n         Vec::<isize>::new() => vec![\n@@ -532,6 +547,17 @@ declare_tests! {\n             Token::StructStart(\"Anything\", Some(0)),\n             Token::MapEnd,\n         ],\n+        hashmap![FnvHasher @ 1 => 2, 3 => 4] => vec![\n+            Token::MapStart(Some(2)),\n+                Token::MapSep,\n+                Token::I32(1),\n+                Token::I32(2),\n+\n+                Token::MapSep,\n+                Token::I32(3),\n+                Token::I32(4),\n+            Token::MapEnd,\n+        ],\n     }\n     test_struct {\n         Struct { a: 1, b: 2, c: 0 } => vec![\ndiff --git a/serde_tests/tests/test_ser.rs b/serde_tests/tests/test_ser.rs\nindex 2a8117a1a..5b3f215b9 100644\n--- a/serde_tests/tests/test_ser.rs\n+++ b/serde_tests/tests/test_ser.rs\n@@ -1,10 +1,13 @@\n-use std::collections::BTreeMap;\n+use std::collections::{BTreeMap, HashMap, HashSet};\n use std::net;\n use std::path::{Path, PathBuf};\n use std::str;\n \n use token::{self, Token};\n \n+extern crate fnv;\n+use self::fnv::FnvHasher;\n+\n //////////////////////////////////////////////////////////////////////////\n \n #[derive(Serialize)]\n@@ -144,6 +147,24 @@ declare_ser_tests! {\n             Token::SeqEnd,\n         ],\n     }\n+    test_hashset {\n+        HashSet::<isize>::new() => &[\n+            Token::SeqStart(Some(0)),\n+            Token::SeqEnd,\n+        ],\n+        hashset![1] => &[\n+            Token::SeqStart(Some(1)),\n+                Token::SeqSep,\n+                Token::I32(1),\n+            Token::SeqEnd,\n+        ],\n+        hashset![FnvHasher @ 1] => &[\n+            Token::SeqStart(Some(1)),\n+                Token::SeqSep,\n+                Token::I32(1),\n+            Token::SeqEnd,\n+        ],\n+    }\n     test_tuple {\n         (1,) => &[\n             Token::TupleStart(1),\n@@ -204,6 +225,26 @@ declare_ser_tests! {\n             Token::MapEnd,\n         ],\n     }\n+    test_hashmap {\n+        HashMap::<isize, isize>::new() => &[\n+            Token::MapStart(Some(0)),\n+            Token::MapEnd,\n+        ],\n+        hashmap![1 => 2] => &[\n+            Token::MapStart(Some(1)),\n+                Token::MapSep,\n+                Token::I32(1),\n+                Token::I32(2),\n+            Token::MapEnd,\n+        ],\n+        hashmap![FnvHasher @ 1 => 2] => &[\n+            Token::MapStart(Some(1)),\n+                Token::MapSep,\n+                Token::I32(1),\n+                Token::I32(2),\n+            Token::MapEnd,\n+        ],\n+    }\n     test_unit_struct {\n         UnitStruct => &[Token::UnitStruct(\"UnitStruct\")],\n     }\n", "problem_statement": "implement Serialize + Deserialize for HashMap with custom hash functions\nAs far as I am aware the implementation of HashMap serialization/deserialization is only for SipHasher. \n\n```\nimpl<K, V> Serialize for HashMap<K, V>\n    where K: Serialize + Eq + Hash,\n          V: Serialize,\n```\n\nIs it feasible or desired to implement it for all hashers? (eg: `impl<K, V, S> Serialize for HashMap<K, V, S>`)\n\nMy specific use case is to serialize/deserialize a HashMap using https://github.com/servo/rust-fnv\n\n", "hints_text": "Custom hashers were added in Rust 1.7, and since serde is currently tracking the last 3 releases it seems like we could add support for this now. @dtolnay / @oli-obk: what do you two think?\n\nLet's do it.\n", "created_at": "2016-06-11T08:11:42Z", "version": "0.7"}, {"repo": "serde-rs/serde", "pull_number": 354, "instance_id": "serde-rs__serde-354", "issue_numbers": ["353"], "base_commit": "4b472be56e8b071a12b3b4f03c3829251812453c", "patch": "diff --git a/serde_codegen/src/attr.rs b/serde_codegen/src/attr.rs\nindex 2a3bd4979..b59e860b8 100644\n--- a/serde_codegen/src/attr.rs\n+++ b/serde_codegen/src/attr.rs\n@@ -82,7 +82,6 @@ impl ContainerAttrs {\n                     // Parse `#[serde(rename=\"foo\")]`\n                     ast::MetaItemKind::NameValue(ref name, ref lit) if name == &\"rename\" => {\n                         let s = try!(get_str_from_lit(cx, name, lit));\n-\n                         container_attrs.name.serialize_name = Some(s.clone());\n                         container_attrs.name.deserialize_name = Some(s);\n                     }\n@@ -90,9 +89,12 @@ impl ContainerAttrs {\n                     // Parse `#[serde(rename(serialize=\"foo\", deserialize=\"bar\"))]`\n                     ast::MetaItemKind::List(ref name, ref meta_items) if name == &\"rename\" => {\n                         let (ser_name, de_name) = try!(get_renames(cx, meta_items));\n-\n-                        container_attrs.name.serialize_name = ser_name;\n-                        container_attrs.name.deserialize_name = de_name;\n+                        if ser_name.is_some() {\n+                            container_attrs.name.serialize_name = ser_name;\n+                        }\n+                        if de_name.is_some() {\n+                            container_attrs.name.deserialize_name = de_name;\n+                        }\n                     }\n \n                     // Parse `#[serde(deny_unknown_fields)]`\n@@ -110,8 +112,12 @@ impl ContainerAttrs {\n                     // Parse `#[serde(bound(serialize=\"D: Serialize\", deserialize=\"D: Deserialize\"))]`\n                     ast::MetaItemKind::List(ref name, ref meta_items) if name == &\"bound\" => {\n                         let (ser_bound, de_bound) = try!(get_where_predicates(cx, meta_items));\n-                        container_attrs.ser_bound = ser_bound;\n-                        container_attrs.de_bound = de_bound;\n+                        if ser_bound.is_some() {\n+                            container_attrs.ser_bound = ser_bound;\n+                        }\n+                        if de_bound.is_some() {\n+                            container_attrs.de_bound = de_bound;\n+                        }\n                     }\n \n                     _ => {\n@@ -164,7 +170,6 @@ impl VariantAttrs {\n                     // Parse `#[serde(rename=\"foo\")]`\n                     ast::MetaItemKind::NameValue(ref name, ref lit) if name == &\"rename\" => {\n                         let s = try!(get_str_from_lit(cx, name, lit));\n-\n                         variant_attrs.name.serialize_name = Some(s.clone());\n                         variant_attrs.name.deserialize_name = Some(s);\n                     }\n@@ -172,9 +177,12 @@ impl VariantAttrs {\n                     // Parse `#[serde(rename(serialize=\"foo\", deserialize=\"bar\"))]`\n                     ast::MetaItemKind::List(ref name, ref meta_items) if name == &\"rename\" => {\n                         let (ser_name, de_name) = try!(get_renames(cx, meta_items));\n-\n-                        variant_attrs.name.serialize_name = ser_name;\n-                        variant_attrs.name.deserialize_name = de_name;\n+                        if ser_name.is_some() {\n+                            variant_attrs.name.serialize_name = ser_name;\n+                        }\n+                        if de_name.is_some() {\n+                            variant_attrs.name.deserialize_name = de_name;\n+                        }\n                     }\n \n                     _ => {\n@@ -241,7 +249,6 @@ impl FieldAttrs {\n                     // Parse `#[serde(rename=\"foo\")]`\n                     ast::MetaItemKind::NameValue(ref name, ref lit) if name == &\"rename\" => {\n                         let s = try!(get_str_from_lit(cx, name, lit));\n-\n                         field_attrs.name.serialize_name = Some(s.clone());\n                         field_attrs.name.deserialize_name = Some(s);\n                     }\n@@ -249,9 +256,12 @@ impl FieldAttrs {\n                     // Parse `#[serde(rename(serialize=\"foo\", deserialize=\"bar\"))]`\n                     ast::MetaItemKind::List(ref name, ref meta_items) if name == &\"rename\" => {\n                         let (ser_name, de_name) = try!(get_renames(cx, meta_items));\n-\n-                        field_attrs.name.serialize_name = ser_name;\n-                        field_attrs.name.deserialize_name = de_name;\n+                        if ser_name.is_some() {\n+                            field_attrs.name.serialize_name = ser_name;\n+                        }\n+                        if de_name.is_some() {\n+                            field_attrs.name.deserialize_name = de_name;\n+                        }\n                     }\n \n                     // Parse `#[serde(default)]`\n@@ -314,8 +324,12 @@ impl FieldAttrs {\n                     // Parse `#[serde(bound(serialize=\"D: Serialize\", deserialize=\"D: Deserialize\"))]`\n                     ast::MetaItemKind::List(ref name, ref meta_items) if name == &\"bound\" => {\n                         let (ser_bound, de_bound) = try!(get_where_predicates(cx, meta_items));\n-                        field_attrs.ser_bound = ser_bound;\n-                        field_attrs.de_bound = de_bound;\n+                        if ser_bound.is_some() {\n+                            field_attrs.ser_bound = ser_bound;\n+                        }\n+                        if de_bound.is_some() {\n+                            field_attrs.de_bound = de_bound;\n+                        }\n                     }\n \n                     _ => {\n", "test_patch": "diff --git a/serde_tests/tests/test_annotations.rs b/serde_tests/tests/test_annotations.rs\nindex cdaa899ef..79e1683b3 100644\n--- a/serde_tests/tests/test_annotations.rs\n+++ b/serde_tests/tests/test_annotations.rs\n@@ -441,7 +441,8 @@ enum RenameEnumSerializeDeserialize<A> {\n     #[serde(rename(serialize=\"dick_grayson\", deserialize=\"jason_todd\"))]\n     Robin {\n         a: i8,\n-        #[serde(rename(serialize=\"c\", deserialize=\"d\"))]\n+        #[serde(rename(serialize=\"c\"))]\n+        #[serde(rename(deserialize=\"d\"))]\n         b: A,\n     },\n }\ndiff --git a/serde_tests/tests/test_gen.rs b/serde_tests/tests/test_gen.rs\nindex 28e3533ee..c2ccdc691 100644\n--- a/serde_tests/tests/test_gen.rs\n+++ b/serde_tests/tests/test_gen.rs\n@@ -111,9 +111,9 @@ struct WithTraits2<D, E> {\n             deserialize_with=\"DeserializeWith::deserialize_with\")]\n     d: D,\n     #[serde(serialize_with=\"SerializeWith::serialize_with\",\n-            deserialize_with=\"DeserializeWith::deserialize_with\",\n-            bound(serialize=\"E: SerializeWith\",\n-                  deserialize=\"E: DeserializeWith\"))]\n+            bound(serialize=\"E: SerializeWith\"))]\n+    #[serde(deserialize_with=\"DeserializeWith::deserialize_with\",\n+            bound(deserialize=\"E: DeserializeWith\"))]\n     e: E,\n }\n \n", "problem_statement": "`rename` attributes overwrite each other\n``` rust\n#![feature(custom_derive, plugin)]\n#![plugin(serde_macros)]\n\nextern crate serde_json;\n\n#[derive(Serialize, Deserialize, Default)]\nstruct S {\n    #[serde(rename(serialize=\"s1\", deserialize=\"d1\"))]\n    v1: (),\n    #[serde(rename(serialize=\"s2\"))]\n    #[serde(rename(deserialize=\"d2\"))]\n    v2: (),\n}\n\nfn main() {\n    let s: S = Default::default();\n    println!(\"{}\", serde_json::to_string(&s).unwrap());\n}\n```\n\nExpected: `{\"s1\":null,\"s2\":null}`\nActual: `{\"s1\":null,\"v2\":null}`\n\n", "hints_text": "", "created_at": "2016-06-06T08:50:43Z", "version": "0.7"}, {"repo": "serde-rs/serde", "pull_number": 338, "instance_id": "serde-rs__serde-338", "issue_numbers": ["337"], "base_commit": "16d3e96b77fe8d50a2f9d9716ec231fc04251bce", "patch": "diff --git a/serde_codegen/src/bound.rs b/serde_codegen/src/bound.rs\nindex c46cc2b0b..4f563e9b2 100644\n--- a/serde_codegen/src/bound.rs\n+++ b/serde_codegen/src/bound.rs\n@@ -139,9 +139,9 @@ fn contains_generic(ty: &ast::Ty, generics: &ast::Generics) -> bool {\n //\n //    impl<'a, T> Serialize for Test<'a, T>\n //        where T: Serialize { ... }\n-fn strip_reference(ty: &P<ast::Ty>) -> &P<ast::Ty> {\n-    match ty.node {\n-        ast::TyKind::Rptr(_, ref mut_ty) => &mut_ty.ty,\n-        _ => ty\n+fn strip_reference(mut ty: &P<ast::Ty>) -> &P<ast::Ty> {\n+    while let ast::TyKind::Rptr(_, ref mut_ty) = ty.node {\n+        ty = &mut_ty.ty;\n     }\n+    ty\n }\n", "test_patch": "diff --git a/serde_tests/tests/test_gen.rs b/serde_tests/tests/test_gen.rs\nindex 805c100db..8410b2c3c 100644\n--- a/serde_tests/tests/test_gen.rs\n+++ b/serde_tests/tests/test_gen.rs\n@@ -49,6 +49,12 @@ enum EnumWith<T> {\n         i: i32 },\n }\n \n+#[derive(Serialize)]\n+struct MultipleRef<'a, 'b, 'c, T> where T: 'c, 'c: 'b, 'b: 'a {\n+    t: T,\n+    rrrt: &'a &'b &'c T,\n+}\n+\n //////////////////////////////////////////////////////////////////////////\n \n fn ser_i32<S: Serializer>(_: &i32, _: &mut S) -> Result<(), S::Error> { panic!() }\n", "problem_statement": "Double reference generates bad code\n``` rust\n#[derive(Serialize)]\npub struct S<'a, 'b, T> where 'b: 'a, T: 'a + 'b {\n    a: &'a &'b T,\n    b: T,\n}\n```\n\n```\nerror: cannot infer an appropriate lifetime for borrow expression due to conflicting requirements [E0495]\n          return Ok(Some(try!(_serializer.serialize_struct_elt(\"b\", &self.value.b))));\n                                                                    ^~~~~~~~~~~~~\n```\n\n", "hints_text": "", "created_at": "2016-05-19T06:49:47Z", "version": "0.7"}, {"repo": "serde-rs/serde", "pull_number": 335, "instance_id": "serde-rs__serde-335", "issue_numbers": ["330"], "base_commit": "cc115ca43a52e88d4afb2dc50e21c9380812f13b", "patch": "diff --git a/serde_codegen/src/attr.rs b/serde_codegen/src/attr.rs\nindex d8dc7379f..cc5cfe383 100644\n--- a/serde_codegen/src/attr.rs\n+++ b/serde_codegen/src/attr.rs\n@@ -177,31 +177,29 @@ pub struct FieldAttrs {\n     name: Name,\n     skip_serializing_field: bool,\n     skip_deserializing_field: bool,\n-    skip_serializing_field_if: Option<P<ast::Expr>>,\n+    skip_serializing_if: Option<ast::Path>,\n     default_expr_if_missing: Option<P<ast::Expr>>,\n-    serialize_with: Option<P<ast::Expr>>,\n+    serialize_with: Option<ast::Path>,\n     deserialize_with: Option<ast::Path>,\n }\n \n impl FieldAttrs {\n     /// Extract out the `#[serde(...)]` attributes from a struct field.\n     pub fn from_field(cx: &ExtCtxt,\n-                      container_ty: &P<ast::Ty>,\n-                      generics: &ast::Generics,\n-                      field: &ast::StructField,\n-                      is_enum: bool) -> Result<Self, Error> {\n+                      index: usize,\n+                      field: &ast::StructField) -> Result<Self, Error> {\n         let builder = AstBuilder::new();\n \n         let field_ident = match field.ident {\n             Some(ident) => ident,\n-            None => { cx.span_bug(field.span, \"struct field has no name?\") }\n+            None => builder.id(index.to_string()),\n         };\n \n         let mut field_attrs = FieldAttrs {\n             name: Name::new(field_ident),\n             skip_serializing_field: false,\n             skip_deserializing_field: false,\n-            skip_serializing_field_if: None,\n+            skip_serializing_if: None,\n             default_expr_if_missing: None,\n             serialize_with: None,\n             deserialize_with: None,\n@@ -260,27 +258,14 @@ impl FieldAttrs {\n \n                     // Parse `#[serde(skip_serializing_if=\"...\")]`\n                     ast::MetaItemKind::NameValue(ref name, ref lit) if name == &\"skip_serializing_if\" => {\n-                        let expr = wrap_skip_serializing(\n-                            field_ident,\n-                            try!(parse_lit_into_path(cx, name, lit)),\n-                            is_enum,\n-                        );\n-\n-                        field_attrs.skip_serializing_field_if = Some(expr);\n+                        let path = try!(parse_lit_into_path(cx, name, lit));\n+                        field_attrs.skip_serializing_if = Some(path);\n                     }\n \n                     // Parse `#[serde(serialize_with=\"...\")]`\n                     ast::MetaItemKind::NameValue(ref name, ref lit) if name == &\"serialize_with\" => {\n-                        let expr = wrap_serialize_with(\n-                            cx,\n-                            container_ty,\n-                            generics,\n-                            field_ident,\n-                            try!(parse_lit_into_path(cx, name, lit)),\n-                            is_enum,\n-                        );\n-\n-                        field_attrs.serialize_with = Some(expr);\n+                        let path = try!(parse_lit_into_path(cx, name, lit));\n+                        field_attrs.serialize_with = Some(path);\n                     }\n \n                     // Parse `#[serde(deserialize_with=\"...\")]`\n@@ -316,15 +301,15 @@ impl FieldAttrs {\n         self.skip_deserializing_field\n     }\n \n-    pub fn skip_serializing_field_if(&self) -> Option<&P<ast::Expr>> {\n-        self.skip_serializing_field_if.as_ref()\n+    pub fn skip_serializing_if(&self) -> Option<&ast::Path> {\n+        self.skip_serializing_if.as_ref()\n     }\n \n     pub fn default_expr_if_missing(&self) -> Option<&P<ast::Expr>> {\n         self.default_expr_if_missing.as_ref()\n     }\n \n-    pub fn serialize_with(&self) -> Option<&P<ast::Expr>> {\n+    pub fn serialize_with(&self) -> Option<&ast::Path> {\n         self.serialize_with.as_ref()\n     }\n \n@@ -334,14 +319,17 @@ impl FieldAttrs {\n }\n \n \n-/// Extract out the `#[serde(...)]` attributes from a struct field.\n-pub fn get_struct_field_attrs(cx: &ExtCtxt,\n-                              container_ty: &P<ast::Ty>,\n-                              generics: &ast::Generics,\n-                              fields: &[ast::StructField],\n-                              is_enum: bool) -> Result<Vec<FieldAttrs>, Error> {\n+/// Zip together fields and `#[serde(...)]` attributes on those fields.\n+pub fn fields_with_attrs<'a>(\n+    cx: &ExtCtxt,\n+    fields: &'a [ast::StructField],\n+) -> Result<Vec<(&'a ast::StructField, FieldAttrs)>, Error> {\n     fields.iter()\n-        .map(|field| FieldAttrs::from_field(cx, container_ty, generics, field, is_enum))\n+        .enumerate()\n+        .map(|(i, field)| {\n+            let attrs = try!(FieldAttrs::from_field(cx, i, field));\n+            Ok((field, attrs))\n+        })\n         .collect()\n }\n \n@@ -495,100 +483,3 @@ fn wrap_default(path: ast::Path) -> P<ast::Expr> {\n         .build_path(path)\n         .build()\n }\n-\n-/// This function wraps the expression in `#[serde(skip_serializing_if=\"...\")]` in a trait to\n-/// prevent it from accessing the internal `Serialize` state.\n-fn wrap_skip_serializing(field_ident: ast::Ident,\n-                         path: ast::Path,\n-                         is_enum: bool) -> P<ast::Expr> {\n-    let builder = AstBuilder::new();\n-\n-    let expr = builder.expr()\n-        .field(field_ident)\n-        .field(\"value\")\n-        .self_();\n-\n-    let expr = if is_enum {\n-        expr\n-    } else {\n-        builder.expr().ref_().build(expr)\n-    };\n-\n-    builder.expr().call()\n-        .build_path(path)\n-        .arg().build(expr)\n-        .build()\n-}\n-\n-/// This function wraps the expression in `#[serde(serialize_with=\"...\")]` in a trait to\n-/// prevent it from accessing the internal `Serialize` state.\n-fn wrap_serialize_with(cx: &ExtCtxt,\n-                       container_ty: &P<ast::Ty>,\n-                       generics: &ast::Generics,\n-                       field_ident: ast::Ident,\n-                       path: ast::Path,\n-                       is_enum: bool) -> P<ast::Expr> {\n-    let builder = AstBuilder::new();\n-\n-    let expr = builder.expr()\n-        .field(field_ident)\n-        .self_();\n-\n-    let expr = if is_enum {\n-        expr\n-    } else {\n-        builder.expr().ref_().build(expr)\n-    };\n-\n-    let expr = builder.expr().call()\n-        .build_path(path)\n-        .arg().build(expr)\n-        .arg()\n-            .id(\"serializer\")\n-        .build();\n-\n-    let where_clause = &generics.where_clause;\n-\n-    quote_expr!(cx, {\n-        trait __SerdeSerializeWith {\n-            fn __serde_serialize_with<__S>(&self, serializer: &mut __S) -> Result<(), __S::Error>\n-                where __S: _serde::ser::Serializer;\n-        }\n-\n-        impl<'__a, __T> __SerdeSerializeWith for &'__a __T\n-            where __T: '__a + __SerdeSerializeWith,\n-        {\n-            fn __serde_serialize_with<__S>(&self, serializer: &mut __S) -> Result<(), __S::Error>\n-                where __S: _serde::ser::Serializer\n-            {\n-                (**self).__serde_serialize_with(serializer)\n-            }\n-        }\n-\n-        impl $generics __SerdeSerializeWith for $container_ty $where_clause {\n-            fn __serde_serialize_with<__S>(&self, serializer: &mut __S) -> Result<(), __S::Error>\n-                where __S: _serde::ser::Serializer\n-            {\n-                $expr\n-            }\n-        }\n-\n-        struct __SerdeSerializeWithStruct<'__a, __T: '__a> {\n-            value: &'__a __T,\n-        }\n-\n-        impl<'__a, __T> _serde::ser::Serialize for __SerdeSerializeWithStruct<'__a, __T>\n-            where __T: '__a + __SerdeSerializeWith\n-        {\n-            fn serialize<__S>(&self, serializer: &mut __S) -> Result<(), __S::Error>\n-                where __S: _serde::ser::Serializer\n-            {\n-                self.value.__serde_serialize_with(serializer)\n-            }\n-        }\n-\n-        __SerdeSerializeWithStruct {\n-            value: &self.value,\n-        }\n-    })\n-}\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex 5573e3853..a2779709a 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -214,7 +214,7 @@ fn deserialize_item_struct(\n                 None,\n                 impl_generics,\n                 ty,\n-                fields.len(),\n+                fields,\n                 container_attrs,\n             )\n         }\n@@ -358,7 +358,7 @@ fn deserialize_tuple(\n     variant_ident: Option<Ident>,\n     impl_generics: &ast::Generics,\n     ty: P<ast::Ty>,\n-    fields: usize,\n+    fields: &[ast::StructField],\n     container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     let where_clause = &impl_generics.where_clause;\n@@ -376,37 +376,43 @@ fn deserialize_tuple(\n         None => builder.path().id(type_ident).build(),\n     };\n \n-    let visit_newtype_struct = if !is_enum && fields == 1 {\n-        Some(quote_tokens!(cx,\n-            #[inline]\n-            fn visit_newtype_struct<__E>(&mut self, deserializer: &mut __E) -> ::std::result::Result<Self::Value, __E::Error>\n-                where __E: _serde::de::Deserializer,\n-            {\n-                let value = try!(_serde::de::Deserialize::deserialize(deserializer));\n-                Ok($type_path(value))\n-            }))\n+    let nfields = fields.len();\n+    let fields_with_attrs = try!(attr::fields_with_attrs(cx, fields));\n+\n+    let visit_newtype_struct = if !is_enum && nfields == 1 {\n+        Some(try!(deserialize_newtype_struct(\n+            cx,\n+            builder,\n+            type_ident,\n+            &type_path,\n+            impl_generics,\n+            &fields_with_attrs[0],\n+        )))\n     } else {\n         None\n     };\n \n-    let visit_seq_expr = deserialize_seq(\n+    let visit_seq_expr = try!(deserialize_seq(\n         cx,\n         builder,\n+        type_ident,\n         type_path,\n-        fields,\n-    );\n+        impl_generics,\n+        &fields_with_attrs,\n+        false,\n+    ));\n \n     let dispatch = if is_enum {\n         quote_expr!(cx,\n-            visitor.visit_tuple($fields, $visitor_expr))\n-    } else if fields == 1 {\n+            visitor.visit_tuple($nfields, $visitor_expr))\n+    } else if nfields == 1 {\n         let type_name = container_attrs.name().deserialize_name_expr();\n         quote_expr!(cx,\n             deserializer.deserialize_newtype_struct($type_name, $visitor_expr))\n     } else {\n         let type_name = container_attrs.name().deserialize_name_expr();\n         quote_expr!(cx,\n-            deserializer.deserialize_tuple_struct($type_name, $fields, $visitor_expr))\n+            deserializer.deserialize_tuple_struct($type_name, $nfields, $visitor_expr))\n     };\n \n     Ok(quote_expr!(cx, {\n@@ -430,46 +436,13 @@ fn deserialize_tuple(\n }\n \n fn deserialize_seq(\n-    cx: &ExtCtxt,\n-    builder: &aster::AstBuilder,\n-    struct_path: ast::Path,\n-    fields: usize,\n-) -> P<ast::Expr> {\n-    let let_values: Vec<ast::Stmt> = (0 .. fields)\n-        .map(|i| {\n-            let name = builder.id(format!(\"__field{}\", i));\n-            quote_stmt!(cx,\n-                let $name = match try!(visitor.visit()) {\n-                    Some(value) => { value },\n-                    None => {\n-                        return Err(_serde::de::Error::end_of_stream());\n-                    }\n-                };\n-            ).unwrap()\n-        })\n-        .collect();\n-\n-    let result = builder.expr().call()\n-        .build_path(struct_path)\n-        .with_args((0 .. fields).map(|i| builder.expr().id(format!(\"__field{}\", i))))\n-        .build();\n-\n-    quote_expr!(cx, {\n-        $let_values\n-\n-        try!(visitor.end());\n-\n-        Ok($result)\n-    })\n-}\n-\n-fn deserialize_struct_as_seq(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n     type_ident: Ident,\n-    struct_path: ast::Path,\n+    type_path: ast::Path,\n     impl_generics: &ast::Generics,\n     fields: &[(&ast::StructField, attr::FieldAttrs)],\n+    is_struct: bool,\n ) -> Result<P<ast::Expr>, Error> {\n     let let_values: Vec<_> = fields.iter()\n         .enumerate()\n@@ -508,23 +481,30 @@ fn deserialize_struct_as_seq(\n         })\n         .collect();\n \n-    let result = builder.expr().struct_path(struct_path)\n-        .with_id_exprs(\n-            fields.iter()\n-                .enumerate()\n-                .map(|(i, &(field, _))| {\n-                    (\n-                        match field.ident {\n-                            Some(name) => name.clone(),\n-                            None => {\n-                                cx.span_bug(field.span, \"struct contains unnamed fields\")\n-                            }\n-                        },\n-                        builder.expr().id(format!(\"__field{}\", i)),\n-                    )\n-                })\n-        )\n-        .build();\n+    let result = if is_struct {\n+        builder.expr().struct_path(type_path)\n+            .with_id_exprs(\n+                fields.iter()\n+                    .enumerate()\n+                    .map(|(i, &(field, _))| {\n+                        (\n+                            match field.ident {\n+                                Some(name) => name.clone(),\n+                                None => {\n+                                    cx.span_bug(field.span, \"struct contains unnamed fields\")\n+                                }\n+                            },\n+                            builder.expr().id(format!(\"__field{}\", i)),\n+                        )\n+                    })\n+            )\n+            .build()\n+    } else {\n+        builder.expr().call()\n+            .build_path(type_path)\n+            .with_args((0..fields.len()).map(|i| builder.expr().id(format!(\"__field{}\", i))))\n+            .build()\n+    };\n \n     Ok(quote_expr!(cx, {\n         $let_values\n@@ -535,6 +515,41 @@ fn deserialize_struct_as_seq(\n     }))\n }\n \n+fn deserialize_newtype_struct(\n+    cx: &ExtCtxt,\n+    builder: &aster::AstBuilder,\n+    type_ident: Ident,\n+    type_path: &ast::Path,\n+    impl_generics: &ast::Generics,\n+    field: &(&ast::StructField, attr::FieldAttrs),\n+) -> Result<Vec<ast::TokenTree>, Error> {\n+    let &(field, ref attrs) = field;\n+    let value = match attrs.deserialize_with() {\n+        None => {\n+            let field_ty = &field.ty;\n+            quote_expr!(cx,\n+                try!(<$field_ty as _serde::Deserialize>::deserialize(__e)))\n+        }\n+        Some(path) => {\n+            let (wrapper, wrapper_impl, wrapper_ty) = wrap_deserialize_with(\n+                cx, builder, type_ident, impl_generics, &field.ty, path);\n+            quote_expr!(cx, {\n+                $wrapper\n+                $wrapper_impl\n+                try!(<$wrapper_ty as _serde::Deserialize>::deserialize(__e)).value\n+            })\n+        }\n+    };\n+    Ok(quote_tokens!(cx,\n+        #[inline]\n+        fn visit_newtype_struct<__E>(&mut self, __e: &mut __E) -> ::std::result::Result<Self::Value, __E::Error>\n+            where __E: _serde::de::Deserializer,\n+        {\n+            Ok($type_path($value))\n+        }\n+    ))\n+}\n+\n fn deserialize_struct(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n@@ -559,16 +574,16 @@ fn deserialize_struct(\n         None => builder.path().id(type_ident).build(),\n     };\n \n-    let is_enum = variant_ident.is_some();\n-    let fields_with_attrs = try!(fields_with_attrs(cx, impl_generics, &ty, fields, is_enum));\n+    let fields_with_attrs = try!(attr::fields_with_attrs(cx, fields));\n \n-    let visit_seq_expr = try!(deserialize_struct_as_seq(\n+    let visit_seq_expr = try!(deserialize_seq(\n         cx,\n         builder,\n         type_ident,\n         type_path.clone(),\n         impl_generics,\n         &fields_with_attrs,\n+        true,\n     ));\n \n     let (field_visitor, fields_stmt, visit_map_expr) = try!(deserialize_struct_visitor(\n@@ -581,6 +596,7 @@ fn deserialize_struct(\n         container_attrs,\n     ));\n \n+    let is_enum = variant_ident.is_some();\n     let dispatch = if is_enum {\n         quote_expr!(cx,\n             visitor.visit_struct(FIELDS, $visitor_expr))\n@@ -737,10 +753,14 @@ fn deserialize_variant(\n             }))\n         }\n         ast::VariantData::Tuple(ref fields, _) if fields.len() == 1 => {\n-            Ok(quote_expr!(cx, {\n-                let val = try!(visitor.visit_newtype());\n-                Ok($type_ident::$variant_ident(val))\n-            }))\n+            deserialize_newtype_variant(\n+                cx,\n+                builder,\n+                type_ident,\n+                variant_ident,\n+                generics,\n+                &fields[0],\n+            )\n         }\n         ast::VariantData::Tuple(ref fields, _) => {\n             deserialize_tuple(\n@@ -750,7 +770,7 @@ fn deserialize_variant(\n                 Some(variant_ident),\n                 generics,\n                 ty,\n-                fields.len(),\n+                fields,\n                 container_attrs,\n             )\n         }\n@@ -769,6 +789,33 @@ fn deserialize_variant(\n     }\n }\n \n+fn deserialize_newtype_variant(\n+    cx: &ExtCtxt,\n+    builder: &aster::AstBuilder,\n+    type_ident: Ident,\n+    variant_ident: Ident,\n+    impl_generics: &ast::Generics,\n+    field: &ast::StructField,\n+) -> Result<P<ast::Expr>, Error> {\n+    let attrs = try!(attr::FieldAttrs::from_field(cx, 0, field));\n+    let visit = match attrs.deserialize_with() {\n+        None => {\n+            let field_ty = &field.ty;\n+            quote_expr!(cx, try!(visitor.visit_newtype::<$field_ty>()))\n+        }\n+        Some(path) => {\n+            let (wrapper, wrapper_impl, wrapper_ty) = wrap_deserialize_with(\n+                cx, builder, type_ident, impl_generics, &field.ty, path);\n+            quote_expr!(cx, {\n+                $wrapper\n+                $wrapper_impl\n+                try!(visitor.visit_newtype::<$wrapper_ty>()).value\n+            })\n+        }\n+    };\n+    Ok(quote_expr!(cx, Ok($type_ident::$variant_ident($visit))))\n+}\n+\n fn deserialize_field_visitor(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n@@ -1117,21 +1164,6 @@ fn deserialize_map(\n     }))\n }\n \n-fn fields_with_attrs<'a>(\n-    cx: &ExtCtxt,\n-    generics: &ast::Generics,\n-    ty: &P<ast::Ty>,\n-    fields: &'a [ast::StructField],\n-    is_enum: bool\n-) -> Result<Vec<(&'a ast::StructField, attr::FieldAttrs)>, Error> {\n-    fields.iter()\n-        .map(|field| {\n-            let attrs = try!(attr::FieldAttrs::from_field(cx, &ty, generics, field, is_enum));\n-            Ok((field, attrs))\n-        })\n-        .collect()\n-}\n-\n /// This function wraps the expression in `#[serde(deserialize_with=\"...\")]` in\n /// a trait to prevent it from accessing the internal `Deserialize` state.\n fn wrap_deserialize_with(\ndiff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex dcae12d02..a1220f695 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -185,6 +185,10 @@ fn serialize_item_struct(\n         ast::VariantData::Tuple(ref fields, _) if fields.len() == 1 => {\n             serialize_newtype_struct(\n                 cx,\n+                &builder,\n+                impl_generics,\n+                ty,\n+                &fields[0],\n                 container_attrs,\n             )\n         }\n@@ -198,7 +202,7 @@ fn serialize_item_struct(\n                 &builder,\n                 impl_generics,\n                 ty,\n-                fields.len(),\n+                fields,\n                 container_attrs,\n             )\n         }\n@@ -232,12 +236,24 @@ fn serialize_unit_struct(\n \n fn serialize_newtype_struct(\n     cx: &ExtCtxt,\n+    builder: &aster::AstBuilder,\n+    impl_generics: &ast::Generics,\n+    container_ty: P<ast::Ty>,\n+    field: &ast::StructField,\n     container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     let type_name = container_attrs.name().serialize_name_expr();\n \n+    let attrs = try!(attr::FieldAttrs::from_field(cx, 0, field));\n+\n+    let mut field_expr = quote_expr!(cx, &self.0);\n+    if let Some(path) = attrs.serialize_with() {\n+        field_expr = wrap_serialize_with(cx, builder,\n+            &container_ty, impl_generics, &field.ty, path, field_expr);\n+    }\n+\n     Ok(quote_expr!(cx,\n-        _serializer.serialize_newtype_struct($type_name, &self.0)\n+        _serializer.serialize_newtype_struct($type_name, $field_expr)\n     ))\n }\n \n@@ -246,10 +262,10 @@ fn serialize_tuple_struct(\n     builder: &aster::AstBuilder,\n     impl_generics: &ast::Generics,\n     ty: P<ast::Ty>,\n-    fields: usize,\n+    fields: &[ast::StructField],\n     container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n-    let (visitor_struct, visitor_impl) = serialize_tuple_struct_visitor(\n+    let (visitor_struct, visitor_impl) = try!(serialize_tuple_struct_visitor(\n         cx,\n         builder,\n         ty.clone(),\n@@ -260,7 +276,8 @@ fn serialize_tuple_struct(\n         builder.id(\"serialize_tuple_struct_elt\"),\n         fields,\n         impl_generics,\n-    );\n+        false,\n+    ));\n \n     let type_name = container_attrs.name().serialize_name_expr();\n \n@@ -362,12 +379,8 @@ fn serialize_variant(\n \n     match variant.node.data {\n         ast::VariantData::Unit(_) => {\n-            let pat = builder.pat().path()\n-                .id(type_ident).id(variant_ident)\n-                .build();\n-\n             Ok(quote_arm!(cx,\n-                $pat => {\n+                $type_ident::$variant_ident => {\n                     _serde::ser::Serializer::serialize_unit_variant(\n                         _serializer,\n                         $type_name,\n@@ -378,23 +391,19 @@ fn serialize_variant(\n             ))\n         },\n         ast::VariantData::Tuple(ref fields, _) if fields.len() == 1 => {\n-            let field = builder.id(\"__simple_value\");\n-            let field = builder.pat().ref_id(field);\n-            let pat = builder.pat().enum_()\n-                .id(type_ident).id(variant_ident).build()\n-                .with_pats(Some(field).into_iter())\n-                .build();\n+            let expr = try!(serialize_newtype_variant(\n+                cx,\n+                builder,\n+                type_name,\n+                variant_index,\n+                variant_name,\n+                ty,\n+                generics,\n+                &fields[0],\n+            ));\n \n             Ok(quote_arm!(cx,\n-                $pat => {\n-                    _serde::ser::Serializer::serialize_newtype_variant(\n-                        _serializer,\n-                        $type_name,\n-                        $variant_index,\n-                        $variant_name,\n-                        __simple_value,\n-                    )\n-                }\n+                $type_ident::$variant_ident(ref __simple_value) => { $expr }\n             ))\n         },\n         ast::VariantData::Tuple(ref fields, _) => {\n@@ -410,7 +419,7 @@ fn serialize_variant(\n                 )\n                 .build();\n \n-            let expr = serialize_tuple_variant(\n+            let expr = try!(serialize_tuple_variant(\n                 cx,\n                 builder,\n                 type_name,\n@@ -420,7 +429,7 @@ fn serialize_variant(\n                 ty,\n                 fields,\n                 field_names,\n-            );\n+            ));\n \n             Ok(quote_arm!(cx,\n                 $pat => { $expr }\n@@ -468,6 +477,35 @@ fn serialize_variant(\n     }\n }\n \n+fn serialize_newtype_variant(\n+    cx: &ExtCtxt,\n+    builder: &aster::AstBuilder,\n+    type_name: P<ast::Expr>,\n+    variant_index: usize,\n+    variant_name: P<ast::Expr>,\n+    container_ty: P<ast::Ty>,\n+    generics: &ast::Generics,\n+    field: &ast::StructField,\n+) -> Result<P<ast::Expr>, Error> {\n+    let attrs = try!(attr::FieldAttrs::from_field(cx, 0, field));\n+\n+    let mut field_expr = quote_expr!(cx, __simple_value);\n+    if let Some(path) = attrs.serialize_with() {\n+        field_expr = wrap_serialize_with(cx, builder,\n+            &container_ty, generics, &field.ty, path, field_expr);\n+    }\n+\n+    Ok(quote_expr!(cx,\n+        _serde::ser::Serializer::serialize_newtype_variant(\n+            _serializer,\n+            $type_name,\n+            $variant_index,\n+            $variant_name,\n+            $field_expr,\n+        )\n+    ))\n+}\n+\n fn serialize_tuple_variant(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n@@ -478,7 +516,7 @@ fn serialize_tuple_variant(\n     structure_ty: P<ast::Ty>,\n     fields: &[ast::StructField],\n     field_names: Vec<Ident>,\n-) -> P<ast::Expr> {\n+) -> Result<P<ast::Expr>, Error> {\n     let variant_ty = builder.ty().tuple()\n         .with_tys(\n             fields.iter().map(|field| {\n@@ -490,15 +528,16 @@ fn serialize_tuple_variant(\n         )\n         .build();\n \n-    let (visitor_struct, visitor_impl) = serialize_tuple_struct_visitor(\n+    let (visitor_struct, visitor_impl) = try!(serialize_tuple_struct_visitor(\n         cx,\n         builder,\n         structure_ty.clone(),\n         variant_ty,\n         builder.id(\"serialize_tuple_variant_elt\"),\n-        fields.len(),\n+        fields,\n         generics,\n-    );\n+        true,\n+    ));\n \n     let value_expr = builder.expr().tuple()\n         .with_exprs(\n@@ -508,7 +547,7 @@ fn serialize_tuple_variant(\n         )\n         .build();\n \n-    quote_expr!(cx, {\n+    Ok(quote_expr!(cx, {\n         $visitor_struct\n         $visitor_impl\n         _serializer.serialize_tuple_variant($type_name, $variant_index, $variant_name, Visitor {\n@@ -516,7 +555,7 @@ fn serialize_tuple_variant(\n             state: 0,\n             _structure_ty: ::std::marker::PhantomData::<&$structure_ty>,\n         })\n-    })\n+    }))\n }\n \n fn serialize_struct_variant(\n@@ -614,20 +653,33 @@ fn serialize_tuple_struct_visitor(\n     structure_ty: P<ast::Ty>,\n     variant_ty: P<ast::Ty>,\n     serializer_method: ast::Ident,\n-    fields: usize,\n-    generics: &ast::Generics\n-) -> (P<ast::Item>, P<ast::Item>) {\n-    let arms: Vec<ast::Arm> = (0 .. fields)\n-        .map(|i| {\n-            let expr = builder.expr().method_call(serializer_method)\n-                .id(\"_serializer\")\n-                .arg().ref_().tup_field(i).field(\"value\").self_()\n-                .build();\n+    fields: &[ast::StructField],\n+    generics: &ast::Generics,\n+    is_enum: bool,\n+) -> Result<(P<ast::Item>, P<ast::Item>), Error> {\n+    let fields_with_attrs = try!(attr::fields_with_attrs(cx, fields));\n+\n+    let arms: Vec<_> = fields_with_attrs.iter()\n+        .enumerate()\n+        .map(|(i, &(field, ref attrs))| {\n+            let mut field_expr = builder.expr().tup_field(i).field(\"value\").self_();\n+            if !is_enum {\n+                field_expr = quote_expr!(cx, &$field_expr);\n+            }\n+\n+            let continue_if_skip = attrs.skip_serializing_if()\n+                .map(|path| quote_stmt!(cx, if $path($field_expr) { continue }));\n+\n+            if let Some(path) = attrs.serialize_with() {\n+                field_expr = wrap_serialize_with(cx, builder,\n+                    &structure_ty, generics, &field.ty, path, field_expr);\n+            }\n \n             quote_arm!(cx,\n                 $i => {\n                     self.state += 1;\n-                    Ok(Some(try!($expr)))\n+                    $continue_if_skip\n+                    Ok(Some(try!(_serializer.$serializer_method($field_expr))))\n                 }\n             )\n         })\n@@ -644,7 +696,9 @@ fn serialize_tuple_struct_visitor(\n         .strip_bounds()\n         .build();\n \n-    (\n+    let nfields = fields.len();\n+\n+    Ok((\n         quote_item!(cx,\n             struct Visitor $visitor_impl_generics $where_clause {\n                 state: usize,\n@@ -669,11 +723,11 @@ fn serialize_tuple_struct_visitor(\n \n                 #[inline]\n                 fn len(&self) -> Option<usize> {\n-                    Some($fields)\n+                    Some($nfields)\n                 }\n             }\n         ).unwrap(),\n-    )\n+    ))\n }\n \n fn serialize_struct_visitor(\n@@ -686,28 +740,27 @@ fn serialize_struct_visitor(\n     generics: &ast::Generics,\n     is_enum: bool,\n ) -> Result<(P<ast::Item>, P<ast::Item>), Error> {\n-    let field_attrs = try!(\n-        attr::get_struct_field_attrs(cx, &structure_ty, generics, fields, is_enum)\n-    );\n+    let fields_with_attrs = try!(attr::fields_with_attrs(cx, fields));\n \n-    let arms: Vec<ast::Arm> = fields.iter().zip(field_attrs.iter())\n-        .filter(|&(_, ref field_attr)| !field_attr.skip_serializing_field())\n+    let arms: Vec<ast::Arm> = fields_with_attrs.iter()\n+        .filter(|&&(_, ref attrs)| !attrs.skip_serializing_field())\n         .enumerate()\n-        .map(|(i, (ref field, ref field_attr))| {\n-            let name = field.ident.expect(\"struct has unnamed field\");\n+        .map(|(i, &(field, ref attrs))| {\n+            let ident = field.ident.expect(\"struct has unnamed field\");\n+            let mut field_expr = quote_expr!(cx, self.value.$ident);\n+            if !is_enum {\n+                field_expr = quote_expr!(cx, &$field_expr);\n+            }\n \n-            let key_expr = field_attr.name().serialize_name_expr();\n+            let key_expr = attrs.name().serialize_name_expr();\n \n-            let stmt = if let Some(expr) = field_attr.skip_serializing_field_if() {\n-                    Some(quote_stmt!(cx, if $expr { continue; }))\n-            } else {\n-                None\n-            };\n+            let continue_if_skip = attrs.skip_serializing_if()\n+                .map(|path| quote_stmt!(cx, if $path($field_expr) { continue }));\n \n-            let field_expr = match field_attr.serialize_with() {\n-                Some(expr) => expr.clone(),\n-                None => quote_expr!(cx, &self.value.$name),\n-            };\n+            if let Some(path) = attrs.serialize_with() {\n+                field_expr = wrap_serialize_with(cx, builder,\n+                    &structure_ty, generics, &field.ty, path, field_expr)\n+            }\n \n             let expr = quote_expr!(cx,\n                 _serializer.$serializer_method($key_expr, $field_expr)\n@@ -716,7 +769,7 @@ fn serialize_struct_visitor(\n             quote_arm!(cx,\n                 $i => {\n                     self.state += 1;\n-                    $stmt\n+                    $continue_if_skip\n                     return Ok(Some(try!($expr)));\n                 }\n             )\n@@ -734,16 +787,18 @@ fn serialize_struct_visitor(\n         .strip_bounds()\n         .build();\n \n-    let len = field_attrs.iter()\n-        .filter(|field_attr| !field_attr.skip_serializing_field())\n-        .map(|field_attr| {\n-            match field_attr.skip_serializing_field_if() {\n-                Some(expr) => {\n-                    quote_expr!(cx, if $expr { 0 } else { 1 })\n-                }\n-                None => {\n-                    quote_expr!(cx, 1)\n-                }\n+    let len = fields_with_attrs.iter()\n+        .filter(|&&(_, ref attrs)| !attrs.skip_serializing_field())\n+        .map(|&(field, ref attrs)| {\n+            let ident = field.ident.expect(\"struct has unnamed fields\");\n+            let mut field_expr = quote_expr!(cx, self.value.$ident);\n+            if !is_enum {\n+                field_expr = quote_expr!(cx, &$field_expr);\n+            }\n+\n+            match attrs.skip_serializing_if() {\n+                Some(path) => quote_expr!(cx, if $path($field_expr) { 0 } else { 1 }),\n+                None => quote_expr!(cx, 1),\n             }\n         })\n         .fold(quote_expr!(cx, 0), |sum, expr| quote_expr!(cx, $sum + $expr));\n@@ -782,3 +837,46 @@ fn serialize_struct_visitor(\n         ).unwrap(),\n     ))\n }\n+\n+fn wrap_serialize_with(\n+    cx: &ExtCtxt,\n+    builder: &aster::AstBuilder,\n+    container_ty: &P<ast::Ty>,\n+    generics: &ast::Generics,\n+    field_ty: &P<ast::Ty>,\n+    path: &ast::Path,\n+    value: P<ast::Expr>,\n+) -> P<ast::Expr> {\n+    let where_clause = &generics.where_clause;\n+\n+    let wrapper_generics = builder.from_generics(generics.clone())\n+        .add_lifetime_bound(\"'__a\")\n+        .lifetime_name(\"'__a\")\n+        .build();\n+\n+    let wrapper_ty = builder.path()\n+        .segment(\"__SerializeWith\")\n+            .with_generics(wrapper_generics.clone())\n+            .build()\n+        .build();\n+\n+    quote_expr!(cx, {\n+        struct __SerializeWith $wrapper_generics $where_clause {\n+            value: &'__a $field_ty,\n+            phantom: ::std::marker::PhantomData<$container_ty>,\n+        }\n+\n+        impl $wrapper_generics _serde::ser::Serialize for $wrapper_ty $where_clause {\n+            fn serialize<__S>(&self, __s: &mut __S) -> Result<(), __S::Error>\n+                where __S: _serde::ser::Serializer\n+            {\n+                $path(self.value, __s)\n+            }\n+        }\n+\n+        __SerializeWith {\n+            value: $value,\n+            phantom: ::std::marker::PhantomData::<$container_ty>,\n+        }\n+    })\n+}\n", "test_patch": "diff --git a/serde_tests/tests/test_gen.rs b/serde_tests/tests/test_gen.rs\nindex 8410b2c3c..6f897e089 100644\n--- a/serde_tests/tests/test_gen.rs\n+++ b/serde_tests/tests/test_gen.rs\n@@ -1,5 +1,6 @@\n // These just test that serde_codegen is able to produce code that compiles\n-// successfully when there are a variety of generics involved.\n+// successfully when there are a variety of generics and non-(de)serializable\n+// types involved.\n \n extern crate serde;\n use self::serde::ser::{Serialize, Serializer};\n@@ -10,16 +11,16 @@ use self::serde::de::{Deserialize, Deserializer};\n #[derive(Serialize, Deserialize)]\n struct With<T> {\n     t: T,\n-    #[serde(serialize_with=\"ser_i32\", deserialize_with=\"de_i32\")]\n-    i: i32,\n+    #[serde(serialize_with=\"ser_x\", deserialize_with=\"de_x\")]\n+    x: X,\n }\n \n #[derive(Serialize, Deserialize)]\n struct WithRef<'a, T: 'a> {\n     #[serde(skip_deserializing)]\n     t: Option<&'a T>,\n-    #[serde(serialize_with=\"ser_i32\", deserialize_with=\"de_i32\")]\n-    i: i32,\n+    #[serde(serialize_with=\"ser_x\", deserialize_with=\"de_x\")]\n+    x: X,\n }\n \n #[derive(Serialize, Deserialize)]\n@@ -40,13 +41,18 @@ struct NoBounds<T> {\n \n #[derive(Serialize, Deserialize)]\n enum EnumWith<T> {\n-    A(\n-        #[serde(serialize_with=\"ser_i32\", deserialize_with=\"de_i32\")]\n-        i32),\n-    B {\n+    Unit,\n+    Newtype(\n+        #[serde(serialize_with=\"ser_x\", deserialize_with=\"de_x\")]\n+        X),\n+    Tuple(\n+        T,\n+        #[serde(serialize_with=\"ser_x\", deserialize_with=\"de_x\")]\n+        X),\n+    Struct {\n         t: T,\n-        #[serde(serialize_with=\"ser_i32\", deserialize_with=\"de_i32\")]\n-        i: i32 },\n+        #[serde(serialize_with=\"ser_x\", deserialize_with=\"de_x\")]\n+        x: X },\n }\n \n #[derive(Serialize)]\n@@ -55,8 +61,23 @@ struct MultipleRef<'a, 'b, 'c, T> where T: 'c, 'c: 'b, 'b: 'a {\n     rrrt: &'a &'b &'c T,\n }\n \n+#[derive(Serialize, Deserialize)]\n+struct Newtype(\n+    #[serde(serialize_with=\"ser_x\", deserialize_with=\"de_x\")]\n+    X\n+);\n+\n+#[derive(Serialize, Deserialize)]\n+struct Tuple<T>(\n+    T,\n+    #[serde(serialize_with=\"ser_x\", deserialize_with=\"de_x\")]\n+    X,\n+);\n+\n //////////////////////////////////////////////////////////////////////////\n \n-fn ser_i32<S: Serializer>(_: &i32, _: &mut S) -> Result<(), S::Error> { panic!() }\n+// Implements neither Serialize nor Deserialize\n+struct X;\n+fn ser_x<S: Serializer>(_: &X, _: &mut S) -> Result<(), S::Error> { panic!() }\n+fn de_x<D: Deserializer>(_: &mut D) -> Result<X, D::Error> { panic!() }\n \n-fn de_i32<D: Deserializer>(_: &mut D) -> Result<i32, D::Error> { panic!() }\n", "problem_statement": "Tuple struct fields with deserialize_with still require Deserialize bound\nThe following complains about `Url` not implementing `Deserialize`\n\n``` rust\n#[derive(Deserialize)]\npub struct SerializableUrl(#[serde(deserialize_with=\"DeserializeWith::deserialize_with\")] Url)\n```\n\n", "hints_text": "", "created_at": "2016-05-16T18:46:34Z", "version": "0.7"}, {"repo": "serde-rs/serde", "pull_number": 322, "instance_id": "serde-rs__serde-322", "issue_numbers": ["321"], "base_commit": "74eb2f52b8f6c8c865f49c222c3ea5d74ef8fb61", "patch": "diff --git a/serde/src/bytes.rs b/serde/src/bytes.rs\nindex f83ab8dd6..67f8ce85b 100644\n--- a/serde/src/bytes.rs\n+++ b/serde/src/bytes.rs\n@@ -41,7 +41,7 @@ impl<'a> From<&'a [u8]> for Bytes<'a> {\n impl<'a> From<&'a Vec<u8>> for Bytes<'a> {\n     fn from(bytes: &'a Vec<u8>) -> Self {\n         Bytes {\n-            bytes: &bytes,\n+            bytes: bytes,\n         }\n     }\n }\n@@ -165,7 +165,7 @@ mod bytebuf {\n         fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n             where S: ser::Serializer\n         {\n-            serializer.serialize_bytes(&self)\n+            serializer.serialize_bytes(self)\n         }\n     }\n \ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex df9c75e40..ed727aa23 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -118,7 +118,7 @@ impl Visitor for BoolVisitor {\n     fn visit_str<E>(&mut self, s: &str) -> Result<bool, E>\n         where E: Error,\n     {\n-        match s.trim_matches(|c| ::utils::Pattern_White_Space(c)) {\n+        match s.trim_matches(::utils::Pattern_White_Space) {\n             \"true\" => Ok(true),\n             \"false\" => Ok(false),\n             _ => Err(Error::invalid_type(Type::Bool)),\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex 3de00dbe1..78cc0c85d 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -9,7 +9,6 @@ use syntax::ast::{\n };\n use syntax::codemap::Span;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n-use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n \n", "test_patch": "diff --git a/serde_tests/benches/bench_enum.rs b/serde_tests/benches/bench_enum.rs\nindex e5deaad77..8badbb494 100644\n--- a/serde_tests/benches/bench_enum.rs\n+++ b/serde_tests/benches/bench_enum.rs\n@@ -1,9 +1,9 @@\n use test::Bencher;\n use std::error;\n use std::fmt;\n-use rustc_serialize::{Decoder, Decodable};\n+use rustc_serialize::Decodable;\n use serde;\n-use serde::de::{Deserializer, Deserialize};\n+use serde::de::Deserialize;\n \n //////////////////////////////////////////////////////////////////////////////\n \ndiff --git a/serde_tests/benches/bench_struct.rs b/serde_tests/benches/bench_struct.rs\nindex 402230d40..82b189e1e 100644\n--- a/serde_tests/benches/bench_struct.rs\n+++ b/serde_tests/benches/bench_struct.rs\n@@ -3,10 +3,10 @@ use test::Bencher;\n use std::fmt;\n use std::error;\n \n-use rustc_serialize::{Decoder, Decodable};\n+use rustc_serialize::Decodable;\n \n use serde;\n-use serde::de::{Deserializer, Deserialize};\n+use serde::de::Deserialize;\n \n //////////////////////////////////////////////////////////////////////////////\n \ndiff --git a/serde_tests/tests/test_de.rs b/serde_tests/tests/test_de.rs\nindex 27794aeb7..932b4b10b 100644\n--- a/serde_tests/tests/test_de.rs\n+++ b/serde_tests/tests/test_de.rs\n@@ -2,9 +2,6 @@ use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n use std::net;\n use std::path::PathBuf;\n \n-extern crate serde;\n-use self::serde::de::Deserializer;\n-\n use token::{\n     Error,\n     Token,\n", "problem_statement": "Unused imports and needless borrows\nI noticed these warnings in a Travis build:\n\n```\n/home/travis/build/serde-rs/serde/serde_codegen/src/de.rs:12:5: 12:35 warning: unused import, #[warn(unused_imports)] on by default\n/home/travis/build/serde-rs/serde/serde_codegen/src/de.rs:12 use syntax::ext::build::AstBuilder;\n                                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/travis/build/serde-rs/serde/serde_codegen/src/de.rs:12:5: 12:35 note: in this expansion of include!\n/home/travis/build/serde-rs/serde/serde/src/bytes.rs:35:20: 35:26 warning: this expression borrows a reference that is immediately dereferenced by the compiler, #[warn(needless_borrow)] on by default\n/home/travis/build/serde-rs/serde/serde/src/bytes.rs:35             bytes: &bytes,\n                                                                           ^~~~~~\n/home/travis/build/serde-rs/serde/serde/src/bytes.rs:35:20: 35:26 help: for further information visit https://github.com/Manishearth/rust-clippy/wiki#needless_borrow\n/home/travis/build/serde-rs/serde/serde/src/bytes.rs:143:36: 143:41 warning: this expression borrows a reference that is immediately dereferenced by the compiler, #[warn(needless_borrow)] on by default\n/home/travis/build/serde-rs/serde/serde/src/bytes.rs:143         serializer.serialize_bytes(&self)\n                                                                                            ^~~~~\n/home/travis/build/serde-rs/serde/serde/src/bytes.rs:143:36: 143:41 help: for further information visit https://github.com/Manishearth/rust-clippy/wiki#needless_borrow\ntests/../../serde_tests/tests/test_de.rs:6:5: 6:34 warning: unused import, #[warn(unused_imports)] on by default\ntests/../../serde_tests/tests/test_de.rs:6 use self::serde::de::Deserializer;\n                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n```\n\n", "hints_text": "More:\n\n```\nbenches/../../serde_tests/benches/bench_enum.rs:4:23: 4:30 warning: unused import, #[warn(unused_imports)] on by default\nbenches/../../serde_tests/benches/bench_enum.rs:4 use rustc_serialize::{Decoder, Decodable};\n                                                                        ^~~~~~~\nbenches/../../serde_tests/benches/bench_enum.rs:4:23: 4:30 note: in this expansion of include!\nbenches/../../serde_tests/benches/bench_enum.rs:6:17: 6:29 warning: unused import, #[warn(unused_imports)] on by default\nbenches/../../serde_tests/benches/bench_enum.rs:6 use serde::de::{Deserializer, Deserialize};\n                                                                  ^~~~~~~~~~~~\nbenches/../../serde_tests/benches/bench_enum.rs:6:17: 6:29 note: in this expansion of include!\nbenches/../../serde_tests/benches/bench_struct.rs:6:23: 6:30 warning: unused import, #[warn(unused_imports)] on by default\nbenches/../../serde_tests/benches/bench_struct.rs:6 use rustc_serialize::{Decoder, Decodable};\n                                                                          ^~~~~~~\nbenches/../../serde_tests/benches/bench_struct.rs:6:23: 6:30 note: in this expansion of include!\nbenches/../../serde_tests/benches/bench_struct.rs:9:17: 9:29 warning: unused import, #[warn(unused_imports)] on by default\nbenches/../../serde_tests/benches/bench_struct.rs:9 use serde::de::{Deserializer, Deserialize};\n                                                                    ^~~~~~~~~~~~\nbenches/../../serde_tests/benches/bench_struct.rs:9:17: 9:29 note: in this expansion of include!\n```\n", "created_at": "2016-05-13T17:47:56Z", "version": "0.7"}, {"repo": "serde-rs/serde", "pull_number": 308, "instance_id": "serde-rs__serde-308", "issue_numbers": ["307"], "base_commit": "8378267b9bcba853a5cd837cd0450f29f8a36efd", "patch": "diff --git a/serde_codegen/src/attr.rs b/serde_codegen/src/attr.rs\nindex 00ff5069c..c9ff9e809 100644\n--- a/serde_codegen/src/attr.rs\n+++ b/serde_codegen/src/attr.rs\n@@ -180,7 +180,7 @@ pub struct FieldAttrs {\n     skip_serializing_field_if: Option<P<ast::Expr>>,\n     default_expr_if_missing: Option<P<ast::Expr>>,\n     serialize_with: Option<P<ast::Expr>>,\n-    deserialize_with: P<ast::Expr>,\n+    deserialize_with: Option<ast::Path>,\n }\n \n impl FieldAttrs {\n@@ -197,8 +197,6 @@ impl FieldAttrs {\n             None => { cx.span_bug(field.span, \"struct field has no name?\") }\n         };\n \n-        let identity = quote_expr!(cx, |x| x);\n-\n         let mut field_attrs = FieldAttrs {\n             name: Name::new(field_ident),\n             skip_serializing_field: false,\n@@ -206,7 +204,7 @@ impl FieldAttrs {\n             skip_serializing_field_if: None,\n             default_expr_if_missing: None,\n             serialize_with: None,\n-            deserialize_with: identity,\n+            deserialize_with: None,\n         };\n \n         for meta_items in field.attrs.iter().filter_map(get_serde_meta_items) {\n@@ -287,14 +285,8 @@ impl FieldAttrs {\n \n                     // Parse `#[serde(deserialize_with=\"...\")]`\n                     ast::MetaItemKind::NameValue(ref name, ref lit) if name == &\"deserialize_with\" => {\n-                        let expr = wrap_deserialize_with(\n-                            cx,\n-                            &field.ty,\n-                            generics,\n-                            try!(parse_lit_into_path(cx, name, lit)),\n-                        );\n-\n-                        field_attrs.deserialize_with = expr;\n+                        let path = try!(parse_lit_into_path(cx, name, lit));\n+                        field_attrs.deserialize_with = Some(path);\n                     }\n \n                     _ => {\n@@ -348,8 +340,8 @@ impl FieldAttrs {\n         self.serialize_with.as_ref()\n     }\n \n-    pub fn deserialize_with(&self) -> &P<ast::Expr> {\n-        &self.deserialize_with\n+    pub fn deserialize_with(&self) -> Option<&ast::Path> {\n+        self.deserialize_with.as_ref()\n     }\n }\n \n@@ -612,36 +604,3 @@ fn wrap_serialize_with(cx: &ExtCtxt,\n         }\n     })\n }\n-\n-/// This function wraps the expression in `#[serde(deserialize_with=\"...\")]` in a trait to prevent\n-/// it from accessing the internal `Deserialize` state.\n-fn wrap_deserialize_with(cx: &ExtCtxt,\n-                         field_ty: &P<ast::Ty>,\n-                         generics: &ast::Generics,\n-                         path: ast::Path) -> P<ast::Expr> {\n-    // Quasi-quoting doesn't do a great job of expanding generics into paths, so manually build it.\n-    let ty_path = AstBuilder::new().path()\n-        .segment(\"__SerdeDeserializeWithStruct\")\n-            .with_generics(generics.clone())\n-            .build()\n-        .build();\n-\n-    let where_clause = &generics.where_clause;\n-\n-    quote_expr!(cx, ({\n-        struct __SerdeDeserializeWithStruct $generics $where_clause {\n-            value: $field_ty,\n-        }\n-\n-        impl $generics _serde::de::Deserialize for $ty_path $where_clause {\n-            fn deserialize<D>(deserializer: &mut D) -> ::std::result::Result<Self, D::Error>\n-                where D: _serde::de::Deserializer\n-            {\n-                let value = try!($path(deserializer));\n-                Ok(__SerdeDeserializeWithStruct { value: value })\n-            }\n-        }\n-\n-        |visit: $ty_path| visit.value\n-    }))\n-}\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex 366fb6680..f98fe7658 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -509,12 +509,14 @@ fn deserialize_seq(\n fn deserialize_struct_as_seq(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n+    type_ident: Ident,\n     struct_path: ast::Path,\n+    impl_generics: &ast::Generics,\n     fields: &[(&ast::StructField, attr::FieldAttrs)],\n ) -> Result<P<ast::Expr>, Error> {\n     let let_values: Vec<_> = fields.iter()\n         .enumerate()\n-        .map(|(i, &(_, ref attrs))| {\n+        .map(|(i, &(field, ref attrs))| {\n             let name = builder.id(format!(\"__field{}\", i));\n             if attrs.skip_deserializing_field() {\n                 let default = attrs.expr_is_missing();\n@@ -522,10 +524,24 @@ fn deserialize_struct_as_seq(\n                     let $name = $default;\n                 ).unwrap()\n             } else {\n-                let deserialize_with = attrs.deserialize_with();\n+                let visit = match attrs.deserialize_with() {\n+                    None => {\n+                        let field_ty = &field.ty;\n+                        quote_expr!(cx, try!(visitor.visit::<$field_ty>()))\n+                    }\n+                    Some(path) => {\n+                        let (wrapper, wrapper_impl, wrapper_ty) = wrap_deserialize_with(\n+                            cx, builder, type_ident, impl_generics, &field.ty, path);\n+                        quote_expr!(cx, {\n+                            $wrapper\n+                            $wrapper_impl\n+                            try!(visitor.visit::<$wrapper_ty>()).map(|wrap| wrap.value)\n+                        })\n+                    }\n+                };\n                 quote_stmt!(cx,\n-                    let $name = match try!(visitor.visit()) {\n-                        Some(value) => { $deserialize_with(value) },\n+                    let $name = match $visit {\n+                        Some(value) => { value },\n                         None => {\n                             return Err(_serde::de::Error::end_of_stream());\n                         }\n@@ -587,14 +603,18 @@ fn deserialize_struct(\n     let visit_seq_expr = try!(deserialize_struct_as_seq(\n         cx,\n         builder,\n+        type_ident,\n         type_path.clone(),\n+        impl_generics,\n         &fields_with_attrs,\n     ));\n \n     let (field_visitor, fields_stmt, visit_map_expr) = try!(deserialize_struct_visitor(\n         cx,\n         builder,\n+        type_ident,\n         type_path.clone(),\n+        impl_generics,\n         &fields_with_attrs,\n         container_attrs,\n     ));\n@@ -843,14 +863,18 @@ fn deserialize_struct_variant(\n     let visit_seq_expr = try!(deserialize_struct_as_seq(\n         cx,\n         builder,\n+        type_ident,\n         type_path.clone(),\n+        generics,\n         &fields_with_attrs,\n     ));\n \n     let (field_visitor, fields_stmt, field_expr) = try!(deserialize_struct_visitor(\n         cx,\n         builder,\n+        type_ident,\n         type_path,\n+        generics,\n         &fields_with_attrs,\n         container_attrs,\n     ));\n@@ -1011,10 +1035,8 @@ fn deserialize_field_visitor(\n             fn deserialize<D>(deserializer: &mut D) -> ::std::result::Result<__Field, D::Error>\n                 where D: _serde::de::Deserializer,\n             {\n-                use std::marker::PhantomData;\n-\n                 struct __FieldVisitor<D> {\n-                    phantom: PhantomData<D>\n+                    phantom: ::std::marker::PhantomData<D>\n                 }\n \n                 impl<__D> _serde::de::Visitor for __FieldVisitor<__D>\n@@ -1041,7 +1063,11 @@ fn deserialize_field_visitor(\n                     }\n                 }\n \n-                deserializer.deserialize_struct_field(__FieldVisitor::<D>{ phantom: PhantomData })\n+                deserializer.deserialize_struct_field(\n+                    __FieldVisitor::<D>{\n+                        phantom: ::std::marker::PhantomData\n+                    }\n+                )\n             }\n         }\n     ).unwrap();\n@@ -1052,7 +1078,9 @@ fn deserialize_field_visitor(\n fn deserialize_struct_visitor(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n+    type_ident: Ident,\n     struct_path: ast::Path,\n+    impl_generics: &ast::Generics,\n     fields: &[(&ast::StructField, attr::FieldAttrs)],\n     container_attrs: &attr::ContainerAttrs,\n ) -> Result<(Vec<P<ast::Item>>, ast::Stmt, P<ast::Expr>), Error> {\n@@ -1071,7 +1099,9 @@ fn deserialize_struct_visitor(\n     let visit_map_expr = try!(deserialize_map(\n         cx,\n         builder,\n+        type_ident,\n         struct_path,\n+        impl_generics,\n         fields,\n         container_attrs,\n     ));\n@@ -1100,7 +1130,9 @@ fn deserialize_struct_visitor(\n fn deserialize_map(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n+    type_ident: Ident,\n     struct_path: ast::Path,\n+    impl_generics: &ast::Generics,\n     fields: &[(&ast::StructField, attr::FieldAttrs)],\n     container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n@@ -1114,17 +1146,34 @@ fn deserialize_map(\n     // Declare each field that will be deserialized.\n     let let_values: Vec<ast::Stmt> = fields_attrs_names.iter()\n         .filter(|&&(_, ref attrs, _)| !attrs.skip_deserializing_field())\n-        .map(|&(_, _, name)| quote_stmt!(cx, let mut $name = None;).unwrap())\n+        .map(|&(field, _, name)| {\n+            let field_ty = &field.ty;\n+            quote_stmt!(cx, let mut $name: Option<$field_ty> = None;).unwrap()\n+        })\n         .collect();\n \n     // Match arms to extract a value for a field.\n     let value_arms = fields_attrs_names.iter()\n         .filter(|&&(_, ref attrs, _)| !attrs.skip_deserializing_field())\n-        .map(|&(_, ref attrs, name)| {\n-            let deserialize_with = attrs.deserialize_with();\n+        .map(|&(field, ref attrs, name)| {\n+            let visit = match attrs.deserialize_with() {\n+                None => {\n+                    let field_ty = &field.ty;\n+                    quote_expr!(cx, try!(visitor.visit_value::<$field_ty>()))\n+                }\n+                Some(path) => {\n+                    let (wrapper, wrapper_impl, wrapper_ty) = wrap_deserialize_with(\n+                        cx, builder, type_ident, impl_generics, &field.ty, path);\n+                    quote_expr!(cx, ({\n+                        $wrapper\n+                        $wrapper_impl\n+                        try!(visitor.visit_value::<$wrapper_ty>()).value\n+                    }))\n+                }\n+            };\n             quote_arm!(cx,\n                 __Field::$name => {\n-                    $name = Some($deserialize_with(try!(visitor.visit_value())));\n+                    $name = Some($visit);\n                 }\n             )\n         })\n@@ -1192,7 +1241,7 @@ fn deserialize_map(\n     Ok(quote_expr!(cx, {\n         $let_values\n \n-        while let Some(key) = try!(visitor.visit_key()) {\n+        while let Some(key) = try!(visitor.visit_key::<__Field>()) {\n             match key {\n                 $value_arms\n                 $skipped_arms\n@@ -1222,3 +1271,55 @@ fn fields_with_attrs<'a>(\n         })\n         .collect()\n }\n+\n+/// This function wraps the expression in `#[serde(deserialize_with=\"...\")]` in\n+/// a trait to prevent it from accessing the internal `Deserialize` state.\n+fn wrap_deserialize_with(\n+    cx: &ExtCtxt,\n+    builder: &aster::AstBuilder,\n+    type_ident: Ident,\n+    impl_generics: &ast::Generics,\n+    field_ty: &P<ast::Ty>,\n+    deserialize_with: &ast::Path,\n+) -> (ast::Stmt, ast::Stmt, ast::Path) {\n+    // Quasi-quoting doesn't do a great job of expanding generics into paths,\n+    // so manually build it.\n+    let wrapper_ty = builder.path()\n+        .segment(\"__SerdeDeserializeWithStruct\")\n+            .with_generics(impl_generics.clone())\n+            .build()\n+        .build();\n+\n+    let where_clause = &impl_generics.where_clause;\n+\n+    let phantom_ty = builder.path()\n+        .segment(type_ident)\n+            .with_generics(builder.from_generics(impl_generics.clone())\n+                .strip_ty_params()\n+                .build())\n+            .build()\n+        .build();\n+\n+    (\n+        quote_stmt!(cx,\n+            struct __SerdeDeserializeWithStruct $impl_generics $where_clause {\n+                value: $field_ty,\n+                phantom: ::std::marker::PhantomData<$phantom_ty>,\n+            }\n+        ).unwrap(),\n+        quote_stmt!(cx,\n+            impl $impl_generics _serde::de::Deserialize for $wrapper_ty $where_clause {\n+                fn deserialize<D>(__d: &mut D) -> ::std::result::Result<Self, D::Error>\n+                    where D: _serde::de::Deserializer\n+                {\n+                    let value = try!($deserialize_with(__d));\n+                    Ok(__SerdeDeserializeWithStruct {\n+                        value: value,\n+                        phantom: ::std::marker::PhantomData,\n+                    })\n+                }\n+            }\n+        ).unwrap(),\n+        wrapper_ty,\n+    )\n+}\n", "test_patch": "diff --git a/serde_tests/tests/test.rs.in b/serde_tests/tests/test.rs.in\nindex 89a1b3456..f64b84c18 100644\n--- a/serde_tests/tests/test.rs.in\n+++ b/serde_tests/tests/test.rs.in\n@@ -6,5 +6,6 @@ mod token;\n mod test_annotations;\n mod test_bytes;\n mod test_de;\n+mod test_gen;\n mod test_macros;\n mod test_ser;\ndiff --git a/serde_tests/tests/test_de.rs b/serde_tests/tests/test_de.rs\nindex 1859cee98..601710adb 100644\n--- a/serde_tests/tests/test_de.rs\n+++ b/serde_tests/tests/test_de.rs\n@@ -3,7 +3,7 @@ use std::net;\n use std::path::PathBuf;\n \n extern crate serde;\n-use self::serde::de::{Deserializer, Visitor};\n+use self::serde::de::Deserializer;\n \n use token::{\n     Error,\ndiff --git a/serde_tests/tests/test_gen.rs b/serde_tests/tests/test_gen.rs\nnew file mode 100644\nindex 000000000..805c100db\n--- /dev/null\n+++ b/serde_tests/tests/test_gen.rs\n@@ -0,0 +1,56 @@\n+// These just test that serde_codegen is able to produce code that compiles\n+// successfully when there are a variety of generics involved.\n+\n+extern crate serde;\n+use self::serde::ser::{Serialize, Serializer};\n+use self::serde::de::{Deserialize, Deserializer};\n+\n+//////////////////////////////////////////////////////////////////////////\n+\n+#[derive(Serialize, Deserialize)]\n+struct With<T> {\n+    t: T,\n+    #[serde(serialize_with=\"ser_i32\", deserialize_with=\"de_i32\")]\n+    i: i32,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+struct WithRef<'a, T: 'a> {\n+    #[serde(skip_deserializing)]\n+    t: Option<&'a T>,\n+    #[serde(serialize_with=\"ser_i32\", deserialize_with=\"de_i32\")]\n+    i: i32,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+struct Bounds<T: Serialize + Deserialize> {\n+    t: T,\n+    option: Option<T>,\n+    boxed: Box<T>,\n+    option_boxed: Option<Box<T>>,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+struct NoBounds<T> {\n+    t: T,\n+    option: Option<T>,\n+    boxed: Box<T>,\n+    option_boxed: Option<Box<T>>,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+enum EnumWith<T> {\n+    A(\n+        #[serde(serialize_with=\"ser_i32\", deserialize_with=\"de_i32\")]\n+        i32),\n+    B {\n+        t: T,\n+        #[serde(serialize_with=\"ser_i32\", deserialize_with=\"de_i32\")]\n+        i: i32 },\n+}\n+\n+//////////////////////////////////////////////////////////////////////////\n+\n+fn ser_i32<S: Serializer>(_: &i32, _: &mut S) -> Result<(), S::Error> { panic!() }\n+\n+fn de_i32<D: Deserializer>(_: &mut D) -> Result<i32, D::Error> { panic!() }\n", "problem_statement": "Deserialize_with generates code that does not compile\n``` rust\n#[derive(Deserialize)]\nstruct S<T> {\n    t: T,\n    #[serde(deserialize_with=\"dw\")]\n    d: i32,\n}\n```\n\nThe implementation of `deserialize_with` turns this into a field deserializer:\n\n``` rust\nstruct __SerdeDeserializeWithStruct<T> where T: Deserialize\n    value: i32,\n}\n```\n\n... which does not compile because the type parameter `T` is unused. It incorrectly uses all of the generic type parameters without filtering for ones relevant to the specific field.\n\nFiltering is hard so a quick fix would be:\n\n``` rust\nstruct __SerdeDeserializeWithStruct<T> where T: Deserialize\n    value: i32,\n    phantom: PhantomData<S<T>>,\n}\n```\n\n", "hints_text": "", "created_at": "2016-05-07T22:31:54Z", "version": "0.7"}, {"repo": "serde-rs/serde", "pull_number": 249, "instance_id": "serde-rs__serde-249", "issue_numbers": ["247"], "base_commit": "96483ee54f5078c7a632dc43332911a1df9241ad", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 7bb024915..c30400da0 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -88,7 +88,7 @@ impl Visitor for BoolVisitor {\n         match s.trim() {\n             \"true\" => Ok(true),\n             \"false\" => Ok(false),\n-            _ => Err(Error::type_mismatch(Type::Bool)),\n+            _ => Err(Error::invalid_type(Type::Bool)),\n         }\n     }\n }\n@@ -111,30 +111,30 @@ macro_rules! impl_deserialize_num_method {\n         {\n             match FromPrimitive::$from_method(v) {\n                 Some(v) => Ok(v),\n-                None => Err(Error::type_mismatch($ty)),\n+                None => Err(Error::invalid_type($ty)),\n             }\n         }\n     }\n }\n \n /// A visitor that produces a primitive type.\n-pub struct PrimitiveVisitor<T> {\n+struct PrimitiveVisitor<T> {\n     marker: PhantomData<T>,\n }\n \n impl<T> PrimitiveVisitor<T> {\n     /// Construct a new `PrimitiveVisitor`.\n     #[inline]\n-    pub fn new() -> Self {\n+    fn new() -> Self {\n         PrimitiveVisitor {\n             marker: PhantomData,\n         }\n     }\n }\n \n-impl<\n-    T: Deserialize + FromPrimitive + str::FromStr\n-> Visitor for PrimitiveVisitor<T> {\n+impl<T> Visitor for PrimitiveVisitor<T>\n+    where T: Deserialize + FromPrimitive + str::FromStr\n+{\n     type Value = T;\n \n     impl_deserialize_num_method!(isize, visit_isize, from_isize, Type::Isize);\n@@ -155,7 +155,7 @@ impl<\n         where E: Error,\n     {\n         str::FromStr::from_str(v.trim()).or_else(|_| {\n-            Err(Error::type_mismatch(Type::Str))\n+            Err(Error::invalid_type(Type::Str))\n         })\n     }\n }\n@@ -207,7 +207,7 @@ impl Visitor for CharVisitor {\n         let mut iter = v.chars();\n         if let Some(v) = iter.next() {\n             if iter.next().is_some() {\n-                Err(Error::type_mismatch(Type::Char))\n+                Err(Error::invalid_type(Type::Char))\n             } else {\n                 Ok(v)\n             }\n@@ -250,7 +250,7 @@ impl Visitor for StringVisitor {\n     {\n         match str::from_utf8(v) {\n             Ok(s) => Ok(s.to_owned()),\n-            Err(_) => Err(Error::type_mismatch(Type::String)),\n+            Err(_) => Err(Error::invalid_type(Type::String)),\n         }\n     }\n \n@@ -259,7 +259,7 @@ impl Visitor for StringVisitor {\n     {\n         match String::from_utf8(v) {\n             Ok(s) => Ok(s),\n-            Err(_) => Err(Error::type_mismatch(Type::String)),\n+            Err(_) => Err(Error::invalid_type(Type::String)),\n         }\n     }\n }\n@@ -889,7 +889,7 @@ impl<T> Deserialize for NonZero<T> where T: Deserialize + PartialEq + Zeroable +\n     fn deserialize<D>(deserializer: &mut D) -> Result<NonZero<T>, D::Error> where D: Deserializer {\n         let value = try!(Deserialize::deserialize(deserializer));\n         if value == Zero::zero() {\n-            return Err(Error::syntax(\"expected a non-zero value\"))\n+            return Err(Error::invalid_value(\"expected a non-zero value\"))\n         }\n         unsafe {\n             Ok(NonZero::new(value))\n@@ -941,7 +941,7 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n                             _ => {\n                                 match str::from_utf8(value) {\n                                     Ok(value) => Err(Error::unknown_field(value)),\n-                                    Err(_) => Err(Error::type_mismatch(Type::String)),\n+                                    Err(_) => Err(Error::invalid_type(Type::String)),\n                                 }\n                             }\n                         }\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex d45930e4e..ef7baedca 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -12,44 +12,44 @@ mod from_primitive;\n /// `Deserializer` error.\n pub trait Error: Sized + error::Error {\n     /// Raised when there is general error when deserializing a type.\n-    fn syntax(msg: &str) -> Self;\n+    fn custom(msg: String) -> Self;\n \n-    /// Raised when a fixed sized sequence or map was passed in the wrong amount of arguments.\n-    fn length_mismatch(_len: usize) -> Self {\n-        Error::syntax(\"incorrect length\")\n-    }\n+    /// Raised when a `Deserialize` type unexpectedly hit the end of the stream.\n+    fn end_of_stream() -> Self;\n \n     /// Raised when a `Deserialize` was passed an incorrect type.\n-    fn type_mismatch(_type: Type) -> Self {\n-        Error::syntax(\"incorrect type\")\n+    fn invalid_type(ty: Type) -> Self {\n+        Error::custom(format!(\"Invalid type. Expected `{:?}`\", ty))\n     }\n \n     /// Raised when a `Deserialize` was passed an incorrect value.\n     fn invalid_value(msg: &str) -> Self {\n-        Error::syntax(msg)\n+        Error::custom(format!(\"Invalid value: {}\", msg))\n     }\n \n-    /// Raised when a `Deserialize` type unexpectedly hit the end of the stream.\n-    fn end_of_stream() -> Self;\n-\n-    /// Raised when a `Deserialize` struct type received an unexpected struct field.\n-    fn unknown_field(field: &str) -> Self {\n-        Error::syntax(&format!(\"Unknown field `{}`\", field))\n+    /// Raised when a fixed sized sequence or map was passed in the wrong amount of arguments.\n+    fn invalid_length(len: usize) -> Self {\n+        Error::custom(format!(\"Invalid length: {}\", len))\n     }\n \n     /// Raised when a `Deserialize` enum type received an unexpected variant.\n     fn unknown_variant(field: &str) -> Self {\n-        Error::syntax(&format!(\"Unknown variant `{}`\", field))\n+        Error::custom(format!(\"Unknown variant `{}`\", field))\n+    }\n+\n+    /// Raised when a `Deserialize` struct type received an unexpected struct field.\n+    fn unknown_field(field: &str) -> Self {\n+        Error::custom(format!(\"Unknown field `{}`\", field))\n     }\n \n     /// raised when a `deserialize` struct type did not receive a field.\n     fn missing_field(field: &'static str) -> Self {\n-        Error::syntax(&format!(\"Missing field `{}`\", field))\n+        Error::custom(format!(\"Missing field `{}`\", field))\n     }\n }\n \n /// `Type` represents all the primitive types that can be deserialized. This is used by\n-/// `Error::kind_mismatch`.\n+/// `Error::invalid_type`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Type {\n     /// Represents a `bool` type.\n@@ -124,12 +124,18 @@ pub enum Type {\n     /// Represents a struct type.\n     Struct,\n \n+    /// Represents a struct field name.\n+    FieldName,\n+\n     /// Represents a tuple type.\n     Tuple,\n \n     /// Represents an `enum` type.\n     Enum,\n \n+    /// Represents an enum variant name.\n+    VariantName,\n+\n     /// Represents a struct variant.\n     StructVariant,\n \n@@ -416,7 +422,7 @@ pub trait Deserializer {\n                            _visitor: V) -> Result<V::Value, Self::Error>\n         where V: EnumVisitor,\n     {\n-        Err(Error::syntax(\"expected an enum\"))\n+        Err(Error::invalid_type(Type::Enum))\n     }\n \n     /// This method hints that the `Deserialize` type is expecting a `Vec<u8>`. This allows\n@@ -460,7 +466,7 @@ pub trait Visitor {\n     fn visit_bool<E>(&mut self, _v: bool) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::type_mismatch(Type::Bool))\n+        Err(Error::invalid_type(Type::Bool))\n     }\n \n     /// `visit_isize` deserializes a `isize` into a `Value`.\n@@ -495,7 +501,7 @@ pub trait Visitor {\n     fn visit_i64<E>(&mut self, _v: i64) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::type_mismatch(Type::I64))\n+        Err(Error::invalid_type(Type::I64))\n     }\n \n     /// `visit_usize` deserializes a `usize` into a `Value`.\n@@ -530,7 +536,7 @@ pub trait Visitor {\n     fn visit_u64<E>(&mut self, _v: u64) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::type_mismatch(Type::U64))\n+        Err(Error::invalid_type(Type::U64))\n     }\n \n     /// `visit_f32` deserializes a `f32` into a `Value`.\n@@ -544,7 +550,7 @@ pub trait Visitor {\n     fn visit_f64<E>(&mut self, _v: f64) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::type_mismatch(Type::F64))\n+        Err(Error::invalid_type(Type::F64))\n     }\n \n     /// `visit_char` deserializes a `char` into a `Value`.\n@@ -561,7 +567,7 @@ pub trait Visitor {\n     fn visit_str<E>(&mut self, _v: &str) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::type_mismatch(Type::Str))\n+        Err(Error::invalid_type(Type::Str))\n     }\n \n     /// `visit_string` deserializes a `String` into a `Value`.  This allows a deserializer to avoid\n@@ -578,7 +584,7 @@ pub trait Visitor {\n     fn visit_unit<E>(&mut self) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::type_mismatch(Type::Unit))\n+        Err(Error::invalid_type(Type::Unit))\n     }\n \n     /// `visit_unit_struct` deserializes a unit struct into a `Value`.\n@@ -593,42 +599,42 @@ pub trait Visitor {\n     fn visit_none<E>(&mut self) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::type_mismatch(Type::Option))\n+        Err(Error::invalid_type(Type::Option))\n     }\n \n     /// `visit_some` deserializes a value into a `Value`.\n     fn visit_some<D>(&mut self, _deserializer: &mut D) -> Result<Self::Value, D::Error>\n         where D: Deserializer,\n     {\n-        Err(Error::type_mismatch(Type::Option))\n+        Err(Error::invalid_type(Type::Option))\n     }\n \n     /// `visit_newtype_struct` deserializes a value into a `Value`.\n     fn visit_newtype_struct<D>(&mut self, _deserializer: &mut D) -> Result<Self::Value, D::Error>\n         where D: Deserializer,\n     {\n-        Err(Error::type_mismatch(Type::NewtypeStruct))\n+        Err(Error::invalid_type(Type::NewtypeStruct))\n     }\n \n     /// `visit_bool` deserializes a `SeqVisitor` into a `Value`.\n     fn visit_seq<V>(&mut self, _visitor: V) -> Result<Self::Value, V::Error>\n         where V: SeqVisitor,\n     {\n-        Err(Error::type_mismatch(Type::Seq))\n+        Err(Error::invalid_type(Type::Seq))\n     }\n \n     /// `visit_map` deserializes a `MapVisitor` into a `Value`.\n     fn visit_map<V>(&mut self, _visitor: V) -> Result<Self::Value, V::Error>\n         where V: MapVisitor,\n     {\n-        Err(Error::type_mismatch(Type::Map))\n+        Err(Error::invalid_type(Type::Map))\n     }\n \n     /// `visit_bytes` deserializes a `&[u8]` into a `Value`.\n     fn visit_bytes<E>(&mut self, _v: &[u8]) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::type_mismatch(Type::Bytes))\n+        Err(Error::invalid_type(Type::Bytes))\n     }\n \n     /// `visit_byte_buf` deserializes a `Vec<u8>` into a `Value`.\n@@ -799,7 +805,7 @@ pub trait VariantVisitor {\n \n     /// `visit_unit` is called when deserializing a variant with no values.\n     fn visit_unit(&mut self) -> Result<(), Self::Error> {\n-        Err(Error::type_mismatch(Type::UnitVariant))\n+        Err(Error::invalid_type(Type::UnitVariant))\n     }\n \n     /// `visit_newtype` is called when deserializing a variant with a single value. By default this\n@@ -818,7 +824,7 @@ pub trait VariantVisitor {\n                       _visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor\n     {\n-        Err(Error::type_mismatch(Type::TupleVariant))\n+        Err(Error::invalid_type(Type::TupleVariant))\n     }\n \n     /// `visit_struct` is called when deserializing a struct-like variant.\n@@ -827,7 +833,7 @@ pub trait VariantVisitor {\n                        _visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor\n     {\n-        Err(Error::type_mismatch(Type::StructVariant))\n+        Err(Error::invalid_type(Type::StructVariant))\n     }\n }\n \ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 3f40f39e5..773c19df3 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -24,18 +24,24 @@ use bytes;\n /// This represents all the possible errors that can occur using the `ValueDeserializer`.\n #[derive(Clone, Debug, PartialEq)]\n pub enum Error {\n-    /// The value had some syntatic error.\n-    Syntax(String),\n+    /// The value had some custom error.\n+    Custom(String),\n \n     /// The value had an incorrect type.\n-    Type(de::Type),\n+    InvalidType(de::Type),\n \n     /// The value had an invalid length.\n-    Length(usize),\n+    InvalidLength(usize),\n+\n+    /// The value is invalid and cannot be deserialized.\n+    InvalidValue(String),\n \n     /// EOF while deserializing a value.\n     EndOfStream,\n \n+    /// Unknown variant in enum.\n+    UnknownVariant(String),\n+\n     /// Unknown field in struct.\n     UnknownField(String),\n \n@@ -44,10 +50,12 @@ pub enum Error {\n }\n \n impl de::Error for Error {\n-    fn syntax(msg: &str) -> Self { Error::Syntax(String::from(msg)) }\n-    fn type_mismatch(type_: de::Type) -> Self { Error::Type(type_) }\n-    fn length_mismatch(len: usize) -> Self { Error::Length(len) }\n+    fn custom(msg: String) -> Self { Error::Custom(msg) }\n     fn end_of_stream() -> Self { Error::EndOfStream }\n+    fn invalid_type(ty: de::Type) -> Self { Error::InvalidType(ty) }\n+    fn invalid_value(msg: &str) -> Self { Error::InvalidValue(msg.to_owned()) }\n+    fn invalid_length(len: usize) -> Self { Error::InvalidLength(len) }\n+    fn unknown_variant(variant: &str) -> Self { Error::UnknownVariant(String::from(variant)) }\n     fn unknown_field(field: &str) -> Self { Error::UnknownField(String::from(field)) }\n     fn missing_field(field: &'static str) -> Self { Error::MissingField(field) }\n }\n@@ -55,10 +63,14 @@ impl de::Error for Error {\n impl fmt::Display for Error {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         match *self {\n-            Error::Syntax(ref s) => write!(formatter, \"Syntax error: {}\", s),\n-            Error::Type(ty) => write!(formatter, \"Invalid type: {:?}\", ty),\n-            Error::Length(len) => write!(formatter, \"Invalid length: {}\", len),\n-            Error::EndOfStream => formatter.write_str(\"EndOfStreamError\"),\n+            Error::Custom(ref s) => write!(formatter, \"{}\", s),\n+            Error::EndOfStream => formatter.write_str(\"End of stream\"),\n+            Error::InvalidType(ty) => write!(formatter, \"Invalid type, expected `{:?}`\", ty),\n+            Error::InvalidValue(ref value) => write!(formatter, \"Invalid value: {}\", value),\n+            Error::InvalidLength(len) => write!(formatter, \"Invalid length: {}\", len),\n+            Error::UnknownVariant(ref variant) => {\n+                write!(formatter, \"Unknown variant: {}\", variant)\n+            }\n             Error::UnknownField(ref field) => write!(formatter, \"Unknown field: {}\", field),\n             Error::MissingField(ref field) => write!(formatter, \"Missing field: {}\", field),\n         }\n@@ -338,7 +350,7 @@ impl<I, T, E> de::SeqVisitor for SeqDeserializer<I, E>\n         if self.len == 0 {\n             Ok(())\n         } else {\n-            Err(de::Error::length_mismatch(self.len))\n+            Err(de::Error::invalid_length(self.len))\n         }\n     }\n \n@@ -494,7 +506,9 @@ impl<I, K, V, E> de::MapVisitor for MapDeserializer<I, K, V, E>\n                 let mut de = value.into_deserializer();\n                 de::Deserialize::deserialize(&mut de)\n             }\n-            None => Err(de::Error::syntax(\"expected a map value\"))\n+            None => {\n+                Err(de::Error::end_of_stream())\n+            }\n         }\n     }\n \n@@ -502,7 +516,7 @@ impl<I, K, V, E> de::MapVisitor for MapDeserializer<I, K, V, E>\n         if self.len == 0 {\n             Ok(())\n         } else {\n-            Err(de::Error::length_mismatch(self.len))\n+            Err(de::Error::invalid_length(self.len))\n         }\n     }\n \ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex e700b44fc..01368afb6 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -10,11 +10,11 @@ pub mod impls;\n /// `Serializer` error.\n pub trait Error: Sized + error::Error {\n     /// Raised when there is general error when deserializing a type.\n-    fn syntax(msg: &str) -> Self;\n+    fn custom(msg: String) -> Self;\n \n     /// Raised when a `Serialize` was passed an incorrect value.\n     fn invalid_value(msg: &str) -> Self {\n-        Error::syntax(msg)\n+        Error::custom(format!(\"invalid value: {}\", msg))\n     }\n }\n \ndiff --git a/serde_codegen/src/attr.rs b/serde_codegen/src/attr.rs\nindex a082fcbfa..d937f6050 100644\n--- a/serde_codegen/src/attr.rs\n+++ b/serde_codegen/src/attr.rs\n@@ -5,7 +5,7 @@ use syntax::codemap::Span;\n use syntax::ext::base::ExtCtxt;\n use syntax::fold::Folder;\n use syntax::parse::parser::PathParsingMode;\n-use syntax::parse::token;\n+use syntax::parse::token::{self, InternedString};\n use syntax::parse;\n use syntax::print::pprust::{lit_to_string, meta_item_to_string};\n use syntax::ptr::P;\n@@ -14,22 +14,66 @@ use aster::AstBuilder;\n \n use error::Error;\n \n+#[derive(Debug)]\n+pub struct Name {\n+    ident: ast::Ident,\n+    serialize_name: Option<InternedString>,\n+    deserialize_name: Option<InternedString>,\n+}\n+\n+impl Name {\n+    fn new(ident: ast::Ident) -> Self {\n+        Name {\n+            ident: ident,\n+            serialize_name: None,\n+            deserialize_name: None,\n+        }\n+    }\n+\n+    /// Return the string expression of the field ident.\n+    pub fn ident_expr(&self) -> P<ast::Expr> {\n+        AstBuilder::new().expr().str(self.ident)\n+    }\n+\n+    /// Return the container name for the container when serializing.\n+    pub fn serialize_name(&self) -> InternedString {\n+        match self.serialize_name {\n+            Some(ref name) => name.clone(),\n+            None => self.ident.name.as_str(),\n+        }\n+    }\n+\n+    /// Return the container name expression for the container when deserializing.\n+    pub fn serialize_name_expr(&self) -> P<ast::Expr> {\n+        AstBuilder::new().expr().str(self.serialize_name())\n+    }\n+\n+    /// Return the container name for the container when deserializing.\n+    pub fn deserialize_name(&self) -> InternedString {\n+        match self.deserialize_name {\n+            Some(ref name) => name.clone(),\n+            None => self.ident.name.as_str(),\n+        }\n+    }\n+\n+    /// Return the container name expression for the container when deserializing.\n+    pub fn deserialize_name_expr(&self) -> P<ast::Expr> {\n+        AstBuilder::new().expr().str(self.deserialize_name())\n+    }\n+}\n+\n /// Represents container (e.g. struct) attribute information\n #[derive(Debug)]\n pub struct ContainerAttrs {\n-    ident: ast::Ident,\n-    serialize_name: Option<ast::Lit>,\n-    deserialize_name: Option<ast::Lit>,\n+    name: Name,\n     deny_unknown_fields: bool,\n }\n \n impl ContainerAttrs {\n     /// Extract out the `#[serde(...)]` attributes from an item.\n-    pub fn from_item(cx: &ExtCtxt, item: &ast::Item) -> Result<ContainerAttrs, Error> {\n+    pub fn from_item(cx: &ExtCtxt, item: &ast::Item) -> Result<Self, Error> {\n         let mut container_attrs = ContainerAttrs {\n-            ident: item.ident,\n-            serialize_name: None,\n-            deserialize_name: None,\n+            name: Name::new(item.ident),\n             deny_unknown_fields: false,\n         };\n \n@@ -38,15 +82,18 @@ impl ContainerAttrs {\n                 match meta_item.node {\n                     // Parse `#[serde(rename=\"foo\")]`\n                     ast::MetaItemKind::NameValue(ref name, ref lit) if name == &\"rename\" => {\n-                        container_attrs.serialize_name = Some(lit.clone());\n-                        container_attrs.deserialize_name = Some(lit.clone());\n+                        let s = try!(get_str_from_lit(cx, name, lit));\n+\n+                        container_attrs.name.serialize_name = Some(s.clone());\n+                        container_attrs.name.deserialize_name = Some(s);\n                     }\n \n                     // Parse `#[serde(rename(serialize=\"foo\", deserialize=\"bar\"))]`\n                     ast::MetaItemKind::List(ref name, ref meta_items) if name == &\"rename\" => {\n                         let (ser_name, de_name) = try!(get_renames(cx, meta_items));\n-                        container_attrs.serialize_name = ser_name;\n-                        container_attrs.deserialize_name = de_name;\n+\n+                        container_attrs.name.serialize_name = ser_name;\n+                        container_attrs.name.deserialize_name = de_name;\n                     }\n \n                     // Parse `#[serde(deny_unknown_fields)]`\n@@ -69,25 +116,8 @@ impl ContainerAttrs {\n         Ok(container_attrs)\n     }\n \n-    /// Return the string expression of the field ident.\n-    pub fn ident_expr(&self) -> P<ast::Expr> {\n-        AstBuilder::new().expr().str(self.ident)\n-    }\n-\n-    /// Return the field name for the field when serializing.\n-    pub fn serialize_name_expr(&self) -> P<ast::Expr> {\n-        match self.serialize_name {\n-            Some(ref name) => AstBuilder::new().expr().build_lit(P(name.clone())),\n-            None => self.ident_expr(),\n-        }\n-    }\n-\n-    /// Return the field name for the field when serializing.\n-    pub fn deserialize_name_expr(&self) -> P<ast::Expr> {\n-        match self.deserialize_name {\n-            Some(ref name) => AstBuilder::new().expr().build_lit(P(name.clone())),\n-            None => self.ident_expr(),\n-        }\n+    pub fn name(&self) -> &Name {\n+        &self.name\n     }\n \n     pub fn deny_unknown_fields(&self) -> bool {\n@@ -98,17 +128,13 @@ impl ContainerAttrs {\n /// Represents variant attribute information\n #[derive(Debug)]\n pub struct VariantAttrs {\n-    ident: ast::Ident,\n-    serialize_name: Option<ast::Lit>,\n-    deserialize_name: Option<ast::Lit>,\n+    name: Name,\n }\n \n impl VariantAttrs {\n     pub fn from_variant(cx: &ExtCtxt, variant: &ast::Variant) -> Result<Self, Error> {\n         let mut variant_attrs = VariantAttrs {\n-            ident: variant.node.name,\n-            serialize_name: None,\n-            deserialize_name: None,\n+            name: Name::new(variant.node.name),\n         };\n \n         for meta_items in variant.node.attrs.iter().filter_map(get_serde_meta_items) {\n@@ -116,15 +142,18 @@ impl VariantAttrs {\n                 match meta_item.node {\n                     // Parse `#[serde(rename=\"foo\")]`\n                     ast::MetaItemKind::NameValue(ref name, ref lit) if name == &\"rename\" => {\n-                        variant_attrs.serialize_name = Some(lit.clone());\n-                        variant_attrs.deserialize_name = Some(lit.clone());\n+                        let s = try!(get_str_from_lit(cx, name, lit));\n+\n+                        variant_attrs.name.serialize_name = Some(s.clone());\n+                        variant_attrs.name.deserialize_name = Some(s);\n                     }\n \n                     // Parse `#[serde(rename(serialize=\"foo\", deserialize=\"bar\"))]`\n                     ast::MetaItemKind::List(ref name, ref meta_items) if name == &\"rename\" => {\n                         let (ser_name, de_name) = try!(get_renames(cx, meta_items));\n-                        variant_attrs.serialize_name = ser_name;\n-                        variant_attrs.deserialize_name = de_name;\n+\n+                        variant_attrs.name.serialize_name = ser_name;\n+                        variant_attrs.name.deserialize_name = de_name;\n                     }\n \n                     _ => {\n@@ -142,34 +171,15 @@ impl VariantAttrs {\n         Ok(variant_attrs)\n     }\n \n-    /// Return the string expression of the field ident.\n-    pub fn ident_expr(&self) -> P<ast::Expr> {\n-        AstBuilder::new().expr().str(self.ident)\n-    }\n-\n-    /// Return the field name for the field when serializing.\n-    pub fn serialize_name_expr(&self) -> P<ast::Expr> {\n-        match self.serialize_name {\n-            Some(ref name) => AstBuilder::new().expr().build_lit(P(name.clone())),\n-            None => self.ident_expr(),\n-        }\n-    }\n-\n-    /// Return the field name for the field when serializing.\n-    pub fn deserialize_name_expr(&self) -> P<ast::Expr> {\n-        match self.deserialize_name {\n-            Some(ref name) => AstBuilder::new().expr().build_lit(P(name.clone())),\n-            None => self.ident_expr(),\n-        }\n+    pub fn name(&self) -> &Name {\n+        &self.name\n     }\n }\n \n /// Represents field attribute information\n #[derive(Debug)]\n pub struct FieldAttrs {\n-    ident: ast::Ident,\n-    serialize_name: Option<ast::Lit>,\n-    deserialize_name: Option<ast::Lit>,\n+    name: Name,\n     skip_serializing_field: bool,\n     skip_serializing_field_if: Option<P<ast::Expr>>,\n     default_expr_if_missing: Option<P<ast::Expr>>,\n@@ -192,9 +202,7 @@ impl FieldAttrs {\n         };\n \n         let mut field_attrs = FieldAttrs {\n-            ident: field_ident,\n-            serialize_name: None,\n-            deserialize_name: None,\n+            name: Name::new(field_ident),\n             skip_serializing_field: false,\n             skip_serializing_field_if: None,\n             default_expr_if_missing: None,\n@@ -207,15 +215,18 @@ impl FieldAttrs {\n                 match meta_item.node {\n                     // Parse `#[serde(rename=\"foo\")]`\n                     ast::MetaItemKind::NameValue(ref name, ref lit) if name == &\"rename\" => {\n-                        field_attrs.serialize_name = Some(lit.clone());\n-                        field_attrs.deserialize_name = Some(lit.clone());\n+                        let s = try!(get_str_from_lit(cx, name, lit));\n+\n+                        field_attrs.name.serialize_name = Some(s.clone());\n+                        field_attrs.name.deserialize_name = Some(s);\n                     }\n \n                     // Parse `#[serde(rename(serialize=\"foo\", deserialize=\"bar\"))]`\n                     ast::MetaItemKind::List(ref name, ref meta_items) if name == &\"rename\" => {\n                         let (ser_name, de_name) = try!(get_renames(cx, meta_items));\n-                        field_attrs.serialize_name = ser_name;\n-                        field_attrs.deserialize_name = de_name;\n+\n+                        field_attrs.name.serialize_name = ser_name;\n+                        field_attrs.name.deserialize_name = de_name;\n                     }\n \n                     // Parse `#[serde(default)]`\n@@ -290,25 +301,8 @@ impl FieldAttrs {\n         Ok(field_attrs)\n     }\n \n-    /// Return the string expression of the field ident.\n-    pub fn ident_expr(&self) -> P<ast::Expr> {\n-        AstBuilder::new().expr().str(self.ident)\n-    }\n-\n-    /// Return the field name for the field when serializing.\n-    pub fn serialize_name_expr(&self) -> P<ast::Expr> {\n-        match self.serialize_name {\n-            Some(ref name) => AstBuilder::new().expr().build_lit(P(name.clone())),\n-            None => self.ident_expr(),\n-        }\n-    }\n-\n-    /// Return the field name for the field when deserializing.\n-    pub fn deserialize_name_expr(&self) -> P<ast::Expr> {\n-        match self.deserialize_name {\n-            Some(ref name) => AstBuilder::new().expr().build_lit(P(name.clone())),\n-            None => self.ident_expr(),\n-        }\n+    pub fn name(&self) -> &Name {\n+        &self.name\n     }\n \n     /// Predicate for using a field's default value\n@@ -316,7 +310,7 @@ impl FieldAttrs {\n         match self.default_expr_if_missing {\n             Some(ref expr) => expr.clone(),\n             None => {\n-                let name = self.ident_expr();\n+                let name = self.name.ident_expr();\n                 AstBuilder::new().expr()\n                     .try()\n                     .method_call(\"missing_field\").id(\"visitor\")\n@@ -357,18 +351,21 @@ pub fn get_struct_field_attrs(cx: &ExtCtxt,\n }\n \n fn get_renames(cx: &ExtCtxt,\n-               items: &[P<ast::MetaItem>]) -> Result<(Option<ast::Lit>, Option<ast::Lit>), Error> {\n+               items: &[P<ast::MetaItem>],\n+              )-> Result<(Option<InternedString>, Option<InternedString>), Error> {\n     let mut ser_name = None;\n     let mut de_name = None;\n \n     for item in items {\n         match item.node {\n             ast::MetaItemKind::NameValue(ref name, ref lit) if name == &\"serialize\" => {\n-                ser_name = Some(lit.clone());\n+                let s = try!(get_str_from_lit(cx, name, lit));\n+                ser_name = Some(s);\n             }\n \n             ast::MetaItemKind::NameValue(ref name, ref lit) if name == &\"deserialize\" => {\n-                de_name = Some(lit.clone());\n+                let s = try!(get_str_from_lit(cx, name, lit));\n+                de_name = Some(s);\n             }\n \n             _ => {\n@@ -442,9 +439,9 @@ impl<'a, 'b> Folder for Respanner<'a, 'b> {\n     }\n }\n \n-fn parse_lit_into_path(cx: &ExtCtxt, name: &str, lit: &ast::Lit) -> Result<ast::Path, Error> {\n-    let source: &str = match lit.node {\n-        ast::LitKind::Str(ref source, _) => &source,\n+fn get_str_from_lit(cx: &ExtCtxt, name: &str, lit: &ast::Lit) -> Result<InternedString, Error> {\n+    match lit.node {\n+        ast::LitKind::Str(ref s, _) => Ok(s.clone()),\n         _ => {\n             cx.span_err(\n                 lit.span,\n@@ -454,7 +451,11 @@ fn parse_lit_into_path(cx: &ExtCtxt, name: &str, lit: &ast::Lit) -> Result<ast::\n \n             return Err(Error);\n         }\n-    };\n+    }\n+}\n+\n+fn parse_lit_into_path(cx: &ExtCtxt, name: &str, lit: &ast::Lit) -> Result<ast::Path, Error> {\n+    let source = try!(get_str_from_lit(cx, name, lit));\n \n     // If we just parse the string into an expression, any syntax errors in the source will only\n     // have spans that point inside the string, and not back to the attribute. So to have better\n@@ -463,7 +464,7 @@ fn parse_lit_into_path(cx: &ExtCtxt, name: &str, lit: &ast::Lit) -> Result<ast::\n     // and then finally parse them into an expression.\n     let tts = parse::parse_tts_from_source_str(\n         format!(\"<serde {} expansion>\", name),\n-        source.to_owned(),\n+        (*source).to_owned(),\n         cx.cfg(),\n         cx.parse_sess());\n \ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex a94fd02bb..fc9358098 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -10,6 +10,7 @@ use syntax::ast::{\n use syntax::codemap::Span;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n+use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n \n use attr;\n@@ -266,7 +267,7 @@ fn deserialize_unit_struct(\n     type_ident: Ident,\n     container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n-    let type_name = container_attrs.deserialize_name_expr();\n+    let type_name = container_attrs.name().deserialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         struct __Visitor;\n@@ -318,7 +319,7 @@ fn deserialize_newtype_struct(\n         1,\n     );\n \n-    let type_name = container_attrs.deserialize_name_expr();\n+    let type_name = container_attrs.name().deserialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         $visitor_item\n@@ -371,7 +372,7 @@ fn deserialize_tuple_struct(\n         fields,\n     );\n \n-    let type_name = container_attrs.deserialize_name_expr();\n+    let type_name = container_attrs.name().deserialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         $visitor_item\n@@ -510,7 +511,7 @@ fn deserialize_struct(\n         false,\n     ));\n \n-    let type_name = container_attrs.deserialize_name_expr();\n+    let type_name = container_attrs.name().deserialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         $field_visitor\n@@ -552,7 +553,7 @@ fn deserialize_item_enum(\n ) -> Result<P<ast::Expr>, Error> {\n     let where_clause = &impl_generics.where_clause;\n \n-    let type_name = container_attrs.deserialize_name_expr();\n+    let type_name = container_attrs.name().deserialize_name_expr();\n \n     let variant_visitor = deserialize_field_visitor(\n         cx,\n@@ -561,7 +562,7 @@ fn deserialize_item_enum(\n             enum_def.variants.iter()\n                 .map(|variant| {\n                     let attrs = try!(attr::VariantAttrs::from_variant(cx, variant));\n-                    Ok(attrs.deserialize_name_expr())\n+                    Ok(attrs.name().deserialize_name())\n                 })\n                 .collect()\n         ),\n@@ -806,12 +807,12 @@ fn deserialize_struct_variant(\n fn deserialize_field_visitor(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n-    field_names: Vec<P<ast::Expr>>,\n+    field_names: Vec<InternedString>,\n     container_attrs: &attr::ContainerAttrs,\n     is_variant: bool,\n ) -> Vec<P<ast::Item>> {\n     // Create the field names for the fields.\n-    let field_idents: Vec<ast::Ident> = (0 .. field_names.len())\n+    let field_idents: Vec<_> = (0 .. field_names.len())\n         .map(|i| builder.id(format!(\"__field{}\", i)))\n         .collect();\n \n@@ -846,22 +847,34 @@ fn deserialize_field_visitor(\n         (builder.expr().str(\"expected a field\"), builder.id(\"unknown_field\"))\n     };\n \n+    let fallthrough_index_arm_expr = if !is_variant && !container_attrs.deny_unknown_fields() {\n+        quote_expr!(cx, Ok(__Field::__ignore))\n+    } else {\n+        quote_expr!(cx, {\n+            Err(::serde::de::Error::invalid_value($index_error_msg))\n+        })\n+    };\n+\n     let index_body = quote_expr!(cx,\n         match value {\n             $index_field_arms\n-            _ => { Err(::serde::de::Error::syntax($index_error_msg)) }\n+            _ => $fallthrough_index_arm_expr\n         }\n     );\n \n+    // Convert the field names into byte strings.\n+    let str_field_names: Vec<_> = field_names.iter()\n+        .map(|name| builder.expr().lit().str(&name))\n+        .collect();\n+\n     // Match arms to extract a field from a string\n-    let default_field_arms: Vec<_> = field_idents.iter()\n-        .zip(field_names.iter())\n+    let str_field_arms: Vec<_> = field_idents.iter().zip(str_field_names.iter())\n         .map(|(field_ident, field_name)| {\n             quote_arm!(cx, $field_name => { Ok(__Field::$field_ident) })\n         })\n         .collect();\n \n-    let fallthrough_arm_expr = if !is_variant && !container_attrs.deny_unknown_fields() {\n+    let fallthrough_str_arm_expr = if !is_variant && !container_attrs.deny_unknown_fields() {\n         quote_expr!(cx, Ok(__Field::__ignore))\n     } else {\n         quote_expr!(cx, Err(::serde::de::Error::$unknown_ident(value)))\n@@ -869,8 +882,39 @@ fn deserialize_field_visitor(\n \n     let str_body = quote_expr!(cx,\n         match value {\n-            $default_field_arms\n-            _ => $fallthrough_arm_expr\n+            $str_field_arms\n+            _ => $fallthrough_str_arm_expr\n+        }\n+    );\n+\n+    // Convert the field names into byte strings.\n+    let bytes_field_names: Vec<_> = field_names.iter()\n+        .map(|name| {\n+            let name: &str = name;\n+            builder.expr().lit().byte_str(name)\n+        })\n+        .collect();\n+\n+    // Match arms to extract a field from a string\n+    let bytes_field_arms: Vec<_> = field_idents.iter().zip(bytes_field_names.iter())\n+        .map(|(field_ident, field_name)| {\n+            quote_arm!(cx, $field_name => { Ok(__Field::$field_ident) })\n+        })\n+        .collect();\n+\n+    let fallthrough_bytes_arm_expr = if !is_variant && !container_attrs.deny_unknown_fields() {\n+        quote_expr!(cx, Ok(__Field::__ignore))\n+    } else {\n+        quote_expr!(cx, {\n+            let value = ::std::string::String::from_utf8_lossy(value);\n+            Err(::serde::de::Error::$unknown_ident(&value))\n+        })\n+    };\n+\n+    let bytes_body = quote_expr!(cx,\n+        match value {\n+            $bytes_field_arms\n+            _ => $fallthrough_bytes_arm_expr\n         }\n     );\n \n@@ -906,17 +950,7 @@ fn deserialize_field_visitor(\n                     fn visit_bytes<E>(&mut self, value: &[u8]) -> ::std::result::Result<__Field, E>\n                         where E: ::serde::de::Error,\n                     {\n-                        // TODO: would be better to generate a byte string literal match\n-                        match ::std::str::from_utf8(value) {\n-                            Ok(s) => self.visit_str(s),\n-                            _ => {\n-                                Err(\n-                                    ::serde::de::Error::syntax(\n-                                        \"could not convert a byte string to a String\"\n-                                    )\n-                                )\n-                            }\n-                        }\n+                        $bytes_body\n                     }\n                 }\n \n@@ -947,7 +981,7 @@ fn deserialize_struct_visitor(\n                                              field,\n                                              is_enum)\n             );\n-            Ok(field_attrs.deserialize_name_expr())\n+            Ok(field_attrs.name().deserialize_name())\n         })\n         .collect();\n \ndiff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex b1e1641ff..cb97640dc 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -185,7 +185,7 @@ fn serialize_unit_struct(\n     cx: &ExtCtxt,\n     container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n-    let type_name = container_attrs.serialize_name_expr();\n+    let type_name = container_attrs.name().serialize_name_expr();\n \n     Ok(quote_expr!(cx,\n         serializer.serialize_unit_struct($type_name)\n@@ -196,7 +196,7 @@ fn serialize_newtype_struct(\n     cx: &ExtCtxt,\n     container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n-    let type_name = container_attrs.serialize_name_expr();\n+    let type_name = container_attrs.name().serialize_name_expr();\n \n     Ok(quote_expr!(cx,\n         serializer.serialize_newtype_struct($type_name, &self.0)\n@@ -224,7 +224,7 @@ fn serialize_tuple_struct(\n         impl_generics,\n     );\n \n-    let type_name = container_attrs.serialize_name_expr();\n+    let type_name = container_attrs.name().serialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         $visitor_struct\n@@ -259,7 +259,7 @@ fn serialize_struct(\n         false,\n     ));\n \n-    let type_name = container_attrs.serialize_name_expr();\n+    let type_name = container_attrs.name().serialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         $visitor_struct\n@@ -316,11 +316,11 @@ fn serialize_variant(\n     variant_index: usize,\n     container_attrs: &attr::ContainerAttrs,\n ) -> Result<ast::Arm, Error> {\n-    let type_name = container_attrs.serialize_name_expr();\n+    let type_name = container_attrs.name().serialize_name_expr();\n \n     let variant_ident = variant.node.name;\n     let variant_attrs = try!(attr::VariantAttrs::from_variant(cx, variant));\n-    let variant_name = variant_attrs.serialize_name_expr();\n+    let variant_name = variant_attrs.name().serialize_name_expr();\n \n     match variant.node.data {\n         ast::VariantData::Unit(_) => {\n@@ -551,7 +551,7 @@ fn serialize_struct_variant(\n         true,\n     ));\n \n-    let container_name = container_attrs.serialize_name_expr();\n+    let container_name = container_attrs.name().serialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         $variant_struct\n@@ -658,7 +658,7 @@ fn serialize_struct_visitor(\n         .map(|(i, (ref field, ref field_attr))| {\n             let name = field.node.ident().expect(\"struct has unnamed field\");\n \n-            let key_expr = field_attr.serialize_name_expr();\n+            let key_expr = field_attr.name().serialize_name_expr();\n \n             let stmt = if let Some(expr) = field_attr.skip_serializing_field_if() {\n                     Some(quote_stmt!(cx, if $expr { continue; }))\n", "test_patch": "diff --git a/serde_tests/benches/bench_enum.rs b/serde_tests/benches/bench_enum.rs\nindex ecd3114ba..220f0de36 100644\n--- a/serde_tests/benches/bench_enum.rs\n+++ b/serde_tests/benches/bench_enum.rs\n@@ -17,18 +17,18 @@ pub enum Animal {\n \n #[derive(Debug)]\n pub enum Error {\n-    EndOfStreamError,\n-    SyntaxError,\n+    EndOfStream,\n+    Syntax,\n }\n \n impl serde::de::Error for Error {\n-    fn syntax(_: &str) -> Error { Error::SyntaxError }\n+    fn custom(_: String) -> Error { Error::Syntax }\n \n-    fn end_of_stream() -> Error { Error::EndOfStreamError }\n+    fn end_of_stream() -> Error { Error::EndOfStream }\n \n-    fn unknown_field(_: &str) -> Error { Error::SyntaxError }\n+    fn unknown_field(_: &str) -> Error { Error::Syntax }\n \n-    fn missing_field(_: &'static str) -> Error { Error::SyntaxError }\n+    fn missing_field(_: &'static str) -> Error { Error::Syntax }\n }\n \n impl fmt::Display for Error {\n@@ -54,12 +54,11 @@ mod decoder {\n \n     use super::{Animal, Error};\n     use super::Animal::{Dog, Frog};\n-    use self::State::{AnimalState, IsizeState, StringState};\n \n     enum State {\n-        AnimalState(Animal),\n-        IsizeState(isize),\n-        StringState(String),\n+        Animal(Animal),\n+        Isize(isize),\n+        String(String),\n     }\n \n     pub struct AnimalDecoder {\n@@ -71,7 +70,7 @@ mod decoder {\n         #[inline]\n         pub fn new(animal: Animal) -> AnimalDecoder {\n             AnimalDecoder {\n-                stack: vec!(AnimalState(animal)),\n+                stack: vec!(State::Animal(animal)),\n             }\n         }\n     }\n@@ -79,35 +78,35 @@ mod decoder {\n     impl Decoder for AnimalDecoder {\n         type Error = Error;\n \n-        fn error(&mut self, _: &str) -> Error { Error::SyntaxError }\n+        fn error(&mut self, _: &str) -> Error { Error::Syntax }\n \n         // Primitive types:\n-        fn read_nil(&mut self) -> Result<(), Error> { Err(Error::SyntaxError) }\n-        fn read_usize(&mut self) -> Result<usize, Error> { Err(Error::SyntaxError) }\n-        fn read_u64(&mut self) -> Result<u64, Error> { Err(Error::SyntaxError) }\n-        fn read_u32(&mut self) -> Result<u32, Error> { Err(Error::SyntaxError) }\n-        fn read_u16(&mut self) -> Result<u16, Error> { Err(Error::SyntaxError) }\n-        fn read_u8(&mut self) -> Result<u8, Error> { Err(Error::SyntaxError) }\n+        fn read_nil(&mut self) -> Result<(), Error> { Err(Error::Syntax) }\n+        fn read_usize(&mut self) -> Result<usize, Error> { Err(Error::Syntax) }\n+        fn read_u64(&mut self) -> Result<u64, Error> { Err(Error::Syntax) }\n+        fn read_u32(&mut self) -> Result<u32, Error> { Err(Error::Syntax) }\n+        fn read_u16(&mut self) -> Result<u16, Error> { Err(Error::Syntax) }\n+        fn read_u8(&mut self) -> Result<u8, Error> { Err(Error::Syntax) }\n         #[inline]\n         fn read_isize(&mut self) -> Result<isize, Error> {\n             match self.stack.pop() {\n-                Some(IsizeState(x)) => Ok(x),\n-                _ => Err(Error::SyntaxError),\n+                Some(State::Isize(x)) => Ok(x),\n+                _ => Err(Error::Syntax),\n             }\n         }\n-        fn read_i64(&mut self) -> Result<i64, Error> { Err(Error::SyntaxError) }\n-        fn read_i32(&mut self) -> Result<i32, Error> { Err(Error::SyntaxError) }\n-        fn read_i16(&mut self) -> Result<i16, Error> { Err(Error::SyntaxError) }\n-        fn read_i8(&mut self) -> Result<i8, Error> { Err(Error::SyntaxError) }\n-        fn read_bool(&mut self) -> Result<bool, Error> { Err(Error::SyntaxError) }\n-        fn read_f64(&mut self) -> Result<f64, Error> { Err(Error::SyntaxError) }\n-        fn read_f32(&mut self) -> Result<f32, Error> { Err(Error::SyntaxError) }\n-        fn read_char(&mut self) -> Result<char, Error> { Err(Error::SyntaxError) }\n+        fn read_i64(&mut self) -> Result<i64, Error> { Err(Error::Syntax) }\n+        fn read_i32(&mut self) -> Result<i32, Error> { Err(Error::Syntax) }\n+        fn read_i16(&mut self) -> Result<i16, Error> { Err(Error::Syntax) }\n+        fn read_i8(&mut self) -> Result<i8, Error> { Err(Error::Syntax) }\n+        fn read_bool(&mut self) -> Result<bool, Error> { Err(Error::Syntax) }\n+        fn read_f64(&mut self) -> Result<f64, Error> { Err(Error::Syntax) }\n+        fn read_f32(&mut self) -> Result<f32, Error> { Err(Error::Syntax) }\n+        fn read_char(&mut self) -> Result<char, Error> { Err(Error::Syntax) }\n         #[inline]\n         fn read_str(&mut self) -> Result<String, Error> {\n             match self.stack.pop() {\n-                Some(StringState(x)) => Ok(x),\n-                _ => Err(Error::SyntaxError),\n+                Some(State::String(x)) => Ok(x),\n+                _ => Err(Error::Syntax),\n             }\n         }\n \n@@ -117,15 +116,15 @@ mod decoder {\n             F: FnOnce(&mut AnimalDecoder) -> Result<T, Error>,\n         {\n             match self.stack.pop() {\n-                Some(AnimalState(animal)) => {\n-                    self.stack.push(AnimalState(animal));\n+                Some(State::Animal(animal)) => {\n+                    self.stack.push(State::Animal(animal));\n                     if name == \"Animal\" {\n                         f(self)\n                     } else {\n-                        Err(Error::SyntaxError)\n+                        Err(Error::Syntax)\n                     }\n                 }\n-                _ => Err(Error::SyntaxError)\n+                _ => Err(Error::Syntax)\n             }\n         }\n \n@@ -134,18 +133,18 @@ mod decoder {\n             F: FnOnce(&mut AnimalDecoder, usize) -> Result<T, Error>,\n         {\n             let name = match self.stack.pop() {\n-                Some(AnimalState(Dog)) => \"Dog\",\n-                Some(AnimalState(Frog(x0, x1))) => {\n-                    self.stack.push(IsizeState(x1));\n-                    self.stack.push(StringState(x0));\n+                Some(State::Animal(Dog)) => \"Dog\",\n+                Some(State::Animal(Frog(x0, x1))) => {\n+                    self.stack.push(State::Isize(x1));\n+                    self.stack.push(State::String(x0));\n                     \"Frog\"\n                 }\n-                _ => { return Err(Error::SyntaxError); }\n+                _ => { return Err(Error::Syntax); }\n             };\n \n             let idx = match names.iter().position(|n| *n == name) {\n                 Some(idx) => idx,\n-                None => { return Err(Error::SyntaxError); }\n+                None => { return Err(Error::Syntax); }\n             };\n \n             f(self, idx)\n@@ -161,56 +160,56 @@ mod decoder {\n         fn read_enum_struct_variant<T, F>(&mut self, _names: &[&str], _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut AnimalDecoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_struct_variant_field<T, F>(&mut self, _f_name: &str, _f_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut AnimalDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut AnimalDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_struct_field<T, F>(&mut self, _f_name: &str, _f_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut AnimalDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple<T, F>(&mut self, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut AnimalDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut AnimalDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_struct<T, F>(&mut self, _s_name: &str, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut AnimalDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_struct_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut AnimalDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         // Specialized types:\n         fn read_option<T, F>(&mut self, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut AnimalDecoder, bool) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         #[inline]\n@@ -230,19 +229,19 @@ mod decoder {\n         fn read_map<T, F>(&mut self, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut AnimalDecoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_map_elt_key<T, F>(&mut self, _idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut AnimalDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_map_elt_val<T, F>(&mut self, _idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut AnimalDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n     }\n }\n@@ -256,10 +255,10 @@ mod deserializer {\n \n     #[derive(Debug)]\n     enum State {\n-        AnimalState(Animal),\n-        IsizeState(isize),\n-        StrState(&'static str),\n-        StringState(String),\n+        Animal(Animal),\n+        Isize(isize),\n+        Str(&'static str),\n+        String(String),\n         UnitState,\n     }\n \n@@ -271,7 +270,7 @@ mod deserializer {\n         #[inline]\n         pub fn new(animal: Animal) -> AnimalDeserializer {\n             AnimalDeserializer {\n-                stack: vec!(State::AnimalState(animal)),\n+                stack: vec!(State::Animal(animal)),\n             }\n         }\n     }\n@@ -284,23 +283,23 @@ mod deserializer {\n             where V: de::Visitor,\n         {\n             match self.stack.pop() {\n-                Some(State::IsizeState(value)) => {\n+                Some(State::Isize(value)) => {\n                     visitor.visit_isize(value)\n                 }\n-                Some(State::StringState(value)) => {\n+                Some(State::String(value)) => {\n                     visitor.visit_string(value)\n                 }\n-                Some(State::StrState(value)) => {\n+                Some(State::Str(value)) => {\n                     visitor.visit_str(value)\n                 }\n                 Some(State::UnitState) => {\n                     visitor.visit_unit()\n                 }\n                 Some(_) => {\n-                    Err(Error::SyntaxError)\n+                    Err(Error::Syntax)\n                 }\n                 None => {\n-                    Err(Error::EndOfStreamError)\n+                    Err(Error::EndOfStream)\n                 }\n             }\n         }\n@@ -313,27 +312,27 @@ mod deserializer {\n             where V: de::EnumVisitor,\n         {\n             match self.stack.pop() {\n-                Some(State::AnimalState(Animal::Dog)) => {\n+                Some(State::Animal(Animal::Dog)) => {\n                     self.stack.push(State::UnitState);\n-                    self.stack.push(State::StrState(\"Dog\"));\n+                    self.stack.push(State::Str(\"Dog\"));\n                     visitor.visit(DogVisitor {\n                         de: self,\n                     })\n                 }\n-                Some(State::AnimalState(Animal::Frog(x0, x1))) => {\n-                    self.stack.push(State::IsizeState(x1));\n-                    self.stack.push(State::StringState(x0));\n-                    self.stack.push(State::StrState(\"Frog\"));\n+                Some(State::Animal(Animal::Frog(x0, x1))) => {\n+                    self.stack.push(State::Isize(x1));\n+                    self.stack.push(State::String(x0));\n+                    self.stack.push(State::Str(\"Frog\"));\n                     visitor.visit(FrogVisitor {\n                         de: self,\n                         state: 0,\n                     })\n                 }\n                 Some(_) => {\n-                    Err(Error::SyntaxError)\n+                    Err(Error::Syntax)\n                 }\n                 None => {\n-                    Err(Error::EndOfStreamError)\n+                    Err(Error::EndOfStream)\n                 }\n             }\n         }\n@@ -405,7 +404,7 @@ mod deserializer {\n             if self.state == 2 {\n                 Ok(())\n             } else {\n-                Err(Error::SyntaxError)\n+                Err(Error::Syntax)\n             }\n         }\n \ndiff --git a/serde_tests/benches/bench_map.rs b/serde_tests/benches/bench_map.rs\nindex ce25f3f1a..beab38f8d 100644\n--- a/serde_tests/benches/bench_map.rs\n+++ b/serde_tests/benches/bench_map.rs\n@@ -14,16 +14,16 @@ use serde::de::{Deserializer, Deserialize};\n #[derive(PartialEq, Debug)]\n pub enum Error {\n     EndOfStream,\n-    SyntaxError,\n+    Syntax,\n     MissingField,\n }\n \n impl serde::de::Error for Error {\n-    fn syntax(_: &str) -> Error { Error::SyntaxError }\n+    fn custom(_: String) -> Error { Error::Syntax }\n \n     fn end_of_stream() -> Error { Error::EndOfStream }\n \n-    fn unknown_field(_: &str) -> Error { Error::SyntaxError }\n+    fn unknown_field(_: &str) -> Error { Error::Syntax }\n \n     fn missing_field(_: &'static str) -> Error {\n         Error::MissingField\n@@ -53,11 +53,10 @@ mod decoder {\n     use rustc_serialize;\n \n     use super::Error;\n-    use self::Value::{StringValue, IsizeValue};\n \n     enum Value {\n-        StringValue(String),\n-        IsizeValue(isize),\n+        String(String),\n+        Isize(isize),\n     }\n \n     pub struct IsizeDecoder {\n@@ -81,37 +80,37 @@ mod decoder {\n         type Error = Error;\n \n         fn error(&mut self, _msg: &str) -> Error {\n-            Error::SyntaxError\n+            Error::Syntax\n         }\n \n         // Primitive types:\n-        fn read_nil(&mut self) -> Result<(), Error> { Err(Error::SyntaxError) }\n-        fn read_usize(&mut self) -> Result<usize, Error> { Err(Error::SyntaxError) }\n-        fn read_u64(&mut self) -> Result<u64, Error> { Err(Error::SyntaxError) }\n-        fn read_u32(&mut self) -> Result<u32, Error> { Err(Error::SyntaxError) }\n-        fn read_u16(&mut self) -> Result<u16, Error> { Err(Error::SyntaxError) }\n-        fn read_u8(&mut self) -> Result<u8, Error> { Err(Error::SyntaxError) }\n+        fn read_nil(&mut self) -> Result<(), Error> { Err(Error::Syntax) }\n+        fn read_usize(&mut self) -> Result<usize, Error> { Err(Error::Syntax) }\n+        fn read_u64(&mut self) -> Result<u64, Error> { Err(Error::Syntax) }\n+        fn read_u32(&mut self) -> Result<u32, Error> { Err(Error::Syntax) }\n+        fn read_u16(&mut self) -> Result<u16, Error> { Err(Error::Syntax) }\n+        fn read_u8(&mut self) -> Result<u8, Error> { Err(Error::Syntax) }\n         #[inline]\n         fn read_isize(&mut self) -> Result<isize, Error> {\n             match self.stack.pop() {\n-                Some(IsizeValue(x)) => Ok(x),\n-                Some(_) => Err(Error::SyntaxError),\n+                Some(Value::Isize(x)) => Ok(x),\n+                Some(_) => Err(Error::Syntax),\n                 None => Err(Error::EndOfStream),\n             }\n         }\n-        fn read_i64(&mut self) -> Result<i64, Error> { Err(Error::SyntaxError) }\n-        fn read_i32(&mut self) -> Result<i32, Error> { Err(Error::SyntaxError) }\n-        fn read_i16(&mut self) -> Result<i16, Error> { Err(Error::SyntaxError) }\n-        fn read_i8(&mut self) -> Result<i8, Error> { Err(Error::SyntaxError) }\n-        fn read_bool(&mut self) -> Result<bool, Error> { Err(Error::SyntaxError) }\n-        fn read_f64(&mut self) -> Result<f64, Error> { Err(Error::SyntaxError) }\n-        fn read_f32(&mut self) -> Result<f32, Error> { Err(Error::SyntaxError) }\n-        fn read_char(&mut self) -> Result<char, Error> { Err(Error::SyntaxError) }\n+        fn read_i64(&mut self) -> Result<i64, Error> { Err(Error::Syntax) }\n+        fn read_i32(&mut self) -> Result<i32, Error> { Err(Error::Syntax) }\n+        fn read_i16(&mut self) -> Result<i16, Error> { Err(Error::Syntax) }\n+        fn read_i8(&mut self) -> Result<i8, Error> { Err(Error::Syntax) }\n+        fn read_bool(&mut self) -> Result<bool, Error> { Err(Error::Syntax) }\n+        fn read_f64(&mut self) -> Result<f64, Error> { Err(Error::Syntax) }\n+        fn read_f32(&mut self) -> Result<f32, Error> { Err(Error::Syntax) }\n+        fn read_char(&mut self) -> Result<char, Error> { Err(Error::Syntax) }\n         #[inline]\n         fn read_str(&mut self) -> Result<String, Error> {\n             match self.stack.pop() {\n-                Some(StringValue(x)) => Ok(x),\n-                Some(_) => Err(Error::SyntaxError),\n+                Some(Value::String(x)) => Ok(x),\n+                Some(_) => Err(Error::Syntax),\n                 None => Err(Error::EndOfStream),\n             }\n         }\n@@ -120,86 +119,86 @@ mod decoder {\n         fn read_enum<T, F>(&mut self, _name: &str, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_variant<T, F>(&mut self, _names: &[&str], _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_struct_variant<T, F>(&mut self, _names: &[&str], _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_struct_variant_field<T, F>(&mut self, _f_name: &str, _f_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_struct_field<T, F>(&mut self, _f_name: &str, _f_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple<T, F>(&mut self, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_struct<T, F>(&mut self, _s_name: &str, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_struct_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         // Specialized types:\n         fn read_option<T, F>(&mut self, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder, bool) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_seq<T, F>(&mut self, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_seq_elt<T, F>(&mut self, _idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut IsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         #[inline]\n@@ -215,12 +214,12 @@ mod decoder {\n         {\n             match self.iter.next() {\n                 Some((key, value)) => {\n-                    self.stack.push(IsizeValue(value));\n-                    self.stack.push(StringValue(key));\n+                    self.stack.push(Value::Isize(value));\n+                    self.stack.push(Value::String(key));\n                     f(self)\n                 }\n                 None => {\n-                    Err(Error::SyntaxError)\n+                    Err(Error::Syntax)\n                 }\n             }\n         }\n@@ -247,8 +246,8 @@ mod deserializer {\n     #[derive(PartialEq, Debug)]\n     enum State {\n         StartState,\n-        KeyState(String),\n-        ValueState(isize),\n+        Key(String),\n+        Value(isize),\n     }\n \n     pub struct IsizeDeserializer {\n@@ -276,10 +275,10 @@ mod deserializer {\n                 Some(State::StartState) => {\n                     visitor.visit_map(self)\n                 }\n-                Some(State::KeyState(key)) => {\n+                Some(State::Key(key)) => {\n                     visitor.visit_string(key)\n                 }\n-                Some(State::ValueState(value)) => {\n+                Some(State::Value(value)) => {\n                     visitor.visit_isize(value)\n                 }\n                 None => {\n@@ -297,8 +296,8 @@ mod deserializer {\n         {\n             match self.iter.next() {\n                 Some((key, value)) => {\n-                    self.stack.push(State::ValueState(value));\n-                    self.stack.push(State::KeyState(key));\n+                    self.stack.push(State::Value(value));\n+                    self.stack.push(State::Key(key));\n                     Ok(Some(try!(de::Deserialize::deserialize(self))))\n                 }\n                 None => {\n@@ -315,7 +314,7 @@ mod deserializer {\n \n         fn end(&mut self) -> Result<(), Error> {\n             match self.iter.next() {\n-                Some(_) => Err(Error::SyntaxError),\n+                Some(_) => Err(Error::Syntax),\n                 None => Ok(()),\n             }\n         }\n@@ -332,14 +331,14 @@ mod deserializer {\n         #[inline]\n         fn next(&mut self) -> Option<Result<de::Token, Error>> {\n             match self.stack.pop() {\n-                Some(StartState) => {\n+                Some(State::StartState) => {\n                     self.stack.push(KeyOrEndState);\n                     Some(Ok(de::Token::MapStart(self.len)))\n                 }\n-                Some(KeyOrEndState) => {\n+                Some(State::KeyOrEndState) => {\n                     match self.iter.next() {\n                         Some((key, value)) => {\n-                            self.stack.push(ValueState(value));\n+                            self.stack.push(Value(value));\n                             Some(Ok(de::Token::String(key)))\n                         }\n                         None => {\n@@ -348,7 +347,7 @@ mod deserializer {\n                         }\n                     }\n                 }\n-                Some(ValueState(x)) => {\n+                Some(State::Value(x)) => {\n                     self.stack.push(KeyOrEndState);\n                     Some(Ok(de::Token::Isize(x)))\n                 }\n@@ -370,24 +369,24 @@ mod deserializer {\n \n         #[inline]\n         fn syntax(&mut self, _token: de::Token, _expected: &[de::TokenKind]) -> Error {\n-            SyntaxError\n+            Syntax\n         }\n \n         #[inline]\n         fn unexpected_name(&mut self, _token: de::Token) -> Error {\n-            SyntaxError\n+            Syntax\n         }\n \n         #[inline]\n         fn conversion_error(&mut self, _token: de::Token) -> Error {\n-            SyntaxError\n+            Syntax\n         }\n \n         #[inline]\n         fn missing_field<\n             T: de::Deserialize<IsizeDeserializer, Error>\n         >(&mut self, _field: &'static str) -> Result<T, Error> {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n     }\n */\ndiff --git a/serde_tests/benches/bench_struct.rs b/serde_tests/benches/bench_struct.rs\nindex 03ae4310e..7ad311f7d 100644\n--- a/serde_tests/benches/bench_struct.rs\n+++ b/serde_tests/benches/bench_struct.rs\n@@ -29,17 +29,17 @@ pub struct Outer {\n #[derive(Debug, PartialEq)]\n pub enum Error {\n     EndOfStream,\n-    SyntaxError,\n+    Syntax,\n     MissingField,\n     OtherError,\n }\n \n impl serde::de::Error for Error {\n-    fn syntax(_: &str) -> Error { Error::SyntaxError }\n+    fn custom(_: String) -> Error { Error::Syntax }\n \n     fn end_of_stream() -> Error { Error::EndOfStream }\n \n-    fn unknown_field(_: &str) -> Error { Error::SyntaxError }\n+    fn unknown_field(_: &str) -> Error { Error::Syntax }\n \n     fn missing_field(_: &'static str) -> Error {\n         Error::MissingField\n@@ -68,31 +68,18 @@ mod decoder {\n \n     use super::{Outer, Inner, Error};\n \n-    use self::State::{\n-        OuterState,\n-        InnerState,\n-        NullState,\n-        UsizeState,\n-        CharState,\n-        StringState,\n-        FieldState,\n-        VecState,\n-        MapState,\n-        OptionState,\n-    };\n-\n     #[derive(Debug)]\n     enum State {\n-        OuterState(Outer),\n-        InnerState(Inner),\n-        NullState,\n-        UsizeState(usize),\n-        CharState(char),\n-        StringState(String),\n-        FieldState(&'static str),\n-        VecState(Vec<Inner>),\n-        MapState(HashMap<String, Option<char>>),\n-        OptionState(bool),\n+        Outer(Outer),\n+        Inner(Inner),\n+        Null,\n+        Usize(usize),\n+        Char(char),\n+        String(String),\n+        Field(&'static str),\n+        Vec(Vec<Inner>),\n+        Map(HashMap<String, Option<char>>),\n+        Option(bool),\n     }\n \n     pub struct OuterDecoder {\n@@ -104,7 +91,7 @@ mod decoder {\n         #[inline]\n         pub fn new(animal: Outer) -> OuterDecoder {\n             OuterDecoder {\n-                stack: vec!(OuterState(animal)),\n+                stack: vec!(State::Outer(animal)),\n             }\n         }\n     }\n@@ -120,41 +107,41 @@ mod decoder {\n         #[inline]\n         fn read_nil(&mut self) -> Result<(), Error> {\n             match self.stack.pop() {\n-                Some(NullState) => Ok(()),\n-                _ => Err(Error::SyntaxError),\n+                Some(State::Null) => Ok(()),\n+                _ => Err(Error::Syntax),\n             }\n         }\n         #[inline]\n         fn read_usize(&mut self) -> Result<usize, Error> {\n             match self.stack.pop() {\n-                Some(UsizeState(value)) => Ok(value),\n-                _ => Err(Error::SyntaxError),\n+                Some(State::Usize(value)) => Ok(value),\n+                _ => Err(Error::Syntax),\n             }\n         }\n-        fn read_u64(&mut self) -> Result<u64, Error> { Err(Error::SyntaxError) }\n-        fn read_u32(&mut self) -> Result<u32, Error> { Err(Error::SyntaxError) }\n-        fn read_u16(&mut self) -> Result<u16, Error> { Err(Error::SyntaxError) }\n-        fn read_u8(&mut self) -> Result<u8, Error> { Err(Error::SyntaxError) }\n-        fn read_isize(&mut self) -> Result<isize, Error> { Err(Error::SyntaxError) }\n-        fn read_i64(&mut self) -> Result<i64, Error> { Err(Error::SyntaxError) }\n-        fn read_i32(&mut self) -> Result<i32, Error> { Err(Error::SyntaxError) }\n-        fn read_i16(&mut self) -> Result<i16, Error> { Err(Error::SyntaxError) }\n-        fn read_i8(&mut self) -> Result<i8, Error> { Err(Error::SyntaxError) }\n-        fn read_bool(&mut self) -> Result<bool, Error> { Err(Error::SyntaxError) }\n-        fn read_f64(&mut self) -> Result<f64, Error> { Err(Error::SyntaxError) }\n-        fn read_f32(&mut self) -> Result<f32, Error> { Err(Error::SyntaxError) }\n+        fn read_u64(&mut self) -> Result<u64, Error> { Err(Error::Syntax) }\n+        fn read_u32(&mut self) -> Result<u32, Error> { Err(Error::Syntax) }\n+        fn read_u16(&mut self) -> Result<u16, Error> { Err(Error::Syntax) }\n+        fn read_u8(&mut self) -> Result<u8, Error> { Err(Error::Syntax) }\n+        fn read_isize(&mut self) -> Result<isize, Error> { Err(Error::Syntax) }\n+        fn read_i64(&mut self) -> Result<i64, Error> { Err(Error::Syntax) }\n+        fn read_i32(&mut self) -> Result<i32, Error> { Err(Error::Syntax) }\n+        fn read_i16(&mut self) -> Result<i16, Error> { Err(Error::Syntax) }\n+        fn read_i8(&mut self) -> Result<i8, Error> { Err(Error::Syntax) }\n+        fn read_bool(&mut self) -> Result<bool, Error> { Err(Error::Syntax) }\n+        fn read_f64(&mut self) -> Result<f64, Error> { Err(Error::Syntax) }\n+        fn read_f32(&mut self) -> Result<f32, Error> { Err(Error::Syntax) }\n         #[inline]\n         fn read_char(&mut self) -> Result<char, Error> {\n             match self.stack.pop() {\n-                Some(CharState(c)) => Ok(c),\n-                _ => Err(Error::SyntaxError),\n+                Some(State::Char(c)) => Ok(c),\n+                _ => Err(Error::Syntax),\n             }\n         }\n         #[inline]\n         fn read_str(&mut self) -> Result<String, Error> {\n             match self.stack.pop() {\n-                Some(StringState(value)) => Ok(value),\n-                _ => Err(Error::SyntaxError),\n+                Some(State::String(value)) => Ok(value),\n+                _ => Err(Error::Syntax),\n             }\n         }\n \n@@ -162,31 +149,31 @@ mod decoder {\n         fn read_enum<T, F>(&mut self, _name: &str, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut OuterDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_variant<T, F>(&mut self, _names: &[&str], _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut OuterDecoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut OuterDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_struct_variant<T, F>(&mut self, _names: &[&str], _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut OuterDecoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_struct_variant_field<T, F>(&mut self, _f_name: &str, _f_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut OuterDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         #[inline]\n@@ -194,31 +181,31 @@ mod decoder {\n             F: FnOnce(&mut OuterDecoder) -> Result<T, Error>,\n         {\n             match self.stack.pop() {\n-                Some(OuterState(Outer { inner })) => {\n+                Some(State::Outer(Outer { inner })) => {\n                     if s_name == \"Outer\" {\n-                        self.stack.push(VecState(inner));\n-                        self.stack.push(FieldState(\"inner\"));\n+                        self.stack.push(State::Vec(inner));\n+                        self.stack.push(State::Field(\"inner\"));\n                         f(self)\n                     } else {\n-                        Err(Error::SyntaxError)\n+                        Err(Error::Syntax)\n                     }\n                 }\n-                Some(InnerState(Inner { a: (), b, c })) => {\n+                Some(State::Inner(Inner { a: (), b, c })) => {\n                     if s_name == \"Inner\" {\n-                        self.stack.push(MapState(c));\n-                        self.stack.push(FieldState(\"c\"));\n+                        self.stack.push(State::Map(c));\n+                        self.stack.push(State::Field(\"c\"));\n \n-                        self.stack.push(UsizeState(b));\n-                        self.stack.push(FieldState(\"b\"));\n+                        self.stack.push(State::Usize(b));\n+                        self.stack.push(State::Field(\"b\"));\n \n-                        self.stack.push(NullState);\n-                        self.stack.push(FieldState(\"a\"));\n+                        self.stack.push(State::Null);\n+                        self.stack.push(State::Field(\"a\"));\n                         f(self)\n                     } else {\n-                        Err(Error::SyntaxError)\n+                        Err(Error::Syntax)\n                     }\n                 }\n-                _ => Err(Error::SyntaxError),\n+                _ => Err(Error::Syntax),\n             }\n         }\n         #[inline]\n@@ -226,39 +213,39 @@ mod decoder {\n             F: FnOnce(&mut OuterDecoder) -> Result<T, Error>,\n         {\n             match self.stack.pop() {\n-                Some(FieldState(name)) => {\n+                Some(State::Field(name)) => {\n                     if f_name == name {\n                         f(self)\n                     } else {\n-                        Err(Error::SyntaxError)\n+                        Err(Error::Syntax)\n                     }\n                 }\n-                _ => Err(Error::SyntaxError)\n+                _ => Err(Error::Syntax)\n             }\n         }\n \n         fn read_tuple<T, F>(&mut self, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut OuterDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut OuterDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_struct<T, F>(&mut self, _s_name: &str, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut OuterDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_struct_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut OuterDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         // Specialized types:\n@@ -267,8 +254,8 @@ mod decoder {\n             F: FnOnce(&mut OuterDecoder, bool) -> Result<T, Error>,\n         {\n             match self.stack.pop() {\n-                Some(OptionState(b)) => f(self, b),\n-                _ => Err(Error::SyntaxError),\n+                Some(State::Option(b)) => f(self, b),\n+                _ => Err(Error::Syntax),\n             }\n         }\n \n@@ -277,14 +264,14 @@ mod decoder {\n             F: FnOnce(&mut OuterDecoder, usize) -> Result<T, Error>,\n         {\n             match self.stack.pop() {\n-                Some(VecState(value)) => {\n+                Some(State::Vec(value)) => {\n                     let len = value.len();\n                     for inner in value.into_iter().rev() {\n-                        self.stack.push(InnerState(inner));\n+                        self.stack.push(State::Inner(inner));\n                     }\n                     f(self, len)\n                 }\n-                _ => Err(Error::SyntaxError)\n+                _ => Err(Error::Syntax)\n             }\n         }\n         #[inline]\n@@ -299,23 +286,23 @@ mod decoder {\n             F: FnOnce(&mut OuterDecoder, usize) -> Result<T, Error>,\n         {\n             match self.stack.pop() {\n-                Some(MapState(map)) => {\n+                Some(State::Map(map)) => {\n                     let len = map.len();\n                     for (key, value) in map {\n                         match value {\n                             Some(c) => {\n-                                self.stack.push(CharState(c));\n-                                self.stack.push(OptionState(true));\n+                                self.stack.push(State::Char(c));\n+                                self.stack.push(State::Option(true));\n                             }\n                             None => {\n-                                self.stack.push(OptionState(false));\n+                                self.stack.push(State::Option(false));\n                             }\n                         }\n-                        self.stack.push(StringState(key));\n+                        self.stack.push(State::String(key));\n                     }\n                     f(self, len)\n                 }\n-                _ => Err(Error::SyntaxError),\n+                _ => Err(Error::Syntax),\n             }\n         }\n         #[inline]\n@@ -346,16 +333,16 @@ mod deserializer {\n \n     #[derive(Debug)]\n     enum State {\n-        OuterState(Outer),\n-        InnerState(Inner),\n-        StrState(&'static str),\n-        NullState,\n-        UsizeState(usize),\n-        CharState(char),\n-        StringState(String),\n-        OptionState(bool),\n-        VecState(Vec<Inner>),\n-        MapState(HashMap<String, Option<char>>),\n+        Outer(Outer),\n+        Inner(Inner),\n+        Str(&'static str),\n+        Null,\n+        Usize(usize),\n+        Char(char),\n+        String(String),\n+        Option(bool),\n+        Vec(Vec<Inner>),\n+        Map(HashMap<String, Option<char>>),\n     }\n \n     pub struct OuterDeserializer {\n@@ -366,7 +353,7 @@ mod deserializer {\n         #[inline]\n         pub fn new(outer: Outer) -> OuterDeserializer {\n             OuterDeserializer {\n-                stack: vec!(State::OuterState(outer)),\n+                stack: vec!(State::Outer(outer)),\n             }\n         }\n     }\n@@ -378,40 +365,40 @@ mod deserializer {\n             where V: de::Visitor,\n         {\n             match self.stack.pop() {\n-                Some(State::VecState(value)) => {\n+                Some(State::Vec(value)) => {\n                     visitor.visit_seq(OuterSeqVisitor {\n                         de: self,\n                         iter: value.into_iter(),\n                     })\n                 }\n-                Some(State::MapState(value)) => {\n+                Some(State::Map(value)) => {\n                     visitor.visit_map(MapVisitor {\n                         de: self,\n                         iter: value.into_iter(),\n                     })\n                 }\n-                Some(State::NullState) => {\n+                Some(State::Null) => {\n                     visitor.visit_unit()\n                 }\n-                Some(State::UsizeState(x)) => {\n+                Some(State::Usize(x)) => {\n                     visitor.visit_usize(x)\n                 }\n-                Some(State::CharState(x)) => {\n+                Some(State::Char(x)) => {\n                     visitor.visit_char(x)\n                 }\n-                Some(State::StrState(x)) => {\n+                Some(State::Str(x)) => {\n                     visitor.visit_str(x)\n                 }\n-                Some(State::StringState(x)) => {\n+                Some(State::String(x)) => {\n                     visitor.visit_string(x)\n                 }\n-                Some(State::OptionState(false)) => {\n+                Some(State::Option(false)) => {\n                     visitor.visit_none()\n                 }\n-                Some(State::OptionState(true)) => {\n+                Some(State::Option(true)) => {\n                     visitor.visit_some(self)\n                 }\n-                Some(_) => Err(Error::SyntaxError),\n+                Some(_) => Err(Error::Syntax),\n                 None => Err(Error::EndOfStream),\n             }\n         }\n@@ -423,32 +410,32 @@ mod deserializer {\n             where V: de::Visitor,\n         {\n             match self.stack.pop() {\n-                Some(State::OuterState(Outer { inner })) => {\n+                Some(State::Outer(Outer { inner })) => {\n                     if name != \"Outer\" {\n-                        return Err(Error::SyntaxError);\n+                        return Err(Error::Syntax);\n                     }\n \n-                    self.stack.push(State::VecState(inner));\n-                    self.stack.push(State::StrState(\"inner\"));\n+                    self.stack.push(State::Vec(inner));\n+                    self.stack.push(State::Str(\"inner\"));\n \n                     visitor.visit_map(OuterMapVisitor {\n                         de: self,\n                         state: 0,\n                     })\n                 }\n-                Some(State::InnerState(Inner { a: (), b, c })) => {\n+                Some(State::Inner(Inner { a: (), b, c })) => {\n                     if name != \"Inner\" {\n-                        return Err(Error::SyntaxError);\n+                        return Err(Error::Syntax);\n                     }\n \n-                    self.stack.push(State::MapState(c));\n-                    self.stack.push(State::StrState(\"c\"));\n+                    self.stack.push(State::Map(c));\n+                    self.stack.push(State::Str(\"c\"));\n \n-                    self.stack.push(State::UsizeState(b));\n-                    self.stack.push(State::StrState(\"b\"));\n+                    self.stack.push(State::Usize(b));\n+                    self.stack.push(State::Str(\"b\"));\n \n-                    self.stack.push(State::NullState);\n-                    self.stack.push(State::StrState(\"a\"));\n+                    self.stack.push(State::Null);\n+                    self.stack.push(State::Str(\"a\"));\n \n                     visitor.visit_map(InnerMapVisitor {\n                         de: self,\n@@ -456,7 +443,7 @@ mod deserializer {\n                     })\n                 }\n                 _ => {\n-                    Err(Error::SyntaxError)\n+                    Err(Error::Syntax)\n                 }\n             }\n         }\n@@ -494,7 +481,7 @@ mod deserializer {\n             if self.state == 1 {\n                 Ok(())\n             } else {\n-                Err(Error::SyntaxError)\n+                Err(Error::Syntax)\n             }\n         }\n \n@@ -517,7 +504,7 @@ mod deserializer {\n         {\n             match self.iter.next() {\n                 Some(value) => {\n-                    self.de.stack.push(State::InnerState(value));\n+                    self.de.stack.push(State::Inner(value));\n                     Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n                 }\n                 None => {\n@@ -528,7 +515,7 @@ mod deserializer {\n \n         fn end(&mut self) -> Result<(), Error> {\n             match self.iter.next() {\n-                Some(_) => Err(Error::SyntaxError),\n+                Some(_) => Err(Error::Syntax),\n                 None => Ok(()),\n             }\n         }\n@@ -570,7 +557,7 @@ mod deserializer {\n             if self.state == 3 {\n                 Ok(())\n             } else {\n-                Err(Error::SyntaxError)\n+                Err(Error::Syntax)\n             }\n         }\n \n@@ -593,14 +580,14 @@ mod deserializer {\n         {\n             match self.iter.next() {\n                 Some((key, Some(value))) => {\n-                    self.de.stack.push(State::CharState(value));\n-                    self.de.stack.push(State::OptionState(true));\n-                    self.de.stack.push(State::StringState(key));\n+                    self.de.stack.push(State::Char(value));\n+                    self.de.stack.push(State::Option(true));\n+                    self.de.stack.push(State::String(key));\n                     Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n                 }\n                 Some((key, None)) => {\n-                    self.de.stack.push(State::OptionState(false));\n-                    self.de.stack.push(State::StringState(key));\n+                    self.de.stack.push(State::Option(false));\n+                    self.de.stack.push(State::String(key));\n                     Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n                 }\n                 None => {\n@@ -617,7 +604,7 @@ mod deserializer {\n \n         fn end(&mut self) -> Result<(), Error> {\n             match self.iter.next() {\n-                Some(_) => Err(Error::SyntaxError),\n+                Some(_) => Err(Error::Syntax),\n                 None => Ok(()),\n             }\n         }\ndiff --git a/serde_tests/benches/bench_vec.rs b/serde_tests/benches/bench_vec.rs\nindex 3ce1cc320..01edcf09e 100644\n--- a/serde_tests/benches/bench_vec.rs\n+++ b/serde_tests/benches/bench_vec.rs\n@@ -12,18 +12,18 @@ use serde::de::{Deserializer, Deserialize};\n \n #[derive(PartialEq, Debug)]\n pub enum Error {\n-    EndOfStreamError,\n-    SyntaxError,\n+    EndOfStream,\n+    Syntax,\n }\n \n impl serde::de::Error for Error {\n-    fn syntax(_: &str) -> Error { Error::SyntaxError }\n+    fn custom(_: String) -> Error { Error::Syntax }\n \n-    fn end_of_stream() -> Error { Error::EndOfStreamError }\n+    fn end_of_stream() -> Error { Error::EndOfStream }\n \n-    fn unknown_field(_: &str) -> Error { Error::SyntaxError }\n+    fn unknown_field(_: &str) -> Error { Error::Syntax }\n \n-    fn missing_field(_: &'static str) -> Error { Error::SyntaxError }\n+    fn missing_field(_: &'static str) -> Error { Error::Syntax }\n }\n \n impl fmt::Display for Error {\n@@ -67,104 +67,104 @@ mod decoder {\n     impl rustc_serialize::Decoder for UsizeDecoder {\n         type Error = Error;\n \n-        fn error(&mut self, _: &str) -> Error { Error::SyntaxError }\n+        fn error(&mut self, _: &str) -> Error { Error::Syntax }\n \n         // Primitive types:\n-        fn read_nil(&mut self) -> Result<(), Error> { Err(Error::SyntaxError) }\n+        fn read_nil(&mut self) -> Result<(), Error> { Err(Error::Syntax) }\n         #[inline]\n         fn read_usize(&mut self) -> Result<usize, Error> {\n             match self.iter.next() {\n                 Some(value) => Ok(value),\n-                None => Err(Error::EndOfStreamError),\n+                None => Err(Error::EndOfStream),\n             }\n         }\n-        fn read_u64(&mut self) -> Result<u64, Error> { Err(Error::SyntaxError) }\n-        fn read_u32(&mut self) -> Result<u32, Error> { Err(Error::SyntaxError) }\n-        fn read_u16(&mut self) -> Result<u16, Error> { Err(Error::SyntaxError) }\n-        fn read_u8(&mut self) -> Result<u8, Error> { Err(Error::SyntaxError) }\n-        fn read_isize(&mut self) -> Result<isize, Error> { Err(Error::SyntaxError) }\n-        fn read_i64(&mut self) -> Result<i64, Error> { Err(Error::SyntaxError) }\n-        fn read_i32(&mut self) -> Result<i32, Error> { Err(Error::SyntaxError) }\n-        fn read_i16(&mut self) -> Result<i16, Error> { Err(Error::SyntaxError) }\n-        fn read_i8(&mut self) -> Result<i8, Error> { Err(Error::SyntaxError) }\n-        fn read_bool(&mut self) -> Result<bool, Error> { Err(Error::SyntaxError) }\n-        fn read_f64(&mut self) -> Result<f64, Error> { Err(Error::SyntaxError) }\n-        fn read_f32(&mut self) -> Result<f32, Error> { Err(Error::SyntaxError) }\n-        fn read_char(&mut self) -> Result<char, Error> { Err(Error::SyntaxError) }\n-        fn read_str(&mut self) -> Result<String, Error> { Err(Error::SyntaxError) }\n+        fn read_u64(&mut self) -> Result<u64, Error> { Err(Error::Syntax) }\n+        fn read_u32(&mut self) -> Result<u32, Error> { Err(Error::Syntax) }\n+        fn read_u16(&mut self) -> Result<u16, Error> { Err(Error::Syntax) }\n+        fn read_u8(&mut self) -> Result<u8, Error> { Err(Error::Syntax) }\n+        fn read_isize(&mut self) -> Result<isize, Error> { Err(Error::Syntax) }\n+        fn read_i64(&mut self) -> Result<i64, Error> { Err(Error::Syntax) }\n+        fn read_i32(&mut self) -> Result<i32, Error> { Err(Error::Syntax) }\n+        fn read_i16(&mut self) -> Result<i16, Error> { Err(Error::Syntax) }\n+        fn read_i8(&mut self) -> Result<i8, Error> { Err(Error::Syntax) }\n+        fn read_bool(&mut self) -> Result<bool, Error> { Err(Error::Syntax) }\n+        fn read_f64(&mut self) -> Result<f64, Error> { Err(Error::Syntax) }\n+        fn read_f32(&mut self) -> Result<f32, Error> { Err(Error::Syntax) }\n+        fn read_char(&mut self) -> Result<char, Error> { Err(Error::Syntax) }\n+        fn read_str(&mut self) -> Result<String, Error> { Err(Error::Syntax) }\n \n         // Compound types:\n         fn read_enum<T, F>(&mut self, _name: &str, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_variant<T, F>(&mut self, _names: &[&str], _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_struct_variant<T, F>(&mut self, _names: &[&str], _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_struct_variant_field<T, F>(&mut self, _f_name: &str, _f_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_struct_field<T, F>(&mut self, _f_name: &str, _f_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple<T, F>(&mut self, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_struct<T, F>(&mut self, _s_name: &str, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_struct_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         // Specialized types:\n         fn read_option<T, F>(&mut self, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder, bool) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         #[inline]\n@@ -184,19 +184,19 @@ mod decoder {\n         fn read_map<T, F>(&mut self, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_map_elt_key<T, F>(&mut self, _idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_map_elt_val<T, F>(&mut self, _idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut UsizeDecoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n     }\n \n@@ -219,105 +219,105 @@ mod decoder {\n     impl rustc_serialize::Decoder for U8Decoder {\n         type Error = Error;\n \n-        fn error(&mut self, _: &str) -> Error { Error::SyntaxError }\n+        fn error(&mut self, _: &str) -> Error { Error::Syntax }\n \n         // Primitive types:\n-        fn read_nil(&mut self) -> Result<(), Error> { Err(Error::SyntaxError) }\n-        fn read_usize(&mut self) -> Result<usize, Error> { Err(Error::SyntaxError) }\n-        fn read_u64(&mut self) -> Result<u64, Error> { Err(Error::SyntaxError) }\n-        fn read_u32(&mut self) -> Result<u32, Error> { Err(Error::SyntaxError) }\n-        fn read_u16(&mut self) -> Result<u16, Error> { Err(Error::SyntaxError) }\n+        fn read_nil(&mut self) -> Result<(), Error> { Err(Error::Syntax) }\n+        fn read_usize(&mut self) -> Result<usize, Error> { Err(Error::Syntax) }\n+        fn read_u64(&mut self) -> Result<u64, Error> { Err(Error::Syntax) }\n+        fn read_u32(&mut self) -> Result<u32, Error> { Err(Error::Syntax) }\n+        fn read_u16(&mut self) -> Result<u16, Error> { Err(Error::Syntax) }\n         #[inline]\n         fn read_u8(&mut self) -> Result<u8, Error> {\n             match self.iter.next() {\n                 Some(value) => Ok(value),\n-                None => Err(Error::EndOfStreamError),\n+                None => Err(Error::EndOfStream),\n             }\n         }\n         #[inline]\n-        fn read_isize(&mut self) -> Result<isize, Error> { Err(Error::SyntaxError) }\n-        fn read_i64(&mut self) -> Result<i64, Error> { Err(Error::SyntaxError) }\n-        fn read_i32(&mut self) -> Result<i32, Error> { Err(Error::SyntaxError) }\n-        fn read_i16(&mut self) -> Result<i16, Error> { Err(Error::SyntaxError) }\n-        fn read_i8(&mut self) -> Result<i8, Error> { Err(Error::SyntaxError) }\n-        fn read_bool(&mut self) -> Result<bool, Error> { Err(Error::SyntaxError) }\n-        fn read_f64(&mut self) -> Result<f64, Error> { Err(Error::SyntaxError) }\n-        fn read_f32(&mut self) -> Result<f32, Error> { Err(Error::SyntaxError) }\n-        fn read_char(&mut self) -> Result<char, Error> { Err(Error::SyntaxError) }\n-        fn read_str(&mut self) -> Result<String, Error> { Err(Error::SyntaxError) }\n+        fn read_isize(&mut self) -> Result<isize, Error> { Err(Error::Syntax) }\n+        fn read_i64(&mut self) -> Result<i64, Error> { Err(Error::Syntax) }\n+        fn read_i32(&mut self) -> Result<i32, Error> { Err(Error::Syntax) }\n+        fn read_i16(&mut self) -> Result<i16, Error> { Err(Error::Syntax) }\n+        fn read_i8(&mut self) -> Result<i8, Error> { Err(Error::Syntax) }\n+        fn read_bool(&mut self) -> Result<bool, Error> { Err(Error::Syntax) }\n+        fn read_f64(&mut self) -> Result<f64, Error> { Err(Error::Syntax) }\n+        fn read_f32(&mut self) -> Result<f32, Error> { Err(Error::Syntax) }\n+        fn read_char(&mut self) -> Result<char, Error> { Err(Error::Syntax) }\n+        fn read_str(&mut self) -> Result<String, Error> { Err(Error::Syntax) }\n \n         // Compound types:\n         fn read_enum<T, F>(&mut self, _name: &str, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_variant<T, F>(&mut self, _names: &[&str], _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_struct_variant<T, F>(&mut self, _names: &[&str], _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_enum_struct_variant_field<T, F>(&mut self, _f_name: &str, _f_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_struct_field<T, F>(&mut self, _f_name: &str, _f_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple<T, F>(&mut self, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_struct<T, F>(&mut self, _s_name: &str, _len: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_tuple_struct_arg<T, F>(&mut self, _a_idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         // Specialized types:\n         fn read_option<T, F>(&mut self, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder, bool) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         #[inline]\n@@ -337,19 +337,19 @@ mod decoder {\n         fn read_map<T, F>(&mut self, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder, usize) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_map_elt_key<T, F>(&mut self, _idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n \n         fn read_map_elt_val<T, F>(&mut self, _idx: usize, _f: F) -> Result<T, Error> where\n             F: FnOnce(&mut U8Decoder) -> Result<T, Error>,\n         {\n-            Err(Error::SyntaxError)\n+            Err(Error::Syntax)\n         }\n     }\n }\n@@ -366,9 +366,9 @@ mod deserializer {\n \n     #[derive(PartialEq, Debug)]\n     enum State {\n-        StartState,\n-        SepOrEndState,\n-        EndState,\n+        Start,\n+        SepOrEnd,\n+        End,\n     }\n \n     pub struct Deserializer<A> {\n@@ -383,7 +383,7 @@ mod deserializer {\n         pub fn new(values: Vec<A>) -> Deserializer<A> {\n             let len = values.len();\n             Deserializer {\n-                state: State::StartState,\n+                state: State::Start,\n                 iter: values.into_iter(),\n                 len: len,\n                 value: None,\n@@ -399,15 +399,15 @@ mod deserializer {\n             where V: de::Visitor,\n         {\n             match self.state {\n-                State::StartState => {\n-                    self.state = State::SepOrEndState;\n+                State::Start => {\n+                    self.state = State::SepOrEnd;\n                     visitor.visit_seq(self)\n                 }\n-                State::SepOrEndState => {\n+                State::SepOrEnd => {\n                     visitor.visit_usize(self.value.take().unwrap())\n                 }\n-                State::EndState => {\n-                    Err(Error::EndOfStreamError)\n+                State::End => {\n+                    Err(Error::EndOfStream)\n                 }\n             }\n         }\n@@ -427,7 +427,7 @@ mod deserializer {\n                     Ok(Some(try!(de::Deserialize::deserialize(self))))\n                 }\n                 None => {\n-                    self.state = State::EndState;\n+                    self.state = State::End;\n                     Ok(None)\n                 }\n             }\n@@ -436,9 +436,9 @@ mod deserializer {\n         #[inline]\n         fn end(&mut self) -> Result<(), Error> {\n             match self.iter.next() {\n-                Some(_) => Err(Error::SyntaxError),\n+                Some(_) => Err(Error::Syntax),\n                 None => {\n-                    self.state = State::EndState;\n+                    self.state = State::End;\n                     Ok(())\n                 }\n             }\n@@ -458,15 +458,15 @@ mod deserializer {\n             where V: de::Visitor,\n         {\n             match self.state {\n-                State::StartState => {\n-                    self.state = State::SepOrEndState;\n+                State::Start => {\n+                    self.state = State::SepOrEnd;\n                     visitor.visit_seq(self)\n                 }\n-                State::SepOrEndState => {\n+                State::SepOrEnd => {\n                     visitor.visit_u8(self.value.take().unwrap())\n                 }\n-                State::EndState => {\n-                    Err(Error::EndOfStreamError)\n+                State::End => {\n+                    Err(Error::EndOfStream)\n                 }\n             }\n         }\n@@ -486,7 +486,7 @@ mod deserializer {\n                     Ok(Some(try!(de::Deserialize::deserialize(self))))\n                 }\n                 None => {\n-                    self.state = State::EndState;\n+                    self.state = State::End;\n                     Ok(None)\n                 }\n             }\n@@ -495,9 +495,9 @@ mod deserializer {\n         #[inline]\n         fn end(&mut self) -> Result<(), Error> {\n             match self.iter.next() {\n-                Some(_) => Err(Error::SyntaxError),\n+                Some(_) => Err(Error::Syntax),\n                 None => {\n-                    self.state = State::EndState;\n+                    self.state = State::End;\n                     Ok(())\n                 }\n             }\ndiff --git a/serde_tests/tests/test_bytes.rs b/serde_tests/tests/test_bytes.rs\nindex 785ff5503..93fe97057 100644\n--- a/serde_tests/tests/test_bytes.rs\n+++ b/serde_tests/tests/test_bytes.rs\n@@ -10,19 +10,13 @@ use serde::bytes::{ByteBuf, Bytes};\n struct Error;\n \n impl serde::ser::Error for Error {\n-    fn syntax(_: &str) -> Error { Error }\n-\n-    fn invalid_value(_field: &str) -> Error { Error }\n+    fn custom(_: String) -> Error { Error }\n }\n \n impl serde::de::Error for Error {\n-    fn syntax(_: &str) -> Error { Error }\n+    fn custom(_: String) -> Error { Error }\n \n     fn end_of_stream() -> Error { Error }\n-\n-    fn unknown_field(_field: &str) -> Error { Error }\n-\n-    fn missing_field(_field: &'static str) -> Error { Error }\n }\n \n impl fmt::Display for Error {\ndiff --git a/serde_tests/tests/token.rs b/serde_tests/tests/token.rs\nindex 11c0dc8ea..16be21b14 100644\n--- a/serde_tests/tests/token.rs\n+++ b/serde_tests/tests/token.rs\n@@ -416,7 +416,7 @@ pub enum Error {\n }\n \n impl ser::Error for Error {\n-    fn syntax(_: &str) -> Error { Error::SyntaxError }\n+    fn custom(_: String) -> Error { Error::SyntaxError }\n \n     fn invalid_value(msg: &str) -> Error {\n         Error::InvalidValue(msg.to_owned())\n@@ -424,7 +424,7 @@ impl ser::Error for Error {\n }\n \n impl de::Error for Error {\n-    fn syntax(_: &str) -> Error { Error::SyntaxError }\n+    fn custom(_: String) -> Error { Error::SyntaxError }\n \n     fn end_of_stream() -> Error { Error::EndOfStreamError }\n \n", "problem_statement": "fix(error): Report `UnknownVariant`\nDon't unify it with syntax errors.\n\n", "hints_text": "I will update my PR on https://github.com/serde-rs/json/pull/11 if this one is merged.\n\nOoh nice catch before I cut the release :)\n\nOn serde_json, I've also got 0.7 almost merged in. Give me a moment to do that. \n\nI just saw another method [`invalid_value`](https://github.com/serde-rs/serde/blob/master/serde/src/de/mod.rs#L27) on `de::Error` trait, maybe you want to forward it through `value::Error` also.\n\n@tomprogrammer: I'll take care of it, and the travis build failure.\n\nMeh, the failure is a typo...\n\nThanks!\n", "created_at": "2016-02-24T04:25:37Z", "version": "0.7"}, {"repo": "serde-rs/serde", "pull_number": 245, "instance_id": "serde-rs__serde-245", "issue_numbers": ["244"], "base_commit": "d24b2c86f2c9b3f5036289d6c2c5764be57d2127", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex dbf0042ba..7bb024915 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -529,7 +529,7 @@ macro_rules! array_impls {\n                 fn deserialize<D>(deserializer: &mut D) -> Result<[T; $len], D::Error>\n                     where D: Deserializer,\n                 {\n-                    deserializer.deserialize_seq($visitor::new())\n+                    deserializer.deserialize_fixed_size_array($len, $visitor::new())\n                 }\n             }\n         )+\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex a69f2701c..d45930e4e 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -329,6 +329,19 @@ pub trait Deserializer {\n         self.deserialize(visitor)\n     }\n \n+    /// This method hints that the `Deserialize` type is expecting a fixed size array. This allows\n+    /// deserializers to parse arrays that aren't tagged as arrays.\n+    ///\n+    /// By default, this deserializes arrays from a sequence.\n+    #[inline]\n+    fn deserialize_fixed_size_array<V>(&mut self,\n+                                       _len: usize,\n+                                       visitor: V) -> Result<V::Value, Self::Error>\n+        where V: Visitor,\n+    {\n+        self.deserialize(visitor)\n+    }\n+\n     /// This method hints that the `Deserialize` type is expecting a map of values. This allows\n     /// deserializers to parse sequences that aren't tagged as maps.\n     #[inline]\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex e7a2e6018..a2441e429 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -196,6 +196,8 @@ impl<T> Serialize for [T]\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////////\n+\n macro_rules! array_impls {\n     ($len:expr) => {\n         impl<T> Serialize for [T; $len] where T: Serialize {\n@@ -203,7 +205,8 @@ macro_rules! array_impls {\n             fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n                 where S: Serializer,\n             {\n-                serializer.serialize_seq(SeqIteratorVisitor::new(self.iter(), Some($len)))\n+                let visitor = SeqIteratorVisitor::new(self.iter(), Some($len));\n+                serializer.serialize_fixed_size_array(visitor)\n             }\n         }\n     }\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 16edd953a..e700b44fc 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -220,6 +220,16 @@ pub trait Serializer {\n         self.serialize_seq_elt(value)\n     }\n \n+    /// Serializes a fixed-size array.\n+    ///\n+    /// By default this serializes an array as a sequence.\n+    #[inline]\n+    fn serialize_fixed_size_array<V>(&mut self, visitor: V) -> Result<(), Self::Error>\n+        where V: SeqVisitor,\n+    {\n+        self.serialize_seq(visitor)\n+    }\n+\n     /// Serializes a tuple struct.\n     ///\n     /// By default, tuple structs are serialized as a tuple.\n", "test_patch": "diff --git a/serde_tests/tests/test_de.rs b/serde_tests/tests/test_de.rs\nindex 082d627d3..ab5a79ca2 100644\n--- a/serde_tests/tests/test_de.rs\n+++ b/serde_tests/tests/test_de.rs\n@@ -186,27 +186,27 @@ declare_tests! {\n         ],\n         TupleStruct(1, 2, 3) => vec![\n             Token::TupleStructStart(\"TupleStruct\", Some(3)),\n-                Token::TupleSeqSep,\n+                Token::TupleStructSep,\n                 Token::I32(1),\n \n-                Token::TupleSeqSep,\n+                Token::TupleStructSep,\n                 Token::I32(2),\n \n-                Token::TupleSeqSep,\n+                Token::TupleStructSep,\n                 Token::I32(3),\n-            Token::TupleSeqEnd,\n+            Token::TupleStructEnd,\n         ],\n         TupleStruct(1, 2, 3) => vec![\n             Token::TupleStructStart(\"TupleStruct\", None),\n-                Token::TupleSeqSep,\n+                Token::TupleStructSep,\n                 Token::I32(1),\n \n-                Token::TupleSeqSep,\n+                Token::TupleStructSep,\n                 Token::I32(2),\n \n-                Token::TupleSeqSep,\n+                Token::TupleStructSep,\n                 Token::I32(3),\n-            Token::TupleSeqEnd,\n+            Token::TupleStructEnd,\n         ],\n     }\n     test_btreeset {\n@@ -321,6 +321,10 @@ declare_tests! {\n             Token::SeqStart(Some(0)),\n             Token::SeqEnd,\n         ],\n+        [0; 0] => vec![\n+            Token::SeqArrayStart(0),\n+            Token::SeqEnd,\n+        ],\n         ([0; 0], [1], [2, 3]) => vec![\n             Token::SeqStart(Some(3)),\n                 Token::SeqSep,\n@@ -343,6 +347,28 @@ declare_tests! {\n                 Token::SeqEnd,\n             Token::SeqEnd,\n         ],\n+        ([0; 0], [1], [2, 3]) => vec![\n+            Token::SeqArrayStart(3),\n+                Token::SeqSep,\n+                Token::SeqArrayStart(0),\n+                Token::SeqEnd,\n+\n+                Token::SeqSep,\n+                Token::SeqArrayStart(1),\n+                    Token::SeqSep,\n+                    Token::I32(1),\n+                Token::SeqEnd,\n+\n+                Token::SeqSep,\n+                Token::SeqArrayStart(2),\n+                    Token::SeqSep,\n+                    Token::I32(2),\n+\n+                    Token::SeqSep,\n+                    Token::I32(3),\n+                Token::SeqEnd,\n+            Token::SeqEnd,\n+        ],\n         [0; 0] => vec![\n             Token::UnitStruct(\"Anything\"),\n         ],\n@@ -370,6 +396,24 @@ declare_tests! {\n                 Token::I32(3),\n             Token::SeqEnd,\n         ],\n+        (1,) => vec![\n+            Token::TupleStart(1),\n+                Token::TupleSep,\n+                Token::I32(1),\n+            Token::TupleEnd,\n+        ],\n+        (1, 2, 3) => vec![\n+            Token::TupleStart(3),\n+                Token::TupleSep,\n+                Token::I32(1),\n+\n+                Token::TupleSep,\n+                Token::I32(2),\n+\n+                Token::TupleSep,\n+                Token::I32(3),\n+            Token::TupleEnd,\n+        ],\n     }\n     test_btreemap {\n         BTreeMap::<isize, isize>::new() => vec![\ndiff --git a/serde_tests/tests/test_macros.rs b/serde_tests/tests/test_macros.rs\nindex 842fa670e..5feb7252d 100644\n--- a/serde_tests/tests/test_macros.rs\n+++ b/serde_tests/tests/test_macros.rs\n@@ -153,16 +153,16 @@ fn test_ser_named_tuple() {\n         &SerNamedTuple(&a, &mut b, c),\n         &[\n             Token::TupleStructStart(\"SerNamedTuple\", Some(3)),\n-            Token::TupleSeqSep,\n+            Token::TupleStructSep,\n             Token::I32(5),\n \n-            Token::TupleSeqSep,\n+            Token::TupleStructSep,\n             Token::I32(6),\n \n-            Token::TupleSeqSep,\n+            Token::TupleStructSep,\n             Token::I32(7),\n \n-            Token::TupleSeqEnd,\n+            Token::TupleStructEnd,\n         ],\n     );\n }\n@@ -190,16 +190,16 @@ fn test_de_named_tuple() {\n         &DeNamedTuple(5, 6, 7),\n         vec![\n             Token::TupleStructStart(\"DeNamedTuple\", Some(3)),\n-            Token::TupleSeqSep,\n+            Token::TupleStructSep,\n             Token::I32(5),\n \n-            Token::TupleSeqSep,\n+            Token::TupleStructSep,\n             Token::I32(6),\n \n-            Token::TupleSeqSep,\n+            Token::TupleStructSep,\n             Token::I32(7),\n \n-            Token::TupleSeqEnd,\n+            Token::TupleStructEnd,\n         ]\n     );\n }\n@@ -525,13 +525,13 @@ fn test_generic_tuple_struct() {\n         vec![\n             Token::TupleStructStart(\"GenericTupleStruct\", Some(2)),\n \n-            Token::TupleSeqSep,\n+            Token::TupleStructSep,\n             Token::U32(5),\n \n-            Token::TupleSeqSep,\n+            Token::TupleStructSep,\n             Token::U32(6),\n \n-            Token::TupleSeqEnd,\n+            Token::TupleStructEnd,\n         ]\n     );\n }\ndiff --git a/serde_tests/tests/test_ser.rs b/serde_tests/tests/test_ser.rs\nindex 2edd7c175..a67a69212 100644\n--- a/serde_tests/tests/test_ser.rs\n+++ b/serde_tests/tests/test_ser.rs\n@@ -100,11 +100,11 @@ declare_ser_tests! {\n     }\n     test_array {\n         [0; 0] => &[\n-            Token::SeqStart(Some(0)),\n+            Token::SeqArrayStart(0),\n             Token::SeqEnd,\n         ],\n         [1, 2, 3] => &[\n-            Token::SeqStart(Some(3)),\n+            Token::SeqArrayStart(3),\n                 Token::SeqSep,\n                 Token::I32(1),\n \n@@ -146,22 +146,22 @@ declare_ser_tests! {\n     }\n     test_tuple {\n         (1,) => &[\n-            Token::SeqStart(Some(1)),\n-                Token::SeqSep,\n+            Token::TupleStart(1),\n+                Token::TupleSep,\n                 Token::I32(1),\n-            Token::SeqEnd,\n+            Token::TupleEnd,\n         ],\n         (1, 2, 3) => &[\n-            Token::SeqStart(Some(3)),\n-                Token::SeqSep,\n+            Token::TupleStart(3),\n+                Token::TupleSep,\n                 Token::I32(1),\n \n-                Token::SeqSep,\n+                Token::TupleSep,\n                 Token::I32(2),\n \n-                Token::SeqSep,\n+                Token::TupleSep,\n                 Token::I32(3),\n-            Token::SeqEnd,\n+            Token::TupleEnd,\n         ],\n     }\n     test_btreemap {\n@@ -210,15 +210,15 @@ declare_ser_tests! {\n     test_tuple_struct {\n         TupleStruct(1, 2, 3) => &[\n             Token::TupleStructStart(\"TupleStruct\", Some(3)),\n-                Token::TupleSeqSep,\n+                Token::TupleStructSep,\n                 Token::I32(1),\n \n-                Token::TupleSeqSep,\n+                Token::TupleStructSep,\n                 Token::I32(2),\n \n-                Token::TupleSeqSep,\n+                Token::TupleStructSep,\n                 Token::I32(3),\n-            Token::TupleSeqEnd,\n+            Token::TupleStructEnd,\n         ],\n     }\n     test_struct {\ndiff --git a/serde_tests/tests/token.rs b/serde_tests/tests/token.rs\nindex 30d623be8..11c0dc8ea 100644\n--- a/serde_tests/tests/token.rs\n+++ b/serde_tests/tests/token.rs\n@@ -38,12 +38,17 @@ pub enum Token<'a> {\n     EnumNewType(&'a str, &'a str),\n \n     SeqStart(Option<usize>),\n+    SeqArrayStart(usize),\n     SeqSep,\n     SeqEnd,\n \n+    TupleStart(usize),\n+    TupleSep,\n+    TupleEnd,\n+\n     TupleStructStart(&'a str, Option<usize>),\n-    TupleSeqSep,\n-    TupleSeqEnd,\n+    TupleStructSep,\n+    TupleStructEnd,\n \n     MapStart(Option<usize>),\n     MapSep,\n@@ -231,6 +236,16 @@ impl<'a, I> ser::Serializer for Serializer<I>\n         self.visit_sequence(visitor)\n     }\n \n+    fn serialize_fixed_size_array<V>(&mut self, visitor: V) -> Result<(), Error>\n+        where V: ser::SeqVisitor\n+    {\n+        let len = visitor.len().expect(\"arrays must have a length\");\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::SeqArrayStart(len)));\n+\n+        self.visit_sequence(visitor)\n+    }\n+\n     fn serialize_seq_elt<T>(&mut self, value: T) -> Result<(), Error>\n         where T: ser::Serialize\n     {\n@@ -238,6 +253,27 @@ impl<'a, I> ser::Serializer for Serializer<I>\n         value.serialize(self)\n     }\n \n+    fn serialize_tuple<V>(&mut self, mut visitor: V) -> Result<(), Error>\n+        where V: ser::SeqVisitor\n+    {\n+        let len = visitor.len().expect(\"arrays must have a length\");\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleStart(len)));\n+\n+        while let Some(()) = try!(visitor.visit(self)) { }\n+\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleEnd));\n+\n+        Ok(())\n+    }\n+\n+    fn serialize_tuple_elt<T>(&mut self, value: T) -> Result<(), Error>\n+        where T: ser::Serialize\n+    {\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleSep));\n+        value.serialize(self)\n+    }\n+\n     fn serialize_newtype_struct<T>(&mut self,\n                                name: &'static str,\n                                value: T) -> Result<(), Error>\n@@ -256,7 +292,7 @@ impl<'a, I> ser::Serializer for Serializer<I>\n \n         while let Some(()) = try!(visitor.visit(self)) { }\n \n-        assert_eq!(self.tokens.next(), Some(&Token::TupleSeqEnd));\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleStructEnd));\n \n         Ok(())\n     }\n@@ -264,7 +300,7 @@ impl<'a, I> ser::Serializer for Serializer<I>\n     fn serialize_tuple_struct_elt<T>(&mut self, value: T) -> Result<(), Error>\n         where T: ser::Serialize,\n     {\n-        assert_eq!(self.tokens.next(), Some(&Token::TupleSeqSep));\n+        assert_eq!(self.tokens.next(), Some(&Token::TupleStructSep));\n         value.serialize(self)\n     }\n \n@@ -449,10 +485,28 @@ impl<I> Deserializer<I>\n         })\n     }\n \n-    fn visit_tuple_seq<V>(&mut self, len: Option<usize>, mut visitor: V) -> Result<V::Value, Error>\n+    fn visit_array<V>(&mut self, len: usize, mut visitor: V) -> Result<V::Value, Error>\n         where V: de::Visitor,\n     {\n-        visitor.visit_seq(DeserializerTupleSeqVisitor {\n+        visitor.visit_seq(DeserializerArrayVisitor {\n+            de: self,\n+            len: len,\n+        })\n+    }\n+\n+    fn visit_tuple<V>(&mut self, len: usize, mut visitor: V) -> Result<V::Value, Error>\n+        where V: de::Visitor,\n+    {\n+        visitor.visit_seq(DeserializerTupleVisitor {\n+            de: self,\n+            len: len,\n+        })\n+    }\n+\n+    fn visit_tuple_struct<V>(&mut self, len: usize, mut visitor: V) -> Result<V::Value, Error>\n+        where V: de::Visitor,\n+    {\n+        visitor.visit_seq(DeserializerTupleStructVisitor {\n             de: self,\n             len: len,\n         })\n@@ -528,6 +582,9 @@ impl<I> de::Deserializer for Deserializer<I>\n             Some(Token::SeqStart(len)) | Some(Token::TupleStructStart(_, len)) => {\n                 self.visit_seq(len, visitor)\n             }\n+            Some(Token::SeqArrayStart(len)) => {\n+                self.visit_seq(Some(len), visitor)\n+            }\n             Some(Token::MapStart(len)) | Some(Token::StructStart(_, len)) => {\n                 self.visit_map(len, visitor)\n             }\n@@ -625,6 +682,56 @@ impl<I> de::Deserializer for Deserializer<I>\n         }\n     }\n \n+    fn deserialize_fixed_size_array<V>(&mut self,\n+                                       len: usize,\n+                                       visitor: V) -> Result<V::Value, Error>\n+        where V: de::Visitor,\n+    {\n+        match self.tokens.peek() {\n+            Some(&Token::SeqArrayStart(_)) => {\n+                self.tokens.next();\n+                self.visit_array(len, visitor)\n+            }\n+            Some(_) => self.deserialize(visitor),\n+            None => Err(Error::EndOfStreamError),\n+        }\n+    }\n+\n+    fn deserialize_tuple<V>(&mut self,\n+                            len: usize,\n+                            mut visitor: V) -> Result<V::Value, Error>\n+        where V: de::Visitor,\n+    {\n+        match self.tokens.peek() {\n+            Some(&Token::Unit) => {\n+                self.tokens.next();\n+                visitor.visit_unit()\n+            }\n+            Some(&Token::UnitStruct(_)) => {\n+                self.tokens.next();\n+                visitor.visit_unit()\n+            }\n+            Some(&Token::SeqStart(_)) => {\n+                self.tokens.next();\n+                self.visit_seq(Some(len), visitor)\n+            }\n+            Some(&Token::SeqArrayStart(_)) => {\n+                self.tokens.next();\n+                self.visit_array(len, visitor)\n+            }\n+            Some(&Token::TupleStart(_)) => {\n+                self.tokens.next();\n+                self.visit_tuple(len, visitor)\n+            }\n+            Some(&Token::TupleStructStart(_, _)) => {\n+                self.tokens.next();\n+                self.visit_tuple_struct(len, visitor)\n+            }\n+            Some(_) => self.deserialize(visitor),\n+            None => Err(Error::EndOfStreamError),\n+        }\n+    }\n+\n     fn deserialize_tuple_struct<V>(&mut self,\n                                    name: &str,\n                                    len: usize,\n@@ -632,6 +739,10 @@ impl<I> de::Deserializer for Deserializer<I>\n         where V: de::Visitor,\n     {\n         match self.tokens.peek() {\n+            Some(&Token::Unit) => {\n+                self.tokens.next();\n+                visitor.visit_unit()\n+            }\n             Some(&Token::UnitStruct(n)) => {\n                 self.tokens.next();\n                 if name == n {\n@@ -640,18 +751,26 @@ impl<I> de::Deserializer for Deserializer<I>\n                     Err(Error::InvalidName(n))\n                 }\n             }\n+            Some(&Token::SeqStart(_)) => {\n+                self.tokens.next();\n+                self.visit_seq(Some(len), visitor)\n+            }\n+            Some(&Token::SeqArrayStart(_)) => {\n+                self.tokens.next();\n+                self.visit_array(len, visitor)\n+            }\n+            Some(&Token::TupleStart(_)) => {\n+                self.tokens.next();\n+                self.visit_tuple(len, visitor)\n+            }\n             Some(&Token::TupleStructStart(n, _)) => {\n                 self.tokens.next();\n                 if name == n {\n-                    self.visit_tuple_seq(Some(len), visitor)\n+                    self.visit_tuple_struct(len, visitor)\n                 } else {\n                     Err(Error::InvalidName(n))\n                 }\n             }\n-            Some(&Token::SeqStart(_)) => {\n-                self.tokens.next();\n-                self.visit_seq(Some(len), visitor)\n-            }\n             Some(_) => self.deserialize(visitor),\n             None => Err(Error::EndOfStreamError),\n         }\n@@ -729,12 +848,12 @@ impl<'a, I> de::SeqVisitor for DeserializerSeqVisitor<'a, I>\n \n //////////////////////////////////////////////////////////////////////////\n \n-struct DeserializerTupleSeqVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n+struct DeserializerArrayVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n     de: &'a mut Deserializer<I>,\n-    len: Option<usize>,\n+    len: usize,\n }\n \n-impl<'a, I> de::SeqVisitor for DeserializerTupleSeqVisitor<'a, I>\n+impl<'a, I> de::SeqVisitor for DeserializerArrayVisitor<'a, I>\n     where I: Iterator<Item=Token<'static>>,\n {\n     type Error = Error;\n@@ -743,12 +862,12 @@ impl<'a, I> de::SeqVisitor for DeserializerTupleSeqVisitor<'a, I>\n         where T: de::Deserialize,\n     {\n         match self.de.tokens.peek() {\n-            Some(&Token::TupleSeqSep) => {\n+            Some(&Token::SeqSep) => {\n                 self.de.tokens.next();\n-                self.len = self.len.map(|len| len - 1);\n+                self.len -= 1;\n                 Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n             }\n-            Some(&Token::TupleSeqEnd) => Ok(None),\n+            Some(&Token::SeqEnd) => Ok(None),\n             Some(_) => {\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n@@ -758,17 +877,104 @@ impl<'a, I> de::SeqVisitor for DeserializerTupleSeqVisitor<'a, I>\n     }\n \n     fn end(&mut self) -> Result<(), Error> {\n-        //assert_eq!(self.len.unwrap_or(0), 0);\n+        assert_eq!(self.len, 0);\n         match self.de.tokens.next() {\n-            Some(Token::TupleSeqEnd) => Ok(()),\n+            Some(Token::SeqEnd) => Ok(()),\n             Some(token) => Err(Error::UnexpectedToken(token)),\n             None => Err(Error::EndOfStreamError),\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.len.unwrap_or(0);\n-        (len, self.len)\n+        (self.len, Some(self.len))\n+    }\n+}\n+\n+//////////////////////////////////////////////////////////////////////////\n+\n+struct DeserializerTupleVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n+    de: &'a mut Deserializer<I>,\n+    len: usize,\n+}\n+\n+impl<'a, I> de::SeqVisitor for DeserializerTupleVisitor<'a, I>\n+    where I: Iterator<Item=Token<'static>>,\n+{\n+    type Error = Error;\n+\n+    fn visit<T>(&mut self) -> Result<Option<T>, Error>\n+        where T: de::Deserialize,\n+    {\n+        match self.de.tokens.peek() {\n+            Some(&Token::TupleSep) => {\n+                self.de.tokens.next();\n+                self.len -= 1;\n+                Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n+            }\n+            Some(&Token::TupleEnd) => Ok(None),\n+            Some(_) => {\n+                let token = self.de.tokens.next().unwrap();\n+                Err(Error::UnexpectedToken(token))\n+            }\n+            None => Err(Error::EndOfStreamError),\n+        }\n+    }\n+\n+    fn end(&mut self) -> Result<(), Error> {\n+        assert_eq!(self.len, 0);\n+        match self.de.tokens.next() {\n+            Some(Token::TupleEnd) => Ok(()),\n+            Some(token) => Err(Error::UnexpectedToken(token)),\n+            None => Err(Error::EndOfStreamError),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.len, Some(self.len))\n+    }\n+}\n+\n+//////////////////////////////////////////////////////////////////////////\n+\n+struct DeserializerTupleStructVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n+    de: &'a mut Deserializer<I>,\n+    len: usize,\n+}\n+\n+impl<'a, I> de::SeqVisitor for DeserializerTupleStructVisitor<'a, I>\n+    where I: Iterator<Item=Token<'static>>,\n+{\n+    type Error = Error;\n+\n+    fn visit<T>(&mut self) -> Result<Option<T>, Error>\n+        where T: de::Deserialize,\n+    {\n+        match self.de.tokens.peek() {\n+            Some(&Token::TupleStructSep) => {\n+                self.de.tokens.next();\n+                self.len -= 1;\n+                Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n+            }\n+            Some(&Token::TupleStructEnd) => Ok(None),\n+            Some(_) => {\n+                let token = self.de.tokens.next().unwrap();\n+                Err(Error::UnexpectedToken(token))\n+            }\n+            None => Err(Error::EndOfStreamError),\n+        }\n+    }\n+\n+    fn end(&mut self) -> Result<(), Error> {\n+        assert_eq!(self.len, 0);\n+        match self.de.tokens.next() {\n+            Some(Token::TupleStructEnd) => Ok(()),\n+            Some(token) => Err(Error::UnexpectedToken(token)),\n+            None => Err(Error::EndOfStreamError),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.len, Some(self.len))\n     }\n }\n \n", "problem_statement": "Figure out if there are sensible hooks for serializing fixed length arrays\nFixed length arrays don't yet have a hook to hint that they're fixed length, so they're serialized like a generic sequence. It might be nice to add one for backends that might want to do something special with them.\n\nOne potential challenge here is how do we trust that the `Serialize` is actually serializing the right number of values, but we have the same challenge for tuples.\n\n", "hints_text": "", "created_at": "2016-02-23T13:16:33Z", "version": "0.6"}, {"repo": "serde-rs/serde", "pull_number": 242, "instance_id": "serde-rs__serde-242", "issue_numbers": ["181"], "base_commit": "c03587f0bf82b8c7c9e4b4c24304d5788206dbda", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 4d8b95f89..4db468a88 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -14,6 +14,7 @@ use std::collections::{\n use collections::enum_set::{CLike, EnumSet};\n use std::hash::Hash;\n use std::marker::PhantomData;\n+use std::net;\n use std::path;\n use std::rc::Rc;\n use std::str;\n@@ -740,6 +741,83 @@ map_impl!(\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+#[cfg(feature = \"nightly\")]\n+impl Deserialize for net::IpAddr {\n+    fn deserialize<D>(deserializer: &mut D) -> Result<Self, D::Error>\n+        where D: Deserializer,\n+    {\n+        let s = try!(String::deserialize(deserializer));\n+        match s.parse() {\n+            Ok(s) => Ok(s),\n+            Err(err) => Err(D::Error::invalid_value(&err.to_string())),\n+        }\n+    }\n+}\n+\n+impl Deserialize for net::Ipv4Addr {\n+    fn deserialize<D>(deserializer: &mut D) -> Result<Self, D::Error>\n+        where D: Deserializer,\n+    {\n+        let s = try!(String::deserialize(deserializer));\n+        match s.parse() {\n+            Ok(s) => Ok(s),\n+            Err(err) => Err(D::Error::invalid_value(&err.to_string())),\n+        }\n+    }\n+}\n+\n+impl Deserialize for net::Ipv6Addr {\n+    fn deserialize<D>(deserializer: &mut D) -> Result<Self, D::Error>\n+        where D: Deserializer,\n+    {\n+        let s = try!(String::deserialize(deserializer));\n+        match s.parse() {\n+            Ok(s) => Ok(s),\n+            Err(err) => Err(D::Error::invalid_value(&err.to_string())),\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+impl Deserialize for net::SocketAddr {\n+    fn deserialize<D>(deserializer: &mut D) -> Result<Self, D::Error>\n+        where D: Deserializer,\n+    {\n+        let s = try!(String::deserialize(deserializer));\n+        match s.parse() {\n+            Ok(s) => Ok(s),\n+            Err(err) => Err(D::Error::invalid_value(&err.to_string())),\n+        }\n+    }\n+}\n+\n+impl Deserialize for net::SocketAddrV4 {\n+    fn deserialize<D>(deserializer: &mut D) -> Result<Self, D::Error>\n+        where D: Deserializer,\n+    {\n+        let s = try!(String::deserialize(deserializer));\n+        match s.parse() {\n+            Ok(s) => Ok(s),\n+            Err(err) => Err(D::Error::invalid_value(&err.to_string())),\n+        }\n+    }\n+}\n+\n+impl Deserialize for net::SocketAddrV6 {\n+    fn deserialize<D>(deserializer: &mut D) -> Result<Self, D::Error>\n+        where D: Deserializer,\n+    {\n+        let s = try!(String::deserialize(deserializer));\n+        match s.parse() {\n+            Ok(s) => Ok(s),\n+            Err(err) => Err(D::Error::invalid_value(&err.to_string())),\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n struct PathBufVisitor;\n \n impl Visitor for PathBufVisitor {\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex cc20f9b60..ac604936d 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -15,6 +15,7 @@ use collections::enum_set::{CLike, EnumSet};\n use std::hash::Hash;\n #[cfg(feature = \"nightly\")]\n use std::iter;\n+use std::net;\n #[cfg(feature = \"nightly\")]\n use std::num;\n #[cfg(feature = \"nightly\")]\n@@ -679,6 +680,65 @@ impl<T, E> Serialize for Result<T, E> where T: Serialize, E: Serialize {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+#[cfg(feature = \"nightly\")]\n+impl Serialize for net::IpAddr {\n+    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+        where S: Serializer,\n+    {\n+        match *self {\n+            net::IpAddr::V4(ref addr) => addr.serialize(serializer),\n+            net::IpAddr::V6(ref addr) => addr.serialize(serializer),\n+        }\n+    }\n+}\n+\n+impl Serialize for net::Ipv4Addr {\n+    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+        where S: Serializer,\n+    {\n+        self.to_string().serialize(serializer)\n+    }\n+}\n+\n+impl Serialize for net::Ipv6Addr {\n+    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+        where S: Serializer,\n+    {\n+        self.to_string().serialize(serializer)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+impl Serialize for net::SocketAddr {\n+    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+        where S: Serializer,\n+    {\n+        match *self {\n+            net::SocketAddr::V4(ref addr) => addr.serialize(serializer),\n+            net::SocketAddr::V6(ref addr) => addr.serialize(serializer),\n+        }\n+    }\n+}\n+\n+impl Serialize for net::SocketAddrV4 {\n+    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+        where S: Serializer,\n+    {\n+        self.to_string().serialize(serializer)\n+    }\n+}\n+\n+impl Serialize for net::SocketAddrV6 {\n+    fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+        where S: Serializer,\n+    {\n+        self.to_string().serialize(serializer)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n impl Serialize for path::Path {\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n         where S: Serializer,\n", "test_patch": "diff --git a/serde_tests/tests/test_de.rs b/serde_tests/tests/test_de.rs\nindex 568bfaea1..88f6a9add 100644\n--- a/serde_tests/tests/test_de.rs\n+++ b/serde_tests/tests/test_de.rs\n@@ -1,4 +1,5 @@\n use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n+use std::net;\n use std::path::PathBuf;\n \n use num::FromPrimitive;\n@@ -571,6 +572,17 @@ declare_tests! {\n             Token::Unit,\n         ],\n     }\n+    test_net_ipv4addr {\n+        \"1.2.3.4\".parse::<net::Ipv4Addr>().unwrap() => vec![Token::Str(\"1.2.3.4\")],\n+    }\n+    test_net_ipv6addr {\n+        \"::1\".parse::<net::Ipv6Addr>().unwrap() => vec![Token::Str(\"::1\")],\n+    }\n+    test_net_socketaddr {\n+        \"1.2.3.4:1234\".parse::<net::SocketAddr>().unwrap() => vec![Token::Str(\"1.2.3.4:1234\")],\n+        \"1.2.3.4:1234\".parse::<net::SocketAddrV4>().unwrap() => vec![Token::Str(\"1.2.3.4:1234\")],\n+        \"[::1]:1234\".parse::<net::SocketAddrV6>().unwrap() => vec![Token::Str(\"[::1]:1234\")],\n+    }\n     test_num_bigint {\n         BigInt::from_i64(123).unwrap() => vec![Token::Str(\"123\")],\n         BigInt::from_i64(-123).unwrap() => vec![Token::Str(\"-123\")],\n@@ -607,6 +619,15 @@ declare_tests! {\n     }\n }\n \n+#[cfg(feature = \"nightly\")]\n+#[test]\n+fn test_net_ipaddr() {\n+    assert_de_tokens(\n+        \"1.2.3.4\".parse::<net::IpAddr>().unwrap(),\n+        vec![Token::Str(\"1.2.3.4\")],\n+    );\n+}\n+\n #[test]\n fn test_enum_error() {\n     assert_de_tokens_error::<Enum>(\ndiff --git a/serde_tests/tests/test_ser.rs b/serde_tests/tests/test_ser.rs\nindex e08d8c140..bf9bd1ead 100644\n--- a/serde_tests/tests/test_ser.rs\n+++ b/serde_tests/tests/test_ser.rs\n@@ -1,4 +1,5 @@\n use std::collections::BTreeMap;\n+use std::net;\n use std::path::{Path, PathBuf};\n use std::str;\n \n@@ -266,6 +267,17 @@ declare_ser_tests! {\n             Token::EnumMapEnd,\n         ],\n     }\n+    test_net_ipv4addr {\n+        \"1.2.3.4\".parse::<net::Ipv4Addr>().unwrap() => &[Token::Str(\"1.2.3.4\")],\n+    }\n+    test_net_ipv6addr {\n+        \"::1\".parse::<net::Ipv6Addr>().unwrap() => &[Token::Str(\"::1\")],\n+    }\n+    test_net_socketaddr {\n+        \"1.2.3.4:1234\".parse::<net::SocketAddr>().unwrap() => &[Token::Str(\"1.2.3.4:1234\")],\n+        \"1.2.3.4:1234\".parse::<net::SocketAddrV4>().unwrap() => &[Token::Str(\"1.2.3.4:1234\")],\n+        \"[::1]:1234\".parse::<net::SocketAddrV6>().unwrap() => &[Token::Str(\"[::1]:1234\")],\n+    }\n     test_num_bigint {\n         BigInt::from_i64(123).unwrap() => &[Token::Str(\"123\")],\n         BigInt::from_i64(-123).unwrap() => &[Token::Str(\"-123\")],\n@@ -307,6 +319,15 @@ declare_ser_tests! {\n     }\n }\n \n+#[cfg(feature = \"nightly\")]\n+#[test]\n+fn test_net_ipaddr() {\n+    assert_ser_tokens(\n+        \"1.2.3.4\".parse::<net::IpAddr>().unwrap(),\n+        &[Token::Str(\"1.2.3.4\")],\n+    );\n+}\n+\n #[test]\n fn test_cannot_serialize_paths() {\n     let path = unsafe {\n", "problem_statement": "Consider changing Ipv*Addr serialization to a tuple of integers from a string\nSerde is missing support for `Ipv4Addr` and `Ipv6Addr`. It would be nice if we supported it and other `std::net` types. One open question though is how should we actually serialize IP addresses? It would be the most compact by serializing to a `u32` or `(u64, u64)`, or in pieces with `(u8, u8, u8, u8)` and 8 `u16`s, but I'm sure human consumable formats like markdown or JSON would prefer a textual format.\n\n", "hints_text": "`[127, 0, 0, 1]` is very human readable imo. As long as it's done with `serialize_tuple` and `serialize_u8` bincode will do the optimal thing (4 bytes) and json will do the readable thing. The same goes for ipv6.\n\nThe only issue I see is that some might prefer to output a `String` in the canonical `\"127.0.0.1\"` form. For deserialization that's a no-brainer, simply offer a deserialization for `String`s. But there's no way to serialize them this way.\n\nI like the octet array version.\n\nVersus text: Once some version of #198 (mapping proxies) lands then serde can add pre-built text mapper proxies that folks can opt in to with annotations.\n\nVersus u32:  Octet arrays look better in JSON. Also, arrays have the same endianness universally.\n\nThe type I'm really interested in is `Timespec`, which has the same basic requirements as `Ipv*Addr`. Serde could by default offer a mapping that very directly models the native shape `(i64, i32)`, and vend #198 mapping proxies with customizable formats for strings.\n", "created_at": "2016-02-22T03:06:33Z", "version": "0.6"}, {"repo": "serde-rs/serde", "pull_number": 241, "instance_id": "serde-rs__serde-241", "issue_numbers": ["169"], "base_commit": "4d10eef55df49ba3d5f7b834750592f27800d0f7", "patch": "diff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 11050648e..142502b77 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -32,10 +32,19 @@ pub trait Error: Sized + error::Error {\n     fn end_of_stream() -> Self;\n \n     /// Raised when a `Deserialize` struct type received an unexpected struct field.\n-    fn unknown_field(field: &str) -> Self;\n+    fn unknown_field(field: &str) -> Self {\n+        Error::syntax(&format!(\"Unknown field `{}`\", field))\n+    }\n+\n+    /// Raised when a `Deserialize` enum type received an unexpected variant.\n+    fn unknown_variant(field: &str) -> Self {\n+        Error::syntax(&format!(\"Unknown variant `{}`\", field))\n+    }\n \n-    /// Raised when a `Deserialize` struct type did not receive a field.\n-    fn missing_field(field: &'static str) -> Self;\n+    /// raised when a `deserialize` struct type did not receive a field.\n+    fn missing_field(field: &'static str) -> Self {\n+        Error::syntax(&format!(\"Missing field `{}`\", field))\n+    }\n }\n \n /// `Type` represents all the primitive types that can be deserialized. This is used by\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex bc53153e4..a94fd02bb 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -566,6 +566,7 @@ fn deserialize_item_enum(\n                 .collect()\n         ),\n         container_attrs,\n+        true,\n     );\n \n     let variants_expr = builder.expr().ref_().slice()\n@@ -807,6 +808,7 @@ fn deserialize_field_visitor(\n     builder: &aster::AstBuilder,\n     field_names: Vec<P<ast::Expr>>,\n     container_attrs: &attr::ContainerAttrs,\n+    is_variant: bool,\n ) -> Vec<P<ast::Item>> {\n     // Create the field names for the fields.\n     let field_idents: Vec<ast::Ident> = (0 .. field_names.len())\n@@ -838,10 +840,16 @@ fn deserialize_field_visitor(\n         })\n         .collect();\n \n+    let (index_error_msg, unknown_ident) = if is_variant {\n+        (builder.expr().str(\"expected a variant\"), builder.id(\"unknown_variant\"))\n+    } else {\n+        (builder.expr().str(\"expected a field\"), builder.id(\"unknown_field\"))\n+    };\n+\n     let index_body = quote_expr!(cx,\n         match value {\n             $index_field_arms\n-            _ => { Err(::serde::de::Error::syntax(\"expected a field\")) }\n+            _ => { Err(::serde::de::Error::syntax($index_error_msg)) }\n         }\n     );\n \n@@ -853,10 +861,10 @@ fn deserialize_field_visitor(\n         })\n         .collect();\n \n-    let fallthrough_arm_expr = if !container_attrs.deny_unknown_fields() {\n+    let fallthrough_arm_expr = if !is_variant && !container_attrs.deny_unknown_fields() {\n         quote_expr!(cx, Ok(__Field::__ignore))\n     } else {\n-        quote_expr!(cx, Err(::serde::de::Error::unknown_field(value)))\n+        quote_expr!(cx, Err(::serde::de::Error::$unknown_ident(value)))\n     };\n \n     let str_body = quote_expr!(cx,\n@@ -947,7 +955,8 @@ fn deserialize_struct_visitor(\n         cx,\n         builder,\n         try!(field_exprs),\n-        container_attrs\n+        container_attrs,\n+        false,\n     );\n \n     let visit_map_expr = try!(deserialize_map(\n", "test_patch": "diff --git a/serde_tests/tests/test_de.rs b/serde_tests/tests/test_de.rs\nindex dcc6e8f00..568bfaea1 100644\n--- a/serde_tests/tests/test_de.rs\n+++ b/serde_tests/tests/test_de.rs\n@@ -8,7 +8,13 @@ use num::rational::Ratio;\n \n use serde::de::{Deserializer, Visitor};\n \n-use token::{Token, assert_de_tokens, assert_de_tokens_ignore};\n+use token::{\n+    Error,\n+    Token,\n+    assert_de_tokens,\n+    assert_de_tokens_ignore,\n+    assert_de_tokens_error,\n+};\n \n //////////////////////////////////////////////////////////////////////////\n \n@@ -600,3 +606,13 @@ declare_tests! {\n         ],\n     }\n }\n+\n+#[test]\n+fn test_enum_error() {\n+    assert_de_tokens_error::<Enum>(\n+        vec![\n+            Token::EnumUnit(\"Enum\", \"Foo\"),\n+        ],\n+        Error::UnknownVariantError(\"Foo\".to_owned()),\n+    )\n+}\ndiff --git a/serde_tests/tests/token.rs b/serde_tests/tests/token.rs\nindex 40810d47d..30d623be8 100644\n--- a/serde_tests/tests/token.rs\n+++ b/serde_tests/tests/token.rs\n@@ -371,6 +371,7 @@ pub enum Error {\n     SyntaxError,\n     EndOfStreamError,\n     UnknownFieldError(String),\n+    UnknownVariantError(String),\n     MissingFieldError(&'static str),\n     InvalidName(&'static str),\n     InvalidValue(String),\n@@ -395,6 +396,10 @@ impl de::Error for Error {\n         Error::UnknownFieldError(field.to_owned())\n     }\n \n+    fn unknown_variant(variant: &str) -> Error {\n+        Error::UnknownVariantError(variant.to_owned())\n+    }\n+\n     fn missing_field(field: &'static str) -> Error {\n         Error::MissingFieldError(field)\n     }\n", "problem_statement": "Add an `Error::unknown_variant` error\nSemantically speaking, it is incorrect for deserializing a variant to error out with an `unknown_field` error. It would be better expressed as an `unknown_variant` error. Without this, certain implementations of #44 may not properly handle unknown variants.\n\n", "hints_text": "", "created_at": "2016-02-22T00:28:03Z", "version": "0.6"}, {"repo": "serde-rs/serde", "pull_number": 233, "instance_id": "serde-rs__serde-233", "issue_numbers": ["211", "218"], "base_commit": "a926cb62f05012d15618922029e1cd9cdf42cd10", "patch": "diff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex cb0e25e8c..3d172a06c 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -424,15 +424,6 @@ pub trait Deserializer {\n     {\n         self.deserialize(visitor)\n     }\n-\n-    /// Specify a format string for the deserializer.\n-    ///\n-    /// The deserializer format is used to determine which format\n-    /// specific field attributes should be used with the\n-    /// deserializer.\n-    fn format() -> &'static str {\n-        \"\"\n-    }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 636517cba..57db91916 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -327,14 +327,6 @@ pub trait Serializer {\n     {\n         self.serialize_struct_elt(key, value)\n     }\n-\n-    /// Specify a format string for the serializer.\n-    ///\n-    /// The serializer format is used to determine which format\n-    /// specific field attributes should be used with the serializer.\n-    fn format() -> &'static str {\n-        \"\"\n-    }\n }\n \n /// A trait that is used by a `Serialize` to iterate through a sequence.\ndiff --git a/serde_codegen/src/attr.rs b/serde_codegen/src/attr.rs\nindex a021ef9c0..9c0362844 100644\n--- a/serde_codegen/src/attr.rs\n+++ b/serde_codegen/src/attr.rs\n@@ -1,365 +1,327 @@\n-use std::collections::HashMap;\n-use std::collections::HashSet;\n-\n use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::ExtCtxt;\n use syntax::print::pprust::meta_item_to_string;\n use syntax::ptr::P;\n \n-use aster;\n+use aster::AstBuilder;\n \n use error::Error;\n \n-/// Represents field name information\n+/// Represents container (e.g. struct) attribute information\n #[derive(Debug)]\n-pub enum FieldNames {\n-    Global(P<ast::Expr>),\n-    Format{\n-        formats: HashMap<P<ast::Expr>, P<ast::Expr>>,\n-        default: P<ast::Expr>,\n-    }\n+pub struct ContainerAttrs {\n+    ident: ast::Ident,\n+    serialize_name: Option<ast::Lit>,\n+    deserialize_name: Option<ast::Lit>,\n+    deny_unknown_fields: bool,\n }\n \n-/// Represents field attribute information\n-#[derive(Debug)]\n-pub struct FieldAttrs {\n-    skip_serializing_field: bool,\n-    skip_serializing_field_if_empty: bool,\n-    skip_serializing_field_if_none: bool,\n-    names: FieldNames,\n-    use_default: bool,\n-}\n+impl ContainerAttrs {\n+    /// Extract out the `#[serde(...)]` attributes from an item.\n+    pub fn from_item(cx: &ExtCtxt, item: &ast::Item) -> Result<ContainerAttrs, Error> {\n+        let mut container_attrs = ContainerAttrs {\n+            ident: item.ident,\n+            serialize_name: None,\n+            deserialize_name: None,\n+            deny_unknown_fields: false,\n+        };\n \n-impl FieldAttrs {\n-    /// Return a set of formats that the field has attributes for.\n-    pub fn formats(&self) -> HashSet<P<ast::Expr>> {\n-        match self.names {\n-            FieldNames::Format { ref formats, .. } => {\n-                let mut set = HashSet::new();\n-                for (fmt, _) in formats.iter() {\n-                    set.insert(fmt.clone());\n-                };\n-                set\n-            },\n-            _ => HashSet::new()\n+        for meta_items in item.attrs().iter().filter_map(get_serde_meta_items) {\n+            for meta_item in meta_items {\n+                match meta_item.node {\n+                    // Parse `#[serde(rename=\"foo\")]`\n+                    ast::MetaNameValue(ref name, ref lit) if name == &\"rename\" => {\n+                        container_attrs.serialize_name = Some(lit.clone());\n+                        container_attrs.deserialize_name = Some(lit.clone());\n+                    }\n+\n+                    // Parse `#[serde(rename(serialize=\"foo\", deserialize=\"bar\"))]`\n+                    ast::MetaList(ref name, ref meta_items) if name == &\"rename\" => {\n+                        let (ser_name, de_name) = try!(get_renames(cx, meta_items));\n+                        container_attrs.serialize_name = ser_name;\n+                        container_attrs.deserialize_name = de_name;\n+                    }\n+\n+                    // Parse `#[serde(deny_unknown_fields)]`\n+                    ast::MetaWord(ref name) if name == &\"deny_unknown_fields\" => {\n+                        container_attrs.deny_unknown_fields = true;\n+                    }\n+\n+                    _ => {\n+                        cx.span_err(\n+                            meta_item.span,\n+                            &format!(\"unknown serde container attribute `{}`\",\n+                                     meta_item_to_string(meta_item)));\n+\n+                        return Err(Error);\n+                    }\n+                }\n+            }\n         }\n+\n+        Ok(container_attrs)\n     }\n \n-    /// Return an expression for the field key name for serialisation.\n-    ///\n-    /// The resulting expression assumes that `S` refers to a type\n-    /// that implements `Serializer`.\n-    pub fn serializer_key_expr(&self, cx: &ExtCtxt) -> P<ast::Expr> {\n-        match self.names {\n-            FieldNames::Global(ref name) => name.clone(),\n-            FieldNames::Format { ref formats, ref default } => {\n-                let arms = formats.iter()\n-                    .map(|(fmt, lit)| {\n-                        quote_arm!(cx, $fmt => { $lit })\n-                    })\n-                    .collect::<Vec<_>>();\n-                quote_expr!(cx,\n-                    match S::format() {\n-                        $arms\n-                        _ => { $default }\n-                    }\n-                )\n-            },\n+    /// Return the string expression of the field ident.\n+    pub fn ident_expr(&self) -> P<ast::Expr> {\n+        AstBuilder::new().expr().str(self.ident)\n+    }\n+\n+    /// Return the field name for the field when serializing.\n+    pub fn serialize_name_expr(&self) -> P<ast::Expr> {\n+        match self.serialize_name {\n+            Some(ref name) => AstBuilder::new().expr().build_lit(P(name.clone())),\n+            None => self.ident_expr(),\n         }\n     }\n \n-    /// Return the default field name for the field.\n-    pub fn default_key_expr(&self) -> &P<ast::Expr> {\n-        match self.names {\n-            FieldNames::Global(ref expr) => expr,\n-            FieldNames::Format { ref default, .. } => default,\n+    /// Return the field name for the field when serializing.\n+    pub fn deserialize_name_expr(&self) -> P<ast::Expr> {\n+        match self.deserialize_name {\n+            Some(ref name) => AstBuilder::new().expr().build_lit(P(name.clone())),\n+            None => self.ident_expr(),\n         }\n     }\n \n-    /// Return the field name for the field in the specified format.\n-    pub fn key_expr(&self, format: &P<ast::Expr>) -> &P<ast::Expr> {\n-        match self.names {\n-            FieldNames::Global(ref expr) => expr,\n-            FieldNames::Format { ref formats, ref default } => {\n-                formats.get(format).unwrap_or(default)\n+    pub fn deny_unknown_fields(&self) -> bool {\n+        self.deny_unknown_fields\n+    }\n+}\n+\n+/// Represents variant attribute information\n+#[derive(Debug)]\n+pub struct VariantAttrs {\n+    ident: ast::Ident,\n+    serialize_name: Option<ast::Lit>,\n+    deserialize_name: Option<ast::Lit>,\n+}\n+\n+impl VariantAttrs {\n+    pub fn from_variant(cx: &ExtCtxt, variant: &ast::Variant) -> Result<Self, Error> {\n+        let mut variant_attrs = VariantAttrs {\n+            ident: variant.node.name,\n+            serialize_name: None,\n+            deserialize_name: None,\n+        };\n+\n+        for meta_items in variant.node.attrs.iter().filter_map(get_serde_meta_items) {\n+            for meta_item in meta_items {\n+                match meta_item.node {\n+                    // Parse `#[serde(rename=\"foo\")]`\n+                    ast::MetaNameValue(ref name, ref lit) if name == &\"rename\" => {\n+                        variant_attrs.serialize_name = Some(lit.clone());\n+                        variant_attrs.deserialize_name = Some(lit.clone());\n+                    }\n+\n+                    // Parse `#[serde(rename(serialize=\"foo\", deserialize=\"bar\"))]`\n+                    ast::MetaList(ref name, ref meta_items) if name == &\"rename\" => {\n+                        let (ser_name, de_name) = try!(get_renames(cx, meta_items));\n+                        variant_attrs.serialize_name = ser_name;\n+                        variant_attrs.deserialize_name = de_name;\n+                    }\n+\n+                    _ => {\n+                        cx.span_err(\n+                            meta_item.span,\n+                            &format!(\"unknown serde variant attribute `{}`\",\n+                                     meta_item_to_string(meta_item)));\n+\n+                        return Err(Error);\n+                    }\n+                }\n             }\n         }\n-    }\n \n-    /// Predicate for using a field's default value\n-    pub fn use_default(&self) -> bool {\n-        self.use_default\n+        Ok(variant_attrs)\n     }\n \n-    /// Predicate for ignoring a field when serializing a value\n-    pub fn skip_serializing_field(&self) -> bool {\n-        self.skip_serializing_field\n+    /// Return the string expression of the field ident.\n+    pub fn ident_expr(&self) -> P<ast::Expr> {\n+        AstBuilder::new().expr().str(self.ident)\n     }\n \n-    pub fn skip_serializing_field_if_empty(&self) -> bool {\n-        self.skip_serializing_field_if_empty\n+    /// Return the field name for the field when serializing.\n+    pub fn serialize_name_expr(&self) -> P<ast::Expr> {\n+        match self.serialize_name {\n+            Some(ref name) => AstBuilder::new().expr().build_lit(P(name.clone())),\n+            None => self.ident_expr(),\n+        }\n     }\n \n-    pub fn skip_serializing_field_if_none(&self) -> bool {\n-        self.skip_serializing_field_if_none\n+    /// Return the field name for the field when serializing.\n+    pub fn deserialize_name_expr(&self) -> P<ast::Expr> {\n+        match self.deserialize_name {\n+            Some(ref name) => AstBuilder::new().expr().build_lit(P(name.clone())),\n+            None => self.ident_expr(),\n+        }\n     }\n }\n \n-pub struct FieldAttrsBuilder<'a> {\n-    cx: &'a ExtCtxt<'a>,\n-    builder: &'a aster::AstBuilder,\n+/// Represents field attribute information\n+#[derive(Debug)]\n+pub struct FieldAttrs {\n+    ident: ast::Ident,\n+    serialize_name: Option<ast::Lit>,\n+    deserialize_name: Option<ast::Lit>,\n     skip_serializing_field: bool,\n     skip_serializing_field_if_empty: bool,\n     skip_serializing_field_if_none: bool,\n-    name: Option<P<ast::Expr>>,\n-    format_rename: HashMap<P<ast::Expr>, P<ast::Expr>>,\n     use_default: bool,\n }\n \n-impl<'a> FieldAttrsBuilder<'a> {\n-    pub fn new(cx: &'a ExtCtxt<'a>,\n-               builder: &'a aster::AstBuilder) -> FieldAttrsBuilder<'a> {\n-        FieldAttrsBuilder {\n-            cx: cx,\n-            builder: builder,\n+impl FieldAttrs {\n+    /// Extract out the `#[serde(...)]` attributes from a struct field.\n+    pub fn from_field(cx: &ExtCtxt, field: &ast::StructField) -> Result<Self, Error> {\n+        let field_ident = match field.node.ident() {\n+            Some(ident) => ident,\n+            None => { cx.span_bug(field.span, \"struct field has no name?\") }\n+        };\n+\n+        let mut field_attrs = FieldAttrs {\n+            ident: field_ident,\n+            serialize_name: None,\n+            deserialize_name: None,\n             skip_serializing_field: false,\n             skip_serializing_field_if_empty: false,\n             skip_serializing_field_if_none: false,\n-            name: None,\n-            format_rename: HashMap::new(),\n             use_default: false,\n-        }\n-    }\n-\n-    pub fn field(mut self, field: &ast::StructField) -> Result<FieldAttrsBuilder<'a>, Error> {\n-        match field.node.kind {\n-            ast::NamedField(name, _) => {\n-                self.name = Some(self.builder.expr().str(name));\n-            }\n-            ast::UnnamedField(_) => { }\n         };\n \n-        self.attrs(&field.node.attrs)\n-    }\n+        for meta_items in field.node.attrs.iter().filter_map(get_serde_meta_items) {\n+            for meta_item in meta_items {\n+                match meta_item.node {\n+                    // Parse `#[serde(rename=\"foo\")]`\n+                    ast::MetaNameValue(ref name, ref lit) if name == &\"rename\" => {\n+                        field_attrs.serialize_name = Some(lit.clone());\n+                        field_attrs.deserialize_name = Some(lit.clone());\n+                    }\n \n-    pub fn attrs(mut self, attrs: &[ast::Attribute]) -> Result<FieldAttrsBuilder<'a>, Error> {\n-        for attr in attrs {\n-            self = try!(self.attr(attr));\n-        }\n+                    // Parse `#[serde(rename(serialize=\"foo\", deserialize=\"bar\"))]`\n+                    ast::MetaList(ref name, ref meta_items) if name == &\"rename\" => {\n+                        let (ser_name, de_name) = try!(get_renames(cx, meta_items));\n+                        field_attrs.serialize_name = ser_name;\n+                        field_attrs.deserialize_name = de_name;\n+                    }\n \n-        Ok(self)\n-    }\n+                    // Parse `#[serde(default)]`\n+                    ast::MetaWord(ref name) if name == &\"default\" => {\n+                        field_attrs.use_default = true;\n+                    }\n \n-    pub fn attr(mut self, attr: &ast::Attribute) -> Result<FieldAttrsBuilder<'a>, Error> {\n-        match attr.node.value.node {\n-            ast::MetaList(ref name, ref items) if name == &\"serde\" => {\n-                attr::mark_used(&attr);\n-                for item in items {\n-                    self = try!(self.meta_item(item));\n-                }\n+                    // Parse `#[serde(skip_serializing)]`\n+                    ast::MetaWord(ref name) if name == &\"skip_serializing\" => {\n+                        field_attrs.skip_serializing_field = true;\n+                    }\n \n-                Ok(self)\n-            }\n-            _ => {\n-                Ok(self)\n-            }\n-        }\n-    }\n+                    // Parse `#[serde(skip_serializing_if_none)]`\n+                    ast::MetaWord(ref name) if name == &\"skip_serializing_if_none\" => {\n+                        field_attrs.skip_serializing_field_if_none = true;\n+                    }\n \n-    pub fn meta_item(mut self,\n-                     meta_item: &P<ast::MetaItem>) -> Result<FieldAttrsBuilder<'a>, Error> {\n-        match meta_item.node {\n-            ast::MetaNameValue(ref name, ref lit) if name == &\"rename\" => {\n-                let expr = self.builder.expr().build_lit(P(lit.clone()));\n+                    // Parse `#[serde(skip_serializing_if_empty)]`\n+                    ast::MetaWord(ref name) if name == &\"skip_serializing_if_empty\" => {\n+                        field_attrs.skip_serializing_field_if_empty = true;\n+                    }\n \n-                Ok(self.name(expr))\n-            }\n-            ast::MetaList(ref name, ref items) if name == &\"rename\" => {\n-                for item in items {\n-                    match item.node {\n-                        ast::MetaNameValue(ref name, ref lit) => {\n-                            let name = self.builder.expr().str(name);\n-                            let expr = self.builder.expr().build_lit(P(lit.clone()));\n-\n-                            self = self.format_rename(name, expr);\n-                        }\n-                        _ => { }\n+                    _ => {\n+                        cx.span_err(\n+                            meta_item.span,\n+                            &format!(\"unknown serde field attribute `{}`\",\n+                                     meta_item_to_string(meta_item)));\n+\n+                        return Err(Error);\n                     }\n                 }\n-\n-                Ok(self)\n-            }\n-            ast::MetaWord(ref name) if name == &\"default\" => {\n-                Ok(self.default())\n-            }\n-            ast::MetaWord(ref name) if name == &\"skip_serializing\" => {\n-                Ok(self.skip_serializing_field())\n-            }\n-            ast::MetaWord(ref name) if name == &\"skip_serializing_if_empty\" => {\n-                Ok(self.skip_serializing_field_if_empty())\n-            }\n-            ast::MetaWord(ref name) if name == &\"skip_serializing_if_none\" => {\n-                Ok(self.skip_serializing_field_if_none())\n-            }\n-            _ => {\n-                self.cx.span_err(\n-                    meta_item.span,\n-                    &format!(\"unknown serde field attribute `{}`\",\n-                             meta_item_to_string(meta_item)));\n-                Err(Error)\n             }\n         }\n-    }\n \n-    pub fn skip_serializing_field(mut self) -> FieldAttrsBuilder<'a> {\n-        self.skip_serializing_field = true;\n-        self\n+        Ok(field_attrs)\n     }\n \n-    pub fn skip_serializing_field_if_empty(mut self) -> FieldAttrsBuilder<'a> {\n-        self.skip_serializing_field_if_empty = true;\n-        self\n+    /// Return the string expression of the field ident.\n+    pub fn ident_expr(&self) -> P<ast::Expr> {\n+        AstBuilder::new().expr().str(self.ident)\n     }\n \n-    pub fn skip_serializing_field_if_none(mut self) -> FieldAttrsBuilder<'a> {\n-        self.skip_serializing_field_if_none = true;\n-        self\n+    /// Return the field name for the field when serializing.\n+    pub fn serialize_name_expr(&self) -> P<ast::Expr> {\n+        match self.serialize_name {\n+            Some(ref name) => AstBuilder::new().expr().build_lit(P(name.clone())),\n+            None => self.ident_expr(),\n+        }\n     }\n \n-    pub fn name(mut self, name: P<ast::Expr>) -> FieldAttrsBuilder<'a> {\n-        self.name = Some(name);\n-        self\n+    /// Return the field name for the field when deserializing.\n+    pub fn deserialize_name_expr(&self) -> P<ast::Expr> {\n+        match self.deserialize_name {\n+            Some(ref name) => AstBuilder::new().expr().build_lit(P(name.clone())),\n+            None => self.ident_expr(),\n+        }\n     }\n \n-    pub fn format_rename(mut self, format: P<ast::Expr>, name: P<ast::Expr>) -> FieldAttrsBuilder<'a> {\n-        self.format_rename.insert(format, name);\n-        self\n+    /// Predicate for using a field's default value\n+    pub fn use_default(&self) -> bool {\n+        self.use_default\n     }\n \n-    pub fn default(mut self) -> FieldAttrsBuilder<'a> {\n-        self.use_default = true;\n-        self\n+    /// Predicate for ignoring a field when serializing a value\n+    pub fn skip_serializing_field(&self) -> bool {\n+        self.skip_serializing_field\n     }\n \n-    pub fn build(self) -> FieldAttrs {\n-        let name = self.name.expect(\"here\");\n-        let names = if self.format_rename.is_empty() {\n-            FieldNames::Global(name)\n-        } else {\n-            FieldNames::Format {\n-                formats: self.format_rename,\n-                default: name,\n-            }\n-        };\n-\n-        FieldAttrs {\n-            skip_serializing_field: self.skip_serializing_field,\n-            skip_serializing_field_if_empty: self.skip_serializing_field_if_empty,\n-            skip_serializing_field_if_none: self.skip_serializing_field_if_none,\n-            names: names,\n-            use_default: self.use_default,\n-        }\n+    pub fn skip_serializing_field_if_empty(&self) -> bool {\n+        self.skip_serializing_field_if_empty\n     }\n-}\n \n-/// Represents container (e.g. struct) attribute information\n-#[derive(Debug)]\n-pub struct ContainerAttrs {\n-    deny_unknown_fields: bool,\n-}\n-\n-impl ContainerAttrs {\n-    pub fn deny_unknown_fields(&self) -> bool {\n-        self.deny_unknown_fields\n+    pub fn skip_serializing_field_if_none(&self) -> bool {\n+        self.skip_serializing_field_if_none\n     }\n }\n \n-pub struct ContainerAttrsBuilder<'a> {\n-    cx: &'a ExtCtxt<'a>,\n-    deny_unknown_fields: bool,\n+/// Extract out the `#[serde(...)]` attributes from a struct field.\n+pub fn get_struct_field_attrs(cx: &ExtCtxt,\n+                              fields: &[ast::StructField]) -> Result<Vec<FieldAttrs>, Error> {\n+    fields.iter()\n+        .map(|field| FieldAttrs::from_field(cx, field))\n+        .collect()\n }\n \n-impl<'a> ContainerAttrsBuilder<'a> {\n-    pub fn new(cx: &'a ExtCtxt) -> Self {\n-        ContainerAttrsBuilder {\n-            cx: cx,\n-            deny_unknown_fields: false,\n-        }\n-    }\n-\n-    pub fn attrs(mut self, attrs: &[ast::Attribute]) -> Result<Self, Error> {\n-        for attr in attrs {\n-            self = try!(self.attr(attr));\n-        }\n-\n-        Ok(self)\n-    }\n+fn get_renames(cx: &ExtCtxt,\n+               items: &[P<ast::MetaItem>]) -> Result<(Option<ast::Lit>, Option<ast::Lit>), Error> {\n+    let mut ser_name = None;\n+    let mut de_name = None;\n \n-    pub fn attr(mut self, attr: &ast::Attribute) -> Result<Self, Error> {\n-        match attr.node.value.node {\n-            ast::MetaList(ref name, ref items) if name == &\"serde\" => {\n-                attr::mark_used(&attr);\n-                for item in items {\n-                    self = try!(self.meta_item(item));\n-                }\n-\n-                Ok(self)\n+    for item in items {\n+        match item.node {\n+            ast::MetaNameValue(ref name, ref lit) if name == &\"serialize\" => {\n+                ser_name = Some(lit.clone());\n             }\n-            _ => {\n-                Ok(self)\n-            }\n-        }\n-    }\n \n-    pub fn meta_item(self, meta_item: &P<ast::MetaItem>) -> Result<Self, Error> {\n-        match meta_item.node {\n-            ast::MetaWord(ref name) if name == &\"deny_unknown_fields\" => {\n-                Ok(self.deny_unknown_fields())\n-            }\n-            _ => {\n-                self.cx.span_err(\n-                    meta_item.span,\n-                    &format!(\"unknown serde container attribute `{}`\",\n-                             meta_item_to_string(meta_item)));\n-                Err(Error)\n+            ast::MetaNameValue(ref name, ref lit) if name == &\"deserialize\" => {\n+                de_name = Some(lit.clone());\n             }\n-        }\n-    }\n \n-    pub fn deny_unknown_fields(mut self) -> Self {\n-        self.deny_unknown_fields = true;\n-        self\n-    }\n+            _ => {\n+                cx.span_err(\n+                    item.span,\n+                    &format!(\"unknown rename attribute `{}`\",\n+                             meta_item_to_string(item)));\n \n-    pub fn build(self) -> ContainerAttrs {\n-        ContainerAttrs {\n-            deny_unknown_fields: self.deny_unknown_fields,\n+                return Err(Error);\n+            }\n         }\n     }\n-}\n \n-/// Extract out the `#[serde(...)]` attributes from an item.\n-pub fn get_container_attrs(cx: &ExtCtxt,\n-                           container: &ast::Item,\n-                          ) -> Result<ContainerAttrs, Error> {\n-    let builder = ContainerAttrsBuilder::new(cx);\n-    let builder = try!(builder.attrs(container.attrs()));\n-    Ok(builder.build())\n+    Ok((ser_name, de_name))\n }\n \n-/// Extract out the `#[serde(...)]` attributes from a struct field.\n-pub fn get_struct_field_attrs(cx: &ExtCtxt,\n-                              builder: &aster::AstBuilder,\n-                              fields: &[ast::StructField]\n-                             ) -> Result<Vec<FieldAttrs>, Error> {\n-    let mut attrs = vec![];\n-    for field in fields {\n-        let builder = FieldAttrsBuilder::new(cx, builder);\n-        let builder = try!(builder.field(field));\n-        let attr = builder.build();\n-        attrs.push(attr);\n+fn get_serde_meta_items(attr: &ast::Attribute) -> Option<&[P<ast::MetaItem>]> {\n+    match attr.node.value.node {\n+        ast::MetaList(ref name, ref items) if name == &\"serde\" => {\n+            attr::mark_used(&attr);\n+            Some(items)\n+        }\n+        _ => None\n     }\n-\n-    Ok(attrs)\n }\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex 5a893e5f9..ea5ed9b6f 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -1,5 +1,3 @@\n-use std::collections::HashSet;\n-\n use aster;\n \n use syntax::ast::{\n@@ -14,8 +12,7 @@ use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n \n-use attr::{self, ContainerAttrs};\n-\n+use attr;\n use error::Error;\n \n pub fn expand_derive_deserialize(\n@@ -88,7 +85,7 @@ fn deserialize_body(\n     impl_generics: &ast::Generics,\n     ty: P<ast::Ty>,\n ) -> Result<P<ast::Expr>, Error> {\n-    let container_attrs = try!(attr::get_container_attrs(cx, item));\n+    let container_attrs = try!(attr::ContainerAttrs::from_item(cx, item));\n \n     match item.node {\n         ast::ItemStruct(ref variant_data, _) => {\n@@ -129,14 +126,14 @@ fn deserialize_item_struct(\n     ty: P<ast::Ty>,\n     span: Span,\n     variant_data: &ast::VariantData,\n-    container_attrs: &ContainerAttrs,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     match *variant_data {\n         ast::VariantData::Unit(_) => {\n             deserialize_unit_struct(\n                 cx,\n-                &builder,\n                 item.ident,\n+                container_attrs,\n             )\n         }\n         ast::VariantData::Tuple(ref fields, _) if fields.len() == 1 => {\n@@ -146,6 +143,7 @@ fn deserialize_item_struct(\n                 item.ident,\n                 impl_generics,\n                 ty,\n+                container_attrs,\n             )\n         }\n         ast::VariantData::Tuple(ref fields, _) => {\n@@ -160,6 +158,7 @@ fn deserialize_item_struct(\n                 impl_generics,\n                 ty,\n                 fields.len(),\n+                container_attrs,\n             )\n         }\n         ast::VariantData::Struct(ref fields, _) => {\n@@ -264,10 +263,10 @@ fn deserializer_ty_arg(builder: &aster::AstBuilder) -> P<ast::Ty>{\n \n fn deserialize_unit_struct(\n     cx: &ExtCtxt,\n-    builder: &aster::AstBuilder,\n     type_ident: Ident,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n-    let type_name = builder.expr().str(type_ident);\n+    let type_name = container_attrs.deserialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         struct __Visitor;\n@@ -301,6 +300,7 @@ fn deserialize_newtype_struct(\n     type_ident: Ident,\n     impl_generics: &ast::Generics,\n     ty: P<ast::Ty>,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     let where_clause = &impl_generics.where_clause;\n \n@@ -318,7 +318,7 @@ fn deserialize_newtype_struct(\n         1,\n     );\n \n-    let type_name = builder.expr().str(type_ident);\n+    let type_name = container_attrs.deserialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         $visitor_item\n@@ -353,6 +353,7 @@ fn deserialize_tuple_struct(\n     impl_generics: &ast::Generics,\n     ty: P<ast::Ty>,\n     fields: usize,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     let where_clause = &impl_generics.where_clause;\n \n@@ -370,7 +371,7 @@ fn deserialize_tuple_struct(\n         fields,\n     );\n \n-    let type_name = builder.expr().str(type_ident);\n+    let type_name = container_attrs.deserialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         $visitor_item\n@@ -478,7 +479,7 @@ fn deserialize_struct(\n     impl_generics: &ast::Generics,\n     ty: P<ast::Ty>,\n     fields: &[ast::StructField],\n-    container_attrs: &ContainerAttrs,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     let where_clause = &impl_generics.where_clause;\n \n@@ -506,7 +507,7 @@ fn deserialize_struct(\n         container_attrs\n     ));\n \n-    let type_name = builder.expr().str(type_ident);\n+    let type_name = container_attrs.deserialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         $field_visitor\n@@ -544,23 +545,23 @@ fn deserialize_item_enum(\n     impl_generics: &ast::Generics,\n     ty: P<ast::Ty>,\n     enum_def: &EnumDef,\n-    container_attrs: &ContainerAttrs\n+    container_attrs: &attr::ContainerAttrs\n ) -> Result<P<ast::Expr>, Error> {\n     let where_clause = &impl_generics.where_clause;\n \n-    let type_name = builder.expr().str(type_ident);\n+    let type_name = container_attrs.deserialize_name_expr();\n \n     let variant_visitor = deserialize_field_visitor(\n         cx,\n         builder,\n-        enum_def.variants.iter()\n-            .map(|variant| {\n-                let expr = builder.expr().str(variant.node.name);\n-                 attr::FieldAttrsBuilder::new(cx, builder)\n-                    .name(expr)\n-                    .build()\n-            })\n-            .collect(),\n+        try!(\n+            enum_def.variants.iter()\n+                .map(|variant| {\n+                    let attrs = try!(attr::VariantAttrs::from_variant(cx, variant));\n+                    Ok(attrs.deserialize_name_expr())\n+                })\n+                .collect()\n+        ),\n         container_attrs,\n     );\n \n@@ -642,7 +643,7 @@ fn deserialize_variant(\n     generics: &ast::Generics,\n     ty: P<ast::Ty>,\n     variant: &ast::Variant,\n-    container_attrs: &ContainerAttrs,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     let variant_ident = variant.node.name;\n \n@@ -735,7 +736,7 @@ fn deserialize_struct_variant(\n     generics: &ast::Generics,\n     ty: P<ast::Ty>,\n     fields: &[ast::StructField],\n-    container_attrs: &ContainerAttrs,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     let where_clause = &generics.where_clause;\n \n@@ -798,11 +799,11 @@ fn deserialize_struct_variant(\n fn deserialize_field_visitor(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n-    field_attrs: Vec<attr::FieldAttrs>,\n-    container_attrs: &ContainerAttrs,\n+    field_names: Vec<P<ast::Expr>>,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Vec<P<ast::Item>> {\n     // Create the field names for the fields.\n-    let field_idents: Vec<ast::Ident> = (0 .. field_attrs.len())\n+    let field_idents: Vec<ast::Ident> = (0 .. field_names.len())\n         .map(|i| builder.id(format!(\"__field{}\", i)))\n         .collect();\n \n@@ -838,19 +839,11 @@ fn deserialize_field_visitor(\n         }\n     );\n \n-    // A set of all the formats that have specialized field attributes\n-    let formats = field_attrs.iter()\n-        .fold(HashSet::new(), |mut set, field_expr| {\n-            set.extend(field_expr.formats());\n-            set\n-        });\n-\n     // Match arms to extract a field from a string\n     let default_field_arms: Vec<_> = field_idents.iter()\n-        .zip(field_attrs.iter())\n-        .map(|(field_ident, field_expr)| {\n-            let expr = field_expr.default_key_expr();\n-            quote_arm!(cx, $expr => { Ok(__Field::$field_ident) })\n+        .zip(field_names.iter())\n+        .map(|(field_ident, field_name)| {\n+            quote_arm!(cx, $field_name => { Ok(__Field::$field_ident) })\n         })\n         .collect();\n \n@@ -860,49 +853,12 @@ fn deserialize_field_visitor(\n         quote_expr!(cx, Err(::serde::de::Error::unknown_field(value)))\n     };\n \n-    let str_body = if formats.is_empty() {\n-        // No formats specific attributes, so no match on format required\n-        quote_expr!(cx,\n-            match value {\n-                $default_field_arms\n-                _ => { $fallthrough_arm_expr }\n-            })\n-    } else {\n-        let field_arms: Vec<_> = formats.iter()\n-            .map(|fmt| {\n-                field_idents.iter()\n-                    .zip(field_attrs.iter())\n-                    .map(|(field_ident, field_expr)| {\n-                        let expr = field_expr.key_expr(fmt);\n-                        quote_arm!(cx, $expr => { Ok(__Field::$field_ident) })\n-                    })\n-                    .collect::<Vec<_>>()\n-            })\n-            .collect();\n-\n-        let fmt_matches: Vec<_> = formats.iter()\n-            .zip(field_arms.iter())\n-            .map(|(ref fmt, ref arms)| {\n-                quote_arm!(cx, $fmt => {\n-                    match value {\n-                        $arms\n-                        _ => {\n-                            $fallthrough_arm_expr\n-                        }\n-                    }})\n-            })\n-            .collect();\n-\n-        quote_expr!(cx,\n-            match __D::format() {\n-                $fmt_matches\n-                _ => match value {\n-                    $default_field_arms\n-                    _ => $fallthrough_arm_expr\n-                }\n-            }\n-        )\n-    };\n+    let str_body = quote_expr!(cx,\n+        match value {\n+            $default_field_arms\n+            _ => $fallthrough_arm_expr\n+        }\n+    );\n \n     let impl_item = quote_item!(cx,\n         impl ::serde::de::Deserialize for __Field {\n@@ -963,12 +919,19 @@ fn deserialize_struct_visitor(\n     builder: &aster::AstBuilder,\n     struct_path: ast::Path,\n     fields: &[ast::StructField],\n-    container_attrs: &ContainerAttrs,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<(Vec<P<ast::Item>>, P<ast::Stmt>, P<ast::Expr>), Error> {\n     let field_visitor = deserialize_field_visitor(\n         cx,\n         builder,\n-        try!(attr::get_struct_field_attrs(cx, builder, fields)),\n+        try!(\n+            fields.iter()\n+                .map(|field| {\n+                    let attrs = try!(attr::FieldAttrs::from_field(cx, field));\n+                    Ok(attrs.deserialize_name_expr())\n+                })\n+                .collect()\n+        ),\n         container_attrs\n     );\n \n@@ -1006,7 +969,7 @@ fn deserialize_map(\n     builder: &aster::AstBuilder,\n     struct_path: ast::Path,\n     fields: &[ast::StructField],\n-    container_attrs: &ContainerAttrs,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     // Create the field names for the fields.\n     let field_names: Vec<ast::Ident> = (0 .. fields.len())\n@@ -1040,33 +1003,16 @@ fn deserialize_map(\n         .chain(ignored_arm.into_iter())\n         .collect();\n \n-    let field_attrs = try!(attr::get_struct_field_attrs(cx, builder, fields));\n+    let field_attrs = try!(attr::get_struct_field_attrs(cx, fields));\n \n-    let extract_values: Vec<P<ast::Stmt>> = field_names.iter()\n+    let extract_values = field_names.iter()\n         .zip(field_attrs.iter())\n         .map(|(field_name, field_attr)| {\n             let missing_expr = if field_attr.use_default() {\n                 quote_expr!(cx, ::std::default::Default::default())\n             } else {\n-                let formats = field_attr.formats();\n-                let arms : Vec<_> = formats.iter()\n-                    .map(|format| {\n-                        let key_expr = field_attr.key_expr(format);\n-                        quote_arm!(cx, $format => { $key_expr })\n-                    })\n-                    .collect();\n-                let default = field_attr.default_key_expr();\n-                if arms.is_empty() {\n-                    quote_expr!(cx, try!(visitor.missing_field($default)))\n-                } else {\n-                    quote_expr!(\n-                        cx,\n-                        try!(visitor.missing_field(\n-                            match __D::format() {\n-                                $arms\n-                                _ => { $default }\n-                            })))\n-                }\n+                let name = field_attr.ident_expr();\n+                quote_expr!(cx, try!(visitor.missing_field($name)))\n             };\n \n             quote_stmt!(cx,\n@@ -1076,7 +1022,7 @@ fn deserialize_map(\n                 };\n             ).unwrap()\n         })\n-        .collect();\n+        .collect::<Vec<_>>();\n \n     let result = builder.expr().struct_path(struct_path)\n         .with_id_exprs(\ndiff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex 7a61c6a22..1c1be6a29 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -84,20 +84,18 @@ fn serialize_body(\n     impl_generics: &ast::Generics,\n     ty: P<ast::Ty>,\n ) -> Result<P<ast::Expr>, Error> {\n-    // Note: While we don't have any container attributes, we still want to try to\n-    // parse them so we can report a proper error if we get passed an unknown attribute.\n-    let _ = try!(attr::get_container_attrs(cx, item));\n+    let container_attrs = try!(attr::ContainerAttrs::from_item(cx, item));\n \n     match item.node {\n         ast::ItemStruct(ref variant_data, _) => {\n             serialize_item_struct(\n                 cx,\n                 builder,\n-                item,\n                 impl_generics,\n                 ty,\n                 item.span,\n                 variant_data,\n+                &container_attrs,\n             )\n         }\n         ast::ItemEnum(ref enum_def, _) => {\n@@ -108,6 +106,7 @@ fn serialize_body(\n                 impl_generics,\n                 ty,\n                 enum_def,\n+                &container_attrs,\n             )\n         }\n         _ => {\n@@ -120,25 +119,23 @@ fn serialize_body(\n fn serialize_item_struct(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n-    item: &Item,\n     impl_generics: &ast::Generics,\n     ty: P<ast::Ty>,\n     span: Span,\n     variant_data: &ast::VariantData,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     match *variant_data {\n         ast::VariantData::Unit(_) => {\n             serialize_unit_struct(\n                 cx,\n-                &builder,\n-                item.ident,\n+                container_attrs,\n             )\n         }\n         ast::VariantData::Tuple(ref fields, _) if fields.len() == 1 => {\n             serialize_newtype_struct(\n                 cx,\n-                &builder,\n-                item.ident,\n+                container_attrs,\n             )\n         }\n         ast::VariantData::Tuple(ref fields, _) => {\n@@ -149,10 +146,10 @@ fn serialize_item_struct(\n             serialize_tuple_struct(\n                 cx,\n                 &builder,\n-                item.ident,\n                 impl_generics,\n                 ty,\n                 fields.len(),\n+                container_attrs,\n             )\n         }\n         ast::VariantData::Struct(ref fields, _) => {\n@@ -163,10 +160,10 @@ fn serialize_item_struct(\n             serialize_struct(\n                 cx,\n                 &builder,\n-                item.ident,\n                 impl_generics,\n                 ty,\n                 fields,\n+                container_attrs,\n             )\n         }\n     }\n@@ -174,10 +171,9 @@ fn serialize_item_struct(\n \n fn serialize_unit_struct(\n     cx: &ExtCtxt,\n-    builder: &aster::AstBuilder,\n-    type_ident: Ident\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n-    let type_name = builder.expr().str(type_ident);\n+    let type_name = container_attrs.serialize_name_expr();\n \n     Ok(quote_expr!(cx,\n         serializer.serialize_unit_struct($type_name)\n@@ -186,10 +182,9 @@ fn serialize_unit_struct(\n \n fn serialize_newtype_struct(\n     cx: &ExtCtxt,\n-    builder: &aster::AstBuilder,\n-    type_ident: Ident\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n-    let type_name = builder.expr().str(type_ident);\n+    let type_name = container_attrs.serialize_name_expr();\n \n     Ok(quote_expr!(cx,\n         serializer.serialize_newtype_struct($type_name, &self.0)\n@@ -199,10 +194,10 @@ fn serialize_newtype_struct(\n fn serialize_tuple_struct(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n-    type_ident: Ident,\n     impl_generics: &ast::Generics,\n     ty: P<ast::Ty>,\n     fields: usize,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     let (visitor_struct, visitor_impl) = serialize_tuple_struct_visitor(\n         cx,\n@@ -216,7 +211,7 @@ fn serialize_tuple_struct(\n         impl_generics,\n     );\n \n-    let type_name = builder.expr().str(type_ident);\n+    let type_name = container_attrs.serialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         $visitor_struct\n@@ -232,10 +227,10 @@ fn serialize_tuple_struct(\n fn serialize_struct(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n-    type_ident: Ident,\n     impl_generics: &ast::Generics,\n     ty: P<ast::Ty>,\n     fields: &[ast::StructField],\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     let value_exprs = fields.iter().map(|field| {\n         let name = field.node.ident().expect(\"struct has unnamed field\");\n@@ -255,7 +250,7 @@ fn serialize_struct(\n         value_exprs,\n     ));\n \n-    let type_name = builder.expr().str(type_ident);\n+    let type_name = container_attrs.serialize_name_expr();\n \n     Ok(quote_expr!(cx, {\n         $visitor_struct\n@@ -275,6 +270,7 @@ fn serialize_item_enum(\n     impl_generics: &ast::Generics,\n     ty: P<ast::Ty>,\n     enum_def: &ast::EnumDef,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<P<ast::Expr>, Error> {\n     let mut arms = vec![];\n \n@@ -287,6 +283,7 @@ fn serialize_item_enum(\n             ty.clone(),\n             variant,\n             variant_index,\n+            container_attrs,\n         ));\n \n         arms.push(arm);\n@@ -307,10 +304,13 @@ fn serialize_variant(\n     ty: P<ast::Ty>,\n     variant: &ast::Variant,\n     variant_index: usize,\n+    container_attrs: &attr::ContainerAttrs,\n ) -> Result<ast::Arm, Error> {\n-    let type_name = builder.expr().str(type_ident);\n+    let type_name = container_attrs.serialize_name_expr();\n+\n     let variant_ident = variant.node.name;\n-    let variant_name = builder.expr().str(variant_ident);\n+    let variant_attrs = try!(attr::VariantAttrs::from_variant(cx, variant));\n+    let variant_name = variant_attrs.serialize_name_expr();\n \n     match variant.node.data {\n         ast::VariantData::Unit(_) => {\n@@ -605,14 +605,14 @@ fn serialize_struct_visitor<I>(\n {\n     let value_exprs = value_exprs.collect::<Vec<_>>();\n \n-    let field_attrs = try!(attr::get_struct_field_attrs(cx, builder, fields));\n+    let field_attrs = try!(attr::get_struct_field_attrs(cx, fields));\n \n     let arms: Vec<ast::Arm> = field_attrs.iter()\n         .zip(value_exprs.iter())\n         .filter(|&(ref field, _)| !field.skip_serializing_field())\n         .enumerate()\n         .map(|(i, (ref field, value_expr))| {\n-            let key_expr = field.serializer_key_expr(cx);\n+            let key_expr = field.serialize_name_expr();\n \n             let stmt = if field.skip_serializing_field_if_empty() {\n                 quote_stmt!(cx, if ($value_expr).is_empty() { continue; })\n", "test_patch": "diff --git a/serde_tests/tests/test_annotations.rs b/serde_tests/tests/test_annotations.rs\nindex dc91b9b5d..82f1265e2 100644\n--- a/serde_tests/tests/test_annotations.rs\n+++ b/serde_tests/tests/test_annotations.rs\n@@ -23,24 +23,44 @@ struct DisallowUnknown {\n }\n \n #[derive(Debug, PartialEq, Serialize, Deserialize)]\n-struct Rename {\n+#[serde(rename=\"Superhero\")]\n+struct RenameStruct {\n     a1: i32,\n     #[serde(rename=\"a3\")]\n     a2: i32,\n }\n \n #[derive(Debug, PartialEq, Serialize, Deserialize)]\n-struct FormatRename {\n+#[serde(rename(serialize=\"SuperheroSer\", deserialize=\"SuperheroDe\"))]\n+struct RenameStructSerializeDeserialize {\n     a1: i32,\n-    #[serde(rename(xml= \"a4\", token=\"a5\"))]\n+    #[serde(rename(serialize=\"a4\", deserialize=\"a5\"))]\n     a2: i32,\n }\n \n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+#[serde(rename=\"Superhero\")]\n+enum RenameEnum {\n+    #[serde(rename=\"bruce_wayne\")]\n+    Batman,\n+    #[serde(rename=\"clark_kent\")]\n+    Superman(i8),\n+    #[serde(rename=\"diana_prince\")]\n+    WonderWoman(i8, i8),\n+    #[serde(rename=\"barry_allan\")]\n+    Flash {\n+        #[serde(rename=\"b\")]\n+        a: i32,\n+    },\n+}\n+\n #[derive(Debug, PartialEq, Deserialize, Serialize)]\n-enum SerEnum<A> {\n-    Map {\n+#[serde(rename(serialize=\"SuperheroSer\", deserialize=\"SuperheroDe\"))]\n+enum RenameEnumSerializeDeserialize<A> {\n+    #[serde(rename(serialize=\"dick_grayson\", deserialize=\"jason_todd\"))]\n+    Robin {\n         a: i8,\n-        #[serde(rename(xml= \"c\", token=\"d\"))]\n+        #[serde(rename(serialize=\"c\", deserialize=\"d\"))]\n         b: A,\n     },\n }\n@@ -153,11 +173,11 @@ fn test_ignore_unknown() {\n }\n \n #[test]\n-fn test_rename() {\n+fn test_rename_struct() {\n     assert_tokens(\n-        &Rename { a1: 1, a2: 2 },\n+        &RenameStruct { a1: 1, a2: 2 },\n         vec![\n-            Token::StructStart(\"Rename\", Some(2)),\n+            Token::StructStart(\"Superhero\", Some(2)),\n \n             Token::MapSep,\n             Token::Str(\"a1\"),\n@@ -173,11 +193,28 @@ fn test_rename() {\n }\n \n #[test]\n-fn test_format_rename() {\n-    assert_tokens(\n-        &FormatRename { a1: 1, a2: 2 },\n+fn test_rename_struct_serialize_deserialize() {\n+    assert_ser_tokens(\n+        &RenameStructSerializeDeserialize { a1: 1, a2: 2 },\n+        &[\n+            Token::StructStart(\"SuperheroSer\", Some(2)),\n+\n+            Token::MapSep,\n+            Token::Str(\"a1\"),\n+            Token::I32(1),\n+\n+            Token::MapSep,\n+            Token::Str(\"a4\"),\n+            Token::I32(2),\n+\n+            Token::MapEnd,\n+        ]\n+    );\n+\n+    assert_de_tokens(\n+        &RenameStructSerializeDeserialize { a1: 1, a2: 2 },\n         vec![\n-            Token::StructStart(\"FormatRename\", Some(2)),\n+            Token::StructStart(\"SuperheroDe\", Some(2)),\n \n             Token::MapSep,\n             Token::Str(\"a1\"),\n@@ -193,14 +230,80 @@ fn test_format_rename() {\n }\n \n #[test]\n-fn test_enum_format_rename() {\n+fn test_rename_enum() {\n+    assert_tokens(\n+        &RenameEnum::Batman,\n+        vec![\n+            Token::EnumUnit(\"Superhero\", \"bruce_wayne\"),\n+        ]\n+    );\n+\n+    assert_tokens(\n+        &RenameEnum::Superman(0),\n+        vec![\n+            Token::EnumNewtype(\"Superhero\", \"clark_kent\"),\n+            Token::I8(0),\n+        ]\n+    );\n+\n+    assert_tokens(\n+        &RenameEnum::WonderWoman(0, 1),\n+        vec![\n+            Token::EnumSeqStart(\"Superhero\", \"diana_prince\", Some(2)),\n+\n+            Token::SeqSep,\n+            Token::I8(0),\n+\n+            Token::SeqSep,\n+            Token::I8(1),\n+\n+            Token::SeqEnd,\n+        ]\n+    );\n+\n     assert_tokens(\n-        &SerEnum::Map {\n+        &RenameEnum::Flash { a: 1 },\n+        vec![\n+            Token::EnumMapStart(\"Superhero\", \"barry_allan\", Some(1)),\n+\n+            Token::MapSep,\n+            Token::Str(\"b\"),\n+            Token::I32(1),\n+\n+            Token::MapEnd,\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn test_enum_serialize_deserialize() {\n+    assert_ser_tokens(\n+        &RenameEnumSerializeDeserialize::Robin {\n+            a: 0,\n+            b: String::new(),\n+        },\n+        &[\n+            Token::EnumMapStart(\"SuperheroSer\", \"dick_grayson\", Some(2)),\n+\n+            Token::MapSep,\n+            Token::Str(\"a\"),\n+            Token::I8(0),\n+\n+            Token::MapSep,\n+            Token::Str(\"c\"),\n+            Token::Str(\"\"),\n+\n+            Token::MapEnd,\n+        ]\n+    );\n+\n+    assert_de_tokens(\n+        &RenameEnumSerializeDeserialize::Robin {\n             a: 0,\n             b: String::new(),\n         },\n         vec![\n-            Token::EnumMapStart(\"SerEnum\", \"Map\", Some(2)),\n+            Token::EnumMapStart(\"SuperheroDe\", \"jason_todd\", Some(2)),\n \n             Token::MapSep,\n             Token::Str(\"a\"),\ndiff --git a/serde_tests/tests/token.rs b/serde_tests/tests/token.rs\nindex b11705113..1b14a7d36 100644\n--- a/serde_tests/tests/token.rs\n+++ b/serde_tests/tests/token.rs\n@@ -301,10 +301,6 @@ impl<'a, I> ser::Serializer for Serializer<I>\n         try!(key.serialize(self));\n         value.serialize(self)\n     }\n-\n-    fn format() -> &'static str {\n-        \"token\"\n-    }\n }\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -583,10 +579,6 @@ impl<I> de::Deserializer for Deserializer<I>\n             None => Err(Error::EndOfStreamError),\n         }\n     }\n-\n-    fn format() -> &'static str {\n-        \"token\"\n-    }\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Consider removing format specific renames\ncc @hugoduncan.\n\nI did a quick search through github, and I couldn't find anyone using `#[serde(rename(json=..., xml=...))]` and etc. I'm not sure if it's pulling it's weight and I'm considering removing it in the upcoming 0.7.0 release. This is also adding some complication in #207. Does anyone have any arguments towards keeping it?\n\n#[serde(rename=...)] should apply to containers\nAs in:\n\n``` rust\n#[derive(Serialize, Deserialize)]\n#[serde(rename = \"foo\")]\nstruct Foo {\n    x: u32,\n}\n```\n\nShould serialize the structure with the name `\"foo\"`.\n\n", "hints_text": "I'm using it in my AWS code, as the names used in the XML replies from\nAWS don't match the names used in their API requests.\n\nHaving said that I haven't found time to work on anything in rust in the\nlast few months.\n\n@hugoduncan: Do you have your code online? I did find another rust AWS API client, [rusoto](https://github.com/rusoto/rusoto), but I didn't see you in the contributors, nor does it seem to be doing any field renames. Are your serialized structures using multiple renames, or are you just doing a rename for the xml replies? Because that could be captured by just `#[serde(rename=\"xyz\")]`.\n\nCode is here: https://bitbucket.org/hugoduncan/rust-awaze\n\nIt is doing multiple renames.  I wanted idiomatic rust variable names,\nwhich resemble neither the XML response name, nor the request name.\n\nFor example: `vpc_id`, is `vpcId` in XML responses and `VpcId` in\nrequests.\n\n@hugoduncan: I just looked through awaze, and I still see that you're using `#[serde(rename_serialize=..., rename_deserialize=...)]` that you removed in #69. Did you end up using the code you implemented in #69 somewhere else?\n\nps: amazon is very silly to return different names here :)\n\n", "created_at": "2016-02-08T06:07:45Z", "version": "0.6"}, {"repo": "serde-rs/serde", "pull_number": 224, "instance_id": "serde-rs__serde-224", "issue_numbers": ["57"], "base_commit": "9ae47a261e2e2f7dacc44c91e315fc90675e4e4b", "patch": "diff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex 7d01a384d..cc20f9b60 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -27,6 +27,7 @@ use std::sync::Arc;\n use core::nonzero::{NonZero, Zeroable};\n \n use super::{\n+    Error,\n     Serialize,\n     Serializer,\n     SeqVisitor,\n@@ -682,7 +683,10 @@ impl Serialize for path::Path {\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n         where S: Serializer,\n     {\n-        self.to_str().unwrap().serialize(serializer)\n+        match self.to_str() {\n+            Some(s) => s.serialize(serializer),\n+            None => Err(Error::invalid_value(\"Path contains invalid UTF-8 characters\")),\n+        }\n     }\n }\n \n@@ -690,7 +694,7 @@ impl Serialize for path::PathBuf {\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n         where S: Serializer,\n     {\n-        self.to_str().unwrap().serialize(serializer)\n+        self.as_path().serialize(serializer)\n     }\n }\n \ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 19dd82120..64bdbdfa1 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -1,9 +1,25 @@\n //! Generic serialization framework.\n \n+use std::error;\n+\n pub mod impls;\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+/// `Error` is a trait that allows a `Serialize` to generically create a\n+/// `Serializer` error.\n+pub trait Error: Sized + error::Error {\n+    /// Raised when there is general error when deserializing a type.\n+    fn syntax(msg: &str) -> Self;\n+\n+    /// Raised when a `Serialize` was passed an incorrect value.\n+    fn invalid_value(msg: &str) -> Self {\n+        Error::syntax(msg)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n /// A trait that describes a type that can be serialized by a `Serializer`.\n pub trait Serialize {\n     /// Serializes this value into this serializer.\n@@ -16,7 +32,7 @@ pub trait Serialize {\n /// A trait that describes a type that can serialize a stream of values into the underlying format.\n pub trait Serializer {\n     /// The error type that can be returned if some error occurs during serialization.\n-    type Error;\n+    type Error: Error;\n \n     /// Serializes a `bool` value.\n     fn serialize_bool(&mut self, v: bool) -> Result<(), Self::Error>;\n", "test_patch": "diff --git a/serde_tests/tests/test_bytes.rs b/serde_tests/tests/test_bytes.rs\nindex 137d00986..785ff5503 100644\n--- a/serde_tests/tests/test_bytes.rs\n+++ b/serde_tests/tests/test_bytes.rs\n@@ -9,6 +9,12 @@ use serde::bytes::{ByteBuf, Bytes};\n #[derive(Debug, PartialEq)]\n struct Error;\n \n+impl serde::ser::Error for Error {\n+    fn syntax(_: &str) -> Error { Error }\n+\n+    fn invalid_value(_field: &str) -> Error { Error }\n+}\n+\n impl serde::de::Error for Error {\n     fn syntax(_: &str) -> Error { Error }\n \ndiff --git a/serde_tests/tests/test_ser.rs b/serde_tests/tests/test_ser.rs\nindex 7fbae4e47..77bf3eb84 100644\n--- a/serde_tests/tests/test_ser.rs\n+++ b/serde_tests/tests/test_ser.rs\n@@ -1,12 +1,13 @@\n use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n+use std::str;\n \n use num::FromPrimitive;\n use num::bigint::{BigInt, BigUint};\n use num::complex::Complex;\n use num::rational::Ratio;\n \n-use token::Token;\n+use token::{self, Token};\n \n //////////////////////////////////////////////////////////////////////////\n \n@@ -305,3 +306,22 @@ declare_ser_tests! {\n         ],\n     }\n }\n+\n+#[test]\n+fn test_cannot_serialize_paths() {\n+    let path = unsafe {\n+        str::from_utf8_unchecked(b\"Hello \\xF0\\x90\\x80World\")\n+    };\n+    token::assert_ser_tokens_error(\n+        &Path::new(path),\n+        &[Token::Str(\"Hello \ufffdWorld\")],\n+        token::Error::InvalidValue(\"Path contains invalid UTF-8 characters\".to_owned()));\n+\n+    let mut path_buf = PathBuf::new();\n+    path_buf.push(path);\n+\n+    token::assert_ser_tokens_error(\n+        &path_buf,\n+        &[Token::Str(\"Hello \ufffdWorld\")],\n+        token::Error::InvalidValue(\"Path contains invalid UTF-8 characters\".to_owned()));\n+}\ndiff --git a/serde_tests/tests/token.rs b/serde_tests/tests/token.rs\nindex 435025675..b11705113 100644\n--- a/serde_tests/tests/token.rs\n+++ b/serde_tests/tests/token.rs\n@@ -64,7 +64,7 @@ impl<'a, I> Serializer<I>\n         }\n     }\n \n-    fn visit_sequence<V>(&mut self, mut visitor: V) -> Result<(), ()>\n+    fn visit_sequence<V>(&mut self, mut visitor: V) -> Result<(), Error>\n         where V: ser::SeqVisitor\n     {\n         while let Some(()) = try!(visitor.visit(self)) { }\n@@ -74,7 +74,7 @@ impl<'a, I> Serializer<I>\n         Ok(())\n     }\n \n-    fn visit_mapping<V>(&mut self, mut visitor: V) -> Result<(), ()>\n+    fn visit_mapping<V>(&mut self, mut visitor: V) -> Result<(), Error>\n         where V: ser::MapVisitor\n     {\n         while let Some(()) = try!(visitor.visit(self)) { }\n@@ -88,9 +88,9 @@ impl<'a, I> Serializer<I>\n impl<'a, I> ser::Serializer for Serializer<I>\n     where I: Iterator<Item=&'a Token<'a>>,\n {\n-    type Error = ();\n+    type Error = Error;\n \n-    fn serialize_unit(&mut self) -> Result<(), ()> {\n+    fn serialize_unit(&mut self) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::Unit));\n         Ok(())\n     }\n@@ -99,14 +99,14 @@ impl<'a, I> ser::Serializer for Serializer<I>\n                                 name: &str,\n                                 _variant_index: usize,\n                                 variant: &str,\n-                                value: T) -> Result<(), ()>\n+                                value: T) -> Result<(), Error>\n         where T: ser::Serialize,\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::EnumNewtype(name, variant)));\n         value.serialize(self)\n     }\n \n-    fn serialize_unit_struct(&mut self, name: &str) -> Result<(), ()> {\n+    fn serialize_unit_struct(&mut self, name: &str) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::UnitStruct(name)));\n         Ok(())\n     }\n@@ -114,93 +114,93 @@ impl<'a, I> ser::Serializer for Serializer<I>\n     fn serialize_unit_variant(&mut self,\n                           name: &str,\n                           _variant_index: usize,\n-                          variant: &str) -> Result<(), ()> {\n+                          variant: &str) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::EnumUnit(name, variant)));\n \n         Ok(())\n     }\n \n-    fn serialize_bool(&mut self, v: bool) -> Result<(), ()> {\n+    fn serialize_bool(&mut self, v: bool) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::Bool(v)));\n         Ok(())\n     }\n \n-    fn serialize_isize(&mut self, v: isize) -> Result<(), ()> {\n+    fn serialize_isize(&mut self, v: isize) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::Isize(v)));\n         Ok(())\n     }\n \n-    fn serialize_i8(&mut self, v: i8) -> Result<(), ()> {\n+    fn serialize_i8(&mut self, v: i8) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::I8(v)));\n         Ok(())\n     }\n \n-    fn serialize_i16(&mut self, v: i16) -> Result<(), ()> {\n+    fn serialize_i16(&mut self, v: i16) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::I16(v)));\n         Ok(())\n     }\n \n-    fn serialize_i32(&mut self, v: i32) -> Result<(), ()> {\n+    fn serialize_i32(&mut self, v: i32) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::I32(v)));\n         Ok(())\n     }\n \n-    fn serialize_i64(&mut self, v: i64) -> Result<(), ()> {\n+    fn serialize_i64(&mut self, v: i64) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::I64(v)));\n         Ok(())\n     }\n \n-    fn serialize_usize(&mut self, v: usize) -> Result<(), ()> {\n+    fn serialize_usize(&mut self, v: usize) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::Usize(v)));\n         Ok(())\n     }\n \n-    fn serialize_u8(&mut self, v: u8) -> Result<(), ()> {\n+    fn serialize_u8(&mut self, v: u8) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::U8(v)));\n         Ok(())\n     }\n \n-    fn serialize_u16(&mut self, v: u16) -> Result<(), ()> {\n+    fn serialize_u16(&mut self, v: u16) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::U16(v)));\n         Ok(())\n     }\n \n-    fn serialize_u32(&mut self, v: u32) -> Result<(), ()> {\n+    fn serialize_u32(&mut self, v: u32) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::U32(v)));\n         Ok(())\n     }\n \n-    fn serialize_u64(&mut self, v: u64) -> Result<(), ()> {\n+    fn serialize_u64(&mut self, v: u64) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::U64(v)));\n         Ok(())\n     }\n \n-    fn serialize_f32(&mut self, v: f32) -> Result<(), ()> {\n+    fn serialize_f32(&mut self, v: f32) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::F32(v)));\n         Ok(())\n     }\n \n-    fn serialize_f64(&mut self, v: f64) -> Result<(), ()> {\n+    fn serialize_f64(&mut self, v: f64) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::F64(v)));\n         Ok(())\n     }\n \n-    fn serialize_char(&mut self, v: char) -> Result<(), ()> {\n+    fn serialize_char(&mut self, v: char) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::Char(v)));\n         Ok(())\n     }\n \n-    fn serialize_str(&mut self, v: &str) -> Result<(), ()> {\n+    fn serialize_str(&mut self, v: &str) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::Str(v)));\n         Ok(())\n     }\n \n-    fn serialize_none(&mut self) -> Result<(), ()> {\n+    fn serialize_none(&mut self) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::Option(false)));\n         Ok(())\n     }\n \n-    fn serialize_some<V>(&mut self, value: V) -> Result<(), ()>\n+    fn serialize_some<V>(&mut self, value: V) -> Result<(), Error>\n         where V: ser::Serialize,\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::Option(true)));\n@@ -208,7 +208,7 @@ impl<'a, I> ser::Serializer for Serializer<I>\n     }\n \n \n-    fn serialize_seq<V>(&mut self, visitor: V) -> Result<(), ()>\n+    fn serialize_seq<V>(&mut self, visitor: V) -> Result<(), Error>\n         where V: ser::SeqVisitor\n     {\n         let len = visitor.len();\n@@ -220,14 +220,14 @@ impl<'a, I> ser::Serializer for Serializer<I>\n \n     fn serialize_newtype_struct<T>(&mut self,\n                                name: &'static str,\n-                               value: T) -> Result<(), ()>\n+                               value: T) -> Result<(), Error>\n         where T: ser::Serialize,\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::StructNewtype(name)));\n         value.serialize(self)\n     }\n \n-    fn serialize_tuple_struct<V>(&mut self, name: &str, visitor: V) -> Result<(), ()>\n+    fn serialize_tuple_struct<V>(&mut self, name: &str, visitor: V) -> Result<(), Error>\n         where V: ser::SeqVisitor\n     {\n         let len = visitor.len();\n@@ -241,7 +241,7 @@ impl<'a, I> ser::Serializer for Serializer<I>\n                               name: &str,\n                               _variant_index: usize,\n                               variant: &str,\n-                              visitor: V) -> Result<(), ()>\n+                              visitor: V) -> Result<(), Error>\n         where V: ser::SeqVisitor\n     {\n         let len = visitor.len();\n@@ -251,14 +251,14 @@ impl<'a, I> ser::Serializer for Serializer<I>\n         self.visit_sequence(visitor)\n     }\n \n-    fn serialize_seq_elt<T>(&mut self, value: T) -> Result<(), ()>\n+    fn serialize_seq_elt<T>(&mut self, value: T) -> Result<(), Error>\n         where T: ser::Serialize\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::SeqSep));\n         value.serialize(self)\n     }\n \n-    fn serialize_map<V>(&mut self, visitor: V) -> Result<(), ()>\n+    fn serialize_map<V>(&mut self, visitor: V) -> Result<(), Error>\n         where V: ser::MapVisitor\n     {\n         let len = visitor.len();\n@@ -268,7 +268,7 @@ impl<'a, I> ser::Serializer for Serializer<I>\n         self.visit_mapping(visitor)\n     }\n \n-    fn serialize_struct<V>(&mut self, name: &str, visitor: V) -> Result<(), ()>\n+    fn serialize_struct<V>(&mut self, name: &str, visitor: V) -> Result<(), Error>\n         where V: ser::MapVisitor\n     {\n         let len = visitor.len();\n@@ -282,7 +282,7 @@ impl<'a, I> ser::Serializer for Serializer<I>\n                                name: &str,\n                                _variant_index: usize,\n                                variant: &str,\n-                               visitor: V) -> Result<(), ()>\n+                               visitor: V) -> Result<(), Error>\n         where V: ser::MapVisitor\n     {\n         let len = visitor.len();\n@@ -292,7 +292,7 @@ impl<'a, I> ser::Serializer for Serializer<I>\n         self.visit_mapping(visitor)\n     }\n \n-    fn serialize_map_elt<K, V>(&mut self, key: K, value: V) -> Result<(), ()>\n+    fn serialize_map_elt<K, V>(&mut self, key: K, value: V) -> Result<(), Error>\n         where K: ser::Serialize,\n               V: ser::Serialize,\n     {\n@@ -316,10 +316,19 @@ pub enum Error {\n     UnknownFieldError(String),\n     MissingFieldError(&'static str),\n     InvalidName(&'static str),\n+    InvalidValue(String),\n     UnexpectedToken(Token<'static>),\n     ValueError(value::Error),\n }\n \n+impl ser::Error for Error {\n+    fn syntax(_: &str) -> Error { Error::SyntaxError }\n+\n+    fn invalid_value(msg: &str) -> Error {\n+        Error::InvalidValue(msg.to_owned())\n+    }\n+}\n+\n impl de::Error for Error {\n     fn syntax(_: &str) -> Error { Error::SyntaxError }\n \n@@ -789,6 +798,15 @@ pub fn assert_ser_tokens<T>(value: &T, tokens: &[Token])\n     assert_eq!(ser.tokens.next(), None);\n }\n \n+// Expect an error deserializing tokens into a T\n+pub fn assert_ser_tokens_error<T>(value: &T, tokens: &[Token], error: Error)\n+    where T: ser::Serialize + PartialEq + fmt::Debug,\n+{\n+    let mut ser = Serializer::new(tokens.iter());\n+    let v: Result<(), Error> = ser::Serialize::serialize(value, &mut ser);\n+    assert_eq!(v.as_ref(), Err(&error));\n+}\n+\n pub fn assert_de_tokens<T>(value: &T, tokens: Vec<Token<'static>>)\n     where T: de::Deserialize + PartialEq + fmt::Debug,\n {\n@@ -804,7 +822,7 @@ pub fn assert_de_tokens_error<T>(tokens: Vec<Token<'static>>, error: Error)\n {\n     let mut de = Deserializer::new(tokens.into_iter());\n     let v: Result<T, Error> = de::Deserialize::deserialize(&mut de);\n-    assert_eq!(v.as_ref(), Err(&error));\n+    assert_eq!(v, Err(error));\n }\n \n // Tests that the given token stream is ignorable when embedded in\n", "problem_statement": "`Path` serialization can panic\nThe `Serialize` implementation of `Path` incorrectly assumes that all paths can be represented as Unicode strings.\n\n", "hints_text": "Good point! Should be simple enough to have it return a syntax error if it gets a non-unicode string.\n\nerr, rather tries to serialize to a non-unicode string. So it could either just be serialized as a byte string, or we first try to encode it as a string, then fail back to a byte string if it's non-unicode.\n\nWhat should happen if you serialize the path `\\xff` on Linux and try to deserialize that on Windows? Similarly, what happens if you serialize a lone surrogate on Windows and try to deserialize that on Linux?\n\nActually, what about path delimiters? :( Should serialization/deserialization even work across systems? What happens for `usize`-incompatiblities?\n\n@tbu-: ah the madness of cross platform things. This is one area where I'm looking forward to #198, which eases overriding which serializer gets used for a field. That'd allow someone with more specific knowledge than serde about how something would get used.\n\nFor a default, I'd just rather have serde be able to serialize and deserialize the value and get the same results. It's more up to the serializers/deserializers/users to decide if they need to conform the serialized format to some well defined schema.\n", "created_at": "2016-01-28T18:41:45Z", "version": "0.6"}, {"repo": "serde-rs/serde", "pull_number": 139, "instance_id": "serde-rs__serde-139", "issue_numbers": ["122"], "base_commit": "7b773ac08880adece2f1bd809efcbd5828b23293", "patch": "diff --git a/serde_json/src/error.rs b/serde_json/src/error.rs\nindex 6621188bb..6c3a494c9 100644\n--- a/serde_json/src/error.rs\n+++ b/serde_json/src/error.rs\n@@ -2,6 +2,7 @@ use std::error;\n use std::fmt;\n use std::io;\n use std::result;\n+use std::string::FromUtf8Error;\n \n use serde::de;\n \n@@ -44,7 +45,6 @@ impl fmt::Debug for ErrorCode {\n         use std::fmt::Debug;\n \n         match *self {\n-            //ErrorCode::ConversionError(ref token) => write!(f, \"failed to convert {}\", token),\n             ErrorCode::EOFWhileParsingList => \"EOF While parsing list\".fmt(f),\n             ErrorCode::EOFWhileParsingObject => \"EOF While parsing object\".fmt(f),\n             ErrorCode::EOFWhileParsingString => \"EOF While parsing string\".fmt(f),\n@@ -61,7 +61,6 @@ impl fmt::Debug for ErrorCode {\n             ErrorCode::ExpectedObjectCommaOrEnd => \"expected `,` or `}`\".fmt(f),\n             ErrorCode::ExpectedSomeIdent => \"expected ident\".fmt(f),\n             ErrorCode::ExpectedSomeValue => \"expected value\".fmt(f),\n-            //ErrorCode::ExpectedTokens(ref token, tokens) => write!(f, \"expected {}, found {}\", tokens, token),\n             ErrorCode::InvalidEscape => \"invalid escape\".fmt(f),\n             ErrorCode::InvalidNumber => \"invalid number\".fmt(f),\n             ErrorCode::InvalidUnicodeCodePoint => \"invalid unicode code point\".fmt(f),\n@@ -73,7 +72,6 @@ impl fmt::Debug for ErrorCode {\n             ErrorCode::NotUtf8 => \"contents not utf-8\".fmt(f),\n             ErrorCode::TrailingCharacters => \"trailing characters\".fmt(f),\n             ErrorCode::UnexpectedEndOfHexEscape => \"unexpected end of hex escape\".fmt(f),\n-            //ErrorCode::UnexpectedName(ref name) => write!(f, \"unexpected name {}\", name),\n             ErrorCode::UnknownVariant => \"unknown variant\".fmt(f),\n             ErrorCode::UnrecognizedHex => \"invalid \\\\u escape (unrecognized hex)\".fmt(f),\n         }\n@@ -85,13 +83,8 @@ pub enum Error {\n     /// msg, line, col\n     SyntaxError(ErrorCode, usize, usize),\n     IoError(io::Error),\n-    /*\n-    ExpectedError(String, String),\n-    */\n     MissingFieldError(&'static str),\n-    /*\n-    UnknownVariantError(String),\n-    */\n+    FromUtf8Error(FromUtf8Error),\n }\n \n impl error::Error for Error {\n@@ -99,19 +92,15 @@ impl error::Error for Error {\n         match *self {\n             Error::SyntaxError(..) => \"syntax error\",\n             Error::IoError(ref error) => error::Error::description(error),\n-            /*\n-            Error::ExpectedError(ref expected, _) => &expected,\n-            */\n             Error::MissingFieldError(_) => \"missing field\",\n-            /*\n-            Error::UnknownVariantError(_) => \"unknown variant\",\n-            */\n+            Error::FromUtf8Error(ref error) => error.description(),\n         }\n     }\n \n     fn cause(&self) -> Option<&error::Error> {\n         match *self {\n             Error::IoError(ref error) => Some(error),\n+            Error::FromUtf8Error(ref error) => Some(error),\n             _ => None,\n         }\n     }\n@@ -125,19 +114,10 @@ impl fmt::Display for Error {\n                 write!(fmt, \"{:?} at line {} column {}\", code, line, col)\n             }\n             Error::IoError(ref error) => fmt::Display::fmt(error, fmt),\n-            /*\n-            Error::ExpectedError(ref expected, ref found) => {\n-                Some(format!(\"expected {}, found {}\", expected, found))\n-            }\n-            */\n+            Error::FromUtf8Error(ref error) => fmt::Display::fmt(error, fmt),\n             Error::MissingFieldError(ref field) => {\n                 write!(fmt, \"missing field {}\", field)\n             }\n-            /*\n-            Error::UnknownVariantError(ref variant) => {\n-                Some(format!(\"unknown variant {}\", variant))\n-            }\n-            */\n         }\n     }\n }\n@@ -148,6 +128,12 @@ impl From<io::Error> for Error {\n     }\n }\n \n+impl From<FromUtf8Error> for Error {\n+    fn from(error: FromUtf8Error) -> Error {\n+        Error::FromUtf8Error(error)\n+    }\n+}\n+\n impl From<de::value::Error> for Error {\n     fn from(error: de::value::Error) -> Error {\n         match error {\ndiff --git a/serde_json/src/ser.rs b/serde_json/src/ser.rs\nindex b03ce38bb..094022f57 100644\n--- a/serde_json/src/ser.rs\n+++ b/serde_json/src/ser.rs\n@@ -1,8 +1,8 @@\n use std::io;\n use std::num::FpCategory;\n-use std::string::FromUtf8Error;\n \n use serde::ser;\n+use super::error::{Error, ErrorCode, Result};\n \n /// A structure for implementing serialization to JSON.\n pub struct Serializer<W, F=CompactFormatter> {\n@@ -60,109 +60,109 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n     where W: io::Write,\n           F: Formatter,\n {\n-    type Error = io::Error;\n+    type Error = Error;\n \n     #[inline]\n-    fn visit_bool(&mut self, value: bool) -> io::Result<()> {\n+    fn visit_bool(&mut self, value: bool) -> Result<()> {\n         if value {\n-            self.writer.write_all(b\"true\")\n+            self.writer.write_all(b\"true\").map_err(From::from)\n         } else {\n-            self.writer.write_all(b\"false\")\n+            self.writer.write_all(b\"false\").map_err(From::from)\n         }\n     }\n \n     #[inline]\n-    fn visit_isize(&mut self, value: isize) -> io::Result<()> {\n-        write!(&mut self.writer, \"{}\", value)\n+    fn visit_isize(&mut self, value: isize) -> Result<()> {\n+        write!(&mut self.writer, \"{}\", value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_i8(&mut self, value: i8) -> io::Result<()> {\n-        write!(&mut self.writer, \"{}\", value)\n+    fn visit_i8(&mut self, value: i8) -> Result<()> {\n+        write!(&mut self.writer, \"{}\", value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_i16(&mut self, value: i16) -> io::Result<()> {\n-        write!(&mut self.writer, \"{}\", value)\n+    fn visit_i16(&mut self, value: i16) -> Result<()> {\n+        write!(&mut self.writer, \"{}\", value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_i32(&mut self, value: i32) -> io::Result<()> {\n-        write!(&mut self.writer, \"{}\", value)\n+    fn visit_i32(&mut self, value: i32) -> Result<()> {\n+        write!(&mut self.writer, \"{}\", value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_i64(&mut self, value: i64) -> io::Result<()> {\n-        write!(&mut self.writer, \"{}\", value)\n+    fn visit_i64(&mut self, value: i64) -> Result<()> {\n+        write!(&mut self.writer, \"{}\", value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_usize(&mut self, value: usize) -> io::Result<()> {\n-        write!(&mut self.writer, \"{}\", value)\n+    fn visit_usize(&mut self, value: usize) -> Result<()> {\n+        write!(&mut self.writer, \"{}\", value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_u8(&mut self, value: u8) -> io::Result<()> {\n-        write!(&mut self.writer, \"{}\", value)\n+    fn visit_u8(&mut self, value: u8) -> Result<()> {\n+        write!(&mut self.writer, \"{}\", value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_u16(&mut self, value: u16) -> io::Result<()> {\n-        write!(&mut self.writer, \"{}\", value)\n+    fn visit_u16(&mut self, value: u16) -> Result<()> {\n+        write!(&mut self.writer, \"{}\", value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_u32(&mut self, value: u32) -> io::Result<()> {\n-        write!(&mut self.writer, \"{}\", value)\n+    fn visit_u32(&mut self, value: u32) -> Result<()> {\n+        write!(&mut self.writer, \"{}\", value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_u64(&mut self, value: u64) -> io::Result<()> {\n-        write!(&mut self.writer, \"{}\", value)\n+    fn visit_u64(&mut self, value: u64) -> Result<()> {\n+        write!(&mut self.writer, \"{}\", value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_f32(&mut self, value: f32) -> io::Result<()> {\n-        fmt_f32_or_null(&mut self.writer, value)\n+    fn visit_f32(&mut self, value: f32) -> Result<()> {\n+        fmt_f32_or_null(&mut self.writer, value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_f64(&mut self, value: f64) -> io::Result<()> {\n-        fmt_f64_or_null(&mut self.writer, value)\n+    fn visit_f64(&mut self, value: f64) -> Result<()> {\n+        fmt_f64_or_null(&mut self.writer, value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_char(&mut self, value: char) -> io::Result<()> {\n-        escape_char(&mut self.writer, value)\n+    fn visit_char(&mut self, value: char) -> Result<()> {\n+        escape_char(&mut self.writer, value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_str(&mut self, value: &str) -> io::Result<()> {\n-        escape_str(&mut self.writer, value)\n+    fn visit_str(&mut self, value: &str) -> Result<()> {\n+        escape_str(&mut self.writer, value).map_err(From::from)\n     }\n \n     #[inline]\n-    fn visit_none(&mut self) -> io::Result<()> {\n+    fn visit_none(&mut self) -> Result<()> {\n         self.visit_unit()\n     }\n \n     #[inline]\n-    fn visit_some<V>(&mut self, value: V) -> io::Result<()>\n+    fn visit_some<V>(&mut self, value: V) -> Result<()>\n         where V: ser::Serialize\n     {\n         value.serialize(self)\n     }\n \n     #[inline]\n-    fn visit_unit(&mut self) -> io::Result<()> {\n-        self.writer.write_all(b\"null\")\n+    fn visit_unit(&mut self) -> Result<()> {\n+        self.writer.write_all(b\"null\").map_err(From::from)\n     }\n \n     /// Override `visit_newtype_struct` to serialize newtypes without an object wrapper.\n     #[inline]\n     fn visit_newtype_struct<T>(&mut self,\n                                _name: &'static str,\n-                               value: T) -> Result<(), Self::Error>\n+                               value: T) -> Result<()>\n         where T: ser::Serialize,\n     {\n         value.serialize(self)\n@@ -172,7 +172,7 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n     fn visit_unit_variant(&mut self,\n                           _name: &str,\n                           _variant_index: usize,\n-                          variant: &str) -> io::Result<()> {\n+                          variant: &str) -> Result<()> {\n         try!(self.formatter.open(&mut self.writer, b'{'));\n         try!(self.formatter.comma(&mut self.writer, true));\n         try!(self.visit_str(variant));\n@@ -186,7 +186,7 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n                                 _name: &str,\n                                 _variant_index: usize,\n                                 variant: &str,\n-                                value: T) -> io::Result<()>\n+                                value: T) -> Result<()>\n         where T: ser::Serialize,\n     {\n         try!(self.formatter.open(&mut self.writer, b'{'));\n@@ -198,12 +198,12 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n     }\n \n     #[inline]\n-    fn visit_seq<V>(&mut self, mut visitor: V) -> io::Result<()>\n+    fn visit_seq<V>(&mut self, mut visitor: V) -> Result<()>\n         where V: ser::SeqVisitor,\n     {\n         match visitor.len() {\n             Some(len) if len == 0 => {\n-                self.writer.write_all(b\"[]\")\n+                self.writer.write_all(b\"[]\").map_err(From::from)\n             }\n             _ => {\n                 try!(self.formatter.open(&mut self.writer, b'['));\n@@ -212,7 +212,7 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n \n                 while let Some(()) = try!(visitor.visit(self)) { }\n \n-                self.formatter.close(&mut self.writer, b']')\n+                self.formatter.close(&mut self.writer, b']').map_err(From::from)\n             }\n         }\n \n@@ -223,7 +223,7 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n                               _name: &str,\n                               _variant_index: usize,\n                               variant: &str,\n-                              visitor: V) -> io::Result<()>\n+                              visitor: V) -> Result<()>\n         where V: ser::SeqVisitor,\n     {\n         try!(self.formatter.open(&mut self.writer, b'{'));\n@@ -235,7 +235,7 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n     }\n \n     #[inline]\n-    fn visit_seq_elt<T>(&mut self, value: T) -> io::Result<()>\n+    fn visit_seq_elt<T>(&mut self, value: T) -> Result<()>\n         where T: ser::Serialize,\n     {\n         try!(self.formatter.comma(&mut self.writer, self.first));\n@@ -247,12 +247,12 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n     }\n \n     #[inline]\n-    fn visit_map<V>(&mut self, mut visitor: V) -> io::Result<()>\n+    fn visit_map<V>(&mut self, mut visitor: V) -> Result<()>\n         where V: ser::MapVisitor,\n     {\n         match visitor.len() {\n             Some(len) if len == 0 => {\n-                self.writer.write_all(b\"{}\")\n+                self.writer.write_all(b\"{}\").map_err(From::from)\n             }\n             _ => {\n                 try!(self.formatter.open(&mut self.writer, b'{'));\n@@ -271,7 +271,7 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n                                _name: &str,\n                                _variant_index: usize,\n                                variant: &str,\n-                               visitor: V) -> io::Result<()>\n+                               visitor: V) -> Result<()>\n         where V: ser::MapVisitor,\n     {\n         try!(self.formatter.open(&mut self.writer, b'{'));\n@@ -284,13 +284,13 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n     }\n \n     #[inline]\n-    fn visit_map_elt<K, V>(&mut self, key: K, value: V) -> io::Result<()>\n+    fn visit_map_elt<K, V>(&mut self, key: K, value: V) -> Result<()>\n         where K: ser::Serialize,\n               V: ser::Serialize,\n     {\n         try!(self.formatter.comma(&mut self.writer, self.first));\n \n-        try!(key.serialize(self));\n+        try!(key.serialize(&mut MapKeySerializer { ser: self }));\n         try!(self.formatter.colon(&mut self.writer));\n         try!(value.serialize(self));\n \n@@ -305,49 +305,120 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n     }\n }\n \n+struct MapKeySerializer<'a, W: 'a, F: 'a> {\n+    ser: &'a mut Serializer<W, F>,\n+}\n+\n+impl<'a, W, F> ser::Serializer for MapKeySerializer<'a, W, F>\n+    where W: io::Write,\n+          F: Formatter,\n+{\n+    type Error = Error;\n+\n+    #[inline]\n+    fn visit_str(&mut self, value: &str) -> Result<()> {\n+        self.ser.visit_str(value)\n+    }\n+\n+    fn visit_bool(&mut self, _value: bool) -> Result<()> {\n+        Err(Error::SyntaxError(ErrorCode::KeyMustBeAString, 0, 0))\n+    }\n+\n+    fn visit_i64(&mut self, _value: i64) -> Result<()> {\n+        Err(Error::SyntaxError(ErrorCode::KeyMustBeAString, 0, 0))\n+    }\n+\n+    fn visit_u64(&mut self, _value: u64) -> Result<()> {\n+        Err(Error::SyntaxError(ErrorCode::KeyMustBeAString, 0, 0))\n+    }\n+\n+    fn visit_f64(&mut self, _value: f64) -> Result<()> {\n+        Err(Error::SyntaxError(ErrorCode::KeyMustBeAString, 0, 0))\n+    }\n+\n+    fn visit_unit(&mut self) -> Result<()> {\n+        Err(Error::SyntaxError(ErrorCode::KeyMustBeAString, 0, 0))\n+    }\n+\n+    fn visit_none(&mut self) -> Result<()> {\n+        Err(Error::SyntaxError(ErrorCode::KeyMustBeAString, 0, 0))\n+    }\n+\n+    fn visit_some<V>(&mut self, _value: V) -> Result<()>\n+        where V: ser::Serialize\n+    {\n+        Err(Error::SyntaxError(ErrorCode::KeyMustBeAString, 0, 0))\n+    }\n+\n+    fn visit_seq<V>(&mut self, _visitor: V) -> Result<()>\n+        where V: ser::SeqVisitor,\n+    {\n+        Err(Error::SyntaxError(ErrorCode::KeyMustBeAString, 0, 0))\n+    }\n+\n+    fn visit_seq_elt<T>(&mut self, _value: T) -> Result<()>\n+        where T: ser::Serialize,\n+    {\n+        Err(Error::SyntaxError(ErrorCode::KeyMustBeAString, 0, 0))\n+    }\n+\n+    fn visit_map<V>(&mut self, _visitor: V) -> Result<()>\n+        where V: ser::MapVisitor,\n+    {\n+        Err(Error::SyntaxError(ErrorCode::KeyMustBeAString, 0, 0))\n+    }\n+\n+    fn visit_map_elt<K, V>(&mut self, _key: K, _value: V) -> Result<()>\n+        where K: ser::Serialize,\n+              V: ser::Serialize,\n+    {\n+        Err(Error::SyntaxError(ErrorCode::KeyMustBeAString, 0, 0))\n+    }\n+}\n+\n pub trait Formatter {\n-    fn open<W>(&mut self, writer: &mut W, ch: u8) -> io::Result<()>\n+    fn open<W>(&mut self, writer: &mut W, ch: u8) -> Result<()>\n         where W: io::Write;\n \n-    fn comma<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n+    fn comma<W>(&mut self, writer: &mut W, first: bool) -> Result<()>\n         where W: io::Write;\n \n-    fn colon<W>(&mut self, writer: &mut W) -> io::Result<()>\n+    fn colon<W>(&mut self, writer: &mut W) -> Result<()>\n         where W: io::Write;\n \n-    fn close<W>(&mut self, writer: &mut W, ch: u8) -> io::Result<()>\n+    fn close<W>(&mut self, writer: &mut W, ch: u8) -> Result<()>\n         where W: io::Write;\n }\n \n pub struct CompactFormatter;\n \n impl Formatter for CompactFormatter {\n-    fn open<W>(&mut self, writer: &mut W, ch: u8) -> io::Result<()>\n+    fn open<W>(&mut self, writer: &mut W, ch: u8) -> Result<()>\n         where W: io::Write,\n     {\n-        writer.write_all(&[ch])\n+        writer.write_all(&[ch]).map_err(From::from)\n     }\n \n-    fn comma<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n+    fn comma<W>(&mut self, writer: &mut W, first: bool) -> Result<()>\n         where W: io::Write,\n     {\n         if first {\n             Ok(())\n         } else {\n-            writer.write_all(b\",\")\n+            writer.write_all(b\",\").map_err(From::from)\n         }\n     }\n \n-    fn colon<W>(&mut self, writer: &mut W) -> io::Result<()>\n+    fn colon<W>(&mut self, writer: &mut W) -> Result<()>\n         where W: io::Write,\n     {\n-        writer.write_all(b\":\")\n+        writer.write_all(b\":\").map_err(From::from)\n     }\n \n-    fn close<W>(&mut self, writer: &mut W, ch: u8) -> io::Result<()>\n+    fn close<W>(&mut self, writer: &mut W, ch: u8) -> Result<()>\n         where W: io::Write,\n     {\n-        writer.write_all(&[ch])\n+        writer.write_all(&[ch]).map_err(From::from)\n     }\n }\n \n@@ -370,14 +441,14 @@ impl<'a> PrettyFormatter<'a> {\n }\n \n impl<'a> Formatter for PrettyFormatter<'a> {\n-    fn open<W>(&mut self, writer: &mut W, ch: u8) -> io::Result<()>\n+    fn open<W>(&mut self, writer: &mut W, ch: u8) -> Result<()>\n         where W: io::Write,\n     {\n         self.current_indent += 1;\n-        writer.write_all(&[ch])\n+        writer.write_all(&[ch]).map_err(From::from)\n     }\n \n-    fn comma<W>(&mut self, writer: &mut W, first: bool) -> io::Result<()>\n+    fn comma<W>(&mut self, writer: &mut W, first: bool) -> Result<()>\n         where W: io::Write,\n     {\n         if first {\n@@ -389,25 +460,25 @@ impl<'a> Formatter for PrettyFormatter<'a> {\n         indent(writer, self.current_indent, self.indent)\n     }\n \n-    fn colon<W>(&mut self, writer: &mut W) -> io::Result<()>\n+    fn colon<W>(&mut self, writer: &mut W) -> Result<()>\n         where W: io::Write,\n     {\n-        writer.write_all(b\": \")\n+        writer.write_all(b\": \").map_err(From::from)\n     }\n \n-    fn close<W>(&mut self, writer: &mut W, ch: u8) -> io::Result<()>\n+    fn close<W>(&mut self, writer: &mut W, ch: u8) -> Result<()>\n         where W: io::Write,\n     {\n         self.current_indent -= 1;\n         try!(writer.write(b\"\\n\"));\n         try!(indent(writer, self.current_indent, self.indent));\n \n-        writer.write_all(&[ch])\n+        writer.write_all(&[ch]).map_err(From::from)\n     }\n }\n \n #[inline]\n-pub fn escape_bytes<W>(wr: &mut W, bytes: &[u8]) -> io::Result<()>\n+pub fn escape_bytes<W>(wr: &mut W, bytes: &[u8]) -> Result<()>\n     where W: io::Write\n {\n     try!(wr.write_all(b\"\\\"\"));\n@@ -444,14 +515,14 @@ pub fn escape_bytes<W>(wr: &mut W, bytes: &[u8]) -> io::Result<()>\n }\n \n #[inline]\n-pub fn escape_str<W>(wr: &mut W, value: &str) -> io::Result<()>\n+pub fn escape_str<W>(wr: &mut W, value: &str) -> Result<()>\n     where W: io::Write\n {\n     escape_bytes(wr, value.as_bytes())\n }\n \n #[inline]\n-fn escape_char<W>(wr: &mut W, value: char) -> io::Result<()>\n+fn escape_char<W>(wr: &mut W, value: char) -> Result<()>\n     where W: io::Write\n {\n     // FIXME: this allocation is required in order to be compatible with stable\n@@ -459,31 +530,39 @@ fn escape_char<W>(wr: &mut W, value: char) -> io::Result<()>\n     escape_bytes(wr, value.to_string().as_bytes())\n }\n \n-fn fmt_f32_or_null<W>(wr: &mut W, value: f32) -> io::Result<()>\n+fn fmt_f32_or_null<W>(wr: &mut W, value: f32) -> Result<()>\n     where W: io::Write\n {\n     match value.classify() {\n-        FpCategory::Nan | FpCategory::Infinite => wr.write_all(b\"null\"),\n+        FpCategory::Nan | FpCategory::Infinite => {\n+            try!(wr.write_all(b\"null\"))\n+        }\n         _ => {\n-            write!(wr, \"{:?}\", value)\n+            try!(write!(wr, \"{:?}\", value))\n         }\n     }\n+\n+    Ok(())\n }\n \n-fn fmt_f64_or_null<W>(wr: &mut W, value: f64) -> io::Result<()>\n+fn fmt_f64_or_null<W>(wr: &mut W, value: f64) -> Result<()>\n     where W: io::Write\n {\n     match value.classify() {\n-        FpCategory::Nan | FpCategory::Infinite => wr.write_all(b\"null\"),\n+        FpCategory::Nan | FpCategory::Infinite => {\n+            try!(wr.write_all(b\"null\"))\n+        }\n         _ => {\n-            write!(wr, \"{:?}\", value)\n+            try!(write!(wr, \"{:?}\", value))\n         }\n     }\n+\n+    Ok(())\n }\n \n /// Encode the specified struct into a json `[u8]` writer.\n #[inline]\n-pub fn to_writer<W, T>(writer: &mut W, value: &T) -> io::Result<()>\n+pub fn to_writer<W, T>(writer: &mut W, value: &T) -> Result<()>\n     where W: io::Write,\n           T: ser::Serialize,\n {\n@@ -494,7 +573,7 @@ pub fn to_writer<W, T>(writer: &mut W, value: &T) -> io::Result<()>\n \n /// Encode the specified struct into a json `[u8]` writer.\n #[inline]\n-pub fn to_writer_pretty<W, T>(writer: &mut W, value: &T) -> io::Result<()>\n+pub fn to_writer_pretty<W, T>(writer: &mut W, value: &T) -> Result<()>\n     where W: io::Write,\n           T: ser::Serialize,\n {\n@@ -505,47 +584,49 @@ pub fn to_writer_pretty<W, T>(writer: &mut W, value: &T) -> io::Result<()>\n \n /// Encode the specified struct into a json `[u8]` buffer.\n #[inline]\n-pub fn to_vec<T>(value: &T) -> Vec<u8>\n+pub fn to_vec<T>(value: &T) -> Result<Vec<u8>>\n     where T: ser::Serialize,\n {\n     // We are writing to a Vec, which doesn't fail. So we can ignore\n     // the error.\n     let mut writer = Vec::with_capacity(128);\n-    to_writer(&mut writer, value).unwrap();\n-    writer\n+    try!(to_writer(&mut writer, value));\n+    Ok(writer)\n }\n \n /// Encode the specified struct into a json `[u8]` buffer.\n #[inline]\n-pub fn to_vec_pretty<T>(value: &T) -> Vec<u8>\n+pub fn to_vec_pretty<T>(value: &T) -> Result<Vec<u8>>\n     where T: ser::Serialize,\n {\n     // We are writing to a Vec, which doesn't fail. So we can ignore\n     // the error.\n     let mut writer = Vec::with_capacity(128);\n-    to_writer_pretty(&mut writer, value).unwrap();\n-    writer\n+    try!(to_writer_pretty(&mut writer, value));\n+    Ok(writer)\n }\n \n /// Encode the specified struct into a json `String` buffer.\n #[inline]\n-pub fn to_string<T>(value: &T) -> Result<String, FromUtf8Error>\n+pub fn to_string<T>(value: &T) -> Result<String>\n     where T: ser::Serialize\n {\n-    let vec = to_vec(value);\n-    String::from_utf8(vec)\n+    let vec = try!(to_vec(value));\n+    let string = try!(String::from_utf8(vec));\n+    Ok(string)\n }\n \n /// Encode the specified struct into a json `String` buffer.\n #[inline]\n-pub fn to_string_pretty<T>(value: &T) -> Result<String, FromUtf8Error>\n+pub fn to_string_pretty<T>(value: &T) -> Result<String>\n     where T: ser::Serialize\n {\n-    let vec = to_vec_pretty(value);\n-    String::from_utf8(vec)\n+    let vec = try!(to_vec_pretty(value));\n+    let string = try!(String::from_utf8(vec));\n+    Ok(string)\n }\n \n-fn indent<W>(wr: &mut W, n: usize, s: &[u8]) -> io::Result<()>\n+fn indent<W>(wr: &mut W, n: usize, s: &[u8]) -> Result<()>\n     where W: io::Write,\n {\n     for _ in 0 .. n {\n", "test_patch": "diff --git a/serde_tests/benches/bench_log.rs b/serde_tests/benches/bench_log.rs\nindex 4fa108da5..1dddcf500 100644\n--- a/serde_tests/benches/bench_log.rs\n+++ b/serde_tests/benches/bench_log.rs\n@@ -1,6 +1,6 @@\n use std::io::{self, Read, Write};\n use num::FromPrimitive;\n-use test::Bencher;\n+use test::{Bencher, black_box};\n \n use rustc_serialize;\n \n@@ -1093,7 +1093,7 @@ fn test_encoder() {\n \n     {\n         let mut encoder = rustc_serialize::json::Encoder::new(&mut wr);\n-        log.encode(&mut encoder).unwrap();\n+        log.encode(&mut encoder).unwrap()\n     }\n \n     assert_eq!(&wr, &JSON_STR);\n@@ -1116,25 +1116,25 @@ fn bench_encoder(b: &mut Bencher) {\n         wr.clear();\n \n         let mut encoder = rustc_serialize::json::Encoder::new(&mut wr);\n-        log.encode(&mut encoder).unwrap();\n+        log.encode(&mut encoder).unwrap()\n     });\n }\n \n #[test]\n fn test_serializer() {\n     let log = Log::new();\n-    let json = serde_json::to_vec(&log);\n+    let json = serde_json::to_vec(&log).unwrap();\n     assert_eq!(json, JSON_STR.as_bytes());\n }\n \n #[bench]\n fn bench_serializer(b: &mut Bencher) {\n     let log = Log::new();\n-    let json = serde_json::to_vec(&log);\n+    let json = serde_json::to_vec(&log).unwrap();\n     b.bytes = json.len() as u64;\n \n     b.iter(|| {\n-        let _ = serde_json::to_vec(&log);\n+        serde_json::to_vec(&log).unwrap()\n     });\n }\n \n@@ -1152,7 +1152,7 @@ fn test_serializer_vec() {\n #[bench]\n fn bench_serializer_vec(b: &mut Bencher) {\n     let log = Log::new();\n-    let json = serde_json::to_vec(&log);\n+    let json = serde_json::to_vec(&log).unwrap();\n     b.bytes = json.len() as u64;\n \n     let mut wr = Vec::with_capacity(1024);\n@@ -1162,14 +1162,15 @@ fn bench_serializer_vec(b: &mut Bencher) {\n \n         let mut serializer = serde_json::Serializer::new(wr.by_ref());\n         log.serialize(&mut serializer).unwrap();\n-        let _json = serializer.into_inner();\n+        let json = serializer.into_inner();\n+        black_box(json);\n     });\n }\n \n #[bench]\n fn bench_serializer_slice(b: &mut Bencher) {\n     let log = Log::new();\n-    let json = serde_json::to_vec(&log);\n+    let json = serde_json::to_vec(&log).unwrap();\n     b.bytes = json.len() as u64;\n \n     let mut buf = [0; 1024];\n@@ -1180,7 +1181,8 @@ fn bench_serializer_slice(b: &mut Bencher) {\n \n         let mut serializer = serde_json::Serializer::new(wr.by_ref());\n         log.serialize(&mut serializer).unwrap();\n-        let _json = serializer.into_inner();\n+        let json = serializer.into_inner();\n+        black_box(json);\n     });\n }\n \n@@ -1193,7 +1195,8 @@ fn test_serializer_my_mem_writer0() {\n     {\n         let mut serializer = serde_json::Serializer::new(wr.by_ref());\n         log.serialize(&mut serializer).unwrap();\n-        let _json = serializer.into_inner();\n+        let json = serializer.into_inner();\n+        black_box(json);\n     }\n \n     assert_eq!(&wr.buf, &JSON_STR.as_bytes());\n@@ -1202,7 +1205,7 @@ fn test_serializer_my_mem_writer0() {\n #[bench]\n fn bench_serializer_my_mem_writer0(b: &mut Bencher) {\n     let log = Log::new();\n-    let json = serde_json::to_vec(&log);\n+    let json = serde_json::to_vec(&log).unwrap();\n     b.bytes = json.len() as u64;\n \n     let mut wr = MyMemWriter0::with_capacity(1024);\n@@ -1212,7 +1215,8 @@ fn bench_serializer_my_mem_writer0(b: &mut Bencher) {\n \n         let mut serializer = serde_json::Serializer::new(wr.by_ref());\n         log.serialize(&mut serializer).unwrap();\n-        let _json = serializer.into_inner();\n+        let json = serializer.into_inner();\n+        black_box(json);\n     });\n }\n \n@@ -1225,7 +1229,8 @@ fn test_serializer_my_mem_writer1() {\n     {\n         let mut serializer = serde_json::Serializer::new(wr.by_ref());\n         log.serialize(&mut serializer).unwrap();\n-        let _json = serializer.into_inner();\n+        let json = serializer.into_inner();\n+        black_box(json);\n     }\n \n     assert_eq!(&wr.buf, &JSON_STR.as_bytes());\n@@ -1234,7 +1239,7 @@ fn test_serializer_my_mem_writer1() {\n #[bench]\n fn bench_serializer_my_mem_writer1(b: &mut Bencher) {\n     let log = Log::new();\n-    let json = serde_json::to_vec(&log);\n+    let json = serde_json::to_vec(&log).unwrap();\n     b.bytes = json.len() as u64;\n \n     let mut wr = MyMemWriter1::with_capacity(1024);\n@@ -1244,7 +1249,8 @@ fn bench_serializer_my_mem_writer1(b: &mut Bencher) {\n \n         let mut serializer = serde_json::Serializer::new(wr.by_ref());\n         log.serialize(&mut serializer).unwrap();\n-        let _json = serializer.into_inner();\n+        let json = serializer.into_inner();\n+        black_box(json);\n     });\n }\n \n@@ -1254,7 +1260,7 @@ fn bench_copy(b: &mut Bencher) {\n     b.bytes = json.len() as u64;\n \n     b.iter(|| {\n-        let _json = JSON_STR.as_bytes().to_vec();\n+        JSON_STR.as_bytes().to_vec()\n     });\n }\n \n@@ -1441,7 +1447,7 @@ fn bench_manual_serialize_vec_no_escape(b: &mut Bencher) {\n \n     b.iter(|| {\n         wr.clear();\n-        manual_serialize_no_escape(&mut wr, &log);\n+        manual_serialize_no_escape(&mut wr, &log)\n     });\n }\n \n@@ -1467,7 +1473,7 @@ fn bench_manual_serialize_vec_escape(b: &mut Bencher) {\n     b.iter(|| {\n         wr.clear();\n \n-        manual_serialize_escape(&mut wr, &log);\n+        manual_serialize_escape(&mut wr, &log)\n     });\n }\n \n@@ -1493,7 +1499,7 @@ fn bench_manual_serialize_my_mem_writer0_no_escape(b: &mut Bencher) {\n     b.iter(|| {\n         wr.buf.clear();\n \n-        manual_serialize_no_escape(&mut wr, &log);\n+        manual_serialize_no_escape(&mut wr, &log)\n     });\n }\n \n@@ -1519,7 +1525,7 @@ fn bench_manual_serialize_my_mem_writer0_escape(b: &mut Bencher) {\n     b.iter(|| {\n         wr.buf.clear();\n \n-        manual_serialize_escape(&mut wr, &log);\n+        manual_serialize_escape(&mut wr, &log)\n     });\n }\n \n@@ -1545,7 +1551,7 @@ fn bench_manual_serialize_my_mem_writer1_no_escape(b: &mut Bencher) {\n     b.iter(|| {\n         wr.buf.clear();\n \n-        manual_serialize_no_escape(&mut wr, &log);\n+        manual_serialize_no_escape(&mut wr, &log)\n     });\n }\n \n@@ -1571,7 +1577,7 @@ fn bench_manual_serialize_my_mem_writer1_escape(b: &mut Bencher) {\n     b.iter(|| {\n         wr.buf.clear();\n \n-        manual_serialize_escape(&mut wr, &log);\n+        manual_serialize_escape(&mut wr, &log)\n     });\n }\n \n@@ -1584,7 +1590,8 @@ fn bench_decoder(b: &mut Bencher) {\n     b.iter(|| {\n         let json = Json::from_str(JSON_STR).unwrap();\n         let mut decoder = rustc_serialize::json::Decoder::new(json);\n-        let _log: Log = rustc_serialize::Decodable::decode(&mut decoder).unwrap();\n+        let log: Log = rustc_serialize::Decodable::decode(&mut decoder).unwrap();\n+        log\n     });\n }\n \n@@ -1593,6 +1600,7 @@ fn bench_deserializer(b: &mut Bencher) {\n     b.bytes = JSON_STR.len() as u64;\n \n     b.iter(|| {\n-        let _log: Log = serde_json::from_str(JSON_STR).unwrap();\n+        let log: Log = serde_json::from_str(JSON_STR).unwrap();\n+        log\n     });\n }\ndiff --git a/serde_tests/tests/test_json.rs b/serde_tests/tests/test_json.rs\nindex 934cbcc40..1c092a97c 100644\n--- a/serde_tests/tests/test_json.rs\n+++ b/serde_tests/tests/test_json.rs\n@@ -1348,3 +1348,16 @@ fn test_deserialize_from_stream() {\n \n     assert_eq!(request, response);\n }\n+\n+#[test]\n+fn test_serialize_rejects_non_key_maps() {\n+    let map = treemap!(\n+        1 => 2,\n+        3 => 4\n+    );\n+\n+    match serde_json::to_vec(&map).unwrap_err() {\n+        serde_json::Error::SyntaxError(serde_json::ErrorCode::KeyMustBeAString, 0, 0) => {}\n+        _ => panic!(\"integers used as keys\"),\n+    }\n+}\n", "problem_statement": "Serializing a map with non-string keys will silently generate invalid JSON\nFor example, a `HashMap<u32, u32>` will produce invalid JSON when serialized.\n\nAt a minimum, the json serializer should error rather than produce invalid JSON.\n\nIdeally however, it would fall back to serializing the map as a list of pairs:\n\n```\n[[0, 1], [2, 0], ...]\n```\n\n", "hints_text": "we had this issue before with rustc-serialize... I wasn't aware we also had it in serde...\n\nprobably we just need an intermediate serializer here: https://github.com/serde-rs/serde/blob/master/serde_json/src/ser.rs#L262 that is passed to the MapVisitor, to check for stringable keys and error else. Fallback to serializing the map as a list of pairs isn't really doable. You should be serializing an iterator to get that behavior.\n\nGood idea @oli-obk! let me whip that up...\n", "created_at": "2015-08-14T05:34:23Z", "version": "0.5"}, {"repo": "serde-rs/serde", "pull_number": 129, "instance_id": "serde-rs__serde-129", "issue_numbers": ["125"], "base_commit": "0482b756e897ccfdac0fe52f54a1ca0f4ba76042", "patch": "diff --git a/README.md b/README.md\nindex 624054f85..e00fa998b 100644\n--- a/README.md\n+++ b/README.md\n@@ -275,7 +275,7 @@ to generate an error for a few common error conditions. Here's how it could be u\n     fn visit_string<E>(&mut self, _: String) -> Result<i32, E>\n         where E: Error,\n     {\n-        Err(serde::de::Error::syntax_error())\n+        Err(serde::de::Error::syntax(\"expect a string\"))\n     }\n \n     ...\n@@ -366,7 +366,7 @@ impl serde::Deserialize for PointField {\n                 match value {\n                     \"x\" => Ok(Field::X),\n                     \"y\" => Ok(Field::Y),\n-                    _ => Err(serde::de::Error::syntax_error()),\n+                    _ => Err(serde::de::Error::syntax(\"expected x or y\")),\n                 }\n             }\n         }\ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex e8b95f580..48a194f3a 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -85,7 +85,7 @@ impl Visitor for BoolVisitor {\n         match s.trim() {\n             \"true\" => Ok(true),\n             \"false\" => Ok(false),\n-            _ => Err(Error::syntax_error()),\n+            _ => Err(Error::syntax(\"expected `true` or `false`\")),\n         }\n     }\n }\n@@ -108,7 +108,7 @@ macro_rules! impl_deserialize_num_method {\n         {\n             match FromPrimitive::$from_method(v) {\n                 Some(v) => Ok(v),\n-                None => Err(Error::syntax_error()),\n+                None => Err(Error::syntax(\"expected a number\")),\n             }\n         }\n     }\n@@ -149,7 +149,7 @@ impl<\n     fn visit_str<E>(&mut self, v: &str) -> Result<T, E>\n         where E: Error,\n     {\n-        str::FromStr::from_str(v.trim()).or(Err(Error::syntax_error()))\n+        str::FromStr::from_str(v.trim()).or(Err(Error::syntax(\"expected a str\")))\n     }\n }\n \n@@ -200,12 +200,12 @@ impl Visitor for CharVisitor {\n         let mut iter = v.chars();\n         if let Some(v) = iter.next() {\n             if iter.next().is_some() {\n-                Err(Error::syntax_error())\n+                Err(Error::syntax(\"expected a character\"))\n             } else {\n                 Ok(v)\n             }\n         } else {\n-            Err(Error::end_of_stream_error())\n+            Err(Error::end_of_stream())\n         }\n     }\n }\n@@ -243,7 +243,7 @@ impl Visitor for StringVisitor {\n     {\n         match str::from_utf8(v) {\n             Ok(s) => Ok(s.to_string()),\n-            Err(_) => Err(Error::syntax_error()),\n+            Err(_) => Err(Error::syntax(\"expected utf8 `&[u8]`\")),\n         }\n     }\n \n@@ -252,7 +252,7 @@ impl Visitor for StringVisitor {\n     {\n         match String::from_utf8(v) {\n             Ok(s) => Ok(s),\n-            Err(_) => Err(Error::syntax_error()),\n+            Err(_) => Err(Error::syntax(\"expected utf8 `&[u8]`\")),\n         }\n     }\n }\n@@ -495,7 +495,7 @@ macro_rules! array_impls {\n                     $(\n                         let $name = match try!(visitor.visit()) {\n                             Some(val) => val,\n-                            None => { return Err(Error::end_of_stream_error()); }\n+                            None => { return Err(Error::end_of_stream()); }\n                         };\n                     )+;\n \n@@ -593,7 +593,7 @@ macro_rules! tuple_impls {\n                     $(\n                         let $name = match try!(visitor.visit()) {\n                             Some(value) => value,\n-                            None => { return Err(Error::end_of_stream_error()); }\n+                            None => { return Err(Error::end_of_stream()); }\n                         };\n                      )+;\n \n@@ -848,7 +848,7 @@ impl<T> Deserialize for NonZero<T> where T: Deserialize + PartialEq + Zeroable +\n     fn deserialize<D>(deserializer: &mut D) -> Result<NonZero<T>, D::Error> where D: Deserializer {\n         let value = try!(Deserialize::deserialize(deserializer));\n         if value == Zero::zero() {\n-            return Err(Error::syntax_error())\n+            return Err(Error::syntax(\"expected a non-zero value\"))\n         }\n         unsafe {\n             Ok(NonZero::new(value))\n@@ -881,7 +881,7 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n                         match value {\n                             0 => Ok(Field::Ok),\n                             1 => Ok(Field::Err),\n-                            _ => Err(Error::unknown_field_error(&value.to_string())),\n+                            _ => Err(Error::unknown_field(&value.to_string())),\n                         }\n                     }\n \n@@ -889,7 +889,7 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n                         match value {\n                             \"Ok\" => Ok(Field::Ok),\n                             \"Err\" => Ok(Field::Err),\n-                            _ => Err(Error::unknown_field_error(value)),\n+                            _ => Err(Error::unknown_field(value)),\n                         }\n                     }\n \n@@ -899,8 +899,8 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n                             b\"Err\" => Ok(Field::Err),\n                             _ => {\n                                 match str::from_utf8(value) {\n-                                    Ok(value) => Err(Error::unknown_field_error(value)),\n-                                    Err(_) => Err(Error::syntax_error()),\n+                                    Ok(value) => Err(Error::unknown_field(value)),\n+                                    Err(_) => Err(Error::syntax(\"expected a `&[u8]`\")),\n                                 }\n                             }\n                         }\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 60c51edcc..db83bdc22 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -6,13 +6,13 @@ pub mod value;\n ///////////////////////////////////////////////////////////////////////////////\n \n pub trait Error {\n-    fn syntax_error() -> Self;\n+    fn syntax(msg: &str) -> Self;\n \n-    fn end_of_stream_error() -> Self;\n+    fn end_of_stream() -> Self;\n \n-    fn unknown_field_error(field: &str) -> Self;\n+    fn unknown_field(field: &str) -> Self;\n \n-    fn missing_field_error(field: &'static str) -> Self;\n+    fn missing_field(field: &'static str) -> Self;\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -273,7 +273,7 @@ pub trait Deserializer {\n                      _visitor: V) -> Result<V::Value, Self::Error>\n         where V: EnumVisitor,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected an enum\"))\n     }\n \n     /// This method hints that the `Deserialize` type is expecting a `Vec<u8>`. This allows\n@@ -304,7 +304,7 @@ pub trait Visitor {\n     fn visit_bool<E>(&mut self, _v: bool) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a bool\"))\n     }\n \n     fn visit_isize<E>(&mut self, v: isize) -> Result<Self::Value, E>\n@@ -334,7 +334,7 @@ pub trait Visitor {\n     fn visit_i64<E>(&mut self, _v: i64) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a i64\"))\n     }\n \n     fn visit_usize<E>(&mut self, v: usize) -> Result<Self::Value, E>\n@@ -364,7 +364,7 @@ pub trait Visitor {\n     fn visit_u64<E>(&mut self, _v: u64) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a u64\"))\n     }\n \n     fn visit_f32<E>(&mut self, v: f32) -> Result<Self::Value, E>\n@@ -376,7 +376,7 @@ pub trait Visitor {\n     fn visit_f64<E>(&mut self, _v: f64) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a f64\"))\n     }\n \n     #[inline]\n@@ -391,7 +391,7 @@ pub trait Visitor {\n     fn visit_str<E>(&mut self, _v: &str) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a str\"))\n     }\n \n     #[inline]\n@@ -404,7 +404,7 @@ pub trait Visitor {\n     fn visit_unit<E>(&mut self) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a unit\"))\n     }\n \n     #[inline]\n@@ -417,37 +417,37 @@ pub trait Visitor {\n     fn visit_none<E>(&mut self) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected an Option::None\"))\n     }\n \n     fn visit_some<D>(&mut self, _deserializer: &mut D) -> Result<Self::Value, D::Error>\n         where D: Deserializer,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected an Option::Some\"))\n     }\n \n     fn visit_newtype_struct<D>(&mut self, _deserializer: &mut D) -> Result<Self::Value, D::Error>\n         where D: Deserializer,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a newtype struct\"))\n     }\n \n     fn visit_seq<V>(&mut self, _visitor: V) -> Result<Self::Value, V::Error>\n         where V: SeqVisitor,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a sequence\"))\n     }\n \n     fn visit_map<V>(&mut self, _visitor: V) -> Result<Self::Value, V::Error>\n         where V: MapVisitor,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a map\"))\n     }\n \n     fn visit_bytes<E>(&mut self, _v: &[u8]) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a &[u8]\"))\n     }\n \n     fn visit_byte_buf<E>(&mut self, v: Vec<u8>) -> Result<Self::Value, E>\n@@ -529,7 +529,7 @@ pub trait MapVisitor {\n     fn missing_field<V>(&mut self, field: &'static str) -> Result<V, Self::Error>\n         where V: Deserialize,\n     {\n-        Err(Error::missing_field_error(field))\n+        Err(Error::missing_field(field))\n     }\n }\n \n@@ -593,7 +593,7 @@ pub trait VariantVisitor {\n \n     /// `visit_unit` is called when deserializing a variant with no values.\n     fn visit_unit(&mut self) -> Result<(), Self::Error> {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a univ variant\"))\n     }\n \n     /// `visit_newtype` is called when deserializing a variant with a single value. By default this\n@@ -612,7 +612,7 @@ pub trait VariantVisitor {\n                       _visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a tuple variant\"))\n     }\n \n     /// `visit_struct` is called when deserializing a struct-like variant.\n@@ -621,7 +621,7 @@ pub trait VariantVisitor {\n                        _visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor\n     {\n-        Err(Error::syntax_error())\n+        Err(Error::syntax(\"expected a struct variant\"))\n     }\n }\n \ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 8ad281b77..b6c6f0feb 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -24,10 +24,10 @@ pub enum Error {\n }\n \n impl de::Error for Error {\n-    fn syntax_error() -> Self { Error::SyntaxError }\n-    fn end_of_stream_error() -> Self { Error::EndOfStreamError }\n-    fn unknown_field_error(field: &str) -> Self { Error::UnknownFieldError(field.to_string()) }\n-    fn missing_field_error(field: &'static str) -> Self { Error::MissingFieldError(field) }\n+    fn syntax(_: &str) -> Self { Error::SyntaxError }\n+    fn end_of_stream() -> Self { Error::EndOfStreamError }\n+    fn unknown_field(field: &str) -> Self { Error::UnknownFieldError(String::from(field)) }\n+    fn missing_field(field: &'static str) -> Self { Error::MissingFieldError(field) }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -89,7 +89,7 @@ macro_rules! primitive_deserializer {\n             {\n                 match self.0.take() {\n                     Some(v) => visitor.$method(v),\n-                    None => Err(de::Error::end_of_stream_error()),\n+                    None => Err(de::Error::end_of_stream()),\n                 }\n             }\n         }\n@@ -132,7 +132,7 @@ impl<'a> de::Deserializer for StrDeserializer<'a> {\n     {\n         match self.0.take() {\n             Some(v) => visitor.visit_str(v),\n-            None => Err(de::Error::end_of_stream_error()),\n+            None => Err(de::Error::end_of_stream()),\n         }\n     }\n \n@@ -181,7 +181,7 @@ impl de::Deserializer for StringDeserializer {\n     {\n         match self.0.take() {\n             Some(string) => visitor.visit_string(string),\n-            None => Err(de::Error::end_of_stream_error()),\n+            None => Err(de::Error::end_of_stream()),\n         }\n     }\n \n@@ -261,7 +261,7 @@ impl<I, T> de::SeqVisitor for SeqDeserializer<I>\n         if self.len == 0 {\n             Ok(())\n         } else {\n-            Err(de::Error::end_of_stream_error())\n+            Err(de::Error::end_of_stream())\n         }\n     }\n \n@@ -374,7 +374,7 @@ impl<I, K, V> de::MapVisitor for MapDeserializer<I, K, V>\n                 let mut de = value.into_deserializer();\n                 de::Deserialize::deserialize(&mut de)\n             }\n-            None => Err(de::Error::syntax_error())\n+            None => Err(de::Error::syntax(\"expected a map value\"))\n         }\n     }\n \n@@ -382,7 +382,7 @@ impl<I, K, V> de::MapVisitor for MapDeserializer<I, K, V>\n         if self.len == 0 {\n             Ok(())\n         } else {\n-            Err(de::Error::end_of_stream_error())\n+            Err(de::Error::end_of_stream())\n         }\n     }\n \n@@ -438,7 +438,7 @@ impl<'a> de::Deserializer for BytesDeserializer<'a> {\n     {\n         match self.0.take() {\n             Some(bytes) => visitor.visit_bytes(bytes),\n-            None => Err(de::Error::end_of_stream_error()),\n+            None => Err(de::Error::end_of_stream()),\n         }\n     }\n }\n@@ -465,7 +465,7 @@ impl de::Deserializer for ByteBufDeserializer {\n     {\n         match self.0.take() {\n             Some(bytes) => visitor.visit_byte_buf(bytes),\n-            None => Err(de::Error::end_of_stream_error()),\n+            None => Err(de::Error::end_of_stream()),\n         }\n     }\n }\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex 580644404..8beb1b9e6 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -397,7 +397,7 @@ fn deserialize_seq(\n                 let $name = match try!(visitor.visit()) {\n                     Some(value) => { value },\n                     None => {\n-                        return Err(::serde::de::Error::end_of_stream_error());\n+                        return Err(::serde::de::Error::end_of_stream());\n                     }\n                 };\n             ).unwrap()\n@@ -431,7 +431,7 @@ fn deserialize_struct_as_seq(\n                 let $name = match try!(visitor.visit()) {\n                     Some(value) => { value },\n                     None => {\n-                        return Err(::serde::de::Error::end_of_stream_error());\n+                        return Err(::serde::de::Error::end_of_stream());\n                     }\n                 };\n             ).unwrap()\n@@ -804,7 +804,7 @@ fn deserialize_field_visitor(\n     let index_body = quote_expr!(cx,\n         match value {\n             $index_field_arms\n-            _ => { Err(::serde::de::Error::syntax_error()) }\n+            _ => { Err(::serde::de::Error::syntax(\"expected a field\")) }\n         }\n     );\n \n@@ -829,7 +829,7 @@ fn deserialize_field_visitor(\n         quote_expr!(cx,\n             match value {\n                 $default_field_arms\n-                _ => { Err(::serde::de::Error::unknown_field_error(value)) }\n+                _ => { Err(::serde::de::Error::unknown_field(value)) }\n             })\n     } else {\n         let field_arms: Vec<_> = formats.iter()\n@@ -851,7 +851,7 @@ fn deserialize_field_visitor(\n                     match value {\n                         $arms\n                         _ => {\n-                            Err(::serde::de::Error::unknown_field_error(value))\n+                            Err(::serde::de::Error::unknown_field(value))\n                         }\n                     }})\n             })\n@@ -862,7 +862,7 @@ fn deserialize_field_visitor(\n                 $fmt_matches\n                 _ => match value {\n                     $default_field_arms\n-                    _ => { Err(::serde::de::Error::unknown_field_error(value)) }\n+                    _ => { Err(::serde::de::Error::unknown_field(value)) }\n                 }\n             }\n         )\n@@ -903,7 +903,13 @@ fn deserialize_field_visitor(\n                         // TODO: would be better to generate a byte string literal match\n                         match ::std::str::from_utf8(value) {\n                             Ok(s) => self.visit_str(s),\n-                            _ => Err(::serde::de::Error::syntax_error()),\n+                            _ => {\n+                                Err(\n+                                    ::serde::de::Error::syntax(\n+                                        \"could not convert a byte string to a String\"\n+                                    )\n+                                )\n+                            }\n                         }\n                     }\n                 }\ndiff --git a/serde_json/src/error.rs b/serde_json/src/error.rs\nindex beaa8a721..6621188bb 100644\n--- a/serde_json/src/error.rs\n+++ b/serde_json/src/error.rs\n@@ -152,35 +152,35 @@ impl From<de::value::Error> for Error {\n     fn from(error: de::value::Error) -> Error {\n         match error {\n             de::value::Error::SyntaxError => {\n-                de::Error::syntax_error()\n+                Error::SyntaxError(ErrorCode::ExpectedSomeValue, 0, 0)\n             }\n             de::value::Error::EndOfStreamError => {\n-                de::Error::end_of_stream_error()\n+                de::Error::end_of_stream()\n             }\n             de::value::Error::UnknownFieldError(field) => {\n                 Error::SyntaxError(ErrorCode::UnknownField(field), 0, 0)\n             }\n             de::value::Error::MissingFieldError(field) => {\n-                de::Error::missing_field_error(field)\n+                de::Error::missing_field(field)\n             }\n         }\n     }\n }\n \n impl de::Error for Error {\n-    fn syntax_error() -> Error {\n+    fn syntax(_: &str) -> Error {\n         Error::SyntaxError(ErrorCode::ExpectedSomeValue, 0, 0)\n     }\n \n-    fn end_of_stream_error() -> Error {\n+    fn end_of_stream() -> Error {\n         Error::SyntaxError(ErrorCode::EOFWhileParsingValue, 0, 0)\n     }\n \n-    fn unknown_field_error(field: &str) -> Error {\n+    fn unknown_field(field: &str) -> Error {\n         Error::SyntaxError(ErrorCode::UnknownField(field.to_string()), 0, 0)\n     }\n \n-    fn missing_field_error(field: &'static str) -> Error {\n+    fn missing_field(field: &'static str) -> Error {\n         Error::MissingFieldError(field)\n     }\n }\ndiff --git a/serde_json/src/value.rs b/serde_json/src/value.rs\nindex 7b6c0bb02..b873ad2c6 100644\n--- a/serde_json/src/value.rs\n+++ b/serde_json/src/value.rs\n@@ -650,7 +650,7 @@ impl de::Deserializer for Deserializer {\n     {\n         let value = match self.value.take() {\n             Some(value) => value,\n-            None => { return Err(de::Error::end_of_stream_error()); }\n+            None => { return Err(de::Error::end_of_stream()); }\n         };\n \n         match value {\n@@ -687,7 +687,7 @@ impl de::Deserializer for Deserializer {\n         match self.value {\n             Some(Value::Null) => visitor.visit_none(),\n             Some(_) => visitor.visit_some(self),\n-            None => Err(de::Error::end_of_stream_error()),\n+            None => Err(de::Error::end_of_stream()),\n         }\n     }\n \n@@ -700,20 +700,20 @@ impl de::Deserializer for Deserializer {\n     {\n         let value = match self.value.take() {\n             Some(Value::Object(value)) => value,\n-            Some(_) => { return Err(de::Error::syntax_error()); }\n-            None => { return Err(de::Error::end_of_stream_error()); }\n+            Some(_) => { return Err(de::Error::syntax(\"expected an enum\")); }\n+            None => { return Err(de::Error::end_of_stream()); }\n         };\n \n         let mut iter = value.into_iter();\n \n         let (variant, value) = match iter.next() {\n             Some(v) => v,\n-            None => return Err(de::Error::syntax_error()),\n+            None => return Err(de::Error::syntax(\"expected a variant name\")),\n         };\n \n         // enums are encoded in json as maps with a single key:value pair\n         match iter.next() {\n-            Some(_) => Err(de::Error::syntax_error()),\n+            Some(_) => Err(de::Error::syntax(\"expected map\")),\n             None => visitor.visit(VariantDeserializer {\n                 de: self,\n                 val: Some(value),\n@@ -768,7 +768,7 @@ impl<'a> de::VariantVisitor for VariantDeserializer<'a> {\n                 visitor,\n             )\n         } else {\n-            Err(de::Error::syntax_error())\n+            Err(de::Error::syntax(\"expected a tuple\"))\n         }\n     }\n \n@@ -788,7 +788,7 @@ impl<'a> de::VariantVisitor for VariantDeserializer<'a> {\n                 visitor,\n             )\n         } else {\n-            Err(de::Error::syntax_error())\n+            Err(de::Error::syntax(\"expected a struct\"))\n         }\n     }\n }\n@@ -834,7 +834,7 @@ impl<'a> de::SeqVisitor for SeqDeserializer<'a> {\n         if self.len == 0 {\n             Ok(())\n         } else {\n-            Err(de::Error::end_of_stream_error())\n+            Err(de::Error::end_of_stream())\n         }\n     }\n \n@@ -879,7 +879,7 @@ impl<'a> de::MapVisitor for MapDeserializer<'a> {\n         if self.len == 0 {\n             Ok(())\n         } else {\n-            Err(de::Error::end_of_stream_error())\n+            Err(de::Error::end_of_stream())\n         }\n     }\n \n", "test_patch": "diff --git a/serde_tests/benches/bench_enum.rs b/serde_tests/benches/bench_enum.rs\nindex b97c20cc6..0367df8b6 100644\n--- a/serde_tests/benches/bench_enum.rs\n+++ b/serde_tests/benches/bench_enum.rs\n@@ -20,13 +20,13 @@ pub enum Error {\n }\n \n impl serde::de::Error for Error {\n-    fn syntax_error() -> Error { Error::SyntaxError }\n+    fn syntax(_: &str) -> Error { Error::SyntaxError }\n \n-    fn end_of_stream_error() -> Error { Error::EndOfStreamError }\n+    fn end_of_stream() -> Error { Error::EndOfStreamError }\n \n-    fn unknown_field_error(_: &str) -> Error { Error::SyntaxError }\n+    fn unknown_field(_: &str) -> Error { Error::SyntaxError }\n \n-    fn missing_field_error(_: &'static str) -> Error { Error::SyntaxError }\n+    fn missing_field(_: &'static str) -> Error { Error::SyntaxError }\n }\n \n //////////////////////////////////////////////////////////////////////////////\ndiff --git a/serde_tests/benches/bench_map.rs b/serde_tests/benches/bench_map.rs\nindex d8c7c285d..2f5b1bcaa 100644\n--- a/serde_tests/benches/bench_map.rs\n+++ b/serde_tests/benches/bench_map.rs\n@@ -17,13 +17,13 @@ pub enum Error {\n }\n \n impl serde::de::Error for Error {\n-    fn syntax_error() -> Error { Error::SyntaxError }\n+    fn syntax(_: &str) -> Error { Error::SyntaxError }\n \n-    fn end_of_stream_error() -> Error { Error::EndOfStream }\n+    fn end_of_stream() -> Error { Error::EndOfStream }\n \n-    fn unknown_field_error(_: &str) -> Error { Error::SyntaxError }\n+    fn unknown_field(_: &str) -> Error { Error::SyntaxError }\n \n-    fn missing_field_error(_: &'static str) -> Error {\n+    fn missing_field(_: &'static str) -> Error {\n         Error::MissingField\n     }\n }\n@@ -347,17 +347,17 @@ mod deserializer {\n \n     impl de::Deserializer<Error> for IsizeDeserializer {\n         #[inline]\n-        fn end_of_stream_error(&mut self) -> Error {\n+        fn end_of_stream(&mut self) -> Error {\n             EndOfStream\n         }\n \n         #[inline]\n-        fn syntax_error(&mut self, _token: de::Token, _expected: &[de::TokenKind]) -> Error {\n+        fn syntax(&mut self, _token: de::Token, _expected: &[de::TokenKind]) -> Error {\n             SyntaxError\n         }\n \n         #[inline]\n-        fn unexpected_name_error(&mut self, _token: de::Token) -> Error {\n+        fn unexpected_name(&mut self, _token: de::Token) -> Error {\n             SyntaxError\n         }\n \ndiff --git a/serde_tests/benches/bench_struct.rs b/serde_tests/benches/bench_struct.rs\nindex 6c76eaef2..0e53d1a3f 100644\n--- a/serde_tests/benches/bench_struct.rs\n+++ b/serde_tests/benches/bench_struct.rs\n@@ -33,13 +33,13 @@ pub enum Error {\n }\n \n impl serde::de::Error for Error {\n-    fn syntax_error() -> Error { Error::SyntaxError }\n+    fn syntax(_: &str) -> Error { Error::SyntaxError }\n \n-    fn end_of_stream_error() -> Error { Error::EndOfStream }\n+    fn end_of_stream() -> Error { Error::EndOfStream }\n \n-    fn unknown_field_error(_: &str) -> Error { Error::SyntaxError }\n+    fn unknown_field(_: &str) -> Error { Error::SyntaxError }\n \n-    fn missing_field_error(_: &'static str) -> Error {\n+    fn missing_field(_: &'static str) -> Error {\n         Error::MissingField\n     }\n }\ndiff --git a/serde_tests/benches/bench_vec.rs b/serde_tests/benches/bench_vec.rs\nindex 9a16d9dde..450d3f1b8 100644\n--- a/serde_tests/benches/bench_vec.rs\n+++ b/serde_tests/benches/bench_vec.rs\n@@ -15,13 +15,13 @@ pub enum Error {\n }\n \n impl serde::de::Error for Error {\n-    fn syntax_error() -> Error { Error::SyntaxError }\n+    fn syntax(_: &str) -> Error { Error::SyntaxError }\n \n-    fn end_of_stream_error() -> Error { Error::EndOfStreamError }\n+    fn end_of_stream() -> Error { Error::EndOfStreamError }\n \n-    fn unknown_field_error(_: &str) -> Error { Error::SyntaxError }\n+    fn unknown_field(_: &str) -> Error { Error::SyntaxError }\n \n-    fn missing_field_error(_: &'static str) -> Error { Error::SyntaxError }\n+    fn missing_field(_: &'static str) -> Error { Error::SyntaxError }\n }\n \n //////////////////////////////////////////////////////////////////////////////\ndiff --git a/serde_tests/tests/test_bytes.rs b/serde_tests/tests/test_bytes.rs\nindex 3ca97285a..d0e8227a1 100644\n--- a/serde_tests/tests/test_bytes.rs\n+++ b/serde_tests/tests/test_bytes.rs\n@@ -9,13 +9,13 @@ use serde_json;\n struct Error;\n \n impl serde::de::Error for Error {\n-    fn syntax_error() -> Error { Error }\n+    fn syntax(_: &str) -> Error { Error }\n \n-    fn end_of_stream_error() -> Error { Error }\n+    fn end_of_stream() -> Error { Error }\n \n-    fn unknown_field_error(_field: &str) -> Error { Error }\n+    fn unknown_field(_field: &str) -> Error { Error }\n \n-    fn missing_field_error(_field: &'static str) -> Error { Error }\n+    fn missing_field(_field: &'static str) -> Error { Error }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\ndiff --git a/serde_tests/tests/test_de.rs b/serde_tests/tests/test_de.rs\nindex 6f45a0afa..5c9448891 100644\n--- a/serde_tests/tests/test_de.rs\n+++ b/serde_tests/tests/test_de.rs\n@@ -68,15 +68,15 @@ enum Error {\n }\n \n impl de::Error for Error {\n-    fn syntax_error() -> Error { Error::SyntaxError }\n+    fn syntax(_: &str) -> Error { Error::SyntaxError }\n \n-    fn end_of_stream_error() -> Error { Error::EndOfStreamError }\n+    fn end_of_stream() -> Error { Error::EndOfStreamError }\n \n-    fn unknown_field_error(field: &str) -> Error {\n+    fn unknown_field(field: &str) -> Error {\n         Error::UnknownFieldError(field.to_string())\n     }\n \n-    fn missing_field_error(field: &'static str) -> Error {\n+    fn missing_field(field: &'static str) -> Error {\n         Error::MissingFieldError(field)\n     }\n }\n", "problem_statement": "Extend `de::Error` to signal more cases of errors\nMaybe we could strip off the `_error` suffix, it's already clear due to the name of the trait. I usually call these method using `de::Error::syntax_error()`.\n\nI often parse some data coming in via `visit_str` and other visitors into specialized types. There are additional error cases when a constraint is not met, for example parsing a string as UUID. How to handle such errors?\n\nOne could argue that these errors are not related to serialization/deserialization, but validation. That means that validation errors should be embedded (like it's done in `io::Error`?).\n\nOtherwise we could add some more methods to `de::Error`. I'd like to change `fn syntax_error() -> Self` to `fn syntax(msg: &str) -> Self` because I (ab)use it to signal validation errors and have no way to transport which constraint was violated. Which error conditions you like to see included?\n\nCurrent trait definition of `de::Error`:\n\n``` rust\npub trait Error {\n    fn syntax_error() -> Self;\n\n    fn end_of_stream_error() -> Self;\n\n    fn unknown_field_error(field: &str) -> Self;\n\n    fn missing_field_error(field: &'static str) -> Self;\n}\n```\n\n", "hints_text": "", "created_at": "2015-08-07T14:54:21Z", "version": "0.5"}, {"repo": "serde-rs/serde", "pull_number": 127, "instance_id": "serde-rs__serde-127", "issue_numbers": ["89"], "base_commit": "199ed417bd6afc2071d17759b8c7e0ab8d0ba4cc", "patch": "diff --git a/serde_json/src/de.rs b/serde_json/src/de.rs\nindex 044918993..c66b50071 100644\n--- a/serde_json/src/de.rs\n+++ b/serde_json/src/de.rs\n@@ -28,49 +28,61 @@ impl<Iter> Deserializer<Iter>\n {\n     /// Creates the JSON parser from an `std::iter::Iterator`.\n     #[inline]\n-    pub fn new(rdr: Iter) -> Result<Deserializer<Iter>> {\n-        let mut deserializer = Deserializer {\n+    pub fn new(rdr: Iter) -> Deserializer<Iter> {\n+        Deserializer {\n             rdr: LineColIterator::new(rdr),\n             ch: None,\n             str_buf: Vec::with_capacity(128),\n-        };\n-\n-        try!(deserializer.bump());\n-\n-        Ok(deserializer)\n+        }\n     }\n \n     #[inline]\n     pub fn end(&mut self) -> Result<()> {\n         try!(self.parse_whitespace());\n-        if self.eof() {\n+        if try!(self.eof()) {\n             Ok(())\n         } else {\n             Err(self.error(ErrorCode::TrailingCharacters))\n         }\n     }\n \n-    fn eof(&self) -> bool { self.ch.is_none() }\n+    fn eof(&mut self) -> Result<bool> {\n+        Ok(try!(self.peek()).is_none())\n+    }\n \n-    fn ch_or_null(&self) -> u8 { self.ch.unwrap_or(b'\\x00') }\n+    fn peek(&mut self) -> Result<Option<u8>> {\n+        match self.ch {\n+            Some(ch) => Ok(Some(ch)),\n+            None => {\n+                self.ch = try!(self.next_char());\n+                Ok(self.ch)\n+            }\n+        }\n+    }\n \n-    fn bump(&mut self) -> Result<()> {\n-        self.ch = match self.rdr.next() {\n-            Some(Err(err)) => { return Err(Error::IoError(err)); }\n-            Some(Ok(ch)) => Some(ch),\n-            None => None,\n-        };\n+    fn peek_or_null(&mut self) -> Result<u8> {\n+        Ok(try!(self.peek()).unwrap_or(b'\\x00'))\n+    }\n \n-        Ok(())\n+    fn eat_char(&mut self) {\n+        self.ch = None;\n     }\n \n     fn next_char(&mut self) -> Result<Option<u8>> {\n-        try!(self.bump());\n-        Ok(self.ch)\n+        match self.ch.take() {\n+            Some(ch) => Ok(Some(ch)),\n+            None => {\n+                match self.rdr.next() {\n+                    Some(Err(err)) => Err(Error::IoError(err)),\n+                    Some(Ok(ch)) => Ok(Some(ch)),\n+                    None => Ok(None),\n+                }\n+            }\n+        }\n     }\n \n-    fn ch_is(&self, c: u8) -> bool {\n-        self.ch == Some(c)\n+    fn next_char_or_null(&mut self) -> Result<u8> {\n+        Ok(try!(self.next_char()).unwrap_or(b'\\x00'))\n     }\n \n     fn error(&mut self, reason: ErrorCode) -> Error {\n@@ -78,12 +90,14 @@ impl<Iter> Deserializer<Iter>\n     }\n \n     fn parse_whitespace(&mut self) -> Result<()> {\n-        while self.ch_is(b' ') ||\n-              self.ch_is(b'\\n') ||\n-              self.ch_is(b'\\t') ||\n-              self.ch_is(b'\\r') { try!(self.bump()); }\n-\n-        Ok(())\n+        loop {\n+            match try!(self.peek_or_null()) {\n+                b' ' | b'\\n' | b'\\t' | b'\\r' => {\n+                    self.eat_char();\n+                }\n+                _ => { return Ok(()); }\n+            }\n+        }\n     }\n \n     fn parse_value<V>(&mut self, mut visitor: V) -> Result<V::Value>\n@@ -91,41 +105,45 @@ impl<Iter> Deserializer<Iter>\n     {\n         try!(self.parse_whitespace());\n \n-        if self.eof() {\n+        if try!(self.eof()) {\n             return Err(self.error(ErrorCode::EOFWhileParsingValue));\n         }\n \n-        let value = match self.ch_or_null() {\n+        let value = match try!(self.peek_or_null()) {\n             b'n' => {\n+                self.eat_char();\n                 try!(self.parse_ident(b\"ull\"));\n                 visitor.visit_unit()\n             }\n             b't' => {\n+                self.eat_char();\n                 try!(self.parse_ident(b\"rue\"));\n                 visitor.visit_bool(true)\n             }\n             b'f' => {\n+                self.eat_char();\n                 try!(self.parse_ident(b\"alse\"));\n                 visitor.visit_bool(false)\n             }\n             b'-' => {\n-                try!(self.bump());\n+                self.eat_char();\n                 self.parse_integer(false, visitor)\n             }\n             b'0' ... b'9' => {\n                 self.parse_integer(true, visitor)\n             }\n             b'\"' => {\n+                self.eat_char();\n                 try!(self.parse_string());\n                 let s = str::from_utf8(&self.str_buf).unwrap();\n                 visitor.visit_str(s)\n             }\n             b'[' => {\n-                try!(self.bump());\n+                self.eat_char();\n                 visitor.visit_seq(SeqVisitor::new(self))\n             }\n             b'{' => {\n-                try!(self.bump());\n+                self.eat_char();\n                 visitor.visit_map(MapVisitor::new(self))\n             }\n             _ => {\n@@ -147,19 +165,16 @@ impl<Iter> Deserializer<Iter>\n             }\n         }\n \n-        try!(self.bump());\n         Ok(())\n     }\n \n     fn parse_integer<V>(&mut self, pos: bool, visitor: V) -> Result<V::Value>\n         where V: de::Visitor,\n     {\n-        match self.ch_or_null() {\n+        match try!(self.next_char_or_null()) {\n             b'0' => {\n-                try!(self.bump());\n-\n                 // There can be only one leading '0'.\n-                match self.ch_or_null() {\n+                match try!(self.peek_or_null()) {\n                     b'0' ... b'9' => {\n                         Err(self.error(ErrorCode::InvalidNumber))\n                     }\n@@ -169,14 +184,12 @@ impl<Iter> Deserializer<Iter>\n                 }\n             },\n             c @ b'1' ... b'9' => {\n-                try!(self.bump());\n-\n                 let mut res: u64 = (c as u64) - ('0' as u64);\n \n                 loop {\n-                    match self.ch_or_null() {\n+                    match try!(self.peek_or_null()) {\n                         c @ b'0' ... b'9' => {\n-                            try!(self.bump());\n+                            self.eat_char();\n \n                             let digit = (c as u64) - ('0' as u64);\n \n@@ -212,17 +225,15 @@ impl<Iter> Deserializer<Iter>\n         where V: de::Visitor,\n     {\n         loop {\n-            match self.ch_or_null() {\n+            match try!(self.next_char_or_null()) {\n                 c @ b'0' ... b'9' => {\n-                    try!(self.bump());\n-\n                     let digit = (c as u64) - ('0' as u64);\n \n                     res *= 10.0;\n                     res += digit as f64;\n                 }\n                 _ => {\n-                    match self.ch_or_null() {\n+                    match try!(self.peek_or_null()) {\n                         b'.' => {\n                             return self.parse_decimal(pos, res, visitor);\n                         }\n@@ -248,7 +259,7 @@ impl<Iter> Deserializer<Iter>\n                        mut visitor: V) -> Result<V::Value>\n         where V: de::Visitor,\n     {\n-        match self.ch_or_null() {\n+        match try!(self.peek_or_null()) {\n             b'.' => {\n                 self.parse_decimal(pos, res as f64, visitor)\n             }\n@@ -280,31 +291,31 @@ impl<Iter> Deserializer<Iter>\n                         mut visitor: V) -> Result<V::Value>\n         where V: de::Visitor,\n     {\n-        try!(self.bump());\n+        self.eat_char();\n \n         let mut dec = 0.1;\n \n         // Make sure a digit follows the decimal place.\n-        match self.ch_or_null() {\n+        match try!(self.next_char_or_null()) {\n             c @ b'0' ... b'9' => {\n-                try!(self.bump());\n                 res += (((c as u64) - (b'0' as u64)) as f64) * dec;\n             }\n              _ => { return Err(self.error(ErrorCode::InvalidNumber)); }\n         }\n \n-        while !self.eof() {\n-            match self.ch_or_null() {\n+        loop {\n+            match try!(self.peek_or_null()) {\n                 c @ b'0' ... b'9' => {\n+                    self.eat_char();\n+\n                     dec /= 10.0;\n                     res += (((c as u64) - (b'0' as u64)) as f64) * dec;\n-                    try!(self.bump());\n                 }\n-                _ => break,\n+                _ => { break; }\n             }\n         }\n \n-        match self.ch_or_null() {\n+        match try!(self.peek_or_null()) {\n             b'e' | b'E' => {\n                 self.parse_exponent(pos, res, visitor)\n             }\n@@ -325,27 +336,24 @@ impl<Iter> Deserializer<Iter>\n                          mut visitor: V) -> Result<V::Value>\n         where V: de::Visitor,\n     {\n-        try!(self.bump());\n+        self.eat_char();\n \n-        let pos_exp = match self.ch_or_null() {\n-            b'+' => { try!(self.bump()); true }\n-            b'-' => { try!(self.bump()); false }\n+        let pos_exp = match try!(self.peek_or_null()) {\n+            b'+' => { self.eat_char(); true }\n+            b'-' => { self.eat_char(); false }\n             _ => { true }\n         };\n \n         // Make sure a digit follows the exponent place.\n-        let mut exp = match self.ch_or_null() {\n-            c @ b'0' ... b'9' => {\n-                try!(self.bump());\n-                (c as u64) - (b'0' as u64)\n-            }\n+        let mut exp = match try!(self.next_char_or_null()) {\n+            c @ b'0' ... b'9' => { (c as u64) - (b'0' as u64) }\n             _ => { return Err(self.error(ErrorCode::InvalidNumber)); }\n         };\n \n         loop {\n-            match self.ch_or_null() {\n+            match try!(self.peek_or_null()) {\n                 c @ b'0' ... b'9' => {\n-                    try!(self.bump());\n+                    self.eat_char();\n \n                     exp = try_or_invalid!(self, exp.checked_mul(10));\n                     exp = try_or_invalid!(self, exp.checked_add((c as u64) - (b'0' as u64)));\n@@ -376,9 +384,8 @@ impl<Iter> Deserializer<Iter>\n     fn decode_hex_escape(&mut self) -> Result<u16> {\n         let mut i = 0;\n         let mut n = 0u16;\n-        while i < 4 && !self.eof() {\n-            try!(self.bump());\n-            n = match self.ch_or_null() {\n+        while i < 4 && !try!(self.eof()) {\n+            n = match try!(self.next_char_or_null()) {\n                 c @ b'0' ... b'9' => n * 16_u16 + ((c as u16) - (b'0' as u16)),\n                 b'a' | b'A' => n * 16_u16 + 10_u16,\n                 b'b' | b'B' => n * 16_u16 + 11_u16,\n@@ -411,7 +418,6 @@ impl<Iter> Deserializer<Iter>\n \n             match ch {\n                 b'\"' => {\n-                    try!(self.bump());\n                     return Ok(());\n                 }\n                 b'\\\\' => {\n@@ -492,13 +498,10 @@ impl<Iter> Deserializer<Iter>\n     fn parse_object_colon(&mut self) -> Result<()> {\n         try!(self.parse_whitespace());\n \n-        if self.ch_is(b':') {\n-            try!(self.bump());\n-            Ok(())\n-        } else if self.eof() {\n-            Err(self.error(ErrorCode::EOFWhileParsingObject))\n-        } else {\n-            Err(self.error(ErrorCode::ExpectedColon))\n+        match try!(self.next_char()) {\n+            Some(b':') => Ok(()),\n+            Some(_) => Err(self.error(ErrorCode::ExpectedColon)),\n+            None => Err(self.error(ErrorCode::EOFWhileParsingObject)),\n         }\n     }\n }\n@@ -515,24 +518,26 @@ impl<Iter> de::Deserializer for Deserializer<Iter>\n         self.parse_value(visitor)\n     }\n \n+    /// Parses a `null` as a None, and any other values as a `Some(...)`.\n     #[inline]\n     fn visit_option<V>(&mut self, mut visitor: V) -> Result<V::Value>\n         where V: de::Visitor,\n     {\n         try!(self.parse_whitespace());\n \n-        if self.eof() {\n-            return Err(self.error(ErrorCode::EOFWhileParsingValue));\n-        }\n-\n-        if self.ch_is(b'n') {\n-            try!(self.parse_ident(b\"ull\"));\n-            visitor.visit_none()\n-        } else {\n-            visitor.visit_some(self)\n+        match try!(self.peek_or_null()) {\n+            b'n' => {\n+                self.eat_char();\n+                try!(self.parse_ident(b\"ull\"));\n+                visitor.visit_none()\n+            }\n+            _ => {\n+                visitor.visit_some(self)\n+            }\n         }\n     }\n \n+    /// Parses a newtype struct as the underlying value.\n     #[inline]\n     fn visit_newtype_struct<V>(&mut self,\n                                _name: &str,\n@@ -542,6 +547,8 @@ impl<Iter> de::Deserializer for Deserializer<Iter>\n         visitor.visit_newtype_struct(self)\n     }\n \n+    /// Parses an enum as an object like `{\"$KEY\":$VALUE}`, where $VALUE is either a straight\n+    /// value, a `[..]`, or a `{..}`.\n     #[inline]\n     fn visit_enum<V>(&mut self,\n                      _name: &str,\n@@ -551,24 +558,28 @@ impl<Iter> de::Deserializer for Deserializer<Iter>\n     {\n         try!(self.parse_whitespace());\n \n-        if self.ch_is(b'{') {\n-            try!(self.bump());\n-            try!(self.parse_whitespace());\n+        match try!(self.next_char_or_null()) {\n+            b'{' => {\n+                try!(self.parse_whitespace());\n \n-            let value = {\n-                try!(visitor.visit(&mut *self))\n-            };\n+                let value = {\n+                    try!(visitor.visit(&mut *self))\n+                };\n \n-            try!(self.parse_whitespace());\n+                try!(self.parse_whitespace());\n \n-            if self.ch_is(b'}') {\n-                try!(self.bump());\n-                Ok(value)\n-            } else {\n+                match try!(self.next_char_or_null()) {\n+                    b'}' => {\n+                        Ok(value)\n+                    }\n+                    _ => {\n+                        Err(self.error(ErrorCode::ExpectedSomeValue))\n+                    }\n+                }\n+            }\n+            _ => {\n                 Err(self.error(ErrorCode::ExpectedSomeValue))\n             }\n-        } else {\n-            Err(self.error(ErrorCode::ExpectedSomeValue))\n         }\n     }\n \n@@ -602,19 +613,22 @@ impl<'a, Iter> de::SeqVisitor for SeqVisitor<'a, Iter>\n     {\n         try!(self.de.parse_whitespace());\n \n-        if self.de.ch_is(b']') {\n-            return Ok(None);\n-        }\n-\n-        if self.first {\n-            self.first = false;\n-        } else {\n-            if self.de.ch_is(b',') {\n-                try!(self.de.bump());\n-            } else if self.de.eof() {\n+        match try!(self.de.peek()) {\n+            Some(b']') => {\n+                return Ok(None);\n+            }\n+            Some(b',') if !self.first => {\n+                self.de.eat_char();\n+            }\n+            Some(_) => {\n+                if self.first {\n+                    self.first = false;\n+                } else {\n+                    return Err(self.de.error(ErrorCode::ExpectedListCommaOrEnd));\n+                }\n+            }\n+            None => {\n                 return Err(self.de.error(ErrorCode::EOFWhileParsingList));\n-            } else {\n-                return Err(self.de.error(ErrorCode::ExpectedListCommaOrEnd));\n             }\n         }\n \n@@ -625,12 +639,14 @@ impl<'a, Iter> de::SeqVisitor for SeqVisitor<'a, Iter>\n     fn end(&mut self) -> Result<()> {\n         try!(self.de.parse_whitespace());\n \n-        if self.de.ch_is(b']') {\n-            self.de.bump()\n-        } else if self.de.eof() {\n-            Err(self.de.error(ErrorCode::EOFWhileParsingList))\n-        } else {\n-            Err(self.de.error(ErrorCode::TrailingCharacters))\n+        match try!(self.de.next_char()) {\n+            Some(b']') => { Ok(()) }\n+            Some(_) => {\n+                Err(self.de.error(ErrorCode::TrailingCharacters))\n+            }\n+            None => {\n+                Err(self.de.error(ErrorCode::EOFWhileParsingList))\n+            }\n         }\n     }\n }\n@@ -659,32 +675,37 @@ impl<'a, Iter> de::MapVisitor for MapVisitor<'a, Iter>\n     {\n         try!(self.de.parse_whitespace());\n \n-        if self.de.ch_is(b'}') {\n-            return Ok(None);\n-        }\n-\n-        if self.first {\n-            self.first = false;\n-        } else {\n-            if self.de.ch_is(b',') {\n-                try!(self.de.bump());\n+        match try!(self.de.peek()) {\n+            Some(b'}') => {\n+                return Ok(None);\n+            }\n+            Some(b',') if !self.first => {\n+                self.de.eat_char();\n                 try!(self.de.parse_whitespace());\n-            } else if self.de.eof() {\n+            }\n+            Some(_) => {\n+                if self.first {\n+                    self.first = false;\n+                } else {\n+                    return Err(self.de.error(ErrorCode::ExpectedObjectCommaOrEnd));\n+                }\n+            }\n+            None => {\n                 return Err(self.de.error(ErrorCode::EOFWhileParsingObject));\n-            } else {\n-                return Err(self.de.error(ErrorCode::ExpectedObjectCommaOrEnd));\n             }\n         }\n \n-        if self.de.eof() {\n-            return Err(self.de.error(ErrorCode::EOFWhileParsingValue));\n-        }\n-\n-        if !self.de.ch_is(b'\"') {\n-            return Err(self.de.error(ErrorCode::KeyMustBeAString));\n+        match try!(self.de.peek()) {\n+            Some(b'\"') => {\n+                Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n+            }\n+            Some(_) => {\n+                Err(self.de.error(ErrorCode::KeyMustBeAString))\n+            }\n+            None => {\n+                Err(self.de.error(ErrorCode::EOFWhileParsingValue))\n+            }\n         }\n-\n-        Ok(Some(try!(de::Deserialize::deserialize(self.de))))\n     }\n \n     fn visit_value<V>(&mut self) -> Result<V>\n@@ -698,13 +719,14 @@ impl<'a, Iter> de::MapVisitor for MapVisitor<'a, Iter>\n     fn end(&mut self) -> Result<()> {\n         try!(self.de.parse_whitespace());\n \n-        if self.de.ch_is(b'}') {\n-            try!(self.de.bump());\n-            Ok(())\n-        } else if self.de.eof() {\n-            Err(self.de.error(ErrorCode::EOFWhileParsingObject))\n-        } else {\n-            Err(self.de.error(ErrorCode::TrailingCharacters))\n+        match try!(self.de.next_char()) {\n+            Some(b'}') => { Ok(()) }\n+            Some(_) => {\n+                Err(self.de.error(ErrorCode::TrailingCharacters))\n+            }\n+            None => {\n+                Err(self.de.error(ErrorCode::EOFWhileParsingObject))\n+            }\n         }\n     }\n \n@@ -761,7 +783,7 @@ pub fn from_iter<I, T>(iter: I) -> Result<T>\n     where I: Iterator<Item=io::Result<u8>>,\n           T: de::Deserialize,\n {\n-    let mut de = try!(Deserializer::new(iter));\n+    let mut de = Deserializer::new(iter);\n     let value = try!(de::Deserialize::deserialize(&mut de));\n \n     // Make sure the whole stream has been consumed.\n", "test_patch": "diff --git a/serde_tests/tests/test_json.rs b/serde_tests/tests/test_json.rs\nindex d8e177b76..934cbcc40 100644\n--- a/serde_tests/tests/test_json.rs\n+++ b/serde_tests/tests/test_json.rs\n@@ -728,7 +728,7 @@ fn test_parse_number_errors() {\n         (\"1e\", Error::SyntaxError(ErrorCode::InvalidNumber, 1, 2)),\n         (\"1e+\", Error::SyntaxError(ErrorCode::InvalidNumber, 1, 3)),\n         (\"1a\", Error::SyntaxError(ErrorCode::TrailingCharacters, 1, 2)),\n-        (\"1e777777777777777777777777777\", Error::SyntaxError(ErrorCode::InvalidNumber, 1, 23)),\n+        (\"1e777777777777777777777777777\", Error::SyntaxError(ErrorCode::InvalidNumber, 1, 22)),\n     ]);\n }\n \n@@ -804,8 +804,8 @@ fn test_parse_string() {\n #[test]\n fn test_parse_list() {\n     test_parse_err::<Vec<f64>>(vec![\n-        (\"[\", Error::SyntaxError(ErrorCode::EOFWhileParsingValue, 1, 1)),\n-        (\"[ \", Error::SyntaxError(ErrorCode::EOFWhileParsingValue, 1, 2)),\n+        (\"[\", Error::SyntaxError(ErrorCode::EOFWhileParsingList, 1, 1)),\n+        (\"[ \", Error::SyntaxError(ErrorCode::EOFWhileParsingList, 1, 2)),\n         (\"[1\", Error::SyntaxError(ErrorCode::EOFWhileParsingList,  1, 2)),\n         (\"[1,\", Error::SyntaxError(ErrorCode::EOFWhileParsingValue, 1, 3)),\n         (\"[1,]\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 4)),\n@@ -856,8 +856,8 @@ fn test_parse_list() {\n #[test]\n fn test_parse_object() {\n     test_parse_err::<BTreeMap<String, u32>>(vec![\n-        (\"{\", Error::SyntaxError(ErrorCode::EOFWhileParsingValue, 1, 1)),\n-        (\"{ \", Error::SyntaxError(ErrorCode::EOFWhileParsingValue, 1, 2)),\n+        (\"{\", Error::SyntaxError(ErrorCode::EOFWhileParsingObject, 1, 1)),\n+        (\"{ \", Error::SyntaxError(ErrorCode::EOFWhileParsingObject, 1, 2)),\n         (\"{1\", Error::SyntaxError(ErrorCode::KeyMustBeAString, 1, 2)),\n         (\"{ \\\"a\\\"\", Error::SyntaxError(ErrorCode::EOFWhileParsingObject, 1, 5)),\n         (\"{\\\"a\\\"\", Error::SyntaxError(ErrorCode::EOFWhileParsingObject, 1, 4)),\n@@ -909,7 +909,7 @@ fn test_parse_struct() {\n     test_parse_err::<Outer>(vec![\n         (\"5\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 1)),\n         (\"\\\"hello\\\"\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 7)),\n-        (\"{\\\"inner\\\": true}\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 15)),\n+        (\"{\\\"inner\\\": true}\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 14)),\n     ]);\n \n     test_parse_ok(vec![\n@@ -988,9 +988,9 @@ fn test_parse_enum_errors() {\n         (\"{}\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 2)),\n         (\"{\\\"Dog\\\":\", Error::SyntaxError(ErrorCode::EOFWhileParsingValue, 1, 7)),\n         (\"{\\\"Dog\\\":}\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 8)),\n-        (\"{\\\"unknown\\\":[]}\", Error::SyntaxError(ErrorCode::UnknownField(\"unknown\".to_string()), 1, 11)),\n-        (\"{\\\"Dog\\\":{}}\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 9)),\n-        (\"{\\\"Frog\\\":{}}\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 10)),\n+        (\"{\\\"unknown\\\":[]}\", Error::SyntaxError(ErrorCode::UnknownField(\"unknown\".to_string()), 1, 10)),\n+        (\"{\\\"Dog\\\":{}}\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 8)),\n+        (\"{\\\"Frog\\\":{}}\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 9)),\n         (\"{\\\"Cat\\\":[]}\", Error::SyntaxError(ErrorCode::EOFWhileParsingValue, 1, 9)),\n     ]);\n }\n@@ -1311,3 +1311,40 @@ fn test_serialize_map_with_no_len() {\n         )\n     );\n }\n+\n+#[test]\n+fn test_deserialize_from_stream() {\n+    use std::net;\n+    use std::io::Read;\n+    use std::thread;\n+    use serde::Deserialize;\n+\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    struct Message {\n+        message: String,\n+    }\n+\n+    let l = net::TcpListener::bind(\"localhost:20000\").unwrap();\n+\n+    thread::spawn(|| {\n+        let l = l;\n+        for stream in l.incoming() {\n+            let mut stream = stream.unwrap();\n+            let read_stream = stream.try_clone().unwrap();\n+\n+            let mut de = serde_json::Deserializer::new(read_stream.bytes());\n+            let request = Message::deserialize(&mut de).unwrap();\n+            let response = Message { message: request.message };\n+            serde_json::to_writer(&mut stream, &response).unwrap();\n+        }\n+    });\n+\n+    let mut stream = net::TcpStream::connect(\"localhost:20000\").unwrap();\n+    let request = Message { message: \"hi there\".to_string() };\n+    serde_json::to_writer(&mut stream, &request).unwrap();\n+\n+    let mut de = serde_json::Deserializer::new(stream.bytes());\n+    let response = Message::deserialize(&mut de).unwrap();\n+\n+    assert_eq!(request, response);\n+}\n", "problem_statement": "Allow deserializing without consuming the entire stream\nMy use case for this is deserializing more than one json object from a tcp connection. Currently you can't open one connection and send objects back and forth because `serde::json::de::from_reader` hangs until eof.\n\n", "hints_text": "Hello @shaladdle! You should be able to directly use `serde::json::de::Deserializer` to do what you want.\n\nThanks for the response! Sorry for taking a while to reply. I was able to get some time to try again with your suggestion, but I still get the same behavior. The receiver doesn't finish deserialization unless the sender closes the connection. Here's an example:\n\n``` rust\n#![feature(custom_derive, plugin)]\n#![plugin(serde_macros)]\n\nextern crate serde;\n\nuse std::net;\nuse std::io::Read;\nuse std::thread;\nuse serde::Deserialize;\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Request {\n    message: String,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Response {\n    message: String,\n}\n\nfn main() {\n    let l = net::TcpListener::bind(\"localhost:20000\").unwrap();\n    thread::spawn(||{\n        let l = l;\n        for stream in l.incoming() {\n            let mut stream = stream.unwrap();\n            let read_stream = stream.try_clone().unwrap();\n            let mut de = serde::json::Deserializer::new(read_stream.bytes()).unwrap();\n            println!(\"deserializing\");\n            let request = Request::deserialize(&mut de).unwrap();\n            println!(\"deserialized\");\n            let response = Response{message: request.message};\n            serde::json::to_writer(&mut stream, &response).unwrap();\n        }\n    });\n    let mut stream = net::TcpStream::connect(\"localhost:20000\").unwrap();\n    let request = Request{message: \"hi there\".to_string()};\n    serde::json::to_writer(&mut stream, &request).unwrap();\n    println!(\"message sent\");\n    let mut de = serde::json::Deserializer::new(stream.bytes()).unwrap();\n    let response = Response::deserialize(&mut de).unwrap();\n    println!(\"response: {:?}\", response);\n}\n```\n\nI would expect to see something like the following for output:\n\n```\nmessage sent\ndeserializing\ndeserialized\nresponse: \"hi there\"\n```\n\nbut it hangs after \"deserializing\".\n\nThere was a strange behavior in `rustc-serialize`, that a just parsed token was not yielded back, because just after successful parsing the decoder has tried to read at least one more byte from the Read.\n\nTry to send over your TCP socket something like this: `{}1`, and if it succeed, then that bug was migrated into this project here.\n\nAh right. Some of the JSON constructs require looking one character ahead, which could trigger this. Maybe we're doing an unnecessary read? This will require some investigation.\n\nOk what's going on is that when we parse the end of an object, we call `bump()` [here](https://github.com/serde-rs/serde/blob/master/serde/src/json/de.rs#L472) in order to say we've consumed this character. That function then reads the next character [here](https://github.com/serde-rs/serde/blob/master/serde/src/json/de.rs#L57) to prep for the next token. This character is being stored in an `Option<u8>`, where `None` means that we've read everything from our stream.\n\nIt shouldn't be _that_ hard to rewrite the parser to only fetch the next character when it actually needs it, but we'll have to be careful it doesn't impact performance.\n", "created_at": "2015-08-06T18:12:52Z", "version": "0.5"}, {"repo": "serde-rs/serde", "pull_number": 118, "instance_id": "serde-rs__serde-118", "issue_numbers": ["99"], "base_commit": "447d08bd9121b871ab6d646bdeba66321a948194", "patch": "diff --git a/serde_codegen/src/attr.rs b/serde_codegen/src/attr.rs\nindex 9f08969df..e40155461 100644\n--- a/serde_codegen/src/attr.rs\n+++ b/serde_codegen/src/attr.rs\n@@ -16,14 +16,20 @@ pub enum FieldNames {\n \n /// Represents field attribute information\n pub struct FieldAttrs {\n+    skip_serializing_field: bool,\n     names: FieldNames,\n     use_default: bool,\n }\n \n impl FieldAttrs {\n     /// Create a FieldAttr with a single default field name\n-    pub fn new(default_value: bool, name: P<ast::Expr>) -> FieldAttrs {\n+    pub fn new(\n+        skip_serializing_field: bool,\n+        default_value: bool,\n+        name: P<ast::Expr>,\n+    ) -> FieldAttrs {\n         FieldAttrs {\n+            skip_serializing_field: skip_serializing_field,\n             names: FieldNames::Global(name),\n             use_default: default_value,\n         }\n@@ -31,12 +37,14 @@ impl FieldAttrs {\n \n     /// Create a FieldAttr with format specific field names\n     pub fn new_with_formats(\n+        skip_serializing_field: bool,\n         default_value: bool,\n         default_name: P<ast::Expr>,\n         formats: HashMap<P<ast::Expr>, P<ast::Expr>>,\n     ) -> FieldAttrs {\n         FieldAttrs {\n-            names:  FieldNames::Format {\n+            skip_serializing_field: skip_serializing_field,\n+            names: FieldNames::Format {\n                 formats: formats,\n                 default: default_name,\n             },\n@@ -104,4 +112,9 @@ impl FieldAttrs {\n     pub fn use_default(&self) -> bool {\n         self.use_default\n     }\n+\n+    /// Predicate for ignoring a field when serializing a value\n+    pub fn skip_serializing_field(&self) -> bool {\n+        self.skip_serializing_field\n+    }\n }\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex 3f949df00..f88f72980 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -483,6 +483,7 @@ fn deserialize_item_enum(\n         enum_def.variants.iter()\n             .map(|variant|\n                  attr::FieldAttrs::new(\n+                     false,\n                      true,\n                      builder.expr().str(variant.node.name)))\n             .collect()\ndiff --git a/serde_codegen/src/field.rs b/serde_codegen/src/field.rs\nindex 676e6cb71..6f10eacfb 100644\n--- a/serde_codegen/src/field.rs\n+++ b/serde_codegen/src/field.rs\n@@ -58,10 +58,18 @@ fn default_value(mi: &ast::MetaItem) -> bool {\n     }\n }\n \n+fn skip_serializing_field(mi: &ast::MetaItem) -> bool {\n+    if let ast::MetaItem_::MetaWord(ref n) = mi.node {\n+        n == &\"skip_serializing\"\n+    } else {\n+        false\n+    }\n+}\n+\n fn field_attrs<'a>(\n     builder: &aster::AstBuilder,\n     field: &'a ast::StructField,\n-) -> (Rename<'a>, bool) {\n+) -> (Rename<'a>, bool, bool) {\n     field.node.attrs.iter()\n         .find(|sa| {\n             if let ast::MetaList(ref n, _) = sa.node.value.node {\n@@ -73,15 +81,18 @@ fn field_attrs<'a>(\n         .and_then(|sa| {\n             if let ast::MetaList(_, ref vals) = sa.node.value.node {\n                 attr::mark_used(&sa);\n-                Some((vals.iter()\n-                      .fold(None, |v, mi| v.or(rename(builder, mi)))\n-                      .unwrap_or(Rename::None),\n-                      vals.iter().any(|mi| default_value(mi))))\n+                Some((\n+                    vals.iter()\n+                        .fold(None, |v, mi| v.or(rename(builder, mi)))\n+                        .unwrap_or(Rename::None),\n+                    vals.iter().any(|mi| default_value(mi)),\n+                    vals.iter().any(|mi| skip_serializing_field(mi)),\n+                ))\n             } else {\n-                Some((Rename::None, false))\n+                Some((Rename::None, false, false))\n             }\n         })\n-        .unwrap_or((Rename::None, false))\n+        .unwrap_or((Rename::None, false, false))\n }\n \n pub fn struct_field_attrs(\n@@ -92,23 +103,26 @@ pub fn struct_field_attrs(\n     struct_def.fields.iter()\n         .map(|field| {\n             match field_attrs(builder, field) {\n-                (Rename::Global(rename), default_value) =>\n+                (Rename::Global(rename), default_value, skip_serializing_field) =>\n                     FieldAttrs::new(\n+                        skip_serializing_field,\n                         default_value,\n                         builder.expr().build_lit(P(rename.clone()))),\n-                (Rename::Format(renames), default_value) => {\n+                (Rename::Format(renames), default_value, skip_serializing_field) => {\n                     let mut res = HashMap::new();\n                     res.extend(\n                         renames.into_iter()\n                             .map(|(k,v)|\n                                  (k, builder.expr().build_lit(P(v.clone())))));\n                     FieldAttrs::new_with_formats(\n+                        skip_serializing_field,\n                         default_value,\n                         default_field_name(cx, builder, field.node.kind),\n                         res)\n                 },\n-                (Rename::None, default_value) => {\n+                (Rename::None, default_value, skip_serializing_field) => {\n                     FieldAttrs::new(\n+                        skip_serializing_field,\n                         default_value,\n                         default_field_name(cx, builder, field.node.kind))\n                 }\ndiff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex 8c74e1199..ab4f21ea3 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -550,6 +550,7 @@ fn serialize_struct_visitor<I>(\n \n     let arms: Vec<ast::Arm> = field_attrs.into_iter()\n         .zip(value_exprs)\n+        .filter(|&(ref field, _)| !field.skip_serializing_field())\n         .enumerate()\n         .map(|(i, (field, value_expr))| {\n             let key_expr = field.serializer_key_expr(cx);\n", "test_patch": "diff --git a/serde_tests/tests/test_annotations.rs b/serde_tests/tests/test_annotations.rs\nindex 9a21e0bf7..9c963f8e2 100644\n--- a/serde_tests/tests/test_annotations.rs\n+++ b/serde_tests/tests/test_annotations.rs\n@@ -1,3 +1,4 @@\n+use std::default;\n use serde_json;\n \n #[derive(Debug, PartialEq, Serialize, Deserialize)]\n@@ -30,6 +31,12 @@ enum SerEnum<A> {\n     },\n }\n \n+#[derive(Debug, PartialEq, Deserialize, Serialize)]\n+struct SkipSerializingFields<A: default::Default> {\n+    a: i8,\n+    #[serde(skip_serializing, default)]\n+    b: A,\n+}\n \n #[test]\n fn test_default() {\n@@ -71,3 +78,13 @@ fn test_enum_format_rename() {\n     let deserialized_value = serde_json::from_str(ans).unwrap();\n     assert_eq!(value, deserialized_value);\n }\n+\n+#[test]\n+fn test_skip_serializing_fields() {\n+    let value = SkipSerializingFields { a: 1, b: 2 };\n+    let serialized_value = serde_json::to_string(&value).unwrap();\n+    assert_eq!(serialized_value, \"{\\\"a\\\":1}\");\n+\n+    let deserialized_value: SkipSerializingFields<_> = serde_json::from_str(&serialized_value).unwrap();\n+    assert_eq!(SkipSerializingFields { a: 1, b: 0 }, deserialized_value);\n+}\n", "problem_statement": "Add annotation that never serializes a particular value\nThis is particularly useful when a structure contains a non-serializable cached value.\n\n", "hints_text": "", "created_at": "2015-07-23T15:09:37Z", "version": "0.5"}, {"repo": "serde-rs/serde", "pull_number": 117, "instance_id": "serde-rs__serde-117", "issue_numbers": ["100"], "base_commit": "8663435a05d004ed982599ffbf72c875c4e08420", "patch": "diff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex ec8c6ccdc..8c74e1199 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -55,10 +55,7 @@ pub fn expand_derive_serialize(\n         &builder,\n         &item,\n         &impl_generics,\n-        builder.ty()\n-            .ref_()\n-            .lifetime(\"'__a\")\n-            .build_ty(ty.clone()),\n+        ty.clone(),\n     );\n \n     let where_clause = &impl_generics.where_clause;\n@@ -184,7 +181,10 @@ fn serialize_tuple_struct(\n         cx,\n         builder,\n         ty.clone(),\n-        ty,\n+        builder.ty()\n+            .ref_()\n+            .lifetime(\"'__a\")\n+            .build_ty(ty.clone()),\n         fields,\n         impl_generics,\n     );\n@@ -197,7 +197,7 @@ fn serialize_tuple_struct(\n         serializer.visit_tuple_struct($type_name, Visitor {\n             value: self,\n             state: 0,\n-            _structure_ty: ::std::marker::PhantomData,\n+            _structure_ty: ::std::marker::PhantomData::<&$ty>,\n         })\n     })\n }\n@@ -215,7 +215,10 @@ fn serialize_struct(\n         cx,\n         builder,\n         ty.clone(),\n-        ty,\n+        builder.ty()\n+            .ref_()\n+            .lifetime(\"'__a\")\n+            .build_ty(ty.clone()),\n         struct_def,\n         impl_generics,\n         fields.iter().map(|field| quote_expr!(cx, &self.value.$field)),\n@@ -229,7 +232,7 @@ fn serialize_struct(\n         serializer.visit_struct($type_name, Visitor {\n             value: self,\n             state: 0,\n-            _structure_ty: ::std::marker::PhantomData,\n+            _structure_ty: ::std::marker::PhantomData::<&$ty>,\n         })\n     })\n }\n@@ -383,7 +386,7 @@ fn serialize_tuple_variant(\n     let (visitor_struct, visitor_impl) = serialize_tuple_struct_visitor(\n         cx,\n         builder,\n-        structure_ty,\n+        structure_ty.clone(),\n         variant_ty,\n         args.len(),\n         generics,\n@@ -392,9 +395,7 @@ fn serialize_tuple_variant(\n     let value_expr = builder.expr().tuple()\n         .with_exprs(\n             fields.iter().map(|field| {\n-                builder.expr()\n-                    .addr_of()\n-                    .id(field)\n+                builder.expr().id(field)\n             })\n         )\n         .build();\n@@ -405,7 +406,7 @@ fn serialize_tuple_variant(\n         serializer.visit_enum_seq($type_name, $variant_index, $variant_name, Visitor {\n             value: $value_expr,\n             state: 0,\n-            _structure_ty: ::std::marker::PhantomData,\n+            _structure_ty: ::std::marker::PhantomData::<&$structure_ty>,\n         })\n     })\n }\n@@ -435,9 +436,7 @@ fn serialize_struct_variant(\n     let value_expr = builder.expr().tuple()\n         .with_exprs(\n             fields.iter().map(|field| {\n-                builder.expr()\n-                    .addr_of()\n-                    .id(field)\n+                builder.expr().id(field)\n             })\n         )\n         .build();\n@@ -445,7 +444,7 @@ fn serialize_struct_variant(\n     let (visitor_struct, visitor_impl) = serialize_struct_visitor(\n         cx,\n         builder,\n-        structure_ty,\n+        structure_ty.clone(),\n         value_ty,\n         struct_def,\n         generics,\n@@ -462,7 +461,7 @@ fn serialize_struct_variant(\n         serializer.visit_enum_map($type_name, $variant_index, $variant_name, Visitor {\n             value: $value_expr,\n             state: 0,\n-            _structure_ty: ::std::marker::PhantomData,\n+            _structure_ty: ::std::marker::PhantomData::<&$structure_ty>,\n         })\n     })\n }\n@@ -502,19 +501,12 @@ fn serialize_tuple_struct_visitor(\n         .strip_bounds()\n         .build();\n \n-    // Variants don't necessarily reference all generic lifetimes and type parameters,\n-    // so to avoid a compilation failure, we'll just add a phantom type to capture these\n-    // unused values.\n-    let structure_ty = builder.ty()\n-        .phantom_data()\n-        .build(structure_ty);\n-\n     (\n         quote_item!(cx,\n             struct Visitor $visitor_impl_generics $where_clause {\n                 state: usize,\n                 value: $variant_ty,\n-                _structure_ty: $structure_ty,\n+                _structure_ty: ::std::marker::PhantomData<&'__a $structure_ty>,\n             }\n         ).unwrap(),\n \n@@ -590,19 +582,12 @@ fn serialize_struct_visitor<I>(\n         .strip_bounds()\n         .build();\n \n-    // Variants don't necessarily reference all generic lifetimes and type parameters,\n-    // so to avoid a compilation failure, we'll just add a phantom type to capture these\n-    // unused values.\n-    let structure_ty = builder.ty()\n-        .phantom_data()\n-        .build(structure_ty);\n-\n     (\n         quote_item!(cx,\n             struct Visitor $visitor_impl_generics $where_clause {\n                 state: usize,\n                 value: $variant_ty,\n-                _structure_ty: $structure_ty,\n+                _structure_ty: ::std::marker::PhantomData<&'__a $structure_ty>,\n             }\n         ).unwrap(),\n \n", "test_patch": "diff --git a/serde_tests/tests/test_macros.rs b/serde_tests/tests/test_macros.rs\nindex d7af98557..3c41ca4c7 100644\n--- a/serde_tests/tests/test_macros.rs\n+++ b/serde_tests/tests/test_macros.rs\n@@ -131,6 +131,26 @@ enum Lifetimes<'a> {\n     NoLifetimeMap { a: i32 },\n }\n \n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+pub struct GenericStruct<T> {\n+    x: T,\n+}\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+pub struct GenericTupleStruct<T>(T);\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+pub enum GenericEnumSeq<T, E> {\n+    Ok(T),\n+    Err(E),\n+}\n+\n+#[derive(Debug, PartialEq, Serialize, Deserialize)]\n+pub enum GenericEnumMap<T, E> {\n+    Ok { x: T },\n+    Err { x: E },\n+}\n+\n #[test]\n fn test_named_unit() {\n     let named_unit = NamedUnit;\n@@ -475,3 +495,29 @@ fn test_lifetimes() {\n         \"{\\\"NoLifetimeMap\\\":{\\\"a\\\":5}}\"\n     );\n }\n+\n+#[test]\n+fn test_generic() {\n+    macro_rules! declare_tests {\n+        ($($ty:ty : $value:expr => $str:expr,)+) => {\n+            $({\n+                let value: $ty = $value;\n+\n+                let string = serde_json::to_string(&value).unwrap();\n+                assert_eq!(string, $str);\n+\n+                let expected: $ty = serde_json::from_str(&string).unwrap();\n+                assert_eq!(value, expected);\n+            })+\n+        }\n+    }\n+\n+    declare_tests!(\n+        GenericStruct<u32> : GenericStruct { x: 5 } => \"{\\\"x\\\":5}\",\n+        GenericTupleStruct<u32> : GenericTupleStruct(5) => \"[5]\",\n+        GenericEnumSeq<u32, u32> : GenericEnumSeq::Ok(5) => \"{\\\"Ok\\\":[5]}\",\n+        GenericEnumSeq<u32, u32> : GenericEnumSeq::Err(5) => \"{\\\"Err\\\":[5]}\",\n+        GenericEnumMap<u32, u32> : GenericEnumMap::Ok { x: 5 } => \"{\\\"Ok\\\":{\\\"x\\\":5}}\",\n+        GenericEnumMap<u32, u32> : GenericEnumMap::Err { x: 5 } => \"{\\\"Err\\\":{\\\"x\\\":5}}\",\n+    );\n+}\n", "problem_statement": "#[derive(Serialize)] causes type errors when used on a generic enum\nSTR:\n\n```\n#[derive(Serialize)]\npub enum SerializableResult<T,E> {\n    Ok(T),\n    Err(E),\n}\n```\n\n", "hints_text": "", "created_at": "2015-07-23T13:59:29Z", "version": "0.5"}, {"repo": "serde-rs/serde", "pull_number": 115, "instance_id": "serde-rs__serde-115", "issue_numbers": ["101"], "base_commit": "b2754c2c3bb9cae4ae7dc1d4ce5aa1275dc45dd4", "patch": "diff --git a/serde/src/json/ser.rs b/serde/src/json/ser.rs\nindex deaace30a..8c05948bc 100644\n--- a/serde/src/json/ser.rs\n+++ b/serde/src/json/ser.rs\n@@ -206,9 +206,11 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n         where T: ser::Serialize,\n     {\n         try!(self.formatter.comma(&mut self.writer, self.first));\n+        try!(value.serialize(self));\n+\n         self.first = false;\n \n-        value.serialize(self)\n+        Ok(())\n     }\n \n     #[inline]\n@@ -250,11 +252,14 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n               V: ser::Serialize,\n     {\n         try!(self.formatter.comma(&mut self.writer, self.first));\n-        self.first = false;\n \n         try!(key.serialize(self));\n         try!(self.formatter.colon(&mut self.writer));\n-        value.serialize(self)\n+        try!(value.serialize(self));\n+\n+        self.first = false;\n+\n+        Ok(())\n     }\n \n     #[inline]\n", "test_patch": "diff --git a/serde_tests/tests/test_json.rs b/serde_tests/tests/test_json.rs\nindex c29f82865..370632b14 100644\n--- a/serde_tests/tests/test_json.rs\n+++ b/serde_tests/tests/test_json.rs\n@@ -1,5 +1,6 @@\n-use std::fmt::Debug;\n use std::collections::BTreeMap;\n+use std::fmt::Debug;\n+use std::marker::PhantomData;\n \n use serde::de;\n use serde::ser;\n@@ -1079,3 +1080,174 @@ fn test_lookup() {\n     assert!(obj.lookup(\"y\").unwrap() == &Value::U64(2));\n     assert!(obj.lookup(\"z\").is_none());\n }\n+\n+#[test]\n+fn test_serialize_seq_with_no_len() {\n+    #[derive(Clone, Debug, PartialEq)]\n+    struct MyVec<T>(Vec<T>);\n+\n+    impl<T> ser::Serialize for MyVec<T>\n+        where T: ser::Serialize,\n+    {\n+        #[inline]\n+        fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+            where S: ser::Serializer,\n+        {\n+            serializer.visit_seq(ser::impls::SeqIteratorVisitor::new(self.0.iter(), None))\n+        }\n+    }\n+\n+    struct Visitor<T> {\n+        marker: PhantomData<MyVec<T>>,\n+    }\n+\n+    impl<T> de::Visitor for Visitor<T>\n+        where T: de::Deserialize,\n+    {\n+        type Value = MyVec<T>;\n+\n+        #[inline]\n+        fn visit_unit<E>(&mut self) -> Result<MyVec<T>, E>\n+            where E: de::Error,\n+        {\n+            Ok(MyVec(Vec::new()))\n+        }\n+\n+        #[inline]\n+        fn visit_seq<V>(&mut self, mut visitor: V) -> Result<MyVec<T>, V::Error>\n+            where V: de::SeqVisitor,\n+        {\n+            let mut values = Vec::new();\n+\n+            while let Some(value) = try!(visitor.visit()) {\n+                values.push(value);\n+            }\n+\n+            try!(visitor.end());\n+\n+            Ok(MyVec(values))\n+        }\n+    }\n+\n+    impl<T> de::Deserialize for MyVec<T>\n+        where T: de::Deserialize,\n+    {\n+        fn deserialize<D>(deserializer: &mut D) -> Result<MyVec<T>, D::Error>\n+            where D: de::Deserializer,\n+        {\n+            deserializer.visit_map(Visitor { marker: PhantomData })\n+        }\n+    }\n+\n+    let mut vec = Vec::new();\n+    vec.push(MyVec(Vec::new()));\n+    vec.push(MyVec(Vec::new()));\n+    let vec: MyVec<MyVec<u32>> = MyVec(vec);\n+\n+    test_encode_ok(&[\n+        (\n+            vec.clone(),\n+            \"[[],[]]\",\n+        ),\n+    ]);\n+\n+    let s = json::to_string_pretty(&vec).unwrap();\n+    assert_eq!(\n+        s,\n+        concat!(\n+            \"[\\n\",\n+            \"  [\\n\",\n+            \"  ],\\n\",\n+            \"  [\\n\",\n+            \"  ]\\n\",\n+            \"]\"\n+        )\n+    );\n+}\n+\n+#[test]\n+fn test_serialize_map_with_no_len() {\n+    #[derive(Clone, Debug, PartialEq)]\n+    struct Map<K, V>(BTreeMap<K, V>);\n+\n+    impl<K, V> ser::Serialize for Map<K, V>\n+        where K: ser::Serialize + Ord,\n+              V: ser::Serialize,\n+    {\n+        #[inline]\n+        fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+            where S: ser::Serializer,\n+        {\n+            serializer.visit_map(ser::impls::MapIteratorVisitor::new(self.0.iter(), None))\n+        }\n+    }\n+\n+    struct Visitor<K, V> {\n+        marker: PhantomData<Map<K, V>>,\n+    }\n+\n+    impl<K, V> de::Visitor for Visitor<K, V>\n+        where K: de::Deserialize + Eq + Ord,\n+              V: de::Deserialize,\n+    {\n+        type Value = Map<K, V>;\n+\n+        #[inline]\n+        fn visit_unit<E>(&mut self) -> Result<Map<K, V>, E>\n+            where E: de::Error,\n+        {\n+            Ok(Map(BTreeMap::new()))\n+        }\n+\n+        #[inline]\n+        fn visit_map<Visitor>(&mut self, mut visitor: Visitor) -> Result<Map<K, V>, Visitor::Error>\n+            where Visitor: de::MapVisitor,\n+        {\n+            let mut values = BTreeMap::new();\n+\n+            while let Some((key, value)) = try!(visitor.visit()) {\n+                values.insert(key, value);\n+            }\n+\n+            try!(visitor.end());\n+\n+            Ok(Map(values))\n+        }\n+    }\n+\n+    impl<K, V> de::Deserialize for Map<K, V>\n+        where K: de::Deserialize + Eq + Ord,\n+              V: de::Deserialize,\n+    {\n+        fn deserialize<D>(deserializer: &mut D) -> Result<Map<K, V>, D::Error>\n+            where D: de::Deserializer,\n+        {\n+            deserializer.visit_map(Visitor { marker: PhantomData })\n+        }\n+    }\n+\n+    let mut map = BTreeMap::new();\n+    map.insert(\"a\", Map(BTreeMap::new()));\n+    map.insert(\"b\", Map(BTreeMap::new()));\n+    let map: Map<_, Map<u32, u32>> = Map(map);\n+\n+    test_encode_ok(&[\n+        (\n+            map.clone(),\n+            \"{\\\"a\\\":{},\\\"b\\\":{}}\",\n+        ),\n+    ]);\n+\n+    let s = json::to_string_pretty(&map).unwrap();\n+    assert_eq!(\n+        s,\n+        concat!(\n+            \"{\\n\",\n+            \"  \\\"a\\\": {\\n\",\n+            \"  },\\n\",\n+            \"  \\\"b\\\": {\\n\",\n+            \"  }\\n\",\n+            \"}\"\n+        )\n+    );\n+}\n", "problem_statement": "Incorrect JSON is generated when serializing an empty map with no up-front size provided\nIt'll generate things like `{\"foo\":{}\"bar\":{}}` (note no comma between `{}` and `\"bar\"`), which causes errors in deserialization. Supplying up-front sizes to all maps in the serialization code works around the problem.\n\n", "hints_text": "", "created_at": "2015-07-22T16:49:46Z", "version": "0.4"}, {"repo": "serde-rs/serde", "pull_number": 114, "instance_id": "serde-rs__serde-114", "issue_numbers": ["101"], "base_commit": "b2754c2c3bb9cae4ae7dc1d4ce5aa1275dc45dd4", "patch": "diff --git a/README.md b/README.md\nindex b79648b20..624054f85 100644\n--- a/README.md\n+++ b/README.md\n@@ -39,7 +39,7 @@ struct Point {\n ```\n \n Serde bundles a high performance JSON serializer and deserializer,\n-[serde::json](http://serde-rs.github.io/serde/serde/json/index.html),\n+[serde_json](http://serde-rs.github.io/serde/serde_json/index.html),\n which comes with the helper functions\n [to_string](http://serde-rs.github.io/serde/serde/json/ser/fn.to_string.html)\n and\n@@ -47,7 +47,7 @@ and\n that make it easy to go to and from JSON:\n \n ```rust\n-use serde::json;\n+use serde_json;\n \n ...\n \n@@ -59,7 +59,7 @@ println!(\"{}\", serialized_point); // prints: {\"x\":1,\"y\":2}\n let deserialize_point: Point = json::from_str(&serialized_point).unwrap();\n ```\n \n-[serde::json](http://serde-rs.github.io/serde/serde/json/index.html) also\n+[serde_json](http://serde-rs.github.io/serde/serde_json/index.html) also\n supports a generic\n [Value](http://serde-rs.github.io/serde/serde/json/value/enum.Value.html)\n type, which can represent any JSON value. Also, any\n@@ -187,7 +187,7 @@ impl serde::Serialize for Point {\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n         where S: serde::Serializer\n     {\n-        serializer.visit_named_map(\"Point\", PointMapVisitor {\n+        serializer.visit_struct(\"Point\", PointMapVisitor {\n             value: self,\n             state: 0,\n         })\n@@ -383,7 +383,7 @@ impl serde::Deserialize for Point {\n     fn deserialize<D>(deserializer: &mut D) -> Result<Point, D::Error>\n         where D: serde::de::Deserializer\n     {\n-        deserializer.visit_named_map(\"Point\", PointVisitor)\n+        deserializer.visit_struct(\"Point\", PointVisitor)\n     }\n }\n \ndiff --git a/serde/Cargo.toml b/serde/Cargo.toml\nindex f47a913bd..0c6d7cbda 100644\n--- a/serde/Cargo.toml\n+++ b/serde/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde\"\n-version = \"0.4.3\"\n+version = \"0.5.0\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"A generic serialization/deserialization framework\"\ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 390d60fb1..d00e483db 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -571,6 +571,15 @@ macro_rules! tuple_impls {\n                 marker: PhantomData<($($name,)+)>,\n             }\n \n+            impl<\n+                $($name: Deserialize,)+\n+            > $visitor<$($name,)+> {\n+                fn new() -> Self {\n+                    $visitor { marker: PhantomData }\n+                }\n+            }\n+\n+\n             impl<\n                 $($name: Deserialize,)+\n             > Visitor for $visitor<$($name,)+> {\n@@ -601,7 +610,7 @@ macro_rules! tuple_impls {\n                 fn deserialize<D>(deserializer: &mut D) -> Result<($($name,)+), D::Error>\n                     where D: Deserializer,\n                 {\n-                    deserializer.visit_tuple($visitor { marker: PhantomData })\n+                    deserializer.visit_tuple($visitor::new())\n                 }\n             }\n         )+\n@@ -849,126 +858,75 @@ impl<T> Deserialize for NonZero<T> where T: Deserialize + PartialEq + Zeroable +\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+\n impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n     fn deserialize<D>(deserializer: &mut D) -> Result<Result<T, E>, D::Error>\n                       where D: Deserializer {\n         enum Field {\n-            Field0,\n-            Field1,\n+            Ok,\n+            Err,\n         }\n \n         impl Deserialize for Field {\n             #[inline]\n             fn deserialize<D>(deserializer: &mut D) -> Result<Field, D::Error>\n-                              where D: Deserializer {\n-                struct FieldVisitor<D> {\n-                    phantom: PhantomData<D>,\n-                }\n+                where D: Deserializer\n+            {\n+                struct FieldVisitor;\n \n-                impl<D> ::de::Visitor for FieldVisitor<D> where D: Deserializer {\n+                impl ::de::Visitor for FieldVisitor {\n                     type Value = Field;\n \n                     fn visit_str<E>(&mut self, value: &str) -> Result<Field, E> where E: Error {\n                         match value {\n-                            \"Ok\" => Ok(Field::Field0),\n-                            \"Err\" => Ok(Field::Field1),\n+                            \"Ok\" => Ok(Field::Ok),\n+                            \"Err\" => Ok(Field::Err),\n                             _ => Err(Error::unknown_field_error(value)),\n                         }\n                     }\n \n                     fn visit_bytes<E>(&mut self, value: &[u8]) -> Result<Field, E> where E: Error {\n-                        match str::from_utf8(value) {\n-                            Ok(s) => self.visit_str(s),\n-                            _ => Err(Error::syntax_error()),\n+                        match value {\n+                            b\"Ok\" => Ok(Field::Ok),\n+                            b\"Err\" => Ok(Field::Err),\n+                            _ => {\n+                                match str::from_utf8(value) {\n+                                    Ok(value) => Err(Error::unknown_field_error(value)),\n+                                    Err(_) => Err(Error::syntax_error()),\n+                                }\n+                            }\n                         }\n                     }\n                 }\n \n-                deserializer.visit(FieldVisitor::<D> {\n-                    phantom: PhantomData,\n-                })\n+                deserializer.visit(FieldVisitor)\n             }\n         }\n \n-        struct Visitor<D, T, E>(PhantomData<D>, PhantomData<T>, PhantomData<E>)\n-                                where D: Deserializer, T: Deserialize, E: Deserialize;\n+        struct Visitor<T, E>(PhantomData<Result<T, E>>);\n \n-        impl<D, T, E> EnumVisitor for Visitor<D, T, E> where D: Deserializer,\n-                                                             T: Deserialize,\n-                                                             E: Deserialize {\n+        impl<T, E> EnumVisitor for Visitor<T, E>\n+            where T: Deserialize,\n+                  E: Deserialize\n+        {\n             type Value = Result<T, E>;\n \n             fn visit<V>(&mut self, mut visitor: V) -> Result<Result<T, E>, V::Error>\n-                        where V: VariantVisitor {\n-                match match visitor.visit_variant() {\n-                          Ok(val) => val,\n-                          Err(err) => return Err(From::from(err)),\n-                      } {\n-                    Field::Field0 => {\n-                        struct Visitor<D, T, E>(PhantomData<D>, PhantomData<T>, PhantomData<E>)\n-                                                where D: Deserializer,\n-                                                      T: Deserialize,\n-                                                      E: Deserialize;\n-                        impl <D, T, E> ::de::Visitor for Visitor<D, T, E> where D: Deserializer,\n-                                                                                T: Deserialize,\n-                                                                                E: Deserialize {\n-                            type Value = Result<T, E>;\n-\n-                            fn visit_seq<V>(&mut self, mut visitor: V)\n-                                            -> Result<Result<T, E>, V::Error> where V: SeqVisitor {\n-                                let field0 = match match visitor.visit() {\n-                                          Ok(val) => val,\n-                                          Err(err) => return Err(From::from(err)),\n-                                      } {\n-                                    Some(value) => value,\n-                                    None => return Err(Error::end_of_stream_error()),\n-                                };\n-                                match visitor.end() {\n-                                    Ok(val) => val,\n-                                    Err(err) => return Err(From::from(err)),\n-                                };\n-                                Ok(Result::Ok(field0))\n-                            }\n-                        }\n-                        visitor.visit_seq(Visitor::<D, T, E>(PhantomData,\n-                                                             PhantomData,\n-                                                             PhantomData))\n+                where V: VariantVisitor\n+            {\n+                match try!(visitor.visit_variant()) {\n+                    Field::Ok => {\n+                        let (value,) = try!(visitor.visit_seq(TupleVisitor1::new()));\n+                        Ok(Ok(value))\n                     }\n-                    Field::Field1 => {\n-                        struct Visitor<D, T, E>(PhantomData<D>, PhantomData<T>, PhantomData<E>)\n-                                                where D: Deserializer,\n-                                                      T: Deserialize,\n-                                                      E: Deserialize;\n-                        impl <D, T, E> ::de::Visitor for Visitor<D, T, E> where D: Deserializer,\n-                                                                                T: Deserialize,\n-                                                                                E: Deserialize {\n-                            type Value = Result<T, E>;\n-\n-                            fn visit_seq<V>(&mut self, mut visitor: V)\n-                                            -> Result<Result<T, E>, V::Error> where V: SeqVisitor {\n-                                let field0 = match match visitor.visit() {\n-                                          Ok(val) => val,\n-                                          Err(err) => return Err(From::from(err)),\n-                                      } {\n-                                    Some(value) => value,\n-                                    None => return Err(Error::end_of_stream_error()),\n-                                };\n-                                match visitor.end() {\n-                                    Ok(val) => val,\n-                                    Err(err) => return Err(From::from(err)),\n-                                };\n-                                Ok(Result::Err(field0))\n-                            }\n-                        }\n-                        visitor.visit_seq(Visitor::<D, T, E>(PhantomData,\n-                                                             PhantomData,\n-                                                             PhantomData))\n+                    Field::Err => {\n+                        let (value,) = try!(visitor.visit_seq(TupleVisitor1::new()));\n+                        Ok(Err(value))\n                     }\n                 }\n             }\n         }\n \n-        deserializer.visit_enum(\"Result\",\n-                                Visitor::<D, T, E>(PhantomData, PhantomData, PhantomData))\n+        deserializer.visit_enum(\"Result\", Visitor(PhantomData))\n     }\n }\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 253be30e7..5484a7b7c 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -211,25 +211,28 @@ pub trait Deserializer {\n     /// This method hints that the `Deserialize` type is expecting a named unit. This allows\n     /// deserializers to a named unit that aren't tagged as a named unit.\n     #[inline]\n-    fn visit_named_unit<V>(&mut self, _name: &str, visitor: V) -> Result<V::Value, Self::Error>\n+    fn visit_unit_struct<V>(&mut self, _name: &str, visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor,\n     {\n-        self.visit(visitor)\n+        self.visit_unit(visitor)\n     }\n \n-    /// This method hints that the `Deserialize` type is expecting a named sequence.\n-    /// This allows deserializers to parse sequences that aren't tagged as sequences.\n+    /// This method hints that the `Deserialize` type is expecting a tuple struct. This allows\n+    /// deserializers to parse sequences that aren't tagged as sequences.\n     #[inline]\n-    fn visit_named_seq<V>(&mut self, _name: &str, visitor: V) -> Result<V::Value, Self::Error>\n+    fn visit_tuple_struct<V>(&mut self, _name: &str, visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor,\n     {\n-        self.visit_seq(visitor)\n+        self.visit_tuple(visitor)\n     }\n \n-    /// This method hints that the `Deserialize` type is expecting a named map.  This allows\n+    /// This method hints that the `Deserialize` type is expecting a struct. This allows\n     /// deserializers to parse sequences that aren't tagged as maps.\n     #[inline]\n-    fn visit_named_map<V>(&mut self, _name: &str, visitor: V) -> Result<V::Value, Self::Error>\n+    fn visit_struct<V>(&mut self,\n+                       _name: &str,\n+                       _fields: &'static [&'static str],\n+                       visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor,\n     {\n         self.visit_map(visitor)\n@@ -241,7 +244,7 @@ pub trait Deserializer {\n     fn visit_tuple<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor,\n     {\n-        self.visit(visitor)\n+        self.visit_seq(visitor)\n     }\n \n     /// This method hints that the `Deserialize` type is expecting an enum value. This allows\n@@ -261,7 +264,7 @@ pub trait Deserializer {\n     fn visit_bytes<V>(&mut self, visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor,\n     {\n-        self.visit(visitor)\n+        self.visit_seq(visitor)\n     }\n \n     /// Specify a format string for the deserializer.\n@@ -386,7 +389,7 @@ pub trait Visitor {\n     }\n \n     #[inline]\n-    fn visit_named_unit<E>(&mut self, _name: &str) -> Result<Self::Value, E>\n+    fn visit_unit_struct<E>(&mut self, _name: &str) -> Result<Self::Value, E>\n         where E: Error,\n     {\n         self.visit_unit()\n@@ -576,7 +579,9 @@ pub trait VariantVisitor {\n     }\n \n     /// `visit_map` is called when deserializing a struct-like variant.\n-    fn visit_map<V>(&mut self, _visitor: V) -> Result<V::Value, Self::Error>\n+    fn visit_map<V>(&mut self,\n+                    _fields: &'static [&'static str],\n+                    _visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor\n     {\n         Err(Error::syntax_error())\n@@ -602,10 +607,12 @@ impl<'a, T> VariantVisitor for &'a mut T where T: VariantVisitor {\n         (**self).visit_seq(visitor)\n     }\n \n-    fn visit_map<V>(&mut self, visitor: V) -> Result<V::Value, T::Error>\n+    fn visit_map<V>(&mut self,\n+                    fields: &'static [&'static str],\n+                    visitor: V) -> Result<V::Value, T::Error>\n         where V: Visitor,\n     {\n-        (**self).visit_map(visitor)\n+        (**self).visit_map(fields, visitor)\n     }\n }\n \ndiff --git a/serde/src/lib.rs b/serde/src/lib.rs\nindex 92d86c788..b573c5b9c 100644\n--- a/serde/src/lib.rs\n+++ b/serde/src/lib.rs\n@@ -22,5 +22,4 @@ pub use de::{Deserialize, Deserializer, Error};\n pub mod bytes;\n pub mod de;\n pub mod iter;\n-pub mod json;\n pub mod ser;\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex 245ffdeca..a8efe18a9 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -15,7 +15,6 @@ use std::collections::vec_map::VecMap;\n use std::hash::Hash;\n #[cfg(feature = \"nightly\")]\n use std::iter;\n-use std::marker::PhantomData;\n #[cfg(feature = \"nightly\")]\n use std::num;\n #[cfg(feature = \"nightly\")]\n@@ -612,28 +611,17 @@ impl<'a, T: ?Sized> Serialize for Cow<'a, T> where T: Serialize + ToOwned, {\n impl<T, E> Serialize for Result<T, E> where T: Serialize, E: Serialize {\n     fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error> where S: Serializer {\n         match *self {\n-            Result::Ok(ref field0) => {\n-                struct Visitor<'a, T, E> where T: Serialize + 'a, E: Serialize + 'a {\n-                    state: usize,\n-                    value: (&'a T,),\n-                    _structure_ty: PhantomData<&'a Result<T, E>>,\n-                }\n+            Result::Ok(ref value) => {\n+                struct Visitor<'a, T: 'a>(Option<&'a T>);\n \n-                impl<'a, T, E> SeqVisitor for Visitor<'a, T, E> where T: Serialize + 'a,\n-                                                                      E: Serialize + 'a {\n+                impl<'a, T> SeqVisitor for Visitor<'a, T> where T: Serialize + 'a {\n                     #[inline]\n                     fn visit<S>(&mut self, serializer: &mut S) -> Result<Option<()>, S::Error>\n-                                where S: Serializer {\n-                        match self.state {\n-                            0 => {\n-                                self.state += 1;\n-                                let v = match serializer.visit_seq_elt(&self.value.0) {\n-                                    Ok(val) => val,\n-                                    Err(err) => return Err(From::from(err)),\n-                                };\n-                                Ok(Some(v))\n-                            }\n-                            _ => Ok(None),\n+                        where S: Serializer\n+                    {\n+                        match self.0.take() {\n+                            Some(value) => Ok(Some(try!(serializer.visit_seq_elt(value)))),\n+                            None => Ok(None),\n                         }\n                     }\n \n@@ -643,37 +631,18 @@ impl<T, E> Serialize for Result<T, E> where T: Serialize, E: Serialize {\n                     }\n                 }\n \n-                let field0: &T = field0;\n-                let data: PhantomData<&Result<&T,E>> = PhantomData;\n-                let visitor = Visitor {\n-                    value: (&field0,),\n-                    state: 0,\n-                    _structure_ty: data\n-                };\n-                serializer.visit_enum_seq(\"Result\", \"Ok\", visitor)\n+                serializer.visit_enum_seq(\"Result\", 0, \"Ok\", Visitor(Some(value)))\n             }\n-            Result::Err(ref field0) => {\n-                struct Visitor<'a, T, E> where T: Serialize + 'a, E: Serialize + 'a {\n-                    state: usize,\n-                    value: (&'a E,),\n-                    _structure_ty: PhantomData<&'a Result<T, E>>,\n-                }\n+            Result::Err(ref value) => {\n+                struct Visitor<'a, E: 'a>(Option<&'a E>);\n \n-                impl<'a, T, E> SeqVisitor for Visitor<'a, T, E> where T: Serialize + 'a,\n-                                                                      E: Serialize + 'a {\n+                impl<'a, E> SeqVisitor for Visitor<'a, E> where E: Serialize + 'a {\n                     #[inline]\n                     fn visit<S>(&mut self, serializer: &mut S) -> Result<Option<()>, S::Error>\n                                 where S: Serializer {\n-                        match self.state {\n-                            0 => {\n-                                self.state += 1;\n-                                let v = match serializer.visit_seq_elt(&self.value.0) {\n-                                    Ok(val) => val,\n-                                    Err(err) => return Err(From::from(err)),\n-                                };\n-                                Ok(Some(v))\n-                            }\n-                            _ => Ok(None),\n+                        match self.0.take() {\n+                            Some(value) => Ok(Some(try!(serializer.visit_seq_elt(value)))),\n+                            None => Ok(None),\n                         }\n                     }\n \n@@ -683,14 +652,7 @@ impl<T, E> Serialize for Result<T, E> where T: Serialize, E: Serialize {\n                     }\n                 }\n \n-                let field0: &E = field0;\n-                let data: PhantomData<&Result<T,&E>> = PhantomData;\n-                let visitor = Visitor {\n-                    value: (&field0,),\n-                    state: 0,\n-                    _structure_ty: data\n-                };\n-                serializer.visit_enum_seq(\"Result\", \"Err\", visitor)\n+                serializer.visit_enum_seq(\"Result\", 1, \"Err\", Visitor(Some(value)))\n             }\n         }\n     }\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 89f180426..d816dc35a 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -113,13 +113,14 @@ pub trait Serializer {\n     fn visit_unit(&mut self) -> Result<(), Self::Error>;\n \n     #[inline]\n-    fn visit_named_unit(&mut self, _name: &str) -> Result<(), Self::Error> {\n+    fn visit_unit_struct(&mut self, _name: &str) -> Result<(), Self::Error> {\n         self.visit_unit()\n     }\n \n     #[inline]\n     fn visit_enum_unit(&mut self,\n                        _name: &str,\n+                       _variant_index: usize,\n                        _variant: &str) -> Result<(), Self::Error> {\n         self.visit_unit()\n     }\n@@ -150,7 +151,7 @@ pub trait Serializer {\n     }\n \n     #[inline]\n-    fn visit_named_seq<V>(&mut self,\n+    fn visit_tuple_struct<V>(&mut self,\n                           _name: &'static str,\n                           visitor: V) -> Result<(), Self::Error>\n         where V: SeqVisitor,\n@@ -159,7 +160,7 @@ pub trait Serializer {\n     }\n \n     #[inline]\n-    fn visit_named_seq_elt<T>(&mut self, value: T) -> Result<(), Self::Error>\n+    fn visit_tuple_struct_elt<T>(&mut self, value: T) -> Result<(), Self::Error>\n         where T: Serialize\n     {\n         self.visit_tuple_elt(value)\n@@ -168,18 +169,19 @@ pub trait Serializer {\n     #[inline]\n     fn visit_enum_seq<V>(&mut self,\n                          _name: &'static str,\n-                         _variant: &'static str,\n+                         _variant_index: usize,\n+                         variant: &'static str,\n                          visitor: V) -> Result<(), Self::Error>\n         where V: SeqVisitor,\n     {\n-        self.visit_tuple(visitor)\n+        self.visit_tuple_struct(variant, visitor)\n     }\n \n     #[inline]\n     fn visit_enum_seq_elt<T>(&mut self, value: T) -> Result<(), Self::Error>\n         where T: Serialize\n     {\n-        self.visit_tuple_elt(value)\n+        self.visit_tuple_struct_elt(value)\n     }\n \n     fn visit_map<V>(&mut self, visitor: V) -> Result<(), Self::Error>\n@@ -190,7 +192,7 @@ pub trait Serializer {\n               V: Serialize;\n \n     #[inline]\n-    fn visit_named_map<V>(&mut self,\n+    fn visit_struct<V>(&mut self,\n                           _name: &'static str,\n                           visitor: V) -> Result<(), Self::Error>\n         where V: MapVisitor,\n@@ -199,7 +201,7 @@ pub trait Serializer {\n     }\n \n     #[inline]\n-    fn visit_named_map_elt<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error>\n+    fn visit_struct_elt<K, V>(&mut self, key: K, value: V) -> Result<(), Self::Error>\n         where K: Serialize,\n               V: Serialize,\n     {\n@@ -209,11 +211,12 @@ pub trait Serializer {\n     #[inline]\n     fn visit_enum_map<V>(&mut self,\n                          _name: &'static str,\n+                         _variant_index: usize,\n                          variant: &'static str,\n                          visitor: V) -> Result<(), Self::Error>\n         where V: MapVisitor,\n     {\n-        self.visit_named_map(variant, visitor)\n+        self.visit_struct(variant, visitor)\n     }\n \n     #[inline]\n@@ -221,7 +224,7 @@ pub trait Serializer {\n         where K: Serialize,\n               V: Serialize,\n     {\n-        self.visit_named_map_elt(key, value)\n+        self.visit_struct_elt(key, value)\n     }\n \n     /// Specify a format string for the serializer.\ndiff --git a/serde_codegen/Cargo.toml b/serde_codegen/Cargo.toml\nindex ec39afd38..08c685202 100644\n--- a/serde_codegen/Cargo.toml\n+++ b/serde_codegen/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_codegen\"\n-version = \"0.4.3\"\n+version = \"0.5.0\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"Macros to auto-generate implementations for the serde framework\"\ndiff --git a/serde_codegen/src/attr.rs b/serde_codegen/src/attr.rs\nindex 8d04b0680..9f08969df 100644\n--- a/serde_codegen/src/attr.rs\n+++ b/serde_codegen/src/attr.rs\n@@ -21,7 +21,6 @@ pub struct FieldAttrs {\n }\n \n impl FieldAttrs {\n-\n     /// Create a FieldAttr with a single default field name\n     pub fn new(default_value: bool, name: P<ast::Expr>) -> FieldAttrs {\n         FieldAttrs {\n@@ -35,7 +34,7 @@ impl FieldAttrs {\n         default_value: bool,\n         default_name: P<ast::Expr>,\n         formats: HashMap<P<ast::Expr>, P<ast::Expr>>,\n-        ) -> FieldAttrs {\n+    ) -> FieldAttrs {\n         FieldAttrs {\n             names:  FieldNames::Format {\n                 formats: formats,\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex 9d256a512..3f949df00 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -190,11 +190,25 @@ fn deserialize_visitor(\n         (\n             builder.item().tuple_struct(\"__Visitor\")\n                 .generics().with(trait_generics.clone()).build()\n-                .with_tys(\n-                    trait_generics.ty_params.iter().map(|ty_param| {\n-                        builder.ty().phantom_data().id(ty_param.ident)\n-                    })\n-                )\n+                .with_tys({\n+                    let lifetimes = trait_generics.lifetimes.iter()\n+                        .map(|lifetime_def| {\n+                            builder.ty()\n+                                .phantom_data()\n+                                .ref_().lifetime(lifetime_def.lifetime.name)\n+                                .ty()\n+                                .unit()\n+                        });\n+\n+                    let ty_params = trait_generics.ty_params.iter()\n+                        .map(|ty_param| {\n+                            builder.ty()\n+                                .phantom_data()\n+                                .id(ty_param.ident)\n+                        });\n+\n+                    lifetimes.chain(ty_params)\n+                })\n                 .build(),\n             builder.ty().path()\n                 .segment(\"__Visitor\").with_generics(trait_generics.clone()).build()\n@@ -204,11 +218,11 @@ fn deserialize_visitor(\n                 .with_tys(forward_tys)\n                 .with_tys(placeholders)\n                 .build().build()\n-                .with_args(\n-                    trait_generics.ty_params.iter().map(|_| {\n-                        builder.expr().phantom_data()\n-                    })\n-                )\n+                .with_args({\n+                    let len = trait_generics.lifetimes.len() + trait_generics.ty_params.len();\n+\n+                    (0 .. len).map(|_| builder.expr().phantom_data())\n+                })\n                 .build(),\n             trait_generics,\n         )\n@@ -260,7 +274,7 @@ fn deserialize_unit_struct(\n             }\n         }\n \n-        deserializer.visit_named_unit($type_name, __Visitor)\n+        deserializer.visit_unit_struct($type_name, __Visitor)\n     })\n }\n \n@@ -304,7 +318,7 @@ fn deserialize_tuple_struct(\n             }\n         }\n \n-        deserializer.visit_named_seq($type_name, $visitor_expr)\n+        deserializer.visit_tuple_struct($type_name, $visitor_expr)\n     })\n }\n \n@@ -342,6 +356,51 @@ fn deserialize_seq(\n     })\n }\n \n+fn deserialize_struct_as_seq(\n+    cx: &ExtCtxt,\n+    builder: &aster::AstBuilder,\n+    struct_path: ast::Path,\n+    struct_def: &StructDef,\n+) -> P<ast::Expr> {\n+    let let_values: Vec<P<ast::Stmt>> = (0 .. struct_def.fields.len())\n+        .map(|i| {\n+            let name = builder.id(format!(\"__field{}\", i));\n+            quote_stmt!(cx,\n+                let $name = match try!(visitor.visit()) {\n+                    Some(value) => { value },\n+                    None => {\n+                        return Err(::serde::de::Error::end_of_stream_error());\n+                    }\n+                };\n+            ).unwrap()\n+        })\n+        .collect();\n+\n+    let result = builder.expr().struct_path(struct_path)\n+        .with_id_exprs(\n+            struct_def.fields.iter()\n+                .enumerate()\n+                .map(|(i, field)| {\n+                    (\n+                        match field.node.kind {\n+                            ast::NamedField(name, _) => name.clone(),\n+                            ast::UnnamedField(_) => panic!(\"struct contains unnamed fields\"),\n+                        },\n+                        builder.expr().id(format!(\"__field{}\", i)),\n+                    )\n+                })\n+        )\n+        .build();\n+\n+    quote_expr!(cx, {\n+        $let_values\n+\n+        try!(visitor.end());\n+\n+        Ok($result)\n+    })\n+}\n+\n fn deserialize_struct(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n@@ -352,19 +411,27 @@ fn deserialize_struct(\n ) -> P<ast::Expr> {\n     let where_clause = &impl_generics.where_clause;\n \n-    let (visitor_item, visitor_ty, visitor_expr, visitor_generics) =\n-        deserialize_visitor(\n-            builder,\n-            &impl_generics,\n-            vec![deserializer_ty_param(builder)],\n-            vec![deserializer_ty_arg(builder)],\n-                );\n+    let (visitor_item, visitor_ty, visitor_expr, visitor_generics) = deserialize_visitor(\n+        builder,\n+        &impl_generics,\n+        vec![deserializer_ty_param(builder)],\n+        vec![deserializer_ty_arg(builder)],\n+    );\n \n-    let (field_visitor, visit_map_expr) = deserialize_struct_visitor(\n+    let type_path = builder.path().id(type_ident).build();\n+\n+    let visit_seq_expr = deserialize_struct_as_seq(\n+        cx,\n+        builder,\n+        type_path.clone(),\n+        struct_def\n+    );\n+\n+    let (field_visitor, fields_stmt, visit_map_expr) = deserialize_struct_visitor(\n         cx,\n         builder,\n         struct_def,\n-        builder.path().id(type_ident).build(),\n+        type_path.clone()\n     );\n \n     let type_name = builder.expr().str(type_ident);\n@@ -377,6 +444,13 @@ fn deserialize_struct(\n         impl $visitor_generics ::serde::de::Visitor for $visitor_ty $where_clause {\n             type Value = $ty;\n \n+            #[inline]\n+            fn visit_seq<__V>(&mut self, mut visitor: __V) -> ::std::result::Result<$ty, __V::Error>\n+                where __V: ::serde::de::SeqVisitor,\n+            {\n+                $visit_seq_expr\n+            }\n+\n             #[inline]\n             fn visit_map<__V>(&mut self, mut visitor: __V) -> ::std::result::Result<$ty, __V::Error>\n                 where __V: ::serde::de::MapVisitor,\n@@ -385,7 +459,9 @@ fn deserialize_struct(\n             }\n         }\n \n-        deserializer.visit_named_map($type_name, $visitor_expr)\n+        $fields_stmt\n+\n+        deserializer.visit_struct($type_name, FIELDS, $visitor_expr)\n     })\n }\n \n@@ -558,11 +634,23 @@ fn deserialize_struct_variant(\n ) -> P<ast::Expr> {\n     let where_clause = &generics.where_clause;\n \n-    let (field_visitor, field_expr) = deserialize_struct_visitor(\n+    let type_path = builder.path()\n+        .id(type_ident)\n+        .id(variant_ident)\n+        .build();\n+\n+    let visit_seq_expr = deserialize_struct_as_seq(\n+        cx,\n+        builder,\n+        type_path.clone(),\n+        struct_def\n+    );\n+\n+    let (field_visitor, fields_stmt, field_expr) = deserialize_struct_visitor(\n         cx,\n         builder,\n         struct_def,\n-        builder.path().id(type_ident).id(variant_ident).build(),\n+        type_path\n     );\n \n     let (visitor_item, visitor_ty, visitor_expr, visitor_generics) =\n@@ -581,6 +669,14 @@ fn deserialize_struct_variant(\n         impl $visitor_generics ::serde::de::Visitor for $visitor_ty $where_clause {\n             type Value = $ty;\n \n+            #[inline]\n+            fn visit_seq<__V>(&mut self, mut visitor: __V) -> ::std::result::Result<$ty, __V::Error>\n+                where __V: ::serde::de::SeqVisitor,\n+            {\n+                $visit_seq_expr\n+            }\n+\n+            #[inline]\n             fn visit_map<__V>(&mut self, mut visitor: __V) -> ::std::result::Result<$ty, __V::Error>\n                 where __V: ::serde::de::MapVisitor,\n             {\n@@ -588,7 +684,9 @@ fn deserialize_struct_variant(\n             }\n         }\n \n-        visitor.visit_map($visitor_expr)\n+        $fields_stmt\n+\n+        visitor.visit_map(FIELDS, $visitor_expr)\n     })\n }\n \n@@ -612,6 +710,20 @@ fn deserialize_field_visitor(\n         )\n         .build();\n \n+    let index_field_arms: Vec<_> = field_idents.iter()\n+        .enumerate()\n+        .map(|(field_index, field_ident)| {\n+            quote_arm!(cx, $field_index => { Ok(__Field::$field_ident) })\n+        })\n+        .collect();\n+\n+    let index_body = quote_expr!(cx,\n+        match value {\n+            $index_field_arms\n+            _ => { Err(::serde::de::Error::syntax_error()) }\n+        }\n+    );\n+\n     // A set of all the formats that have specialized field attributes\n     let formats = field_attrs.iter()\n         .fold(HashSet::new(), |mut set, field_expr| {\n@@ -628,7 +740,7 @@ fn deserialize_field_visitor(\n         })\n         .collect();\n \n-    let body = if formats.is_empty() {\n+    let str_body = if formats.is_empty() {\n         // No formats specific attributes, so no match on format required\n         quote_expr!(cx,\n                     match value {\n@@ -636,7 +748,7 @@ fn deserialize_field_visitor(\n                         _ => { Err(::serde::de::Error::unknown_field_error(value)) }\n                     })\n     } else {\n-        let field_arms : Vec<_> = formats.iter()\n+        let field_arms: Vec<_> = formats.iter()\n             .map(|fmt| {\n                 field_idents.iter()\n                     .zip(field_attrs.iter())\n@@ -648,7 +760,7 @@ fn deserialize_field_visitor(\n             })\n             .collect();\n \n-        let fmt_matches : Vec<_> = formats.iter()\n+        let fmt_matches: Vec<_> = formats.iter()\n             .zip(field_arms.iter())\n             .map(|(ref fmt, ref arms)| {\n                 quote_arm!(cx, $fmt => {\n@@ -662,13 +774,14 @@ fn deserialize_field_visitor(\n             .collect();\n \n         quote_expr!(cx,\n-                    match __D::format() {\n-                        $fmt_matches\n-                        _ => match value {\n-                            $default_field_arms\n-                            _ => { Err(::serde::de::Error::unknown_field_error(value)) }\n-                        }\n-                    })\n+            match __D::format() {\n+                $fmt_matches\n+                _ => match value {\n+                    $default_field_arms\n+                    _ => { Err(::serde::de::Error::unknown_field_error(value)) }\n+                }\n+            }\n+        )\n     };\n \n     let impl_item = quote_item!(cx,\n@@ -688,10 +801,16 @@ fn deserialize_field_visitor(\n                 {\n                     type Value = __Field;\n \n+                    fn visit_usize<E>(&mut self, value: usize) -> ::std::result::Result<__Field, E>\n+                        where E: ::serde::de::Error,\n+                    {\n+                        $index_body\n+                    }\n+\n                     fn visit_str<E>(&mut self, value: &str) -> ::std::result::Result<__Field, E>\n                         where E: ::serde::de::Error,\n                     {\n-                        $body\n+                        $str_body\n                     }\n \n                     fn visit_bytes<E>(&mut self, value: &[u8]) -> ::std::result::Result<__Field, E>\n@@ -705,8 +824,7 @@ fn deserialize_field_visitor(\n                     }\n                 }\n \n-                deserializer.visit(\n-                    __FieldVisitor::<D>{ phantom: PhantomData })\n+                deserializer.visit(__FieldVisitor::<D>{ phantom: PhantomData })\n             }\n         }\n     ).unwrap();\n@@ -719,7 +837,7 @@ fn deserialize_struct_visitor(\n     builder: &aster::AstBuilder,\n     struct_def: &ast::StructDef,\n     struct_path: ast::Path,\n-) -> (Vec<P<ast::Item>>, P<ast::Expr>) {\n+) -> (Vec<P<ast::Item>>, P<ast::Stmt>, P<ast::Expr>) {\n     let field_visitor = deserialize_field_visitor(\n         cx,\n         builder,\n@@ -733,7 +851,23 @@ fn deserialize_struct_visitor(\n         struct_def,\n     );\n \n-    (field_visitor, visit_map_expr)\n+    let fields_expr = builder.expr().addr_of().slice()\n+        .with_exprs(\n+            struct_def.fields.iter()\n+                .map(|field| {\n+                    match field.node.kind {\n+                        ast::NamedField(name, _) => builder.expr().str(name),\n+                        ast::UnnamedField(_) => panic!(\"struct contains unnamed fields\"),\n+                    }\n+                })\n+        )\n+        .build();\n+\n+    let fields_stmt = quote_stmt!(cx,\n+        const FIELDS: &'static [&'static str] = $fields_expr;\n+    ).unwrap();\n+\n+    (field_visitor, fields_stmt, visit_map_expr)\n }\n \n fn deserialize_map(\ndiff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex 656d5f31b..ec8c6ccdc 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -169,7 +169,7 @@ fn serialize_unit_struct(\n ) -> P<ast::Expr> {\n     let type_name = builder.expr().str(type_ident);\n \n-    quote_expr!(cx, serializer.visit_named_unit($type_name))\n+    quote_expr!(cx, serializer.visit_unit_struct($type_name))\n }\n \n fn serialize_tuple_struct(\n@@ -194,7 +194,7 @@ fn serialize_tuple_struct(\n     quote_expr!(cx, {\n         $visitor_struct\n         $visitor_impl\n-        serializer.visit_named_seq($type_name, Visitor {\n+        serializer.visit_tuple_struct($type_name, Visitor {\n             value: self,\n             state: 0,\n             _structure_ty: ::std::marker::PhantomData,\n@@ -226,7 +226,7 @@ fn serialize_struct(\n     quote_expr!(cx, {\n         $visitor_struct\n         $visitor_impl\n-        serializer.visit_named_map($type_name, Visitor {\n+        serializer.visit_struct($type_name, Visitor {\n             value: self,\n             state: 0,\n             _structure_ty: ::std::marker::PhantomData,\n@@ -243,7 +243,8 @@ fn serialize_item_enum(\n     enum_def: &ast::EnumDef,\n ) -> P<ast::Expr> {\n     let arms: Vec<ast::Arm> = enum_def.variants.iter()\n-        .map(|variant| {\n+        .enumerate()\n+        .map(|(variant_index, variant)| {\n             serialize_variant(\n                 cx,\n                 builder,\n@@ -251,6 +252,7 @@ fn serialize_item_enum(\n                 impl_generics,\n                 ty.clone(),\n                 variant,\n+                variant_index,\n             )\n         })\n         .collect();\n@@ -269,6 +271,7 @@ fn serialize_variant(\n     generics: &ast::Generics,\n     ty: P<ast::Ty>,\n     variant: &ast::Variant,\n+    variant_index: usize,\n ) -> ast::Arm {\n     let type_name = builder.expr().str(type_ident);\n     let variant_ident = variant.node.name;\n@@ -285,6 +288,7 @@ fn serialize_variant(\n                     ::serde::ser::Serializer::visit_enum_unit(\n                         serializer,\n                         $type_name,\n+                        $variant_index,\n                         $variant_name,\n                     )\n                 }\n@@ -304,6 +308,7 @@ fn serialize_variant(\n                 cx,\n                 builder,\n                 type_name,\n+                variant_index,\n                 variant_name,\n                 generics,\n                 ty,\n@@ -340,6 +345,7 @@ fn serialize_variant(\n                 cx,\n                 builder,\n                 type_name,\n+                variant_index,\n                 variant_name,\n                 generics,\n                 ty,\n@@ -356,6 +362,7 @@ fn serialize_tuple_variant(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n     type_name: P<ast::Expr>,\n+    variant_index: usize,\n     variant_name: P<ast::Expr>,\n     generics: &ast::Generics,\n     structure_ty: P<ast::Ty>,\n@@ -395,7 +402,7 @@ fn serialize_tuple_variant(\n     quote_expr!(cx, {\n         $visitor_struct\n         $visitor_impl\n-        serializer.visit_enum_seq($type_name, $variant_name, Visitor {\n+        serializer.visit_enum_seq($type_name, $variant_index, $variant_name, Visitor {\n             value: $value_expr,\n             state: 0,\n             _structure_ty: ::std::marker::PhantomData,\n@@ -407,6 +414,7 @@ fn serialize_struct_variant(\n     cx: &ExtCtxt,\n     builder: &aster::AstBuilder,\n     type_name: P<ast::Expr>,\n+    variant_index: usize,\n     variant_name: P<ast::Expr>,\n     generics: &ast::Generics,\n     structure_ty: P<ast::Ty>,\n@@ -451,7 +459,7 @@ fn serialize_struct_variant(\n     quote_expr!(cx, {\n         $visitor_struct\n         $visitor_impl\n-        serializer.visit_enum_map($type_name, $variant_name, Visitor {\n+        serializer.visit_enum_map($type_name, $variant_index, $variant_name, Visitor {\n             value: $value_expr,\n             state: 0,\n             _structure_ty: ::std::marker::PhantomData,\n@@ -476,7 +484,7 @@ fn serialize_tuple_struct_visitor(\n             quote_arm!(cx,\n                 $i => {\n                     self.state += 1;\n-                    let v = try!(serializer.visit_named_seq_elt(&$expr));\n+                    let v = try!(serializer.visit_tuple_struct_elt(&$expr));\n                     Ok(Some(v))\n                 }\n             )\n@@ -559,7 +567,7 @@ fn serialize_struct_visitor<I>(\n                     Ok(\n                         Some(\n                             try!(\n-                                serializer.visit_named_map_elt(\n+                                serializer.visit_struct_elt(\n                                     $key_expr,\n                                     $value_expr,\n                                 )\ndiff --git a/serde_json/Cargo.toml b/serde_json/Cargo.toml\nnew file mode 100644\nindex 000000000..dbde52a96\n--- /dev/null\n+++ b/serde_json/Cargo.toml\n@@ -0,0 +1,14 @@\n+[package]\n+name = \"serde_json\"\n+version = \"0.5.0\"\n+authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n+license = \"MIT/Apache-2.0\"\n+description = \"A JSON serialization file format\"\n+repository = \"https://github.com/serde-rs/serde\"\n+documentation = \"http://serde-rs.github.io/serde/serde\"\n+readme = \"README.md\"\n+keywords = [\"serialization\", \"json\"]\n+\n+[dependencies]\n+num = \"*\"\n+serde = { version = \"*\", path = \"../serde\" }\ndiff --git a/serde/src/json/builder.rs b/serde_json/src/builder.rs\nsimilarity index 97%\nrename from serde/src/json/builder.rs\nrename to serde_json/src/builder.rs\nindex 3db2c4ed9..2743b3d95 100644\n--- a/serde/src/json/builder.rs\n+++ b/serde_json/src/builder.rs\n@@ -10,8 +10,9 @@\n \n use std::collections::BTreeMap;\n \n-use ser::{self, Serialize};\n-use json::value::{self, Value};\n+use serde::ser::{self, Serialize};\n+\n+use value::{self, Value};\n \n pub struct ArrayBuilder {\n     array: Vec<Value>,\ndiff --git a/serde/src/json/de.rs b/serde_json/src/de.rs\nsimilarity index 99%\nrename from serde/src/json/de.rs\nrename to serde_json/src/de.rs\nindex d4e9f47ed..8bb33931d 100644\n--- a/serde/src/json/de.rs\n+++ b/serde_json/src/de.rs\n@@ -3,8 +3,8 @@ use std::i32;\n use std::io;\n use std::str;\n \n-use de;\n-use iter::LineColIterator;\n+use serde::de;\n+use serde::iter::LineColIterator;\n \n use super::error::{Error, ErrorCode};\n \n@@ -649,7 +649,9 @@ impl<Iter> de::VariantVisitor for Deserializer<Iter>\n         de::Deserializer::visit(self, visitor)\n     }\n \n-    fn visit_map<V>(&mut self, visitor: V) -> Result<V::Value, Error>\n+    fn visit_map<V>(&mut self,\n+                    _fields: &'static [&'static str],\n+                    visitor: V) -> Result<V::Value, Error>\n         where V: de::Visitor,\n     {\n         try!(self.parse_object_colon());\ndiff --git a/serde/src/json/error.rs b/serde_json/src/error.rs\nsimilarity index 99%\nrename from serde/src/json/error.rs\nrename to serde_json/src/error.rs\nindex 29570ebd0..171e24590 100644\n--- a/serde/src/json/error.rs\n+++ b/serde_json/src/error.rs\n@@ -2,7 +2,7 @@ use std::error;\n use std::fmt;\n use std::io;\n \n-use de;\n+use serde::de;\n \n /// The errors that can arise while parsing a JSON stream.\n #[derive(Clone, PartialEq)]\ndiff --git a/serde/src/json/mod.rs b/serde_json/src/lib.rs\nsimilarity index 90%\nrename from serde/src/json/mod.rs\nrename to serde_json/src/lib.rs\nindex 3a3a35260..2e13f2a42 100644\n--- a/serde/src/json/mod.rs\n+++ b/serde_json/src/lib.rs\n@@ -6,7 +6,7 @@\n //! encode structured data in a text format that can be easily read by humans.  Its simple syntax\n //! and native compatibility with JavaScript have made it a widely used format.\n //!\n-//! Data types that can be encoded are JavaScript types (see the `serde::json:Value` enum for more\n+//! Data types that can be encoded are JavaScript types (see the `serde_json:Value` enum for more\n //! details):\n //!\n //! * `Boolean`: equivalent to rust's `bool`\n@@ -16,7 +16,7 @@\n //! * `String`: equivalent to rust's `String`\n //! * `Array`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the\n //!    same array\n-//! * `Object`: equivalent to rust's `BTreeMap<String, serde::json::Value>`\n+//! * `Object`: equivalent to rust's `BTreeMap<String, serde_json::Value>`\n //! * `Null`\n //!\n //! An object is a series of string keys mapping to values, in `\"key\": value` format.  Arrays are\n@@ -48,8 +48,8 @@\n //! `serde::Deserialize` trait.  Serde provides provides an annotation to automatically generate\n //! the code for these traits: `#[derive(Serialize, Deserialize)]`.\n //!\n-//! The JSON API also provides an enum `serde::json::Value` and a method `to_value` to serialize\n-//! objects.  A `serde::json::Value` value can be serialized as a string or buffer using the\n+//! The JSON API also provides an enum `serde_json::Value` and a method `to_value` to serialize\n+//! objects.  A `serde_json::Value` value can be serialized as a string or buffer using the\n //! functions described above.  You can also use the `json::Serializer` object, which implements the\n //! `Serializer` trait.\n //!\n@@ -63,7 +63,7 @@\n //!\n //! extern crate serde;\n //!\n-//! use serde::json::{self, Value};\n+//! use serde_json::{self, Value};\n //!\n //! fn main() {\n //!     let data: Value = json::from_str(\"{\\\"foo\\\": 13, \\\"bar\\\": \\\"baz\\\"}\").unwrap();\n@@ -92,6 +92,9 @@\n //! }\n //! ```\n \n+extern crate num;\n+extern crate serde;\n+\n pub use self::de::{Deserializer, from_str};\n pub use self::error::{Error, ErrorCode};\n pub use self::ser::{\ndiff --git a/serde/src/json/ser.rs b/serde_json/src/ser.rs\nsimilarity index 94%\nrename from serde/src/json/ser.rs\nrename to serde_json/src/ser.rs\nindex deaace30a..294a7f494 100644\n--- a/serde/src/json/ser.rs\n+++ b/serde_json/src/ser.rs\n@@ -2,7 +2,7 @@ use std::io;\n use std::num::FpCategory;\n use std::string::FromUtf8Error;\n \n-use ser;\n+use serde::ser;\n \n /// A structure for implementing serialization to JSON.\n pub struct Serializer<W, F=CompactFormatter> {\n@@ -159,7 +159,10 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n     }\n \n     #[inline]\n-    fn visit_enum_unit(&mut self, _name: &str, variant: &str) -> io::Result<()> {\n+    fn visit_enum_unit(&mut self,\n+                       _name: &str,\n+                       _variant_index: usize,\n+                       variant: &str) -> io::Result<()> {\n         try!(self.formatter.open(&mut self.writer, b'{'));\n         try!(self.formatter.comma(&mut self.writer, true));\n         try!(self.visit_str(variant));\n@@ -190,7 +193,11 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n     }\n \n     #[inline]\n-    fn visit_enum_seq<V>(&mut self, _name: &str, variant: &str, visitor: V) -> io::Result<()>\n+    fn visit_enum_seq<V>(&mut self,\n+                         _name: &str,\n+                         _variant_index: usize,\n+                         variant: &str,\n+                         visitor: V) -> io::Result<()>\n         where V: ser::SeqVisitor,\n     {\n         try!(self.formatter.open(&mut self.writer, b'{'));\n@@ -206,9 +213,11 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n         where T: ser::Serialize,\n     {\n         try!(self.formatter.comma(&mut self.writer, self.first));\n+        try!(value.serialize(self));\n+\n         self.first = false;\n \n-        value.serialize(self)\n+        Ok(())\n     }\n \n     #[inline]\n@@ -232,7 +241,11 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n     }\n \n     #[inline]\n-    fn visit_enum_map<V>(&mut self, _name: &str, variant: &str, visitor: V) -> io::Result<()>\n+    fn visit_enum_map<V>(&mut self,\n+                         _name: &str,\n+                         _variant_index: usize,\n+                         variant: &str,\n+                         visitor: V) -> io::Result<()>\n         where V: ser::MapVisitor,\n     {\n         try!(self.formatter.open(&mut self.writer, b'{'));\n@@ -250,11 +263,14 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n               V: ser::Serialize,\n     {\n         try!(self.formatter.comma(&mut self.writer, self.first));\n-        self.first = false;\n \n         try!(key.serialize(self));\n         try!(self.formatter.colon(&mut self.writer));\n-        value.serialize(self)\n+        try!(value.serialize(self));\n+\n+        self.first = false;\n+\n+        Ok(())\n     }\n \n     #[inline]\ndiff --git a/serde/src/json/value.rs b/serde_json/src/value.rs\nsimilarity index 96%\nrename from serde/src/json/value.rs\nrename to serde_json/src/value.rs\nindex 7006a0e5c..45cb77855 100644\n--- a/serde/src/json/value.rs\n+++ b/serde_json/src/value.rs\n@@ -6,9 +6,10 @@ use std::vec;\n \n use num::NumCast;\n \n-use de;\n-use ser;\n-use super::error::Error;\n+use serde::de;\n+use serde::ser;\n+\n+use error::Error;\n \n #[derive(Clone, PartialEq)]\n pub enum Value {\n@@ -458,7 +459,10 @@ impl ser::Serializer for Serializer {\n     }\n \n     #[inline]\n-    fn visit_enum_unit(&mut self, _name: &str, variant: &str) -> Result<(), ()> {\n+    fn visit_enum_unit(&mut self,\n+                       _name: &str,\n+                       _variant_index: usize,\n+                       variant: &str) -> Result<(), ()> {\n         let mut values = BTreeMap::new();\n         values.insert(variant.to_string(), Value::Array(vec![]));\n \n@@ -489,7 +493,11 @@ impl ser::Serializer for Serializer {\n     }\n \n     #[inline]\n-    fn visit_enum_seq<V>(&mut self, _name: &str, variant: &str, visitor: V) -> Result<(), ()>\n+    fn visit_enum_seq<V>(&mut self,\n+                         _name: &str,\n+                         _variant_index: usize,\n+                         variant: &str,\n+                         visitor: V) -> Result<(), ()>\n         where V: ser::SeqVisitor,\n     {\n         try!(self.visit_seq(visitor));\n@@ -548,7 +556,11 @@ impl ser::Serializer for Serializer {\n     }\n \n     #[inline]\n-    fn visit_enum_map<V>(&mut self, _name: &str, variant: &str, visitor: V) -> Result<(), ()>\n+    fn visit_enum_map<V>(&mut self,\n+                         _name: &str,\n+                         _variant_index: usize,\n+                         variant: &str,\n+                         visitor: V) -> Result<(), ()>\n         where V: ser::MapVisitor,\n     {\n         try!(self.visit_map(visitor));\n@@ -781,7 +793,9 @@ impl<'a> de::VariantVisitor for SeqDeserializer<'a> {\n         de::Deserializer::visit(self, visitor)\n     }\n \n-    fn visit_map<V>(&mut self, visitor: V) -> Result<V::Value, Error>\n+    fn visit_map<V>(&mut self,\n+                    _fields: &'static [&'static str],\n+                    visitor: V) -> Result<V::Value, Error>\n         where V: de::Visitor,\n     {\n         de::Deserializer::visit(self, visitor)\n@@ -890,7 +904,9 @@ impl<'a> de::VariantVisitor for MapDeserializer<'a> {\n         de::Deserializer::visit(self, visitor)\n     }\n \n-    fn visit_map<V>(&mut self, visitor: V) -> Result<V::Value, Error>\n+    fn visit_map<V>(&mut self,\n+                    _fields: &'static [&'static str],\n+                    visitor: V) -> Result<V::Value, Error>\n         where V: de::Visitor,\n     {\n         de::Deserializer::visit(self, visitor)\ndiff --git a/serde_macros/Cargo.toml b/serde_macros/Cargo.toml\nindex f9ce2bb2d..fc2d9e406 100644\n--- a/serde_macros/Cargo.toml\n+++ b/serde_macros/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_macros\"\n-version = \"0.4.4\"\n+version = \"0.5.0\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"Macros to auto-generate implementations for the serde framework\"\n@@ -17,3 +17,4 @@ serde_codegen = { version = \"*\", path = \"../serde_codegen\", default-features = f\n num = \"*\"\n rustc-serialize = \"*\"\n serde = { version = \"*\", path = \"../serde\", features = [\"nightly\"] }\n+serde_json = { version = \"*\", path = \"../serde_json\" }\ndiff --git a/serde_macros/benches/bench.rs b/serde_macros/benches/bench.rs\nindex 519c189f8..514edc488 100644\n--- a/serde_macros/benches/bench.rs\n+++ b/serde_macros/benches/bench.rs\n@@ -4,6 +4,7 @@\n extern crate num;\n extern crate rustc_serialize;\n extern crate serde;\n+extern crate serde_json;\n extern crate test;\n \n include!(\"../../serde_tests/benches/bench.rs.in\");\ndiff --git a/serde_macros/examples/json.rs b/serde_macros/examples/json.rs\nindex 3da197dfe..50f5d1992 100644\n--- a/serde_macros/examples/json.rs\n+++ b/serde_macros/examples/json.rs\n@@ -2,9 +2,9 @@\n #![plugin(serde_macros)]\n \n extern crate serde;\n+extern crate serde_json;\n \n use std::collections::BTreeMap;\n-use serde::json;\n \n // Creating serializable types with serde is quite simple with `serde_macros`. It implements a\n // syntax extension that automatically generates the necessary serde trait implementations.\n@@ -18,7 +18,7 @@ fn main() {\n     let point = Point { x: 5, y: 6 };\n \n     // Serializing to JSON is pretty simple by using the `to_string` method:\n-    let serialized_point = json::to_string(&point).unwrap();\n+    let serialized_point = serde_json::to_string(&point).unwrap();\n \n     println!(\"{}\", serialized_point);\n     // prints:\n@@ -26,7 +26,7 @@ fn main() {\n     // {\"x\":5,\"y\":6}\n \n     // There is also support for pretty printing using `to_string_pretty`:\n-    let serialized_point = json::to_string_pretty(&point).unwrap();\n+    let serialized_point = serde_json::to_string_pretty(&point).unwrap();\n \n     println!(\"{}\", serialized_point);\n     // prints:\n@@ -37,7 +37,7 @@ fn main() {\n     // }\n \n     // Values can also be deserialized with the same style using `from_str`:\n-    let deserialized_point: Point = json::from_str(&serialized_point).unwrap();\n+    let deserialized_point: Point = serde_json::from_str(&serialized_point).unwrap();\n \n     println!(\"{:?}\", deserialized_point);\n     // prints:\n@@ -46,16 +46,18 @@ fn main() {\n \n     // `Point`s aren't the only type that can be serialized to. Because `Point` members have the\n     // same type, they can be also serialized into a map. Also, \n-    let deserialized_map: BTreeMap<String, i64> = json::from_str(&serialized_point).unwrap();\n+    let deserialized_map: BTreeMap<String, i64> =\n+        serde_json::from_str(&serialized_point).unwrap();\n \n     println!(\"{:?}\", deserialized_map);\n     // prints:\n     //\n     // {\"x\": 5, \"y\": 6}\n \n-    // If you need to accept arbitrary data, you can also deserialize into `json::Value`, which\n-    // can represent all JSON values.\n-    let deserialized_value: json::Value = json::from_str(&serialized_point).unwrap();\n+    // If you need to accept arbitrary data, you can also deserialize into `serde_json::Value`,\n+    // which can represent all JSON values.\n+    let deserialized_value: serde_json::Value =\n+        serde_json::from_str(&serialized_point).unwrap();\n \n     println!(\"{:?}\", deserialized_value);\n     // prints:\n", "test_patch": "diff --git a/serde_macros/tests/test.rs b/serde_macros/tests/test.rs\nindex fd353e1b3..7e98981cf 100644\n--- a/serde_macros/tests/test.rs\n+++ b/serde_macros/tests/test.rs\n@@ -2,6 +2,7 @@\n #![plugin(serde_macros)]\n \n extern crate serde;\n+extern crate serde_json;\n extern crate test;\n \n include!(\"../../serde_tests/tests/test.rs.in\");\ndiff --git a/serde_tests/Cargo.toml b/serde_tests/Cargo.toml\nindex 461ce3631..2fdf55101 100644\n--- a/serde_tests/Cargo.toml\n+++ b/serde_tests/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_tests\"\n-version = \"0.4.3\"\n+version = \"0.5.0\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"A generic serialization/deserialization framework\"\n@@ -19,6 +19,7 @@ serde_codegen = { version = \"*\", path = \"../serde_codegen\", features = [\"with-sy\n num = \"*\"\n rustc-serialize = \"*\"\n serde = { version = \"*\", path = \"../serde\" }\n+serde_json = { version = \"*\", path = \"../serde_json\" }\n syntex = \"*\"\n \n [[test]]\ndiff --git a/serde_tests/benches/bench.rs b/serde_tests/benches/bench.rs\nindex 181c4c616..7cc2fc324 100644\n--- a/serde_tests/benches/bench.rs\n+++ b/serde_tests/benches/bench.rs\n@@ -3,6 +3,7 @@\n extern crate num;\n extern crate rustc_serialize;\n extern crate serde;\n+extern crate serde_json;\n extern crate test;\n \n include!(concat!(env!(\"OUT_DIR\"), \"/bench.rs\"));\ndiff --git a/serde_tests/benches/bench_log.rs b/serde_tests/benches/bench_log.rs\nindex 925b03ed2..4fa108da5 100644\n--- a/serde_tests/benches/bench_log.rs\n+++ b/serde_tests/benches/bench_log.rs\n@@ -5,9 +5,9 @@ use test::Bencher;\n use rustc_serialize;\n \n use serde::de::{self, Deserialize, Deserializer};\n-use serde::json::ser::escape_str;\n-use serde::json;\n use serde::ser::{self, Serialize, Serializer};\n+use serde_json::ser::escape_str;\n+use serde_json;\n use std::str::FromStr;\n \n use rustc_serialize::Encodable;\n@@ -1123,18 +1123,18 @@ fn bench_encoder(b: &mut Bencher) {\n #[test]\n fn test_serializer() {\n     let log = Log::new();\n-    let json = json::to_vec(&log);\n+    let json = serde_json::to_vec(&log);\n     assert_eq!(json, JSON_STR.as_bytes());\n }\n \n #[bench]\n fn bench_serializer(b: &mut Bencher) {\n     let log = Log::new();\n-    let json = json::to_vec(&log);\n+    let json = serde_json::to_vec(&log);\n     b.bytes = json.len() as u64;\n \n     b.iter(|| {\n-        let _ = json::to_vec(&log);\n+        let _ = serde_json::to_vec(&log);\n     });\n }\n \n@@ -1142,7 +1142,7 @@ fn bench_serializer(b: &mut Bencher) {\n fn test_serializer_vec() {\n     let log = Log::new();\n     let wr = Vec::with_capacity(1024);\n-    let mut serializer = json::Serializer::new(wr);\n+    let mut serializer = serde_json::Serializer::new(wr);\n     log.serialize(&mut serializer).unwrap();\n \n     let json = serializer.into_inner();\n@@ -1152,7 +1152,7 @@ fn test_serializer_vec() {\n #[bench]\n fn bench_serializer_vec(b: &mut Bencher) {\n     let log = Log::new();\n-    let json = json::to_vec(&log);\n+    let json = serde_json::to_vec(&log);\n     b.bytes = json.len() as u64;\n \n     let mut wr = Vec::with_capacity(1024);\n@@ -1160,7 +1160,7 @@ fn bench_serializer_vec(b: &mut Bencher) {\n     b.iter(|| {\n         wr.clear();\n \n-        let mut serializer = json::Serializer::new(wr.by_ref());\n+        let mut serializer = serde_json::Serializer::new(wr.by_ref());\n         log.serialize(&mut serializer).unwrap();\n         let _json = serializer.into_inner();\n     });\n@@ -1169,7 +1169,7 @@ fn bench_serializer_vec(b: &mut Bencher) {\n #[bench]\n fn bench_serializer_slice(b: &mut Bencher) {\n     let log = Log::new();\n-    let json = json::to_vec(&log);\n+    let json = serde_json::to_vec(&log);\n     b.bytes = json.len() as u64;\n \n     let mut buf = [0; 1024];\n@@ -1178,7 +1178,7 @@ fn bench_serializer_slice(b: &mut Bencher) {\n         for item in buf.iter_mut(){ *item = 0; }\n         let mut wr = &mut buf[..];\n \n-        let mut serializer = json::Serializer::new(wr.by_ref());\n+        let mut serializer = serde_json::Serializer::new(wr.by_ref());\n         log.serialize(&mut serializer).unwrap();\n         let _json = serializer.into_inner();\n     });\n@@ -1191,7 +1191,7 @@ fn test_serializer_my_mem_writer0() {\n     let mut wr = MyMemWriter0::with_capacity(1024);\n \n     {\n-        let mut serializer = json::Serializer::new(wr.by_ref());\n+        let mut serializer = serde_json::Serializer::new(wr.by_ref());\n         log.serialize(&mut serializer).unwrap();\n         let _json = serializer.into_inner();\n     }\n@@ -1202,7 +1202,7 @@ fn test_serializer_my_mem_writer0() {\n #[bench]\n fn bench_serializer_my_mem_writer0(b: &mut Bencher) {\n     let log = Log::new();\n-    let json = json::to_vec(&log);\n+    let json = serde_json::to_vec(&log);\n     b.bytes = json.len() as u64;\n \n     let mut wr = MyMemWriter0::with_capacity(1024);\n@@ -1210,7 +1210,7 @@ fn bench_serializer_my_mem_writer0(b: &mut Bencher) {\n     b.iter(|| {\n         wr.buf.clear();\n \n-        let mut serializer = json::Serializer::new(wr.by_ref());\n+        let mut serializer = serde_json::Serializer::new(wr.by_ref());\n         log.serialize(&mut serializer).unwrap();\n         let _json = serializer.into_inner();\n     });\n@@ -1223,7 +1223,7 @@ fn test_serializer_my_mem_writer1() {\n     let mut wr = MyMemWriter1::with_capacity(1024);\n \n     {\n-        let mut serializer = json::Serializer::new(wr.by_ref());\n+        let mut serializer = serde_json::Serializer::new(wr.by_ref());\n         log.serialize(&mut serializer).unwrap();\n         let _json = serializer.into_inner();\n     }\n@@ -1234,7 +1234,7 @@ fn test_serializer_my_mem_writer1() {\n #[bench]\n fn bench_serializer_my_mem_writer1(b: &mut Bencher) {\n     let log = Log::new();\n-    let json = json::to_vec(&log);\n+    let json = serde_json::to_vec(&log);\n     b.bytes = json.len() as u64;\n \n     let mut wr = MyMemWriter1::with_capacity(1024);\n@@ -1242,7 +1242,7 @@ fn bench_serializer_my_mem_writer1(b: &mut Bencher) {\n     b.iter(|| {\n         wr.buf.clear();\n \n-        let mut serializer = json::Serializer::new(wr.by_ref());\n+        let mut serializer = serde_json::Serializer::new(wr.by_ref());\n         log.serialize(&mut serializer).unwrap();\n         let _json = serializer.into_inner();\n     });\n@@ -1593,6 +1593,6 @@ fn bench_deserializer(b: &mut Bencher) {\n     b.bytes = JSON_STR.len() as u64;\n \n     b.iter(|| {\n-        let _log: Log = json::from_str(JSON_STR).unwrap();\n+        let _log: Log = serde_json::from_str(JSON_STR).unwrap();\n     });\n }\ndiff --git a/serde_tests/benches/bench_struct.rs b/serde_tests/benches/bench_struct.rs\nindex fd52097b9..6c76eaef2 100644\n--- a/serde_tests/benches/bench_struct.rs\n+++ b/serde_tests/benches/bench_struct.rs\n@@ -398,7 +398,10 @@ mod deserializer {\n             }\n         }\n \n-        fn visit_named_map<V>(&mut self, name: &str, mut visitor: V) -> Result<V::Value, Error>\n+        fn visit_struct<V>(&mut self,\n+                           name: &str,\n+                           _fields: &'static [&'static str],\n+                           mut visitor: V) -> Result<V::Value, Error>\n             where V: de::Visitor,\n         {\n             match self.stack.pop() {\ndiff --git a/serde_tests/tests/test.rs b/serde_tests/tests/test.rs\nindex 732c14329..933c6b850 100644\n--- a/serde_tests/tests/test.rs\n+++ b/serde_tests/tests/test.rs\n@@ -1,3 +1,4 @@\n extern crate serde;\n+extern crate serde_json;\n \n include!(concat!(env!(\"OUT_DIR\"), \"/test.rs\"));\ndiff --git a/serde_tests/tests/test_annotations.rs b/serde_tests/tests/test_annotations.rs\nindex 37746ae5b..9a21e0bf7 100644\n--- a/serde_tests/tests/test_annotations.rs\n+++ b/serde_tests/tests/test_annotations.rs\n@@ -1,4 +1,4 @@\n-use serde::json;\n+use serde_json;\n \n #[derive(Debug, PartialEq, Serialize, Deserialize)]\n struct Default {\n@@ -33,30 +33,30 @@ enum SerEnum<A> {\n \n #[test]\n fn test_default() {\n-    let deserialized_value: Default = json::from_str(&\"{\\\"a1\\\":1,\\\"a2\\\":2}\").unwrap();\n+    let deserialized_value: Default = serde_json::from_str(&\"{\\\"a1\\\":1,\\\"a2\\\":2}\").unwrap();\n     assert_eq!(deserialized_value, Default { a1: 1, a2: 2 });\n \n-    let deserialized_value: Default = json::from_str(&\"{\\\"a1\\\":1}\").unwrap();\n+    let deserialized_value: Default = serde_json::from_str(&\"{\\\"a1\\\":1}\").unwrap();\n     assert_eq!(deserialized_value, Default { a1: 1, a2: 0 });\n }\n \n #[test]\n fn test_rename() {\n     let value = Rename { a1: 1, a2: 2 };\n-    let serialized_value = json::to_string(&value).unwrap();\n+    let serialized_value = serde_json::to_string(&value).unwrap();\n     assert_eq!(serialized_value, \"{\\\"a1\\\":1,\\\"a3\\\":2}\");\n \n-    let deserialized_value: Rename = json::from_str(&serialized_value).unwrap();\n+    let deserialized_value: Rename = serde_json::from_str(&serialized_value).unwrap();\n     assert_eq!(value, deserialized_value);\n }\n \n #[test]\n fn test_format_rename() {\n     let value = FormatRename { a1: 1, a2: 2 };\n-    let serialized_value = json::to_string(&value).unwrap();\n+    let serialized_value = serde_json::to_string(&value).unwrap();\n     assert_eq!(serialized_value, \"{\\\"a1\\\":1,\\\"a5\\\":2}\");\n \n-    let deserialized_value = json::from_str(\"{\\\"a1\\\":1,\\\"a5\\\":2}\").unwrap();\n+    let deserialized_value = serde_json::from_str(\"{\\\"a1\\\":1,\\\"a5\\\":2}\").unwrap();\n     assert_eq!(value, deserialized_value);\n }\n \n@@ -64,10 +64,10 @@ fn test_format_rename() {\n fn test_enum_format_rename() {\n     let s1 = String::new();\n     let value = SerEnum::Map { a: 0i8, b: s1 };\n-    let serialized_value = json::to_string(&value).unwrap();\n+    let serialized_value = serde_json::to_string(&value).unwrap();\n     let ans = \"{\\\"Map\\\":{\\\"a\\\":0,\\\"d\\\":\\\"\\\"}}\";\n     assert_eq!(serialized_value, ans);\n \n-    let deserialized_value = json::from_str(ans).unwrap();\n+    let deserialized_value = serde_json::from_str(ans).unwrap();\n     assert_eq!(value, deserialized_value);\n }\ndiff --git a/serde_tests/tests/test_bytes.rs b/serde_tests/tests/test_bytes.rs\nindex a72cf1ae2..3ca97285a 100644\n--- a/serde_tests/tests/test_bytes.rs\n+++ b/serde_tests/tests/test_bytes.rs\n@@ -1,7 +1,7 @@\n use serde;\n use serde::Serialize;\n use serde::bytes::{ByteBuf, Bytes};\n-use serde::json;\n+use serde_json;\n \n ///////////////////////////////////////////////////////////////////////////////\n \n@@ -144,11 +144,11 @@ impl serde::Deserializer for BytesDeserializer {\n fn test_bytes_ser_json() {\n     let buf = vec![];\n     let bytes = Bytes::from(&buf);\n-    assert_eq!(json::to_string(&bytes).unwrap(), \"[]\".to_string());\n+    assert_eq!(serde_json::to_string(&bytes).unwrap(), \"[]\".to_string());\n \n     let buf = vec![1, 2, 3];\n     let bytes = Bytes::from(&buf);\n-    assert_eq!(json::to_string(&bytes).unwrap(), \"[1,2,3]\".to_string());\n+    assert_eq!(serde_json::to_string(&bytes).unwrap(), \"[1,2,3]\".to_string());\n }\n \n #[test]\n@@ -167,10 +167,10 @@ fn test_bytes_ser_bytes() {\n #[test]\n fn test_byte_buf_ser_json() {\n     let bytes = ByteBuf::new();\n-    assert_eq!(json::to_string(&bytes).unwrap(), \"[]\".to_string());\n+    assert_eq!(serde_json::to_string(&bytes).unwrap(), \"[]\".to_string());\n \n     let bytes = ByteBuf::from(vec![1, 2, 3]);\n-    assert_eq!(json::to_string(&bytes).unwrap(), \"[1,2,3]\".to_string());\n+    assert_eq!(serde_json::to_string(&bytes).unwrap(), \"[1,2,3]\".to_string());\n }\n \n #[test]\n@@ -189,11 +189,11 @@ fn test_byte_buf_ser_bytes() {\n #[test]\n fn test_byte_buf_de_json() {\n     let bytes = ByteBuf::new();\n-    let v: ByteBuf = json::from_str(\"[]\").unwrap();\n+    let v: ByteBuf = serde_json::from_str(\"[]\").unwrap();\n     assert_eq!(v, bytes);\n \n     let bytes = ByteBuf::from(vec![1, 2, 3]);\n-    let v: ByteBuf = json::from_str(\"[1, 2, 3]\").unwrap();\n+    let v: ByteBuf = serde_json::from_str(\"[1, 2, 3]\").unwrap();\n     assert_eq!(v, bytes);\n }\n \ndiff --git a/serde_tests/tests/test_de.rs b/serde_tests/tests/test_de.rs\nindex 7e1f2d986..9b789c84b 100644\n--- a/serde_tests/tests/test_de.rs\n+++ b/serde_tests/tests/test_de.rs\n@@ -161,7 +161,7 @@ impl Deserializer for TokenDeserializer {\n         }\n     }\n \n-    fn visit_named_unit<V>(&mut self, name: &str, visitor: V) -> Result<V::Value, Error>\n+    fn visit_unit_struct<V>(&mut self, name: &str, visitor: V) -> Result<V::Value, Error>\n         where V: de::Visitor,\n     {\n         match self.tokens.peek() {\n@@ -178,7 +178,7 @@ impl Deserializer for TokenDeserializer {\n         }\n     }\n \n-    fn visit_named_seq<V>(&mut self, name: &str, visitor: V) -> Result<V::Value, Error>\n+    fn visit_tuple_struct<V>(&mut self, name: &str, visitor: V) -> Result<V::Value, Error>\n         where V: de::Visitor,\n     {\n         match self.tokens.peek() {\n@@ -195,7 +195,10 @@ impl Deserializer for TokenDeserializer {\n         }\n     }\n \n-    fn visit_named_map<V>(&mut self, name: &str, visitor: V) -> Result<V::Value, Error>\n+    fn visit_struct<V>(&mut self,\n+                       name: &str,\n+                       _fields: &'static [&'static str],\n+                       visitor: V) -> Result<V::Value, Error>\n         where V: de::Visitor,\n     {\n         match self.tokens.peek() {\n@@ -324,7 +327,9 @@ impl<'a> de::VariantVisitor for TokenDeserializerVariantVisitor<'a> {\n         de::Deserializer::visit(self.de, visitor)\n     }\n \n-    fn visit_map<V>(&mut self, visitor: V) -> Result<V::Value, Error>\n+    fn visit_map<V>(&mut self,\n+                    _fields: &'static [&'static str],\n+                    visitor: V) -> Result<V::Value, Error>\n         where V: de::Visitor,\n     {\n         de::Deserializer::visit(self.de, visitor)\n@@ -334,13 +339,13 @@ impl<'a> de::VariantVisitor for TokenDeserializerVariantVisitor<'a> {\n //////////////////////////////////////////////////////////////////////////\n \n #[derive(Copy, Clone, PartialEq, Debug, Deserialize)]\n-struct NamedUnit;\n+struct UnitStruct;\n \n #[derive(PartialEq, Debug, Deserialize)]\n-struct NamedSeq(i32, i32, i32);\n+struct TupleStruct(i32, i32, i32);\n \n #[derive(PartialEq, Debug, Deserialize)]\n-struct NamedMap {\n+struct Struct {\n     a: i32,\n     b: i32,\n     c: i32,\n@@ -486,6 +491,26 @@ declare_tests! {\n             Token::I32(1),\n         ],\n     }\n+    test_result {\n+        Ok::<i32, i32>(0) => vec![\n+            Token::EnumStart(\"Result\"),\n+                Token::Str(\"Ok\"),\n+                Token::SeqStart(1),\n+                    Token::SeqSep,\n+                    Token::I32(0),\n+                Token::SeqEnd,\n+            Token::EnumEnd,\n+        ],\n+        Err::<i32, i32>(1) => vec![\n+            Token::EnumStart(\"Result\"),\n+                Token::Str(\"Err\"),\n+                Token::SeqStart(1),\n+                    Token::SeqSep,\n+                    Token::I32(1),\n+                Token::SeqEnd,\n+            Token::EnumEnd,\n+        ],\n+    }\n     test_unit {\n         () => vec![Token::Unit],\n         () => vec![\n@@ -498,19 +523,19 @@ declare_tests! {\n             Token::SeqEnd,\n         ],\n     }\n-    test_named_unit {\n-        NamedUnit => vec![Token::Unit],\n-        NamedUnit => vec![\n-            Token::Name(\"NamedUnit\"),\n+    test_unit_struct {\n+        UnitStruct => vec![Token::Unit],\n+        UnitStruct => vec![\n+            Token::Name(\"UnitStruct\"),\n             Token::Unit,\n         ],\n-        NamedUnit => vec![\n+        UnitStruct => vec![\n             Token::SeqStart(0),\n             Token::SeqEnd,\n         ],\n     }\n-    test_named_seq {\n-        NamedSeq(1, 2, 3) => vec![\n+    test_tuple_struct {\n+        TupleStruct(1, 2, 3) => vec![\n             Token::SeqStart(3),\n                 Token::SeqSep,\n                 Token::I32(1),\n@@ -522,8 +547,8 @@ declare_tests! {\n                 Token::I32(3),\n             Token::SeqEnd,\n         ],\n-        NamedSeq(1, 2, 3) => vec![\n-            Token::Name(\"NamedSeq\"),\n+        TupleStruct(1, 2, 3) => vec![\n+            Token::Name(\"TupleStruct\"),\n             Token::SeqStart(3),\n                 Token::SeqSep,\n                 Token::I32(1),\n@@ -818,8 +843,8 @@ declare_tests! {\n             Token::MapEnd,\n         ],\n     }\n-    test_named_map {\n-        NamedMap { a: 1, b: 2, c: 3 } => vec![\n+    test_struct {\n+        Struct { a: 1, b: 2, c: 3 } => vec![\n             Token::MapStart(3),\n                 Token::MapSep,\n                 Token::Str(\"a\"),\n@@ -834,8 +859,8 @@ declare_tests! {\n                 Token::I32(3),\n             Token::MapEnd,\n         ],\n-        NamedMap { a: 1, b: 2, c: 3 } => vec![\n-            Token::Name(\"NamedMap\"),\n+        Struct { a: 1, b: 2, c: 3 } => vec![\n+            Token::Name(\"Struct\"),\n             Token::MapStart(3),\n                 Token::MapSep,\n                 Token::Str(\"a\"),\ndiff --git a/serde_tests/tests/test_json.rs b/serde_tests/tests/test_json.rs\nindex c29f82865..931527e97 100644\n--- a/serde_tests/tests/test_json.rs\n+++ b/serde_tests/tests/test_json.rs\n@@ -1,10 +1,11 @@\n-use std::fmt::Debug;\n use std::collections::BTreeMap;\n+use std::fmt::Debug;\n+use std::marker::PhantomData;\n \n use serde::de;\n use serde::ser;\n \n-use serde::json::{\n+use serde_json::{\n     self,\n     Value,\n     from_str,\n@@ -12,7 +13,7 @@ use serde::json::{\n     to_value,\n };\n \n-use serde::json::error::{Error, ErrorCode};\n+use serde_json::error::{Error, ErrorCode};\n \n macro_rules! treemap {\n     ($($k:expr => $v:expr),*) => ({\n@@ -48,11 +49,11 @@ fn test_encode_ok<T>(errors: &[(T, &str)])\n     for &(ref value, out) in errors {\n         let out = out.to_string();\n \n-        let s = json::to_string(value).unwrap();\n+        let s = serde_json::to_string(value).unwrap();\n         assert_eq!(s, out);\n \n         let v = to_value(&value);\n-        let s = json::to_string(&v).unwrap();\n+        let s = serde_json::to_string(&v).unwrap();\n         assert_eq!(s, out);\n     }\n }\n@@ -63,11 +64,11 @@ fn test_pretty_encode_ok<T>(errors: &[(T, &str)])\n     for &(ref value, out) in errors {\n         let out = out.to_string();\n \n-        let s = json::to_string_pretty(value).unwrap();\n+        let s = serde_json::to_string_pretty(value).unwrap();\n         assert_eq!(s, out);\n \n         let v = to_value(&value);\n-        let s = json::to_string_pretty(&v).unwrap();\n+        let s = serde_json::to_string_pretty(&v).unwrap();\n         assert_eq!(s, out);\n     }\n }\n@@ -891,7 +892,7 @@ fn test_parse_struct() {\n                     Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }\n                 ]\n             },\n-        )\n+        ),\n     ]);\n \n     let v: Outer = from_str(\"{}\").unwrap();\n@@ -902,6 +903,22 @@ fn test_parse_struct() {\n             inner: vec![],\n         }\n     );\n+\n+    let v: Outer = from_str(\n+        \"[\n+            [\n+                [ null, 2, [\\\"abc\\\", \\\"xyz\\\"] ]\n+            ]\n+        ]\").unwrap();\n+\n+    assert_eq!(\n+        v,\n+        Outer {\n+            inner: vec![\n+                Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }\n+            ],\n+        }\n+    );\n }\n \n #[test]\n@@ -934,7 +951,7 @@ fn test_parse_enum_errors() {\n         (\"{\\\"unknown\\\":[]}\", Error::SyntaxError(ErrorCode::UnknownField(\"unknown\".to_string()), 1, 11)),\n         (\"{\\\"Dog\\\":{}}\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 9)),\n         (\"{\\\"Frog\\\":{}}\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 10)),\n-        (\"{\\\"Cat\\\":[]}\", Error::SyntaxError(ErrorCode::ExpectedSomeValue, 1, 9)),\n+        (\"{\\\"Cat\\\":[]}\", Error::SyntaxError(ErrorCode::EOFWhileParsingValue, 1, 9)),\n     ]);\n }\n \n@@ -1064,7 +1081,7 @@ fn test_missing_fmt_renamed_field() {\n \n #[test]\n fn test_find_path() {\n-    let obj: Value = json::from_str(r#\"{\"x\": {\"a\": 1}, \"y\": 2}\"#).unwrap();\n+    let obj: Value = serde_json::from_str(r#\"{\"x\": {\"a\": 1}, \"y\": 2}\"#).unwrap();\n \n     assert!(obj.find_path(&[\"x\", \"a\"]).unwrap() == &Value::U64(1));\n     assert!(obj.find_path(&[\"y\"]).unwrap() == &Value::U64(2));\n@@ -1073,9 +1090,180 @@ fn test_find_path() {\n \n #[test]\n fn test_lookup() {\n-    let obj: Value = json::from_str(r#\"{\"x\": {\"a\": 1}, \"y\": 2}\"#).unwrap();\n+    let obj: Value = serde_json::from_str(r#\"{\"x\": {\"a\": 1}, \"y\": 2}\"#).unwrap();\n \n     assert!(obj.lookup(\"x.a\").unwrap() == &Value::U64(1));\n     assert!(obj.lookup(\"y\").unwrap() == &Value::U64(2));\n     assert!(obj.lookup(\"z\").is_none());\n }\n+\n+#[test]\n+fn test_serialize_seq_with_no_len() {\n+    #[derive(Clone, Debug, PartialEq)]\n+    struct MyVec<T>(Vec<T>);\n+\n+    impl<T> ser::Serialize for MyVec<T>\n+        where T: ser::Serialize,\n+    {\n+        #[inline]\n+        fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+            where S: ser::Serializer,\n+        {\n+            serializer.visit_seq(ser::impls::SeqIteratorVisitor::new(self.0.iter(), None))\n+        }\n+    }\n+\n+    struct Visitor<T> {\n+        marker: PhantomData<MyVec<T>>,\n+    }\n+\n+    impl<T> de::Visitor for Visitor<T>\n+        where T: de::Deserialize,\n+    {\n+        type Value = MyVec<T>;\n+\n+        #[inline]\n+        fn visit_unit<E>(&mut self) -> Result<MyVec<T>, E>\n+            where E: de::Error,\n+        {\n+            Ok(MyVec(Vec::new()))\n+        }\n+\n+        #[inline]\n+        fn visit_seq<V>(&mut self, mut visitor: V) -> Result<MyVec<T>, V::Error>\n+            where V: de::SeqVisitor,\n+        {\n+            let mut values = Vec::new();\n+\n+            while let Some(value) = try!(visitor.visit()) {\n+                values.push(value);\n+            }\n+\n+            try!(visitor.end());\n+\n+            Ok(MyVec(values))\n+        }\n+    }\n+\n+    impl<T> de::Deserialize for MyVec<T>\n+        where T: de::Deserialize,\n+    {\n+        fn deserialize<D>(deserializer: &mut D) -> Result<MyVec<T>, D::Error>\n+            where D: de::Deserializer,\n+        {\n+            deserializer.visit_map(Visitor { marker: PhantomData })\n+        }\n+    }\n+\n+    let mut vec = Vec::new();\n+    vec.push(MyVec(Vec::new()));\n+    vec.push(MyVec(Vec::new()));\n+    let vec: MyVec<MyVec<u32>> = MyVec(vec);\n+\n+    test_encode_ok(&[\n+        (\n+            vec.clone(),\n+            \"[[],[]]\",\n+        ),\n+    ]);\n+\n+    let s = serde_json::to_string_pretty(&vec).unwrap();\n+    assert_eq!(\n+        s,\n+        concat!(\n+            \"[\\n\",\n+            \"  [\\n\",\n+            \"  ],\\n\",\n+            \"  [\\n\",\n+            \"  ]\\n\",\n+            \"]\"\n+        )\n+    );\n+}\n+\n+#[test]\n+fn test_serialize_map_with_no_len() {\n+    #[derive(Clone, Debug, PartialEq)]\n+    struct Map<K, V>(BTreeMap<K, V>);\n+\n+    impl<K, V> ser::Serialize for Map<K, V>\n+        where K: ser::Serialize + Ord,\n+              V: ser::Serialize,\n+    {\n+        #[inline]\n+        fn serialize<S>(&self, serializer: &mut S) -> Result<(), S::Error>\n+            where S: ser::Serializer,\n+        {\n+            serializer.visit_map(ser::impls::MapIteratorVisitor::new(self.0.iter(), None))\n+        }\n+    }\n+\n+    struct Visitor<K, V> {\n+        marker: PhantomData<Map<K, V>>,\n+    }\n+\n+    impl<K, V> de::Visitor for Visitor<K, V>\n+        where K: de::Deserialize + Eq + Ord,\n+              V: de::Deserialize,\n+    {\n+        type Value = Map<K, V>;\n+\n+        #[inline]\n+        fn visit_unit<E>(&mut self) -> Result<Map<K, V>, E>\n+            where E: de::Error,\n+        {\n+            Ok(Map(BTreeMap::new()))\n+        }\n+\n+        #[inline]\n+        fn visit_map<Visitor>(&mut self, mut visitor: Visitor) -> Result<Map<K, V>, Visitor::Error>\n+            where Visitor: de::MapVisitor,\n+        {\n+            let mut values = BTreeMap::new();\n+\n+            while let Some((key, value)) = try!(visitor.visit()) {\n+                values.insert(key, value);\n+            }\n+\n+            try!(visitor.end());\n+\n+            Ok(Map(values))\n+        }\n+    }\n+\n+    impl<K, V> de::Deserialize for Map<K, V>\n+        where K: de::Deserialize + Eq + Ord,\n+              V: de::Deserialize,\n+    {\n+        fn deserialize<D>(deserializer: &mut D) -> Result<Map<K, V>, D::Error>\n+            where D: de::Deserializer,\n+        {\n+            deserializer.visit_map(Visitor { marker: PhantomData })\n+        }\n+    }\n+\n+    let mut map = BTreeMap::new();\n+    map.insert(\"a\", Map(BTreeMap::new()));\n+    map.insert(\"b\", Map(BTreeMap::new()));\n+    let map: Map<_, Map<u32, u32>> = Map(map);\n+\n+    test_encode_ok(&[\n+        (\n+            map.clone(),\n+            \"{\\\"a\\\":{},\\\"b\\\":{}}\",\n+        ),\n+    ]);\n+\n+    let s = serde_json::to_string_pretty(&map).unwrap();\n+    assert_eq!(\n+        s,\n+        concat!(\n+            \"{\\n\",\n+            \"  \\\"a\\\": {\\n\",\n+            \"  },\\n\",\n+            \"  \\\"b\\\": {\\n\",\n+            \"  }\\n\",\n+            \"}\"\n+        )\n+    );\n+}\ndiff --git a/serde_tests/tests/test_json_builder.rs b/serde_tests/tests/test_json_builder.rs\nindex f17dd70ae..55fcff08e 100644\n--- a/serde_tests/tests/test_json_builder.rs\n+++ b/serde_tests/tests/test_json_builder.rs\n@@ -1,7 +1,7 @@\n use std::collections::BTreeMap;\n \n-use serde::json::value::Value;\n-use serde::json::builder::{ArrayBuilder, ObjectBuilder};\n+use serde_json::value::Value;\n+use serde_json::builder::{ArrayBuilder, ObjectBuilder};\n \n #[test]\n fn test_array_builder() {\ndiff --git a/serde_tests/tests/test_macros.rs b/serde_tests/tests/test_macros.rs\nindex 524147bf7..d7af98557 100644\n--- a/serde_tests/tests/test_macros.rs\n+++ b/serde_tests/tests/test_macros.rs\n@@ -1,5 +1,5 @@\n use std::collections::BTreeMap;\n-use serde::json::{self, Value};\n+use serde_json::{self, Value};\n \n macro_rules! btreemap {\n     () => {\n@@ -136,19 +136,19 @@ fn test_named_unit() {\n     let named_unit = NamedUnit;\n \n     assert_eq!(\n-        json::to_string(&named_unit).unwrap(),\n+        serde_json::to_string(&named_unit).unwrap(),\n         \"null\".to_string()\n     );\n \n     assert_eq!(\n-        json::to_value(&named_unit),\n+        serde_json::to_value(&named_unit),\n         Value::Null\n     );\n \n-    let v: NamedUnit = json::from_str(\"null\").unwrap();\n+    let v: NamedUnit = serde_json::from_str(\"null\").unwrap();\n     assert_eq!(v, named_unit);\n \n-    let v: NamedUnit = json::from_value(Value::Null).unwrap();\n+    let v: NamedUnit = serde_json::from_value(Value::Null).unwrap();\n     assert_eq!(v, named_unit);\n }\n \n@@ -160,25 +160,25 @@ fn test_ser_named_tuple() {\n     let named_tuple = SerNamedTuple(&a, &mut b, c);\n \n     assert_eq!(\n-        json::to_string(&named_tuple).unwrap(),\n+        serde_json::to_string(&named_tuple).unwrap(),\n         \"[5,6,7]\"\n     );\n \n     assert_eq!(\n-        json::to_value(&named_tuple),\n+        serde_json::to_value(&named_tuple),\n         Value::Array(vec![Value::U64(5), Value::U64(6), Value::U64(7)])\n     );\n }\n \n #[test]\n fn test_de_named_tuple() {\n-    let v: DeNamedTuple<i32, i32, i32> = json::from_str(\"[1,2,3]\").unwrap();\n+    let v: DeNamedTuple<i32, i32, i32> = serde_json::from_str(\"[1,2,3]\").unwrap();\n     assert_eq!(\n         v,\n         DeNamedTuple(1, 2, 3)\n     );\n \n-    let v: Value = json::from_str(\"[1,2,3]\").unwrap();\n+    let v: Value = serde_json::from_str(\"[1,2,3]\").unwrap();\n     assert_eq!(\n         v,\n         Value::Array(vec![\n@@ -201,12 +201,12 @@ fn test_ser_named_map() {\n     };\n \n     assert_eq!(\n-        json::to_string(&named_map).unwrap(),\n+        serde_json::to_string(&named_map).unwrap(),\n         \"{\\\"a\\\":5,\\\"b\\\":6,\\\"c\\\":7}\"\n     );\n \n     assert_eq!(\n-        json::to_value(&named_map),\n+        serde_json::to_value(&named_map),\n         Value::Object(btreemap![\n             \"a\".to_string() => Value::U64(5),\n             \"b\".to_string() => Value::U64(6),\n@@ -223,12 +223,12 @@ fn test_de_named_map() {\n         c: 7,\n     };\n \n-    let v2: DeNamedMap<i32, i32, i32> = json::from_str(\n+    let v2: DeNamedMap<i32, i32, i32> = serde_json::from_str(\n         \"{\\\"a\\\":5,\\\"b\\\":6,\\\"c\\\":7}\"\n     ).unwrap();\n     assert_eq!(v, v2);\n \n-    let v2 = json::from_value(Value::Object(btreemap![\n+    let v2 = serde_json::from_value(Value::Object(btreemap![\n         \"a\".to_string() => Value::U64(5),\n         \"b\".to_string() => Value::U64(6),\n         \"c\".to_string() => Value::U64(7)\n@@ -239,12 +239,12 @@ fn test_de_named_map() {\n #[test]\n fn test_ser_enum_unit() {\n     assert_eq!(\n-        json::to_string(&SerEnum::Unit::<u32, u32, u32>).unwrap(),\n+        serde_json::to_string(&SerEnum::Unit::<u32, u32, u32>).unwrap(),\n         \"{\\\"Unit\\\":[]}\"\n     );\n \n     assert_eq!(\n-        json::to_value(&SerEnum::Unit::<u32, u32, u32>),\n+        serde_json::to_value(&SerEnum::Unit::<u32, u32, u32>),\n         Value::Object(btreemap!(\n             \"Unit\".to_string() => Value::Array(vec![]))\n         )\n@@ -261,7 +261,7 @@ fn test_ser_enum_seq() {\n     //let f = 6;\n \n     assert_eq!(\n-        json::to_string(&SerEnum::Seq(\n+        serde_json::to_string(&SerEnum::Seq(\n             a,\n             b,\n             &c,\n@@ -273,7 +273,7 @@ fn test_ser_enum_seq() {\n     );\n \n     assert_eq!(\n-        json::to_value(&SerEnum::Seq(\n+        serde_json::to_value(&SerEnum::Seq(\n             a,\n             b,\n             &c,\n@@ -304,7 +304,7 @@ fn test_ser_enum_map() {\n     //let f = 6;\n \n     assert_eq!(\n-        json::to_string(&SerEnum::Map {\n+        serde_json::to_string(&SerEnum::Map {\n             a: a,\n             b: b,\n             c: &c,\n@@ -316,7 +316,7 @@ fn test_ser_enum_map() {\n     );\n \n     assert_eq!(\n-        json::to_value(&SerEnum::Map {\n+        serde_json::to_value(&SerEnum::Map {\n             a: a,\n             b: b,\n             c: &c,\n@@ -339,13 +339,13 @@ fn test_ser_enum_map() {\n \n #[test]\n fn test_de_enum_unit() {\n-    let v: DeEnum<_, _, _> = json::from_str(\"{\\\"Unit\\\":[]}\").unwrap();\n+    let v: DeEnum<_, _, _> = serde_json::from_str(\"{\\\"Unit\\\":[]}\").unwrap();\n     assert_eq!(\n         v,\n         DeEnum::Unit::<u32, u32, u32>\n     );\n \n-    let v: DeEnum<_, _, _> = json::from_value(Value::Object(btreemap!(\n+    let v: DeEnum<_, _, _> = serde_json::from_value(Value::Object(btreemap!(\n         \"Unit\".to_string() => Value::Array(vec![]))\n     )).unwrap();\n     assert_eq!(\n@@ -363,7 +363,7 @@ fn test_de_enum_seq() {\n     let e = 5;\n     //let f = 6;\n \n-    let v: DeEnum<_, _, _> = json::from_str(\"{\\\"Seq\\\":[1,2,3,5]}\").unwrap();\n+    let v: DeEnum<_, _, _> = serde_json::from_str(\"{\\\"Seq\\\":[1,2,3,5]}\").unwrap();\n     assert_eq!(\n         v,\n         DeEnum::Seq(\n@@ -376,7 +376,7 @@ fn test_de_enum_seq() {\n         )\n     );\n \n-    let v: DeEnum<_, _, _> = json::from_value(Value::Object(btreemap!(\n+    let v: DeEnum<_, _, _> = serde_json::from_value(Value::Object(btreemap!(\n         \"Seq\".to_string() => Value::Array(vec![\n             Value::U64(1),\n             Value::U64(2),\n@@ -408,7 +408,7 @@ fn test_de_enum_map() {\n     let e = 5;\n     //let f = 6;\n \n-    let v: DeEnum<_, _, _> = json::from_str(\n+    let v: DeEnum<_, _, _> = serde_json::from_str(\n         \"{\\\"Map\\\":{\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3,\\\"e\\\":5}}\"\n     ).unwrap();\n     assert_eq!(\n@@ -423,7 +423,7 @@ fn test_de_enum_map() {\n         }\n     );\n \n-    let v: DeEnum<_, _, _> = json::from_value(Value::Object(btreemap!(\n+    let v: DeEnum<_, _, _> = serde_json::from_value(Value::Object(btreemap!(\n         \"Map\".to_string() => Value::Object(btreemap![\n             \"a\".to_string() => Value::U64(1),\n             \"b\".to_string() => Value::U64(2),\n@@ -452,26 +452,26 @@ fn test_lifetimes() {\n     let value = 5;\n     let lifetime = Lifetimes::LifetimeSeq(&value);\n     assert_eq!(\n-        json::to_string(&lifetime).unwrap(),\n+        serde_json::to_string(&lifetime).unwrap(),\n         \"{\\\"LifetimeSeq\\\":[5]}\"\n     );\n \n     let lifetime = Lifetimes::NoLifetimeSeq(5);\n     assert_eq!(\n-        json::to_string(&lifetime).unwrap(),\n+        serde_json::to_string(&lifetime).unwrap(),\n         \"{\\\"NoLifetimeSeq\\\":[5]}\"\n     );\n \n     let value = 5;\n     let lifetime = Lifetimes::LifetimeMap { a: &value };\n     assert_eq!(\n-        json::to_string(&lifetime).unwrap(),\n+        serde_json::to_string(&lifetime).unwrap(),\n         \"{\\\"LifetimeMap\\\":{\\\"a\\\":5}}\"\n     );\n \n     let lifetime = Lifetimes::NoLifetimeMap { a: 5 };\n     assert_eq!(\n-        json::to_string(&lifetime).unwrap(),\n+        serde_json::to_string(&lifetime).unwrap(),\n         \"{\\\"NoLifetimeMap\\\":{\\\"a\\\":5}}\"\n     );\n }\ndiff --git a/serde_tests/tests/test_ser.rs b/serde_tests/tests/test_ser.rs\nindex 27644f450..950b5b828 100644\n--- a/serde_tests/tests/test_ser.rs\n+++ b/serde_tests/tests/test_ser.rs\n@@ -24,17 +24,17 @@ pub enum Token<'a> {\n     Option(bool),\n \n     Unit,\n-    NamedUnit(&'a str),\n+    UnitStruct(&'a str),\n     EnumUnit(&'a str, &'a str),\n \n     SeqStart(Option<usize>),\n-    NamedSeqStart(&'a str, Option<usize>),\n+    TupleStructStart(&'a str, Option<usize>),\n     EnumSeqStart(&'a str, &'a str, Option<usize>),\n     SeqSep,\n     SeqEnd,\n \n     MapStart(Option<usize>),\n-    NamedMapStart(&'a str, Option<usize>),\n+    StructStart(&'a str, Option<usize>),\n     EnumMapStart(&'a str, &'a str, Option<usize>),\n     MapSep,\n     MapEnd,\n@@ -80,13 +80,20 @@ impl<'a> Serializer for AssertSerializer<'a> {\n         Ok(())\n     }\n \n-    fn visit_named_unit(&mut self, name: &str) -> Result<(), ()> {\n-        assert_eq!(self.iter.next().unwrap(), Token::NamedUnit(name));\n+    fn visit_unit_struct(&mut self, name: &str) -> Result<(), ()> {\n+        assert_eq!(self.iter.next().unwrap(), Token::UnitStruct(name));\n         Ok(())\n     }\n \n-    fn visit_enum_unit(&mut self, name: &str, variant: &str) -> Result<(), ()> {\n-        assert_eq!(self.iter.next().unwrap(), Token::EnumUnit(name, variant));\n+    fn visit_enum_unit(&mut self,\n+                       name: &str,\n+                       _variant_index: usize,\n+                       variant: &str) -> Result<(), ()> {\n+        assert_eq!(\n+            self.iter.next().unwrap(),\n+            Token::EnumUnit(name, variant)\n+        );\n+\n         Ok(())\n     }\n \n@@ -188,25 +195,32 @@ impl<'a> Serializer for AssertSerializer<'a> {\n         self.visit_sequence(visitor)\n     }\n \n-    fn visit_named_seq<V>(&mut self, name: &str, visitor: V) -> Result<(), ()>\n+    fn visit_tuple_struct<V>(&mut self, name: &str, visitor: V) -> Result<(), ()>\n         where V: SeqVisitor\n     {\n         let len = visitor.len();\n \n-        assert_eq!(self.iter.next().unwrap(), Token::NamedSeqStart(name, len));\n+        assert_eq!(\n+            self.iter.next().unwrap(),\n+            Token::TupleStructStart(name, len)\n+        );\n \n         self.visit_sequence(visitor)\n     }\n \n     fn visit_enum_seq<V>(&mut self,\n                          name: &str,\n+                         _variant_index: usize,\n                          variant: &str,\n                          visitor: V) -> Result<(), ()>\n         where V: SeqVisitor\n     {\n         let len = visitor.len();\n \n-        assert_eq!(self.iter.next().unwrap(), Token::EnumSeqStart(name, variant, len));\n+        assert_eq!(\n+            self.iter.next().unwrap(),\n+            Token::EnumSeqStart(name, variant, len)\n+        );\n \n         self.visit_sequence(visitor)\n     }\n@@ -228,22 +242,32 @@ impl<'a> Serializer for AssertSerializer<'a> {\n         self.visit_mapping(visitor)\n     }\n \n-    fn visit_named_map<V>(&mut self, name: &str, visitor: V) -> Result<(), ()>\n+    fn visit_struct<V>(&mut self, name: &str, visitor: V) -> Result<(), ()>\n         where V: MapVisitor\n     {\n         let len = visitor.len();\n \n-        assert_eq!(self.iter.next().unwrap(), Token::NamedMapStart(name, len));\n+        assert_eq!(\n+            self.iter.next().unwrap(),\n+            Token::StructStart(name, len)\n+        );\n \n         self.visit_mapping(visitor)\n     }\n \n-    fn visit_enum_map<V>(&mut self, name: &str, variant: &str, visitor: V) -> Result<(), ()>\n+    fn visit_enum_map<V>(&mut self,\n+                         name: &str,\n+                         _variant_index: usize,\n+                         variant: &str,\n+                         visitor: V) -> Result<(), ()>\n         where V: MapVisitor\n     {\n         let len = visitor.len();\n \n-        assert_eq!(self.iter.next().unwrap(), Token::EnumMapStart(name, variant, len));\n+        assert_eq!(\n+            self.iter.next().unwrap(),\n+            Token::EnumMapStart(name, variant, len)\n+        );\n \n         self.visit_mapping(visitor)\n     }\n@@ -262,13 +286,13 @@ impl<'a> Serializer for AssertSerializer<'a> {\n //////////////////////////////////////////////////////////////////////////\n \n #[derive(Serialize)]\n-struct NamedUnit;\n+struct UnitStruct;\n \n #[derive(Serialize)]\n-struct NamedSeq(i32, i32, i32);\n+struct TupleStruct(i32, i32, i32);\n \n #[derive(Serialize)]\n-struct NamedMap {\n+struct Struct {\n     a: i32,\n     b: i32,\n     c: i32,\n@@ -356,6 +380,20 @@ declare_tests! {\n             Token::I32(1),\n         ],\n     }\n+    test_result {\n+        Ok::<i32, i32>(0) => vec![\n+            Token::EnumSeqStart(\"Result\", \"Ok\", Some(1)),\n+            Token::SeqSep,\n+            Token::I32(0),\n+            Token::SeqEnd,\n+        ],\n+        Err::<i32, i32>(1) => vec![\n+            Token::EnumSeqStart(\"Result\", \"Err\", Some(1)),\n+            Token::SeqSep,\n+            Token::I32(1),\n+            Token::SeqEnd,\n+        ],\n+    }\n     test_slice {\n         &[0][..0] => vec![\n             Token::SeqStart(Some(0)),\n@@ -480,12 +518,12 @@ declare_tests! {\n             Token::MapEnd,\n         ],\n     }\n-    test_named_unit {\n-        NamedUnit => vec![Token::NamedUnit(\"NamedUnit\")],\n+    test_unit_struct {\n+        UnitStruct => vec![Token::UnitStruct(\"UnitStruct\")],\n     }\n-    test_named_seq {\n-        NamedSeq(1, 2, 3) => vec![\n-            Token::NamedSeqStart(\"NamedSeq\", Some(3)),\n+    test_tuple_struct {\n+        TupleStruct(1, 2, 3) => vec![\n+            Token::TupleStructStart(\"TupleStruct\", Some(3)),\n                 Token::SeqSep,\n                 Token::I32(1),\n \n@@ -497,9 +535,9 @@ declare_tests! {\n             Token::SeqEnd,\n         ],\n     }\n-    test_named_map {\n-        NamedMap { a: 1, b: 2, c: 3 } => vec![\n-            Token::NamedMapStart(\"NamedMap\", Some(3)),\n+    test_struct {\n+        Struct { a: 1, b: 2, c: 3 } => vec![\n+            Token::StructStart(\"Struct\", Some(3)),\n                 Token::MapSep,\n                 Token::Str(\"a\"),\n                 Token::I32(1),\n", "problem_statement": "Incorrect JSON is generated when serializing an empty map with no up-front size provided\nIt'll generate things like `{\"foo\":{}\"bar\":{}}` (note no comma between `{}` and `\"bar\"`), which causes errors in deserialization. Supplying up-front sizes to all maps in the serialization code works around the problem.\n\n", "hints_text": "", "created_at": "2015-07-22T15:55:06Z", "version": "0.4"}, {"repo": "serde-rs/serde", "pull_number": 111, "instance_id": "serde-rs__serde-111", "issue_numbers": ["104"], "base_commit": "447d08bd9121b871ab6d646bdeba66321a948194", "patch": "diff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 5484a7b7c..2f3c6a301 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -571,6 +571,11 @@ pub trait VariantVisitor {\n         Err(Error::syntax_error())\n     }\n \n+    /// `visit_simple` is called when deserializing a variant with a single value.\n+    fn visit_simple<T: Deserialize>(&mut self) -> Result<T, Self::Error> {\n+        Err(Error::syntax_error())\n+    }\n+\n     /// `visit_seq` is called when deserializing a tuple-like variant.\n     fn visit_seq<V>(&mut self, _visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor\n@@ -601,6 +606,10 @@ impl<'a, T> VariantVisitor for &'a mut T where T: VariantVisitor {\n         (**self).visit_unit()\n     }\n \n+    fn visit_simple<D: Deserialize>(&mut self) -> Result<D, T::Error> {\n+        (**self).visit_simple()\n+    }\n+\n     fn visit_seq<V>(&mut self, visitor: V) -> Result<V::Value, T::Error>\n         where V: Visitor,\n     {\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex d816dc35a..4484d344d 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -125,6 +125,14 @@ pub trait Serializer {\n         self.visit_unit()\n     }\n \n+    #[inline]\n+    fn visit_enum_simple<T>(&mut self,\n+                            _name: &str,\n+                            _variant: &str,\n+                            _value: T,\n+                            ) -> Result<(), Self::Error>\n+        where T: Serialize;\n+\n     fn visit_none(&mut self) -> Result<(), Self::Error>;\n \n     fn visit_some<V>(&mut self, value: V) -> Result<(), Self::Error>\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex 3f949df00..90f7d7ff6 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -555,6 +555,12 @@ fn deserialize_variant(\n                 Ok($type_ident::$variant_ident)\n             })\n         }\n+        ast::TupleVariantKind(ref args) if args.len() == 1 => {\n+            quote_expr!(cx, {\n+                let val = try!(visitor.visit_simple());\n+                Ok($type_ident::$variant_ident(val))\n+            })\n+        }\n         ast::TupleVariantKind(ref args) => {\n             deserialize_tuple_variant(\n                 cx,\ndiff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex 8c74e1199..fb48eb25e 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -296,7 +296,25 @@ fn serialize_variant(\n                     )\n                 }\n             )\n-        }\n+        },\n+        ast::TupleVariantKind(ref args) if args.len() == 1 => {\n+            let field = builder.id(\"__simple_value\");\n+            let field = builder.pat().ref_id(field);\n+            let pat = builder.pat().enum_()\n+                .id(type_ident).id(variant_ident).build()\n+                .with_pats(Some(field).into_iter())\n+                .build();\n+            quote_arm!(cx,\n+                $pat => {\n+                    ::serde::ser::Serializer::visit_enum_simple(\n+                        serializer,\n+                        $type_name,\n+                        $variant_name,\n+                        __simple_value,\n+                    )\n+                }\n+            )\n+        },\n         ast::TupleVariantKind(ref args) => {\n             let fields: Vec<ast::Ident> = (0 .. args.len())\n                 .map(|i| builder.id(format!(\"__field{}\", i)))\ndiff --git a/serde_json/src/de.rs b/serde_json/src/de.rs\nindex 8bb33931d..efdd53df8 100644\n--- a/serde_json/src/de.rs\n+++ b/serde_json/src/de.rs\n@@ -632,20 +632,22 @@ impl<Iter> de::VariantVisitor for Deserializer<Iter>\n     fn visit_variant<V>(&mut self) -> Result<V, Error>\n         where V: de::Deserialize\n     {\n-        de::Deserialize::deserialize(self)\n+        let val = try!(de::Deserialize::deserialize(self));\n+        try!(self.parse_object_colon());\n+        Ok(val)\n     }\n \n     fn visit_unit(&mut self) -> Result<(), Error> {\n-        try!(self.parse_object_colon());\n+        de::Deserialize::deserialize(self)\n+    }\n \n+    fn visit_simple<T: de::Deserialize>(&mut self) -> Result<T, Error> {\n         de::Deserialize::deserialize(self)\n     }\n \n     fn visit_seq<V>(&mut self, visitor: V) -> Result<V::Value, Error>\n         where V: de::Visitor,\n     {\n-        try!(self.parse_object_colon());\n-\n         de::Deserializer::visit(self, visitor)\n     }\n \n@@ -654,8 +656,6 @@ impl<Iter> de::VariantVisitor for Deserializer<Iter>\n                     visitor: V) -> Result<V::Value, Error>\n         where V: de::Visitor,\n     {\n-        try!(self.parse_object_colon());\n-\n         de::Deserializer::visit(self, visitor)\n     }\n }\ndiff --git a/serde_json/src/lib.rs b/serde_json/src/lib.rs\nindex 2e13f2a42..3032db9c2 100644\n--- a/serde_json/src/lib.rs\n+++ b/serde_json/src/lib.rs\n@@ -61,12 +61,12 @@\n //! //#![feature(custom_derive, plugin)]\n //! //#![plugin(serde_macros)]\n //!\n-//! extern crate serde;\n+//! extern crate serde_json;\n //!\n-//! use serde_json::{self, Value};\n+//! use serde_json::Value;\n //!\n //! fn main() {\n-//!     let data: Value = json::from_str(\"{\\\"foo\\\": 13, \\\"bar\\\": \\\"baz\\\"}\").unwrap();\n+//!     let data: Value = serde_json::from_str(\"{\\\"foo\\\": 13, \\\"bar\\\": \\\"baz\\\"}\").unwrap();\n //!     println!(\"data: {:?}\", data);\n //!     // data: {\"bar\":\"baz\",\"foo\":13}\n //!     println!(\"object? {}\", data.is_object());\ndiff --git a/serde_json/src/ser.rs b/serde_json/src/ser.rs\nindex 294a7f494..b7f5b2d81 100644\n--- a/serde_json/src/ser.rs\n+++ b/serde_json/src/ser.rs\n@@ -171,6 +171,22 @@ impl<W, F> ser::Serializer for Serializer<W, F>\n         self.formatter.close(&mut self.writer, b'}')\n     }\n \n+    #[inline]\n+    fn visit_enum_simple<T>(&mut self,\n+                            _name: &str,\n+                            variant: &str,\n+                            value: T,\n+                            ) -> io::Result<()>\n+        where T: ser::Serialize,\n+    {\n+        try!(self.formatter.open(&mut self.writer, b'{'));\n+        try!(self.formatter.comma(&mut self.writer, true));\n+        try!(self.visit_str(variant));\n+        try!(self.formatter.colon(&mut self.writer));\n+        try!(value.serialize(self));\n+        self.formatter.close(&mut self.writer, b'}')\n+    }\n+\n     #[inline]\n     fn visit_seq<V>(&mut self, mut visitor: V) -> io::Result<()>\n         where V: ser::SeqVisitor,\ndiff --git a/serde_json/src/value.rs b/serde_json/src/value.rs\nindex 45cb77855..f01dfe1d6 100644\n--- a/serde_json/src/value.rs\n+++ b/serde_json/src/value.rs\n@@ -471,6 +471,22 @@ impl ser::Serializer for Serializer {\n         Ok(())\n     }\n \n+    #[inline]\n+    fn visit_enum_simple<T>(&mut self,\n+                            _name: &str,\n+                            variant: &str,\n+                            value: T,\n+                            ) -> Result<(), ()>\n+        where T: ser::Serialize,\n+    {\n+        let mut values = BTreeMap::new();\n+        values.insert(variant.to_string(), to_value(&value));\n+\n+        self.state.push(State::Value(Value::Object(values)));\n+\n+        Ok(())\n+    }\n+\n     #[inline]\n     fn visit_seq<V>(&mut self, mut visitor: V) -> Result<(), ()>\n         where V: ser::SeqVisitor,\n@@ -687,33 +703,19 @@ impl de::Deserializer for Deserializer {\n \n         let mut iter = value.into_iter();\n \n-        let value = match iter.next() {\n-            Some((variant, Value::Array(fields))) => {\n-                self.value = Some(Value::String(variant));\n-\n-                let len = fields.len();\n-                try!(visitor.visit(SeqDeserializer {\n-                    de: self,\n-                    iter: fields.into_iter(),\n-                    len: len,\n-                }))\n-            }\n-            Some((variant, Value::Object(fields))) => {\n-                let len = fields.len();\n-                try!(visitor.visit(MapDeserializer {\n-                    de: self,\n-                    iter: fields.into_iter(),\n-                    value: Some(Value::String(variant)),\n-                    len: len,\n-                }))\n-            }\n-            Some(_) => { return Err(de::Error::syntax_error()); }\n-            None => { return Err(de::Error::syntax_error()); }\n+        let (variant, value) = match iter.next() {\n+            Some(v) => v,\n+            None => return Err(de::Error::syntax_error()),\n         };\n \n+        // enums are encoded in json as maps with a single key:value pair\n         match iter.next() {\n             Some(_) => Err(de::Error::syntax_error()),\n-            None => Ok(value)\n+            None => visitor.visit(VariantDeserializer {\n+                de: self,\n+                val: Some(value),\n+                variant: Some(Value::String(variant)),\n+            }),\n         }\n     }\n \n@@ -723,6 +725,67 @@ impl de::Deserializer for Deserializer {\n     }\n }\n \n+struct VariantDeserializer<'a> {\n+    de: &'a mut Deserializer,\n+    val: Option<Value>,\n+    variant: Option<Value>,\n+}\n+\n+impl<'a> de::VariantVisitor for VariantDeserializer<'a> {\n+    type Error = Error;\n+\n+    fn visit_variant<V>(&mut self) -> Result<V, Error>\n+        where V: de::Deserialize,\n+    {\n+        de::Deserialize::deserialize(&mut Deserializer::new(self.variant.take().unwrap()))\n+    }\n+\n+    fn visit_unit(&mut self) -> Result<(), Error>\n+    {\n+        de::Deserialize::deserialize(&mut Deserializer::new(self.val.take().unwrap()))\n+    }\n+\n+    fn visit_simple<D: de::Deserialize>(&mut self) -> Result<D, Error>\n+    {\n+        de::Deserialize::deserialize(&mut Deserializer::new(self.val.take().unwrap()))\n+    }\n+\n+    fn visit_seq<V>(&mut self, visitor: V) -> Result<V::Value, Error>\n+        where V: de::Visitor,\n+    {\n+        if let Value::Array(fields) = self.val.take().unwrap() {\n+            de::Deserializer::visit(\n+                &mut SeqDeserializer {\n+                    de: self.de,\n+                    len: fields.len(),\n+                    iter: fields.into_iter(),\n+                },\n+                visitor,\n+            )\n+        } else {\n+            Err(de::Error::syntax_error())\n+        }\n+    }\n+\n+    fn visit_map<V>(&mut self, _fields: &'static[&'static str], visitor: V) -> Result<V::Value, Error>\n+        where V: de::Visitor,\n+    {\n+        if let Value::Object(fields) = self.val.take().unwrap() {\n+            de::Deserializer::visit(\n+                &mut MapDeserializer {\n+                    de: self.de,\n+                    len: fields.len(),\n+                    iter: fields.into_iter(),\n+                    value: None,\n+                },\n+                visitor,\n+            )\n+        } else {\n+            Err(de::Error::syntax_error())\n+        }\n+    }\n+}\n+\n struct SeqDeserializer<'a> {\n     de: &'a mut Deserializer,\n     iter: vec::IntoIter<Value>,\n@@ -773,35 +836,6 @@ impl<'a> de::SeqVisitor for SeqDeserializer<'a> {\n     }\n }\n \n-impl<'a> de::VariantVisitor for SeqDeserializer<'a> {\n-    type Error = Error;\n-\n-    fn visit_variant<V>(&mut self) -> Result<V, Error>\n-        where V: de::Deserialize,\n-    {\n-        de::Deserialize::deserialize(self.de)\n-    }\n-\n-    fn visit_unit(&mut self) -> Result<(), Error>\n-    {\n-        de::Deserialize::deserialize(self)\n-    }\n-\n-    fn visit_seq<V>(&mut self, visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n-    {\n-        de::Deserializer::visit(self, visitor)\n-    }\n-\n-    fn visit_map<V>(&mut self,\n-                    _fields: &'static [&'static str],\n-                    visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n-    {\n-        de::Deserializer::visit(self, visitor)\n-    }\n-}\n-\n struct MapDeserializer<'a> {\n     de: &'a mut Deserializer,\n     iter: btree_map::IntoIter<String, Value>,\n@@ -884,35 +918,6 @@ impl<'a> de::Deserializer for MapDeserializer<'a> {\n     }\n }\n \n-impl<'a> de::VariantVisitor for MapDeserializer<'a> {\n-    type Error = Error;\n-\n-    fn visit_variant<V>(&mut self) -> Result<V, Error>\n-        where V: de::Deserialize,\n-    {\n-        self.de.value = self.value.take();\n-        de::Deserialize::deserialize(self.de)\n-    }\n-\n-    fn visit_unit(&mut self) -> Result<(), Error> {\n-        de::Deserialize::deserialize(self)\n-    }\n-\n-    fn visit_seq<V>(&mut self, visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n-    {\n-        de::Deserializer::visit(self, visitor)\n-    }\n-\n-    fn visit_map<V>(&mut self,\n-                    _fields: &'static [&'static str],\n-                    visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n-    {\n-        de::Deserializer::visit(self, visitor)\n-    }\n-}\n-\n /// Shortcut function to encode a `T` into a JSON `Value`\n pub fn to_value<T>(value: &T) -> Value\n     where T: ser::Serialize\n", "test_patch": "diff --git a/serde_tests/tests/test_bytes.rs b/serde_tests/tests/test_bytes.rs\nindex 3ca97285a..65c466a38 100644\n--- a/serde_tests/tests/test_bytes.rs\n+++ b/serde_tests/tests/test_bytes.rs\n@@ -39,6 +39,15 @@ impl serde::Serializer for BytesSerializer {\n         Err(Error)\n     }\n \n+    fn visit_enum_simple<T>(&mut self,\n+                            _name: &str,\n+                            _variant: &str,\n+                            _value: T,\n+                            ) -> Result<(), Error>\n+    {\n+        Err(Error)\n+    }\n+\n     fn visit_bool(&mut self, _v: bool) -> Result<(), Error> {\n         Err(Error)\n     }\ndiff --git a/serde_tests/tests/test_json.rs b/serde_tests/tests/test_json.rs\nindex 931527e97..14345a289 100644\n--- a/serde_tests/tests/test_json.rs\n+++ b/serde_tests/tests/test_json.rs\n@@ -28,7 +28,7 @@ enum Animal {\n     Dog,\n     Frog(String, Vec<isize>),\n     Cat { age: usize, name: String },\n-\n+    AntHive(Vec<String>),\n }\n \n #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]\n@@ -534,6 +534,10 @@ fn test_write_enum() {\n             Animal::Cat { age: 5, name: \"Kate\".to_string() },\n             \"{\\\"Cat\\\":{\\\"age\\\":5,\\\"name\\\":\\\"Kate\\\"}}\"\n         ),\n+        (\n+            Animal::AntHive(vec![\"Bob\".to_string(), \"Stuart\".to_string()]),\n+            \"{\\\"AntHive\\\":[\\\"Bob\\\",\\\"Stuart\\\"]}\",\n+        ),\n     ]);\n \n     test_pretty_encode_ok(&[\n@@ -976,6 +980,10 @@ fn test_parse_enum() {\n             \" { \\\"Cat\\\" : { \\\"age\\\" : 5 , \\\"name\\\" : \\\"Kate\\\" } } \",\n             Animal::Cat { age: 5, name: \"Kate\".to_string() },\n         ),\n+        (\n+            \" { \\\"AntHive\\\" : [\\\"Bob\\\", \\\"Stuart\\\"] } \",\n+            Animal::AntHive(vec![\"Bob\".to_string(), \"Stuart\".to_string()]),\n+        ),\n     ]);\n \n     test_parse_ok(vec![\ndiff --git a/serde_tests/tests/test_macros.rs b/serde_tests/tests/test_macros.rs\nindex 3c41ca4c7..c36e086ef 100644\n--- a/serde_tests/tests/test_macros.rs\n+++ b/serde_tests/tests/test_macros.rs\n@@ -473,13 +473,13 @@ fn test_lifetimes() {\n     let lifetime = Lifetimes::LifetimeSeq(&value);\n     assert_eq!(\n         serde_json::to_string(&lifetime).unwrap(),\n-        \"{\\\"LifetimeSeq\\\":[5]}\"\n+        \"{\\\"LifetimeSeq\\\":5}\"\n     );\n \n     let lifetime = Lifetimes::NoLifetimeSeq(5);\n     assert_eq!(\n         serde_json::to_string(&lifetime).unwrap(),\n-        \"{\\\"NoLifetimeSeq\\\":[5]}\"\n+        \"{\\\"NoLifetimeSeq\\\":5}\"\n     );\n \n     let value = 5;\n@@ -515,8 +515,8 @@ fn test_generic() {\n     declare_tests!(\n         GenericStruct<u32> : GenericStruct { x: 5 } => \"{\\\"x\\\":5}\",\n         GenericTupleStruct<u32> : GenericTupleStruct(5) => \"[5]\",\n-        GenericEnumSeq<u32, u32> : GenericEnumSeq::Ok(5) => \"{\\\"Ok\\\":[5]}\",\n-        GenericEnumSeq<u32, u32> : GenericEnumSeq::Err(5) => \"{\\\"Err\\\":[5]}\",\n+        GenericEnumSeq<u32, u32> : GenericEnumSeq::Ok(5) => \"{\\\"Ok\\\":5}\",\n+        GenericEnumSeq<u32, u32> : GenericEnumSeq::Err(5) => \"{\\\"Err\\\":5}\",\n         GenericEnumMap<u32, u32> : GenericEnumMap::Ok { x: 5 } => \"{\\\"Ok\\\":{\\\"x\\\":5}}\",\n         GenericEnumMap<u32, u32> : GenericEnumMap::Err { x: 5 } => \"{\\\"Err\\\":{\\\"x\\\":5}}\",\n     );\ndiff --git a/serde_tests/tests/test_ser.rs b/serde_tests/tests/test_ser.rs\nindex 950b5b828..62627fba1 100644\n--- a/serde_tests/tests/test_ser.rs\n+++ b/serde_tests/tests/test_ser.rs\n@@ -27,6 +27,8 @@ pub enum Token<'a> {\n     UnitStruct(&'a str),\n     EnumUnit(&'a str, &'a str),\n \n+    EnumSimple(&'a str, &'a str),\n+\n     SeqStart(Option<usize>),\n     TupleStructStart(&'a str, Option<usize>),\n     EnumSeqStart(&'a str, &'a str, Option<usize>),\n@@ -80,6 +82,17 @@ impl<'a> Serializer for AssertSerializer<'a> {\n         Ok(())\n     }\n \n+    fn visit_enum_simple<T>(&mut self,\n+                            name: &str,\n+                            variant: &str,\n+                            value: T,\n+                            ) -> Result<(), ()>\n+        where T: Serialize,\n+    {\n+        assert_eq!(self.iter.next(), Some(Token::EnumSimple(name, variant)));\n+        value.serialize(self)\n+    }\n+\n     fn visit_unit_struct(&mut self, name: &str) -> Result<(), ()> {\n         assert_eq!(self.iter.next().unwrap(), Token::UnitStruct(name));\n         Ok(())\n@@ -301,6 +314,7 @@ struct Struct {\n #[derive(Serialize)]\n enum Enum {\n     Unit,\n+    One(i32),\n     Seq(i32, i32),\n     Map { a: i32, b: i32 },\n }\n@@ -554,6 +568,7 @@ declare_tests! {\n     }\n     test_enum {\n         Enum::Unit => vec![Token::EnumUnit(\"Enum\", \"Unit\")],\n+        Enum::One(42) => vec![Token::EnumSimple(\"Enum\", \"One\"), Token::I32(42)],\n         Enum::Seq(1, 2) => vec![\n             Token::EnumSeqStart(\"Enum\", \"Seq\", Some(2)),\n                 Token::SeqSep,\n", "problem_statement": "Enum-Tuple-Variant with single element should not be a sequence\n``` rust\n#[Deserialize]\nenum A {\n    B(i32),\n    C(Vec<i32>),\n}\n```\n\nThe json for this requires additional square brackets for another array layer.\n\n``` json\n{\"C\":[[5, 6, 7]]}\n\nor\n\n{\"B\":[42]}\n```\n\nUnit variants are already handles specially. I propose to also handle single element variants specially, so the following would be legal:\n\n``` json\n{\"C\":[5, 6, 7]}\n\nor\n\n{\"B\":42}\n```\n\nAnyone that wishes to have the previous behavior, could use an explicit tuple.\n\n``` rust\n#[Deserialize]\nenum A {\n    B((i32,)),\n    C((Vec<i32>,)),\n}\n```\n\nAlternatively deserialization might accept both, but that might be more of a mess than it's worth\n\n", "hints_text": "The use-case is the pandoc ast\n\nhttp://hackage.haskell.org/package/pandoc-types-1.12.4.4/docs/Text-Pandoc-Definition.html\n\nThat is interesting, because \"normal\" single element variants serialize directly as their inner type.\n\nO_o, i need to investigate further then... maybe a newtype might come to my rescue\n\nMy claim isn't true, it was in a faulty version I wrote some time ago. Sorry for the rush.\n", "created_at": "2015-07-17T13:23:12Z", "version": "0.5"}, {"repo": "serde-rs/serde", "pull_number": 80, "instance_id": "serde-rs__serde-80", "issue_numbers": ["77"], "base_commit": "81d617bd936b15a24db7d800bb92d6d0bafc9ed6", "patch": "diff --git a/serde/src/json/de.rs b/serde/src/json/de.rs\nindex 1d0bc8d94..a5ec279bb 100644\n--- a/serde/src/json/de.rs\n+++ b/serde/src/json/de.rs\n@@ -249,7 +249,7 @@ impl<Iter> Deserializer<Iter>\n     fn parse_exponent(&mut self, mut res: f64) -> Result<f64, Error> {\n         try!(self.bump());\n \n-        let mut exp = 0;\n+        let mut exp: u64 = 0;\n         let mut neg_exp = false;\n \n         if self.ch_is(b'+') {\n@@ -267,8 +267,16 @@ impl<Iter> Deserializer<Iter>\n         while !self.eof() {\n             match self.ch_or_null() {\n                 c @ b'0' ... b'9' => {\n-                    exp *= 10;\n-                    exp += (c as i32) - (b'0' as i32);\n+                    macro_rules! try_or_invalid {\n+                        ($e: expr) => {\n+                            match $e {\n+                                Some(v) => v,\n+                                None => { return Err(self.error(ErrorCode::InvalidNumber)); }\n+                            }\n+                        }\n+                    }\n+                    exp = try_or_invalid!(exp.checked_mul(10));\n+                    exp = try_or_invalid!(exp.checked_add((c as u64) - (b'0' as u64)));\n \n                     try!(self.bump());\n                 }\n@@ -276,7 +284,7 @@ impl<Iter> Deserializer<Iter>\n             }\n         }\n \n-        let exp: f64 = 10_f64.powi(exp);\n+        let exp: f64 = 10_f64.powf(exp as f64);\n         if neg_exp {\n             res /= exp;\n         } else {\n", "test_patch": "diff --git a/serde_tests/tests/test_json.rs b/serde_tests/tests/test_json.rs\nindex 58f118dac..c29f82865 100644\n--- a/serde_tests/tests/test_json.rs\n+++ b/serde_tests/tests/test_json.rs\n@@ -703,6 +703,7 @@ fn test_parse_number_errors() {\n         (\"1e+\", Error::SyntaxError(ErrorCode::InvalidNumber, 1, 3)),\n         (\"1a\", Error::SyntaxError(ErrorCode::TrailingCharacters, 1, 2)),\n         (\"777777777777777777777777777\", Error::SyntaxError(ErrorCode::InvalidNumber, 1, 20)),\n+        (\"1e777777777777777777777777777\", Error::SyntaxError(ErrorCode::InvalidNumber, 1, 22)),\n     ]);\n }\n \n", "problem_statement": "Integer overflow when parsing JSON scientific notation number\nThis is a different issue from #75\n### Code\n\n``` rust\n#![feature(plugin)]\n#![plugin(afl_coverage_plugin)]\n\nextern crate afl_coverage;\n\nextern crate serde;\n\nuse std::io::{self, Read, Cursor};\n\nuse serde::json::{self, Value};\n\n\nfn main() {\n    let mut input = String::new();\n    let result = io::stdin().read_to_string(&mut input);\n    if result.is_ok() {\n        if let Ok(j) = json::from_str::<json::Value>(&input) {\n            let _ = json::to_string(&j);\n        }\n    }\n}\n```\n### Input\n\n```\n[7E-7777777777]\n```\n### Crash\n\n```\nroot@vultr:~/afl-staging-area2# cargo run < outputs/crashes/id\\:000008*\n     Running `target/debug/afl-staging-area2`\nthread '<main>' panicked at 'arithmetic operation overflowed', /root/serde/serde/src/json/de.rs:270\nAn unknown error occurred\n\nTo learn more, run the command again with --verbose.\n```\n\nThis bug was found using https://github.com/kmcallister/afl.rs \ud83d\udc4d\n\n", "hints_text": "", "created_at": "2015-05-20T14:35:12Z", "version": "0.4"}, {"repo": "serde-rs/serde", "pull_number": 64, "instance_id": "serde-rs__serde-64", "issue_numbers": ["63"], "base_commit": "ed1b476a22aed23674e81b326a706eac64178de0", "patch": "diff --git a/serde_macros/src/de.rs b/serde_macros/src/de.rs\nindex a47ad0abc..14716bf0f 100644\n--- a/serde_macros/src/de.rs\n+++ b/serde_macros/src/de.rs\n@@ -639,9 +639,11 @@ fn deserialize_map(\n     let extract_values: Vec<P<ast::Stmt>> = field_names.iter()\n         .zip(struct_def.fields.iter())\n         .map(|(field_name, field)| {\n-            let name_str = match field.node.kind {\n-                ast::NamedField(name, _) => builder.expr().str(name),\n-                ast::UnnamedField(_) => panic!(\"struct contains unnamed fields\"),\n+            let rename = field::field_rename(field, &field::Direction::Deserialize);\n+            let name_str = match (rename, field.node.kind) {\n+                (Some(rename), _) => builder.expr().build_lit(P(rename.clone())),\n+                (None, ast::NamedField(name, _)) => builder.expr().str(name),\n+                (None, ast::UnnamedField(_)) => panic!(\"struct contains unnamed fields\"),\n             };\n \n             let missing_expr = if field::default_value(field) {\ndiff --git a/serde_macros/src/field.rs b/serde_macros/src/field.rs\nindex baa79009f..c35e694ba 100644\n--- a/serde_macros/src/field.rs\n+++ b/serde_macros/src/field.rs\n@@ -10,7 +10,7 @@ pub enum Direction {\n     Deserialize,\n }\n \n-fn field_rename<'a>(\n+pub fn field_rename<'a>(\n     field: &'a ast::StructField,\n     direction: &Direction,\n ) -> Option<&'a ast::Lit> {\n", "test_patch": "diff --git a/tests/test_json.rs b/tests/test_json.rs\nindex 2135f0c5d..ba45d9747 100644\n--- a/tests/test_json.rs\n+++ b/tests/test_json.rs\n@@ -1,4 +1,4 @@\n-#![feature(custom_derive, plugin, test)]\n+#![feature(custom_derive, plugin, test, custom_attribute)]\n #![plugin(serde_macros)]\n \n extern crate test;\n@@ -1019,3 +1019,26 @@ fn test_missing_field() {\n     ))).unwrap();\n     assert_eq!(value, Foo { x: Some(5) });\n }\n+\n+#[test]\n+fn test_missing_renamed_field() {\n+    #[derive(Debug, PartialEq, Deserialize)]\n+    struct Foo {\n+        #[serde(rename_deserialize=\"y\")]\n+        x: Option<u32>,\n+    }\n+\n+    let value: Foo = from_str(\"{}\").unwrap();\n+    assert_eq!(value, Foo { x: None });\n+\n+    let value: Foo = from_str(\"{\\\"y\\\": 5}\").unwrap();\n+    assert_eq!(value, Foo { x: Some(5) });\n+\n+    let value: Foo = from_value(Value::Object(treemap!())).unwrap();\n+    assert_eq!(value, Foo { x: None });\n+\n+    let value: Foo = from_value(Value::Object(treemap!(\n+        \"y\".to_string() => Value::I64(5)\n+    ))).unwrap();\n+    assert_eq!(value, Foo { x: Some(5) });\n+}\n", "problem_statement": "MapVisitor::missing_field gets the original field name, not the renamed name\nDeserializing the following struct calls `missing_field` with `field==\"myval\"` instead of `field==\"blubber\"`\n\n``` rust\nstruct Test {\n    #[serde(rename=\"blubber\")]\n    myval: String,\n}\n```\n\n", "hints_text": "", "created_at": "2015-04-23T14:44:58Z"}, {"repo": "serde-rs/serde", "pull_number": 905, "instance_id": "serde-rs__serde-905", "issue_numbers": ["816"], "base_commit": "c96efcb87ab72f14a2a084644308c4a5e98ed820", "patch": "diff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex 270e1df8a..45b383fb0 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -16,6 +16,7 @@ use de::Unexpected;\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n pub use self::content::{Content, ContentRefDeserializer, ContentDeserializer,\n                         TaggedContentVisitor, TagOrContentField, TagOrContentFieldVisitor,\n+                        TagContentOtherField, TagContentOtherFieldVisitor,\n                         InternallyTaggedUnitVisitor, UntaggedUnitVisitor};\n \n /// If the missing field is of type `Option<T>` then treat is as `None`,\n@@ -863,6 +864,54 @@ mod content {\n         }\n     }\n \n+    /// Used by generated code to deserialize an adjacently tagged enum when\n+    /// ignoring unrelated fields is allowed.\n+    ///\n+    /// Not public API.\n+    pub enum TagContentOtherField {\n+        Tag,\n+        Content,\n+        Other,\n+    }\n+\n+    /// Not public API.\n+    pub struct TagContentOtherFieldVisitor {\n+        pub tag: &'static str,\n+        pub content: &'static str,\n+    }\n+\n+    impl<'de> DeserializeSeed<'de> for TagContentOtherFieldVisitor {\n+        type Value = TagContentOtherField;\n+\n+        fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n+        where\n+            D: Deserializer<'de>,\n+        {\n+            deserializer.deserialize_str(self)\n+        }\n+    }\n+\n+    impl<'de> Visitor<'de> for TagContentOtherFieldVisitor {\n+        type Value = TagContentOtherField;\n+\n+        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+            write!(formatter, \"{:?}, {:?}, or other ignored fields\", self.tag, self.content)\n+        }\n+\n+        fn visit_str<E>(self, field: &str) -> Result<Self::Value, E>\n+        where\n+            E: de::Error,\n+        {\n+            if field == self.tag {\n+                Ok(TagContentOtherField::Tag)\n+            } else if field == self.content {\n+                Ok(TagContentOtherField::Content)\n+            } else {\n+                Ok(TagContentOtherField::Other)\n+            }\n+        }\n+    }\n+\n     /// Not public API\n     pub struct ContentDeserializer<E> {\n         content: Content,\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 9827dbbe9..6f294f01e 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -795,9 +795,19 @@ fn deserialize_adjacently_tagged_enum(\n \n     let expecting = format!(\"adjacently tagged enum {}\", params.type_name());\n     let type_name = cattrs.name().deserialize_name();\n+    let deny_unknown_fields = cattrs.deny_unknown_fields();\n+\n+    /// If unknown fields are allowed, we pick the visitor that can\n+    /// step over those. Otherwise we pick the visitor that fails on\n+    /// unknown keys.\n+    let field_visitor_ty = if deny_unknown_fields {\n+        quote! { _serde::private::de::TagOrContentFieldVisitor }\n+    } else {\n+        quote! { _serde::private::de::TagContentOtherFieldVisitor }\n+    };\n \n     let tag_or_content = quote! {\n-        _serde::private::de::TagOrContentFieldVisitor {\n+        #field_visitor_ty {\n             tag: #tag,\n             content: #content,\n         }\n@@ -844,9 +854,46 @@ fn deserialize_adjacently_tagged_enum(\n         };\n     }\n \n-    let visit_third_key = quote! {\n-        // Visit the third key in the map, hopefully there isn't one.\n-        match try!(_serde::de::MapAccess::next_key_seed(&mut __map, #tag_or_content)) {\n+    /// Advance the map by one key, returning early in case of error.\n+    let next_key = quote! {\n+        try!(_serde::de::MapAccess::next_key_seed(&mut __map, #tag_or_content))\n+    };\n+\n+    /// When allowing unknown fields, we want to transparently step through keys we don't care\n+    /// about until we find `tag`, `content`, or run out of keys.\n+    let next_relevant_key = if deny_unknown_fields {\n+        next_key\n+    } else {\n+        quote! {\n+            {\n+                let mut __rk : _serde::export::Option<_serde::private::de::TagOrContentField> = _serde::export::None;\n+                while let _serde::export::Some(__k) = #next_key {\n+                    match __k {\n+                        _serde::private::de::TagContentOtherField::Other => {\n+                            try!(_serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map));\n+                            continue;\n+                        },\n+                        _serde::private::de::TagContentOtherField::Tag => {\n+                            __rk = _serde::export::Some(_serde::private::de::TagOrContentField::Tag);\n+                            break;\n+                        }\n+                        _serde::private::de::TagContentOtherField::Content => {\n+                            __rk = _serde::export::Some(_serde::private::de::TagOrContentField::Content);\n+                            break;\n+                        }\n+                    }\n+                }\n+\n+                __rk\n+            }\n+        }\n+    };\n+\n+    /// Step through remaining keys, looking for duplicates of previously-seen keys.\n+    /// When unknown fields are denied, any key that isn't a duplicate will at this\n+    /// point immediately produce an error.\n+    let visit_remaining_keys = quote! {\n+        match #next_relevant_key {\n             _serde::export::Some(_serde::private::de::TagOrContentField::Tag) => {\n                 _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#tag))\n             }\n@@ -857,6 +904,8 @@ fn deserialize_adjacently_tagged_enum(\n         }\n     };\n \n+    \n+\n     quote_block! {\n         #variant_visitor\n \n@@ -895,14 +944,14 @@ fn deserialize_adjacently_tagged_enum(\n             fn visit_map<__A>(self, mut __map: __A) -> _serde::export::Result<Self::Value, __A::Error>\n                 where __A: _serde::de::MapAccess<'de>\n             {\n-                // Visit the first key.\n-                match try!(_serde::de::MapAccess::next_key_seed(&mut __map, #tag_or_content)) {\n+                // Visit the first relevant key.\n+                match #next_relevant_key {\n                     // First key is the tag.\n                     _serde::export::Some(_serde::private::de::TagOrContentField::Tag) => {\n                         // Parse the tag.\n                         let __field = try!(_serde::de::MapAccess::next_value(&mut __map));\n                         // Visit the second key.\n-                        match try!(_serde::de::MapAccess::next_key_seed(&mut __map, #tag_or_content)) {\n+                        match #next_relevant_key {\n                             // Second key is a duplicate of the tag.\n                             _serde::export::Some(_serde::private::de::TagOrContentField::Tag) => {\n                                 _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#tag))\n@@ -915,8 +964,8 @@ fn deserialize_adjacently_tagged_enum(\n                                         marker: _serde::export::PhantomData,\n                                         lifetime: _serde::export::PhantomData,\n                                     }));\n-                                // Visit the third key, hopefully there isn't one.\n-                                #visit_third_key\n+                                // Visit remaining keys, looking for duplicates.\n+                                #visit_remaining_keys\n                             }\n                             // There is no second key; might be okay if the we have a unit variant.\n                             _serde::export::None => #missing_content\n@@ -927,7 +976,7 @@ fn deserialize_adjacently_tagged_enum(\n                         // Buffer up the content.\n                         let __content = try!(_serde::de::MapAccess::next_value::<_serde::private::de::Content>(&mut __map));\n                         // Visit the second key.\n-                        match try!(_serde::de::MapAccess::next_key_seed(&mut __map, #tag_or_content)) {\n+                        match #next_relevant_key {\n                             // Second key is the tag.\n                             _serde::export::Some(_serde::private::de::TagOrContentField::Tag) => {\n                                 let __deserializer = _serde::private::de::ContentDeserializer::<__A::Error>::new(__content);\n@@ -936,8 +985,8 @@ fn deserialize_adjacently_tagged_enum(\n                                     // Deserialize the buffered content now that we know the variant.\n                                     #(#variant_arms)*\n                                 });\n-                                // Visit the third key, hopefully there isn't one.\n-                                #visit_third_key\n+                                // Visit remaining keys, looking for duplicates.\n+                                #visit_remaining_keys\n                             }\n                             // Second key is a duplicate of the content.\n                             _serde::export::Some(_serde::private::de::TagOrContentField::Content) => {\n", "test_patch": "diff --git a/test_suite/tests/test_macros.rs b/test_suite/tests/test_macros.rs\nindex d4144ab3d..6c7e4b2ab 100644\n--- a/test_suite/tests/test_macros.rs\n+++ b/test_suite/tests/test_macros.rs\n@@ -751,6 +751,31 @@ fn test_adjacently_tagged_enum() {\n         ],\n     );\n \n+    // unit with excess content (f, g, h)\n+    assert_de_tokens(\n+        &AdjacentlyTagged::Unit::<u8>,\n+        &[\n+            Token::Struct { name: \"AdjacentlyTagged\", len: 3 },\n+\n+            Token::Str(\"f\"),\n+            Token::Unit,\n+\n+            Token::Str(\"t\"),\n+            Token::Str(\"Unit\"),\n+\n+            Token::Str(\"g\"),\n+            Token::Unit,\n+\n+            Token::Str(\"c\"),\n+            Token::Unit,\n+\n+            Token::Str(\"h\"),\n+            Token::Unit,\n+\n+            Token::StructEnd,\n+        ],\n+    );\n+\n     // newtype with tag first\n     assert_tokens(\n         &AdjacentlyTagged::Newtype::<u8>(1),\n@@ -860,6 +885,66 @@ fn test_adjacently_tagged_enum() {\n     );\n }\n \n+#[test]\n+fn test_adjacently_tagged_enum_deny_unknown_fields() {\n+    #[derive(Debug, PartialEq, Deserialize)]\n+    #[serde(tag = \"t\", content = \"c\", deny_unknown_fields)]\n+    enum AdjacentlyTagged {\n+        Unit,\n+    }\n+\n+    assert_de_tokens(\n+        &AdjacentlyTagged::Unit,\n+        &[\n+            Token::Struct { name: \"AdjacentlyTagged\", len: 2},\n+\n+            Token::Str(\"t\"),\n+            Token::Str(\"Unit\"),\n+\n+            Token::Str(\"c\"),\n+            Token::Unit,\n+\n+            Token::StructEnd,\n+        ],\n+    );\n+\n+    assert_de_tokens_error::<AdjacentlyTagged>(\n+        &[\n+            Token::Struct { name: \"AdjacentlyTagged\", len: 3},\n+\n+            Token::Str(\"t\"),\n+            Token::Str(\"Unit\"),\n+\n+            Token::Str(\"c\"),\n+            Token::Unit,\n+\n+            Token::Str(\"h\"),\n+        ],\n+        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#\n+    );\n+\n+    assert_de_tokens_error::<AdjacentlyTagged>(\n+        &[\n+            Token::Struct { name: \"AdjacentlyTagged\", len: 3},\n+\n+            Token::Str(\"h\"),\n+        ],\n+        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#\n+    );\n+\n+    assert_de_tokens_error::<AdjacentlyTagged>(\n+        &[\n+            Token::Struct { name: \"AdjacentlyTagged\", len: 3},\n+\n+            Token::Str(\"c\"),\n+            Token::Unit,\n+\n+            Token::Str(\"h\"),\n+        ],\n+        r#\"invalid value: string \"h\", expected \"t\" or \"c\"\"#\n+    );\n+}\n+\n #[test]\n fn test_enum_in_internally_tagged_enum() {\n     #[derive(Debug, PartialEq, Serialize, Deserialize)]\n", "problem_statement": "Tag/Content attributes should silently ignore unkown attributes\nCurrently if I use `#[serde(tag, content)]` on a tagged enum, it seems that serde would throw error when the JSON string contains attributes other than the tag and the content. I think silently ignore the unknown field could be better?\n", "hints_text": "Really we should respect deny_unknown_fields.\r\n\r\n```rust\r\n// as you said\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(tag = \"t\", content = \"c\")]\r\nenum E { /* ... */ }\r\n\r\n// current behavior\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(tag = \"t\", content = \"c\", deny_unknown_fields)]\r\nenum F { /* ... */ }\r\n```\r\n\r\nI would welcome a PR if you have time to work on this.\nSeems to have to modify quite a lot of logic to make this working. Currently only Structs are allowed to use `deny_unknown_fields`, as enums are variants, they could not use the field ignore logic when deserializing.\nping @dtolnay \r\nAny ideas?\nThis is not a high priority for me but I have scheduled it as something I intend to address in the next major release if a PR has not been submitted by the time I get to it.\nThanks, I'll wait", "created_at": "2017-04-27T18:25:41Z", "version": "1.0"}, {"repo": "serde-rs/serde", "pull_number": 884, "instance_id": "serde-rs__serde-884", "issue_numbers": ["883"], "base_commit": "739ad64c7cc79afc9acbe81f745671d9bfd0ff47", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 6e4c65021..d7e6b7f83 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -634,7 +634,7 @@ impl<'de, T> Deserialize<'de> for [T; 0] {\n     where\n         D: Deserializer<'de>,\n     {\n-        deserializer.deserialize_seq_fixed_size(0, ArrayVisitor::<[T; 0]>::new())\n+        deserializer.deserialize_tuple(0, ArrayVisitor::<[T; 0]>::new())\n     }\n }\n \n@@ -675,7 +675,7 @@ macro_rules! array_impls {\n                 where\n                     D: Deserializer<'de>,\n                 {\n-                    deserializer.deserialize_seq_fixed_size($len, ArrayVisitor::<[T; $len]>::new())\n+                    deserializer.deserialize_tuple($len, ArrayVisitor::<[T; $len]>::new())\n                 }\n             }\n         )+\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 245aa6ea0..3c9afa6f9 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -704,7 +704,7 @@ where\n /// Serde.\n ///\n /// The role of this trait is to define the deserialization half of the Serde\n-/// data model, which is a way to categorize every Rust data type into one of 28\n+/// data model, which is a way to categorize every Rust data type into one of 27\n /// possible types. Each method of the `Serializer` trait corresponds to one of\n /// the types of the data model.\n ///\n@@ -714,47 +714,54 @@ where\n ///\n /// The types that make up the Serde data model are:\n ///\n-///  - 12 primitive types:\n+///  - **12 primitive types**\n ///    - bool\n ///    - i8, i16, i32, i64\n ///    - u8, u16, u32, u64\n ///    - f32, f64\n ///    - char\n-///  - string\n-///  - byte array - [u8]\n-///  - option\n-///    - either none or some value\n-///  - unit\n-///    - unit is the type of () in Rust\n-///  - unit_struct\n-///    - for example `struct Unit` or `PhantomData<T>`\n-///  - unit_variant\n-///    - the `E::A` and `E::B` in `enum E { A, B }`\n-///  - newtype_struct\n-///    - for example `struct Millimeters(u8)`\n-///  - newtype_variant\n-///    - the `E::N` in `enum E { N(u8) }`\n-///  - seq\n-///    - a variably sized sequence of values, for example `Vec<T>` or\n-///      `HashSet<T>`\n-///  - seq_fixed_size\n-///    - a statically sized sequence of values for which the size will be known\n-///      at deserialization time without looking at the serialized data, for\n-///      example `[u64; 10]`\n-///  - tuple\n-///    - for example `(u8,)` or `(String, u64, Vec<T>)`\n-///  - tuple_struct\n-///    - for example `struct Rgb(u8, u8, u8)`\n-///  - tuple_variant\n-///    - the `E::T` in `enum E { T(u8, u8) }`\n-///  - map\n-///    - for example `BTreeMap<K, V>`\n-///  - struct\n-///    - a key-value pairing in which the keys will be known at deserialization\n-///      time without looking at the serialized data, for example `struct S { r:\n-///      u8, g: u8, b: u8 }`\n-///  - struct_variant\n-///    - the `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`\n+///  - **string**\n+///    - UTF-8 bytes with a length and no null terminator.\n+///    - When serializing, all strings are handled equally. When deserializing,\n+///      there are three flavors of strings: transient, owned, and borrowed.\n+///  - **byte array** - [u8]\n+///    - Similar to strings, during deserialization byte arrays can be transient,\n+///      owned, or borrowed.\n+///  - **option**\n+///    - Either none or some value.\n+///  - **unit**\n+///    - The type of `()` in Rust. It represents an anonymous value containing no\n+///      data.\n+///  - **unit_struct**\n+///    - For example `struct Unit` or `PhantomData<T>`. It represents a named value\n+///      containing no data.\n+///  - **unit_variant**\n+///    - For example the `E::A` and `E::B` in `enum E { A, B }`.\n+///  - **newtype_struct**\n+///    - For example `struct Millimeters(u8)`.\n+///  - **newtype_variant**\n+///    - For example the `E::N` in `enum E { N(u8) }`.\n+///  - **seq**\n+///    - A variably sized heterogeneous sequence of values, for example `Vec<T>` or\n+///      `HashSet<T>`. When serializing, the length may or may not be known before\n+///      iterating through all the data. When deserializing, the length is determined\n+///      by looking at the serialized data.\n+///  - **tuple**\n+///    - A statically sized heterogeneous sequence of values for which the length\n+///      will be known at deserialization time without looking at the serialized\n+///      data, for example `(u8,)` or `(String, u64, Vec<T>)` or `[u64; 10]`.\n+///  - **tuple_struct**\n+///    - A named tuple, for example `struct Rgb(u8, u8, u8)`.\n+///  - **tuple_variant**\n+///    - For example the `E::T` in `enum E { T(u8, u8) }`.\n+///  - **map**\n+///    - A heterogeneous key-value pairing, for example `BTreeMap<K, V>`.\n+///  - **struct**\n+///    - A heterogeneous key-value pairing in which the keys are strings and will be\n+///      known at deserialization time without looking at the serialized data, for\n+///      example `struct S { r: u8, g: u8, b: u8 }`.\n+///  - **struct_variant**\n+///    - For example the `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`.\n ///\n /// The `Deserializer` trait supports two entry point styles which enables\n /// different kinds of deserialization.\n@@ -944,16 +951,6 @@ pub trait Deserializer<'de>: Sized {\n \n     /// Hint that the `Deserialize` type is expecting a sequence of values and\n     /// knows how many values there are without looking at the serialized data.\n-    fn deserialize_seq_fixed_size<V>(\n-        self,\n-        len: usize,\n-        visitor: V,\n-    ) -> Result<V::Value, Self::Error>\n-    where\n-        V: Visitor<'de>;\n-\n-    /// Hint that the `Deserialize` type is expecting a tuple value with a\n-    /// particular number of elements.\n     fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: Visitor<'de>;\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 97c558816..d8b0b434a 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -130,8 +130,8 @@ where\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf unit unit_struct newtype_struct seq seq_fixed_size tuple\n-        tuple_struct map struct enum identifier ignored_any\n+        byte_buf unit unit_struct newtype_struct seq tuple tuple_struct map\n+        struct enum identifier ignored_any\n     }\n \n     fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n@@ -183,8 +183,8 @@ macro_rules! primitive_deserializer {\n \n             forward_to_deserialize_any! {\n                 bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-                byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-                tuple tuple_struct map struct enum identifier ignored_any\n+                byte_buf option unit unit_struct newtype_struct seq tuple\n+                tuple_struct map struct enum identifier ignored_any\n             }\n \n             fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n@@ -240,8 +240,8 @@ where\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-        tuple tuple_struct map struct identifier ignored_any\n+        byte_buf option unit unit_struct newtype_struct seq tuple tuple_struct\n+        map struct identifier ignored_any\n     }\n \n     fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n@@ -333,8 +333,8 @@ where\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-        tuple tuple_struct map struct identifier ignored_any\n+        byte_buf option unit unit_struct newtype_struct seq tuple tuple_struct\n+        map struct identifier ignored_any\n     }\n }\n \n@@ -408,8 +408,8 @@ where\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-        tuple tuple_struct map struct identifier ignored_any\n+        byte_buf option unit unit_struct newtype_struct seq tuple tuple_struct\n+        map struct identifier ignored_any\n     }\n }\n \n@@ -487,8 +487,8 @@ where\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-        tuple tuple_struct map struct identifier ignored_any\n+        byte_buf option unit unit_struct newtype_struct seq tuple tuple_struct\n+        map struct identifier ignored_any\n     }\n }\n \n@@ -573,8 +573,8 @@ where\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-        tuple tuple_struct map struct enum identifier ignored_any\n+        byte_buf option unit unit_struct newtype_struct seq tuple tuple_struct\n+        map struct enum identifier ignored_any\n     }\n }\n \n@@ -687,8 +687,8 @@ where\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-        tuple tuple_struct map struct enum identifier ignored_any\n+        byte_buf option unit unit_struct newtype_struct seq tuple tuple_struct\n+        map struct enum identifier ignored_any\n     }\n }\n \n@@ -791,7 +791,7 @@ where\n         Ok(value)\n     }\n \n-    fn deserialize_seq_fixed_size<V>(\n+    fn deserialize_tuple<V>(\n         self,\n         len: usize,\n         visitor: V,\n@@ -805,8 +805,8 @@ where\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf option unit unit_struct newtype_struct tuple tuple_struct\n-        map struct enum identifier ignored_any\n+        byte_buf option unit unit_struct newtype_struct tuple_struct map struct\n+        enum identifier ignored_any\n     }\n }\n \n@@ -946,8 +946,8 @@ where\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf option unit unit_struct newtype_struct tuple tuple_struct\n-        map struct enum identifier ignored_any\n+        byte_buf option unit unit_struct newtype_struct tuple_struct map struct\n+        enum identifier ignored_any\n     }\n \n     fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n@@ -973,7 +973,7 @@ where\n         }\n     }\n \n-    fn deserialize_seq_fixed_size<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: de::Visitor<'de>,\n     {\n@@ -1093,8 +1093,8 @@ where\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-        tuple tuple_struct map struct enum identifier ignored_any\n+        byte_buf option unit unit_struct newtype_struct seq tuple tuple_struct\n+        map struct enum identifier ignored_any\n     }\n }\n \ndiff --git a/serde/src/macros.rs b/serde/src/macros.rs\nindex 0d6545839..2a3d08724 100644\n--- a/serde/src/macros.rs\n+++ b/serde/src/macros.rs\n@@ -44,9 +44,9 @@\n /// }\n /// #\n /// #     forward_to_deserialize_any! {\n-/// #         u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n-/// #         seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n-/// #         tuple_struct struct identifier tuple enum ignored_any\n+/// #         i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n+/// #         byte_buf option unit unit_struct newtype_struct seq tuple\n+/// #         tuple_struct map struct enum identifier ignored_any\n /// #     }\n /// # }\n /// #\n@@ -78,8 +78,8 @@\n ///\n ///     forward_to_deserialize_any! {\n ///         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-///         byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-///         tuple tuple_struct map struct enum identifier ignored_any\n+///         byte_buf option unit unit_struct newtype_struct seq tuple\n+///         tuple_struct map struct enum identifier ignored_any\n ///     }\n /// }\n /// #\n@@ -113,8 +113,8 @@\n /// forward_to_deserialize_any! {\n ///     <W: Visitor<'q>>\n ///     bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-///     byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-///     tuple tuple_struct map struct enum identifier ignored_any\n+///     byte_buf option unit unit_struct newtype_struct seq tuple tuple_struct\n+///     map struct enum identifier ignored_any\n /// }\n /// # }\n /// #\n@@ -218,9 +218,6 @@ macro_rules! forward_to_deserialize_any_helper {\n     (seq<$l:tt, $v:ident>) => {\n         forward_to_deserialize_any_method!{deserialize_seq<$l, $v>()}\n     };\n-    (seq_fixed_size<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_any_method!{deserialize_seq_fixed_size<$l, $v>(len: usize)}\n-    };\n     (tuple<$l:tt, $v:ident>) => {\n         forward_to_deserialize_any_method!{deserialize_tuple<$l, $v>(len: usize)}\n     };\ndiff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex 751113211..6666ada2d 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -49,8 +49,8 @@ where\n \n         forward_to_deserialize_any! {\n             bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-            byte_buf unit unit_struct newtype_struct seq seq_fixed_size tuple\n-            tuple_struct map struct enum identifier ignored_any\n+            byte_buf unit unit_struct newtype_struct seq tuple tuple_struct map\n+            struct enum identifier ignored_any\n         }\n     }\n \n@@ -995,8 +995,8 @@ mod content {\n \n         forward_to_deserialize_any! {\n             bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-            byte_buf unit unit_struct seq seq_fixed_size tuple tuple_struct map\n-            struct identifier ignored_any\n+            byte_buf unit unit_struct seq tuple tuple_struct map struct\n+            identifier ignored_any\n         }\n     }\n \n@@ -1153,8 +1153,8 @@ mod content {\n \n         forward_to_deserialize_any! {\n             bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-            byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-            tuple tuple_struct map struct enum identifier ignored_any\n+            byte_buf option unit unit_struct newtype_struct seq tuple\n+            tuple_struct map struct enum identifier ignored_any\n         }\n     }\n \n@@ -1254,8 +1254,8 @@ mod content {\n \n         forward_to_deserialize_any! {\n             bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-            byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-            tuple tuple_struct map struct enum identifier ignored_any\n+            byte_buf option unit unit_struct newtype_struct seq tuple\n+            tuple_struct map struct enum identifier ignored_any\n         }\n     }\n \n@@ -1390,8 +1390,8 @@ mod content {\n \n         forward_to_deserialize_any! {\n             bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-            byte_buf unit unit_struct seq seq_fixed_size tuple tuple_struct map\n-            struct identifier ignored_any\n+            byte_buf unit unit_struct seq tuple tuple_struct map struct\n+            identifier ignored_any\n         }\n     }\n \n@@ -1545,8 +1545,8 @@ mod content {\n \n         forward_to_deserialize_any! {\n             bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-            byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-            tuple tuple_struct map struct enum identifier ignored_any\n+            byte_buf option unit unit_struct newtype_struct seq tuple\n+            tuple_struct map struct enum identifier ignored_any\n         }\n     }\n \n@@ -1647,8 +1647,8 @@ mod content {\n \n         forward_to_deserialize_any! {\n             bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-            byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-            tuple tuple_struct map struct enum identifier ignored_any\n+            byte_buf option unit unit_struct newtype_struct seq tuple\n+            tuple_struct map struct enum identifier ignored_any\n         }\n     }\n \n@@ -1804,8 +1804,8 @@ where\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-        tuple tuple_struct map struct enum identifier ignored_any\n+        byte_buf option unit unit_struct newtype_struct seq tuple tuple_struct\n+        map struct enum identifier ignored_any\n     }\n }\n \n@@ -1843,7 +1843,7 @@ where\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-        tuple tuple_struct map struct enum identifier ignored_any\n+        byte_buf option unit unit_struct newtype_struct seq tuple tuple_struct\n+        map struct enum identifier ignored_any\n     }\n }\ndiff --git a/serde/src/private/macros.rs b/serde/src/private/macros.rs\nindex 0253e6e09..046761385 100644\n--- a/serde/src/private/macros.rs\n+++ b/serde/src/private/macros.rs\n@@ -121,9 +121,6 @@ macro_rules! __serialize_unimplemented_helper {\n         type SerializeSeq = $crate::ser::Impossible<Self::Ok, Self::Error>;\n         __serialize_unimplemented_method!(serialize_seq(Option<usize>) -> SerializeSeq);\n     };\n-    (seq_fixed_size) => {\n-        __serialize_unimplemented_method!(serialize_seq_fixed_size(usize) -> SerializeSeq);\n-    };\n     (tuple) => {\n         type SerializeTuple = $crate::ser::Impossible<Self::Ok, Self::Error>;\n         __serialize_unimplemented_method!(serialize_tuple(usize) -> SerializeTuple);\ndiff --git a/serde/src/private/ser.rs b/serde/src/private/ser.rs\nindex 994875d44..8cb26d955 100644\n--- a/serde/src/private/ser.rs\n+++ b/serde/src/private/ser.rs\n@@ -245,10 +245,6 @@ where\n         Err(self.bad_type(Unsupported::Sequence))\n     }\n \n-    fn serialize_seq_fixed_size(self, _: usize) -> Result<Self::SerializeSeq, Self::Error> {\n-        Err(self.bad_type(Unsupported::Sequence))\n-    }\n-\n     fn serialize_tuple(self, _: usize) -> Result<Self::SerializeTuple, Self::Error> {\n         Err(self.bad_type(Unsupported::Tuple))\n     }\n@@ -484,7 +480,6 @@ mod content {\n         NewtypeVariant(&'static str, u32, &'static str, Box<Content>),\n \n         Seq(Vec<Content>),\n-        SeqFixedSize(Vec<Content>),\n         Tuple(Vec<Content>),\n         TupleStruct(&'static str, Vec<Content>),\n         TupleVariant(&'static str, u32, &'static str, Vec<Content>),\n@@ -523,14 +518,6 @@ mod content {\n                     serializer.serialize_newtype_variant(n, i, v, &**c)\n                 }\n                 Content::Seq(ref elements) => elements.serialize(serializer),\n-                Content::SeqFixedSize(ref elements) => {\n-                    use ser::SerializeSeq;\n-                    let mut seq = try!(serializer.serialize_seq_fixed_size(elements.len()));\n-                    for e in elements {\n-                        try!(seq.serialize_element(e));\n-                    }\n-                    seq.end()\n-                }\n                 Content::Tuple(ref elements) => {\n                     use ser::SerializeTuple;\n                     let mut tuple = try!(serializer.serialize_tuple(elements.len()));\n@@ -726,23 +713,12 @@ mod content {\n         fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, E> {\n             Ok(\n                 SerializeSeq {\n-                    fixed_size: false,\n                     elements: Vec::with_capacity(len.unwrap_or(0)),\n                     error: PhantomData,\n                 },\n             )\n         }\n \n-        fn serialize_seq_fixed_size(self, size: usize) -> Result<Self::SerializeSeq, E> {\n-            Ok(\n-                SerializeSeq {\n-                    fixed_size: true,\n-                    elements: Vec::with_capacity(size),\n-                    error: PhantomData,\n-                },\n-            )\n-        }\n-\n         fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, E> {\n             Ok(\n                 SerializeTuple {\n@@ -828,7 +804,6 @@ mod content {\n     }\n \n     struct SerializeSeq<E> {\n-        fixed_size: bool,\n         elements: Vec<Content>,\n         error: PhantomData<E>,\n     }\n@@ -850,13 +825,7 @@ mod content {\n         }\n \n         fn end(self) -> Result<Content, E> {\n-            Ok(\n-                if self.fixed_size {\n-                    Content::SeqFixedSize(self.elements)\n-                } else {\n-                    Content::Seq(self.elements)\n-                },\n-            )\n+            Ok(Content::Seq(self.elements))\n         }\n     }\n \ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex b127773e7..dad456f15 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -8,7 +8,7 @@\n \n use lib::*;\n \n-use ser::{Serialize, SerializeSeq, SerializeTuple, Serializer};\n+use ser::{Serialize, SerializeTuple, Serializer};\n \n #[cfg(feature = \"std\")]\n use ser::Error;\n@@ -130,7 +130,7 @@ impl<T> Serialize for [T; 0] {\n     where\n         S: Serializer,\n     {\n-        try!(serializer.serialize_seq_fixed_size(0)).end()\n+        try!(serializer.serialize_tuple(0)).end()\n     }\n }\n \n@@ -146,7 +146,7 @@ macro_rules! array_impls {\n                 where\n                     S: Serializer,\n                 {\n-                    let mut seq = try!(serializer.serialize_seq_fixed_size($len));\n+                    let mut seq = try!(serializer.serialize_tuple($len));\n                     for e in self {\n                         try!(seq.serialize_element(e));\n                     }\ndiff --git a/serde/src/ser/impossible.rs b/serde/src/ser/impossible.rs\nindex 592047f4f..f72748f69 100644\n--- a/serde/src/ser/impossible.rs\n+++ b/serde/src/ser/impossible.rs\n@@ -53,8 +53,7 @@ use ser::{self, Serialize, SerializeSeq, SerializeTuple, SerializeTupleStruct,\n /// #     __serialize_unimplemented! {\n /// #         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str bytes none some\n /// #         unit unit_struct unit_variant newtype_struct newtype_variant\n-/// #         seq_fixed_size tuple tuple_struct tuple_variant map struct\n-/// #         struct_variant\n+/// #         tuple tuple_struct tuple_variant map struct struct_variant\n /// #     }\n /// }\n /// #\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 0aa3c9a7c..67b60fcc7 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -239,7 +239,7 @@ pub trait Serialize {\n /// A **data format** that can serialize any data structure supported by Serde.\n ///\n /// The role of this trait is to define the serialization half of the Serde data\n-/// model, which is a way to categorize every Rust data structure into one of 28\n+/// model, which is a way to categorize every Rust data structure into one of 27\n /// possible types. Each method of the `Serializer` trait corresponds to one of\n /// the types of the data model.\n ///\n@@ -248,47 +248,54 @@ pub trait Serialize {\n ///\n /// The types that make up the Serde data model are:\n ///\n-///  - 12 primitive types:\n+///  - **12 primitive types**\n ///    - bool\n ///    - i8, i16, i32, i64\n ///    - u8, u16, u32, u64\n ///    - f32, f64\n ///    - char\n-///  - string\n-///  - byte array - [u8]\n-///  - option\n-///    - either none or some value\n-///  - unit\n-///    - unit is the type of () in Rust\n-///  - unit_struct\n-///    - for example `struct Unit` or `PhantomData<T>`\n-///  - unit_variant\n-///    - the `E::A` and `E::B` in `enum E { A, B }`\n-///  - newtype_struct\n-///    - for example `struct Millimeters(u8)`\n-///  - newtype_variant\n-///    - the `E::N` in `enum E { N(u8) }`\n-///  - seq\n-///    - a variably sized sequence of values, for example `Vec<T>` or\n-///      `HashSet<T>`\n-///  - seq_fixed_size\n-///    - a statically sized sequence of values for which the size will be known\n-///      at deserialization time without looking at the serialized data, for\n-///      example `[u64; 10]`\n-///  - tuple\n-///    - for example `(u8,)` or `(String, u64, Vec<T>)`\n-///  - tuple_struct\n-///    - for example `struct Rgb(u8, u8, u8)`\n-///  - tuple_variant\n-///    - the `E::T` in `enum E { T(u8, u8) }`\n-///  - map\n-///    - for example `BTreeMap<K, V>`\n-///  - struct\n-///    - a key-value pairing in which the keys will be known at deserialization\n-///      time without looking at the serialized data, for example `struct S { r:\n-///      u8, g: u8, b: u8 }`\n-///  - struct_variant\n-///    - the `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`\n+///  - **string**\n+///    - UTF-8 bytes with a length and no null terminator.\n+///    - When serializing, all strings are handled equally. When deserializing,\n+///      there are three flavors of strings: transient, owned, and borrowed.\n+///  - **byte array** - [u8]\n+///    - Similar to strings, during deserialization byte arrays can be transient,\n+///      owned, or borrowed.\n+///  - **option**\n+///    - Either none or some value.\n+///  - **unit**\n+///    - The type of `()` in Rust. It represents an anonymous value containing no\n+///      data.\n+///  - **unit_struct**\n+///    - For example `struct Unit` or `PhantomData<T>`. It represents a named value\n+///      containing no data.\n+///  - **unit_variant**\n+///    - For example the `E::A` and `E::B` in `enum E { A, B }`.\n+///  - **newtype_struct**\n+///    - For example `struct Millimeters(u8)`.\n+///  - **newtype_variant**\n+///    - For example the `E::N` in `enum E { N(u8) }`.\n+///  - **seq**\n+///    - A variably sized heterogeneous sequence of values, for example `Vec<T>` or\n+///      `HashSet<T>`. When serializing, the length may or may not be known before\n+///      iterating through all the data. When deserializing, the length is determined\n+///      by looking at the serialized data.\n+///  - **tuple**\n+///    - A statically sized heterogeneous sequence of values for which the length\n+///      will be known at deserialization time without looking at the serialized\n+///      data, for example `(u8,)` or `(String, u64, Vec<T>)` or `[u64; 10]`.\n+///  - **tuple_struct**\n+///    - A named tuple, for example `struct Rgb(u8, u8, u8)`.\n+///  - **tuple_variant**\n+///    - For example the `E::T` in `enum E { T(u8, u8) }`.\n+///  - **map**\n+///    - A heterogeneous key-value pairing, for example `BTreeMap<K, V>`.\n+///  - **struct**\n+///    - A heterogeneous key-value pairing in which the keys are strings and will be\n+///      known at deserialization time without looking at the serialized data, for\n+///      example `struct S { r: u8, g: u8, b: u8 }`.\n+///  - **struct_variant**\n+///    - For example the `E::S` in `enum E { S { r: u8, g: u8, b: u8 } }`.\n ///\n /// Many Serde serializers produce text or binary data as output, for example\n /// JSON or Bincode. This is not a requirement of the `Serializer` trait, and\n@@ -310,11 +317,10 @@ pub trait Serializer: Sized {\n     /// The error type when some error occurs during serialization.\n     type Error: Error;\n \n-    /// Type returned from [`serialize_seq`] and [`serialize_seq_fixed_size`]\n-    /// for serializing the content of the sequence.\n+    /// Type returned from [`serialize_seq`] for serializing the content of the\n+    /// sequence.\n     ///\n     /// [`serialize_seq`]: #tymethod.serialize_seq\n-    /// [`serialize_seq_fixed_size`]: #tymethod.serialize_seq_fixed_size\n     type SerializeSeq: SerializeSeq<Ok = Self::Ok, Error = Self::Error>;\n \n     /// Type returned from [`serialize_tuple`] for serializing the content of\n@@ -702,8 +708,7 @@ pub trait Serializer: Sized {\n     /// #     __serialize_unimplemented! {\n     /// #         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str none some\n     /// #         unit unit_struct unit_variant newtype_struct newtype_variant\n-    /// #         seq seq_fixed_size tuple tuple_struct tuple_variant map struct\n-    /// #         struct_variant\n+    /// #         seq tuple tuple_struct tuple_variant map struct struct_variant\n     /// #     }\n     /// # }\n     /// #\n@@ -966,29 +971,6 @@ pub trait Serializer: Sized {\n     /// then a call to `end`.\n     ///\n     /// ```rust\n-    /// use serde::ser::{Serialize, Serializer, SerializeSeq};\n-    ///\n-    /// const VRAM_SIZE: usize = 386;\n-    /// struct Vram([u16; VRAM_SIZE]);\n-    ///\n-    /// impl Serialize for Vram {\n-    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-    ///         where S: Serializer\n-    ///     {\n-    ///         let mut seq = serializer.serialize_seq_fixed_size(VRAM_SIZE)?;\n-    ///         for element in &self.0[..] {\n-    ///             seq.serialize_element(element)?;\n-    ///         }\n-    ///         seq.end()\n-    ///     }\n-    /// }\n-    /// ```\n-    fn serialize_seq_fixed_size(self, size: usize) -> Result<Self::SerializeSeq, Self::Error>;\n-\n-    /// Begin to serialize a tuple. This call must be followed by zero or more\n-    /// calls to `serialize_element`, then a call to `end`.\n-    ///\n-    /// ```rust\n     /// use serde::ser::{Serialize, Serializer, SerializeTuple};\n     ///\n     /// # mod fool {\n@@ -1015,6 +997,25 @@ pub trait Serializer: Sized {\n     ///     }\n     /// }\n     /// ```\n+    ///\n+    /// ```rust\n+    /// use serde::ser::{Serialize, Serializer, SerializeTuple};\n+    ///\n+    /// const VRAM_SIZE: usize = 386;\n+    /// struct Vram([u16; VRAM_SIZE]);\n+    ///\n+    /// impl Serialize for Vram {\n+    ///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    ///         where S: Serializer\n+    ///     {\n+    ///         let mut seq = serializer.serialize_tuple(VRAM_SIZE)?;\n+    ///         for element in &self.0[..] {\n+    ///             seq.serialize_element(element)?;\n+    ///         }\n+    ///         seq.end()\n+    ///     }\n+    /// }\n+    /// ```\n     fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error>;\n \n     /// Begin to serialize a tuple struct like `struct Rgb(u8, u8, u8)`. This\n@@ -1359,34 +1360,26 @@ pub trait Serializer: Sized {\n         T: Display;\n }\n \n-/// Returned from `Serializer::serialize_seq` and\n-/// `Serializer::serialize_seq_fixed_size`.\n+/// Returned from `Serializer::serialize_seq`.\n ///\n /// ```rust\n /// # use std::marker::PhantomData;\n /// #\n-/// # macro_rules! unimplemented_vec {\n-/// #     ($name:ident) => {\n-/// #         struct $name<T>(PhantomData<T>);\n-/// #\n-/// #         impl<T> $name<T> {\n-/// #             fn len(&self) -> usize {\n-/// #                 unimplemented!()\n-/// #             }\n-/// #         }\n+/// # struct Vec<T>(PhantomData<T>);\n /// #\n-/// #         impl<'a, T> IntoIterator for &'a $name<T> {\n-/// #             type Item = &'a T;\n-/// #             type IntoIter = Box<Iterator<Item = &'a T>>;\n-/// #             fn into_iter(self) -> Self::IntoIter {\n-/// #                 unimplemented!()\n-/// #             }\n-/// #         }\n+/// # impl<T> Vec<T> {\n+/// #     fn len(&self) -> usize {\n+/// #         unimplemented!()\n /// #     }\n /// # }\n /// #\n-/// # unimplemented_vec!(Vec);\n-/// # unimplemented_vec!(Array);\n+/// # impl<'a, T> IntoIterator for &'a Vec<T> {\n+/// #     type Item = &'a T;\n+/// #     type IntoIter = Box<Iterator<Item = &'a T>>;\n+/// #     fn into_iter(self) -> Self::IntoIter {\n+/// #         unimplemented!()\n+/// #     }\n+/// # }\n /// #\n /// use serde::ser::{Serialize, Serializer, SerializeSeq};\n ///\n@@ -1403,26 +1396,6 @@ pub trait Serializer: Sized {\n ///         seq.end()\n ///     }\n /// }\n-///\n-/// # mod fool {\n-/// #     trait Serialize {}\n-/// impl<T> Serialize for [T; 16]\n-/// #     {}\n-/// # }\n-/// #\n-/// # impl<T> Serialize for Array<T>\n-///     where T: Serialize\n-/// {\n-///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-///         where S: Serializer\n-///     {\n-///         let mut seq = serializer.serialize_seq_fixed_size(16)?;\n-///         for element in self {\n-///             seq.serialize_element(element)?;\n-///         }\n-///         seq.end()\n-///     }\n-/// }\n /// ```\n pub trait SerializeSeq {\n     /// Must match the `Ok` type of our `Serializer`.\n@@ -1469,6 +1442,48 @@ pub trait SerializeSeq {\n ///     }\n /// }\n /// ```\n+///\n+/// ```rust\n+/// # use std::marker::PhantomData;\n+/// #\n+/// # struct Array<T>(PhantomData<T>);\n+/// #\n+/// # impl<T> Array<T> {\n+/// #     fn len(&self) -> usize {\n+/// #         unimplemented!()\n+/// #     }\n+/// # }\n+/// #\n+/// # impl<'a, T> IntoIterator for &'a Array<T> {\n+/// #     type Item = &'a T;\n+/// #     type IntoIter = Box<Iterator<Item = &'a T>>;\n+/// #     fn into_iter(self) -> Self::IntoIter {\n+/// #         unimplemented!()\n+/// #     }\n+/// # }\n+/// #\n+/// use serde::ser::{Serialize, Serializer, SerializeTuple};\n+///\n+/// # mod fool {\n+/// #     trait Serialize {}\n+/// impl<T> Serialize for [T; 16]\n+/// #     {}\n+/// # }\n+/// #\n+/// # impl<T> Serialize for Array<T>\n+///     where T: Serialize\n+/// {\n+///     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+///         where S: Serializer\n+///     {\n+///         let mut seq = serializer.serialize_tuple(16)?;\n+///         for element in self {\n+///             seq.serialize_element(element)?;\n+///         }\n+///         seq.end()\n+///     }\n+/// }\n+/// ```\n pub trait SerializeTuple {\n     /// Must match the `Ok` type of our `Serializer`.\n     type Ok;\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 9b5fc85a0..bb2010738 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -132,7 +132,6 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n             Token::UnitStruct(_name) => visitor.visit_unit(),\n             Token::NewtypeStruct(_name) => visitor.visit_newtype_struct(self),\n             Token::Seq(len) => self.visit_seq(len, Token::SeqEnd, visitor),\n-            Token::SeqFixedSize(len) => self.visit_seq(Some(len), Token::SeqEnd, visitor),\n             Token::Tuple(len) => self.visit_seq(Some(len), Token::TupleEnd, visitor),\n             Token::TupleStruct(_, len) => self.visit_seq(Some(len), Token::TupleStructEnd, visitor),\n             Token::Map(len) => self.visit_map(len, Token::MapEnd, visitor),\n@@ -262,20 +261,6 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n         }\n     }\n \n-    fn deserialize_seq_fixed_size<V>(self, len: usize, visitor: V) -> Result<V::Value, Error>\n-    where\n-        V: Visitor<'de>,\n-    {\n-        match self.tokens.first() {\n-            Some(&Token::SeqFixedSize(_)) => {\n-                self.next_token();\n-                self.visit_seq(Some(len), Token::SeqEnd, visitor)\n-            }\n-            Some(_) => self.deserialize_any(visitor),\n-            None => Err(Error::EndOfTokens),\n-        }\n-    }\n-\n     fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Error>\n     where\n         V: Visitor<'de>,\n@@ -290,10 +275,6 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n                 self.next_token();\n                 self.visit_seq(Some(len), Token::SeqEnd, visitor)\n             }\n-            Some(&Token::SeqFixedSize(_)) => {\n-                self.next_token();\n-                self.visit_seq(Some(len), Token::SeqEnd, visitor)\n-            }\n             Some(&Token::Tuple(_)) => {\n                 self.next_token();\n                 self.visit_seq(Some(len), Token::TupleEnd, visitor)\n@@ -333,10 +314,6 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n                 self.next_token();\n                 self.visit_seq(Some(len), Token::SeqEnd, visitor)\n             }\n-            Some(&Token::SeqFixedSize(_)) => {\n-                self.next_token();\n-                self.visit_seq(Some(len), Token::SeqEnd, visitor)\n-            }\n             Some(&Token::Tuple(_)) => {\n                 self.next_token();\n                 self.visit_seq(Some(len), Token::TupleEnd, visitor)\n@@ -656,7 +633,7 @@ impl<'de> de::Deserializer<'de> for BytesDeserializer {\n \n     forward_to_deserialize_any! {\n         bool i8 i16 i32 i64 u8 u16 u32 u64 f32 f64 char str string bytes\n-        byte_buf option unit unit_struct newtype_struct seq seq_fixed_size\n-        tuple tuple_struct map struct enum identifier ignored_any\n+        byte_buf option unit unit_struct newtype_struct seq tuple tuple_struct\n+        map struct enum identifier ignored_any\n     }\n }\ndiff --git a/serde_test/src/ser.rs b/serde_test/src/ser.rs\nindex b7b80d3be..5c90fee4e 100644\n--- a/serde_test/src/ser.rs\n+++ b/serde_test/src/ser.rs\n@@ -212,11 +212,6 @@ impl<'s, 'a> ser::Serializer for &'s mut Serializer<'a> {\n         Ok(self)\n     }\n \n-    fn serialize_seq_fixed_size(self, len: usize) -> Result<Self, Error> {\n-        assert_next_token!(self, SeqFixedSize(len));\n-        Ok(self)\n-    }\n-\n     fn serialize_tuple(self, len: usize) -> Result<Self, Error> {\n         assert_next_token!(self, Tuple(len));\n         Ok(self)\ndiff --git a/serde_test/src/token.rs b/serde_test/src/token.rs\nindex c640e48f1..07bbc0b99 100644\n--- a/serde_test/src/token.rs\n+++ b/serde_test/src/token.rs\n@@ -103,12 +103,6 @@ pub enum Token {\n     /// header is a list of elements, followed by `SeqEnd`.\n     Seq(Option<usize>),\n \n-    /// The header to an array of the given length.\n-    ///\n-    /// These are serialized via `serialize_seq_fized_size`, which requires a length. After this\n-    /// header is a list of elements, followed by `SeqEnd`.\n-    SeqFixedSize(usize),\n-\n     /// An indicator of the end of a sequence.\n     SeqEnd,\n \ndiff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 4a0ebb10e..e76fc6a95 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -360,8 +360,8 @@ declare_tests! {\n             Token::SeqEnd,\n         ],\n         [0; 0] => &[\n-            Token::SeqFixedSize(0),\n-            Token::SeqEnd,\n+            Token::Tuple(0),\n+            Token::TupleEnd,\n         ],\n         ([0; 0], [1], [2, 3]) => &[\n             Token::Seq(Some(3)),\n@@ -379,19 +379,19 @@ declare_tests! {\n             Token::SeqEnd,\n         ],\n         ([0; 0], [1], [2, 3]) => &[\n-            Token::SeqFixedSize(3),\n-                Token::SeqFixedSize(0),\n-                Token::SeqEnd,\n+            Token::Tuple(3),\n+                Token::Tuple(0),\n+                Token::TupleEnd,\n \n-                Token::SeqFixedSize(1),\n+                Token::Tuple(1),\n                     Token::I32(1),\n-                Token::SeqEnd,\n+                Token::TupleEnd,\n \n-                Token::SeqFixedSize(2),\n+                Token::Tuple(2),\n                     Token::I32(2),\n                     Token::I32(3),\n-                Token::SeqEnd,\n-            Token::SeqEnd,\n+                Token::TupleEnd,\n+            Token::TupleEnd,\n         ],\n         [0; 0] => &[\n             Token::TupleStruct(\"Anything\", 0),\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex 28472ce37..2de5db147 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -138,15 +138,15 @@ declare_tests! {\n     }\n     test_array {\n         [0; 0] => &[\n-            Token::SeqFixedSize(0),\n-            Token::SeqEnd,\n+            Token::Tuple(0),\n+            Token::TupleEnd,\n         ],\n         [1, 2, 3] => &[\n-            Token::SeqFixedSize(3),\n+            Token::Tuple(3),\n                 Token::I32(1),\n                 Token::I32(2),\n                 Token::I32(3),\n-            Token::SeqEnd,\n+            Token::TupleEnd,\n         ],\n     }\n     test_vec {\n@@ -301,11 +301,11 @@ declare_tests! {\n     }\n     test_boxed_slice {\n         Box::new([0, 1, 2]) => &[\n-            Token::SeqFixedSize(3),\n+            Token::Tuple(3),\n             Token::I32(0),\n             Token::I32(1),\n             Token::I32(2),\n-            Token::SeqEnd,\n+            Token::TupleEnd,\n         ],\n     }\n     test_duration {\n", "problem_statement": "Remove seq_fixed_size in favor of tuple\nCurrently the data model uses different types for tuples like `(A, B, C)` and seq_fixed_size like `[u64; 3]`. I don't think there are any formats that treat these differently. The defining characteristic in both cases is they are heterogeneous sequences in which the length is known during deserialization without looking at the serialized data.\r\n\r\nLet's remove seq_fixed_size and serialize fixed size arrays as tuples instead.\n", "hints_text": "", "created_at": "2017-04-17T19:08:34Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 879, "instance_id": "serde-rs__serde-879", "issue_numbers": ["875"], "base_commit": "637332de2d2fa8008a8d35fbcd90d0d1ce221957", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 3999f3e36..c955498b9 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -16,6 +16,9 @@ use de::MapAccess;\n \n use de::from_primitive::FromPrimitive;\n \n+#[cfg(any(feature = \"std\", feature = \"collections\"))]\n+use private::de::size_hint;\n+\n ////////////////////////////////////////////////////////////////////////////////\n \n struct UnitVisitor;\n@@ -344,7 +347,7 @@ impl<'de> Visitor<'de> for CStringVisitor {\n     where\n         A: SeqAccess<'de>,\n     {\n-        let len = cmp::min(seq.size_hint().0, 4096);\n+        let len = size_hint::cautious(seq.size_hint());\n         let mut values = Vec::with_capacity(len);\n \n         while let Some(value) = try!(seq.next_element()) {\n@@ -557,16 +560,16 @@ macro_rules! seq_impl {\n seq_impl!(\n     BinaryHeap<T>,\n     BinaryHeapVisitor<T: Ord>,\n-    visitor,\n+    seq,\n     BinaryHeap::new(),\n-    BinaryHeap::with_capacity(cmp::min(visitor.size_hint().0, 4096)),\n+    BinaryHeap::with_capacity(size_hint::cautious(seq.size_hint())),\n     BinaryHeap::push);\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n seq_impl!(\n     BTreeSet<T>,\n     BTreeSetVisitor<T: Eq + Ord>,\n-    visitor,\n+    seq,\n     BTreeSet::new(),\n     BTreeSet::new(),\n     BTreeSet::insert);\n@@ -575,7 +578,7 @@ seq_impl!(\n seq_impl!(\n     LinkedList<T>,\n     LinkedListVisitor,\n-    visitor,\n+    seq,\n     LinkedList::new(),\n     LinkedList::new(),\n     LinkedList::push_back);\n@@ -585,27 +588,27 @@ seq_impl!(\n     HashSet<T, S>,\n     HashSetVisitor<T: Eq + Hash,\n                    S: BuildHasher + Default>,\n-    visitor,\n+    seq,\n     HashSet::with_hasher(S::default()),\n-    HashSet::with_capacity_and_hasher(cmp::min(visitor.size_hint().0, 4096), S::default()),\n+    HashSet::with_capacity_and_hasher(size_hint::cautious(seq.size_hint()), S::default()),\n     HashSet::insert);\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n seq_impl!(\n     Vec<T>,\n     VecVisitor,\n-    visitor,\n+    seq,\n     Vec::new(),\n-    Vec::with_capacity(cmp::min(visitor.size_hint().0, 4096)),\n+    Vec::with_capacity(size_hint::cautious(seq.size_hint())),\n     Vec::push);\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n seq_impl!(\n     VecDeque<T>,\n     VecDequeVisitor,\n-    visitor,\n+    seq,\n     VecDeque::new(),\n-    VecDeque::with_capacity(cmp::min(visitor.size_hint().0, 4096)),\n+    VecDeque::with_capacity(size_hint::cautious(seq.size_hint())),\n     VecDeque::push_back);\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -865,7 +868,7 @@ macro_rules! map_impl {\n map_impl!(\n     BTreeMap<K, V>,\n     BTreeMapVisitor<K: Ord>,\n-    visitor,\n+    map,\n     BTreeMap::new(),\n     BTreeMap::new());\n \n@@ -874,9 +877,9 @@ map_impl!(\n     HashMap<K, V, S>,\n     HashMapVisitor<K: Eq + Hash,\n                    S: BuildHasher + Default>,\n-    visitor,\n+    map,\n     HashMap::with_hasher(S::default()),\n-    HashMap::with_capacity_and_hasher(cmp::min(visitor.size_hint().0, 4096), S::default()));\n+    HashMap::with_capacity_and_hasher(size_hint::cautious(map.size_hint()), S::default()));\n \n ////////////////////////////////////////////////////////////////////////////////\n \ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex dc67021b2..af45dbb31 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -1376,10 +1376,10 @@ pub trait SeqAccess<'de> {\n         self.next_element_seed(PhantomData)\n     }\n \n-    /// Return the lower and upper bound of items remaining in the sequence.\n+    /// Returns the number of elements remaining in the sequence, if known.\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, None)\n+    fn size_hint(&self) -> Option<usize> {\n+        None\n     }\n }\n \n@@ -1406,7 +1406,7 @@ where\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n+    fn size_hint(&self) -> Option<usize> {\n         (**self).size_hint()\n     }\n }\n@@ -1504,10 +1504,10 @@ pub trait MapAccess<'de> {\n         self.next_entry_seed(PhantomData, PhantomData)\n     }\n \n-    /// Return the lower and upper bound of items remaining in the sequence.\n+    /// Returns the number of entries remaining in the map, if known.\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, None)\n+    fn size_hint(&self) -> Option<usize> {\n+        None\n     }\n }\n \n@@ -1572,7 +1572,7 @@ where\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n+    fn size_hint(&self) -> Option<usize> {\n         (**self).size_hint()\n     }\n }\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex a521c9a6e..921a4ac56 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -11,6 +11,7 @@\n use lib::*;\n \n use de::{self, IntoDeserializer, Expected, SeqAccess};\n+use private::de::size_hint;\n use self::private::{First, Second};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -545,8 +546,8 @@ where\n         }\n     }\n \n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+    fn size_hint(&self) -> Option<usize> {\n+        size_hint::from_bounds(&self.iter)\n     }\n }\n \n@@ -799,8 +800,8 @@ where\n         }\n     }\n \n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+    fn size_hint(&self) -> Option<usize> {\n+        size_hint::from_bounds(&self.iter)\n     }\n }\n \n@@ -827,8 +828,8 @@ where\n         }\n     }\n \n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n+    fn size_hint(&self) -> Option<usize> {\n+        size_hint::from_bounds(&self.iter)\n     }\n }\n \n@@ -910,7 +911,7 @@ where\n         if pair_visitor.1.is_none() {\n             Ok(pair)\n         } else {\n-            let remaining = pair_visitor.size_hint().0;\n+            let remaining = pair_visitor.size_hint().unwrap();\n             // First argument is the number of elements in the data, second\n             // argument is the number of elements expected by the Deserialize.\n             Err(de::Error::invalid_length(2, &ExpectedInSeq(2 - remaining)))\n@@ -954,15 +955,14 @@ where\n         }\n     }\n \n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = if self.0.is_some() {\n-            2\n+    fn size_hint(&self) -> Option<usize> {\n+        if self.0.is_some() {\n+            Some(2)\n         } else if self.1.is_some() {\n-            1\n+            Some(1)\n         } else {\n-            0\n-        };\n-        (len, Some(len))\n+            Some(0)\n+        }\n     }\n }\n \ndiff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex 7ad86def5..957052a35 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -187,6 +187,29 @@ where\n     deserializer.deserialize_str(CowBytesVisitor)\n }\n \n+pub mod size_hint {\n+    use lib::*;\n+\n+    pub fn from_bounds<I>(iter: &I) -> Option<usize>\n+        where I: Iterator\n+    {\n+        helper(iter.size_hint())\n+    }\n+\n+    pub fn cautious(hint: Option<usize>) -> usize {\n+        cmp::min(hint.unwrap_or(0), 4096)\n+    }\n+\n+    fn helper(bounds: (usize, Option<usize>)) -> Option<usize> {\n+        match bounds {\n+            (lower, Some(upper)) if lower == upper => {\n+                Some(upper)\n+            }\n+            _ => None,\n+        }\n+    }\n+}\n+\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n mod content {\n     // This module is private and nothing here should be used outside of\n@@ -203,6 +226,7 @@ mod content {\n \n     use de::{self, Deserialize, DeserializeSeed, Deserializer, Visitor, SeqAccess, MapAccess,\n              EnumAccess, Unexpected};\n+    use super::size_hint;\n \n     /// Used from generated code to buffer the contents of the Deserializer when\n     /// deserializing untagged enums and internally tagged enums.\n@@ -428,7 +452,7 @@ mod content {\n         where\n             V: SeqAccess<'de>,\n         {\n-            let mut vec = Vec::with_capacity(cmp::min(visitor.size_hint().0, 4096));\n+            let mut vec = Vec::with_capacity(size_hint::cautious(visitor.size_hint()));\n             while let Some(e) = try!(visitor.next_element()) {\n                 vec.push(e);\n             }\n@@ -439,7 +463,7 @@ mod content {\n         where\n             V: MapAccess<'de>,\n         {\n-            let mut vec = Vec::with_capacity(cmp::min(visitor.size_hint().0, 4096));\n+            let mut vec = Vec::with_capacity(size_hint::cautious(visitor.size_hint()));\n             while let Some(kv) = try!(visitor.next_entry()) {\n                 vec.push(kv);\n             }\n@@ -764,7 +788,7 @@ mod content {\n             V: MapAccess<'de>,\n         {\n             let mut tag = None;\n-            let mut vec = Vec::with_capacity(cmp::min(visitor.size_hint().0, 4096));\n+            let mut vec = Vec::with_capacity(size_hint::cautious(visitor.size_hint()));\n             while let Some(k) =\n                 try!(visitor.next_key_seed(TagOrContentVisitor::new(self.tag_name))) {\n                 match k {\n@@ -1153,8 +1177,8 @@ mod content {\n             }\n         }\n \n-        fn size_hint(&self) -> (usize, Option<usize>) {\n-            self.iter.size_hint()\n+        fn size_hint(&self) -> Option<usize> {\n+            size_hint::from_bounds(&self.iter)\n         }\n     }\n \n@@ -1209,8 +1233,8 @@ mod content {\n             }\n         }\n \n-        fn size_hint(&self) -> (usize, Option<usize>) {\n-            self.iter.size_hint()\n+        fn size_hint(&self) -> Option<usize> {\n+            size_hint::from_bounds(&self.iter)\n         }\n     }\n \n@@ -1546,8 +1570,8 @@ mod content {\n             }\n         }\n \n-        fn size_hint(&self) -> (usize, Option<usize>) {\n-            self.iter.size_hint()\n+        fn size_hint(&self) -> Option<usize> {\n+            size_hint::from_bounds(&self.iter)\n         }\n     }\n \n@@ -1603,8 +1627,8 @@ mod content {\n             }\n         }\n \n-        fn size_hint(&self) -> (usize, Option<usize>) {\n-            self.iter.size_hint()\n+        fn size_hint(&self) -> Option<usize> {\n+            size_hint::from_bounds(&self.iter)\n         }\n     }\n \n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex cef4bcaed..c826ee865 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -404,9 +404,8 @@ impl<'de, 'a> SeqAccess<'de> for DeserializerSeqVisitor<'a, 'de> {\n         seed.deserialize(&mut *self.de).map(Some)\n     }\n \n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.len.unwrap_or(0);\n-        (len, self.len)\n+    fn size_hint(&self) -> Option<usize> {\n+        self.len\n     }\n }\n \n@@ -439,9 +438,8 @@ impl<'de, 'a> MapAccess<'de> for DeserializerMapVisitor<'a, 'de> {\n         seed.deserialize(&mut *self.de)\n     }\n \n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.len.unwrap_or(0);\n-        (len, self.len)\n+    fn size_hint(&self) -> Option<usize> {\n+        self.len\n     }\n }\n \n", "problem_statement": "Change size_hint from (usize, Option<usize>) to Option<usize>\nThe size_hint for iterators is `(lower, Option<upper>)` because if you filter, take, chain, etc then you can get these elaborate constraints. That never happens when deserializing. The deserializer either knows ahead of time how many elements there are or it doesn't know.\n", "hints_text": "", "created_at": "2017-04-14T20:28:29Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 878, "instance_id": "serde-rs__serde-878", "issue_numbers": ["874"], "base_commit": "1798d1af6e3de3083d4d3ff8610e2b215a855f32", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex b7ec32b19..3999f3e36 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -1070,7 +1070,7 @@ impl<'de> Deserialize<'de> for OsStringKind {\n             }\n         }\n \n-        deserializer.deserialize(KindVisitor)\n+        deserializer.deserialize_identifier(KindVisitor)\n     }\n }\n \n@@ -1581,7 +1581,7 @@ where\n                     }\n                 }\n \n-                deserializer.deserialize(FieldVisitor)\n+                deserializer.deserialize_identifier(FieldVisitor)\n             }\n         }\n \ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 86398eb35..dc67021b2 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -763,22 +763,22 @@ where\n ///    to look at the serialized data and tell what it represents. For example\n ///    the JSON deserializer may see an opening curly brace (`{`) and know that\n ///    it is seeing a map. If the data format supports\n-///    `Deserializer::deserialize`, it will drive the Visitor using whatever\n+///    `Deserializer::deserialize_any`, it will drive the Visitor using whatever\n ///    type it sees in the input. JSON uses this approach when deserializing\n ///    `serde_json::Value` which is an enum that can represent any JSON\n ///    document. Without knowing what is in a JSON document, we can deserialize\n-///    it to `serde_json::Value` by going through `Deserializer::deserialize`.\n+///    it to `serde_json::Value` by going through `Deserializer::deserialize_any`.\n ///\n /// 2. The various `deserialize_*` methods. Non-self-describing formats like\n ///    Bincode need to be told what is in the input in order to deserialize it.\n ///    The `deserialize_*` methods are hints to the deserializer for how to\n ///    interpret the next piece of input. Non-self-describing formats are not\n ///    able to deserialize something like `serde_json::Value` which relies on\n-///    `Deserializer::deserialize`.\n+///    `Deserializer::deserialize_any`.\n ///\n /// When implementing `Deserialize`, you should avoid relying on\n-/// `Deserializer::deserialize` unless you need to be told by the Deserializer\n-/// what type is in the input. Know that relying on `Deserializer::deserialize`\n+/// `Deserializer::deserialize_any` unless you need to be told by the Deserializer\n+/// what type is in the input. Know that relying on `Deserializer::deserialize_any`\n /// means your data type will be able to deserialize from self-describing\n /// formats only, ruling out Bincode and many others.\n pub trait Deserializer<'de>: Sized {\n@@ -790,12 +790,12 @@ pub trait Deserializer<'de>: Sized {\n     /// on what data type is in the input.\n     ///\n     /// When implementing `Deserialize`, you should avoid relying on\n-    /// `Deserializer::deserialize` unless you need to be told by the\n+    /// `Deserializer::deserialize_any` unless you need to be told by the\n     /// Deserializer what type is in the input. Know that relying on\n-    /// `Deserializer::deserialize` means your data type will be able to\n+    /// `Deserializer::deserialize_any` means your data type will be able to\n     /// deserialize from self-describing formats only, ruling out Bincode and\n     /// many others.\n-    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: Visitor<'de>;\n \ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 0917d5498..a521c9a6e 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -88,13 +88,13 @@ where\n {\n     type Error = E;\n \n-    forward_to_deserialize! {\n+    forward_to_deserialize_any! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n         seq_fixed_size bytes map unit_struct newtype_struct tuple_struct struct\n         identifier tuple enum ignored_any byte_buf\n     }\n \n-    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: de::Visitor<'de>,\n     {\n@@ -140,13 +140,13 @@ macro_rules! primitive_deserializer {\n         {\n             type Error = E;\n \n-            forward_to_deserialize! {\n+            forward_to_deserialize_any! {\n                 bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit\n                 option seq seq_fixed_size bytes map unit_struct newtype_struct\n                 tuple_struct struct identifier tuple enum ignored_any byte_buf\n             }\n \n-            fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+            fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n             where\n                 V: de::Visitor<'de>,\n             {\n@@ -197,13 +197,13 @@ where\n {\n     type Error = E;\n \n-    forward_to_deserialize! {\n+    forward_to_deserialize_any! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n         struct identifier tuple ignored_any byte_buf\n     }\n \n-    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: de::Visitor<'de>,\n     {\n@@ -267,7 +267,7 @@ where\n {\n     type Error = E;\n \n-    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: de::Visitor<'de>,\n     {\n@@ -286,7 +286,7 @@ where\n         visitor.visit_enum(self)\n     }\n \n-    forward_to_deserialize! {\n+    forward_to_deserialize_any! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n         struct identifier tuple ignored_any byte_buf\n@@ -340,7 +340,7 @@ where\n {\n     type Error = E;\n \n-    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: de::Visitor<'de>,\n     {\n@@ -359,7 +359,7 @@ where\n         visitor.visit_enum(self)\n     }\n \n-    forward_to_deserialize! {\n+    forward_to_deserialize_any! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n         struct identifier tuple ignored_any byte_buf\n@@ -414,7 +414,7 @@ where\n {\n     type Error = E;\n \n-    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: de::Visitor<'de>,\n     {\n@@ -436,7 +436,7 @@ where\n         visitor.visit_enum(self)\n     }\n \n-    forward_to_deserialize! {\n+    forward_to_deserialize_any! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n         struct identifier tuple ignored_any byte_buf\n@@ -508,7 +508,7 @@ where\n {\n     type Error = E;\n \n-    fn deserialize<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_any<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: de::Visitor<'de>,\n     {\n@@ -517,7 +517,7 @@ where\n         Ok(v)\n     }\n \n-    forward_to_deserialize! {\n+    forward_to_deserialize_any! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n         struct identifier tuple enum ignored_any byte_buf\n@@ -624,14 +624,14 @@ where\n {\n     type Error = V_::Error;\n \n-    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: de::Visitor<'de>,\n     {\n         visitor.visit_seq(self.visitor)\n     }\n \n-    forward_to_deserialize! {\n+    forward_to_deserialize_any! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n         struct identifier tuple enum ignored_any byte_buf\n@@ -712,7 +712,7 @@ where\n {\n     type Error = E;\n \n-    fn deserialize<V_>(mut self, visitor: V_) -> Result<V_::Value, Self::Error>\n+    fn deserialize_any<V_>(mut self, visitor: V_) -> Result<V_::Value, Self::Error>\n     where\n         V_: de::Visitor<'de>,\n     {\n@@ -740,7 +740,7 @@ where\n         self.deserialize_seq(visitor)\n     }\n \n-    forward_to_deserialize! {\n+    forward_to_deserialize_any! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         bytes map unit_struct newtype_struct tuple_struct struct identifier\n         tuple enum ignored_any byte_buf\n@@ -888,13 +888,13 @@ where\n {\n     type Error = E;\n \n-    forward_to_deserialize! {\n+    forward_to_deserialize_any! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         bytes map unit_struct newtype_struct tuple_struct struct identifier\n         tuple enum ignored_any byte_buf\n     }\n \n-    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: de::Visitor<'de>,\n     {\n@@ -1029,14 +1029,14 @@ where\n {\n     type Error = V_::Error;\n \n-    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: de::Visitor<'de>,\n     {\n         visitor.visit_map(self.visitor)\n     }\n \n-    forward_to_deserialize! {\n+    forward_to_deserialize_any! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n         struct identifier tuple enum ignored_any byte_buf\ndiff --git a/serde/src/macros.rs b/serde/src/macros.rs\nindex f75eebf9a..6b7ea6e22 100644\n--- a/serde/src/macros.rs\n+++ b/serde/src/macros.rs\n@@ -30,7 +30,7 @@\n /// # impl<'de> Deserializer<'de> for MyDeserializer {\n /// #     type Error = value::Error;\n /// #\n-/// #     fn deserialize<V>(self, _: V) -> Result<V::Value, Self::Error>\n+/// #     fn deserialize_any<V>(self, _: V) -> Result<V::Value, Self::Error>\n /// #         where V: Visitor<'de>\n /// #     {\n /// #         unimplemented!()\n@@ -40,10 +40,10 @@\n /// fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n ///     where V: Visitor<'de>\n /// {\n-///     self.deserialize(visitor)\n+///     self.deserialize_any(visitor)\n /// }\n /// #\n-/// #     forward_to_deserialize! {\n+/// #     forward_to_deserialize_any! {\n /// #         u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n /// #         seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n /// #         tuple_struct struct identifier tuple enum ignored_any\n@@ -53,9 +53,9 @@\n /// # fn main() {}\n /// ```\n ///\n-/// The `forward_to_deserialize!` macro implements these simple forwarding\n-/// methods so that they forward directly to [`Deserializer::deserialize`]. You\n-/// can choose which methods to forward.\n+/// The `forward_to_deserialize_any!` macro implements these simple forwarding\n+/// methods so that they forward directly to [`Deserializer::deserialize_any`].\n+/// You can choose which methods to forward.\n ///\n /// ```rust\n /// # #[macro_use]\n@@ -68,7 +68,7 @@\n /// impl<'de> Deserializer<'de> for MyDeserializer {\n /// #   type Error = value::Error;\n /// #\n-///     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+///     fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n ///         where V: Visitor<'de>\n ///     {\n ///         /* ... */\n@@ -76,7 +76,7 @@\n /// #       unimplemented!()\n ///     }\n ///\n-///     forward_to_deserialize! {\n+///     forward_to_deserialize_any! {\n ///         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n ///         seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n ///         tuple_struct struct identifier tuple enum ignored_any\n@@ -104,13 +104,13 @@\n /// # impl<'q, V> Deserializer<'q> for MyDeserializer<V> {\n /// #     type Error = value::Error;\n /// #\n-/// #     fn deserialize<W>(self, visitor: W) -> Result<W::Value, Self::Error>\n+/// #     fn deserialize_any<W>(self, visitor: W) -> Result<W::Value, Self::Error>\n /// #         where W: Visitor<'q>\n /// #     {\n /// #         unimplemented!()\n /// #     }\n /// #\n-/// forward_to_deserialize! {\n+/// forward_to_deserialize_any! {\n ///     <W: Visitor<'q>>\n ///     bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n ///     seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n@@ -123,21 +123,21 @@\n ///\n /// [`Deserializer`]: trait.Deserializer.html\n /// [`Visitor`]: de/trait.Visitor.html\n-/// [`Deserializer::deserialize`]: trait.Deserializer.html#tymethod.deserialize\n+/// [`Deserializer::deserialize_any`]: trait.Deserializer.html#tymethod.deserialize_any\n #[macro_export]\n-macro_rules! forward_to_deserialize {\n+macro_rules! forward_to_deserialize_any {\n     (<$visitor:ident: Visitor<$lifetime:tt>> $($func:ident)*) => {\n-        $(forward_to_deserialize_helper!{$func<$lifetime, $visitor>})*\n+        $(forward_to_deserialize_any_helper!{$func<$lifetime, $visitor>})*\n     };\n     // This case must be after the previous one.\n     ($($func:ident)*) => {\n-        $(forward_to_deserialize_helper!{$func<'de, V>})*\n+        $(forward_to_deserialize_any_helper!{$func<'de, V>})*\n     };\n }\n \n #[doc(hidden)]\n #[macro_export]\n-macro_rules! forward_to_deserialize_method {\n+macro_rules! forward_to_deserialize_any_method {\n     ($func:ident<$l:tt, $v:ident>($($arg:ident : $ty:ty),*)) => {\n         #[inline]\n         fn $func<$v>(self, $($arg: $ty,)* visitor: $v) -> $crate::export::Result<$v::Value, Self::Error>\n@@ -147,99 +147,99 @@ macro_rules! forward_to_deserialize_method {\n             $(\n                 let _ = $arg;\n             )*\n-            self.deserialize(visitor)\n+            self.deserialize_any(visitor)\n         }\n     };\n }\n \n #[doc(hidden)]\n #[macro_export]\n-macro_rules! forward_to_deserialize_helper {\n+macro_rules! forward_to_deserialize_any_helper {\n     (bool<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_bool<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_bool<$l, $v>()}\n     };\n     (u8<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_u8<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_u8<$l, $v>()}\n     };\n     (u16<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_u16<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_u16<$l, $v>()}\n     };\n     (u32<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_u32<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_u32<$l, $v>()}\n     };\n     (u64<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_u64<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_u64<$l, $v>()}\n     };\n     (i8<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_i8<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_i8<$l, $v>()}\n     };\n     (i16<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_i16<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_i16<$l, $v>()}\n     };\n     (i32<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_i32<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_i32<$l, $v>()}\n     };\n     (i64<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_i64<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_i64<$l, $v>()}\n     };\n     (f32<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_f32<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_f32<$l, $v>()}\n     };\n     (f64<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_f64<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_f64<$l, $v>()}\n     };\n     (char<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_char<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_char<$l, $v>()}\n     };\n     (str<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_str<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_str<$l, $v>()}\n     };\n     (string<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_string<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_string<$l, $v>()}\n     };\n     (unit<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_unit<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_unit<$l, $v>()}\n     };\n     (option<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_option<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_option<$l, $v>()}\n     };\n     (seq<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_seq<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_seq<$l, $v>()}\n     };\n     (seq_fixed_size<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_seq_fixed_size<$l, $v>(len: usize)}\n+        forward_to_deserialize_any_method!{deserialize_seq_fixed_size<$l, $v>(len: usize)}\n     };\n     (bytes<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_bytes<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_bytes<$l, $v>()}\n     };\n     (byte_buf<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_byte_buf<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_byte_buf<$l, $v>()}\n     };\n     (map<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_map<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_map<$l, $v>()}\n     };\n     (unit_struct<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_unit_struct<$l, $v>(name: &'static str)}\n+        forward_to_deserialize_any_method!{deserialize_unit_struct<$l, $v>(name: &'static str)}\n     };\n     (newtype_struct<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_newtype_struct<$l, $v>(name: &'static str)}\n+        forward_to_deserialize_any_method!{deserialize_newtype_struct<$l, $v>(name: &'static str)}\n     };\n     (tuple_struct<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_tuple_struct<$l, $v>(name: &'static str, len: usize)}\n+        forward_to_deserialize_any_method!{deserialize_tuple_struct<$l, $v>(name: &'static str, len: usize)}\n     };\n     (struct<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_struct<$l, $v>(name: &'static str, fields: &'static [&'static str])}\n+        forward_to_deserialize_any_method!{deserialize_struct<$l, $v>(name: &'static str, fields: &'static [&'static str])}\n     };\n     (identifier<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_identifier<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_identifier<$l, $v>()}\n     };\n     (tuple<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_tuple<$l, $v>(len: usize)}\n+        forward_to_deserialize_any_method!{deserialize_tuple<$l, $v>(len: usize)}\n     };\n     (enum<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_enum<$l, $v>(name: &'static str, variants: &'static [&'static str])}\n+        forward_to_deserialize_any_method!{deserialize_enum<$l, $v>(name: &'static str, variants: &'static [&'static str])}\n     };\n     (ignored_any<$l:tt, $v:ident>) => {\n-        forward_to_deserialize_method!{deserialize_ignored_any<$l, $v>()}\n+        forward_to_deserialize_any_method!{deserialize_ignored_any<$l, $v>()}\n     };\n }\ndiff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex d5c03061d..7ad86def5 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -33,7 +33,7 @@ where\n     {\n         type Error = E;\n \n-        fn deserialize<V>(self, _visitor: V) -> Result<V::Value, E>\n+        fn deserialize_any<V>(self, _visitor: V) -> Result<V::Value, E>\n         where\n             V: Visitor<'de>,\n         {\n@@ -47,7 +47,7 @@ where\n             visitor.visit_none()\n         }\n \n-        forward_to_deserialize! {\n+        forward_to_deserialize_any! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n             seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n             tuple_struct struct identifier tuple enum ignored_any\n@@ -271,7 +271,7 @@ mod content {\n         {\n             // Untagged and internally tagged enums are only supported in\n             // self-describing formats.\n-            deserializer.deserialize(ContentVisitor)\n+            deserializer.deserialize_any(ContentVisitor)\n         }\n     }\n \n@@ -481,7 +481,7 @@ mod content {\n         {\n             // Internally tagged enums are only supported in self-describing\n             // formats.\n-            deserializer.deserialize(self)\n+            deserializer.deserialize_any(self)\n         }\n     }\n \n@@ -745,7 +745,7 @@ mod content {\n         {\n             // Internally tagged enums are only supported in self-describing\n             // formats.\n-            deserializer.deserialize(self)\n+            deserializer.deserialize_any(self)\n         }\n     }\n \n@@ -854,7 +854,7 @@ mod content {\n     {\n         type Error = E;\n \n-        fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n         where\n             V: Visitor<'de>,\n         {\n@@ -969,7 +969,7 @@ mod content {\n             )\n         }\n \n-        forward_to_deserialize! {\n+        forward_to_deserialize_any! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n             seq_fixed_size bytes byte_buf map unit_struct tuple_struct struct\n             identifier tuple ignored_any\n@@ -1057,7 +1057,7 @@ mod content {\n         {\n             match self.value {\n                 Some(Content::Seq(v)) => {\n-                    de::Deserializer::deserialize(SeqDeserializer::new(v), visitor)\n+                    de::Deserializer::deserialize_any(SeqDeserializer::new(v), visitor)\n                 }\n                 Some(other) => Err(de::Error::invalid_type(other.unexpected(), &\"tuple variant\"),),\n                 None => Err(de::Error::invalid_type(de::Unexpected::UnitVariant, &\"tuple variant\"),),\n@@ -1074,7 +1074,7 @@ mod content {\n         {\n             match self.value {\n                 Some(Content::Map(v)) => {\n-                    de::Deserializer::deserialize(MapDeserializer::new(v), visitor)\n+                    de::Deserializer::deserialize_any(MapDeserializer::new(v), visitor)\n                 }\n                 Some(other) => Err(de::Error::invalid_type(other.unexpected(), &\"struct variant\"),),\n                 _ => Err(de::Error::invalid_type(de::Unexpected::UnitVariant, &\"struct variant\"),),\n@@ -1109,7 +1109,7 @@ mod content {\n         type Error = E;\n \n         #[inline]\n-        fn deserialize<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n+        fn deserialize_any<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n         where\n             V: de::Visitor<'de>,\n         {\n@@ -1127,7 +1127,7 @@ mod content {\n             }\n         }\n \n-        forward_to_deserialize! {\n+        forward_to_deserialize_any! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n             seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n             tuple_struct struct identifier tuple enum ignored_any\n@@ -1221,14 +1221,14 @@ mod content {\n         type Error = E;\n \n         #[inline]\n-        fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n         where\n             V: de::Visitor<'de>,\n         {\n             visitor.visit_map(self)\n         }\n \n-        forward_to_deserialize! {\n+        forward_to_deserialize_any! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n             seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n             tuple_struct struct identifier tuple enum ignored_any\n@@ -1250,7 +1250,7 @@ mod content {\n     {\n         type Error = E;\n \n-        fn deserialize<V>(self, visitor: V) -> Result<V::Value, E>\n+        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, E>\n         where\n             V: Visitor<'de>,\n         {\n@@ -1365,7 +1365,7 @@ mod content {\n             )\n         }\n \n-        forward_to_deserialize! {\n+        forward_to_deserialize_any! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n             seq_fixed_size bytes byte_buf map unit_struct tuple_struct struct\n             identifier tuple ignored_any\n@@ -1450,7 +1450,7 @@ mod content {\n         {\n             match self.value {\n                 Some(&Content::Seq(ref v)) => {\n-                    de::Deserializer::deserialize(SeqRefDeserializer::new(v), visitor)\n+                    de::Deserializer::deserialize_any(SeqRefDeserializer::new(v), visitor)\n                 }\n                 Some(other) => Err(de::Error::invalid_type(other.unexpected(), &\"tuple variant\"),),\n                 None => Err(de::Error::invalid_type(de::Unexpected::UnitVariant, &\"tuple variant\"),),\n@@ -1467,7 +1467,7 @@ mod content {\n         {\n             match self.value {\n                 Some(&Content::Map(ref v)) => {\n-                    de::Deserializer::deserialize(MapRefDeserializer::new(v), visitor)\n+                    de::Deserializer::deserialize_any(MapRefDeserializer::new(v), visitor)\n                 }\n                 Some(other) => Err(de::Error::invalid_type(other.unexpected(), &\"struct variant\"),),\n                 _ => Err(de::Error::invalid_type(de::Unexpected::UnitVariant, &\"struct variant\"),),\n@@ -1502,7 +1502,7 @@ mod content {\n         type Error = E;\n \n         #[inline]\n-        fn deserialize<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n+        fn deserialize_any<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n         where\n             V: de::Visitor<'de>,\n         {\n@@ -1520,7 +1520,7 @@ mod content {\n             }\n         }\n \n-        forward_to_deserialize! {\n+        forward_to_deserialize_any! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n             seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n             tuple_struct struct identifier tuple enum ignored_any\n@@ -1615,14 +1615,14 @@ mod content {\n         type Error = E;\n \n         #[inline]\n-        fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+        fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n         where\n             V: de::Visitor<'de>,\n         {\n             visitor.visit_map(self)\n         }\n \n-        forward_to_deserialize! {\n+        forward_to_deserialize_any! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n             seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n             tuple_struct struct identifier tuple enum ignored_any\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 994b9a9ba..6eb3846bd 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -497,7 +497,7 @@ fn deserialize_struct(\n     };\n     let dispatch = if let Some(deserializer) = deserializer {\n         quote! {\n-            _serde::Deserializer::deserialize(#deserializer, #visitor_expr)\n+            _serde::Deserializer::deserialize_any(#deserializer, #visitor_expr)\n         }\n     } else if is_enum {\n         quote! {\n@@ -729,7 +729,7 @@ fn deserialize_internally_tagged_enum(\n \n         #variants_stmt\n \n-        let __tagged = try!(_serde::Deserializer::deserialize(\n+        let __tagged = try!(_serde::Deserializer::deserialize_any(\n             __deserializer,\n             _serde::private::de::TaggedContentVisitor::<__Field>::new(#tag)));\n \n@@ -1083,7 +1083,7 @@ fn deserialize_internally_tagged_variant(\n             let type_name = params.type_name();\n             let variant_name = variant.ident.as_ref();\n             quote_block! {\n-                try!(_serde::Deserializer::deserialize(#deserializer, _serde::private::de::InternallyTaggedUnitVisitor::new(#type_name, #variant_name)));\n+                try!(_serde::Deserializer::deserialize_any(#deserializer, _serde::private::de::InternallyTaggedUnitVisitor::new(#type_name, #variant_name)));\n                 _serde::export::Ok(#this::#variant_ident)\n             }\n         }\n@@ -1109,7 +1109,7 @@ fn deserialize_untagged_variant(\n             let variant_name = variant.ident.as_ref();\n             quote_expr! {\n                 _serde::export::Result::map(\n-                    _serde::Deserializer::deserialize(\n+                    _serde::Deserializer::deserialize_any(\n                         #deserializer,\n                         _serde::private::de::UntaggedUnitVisitor::new(#type_name, #variant_name)\n                     ),\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex b6ce5725b..cef4bcaed 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -97,12 +97,12 @@ impl<'de> Deserializer<'de> {\n impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n     type Error = Error;\n \n-    forward_to_deserialize! {\n+    forward_to_deserialize_any! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit\n         seq bytes byte_buf map identifier ignored_any\n     }\n \n-    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Error>\n     where\n         V: Visitor<'de>,\n     {\n@@ -192,7 +192,7 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n                 self.next_token();\n                 visitor.visit_some(self)\n             }\n-            Some(_) => self.deserialize(visitor),\n+            Some(_) => self.deserialize_any(visitor),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n@@ -239,7 +239,7 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n                     Err(Error::InvalidName(n))\n                 }\n             }\n-            Some(_) => self.deserialize(visitor),\n+            Some(_) => self.deserialize_any(visitor),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n@@ -257,7 +257,7 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n                     Err(Error::InvalidName(n))\n                 }\n             }\n-            Some(_) => self.deserialize(visitor),\n+            Some(_) => self.deserialize_any(visitor),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n@@ -271,7 +271,7 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n                 self.next_token();\n                 self.visit_seq(Some(len), Token::SeqEnd, visitor)\n             }\n-            Some(_) => self.deserialize(visitor),\n+            Some(_) => self.deserialize_any(visitor),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n@@ -302,7 +302,7 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n                 self.next_token();\n                 self.visit_seq(Some(len), Token::TupleStructEnd, visitor)\n             }\n-            Some(_) => self.deserialize(visitor),\n+            Some(_) => self.deserialize_any(visitor),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n@@ -349,7 +349,7 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n                     Err(Error::InvalidName(n))\n                 }\n             }\n-            Some(_) => self.deserialize(visitor),\n+            Some(_) => self.deserialize_any(visitor),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n@@ -376,7 +376,7 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n                 self.next_token();\n                 self.visit_map(Some(fields.len()), Token::MapEnd, visitor)\n             }\n-            Some(_) => self.deserialize(visitor),\n+            Some(_) => self.deserialize_any(visitor),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n@@ -529,7 +529,7 @@ impl<'de, 'a> VariantAccess<'de> for DeserializerEnumVisitor<'a, 'de> {\n                     Err(Error::UnexpectedToken(token))\n                 }\n             }\n-            Some(_) => de::Deserializer::deserialize(self.de, visitor),\n+            Some(_) => de::Deserializer::deserialize_any(self.de, visitor),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n@@ -559,7 +559,7 @@ impl<'de, 'a> VariantAccess<'de> for DeserializerEnumVisitor<'a, 'de> {\n                     Err(Error::UnexpectedToken(token))\n                 }\n             }\n-            Some(_) => de::Deserializer::deserialize(self.de, visitor),\n+            Some(_) => de::Deserializer::deserialize_any(self.de, visitor),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n@@ -649,14 +649,14 @@ struct BytesDeserializer {\n impl<'de> de::Deserializer<'de> for BytesDeserializer {\n     type Error = Error;\n \n-    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: de::Visitor<'de>,\n     {\n         visitor.visit_bytes(self.value)\n     }\n \n-    forward_to_deserialize! {\n+    forward_to_deserialize_any! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n         struct identifier tuple enum ignored_any byte_buf\n", "problem_statement": "Rename Deserializer::deserialize to deserialize_any\n- I think the current method is overused unintentionally and I think a better name would clarify the point of the method.\r\n\r\n- The current name causes ambiguities when both Deserialize and Deserializer are in scope. In particular, `serde_json::Value::deserialize` is ambiguous and requires less-readable workarounds.\r\n\r\n- The name `deserialize_any` nicely relates to `deserialize_ignored_any`.\n", "hints_text": "", "created_at": "2017-04-14T19:51:27Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 876, "instance_id": "serde-rs__serde-876", "issue_numbers": ["873"], "base_commit": "f2de0509f5cbabad34e20dded361a65347afc96c", "patch": "diff --git a/serde/src/de/ignored_any.rs b/serde/src/de/ignored_any.rs\nindex b8ff0c756..a4f3abe26 100644\n--- a/serde/src/de/ignored_any.rs\n+++ b/serde/src/de/ignored_any.rs\n@@ -8,7 +8,7 @@\n \n use lib::*;\n \n-use de::{Deserialize, Deserializer, Visitor, SeqVisitor, MapVisitor, Error};\n+use de::{Deserialize, Deserializer, Visitor, SeqAccess, MapAccess, Error};\n \n /// An efficient way of discarding data from a deserializer.\n ///\n@@ -20,7 +20,7 @@ use de::{Deserialize, Deserializer, Visitor, SeqVisitor, MapVisitor, Error};\n /// use std::fmt;\n /// use std::marker::PhantomData;\n ///\n-/// use serde::de::{self, Deserialize, DeserializeSeed, Deserializer, Visitor, SeqVisitor, IgnoredAny};\n+/// use serde::de::{self, Deserialize, DeserializeSeed, Deserializer, Visitor, SeqAccess, IgnoredAny};\n ///\n /// /// A seed that can be used to deserialize only the `n`th element of a sequence\n /// /// while efficiently discarding elements of any type before or after index `n`.\n@@ -53,19 +53,19 @@ use de::{Deserialize, Deserializer, Visitor, SeqVisitor, MapVisitor, Error};\n ///         write!(formatter, \"a sequence in which we care about element {}\", self.n)\n ///     }\n ///\n-///     fn visit_seq<V>(self, mut seq: V) -> Result<Self::Value, V::Error>\n-///         where V: SeqVisitor<'de>\n+///     fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n+///         where A: SeqAccess<'de>\n ///     {\n ///         // Skip over the first `n` elements.\n ///         for i in 0..self.n {\n ///             // It is an error if the sequence ends before we get to element `n`.\n-///             if seq.visit::<IgnoredAny>()?.is_none() {\n+///             if seq.next_element::<IgnoredAny>()?.is_none() {\n ///                 return Err(de::Error::invalid_length(i, &self));\n ///             }\n ///         }\n ///\n ///         // Deserialize the one we care about.\n-///         let nth = match seq.visit()? {\n+///         let nth = match seq.next_element()? {\n ///             Some(nth) => nth,\n ///             None => {\n ///                 return Err(de::Error::invalid_length(self.n, &self));\n@@ -73,7 +73,7 @@ use de::{Deserialize, Deserializer, Visitor, SeqVisitor, MapVisitor, Error};\n ///         };\n ///\n ///         // Skip over any remaining elements in the sequence after `n`.\n-///         while let Some(IgnoredAny) = seq.visit()? {\n+///         while let Some(IgnoredAny) = seq.next_element()? {\n ///             // ignore\n ///         }\n ///\n@@ -173,22 +173,22 @@ impl<'de> Visitor<'de> for IgnoredAny {\n     }\n \n     #[inline]\n-    fn visit_seq<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n+    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n     where\n-        V: SeqVisitor<'de>,\n+        A: SeqAccess<'de>,\n     {\n-        while let Some(IgnoredAny) = try!(visitor.visit()) {\n+        while let Some(IgnoredAny) = try!(seq.next_element()) {\n             // Gobble\n         }\n         Ok(IgnoredAny)\n     }\n \n     #[inline]\n-    fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n+    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>\n     where\n-        V: MapVisitor<'de>,\n+        A: MapAccess<'de>,\n     {\n-        while let Some((IgnoredAny, IgnoredAny)) = try!(visitor.visit()) {\n+        while let Some((IgnoredAny, IgnoredAny)) = try!(map.next_entry()) {\n             // Gobble\n         }\n         Ok(IgnoredAny)\ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 222df6246..b7ec32b19 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -8,11 +8,11 @@\n \n use lib::*;\n \n-use de::{Deserialize, Deserializer, EnumVisitor, Error, SeqVisitor, Unexpected, VariantVisitor,\n+use de::{Deserialize, Deserializer, EnumAccess, Error, SeqAccess, Unexpected, VariantAccess,\n          Visitor};\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-use de::MapVisitor;\n+use de::MapAccess;\n \n use de::from_primitive::FromPrimitive;\n \n@@ -340,14 +340,14 @@ impl<'de> Visitor<'de> for CStringVisitor {\n         formatter.write_str(\"byte array\")\n     }\n \n-    fn visit_seq<V>(self, mut visitor: V) -> Result<CString, V::Error>\n+    fn visit_seq<A>(self, mut seq: A) -> Result<CString, A::Error>\n     where\n-        V: SeqVisitor<'de>,\n+        A: SeqAccess<'de>,\n     {\n-        let len = cmp::min(visitor.size_hint().0, 4096);\n+        let len = cmp::min(seq.size_hint().0, 4096);\n         let mut values = Vec::with_capacity(len);\n \n-        while let Some(value) = try!(visitor.visit()) {\n+        while let Some(value) = try!(seq.next_element()) {\n             values.push(value);\n         }\n \n@@ -495,7 +495,7 @@ macro_rules! seq_impl {\n     (\n         $ty:ident < T $(, $typaram:ident)* >,\n         $visitor_ty:ident $( < $($boundparam:ident : $bound1:ident $(+ $bound2:ident)*),* > )*,\n-        $visitor:ident,\n+        $access:ident,\n         $ctor:expr,\n         $with_capacity:expr,\n         $insert:expr\n@@ -524,13 +524,13 @@ macro_rules! seq_impl {\n             }\n \n             #[inline]\n-            fn visit_seq<V>(self, mut $visitor: V) -> Result<Self::Value, V::Error>\n+            fn visit_seq<A>(self, mut $access: A) -> Result<Self::Value, A::Error>\n             where\n-                V: SeqVisitor<'de>,\n+                A: SeqAccess<'de>,\n             {\n                 let mut values = $with_capacity;\n \n-                while let Some(value) = try!($visitor.visit()) {\n+                while let Some(value) = try!($access.next_element()) {\n                     $insert(&mut values, value);\n                 }\n \n@@ -628,9 +628,9 @@ impl<'de, T> Visitor<'de> for ArrayVisitor<[T; 0]> {\n     }\n \n     #[inline]\n-    fn visit_seq<V>(self, _: V) -> Result<[T; 0], V::Error>\n+    fn visit_seq<A>(self, _: A) -> Result<[T; 0], A::Error>\n     where\n-        V: SeqVisitor<'de>,\n+        A: SeqAccess<'de>,\n     {\n         Ok([])\n     }\n@@ -660,12 +660,12 @@ macro_rules! array_impls {\n                 }\n \n                 #[inline]\n-                fn visit_seq<V>(self, mut visitor: V) -> Result<[T; $len], V::Error>\n+                fn visit_seq<A>(self, mut seq: A) -> Result<[T; $len], A::Error>\n                 where\n-                    V: SeqVisitor<'de>,\n+                    A: SeqAccess<'de>,\n                 {\n                     $(\n-                        let $name = match try!(visitor.visit()) {\n+                        let $name = match try!(seq.next_element()) {\n                             Some(val) => val,\n                             None => return Err(Error::invalid_length($n, &self)),\n                         };\n@@ -749,12 +749,12 @@ macro_rules! tuple_impls {\n \n                 #[inline]\n                 #[allow(non_snake_case)]\n-                fn visit_seq<V>(self, mut visitor: V) -> Result<($($name,)+), V::Error>\n+                fn visit_seq<A>(self, mut seq: A) -> Result<($($name,)+), A::Error>\n                 where\n-                    V: SeqVisitor<'de>,\n+                    A: SeqAccess<'de>,\n                 {\n                     $(\n-                        let $name = match try!(visitor.visit()) {\n+                        let $name = match try!(seq.next_element()) {\n                             Some(value) => value,\n                             None => return Err(Error::invalid_length($n, &self)),\n                         };\n@@ -802,7 +802,7 @@ macro_rules! map_impl {\n     (\n         $ty:ident < K, V $(, $typaram:ident)* >,\n         $visitor_ty:ident < $($boundparam:ident : $bound1:ident $(+ $bound2:ident)*),* >,\n-        $visitor:ident,\n+        $access:ident,\n         $ctor:expr,\n         $with_capacity:expr\n     ) => {\n@@ -831,13 +831,13 @@ macro_rules! map_impl {\n             }\n \n             #[inline]\n-            fn visit_map<Visitor>(self, mut $visitor: Visitor) -> Result<Self::Value, Visitor::Error>\n+            fn visit_map<A>(self, mut $access: A) -> Result<Self::Value, A::Error>\n             where\n-                Visitor: MapVisitor<'de>,\n+                A: MapAccess<'de>,\n             {\n                 let mut values = $with_capacity;\n \n-                while let Some((key, value)) = try!($visitor.visit()) {\n+                while let Some((key, value)) = try!($access.next_entry()) {\n                     values.insert(key, value);\n                 }\n \n@@ -1086,29 +1086,29 @@ impl<'de> Visitor<'de> for OsStringVisitor {\n     }\n \n     #[cfg(unix)]\n-    fn visit_enum<V>(self, visitor: V) -> Result<OsString, V::Error>\n+    fn visit_enum<A>(self, data: A) -> Result<OsString, A::Error>\n     where\n-        V: EnumVisitor<'de>,\n+        A: EnumAccess<'de>,\n     {\n         use std::os::unix::ffi::OsStringExt;\n \n-        match try!(visitor.visit_variant()) {\n-            (OsStringKind::Unix, variant) => variant.visit_newtype().map(OsString::from_vec),\n+        match try!(data.variant()) {\n+            (OsStringKind::Unix, variant) => variant.deserialize_newtype().map(OsString::from_vec),\n             (OsStringKind::Windows, _) => Err(Error::custom(\"cannot deserialize Windows OS string on Unix\",),),\n         }\n     }\n \n     #[cfg(windows)]\n-    fn visit_enum<V>(self, visitor: V) -> Result<OsString, V::Error>\n+    fn visit_enum<A>(self, data: A) -> Result<OsString, A::Error>\n     where\n-        V: EnumVisitor<'de>,\n+        A: EnumAccess<'de>,\n     {\n         use std::os::windows::ffi::OsStringExt;\n \n-        match try!(visitor.visit_variant()) {\n+        match try!(data.variant()) {\n             (OsStringKind::Windows, variant) => {\n                 variant\n-                    .visit_newtype::<Vec<u16>>()\n+                    .deserialize_newtype::<Vec<u16>>()\n                     .map(|vec| OsString::from_wide(&vec))\n             }\n             (OsStringKind::Unix, _) => Err(Error::custom(\"cannot deserialize Unix OS string on Windows\",),),\n@@ -1285,17 +1285,17 @@ impl<'de> Deserialize<'de> for Duration {\n                 formatter.write_str(\"struct Duration\")\n             }\n \n-            fn visit_seq<V>(self, mut visitor: V) -> Result<Duration, V::Error>\n+            fn visit_seq<A>(self, mut seq: A) -> Result<Duration, A::Error>\n             where\n-                V: SeqVisitor<'de>,\n+                A: SeqAccess<'de>,\n             {\n-                let secs: u64 = match try!(visitor.visit()) {\n+                let secs: u64 = match try!(seq.next_element()) {\n                     Some(value) => value,\n                     None => {\n                         return Err(Error::invalid_length(0, &self));\n                     }\n                 };\n-                let nanos: u32 = match try!(visitor.visit()) {\n+                let nanos: u32 = match try!(seq.next_element()) {\n                     Some(value) => value,\n                     None => {\n                         return Err(Error::invalid_length(1, &self));\n@@ -1304,35 +1304,35 @@ impl<'de> Deserialize<'de> for Duration {\n                 Ok(Duration::new(secs, nanos))\n             }\n \n-            fn visit_map<V>(self, mut visitor: V) -> Result<Duration, V::Error>\n+            fn visit_map<A>(self, mut map: A) -> Result<Duration, A::Error>\n             where\n-                V: MapVisitor<'de>,\n+                A: MapAccess<'de>,\n             {\n                 let mut secs: Option<u64> = None;\n                 let mut nanos: Option<u32> = None;\n-                while let Some(key) = try!(visitor.visit_key::<Field>()) {\n+                while let Some(key) = try!(map.next_key()) {\n                     match key {\n                         Field::Secs => {\n                             if secs.is_some() {\n-                                return Err(<V::Error as Error>::duplicate_field(\"secs\"));\n+                                return Err(<A::Error as Error>::duplicate_field(\"secs\"));\n                             }\n-                            secs = Some(try!(visitor.visit_value()));\n+                            secs = Some(try!(map.next_value()));\n                         }\n                         Field::Nanos => {\n                             if nanos.is_some() {\n-                                return Err(<V::Error as Error>::duplicate_field(\"nanos\"));\n+                                return Err(<A::Error as Error>::duplicate_field(\"nanos\"));\n                             }\n-                            nanos = Some(try!(visitor.visit_value()));\n+                            nanos = Some(try!(map.next_value()));\n                         }\n                     }\n                 }\n                 let secs = match secs {\n                     Some(secs) => secs,\n-                    None => return Err(<V::Error as Error>::missing_field(\"secs\")),\n+                    None => return Err(<A::Error as Error>::missing_field(\"secs\")),\n                 };\n                 let nanos = match nanos {\n                     Some(nanos) => nanos,\n-                    None => return Err(<V::Error as Error>::missing_field(\"nanos\")),\n+                    None => return Err(<A::Error as Error>::missing_field(\"nanos\")),\n                 };\n                 Ok(Duration::new(secs, nanos))\n             }\n@@ -1425,17 +1425,17 @@ where\n                 formatter.write_str(\"struct Range\")\n             }\n \n-            fn visit_seq<V>(self, mut visitor: V) -> Result<ops::Range<Idx>, V::Error>\n+            fn visit_seq<A>(self, mut seq: A) -> Result<ops::Range<Idx>, A::Error>\n             where\n-                V: SeqVisitor<'de>,\n+                A: SeqAccess<'de>,\n             {\n-                let start: Idx = match try!(visitor.visit()) {\n+                let start: Idx = match try!(seq.next_element()) {\n                     Some(value) => value,\n                     None => {\n                         return Err(Error::invalid_length(0, &self));\n                     }\n                 };\n-                let end: Idx = match try!(visitor.visit()) {\n+                let end: Idx = match try!(seq.next_element()) {\n                     Some(value) => value,\n                     None => {\n                         return Err(Error::invalid_length(1, &self));\n@@ -1444,35 +1444,35 @@ where\n                 Ok(start..end)\n             }\n \n-            fn visit_map<V>(self, mut visitor: V) -> Result<ops::Range<Idx>, V::Error>\n+            fn visit_map<A>(self, mut map: A) -> Result<ops::Range<Idx>, A::Error>\n             where\n-                V: MapVisitor<'de>,\n+                A: MapAccess<'de>,\n             {\n                 let mut start: Option<Idx> = None;\n                 let mut end: Option<Idx> = None;\n-                while let Some(key) = try!(visitor.visit_key::<Field>()) {\n+                while let Some(key) = try!(map.next_key()) {\n                     match key {\n                         Field::Start => {\n                             if start.is_some() {\n-                                return Err(<V::Error as Error>::duplicate_field(\"start\"));\n+                                return Err(<A::Error as Error>::duplicate_field(\"start\"));\n                             }\n-                            start = Some(try!(visitor.visit_value()));\n+                            start = Some(try!(map.next_value()));\n                         }\n                         Field::End => {\n                             if end.is_some() {\n-                                return Err(<V::Error as Error>::duplicate_field(\"end\"));\n+                                return Err(<A::Error as Error>::duplicate_field(\"end\"));\n                             }\n-                            end = Some(try!(visitor.visit_value()));\n+                            end = Some(try!(map.next_value()));\n                         }\n                     }\n                 }\n                 let start = match start {\n                     Some(start) => start,\n-                    None => return Err(<V::Error as Error>::missing_field(\"start\")),\n+                    None => return Err(<A::Error as Error>::missing_field(\"start\")),\n                 };\n                 let end = match end {\n                     Some(end) => end,\n-                    None => return Err(<V::Error as Error>::missing_field(\"end\")),\n+                    None => return Err(<A::Error as Error>::missing_field(\"end\")),\n                 };\n                 Ok(start..end)\n             }\n@@ -1598,13 +1598,13 @@ where\n                 formatter.write_str(\"enum Result\")\n             }\n \n-            fn visit_enum<V>(self, visitor: V) -> Result<Result<T, E>, V::Error>\n+            fn visit_enum<A>(self, data: A) -> Result<Result<T, E>, A::Error>\n             where\n-                V: EnumVisitor<'de>,\n+                A: EnumAccess<'de>,\n             {\n-                match try!(visitor.visit_variant()) {\n-                    (Field::Ok, variant) => variant.visit_newtype().map(Ok),\n-                    (Field::Err, variant) => variant.visit_newtype().map(Err),\n+                match try!(data.variant()) {\n+                    (Field::Ok, variant) => variant.deserialize_newtype().map(Ok),\n+                    (Field::Err, variant) => variant.deserialize_newtype().map(Err),\n                 }\n             }\n         }\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 35e00531d..86398eb35 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -585,7 +585,7 @@ where\n /// use std::fmt;\n /// use std::marker::PhantomData;\n ///\n-/// use serde::de::{Deserialize, DeserializeSeed, Deserializer, Visitor, SeqVisitor};\n+/// use serde::de::{Deserialize, DeserializeSeed, Deserializer, Visitor, SeqAccess};\n ///\n /// // A DeserializeSeed implementation that uses stateful deserialization to\n /// // append array elements onto the end of an existing vector. The preexisting\n@@ -618,12 +618,12 @@ where\n ///                 write!(formatter, \"an array of integers\")\n ///             }\n ///\n-///             fn visit_seq<V>(self, mut visitor: V) -> Result<(), V::Error>\n-///                 where V: SeqVisitor<'de>\n+///             fn visit_seq<A>(self, mut seq: A) -> Result<(), A::Error>\n+///                 where A: SeqAccess<'de>\n ///             {\n ///                 // Visit each element in the inner array and push it onto\n ///                 // the existing vector.\n-///                 while let Some(elem) = visitor.visit()? {\n+///                 while let Some(elem) = seq.next_element()? {\n ///                     self.0.push(elem);\n ///                 }\n ///                 Ok(())\n@@ -648,14 +648,14 @@ where\n ///         write!(formatter, \"an array of arrays\")\n ///     }\n ///\n-///     fn visit_seq<V>(self, mut visitor: V) -> Result<Vec<T>, V::Error>\n-///         where V: SeqVisitor<'de>\n+///     fn visit_seq<A>(self, mut seq: A) -> Result<Vec<T>, A::Error>\n+///         where A: SeqAccess<'de>\n ///     {\n ///         // Create a single Vec to hold the flattened contents.\n ///         let mut vec = Vec::new();\n ///\n ///         // Each iteration through this loop is one inner array.\n-///         while let Some(()) = visitor.visit_seed(ExtendVec(&mut vec))? {\n+///         while let Some(()) = seq.next_element_seed(ExtendVec(&mut vec))? {\n ///             // Nothing to do; inner array has been appended into `vec`.\n ///         }\n ///\n@@ -1260,29 +1260,29 @@ pub trait Visitor<'de>: Sized {\n     }\n \n     /// Deserialize `Value` as a sequence of elements.\n-    fn visit_seq<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n+    fn visit_seq<A>(self, seq: A) -> Result<Self::Value, A::Error>\n     where\n-        V: SeqVisitor<'de>,\n+        A: SeqAccess<'de>,\n     {\n-        let _ = visitor;\n+        let _ = seq;\n         Err(Error::invalid_type(Unexpected::Seq, &self))\n     }\n \n     /// Deserialize `Value` as a key-value map.\n-    fn visit_map<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n+    fn visit_map<A>(self, map: A) -> Result<Self::Value, A::Error>\n     where\n-        V: MapVisitor<'de>,\n+        A: MapAccess<'de>,\n     {\n-        let _ = visitor;\n+        let _ = map;\n         Err(Error::invalid_type(Unexpected::Map, &self))\n     }\n \n     /// Deserialize `Value` as an enum.\n-    fn visit_enum<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n+    fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>\n     where\n-        V: EnumVisitor<'de>,\n+        A: EnumAccess<'de>,\n     {\n-        let _ = visitor;\n+        let _ = data;\n         Err(Error::invalid_type(Unexpected::Enum, &self))\n     }\n \n@@ -1345,11 +1345,11 @@ pub trait Visitor<'de>: Sized {\n \n ////////////////////////////////////////////////////////////////////////////////\n \n-/// `SeqVisitor` visits each item in a sequence.\n+/// Provides a `Visitor` access to each element of a sequence in the input.\n ///\n /// This is a trait that a `Deserializer` passes to a `Visitor` implementation,\n /// which deserializes each item in a sequence.\n-pub trait SeqVisitor<'de> {\n+pub trait SeqAccess<'de> {\n     /// The error type that can be returned if some error occurs during\n     /// deserialization.\n     type Error: Error;\n@@ -1357,9 +1357,9 @@ pub trait SeqVisitor<'de> {\n     /// This returns `Ok(Some(value))` for the next value in the sequence, or\n     /// `Ok(None)` if there are no more remaining items.\n     ///\n-    /// `Deserialize` implementations should typically use `SeqVisitor::visit`\n-    /// instead.\n-    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+    /// `Deserialize` implementations should typically use\n+    /// `SeqAcccess::next_element` instead.\n+    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n     where\n         T: DeserializeSeed<'de>;\n \n@@ -1367,13 +1367,13 @@ pub trait SeqVisitor<'de> {\n     /// `Ok(None)` if there are no more remaining items.\n     ///\n     /// This method exists as a convenience for `Deserialize` implementations.\n-    /// `SeqVisitor` implementations should not override the default behavior.\n+    /// `SeqAccess` implementations should not override the default behavior.\n     #[inline]\n-    fn visit<T>(&mut self) -> Result<Option<T>, Self::Error>\n+    fn next_element<T>(&mut self) -> Result<Option<T>, Self::Error>\n     where\n         T: Deserialize<'de>,\n     {\n-        self.visit_seed(PhantomData)\n+        self.next_element_seed(PhantomData)\n     }\n \n     /// Return the lower and upper bound of items remaining in the sequence.\n@@ -1383,26 +1383,26 @@ pub trait SeqVisitor<'de> {\n     }\n }\n \n-impl<'de, 'a, V> SeqVisitor<'de> for &'a mut V\n+impl<'de, 'a, V> SeqAccess<'de> for &'a mut V\n where\n-    V: SeqVisitor<'de>,\n+    V: SeqAccess<'de>,\n {\n     type Error = V::Error;\n \n     #[inline]\n-    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, V::Error>\n+    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, V::Error>\n     where\n         T: DeserializeSeed<'de>,\n     {\n-        (**self).visit_seed(seed)\n+        (**self).next_element_seed(seed)\n     }\n \n     #[inline]\n-    fn visit<T>(&mut self) -> Result<Option<T>, V::Error>\n+    fn next_element<T>(&mut self) -> Result<Option<T>, V::Error>\n     where\n         T: Deserialize<'de>,\n     {\n-        (**self).visit()\n+        (**self).next_element()\n     }\n \n     #[inline]\n@@ -1413,10 +1413,10 @@ where\n \n ////////////////////////////////////////////////////////////////////////////////\n \n-/// `MapVisitor` visits each item in a sequence.\n+/// Provides a `Visitor` access to each entry of a map in the input.\n ///\n /// This is a trait that a `Deserializer` passes to a `Visitor` implementation.\n-pub trait MapVisitor<'de> {\n+pub trait MapAccess<'de> {\n     /// The error type that can be returned if some error occurs during\n     /// deserialization.\n     type Error: Error;\n@@ -1425,29 +1425,29 @@ pub trait MapVisitor<'de> {\n     /// if there are no more remaining entries.\n     ///\n     /// `Deserialize` implementations should typically use\n-    /// `MapVisitor::visit_key` or `MapVisitor::visit` instead.\n-    fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n+    /// `MapAccess::next_key` or `MapAccess::next_entry` instead.\n+    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n     where\n         K: DeserializeSeed<'de>;\n \n     /// This returns a `Ok(value)` for the next value in the map.\n     ///\n     /// `Deserialize` implementations should typically use\n-    /// `MapVisitor::visit_value` instead.\n-    fn visit_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n+    /// `MapAccess::next_value` instead.\n+    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n     where\n         V: DeserializeSeed<'de>;\n \n     /// This returns `Ok(Some((key, value)))` for the next (key-value) pair in\n     /// the map, or `Ok(None)` if there are no more remaining items.\n     ///\n-    /// `MapVisitor` implementations should override the default behavior if a\n+    /// `MapAccess` implementations should override the default behavior if a\n     /// more efficient implementation is possible.\n     ///\n-    /// `Deserialize` implementations should typically use `MapVisitor::visit`\n-    /// instead.\n+    /// `Deserialize` implementations should typically use\n+    /// `MapAccess::next_entry` instead.\n     #[inline]\n-    fn visit_seed<K, V>(\n+    fn next_entry_seed<K, V>(\n         &mut self,\n         kseed: K,\n         vseed: V,\n@@ -1456,9 +1456,9 @@ pub trait MapVisitor<'de> {\n         K: DeserializeSeed<'de>,\n         V: DeserializeSeed<'de>,\n     {\n-        match try!(self.visit_key_seed(kseed)) {\n+        match try!(self.next_key_seed(kseed)) {\n             Some(key) => {\n-                let value = try!(self.visit_value_seed(vseed));\n+                let value = try!(self.next_value_seed(vseed));\n                 Ok(Some((key, value)))\n             }\n             None => Ok(None),\n@@ -1469,39 +1469,39 @@ pub trait MapVisitor<'de> {\n     /// if there are no more remaining entries.\n     ///\n     /// This method exists as a convenience for `Deserialize` implementations.\n-    /// `MapVisitor` implementations should not override the default behavior.\n+    /// `MapAccess` implementations should not override the default behavior.\n     #[inline]\n-    fn visit_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n+    fn next_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n     where\n         K: Deserialize<'de>,\n     {\n-        self.visit_key_seed(PhantomData)\n+        self.next_key_seed(PhantomData)\n     }\n \n     /// This returns a `Ok(value)` for the next value in the map.\n     ///\n     /// This method exists as a convenience for `Deserialize` implementations.\n-    /// `MapVisitor` implementations should not override the default behavior.\n+    /// `MapAccess` implementations should not override the default behavior.\n     #[inline]\n-    fn visit_value<V>(&mut self) -> Result<V, Self::Error>\n+    fn next_value<V>(&mut self) -> Result<V, Self::Error>\n     where\n         V: Deserialize<'de>,\n     {\n-        self.visit_value_seed(PhantomData)\n+        self.next_value_seed(PhantomData)\n     }\n \n     /// This returns `Ok(Some((key, value)))` for the next (key-value) pair in\n     /// the map, or `Ok(None)` if there are no more remaining items.\n     ///\n     /// This method exists as a convenience for `Deserialize` implementations.\n-    /// `MapVisitor` implementations should not override the default behavior.\n+    /// `MapAccess` implementations should not override the default behavior.\n     #[inline]\n-    fn visit<K, V>(&mut self) -> Result<Option<(K, V)>, Self::Error>\n+    fn next_entry<K, V>(&mut self) -> Result<Option<(K, V)>, Self::Error>\n     where\n         K: Deserialize<'de>,\n         V: Deserialize<'de>,\n     {\n-        self.visit_seed(PhantomData, PhantomData)\n+        self.next_entry_seed(PhantomData, PhantomData)\n     }\n \n     /// Return the lower and upper bound of items remaining in the sequence.\n@@ -1511,30 +1511,30 @@ pub trait MapVisitor<'de> {\n     }\n }\n \n-impl<'de, 'a, V_> MapVisitor<'de> for &'a mut V_\n+impl<'de, 'a, V_> MapAccess<'de> for &'a mut V_\n where\n-    V_: MapVisitor<'de>,\n+    V_: MapAccess<'de>,\n {\n     type Error = V_::Error;\n \n     #[inline]\n-    fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n+    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n     where\n         K: DeserializeSeed<'de>,\n     {\n-        (**self).visit_key_seed(seed)\n+        (**self).next_key_seed(seed)\n     }\n \n     #[inline]\n-    fn visit_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n+    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n     where\n         V: DeserializeSeed<'de>,\n     {\n-        (**self).visit_value_seed(seed)\n+        (**self).next_value_seed(seed)\n     }\n \n     #[inline]\n-    fn visit_seed<K, V>(\n+    fn next_entry_seed<K, V>(\n         &mut self,\n         kseed: K,\n         vseed: V,\n@@ -1543,32 +1543,32 @@ where\n         K: DeserializeSeed<'de>,\n         V: DeserializeSeed<'de>,\n     {\n-        (**self).visit_seed(kseed, vseed)\n+        (**self).next_entry_seed(kseed, vseed)\n     }\n \n     #[inline]\n-    fn visit<K, V>(&mut self) -> Result<Option<(K, V)>, V_::Error>\n+    fn next_entry<K, V>(&mut self) -> Result<Option<(K, V)>, V_::Error>\n     where\n         K: Deserialize<'de>,\n         V: Deserialize<'de>,\n     {\n-        (**self).visit()\n+        (**self).next_entry()\n     }\n \n     #[inline]\n-    fn visit_key<K>(&mut self) -> Result<Option<K>, V_::Error>\n+    fn next_key<K>(&mut self) -> Result<Option<K>, V_::Error>\n     where\n         K: Deserialize<'de>,\n     {\n-        (**self).visit_key()\n+        (**self).next_key()\n     }\n \n     #[inline]\n-    fn visit_value<V>(&mut self) -> Result<V, V_::Error>\n+    fn next_value<V>(&mut self) -> Result<V, V_::Error>\n     where\n         V: Deserialize<'de>,\n     {\n-        (**self).visit_value()\n+        (**self).next_value()\n     }\n \n     #[inline]\n@@ -1579,44 +1579,45 @@ where\n \n ////////////////////////////////////////////////////////////////////////////////\n \n-/// `EnumVisitor` is a visitor that is created by the `Deserializer` and passed\n-/// to the `Deserialize` in order to identify which variant of an enum to\n-/// deserialize.\n-pub trait EnumVisitor<'de>: Sized {\n+/// Provides a `Visitor` access to the data of an enum in the input.\n+///\n+/// `EnumAccess` is created by the `Deserializer` and passed to the\n+/// `Visitor` in order to identify which variant of an enum to deserialize.\n+pub trait EnumAccess<'de>: Sized {\n     /// The error type that can be returned if some error occurs during\n     /// deserialization.\n     type Error: Error;\n     /// The `Visitor` that will be used to deserialize the content of the enum\n     /// variant.\n-    type Variant: VariantVisitor<'de, Error = Self::Error>;\n+    type Variant: VariantAccess<'de, Error = Self::Error>;\n \n-    /// `visit_variant` is called to identify which variant to deserialize.\n+    /// `variant` is called to identify which variant to deserialize.\n     ///\n-    /// `Deserialize` implementations should typically use\n-    /// `EnumVisitor::visit_variant` instead.\n-    fn visit_variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n+    /// `Deserialize` implementations should typically use `EnumAccess::variant`\n+    /// instead.\n+    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n     where\n         V: DeserializeSeed<'de>;\n \n-    /// `visit_variant` is called to identify which variant to deserialize.\n+    /// `variant` is called to identify which variant to deserialize.\n     ///\n     /// This method exists as a convenience for `Deserialize` implementations.\n-    /// `EnumVisitor` implementations should not override the default behavior.\n+    /// `EnumAccess` implementations should not override the default behavior.\n     #[inline]\n-    fn visit_variant<V>(self) -> Result<(V, Self::Variant), Self::Error>\n+    fn variant<V>(self) -> Result<(V, Self::Variant), Self::Error>\n     where\n         V: Deserialize<'de>,\n     {\n-        self.visit_variant_seed(PhantomData)\n+        self.variant_seed(PhantomData)\n     }\n }\n \n-/// `VariantVisitor` is a visitor that is created by the `Deserializer` and\n+/// `VariantAccess` is a visitor that is created by the `Deserializer` and\n /// passed to the `Deserialize` to deserialize the content of a particular enum\n /// variant.\n-pub trait VariantVisitor<'de>: Sized {\n+pub trait VariantAccess<'de>: Sized {\n     /// The error type that can be returned if some error occurs during\n-    /// deserialization. Must match the error type of our `EnumVisitor`.\n+    /// deserialization. Must match the error type of our `EnumAccess`.\n     type Error: Error;\n \n     /// Called when deserializing a variant with no values.\n@@ -1625,55 +1626,55 @@ pub trait VariantVisitor<'de>: Sized {\n     /// `invalid_type` error should be constructed:\n     ///\n     /// ```rust\n-    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantVisitor, Unexpected};\n+    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n     /// #\n     /// # struct X;\n     /// #\n-    /// # impl<'de> VariantVisitor<'de> for X {\n+    /// # impl<'de> VariantAccess<'de> for X {\n     /// #     type Error = value::Error;\n     /// #\n-    /// fn visit_unit(self) -> Result<(), Self::Error> {\n+    /// fn deserialize_unit(self) -> Result<(), Self::Error> {\n     ///     // What the data actually contained; suppose it is a tuple variant.\n     ///     let unexp = Unexpected::TupleVariant;\n     ///     Err(de::Error::invalid_type(unexp, &\"unit variant\"))\n     /// }\n     /// #\n-    /// #     fn visit_newtype_seed<T>(self, _: T) -> Result<T::Value, Self::Error>\n+    /// #     fn deserialize_newtype_seed<T>(self, _: T) -> Result<T::Value, Self::Error>\n     /// #         where T: DeserializeSeed<'de>\n     /// #     { unimplemented!() }\n     /// #\n-    /// #     fn visit_tuple<V>(self, _: usize, _: V) -> Result<V::Value, Self::Error>\n+    /// #     fn deserialize_tuple<V>(self, _: usize, _: V) -> Result<V::Value, Self::Error>\n     /// #         where V: Visitor<'de>\n     /// #     { unimplemented!() }\n     /// #\n-    /// #     fn visit_struct<V>(self, _: &[&str], _: V) -> Result<V::Value, Self::Error>\n+    /// #     fn deserialize_struct<V>(self, _: &[&str], _: V) -> Result<V::Value, Self::Error>\n     /// #         where V: Visitor<'de>\n     /// #     { unimplemented!() }\n     /// # }\n     /// ```\n-    fn visit_unit(self) -> Result<(), Self::Error>;\n+    fn deserialize_unit(self) -> Result<(), Self::Error>;\n \n     /// Called when deserializing a variant with a single value.\n     ///\n     /// `Deserialize` implementations should typically use\n-    /// `VariantVisitor::visit_newtype` instead.\n+    /// `VariantAccess::deserialize_newtype` instead.\n     ///\n     /// If the data contains a different type of variant, the following\n     /// `invalid_type` error should be constructed:\n     ///\n     /// ```rust\n-    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantVisitor, Unexpected};\n+    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n     /// #\n     /// # struct X;\n     /// #\n-    /// # impl<'de> VariantVisitor<'de> for X {\n+    /// # impl<'de> VariantAccess<'de> for X {\n     /// #     type Error = value::Error;\n     /// #\n-    /// #     fn visit_unit(self) -> Result<(), Self::Error> {\n+    /// #     fn deserialize_unit(self) -> Result<(), Self::Error> {\n     /// #         unimplemented!()\n     /// #     }\n     /// #\n-    /// fn visit_newtype_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>\n+    /// fn deserialize_newtype_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>\n     ///     where T: DeserializeSeed<'de>\n     /// {\n     ///     // What the data actually contained; suppose it is a unit variant.\n@@ -1681,30 +1682,30 @@ pub trait VariantVisitor<'de>: Sized {\n     ///     Err(de::Error::invalid_type(unexp, &\"newtype variant\"))\n     /// }\n     /// #\n-    /// #     fn visit_tuple<V>(self, _: usize, _: V) -> Result<V::Value, Self::Error>\n+    /// #     fn deserialize_tuple<V>(self, _: usize, _: V) -> Result<V::Value, Self::Error>\n     /// #         where V: Visitor<'de>\n     /// #     { unimplemented!() }\n     /// #\n-    /// #     fn visit_struct<V>(self, _: &[&str], _: V) -> Result<V::Value, Self::Error>\n+    /// #     fn deserialize_struct<V>(self, _: &[&str], _: V) -> Result<V::Value, Self::Error>\n     /// #         where V: Visitor<'de>\n     /// #     { unimplemented!() }\n     /// # }\n     /// ```\n-    fn visit_newtype_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n+    fn deserialize_newtype_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n     where\n         T: DeserializeSeed<'de>;\n \n     /// Called when deserializing a variant with a single value.\n     ///\n     /// This method exists as a convenience for `Deserialize` implementations.\n-    /// `VariantVisitor` implementations should not override the default\n+    /// `VariantAccess` implementations should not override the default\n     /// behavior.\n     #[inline]\n-    fn visit_newtype<T>(self) -> Result<T, Self::Error>\n+    fn deserialize_newtype<T>(self) -> Result<T, Self::Error>\n     where\n         T: Deserialize<'de>,\n     {\n-        self.visit_newtype_seed(PhantomData)\n+        self.deserialize_newtype_seed(PhantomData)\n     }\n \n     /// Called when deserializing a tuple-like variant.\n@@ -1715,24 +1716,24 @@ pub trait VariantVisitor<'de>: Sized {\n     /// `invalid_type` error should be constructed:\n     ///\n     /// ```rust\n-    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantVisitor, Unexpected};\n+    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n     /// #\n     /// # struct X;\n     /// #\n-    /// # impl<'de> VariantVisitor<'de> for X {\n+    /// # impl<'de> VariantAccess<'de> for X {\n     /// #     type Error = value::Error;\n     /// #\n-    /// #     fn visit_unit(self) -> Result<(), Self::Error> {\n+    /// #     fn deserialize_unit(self) -> Result<(), Self::Error> {\n     /// #         unimplemented!()\n     /// #     }\n     /// #\n-    /// #     fn visit_newtype_seed<T>(self, _: T) -> Result<T::Value, Self::Error>\n+    /// #     fn deserialize_newtype_seed<T>(self, _: T) -> Result<T::Value, Self::Error>\n     /// #         where T: DeserializeSeed<'de>\n     /// #     { unimplemented!() }\n     /// #\n-    /// fn visit_tuple<V>(self,\n-    ///                   _len: usize,\n-    ///                   _visitor: V) -> Result<V::Value, Self::Error>\n+    /// fn deserialize_tuple<V>(self,\n+    ///                         _len: usize,\n+    ///                         _visitor: V) -> Result<V::Value, Self::Error>\n     ///     where V: Visitor<'de>\n     /// {\n     ///     // What the data actually contained; suppose it is a unit variant.\n@@ -1740,12 +1741,12 @@ pub trait VariantVisitor<'de>: Sized {\n     ///     Err(de::Error::invalid_type(unexp, &\"tuple variant\"))\n     /// }\n     /// #\n-    /// #     fn visit_struct<V>(self, _: &[&str], _: V) -> Result<V::Value, Self::Error>\n+    /// #     fn deserialize_struct<V>(self, _: &[&str], _: V) -> Result<V::Value, Self::Error>\n     /// #         where V: Visitor<'de>\n     /// #     { unimplemented!() }\n     /// # }\n     /// ```\n-    fn visit_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n+    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n     where\n         V: Visitor<'de>;\n \n@@ -1757,28 +1758,28 @@ pub trait VariantVisitor<'de>: Sized {\n     /// `invalid_type` error should be constructed:\n     ///\n     /// ```rust\n-    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantVisitor, Unexpected};\n+    /// # use serde::de::{self, value, DeserializeSeed, Visitor, VariantAccess, Unexpected};\n     /// #\n     /// # struct X;\n     /// #\n-    /// # impl<'de> VariantVisitor<'de> for X {\n+    /// # impl<'de> VariantAccess<'de> for X {\n     /// #     type Error = value::Error;\n     /// #\n-    /// #     fn visit_unit(self) -> Result<(), Self::Error> {\n+    /// #     fn deserialize_unit(self) -> Result<(), Self::Error> {\n     /// #         unimplemented!()\n     /// #     }\n     /// #\n-    /// #     fn visit_newtype_seed<T>(self, _: T) -> Result<T::Value, Self::Error>\n+    /// #     fn deserialize_newtype_seed<T>(self, _: T) -> Result<T::Value, Self::Error>\n     /// #         where T: DeserializeSeed<'de>\n     /// #     { unimplemented!() }\n     /// #\n-    /// #     fn visit_tuple<V>(self, _: usize, _: V) -> Result<V::Value, Self::Error>\n+    /// #     fn deserialize_tuple<V>(self, _: usize, _: V) -> Result<V::Value, Self::Error>\n     /// #         where V: Visitor<'de>\n     /// #     { unimplemented!() }\n     /// #\n-    /// fn visit_struct<V>(self,\n-    ///                    _fields: &'static [&'static str],\n-    ///                    _visitor: V) -> Result<V::Value, Self::Error>\n+    /// fn deserialize_struct<V>(self,\n+    ///                          _fields: &'static [&'static str],\n+    ///                          _visitor: V) -> Result<V::Value, Self::Error>\n     ///     where V: Visitor<'de>\n     /// {\n     ///     // What the data actually contained; suppose it is a unit variant.\n@@ -1787,7 +1788,7 @@ pub trait VariantVisitor<'de>: Sized {\n     /// }\n     /// # }\n     /// ```\n-    fn visit_struct<V>(\n+    fn deserialize_struct<V>(\n         self,\n         fields: &'static [&'static str],\n         visitor: V,\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 2e611551f..0917d5498 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -10,7 +10,7 @@\n \n use lib::*;\n \n-use de::{self, IntoDeserializer, Expected, SeqVisitor};\n+use de::{self, IntoDeserializer, Expected, SeqAccess};\n use self::private::{First, Second};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -223,14 +223,14 @@ where\n     }\n }\n \n-impl<'de, E> de::EnumVisitor<'de> for U32Deserializer<E>\n+impl<'de, E> de::EnumAccess<'de> for U32Deserializer<E>\n where\n     E: de::Error,\n {\n     type Error = E;\n     type Variant = private::UnitOnly<E>;\n \n-    fn visit_variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n+    fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n     where\n         T: de::DeserializeSeed<'de>,\n     {\n@@ -293,14 +293,14 @@ where\n     }\n }\n \n-impl<'de, 'a, E> de::EnumVisitor<'de> for StrDeserializer<'a, E>\n+impl<'de, 'a, E> de::EnumAccess<'de> for StrDeserializer<'a, E>\n where\n     E: de::Error,\n {\n     type Error = E;\n     type Variant = private::UnitOnly<E>;\n \n-    fn visit_variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n+    fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n     where\n         T: de::DeserializeSeed<'de>,\n     {\n@@ -367,14 +367,14 @@ where\n }\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-impl<'de, 'a, E> de::EnumVisitor<'de> for StringDeserializer<E>\n+impl<'de, 'a, E> de::EnumAccess<'de> for StringDeserializer<E>\n where\n     E: de::Error,\n {\n     type Error = E;\n     type Variant = private::UnitOnly<E>;\n \n-    fn visit_variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n+    fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n     where\n         T: de::DeserializeSeed<'de>,\n     {\n@@ -444,14 +444,14 @@ where\n }\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-impl<'de, 'a, E> de::EnumVisitor<'de> for CowStrDeserializer<'a, E>\n+impl<'de, 'a, E> de::EnumAccess<'de> for CowStrDeserializer<'a, E>\n where\n     E: de::Error,\n {\n     type Error = E;\n     type Variant = private::UnitOnly<E>;\n \n-    fn visit_variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n+    fn variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n     where\n         T: de::DeserializeSeed<'de>,\n     {\n@@ -524,7 +524,7 @@ where\n     }\n }\n \n-impl<'de, I, T, E> de::SeqVisitor<'de> for SeqDeserializer<I, E>\n+impl<'de, I, T, E> de::SeqAccess<'de> for SeqDeserializer<I, E>\n where\n     I: Iterator<Item = T>,\n     T: IntoDeserializer<'de, E>,\n@@ -532,7 +532,7 @@ where\n {\n     type Error = E;\n \n-    fn visit_seed<V>(&mut self, seed: V) -> Result<Option<V::Value>, Self::Error>\n+    fn next_element_seed<V>(&mut self, seed: V) -> Result<Option<V::Value>, Self::Error>\n     where\n         V: de::DeserializeSeed<'de>,\n     {\n@@ -605,7 +605,7 @@ where\n \n ////////////////////////////////////////////////////////////////////////////////\n \n-/// A helper deserializer that deserializes a sequence using a `SeqVisitor`.\n+/// A helper deserializer that deserializes a sequence using a `SeqAccess`.\n #[derive(Clone, Debug)]\n pub struct SeqVisitorDeserializer<V_> {\n     visitor: V_,\n@@ -620,7 +620,7 @@ impl<V_> SeqVisitorDeserializer<V_> {\n \n impl<'de, V_> de::Deserializer<'de> for SeqVisitorDeserializer<V_>\n where\n-    V_: de::SeqVisitor<'de>,\n+    V_: de::SeqAccess<'de>,\n {\n     type Error = V_::Error;\n \n@@ -747,7 +747,7 @@ where\n     }\n }\n \n-impl<'de, I, E> de::MapVisitor<'de> for MapDeserializer<'de, I, E>\n+impl<'de, I, E> de::MapAccess<'de> for MapDeserializer<'de, I, E>\n where\n     I: Iterator,\n     I::Item: private::Pair,\n@@ -757,7 +757,7 @@ where\n {\n     type Error = E;\n \n-    fn visit_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+    fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n     where\n         T: de::DeserializeSeed<'de>,\n     {\n@@ -770,18 +770,18 @@ where\n         }\n     }\n \n-    fn visit_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n+    fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n     where\n         T: de::DeserializeSeed<'de>,\n     {\n         let value = self.value.take();\n         // Panic because this indicates a bug in the program rather than an\n         // expected failure.\n-        let value = value.expect(\"MapVisitor::visit_value called before visit_key\");\n+        let value = value.expect(\"MapAccess::visit_value called before visit_key\");\n         seed.deserialize(value.into_deserializer())\n     }\n \n-    fn visit_seed<TK, TV>(&mut self,\n+    fn next_entry_seed<TK, TV>(&mut self,\n                           kseed: TK,\n                           vseed: TV)\n                           -> Result<Option<(TK::Value, TV::Value)>, Self::Error>\n@@ -804,7 +804,7 @@ where\n     }\n }\n \n-impl<'de, I, E> de::SeqVisitor<'de> for MapDeserializer<'de, I, E>\n+impl<'de, I, E> de::SeqAccess<'de> for MapDeserializer<'de, I, E>\n where\n     I: Iterator,\n     I::Item: private::Pair,\n@@ -814,7 +814,7 @@ where\n {\n     type Error = E;\n \n-    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n     where\n         T: de::DeserializeSeed<'de>,\n     {\n@@ -876,7 +876,7 @@ where\n     }\n }\n \n-// Used in the `impl SeqVisitor for MapDeserializer` to visit the map as a\n+// Used in the `impl SeqAccess for MapDeserializer` to visit the map as a\n // sequence of pairs.\n struct PairDeserializer<A, B, E>(A, B, PhantomData<E>);\n \n@@ -933,7 +933,7 @@ where\n \n struct PairVisitor<A, B, E>(Option<A>, Option<B>, PhantomData<E>);\n \n-impl<'de, A, B, E> de::SeqVisitor<'de> for PairVisitor<A, B, E>\n+impl<'de, A, B, E> de::SeqAccess<'de> for PairVisitor<A, B, E>\n where\n     A: IntoDeserializer<'de, E>,\n     B: IntoDeserializer<'de, E>,\n@@ -941,7 +941,7 @@ where\n {\n     type Error = E;\n \n-    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n     where\n         T: de::DeserializeSeed<'de>,\n     {\n@@ -1010,7 +1010,7 @@ where\n \n ////////////////////////////////////////////////////////////////////////////////\n \n-/// A helper deserializer that deserializes a map using a `MapVisitor`.\n+/// A helper deserializer that deserializes a map using a `MapAccess`.\n #[derive(Clone, Debug)]\n pub struct MapVisitorDeserializer<V_> {\n     visitor: V_,\n@@ -1025,7 +1025,7 @@ impl<V_> MapVisitorDeserializer<V_> {\n \n impl<'de, V_> de::Deserializer<'de> for MapVisitorDeserializer<V_>\n where\n-    V_: de::MapVisitor<'de>,\n+    V_: de::MapAccess<'de>,\n {\n     type Error = V_::Error;\n \n@@ -1059,31 +1059,31 @@ mod private {\n         (t, UnitOnly { marker: PhantomData })\n     }\n \n-    impl<'de, E> de::VariantVisitor<'de> for UnitOnly<E>\n+    impl<'de, E> de::VariantAccess<'de> for UnitOnly<E>\n     where\n         E: de::Error,\n     {\n         type Error = E;\n \n-        fn visit_unit(self) -> Result<(), Self::Error> {\n+        fn deserialize_unit(self) -> Result<(), Self::Error> {\n             Ok(())\n         }\n \n-        fn visit_newtype_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>\n+        fn deserialize_newtype_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>\n         where\n             T: de::DeserializeSeed<'de>,\n         {\n             Err(de::Error::invalid_type(Unexpected::UnitVariant, &\"newtype variant\"),)\n         }\n \n-        fn visit_tuple<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>\n+        fn deserialize_tuple<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>\n         where\n             V: de::Visitor<'de>,\n         {\n             Err(de::Error::invalid_type(Unexpected::UnitVariant, &\"tuple variant\"),)\n         }\n \n-        fn visit_struct<V>(\n+        fn deserialize_struct<V>(\n             self,\n             _fields: &'static [&'static str],\n             _visitor: V,\ndiff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex 844a9d7bb..d5c03061d 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -201,8 +201,8 @@ mod content {\n \n     use lib::*;\n \n-    use de::{self, Deserialize, DeserializeSeed, Deserializer, Visitor, SeqVisitor, MapVisitor,\n-             EnumVisitor, Unexpected};\n+    use de::{self, Deserialize, DeserializeSeed, Deserializer, Visitor, SeqAccess, MapAccess,\n+             EnumAccess, Unexpected};\n \n     /// Used from generated code to buffer the contents of the Deserializer when\n     /// deserializing untagged enums and internally tagged enums.\n@@ -426,10 +426,10 @@ mod content {\n \n         fn visit_seq<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n         where\n-            V: SeqVisitor<'de>,\n+            V: SeqAccess<'de>,\n         {\n             let mut vec = Vec::with_capacity(cmp::min(visitor.size_hint().0, 4096));\n-            while let Some(e) = try!(visitor.visit()) {\n+            while let Some(e) = try!(visitor.next_element()) {\n                 vec.push(e);\n             }\n             Ok(Content::Seq(vec))\n@@ -437,10 +437,10 @@ mod content {\n \n         fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n         where\n-            V: MapVisitor<'de>,\n+            V: MapAccess<'de>,\n         {\n             let mut vec = Vec::with_capacity(cmp::min(visitor.size_hint().0, 4096));\n-            while let Some(kv) = try!(visitor.visit()) {\n+            while let Some(kv) = try!(visitor.next_entry()) {\n                 vec.push(kv);\n             }\n             Ok(Content::Map(vec))\n@@ -448,7 +448,7 @@ mod content {\n \n         fn visit_enum<V>(self, _visitor: V) -> Result<Self::Value, V::Error>\n         where\n-            V: EnumVisitor<'de>,\n+            V: EnumAccess<'de>,\n         {\n             Err(de::Error::custom(\"untagged and internally tagged enums do not support enum input\",),)\n         }\n@@ -682,7 +682,7 @@ mod content {\n \n         fn visit_seq<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n         where\n-            V: SeqVisitor<'de>,\n+            V: SeqAccess<'de>,\n         {\n             ContentVisitor\n                 .visit_seq(visitor)\n@@ -691,7 +691,7 @@ mod content {\n \n         fn visit_map<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n         where\n-            V: MapVisitor<'de>,\n+            V: MapAccess<'de>,\n         {\n             ContentVisitor\n                 .visit_map(visitor)\n@@ -700,7 +700,7 @@ mod content {\n \n         fn visit_enum<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n         where\n-            V: EnumVisitor<'de>,\n+            V: EnumAccess<'de>,\n         {\n             ContentVisitor\n                 .visit_enum(visitor)\n@@ -761,21 +761,21 @@ mod content {\n \n         fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n         where\n-            V: MapVisitor<'de>,\n+            V: MapAccess<'de>,\n         {\n             let mut tag = None;\n             let mut vec = Vec::with_capacity(cmp::min(visitor.size_hint().0, 4096));\n             while let Some(k) =\n-                try!(visitor.visit_key_seed(TagOrContentVisitor::new(self.tag_name))) {\n+                try!(visitor.next_key_seed(TagOrContentVisitor::new(self.tag_name))) {\n                 match k {\n                     TagOrContent::Tag => {\n                         if tag.is_some() {\n                             return Err(de::Error::duplicate_field(self.tag_name));\n                         }\n-                        tag = Some(try!(visitor.visit_value()));\n+                        tag = Some(try!(visitor.next_value()));\n                     }\n                     TagOrContent::Content(k) => {\n-                        let v = try!(visitor.visit_value());\n+                        let v = try!(visitor.next_value());\n                         vec.push((k, v));\n                     }\n                 }\n@@ -995,14 +995,14 @@ mod content {\n         err: PhantomData<E>,\n     }\n \n-    impl<'de, E> de::EnumVisitor<'de> for EnumDeserializer<E>\n+    impl<'de, E> de::EnumAccess<'de> for EnumDeserializer<E>\n     where\n         E: de::Error,\n     {\n         type Error = E;\n         type Variant = VariantDeserializer<Self::Error>;\n \n-        fn visit_variant_seed<V>(\n+        fn variant_seed<V>(\n             self,\n             seed: V,\n         ) -> Result<(V::Value, VariantDeserializer<E>), Self::Error>\n@@ -1026,20 +1026,20 @@ mod content {\n         err: PhantomData<E>,\n     }\n \n-    impl<'de, E> de::VariantVisitor<'de> for VariantDeserializer<E>\n+    impl<'de, E> de::VariantAccess<'de> for VariantDeserializer<E>\n     where\n         E: de::Error,\n     {\n         type Error = E;\n \n-        fn visit_unit(self) -> Result<(), E> {\n+        fn deserialize_unit(self) -> Result<(), E> {\n             match self.value {\n                 Some(value) => de::Deserialize::deserialize(ContentDeserializer::new(value)),\n                 None => Ok(()),\n             }\n         }\n \n-        fn visit_newtype_seed<T>(self, seed: T) -> Result<T::Value, E>\n+        fn deserialize_newtype_seed<T>(self, seed: T) -> Result<T::Value, E>\n         where\n             T: de::DeserializeSeed<'de>,\n         {\n@@ -1051,7 +1051,7 @@ mod content {\n             }\n         }\n \n-        fn visit_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error>\n+        fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error>\n         where\n             V: de::Visitor<'de>,\n         {\n@@ -1064,7 +1064,7 @@ mod content {\n             }\n         }\n \n-        fn visit_struct<V>(\n+        fn deserialize_struct<V>(\n             self,\n             _fields: &'static [&'static str],\n             visitor: V,\n@@ -1134,13 +1134,13 @@ mod content {\n         }\n     }\n \n-    impl<'de, E> de::SeqVisitor<'de> for SeqDeserializer<E>\n+    impl<'de, E> de::SeqAccess<'de> for SeqDeserializer<E>\n     where\n         E: de::Error,\n     {\n         type Error = E;\n \n-        fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+        fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n         where\n             T: de::DeserializeSeed<'de>,\n         {\n@@ -1180,13 +1180,13 @@ mod content {\n         }\n     }\n \n-    impl<'de, E> de::MapVisitor<'de> for MapDeserializer<E>\n+    impl<'de, E> de::MapAccess<'de> for MapDeserializer<E>\n     where\n         E: de::Error,\n     {\n         type Error = E;\n \n-        fn visit_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+        fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n         where\n             T: de::DeserializeSeed<'de>,\n         {\n@@ -1199,7 +1199,7 @@ mod content {\n             }\n         }\n \n-        fn visit_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n+        fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n         where\n             T: de::DeserializeSeed<'de>,\n         {\n@@ -1391,14 +1391,14 @@ mod content {\n         err: PhantomData<E>,\n     }\n \n-    impl<'de, 'a, E> de::EnumVisitor<'de> for EnumRefDeserializer<'a, E>\n+    impl<'de, 'a, E> de::EnumAccess<'de> for EnumRefDeserializer<'a, E>\n     where\n         E: de::Error,\n     {\n         type Error = E;\n         type Variant = VariantRefDeserializer<'a, Self::Error>;\n \n-        fn visit_variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n+        fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n         where\n             V: de::DeserializeSeed<'de>,\n         {\n@@ -1419,20 +1419,20 @@ mod content {\n         err: PhantomData<E>,\n     }\n \n-    impl<'de, 'a, E> de::VariantVisitor<'de> for VariantRefDeserializer<'a, E>\n+    impl<'de, 'a, E> de::VariantAccess<'de> for VariantRefDeserializer<'a, E>\n     where\n         E: de::Error,\n     {\n         type Error = E;\n \n-        fn visit_unit(self) -> Result<(), E> {\n+        fn deserialize_unit(self) -> Result<(), E> {\n             match self.value {\n                 Some(value) => de::Deserialize::deserialize(ContentRefDeserializer::new(value)),\n                 None => Ok(()),\n             }\n         }\n \n-        fn visit_newtype_seed<T>(self, seed: T) -> Result<T::Value, E>\n+        fn deserialize_newtype_seed<T>(self, seed: T) -> Result<T::Value, E>\n         where\n             T: de::DeserializeSeed<'de>,\n         {\n@@ -1444,7 +1444,7 @@ mod content {\n             }\n         }\n \n-        fn visit_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error>\n+        fn deserialize_tuple<V>(self, _len: usize, visitor: V) -> Result<V::Value, Self::Error>\n         where\n             V: de::Visitor<'de>,\n         {\n@@ -1457,7 +1457,7 @@ mod content {\n             }\n         }\n \n-        fn visit_struct<V>(\n+        fn deserialize_struct<V>(\n             self,\n             _fields: &'static [&'static str],\n             visitor: V,\n@@ -1527,13 +1527,13 @@ mod content {\n         }\n     }\n \n-    impl<'de, 'a, E> de::SeqVisitor<'de> for SeqRefDeserializer<'a, E>\n+    impl<'de, 'a, E> de::SeqAccess<'de> for SeqRefDeserializer<'a, E>\n     where\n         E: de::Error,\n     {\n         type Error = E;\n \n-        fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+        fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n         where\n             T: de::DeserializeSeed<'de>,\n         {\n@@ -1573,13 +1573,13 @@ mod content {\n         }\n     }\n \n-    impl<'de, 'a, E> de::MapVisitor<'de> for MapRefDeserializer<'a, E>\n+    impl<'de, 'a, E> de::MapAccess<'de> for MapRefDeserializer<'a, E>\n     where\n         E: de::Error,\n     {\n         type Error = E;\n \n-        fn visit_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+        fn next_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n         where\n             T: de::DeserializeSeed<'de>,\n         {\n@@ -1593,7 +1593,7 @@ mod content {\n             }\n         }\n \n-        fn visit_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n+        fn next_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n         where\n             T: de::DeserializeSeed<'de>,\n         {\n@@ -1678,7 +1678,7 @@ mod content {\n \n         fn visit_map<V>(self, _: V) -> Result<(), V::Error>\n         where\n-            V: MapVisitor<'de>,\n+            V: MapAccess<'de>,\n         {\n             Ok(())\n         }\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 6d07458d7..994b9a9ba 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -292,7 +292,7 @@ fn deserialize_tuple(\n     let dispatch = if let Some(deserializer) = deserializer {\n         quote!(_serde::Deserializer::deserialize_tuple(#deserializer, #nfields, #visitor_expr))\n     } else if is_enum {\n-        quote!(_serde::de::VariantVisitor::visit_tuple(__visitor, #nfields, #visitor_expr))\n+        quote!(_serde::de::VariantAccess::deserialize_tuple(__variant, #nfields, #visitor_expr))\n     } else if nfields == 1 {\n         let type_name = item_attrs.name().deserialize_name();\n         quote!(_serde::Deserializer::deserialize_newtype_struct(__deserializer, #type_name, #visitor_expr))\n@@ -307,7 +307,7 @@ fn deserialize_tuple(\n     let visitor_var = if all_skipped {\n         quote!(_)\n     } else {\n-        quote!(mut __visitor)\n+        quote!(mut __seq)\n     };\n \n     quote_block! {\n@@ -326,8 +326,8 @@ fn deserialize_tuple(\n             #visit_newtype_struct\n \n             #[inline]\n-            fn visit_seq<__V>(self, #visitor_var: __V) -> _serde::export::Result<Self::Value, __V::Error>\n-                where __V: _serde::de::SeqVisitor<'de>\n+            fn visit_seq<__A>(self, #visitor_var: __A) -> _serde::export::Result<Self::Value, __A::Error>\n+                where __A: _serde::de::SeqAccess<'de>\n             {\n                 #visit_seq\n             }\n@@ -364,7 +364,7 @@ fn deserialize_seq(\n                 let visit = match field.attrs.deserialize_with() {\n                     None => {\n                         let field_ty = &field.ty;\n-                        quote!(try!(_serde::de::SeqVisitor::visit::<#field_ty>(&mut __visitor)))\n+                        quote!(try!(_serde::de::SeqAccess::next_element::<#field_ty>(&mut __seq)))\n                     }\n                     Some(path) => {\n                         let (wrapper, wrapper_ty) = wrap_deserialize_with(\n@@ -372,7 +372,7 @@ fn deserialize_seq(\n                         quote!({\n                             #wrapper\n                             _serde::export::Option::map(\n-                                try!(_serde::de::SeqVisitor::visit::<#wrapper_ty>(&mut __visitor)),\n+                                try!(_serde::de::SeqAccess::next_element::<#wrapper_ty>(&mut __seq)),\n                                 |__wrap| __wrap.value)\n                         })\n                     }\n@@ -501,7 +501,7 @@ fn deserialize_struct(\n         }\n     } else if is_enum {\n         quote! {\n-            _serde::de::VariantVisitor::visit_struct(__visitor, FIELDS, #visitor_expr)\n+            _serde::de::VariantAccess::deserialize_struct(__variant, FIELDS, #visitor_expr)\n         }\n     } else {\n         let type_name = item_attrs.name().deserialize_name();\n@@ -516,7 +516,7 @@ fn deserialize_struct(\n     let visitor_var = if all_skipped {\n         quote!(_)\n     } else {\n-        quote!(mut __visitor)\n+        quote!(mut __seq)\n     };\n \n     let visit_seq = if is_untagged {\n@@ -525,8 +525,8 @@ fn deserialize_struct(\n     } else {\n         Some(quote! {\n             #[inline]\n-            fn visit_seq<__V>(self, #visitor_var: __V) -> _serde::export::Result<Self::Value, __V::Error>\n-                where __V: _serde::de::SeqVisitor<'de>\n+            fn visit_seq<__A>(self, #visitor_var: __A) -> _serde::export::Result<Self::Value, __A::Error>\n+                where __A: _serde::de::SeqAccess<'de>\n             {\n                 #visit_seq\n             }\n@@ -551,8 +551,8 @@ fn deserialize_struct(\n             #visit_seq\n \n             #[inline]\n-            fn visit_map<__V>(self, mut __visitor: __V) -> _serde::export::Result<Self::Value, __V::Error>\n-                where __V: _serde::de::MapVisitor<'de>\n+            fn visit_map<__A>(self, mut __map: __A) -> _serde::export::Result<Self::Value, __A::Error>\n+                where __A: _serde::de::MapAccess<'de>\n             {\n                 #visit_map\n             }\n@@ -624,7 +624,7 @@ fn deserialize_externally_tagged_enum(\n                         Match(deserialize_externally_tagged_variant(params, variant, item_attrs),);\n \n                     quote! {\n-                (__Field::#variant_name, __visitor) => #block\n+                (__Field::#variant_name, __variant) => #block\n             }\n                 },\n             );\n@@ -637,15 +637,15 @@ fn deserialize_externally_tagged_enum(\n         // all variants have `#[serde(skip_deserializing)]`.\n         quote! {\n             // FIXME: Once we drop support for Rust 1.15:\n-            // let _serde::export::Err(__err) = _serde::de::EnumVisitor::visit_variant::<__Field>(__visitor);\n+            // let _serde::export::Err(__err) = _serde::de::EnumAccess::variant::<__Field>(__data);\n             // _serde::export::Err(__err)\n             _serde::export::Result::map(\n-                _serde::de::EnumVisitor::visit_variant::<__Field>(__visitor),\n+                _serde::de::EnumAccess::variant::<__Field>(__data),\n                 |(__impossible, _)| match __impossible {})\n         }\n     } else {\n         quote! {\n-            match try!(_serde::de::EnumVisitor::visit_variant(__visitor)) {\n+            match try!(_serde::de::EnumAccess::variant(__data)) {\n                 #(#variant_arms)*\n             }\n         }\n@@ -666,8 +666,8 @@ fn deserialize_externally_tagged_enum(\n                 _serde::export::Formatter::write_str(formatter, #expecting)\n             }\n \n-            fn visit_enum<__V>(self, __visitor: __V) -> _serde::export::Result<Self::Value, __V::Error>\n-                where __V: _serde::de::EnumVisitor<'de>\n+            fn visit_enum<__A>(self, __data: __A) -> _serde::export::Result<Self::Value, __A::Error>\n+                where __A: _serde::de::EnumAccess<'de>\n             {\n                 #match_variant\n             }\n@@ -807,7 +807,7 @@ fn deserialize_adjacently_tagged_enum(\n     }\n \n     let mut missing_content = quote! {\n-        _serde::export::Err(<__V::Error as _serde::de::Error>::missing_field(#content))\n+        _serde::export::Err(<__A::Error as _serde::de::Error>::missing_field(#content))\n     };\n     if variants.iter().any(is_unit) {\n         let fallthrough = if variants.iter().all(is_unit) {\n@@ -842,12 +842,12 @@ fn deserialize_adjacently_tagged_enum(\n \n     let visit_third_key = quote! {\n         // Visit the third key in the map, hopefully there isn't one.\n-        match try!(_serde::de::MapVisitor::visit_key_seed(&mut __visitor, #tag_or_content)) {\n+        match try!(_serde::de::MapAccess::next_key_seed(&mut __map, #tag_or_content)) {\n             _serde::export::Some(_serde::private::de::TagOrContentField::Tag) => {\n-                _serde::export::Err(<__V::Error as _serde::de::Error>::duplicate_field(#tag))\n+                _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#tag))\n             }\n             _serde::export::Some(_serde::private::de::TagOrContentField::Content) => {\n-                _serde::export::Err(<__V::Error as _serde::de::Error>::duplicate_field(#content))\n+                _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#content))\n             }\n             _serde::export::None => _serde::export::Ok(__ret),\n         }\n@@ -888,24 +888,24 @@ fn deserialize_adjacently_tagged_enum(\n                 _serde::export::Formatter::write_str(formatter, #expecting)\n             }\n \n-            fn visit_map<__V>(self, mut __visitor: __V) -> _serde::export::Result<Self::Value, __V::Error>\n-                where __V: _serde::de::MapVisitor<'de>\n+            fn visit_map<__A>(self, mut __map: __A) -> _serde::export::Result<Self::Value, __A::Error>\n+                where __A: _serde::de::MapAccess<'de>\n             {\n                 // Visit the first key.\n-                match try!(_serde::de::MapVisitor::visit_key_seed(&mut __visitor, #tag_or_content)) {\n+                match try!(_serde::de::MapAccess::next_key_seed(&mut __map, #tag_or_content)) {\n                     // First key is the tag.\n                     _serde::export::Some(_serde::private::de::TagOrContentField::Tag) => {\n                         // Parse the tag.\n-                        let __field = try!(_serde::de::MapVisitor::visit_value(&mut __visitor));\n+                        let __field = try!(_serde::de::MapAccess::next_value(&mut __map));\n                         // Visit the second key.\n-                        match try!(_serde::de::MapVisitor::visit_key_seed(&mut __visitor, #tag_or_content)) {\n+                        match try!(_serde::de::MapAccess::next_key_seed(&mut __map, #tag_or_content)) {\n                             // Second key is a duplicate of the tag.\n                             _serde::export::Some(_serde::private::de::TagOrContentField::Tag) => {\n-                                _serde::export::Err(<__V::Error as _serde::de::Error>::duplicate_field(#tag))\n+                                _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#tag))\n                             }\n                             // Second key is the content.\n                             _serde::export::Some(_serde::private::de::TagOrContentField::Content) => {\n-                                let __ret = try!(_serde::de::MapVisitor::visit_value_seed(&mut __visitor,\n+                                let __ret = try!(_serde::de::MapAccess::next_value_seed(&mut __map,\n                                     __Seed {\n                                         field: __field,\n                                         marker: _serde::export::PhantomData,\n@@ -921,14 +921,14 @@ fn deserialize_adjacently_tagged_enum(\n                     // First key is the content.\n                     _serde::export::Some(_serde::private::de::TagOrContentField::Content) => {\n                         // Buffer up the content.\n-                        let __content = try!(_serde::de::MapVisitor::visit_value::<_serde::private::de::Content>(&mut __visitor));\n+                        let __content = try!(_serde::de::MapAccess::next_value::<_serde::private::de::Content>(&mut __map));\n                         // Visit the second key.\n-                        match try!(_serde::de::MapVisitor::visit_key_seed(&mut __visitor, #tag_or_content)) {\n+                        match try!(_serde::de::MapAccess::next_key_seed(&mut __map, #tag_or_content)) {\n                             // Second key is the tag.\n                             _serde::export::Some(_serde::private::de::TagOrContentField::Tag) => {\n-                                let __deserializer = _serde::private::de::ContentDeserializer::<__V::Error>::new(__content);\n+                                let __deserializer = _serde::private::de::ContentDeserializer::<__A::Error>::new(__content);\n                                 // Parse the tag.\n-                                let __ret = try!(match try!(_serde::de::MapVisitor::visit_value(&mut __visitor)) {\n+                                let __ret = try!(match try!(_serde::de::MapAccess::next_value(&mut __map)) {\n                                     // Deserialize the buffered content now that we know the variant.\n                                     #(#variant_arms)*\n                                 });\n@@ -937,29 +937,29 @@ fn deserialize_adjacently_tagged_enum(\n                             }\n                             // Second key is a duplicate of the content.\n                             _serde::export::Some(_serde::private::de::TagOrContentField::Content) => {\n-                                _serde::export::Err(<__V::Error as _serde::de::Error>::duplicate_field(#content))\n+                                _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#content))\n                             }\n                             // There is no second key.\n                             _serde::export::None => {\n-                                _serde::export::Err(<__V::Error as _serde::de::Error>::missing_field(#tag))\n+                                _serde::export::Err(<__A::Error as _serde::de::Error>::missing_field(#tag))\n                             }\n                         }\n                     }\n                     // There is no first key.\n                     _serde::export::None => {\n-                        _serde::export::Err(<__V::Error as _serde::de::Error>::missing_field(#tag))\n+                        _serde::export::Err(<__A::Error as _serde::de::Error>::missing_field(#tag))\n                     }\n                 }\n             }\n \n-            fn visit_seq<__V>(self, mut __visitor: __V) -> _serde::export::Result<Self::Value, __V::Error>\n-                where __V: _serde::de::SeqVisitor<'de>\n+            fn visit_seq<__A>(self, mut __seq: __A) -> _serde::export::Result<Self::Value, __A::Error>\n+                where __A: _serde::de::SeqAccess<'de>\n             {\n                 // Visit the first element - the tag.\n-                match try!(_serde::de::SeqVisitor::visit(&mut __visitor)) {\n+                match try!(_serde::de::SeqAccess::next_element(&mut __seq)) {\n                     _serde::export::Some(__field) => {\n                         // Visit the second element - the content.\n-                        match try!(_serde::de::SeqVisitor::visit_seed(&mut __visitor,\n+                        match try!(_serde::de::SeqAccess::next_element_seed(&mut __seq,\n                                 __Seed {\n                                     field: __field,\n                                     marker: _serde::export::PhantomData,\n@@ -1041,7 +1041,7 @@ fn deserialize_externally_tagged_variant(\n         Style::Unit => {\n             let this = &params.this;\n             quote_block! {\n-                try!(_serde::de::VariantVisitor::visit_unit(__visitor));\n+                try!(_serde::de::VariantAccess::deserialize_unit(__variant));\n                 _serde::export::Ok(#this::#variant_ident)\n             }\n         }\n@@ -1156,7 +1156,7 @@ fn deserialize_externally_tagged_newtype_variant(\n             let field_ty = &field.ty;\n             quote_expr! {\n                 _serde::export::Result::map(\n-                    _serde::de::VariantVisitor::visit_newtype::<#field_ty>(__visitor),\n+                    _serde::de::VariantAccess::deserialize_newtype::<#field_ty>(__variant),\n                     #this::#variant_ident)\n             }\n         }\n@@ -1165,7 +1165,7 @@ fn deserialize_externally_tagged_newtype_variant(\n             quote_block! {\n                 #wrapper\n                 _serde::export::Result::map(\n-                    _serde::de::VariantVisitor::visit_newtype::<#wrapper_ty>(__visitor),\n+                    _serde::de::VariantAccess::deserialize_newtype::<#wrapper_ty>(__variant),\n                     |__wrapper| #this::#variant_ident(__wrapper.value))\n             }\n         }\n@@ -1380,7 +1380,7 @@ fn deserialize_map(\n                 None => {\n                     let field_ty = &field.ty;\n                     quote! {\n-                        try!(_serde::de::MapVisitor::visit_value::<#field_ty>(&mut __visitor))\n+                        try!(_serde::de::MapAccess::next_value::<#field_ty>(&mut __map))\n                     }\n                 }\n                 Some(path) => {\n@@ -1388,14 +1388,14 @@ fn deserialize_map(\n                         params, field.ty, path);\n                     quote!({\n                         #wrapper\n-                        try!(_serde::de::MapVisitor::visit_value::<#wrapper_ty>(&mut __visitor)).value\n+                        try!(_serde::de::MapAccess::next_value::<#wrapper_ty>(&mut __map)).value\n                     })\n                 }\n             };\n             quote! {\n                 __Field::#name => {\n                     if _serde::export::Option::is_some(&#name) {\n-                        return _serde::export::Err(<__V::Error as _serde::de::Error>::duplicate_field(#deser_name));\n+                        return _serde::export::Err(<__A::Error as _serde::de::Error>::duplicate_field(#deser_name));\n                     }\n                     #name = _serde::export::Some(#visit);\n                 }\n@@ -1407,7 +1407,7 @@ fn deserialize_map(\n         None\n     } else {\n         Some(quote! {\n-            _ => { let _ = try!(_serde::de::MapVisitor::visit_value::<_serde::de::IgnoredAny>(&mut __visitor)); }\n+            _ => { let _ = try!(_serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)); }\n         })\n     };\n \n@@ -1417,14 +1417,14 @@ fn deserialize_map(\n     let match_keys = if item_attrs.deny_unknown_fields() && all_skipped {\n         quote! {\n             // FIXME: Once we drop support for Rust 1.15:\n-            // let _serde::export::None::<__Field> = try!(_serde::de::MapVisitor::visit_key(&mut __visitor));\n+            // let _serde::export::None::<__Field> = try!(_serde::de::MapAccess::next_key(&mut __map));\n             _serde::export::Option::map(\n-                try!(_serde::de::MapVisitor::visit_key::<__Field>(&mut __visitor)),\n+                try!(_serde::de::MapAccess::next_key::<__Field>(&mut __map)),\n                 |__impossible| match __impossible {});\n         }\n     } else {\n         quote! {\n-            while let _serde::export::Some(__key) = try!(_serde::de::MapVisitor::visit_key::<__Field>(&mut __visitor)) {\n+            while let _serde::export::Some(__key) = try!(_serde::de::MapAccess::next_key::<__Field>(&mut __map)) {\n                 match __key {\n                     #(#value_arms)*\n                     #ignored_arm\n@@ -1577,7 +1577,7 @@ fn expr_is_missing(field: &Field, item_attrs: &attr::Item) -> Fragment {\n         }\n         Some(_) => {\n             quote_expr! {\n-                return _serde::export::Err(<__V::Error as _serde::de::Error>::missing_field(#name))\n+                return _serde::export::Err(<__A::Error as _serde::de::Error>::missing_field(#name))\n             }\n         }\n     }\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex c30f6e273..b6ce5725b 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -6,8 +6,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use serde::de::{self, Deserialize, DeserializeSeed, EnumVisitor, IntoDeserializer, MapVisitor,\n-                SeqVisitor, VariantVisitor, Visitor};\n+use serde::de::{self, Deserialize, DeserializeSeed, EnumAccess, IntoDeserializer, MapAccess,\n+                SeqAccess, VariantAccess, Visitor};\n use serde::de::value::{MapVisitorDeserializer, SeqVisitorDeserializer};\n \n use error::Error;\n@@ -390,10 +390,10 @@ struct DeserializerSeqVisitor<'a, 'de: 'a> {\n     end: Token,\n }\n \n-impl<'de, 'a> SeqVisitor<'de> for DeserializerSeqVisitor<'a, 'de> {\n+impl<'de, 'a> SeqAccess<'de> for DeserializerSeqVisitor<'a, 'de> {\n     type Error = Error;\n \n-    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n+    fn next_element_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n     where\n         T: DeserializeSeed<'de>,\n     {\n@@ -418,10 +418,10 @@ struct DeserializerMapVisitor<'a, 'de: 'a> {\n     end: Token,\n }\n \n-impl<'de, 'a> MapVisitor<'de> for DeserializerMapVisitor<'a, 'de> {\n+impl<'de, 'a> MapAccess<'de> for DeserializerMapVisitor<'a, 'de> {\n     type Error = Error;\n \n-    fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n+    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n     where\n         K: DeserializeSeed<'de>,\n     {\n@@ -432,7 +432,7 @@ impl<'de, 'a> MapVisitor<'de> for DeserializerMapVisitor<'a, 'de> {\n         seed.deserialize(&mut *self.de).map(Some)\n     }\n \n-    fn visit_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n+    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n     where\n         V: DeserializeSeed<'de>,\n     {\n@@ -451,11 +451,11 @@ struct DeserializerEnumVisitor<'a, 'de: 'a> {\n     de: &'a mut Deserializer<'de>,\n }\n \n-impl<'de, 'a> EnumVisitor<'de> for DeserializerEnumVisitor<'a, 'de> {\n+impl<'de, 'a> EnumAccess<'de> for DeserializerEnumVisitor<'a, 'de> {\n     type Error = Error;\n     type Variant = Self;\n \n-    fn visit_variant_seed<V>(self, seed: V) -> Result<(V::Value, Self), Error>\n+    fn variant_seed<V>(self, seed: V) -> Result<(V::Value, Self), Error>\n     where\n         V: DeserializeSeed<'de>,\n     {\n@@ -477,10 +477,10 @@ impl<'de, 'a> EnumVisitor<'de> for DeserializerEnumVisitor<'a, 'de> {\n     }\n }\n \n-impl<'de, 'a> VariantVisitor<'de> for DeserializerEnumVisitor<'a, 'de> {\n+impl<'de, 'a> VariantAccess<'de> for DeserializerEnumVisitor<'a, 'de> {\n     type Error = Error;\n \n-    fn visit_unit(self) -> Result<(), Error> {\n+    fn deserialize_unit(self) -> Result<(), Error> {\n         match self.de.tokens.first() {\n             Some(&Token::UnitVariant(_, _)) => {\n                 self.de.next_token();\n@@ -491,7 +491,7 @@ impl<'de, 'a> VariantVisitor<'de> for DeserializerEnumVisitor<'a, 'de> {\n         }\n     }\n \n-    fn visit_newtype_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n+    fn deserialize_newtype_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n     where\n         T: DeserializeSeed<'de>,\n     {\n@@ -505,7 +505,7 @@ impl<'de, 'a> VariantVisitor<'de> for DeserializerEnumVisitor<'a, 'de> {\n         }\n     }\n \n-    fn visit_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Error>\n+    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Error>\n     where\n         V: Visitor<'de>,\n     {\n@@ -534,7 +534,7 @@ impl<'de, 'a> VariantVisitor<'de> for DeserializerEnumVisitor<'a, 'de> {\n         }\n     }\n \n-    fn visit_struct<V>(self, fields: &'static [&'static str], visitor: V) -> Result<V::Value, Error>\n+    fn deserialize_struct<V>(self, fields: &'static [&'static str], visitor: V) -> Result<V::Value, Error>\n     where\n         V: Visitor<'de>,\n     {\n@@ -589,10 +589,10 @@ impl<'a, 'de> EnumMapVisitor<'a, 'de> {\n     }\n }\n \n-impl<'de, 'a> MapVisitor<'de> for EnumMapVisitor<'a, 'de> {\n+impl<'de, 'a> MapAccess<'de> for EnumMapVisitor<'a, 'de> {\n     type Error = Error;\n \n-    fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n+    fn next_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n     where\n         K: DeserializeSeed<'de>,\n     {\n@@ -608,7 +608,7 @@ impl<'de, 'a> MapVisitor<'de> for EnumMapVisitor<'a, 'de> {\n         }\n     }\n \n-    fn visit_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n+    fn next_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n     where\n         V: DeserializeSeed<'de>,\n     {\n", "problem_statement": "Rename Seq/Map/Enum/VariantVisitor\nPossible new names:\r\n\r\n- `serde::de::SeqAccess`\r\n- `serde::de::MapAccess`\r\n- `serde::de::EnumAccess`\r\n- `serde::de::VariantAccess`\r\n\r\nI dislike that Visitor and SeqVisitor are both \"visitors\" but one of them is the responsibility of the data structure and the other is the responsibility of the data format. I have seen this trip people up where they aren't sure which one(s) they need to implement. I believe the current naming scheme is unhelpful.\r\n\r\nConceptually the only thing doing any visiting is the data structure's Visitor. The SeqVisitor etc have never been visitors but are providing access to the data contained inside a seq/map/enum/variant.\r\n\r\nWith the new scheme the data structure would be responsible for providing Deserialize(..) and Visitor, while the data format would be responsible for providing Deserializer and (..)Access.\r\n\r\nThoughts @oli-obk @nox?\n", "hints_text": "Trait naming could use some guidelines - https://github.com/brson/rust-api-guidelines/issues/28.", "created_at": "2017-04-14T19:15:57Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 869, "instance_id": "serde-rs__serde-869", "issue_numbers": ["867"], "base_commit": "aed5a77540cda0365d245621876f69058445b7a3", "patch": "diff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 7e0404900..06ae2e451 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -1658,6 +1658,17 @@ pub trait VariantVisitor<'de>: Sized {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+/// This trait converts primitive types into a deserializer.\n+pub trait IntoDeserializer<'de, E: Error = value::Error> {\n+    /// The actual deserializer type.\n+    type Deserializer: Deserializer<'de, Error = E>;\n+\n+    /// Convert this value into a deserializer.\n+    fn into_deserializer(self) -> Self::Deserializer;\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n /// Used in error messages.\n ///\n /// - expected `a`\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 5a261334e..83e50a56f 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -2,7 +2,7 @@\n \n use lib::*;\n \n-use de::{self, Expected, SeqVisitor};\n+use de::{self, IntoDeserializer, Expected, SeqVisitor};\n \n ///////////////////////////////////////////////////////////////////////////////\n \n@@ -50,18 +50,7 @@ impl error::Error for Error {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-/// This trait converts primitive types into a deserializer.\n-pub trait ValueDeserializer<'de, E: de::Error = Error> {\n-    /// The actual deserializer type.\n-    type Deserializer: de::Deserializer<'de, Error = E>;\n-\n-    /// Convert this value into a deserializer.\n-    fn into_deserializer(self) -> Self::Deserializer;\n-}\n-\n-///////////////////////////////////////////////////////////////////////////////\n-\n-impl<'de, E> ValueDeserializer<'de, E> for ()\n+impl<'de, E> IntoDeserializer<'de, E> for ()\n     where E: de::Error\n {\n     type Deserializer = UnitDeserializer<E>;\n@@ -110,7 +99,7 @@ macro_rules! primitive_deserializer {\n             marker: PhantomData<E>\n         }\n \n-        impl<'de, E> ValueDeserializer<'de, E> for $ty\n+        impl<'de, E> IntoDeserializer<'de, E> for $ty\n             where E: de::Error,\n         {\n             type Deserializer = $name<E>;\n@@ -163,7 +152,7 @@ pub struct U32Deserializer<E> {\n     marker: PhantomData<E>,\n }\n \n-impl<'de, E> ValueDeserializer<'de, E> for u32\n+impl<'de, E> IntoDeserializer<'de, E> for u32\n     where E: de::Error\n {\n     type Deserializer = U32Deserializer<E>;\n@@ -225,7 +214,7 @@ pub struct StrDeserializer<'a, E> {\n     marker: PhantomData<E>,\n }\n \n-impl<'de, 'a, E> ValueDeserializer<'de, E> for &'a str\n+impl<'de, 'a, E> IntoDeserializer<'de, E> for &'a str\n     where E: de::Error\n {\n     type Deserializer = StrDeserializer<'a, E>;\n@@ -289,7 +278,7 @@ pub struct StringDeserializer<E> {\n }\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-impl<'de, E> ValueDeserializer<'de, E> for String\n+impl<'de, E> IntoDeserializer<'de, E> for String\n     where E: de::Error\n {\n     type Deserializer = StringDeserializer<E>;\n@@ -355,7 +344,7 @@ pub struct CowStrDeserializer<'a, E> {\n }\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-impl<'de, 'a, E> ValueDeserializer<'de, E> for Cow<'a, str>\n+impl<'de, 'a, E> IntoDeserializer<'de, E> for Cow<'a, str>\n     where E: de::Error\n {\n     type Deserializer = CowStrDeserializer<'a, E>;\n@@ -455,7 +444,7 @@ impl<I, E> SeqDeserializer<I, E>\n \n impl<'de, I, T, E> de::Deserializer<'de> for SeqDeserializer<I, E>\n     where I: Iterator<Item = T>,\n-          T: ValueDeserializer<'de, E>,\n+          T: IntoDeserializer<'de, E>,\n           E: de::Error\n {\n     type Error = E;\n@@ -477,7 +466,7 @@ impl<'de, I, T, E> de::Deserializer<'de> for SeqDeserializer<I, E>\n \n impl<'de, I, T, E> de::SeqVisitor<'de> for SeqDeserializer<I, E>\n     where I: Iterator<Item = T>,\n-          T: ValueDeserializer<'de, E>,\n+          T: IntoDeserializer<'de, E>,\n           E: de::Error\n {\n     type Error = E;\n@@ -514,8 +503,8 @@ impl Expected for ExpectedInSeq {\n ///////////////////////////////////////////////////////////////////////////////\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-impl<'de, T, E> ValueDeserializer<'de, E> for Vec<T>\n-    where T: ValueDeserializer<'de, E>,\n+impl<'de, T, E> IntoDeserializer<'de, E> for Vec<T>\n+    where T: IntoDeserializer<'de, E>,\n           E: de::Error\n {\n     type Deserializer = SeqDeserializer<<Vec<T> as IntoIterator>::IntoIter, E>;\n@@ -526,8 +515,8 @@ impl<'de, T, E> ValueDeserializer<'de, E> for Vec<T>\n }\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-impl<'de, T, E> ValueDeserializer<'de, E> for BTreeSet<T>\n-    where T: ValueDeserializer<'de, E> + Eq + Ord,\n+impl<'de, T, E> IntoDeserializer<'de, E> for BTreeSet<T>\n+    where T: IntoDeserializer<'de, E> + Eq + Ord,\n           E: de::Error\n {\n     type Deserializer = SeqDeserializer<<BTreeSet<T> as IntoIterator>::IntoIter, E>;\n@@ -538,8 +527,8 @@ impl<'de, T, E> ValueDeserializer<'de, E> for BTreeSet<T>\n }\n \n #[cfg(feature = \"std\")]\n-impl<'de, T, E> ValueDeserializer<'de, E> for HashSet<T>\n-    where T: ValueDeserializer<'de, E> + Eq + Hash,\n+impl<'de, T, E> IntoDeserializer<'de, E> for HashSet<T>\n+    where T: IntoDeserializer<'de, E> + Eq + Hash,\n           E: de::Error\n {\n     type Deserializer = SeqDeserializer<<HashSet<T> as IntoIterator>::IntoIter, E>;\n@@ -589,8 +578,8 @@ impl<'de, V_> de::Deserializer<'de> for SeqVisitorDeserializer<V_>\n pub struct MapDeserializer<'de, I, E>\n     where I: Iterator,\n           I::Item: private::Pair,\n-          <I::Item as private::Pair>::First: ValueDeserializer<'de, E>,\n-          <I::Item as private::Pair>::Second: ValueDeserializer<'de, E>,\n+          <I::Item as private::Pair>::First: IntoDeserializer<'de, E>,\n+          <I::Item as private::Pair>::Second: IntoDeserializer<'de, E>,\n           E: de::Error\n {\n     iter: iter::Fuse<I>,\n@@ -603,8 +592,8 @@ pub struct MapDeserializer<'de, I, E>\n impl<'de, I, E> MapDeserializer<'de, I, E>\n     where I: Iterator,\n           I::Item: private::Pair,\n-          <I::Item as private::Pair>::First: ValueDeserializer<'de, E>,\n-          <I::Item as private::Pair>::Second: ValueDeserializer<'de, E>,\n+          <I::Item as private::Pair>::First: IntoDeserializer<'de, E>,\n+          <I::Item as private::Pair>::Second: IntoDeserializer<'de, E>,\n           E: de::Error\n {\n     /// Construct a new `MapDeserializer<I, K, V, E>`.\n@@ -650,8 +639,8 @@ impl<'de, I, E> MapDeserializer<'de, I, E>\n impl<'de, I, E> de::Deserializer<'de> for MapDeserializer<'de, I, E>\n     where I: Iterator,\n           I::Item: private::Pair,\n-          <I::Item as private::Pair>::First: ValueDeserializer<'de, E>,\n-          <I::Item as private::Pair>::Second: ValueDeserializer<'de, E>,\n+          <I::Item as private::Pair>::First: IntoDeserializer<'de, E>,\n+          <I::Item as private::Pair>::Second: IntoDeserializer<'de, E>,\n           E: de::Error\n {\n     type Error = E;\n@@ -691,8 +680,8 @@ impl<'de, I, E> de::Deserializer<'de> for MapDeserializer<'de, I, E>\n impl<'de, I, E> de::MapVisitor<'de> for MapDeserializer<'de, I, E>\n     where I: Iterator,\n           I::Item: private::Pair,\n-          <I::Item as private::Pair>::First: ValueDeserializer<'de, E>,\n-          <I::Item as private::Pair>::Second: ValueDeserializer<'de, E>,\n+          <I::Item as private::Pair>::First: IntoDeserializer<'de, E>,\n+          <I::Item as private::Pair>::Second: IntoDeserializer<'de, E>,\n           E: de::Error\n {\n     type Error = E;\n@@ -744,8 +733,8 @@ impl<'de, I, E> de::MapVisitor<'de> for MapDeserializer<'de, I, E>\n impl<'de, I, E> de::SeqVisitor<'de> for MapDeserializer<'de, I, E>\n     where I: Iterator,\n           I::Item: private::Pair,\n-          <I::Item as private::Pair>::First: ValueDeserializer<'de, E>,\n-          <I::Item as private::Pair>::Second: ValueDeserializer<'de, E>,\n+          <I::Item as private::Pair>::First: IntoDeserializer<'de, E>,\n+          <I::Item as private::Pair>::Second: IntoDeserializer<'de, E>,\n           E: de::Error\n {\n     type Error = E;\n@@ -772,8 +761,8 @@ impl<'de, I, E> de::SeqVisitor<'de> for MapDeserializer<'de, I, E>\n struct PairDeserializer<A, B, E>(A, B, PhantomData<E>);\n \n impl<'de, A, B, E> de::Deserializer<'de> for PairDeserializer<A, B, E>\n-    where A: ValueDeserializer<'de, E>,\n-          B: ValueDeserializer<'de, E>,\n+    where A: IntoDeserializer<'de, E>,\n+          B: IntoDeserializer<'de, E>,\n           E: de::Error\n {\n     type Error = E;\n@@ -821,8 +810,8 @@ impl<'de, A, B, E> de::Deserializer<'de> for PairDeserializer<A, B, E>\n struct PairVisitor<A, B, E>(Option<A>, Option<B>, PhantomData<E>);\n \n impl<'de, A, B, E> de::SeqVisitor<'de> for PairVisitor<A, B, E>\n-    where A: ValueDeserializer<'de, E>,\n-          B: ValueDeserializer<'de, E>,\n+    where A: IntoDeserializer<'de, E>,\n+          B: IntoDeserializer<'de, E>,\n           E: de::Error\n {\n     type Error = E;\n@@ -866,9 +855,9 @@ impl Expected for ExpectedInMap {\n ///////////////////////////////////////////////////////////////////////////////\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-impl<'de, K, V, E> ValueDeserializer<'de, E> for BTreeMap<K, V>\n-    where K: ValueDeserializer<'de, E> + Eq + Ord,\n-          V: ValueDeserializer<'de, E>,\n+impl<'de, K, V, E> IntoDeserializer<'de, E> for BTreeMap<K, V>\n+    where K: IntoDeserializer<'de, E> + Eq + Ord,\n+          V: IntoDeserializer<'de, E>,\n           E: de::Error\n {\n     type Deserializer = MapDeserializer<'de, <BTreeMap<K, V> as IntoIterator>::IntoIter, E>;\n@@ -879,9 +868,9 @@ impl<'de, K, V, E> ValueDeserializer<'de, E> for BTreeMap<K, V>\n }\n \n #[cfg(feature = \"std\")]\n-impl<'de, K, V, E> ValueDeserializer<'de, E> for HashMap<K, V>\n-    where K: ValueDeserializer<'de, E> + Eq + Hash,\n-          V: ValueDeserializer<'de, E>,\n+impl<'de, K, V, E> IntoDeserializer<'de, E> for HashMap<K, V>\n+    where K: IntoDeserializer<'de, E> + Eq + Hash,\n+          V: IntoDeserializer<'de, E>,\n           E: de::Error\n {\n     type Deserializer = MapDeserializer<'de, <HashMap<K, V> as IntoIterator>::IntoIter, E>;\ndiff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex 394c72cb9..9d56071d3 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -1410,7 +1410,7 @@ mod content {\n         }\n     }\n \n-    impl<'de, E> de::value::ValueDeserializer<'de, E> for ContentDeserializer<E>\n+    impl<'de, E> de::IntoDeserializer<'de, E> for ContentDeserializer<E>\n         where E: de::Error\n     {\n         type Deserializer = Self;\n@@ -1420,7 +1420,7 @@ mod content {\n         }\n     }\n \n-    impl<'de, 'a, E> de::value::ValueDeserializer<'de, E> for ContentRefDeserializer<'a, E>\n+    impl<'de, 'a, E> de::IntoDeserializer<'de, E> for ContentRefDeserializer<'a, E>\n         where E: de::Error\n     {\n         type Deserializer = Self;\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 243c8eb68..75996fc59 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -1,6 +1,6 @@\n-use serde::de::{self, Deserialize, DeserializeSeed, EnumVisitor, MapVisitor, SeqVisitor,\n-                VariantVisitor, Visitor};\n-use serde::de::value::{ValueDeserializer, MapVisitorDeserializer, SeqVisitorDeserializer};\n+use serde::de::{self, Deserialize, DeserializeSeed, EnumVisitor, IntoDeserializer,\n+                MapVisitor, SeqVisitor, VariantVisitor, Visitor};\n+use serde::de::value::{MapVisitorDeserializer, SeqVisitorDeserializer};\n \n use error::Error;\n use token::Token;\ndiff --git a/test_suite/tests/test_value.rs b/test_suite/tests/test_value.rs\nindex fc4441632..08b1c3c3a 100644\n--- a/test_suite/tests/test_value.rs\n+++ b/test_suite/tests/test_value.rs\n@@ -3,7 +3,7 @@ extern crate serde_derive;\n \n extern crate serde;\n use serde::Deserialize;\n-use serde::de::value::{self, ValueDeserializer};\n+use serde::de::{value, IntoDeserializer};\n \n #[test]\n fn test_u32_to_enum() {\n@@ -13,7 +13,7 @@ fn test_u32_to_enum() {\n         B,\n     }\n \n-    let deserializer = ValueDeserializer::<value::Error>::into_deserializer(1u32);\n+    let deserializer = IntoDeserializer::<value::Error>::into_deserializer(1u32);\n     let e: E = E::deserialize(deserializer).unwrap();\n     assert_eq!(E::B, e);\n }\n", "problem_statement": "Rename ValueDeserializer trait to IntoDeserializer\nThis would be more consistent with IntoIterator, IntoFuture, etc.\n", "hints_text": "", "created_at": "2017-04-12T06:21:23Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 860, "instance_id": "serde-rs__serde-860", "issue_numbers": ["722"], "base_commit": "517270a9432d00eb755a89349f0d3931ed162844", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 597938127..ffe3291c5 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -1232,7 +1232,7 @@ impl<'de> Deserialize<'de> for Duration {\n                     }\n                 }\n \n-                deserializer.deserialize_struct_field(FieldVisitor)\n+                deserializer.deserialize_identifier(FieldVisitor)\n             }\n         }\n \n@@ -1358,7 +1358,7 @@ impl<'de, Idx: Deserialize<'de>> Deserialize<'de> for std::ops::Range<Idx> {\n                     }\n                 }\n \n-                deserializer.deserialize_struct_field(FieldVisitor)\n+                deserializer.deserialize_identifier(FieldVisitor)\n             }\n         }\n \ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 453a531bc..754fa12e7 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -911,8 +911,8 @@ pub trait Deserializer<'de>: Sized {\n         where V: Visitor<'de>;\n \n     /// Hint that the `Deserialize` type is expecting the name of a struct\n-    /// field.\n-    fn deserialize_struct_field<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+    /// field or the discriminant of an enum variant.\n+    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor<'de>;\n \n     /// Hint that the `Deserialize` type is expecting an enum value with a\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 3b157b0ca..1323450d6 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -108,7 +108,7 @@ impl<'de, E> de::Deserializer<'de> for UnitDeserializer<E>\n     forward_to_deserialize! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n         seq_fixed_size bytes map unit_struct newtype_struct tuple_struct struct\n-        struct_field tuple enum ignored_any byte_buf\n+        identifier tuple enum ignored_any byte_buf\n     }\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n@@ -155,7 +155,7 @@ macro_rules! primitive_deserializer {\n             forward_to_deserialize! {\n                 bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit\n                 option seq seq_fixed_size bytes map unit_struct newtype_struct\n-                tuple_struct struct struct_field tuple enum ignored_any byte_buf\n+                tuple_struct struct identifier tuple enum ignored_any byte_buf\n             }\n \n             fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n@@ -208,7 +208,7 @@ impl<'de, E> de::Deserializer<'de> for U32Deserializer<E>\n     forward_to_deserialize! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n-        struct struct_field tuple ignored_any byte_buf\n+        struct identifier tuple ignored_any byte_buf\n     }\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n@@ -286,7 +286,7 @@ impl<'de, 'a, E> de::Deserializer<'de> for StrDeserializer<'a, E>\n     forward_to_deserialize! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n-        struct struct_field tuple ignored_any byte_buf\n+        struct identifier tuple ignored_any byte_buf\n     }\n }\n \n@@ -351,7 +351,7 @@ impl<'de, E> de::Deserializer<'de> for StringDeserializer<E>\n     forward_to_deserialize! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n-        struct struct_field tuple ignored_any byte_buf\n+        struct identifier tuple ignored_any byte_buf\n     }\n }\n \n@@ -420,7 +420,7 @@ impl<'de, 'a, E> de::Deserializer<'de> for CowStrDeserializer<'a, E>\n     forward_to_deserialize! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n-        struct struct_field tuple ignored_any byte_buf\n+        struct identifier tuple ignored_any byte_buf\n     }\n }\n \n@@ -495,7 +495,7 @@ impl<'de, I, T, E> de::Deserializer<'de> for SeqDeserializer<I, E>\n     forward_to_deserialize! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n-        struct struct_field tuple enum ignored_any byte_buf\n+        struct identifier tuple enum ignored_any byte_buf\n     }\n }\n \n@@ -603,7 +603,7 @@ impl<'de, V_> de::Deserializer<'de> for SeqVisitorDeserializer<V_>\n     forward_to_deserialize! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n-        struct struct_field tuple enum ignored_any byte_buf\n+        struct identifier tuple enum ignored_any byte_buf\n     }\n }\n \n@@ -707,7 +707,7 @@ impl<'de, I, E> de::Deserializer<'de> for MapDeserializer<'de, I, E>\n \n     forward_to_deserialize! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n-        bytes map unit_struct newtype_struct tuple_struct struct struct_field\n+        bytes map unit_struct newtype_struct tuple_struct struct identifier\n         tuple enum ignored_any byte_buf\n     }\n }\n@@ -804,7 +804,7 @@ impl<'de, A, B, E> de::Deserializer<'de> for PairDeserializer<A, B, E>\n \n     forward_to_deserialize! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n-        bytes map unit_struct newtype_struct tuple_struct struct struct_field\n+        bytes map unit_struct newtype_struct tuple_struct struct identifier\n         tuple enum ignored_any byte_buf\n     }\n \n@@ -945,7 +945,7 @@ impl<'de, V_> de::Deserializer<'de> for MapVisitorDeserializer<V_>\n     forward_to_deserialize! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n-        struct struct_field tuple enum ignored_any byte_buf\n+        struct identifier tuple enum ignored_any byte_buf\n     }\n }\n \ndiff --git a/serde/src/macros.rs b/serde/src/macros.rs\nindex 5873e1a70..80ababfa0 100644\n--- a/serde/src/macros.rs\n+++ b/serde/src/macros.rs\n@@ -89,8 +89,8 @@ macro_rules! forward_to_deserialize_helper {\n     (struct) => {\n         forward_to_deserialize_method!{deserialize_struct(&'static str, &'static [&'static str])}\n     };\n-    (struct_field) => {\n-        forward_to_deserialize_method!{deserialize_struct_field()}\n+    (identifier) => {\n+        forward_to_deserialize_method!{deserialize_identifier()}\n     };\n     (tuple) => {\n         forward_to_deserialize_method!{deserialize_tuple(usize)}\n@@ -143,7 +143,7 @@ macro_rules! forward_to_deserialize_helper {\n /// #     forward_to_deserialize! {\n /// #         u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n /// #         seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n-/// #         tuple_struct struct struct_field tuple enum ignored_any\n+/// #         tuple_struct struct identifier tuple enum ignored_any\n /// #     }\n /// # }\n /// #\n@@ -176,7 +176,7 @@ macro_rules! forward_to_deserialize_helper {\n ///     forward_to_deserialize! {\n ///         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n ///         seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n-///         tuple_struct struct struct_field tuple enum ignored_any\n+///         tuple_struct struct identifier tuple enum ignored_any\n ///     }\n /// }\n /// #\ndiff --git a/serde/src/private/de.rs b/serde/src/private/de.rs\nindex f4e95dc63..2d019b427 100644\n--- a/serde/src/private/de.rs\n+++ b/serde/src/private/de.rs\n@@ -52,7 +52,7 @@ pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>\n         forward_to_deserialize! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n             seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n-            tuple_struct struct struct_field tuple enum ignored_any\n+            tuple_struct struct identifier tuple enum ignored_any\n         }\n     }\n \n@@ -855,7 +855,7 @@ mod content {\n         forward_to_deserialize! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n             seq_fixed_size bytes byte_buf map unit_struct tuple_struct struct\n-            struct_field tuple ignored_any\n+            identifier tuple ignored_any\n         }\n     }\n \n@@ -996,7 +996,7 @@ mod content {\n         forward_to_deserialize! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n             seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n-            tuple_struct struct struct_field tuple enum ignored_any\n+            tuple_struct struct identifier tuple enum ignored_any\n         }\n     }\n \n@@ -1085,7 +1085,7 @@ mod content {\n         forward_to_deserialize! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n             seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n-            tuple_struct struct struct_field tuple enum ignored_any\n+            tuple_struct struct identifier tuple enum ignored_any\n         }\n     }\n \n@@ -1202,7 +1202,7 @@ mod content {\n         forward_to_deserialize! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n             seq_fixed_size bytes byte_buf map unit_struct tuple_struct struct\n-            struct_field tuple ignored_any\n+            identifier tuple ignored_any\n         }\n     }\n \n@@ -1341,7 +1341,7 @@ mod content {\n         forward_to_deserialize! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n             seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n-            tuple_struct struct struct_field tuple enum ignored_any\n+            tuple_struct struct identifier tuple enum ignored_any\n         }\n     }\n \n@@ -1430,7 +1430,7 @@ mod content {\n         forward_to_deserialize! {\n             bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n             seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n-            tuple_struct struct struct_field tuple enum ignored_any\n+            tuple_struct struct identifier tuple enum ignored_any\n         }\n     }\n \ndiff --git a/serde/src/private/macros.rs b/serde/src/private/macros.rs\nindex 4d40c510d..f0e0703a3 100644\n--- a/serde/src/private/macros.rs\n+++ b/serde/src/private/macros.rs\n@@ -66,13 +66,13 @@ macro_rules! __serialize_unimplemented_helper {\n         __serialize_unimplemented_method!(serialize_unit_struct(&str) -> Ok);\n     };\n     (unit_variant) => {\n-        __serialize_unimplemented_method!(serialize_unit_variant(&str, usize, &str) -> Ok);\n+        __serialize_unimplemented_method!(serialize_unit_variant(&str, u32, &str) -> Ok);\n     };\n     (newtype_struct) => {\n         __serialize_unimplemented_method!(serialize_newtype_struct<T>(&str, &T) -> Ok);\n     };\n     (newtype_variant) => {\n-        __serialize_unimplemented_method!(serialize_newtype_variant<T>(&str, usize, &str, &T) -> Ok);\n+        __serialize_unimplemented_method!(serialize_newtype_variant<T>(&str, u32, &str, &T) -> Ok);\n     };\n     (seq) => {\n         type SerializeSeq = $crate::ser::Impossible<Self::Ok, Self::Error>;\n@@ -91,7 +91,7 @@ macro_rules! __serialize_unimplemented_helper {\n     };\n     (tuple_variant) => {\n         type SerializeTupleVariant = $crate::ser::Impossible<Self::Ok, Self::Error>;\n-        __serialize_unimplemented_method!(serialize_tuple_variant(&str, usize, &str, usize) -> SerializeTupleVariant);\n+        __serialize_unimplemented_method!(serialize_tuple_variant(&str, u32, &str, usize) -> SerializeTupleVariant);\n     };\n     (map) => {\n         type SerializeMap = $crate::ser::Impossible<Self::Ok, Self::Error>;\n@@ -103,7 +103,7 @@ macro_rules! __serialize_unimplemented_helper {\n     };\n     (struct_variant) => {\n         type SerializeStructVariant = $crate::ser::Impossible<Self::Ok, Self::Error>;\n-        __serialize_unimplemented_method!(serialize_struct_variant(&str, usize, &str, usize) -> SerializeStructVariant);\n+        __serialize_unimplemented_method!(serialize_struct_variant(&str, u32, &str, usize) -> SerializeStructVariant);\n     };\n }\n \ndiff --git a/serde/src/private/ser.rs b/serde/src/private/ser.rs\nindex 333cb7425..f307d3d78 100644\n--- a/serde/src/private/ser.rs\n+++ b/serde/src/private/ser.rs\n@@ -190,7 +190,7 @@ impl<S> Serializer for TaggedSerializer<S>\n \n     fn serialize_unit_variant(self,\n                               _: &'static str,\n-                              _: usize,\n+                              _: u32,\n                               inner_variant: &'static str)\n                               -> Result<Self::Ok, Self::Error> {\n         let mut map = try!(self.delegate.serialize_map(Some(2)));\n@@ -210,7 +210,7 @@ impl<S> Serializer for TaggedSerializer<S>\n \n     fn serialize_newtype_variant<T: ?Sized>(self,\n                                             _: &'static str,\n-                                            _: usize,\n+                                            _: u32,\n                                             inner_variant: &'static str,\n                                             inner_value: &T)\n                                             -> Result<Self::Ok, Self::Error>\n@@ -244,7 +244,7 @@ impl<S> Serializer for TaggedSerializer<S>\n     #[cfg(not(any(feature = \"std\", feature = \"collections\")))]\n     fn serialize_tuple_variant(self,\n                                _: &'static str,\n-                               _: usize,\n+                               _: u32,\n                                _: &'static str,\n                                _: usize)\n                                -> Result<Self::SerializeTupleVariant, Self::Error> {\n@@ -256,7 +256,7 @@ impl<S> Serializer for TaggedSerializer<S>\n     #[cfg(any(feature = \"std\", feature = \"collections\"))]\n     fn serialize_tuple_variant(self,\n                                _: &'static str,\n-                               _: usize,\n+                               _: u32,\n                                inner_variant: &'static str,\n                                len: usize)\n                                -> Result<Self::SerializeTupleVariant, Self::Error> {\n@@ -284,7 +284,7 @@ impl<S> Serializer for TaggedSerializer<S>\n     #[cfg(not(any(feature = \"std\", feature = \"collections\")))]\n     fn serialize_struct_variant(self,\n                                 _: &'static str,\n-                                _: usize,\n+                                _: u32,\n                                 _: &'static str,\n                                 _: usize)\n                                 -> Result<Self::SerializeStructVariant, Self::Error> {\n@@ -296,7 +296,7 @@ impl<S> Serializer for TaggedSerializer<S>\n     #[cfg(any(feature = \"std\", feature = \"collections\"))]\n     fn serialize_struct_variant(self,\n                                 _: &'static str,\n-                                _: usize,\n+                                _: u32,\n                                 inner_variant: &'static str,\n                                 len: usize)\n                                 -> Result<Self::SerializeStructVariant, Self::Error> {\n@@ -450,18 +450,18 @@ mod content {\n \n         Unit,\n         UnitStruct(&'static str),\n-        UnitVariant(&'static str, usize, &'static str),\n+        UnitVariant(&'static str, u32, &'static str),\n         NewtypeStruct(&'static str, Box<Content>),\n-        NewtypeVariant(&'static str, usize, &'static str, Box<Content>),\n+        NewtypeVariant(&'static str, u32, &'static str, Box<Content>),\n \n         Seq(Vec<Content>),\n         SeqFixedSize(Vec<Content>),\n         Tuple(Vec<Content>),\n         TupleStruct(&'static str, Vec<Content>),\n-        TupleVariant(&'static str, usize, &'static str, Vec<Content>),\n+        TupleVariant(&'static str, u32, &'static str, Vec<Content>),\n         Map(Vec<(Content, Content)>),\n         Struct(&'static str, Vec<(&'static str, Content)>),\n-        StructVariant(&'static str, usize, &'static str, Vec<(&'static str, Content)>),\n+        StructVariant(&'static str, u32, &'static str, Vec<(&'static str, Content)>),\n     }\n \n     impl Serialize for Content {\n@@ -651,7 +651,7 @@ mod content {\n \n         fn serialize_unit_variant(self,\n                                 name: &'static str,\n-                                variant_index: usize,\n+                                variant_index: u32,\n                                 variant: &'static str)\n                                 -> Result<Content, E> {\n             Ok(Content::UnitVariant(name, variant_index, variant))\n@@ -666,7 +666,7 @@ mod content {\n \n         fn serialize_newtype_variant<T: ?Sized + Serialize>(self,\n                                                             name: &'static str,\n-                                                            variant_index: usize,\n+                                                            variant_index: u32,\n                                                             variant: &'static str,\n                                                             value: &T)\n                                                             -> Result<Content, E> {\n@@ -712,7 +712,7 @@ mod content {\n \n         fn serialize_tuple_variant(self,\n                                 name: &'static str,\n-                                variant_index: usize,\n+                                variant_index: u32,\n                                 variant: &'static str,\n                                 len: usize)\n                                 -> Result<Self::SerializeTupleVariant, E> {\n@@ -743,7 +743,7 @@ mod content {\n \n         fn serialize_struct_variant(self,\n                                     name: &'static str,\n-                                    variant_index: usize,\n+                                    variant_index: u32,\n                                     variant: &'static str,\n                                     len: usize)\n                                     -> Result<Self::SerializeStructVariant, E> {\n@@ -831,7 +831,7 @@ mod content {\n \n     struct SerializeTupleVariant<E> {\n         name: &'static str,\n-        variant_index: usize,\n+        variant_index: u32,\n         variant: &'static str,\n         fields: Vec<Content>,\n         error: PhantomData<E>,\n@@ -922,7 +922,7 @@ mod content {\n \n     struct SerializeStructVariant<E> {\n         name: &'static str,\n-        variant_index: usize,\n+        variant_index: u32,\n         variant: &'static str,\n         fields: Vec<(&'static str, Content)>,\n         error: PhantomData<E>,\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 332bdfabf..1a20646a7 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -449,7 +449,7 @@ pub trait Serializer: Sized {\n     /// ```\n     fn serialize_unit_variant(self,\n                               name: &'static str,\n-                              variant_index: usize,\n+                              variant_index: u32,\n                               variant: &'static str)\n                               -> Result<Self::Ok, Self::Error>;\n \n@@ -504,7 +504,7 @@ pub trait Serializer: Sized {\n     /// ```\n     fn serialize_newtype_variant<T: ?Sized + Serialize>(self,\n                                                         name: &'static str,\n-                                                        variant_index: usize,\n+                                                        variant_index: u32,\n                                                         variant: &'static str,\n                                                         value: &T)\n                                                         -> Result<Self::Ok, Self::Error>;\n@@ -686,7 +686,7 @@ pub trait Serializer: Sized {\n     /// ```\n     fn serialize_tuple_variant(self,\n                                name: &'static str,\n-                               variant_index: usize,\n+                               variant_index: u32,\n                                variant: &'static str,\n                                len: usize)\n                                -> Result<Self::SerializeTupleVariant, Self::Error>;\n@@ -806,7 +806,7 @@ pub trait Serializer: Sized {\n     /// ```\n     fn serialize_struct_variant(self,\n                                 name: &'static str,\n-                                variant_index: usize,\n+                                variant_index: u32,\n                                 variant: &'static str,\n                                 len: usize)\n                                 -> Result<Self::SerializeStructVariant, Self::Error>;\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex c8c291c9e..077b072f9 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -1274,7 +1274,7 @@ fn deserialize_field_visitor(fields: Vec<(String, Ident)>,\n                     }\n                 }\n \n-                _serde::Deserializer::deserialize_struct_field(__deserializer, __FieldVisitor)\n+                _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)\n             }\n         }\n     }\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 7b893e440..cb5e8e85d 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -6,6 +6,8 @@ use fragment::{Fragment, Stmts, Match};\n use internals::ast::{Body, Field, Item, Style, Variant};\n use internals::{self, attr};\n \n+use std::u32;\n+\n pub fn expand_derive_serialize(item: &syn::DeriveInput) -> Result<Tokens, String> {\n     let ctxt = internals::Ctxt::new();\n     let item = Item::from_ast(&ctxt, item);\n@@ -210,6 +212,8 @@ fn serialize_struct(params: &Parameters,\n                     fields: &[Field],\n                     item_attrs: &attr::Item)\n                     -> Fragment {\n+    assert!(fields.len() as u64 <= u32::MAX as u64);\n+\n     let serialize_fields =\n         serialize_struct_visitor(fields,\n                                  params,\n@@ -247,6 +251,8 @@ fn serialize_item_enum(params: &Parameters,\n                        variants: &[Variant],\n                        item_attrs: &attr::Item)\n                        -> Fragment {\n+    assert!(variants.len() as u64 <= u32::MAX as u64);\n+\n     let self_var = &params.self_var;\n \n     let arms: Vec<_> = variants.iter()\n@@ -254,7 +260,7 @@ fn serialize_item_enum(params: &Parameters,\n         .map(|(variant_index, variant)| {\n             serialize_variant(params,\n                               variant,\n-                              variant_index,\n+                              variant_index as u32,\n                               item_attrs)\n         })\n         .collect();\n@@ -268,7 +274,7 @@ fn serialize_item_enum(params: &Parameters,\n \n fn serialize_variant(params: &Parameters,\n                      variant: &Variant,\n-                     variant_index: usize,\n+                     variant_index: u32,\n                      item_attrs: &attr::Item)\n                      -> Tokens {\n     let this = &params.this;\n@@ -349,7 +355,7 @@ fn serialize_variant(params: &Parameters,\n \n fn serialize_externally_tagged_variant(params: &Parameters,\n                                        variant: &Variant,\n-                                       variant_index: usize,\n+                                       variant_index: u32,\n                                        item_attrs: &attr::Item)\n                                        -> Fragment {\n     let type_name = item_attrs.name().serialize_name();\n@@ -587,7 +593,7 @@ fn serialize_untagged_variant(params: &Parameters,\n enum TupleVariant {\n     ExternallyTagged {\n         type_name: String,\n-        variant_index: usize,\n+        variant_index: u32,\n         variant_name: String,\n     },\n     Untagged,\n@@ -637,7 +643,7 @@ fn serialize_tuple_variant(context: TupleVariant,\n \n enum StructVariant<'a> {\n     ExternallyTagged {\n-        variant_index: usize,\n+        variant_index: u32,\n         variant_name: String,\n     },\n     InternallyTagged { tag: &'a str, variant_name: String },\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex fcbb762b2..243c8eb68 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -78,7 +78,7 @@ impl<'de, 'a> de::Deserializer<'de> for &'a mut Deserializer<'de> {\n \n     forward_to_deserialize! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit\n-        seq bytes byte_buf map struct_field ignored_any\n+        seq bytes byte_buf map identifier ignored_any\n     }\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n@@ -645,6 +645,6 @@ impl<'de> de::Deserializer<'de> for BytesDeserializer {\n     forward_to_deserialize! {\n         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n         seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n-        struct struct_field tuple enum ignored_any byte_buf\n+        struct identifier tuple enum ignored_any byte_buf\n     }\n }\ndiff --git a/serde_test/src/ser.rs b/serde_test/src/ser.rs\nindex 2a82970f7..f6c401eed 100644\n--- a/serde_test/src/ser.rs\n+++ b/serde_test/src/ser.rs\n@@ -146,7 +146,7 @@ impl<'s, 'a> ser::Serializer for &'s mut Serializer<'a> {\n \n     fn serialize_unit_variant(self,\n                               name: &'static str,\n-                              _variant_index: usize,\n+                              _variant_index: u32,\n                               variant: &'static str)\n                               -> Result<(), Error> {\n         if self.tokens.first() == Some(&Token::Enum(name)) {\n@@ -168,7 +168,7 @@ impl<'s, 'a> ser::Serializer for &'s mut Serializer<'a> {\n \n     fn serialize_newtype_variant<T: ?Sized>(self,\n                                             name: &'static str,\n-                                            _variant_index: usize,\n+                                            _variant_index: u32,\n                                             variant: &'static str,\n                                             value: &T)\n                                             -> Result<(), Error>\n@@ -217,7 +217,7 @@ impl<'s, 'a> ser::Serializer for &'s mut Serializer<'a> {\n \n     fn serialize_tuple_variant(self,\n                                name: &'static str,\n-                               _variant_index: usize,\n+                               _variant_index: u32,\n                                variant: &'static str,\n                                len: usize)\n                                -> Result<Self, Error> {\n@@ -237,7 +237,7 @@ impl<'s, 'a> ser::Serializer for &'s mut Serializer<'a> {\n \n     fn serialize_struct_variant(self,\n                                 name: &'static str,\n-                                _variant_index: usize,\n+                                _variant_index: u32,\n                                 variant: &'static str,\n                                 len: usize)\n                                 -> Result<Self, Error> {\n", "problem_statement": "Struct fields and variant tags both go through deserialize_struct_field\nIn `#[derive(Deserialize)]` we are generating effectively the same Deserialize implementation for deciding which struct field is next vs which variant we are looking at. As a result, both implementations go through Deserializer::deserialize_struct_field which is unexpected for Deserializer authors trying to implement `EnumVisitor::visit_variant`.\n", "hints_text": "The workaround for binary formats is to go through U32Deserializer. Something like:\r\n\r\n```rust\r\nfn visit_variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant)>\r\n    where V: de::DeserializeSeed\r\n{\r\n    // instead of `seed.deserialize(&mut *self.de)`\r\n    let idx: u32 = Deserialize::deserialize(&mut *self.de)?;\r\n    let val = seed.deserialize(idx.into_deserializer())?;\r\n    Ok((val, /* ... */))\r\n}\r\n```", "created_at": "2017-04-09T20:55:07Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 859, "instance_id": "serde-rs__serde-859", "issue_numbers": ["857"], "base_commit": "cc933b9cdb0f787dd33a6ff01e7a65b4627e73a0", "patch": "diff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 5c84a6494..4c4ffe14e 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -168,13 +168,6 @@ fn deserialize_unit_struct(ident: &syn::Ident, item_attrs: &attr::Item) -> Fragm\n             {\n                 _serde::export::Ok(#ident)\n             }\n-\n-            #[inline]\n-            fn visit_seq<__V>(self, _: __V) -> _serde::export::Result<#ident, __V::Error>\n-                where __V: _serde::de::SeqVisitor<'de>\n-            {\n-                _serde::export::Ok(#ident)\n-            }\n         }\n \n         _serde::Deserializer::deserialize_unit_struct(__deserializer, #type_name, __Visitor)\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex bff0b48bb..43fa0bf37 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -242,14 +242,6 @@ declare_tests! {\n         UnitStruct => &[\n             Token::UnitStruct(\"UnitStruct\"),\n         ],\n-        UnitStruct => &[\n-            Token::Seq(Some(0)),\n-            Token::SeqEnd,\n-        ],\n-        UnitStruct => &[\n-            Token::Seq(None),\n-            Token::SeqEnd,\n-        ],\n     }\n     test_newtype_struct {\n         NewtypeStruct(1) => &[\n@@ -1036,4 +1028,11 @@ declare_error_tests! {\n         ],\n         Error::Message(\"invalid type: floating point `0`, expected isize\".into()),\n     }\n+    test_unit_struct_from_seq<UnitStruct> {\n+        &[\n+            Token::Seq(Some(0)),\n+            Token::SeqEnd,\n+        ],\n+        Error::Message(\"invalid type: sequence, expected unit struct UnitStruct\".into()),\n+    }\n }\n", "problem_statement": "Remove conversion from empty seq to unit struct\n[This function](https://github.com/serde-rs/serde/blob/v0.9.13/serde_derive/src/de.rs#L153-L158) should be removed to match the handling of () in #839.\n", "hints_text": "", "created_at": "2017-04-09T20:08:33Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 858, "instance_id": "serde-rs__serde-858", "issue_numbers": ["496"], "base_commit": "528ec3cdd870abf801ca5cb3a47cdcc1a0f5cfc7", "patch": "diff --git a/serde/src/private/ser.rs b/serde/src/private/ser.rs\nindex c8d09d0b8..333cb7425 100644\n--- a/serde/src/private/ser.rs\n+++ b/serde/src/private/ser.rs\n@@ -8,6 +8,12 @@ use self::content::{SerializeTupleVariantAsMapValue, SerializeStructVariantAsMap\n #[cfg(feature = \"std\")]\n use std::error;\n \n+/// Used to check that serde(getter) attributes return the expected type.\n+/// Not public API.\n+pub fn constrain<T: ?Sized>(t: &T) -> &T {\n+    t\n+}\n+\n /// Not public API.\n pub fn serialize_tagged_newtype<S, T>(serializer: S,\n                                       type_ident: &'static str,\ndiff --git a/serde_codegen_internals/src/ast.rs b/serde_codegen_internals/src/ast.rs\nindex 0a50691eb..462d061f4 100644\n--- a/serde_codegen_internals/src/ast.rs\n+++ b/serde_codegen_internals/src/ast.rs\n@@ -1,5 +1,6 @@\n use syn;\n use attr;\n+use check;\n use Ctxt;\n \n pub struct Item<'a> {\n@@ -62,12 +63,14 @@ impl<'a> Item<'a> {\n             }\n         }\n \n-        Item {\n+        let item = Item {\n             ident: item.ident.clone(),\n             attrs: attrs,\n             body: body,\n             generics: &item.generics,\n-        }\n+        };\n+        check::check(cx, &item);\n+        item\n     }\n }\n \n@@ -81,6 +84,10 @@ impl<'a> Body<'a> {\n             Body::Struct(_, ref fields) => Box::new(fields.iter()),\n         }\n     }\n+\n+    pub fn has_getter(&self) -> bool {\n+        self.all_fields().any(|f| f.attrs.getter().is_some())\n+    }\n }\n \n fn enum_from_ast<'a>(cx: &Ctxt, variants: &'a [syn::Variant]) -> Vec<Variant<'a>> {\ndiff --git a/serde_codegen_internals/src/attr.rs b/serde_codegen_internals/src/attr.rs\nindex 9e957ad90..cb4ddd8ae 100644\n--- a/serde_codegen_internals/src/attr.rs\n+++ b/serde_codegen_internals/src/attr.rs\n@@ -102,6 +102,7 @@ pub struct Item {\n     tag: EnumTag,\n     from_type: Option<syn::Ty>,\n     into_type: Option<syn::Ty>,\n+    remote: Option<syn::Path>,\n }\n \n /// Styles of representing an enum.\n@@ -151,6 +152,7 @@ impl Item {\n         let mut content = Attr::none(cx, \"content\");\n         let mut from_type = Attr::none(cx, \"from\");\n         let mut into_type = Attr::none(cx, \"into\");\n+        let mut remote = Attr::none(cx, \"remote\");\n \n         for meta_items in item.attrs.iter().filter_map(get_serde_meta_items) {\n             for meta_item in meta_items {\n@@ -290,6 +292,13 @@ impl Item {\n                         }\n                     }\n \n+                    // Parse `#[serde(remote = \"...\")]`\n+                    MetaItem(NameValue(ref name, ref lit)) if name == \"remote\" => {\n+                        if let Ok(path) = parse_lit_into_path(cx, name.as_ref(), lit) {\n+                            remote.set(path);\n+                        }\n+                    }\n+\n                     MetaItem(ref meta_item) => {\n                         cx.error(format!(\"unknown serde container attribute `{}`\",\n                                          meta_item.name()));\n@@ -361,6 +370,7 @@ impl Item {\n             tag: tag,\n             from_type: from_type.get(),\n             into_type: into_type.get(),\n+            remote: remote.get(),\n         }\n     }\n \n@@ -399,6 +409,10 @@ impl Item {\n     pub fn into_type(&self) -> Option<&syn::Ty> {\n         self.into_type.as_ref()\n     }\n+\n+    pub fn remote(&self) -> Option<&syn::Path> {\n+        self.remote.as_ref()\n+    }\n }\n \n /// Represents variant attribute information\n@@ -531,6 +545,7 @@ pub struct Field {\n     ser_bound: Option<Vec<syn::WherePredicate>>,\n     de_bound: Option<Vec<syn::WherePredicate>>,\n     borrowed_lifetimes: BTreeSet<syn::Lifetime>,\n+    getter: Option<syn::Path>,\n }\n \n /// Represents the default to use for a field when deserializing.\n@@ -558,6 +573,7 @@ impl Field {\n         let mut ser_bound = Attr::none(cx, \"bound\");\n         let mut de_bound = Attr::none(cx, \"bound\");\n         let mut borrowed_lifetimes = Attr::none(cx, \"borrow\");\n+        let mut getter = Attr::none(cx, \"getter\");\n \n         let ident = match field.ident {\n             Some(ref ident) => ident.to_string(),\n@@ -676,6 +692,13 @@ impl Field {\n                         }\n                     }\n \n+                    // Parse `#[serde(getter = \"...\")]`\n+                    MetaItem(NameValue(ref name, ref lit)) if name == \"getter\" => {\n+                        if let Ok(path) = parse_lit_into_path(cx, name.as_ref(), lit) {\n+                            getter.set(path);\n+                        }\n+                    }\n+\n                     MetaItem(ref meta_item) => {\n                         cx.error(format!(\"unknown serde field attribute `{}`\", meta_item.name()));\n                     }\n@@ -737,6 +760,7 @@ impl Field {\n             ser_bound: ser_bound.get(),\n             de_bound: de_bound.get(),\n             borrowed_lifetimes: borrowed_lifetimes,\n+            getter: getter.get(),\n         }\n     }\n \n@@ -788,6 +812,10 @@ impl Field {\n     pub fn borrowed_lifetimes(&self) -> &BTreeSet<syn::Lifetime> {\n         &self.borrowed_lifetimes\n     }\n+\n+    pub fn getter(&self) -> Option<&syn::Path> {\n+        self.getter.as_ref()\n+    }\n }\n \n type SerAndDe<T> = (Option<T>, Option<T>);\ndiff --git a/serde_codegen_internals/src/check.rs b/serde_codegen_internals/src/check.rs\nnew file mode 100644\nindex 000000000..fd4d4e7d6\n--- /dev/null\n+++ b/serde_codegen_internals/src/check.rs\n@@ -0,0 +1,20 @@\n+use ast::{Body, Item};\n+use Ctxt;\n+\n+/// Cross-cutting checks that require looking at more than a single attrs\n+/// object. Simpler checks should happen when parsing and building the attrs.\n+pub fn check(cx: &Ctxt, item: &Item) {\n+    match item.body {\n+        Body::Enum(_) => {\n+            if item.body.has_getter() {\n+                cx.error(\"#[serde(getter = \\\"...\\\")] is not allowed in an enum\");\n+            }\n+        }\n+        Body::Struct(_, _) => {\n+            if item.body.has_getter() && item.attrs.remote().is_none() {\n+                cx.error(\"#[serde(getter = \\\"...\\\")] can only be used in structs \\\n+                          that have #[serde(remote = \\\"...\\\")]\");\n+            }\n+        }\n+    }\n+}\ndiff --git a/serde_codegen_internals/src/lib.rs b/serde_codegen_internals/src/lib.rs\nindex d5baf00b9..6353330b0 100644\n--- a/serde_codegen_internals/src/lib.rs\n+++ b/serde_codegen_internals/src/lib.rs\n@@ -9,3 +9,4 @@ mod ctxt;\n pub use ctxt::Ctxt;\n \n mod case;\n+mod check;\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 4c4ffe14e..c8c291c9e 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -14,17 +14,25 @@ pub fn expand_derive_deserialize(item: &syn::DeriveInput) -> Result<Tokens, Stri\n     try!(ctxt.check());\n \n     let ident = &item.ident;\n-    let generics = build_generics(&item);\n-    let borrowed = borrowed_lifetimes(&item);\n-    let params = Parameters { generics: generics, borrowed: borrowed };\n-    let (de_impl_generics, _, ty_generics, where_clause) = split_with_de_lifetime(&params);\n+    let params = Parameters::new(&item);\n     let dummy_const = Ident::new(format!(\"_IMPL_DESERIALIZE_FOR_{}\", ident));\n     let body = Stmts(deserialize_body(&item, &params));\n \n-    Ok(quote! {\n-        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-        const #dummy_const: () = {\n-            extern crate serde as _serde;\n+    let impl_item = if let Some(remote) = item.attrs.remote() {\n+        let (impl_generics, ty_generics, where_clause) = item.generics.split_for_impl();\n+        let de_lifetime = params.de_lifetime_def();\n+        quote! {\n+            impl #impl_generics #ident #ty_generics #where_clause {\n+                fn deserialize<#de_lifetime, __D>(__deserializer: __D) -> _serde::export::Result<#remote #ty_generics, __D::Error>\n+                    where __D: _serde::Deserializer<'de>\n+                {\n+                    #body\n+                }\n+            }\n+        }\n+    } else {\n+        let (de_impl_generics, _, ty_generics, where_clause) = split_with_de_lifetime(&params);\n+        quote! {\n             #[automatically_derived]\n             impl #de_impl_generics _serde::Deserialize<'de> for #ident #ty_generics #where_clause {\n                 fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>\n@@ -33,13 +41,72 @@ pub fn expand_derive_deserialize(item: &syn::DeriveInput) -> Result<Tokens, Stri\n                     #body\n                 }\n             }\n+        }\n+    };\n+\n+    Ok(quote! {\n+        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n+        const #dummy_const: () = {\n+            extern crate serde as _serde;\n+            #impl_item\n         };\n     })\n }\n \n struct Parameters {\n+    /// Name of the type the `derive` is on.\n+    local: syn::Ident,\n+\n+    /// Path to the type the impl is for. Either a single `Ident` for local\n+    /// types or `some::remote::Ident` for remote types. Does not include\n+    /// generic parameters.\n+    this: syn::Path,\n+\n+    /// Generics including any explicit and inferred bounds for the impl.\n     generics: syn::Generics,\n+\n+    /// Lifetimes borrowed from the deserializer. These will become bounds on\n+    /// the `'de` lifetime of the deserializer.\n     borrowed: BTreeSet<syn::Lifetime>,\n+\n+    /// At least one field has a serde(getter) attribute, implying that the\n+    /// remote type has a private field.\n+    has_getter: bool,\n+}\n+\n+impl Parameters {\n+    fn new(item: &Item) -> Self {\n+        let local = item.ident.clone();\n+        let this = match item.attrs.remote() {\n+            Some(remote) => remote.clone(),\n+            None => item.ident.clone().into(),\n+        };\n+        let generics = build_generics(item);\n+        let borrowed = borrowed_lifetimes(item);\n+        let has_getter = item.body.has_getter();\n+\n+        Parameters {\n+            local: local,\n+            this: this,\n+            generics: generics,\n+            borrowed: borrowed,\n+            has_getter: has_getter,\n+        }\n+    }\n+\n+    /// Type name to use in error messages and `&'static str` arguments to\n+    /// various Deserializer methods.\n+    fn type_name(&self) -> &str {\n+        self.this.segments.last().unwrap().ident.as_ref()\n+    }\n+\n+    fn de_lifetime_def(&self) -> syn::LifetimeDef {\n+        syn::LifetimeDef {\n+            attrs: Vec::new(),\n+            lifetime: syn::Lifetime::new(\"'de\"),\n+            bounds: self.borrowed.iter().cloned().collect(),\n+        }\n+    }\n }\n \n // All the generics in the input, plus a bound `T: Deserialize` for each generic\n@@ -109,14 +176,13 @@ fn deserialize_body(item: &Item, params: &Parameters) -> Fragment {\n     } else {\n         match item.body {\n             Body::Enum(ref variants) => {\n-                deserialize_item_enum(&item.ident, params, variants, &item.attrs)\n+                deserialize_item_enum(params, variants, &item.attrs)\n             }\n             Body::Struct(Style::Struct, ref fields) => {\n                 if fields.iter().any(|field| field.ident.is_none()) {\n                     panic!(\"struct has unnamed fields\");\n                 }\n-                deserialize_struct(&item.ident,\n-                                   None,\n+                deserialize_struct(None,\n                                    params,\n                                    fields,\n                                    &item.attrs,\n@@ -127,14 +193,13 @@ fn deserialize_body(item: &Item, params: &Parameters) -> Fragment {\n                 if fields.iter().any(|field| field.ident.is_some()) {\n                     panic!(\"tuple struct has named fields\");\n                 }\n-                deserialize_tuple(&item.ident,\n-                                  None,\n+                deserialize_tuple(None,\n                                   params,\n                                   fields,\n                                   &item.attrs,\n                                   None)\n             }\n-            Body::Struct(Style::Unit, _) => deserialize_unit_struct(&item.ident, &item.attrs),\n+            Body::Struct(Style::Unit, _) => deserialize_unit_struct(params, &item.attrs),\n         }\n     }\n }\n@@ -147,26 +212,27 @@ fn deserialize_from(from_type: &syn::Ty) -> Fragment {\n     }\n }\n \n-fn deserialize_unit_struct(ident: &syn::Ident, item_attrs: &attr::Item) -> Fragment {\n+fn deserialize_unit_struct(params: &Parameters, item_attrs: &attr::Item) -> Fragment {\n+    let this = &params.this;\n     let type_name = item_attrs.name().deserialize_name();\n \n-    let expecting = format!(\"unit struct {}\", ident);\n+    let expecting = format!(\"unit struct {}\", params.type_name());\n \n     quote_block! {\n         struct __Visitor;\n \n         impl<'de> _serde::de::Visitor<'de> for __Visitor {\n-            type Value = #ident;\n+            type Value = #this;\n \n             fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n                 _serde::export::fmt::Formatter::write_str(formatter, #expecting)\n             }\n \n             #[inline]\n-            fn visit_unit<__E>(self) -> _serde::export::Result<#ident, __E>\n+            fn visit_unit<__E>(self) -> _serde::export::Result<Self::Value, __E>\n                 where __E: _serde::de::Error\n             {\n-                _serde::export::Ok(#ident)\n+                _serde::export::Ok(#this)\n             }\n         }\n \n@@ -174,38 +240,48 @@ fn deserialize_unit_struct(ident: &syn::Ident, item_attrs: &attr::Item) -> Fragm\n     }\n }\n \n-fn deserialize_tuple(ident: &syn::Ident,\n-                     variant_ident: Option<&syn::Ident>,\n+fn deserialize_tuple(variant_ident: Option<&syn::Ident>,\n                      params: &Parameters,\n                      fields: &[Field],\n                      item_attrs: &attr::Item,\n                      deserializer: Option<Tokens>)\n                      -> Fragment {\n+    let this = &params.this;\n     let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params);\n \n+    // If there are getters (implying private fields), construct the local type\n+    // and use an `Into` conversion to get the remote type. If there are no\n+    // getters then construct the target type directly.\n+    let construct = if params.has_getter {\n+        let local = &params.local;\n+        quote!(#local)\n+    } else {\n+        quote!(#this)\n+    };\n+\n     let is_enum = variant_ident.is_some();\n     let type_path = match variant_ident {\n-        Some(variant_ident) => quote!(#ident::#variant_ident),\n-        None => quote!(#ident),\n+        Some(variant_ident) => quote!(#construct::#variant_ident),\n+        None => construct,\n     };\n     let expecting = match variant_ident {\n-        Some(variant_ident) => format!(\"tuple variant {}::{}\", ident, variant_ident),\n-        None => format!(\"tuple struct {}\", ident),\n+        Some(variant_ident) => format!(\"tuple variant {}::{}\", params.type_name(), variant_ident),\n+        None => format!(\"tuple struct {}\", params.type_name()),\n     };\n \n     let nfields = fields.len();\n \n     let visit_newtype_struct = if !is_enum && nfields == 1 {\n-        Some(deserialize_newtype_struct(ident, &type_path, params, &fields[0]))\n+        Some(deserialize_newtype_struct(&type_path, params, &fields[0]))\n     } else {\n         None\n     };\n \n-    let visit_seq = Stmts(deserialize_seq(ident, &type_path, params, fields, false, item_attrs));\n+    let visit_seq = Stmts(deserialize_seq(&type_path, params, fields, false, item_attrs));\n \n     let visitor_expr = quote! {\n         __Visitor {\n-            marker: _serde::export::PhantomData::<#ident #ty_generics>,\n+            marker: _serde::export::PhantomData::<#this #ty_generics>,\n             lifetime: _serde::export::PhantomData,\n         }\n     };\n@@ -230,12 +306,12 @@ fn deserialize_tuple(ident: &syn::Ident,\n \n     quote_block! {\n         struct __Visitor #de_impl_generics #where_clause {\n-            marker: _serde::export::PhantomData<#ident #ty_generics>,\n+            marker: _serde::export::PhantomData<#this #ty_generics>,\n             lifetime: _serde::export::PhantomData<&'de ()>,\n         }\n \n         impl #de_impl_generics _serde::de::Visitor<'de> for __Visitor #de_ty_generics #where_clause {\n-            type Value = #ident #ty_generics;\n+            type Value = #this #ty_generics;\n \n             fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n                 _serde::export::fmt::Formatter::write_str(formatter, #expecting)\n@@ -255,8 +331,7 @@ fn deserialize_tuple(ident: &syn::Ident,\n     }\n }\n \n-fn deserialize_seq(ident: &syn::Ident,\n-                   type_path: &Tokens,\n+fn deserialize_seq(type_path: &Tokens,\n                    params: &Parameters,\n                    fields: &[Field],\n                    is_struct: bool,\n@@ -285,7 +360,7 @@ fn deserialize_seq(ident: &syn::Ident,\n                     }\n                     Some(path) => {\n                         let (wrapper, wrapper_ty) = wrap_deserialize_with(\n-                            ident, params, field.ty, path);\n+                            params, field.ty, path);\n                         quote!({\n                             #wrapper\n                             _serde::export::Option::map(\n@@ -307,7 +382,7 @@ fn deserialize_seq(ident: &syn::Ident,\n             }\n         });\n \n-    let result = if is_struct {\n+    let mut result = if is_struct {\n         let names = fields.iter().map(|f| &f.ident);\n         quote! {\n             #type_path { #( #names: #vars ),* }\n@@ -318,14 +393,20 @@ fn deserialize_seq(ident: &syn::Ident,\n         }\n     };\n \n+    if params.has_getter {\n+        let this = &params.this;\n+        result = quote! {\n+            _serde::export::Into::<#this>::into(#result)\n+        };\n+    }\n+\n     quote_block! {\n         #(#let_values)*\n         _serde::export::Ok(#result)\n     }\n }\n \n-fn deserialize_newtype_struct(ident: &syn::Ident,\n-                              type_path: &Tokens,\n+fn deserialize_newtype_struct(type_path: &Tokens,\n                               params: &Parameters,\n                               field: &Field)\n                               -> Tokens {\n@@ -338,25 +419,33 @@ fn deserialize_newtype_struct(ident: &syn::Ident,\n         }\n         Some(path) => {\n             let (wrapper, wrapper_ty) =\n-                wrap_deserialize_with(ident, params, field.ty, path);\n+                wrap_deserialize_with(params, field.ty, path);\n             quote!({\n                 #wrapper\n                 try!(<#wrapper_ty as _serde::Deserialize>::deserialize(__e)).value\n             })\n         }\n     };\n+\n+    let mut result = quote!(#type_path(#value));\n+    if params.has_getter {\n+        let this = &params.this;\n+        result = quote! {\n+            _serde::export::Into::<#this>::into(#result)\n+        };\n+    }\n+\n     quote! {\n         #[inline]\n         fn visit_newtype_struct<__E>(self, __e: __E) -> _serde::export::Result<Self::Value, __E::Error>\n             where __E: _serde::Deserializer<'de>\n         {\n-            _serde::export::Ok(#type_path(#value))\n+            _serde::export::Ok(#result)\n         }\n     }\n }\n \n-fn deserialize_struct(ident: &syn::Ident,\n-                      variant_ident: Option<&syn::Ident>,\n+fn deserialize_struct(variant_ident: Option<&syn::Ident>,\n                       params: &Parameters,\n                       fields: &[Field],\n                       item_attrs: &attr::Item,\n@@ -365,28 +454,39 @@ fn deserialize_struct(ident: &syn::Ident,\n     let is_enum = variant_ident.is_some();\n     let is_untagged = deserializer.is_some();\n \n+    let this = &params.this;\n     let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params);\n \n+    // If there are getters (implying private fields), construct the local type\n+    // and use an `Into` conversion to get the remote type. If there are no\n+    // getters then construct the target type directly.\n+    let construct = if params.has_getter {\n+        let local = &params.local;\n+        quote!(#local)\n+    } else {\n+        quote!(#this)\n+    };\n+\n     let type_path = match variant_ident {\n-        Some(variant_ident) => quote!(#ident::#variant_ident),\n-        None => quote!(#ident),\n+        Some(variant_ident) => quote!(#construct::#variant_ident),\n+        None => construct,\n     };\n     let expecting = match variant_ident {\n-        Some(variant_ident) => format!(\"struct variant {}::{}\", ident, variant_ident),\n-        None => format!(\"struct {}\", ident),\n+        Some(variant_ident) => format!(\"struct variant {}::{}\", params.type_name(), variant_ident),\n+        None => format!(\"struct {}\", params.type_name()),\n     };\n \n-    let visit_seq = Stmts(deserialize_seq(ident, &type_path, params, fields, true, item_attrs));\n+    let visit_seq = Stmts(deserialize_seq(&type_path, params, fields, true, item_attrs));\n \n     let (field_visitor, fields_stmt, visit_map) =\n-        deserialize_struct_visitor(ident, type_path, params, fields, item_attrs);\n+        deserialize_struct_visitor(type_path, params, fields, item_attrs);\n     let field_visitor = Stmts(field_visitor);\n     let fields_stmt = Stmts(fields_stmt);\n     let visit_map = Stmts(visit_map);\n \n     let visitor_expr = quote! {\n         __Visitor {\n-            marker: _serde::export::PhantomData::<#ident #ty_generics>,\n+            marker: _serde::export::PhantomData::<#this #ty_generics>,\n             lifetime: _serde::export::PhantomData,\n         }\n     };\n@@ -430,12 +530,12 @@ fn deserialize_struct(ident: &syn::Ident,\n         #field_visitor\n \n         struct __Visitor #de_impl_generics #where_clause {\n-            marker: _serde::export::PhantomData<#ident #ty_generics>,\n+            marker: _serde::export::PhantomData<#this #ty_generics>,\n             lifetime: _serde::export::PhantomData<&'de ()>,\n         }\n \n         impl #de_impl_generics _serde::de::Visitor<'de> for __Visitor #de_ty_generics #where_clause {\n-            type Value = #ident #ty_generics;\n+            type Value = #this #ty_generics;\n \n             fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n                 _serde::export::fmt::Formatter::write_str(formatter, #expecting)\n@@ -457,46 +557,43 @@ fn deserialize_struct(ident: &syn::Ident,\n     }\n }\n \n-fn deserialize_item_enum(ident: &syn::Ident,\n-                         params: &Parameters,\n+fn deserialize_item_enum(params: &Parameters,\n                          variants: &[Variant],\n                          item_attrs: &attr::Item)\n                          -> Fragment {\n     match *item_attrs.tag() {\n         attr::EnumTag::External => {\n-            deserialize_externally_tagged_enum(ident, params, variants, item_attrs)\n+            deserialize_externally_tagged_enum(params, variants, item_attrs)\n         }\n         attr::EnumTag::Internal { ref tag } => {\n-            deserialize_internally_tagged_enum(ident,\n-                                               params,\n+            deserialize_internally_tagged_enum(params,\n                                                variants,\n                                                item_attrs,\n                                                tag)\n         }\n         attr::EnumTag::Adjacent { ref tag, ref content } => {\n-            deserialize_adjacently_tagged_enum(ident,\n-                                               params,\n+            deserialize_adjacently_tagged_enum(params,\n                                                variants,\n                                                item_attrs,\n                                                tag,\n                                                content)\n         }\n         attr::EnumTag::None => {\n-            deserialize_untagged_enum(ident, params, variants, item_attrs)\n+            deserialize_untagged_enum(params, variants, item_attrs)\n         }\n     }\n }\n \n-fn deserialize_externally_tagged_enum(ident: &syn::Ident,\n-                                      params: &Parameters,\n+fn deserialize_externally_tagged_enum(params: &Parameters,\n                                       variants: &[Variant],\n                                       item_attrs: &attr::Item)\n                                       -> Fragment {\n+    let this = &params.this;\n     let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params);\n \n     let type_name = item_attrs.name().deserialize_name();\n \n-    let expecting = format!(\"enum {}\", ident);\n+    let expecting = format!(\"enum {}\", params.type_name());\n \n     let variant_names_idents: Vec<_> = variants.iter()\n         .enumerate()\n@@ -520,8 +617,7 @@ fn deserialize_externally_tagged_enum(ident: &syn::Ident,\n         .map(|(i, variant)| {\n             let variant_name = field_i(i);\n \n-            let block = Match(deserialize_externally_tagged_variant(ident,\n-                                                                    params,\n+            let block = Match(deserialize_externally_tagged_variant(params,\n                                                                     variant,\n                                                                     item_attrs));\n \n@@ -554,12 +650,12 @@ fn deserialize_externally_tagged_enum(ident: &syn::Ident,\n         #variant_visitor\n \n         struct __Visitor #de_impl_generics #where_clause {\n-            marker: _serde::export::PhantomData<#ident #ty_generics>,\n+            marker: _serde::export::PhantomData<#this #ty_generics>,\n             lifetime: _serde::export::PhantomData<&'de ()>,\n         }\n \n         impl #de_impl_generics _serde::de::Visitor<'de> for __Visitor #de_ty_generics #where_clause {\n-            type Value = #ident #ty_generics;\n+            type Value = #this #ty_generics;\n \n             fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n                 _serde::export::fmt::Formatter::write_str(formatter, #expecting)\n@@ -576,14 +672,13 @@ fn deserialize_externally_tagged_enum(ident: &syn::Ident,\n \n         _serde::Deserializer::deserialize_enum(__deserializer, #type_name, VARIANTS,\n                                                __Visitor {\n-                                                   marker: _serde::export::PhantomData::<#ident #ty_generics>,\n+                                                   marker: _serde::export::PhantomData::<#this #ty_generics>,\n                                                    lifetime: _serde::export::PhantomData,\n                                                })\n     }\n }\n \n-fn deserialize_internally_tagged_enum(ident: &syn::Ident,\n-                                      params: &Parameters,\n+fn deserialize_internally_tagged_enum(params: &Parameters,\n                                       variants: &[Variant],\n                                       item_attrs: &attr::Item,\n                                       tag: &str)\n@@ -611,7 +706,6 @@ fn deserialize_internally_tagged_enum(ident: &syn::Ident,\n             let variant_name = field_i(i);\n \n             let block = Match(deserialize_internally_tagged_variant(\n-                ident,\n                 params,\n                 variant,\n                 item_attrs,\n@@ -638,13 +732,13 @@ fn deserialize_internally_tagged_enum(ident: &syn::Ident,\n     }\n }\n \n-fn deserialize_adjacently_tagged_enum(ident: &syn::Ident,\n-                                      params: &Parameters,\n+fn deserialize_adjacently_tagged_enum(params: &Parameters,\n                                       variants: &[Variant],\n                                       item_attrs: &attr::Item,\n                                       tag: &str,\n                                       content: &str)\n                                       -> Fragment {\n+    let this = &params.this;\n     let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params);\n \n     let variant_names_idents: Vec<_> = variants.iter()\n@@ -669,7 +763,6 @@ fn deserialize_adjacently_tagged_enum(ident: &syn::Ident,\n             let variant_index = field_i(i);\n \n             let block = Match(deserialize_untagged_variant(\n-                ident,\n                 params,\n                 variant,\n                 item_attrs,\n@@ -682,7 +775,7 @@ fn deserialize_adjacently_tagged_enum(ident: &syn::Ident,\n         })\n         .collect();\n \n-    let expecting = format!(\"adjacently tagged enum {}\", ident);\n+    let expecting = format!(\"adjacently tagged enum {}\", params.type_name());\n     let type_name = item_attrs.name().deserialize_name();\n \n     let tag_or_content = quote! {\n@@ -717,7 +810,7 @@ fn deserialize_adjacently_tagged_enum(ident: &syn::Ident,\n                 let variant_index = field_i(i);\n                 let variant_ident = &variant.ident;\n                 quote! {\n-                    __Field::#variant_index => _serde::export::Ok(#ident::#variant_ident),\n+                    __Field::#variant_index => _serde::export::Ok(#this::#variant_ident),\n                 }\n             });\n         missing_content = quote! {\n@@ -748,12 +841,12 @@ fn deserialize_adjacently_tagged_enum(ident: &syn::Ident,\n \n         struct __Seed #de_impl_generics #where_clause {\n             field: __Field,\n-            marker: _serde::export::PhantomData<#ident #ty_generics>,\n+            marker: _serde::export::PhantomData<#this #ty_generics>,\n             lifetime: _serde::export::PhantomData<&'de ()>,\n         }\n \n         impl #de_impl_generics _serde::de::DeserializeSeed<'de> for __Seed #de_ty_generics #where_clause {\n-            type Value = #ident #ty_generics;\n+            type Value = #this #ty_generics;\n \n             fn deserialize<__D>(self, __deserializer: __D) -> _serde::export::Result<Self::Value, __D::Error>\n                 where __D: _serde::Deserializer<'de>\n@@ -765,12 +858,12 @@ fn deserialize_adjacently_tagged_enum(ident: &syn::Ident,\n         }\n \n         struct __Visitor #de_impl_generics #where_clause {\n-            marker: _serde::export::PhantomData<#ident #ty_generics>,\n+            marker: _serde::export::PhantomData<#this #ty_generics>,\n             lifetime: _serde::export::PhantomData<&'de ()>,\n         }\n \n         impl #de_impl_generics _serde::de::Visitor<'de> for __Visitor #de_ty_generics #where_clause {\n-            type Value = #ident #ty_generics;\n+            type Value = #this #ty_generics;\n \n             fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n                 _serde::export::fmt::Formatter::write_str(formatter, #expecting)\n@@ -871,14 +964,13 @@ fn deserialize_adjacently_tagged_enum(ident: &syn::Ident,\n         const FIELDS: &'static [&'static str] = &[#tag, #content];\n         _serde::Deserializer::deserialize_struct(__deserializer, #type_name, FIELDS,\n             __Visitor {\n-                marker: _serde::export::PhantomData::<#ident #ty_generics>,\n+                marker: _serde::export::PhantomData::<#this #ty_generics>,\n                 lifetime: _serde::export::PhantomData,\n             })\n     }\n }\n \n-fn deserialize_untagged_enum(ident: &syn::Ident,\n-                             params: &Parameters,\n+fn deserialize_untagged_enum(params: &Parameters,\n                              variants: &[Variant],\n                              item_attrs: &attr::Item)\n                              -> Fragment {\n@@ -886,7 +978,6 @@ fn deserialize_untagged_enum(ident: &syn::Ident,\n         .filter(|variant| !variant.attrs.skip_deserializing())\n         .map(|variant| {\n             Expr(deserialize_untagged_variant(\n-                ident,\n                 params,\n                 variant,\n                 item_attrs,\n@@ -900,7 +991,7 @@ fn deserialize_untagged_enum(ident: &syn::Ident,\n     // largest number of fields. I'm not sure I like that. Maybe it would be\n     // better to save all the errors and combine them into one message that\n     // explains why none of the variants matched.\n-    let fallthrough_msg = format!(\"data did not match any variant of untagged enum {}\", ident);\n+    let fallthrough_msg = format!(\"data did not match any variant of untagged enum {}\", params.type_name());\n \n     quote_block! {\n         let __content = try!(<_serde::private::de::Content as _serde::Deserialize>::deserialize(__deserializer));\n@@ -915,8 +1006,7 @@ fn deserialize_untagged_enum(ident: &syn::Ident,\n     }\n }\n \n-fn deserialize_externally_tagged_variant(ident: &syn::Ident,\n-                                         params: &Parameters,\n+fn deserialize_externally_tagged_variant(params: &Parameters,\n                                          variant: &Variant,\n                                          item_attrs: &attr::Item)\n                                          -> Fragment {\n@@ -924,28 +1014,26 @@ fn deserialize_externally_tagged_variant(ident: &syn::Ident,\n \n     match variant.style {\n         Style::Unit => {\n+            let this = &params.this;\n             quote_block! {\n                 try!(_serde::de::VariantVisitor::visit_unit(__visitor));\n-                _serde::export::Ok(#ident::#variant_ident)\n+                _serde::export::Ok(#this::#variant_ident)\n             }\n         }\n         Style::Newtype => {\n-            deserialize_externally_tagged_newtype_variant(ident,\n-                                                          variant_ident,\n+            deserialize_externally_tagged_newtype_variant(variant_ident,\n                                                           params,\n                                                           &variant.fields[0])\n         }\n         Style::Tuple => {\n-            deserialize_tuple(ident,\n-                              Some(variant_ident),\n+            deserialize_tuple(Some(variant_ident),\n                               params,\n                               &variant.fields,\n                               item_attrs,\n                               None)\n         }\n         Style::Struct => {\n-            deserialize_struct(ident,\n-                               Some(variant_ident),\n+            deserialize_struct(Some(variant_ident),\n                                params,\n                                &variant.fields,\n                                item_attrs,\n@@ -954,8 +1042,7 @@ fn deserialize_externally_tagged_variant(ident: &syn::Ident,\n     }\n }\n \n-fn deserialize_internally_tagged_variant(ident: &syn::Ident,\n-                                         params: &Parameters,\n+fn deserialize_internally_tagged_variant(params: &Parameters,\n                                          variant: &Variant,\n                                          item_attrs: &attr::Item,\n                                          deserializer: Tokens)\n@@ -964,16 +1051,16 @@ fn deserialize_internally_tagged_variant(ident: &syn::Ident,\n \n     match variant.style {\n         Style::Unit => {\n-            let type_name = ident.as_ref();\n+            let this = &params.this;\n+            let type_name = params.type_name();\n             let variant_name = variant.ident.as_ref();\n             quote_block! {\n                 try!(_serde::Deserializer::deserialize(#deserializer, _serde::private::de::InternallyTaggedUnitVisitor::new(#type_name, #variant_name)));\n-                _serde::export::Ok(#ident::#variant_ident)\n+                _serde::export::Ok(#this::#variant_ident)\n             }\n         }\n         Style::Newtype | Style::Struct => {\n-            deserialize_untagged_variant(ident,\n-                                         params,\n+            deserialize_untagged_variant(params,\n                                          variant,\n                                          item_attrs,\n                                          deserializer)\n@@ -982,8 +1069,7 @@ fn deserialize_internally_tagged_variant(ident: &syn::Ident,\n     }\n }\n \n-fn deserialize_untagged_variant(ident: &syn::Ident,\n-                                params: &Parameters,\n+fn deserialize_untagged_variant(params: &Parameters,\n                                 variant: &Variant,\n                                 item_attrs: &attr::Item,\n                                 deserializer: Tokens)\n@@ -992,7 +1078,8 @@ fn deserialize_untagged_variant(ident: &syn::Ident,\n \n     match variant.style {\n         Style::Unit => {\n-            let type_name = ident.as_ref();\n+            let this = &params.this;\n+            let type_name = params.type_name();\n             let variant_name = variant.ident.as_ref();\n             quote_expr! {\n                 _serde::export::Result::map(\n@@ -1000,27 +1087,24 @@ fn deserialize_untagged_variant(ident: &syn::Ident,\n                         #deserializer,\n                         _serde::private::de::UntaggedUnitVisitor::new(#type_name, #variant_name)\n                     ),\n-                    |()| #ident::#variant_ident)\n+                    |()| #this::#variant_ident)\n             }\n         }\n         Style::Newtype => {\n-            deserialize_untagged_newtype_variant(ident,\n-                                                 variant_ident,\n+            deserialize_untagged_newtype_variant(variant_ident,\n                                                  params,\n                                                  &variant.fields[0],\n                                                  deserializer)\n         }\n         Style::Tuple => {\n-            deserialize_tuple(ident,\n-                              Some(variant_ident),\n+            deserialize_tuple(Some(variant_ident),\n                               params,\n                               &variant.fields,\n                               item_attrs,\n                               Some(deserializer))\n         }\n         Style::Struct => {\n-            deserialize_struct(ident,\n-                               Some(variant_ident),\n+            deserialize_struct(Some(variant_ident),\n                                params,\n                                &variant.fields,\n                                item_attrs,\n@@ -1029,56 +1113,56 @@ fn deserialize_untagged_variant(ident: &syn::Ident,\n     }\n }\n \n-fn deserialize_externally_tagged_newtype_variant(ident: &syn::Ident,\n-                                                 variant_ident: &syn::Ident,\n+fn deserialize_externally_tagged_newtype_variant(variant_ident: &syn::Ident,\n                                                  params: &Parameters,\n                                                  field: &Field)\n                                                  -> Fragment {\n+    let this = &params.this;\n     match field.attrs.deserialize_with() {\n         None => {\n             let field_ty = &field.ty;\n             quote_expr! {\n                 _serde::export::Result::map(\n                     _serde::de::VariantVisitor::visit_newtype::<#field_ty>(__visitor),\n-                    #ident::#variant_ident)\n+                    #this::#variant_ident)\n             }\n         }\n         Some(path) => {\n             let (wrapper, wrapper_ty) =\n-                wrap_deserialize_with(ident, params, field.ty, path);\n+                wrap_deserialize_with(params, field.ty, path);\n             quote_block! {\n                 #wrapper\n                 _serde::export::Result::map(\n                     _serde::de::VariantVisitor::visit_newtype::<#wrapper_ty>(__visitor),\n-                    |__wrapper| #ident::#variant_ident(__wrapper.value))\n+                    |__wrapper| #this::#variant_ident(__wrapper.value))\n             }\n         }\n     }\n }\n \n-fn deserialize_untagged_newtype_variant(ident: &syn::Ident,\n-                                        variant_ident: &syn::Ident,\n+fn deserialize_untagged_newtype_variant(variant_ident: &syn::Ident,\n                                         params: &Parameters,\n                                         field: &Field,\n                                         deserializer: Tokens)\n                                         -> Fragment {\n+    let this = &params.this;\n     match field.attrs.deserialize_with() {\n         None => {\n             let field_ty = &field.ty;\n             quote_expr! {\n                 _serde::export::Result::map(\n                     <#field_ty as _serde::Deserialize>::deserialize(#deserializer),\n-                    #ident::#variant_ident)\n+                    #this::#variant_ident)\n             }\n         }\n         Some(path) => {\n             let (wrapper, wrapper_ty) =\n-                wrap_deserialize_with(ident, params, field.ty, path);\n+                wrap_deserialize_with(params, field.ty, path);\n             quote_block! {\n                 #wrapper\n                 _serde::export::Result::map(\n                     <#wrapper_ty as _serde::Deserialize>::deserialize(#deserializer),\n-                    |__wrapper| #ident::#variant_ident(__wrapper.value))\n+                    |__wrapper| #this::#variant_ident(__wrapper.value))\n             }\n         }\n     }\n@@ -1196,8 +1280,7 @@ fn deserialize_field_visitor(fields: Vec<(String, Ident)>,\n     }\n }\n \n-fn deserialize_struct_visitor(ident: &syn::Ident,\n-                              struct_path: Tokens,\n+fn deserialize_struct_visitor(struct_path: Tokens,\n                               params: &Parameters,\n                               fields: &[Field],\n                               item_attrs: &attr::Item)\n@@ -1217,13 +1300,12 @@ fn deserialize_struct_visitor(ident: &syn::Ident,\n \n     let field_visitor = deserialize_field_visitor(field_names_idents, item_attrs, false);\n \n-    let visit_map = deserialize_map(ident, struct_path, params, fields, item_attrs);\n+    let visit_map = deserialize_map(struct_path, params, fields, item_attrs);\n \n     (field_visitor, fields_stmt, visit_map)\n }\n \n-fn deserialize_map(ident: &syn::Ident,\n-                   struct_path: Tokens,\n+fn deserialize_map(struct_path: Tokens,\n                    params: &Parameters,\n                    fields: &[Field],\n                    item_attrs: &attr::Item)\n@@ -1259,7 +1341,7 @@ fn deserialize_map(ident: &syn::Ident,\n                 }\n                 Some(path) => {\n                     let (wrapper, wrapper_ty) = wrap_deserialize_with(\n-                        ident, params, field.ty, path);\n+                        params, field.ty, path);\n                     quote!({\n                         #wrapper\n                         try!(_serde::de::MapVisitor::visit_value::<#wrapper_ty>(&mut __visitor)).value\n@@ -1347,6 +1429,14 @@ fn deserialize_map(ident: &syn::Ident,\n         }\n     };\n \n+    let mut result = quote!(#struct_path { #(#result),* });\n+    if params.has_getter {\n+        let this = &params.this;\n+        result = quote! {\n+            _serde::export::Into::<#this>::into(#result)\n+        };\n+    }\n+\n     quote_block! {\n         #(#let_values)*\n \n@@ -1356,7 +1446,7 @@ fn deserialize_map(ident: &syn::Ident,\n \n         #(#extract_values)*\n \n-        _serde::export::Ok(#struct_path { #(#result),* })\n+        _serde::export::Ok(#result)\n     }\n }\n \n@@ -1366,17 +1456,17 @@ fn field_i(i: usize) -> Ident {\n \n /// This function wraps the expression in `#[serde(deserialize_with = \"...\")]`\n /// in a trait to prevent it from accessing the internal `Deserialize` state.\n-fn wrap_deserialize_with(ident: &syn::Ident,\n-                         params: &Parameters,\n+fn wrap_deserialize_with(params: &Parameters,\n                          field_ty: &syn::Ty,\n                          deserialize_with: &syn::Path)\n                          -> (Tokens, Tokens) {\n+    let this = &params.this;\n     let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params);\n \n     let wrapper = quote! {\n         struct __DeserializeWith #de_impl_generics #where_clause {\n             value: #field_ty,\n-            phantom: _serde::export::PhantomData<#ident #ty_generics>,\n+            phantom: _serde::export::PhantomData<#this #ty_generics>,\n             lifetime: _serde::export::PhantomData<&'de ()>,\n         }\n \n@@ -1437,11 +1527,7 @@ struct DeImplGenerics<'a>(&'a Parameters);\n impl<'a> ToTokens for DeImplGenerics<'a> {\n     fn to_tokens(&self, tokens: &mut Tokens) {\n         let mut generics = self.0.generics.clone();\n-        generics.lifetimes.insert(0, syn::LifetimeDef {\n-            attrs: Vec::new(),\n-            lifetime: syn::Lifetime::new(\"'de\"),\n-            bounds: self.0.borrowed.iter().cloned().collect(),\n-        });\n+        generics.lifetimes.insert(0, self.0.de_lifetime_def());\n         let (impl_generics, _, _) = generics.split_for_impl();\n         impl_generics.to_tokens(tokens);\n     }\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 51826928b..7b893e440 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -12,15 +12,23 @@ pub fn expand_derive_serialize(item: &syn::DeriveInput) -> Result<Tokens, String\n     try!(ctxt.check());\n \n     let ident = &item.ident;\n-    let generics = build_generics(&item);\n-    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n+    let params = Parameters::new(&item);\n+    let (impl_generics, ty_generics, where_clause) = params.generics.split_for_impl();\n     let dummy_const = Ident::new(format!(\"_IMPL_SERIALIZE_FOR_{}\", ident));\n-    let body = Stmts(serialize_body(&item, &generics));\n+    let body = Stmts(serialize_body(&item, &params));\n \n-    Ok(quote! {\n-        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n-        const #dummy_const: () = {\n-            extern crate serde as _serde;\n+    let impl_item = if let Some(remote) = item.attrs.remote() {\n+        quote! {\n+            impl #impl_generics #ident #ty_generics #where_clause {\n+                fn serialize<__S>(__self: &#remote #ty_generics, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n+                    where __S: _serde::Serializer\n+                {\n+                    #body\n+                }\n+            }\n+        }\n+    } else {\n+        quote! {\n             #[automatically_derived]\n             impl #impl_generics _serde::Serialize for #ident #ty_generics #where_clause {\n                 fn serialize<__S>(&self, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n@@ -29,10 +37,66 @@ pub fn expand_derive_serialize(item: &syn::DeriveInput) -> Result<Tokens, String\n                     #body\n                 }\n             }\n+        }\n+    };\n+\n+    Ok(quote! {\n+        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n+        const #dummy_const: () = {\n+            extern crate serde as _serde;\n+            #impl_item\n         };\n     })\n }\n \n+struct Parameters {\n+    /// Variable holding the value being serialized. Either `self` for local\n+    /// types or `__self` for remote types.\n+    self_var: Ident,\n+\n+    /// Path to the type the impl is for. Either a single `Ident` for local\n+    /// types or `some::remote::Ident` for remote types. Does not include\n+    /// generic parameters.\n+    this: syn::Path,\n+\n+    /// Generics including any explicit and inferred bounds for the impl.\n+    generics: syn::Generics,\n+\n+    /// Type has a `serde(remote = \"...\")` attribute.\n+    is_remote: bool,\n+}\n+\n+impl Parameters {\n+    fn new(item: &Item) -> Self {\n+        let is_remote = item.attrs.remote().is_some();\n+        let self_var = if is_remote {\n+            Ident::new(\"__self\")\n+        } else {\n+            Ident::new(\"self\")\n+        };\n+\n+        let this = match item.attrs.remote() {\n+            Some(remote) => remote.clone(),\n+            None => item.ident.clone().into(),\n+        };\n+\n+        let generics = build_generics(item);\n+\n+        Parameters {\n+            self_var: self_var,\n+            this: this,\n+            generics: generics,\n+            is_remote: is_remote,\n+        }\n+    }\n+\n+    /// Type name to use in error messages and `&'static str` arguments to\n+    /// various Serializer methods.\n+    fn type_name(&self) -> &str {\n+        self.this.segments.last().unwrap().ident.as_ref()\n+    }\n+}\n+\n // All the generics in the input, plus a bound `T: Serialize` for each generic\n // field type that will be serialized by us.\n fn build_generics(item: &Item) -> syn::Generics {\n@@ -60,38 +124,39 @@ fn needs_serialize_bound(attrs: &attr::Field) -> bool {\n     !attrs.skip_serializing() && attrs.serialize_with().is_none() && attrs.ser_bound().is_none()\n }\n \n-fn serialize_body(item: &Item, generics: &syn::Generics) -> Fragment {\n+fn serialize_body(item: &Item, params: &Parameters) -> Fragment {\n     if let Some(into_type) = item.attrs.into_type() {\n-        serialize_into(into_type)\n+        serialize_into(params, into_type)\n     } else {\n         match item.body {\n             Body::Enum(ref variants) => {\n-                serialize_item_enum(&item.ident, generics, variants, &item.attrs)\n+                serialize_item_enum(params, variants, &item.attrs)\n             }\n             Body::Struct(Style::Struct, ref fields) => {\n                 if fields.iter().any(|field| field.ident.is_none()) {\n                     panic!(\"struct has unnamed fields\");\n                 }\n-                serialize_struct(&item.ident, generics, fields, &item.attrs)\n+                serialize_struct(params, fields, &item.attrs)\n             }\n             Body::Struct(Style::Tuple, ref fields) => {\n                 if fields.iter().any(|field| field.ident.is_some()) {\n                     panic!(\"tuple struct has named fields\");\n                 }\n-                serialize_tuple_struct(&item.ident, generics, fields, &item.attrs)\n+                serialize_tuple_struct(params, fields, &item.attrs)\n             }\n             Body::Struct(Style::Newtype, ref fields) => {\n-                serialize_newtype_struct(&item.ident, generics, &fields[0], &item.attrs)\n+                serialize_newtype_struct(params, &fields[0], &item.attrs)\n             }\n             Body::Struct(Style::Unit, _) => serialize_unit_struct(&item.attrs),\n         }\n     }\n }\n \n-fn serialize_into(into_type: &syn::Ty) -> Fragment {\n+fn serialize_into(params: &Parameters, into_type: &syn::Ty) -> Fragment {\n+    let self_var = &params.self_var;\n     quote_block! {\n         _serde::Serialize::serialize(\n-            &<Self as _serde::export::Into<#into_type>>::into(_serde::export::Clone::clone(self)),\n+            &_serde::export::Into::<#into_type>::into(_serde::export::Clone::clone(#self_var)),\n             __serializer)\n     }\n }\n@@ -104,16 +169,15 @@ fn serialize_unit_struct(item_attrs: &attr::Item) -> Fragment {\n     }\n }\n \n-fn serialize_newtype_struct(ident: &syn::Ident,\n-                            generics: &syn::Generics,\n+fn serialize_newtype_struct(params: &Parameters,\n                             field: &Field,\n                             item_attrs: &attr::Item)\n                             -> Fragment {\n     let type_name = item_attrs.name().serialize_name();\n \n-    let mut field_expr = quote!(&self.0);\n+    let mut field_expr = get_field(params, field, 0);\n     if let Some(path) = field.attrs.serialize_with() {\n-        field_expr = wrap_serialize_with(ident, generics, field.ty, path, field_expr);\n+        field_expr = wrap_serialize_with(params, field.ty, path, field_expr);\n     }\n \n     quote_expr! {\n@@ -121,15 +185,13 @@ fn serialize_newtype_struct(ident: &syn::Ident,\n     }\n }\n \n-fn serialize_tuple_struct(ident: &syn::Ident,\n-                          generics: &syn::Generics,\n+fn serialize_tuple_struct(params: &Parameters,\n                           fields: &[Field],\n                           item_attrs: &attr::Item)\n                           -> Fragment {\n     let serialize_stmts =\n-        serialize_tuple_struct_visitor(ident,\n-                                       fields,\n-                                       generics,\n+        serialize_tuple_struct_visitor(fields,\n+                                       params,\n                                        false,\n                                        quote!(_serde::ser::SerializeTupleStruct::serialize_field));\n \n@@ -144,15 +206,13 @@ fn serialize_tuple_struct(ident: &syn::Ident,\n     }\n }\n \n-fn serialize_struct(ident: &syn::Ident,\n-                    generics: &syn::Generics,\n+fn serialize_struct(params: &Parameters,\n                     fields: &[Field],\n                     item_attrs: &attr::Item)\n                     -> Fragment {\n     let serialize_fields =\n-        serialize_struct_visitor(ident,\n-                                 fields,\n-                                 generics,\n+        serialize_struct_visitor(fields,\n+                                 params,\n                                  false,\n                                  quote!(_serde::ser::SerializeStruct::serialize_field));\n \n@@ -165,12 +225,13 @@ fn serialize_struct(ident: &syn::Ident,\n     let let_mut = mut_if(serialized_fields.peek().is_some());\n \n     let len = serialized_fields.map(|field| {\n-            let ident = field.ident.clone().expect(\"struct has unnamed fields\");\n-            let field_expr = quote!(&self.#ident);\n-\n             match field.attrs.skip_serializing_if() {\n-                Some(path) => quote!(if #path(#field_expr) { 0 } else { 1 }),\n                 None => quote!(1),\n+                Some(path) => {\n+                    let ident = field.ident.clone().expect(\"struct has unnamed fields\");\n+                    let field_expr = get_field(params, field, ident);\n+                    quote!(if #path(#field_expr) { 0 } else { 1 })\n+                }\n             }\n         })\n         .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n@@ -182,16 +243,16 @@ fn serialize_struct(ident: &syn::Ident,\n     }\n }\n \n-fn serialize_item_enum(ident: &syn::Ident,\n-                       generics: &syn::Generics,\n+fn serialize_item_enum(params: &Parameters,\n                        variants: &[Variant],\n                        item_attrs: &attr::Item)\n                        -> Fragment {\n+    let self_var = &params.self_var;\n+\n     let arms: Vec<_> = variants.iter()\n         .enumerate()\n         .map(|(variant_index, variant)| {\n-            serialize_variant(ident,\n-                              generics,\n+            serialize_variant(params,\n                               variant,\n                               variant_index,\n                               item_attrs)\n@@ -199,23 +260,23 @@ fn serialize_item_enum(ident: &syn::Ident,\n         .collect();\n \n     quote_expr! {\n-        match *self {\n+        match *#self_var {\n             #(#arms)*\n         }\n     }\n }\n \n-fn serialize_variant(ident: &syn::Ident,\n-                     generics: &syn::Generics,\n+fn serialize_variant(params: &Parameters,\n                      variant: &Variant,\n                      variant_index: usize,\n                      item_attrs: &attr::Item)\n                      -> Tokens {\n+    let this = &params.this;\n     let variant_ident = variant.ident.clone();\n \n     if variant.attrs.skip_serializing() {\n         let skipped_msg = format!(\"the enum variant {}::{} cannot be serialized\",\n-                                  ident, variant_ident);\n+                                  params.type_name(), variant_ident);\n         let skipped_err = quote! {\n             _serde::export::Err(_serde::ser::Error::custom(#skipped_msg))\n         };\n@@ -225,26 +286,26 @@ fn serialize_variant(ident: &syn::Ident,\n             Style::Struct => quote!( {..} ),\n         };\n         quote! {\n-            #ident::#variant_ident #fields_pat => #skipped_err,\n+            #this::#variant_ident #fields_pat => #skipped_err,\n         }\n     } else {\n         // variant wasn't skipped\n         let case = match variant.style {\n             Style::Unit => {\n                 quote! {\n-                    #ident::#variant_ident\n+                    #this::#variant_ident\n                 }\n             }\n             Style::Newtype => {\n                 quote! {\n-                    #ident::#variant_ident(ref __field0)\n+                    #this::#variant_ident(ref __field0)\n                 }\n             }\n             Style::Tuple => {\n                 let field_names = (0..variant.fields.len())\n                     .map(|i| Ident::new(format!(\"__field{}\", i)));\n                 quote! {\n-                    #ident::#variant_ident(#(ref #field_names),*)\n+                    #this::#variant_ident(#(ref #field_names),*)\n                 }\n             }\n             Style::Struct => {\n@@ -252,35 +313,32 @@ fn serialize_variant(ident: &syn::Ident,\n                     .iter()\n                     .map(|f| f.ident.clone().expect(\"struct variant has unnamed fields\"));\n                 quote! {\n-                    #ident::#variant_ident { #(ref #fields),* }\n+                    #this::#variant_ident { #(ref #fields),* }\n                 }\n             }\n         };\n \n         let body = Match(match *item_attrs.tag() {\n             attr::EnumTag::External => {\n-                serialize_externally_tagged_variant(ident,\n-                                                    generics,\n+                serialize_externally_tagged_variant(params,\n                                                     variant,\n                                                     variant_index,\n                                                     item_attrs)\n             }\n             attr::EnumTag::Internal { ref tag } => {\n-                serialize_internally_tagged_variant(ident,\n-                                                    generics,\n+                serialize_internally_tagged_variant(params,\n                                                     variant,\n                                                     item_attrs,\n                                                     tag)\n             }\n             attr::EnumTag::Adjacent { ref tag, ref content } => {\n-                serialize_adjacently_tagged_variant(ident,\n-                                                    generics,\n+                serialize_adjacently_tagged_variant(params,\n                                                     variant,\n                                                     item_attrs,\n                                                     tag,\n                                                     content)\n             }\n-            attr::EnumTag::None => serialize_untagged_variant(ident, generics, variant, item_attrs),\n+            attr::EnumTag::None => serialize_untagged_variant(params, variant, item_attrs),\n         });\n \n         quote! {\n@@ -289,8 +347,7 @@ fn serialize_variant(ident: &syn::Ident,\n     }\n }\n \n-fn serialize_externally_tagged_variant(ident: &syn::Ident,\n-                                       generics: &syn::Generics,\n+fn serialize_externally_tagged_variant(params: &Parameters,\n                                        variant: &Variant,\n                                        variant_index: usize,\n                                        item_attrs: &attr::Item)\n@@ -313,7 +370,7 @@ fn serialize_externally_tagged_variant(ident: &syn::Ident,\n             let field = &variant.fields[0];\n             let mut field_expr = quote!(__field0);\n             if let Some(path) = field.attrs.serialize_with() {\n-                field_expr = wrap_serialize_with(ident, generics, field.ty, path, field_expr);\n+                field_expr = wrap_serialize_with(params, field.ty, path, field_expr);\n             }\n \n             quote_expr! {\n@@ -332,8 +389,7 @@ fn serialize_externally_tagged_variant(ident: &syn::Ident,\n                                         variant_index: variant_index,\n                                         variant_name: variant_name,\n                                     },\n-                                    ident,\n-                                    generics,\n+                                    params,\n                                     &variant.fields)\n         }\n         Style::Struct => {\n@@ -341,16 +397,14 @@ fn serialize_externally_tagged_variant(ident: &syn::Ident,\n                                          variant_index: variant_index,\n                                          variant_name: variant_name,\n                                      },\n-                                     ident,\n-                                     generics,\n+                                     params,\n                                      &variant.fields,\n                                      &type_name)\n         }\n     }\n }\n \n-fn serialize_internally_tagged_variant(ident: &syn::Ident,\n-                                       generics: &syn::Generics,\n+fn serialize_internally_tagged_variant(params: &Parameters,\n                                        variant: &Variant,\n                                        item_attrs: &attr::Item,\n                                        tag: &str)\n@@ -358,7 +412,7 @@ fn serialize_internally_tagged_variant(ident: &syn::Ident,\n     let type_name = item_attrs.name().serialize_name();\n     let variant_name = variant.attrs.name().serialize_name();\n \n-    let enum_ident_str = ident.as_ref();\n+    let enum_ident_str = params.type_name();\n     let variant_ident_str = variant.ident.as_ref();\n \n     match variant.style {\n@@ -375,7 +429,7 @@ fn serialize_internally_tagged_variant(ident: &syn::Ident,\n             let field = &variant.fields[0];\n             let mut field_expr = quote!(__field0);\n             if let Some(path) = field.attrs.serialize_with() {\n-                field_expr = wrap_serialize_with(ident, generics, field.ty, path, field_expr);\n+                field_expr = wrap_serialize_with(params, field.ty, path, field_expr);\n             }\n \n             quote_expr! {\n@@ -394,8 +448,7 @@ fn serialize_internally_tagged_variant(ident: &syn::Ident,\n                                          tag: tag,\n                                          variant_name: variant_name,\n                                      },\n-                                     ident,\n-                                     generics,\n+                                     params,\n                                      &variant.fields,\n                                      &type_name)\n         }\n@@ -403,13 +456,13 @@ fn serialize_internally_tagged_variant(ident: &syn::Ident,\n     }\n }\n \n-fn serialize_adjacently_tagged_variant(ident: &syn::Ident,\n-                                       generics: &syn::Generics,\n+fn serialize_adjacently_tagged_variant(params: &Parameters,\n                                        variant: &Variant,\n                                        item_attrs: &attr::Item,\n                                        tag: &str,\n                                        content: &str)\n                                        -> Fragment {\n+    let this = &params.this;\n     let type_name = item_attrs.name().serialize_name();\n     let variant_name = variant.attrs.name().serialize_name();\n \n@@ -427,7 +480,7 @@ fn serialize_adjacently_tagged_variant(ident: &syn::Ident,\n             let field = &variant.fields[0];\n             let mut field_expr = quote!(__field0);\n             if let Some(path) = field.attrs.serialize_with() {\n-                field_expr = wrap_serialize_with(ident, generics, field.ty, path, field_expr);\n+                field_expr = wrap_serialize_with(params, field.ty, path, field_expr);\n             }\n \n             quote_expr! {\n@@ -436,14 +489,12 @@ fn serialize_adjacently_tagged_variant(ident: &syn::Ident,\n         }\n         Style::Tuple => {\n             serialize_tuple_variant(TupleVariant::Untagged,\n-                                    ident,\n-                                    generics,\n+                                    params,\n                                     &variant.fields)\n         }\n         Style::Struct => {\n             serialize_struct_variant(StructVariant::Untagged,\n-                                     ident,\n-                                     generics,\n+                                     params,\n                                      &variant.fields,\n                                      &variant_name)\n         }\n@@ -466,15 +517,15 @@ fn serialize_adjacently_tagged_variant(ident: &syn::Ident,\n         }\n     };\n \n-    let (_, ty_generics, where_clause) = generics.split_for_impl();\n+    let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n \n-    let wrapper_generics = bound::with_lifetime_bound(generics, \"'__a\");\n+    let wrapper_generics = bound::with_lifetime_bound(&params.generics, \"'__a\");\n     let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n \n     quote_block! {\n         struct __AdjacentlyTagged #wrapper_generics #where_clause {\n             data: (#(&'__a #fields_ty,)*),\n-            phantom: _serde::export::PhantomData<#ident #ty_generics>,\n+            phantom: _serde::export::PhantomData<#this #ty_generics>,\n         }\n \n         impl #wrapper_impl_generics _serde::Serialize for __AdjacentlyTagged #wrapper_ty_generics #where_clause {\n@@ -493,14 +544,13 @@ fn serialize_adjacently_tagged_variant(ident: &syn::Ident,\n         try!(_serde::ser::SerializeStruct::serialize_field(\n             &mut __struct, #content, &__AdjacentlyTagged {\n                 data: (#(#fields_ident,)*),\n-                phantom: _serde::export::PhantomData::<#ident #ty_generics>,\n+                phantom: _serde::export::PhantomData::<#this #ty_generics>,\n             }));\n         _serde::ser::SerializeStruct::end(__struct)\n     }\n }\n \n-fn serialize_untagged_variant(ident: &syn::Ident,\n-                              generics: &syn::Generics,\n+fn serialize_untagged_variant(params: &Parameters,\n                               variant: &Variant,\n                               item_attrs: &attr::Item)\n                               -> Fragment {\n@@ -514,7 +564,7 @@ fn serialize_untagged_variant(ident: &syn::Ident,\n             let field = &variant.fields[0];\n             let mut field_expr = quote!(__field0);\n             if let Some(path) = field.attrs.serialize_with() {\n-                field_expr = wrap_serialize_with(ident, generics, field.ty, path, field_expr);\n+                field_expr = wrap_serialize_with(params, field.ty, path, field_expr);\n             }\n \n             quote_expr! {\n@@ -522,13 +572,12 @@ fn serialize_untagged_variant(ident: &syn::Ident,\n             }\n         }\n         Style::Tuple => {\n-            serialize_tuple_variant(TupleVariant::Untagged, ident, generics, &variant.fields)\n+            serialize_tuple_variant(TupleVariant::Untagged, params, &variant.fields)\n         }\n         Style::Struct => {\n             let type_name = item_attrs.name().serialize_name();\n             serialize_struct_variant(StructVariant::Untagged,\n-                                     ident,\n-                                     generics,\n+                                     params,\n                                      &variant.fields,\n                                      &type_name)\n         }\n@@ -545,8 +594,7 @@ enum TupleVariant {\n }\n \n fn serialize_tuple_variant(context: TupleVariant,\n-                           ident: &syn::Ident,\n-                           generics: &syn::Generics,\n+                           params: &Parameters,\n                            fields: &[Field])\n                            -> Fragment {\n     let method = match context {\n@@ -557,7 +605,7 @@ fn serialize_tuple_variant(context: TupleVariant,\n     };\n \n     let serialize_stmts =\n-        serialize_tuple_struct_visitor(ident, fields, generics, true, method);\n+        serialize_tuple_struct_visitor(fields, params, true, method);\n \n     let len = serialize_stmts.len();\n     let let_mut = mut_if(len > 0);\n@@ -597,8 +645,7 @@ enum StructVariant<'a> {\n }\n \n fn serialize_struct_variant<'a>(context: StructVariant<'a>,\n-                                ident: &syn::Ident,\n-                                generics: &syn::Generics,\n+                                params: &Parameters,\n                                 fields: &[Field],\n                                 name: &str)\n                                 -> Fragment {\n@@ -610,7 +657,7 @@ fn serialize_struct_variant<'a>(context: StructVariant<'a>,\n         StructVariant::Untagged => quote!(_serde::ser::SerializeStruct::serialize_field),\n     };\n \n-    let serialize_fields = serialize_struct_visitor(ident, fields, generics, true, method);\n+    let serialize_fields = serialize_struct_visitor(fields, params, true, method);\n \n     let mut serialized_fields = fields.iter()\n         .filter(|&field| !field.attrs.skip_serializing())\n@@ -672,9 +719,8 @@ fn serialize_struct_variant<'a>(context: StructVariant<'a>,\n     }\n }\n \n-fn serialize_tuple_struct_visitor(ident: &syn::Ident,\n-                                  fields: &[Field],\n-                                  generics: &syn::Generics,\n+fn serialize_tuple_struct_visitor(fields: &[Field],\n+                                  params: &Parameters,\n                                   is_enum: bool,\n                                   func: Tokens)\n                                   -> Vec<Tokens> {\n@@ -685,8 +731,7 @@ fn serialize_tuple_struct_visitor(ident: &syn::Ident,\n                 let id = Ident::new(format!(\"__field{}\", i));\n                 quote!(#id)\n             } else {\n-                let i = Ident::new(i);\n-                quote!(&self.#i)\n+                get_field(params, field, i)\n             };\n \n             let skip = field.attrs\n@@ -695,7 +740,7 @@ fn serialize_tuple_struct_visitor(ident: &syn::Ident,\n \n             if let Some(path) = field.attrs.serialize_with() {\n                 field_expr =\n-                    wrap_serialize_with(ident, generics, field.ty, path, field_expr);\n+                    wrap_serialize_with(params, field.ty, path, field_expr);\n             }\n \n             let ser = quote! {\n@@ -710,9 +755,8 @@ fn serialize_tuple_struct_visitor(ident: &syn::Ident,\n         .collect()\n }\n \n-fn serialize_struct_visitor(ident: &syn::Ident,\n-                            fields: &[Field],\n-                            generics: &syn::Generics,\n+fn serialize_struct_visitor(fields: &[Field],\n+                            params: &Parameters,\n                             is_enum: bool,\n                             func: Tokens)\n                             -> Vec<Tokens> {\n@@ -723,7 +767,7 @@ fn serialize_struct_visitor(ident: &syn::Ident,\n             let mut field_expr = if is_enum {\n                 quote!(#field_ident)\n             } else {\n-                quote!(&self.#field_ident)\n+                get_field(params, field, field_ident)\n             };\n \n             let key_expr = field.attrs.name().serialize_name();\n@@ -734,7 +778,7 @@ fn serialize_struct_visitor(ident: &syn::Ident,\n \n             if let Some(path) = field.attrs.serialize_with() {\n                 field_expr =\n-                    wrap_serialize_with(ident, generics, field.ty, path, field_expr)\n+                    wrap_serialize_with(params, field.ty, path, field_expr)\n             }\n \n             let ser = quote! {\n@@ -749,21 +793,21 @@ fn serialize_struct_visitor(ident: &syn::Ident,\n         .collect()\n }\n \n-fn wrap_serialize_with(ident: &syn::Ident,\n-                       generics: &syn::Generics,\n+fn wrap_serialize_with(params: &Parameters,\n                        field_ty: &syn::Ty,\n                        serialize_with: &syn::Path,\n                        value: Tokens)\n                        -> Tokens {\n-    let (_, ty_generics, where_clause) = generics.split_for_impl();\n+    let this = &params.this;\n+    let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n \n-    let wrapper_generics = bound::with_lifetime_bound(generics, \"'__a\");\n+    let wrapper_generics = bound::with_lifetime_bound(&params.generics, \"'__a\");\n     let (wrapper_impl_generics, wrapper_ty_generics, _) = wrapper_generics.split_for_impl();\n \n     quote!({\n         struct __SerializeWith #wrapper_impl_generics #where_clause {\n             value: &'__a #field_ty,\n-            phantom: _serde::export::PhantomData<#ident #ty_generics>,\n+            phantom: _serde::export::PhantomData<#this #ty_generics>,\n         }\n \n         impl #wrapper_impl_generics _serde::Serialize for __SerializeWith #wrapper_ty_generics #where_clause {\n@@ -776,7 +820,7 @@ fn wrap_serialize_with(ident: &syn::Ident,\n \n         &__SerializeWith {\n             value: #value,\n-            phantom: _serde::export::PhantomData::<#ident #ty_generics>,\n+            phantom: _serde::export::PhantomData::<#this #ty_generics>,\n         }\n     })\n }\n@@ -790,3 +834,27 @@ fn wrap_serialize_with(ident: &syn::Ident,\n fn mut_if(is_mut: bool) -> Option<Tokens> {\n     if is_mut { Some(quote!(mut)) } else { None }\n }\n+\n+fn get_field<I>(params: &Parameters, field: &Field, ident: I) -> Tokens\n+    where I: Into<Ident>\n+{\n+    let self_var = &params.self_var;\n+    match (params.is_remote, field.attrs.getter()) {\n+        (false, None) => {\n+            let ident = ident.into();\n+            quote!(&#self_var.#ident)\n+        }\n+        (true, None) => {\n+            let ty = field.ty;\n+            let ident = ident.into();\n+            quote!(_serde::private::ser::constrain::<#ty>(&#self_var.#ident))\n+        }\n+        (true, Some(getter)) => {\n+            let ty = field.ty;\n+            quote!(_serde::private::ser::constrain::<#ty>(&#getter(#self_var)))\n+        }\n+        (false, Some(_)) => {\n+            unreachable!(\"getter is only allowed for remote impls\");\n+        }\n+    }\n+}\n", "test_patch": "diff --git a/test_suite/tests/compile-fail/remote/bad_getter.rs b/test_suite/tests/compile-fail/remote/bad_getter.rs\nnew file mode 100644\nindex 000000000..3495a10b4\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/remote/bad_getter.rs\n@@ -0,0 +1,17 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+mod remote {\n+    pub struct S {\n+        a: u8,\n+    }\n+}\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[serde(remote = \"remote::S\")]\n+struct S {\n+    #[serde(getter = \"~~~\")] //~^^^ HELP: failed to parse path: \"~~~\"\n+    a: u8,\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/remote/bad_remote.rs b/test_suite/tests/compile-fail/remote/bad_remote.rs\nnew file mode 100644\nindex 000000000..5ef17670a\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/remote/bad_remote.rs\n@@ -0,0 +1,16 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+mod remote {\n+    pub struct S {\n+        a: u8,\n+    }\n+}\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[serde(remote = \"~~~\")] //~^ HELP: failed to parse path: \"~~~\"\n+struct S {\n+    a: u8,\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/remote/enum_getter.rs b/test_suite/tests/compile-fail/remote/enum_getter.rs\nnew file mode 100644\nindex 000000000..e012cbe11\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/remote/enum_getter.rs\n@@ -0,0 +1,19 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+mod remote {\n+    pub enum E {\n+        A { a: u8 }\n+    }\n+}\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+#[serde(remote = \"remote::E\")]\n+pub enum E {\n+    A {\n+        #[serde(getter = \"get_a\")] //~^^^^ HELP: #[serde(getter = \"...\")] is not allowed in an enum\n+        a: u8,\n+    }\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/remote/missing_field.rs b/test_suite/tests/compile-fail/remote/missing_field.rs\nnew file mode 100644\nindex 000000000..3be802a65\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/remote/missing_field.rs\n@@ -0,0 +1,17 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+mod remote {\n+    pub struct S {\n+        pub a: u8,\n+        pub b: u8,\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize)] //~ ERROR: missing field `b` in initializer of `remote::S`\n+#[serde(remote = \"remote::S\")]\n+struct S {\n+    a: u8, //~^^^ ERROR: missing field `b` in initializer of `remote::S`\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/remote/nonremote_getter.rs b/test_suite/tests/compile-fail/remote/nonremote_getter.rs\nnew file mode 100644\nindex 000000000..11271e5a8\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/remote/nonremote_getter.rs\n@@ -0,0 +1,16 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: proc-macro derive panicked\n+struct S {\n+    #[serde(getter = \"S::get\")] //~^^ HELP: #[serde(getter = \"...\")] can only be used in structs that have #[serde(remote = \"...\")]\n+    a: u8,\n+}\n+\n+impl S {\n+    fn get(&self) -> u8 {\n+        self.a\n+    }\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/remote/unknown_field.rs b/test_suite/tests/compile-fail/remote/unknown_field.rs\nnew file mode 100644\nindex 000000000..8f2fa4814\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/remote/unknown_field.rs\n@@ -0,0 +1,16 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+mod remote {\n+    pub struct S {\n+        pub a: u8,\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"remote::S\")]\n+struct S {\n+    b: u8, //~^^^ ERROR: no field `b` on type `&remote::S`\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/remote/wrong_de.rs b/test_suite/tests/compile-fail/remote/wrong_de.rs\nnew file mode 100644\nindex 000000000..58a05e198\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/remote/wrong_de.rs\n@@ -0,0 +1,12 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+mod remote {\n+    pub struct S(pub u16);\n+}\n+\n+#[derive(Deserialize)] //~ ERROR: mismatched types\n+#[serde(remote = \"remote::S\")]\n+struct S(u8); //~^^ expected u16, found u8\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/remote/wrong_getter.rs b/test_suite/tests/compile-fail/remote/wrong_getter.rs\nnew file mode 100644\nindex 000000000..f767263df\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/remote/wrong_getter.rs\n@@ -0,0 +1,23 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+mod remote {\n+    pub struct S {\n+        a: u8,\n+    }\n+\n+    impl S {\n+        pub fn get(&self) -> u16 {\n+            self.a as u16\n+        }\n+    }\n+}\n+\n+#[derive(Serialize)] //~ ERROR: mismatched types\n+#[serde(remote = \"remote::S\")]\n+struct S {\n+    #[serde(getter = \"remote::S::get\")]\n+    a: u8, //~^^^^ expected u8, found u16\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/remote/wrong_ser.rs b/test_suite/tests/compile-fail/remote/wrong_ser.rs\nnew file mode 100644\nindex 000000000..bd4ca1a26\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/remote/wrong_ser.rs\n@@ -0,0 +1,16 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+mod remote {\n+    pub struct S {\n+        pub a: u16,\n+    }\n+}\n+\n+#[derive(Serialize)] //~ ERROR: mismatched types\n+#[serde(remote = \"remote::S\")]\n+struct S {\n+    a: u8, //~^^^ expected u8, found u16\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/test_remote.rs b/test_suite/tests/test_remote.rs\nnew file mode 100644\nindex 000000000..4f21a09ac\n--- /dev/null\n+++ b/test_suite/tests/test_remote.rs\n@@ -0,0 +1,184 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+extern crate serde;\n+\n+mod remote {\n+    pub struct Unit;\n+\n+    pub struct PrimitivePriv(u8);\n+\n+    pub struct PrimitivePub(pub u8);\n+\n+    pub struct NewtypePriv(Unit);\n+\n+    pub struct NewtypePub(pub Unit);\n+\n+    pub struct TuplePriv(u8, Unit);\n+\n+    pub struct TuplePub(pub u8, pub Unit);\n+\n+    pub struct StructPriv {\n+        a: u8,\n+        b: Unit,\n+    }\n+\n+    pub struct StructPub  {\n+        pub a: u8,\n+        pub b: Unit,\n+    }\n+\n+    impl PrimitivePriv {\n+        pub fn new(a: u8) -> Self {\n+            PrimitivePriv(a)\n+        }\n+\n+        pub fn get(&self) -> u8 {\n+            self.0\n+        }\n+    }\n+\n+    impl NewtypePriv {\n+        pub fn new(a: Unit) -> Self {\n+            NewtypePriv(a)\n+        }\n+\n+        pub fn get(&self) -> &Unit {\n+            &self.0\n+        }\n+    }\n+\n+    impl TuplePriv {\n+        pub fn new(a: u8, b: Unit) -> Self {\n+            TuplePriv(a, b)\n+        }\n+\n+        pub fn first(&self) -> u8 {\n+            self.0\n+        }\n+\n+        pub fn second(&self) -> &Unit {\n+            &self.1\n+        }\n+    }\n+\n+    impl StructPriv {\n+        pub fn new(a: u8, b: Unit) -> Self {\n+            StructPriv { a: a, b: b }\n+        }\n+\n+        pub fn a(&self) -> u8 {\n+            self.a\n+        }\n+\n+        pub fn b(&self) -> &Unit {\n+            &self.b\n+        }\n+    }\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+struct Test {\n+    #[serde(with = \"UnitDef\")]\n+    unit: remote::Unit,\n+\n+    #[serde(with = \"PrimitivePrivDef\")]\n+    primitive_priv: remote::PrimitivePriv,\n+\n+    #[serde(with = \"PrimitivePubDef\")]\n+    primitive_pub: remote::PrimitivePub,\n+\n+    #[serde(with = \"NewtypePrivDef\")]\n+    newtype_priv: remote::NewtypePriv,\n+\n+    #[serde(with = \"NewtypePubDef\")]\n+    newtype_pub: remote::NewtypePub,\n+\n+    #[serde(with = \"TuplePrivDef\")]\n+    tuple_priv: remote::TuplePriv,\n+\n+    #[serde(with = \"TuplePubDef\")]\n+    tuple_pub: remote::TuplePub,\n+\n+    #[serde(with = \"StructPrivDef\")]\n+    struct_priv: remote::StructPriv,\n+\n+    #[serde(with = \"StructPubDef\")]\n+    struct_pub: remote::StructPub,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"remote::Unit\")]\n+struct UnitDef;\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"remote::PrimitivePriv\")]\n+struct PrimitivePrivDef(#[serde(getter = \"remote::PrimitivePriv::get\")] u8);\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"remote::PrimitivePub\")]\n+struct PrimitivePubDef(u8);\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"remote::NewtypePriv\")]\n+struct NewtypePrivDef(#[serde(getter = \"remote::NewtypePriv::get\", with = \"UnitDef\")] remote::Unit);\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"remote::NewtypePub\")]\n+struct NewtypePubDef(#[serde(with = \"UnitDef\")] remote::Unit);\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"remote::TuplePriv\")]\n+struct TuplePrivDef(\n+    #[serde(getter = \"remote::TuplePriv::first\")] u8,\n+    #[serde(getter = \"remote::TuplePriv::second\", with = \"UnitDef\")] remote::Unit);\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"remote::TuplePub\")]\n+struct TuplePubDef(u8, #[serde(with = \"UnitDef\")] remote::Unit);\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"remote::StructPriv\")]\n+struct StructPrivDef {\n+    #[serde(getter = \"remote::StructPriv::a\")]\n+    a: u8,\n+\n+    #[serde(getter = \"remote::StructPriv::b\")]\n+    #[serde(with= \"UnitDef\")]\n+    b: remote::Unit,\n+}\n+\n+#[derive(Serialize, Deserialize)]\n+#[serde(remote = \"remote::StructPub\")]\n+struct StructPubDef {\n+    #[allow(dead_code)]\n+    a: u8,\n+\n+    #[allow(dead_code)]\n+    #[serde(with= \"UnitDef\")]\n+    b: remote::Unit,\n+}\n+\n+impl From<PrimitivePrivDef> for remote::PrimitivePriv {\n+    fn from(def: PrimitivePrivDef) -> Self {\n+        remote::PrimitivePriv::new(def.0)\n+    }\n+}\n+\n+impl From<NewtypePrivDef> for remote::NewtypePriv {\n+    fn from(def: NewtypePrivDef) -> Self {\n+        remote::NewtypePriv::new(def.0)\n+    }\n+}\n+\n+impl From<TuplePrivDef> for remote::TuplePriv {\n+    fn from(def: TuplePrivDef) -> Self {\n+        remote::TuplePriv::new(def.0, def.1)\n+    }\n+}\n+\n+impl From<StructPrivDef> for remote::StructPriv {\n+    fn from(def: StructPrivDef) -> Self {\n+        remote::StructPriv::new(def.a, def.b)\n+    }\n+}\n", "problem_statement": "Improve the newtype wrapper situation\nSomething like:\n\n``` rust\nserde_newtype! {\n    #[derive(Serialize, Deserialize)]\n    pub struct MyDuration(time::Duration);\n\n    struct time::Duration {\n        secs: u64,\n        nanos: u32,\n    }\n}\n```\n\n", "hints_text": "@nox points out the approach from hyper_serde could be more convenient in some cases so we can provide that instead / in addition to the above. That approach is to define a single shared `Ser<T>` and `De<T>` wrapper in the user's crate and then implement Serialize for `Ser<time::Duration>` and Deserialize for `De<time::Duration>`. Then provide functions to use with serialize_with and deserialize_with that take any `Ser<T>` or `De<T>`. That lets you use the intended type like time::Duration inside all of your structs rather than using a newtype wrapper inside your structs.\n\nThat could look like:\n\n``` rust\n// just once\nserde_remote_init!(SerdeWrapper);\n\n// for each struct\nserde_remote_derive! {\n    #[derive(Serialize, Deserialize)]\n    struct time::Duration {\n        secs: u64,\n        nanos: u32,\n    }\n}\n\n#[derive(Serialize, Deserialize)]\nstruct Mine {\n    #[serde(serialize_with = \"SerdeWrapper::serialize\",\n            deserialize_with = \"SerdeWrapper::deserialize\")]\n    dur: time::Duration,\n}\n```\n\nI wonder if I can make this work:\r\n\r\n```rust\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(remote = \"time::Duration\")]\r\nstruct Duration {\r\n    secs: u64,\r\n    nanos: u32,\r\n}\r\n\r\n#[derive(Serialize, Deserialize)]\r\nstruct Mine {\r\n    #[serde(with = \"Duration\")]\r\n    dur: time::Duration,\r\n}\r\n```\nPrivate fields make it less nice but here is a proof of concept:\r\n\r\n```rust\r\n#[macro_use]\r\nextern crate serde_derive;\r\n\r\nextern crate serde;\r\nextern crate serde_json;\r\n\r\nuse serde::ser::{Serializer, SerializeStruct};\r\n\r\nuse std::time;\r\n\r\n// #[derive(Serialize)]\r\n// #[serde(remote = \"time::Duration\")]\r\nstruct Duration {\r\n    // #[serde(getter = \"time::Duration::as_secs\")]\r\n    secs: u64,\r\n    // #[serde(getter = \"time::Duration::subsec_nanos\")]\r\n    nanos: u32,\r\n}\r\n\r\nimpl Duration {\r\n    fn serialize<S>(remote: &time::Duration, serializer: S) -> Result<S::Ok, S::Error>\r\n        where S: Serializer\r\n    {\r\n        let mut state = serializer.serialize_struct(\"Duration\", 2)?;\r\n        state.serialize_field(\"secs\", &time::Duration::as_secs(&remote))?;\r\n        state.serialize_field(\"nanos\", &time::Duration::subsec_nanos(&remote))?;\r\n        state.end()\r\n    }\r\n}\r\n\r\n#[derive(Serialize)]\r\nstruct Mine {\r\n    #[serde(with = \"Duration\")]\r\n    dur: time::Duration,\r\n}\r\n\r\nfn main() {\r\n    let mine = Mine { dur: time::Duration::new(1, 2) };\r\n    println!(\"{}\", serde_json::to_string(&mine).unwrap());\r\n}\r\n```\n#### Proposed semantics\r\n\r\nIf the remote struct has all public fields then it works with just a remote attribute.\r\n\r\n```rust\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(remote = \"time::Duration\")]\r\nstruct Duration {\r\n    secs: u64,\r\n    nanos: u32,\r\n}\r\n```\r\n\r\nIf the remote struct has one or more private fields, you provide a getter for any private fields and an Into conversion in the deserialization direction. The Into conversion is executed if there is at least one getter attribute.\r\n\r\n```rust\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(remote = \"time::Duration\")]\r\nstruct Duration {\r\n    #[serde(getter = \"time::Duration::as_secs\")]\r\n    secs: u64,\r\n    #[serde(getter = \"time::Duration::subsec_nanos\")]\r\n    nanos: u32,\r\n}\r\n\r\nimpl From<Duration> for time::Duration {\r\n    fn from(helper: Duration) -> time::Duration {\r\n        time::Duration::new(helper.secs, helper.nanos)\r\n    }\r\n}\r\n```", "created_at": "2017-04-09T17:20:43Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 848, "instance_id": "serde-rs__serde-848", "issue_numbers": ["821"], "base_commit": "2fe67d3d72534a011ef7c63065e4fb70f73cdddd", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 21f557f93..eefe3215d 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -625,9 +625,7 @@ impl<A> ArrayVisitor<A> {\n     }\n }\n \n-impl<'de, T> Visitor<'de> for ArrayVisitor<[T; 0]>\n-    where T: Deserialize<'de>\n-{\n+impl<'de, T> Visitor<'de> for ArrayVisitor<[T; 0]> {\n     type Value = [T; 0];\n \n     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n@@ -642,9 +640,8 @@ impl<'de, T> Visitor<'de> for ArrayVisitor<[T; 0]>\n     }\n }\n \n-impl<'de, T> Deserialize<'de> for [T; 0]\n-    where T: Deserialize<'de>\n-{\n+// Does not require T: Deserialize<'de>.\n+impl<'de, T> Deserialize<'de> for [T; 0] {\n     fn deserialize<D>(deserializer: D) -> Result<[T; 0], D::Error>\n         where D: Deserializer<'de>\n     {\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex a9bfaf092..6cfa32a91 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -143,6 +143,16 @@ impl<T> Serialize for PhantomData<T> {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+// Does not require T: Serialize.\n+impl<T> Serialize for [T; 0] {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+        where S: Serializer\n+    {\n+        try!(serializer.serialize_seq_fixed_size(0)).end()\n+    }\n+}\n+\n macro_rules! array_impls {\n     ($len:expr) => {\n         impl<T> Serialize for [T; $len] where T: Serialize {\n@@ -160,7 +170,6 @@ macro_rules! array_impls {\n     }\n }\n \n-array_impls!(0);\n array_impls!(1);\n array_impls!(2);\n array_impls!(3);\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 68e63505c..c1e68a92b 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -295,6 +295,11 @@ fn test_gen() {\n     #[derive(Serialize, Deserialize)]\n     #[serde(deny_unknown_fields)]\n     struct UnitDenyUnknown;\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct EmptyArray {\n+        empty: [X; 0],\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Do not require T: Deserialize in order to deserialize [T; 0]\nThe current impl is:\r\n\r\n```rust\r\nimpl<T> Deserialize for [T; 0] where T: Deserialize\r\n```\r\n\r\nThe `T: Deserialize` is not necessary.\n", "hints_text": "Serialize for [T; 0] as well.", "created_at": "2017-04-06T00:34:37Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 839, "instance_id": "serde-rs__serde-839", "issue_numbers": ["836"], "base_commit": "92bc23e484841554f1715825989df32ae9eedc82", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 9b6f1f5dd..1aa91db50 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -80,12 +80,6 @@ impl<'de> Visitor<'de> for UnitVisitor {\n     {\n         Ok(())\n     }\n-\n-    fn visit_seq<V>(self, _: V) -> Result<(), V::Error>\n-        where V: SeqVisitor<'de>\n-    {\n-        Ok(())\n-    }\n }\n \n impl<'de> Deserialize<'de> for () {\n@@ -113,16 +107,6 @@ impl<'de> Visitor<'de> for BoolVisitor {\n     {\n         Ok(v)\n     }\n-\n-    fn visit_str<E>(self, s: &str) -> Result<bool, E>\n-        where E: Error\n-    {\n-        match s.trim_matches(::utils::Pattern_White_Space) {\n-            \"true\" => Ok(true),\n-            \"false\" => Ok(false),\n-            _ => Err(Error::invalid_type(Unexpected::Str(s), &self)),\n-        }\n-    }\n }\n \n impl<'de> Deserialize<'de> for bool {\n@@ -175,15 +159,6 @@ macro_rules! impl_deserialize_num {\n                     impl_deserialize_num_method!($ty, u64, visit_u64, from_u64, Unsigned, u64);\n                     impl_deserialize_num_method!($ty, f32, visit_f32, from_f32, Float, f64);\n                     impl_deserialize_num_method!($ty, f64, visit_f64, from_f64, Float, f64);\n-\n-                    #[inline]\n-                    fn visit_str<E>(self, s: &str) -> Result<$ty, E>\n-                        where E: Error,\n-                    {\n-                        str::FromStr::from_str(s.trim_matches(::utils::Pattern_White_Space)).or_else(|_| {\n-                            Err(Error::invalid_type(Unexpected::Str(s), &self))\n-                        })\n-                    }\n                 }\n \n                 deserializer.$method(PrimitiveVisitor)\n@@ -269,12 +244,6 @@ impl<'de> Visitor<'de> for StringVisitor {\n         Ok(v)\n     }\n \n-    fn visit_unit<E>(self) -> Result<String, E>\n-        where E: Error\n-    {\n-        Ok(String::new())\n-    }\n-\n     fn visit_bytes<E>(self, v: &[u8]) -> Result<String, E>\n         where E: Error\n     {\n@@ -503,13 +472,6 @@ macro_rules! seq_impl {\n                 formatter.write_str(\"a sequence\")\n             }\n \n-            #[inline]\n-            fn visit_unit<E>(self) -> Result<Self::Value, E>\n-                where E: Error,\n-            {\n-                Ok($ctor)\n-            }\n-\n             #[inline]\n             fn visit_seq<V>(self, mut $visitor: V) -> Result<Self::Value, V::Error>\n                 where V: SeqVisitor<'de>,\n@@ -613,13 +575,6 @@ impl<'de, T> Visitor<'de> for ArrayVisitor<[T; 0]>\n         formatter.write_str(\"an empty array\")\n     }\n \n-    #[inline]\n-    fn visit_unit<E>(self) -> Result<[T; 0], E>\n-        where E: Error\n-    {\n-        Ok([])\n-    }\n-\n     #[inline]\n     fn visit_seq<V>(self, _: V) -> Result<[T; 0], V::Error>\n         where V: SeqVisitor<'de>\n@@ -819,13 +774,6 @@ macro_rules! map_impl {\n                 formatter.write_str(\"a map\")\n             }\n \n-            #[inline]\n-            fn visit_unit<E>(self) -> Result<Self::Value, E>\n-                where E: Error,\n-            {\n-                Ok($ctor)\n-            }\n-\n             #[inline]\n             fn visit_map<Visitor>(self, mut $visitor: Visitor) -> Result<Self::Value, Visitor::Error>\n                 where Visitor: MapVisitor<'de>,\ndiff --git a/serde/src/utils.rs b/serde/src/utils.rs\nindex 927d1256a..4e81616ad 100644\n--- a/serde/src/utils.rs\n+++ b/serde/src/utils.rs\n@@ -48,27 +48,3 @@ impl EncodeUtf8 {\n         ::core::str::from_utf8(&self.buf[self.pos..]).unwrap()\n     }\n }\n-\n-#[allow(non_upper_case_globals)]\n-const Pattern_White_Space_table: &'static [(char, char)] = &[('\\u{9}', '\\u{d}'),\n-                                                             ('\\u{20}', '\\u{20}'),\n-                                                             ('\\u{85}', '\\u{85}'),\n-                                                             ('\\u{200e}', '\\u{200f}'),\n-                                                             ('\\u{2028}', '\\u{2029}')];\n-\n-fn bsearch_range_table(c: char, r: &'static [(char, char)]) -> bool {\n-    use core::cmp::Ordering::{Equal, Less, Greater};\n-    r.binary_search_by(|&(lo, hi)| if c < lo {\n-                              Greater\n-                          } else if hi < c {\n-            Less\n-        } else {\n-            Equal\n-        })\n-        .is_ok()\n-}\n-\n-#[allow(non_snake_case)]\n-pub fn Pattern_White_Space(c: char) -> bool {\n-    bsearch_range_table(c, Pattern_White_Space_table)\n-}\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 8d21844cc..552e58cb7 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -245,18 +245,6 @@ declare_tests! {\n     }\n     test_unit {\n         () => &[Token::Unit],\n-        () => &[\n-            Token::SeqStart(Some(0)),\n-            Token::SeqEnd,\n-        ],\n-        () => &[\n-            Token::SeqStart(None),\n-            Token::SeqEnd,\n-        ],\n-        () => &[\n-            Token::TupleStructStart(\"Anything\", 0),\n-            Token::TupleStructEnd,\n-        ],\n     }\n     test_unit_struct {\n         UnitStruct => &[Token::Unit],\n@@ -272,9 +260,6 @@ declare_tests! {\n             Token::SeqEnd,\n         ],\n     }\n-    test_unit_string {\n-        String::new() => &[Token::Unit],\n-    }\n     test_tuple_struct {\n         TupleStruct(1, 2, 3) => &[\n             Token::SeqStart(Some(3)),\n@@ -326,9 +311,6 @@ declare_tests! {\n         ],\n     }\n     test_btreeset {\n-        BTreeSet::<isize>::new() => &[\n-            Token::Unit,\n-        ],\n         BTreeSet::<isize>::new() => &[\n             Token::SeqStart(Some(0)),\n             Token::SeqEnd,\n@@ -355,18 +337,12 @@ declare_tests! {\n                 Token::SeqEnd,\n             Token::SeqEnd,\n         ],\n-        BTreeSet::<isize>::new() => &[\n-            Token::UnitStruct(\"Anything\"),\n-        ],\n         BTreeSet::<isize>::new() => &[\n             Token::TupleStructStart(\"Anything\", 0),\n             Token::TupleStructEnd,\n         ],\n     }\n     test_hashset {\n-        HashSet::<isize>::new() => &[\n-            Token::Unit,\n-        ],\n         HashSet::<isize>::new() => &[\n             Token::SeqStart(Some(0)),\n             Token::SeqEnd,\n@@ -383,9 +359,6 @@ declare_tests! {\n                 Token::I32(3),\n             Token::SeqEnd,\n         ],\n-        HashSet::<isize>::new() => &[\n-            Token::UnitStruct(\"Anything\"),\n-        ],\n         HashSet::<isize>::new() => &[\n             Token::TupleStructStart(\"Anything\", 0),\n             Token::TupleStructEnd,\n@@ -404,9 +377,6 @@ declare_tests! {\n         ],\n     }\n     test_vec {\n-        Vec::<isize>::new() => &[\n-            Token::Unit,\n-        ],\n         Vec::<isize>::new() => &[\n             Token::SeqStart(Some(0)),\n             Token::SeqEnd,\n@@ -433,18 +403,12 @@ declare_tests! {\n                 Token::SeqEnd,\n             Token::SeqEnd,\n         ],\n-        Vec::<isize>::new() => &[\n-            Token::UnitStruct(\"Anything\"),\n-        ],\n         Vec::<isize>::new() => &[\n             Token::TupleStructStart(\"Anything\", 0),\n             Token::TupleStructEnd,\n         ],\n     }\n     test_array {\n-        [0; 0] => &[\n-            Token::Unit,\n-        ],\n         [0; 0] => &[\n             Token::SeqStart(Some(0)),\n             Token::SeqEnd,\n@@ -497,9 +461,6 @@ declare_tests! {\n                 Token::SeqEnd,\n             Token::SeqEnd,\n         ],\n-        [0; 0] => &[\n-            Token::UnitStruct(\"Anything\"),\n-        ],\n         [0; 0] => &[\n             Token::TupleStructStart(\"Anything\", 0),\n             Token::TupleStructEnd,\n@@ -544,9 +505,6 @@ declare_tests! {\n         ],\n     }\n     test_btreemap {\n-        BTreeMap::<isize, isize>::new() => &[\n-            Token::Unit,\n-        ],\n         BTreeMap::<isize, isize>::new() => &[\n             Token::MapStart(Some(0)),\n             Token::MapEnd,\n@@ -589,18 +547,12 @@ declare_tests! {\n                 Token::MapEnd,\n             Token::MapEnd,\n         ],\n-        BTreeMap::<isize, isize>::new() => &[\n-            Token::UnitStruct(\"Anything\"),\n-        ],\n         BTreeMap::<isize, isize>::new() => &[\n             Token::StructStart(\"Anything\", 0),\n             Token::StructEnd,\n         ],\n     }\n     test_hashmap {\n-        HashMap::<isize, isize>::new() => &[\n-            Token::Unit,\n-        ],\n         HashMap::<isize, isize>::new() => &[\n             Token::MapStart(Some(0)),\n             Token::MapEnd,\n@@ -643,9 +595,6 @@ declare_tests! {\n                 Token::MapEnd,\n             Token::MapEnd,\n         ],\n-        HashMap::<isize, isize>::new() => &[\n-            Token::UnitStruct(\"Anything\"),\n-        ],\n         HashMap::<isize, isize>::new() => &[\n             Token::StructStart(\"Anything\", 0),\n             Token::StructEnd,\n@@ -1119,4 +1068,115 @@ declare_error_tests! {\n         ],\n         Error::Message(\"nul byte found in provided data at position: 2\".into()),\n     }\n+    test_unit_from_empty_seq<()> {\n+        &[\n+            Token::SeqStart(Some(0)),\n+            Token::SeqEnd,\n+        ],\n+        Error::Message(\"invalid type: sequence, expected unit\".into()),\n+    }\n+    test_unit_from_empty_seq_without_len<()> {\n+        &[\n+            Token::SeqStart(None),\n+            Token::SeqEnd,\n+        ],\n+        Error::Message(\"invalid type: sequence, expected unit\".into()),\n+    }\n+    test_unit_from_tuple_struct<()> {\n+        &[\n+            Token::TupleStructStart(\"Anything\", 0),\n+            Token::TupleStructEnd,\n+        ],\n+        Error::Message(\"invalid type: sequence, expected unit\".into()),\n+    }\n+    test_string_from_unit<String> {\n+        &[\n+            Token::Unit,\n+        ],\n+        Error::Message(\"invalid type: unit value, expected a string\".into()),\n+    }\n+    test_btreeset_from_unit<BTreeSet<isize>> {\n+        &[\n+            Token::Unit,\n+        ],\n+        Error::Message(\"invalid type: unit value, expected a sequence\".into()),\n+    }\n+    test_btreeset_from_unit_struct<BTreeSet<isize>> {\n+        &[\n+            Token::UnitStruct(\"Anything\"),\n+        ],\n+        Error::Message(\"invalid type: unit value, expected a sequence\".into()),\n+    }\n+    test_hashset_from_unit<HashSet<isize>> {\n+        &[\n+            Token::Unit,\n+        ],\n+        Error::Message(\"invalid type: unit value, expected a sequence\".into()),\n+    }\n+    test_hashset_from_unit_struct<HashSet<isize>> {\n+        &[\n+            Token::UnitStruct(\"Anything\"),\n+        ],\n+        Error::Message(\"invalid type: unit value, expected a sequence\".into()),\n+    }\n+    test_vec_from_unit<Vec<isize>> {\n+        &[\n+            Token::Unit,\n+        ],\n+        Error::Message(\"invalid type: unit value, expected a sequence\".into()),\n+    }\n+    test_vec_from_unit_struct<Vec<isize>> {\n+        &[\n+            Token::UnitStruct(\"Anything\"),\n+        ],\n+        Error::Message(\"invalid type: unit value, expected a sequence\".into()),\n+    }\n+    test_zero_array_from_unit<[isize; 0]> {\n+        &[\n+            Token::Unit,\n+        ],\n+        Error::Message(\"invalid type: unit value, expected an empty array\".into()),\n+    }\n+    test_zero_array_from_unit_struct<[isize; 0]> {\n+        &[\n+            Token::UnitStruct(\"Anything\"),\n+        ],\n+        Error::Message(\"invalid type: unit value, expected an empty array\".into()),\n+    }\n+    test_btreemap_from_unit<BTreeMap<isize, isize>> {\n+        &[\n+            Token::Unit,\n+        ],\n+        Error::Message(\"invalid type: unit value, expected a map\".into()),\n+    }\n+    test_btreemap_from_unit_struct<BTreeMap<isize, isize>> {\n+        &[\n+            Token::UnitStruct(\"Anything\"),\n+        ],\n+        Error::Message(\"invalid type: unit value, expected a map\".into()),\n+    }\n+    test_hashmap_from_unit<HashMap<isize, isize>> {\n+        &[\n+            Token::Unit,\n+        ],\n+        Error::Message(\"invalid type: unit value, expected a map\".into()),\n+    }\n+    test_hashmap_from_unit_struct<HashMap<isize, isize>> {\n+        &[\n+            Token::UnitStruct(\"Anything\"),\n+        ],\n+        Error::Message(\"invalid type: unit value, expected a map\".into()),\n+    }\n+    test_bool_from_string<bool> {\n+        &[\n+            Token::Str(\"false\"),\n+        ],\n+        Error::Message(\"invalid type: string \\\"false\\\", expected a boolean\".into()),\n+    }\n+    test_number_from_string<isize> {\n+        &[\n+            Token::Str(\"1\"),\n+        ],\n+        Error::Message(\"invalid type: string \\\"1\\\", expected isize\".into()),\n+    }\n }\n", "problem_statement": "Audit type conversions\nThe standard I would like to set is that if Serde successfully deserializes some input into a particular struct, you can be confident that the input matches what your struct says it should look like.\r\n\r\nCurrently there are conversions that I think violate this, for example deserializing strings and collections from unit:\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\nstruct Bad {\r\n    s: String\r\n}\r\n\r\nserde_json::from_str::<Bad>(\"{\\\"s\\\":null}\").unwrap();\r\n```\r\n\r\nTo me, null in the input means you should have used Option\\<String> or a deserialize_with function that treats null as default.\r\n\r\nLet's go through and critically evaluate all of the type conversions that are being done and eliminate these confusing ones.\n", "hints_text": "", "created_at": "2017-04-05T01:33:44Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 837, "instance_id": "serde-rs__serde-837", "issue_numbers": ["492"], "base_commit": "8c3e72f2c8f984d6deae3a3a9620efe724e8b849", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 41698195a..881f0df93 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -328,9 +328,9 @@ impl<'a> Visitor<'a> for StrVisitor {\n     }\n }\n \n-impl<'a> Deserialize<'a> for &'a str {\n+impl<'de: 'a, 'a> Deserialize<'de> for &'a str {\n     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-        where D: Deserializer<'a>\n+        where D: Deserializer<'de>\n     {\n         deserializer.deserialize_str(StrVisitor)\n     }\n@@ -360,9 +360,9 @@ impl<'a> Visitor<'a> for BytesVisitor {\n     }\n }\n \n-impl<'a> Deserialize<'a> for &'a [u8] {\n+impl<'de: 'a, 'a> Deserialize<'de> for &'a [u8] {\n     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-        where D: Deserializer<'a>\n+        where D: Deserializer<'de>\n     {\n         deserializer.deserialize_bytes(BytesVisitor)\n     }\ndiff --git a/serde/src/de/private.rs b/serde/src/de/private.rs\nindex 0e001962e..8121ee156 100644\n--- a/serde/src/de/private.rs\n+++ b/serde/src/de/private.rs\n@@ -1,7 +1,24 @@\n+#[cfg(any(feature = \"std\", feature = \"collections\"))]\n+use core::{fmt, str};\n+\n use core::marker::PhantomData;\n \n+#[cfg(feature = \"collections\")]\n+use collections::borrow::ToOwned;\n+\n+#[cfg(feature = \"std\")]\n+use std::borrow::Cow;\n+#[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n+use collections::borrow::Cow;\n+\n+#[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n+use collections::{String, Vec};\n+\n use de::{Deserialize, Deserializer, Error, Visitor};\n \n+#[cfg(any(feature = \"std\", feature = \"collections\"))]\n+use de::Unexpected;\n+\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n pub use de::content::{Content, ContentRefDeserializer, ContentDeserializer, TaggedContentVisitor,\n                       TagOrContentField, TagOrContentFieldVisitor, InternallyTaggedUnitVisitor,\n@@ -42,3 +59,118 @@ pub fn missing_field<'de, V, E>(field: &'static str) -> Result<V, E>\n     let deserializer = MissingFieldDeserializer(field, PhantomData);\n     Deserialize::deserialize(deserializer)\n }\n+\n+#[cfg(any(feature = \"std\", feature = \"collections\"))]\n+pub fn borrow_cow_str<'de: 'a, 'a, D>(deserializer: D) -> Result<Cow<'a, str>, D::Error>\n+    where D: Deserializer<'de>\n+{\n+    struct CowStrVisitor;\n+\n+    impl<'a> Visitor<'a> for CowStrVisitor {\n+        type Value = Cow<'a, str>;\n+\n+        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+            formatter.write_str(\"a string\")\n+        }\n+\n+        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n+            where E: Error\n+        {\n+            Ok(Cow::Owned(v.to_owned()))\n+        }\n+\n+        fn visit_borrowed_str<E>(self, v: &'a str) -> Result<Self::Value, E>\n+            where E: Error\n+        {\n+            Ok(Cow::Borrowed(v))\n+        }\n+\n+        fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n+            where E: Error\n+        {\n+            Ok(Cow::Owned(v))\n+        }\n+\n+        fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n+            where E: Error\n+        {\n+            match str::from_utf8(v) {\n+                Ok(s) => Ok(Cow::Owned(s.to_owned())),\n+                Err(_) => Err(Error::invalid_value(Unexpected::Bytes(v), &self)),\n+            }\n+        }\n+\n+        fn visit_borrowed_bytes<E>(self, v: &'a [u8]) -> Result<Self::Value, E>\n+            where E: Error\n+        {\n+            match str::from_utf8(v) {\n+                Ok(s) => Ok(Cow::Borrowed(s)),\n+                Err(_) => Err(Error::invalid_value(Unexpected::Bytes(v), &self)),\n+            }\n+        }\n+\n+        fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n+            where E: Error\n+        {\n+            match String::from_utf8(v) {\n+                Ok(s) => Ok(Cow::Owned(s)),\n+                Err(e) => Err(Error::invalid_value(Unexpected::Bytes(&e.into_bytes()), &self)),\n+            }\n+        }\n+    }\n+\n+    deserializer.deserialize_str(CowStrVisitor)\n+}\n+\n+#[cfg(any(feature = \"std\", feature = \"collections\"))]\n+pub fn borrow_cow_bytes<'de: 'a, 'a, D>(deserializer: D) -> Result<Cow<'a, [u8]>, D::Error>\n+    where D: Deserializer<'de>\n+{\n+    struct CowBytesVisitor;\n+\n+    impl<'a> Visitor<'a> for CowBytesVisitor {\n+        type Value = Cow<'a, [u8]>;\n+\n+        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+            formatter.write_str(\"a byte array\")\n+        }\n+\n+        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n+            where E: Error\n+        {\n+            Ok(Cow::Owned(v.as_bytes().to_vec()))\n+        }\n+\n+        fn visit_borrowed_str<E>(self, v: &'a str) -> Result<Self::Value, E>\n+            where E: Error\n+        {\n+            Ok(Cow::Borrowed(v.as_bytes()))\n+        }\n+\n+        fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n+            where E: Error\n+        {\n+            Ok(Cow::Owned(v.into_bytes()))\n+        }\n+\n+        fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n+            where E: Error\n+        {\n+            Ok(Cow::Owned(v.to_vec()))\n+        }\n+\n+        fn visit_borrowed_bytes<E>(self, v: &'a [u8]) -> Result<Self::Value, E>\n+            where E: Error\n+        {\n+            Ok(Cow::Borrowed(v))\n+        }\n+\n+        fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n+            where E: Error\n+        {\n+            Ok(Cow::Owned(v))\n+        }\n+    }\n+\n+    deserializer.deserialize_str(CowBytesVisitor)\n+}\ndiff --git a/serde_codegen_internals/Cargo.toml b/serde_codegen_internals/Cargo.toml\nindex cd167bfe3..6f006914b 100644\n--- a/serde_codegen_internals/Cargo.toml\n+++ b/serde_codegen_internals/Cargo.toml\n@@ -12,7 +12,8 @@ readme = \"../README.md\"\n include = [\"Cargo.toml\", \"src/**/*.rs\", \"README.md\", \"LICENSE-APACHE\", \"LICENSE-MIT\"]\n \n [dependencies]\n-syn = { version = \"0.11\", default-features = false, features = [\"parsing\"] }\n+syn = { version = \"0.11.10\", default-features = false, features = [\"parsing\"] }\n+synom = \"0.11\"\n \n [badges]\n travis-ci = { repository = \"serde-rs/serde\" }\ndiff --git a/serde_codegen_internals/src/attr.rs b/serde_codegen_internals/src/attr.rs\nindex 11a2eb2a0..13b429b96 100644\n--- a/serde_codegen_internals/src/attr.rs\n+++ b/serde_codegen_internals/src/attr.rs\n@@ -2,6 +2,8 @@ use Ctxt;\n use syn;\n use syn::MetaItem::{List, NameValue, Word};\n use syn::NestedMetaItem::{Literal, MetaItem};\n+use synom::IResult;\n+use std::collections::BTreeSet;\n use std::str::FromStr;\n \n // This module handles parsing of `#[serde(...)]` attributes. The entrypoints\n@@ -528,6 +530,7 @@ pub struct Field {\n     deserialize_with: Option<syn::Path>,\n     ser_bound: Option<Vec<syn::WherePredicate>>,\n     de_bound: Option<Vec<syn::WherePredicate>>,\n+    borrowed_lifetimes: BTreeSet<syn::Lifetime>,\n }\n \n /// Represents the default to use for a field when deserializing.\n@@ -554,6 +557,7 @@ impl Field {\n         let mut deserialize_with = Attr::none(cx, \"deserialize_with\");\n         let mut ser_bound = Attr::none(cx, \"bound\");\n         let mut de_bound = Attr::none(cx, \"bound\");\n+        let mut borrowed_lifetimes = Attr::none(cx, \"borrow\");\n \n         let ident = match field.ident {\n             Some(ref ident) => ident.to_string(),\n@@ -651,6 +655,27 @@ impl Field {\n                         }\n                     }\n \n+                    // Parse `#[serde(borrow)]`\n+                    MetaItem(Word(ref name)) if name == \"borrow\" => {\n+                        if let Ok(borrowable) = borrowable_lifetimes(cx, &ident, &field.ty) {\n+                            borrowed_lifetimes.set(borrowable);\n+                        }\n+                    }\n+\n+                    // Parse `#[serde(borrow = \"'a + 'b\")]`\n+                    MetaItem(NameValue(ref name, ref lit)) if name == \"borrow\" => {\n+                        if let Ok(lifetimes) = parse_lit_into_lifetimes(cx, name.as_ref(), lit) {\n+                            if let Ok(borrowable) = borrowable_lifetimes(cx, &ident, &field.ty) {\n+                                for lifetime in &lifetimes {\n+                                    if !borrowable.contains(lifetime) {\n+                                        cx.error(format!(\"field `{}` does not have lifetime {}\", ident, lifetime.ident));\n+                                    }\n+                                }\n+                                borrowed_lifetimes.set(lifetimes);\n+                            }\n+                        }\n+                    }\n+\n                     MetaItem(ref meta_item) => {\n                         cx.error(format!(\"unknown serde field attribute `{}`\", meta_item.name()));\n                     }\n@@ -668,6 +693,30 @@ impl Field {\n             default.set_if_none(Default::Default);\n         }\n \n+        let mut borrowed_lifetimes = borrowed_lifetimes.get().unwrap_or_default();\n+        if !borrowed_lifetimes.is_empty() {\n+            // Cow<str> and Cow<[u8]> never borrow by default:\n+            //\n+            //     impl<'de, 'a, T: ?Sized> Deserialize<'de> for Cow<'a, T>\n+            //\n+            // A #[serde(borrow)] attribute enables borrowing that corresponds\n+            // roughly to these impls:\n+            //\n+            //     impl<'de: 'a, 'a> Deserialize<'de> for Cow<'a, str>\n+            //     impl<'de: 'a, 'a> Deserialize<'de> for Cow<'a, [u8]>\n+            if is_cow(&field.ty, \"str\") {\n+                let path = syn::parse_path(\"_serde::de::private::borrow_cow_str\").unwrap();\n+                deserialize_with.set_if_none(path);\n+            } else if is_cow(&field.ty, \"[u8]\") {\n+                let path = syn::parse_path(\"_serde::de::private::borrow_cow_bytes\").unwrap();\n+                deserialize_with.set_if_none(path);\n+            }\n+        } else if is_rptr(&field.ty, \"str\") || is_rptr(&field.ty, \"[u8]\") {\n+            // Types &str and &[u8] are always implicitly borrowed. No need for\n+            // a #[serde(borrow)].\n+            borrowed_lifetimes = borrowable_lifetimes(cx, &ident, &field.ty).unwrap();\n+        }\n+\n         let ser_name = ser_name.get();\n         let ser_renamed = ser_name.is_some();\n         let de_name = de_name.get();\n@@ -687,6 +736,7 @@ impl Field {\n             deserialize_with: deserialize_with.get(),\n             ser_bound: ser_bound.get(),\n             de_bound: de_bound.get(),\n+            borrowed_lifetimes: borrowed_lifetimes,\n         }\n     }\n \n@@ -734,6 +784,10 @@ impl Field {\n     pub fn de_bound(&self) -> Option<&[syn::WherePredicate]> {\n         self.de_bound.as_ref().map(|vec| &vec[..])\n     }\n+\n+    pub fn borrowed_lifetimes(&self) -> &BTreeSet<syn::Lifetime> {\n+        &self.borrowed_lifetimes\n+    }\n }\n \n type SerAndDe<T> = (Option<T>, Option<T>);\n@@ -836,3 +890,174 @@ fn parse_lit_into_ty(cx: &Ctxt,\n         cx.error(format!(\"failed to parse type: {} = {:?}\", attr_name, string))\n     })\n }\n+\n+// Parses a string literal like \"'a + 'b + 'c\" containing a nonempty list of\n+// lifetimes separated by `+`.\n+fn parse_lit_into_lifetimes(cx: &Ctxt,\n+                            attr_name: &str,\n+                            lit: &syn::Lit)\n+                            -> Result<BTreeSet<syn::Lifetime>, ()> {\n+    let string = try!(get_string_from_lit(cx, attr_name, attr_name, lit));\n+    if string.is_empty() {\n+        cx.error(\"at least one lifetime must be borrowed\");\n+        return Err(());\n+    }\n+\n+    named!(lifetimes -> Vec<syn::Lifetime>,\n+        separated_nonempty_list!(punct!(\"+\"), syn::parse::lifetime)\n+    );\n+\n+    if let IResult::Done(rest, o) = lifetimes(&string) {\n+        if rest.trim().is_empty() {\n+            let mut set = BTreeSet::new();\n+            for lifetime in o {\n+                if !set.insert(lifetime.clone()) {\n+                    cx.error(format!(\"duplicate borrowed lifetime `{}`\", lifetime.ident));\n+                }\n+            }\n+            return Ok(set);\n+        }\n+    }\n+    Err(cx.error(format!(\"failed to parse borrowed lifetimes: {:?}\", string)))\n+}\n+\n+// Whether the type looks like it might be `std::borrow::Cow<T>` where elem=\"T\".\n+// This can have false negatives and false positives.\n+//\n+// False negative:\n+//\n+//     use std::borrow::Cow as Pig;\n+//\n+//     #[derive(Deserialize)]\n+//     struct S<'a> {\n+//         #[serde(borrow)]\n+//         pig: Pig<'a, str>,\n+//     }\n+//\n+// False positive:\n+//\n+//     type str = [i16];\n+//\n+//     #[derive(Deserialize)]\n+//     struct S<'a> {\n+//         #[serde(borrow)]\n+//         cow: Cow<'a, str>,\n+//     }\n+fn is_cow(ty: &syn::Ty, elem: &str) -> bool {\n+    let path = match *ty {\n+        syn::Ty::Path(None, ref path) => path,\n+        _ => {\n+            return false;\n+        }\n+    };\n+    let seg = match path.segments.last() {\n+        Some(seg) => seg,\n+        None => {\n+            return false;\n+        }\n+    };\n+    let params = match seg.parameters {\n+        syn::PathParameters::AngleBracketed(ref params) => params,\n+        _ => {\n+            return false;\n+        }\n+    };\n+    seg.ident == \"Cow\"\n+        && params.lifetimes.len() == 1\n+        && params.types == vec![syn::parse_type(elem).unwrap()]\n+        && params.bindings.is_empty()\n+}\n+\n+// Whether the type looks like it might be `&T` where elem=\"T\". This can have\n+// false negatives and false positives.\n+//\n+// False negative:\n+//\n+//     type Yarn = str;\n+//\n+//     #[derive(Deserialize)]\n+//     struct S<'a> {\n+//         r: &'a Yarn,\n+//     }\n+//\n+// False positive:\n+//\n+//     type str = [i16];\n+//\n+//     #[derive(Deserialize)]\n+//     struct S<'a> {\n+//         r: &'a str,\n+//     }\n+fn is_rptr(ty: &syn::Ty, elem: &str) -> bool {\n+    match *ty {\n+        syn::Ty::Rptr(Some(_), ref mut_ty) => {\n+            mut_ty.mutability == syn::Mutability::Immutable\n+                && mut_ty.ty == syn::parse_type(elem).unwrap()\n+        }\n+        _ => false,\n+    }\n+}\n+\n+// All lifetimes that this type could borrow from a Deserializer.\n+//\n+// For example a type `S<'a, 'b>` could borrow `'a` and `'b`. On the other hand\n+// a type `for<'a> fn(&'a str)` could not borrow `'a` from the Deserializer.\n+//\n+// This is used when there is an explicit or implicit `#[serde(borrow)]`\n+// attribute on the field so there must be at least one borrowable lifetime.\n+fn borrowable_lifetimes(cx: &Ctxt,\n+                        name: &str,\n+                        ty: &syn::Ty)\n+                        -> Result<BTreeSet<syn::Lifetime>, ()> {\n+    let mut lifetimes = BTreeSet::new();\n+    collect_lifetimes(ty, &mut lifetimes);\n+    if lifetimes.is_empty() {\n+        Err(cx.error(format!(\"field `{}` has no lifetimes to borrow\", name)))\n+    } else {\n+        Ok(lifetimes)\n+    }\n+}\n+\n+fn collect_lifetimes(ty: &syn::Ty, out: &mut BTreeSet<syn::Lifetime>) {\n+    match *ty {\n+        syn::Ty::Slice(ref elem) |\n+        syn::Ty::Array(ref elem, _) |\n+        syn::Ty::Paren(ref elem) => {\n+            collect_lifetimes(elem, out);\n+        }\n+        syn::Ty::Ptr(ref elem) => {\n+            collect_lifetimes(&elem.ty, out);\n+        }\n+        syn::Ty::Rptr(ref lifetime, ref elem) => {\n+            out.extend(lifetime.iter().cloned());\n+            collect_lifetimes(&elem.ty, out);\n+        }\n+        syn::Ty::Tup(ref elems) => {\n+            for elem in elems {\n+                collect_lifetimes(elem, out);\n+            }\n+        }\n+        syn::Ty::Path(ref qself, ref path) => {\n+            if let Some(ref qself) = *qself {\n+                collect_lifetimes(&qself.ty, out);\n+            }\n+            for seg in &path.segments {\n+                if let syn::PathParameters::AngleBracketed(ref params) = seg.parameters {\n+                    out.extend(params.lifetimes.iter().cloned());\n+                    for ty in &params.types {\n+                        collect_lifetimes(ty, out);\n+                    }\n+                    for binding in &params.bindings {\n+                        collect_lifetimes(&binding.ty, out);\n+                    }\n+                }\n+            }\n+        }\n+        syn::Ty::BareFn(_) |\n+        syn::Ty::Never |\n+        syn::Ty::TraitObject(_) |\n+        syn::Ty::ImplTrait(_) |\n+        syn::Ty::Infer |\n+        syn::Ty::Mac(_) => {}\n+    }\n+}\ndiff --git a/serde_codegen_internals/src/lib.rs b/serde_codegen_internals/src/lib.rs\nindex c5e8885c7..d5baf00b9 100644\n--- a/serde_codegen_internals/src/lib.rs\n+++ b/serde_codegen_internals/src/lib.rs\n@@ -1,4 +1,6 @@\n extern crate syn;\n+#[macro_use]\n+extern crate synom;\n \n pub mod ast;\n pub mod attr;\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 6ab9f95eb..b67ad285c 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -6,20 +6,20 @@ use fragment::{Fragment, Expr, Stmts, Match};\n use internals::ast::{Body, Field, Item, Style, Variant};\n use internals::{self, attr};\n \n+use std::collections::BTreeSet;\n+\n pub fn expand_derive_deserialize(item: &syn::DeriveInput) -> Result<Tokens, String> {\n-    let item = {\n-        let ctxt = internals::Ctxt::new();\n-        let item = Item::from_ast(&ctxt, item);\n-        check_no_str(&ctxt, &item);\n-        try!(ctxt.check());\n-        item\n-    };\n+    let ctxt = internals::Ctxt::new();\n+    let item = Item::from_ast(&ctxt, item);\n+    try!(ctxt.check());\n \n     let ident = &item.ident;\n     let generics = build_generics(&item);\n-    let (de_impl_generics, _, ty_generics, where_clause) = split_with_de_lifetime(&generics);\n+    let borrowed = borrowed_lifetimes(&item);\n+    let params = Parameters { generics: generics, borrowed: borrowed };\n+    let (de_impl_generics, _, ty_generics, where_clause) = split_with_de_lifetime(&params);\n     let dummy_const = Ident::new(format!(\"_IMPL_DESERIALIZE_FOR_{}\", ident));\n-    let body = Stmts(deserialize_body(&item, &generics));\n+    let body = Stmts(deserialize_body(&item, &params));\n \n     Ok(quote! {\n         #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]\n@@ -37,6 +37,11 @@ pub fn expand_derive_deserialize(item: &syn::DeriveInput) -> Result<Tokens, Stri\n     })\n }\n \n+struct Parameters {\n+    generics: syn::Generics,\n+    borrowed: BTreeSet<syn::Lifetime>,\n+}\n+\n // All the generics in the input, plus a bound `T: Deserialize` for each generic\n // field type that will be deserialized by us, plus a bound `T: Default` for\n // each generic field type that will be set to a default value.\n@@ -84,13 +89,27 @@ fn requires_default(attrs: &attr::Field) -> bool {\n     attrs.default() == &attr::Default::Default\n }\n \n-fn deserialize_body(item: &Item, generics: &syn::Generics) -> Fragment {\n+// The union of lifetimes borrowed by each field of the item.\n+//\n+// These turn into bounds on the `'de` lifetime of the Deserialize impl. If\n+// lifetimes `'a` and `'b` are borrowed but `'c` is not, the impl is:\n+//\n+//     impl<'de: 'a + 'b, 'a, 'b, 'c> Deserialize<'de> for S<'a, 'b, 'c>\n+fn borrowed_lifetimes(item: &Item) -> BTreeSet<syn::Lifetime> {\n+    let mut lifetimes = BTreeSet::new();\n+    for field in item.body.all_fields() {\n+        lifetimes.extend(field.attrs.borrowed_lifetimes().iter().cloned());\n+    }\n+    lifetimes\n+}\n+\n+fn deserialize_body(item: &Item, params: &Parameters) -> Fragment {\n     if let Some(from_type) = item.attrs.from_type() {\n         deserialize_from(from_type)\n     } else {\n         match item.body {\n             Body::Enum(ref variants) => {\n-                deserialize_item_enum(&item.ident, generics, variants, &item.attrs)\n+                deserialize_item_enum(&item.ident, params, variants, &item.attrs)\n             }\n             Body::Struct(Style::Struct, ref fields) => {\n                 if fields.iter().any(|field| field.ident.is_none()) {\n@@ -98,7 +117,7 @@ fn deserialize_body(item: &Item, generics: &syn::Generics) -> Fragment {\n                 }\n                 deserialize_struct(&item.ident,\n                                    None,\n-                                   generics,\n+                                   params,\n                                    fields,\n                                    &item.attrs,\n                                    None)\n@@ -110,7 +129,7 @@ fn deserialize_body(item: &Item, generics: &syn::Generics) -> Fragment {\n                 }\n                 deserialize_tuple(&item.ident,\n                                   None,\n-                                  generics,\n+                                  params,\n                                   fields,\n                                   &item.attrs,\n                                   None)\n@@ -164,12 +183,12 @@ fn deserialize_unit_struct(ident: &syn::Ident, item_attrs: &attr::Item) -> Fragm\n \n fn deserialize_tuple(ident: &syn::Ident,\n                      variant_ident: Option<&syn::Ident>,\n-                     generics: &syn::Generics,\n+                     params: &Parameters,\n                      fields: &[Field],\n                      item_attrs: &attr::Item,\n                      deserializer: Option<Tokens>)\n                      -> Fragment {\n-    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(generics);\n+    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params);\n \n     let is_enum = variant_ident.is_some();\n     let type_path = match variant_ident {\n@@ -184,12 +203,12 @@ fn deserialize_tuple(ident: &syn::Ident,\n     let nfields = fields.len();\n \n     let visit_newtype_struct = if !is_enum && nfields == 1 {\n-        Some(deserialize_newtype_struct(ident, &type_path, generics, &fields[0]))\n+        Some(deserialize_newtype_struct(ident, &type_path, params, &fields[0]))\n     } else {\n         None\n     };\n \n-    let visit_seq = Stmts(deserialize_seq(ident, &type_path, generics, fields, false, item_attrs));\n+    let visit_seq = Stmts(deserialize_seq(ident, &type_path, params, fields, false, item_attrs));\n \n     let visitor_expr = quote! {\n         __Visitor {\n@@ -245,7 +264,7 @@ fn deserialize_tuple(ident: &syn::Ident,\n \n fn deserialize_seq(ident: &syn::Ident,\n                    type_path: &Tokens,\n-                   generics: &syn::Generics,\n+                   params: &Parameters,\n                    fields: &[Field],\n                    is_struct: bool,\n                    item_attrs: &attr::Item)\n@@ -273,7 +292,7 @@ fn deserialize_seq(ident: &syn::Ident,\n                     }\n                     Some(path) => {\n                         let (wrapper, wrapper_ty) = wrap_deserialize_with(\n-                            ident, generics, field.ty, path);\n+                            ident, params, field.ty, path);\n                         quote!({\n                             #wrapper\n                             _serde::export::Option::map(\n@@ -314,7 +333,7 @@ fn deserialize_seq(ident: &syn::Ident,\n \n fn deserialize_newtype_struct(ident: &syn::Ident,\n                               type_path: &Tokens,\n-                              generics: &syn::Generics,\n+                              params: &Parameters,\n                               field: &Field)\n                               -> Tokens {\n     let value = match field.attrs.deserialize_with() {\n@@ -326,7 +345,7 @@ fn deserialize_newtype_struct(ident: &syn::Ident,\n         }\n         Some(path) => {\n             let (wrapper, wrapper_ty) =\n-                wrap_deserialize_with(ident, generics, field.ty, path);\n+                wrap_deserialize_with(ident, params, field.ty, path);\n             quote!({\n                 #wrapper\n                 try!(<#wrapper_ty as _serde::Deserialize>::deserialize(__e)).value\n@@ -345,7 +364,7 @@ fn deserialize_newtype_struct(ident: &syn::Ident,\n \n fn deserialize_struct(ident: &syn::Ident,\n                       variant_ident: Option<&syn::Ident>,\n-                      generics: &syn::Generics,\n+                      params: &Parameters,\n                       fields: &[Field],\n                       item_attrs: &attr::Item,\n                       deserializer: Option<Tokens>)\n@@ -353,7 +372,7 @@ fn deserialize_struct(ident: &syn::Ident,\n     let is_enum = variant_ident.is_some();\n     let is_untagged = deserializer.is_some();\n \n-    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(generics);\n+    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params);\n \n     let type_path = match variant_ident {\n         Some(variant_ident) => quote!(#ident::#variant_ident),\n@@ -364,10 +383,10 @@ fn deserialize_struct(ident: &syn::Ident,\n         None => format!(\"struct {}\", ident),\n     };\n \n-    let visit_seq = Stmts(deserialize_seq(ident, &type_path, generics, fields, true, item_attrs));\n+    let visit_seq = Stmts(deserialize_seq(ident, &type_path, params, fields, true, item_attrs));\n \n     let (field_visitor, fields_stmt, visit_map) =\n-        deserialize_struct_visitor(ident, type_path, generics, fields, item_attrs);\n+        deserialize_struct_visitor(ident, type_path, params, fields, item_attrs);\n     let field_visitor = Stmts(field_visitor);\n     let fields_stmt = Stmts(fields_stmt);\n     let visit_map = Stmts(visit_map);\n@@ -446,41 +465,41 @@ fn deserialize_struct(ident: &syn::Ident,\n }\n \n fn deserialize_item_enum(ident: &syn::Ident,\n-                         generics: &syn::Generics,\n+                         params: &Parameters,\n                          variants: &[Variant],\n                          item_attrs: &attr::Item)\n                          -> Fragment {\n     match *item_attrs.tag() {\n         attr::EnumTag::External => {\n-            deserialize_externally_tagged_enum(ident, generics, variants, item_attrs)\n+            deserialize_externally_tagged_enum(ident, params, variants, item_attrs)\n         }\n         attr::EnumTag::Internal { ref tag } => {\n             deserialize_internally_tagged_enum(ident,\n-                                               generics,\n+                                               params,\n                                                variants,\n                                                item_attrs,\n                                                tag)\n         }\n         attr::EnumTag::Adjacent { ref tag, ref content } => {\n             deserialize_adjacently_tagged_enum(ident,\n-                                               generics,\n+                                               params,\n                                                variants,\n                                                item_attrs,\n                                                tag,\n                                                content)\n         }\n         attr::EnumTag::None => {\n-            deserialize_untagged_enum(ident, generics, variants, item_attrs)\n+            deserialize_untagged_enum(ident, params, variants, item_attrs)\n         }\n     }\n }\n \n fn deserialize_externally_tagged_enum(ident: &syn::Ident,\n-                                      generics: &syn::Generics,\n+                                      params: &Parameters,\n                                       variants: &[Variant],\n                                       item_attrs: &attr::Item)\n                                       -> Fragment {\n-    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(generics);\n+    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params);\n \n     let type_name = item_attrs.name().deserialize_name();\n \n@@ -509,7 +528,7 @@ fn deserialize_externally_tagged_enum(ident: &syn::Ident,\n             let variant_name = field_i(i);\n \n             let block = Match(deserialize_externally_tagged_variant(ident,\n-                                                                    generics,\n+                                                                    params,\n                                                                     variant,\n                                                                     item_attrs));\n \n@@ -571,7 +590,7 @@ fn deserialize_externally_tagged_enum(ident: &syn::Ident,\n }\n \n fn deserialize_internally_tagged_enum(ident: &syn::Ident,\n-                                      generics: &syn::Generics,\n+                                      params: &Parameters,\n                                       variants: &[Variant],\n                                       item_attrs: &attr::Item,\n                                       tag: &str)\n@@ -600,7 +619,7 @@ fn deserialize_internally_tagged_enum(ident: &syn::Ident,\n \n             let block = Match(deserialize_internally_tagged_variant(\n                 ident,\n-                generics,\n+                params,\n                 variant,\n                 item_attrs,\n                 quote!(_serde::de::private::ContentDeserializer::<__D::Error>::new(__tagged.content)),\n@@ -627,13 +646,13 @@ fn deserialize_internally_tagged_enum(ident: &syn::Ident,\n }\n \n fn deserialize_adjacently_tagged_enum(ident: &syn::Ident,\n-                                      generics: &syn::Generics,\n+                                      params: &Parameters,\n                                       variants: &[Variant],\n                                       item_attrs: &attr::Item,\n                                       tag: &str,\n                                       content: &str)\n                                       -> Fragment {\n-    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(generics);\n+    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params);\n \n     let variant_names_idents: Vec<_> = variants.iter()\n         .enumerate()\n@@ -658,7 +677,7 @@ fn deserialize_adjacently_tagged_enum(ident: &syn::Ident,\n \n             let block = Match(deserialize_untagged_variant(\n                 ident,\n-                generics,\n+                params,\n                 variant,\n                 item_attrs,\n                 quote!(__deserializer),\n@@ -866,7 +885,7 @@ fn deserialize_adjacently_tagged_enum(ident: &syn::Ident,\n }\n \n fn deserialize_untagged_enum(ident: &syn::Ident,\n-                             generics: &syn::Generics,\n+                             params: &Parameters,\n                              variants: &[Variant],\n                              item_attrs: &attr::Item)\n                              -> Fragment {\n@@ -875,7 +894,7 @@ fn deserialize_untagged_enum(ident: &syn::Ident,\n         .map(|variant| {\n             Expr(deserialize_untagged_variant(\n                 ident,\n-                generics,\n+                params,\n                 variant,\n                 item_attrs,\n                 quote!(_serde::de::private::ContentRefDeserializer::<__D::Error>::new(&__content)),\n@@ -904,7 +923,7 @@ fn deserialize_untagged_enum(ident: &syn::Ident,\n }\n \n fn deserialize_externally_tagged_variant(ident: &syn::Ident,\n-                                         generics: &syn::Generics,\n+                                         params: &Parameters,\n                                          variant: &Variant,\n                                          item_attrs: &attr::Item)\n                                          -> Fragment {\n@@ -920,13 +939,13 @@ fn deserialize_externally_tagged_variant(ident: &syn::Ident,\n         Style::Newtype => {\n             deserialize_externally_tagged_newtype_variant(ident,\n                                                           variant_ident,\n-                                                          generics,\n+                                                          params,\n                                                           &variant.fields[0])\n         }\n         Style::Tuple => {\n             deserialize_tuple(ident,\n                               Some(variant_ident),\n-                              generics,\n+                              params,\n                               &variant.fields,\n                               item_attrs,\n                               None)\n@@ -934,7 +953,7 @@ fn deserialize_externally_tagged_variant(ident: &syn::Ident,\n         Style::Struct => {\n             deserialize_struct(ident,\n                                Some(variant_ident),\n-                               generics,\n+                               params,\n                                &variant.fields,\n                                item_attrs,\n                                None)\n@@ -943,7 +962,7 @@ fn deserialize_externally_tagged_variant(ident: &syn::Ident,\n }\n \n fn deserialize_internally_tagged_variant(ident: &syn::Ident,\n-                                         generics: &syn::Generics,\n+                                         params: &Parameters,\n                                          variant: &Variant,\n                                          item_attrs: &attr::Item,\n                                          deserializer: Tokens)\n@@ -961,7 +980,7 @@ fn deserialize_internally_tagged_variant(ident: &syn::Ident,\n         }\n         Style::Newtype | Style::Struct => {\n             deserialize_untagged_variant(ident,\n-                                         generics,\n+                                         params,\n                                          variant,\n                                          item_attrs,\n                                          deserializer)\n@@ -971,7 +990,7 @@ fn deserialize_internally_tagged_variant(ident: &syn::Ident,\n }\n \n fn deserialize_untagged_variant(ident: &syn::Ident,\n-                                generics: &syn::Generics,\n+                                params: &Parameters,\n                                 variant: &Variant,\n                                 item_attrs: &attr::Item,\n                                 deserializer: Tokens)\n@@ -994,14 +1013,14 @@ fn deserialize_untagged_variant(ident: &syn::Ident,\n         Style::Newtype => {\n             deserialize_untagged_newtype_variant(ident,\n                                                  variant_ident,\n-                                                 generics,\n+                                                 params,\n                                                  &variant.fields[0],\n                                                  deserializer)\n         }\n         Style::Tuple => {\n             deserialize_tuple(ident,\n                               Some(variant_ident),\n-                              generics,\n+                              params,\n                               &variant.fields,\n                               item_attrs,\n                               Some(deserializer))\n@@ -1009,7 +1028,7 @@ fn deserialize_untagged_variant(ident: &syn::Ident,\n         Style::Struct => {\n             deserialize_struct(ident,\n                                Some(variant_ident),\n-                               generics,\n+                               params,\n                                &variant.fields,\n                                item_attrs,\n                                Some(deserializer))\n@@ -1019,7 +1038,7 @@ fn deserialize_untagged_variant(ident: &syn::Ident,\n \n fn deserialize_externally_tagged_newtype_variant(ident: &syn::Ident,\n                                                  variant_ident: &syn::Ident,\n-                                                 generics: &syn::Generics,\n+                                                 params: &Parameters,\n                                                  field: &Field)\n                                                  -> Fragment {\n     match field.attrs.deserialize_with() {\n@@ -1033,7 +1052,7 @@ fn deserialize_externally_tagged_newtype_variant(ident: &syn::Ident,\n         }\n         Some(path) => {\n             let (wrapper, wrapper_ty) =\n-                wrap_deserialize_with(ident, generics, field.ty, path);\n+                wrap_deserialize_with(ident, params, field.ty, path);\n             quote_block! {\n                 #wrapper\n                 _serde::export::Result::map(\n@@ -1046,7 +1065,7 @@ fn deserialize_externally_tagged_newtype_variant(ident: &syn::Ident,\n \n fn deserialize_untagged_newtype_variant(ident: &syn::Ident,\n                                         variant_ident: &syn::Ident,\n-                                        generics: &syn::Generics,\n+                                        params: &Parameters,\n                                         field: &Field,\n                                         deserializer: Tokens)\n                                         -> Fragment {\n@@ -1061,7 +1080,7 @@ fn deserialize_untagged_newtype_variant(ident: &syn::Ident,\n         }\n         Some(path) => {\n             let (wrapper, wrapper_ty) =\n-                wrap_deserialize_with(ident, generics, field.ty, path);\n+                wrap_deserialize_with(ident, params, field.ty, path);\n             quote_block! {\n                 #wrapper\n                 _serde::export::Result::map(\n@@ -1186,7 +1205,7 @@ fn deserialize_field_visitor(fields: Vec<(String, Ident)>,\n \n fn deserialize_struct_visitor(ident: &syn::Ident,\n                               struct_path: Tokens,\n-                              generics: &syn::Generics,\n+                              params: &Parameters,\n                               fields: &[Field],\n                               item_attrs: &attr::Item)\n                               -> (Fragment, Fragment, Fragment) {\n@@ -1205,14 +1224,14 @@ fn deserialize_struct_visitor(ident: &syn::Ident,\n \n     let field_visitor = deserialize_field_visitor(field_names_idents, item_attrs, false);\n \n-    let visit_map = deserialize_map(ident, struct_path, generics, fields, item_attrs);\n+    let visit_map = deserialize_map(ident, struct_path, params, fields, item_attrs);\n \n     (field_visitor, fields_stmt, visit_map)\n }\n \n fn deserialize_map(ident: &syn::Ident,\n                    struct_path: Tokens,\n-                   generics: &syn::Generics,\n+                   params: &Parameters,\n                    fields: &[Field],\n                    item_attrs: &attr::Item)\n                    -> Fragment {\n@@ -1247,7 +1266,7 @@ fn deserialize_map(ident: &syn::Ident,\n                 }\n                 Some(path) => {\n                     let (wrapper, wrapper_ty) = wrap_deserialize_with(\n-                        ident, generics, field.ty, path);\n+                        ident, params, field.ty, path);\n                     quote!({\n                         #wrapper\n                         try!(_serde::de::MapVisitor::visit_value::<#wrapper_ty>(&mut __visitor)).value\n@@ -1355,11 +1374,11 @@ fn field_i(i: usize) -> Ident {\n /// This function wraps the expression in `#[serde(deserialize_with=\"...\")]` in\n /// a trait to prevent it from accessing the internal `Deserialize` state.\n fn wrap_deserialize_with(ident: &syn::Ident,\n-                         generics: &syn::Generics,\n+                         params: &Parameters,\n                          field_ty: &syn::Ty,\n                          deserialize_with: &syn::Path)\n                          -> (Tokens, Tokens) {\n-    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(generics);\n+    let (de_impl_generics, de_ty_generics, ty_generics, where_clause) = split_with_de_lifetime(params);\n \n     let wrapper = quote! {\n         struct __DeserializeWith #de_impl_generics #where_clause {\n@@ -1420,34 +1439,16 @@ fn expr_is_missing(field: &Field, item_attrs: &attr::Item) -> Fragment {\n     }\n }\n \n-fn check_no_str(cx: &internals::Ctxt, item: &Item) {\n-    let fail = || {\n-        cx.error(\"Serde does not support deserializing fields of type &str; consider using \\\n-                  String instead\");\n-    };\n-\n-    for field in item.body.all_fields() {\n-        if field.attrs.skip_deserializing() || field.attrs.deserialize_with().is_some() {\n-            continue;\n-        }\n-\n-        if let syn::Ty::Rptr(_, ref inner) = *field.ty {\n-            if let syn::Ty::Path(_, ref path) = inner.ty {\n-                if path.segments.len() == 1 && path.segments[0].ident == \"str\" {\n-                    fail();\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-struct DeImplGenerics<'a>(&'a syn::Generics);\n+struct DeImplGenerics<'a>(&'a Parameters);\n \n impl<'a> ToTokens for DeImplGenerics<'a> {\n     fn to_tokens(&self, tokens: &mut Tokens) {\n-        let mut generics = self.0.clone();\n-        generics.lifetimes.insert(0, syn::LifetimeDef::new(\"'de\"));\n+        let mut generics = self.0.generics.clone();\n+        generics.lifetimes.insert(0, syn::LifetimeDef {\n+            attrs: Vec::new(),\n+            lifetime: syn::Lifetime::new(\"'de\"),\n+            bounds: self.0.borrowed.iter().cloned().collect(),\n+        });\n         let (impl_generics, _, _) = generics.split_for_impl();\n         impl_generics.to_tokens(tokens);\n     }\n@@ -1464,9 +1465,9 @@ impl<'a> ToTokens for DeTyGenerics<'a> {\n     }\n }\n \n-fn split_with_de_lifetime(generics: &syn::Generics) -> (DeImplGenerics, DeTyGenerics, syn::TyGenerics, &syn::WhereClause) {\n-    let de_impl_generics = DeImplGenerics(generics);\n-    let de_ty_generics = DeTyGenerics(generics);\n-    let (_, ty_generics, where_clause) = generics.split_for_impl();\n+fn split_with_de_lifetime(params: &Parameters) -> (DeImplGenerics, DeTyGenerics, syn::TyGenerics, &syn::WhereClause) {\n+    let de_impl_generics = DeImplGenerics(&params);\n+    let de_ty_generics = DeTyGenerics(&params.generics);\n+    let (_, ty_generics, where_clause) = params.generics.split_for_impl();\n     (de_impl_generics, de_ty_generics, ty_generics, where_clause)\n }\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex b2d6dd127..2ec45f464 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -105,8 +105,10 @@ impl<'de, 'a, I> de::Deserializer<'de> for &'a mut Deserializer<I>\n             Some(Token::F64(v)) => visitor.visit_f64(v),\n             Some(Token::Char(v)) => visitor.visit_char(v),\n             Some(Token::Str(v)) => visitor.visit_str(v),\n+            Some(Token::BorrowedStr(v)) => visitor.visit_borrowed_str(v),\n             Some(Token::String(v)) => visitor.visit_string(v),\n             Some(Token::Bytes(v)) => visitor.visit_bytes(v),\n+            Some(Token::BorrowedBytes(v)) => visitor.visit_borrowed_bytes(v),\n             Some(Token::ByteBuf(v)) => visitor.visit_byte_buf(v),\n             Some(Token::Option(false)) => visitor.visit_none(),\n             Some(Token::Option(true)) => visitor.visit_some(self),\ndiff --git a/serde_test/src/token.rs b/serde_test/src/token.rs\nindex 82ccd9f2c..05e15583a 100644\n--- a/serde_test/src/token.rs\n+++ b/serde_test/src/token.rs\n@@ -39,12 +39,18 @@ pub enum Token<'a> {\n     /// A serialized `str`.\n     Str(&'a str),\n \n+    /// A borrowed `str`.\n+    BorrowedStr(&'a str),\n+\n     /// A serialized `String`.\n     String(String),\n \n     /// A serialized `[u8]`\n     Bytes(&'a [u8]),\n \n+    /// A borrowed `[u8]`.\n+    BorrowedBytes(&'a [u8]),\n+\n     /// A serialized `ByteBuf`\n     ByteBuf(Vec<u8>),\n \ndiff --git a/test_suite/tests/compile-fail/borrow/bad_lifetimes.rs b/test_suite/tests/compile-fail/borrow/bad_lifetimes.rs\nnew file mode 100644\nindex 000000000..b4a5e4a38\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/borrow/bad_lifetimes.rs\n@@ -0,0 +1,10 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+struct Test<'a> {\n+    #[serde(borrow = \"zzz\")] //~^^ HELP: failed to parse borrowed lifetimes: \"zzz\"\n+    s: &'a str,\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/borrow/duplicate_lifetime.rs b/test_suite/tests/compile-fail/borrow/duplicate_lifetime.rs\nnew file mode 100644\nindex 000000000..542ddc2a7\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/borrow/duplicate_lifetime.rs\n@@ -0,0 +1,10 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+struct Test<'a> {\n+    #[serde(borrow = \"'a + 'a\")] //~^^ HELP: duplicate borrowed lifetime `'a`\n+    s: &'a str,\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/borrow/empty_lifetimes.rs b/test_suite/tests/compile-fail/borrow/empty_lifetimes.rs\nnew file mode 100644\nindex 000000000..c1d43b579\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/borrow/empty_lifetimes.rs\n@@ -0,0 +1,10 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+struct Test<'a> {\n+    #[serde(borrow = \"\")] //~^^ HELP: at least one lifetime must be borrowed\n+    s: &'a str,\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/borrow/no_lifetimes.rs b/test_suite/tests/compile-fail/borrow/no_lifetimes.rs\nnew file mode 100644\nindex 000000000..47b3c0d47\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/borrow/no_lifetimes.rs\n@@ -0,0 +1,10 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+struct Test {\n+    #[serde(borrow)] //~^^ HELP: field `s` has no lifetimes to borrow\n+    s: String,\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/borrow/wrong_lifetime.rs b/test_suite/tests/compile-fail/borrow/wrong_lifetime.rs\nnew file mode 100644\nindex 000000000..5cf8999fa\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/borrow/wrong_lifetime.rs\n@@ -0,0 +1,10 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Deserialize)] //~ ERROR: proc-macro derive panicked\n+struct Test<'a> {\n+    #[serde(borrow = \"'b\")] //~^^ HELP: field `s` does not have lifetime 'b\n+    s: &'a str,\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/str_ref_deser.rs b/test_suite/tests/compile-fail/str_ref_deser.rs\ndeleted file mode 100644\nindex 51f03f5c7..000000000\n--- a/test_suite/tests/compile-fail/str_ref_deser.rs\n+++ /dev/null\n@@ -1,9 +0,0 @@\n-#[macro_use]\n-extern crate serde_derive;\n-\n-#[derive(Serialize, Deserialize)] //~ ERROR: proc-macro derive panicked\n-struct Test<'a> {\n-    s: &'a str, //~^^ HELP: Serde does not support deserializing fields of type &str\n-}\n-\n-fn main() {}\ndiff --git a/test_suite/tests/test_borrow.rs b/test_suite/tests/test_borrow.rs\nnew file mode 100644\nindex 000000000..dd75f70b2\n--- /dev/null\n+++ b/test_suite/tests/test_borrow.rs\n@@ -0,0 +1,199 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+extern crate serde;\n+use serde::{Deserialize, Deserializer};\n+\n+extern crate serde_test;\n+use serde_test::{\n+    Error,\n+    Token,\n+    assert_de_tokens,\n+    assert_de_tokens_error,\n+};\n+\n+use std::borrow::Cow;\n+\n+#[test]\n+fn test_borrowed_str() {\n+    assert_de_tokens(\n+        &\"borrowed\",\n+        &[\n+            Token::BorrowedStr(\"borrowed\"),\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn test_borrowed_str_from_string() {\n+    assert_de_tokens_error::<&str>(\n+        &[\n+            Token::String(\"borrowed\".to_owned()),\n+        ],\n+        Error::Message(\"invalid type: string \\\"borrowed\\\", expected a borrowed string\".to_owned()),\n+    );\n+}\n+\n+#[test]\n+fn test_borrowed_str_from_str() {\n+    assert_de_tokens_error::<&str>(\n+        &[\n+            Token::Str(\"borrowed\"),\n+        ],\n+        Error::Message(\"invalid type: string \\\"borrowed\\\", expected a borrowed string\".to_owned()),\n+    );\n+}\n+\n+#[test]\n+fn test_string_from_borrowed_str() {\n+    assert_de_tokens(\n+        &\"owned\".to_owned(),\n+        &[\n+            Token::BorrowedStr(\"owned\"),\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn test_borrowed_bytes() {\n+    assert_de_tokens(\n+        &&b\"borrowed\"[..],\n+        &[\n+            Token::BorrowedBytes(b\"borrowed\"),\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn test_borrowed_bytes_from_bytebuf() {\n+    assert_de_tokens_error::<&[u8]>(\n+        &[\n+            Token::ByteBuf(b\"borrowed\".to_vec()),\n+        ],\n+        Error::Message(\"invalid type: byte array, expected a borrowed byte array\".to_owned()),\n+    );\n+}\n+\n+#[test]\n+fn test_borrowed_bytes_from_bytes() {\n+    assert_de_tokens_error::<&[u8]>(\n+        &[\n+            Token::Bytes(b\"borrowed\"),\n+        ],\n+        Error::Message(\"invalid type: byte array, expected a borrowed byte array\".to_owned()),\n+    );\n+}\n+\n+#[test]\n+fn test_tuple() {\n+    assert_de_tokens(\n+        &(\"str\", &b\"bytes\"[..]),\n+        &[\n+            Token::TupleStart(2),\n+\n+            Token::TupleSep,\n+            Token::BorrowedStr(\"str\"),\n+\n+            Token::TupleSep,\n+            Token::BorrowedBytes(b\"bytes\"),\n+\n+            Token::TupleEnd,\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn test_struct() {\n+    #[derive(Deserialize, Debug, PartialEq)]\n+    struct Borrowing<'a, 'b> {\n+        bs: &'a str,\n+        bb: &'b [u8],\n+    }\n+\n+    assert_de_tokens(\n+        &Borrowing { bs: \"str\", bb: b\"bytes\" },\n+        &[\n+            Token::StructStart(\"Borrowing\", 2),\n+\n+            Token::StructSep,\n+            Token::BorrowedStr(\"bs\"),\n+            Token::BorrowedStr(\"str\"),\n+\n+            Token::StructSep,\n+            Token::BorrowedStr(\"bb\"),\n+            Token::BorrowedBytes(b\"bytes\"),\n+\n+            Token::StructEnd,\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn test_cow() {\n+    #[derive(Deserialize)]\n+    struct Cows<'a, 'b> {\n+        copied: Cow<'a, str>,\n+\n+        #[serde(borrow)]\n+        borrowed: Cow<'b, str>,\n+    }\n+\n+    let tokens = vec![\n+        Token::StructStart(\"Cows\", 2),\n+\n+        Token::StructSep,\n+        Token::Str(\"copied\"),\n+        Token::BorrowedStr(\"copied\"),\n+\n+        Token::StructSep,\n+        Token::Str(\"borrowed\"),\n+        Token::BorrowedStr(\"borrowed\"),\n+\n+        Token::StructEnd,\n+    ];\n+\n+    let mut de = serde_test::Deserializer::new(tokens.into_iter());\n+    let cows = Cows::deserialize(&mut de).unwrap();\n+    assert_eq!(de.next_token(), None);\n+\n+    match cows.copied {\n+        Cow::Owned(ref s) if s == \"copied\" => {}\n+        _ => panic!(\"expected a copied string\"),\n+    }\n+\n+    match cows.borrowed {\n+        Cow::Borrowed(\"borrowed\") => {}\n+        _ => panic!(\"expected a borrowed string\"),\n+    }\n+}\n+\n+#[test]\n+fn test_lifetimes() {\n+    #[derive(Deserialize)]\n+    struct Cows<'a, 'b> {\n+        _copied: Cow<'a, str>,\n+\n+        #[serde(borrow)]\n+        _borrowed: Cow<'b, str>,\n+    }\n+\n+    // Tests that `'de: 'a` is not required by the Deserialize impl.\n+    fn _cows_lifetimes<'de: 'b, 'a, 'b, D>(deserializer: D) -> Cows<'a, 'b>\n+        where D: Deserializer<'de>\n+    {\n+        Deserialize::deserialize(deserializer).unwrap()\n+    }\n+\n+    #[derive(Deserialize)]\n+    struct Wrap<'a, 'b> {\n+        #[serde(borrow = \"'b\")]\n+        _cows: Cows<'a, 'b>,\n+    }\n+\n+    // Tests that `'de: 'a` is not required by the Deserialize impl.\n+    fn _wrap_lifetimes<'de: 'b, 'a, 'b, D>(deserializer: D) -> Wrap<'a, 'b>\n+        where D: Deserializer<'de>\n+    {\n+        Deserialize::deserialize(deserializer).unwrap()\n+    }\n+}\n", "problem_statement": "What's serde zero-copy story so far?\nHi all, first of all huge kudos to all contributors! Serde is already a tried and proven framework for de/serializing! \n\nI was wondering what's the current state or plans to support zero-copy deserialization, aka deserializing into &str and &[u8].\n\n", "hints_text": "That kind of deserialization is only possible when the original serialized state outlives the deserialized data, and the data is in the correct format.\n\nIt's probably nothing more than spraying a few lifetimes around, but it might break the existing use cases, so we have to take care here.\n\nHere is a proof of concept of what @oli-obk meant by \"spraying a few lifetimes around.\" The remaining work on this issue will be figuring out how to support this without polluting every usage of Deserialize and Deserializer with lifetimes.\r\n\r\n```rust\r\ntrait Deserialize<'a>: Sized {\r\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\r\n        where D: Deserializer<'a>;\r\n}\r\n\r\ntrait Deserializer<'a>: Sized {\r\n    type Error: Error;\r\n\r\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\r\n        where V: Visitor<'a>;\r\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\r\n        where V: Visitor<'a>;\r\n}\r\n\r\ntrait Error {\r\n    fn whatever() -> Self;\r\n}\r\n\r\ntrait Visitor<'a>: Sized {\r\n    type Value;\r\n\r\n    fn visit_str_from_input<E>(self, v: &'a str) -> Result<Self::Value, E>\r\n        where E: Error\r\n    {\r\n        self.visit_str(v)\r\n    }\r\n\r\n    fn visit_str<E>(self, _v: &str) -> Result<Self::Value, E>\r\n        where E: Error\r\n    {\r\n        Err(Error::whatever())\r\n    }\r\n\r\n    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\r\n        where E: Error\r\n    {\r\n        self.visit_str(&v)\r\n    }\r\n}\r\n\r\nimpl<'a> Deserialize<'a> for String {\r\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\r\n        where D: Deserializer<'a>\r\n    {\r\n        struct StringVisitor;\r\n\r\n        impl<'a> Visitor<'a> for StringVisitor {\r\n            type Value = String;\r\n\r\n            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\r\n                where E: Error\r\n            {\r\n                Ok(v.to_owned())\r\n            }\r\n\r\n            fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\r\n                where E: Error\r\n            {\r\n                Ok(v)\r\n            }\r\n        }\r\n\r\n        deserializer.deserialize_string(StringVisitor)\r\n    }\r\n}\r\n\r\nimpl<'a> Deserialize<'a> for &'a str {\r\n    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\r\n        where D: Deserializer<'a>\r\n    {\r\n        struct StrVisitor;\r\n\r\n        impl<'a> Visitor<'a> for StrVisitor {\r\n            type Value = &'a str;\r\n\r\n            fn visit_str_from_input<E>(self, v: &'a str) -> Result<Self::Value, E>\r\n                where E: Error\r\n            {\r\n                Ok(v)\r\n            }\r\n        }\r\n\r\n        deserializer.deserialize_str(StrVisitor)\r\n    }\r\n}\r\n```\nOne unfortunate limitation here that would require some sort of lifetime dispatch is that we can't have `Cow<'a, T>` borrow the data if the input outlives the output, and copy the data if the input does not outlive the output. We either need to `impl<'a, 'd, T> Deserialize<'d> for Cow<'a, T>` and have it always copy, or `impl<'a, T> Deserialize<'a> for Cow<'a, T>` and have it always borrow even if you would otherwise want it to copy.\n#819 would be a way to preserve the current Deserialize and Deserializer traits without lifetimes.\nIt makes me sad that the approach in https://github.com/serde-rs/serde/issues/492#issuecomment-287152946 is so simple but would require HRTB to accomplish most things that a person would want to do with Deserialize.\r\n\r\n```rust\r\npub fn from_reader<R, T>(rdr: R) -> Result<T>\r\n    where R: Read,\r\n          T: for<'a> Deserialize<'a>\r\n```\r\n\r\nI would not want an understanding of HRTB as a prerequisite for using Serde. @maciejhirsz have you found this to be a problem with bitsparrow::BitDecode\\<'src>?\r\n\r\nMaybe if we ever get type aliases in trait bounds, we could somehow have Deserialize be an alias for `for<'a> Deserialize<'a>`.\nMaybe we want this sort of setup, but unclear whether this is less or more complicated than HRTB.\r\n\r\n```rust\r\npub trait DeserializeBorrow<'a>;\r\npub trait Deserialize: for<'a> DeserializeBorrow<'a>;\r\nimpl<T> Deserialize for T where T: for<'a> DeserializeBorrow<'a>;\r\n\r\n\r\n// #[derive(Deserialize)]\r\nstruct A;\r\nimpl<'a> DeserializeBorrow<'a> for A;\r\n\r\n// #[derive(DeserializeBorrow)]\r\nstruct B<'b> { b: &'b str }\r\nimpl<'b> DeserializeBorrow<'b> for B<'b>;\r\n\r\n\r\npub fn from_reader<R, T>(rdr: R) -> Result<T>\r\n    where R: Read,\r\n          T: Deserialize;\r\n\r\npub fn from_str<'a, T>(s: &'a str) -> Result<T>\r\n    where T: DeserializeBorrow<'a>;\r\n```\nDidn't run into any issues with HRTB for sparrow. For the most part, the fact that there is a lifetime on the trait is completely opaque to the end user when deriving the impl, which - I imagine - is the vast majority of cases. Even when you implement it manually you just need to stick two `<'a>`s on your `impl` and you are done.\r\n\r\nThat said, I didn't have backwards compatibility to consider.\nRight, deriving is not a problem and I am also not concerned about handwritten impls because that is an advanced use case anyway.\r\n\r\nLook at [these 220 places](https://github.com/search?l=Rust&q=%22where+t+deserialize%22&type=Code). Almost all of those would require HRTB and practically all users will need to interact with a function like that to use Serde, for example serde_json::from_reader.\nRight now I am leaning toward Deserialize\\<'a> along with an explicit setting to opt into borrowing particular fields to address https://github.com/serde-rs/serde/issues/492#issuecomment-287585503.\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\nstruct S<'a, 'b, 'c, 'd, 'e, 'f, 'g> {\r\n    // &str and &[u8] are the only types automatically borrowed\r\n    a: &'a str,\r\n    b: &'b [u8],\r\n\r\n    // everything else must use serde(borrow)\r\n    #[serde(borrow)]\r\n    c: Cow<'c, str>,\r\n    #[serde(borrow)]\r\n    d: T<'d>,\r\n    #[serde(borrow = \"'e + 'f\")]\r\n    x: X<'e, 'f, 'g>,\r\n}\r\n```\r\n\r\nAlong with possibly a helper trait to simplify bounds. I think `T: DeserializeOwned` is clearer in intent and meaning than `T: for<'a> Deserialize<'a>`.\r\n\r\n```rust\r\npub trait DeserializeOwned: for<'a> Deserialize<'a> {}\r\nimpl<T> DeserializeOwned for T where T: for<'a> Deserialize<'a> {}\r\n\r\npub fn from_reader<R, T>(rdr: R) -> Result<T>\r\n    where R: Read,\r\n          T: DeserializeOwned;\r\n\r\npub fn from_str<'a, T>(s: &'a str) -> Result<T>\r\n    where T: Deserialize<'a>;\r\n```", "created_at": "2017-04-03T07:48:50Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 824, "instance_id": "serde-rs__serde-824", "issue_numbers": ["823"], "base_commit": "71ccc5753be3f74fba512b8b7e3f237b1bbb89c0", "patch": "diff --git a/appveyor.yml b/appveyor.yml\nnew file mode 100644\nindex 000000000..f720b046f\n--- /dev/null\n+++ b/appveyor.yml\n@@ -0,0 +1,17 @@\n+environment:\n+  matrix:\n+    - APPVEYOR_RUST_CHANNEL: stable\n+    - APPVEYOR_RUST_CHANNEL: nightly\n+\n+install:\n+  # Install rust, x86_64-pc-windows-msvc host\n+  - appveyor DownloadFile https://win.rustup.rs/ -FileName rustup-init.exe\n+  - rustup-init.exe -y --default-host x86_64-pc-windows-msvc --default-toolchain %APPVEYOR_RUST_CHANNEL%\n+  - set PATH=C:\\msys64\\usr\\bin;%PATH%;C:\\Users\\appveyor\\.cargo\\bin\n+  - rustc -vV\n+  - cargo -vV\n+\n+build: false\n+\n+test_script:\n+  - sh -c 'PATH=`rustc --print sysroot`/bin:$PATH ./travis.sh'\ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 35f3cdf23..7bffab32a 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -26,7 +26,7 @@ use std::net;\n use std::path;\n use core::str;\n #[cfg(feature = \"std\")]\n-use std::ffi::CString;\n+use std::ffi::{CString, OsString};\n #[cfg(all(feature = \"std\", feature=\"unstable\"))]\n use std::ffi::CStr;\n \n@@ -910,6 +910,7 @@ impl Visitor for PathBufVisitor {\n     }\n }\n \n+\n #[cfg(feature = \"std\")]\n impl Deserialize for path::PathBuf {\n     fn deserialize<D>(deserializer: D) -> Result<path::PathBuf, D::Error>\n@@ -921,6 +922,110 @@ impl Deserialize for path::PathBuf {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+#[cfg(all(feature = \"std\", any(unix, windows)))]\n+enum OsStringKind {\n+    Unix,\n+    Windows,\n+}\n+\n+#[cfg(all(feature = \"std\", any(unix, windows)))]\n+static OSSTR_VARIANTS: &'static [&'static str] = &[\"Unix\", \"Windows\"];\n+\n+#[cfg(all(feature = \"std\", any(unix, windows)))]\n+impl Deserialize for OsStringKind {\n+    fn deserialize<D>(deserializer: D) -> Result<OsStringKind, D::Error>\n+        where D: Deserializer\n+    {\n+        struct KindVisitor;\n+\n+        impl Visitor for KindVisitor {\n+            type Value = OsStringKind;\n+\n+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                formatter.write_str(\"`Unix` or `Windows`\")\n+            }\n+\n+            fn visit_u32<E>(self, value: u32) -> Result<OsStringKind, E>\n+                where E: Error,\n+            {\n+                match value {\n+                    0 => Ok(OsStringKind::Unix),\n+                    1 => Ok(OsStringKind::Windows),\n+                    _ => Err(Error::invalid_value(Unexpected::Unsigned(value as u64), &self))\n+                }\n+            }\n+\n+            fn visit_str<E>(self, value: &str) -> Result<OsStringKind, E>\n+                where E: Error,\n+            {\n+                match value {\n+                    \"Unix\" => Ok(OsStringKind::Unix),\n+                    \"Windows\" => Ok(OsStringKind::Windows),\n+                    _ => Err(Error::unknown_variant(value, OSSTR_VARIANTS)),\n+                }\n+            }\n+\n+            fn visit_bytes<E>(self, value: &[u8]) -> Result<OsStringKind, E>\n+                where E: Error,\n+            {\n+                match value {\n+                    b\"Unix\" => Ok(OsStringKind::Unix),\n+                    b\"Windows\" => Ok(OsStringKind::Windows),\n+                    _ => {\n+                        match str::from_utf8(value) {\n+                            Ok(value) => Err(Error::unknown_variant(value, OSSTR_VARIANTS)),\n+                            Err(_) => {\n+                                Err(Error::invalid_value(Unexpected::Bytes(value), &self))\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        deserializer.deserialize(KindVisitor)\n+    }\n+}\n+\n+#[cfg(all(feature = \"std\", any(unix, windows)))]\n+struct OsStringVisitor;\n+\n+#[cfg(all(feature = \"std\", any(unix, windows)))]\n+impl Visitor for OsStringVisitor {\n+    type Value = OsString;\n+\n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        formatter.write_str(\"os string\")\n+    }\n+\n+    #[cfg(unix)]\n+    fn visit_enum<V>(self, visitor: V) -> Result<OsString, V::Error>\n+        where V: EnumVisitor,\n+    {\n+        use std::os::unix::ffi::OsStringExt;\n+\n+        match try!(visitor.visit_variant()) {\n+            (OsStringKind::Unix, variant) => {\n+                variant.visit_newtype().map(OsString::from_vec)\n+            }\n+            (OsStringKind::Windows, _) => {\n+                Err(Error::custom(\"cannot deserialize windows os string on unix\"))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(all(feature = \"std\", any(unix, windows)))]\n+impl Deserialize for OsString {\n+    fn deserialize<D>(deserializer: D) -> Result<OsString, D::Error>\n+        where D: Deserializer\n+    {\n+        deserializer.deserialize_enum(\"OsString\", OSSTR_VARIANTS, OsStringVisitor)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n impl<T: Deserialize> Deserialize for Box<T> {\n     fn deserialize<D>(deserializer: D) -> Result<Box<T>, D::Error>\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex 53ac7bf0c..4f8177604 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -20,7 +20,7 @@ use core::ops;\n #[cfg(feature = \"std\")]\n use std::path;\n #[cfg(feature = \"std\")]\n-use std::ffi::{CString, CStr};\n+use std::ffi::{CString, CStr, OsString, OsStr};\n #[cfg(feature = \"std\")]\n use std::rc::Rc;\n #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n@@ -714,6 +714,41 @@ impl Serialize for path::PathBuf {\n     }\n }\n \n+#[cfg(all(feature = \"std\", any(unix, windows)))]\n+impl Serialize for OsStr {\n+    #[cfg(unix)]\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+        where S: Serializer\n+    {\n+        use std::os::unix::ffi::OsStrExt;\n+        serializer.serialize_newtype_variant(\"OsString\",\n+                                             0,\n+                                             \"Unix\",\n+                                             self.as_bytes())\n+    }\n+    #[cfg(windows)]\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+        where S: Serializer\n+    {\n+        use std::os::windows::ffi::OsStrExt;\n+        let val = self.encode_wide().collect::<Vec<_>>();\n+        serializer.serialize_newtype_variant(\"OsString\",\n+                                             1,\n+                                             \"Windows\",\n+                                             &val)\n+    }\n+}\n+\n+#[cfg(all(feature = \"std\", any(unix, windows)))]\n+#[cfg(feature = \"std\")]\n+impl Serialize for OsString {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+        where S: Serializer\n+    {\n+        self.as_os_str().serialize(serializer)\n+    }\n+}\n+\n #[cfg(feature = \"unstable\")]\n impl<T> Serialize for NonZero<T>\n     where T: Serialize + Zeroable\ndiff --git a/travis.sh b/travis.sh\nindex d2e1a998e..d5f62d28c 100755\n--- a/travis.sh\n+++ b/travis.sh\n@@ -10,6 +10,11 @@ channel() {\n             pwd\n             (set -x; cargo \"$@\")\n         fi\n+    elif [ -n \"${APPVEYOR}\" ]; then\n+        if [ \"${APPVEYOR_RUST_CHANNEL}\" = \"${CHANNEL}\" ]; then\n+            pwd\n+            (set -x; cargo \"$@\")\n+        fi\n     else\n         pwd\n         (set -x; cargo \"+${CHANNEL}\" \"$@\")\n", "test_patch": "diff --git a/test_suite/no_std/src/main.rs b/test_suite/no_std/src/main.rs\nindex 6639b5ccc..a4469819c 100644\n--- a/test_suite/no_std/src/main.rs\n+++ b/test_suite/no_std/src/main.rs\n@@ -1,7 +1,8 @@\n-#![feature(lang_items, start, libc)]\n+#![feature(lang_items, start, libc, compiler_builtins_lib)]\n #![no_std]\n \n extern crate libc;\n+extern crate compiler_builtins;\n \n #[start]\n fn start(_argc: isize, _argv: *const *const u8) -> isize {\ndiff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex 066eb2a31..8d21844cc 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -8,7 +8,7 @@ use std::net;\n use std::path::PathBuf;\n use std::time::Duration;\n use std::default::Default;\n-use std::ffi::CString;\n+use std::ffi::{CString, OsString};\n \n #[cfg(feature = \"unstable\")]\n use std::ffi::CStr;\n@@ -913,6 +913,56 @@ declare_tests! {\n     }\n }\n \n+#[cfg(unix)]\n+#[test]\n+fn test_osstring() {\n+    use std::os::unix::ffi::OsStringExt;\n+\n+    let value = OsString::from_vec(vec![1, 2, 3]);\n+    let tokens = [\n+        Token::EnumStart(\"OsString\"),\n+        Token::Str(\"Unix\"),\n+        Token::SeqStart(Some(2)),\n+            Token::SeqSep,\n+            Token::U8(1),\n+\n+            Token::SeqSep,\n+            Token::U8(2),\n+\n+            Token::SeqSep,\n+            Token::U8(3),\n+        Token::SeqEnd,\n+    ];\n+\n+    assert_de_tokens(&value, &tokens);\n+    assert_de_tokens_ignore(&tokens);\n+}\n+\n+#[cfg(windows)]\n+#[test]\n+fn test_osstring() {\n+    use std::os::windows::ffi::OsStringExt;\n+\n+    let value = OsString::from_wide(&[1, 2, 3]);\n+    let tokens = [\n+        Token::EnumStart(\"OsString\"),\n+        Token::Str(\"Windows\"),\n+        Token::SeqStart(Some(2)),\n+            Token::SeqSep,\n+            Token::U16(1),\n+\n+            Token::SeqSep,\n+            Token::U16(2),\n+\n+            Token::SeqSep,\n+            Token::U16(3),\n+        Token::SeqEnd,\n+    ];\n+\n+    assert_de_tokens(&value, &tokens);\n+    assert_de_tokens_ignore(&tokens);\n+}\n+\n #[cfg(feature = \"unstable\")]\n #[test]\n fn test_cstr() {\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex d58fdfe71..7613cb8ad 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -422,6 +422,7 @@ fn test_net_ipaddr() {\n }\n \n #[test]\n+#[cfg(unix)]\n fn test_cannot_serialize_paths() {\n     let path = unsafe {\n         str::from_utf8_unchecked(b\"Hello \\xF0\\x90\\x80World\")\n", "problem_statement": "Implementations for OsStr/ing\n\n", "hints_text": "It's unclear whether this should be provided at all, given that `OsString` differs by platform, so there's no way to ensure that round-trips (eg. windows -> linux -> windows) are lossless.\r\n\r\nIf this is going to be added, I think it should tag the encoded string with the platform, and refuse to decode a windows OsString into a linux OsString or vice-versa, given that any data encoded this way will not be portable.", "created_at": "2017-03-27T16:21:38Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 813, "instance_id": "serde-rs__serde-813", "issue_numbers": ["796"], "base_commit": "77ee306b573e9adf6eaacc7204ad5bad3928b28d", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 85bf64c4e..35f3cdf23 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -46,6 +46,9 @@ use alloc::boxed::Box;\n #[cfg(feature = \"std\")]\n use std::time::Duration;\n \n+#[cfg(feature = \"std\")]\n+use std;\n+\n #[cfg(feature = \"unstable\")]\n use core::nonzero::{NonZero, Zeroable};\n \n@@ -1108,6 +1111,137 @@ impl Deserialize for Duration {\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////////\n+\n+// Similar to:\n+//\n+//     #[derive(Deserialize)]\n+//     #[serde(deny_unknown_fields)]\n+//     struct Range {\n+//         start: u64,\n+//         end: u32,\n+//     }\n+#[cfg(feature = \"std\")]\n+impl<Idx: Deserialize> Deserialize for std::ops::Range<Idx> {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+        where D: Deserializer\n+    {\n+        enum Field {\n+            Start,\n+            End,\n+        };\n+\n+        impl Deserialize for Field {\n+            fn deserialize<D>(deserializer: D) -> Result<Field, D::Error>\n+                where D: Deserializer\n+            {\n+                struct FieldVisitor;\n+\n+                impl Visitor for FieldVisitor {\n+                    type Value = Field;\n+\n+                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                        formatter.write_str(\"`start` or `end`\")\n+                    }\n+\n+                    fn visit_str<E>(self, value: &str) -> Result<Field, E>\n+                        where E: Error\n+                    {\n+                        match value {\n+                            \"start\" => Ok(Field::Start),\n+                            \"end\" => Ok(Field::End),\n+                            _ => Err(Error::unknown_field(value, FIELDS)),\n+                        }\n+                    }\n+\n+                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Field, E>\n+                        where E: Error\n+                    {\n+                        match value {\n+                            b\"start\" => Ok(Field::Start),\n+                            b\"end\" => Ok(Field::End),\n+                            _ => {\n+                                let value = String::from_utf8_lossy(value);\n+                                Err(Error::unknown_field(&value, FIELDS))\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                deserializer.deserialize_struct_field(FieldVisitor)\n+            }\n+        }\n+\n+        struct RangeVisitor<Idx> {\n+            phantom: PhantomData<Idx>,\n+        }\n+\n+        impl<Idx: Deserialize> Visitor for RangeVisitor<Idx> {\n+            type Value = std::ops::Range<Idx>;\n+\n+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                formatter.write_str(\"struct Range\")\n+            }\n+\n+            fn visit_seq<V>(self, mut visitor: V) -> Result<std::ops::Range<Idx>, V::Error>\n+                where V: SeqVisitor\n+            {\n+                let start: Idx = match try!(visitor.visit()) {\n+                    Some(value) => value,\n+                    None => {\n+                        return Err(Error::invalid_length(0, &self));\n+                    }\n+                };\n+                let end: Idx = match try!(visitor.visit()) {\n+                    Some(value) => value,\n+                    None => {\n+                        return Err(Error::invalid_length(1, &self));\n+                    }\n+                };\n+                Ok(start..end)\n+            }\n+\n+            fn visit_map<V>(self, mut visitor: V) -> Result<std::ops::Range<Idx>, V::Error>\n+                where V: MapVisitor\n+            {\n+                let mut start: Option<Idx> = None;\n+                let mut end: Option<Idx> = None;\n+                while let Some(key) = try!(visitor.visit_key::<Field>()) {\n+                    match key {\n+                        Field::Start => {\n+                            if start.is_some() {\n+                                return Err(<V::Error as Error>::duplicate_field(\"start\"));\n+                            }\n+                            start = Some(try!(visitor.visit_value()));\n+                        }\n+                        Field::End => {\n+                            if end.is_some() {\n+                                return Err(<V::Error as Error>::duplicate_field(\"end\"));\n+                            }\n+                            end = Some(try!(visitor.visit_value()));\n+                        }\n+                    }\n+                }\n+                let start = match start {\n+                    Some(start) => start,\n+                    None => return Err(<V::Error as Error>::missing_field(\"start\")),\n+                };\n+                let end = match end {\n+                    Some(end) => end,\n+                    None => return Err(<V::Error as Error>::missing_field(\"end\")),\n+                };\n+                Ok(start..end)\n+            }\n+        }\n+\n+        const FIELDS: &'static [&'static str] = &[\"start\", \"end\"];\n+        deserializer.deserialize_struct(\"Range\", FIELDS, RangeVisitor { phantom: PhantomData })\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+\n ///////////////////////////////////////////////////////////////////////////////\n \n #[cfg(feature = \"unstable\")]\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex 4c7a263fd..409ec4709 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -29,6 +29,8 @@ use std::rc::Rc;\n use alloc::rc::Rc;\n #[cfg(feature = \"std\")]\n use std::time::Duration;\n+#[cfg(feature = \"std\")]\n+use std;\n \n #[cfg(feature = \"std\")]\n use std::sync::Arc;\n@@ -262,6 +264,23 @@ impl<T> Serialize for VecDeque<T>\n     serialize_seq!();\n }\n \n+///////////////////////////////////////////////////////////////////////////////\n+\n+#[cfg(feature = \"std\")]\n+impl<Idx: Serialize> Serialize for std::ops::Range<Idx> {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+        where S: Serializer\n+    {\n+        use super::SerializeStruct;\n+        let mut state = try!(serializer.serialize_struct(\"Range\", 2));\n+        try!(state.serialize_field(\"start\", &self.start));\n+        try!(state.serialize_field(\"end\", &self.end));\n+        state.end()\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n #[cfg(feature = \"unstable\")]\n impl<A> Serialize for ops::Range<A>\n     where ops::Range<A>: ExactSizeIterator + iter::Iterator<Item = A> + Clone,\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex f77359e25..066eb2a31 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -868,6 +868,28 @@ declare_tests! {\n             Token::SeqEnd,\n         ],\n     }\n+    test_range {\n+        1u32..2u32 => &[\n+            Token::StructStart(\"Range\", 2),\n+                Token::StructSep,\n+                Token::Str(\"start\"),\n+                Token::U32(1),\n+\n+                Token::StructSep,\n+                Token::Str(\"end\"),\n+                Token::U32(2),\n+            Token::StructEnd,\n+        ],\n+        1u32..2u32 => &[\n+            Token::SeqStart(Some(2)),\n+                Token::SeqSep,\n+                Token::U64(1),\n+\n+                Token::SeqSep,\n+                Token::U64(2),\n+            Token::SeqEnd,\n+        ],\n+    }\n     test_net_ipv4addr {\n         \"1.2.3.4\".parse::<net::Ipv4Addr>().unwrap() => &[Token::Str(\"1.2.3.4\")],\n     }\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex 940f463df..d58fdfe71 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -366,6 +366,19 @@ declare_tests! {\n             Token::StructEnd,\n         ],\n     }\n+    test_range {\n+        1u32..2u32 => &[\n+            Token::StructStart(\"Range\", 2),\n+                Token::StructSep,\n+                Token::Str(\"start\"),\n+                Token::U32(1),\n+\n+                Token::StructSep,\n+                Token::Str(\"end\"),\n+                Token::U32(2),\n+            Token::StructEnd,\n+        ],\n+    }\n     test_net_ipv4addr {\n         \"1.2.3.4\".parse::<net::Ipv4Addr>().unwrap() => &[Token::Str(\"1.2.3.4\")],\n     }\n", "problem_statement": "Implent Serialize/Deserialize for `Range`\n...  when T is Serialize/Deserialize, of course.\n", "hints_text": "Any preference for what the representation would be? Something like `3..6` could be either\r\n\r\n```json\r\n[3, 4, 5]\r\n```\r\n\r\n... or\r\n\r\n```json\r\n{\r\n  \"start\": 3,\r\n  \"end\": 6\r\n}\r\n```\r\n\r\nAnother important thing to consider is whether people will ever need to deserialize a range without knowing ahead of time whether it is Range or RangeFrom or RangeTo or RangeFull.\r\n\r\nCan you provide a bit more detail about your use case for this?\n````\r\n{\r\n  \"start\": 3,\r\n  \"end\": 6\r\n}\r\n````\r\nThat's all a `Range` is.\r\n> Another important thing to consider is whether people will ever need to deserialize a range without knowing ahead of time whether it is Range or RangeFrom or RangeTo or RangeFull.\r\n\r\nNo idea, but that would only come up when you consider whether/how to implement `Serialize`/`Deserialize` for `RangeArgument`, which isn't even stable yet.\r\n> Can you provide a bit more detail about your use case for this?\r\n\r\nI have a struct containing a field that's of type `Range<MyLocalType>` and I want to auto-derive `Serialize` and `Deserialize` for it, but I can't. I can't implement `Serialize`/`Deserialize` for `Range<MyLocalType>` in my own crate because of the orphan rules.", "created_at": "2017-03-09T19:44:46Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 811, "instance_id": "serde-rs__serde-811", "issue_numbers": ["810"], "base_commit": "a4ee9bd0457bb61cf818cff1c3aaf061bc0ed0a1", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 5f5307fd8..85bf64c4e 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -27,6 +27,8 @@ use std::path;\n use core::str;\n #[cfg(feature = \"std\")]\n use std::ffi::CString;\n+#[cfg(all(feature = \"std\", feature=\"unstable\"))]\n+use std::ffi::CStr;\n \n #[cfg(feature = \"std\")]\n use std::rc::Rc;\n@@ -300,6 +302,16 @@ impl Deserialize for String {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+#[cfg(all(feature = \"std\", feature=\"unstable\"))]\n+impl Deserialize for Box<CStr> {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+        where D: Deserializer\n+    {\n+        let s = try!(CString::deserialize(deserializer));\n+        Ok(s.into_boxed_c_str())\n+    }\n+}\n+\n #[cfg(feature = \"std\")]\n impl Deserialize for CString {\n     fn deserialize<D>(deserializer: D) -> Result<CString, D::Error>\ndiff --git a/serde/src/lib.rs b/serde/src/lib.rs\nindex 9560ecb6e..5c7637938 100644\n--- a/serde/src/lib.rs\n+++ b/serde/src/lib.rs\n@@ -61,7 +61,7 @@\n \n #![doc(html_root_url=\"https://docs.serde.rs\")]\n #![cfg_attr(not(feature = \"std\"), no_std)]\n-#![cfg_attr(feature = \"unstable\", feature(inclusive_range, nonzero, specialization, zero_one))]\n+#![cfg_attr(feature = \"unstable\", feature(inclusive_range, nonzero, specialization, zero_one, into_boxed_c_str))]\n #![cfg_attr(feature = \"alloc\", feature(alloc))]\n #![cfg_attr(feature = \"collections\", feature(collections))]\n #![cfg_attr(feature = \"cargo-clippy\", allow(linkedlist, type_complexity, doc_markdown))]\ndiff --git a/travis.sh b/travis.sh\nindex 24de5d288..d2e1a998e 100755\n--- a/travis.sh\n+++ b/travis.sh\n@@ -30,7 +30,7 @@ if [ -n \"${CLIPPY}\" ]; then\n     cargo clippy --features unstable-testing -- -Dclippy\n \n     cd \"$DIR/test_suite\"\n-    cargo clippy --features unstable-testing -- -Dclippy\n+    cargo clippy --features unstable -- -Dclippy\n \n     cd \"$DIR/test_suite/no_std\"\n     cargo clippy -- -Dclippy\n@@ -46,7 +46,7 @@ else\n     cd \"$DIR/test_suite/deps\"\n     channel build\n     cd \"$DIR/test_suite\"\n-    channel test --features unstable-testing\n+    channel test --features unstable\n     cd \"$DIR/test_suite/no_std\"\n     channel build\n \n", "test_patch": "diff --git a/test_suite/Cargo.toml b/test_suite/Cargo.toml\nindex 1cd4ff75c..85fbf395d 100644\n--- a/test_suite/Cargo.toml\n+++ b/test_suite/Cargo.toml\n@@ -5,7 +5,7 @@ authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n publish = false\n \n [features]\n-unstable-testing = [\"compiletest_rs\"]\n+unstable = [\"serde/unstable\", \"compiletest_rs\"]\n \n [dev-dependencies]\n fnv = \"1.0\"\ndiff --git a/test_suite/tests/compiletest.rs b/test_suite/tests/compiletest.rs\nindex 4315a8583..a47730939 100644\n--- a/test_suite/tests/compiletest.rs\n+++ b/test_suite/tests/compiletest.rs\n@@ -1,4 +1,4 @@\n-#![cfg(feature = \"unstable-testing\")]\n+#![cfg(feature = \"unstable\")]\n \n extern crate compiletest_rs as compiletest;\n \ndiff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex fa5943c2e..f77359e25 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -1,3 +1,5 @@\n+#![cfg_attr(feature = \"unstable\", feature(into_boxed_c_str))]\n+\n #[macro_use]\n extern crate serde_derive;\n \n@@ -8,6 +10,9 @@ use std::time::Duration;\n use std::default::Default;\n use std::ffi::CString;\n \n+#[cfg(feature = \"unstable\")]\n+use std::ffi::CStr;\n+\n extern crate serde;\n use serde::Deserialize;\n \n@@ -886,15 +891,44 @@ declare_tests! {\n     }\n }\n \n+#[cfg(feature = \"unstable\")]\n+#[test]\n+fn test_cstr() {\n+    assert_de_tokens::<Box<CStr>>(&CString::new(\"abc\").unwrap().into_boxed_c_str(),\n+                                  &[Token::Bytes(b\"abc\")]);\n+}\n+\n #[cfg(feature = \"unstable\")]\n #[test]\n fn test_net_ipaddr() {\n     assert_de_tokens(\n-        \"1.2.3.4\".parse::<net::IpAddr>().unwrap(),\n+        &\"1.2.3.4\".parse::<net::IpAddr>().unwrap(),\n         &[Token::Str(\"1.2.3.4\")],\n     );\n }\n \n+#[cfg(feature = \"unstable\")]\n+#[test]\n+fn test_cstr_internal_null() {\n+    assert_de_tokens_error::<Box<CStr>>(\n+        &[\n+            Token::Bytes(b\"a\\0c\"),\n+        ],\n+        Error::Message(\"nul byte found in provided data at position: 1\".into())\n+    );\n+}\n+\n+#[cfg(feature = \"unstable\")]\n+#[test]\n+fn test_cstr_internal_null_end() {\n+    assert_de_tokens_error::<Box<CStr>>(\n+        &[\n+            Token::Bytes(b\"ac\\0\"),\n+        ],\n+        Error::Message(\"nul byte found in provided data at position: 2\".into())\n+    );\n+}\n+\n declare_error_tests! {\n     test_unknown_field<StructDenyUnknown> {\n         &[\ndiff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex ab449e4e3..8cdb254e1 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -2,7 +2,7 @@\n // successfully when there are a variety of generics and non-(de)serializable\n // types involved.\n \n-#![cfg_attr(feature = \"unstable-testing\", feature(non_ascii_idents))]\n+#![cfg_attr(feature = \"unstable\", feature(non_ascii_idents))]\n \n #[macro_use]\n extern crate serde_derive;\n@@ -220,8 +220,8 @@ fn test_gen() {\n     }\n     assert::<EmptyEnumVariant>();\n \n-    #[cfg(feature = \"unstable-testing\")]\n-    #[cfg_attr(feature = \"unstable-testing\", derive(Serialize, Deserialize))]\n+    #[cfg(feature = \"unstable\")]\n+    #[derive(Serialize, Deserialize)]\n     struct NonAsciiIdents {\n         \u03c3: f64\n     }\n@@ -246,12 +246,12 @@ fn test_gen() {\n         f: u8,\n     }\n \n-    #[cfg(feature = \"unstable-testing\")]\n-    #[cfg_attr(feature = \"unstable-testing\", derive(Serialize, Deserialize))]\n+    #[cfg(feature = \"unstable\")]\n+    #[derive(Serialize, Deserialize)]\n     struct EmptyTuple();\n \n-    #[cfg(feature = \"unstable-testing\")]\n-    #[cfg_attr(feature = \"unstable-testing\", derive(Serialize, Deserialize))]\n+    #[cfg(feature = \"unstable\")]\n+    #[derive(Serialize, Deserialize)]\n     #[serde(deny_unknown_fields)]\n     struct EmptyTupleDenyUnknown();\n \n@@ -276,8 +276,8 @@ fn test_gen() {\n         Variant,\n     }\n \n-    #[cfg(feature = \"unstable-testing\")]\n-    #[cfg_attr(feature = \"unstable-testing\", derive(Serialize, Deserialize))]\n+    #[cfg(feature = \"unstable\")]\n+    #[derive(Serialize, Deserialize)]\n     enum EmptyVariants {\n         Braced {},\n         Tuple(),\n@@ -288,8 +288,8 @@ fn test_gen() {\n         TupleSkip(#[serde(skip_deserializing)] u8),\n     }\n \n-    #[cfg(feature = \"unstable-testing\")]\n-    #[cfg_attr(feature = \"unstable-testing\", derive(Serialize, Deserialize))]\n+    #[cfg(feature = \"unstable\")]\n+    #[derive(Serialize, Deserialize)]\n     #[serde(deny_unknown_fields)]\n     enum EmptyVariantsDenyUnknown {\n         Braced {},\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex 72ed3f0cd..940f463df 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -21,9 +21,6 @@ use self::serde_test::{\n extern crate fnv;\n use self::fnv::FnvHasher;\n \n-#[cfg(feature = \"unstable\")]\n-use serde::ser::iterator;\n-\n #[macro_use]\n mod macros;\n \n@@ -402,54 +399,11 @@ declare_tests! {\n     }\n }\n \n-\n-#[cfg(feature = \"unstable\")]\n-#[test]\n-fn test_iterator() {\n-    assert_ser_tokens(iterator([0; 0].iter()), &[\n-        Token::SeqStart(Some(0)),\n-        Token::SeqEnd,\n-    ]);\n-    assert_ser_tokens(iterator([1, 2, 3].iter()), &[\n-        Token::SeqStart(Some(3)),\n-            Token::SeqSep,\n-            Token::I32(1),\n-\n-            Token::SeqSep,\n-            Token::I32(2),\n-\n-            Token::SeqSep,\n-            Token::I32(3),\n-        Token::SeqEnd,\n-    ]);\n-    assert_ser_tokens(iterator([1, 2, 3].iter().map(|x| x * 2)), &[\n-        Token::SeqStart(Some(3)),\n-            Token::SeqSep,\n-            Token::I32(2),\n-\n-            Token::SeqSep,\n-            Token::I32(4),\n-\n-            Token::SeqSep,\n-            Token::I32(6),\n-        Token::SeqEnd,\n-    ]);\n-    assert_ser_tokens(iterator([1, 2, 3].iter().filter(|&x| x % 2 != 0)), &[\n-        Token::SeqStart(None),\n-            Token::SeqSep,\n-            Token::I32(1),\n-\n-            Token::SeqSep,\n-            Token::I32(3),\n-        Token::SeqEnd,\n-    ]);\n-}\n-\n #[cfg(feature = \"unstable\")]\n #[test]\n fn test_net_ipaddr() {\n     assert_ser_tokens(\n-        \"1.2.3.4\".parse::<net::IpAddr>().unwrap(),\n+        &\"1.2.3.4\".parse::<net::IpAddr>().unwrap(),\n         &[Token::Str(\"1.2.3.4\")],\n     );\n }\n", "problem_statement": "Implement Deserialize for Box<CStr>\nThis is waiting on a stable [`CString::into_boxed_c_str`](https://doc.rust-lang.org/nightly/std/ffi/struct.CString.html#method.into_boxed_c_str): https://github.com/rust-lang/rust/issues/40380\n", "hints_text": "", "created_at": "2017-03-09T04:40:27Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 801, "instance_id": "serde-rs__serde-801", "issue_numbers": ["800"], "base_commit": "d70636f4d4d5e324df8b6286a9aef99655dcee1f", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex ba0acae2f..2946dcfee 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -25,6 +25,8 @@ use std::net;\n #[cfg(feature = \"std\")]\n use std::path;\n use core::str;\n+#[cfg(feature = \"std\")]\n+use std::ffi::CString;\n \n #[cfg(feature = \"std\")]\n use std::rc::Rc;\n@@ -53,6 +55,9 @@ use de::{Deserialize, Deserializer, EnumVisitor, Error, MapVisitor, SeqVisitor,\n          VariantVisitor, Visitor};\n use de::from_primitive::FromPrimitive;\n \n+#[cfg(feature = \"std\")]\n+use bytes::ByteBuf;\n+\n ///////////////////////////////////////////////////////////////////////////////\n \n /// A visitor that produces a `()`.\n@@ -295,6 +300,19 @@ impl Deserialize for String {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+#[cfg(feature = \"std\")]\n+impl Deserialize for CString {\n+    fn deserialize<D>(deserializer: D) -> Result<CString, D::Error>\n+        where D: Deserializer\n+    {\n+        let v: Vec<u8> = try!(ByteBuf::deserialize(deserializer)).into();\n+        CString::new(v)\n+            .map_err(|e| Error::custom(format!(\"unexpected NULL at byte {}\", e.nul_position())))\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n struct OptionVisitor<T> {\n     marker: PhantomData<T>,\n }\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex a7ac780f5..4c7a263fd 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -22,6 +22,8 @@ use core::ops;\n #[cfg(feature = \"std\")]\n use std::path;\n #[cfg(feature = \"std\")]\n+use std::ffi::{CString, CStr};\n+#[cfg(feature = \"std\")]\n use std::rc::Rc;\n #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n use alloc::rc::Rc;\n@@ -98,6 +100,28 @@ impl Serialize for String {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n+#[cfg(feature = \"std\")]\n+impl Serialize for CStr {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+        where S: Serializer\n+    {\n+        serializer.serialize_bytes(self.to_bytes())\n+    }\n+}\n+\n+#[cfg(feature = \"std\")]\n+impl Serialize for CString {\n+    #[inline]\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+        where S: Serializer\n+    {\n+        serializer.serialize_bytes(self.to_bytes())\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n impl<T> Serialize for Option<T>\n     where T: Serialize\n {\n", "test_patch": "diff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex f41124288..8e79f1f14 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -6,6 +6,7 @@ use std::net;\n use std::path::PathBuf;\n use std::time::Duration;\n use std::default::Default;\n+use std::ffi::CString;\n \n extern crate serde;\n use serde::Deserialize;\n@@ -878,6 +879,11 @@ declare_tests! {\n             Token::String(\"/usr/local/lib\".to_owned()),\n         ],\n     }\n+    test_cstring {\n+        CString::new(\"abc\").unwrap() => &[\n+            Token::Bytes(b\"abc\"),\n+        ],\n+    }\n }\n \n #[cfg(feature = \"unstable\")]\n@@ -995,4 +1001,16 @@ declare_error_tests! {\n         ],\n         Error::Message(\"invalid length 1, expected an array of length 3\".into()),\n     }\n+    test_cstring_internal_null<CString> {\n+        &[\n+            Token::Bytes(b\"a\\0c\"),\n+        ],\n+        Error::Message(\"unexpected NULL at byte 1\".into()),\n+    }\n+    test_cstring_internal_null_end<CString> {\n+        &[\n+            Token::Bytes(b\"ac\\0\"),\n+        ],\n+        Error::Message(\"unexpected NULL at byte 2\".into()),\n+    }\n }\ndiff --git a/test_suite/tests/test_ser.rs b/test_suite/tests/test_ser.rs\nindex e1f298ea9..72ed3f0cd 100644\n--- a/test_suite/tests/test_ser.rs\n+++ b/test_suite/tests/test_ser.rs\n@@ -6,6 +6,7 @@ use std::net;\n use std::path::{Path, PathBuf};\n use std::str;\n use std::time::Duration;\n+use std::ffi::CString;\n \n extern crate serde;\n \n@@ -389,6 +390,16 @@ declare_tests! {\n             Token::Str(\"/usr/local/lib\"),\n         ],\n     }\n+    test_cstring {\n+        CString::new(\"abc\").unwrap() => &[\n+            Token::Bytes(b\"abc\"),\n+        ],\n+    }\n+    test_cstr {\n+        (&*CString::new(\"abc\").unwrap()) => &[\n+            Token::Bytes(b\"abc\"),\n+        ],\n+    }\n }\n \n \n", "problem_statement": "Implement Serialize/Deserialize for CStr\n`serde` currently ships with an `impl` of `Serialize` and `Deserialize` for [`str`](https://github.com/serde-rs/serde/blob/master/serde/src/ser/impls.rs#L80) and [`String`](https://github.com/serde-rs/serde/blob/master/serde/src/ser/impls.rs#L90), but not for the null-terminated C-like string types [`ffi::CStr`](https://doc.rust-lang.org/std/ffi/struct.CStr.html) and [`ffi::CString`](https://doc.rust-lang.org/std/ffi/struct.CString.html). Under the hood, these string implementations are very similar, and providing serialization implementations for the latter two shouldn't be too hard. Are there any particular reasons why `impl`s for these types are not provided?\n", "hints_text": "No reason. Would you be able to send a PR adding these two impls?\n@dtolnay I'll give it a shot. Should this be placed under its own flag, given that it's in `ffi`?\nNo, both types are in std so they should be behind the `std` feature.\r\n\r\nOne open question is how you intend to handle non-UTF8 strings.\nI was thinking of serializing through `[u8]` rather than as strings, which should work fine, right?\nSure, that works.", "created_at": "2017-03-03T21:11:53Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 782, "instance_id": "serde-rs__serde-782", "issue_numbers": ["758"], "base_commit": "599a1b6607972e9eeeb0f513fc0f50605e2c68e9", "patch": "diff --git a/serde/src/de/content.rs b/serde/src/de/content.rs\nindex 1ae2e8696..5ba2a1697 100644\n--- a/serde/src/de/content.rs\n+++ b/serde/src/de/content.rs\n@@ -21,7 +21,7 @@ use collections::{String, Vec};\n use alloc::boxed::Box;\n \n use de::{self, Deserialize, DeserializeSeed, Deserializer, Visitor, SeqVisitor, MapVisitor,\n-         EnumVisitor};\n+         EnumVisitor, Unexpected};\n \n /// Used from generated code to buffer the contents of the Deserializer when\n /// deserializing untagged enums and internally tagged enums.\n@@ -493,6 +493,50 @@ impl<T> Visitor for TaggedContentVisitor<T>\n     }\n }\n \n+/// Used by generated code to deserialize an adjacently tagged enum.\n+///\n+/// Not public API.\n+pub enum TagOrContentField {\n+    Tag,\n+    Content,\n+}\n+\n+/// Not public API.\n+pub struct TagOrContentFieldVisitor {\n+    pub tag: &'static str,\n+    pub content: &'static str,\n+}\n+\n+impl DeserializeSeed for TagOrContentFieldVisitor {\n+    type Value = TagOrContentField;\n+\n+    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n+        where D: Deserializer\n+    {\n+        deserializer.deserialize_str(self)\n+    }\n+}\n+\n+impl Visitor for TagOrContentFieldVisitor {\n+    type Value = TagOrContentField;\n+\n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        write!(formatter, \"{:?} or {:?}\", self.tag, self.content)\n+    }\n+\n+    fn visit_str<E>(self, field: &str) -> Result<Self::Value, E>\n+        where E: de::Error\n+    {\n+        if field == self.tag {\n+            Ok(TagOrContentField::Tag)\n+        } else if field == self.content {\n+            Ok(TagOrContentField::Content)\n+        } else {\n+            Err(de::Error::invalid_value(Unexpected::Str(field), &self))\n+        }\n+    }\n+}\n+\n /// Not public API\n pub struct ContentDeserializer<E> {\n     content: Content,\ndiff --git a/serde/src/de/private.rs b/serde/src/de/private.rs\nindex 8ef622316..092d66a60 100644\n--- a/serde/src/de/private.rs\n+++ b/serde/src/de/private.rs\n@@ -4,7 +4,8 @@ use de::{Deserialize, Deserializer, Error, Visitor};\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n pub use de::content::{Content, ContentRefDeserializer, ContentDeserializer, TaggedContentVisitor,\n-                      InternallyTaggedUnitVisitor, UntaggedUnitVisitor};\n+                      TagOrContentField, TagOrContentFieldVisitor, InternallyTaggedUnitVisitor,\n+                      UntaggedUnitVisitor};\n \n /// If the missing field is of type `Option<T>` then treat is as `None`,\n /// otherwise it is an error.\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex b73d16696..b47f334bd 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -185,7 +185,7 @@ fn deserialize_tuple(ident: &syn::Ident,\n         __Visitor { marker: _serde::export::PhantomData::<#ident #ty_generics> }\n     };\n     let dispatch = if let Some(deserializer) = deserializer {\n-        quote!(_serde::Deserializer::deserialize(#deserializer, #visitor_expr))\n+        quote!(_serde::Deserializer::deserialize_tuple(#deserializer, #nfields, #visitor_expr))\n     } else if is_enum {\n         quote!(_serde::de::VariantVisitor::visit_tuple(visitor, #nfields, #visitor_expr))\n     } else if nfields == 1 {\n@@ -442,7 +442,14 @@ fn deserialize_item_enum(ident: &syn::Ident,\n                                                item_attrs,\n                                                tag)\n         }\n-        attr::EnumTag::Adjacent { .. } => unimplemented!(),\n+        attr::EnumTag::Adjacent { ref tag, ref content } => {\n+            deserialize_adjacently_tagged_enum(ident,\n+                                               generics,\n+                                               variants,\n+                                               item_attrs,\n+                                               tag,\n+                                               content)\n+        }\n         attr::EnumTag::None => {\n             deserialize_untagged_enum(ident, generics, variants, item_attrs)\n         }\n@@ -597,6 +604,230 @@ fn deserialize_internally_tagged_enum(ident: &syn::Ident,\n     }\n }\n \n+fn deserialize_adjacently_tagged_enum(ident: &syn::Ident,\n+                                      generics: &syn::Generics,\n+                                      variants: &[Variant],\n+                                      item_attrs: &attr::Item,\n+                                      tag: &str,\n+                                      content: &str)\n+                                      -> Fragment {\n+    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n+\n+    let variant_names_idents: Vec<_> = variants.iter()\n+        .enumerate()\n+        .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n+        .map(|(i, variant)| (variant.attrs.name().deserialize_name(), field_i(i)))\n+        .collect();\n+\n+    let variants_stmt = {\n+        let variant_names = variant_names_idents.iter().map(|&(ref name, _)| name);\n+        quote! {\n+            const VARIANTS: &'static [&'static str] = &[ #(#variant_names),* ];\n+        }\n+    };\n+\n+    let variant_visitor = Stmts(deserialize_field_visitor(variant_names_idents, item_attrs, true));\n+\n+    let ref variant_arms: Vec<_> = variants.iter()\n+        .enumerate()\n+        .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n+        .map(|(i, variant)| {\n+            let variant_index = field_i(i);\n+\n+            let block = Match(deserialize_untagged_variant(\n+                ident,\n+                generics,\n+                variant,\n+                item_attrs,\n+                quote!(_deserializer),\n+            ));\n+\n+            quote! {\n+                __Field::#variant_index => #block\n+            }\n+        })\n+        .collect();\n+\n+    let expecting = format!(\"adjacently tagged enum {}\", ident);\n+    let type_name = item_attrs.name().deserialize_name();\n+\n+    let tag_or_content = quote! {\n+        _serde::de::private::TagOrContentFieldVisitor {\n+            tag: #tag,\n+            content: #content,\n+        }\n+    };\n+\n+    fn is_unit(variant: &Variant) -> bool {\n+        match variant.style {\n+            Style::Unit => true,\n+            Style::Struct | Style::Tuple | Style::Newtype => false,\n+        }\n+    }\n+\n+    let mut missing_content = quote! {\n+        _serde::export::Err(<__V::Error as _serde::de::Error>::missing_field(#content))\n+    };\n+    if variants.iter().any(is_unit) {\n+        let fallthrough = if variants.iter().all(is_unit) {\n+            None\n+        } else {\n+            Some(quote! {\n+                _ => #missing_content\n+            })\n+        };\n+        let arms = variants.iter()\n+            .enumerate()\n+            .filter(|&(_, variant)| !variant.attrs.skip_deserializing() && is_unit(variant))\n+            .map(|(i, variant)| {\n+                let variant_index = field_i(i);\n+                let variant_ident = &variant.ident;\n+                quote! {\n+                    __Field::#variant_index => _serde::export::Ok(#ident::#variant_ident),\n+                }\n+            });\n+        missing_content = quote! {\n+            match __field {\n+                #(#arms)*\n+                #fallthrough\n+            }\n+        };\n+    }\n+\n+    let visit_third_key = quote! {\n+        // Visit the third key in the map, hopefully there isn't one.\n+        match try!(_serde::de::MapVisitor::visit_key_seed(&mut visitor, #tag_or_content)) {\n+            _serde::export::Some(_serde::de::private::TagOrContentField::Tag) => {\n+                _serde::export::Err(<__V::Error as _serde::de::Error>::duplicate_field(#tag))\n+            }\n+            _serde::export::Some(_serde::de::private::TagOrContentField::Content) => {\n+                _serde::export::Err(<__V::Error as _serde::de::Error>::duplicate_field(#content))\n+            }\n+            _serde::export::None => _serde::export::Ok(__ret),\n+        }\n+    };\n+\n+    quote_block! {\n+        #variant_visitor\n+\n+        #variants_stmt\n+\n+        struct __Seed #impl_generics #where_clause {\n+            field: __Field,\n+            marker: _serde::export::PhantomData<#ident #ty_generics>,\n+        }\n+\n+        impl #impl_generics _serde::de::DeserializeSeed for __Seed #ty_generics #where_clause {\n+            type Value = #ident #ty_generics;\n+\n+            fn deserialize<__D>(self, _deserializer: __D) -> _serde::export::Result<Self::Value, __D::Error>\n+                where __D: _serde::Deserializer\n+            {\n+                match self.field {\n+                    #(#variant_arms)*\n+                }\n+            }\n+        }\n+\n+        struct __Visitor #impl_generics #where_clause {\n+            marker: _serde::export::PhantomData<#ident #ty_generics>,\n+        }\n+\n+        impl #impl_generics _serde::de::Visitor for __Visitor #ty_generics #where_clause {\n+            type Value = #ident #ty_generics;\n+\n+            fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n+                _serde::export::fmt::Formatter::write_str(formatter, #expecting)\n+            }\n+\n+            fn visit_map<__V>(self, mut visitor: __V) -> _serde::export::Result<Self::Value, __V::Error>\n+                where __V: _serde::de::MapVisitor\n+            {\n+                // Visit the first key.\n+                match try!(_serde::de::MapVisitor::visit_key_seed(&mut visitor, #tag_or_content)) {\n+                    // First key is the tag.\n+                    _serde::export::Some(_serde::de::private::TagOrContentField::Tag) => {\n+                        // Parse the tag.\n+                        let __field = try!(_serde::de::MapVisitor::visit_value(&mut visitor));\n+                        // Visit the second key.\n+                        match try!(_serde::de::MapVisitor::visit_key_seed(&mut visitor, #tag_or_content)) {\n+                            // Second key is a duplicate of the tag.\n+                            _serde::export::Some(_serde::de::private::TagOrContentField::Tag) => {\n+                                _serde::export::Err(<__V::Error as _serde::de::Error>::duplicate_field(#tag))\n+                            }\n+                            // Second key is the content.\n+                            _serde::export::Some(_serde::de::private::TagOrContentField::Content) => {\n+                                let __ret = try!(_serde::de::MapVisitor::visit_value_seed(&mut visitor, __Seed { field: __field, marker: _serde::export::PhantomData }));\n+                                // Visit the third key, hopefully there isn't one.\n+                                #visit_third_key\n+                            }\n+                            // There is no second key; might be okay if the we have a unit variant.\n+                            _serde::export::None => #missing_content\n+                        }\n+                    }\n+                    // First key is the content.\n+                    _serde::export::Some(_serde::de::private::TagOrContentField::Content) => {\n+                        // Buffer up the content.\n+                        let __content = try!(_serde::de::MapVisitor::visit_value::<_serde::de::private::Content>(&mut visitor));\n+                        // Visit the second key.\n+                        match try!(_serde::de::MapVisitor::visit_key_seed(&mut visitor, #tag_or_content)) {\n+                            // Second key is the tag.\n+                            _serde::export::Some(_serde::de::private::TagOrContentField::Tag) => {\n+                                let _deserializer = _serde::de::private::ContentDeserializer::<__V::Error>::new(__content);\n+                                // Parse the tag.\n+                                let __ret = try!(match try!(_serde::de::MapVisitor::visit_value(&mut visitor)) {\n+                                    // Deserialize the buffered content now that we know the variant.\n+                                    #(#variant_arms)*\n+                                });\n+                                // Visit the third key, hopefully there isn't one.\n+                                #visit_third_key\n+                            }\n+                            // Second key is a duplicate of the content.\n+                            _serde::export::Some(_serde::de::private::TagOrContentField::Content) => {\n+                                _serde::export::Err(<__V::Error as _serde::de::Error>::duplicate_field(#content))\n+                            }\n+                            // There is no second key.\n+                            _serde::export::None => {\n+                                _serde::export::Err(<__V::Error as _serde::de::Error>::missing_field(#tag))\n+                            }\n+                        }\n+                    }\n+                    // There is no first key.\n+                    _serde::export::None => {\n+                        _serde::export::Err(<__V::Error as _serde::de::Error>::missing_field(#tag))\n+                    }\n+                }\n+            }\n+\n+            fn visit_seq<__V>(self, mut visitor: __V) -> _serde::export::Result<Self::Value, __V::Error>\n+                where __V: _serde::de::SeqVisitor\n+            {\n+                // Visit the first element - the tag.\n+                match try!(_serde::de::SeqVisitor::visit(&mut visitor)) {\n+                    _serde::export::Some(__field) => {\n+                        // Visit the second element - the content.\n+                        match try!(_serde::de::SeqVisitor::visit_seed(&mut visitor, __Seed { field: __field, marker: _serde::export::PhantomData })) {\n+                            _serde::export::Some(__ret) => _serde::export::Ok(__ret),\n+                            // There is no second element.\n+                            _serde::export::None => {\n+                                _serde::export::Err(_serde::de::Error::invalid_length(1, &self))\n+                            }\n+                        }\n+                    }\n+                    // There is no first element.\n+                    _serde::export::None => {\n+                        _serde::export::Err(_serde::de::Error::invalid_length(0, &self))\n+                    }\n+                }\n+            }\n+        }\n+\n+        const FIELDS: &'static [&'static str] = &[#tag, #content];\n+        _serde::Deserializer::deserialize_struct(deserializer, #type_name, FIELDS,\n+            __Visitor { marker: _serde::export::PhantomData::<#ident #ty_generics> })\n+    }\n+}\n+\n fn deserialize_untagged_enum(ident: &syn::Ident,\n                              generics: &syn::Generics,\n                              variants: &[Variant],\n", "test_patch": "diff --git a/test_suite/tests/test_macros.rs b/test_suite/tests/test_macros.rs\nindex 4b84daeb3..f4ef675d5 100644\n--- a/test_suite/tests/test_macros.rs\n+++ b/test_suite/tests/test_macros.rs\n@@ -884,17 +884,18 @@ fn test_internally_tagged_enum() {\n \n #[test]\n fn test_adjacently_tagged_enum() {\n-    #[derive(Debug, PartialEq, Serialize)]\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n     #[serde(tag = \"t\", content = \"c\")]\n-    enum AdjacentlyTagged {\n+    enum AdjacentlyTagged<T> {\n         Unit,\n-        Newtype(u8),\n+        Newtype(T),\n         Tuple(u8, u8),\n         Struct { f: u8 },\n     }\n \n-    assert_ser_tokens(\n-        &AdjacentlyTagged::Unit,\n+    // unit with no content\n+    assert_tokens(\n+        &AdjacentlyTagged::Unit::<u8>,\n         &[\n             Token::StructStart(\"AdjacentlyTagged\", 1),\n \n@@ -906,8 +907,45 @@ fn test_adjacently_tagged_enum() {\n         ]\n     );\n \n-    assert_ser_tokens(\n-        &AdjacentlyTagged::Newtype(1),\n+    // unit with tag first\n+    assert_de_tokens(\n+        &AdjacentlyTagged::Unit::<u8>,\n+        &[\n+            Token::StructStart(\"AdjacentlyTagged\", 1),\n+\n+            Token::StructSep,\n+            Token::Str(\"t\"),\n+            Token::Str(\"Unit\"),\n+\n+            Token::StructSep,\n+            Token::Str(\"c\"),\n+            Token::Unit,\n+\n+            Token::StructEnd,\n+        ]\n+    );\n+\n+    // unit with content first\n+    assert_de_tokens(\n+        &AdjacentlyTagged::Unit::<u8>,\n+        &[\n+            Token::StructStart(\"AdjacentlyTagged\", 1),\n+\n+            Token::StructSep,\n+            Token::Str(\"c\"),\n+            Token::Unit,\n+\n+            Token::StructSep,\n+            Token::Str(\"t\"),\n+            Token::Str(\"Unit\"),\n+\n+            Token::StructEnd,\n+        ]\n+    );\n+\n+    // newtype with tag first\n+    assert_tokens(\n+        &AdjacentlyTagged::Newtype::<u8>(1),\n         &[\n             Token::StructStart(\"AdjacentlyTagged\", 2),\n \n@@ -923,8 +961,27 @@ fn test_adjacently_tagged_enum() {\n         ]\n     );\n \n-    assert_ser_tokens(\n-        &AdjacentlyTagged::Tuple(1, 1),\n+    // newtype with content first\n+    assert_de_tokens(\n+        &AdjacentlyTagged::Newtype::<u8>(1),\n+        &[\n+            Token::StructStart(\"AdjacentlyTagged\", 2),\n+\n+            Token::StructSep,\n+            Token::Str(\"c\"),\n+            Token::U8(1),\n+\n+            Token::StructSep,\n+            Token::Str(\"t\"),\n+            Token::Str(\"Newtype\"),\n+\n+            Token::StructEnd,\n+        ]\n+    );\n+\n+    // tuple with tag first\n+    assert_tokens(\n+        &AdjacentlyTagged::Tuple::<u8>(1, 1),\n         &[\n             Token::StructStart(\"AdjacentlyTagged\", 2),\n \n@@ -945,8 +1002,32 @@ fn test_adjacently_tagged_enum() {\n         ]\n     );\n \n-    assert_ser_tokens(\n-        &AdjacentlyTagged::Struct { f: 1 },\n+    // tuple with content first\n+    assert_de_tokens(\n+        &AdjacentlyTagged::Tuple::<u8>(1, 1),\n+        &[\n+            Token::StructStart(\"AdjacentlyTagged\", 2),\n+\n+            Token::StructSep,\n+            Token::Str(\"c\"),\n+            Token::TupleStart(2),\n+            Token::TupleSep,\n+            Token::U8(1),\n+            Token::TupleSep,\n+            Token::U8(1),\n+            Token::TupleEnd,\n+\n+            Token::StructSep,\n+            Token::Str(\"t\"),\n+            Token::Str(\"Tuple\"),\n+\n+            Token::StructEnd,\n+        ]\n+    );\n+\n+    // struct with tag first\n+    assert_tokens(\n+        &AdjacentlyTagged::Struct::<u8> { f: 1 },\n         &[\n             Token::StructStart(\"AdjacentlyTagged\", 2),\n \n@@ -965,4 +1046,26 @@ fn test_adjacently_tagged_enum() {\n             Token::StructEnd,\n         ]\n     );\n+\n+    // struct with content first\n+    assert_de_tokens(\n+        &AdjacentlyTagged::Struct::<u8> { f: 1 },\n+        &[\n+            Token::StructStart(\"AdjacentlyTagged\", 2),\n+\n+            Token::StructSep,\n+            Token::Str(\"c\"),\n+            Token::StructStart(\"Struct\", 1),\n+            Token::StructSep,\n+            Token::Str(\"f\"),\n+            Token::U8(1),\n+            Token::StructEnd,\n+\n+            Token::StructSep,\n+            Token::Str(\"t\"),\n+            Token::Str(\"Struct\"),\n+\n+            Token::StructEnd,\n+        ]\n+    );\n }\n", "problem_statement": "haskell serialized formats could be better supported\nhaskell serializes enums to json by encoding a `t` field for the variant name and a `c` field for the content. We can represent this with\r\n\r\n```rust\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(tag = \"t\")]\r\nenum MyType {\r\n    Variant { c: ActualContent },\r\n    Variant2 { c: (A, B, C) },\r\n}\r\n```\r\n\r\nThis works fine, but is a little verbose. Not sure if this use case is too niche.\n", "hints_text": "This representation also came up in https://github.com/serde-rs/serde/issues/415#issue-162867209 so I don't think it is too niche. How about something like this?\r\n\r\n```rust\r\n#[derive(Serialize, Deserialize)]\r\n#[serde(tag = \"t\", content = \"c\")]\r\nenum MyType {\r\n    Variant(ActualContent),\r\n    Variant2(A, B, C),\r\n}\r\n```\nSounds simple enough. We need to be aware of edge cases though. like what happens with empty variants (don't serialize the content field, deserialize without content field and with \"unit\" content field).\nI took a first pass on this in #771, but got stuck at the part where I need to serialize the internal contents of the `\"c\": ...` portion. If you have any advice, I'd appreciate suggestions in the other thread.", "created_at": "2017-02-21T04:03:37Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 765, "instance_id": "serde-rs__serde-765", "issue_numbers": ["763"], "base_commit": "090c8a7049cff6cd98139a8fcfc28b65ef73ec2d", "patch": "diff --git a/serde_codegen_internals/src/attr.rs b/serde_codegen_internals/src/attr.rs\nindex 224bb9398..2ed7bf423 100644\n--- a/serde_codegen_internals/src/attr.rs\n+++ b/serde_codegen_internals/src/attr.rs\n@@ -453,6 +453,18 @@ impl Field {\n                         }\n                     }\n \n+                    // Parse `#[serde(with=\"...\")]`\n+                    MetaItem(NameValue(ref name, ref lit)) if name == \"with\" => {\n+                        if let Ok(path) = parse_lit_into_path(cx, name.as_ref(), lit) {\n+                            let mut ser_path = path.clone();\n+                            ser_path.segments.push(\"serialize\".into());\n+                            serialize_with.set(ser_path);\n+                            let mut de_path = path;\n+                            de_path.segments.push(\"deserialize\".into());\n+                            deserialize_with.set(de_path);\n+                        }\n+                    }\n+\n                     // Parse `#[serde(bound=\"D: Serialize\")]`\n                     MetaItem(NameValue(ref name, ref lit)) if name == \"bound\" => {\n                         if let Ok(where_predicates) =\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 2f53a00e4..d008c0f20 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -30,6 +30,14 @@ fn test_gen() {\n     }\n     assert::<With<i32>>();\n \n+    #[derive(Serialize, Deserialize)]\n+    struct WithTogether<T> {\n+        t: T,\n+        #[serde(with=\"both_x\")]\n+        x: X,\n+    }\n+    assert::<WithTogether<i32>>();\n+\n     #[derive(Serialize, Deserialize)]\n     struct WithRef<'a, T: 'a> {\n         #[serde(skip_deserializing)]\n@@ -307,16 +315,20 @@ trait DeserializeWith: Sized {\n }\n \n // Implements neither Serialize nor Deserialize\n-struct X;\n+pub struct X;\n \n-fn ser_x<S: Serializer>(_: &X, _: S) -> StdResult<S::Ok, S::Error> {\n+pub fn ser_x<S: Serializer>(_: &X, _: S) -> StdResult<S::Ok, S::Error> {\n     unimplemented!()\n }\n \n-fn de_x<D: Deserializer>(_: D) -> StdResult<X, D::Error> {\n+pub fn de_x<D: Deserializer>(_: D) -> StdResult<X, D::Error> {\n     unimplemented!()\n }\n \n+mod both_x {\n+    pub use super::{ser_x as serialize, de_x as deserialize};\n+}\n+\n impl SerializeWith for X {\n     fn serialize_with<S: Serializer>(_: &Self, _: S) -> StdResult<S::Ok, S::Error> {\n         unimplemented!()\n", "problem_statement": "Way to pair serialize_with and deserialize_with into one attribute\n```rust\r\n#[serde(serialize_with = \"url_serde::serialize\",\r\n        deserialize_with = \"url_serde::deserialize\")]\r\n```\r\n\r\nThis gets tedious because you almost always want these paired. Can we deduplicate into one attribute?\r\n\r\n```rust\r\n#[serde(with = \"url_serde\")]\r\n```\n", "hints_text": "So the `use = \"type\"` would require `type` to implement both `Serialize` and `Deserialize` (barring further attributes like `deserialize_default`)?\nI haven't thought about how it would work yet.\r\n\r\nI think the way you are suggesting is you give the attribute a path to a wrapper type:\r\n\r\n```rust\r\nstruct Url(url::Url);\r\nimpl Serialize for Url { ... }\r\nimpl Deserialize for Url { ... }\r\n```\r\n\r\nA different approach that would be more similar to serialize_with and deserialize_with would be to give the attribute a path to a module containing ser and de functions:\r\n\r\n```rust\r\nmod url {\r\n    fn serialize<S>(...) { ... }\r\n    fn deserialize<D>(...) { ... }\r\n}\r\n```\r\n\r\nRight now I am leaning toward the module approach because it means that simple wrapper libraries like url_serde can be used just with `#[serde(use = \"url_serde\")]`.\nOh, your idea is much more general, since it also supports the case where the \"wrapper type\" is not a wrapper type at all, but e.g. some random type from another crate.\n@nox my `mod` proposal would work with hyper_serde out of the box without any code change on your end.\r\n\r\n```diff\r\n #[derive(Serialize, Deserialize)]\r\n struct MyStruct {\r\n-    #[serde(deserialize_with = \"hyper_serde::deserialize\",\r\n-            serialize_with = \"hyper_serde::serialize\")]\r\n+    #[serde(with = \"hyper_serde\")]\r\n     headers: Headers,\r\n }\r\n```\r\n\r\nAny concerns or suggestions?", "created_at": "2017-02-15T01:37:15Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 762, "instance_id": "serde-rs__serde-762", "issue_numbers": ["438"], "base_commit": "964a2dd4d195b8c14c76df5f7ddb8f321c0d211c", "patch": "diff --git a/serde/src/bytes.rs b/serde/src/bytes.rs\nindex 8f9148390..52cc1caff 100644\n--- a/serde/src/bytes.rs\n+++ b/serde/src/bytes.rs\n@@ -60,9 +60,7 @@ pub struct Bytes<'a> {\n impl<'a> Bytes<'a> {\n     /// Wrap an existing `&[u8]`.\n     pub fn new(bytes: &'a [u8]) -> Self {\n-        Bytes {\n-            bytes: bytes,\n-        }\n+        Bytes { bytes: bytes }\n     }\n }\n \n@@ -98,7 +96,9 @@ impl<'a> Into<&'a [u8]> for Bytes<'a> {\n impl<'a> ops::Deref for Bytes<'a> {\n     type Target = [u8];\n \n-    fn deref(&self) -> &[u8] { self.bytes }\n+    fn deref(&self) -> &[u8] {\n+        self.bytes\n+    }\n }\n \n impl<'a> ser::Serialize for Bytes<'a> {\n@@ -161,9 +161,7 @@ mod bytebuf {\n \n         /// Wrap existing bytes in a `ByteBuf`.\n         pub fn from<T: Into<Vec<u8>>>(bytes: T) -> Self {\n-            ByteBuf {\n-                bytes: bytes.into(),\n-            }\n+            ByteBuf { bytes: bytes.into() }\n         }\n     }\n \n@@ -216,11 +214,15 @@ mod bytebuf {\n     impl ops::Deref for ByteBuf {\n         type Target = [u8];\n \n-        fn deref(&self) -> &[u8] { &self.bytes[..] }\n+        fn deref(&self) -> &[u8] {\n+            &self.bytes[..]\n+        }\n     }\n \n     impl ops::DerefMut for ByteBuf {\n-        fn deref_mut(&mut self) -> &mut [u8] { &mut self.bytes[..] }\n+        fn deref_mut(&mut self) -> &mut [u8] {\n+            &mut self.bytes[..]\n+        }\n     }\n \n     impl ser::Serialize for ByteBuf {\n@@ -243,14 +245,14 @@ mod bytebuf {\n \n         #[inline]\n         fn visit_unit<E>(self) -> Result<ByteBuf, E>\n-            where E: de::Error,\n+            where E: de::Error\n         {\n             Ok(ByteBuf::new())\n         }\n \n         #[inline]\n         fn visit_seq<V>(self, mut visitor: V) -> Result<ByteBuf, V::Error>\n-            where V: de::SeqVisitor,\n+            where V: de::SeqVisitor\n         {\n             let (len, _) = visitor.size_hint();\n             let mut values = Vec::with_capacity(len);\n@@ -264,26 +266,26 @@ mod bytebuf {\n \n         #[inline]\n         fn visit_bytes<E>(self, v: &[u8]) -> Result<ByteBuf, E>\n-            where E: de::Error,\n+            where E: de::Error\n         {\n             Ok(ByteBuf::from(v))\n         }\n \n         #[inline]\n         fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<ByteBuf, E>\n-            where E: de::Error,\n+            where E: de::Error\n         {\n             Ok(ByteBuf::from(v))\n         }\n \n         fn visit_str<E>(self, v: &str) -> Result<ByteBuf, E>\n-            where E: de::Error,\n+            where E: de::Error\n         {\n             Ok(ByteBuf::from(v))\n         }\n \n         fn visit_string<E>(self, v: String) -> Result<ByteBuf, E>\n-            where E: de::Error,\n+            where E: de::Error\n         {\n             Ok(ByteBuf::from(v))\n         }\n@@ -302,7 +304,9 @@ mod bytebuf {\n ///////////////////////////////////////////////////////////////////////////////\n \n #[inline]\n-fn escape_bytestring<'a>(bytes: &'a [u8]) -> iter::FlatMap<slice::Iter<'a, u8>, char::EscapeDefault, fn(&u8) -> char::EscapeDefault> {\n+fn escape_bytestring<'a>\n+    (bytes: &'a [u8])\n+     -> iter::FlatMap<slice::Iter<'a, u8>, char::EscapeDefault, fn(&u8) -> char::EscapeDefault> {\n     fn f(b: &u8) -> char::EscapeDefault {\n         char::from_u32(*b as u32).unwrap().escape_default()\n     }\ndiff --git a/serde/src/de/content.rs b/serde/src/de/content.rs\nindex 59c3f8ae5..d3bd0b643 100644\n--- a/serde/src/de/content.rs\n+++ b/serde/src/de/content.rs\n@@ -19,16 +19,8 @@ use collections::{String, Vec};\n #[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n use alloc::boxed::Box;\n \n-use de::{\n-    self,\n-    Deserialize,\n-    DeserializeSeed,\n-    Deserializer,\n-    Visitor,\n-    SeqVisitor,\n-    MapVisitor,\n-    EnumVisitor,\n-};\n+use de::{self, Deserialize, DeserializeSeed, Deserializer, Visitor, SeqVisitor, MapVisitor,\n+         EnumVisitor};\n \n /// Used from generated code to buffer the contents of the Deserializer when\n /// deserializing untagged enums and internally tagged enums.\n@@ -243,9 +235,7 @@ struct TagOrContentVisitor {\n \n impl TagOrContentVisitor {\n     fn new(name: &'static str) -> Self {\n-        TagOrContentVisitor {\n-            name: name,\n-        }\n+        TagOrContentVisitor { name: name }\n     }\n }\n \n@@ -491,9 +481,7 @@ impl<T> Visitor for TaggedContentVisitor<T>\n             }\n         }\n         match tag {\n-            None => {\n-                Err(de::Error::missing_field(self.tag_name))\n-            }\n+            None => Err(de::Error::missing_field(self.tag_name)),\n             Some(tag) => {\n                 Ok(TaggedContent {\n                     tag: tag,\n@@ -544,14 +532,15 @@ impl<E> Deserializer for ContentDeserializer<E>\n                 let value = try!(visitor.visit_seq(&mut seq_visitor));\n                 try!(seq_visitor.end());\n                 Ok(value)\n-            },\n+            }\n             Content::Map(v) => {\n-                let map = v.into_iter().map(|(k, v)| (ContentDeserializer::new(k), ContentDeserializer::new(v)));\n+                let map = v.into_iter()\n+                    .map(|(k, v)| (ContentDeserializer::new(k), ContentDeserializer::new(v)));\n                 let mut map_visitor = de::value::MapDeserializer::new(map);\n                 let value = try!(visitor.visit_map(&mut map_visitor));\n                 try!(map_visitor.end());\n                 Ok(value)\n-            },\n+            }\n             Content::Bytes(v) => visitor.visit_byte_buf(v),\n         }\n     }\n@@ -563,7 +552,7 @@ impl<E> Deserializer for ContentDeserializer<E>\n             Content::None => visitor.visit_none(),\n             Content::Some(v) => visitor.visit_some(ContentDeserializer::new(*v)),\n             Content::Unit => visitor.visit_unit(),\n-            _ => visitor.visit_some(self)\n+            _ => visitor.visit_some(self),\n         }\n     }\n \n@@ -630,14 +619,16 @@ impl<'a, E> Deserializer for ContentRefDeserializer<'a, E>\n                 let value = try!(visitor.visit_seq(&mut seq_visitor));\n                 try!(seq_visitor.end());\n                 Ok(value)\n-            },\n+            }\n             Content::Map(ref v) => {\n-                let map = v.into_iter().map(|&(ref k, ref v)| (ContentRefDeserializer::new(k), ContentRefDeserializer::new(v)));\n+                let map = v.into_iter().map(|&(ref k, ref v)| {\n+                    (ContentRefDeserializer::new(k), ContentRefDeserializer::new(v))\n+                });\n                 let mut map_visitor = de::value::MapDeserializer::new(map);\n                 let value = try!(visitor.visit_map(&mut map_visitor));\n                 try!(map_visitor.end());\n                 Ok(value)\n-            },\n+            }\n             Content::Bytes(ref v) => visitor.visit_bytes(v),\n         }\n     }\n@@ -649,7 +640,7 @@ impl<'a, E> Deserializer for ContentRefDeserializer<'a, E>\n             Content::None => visitor.visit_none(),\n             Content::Some(ref v) => visitor.visit_some(ContentRefDeserializer::new(v)),\n             Content::Unit => visitor.visit_unit(),\n-            _ => visitor.visit_some(self)\n+            _ => visitor.visit_some(self),\n         }\n     }\n \ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex fa3cd214f..e933d6922 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -6,26 +6,10 @@ use std::borrow::Cow;\n use collections::borrow::Cow;\n \n #[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n-use collections::{\n-    BinaryHeap,\n-    BTreeMap,\n-    BTreeSet,\n-    LinkedList,\n-    VecDeque,\n-    Vec,\n-    String,\n-};\n+use collections::{BinaryHeap, BTreeMap, BTreeSet, LinkedList, VecDeque, Vec, String};\n \n #[cfg(feature = \"std\")]\n-use std::collections::{\n-    HashMap,\n-    HashSet,\n-    BinaryHeap,\n-    BTreeMap,\n-    BTreeSet,\n-    LinkedList,\n-    VecDeque,\n-};\n+use std::collections::{HashMap, HashSet, BinaryHeap, BTreeMap, BTreeSet, LinkedList, VecDeque};\n \n #[cfg(feature = \"collections\")]\n use collections::borrow::ToOwned;\n@@ -63,17 +47,8 @@ use core::nonzero::{NonZero, Zeroable};\n #[allow(deprecated)] // required for impl Deserialize for NonZero<T>\n use core::num::Zero;\n \n-use de::{\n-    Deserialize,\n-    Deserializer,\n-    EnumVisitor,\n-    Error,\n-    MapVisitor,\n-    SeqVisitor,\n-    Unexpected,\n-    VariantVisitor,\n-    Visitor,\n-};\n+use de::{Deserialize, Deserializer, EnumVisitor, Error, MapVisitor, SeqVisitor, Unexpected,\n+         VariantVisitor, Visitor};\n use de::from_primitive::FromPrimitive;\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -89,13 +64,13 @@ impl Visitor for UnitVisitor {\n     }\n \n     fn visit_unit<E>(self) -> Result<(), E>\n-        where E: Error,\n+        where E: Error\n     {\n         Ok(())\n     }\n \n     fn visit_seq<V>(self, _: V) -> Result<(), V::Error>\n-        where V: SeqVisitor,\n+        where V: SeqVisitor\n     {\n         Ok(())\n     }\n@@ -103,7 +78,7 @@ impl Visitor for UnitVisitor {\n \n impl Deserialize for () {\n     fn deserialize<D>(deserializer: D) -> Result<(), D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         deserializer.deserialize_unit(UnitVisitor)\n     }\n@@ -122,13 +97,13 @@ impl Visitor for BoolVisitor {\n     }\n \n     fn visit_bool<E>(self, v: bool) -> Result<bool, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Ok(v)\n     }\n \n     fn visit_str<E>(self, s: &str) -> Result<bool, E>\n-        where E: Error,\n+        where E: Error\n     {\n         match s.trim_matches(::utils::Pattern_White_Space) {\n             \"true\" => Ok(true),\n@@ -140,7 +115,7 @@ impl Visitor for BoolVisitor {\n \n impl Deserialize for bool {\n     fn deserialize<D>(deserializer: D) -> Result<bool, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         deserializer.deserialize_bool(BoolVisitor)\n     }\n@@ -231,14 +206,14 @@ impl Visitor for CharVisitor {\n \n     #[inline]\n     fn visit_char<E>(self, v: char) -> Result<char, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Ok(v)\n     }\n \n     #[inline]\n     fn visit_str<E>(self, v: &str) -> Result<char, E>\n-        where E: Error,\n+        where E: Error\n     {\n         let mut iter = v.chars();\n         match (iter.next(), iter.next()) {\n@@ -251,7 +226,7 @@ impl Visitor for CharVisitor {\n impl Deserialize for char {\n     #[inline]\n     fn deserialize<D>(deserializer: D) -> Result<char, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         deserializer.deserialize_char(CharVisitor)\n     }\n@@ -271,25 +246,25 @@ impl Visitor for StringVisitor {\n     }\n \n     fn visit_str<E>(self, v: &str) -> Result<String, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Ok(v.to_owned())\n     }\n \n     fn visit_string<E>(self, v: String) -> Result<String, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Ok(v)\n     }\n \n     fn visit_unit<E>(self) -> Result<String, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Ok(String::new())\n     }\n \n     fn visit_bytes<E>(self, v: &[u8]) -> Result<String, E>\n-        where E: Error,\n+        where E: Error\n     {\n         match str::from_utf8(v) {\n             Ok(s) => Ok(s.to_owned()),\n@@ -298,7 +273,7 @@ impl Visitor for StringVisitor {\n     }\n \n     fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<String, E>\n-        where E: Error,\n+        where E: Error\n     {\n         match String::from_utf8(v) {\n             Ok(s) => Ok(s),\n@@ -310,7 +285,7 @@ impl Visitor for StringVisitor {\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl Deserialize for String {\n     fn deserialize<D>(deserializer: D) -> Result<String, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         deserializer.deserialize_string(StringVisitor)\n     }\n@@ -322,9 +297,7 @@ struct OptionVisitor<T> {\n     marker: PhantomData<T>,\n }\n \n-impl<\n-    T: Deserialize,\n-> Visitor for OptionVisitor<T> {\n+impl<T: Deserialize> Visitor for OptionVisitor<T> {\n     type Value = Option<T>;\n \n     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n@@ -333,29 +306,31 @@ impl<\n \n     #[inline]\n     fn visit_unit<E>(self) -> Result<Option<T>, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Ok(None)\n     }\n \n     #[inline]\n     fn visit_none<E>(self) -> Result<Option<T>, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Ok(None)\n     }\n \n     #[inline]\n     fn visit_some<D>(self, deserializer: D) -> Result<Option<T>, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         Ok(Some(try!(Deserialize::deserialize(deserializer))))\n     }\n }\n \n-impl<T> Deserialize for Option<T> where T: Deserialize {\n+impl<T> Deserialize for Option<T>\n+    where T: Deserialize\n+{\n     fn deserialize<D>(deserializer: D) -> Result<Option<T>, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         deserializer.deserialize_option(OptionVisitor { marker: PhantomData })\n     }\n@@ -377,7 +352,7 @@ impl<T> Visitor for PhantomDataVisitor<T> {\n \n     #[inline]\n     fn visit_unit<E>(self) -> Result<PhantomData<T>, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Ok(PhantomData)\n     }\n@@ -385,7 +360,7 @@ impl<T> Visitor for PhantomDataVisitor<T> {\n \n impl<T> Deserialize for PhantomData<T> {\n     fn deserialize<D>(deserializer: D) -> Result<PhantomData<T>, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let visitor = PhantomDataVisitor { marker: PhantomData };\n         deserializer.deserialize_unit_struct(\"PhantomData\", visitor)\n@@ -524,13 +499,13 @@ struct ArrayVisitor<A> {\n \n impl<A> ArrayVisitor<A> {\n     pub fn new() -> Self {\n-        ArrayVisitor {\n-            marker: PhantomData,\n-        }\n+        ArrayVisitor { marker: PhantomData }\n     }\n }\n \n-impl<T> Visitor for ArrayVisitor<[T; 0]> where T: Deserialize {\n+impl<T> Visitor for ArrayVisitor<[T; 0]>\n+    where T: Deserialize\n+{\n     type Value = [T; 0];\n \n     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n@@ -539,14 +514,14 @@ impl<T> Visitor for ArrayVisitor<[T; 0]> where T: Deserialize {\n \n     #[inline]\n     fn visit_unit<E>(self) -> Result<[T; 0], E>\n-        where E: Error,\n+        where E: Error\n     {\n         Ok([])\n     }\n \n     #[inline]\n     fn visit_seq<V>(self, _: V) -> Result<[T; 0], V::Error>\n-        where V: SeqVisitor,\n+        where V: SeqVisitor\n     {\n         Ok([])\n     }\n@@ -556,7 +531,7 @@ impl<T> Deserialize for [T; 0]\n     where T: Deserialize\n {\n     fn deserialize<D>(deserializer: D) -> Result<[T; 0], D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         deserializer.deserialize_seq_fixed_size(0, ArrayVisitor::<[T; 0]>::new())\n     }\n@@ -798,7 +773,7 @@ map_impl!(\n #[cfg(feature = \"std\")]\n impl Deserialize for net::IpAddr {\n     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let s = try!(String::deserialize(deserializer));\n         match s.parse() {\n@@ -811,7 +786,7 @@ impl Deserialize for net::IpAddr {\n #[cfg(feature = \"std\")]\n impl Deserialize for net::Ipv4Addr {\n     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let s = try!(String::deserialize(deserializer));\n         match s.parse() {\n@@ -824,7 +799,7 @@ impl Deserialize for net::Ipv4Addr {\n #[cfg(feature = \"std\")]\n impl Deserialize for net::Ipv6Addr {\n     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let s = try!(String::deserialize(deserializer));\n         match s.parse() {\n@@ -839,7 +814,7 @@ impl Deserialize for net::Ipv6Addr {\n #[cfg(feature = \"std\")]\n impl Deserialize for net::SocketAddr {\n     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let s = try!(String::deserialize(deserializer));\n         match s.parse() {\n@@ -852,7 +827,7 @@ impl Deserialize for net::SocketAddr {\n #[cfg(feature = \"std\")]\n impl Deserialize for net::SocketAddrV4 {\n     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let s = try!(String::deserialize(deserializer));\n         match s.parse() {\n@@ -865,7 +840,7 @@ impl Deserialize for net::SocketAddrV4 {\n #[cfg(feature = \"std\")]\n impl Deserialize for net::SocketAddrV6 {\n     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let s = try!(String::deserialize(deserializer));\n         match s.parse() {\n@@ -889,13 +864,13 @@ impl Visitor for PathBufVisitor {\n     }\n \n     fn visit_str<E>(self, v: &str) -> Result<path::PathBuf, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Ok(From::from(v))\n     }\n \n     fn visit_string<E>(self, v: String) -> Result<path::PathBuf, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Ok(From::from(v))\n     }\n@@ -904,7 +879,7 @@ impl Visitor for PathBufVisitor {\n #[cfg(feature = \"std\")]\n impl Deserialize for path::PathBuf {\n     fn deserialize<D>(deserializer: D) -> Result<path::PathBuf, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         deserializer.deserialize_string(PathBufVisitor)\n     }\n@@ -915,7 +890,7 @@ impl Deserialize for path::PathBuf {\n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n impl<T: Deserialize> Deserialize for Box<T> {\n     fn deserialize<D>(deserializer: D) -> Result<Box<T>, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let val = try!(Deserialize::deserialize(deserializer));\n         Ok(Box::new(val))\n@@ -925,7 +900,7 @@ impl<T: Deserialize> Deserialize for Box<T> {\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<T: Deserialize> Deserialize for Box<[T]> {\n     fn deserialize<D>(deserializer: D) -> Result<Box<[T]>, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let v: Vec<T> = try!(Deserialize::deserialize(deserializer));\n         Ok(v.into_boxed_slice())\n@@ -945,7 +920,7 @@ impl Deserialize for Box<str> {\n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n impl<T: Deserialize> Deserialize for Arc<T> {\n     fn deserialize<D>(deserializer: D) -> Result<Arc<T>, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let val = try!(Deserialize::deserialize(deserializer));\n         Ok(Arc::new(val))\n@@ -955,7 +930,7 @@ impl<T: Deserialize> Deserialize for Arc<T> {\n #[cfg(any(feature = \"std\", feature = \"alloc\"))]\n impl<T: Deserialize> Deserialize for Rc<T> {\n     fn deserialize<D>(deserializer: D) -> Result<Rc<T>, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let val = try!(Deserialize::deserialize(deserializer));\n         Ok(Rc::new(val))\n@@ -963,10 +938,13 @@ impl<T: Deserialize> Deserialize for Rc<T> {\n }\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-impl<'a, T: ?Sized> Deserialize for Cow<'a, T> where T: ToOwned, T::Owned: Deserialize, {\n+impl<'a, T: ?Sized> Deserialize for Cow<'a, T>\n+    where T: ToOwned,\n+          T::Owned: Deserialize\n+{\n     #[inline]\n     fn deserialize<D>(deserializer: D) -> Result<Cow<'a, T>, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let val = try!(Deserialize::deserialize(deserializer));\n         Ok(Cow::Owned(val))\n@@ -986,13 +964,16 @@ impl<'a, T: ?Sized> Deserialize for Cow<'a, T> where T: ToOwned, T::Owned: Deser\n #[cfg(feature = \"std\")]\n impl Deserialize for Duration {\n     fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n-        enum Field { Secs, Nanos };\n+        enum Field {\n+            Secs,\n+            Nanos,\n+        };\n \n         impl Deserialize for Field {\n             fn deserialize<D>(deserializer: D) -> Result<Field, D::Error>\n-                where D: Deserializer,\n+                where D: Deserializer\n             {\n                 struct FieldVisitor;\n \n@@ -1004,7 +985,7 @@ impl Deserialize for Duration {\n                     }\n \n                     fn visit_str<E>(self, value: &str) -> Result<Field, E>\n-                        where E: Error,\n+                        where E: Error\n                     {\n                         match value {\n                             \"secs\" => Ok(Field::Secs),\n@@ -1014,7 +995,7 @@ impl Deserialize for Duration {\n                     }\n \n                     fn visit_bytes<E>(self, value: &[u8]) -> Result<Field, E>\n-                        where E: Error,\n+                        where E: Error\n                     {\n                         match value {\n                             b\"secs\" => Ok(Field::Secs),\n@@ -1041,7 +1022,7 @@ impl Deserialize for Duration {\n             }\n \n             fn visit_seq<V>(self, mut visitor: V) -> Result<Duration, V::Error>\n-                where V: SeqVisitor,\n+                where V: SeqVisitor\n             {\n                 let secs: u64 = match try!(visitor.visit()) {\n                     Some(value) => value,\n@@ -1059,7 +1040,7 @@ impl Deserialize for Duration {\n             }\n \n             fn visit_map<V>(self, mut visitor: V) -> Result<Duration, V::Error>\n-                where V: MapVisitor,\n+                where V: MapVisitor\n             {\n                 let mut secs: Option<u64> = None;\n                 let mut nanos: Option<u32> = None;\n@@ -1100,24 +1081,30 @@ impl Deserialize for Duration {\n \n #[cfg(feature = \"unstable\")]\n #[allow(deprecated)] // num::Zero is deprecated but there is no replacement\n-impl<T> Deserialize for NonZero<T> where T: Deserialize + PartialEq + Zeroable + Zero {\n-    fn deserialize<D>(deserializer: D) -> Result<NonZero<T>, D::Error> where D: Deserializer {\n+impl<T> Deserialize for NonZero<T>\n+    where T: Deserialize + PartialEq + Zeroable + Zero\n+{\n+    fn deserialize<D>(deserializer: D) -> Result<NonZero<T>, D::Error>\n+        where D: Deserializer\n+    {\n         let value = try!(Deserialize::deserialize(deserializer));\n         if value == Zero::zero() {\n-            return Err(Error::custom(\"expected a non-zero value\"))\n-        }\n-        unsafe {\n-            Ok(NonZero::new(value))\n+            return Err(Error::custom(\"expected a non-zero value\"));\n         }\n+        unsafe { Ok(NonZero::new(value)) }\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n \n \n-impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n+impl<T, E> Deserialize for Result<T, E>\n+    where T: Deserialize,\n+          E: Deserialize\n+{\n     fn deserialize<D>(deserializer: D) -> Result<Result<T, E>, D::Error>\n-                      where D: Deserializer {\n+        where D: Deserializer\n+    {\n         enum Field {\n             Ok,\n             Err,\n@@ -1137,15 +1124,21 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n                         formatter.write_str(\"`Ok` or `Err`\")\n                     }\n \n-                    fn visit_u32<E>(self, value: u32) -> Result<Field, E> where E: Error {\n+                    fn visit_u32<E>(self, value: u32) -> Result<Field, E>\n+                        where E: Error\n+                    {\n                         match value {\n                             0 => Ok(Field::Ok),\n                             1 => Ok(Field::Err),\n-                            _ => Err(Error::invalid_value(Unexpected::Unsigned(value as u64), &self)),\n+                            _ => {\n+                                Err(Error::invalid_value(Unexpected::Unsigned(value as u64), &self))\n+                            }\n                         }\n                     }\n \n-                    fn visit_str<E>(self, value: &str) -> Result<Field, E> where E: Error {\n+                    fn visit_str<E>(self, value: &str) -> Result<Field, E>\n+                        where E: Error\n+                    {\n                         match value {\n                             \"Ok\" => Ok(Field::Ok),\n                             \"Err\" => Ok(Field::Err),\n@@ -1153,14 +1146,18 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n                         }\n                     }\n \n-                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Field, E> where E: Error {\n+                    fn visit_bytes<E>(self, value: &[u8]) -> Result<Field, E>\n+                        where E: Error\n+                    {\n                         match value {\n                             b\"Ok\" => Ok(Field::Ok),\n                             b\"Err\" => Ok(Field::Err),\n                             _ => {\n                                 match str::from_utf8(value) {\n                                     Ok(value) => Err(Error::unknown_variant(value, VARIANTS)),\n-                                    Err(_) => Err(Error::invalid_value(Unexpected::Bytes(value), &self)),\n+                                    Err(_) => {\n+                                        Err(Error::invalid_value(Unexpected::Bytes(value), &self))\n+                                    }\n                                 }\n                             }\n                         }\n@@ -1208,7 +1205,7 @@ pub struct IgnoredAny;\n impl Deserialize for IgnoredAny {\n     #[inline]\n     fn deserialize<D>(deserializer: D) -> Result<IgnoredAny, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         struct IgnoredAnyVisitor;\n \n@@ -1241,7 +1238,7 @@ impl Deserialize for IgnoredAny {\n \n             #[inline]\n             fn visit_str<E>(self, _: &str) -> Result<IgnoredAny, E>\n-                where E: Error,\n+                where E: Error\n             {\n                 Ok(IgnoredAny)\n             }\n@@ -1253,14 +1250,14 @@ impl Deserialize for IgnoredAny {\n \n             #[inline]\n             fn visit_some<D>(self, _: D) -> Result<IgnoredAny, D::Error>\n-                where D: Deserializer,\n+                where D: Deserializer\n             {\n                 Ok(IgnoredAny)\n             }\n \n             #[inline]\n             fn visit_newtype_struct<D>(self, _: D) -> Result<IgnoredAny, D::Error>\n-                where D: Deserializer,\n+                where D: Deserializer\n             {\n                 Ok(IgnoredAny)\n             }\n@@ -1272,7 +1269,7 @@ impl Deserialize for IgnoredAny {\n \n             #[inline]\n             fn visit_seq<V>(self, mut visitor: V) -> Result<IgnoredAny, V::Error>\n-                where V: SeqVisitor,\n+                where V: SeqVisitor\n             {\n                 while let Some(_) = try!(visitor.visit::<IgnoredAny>()) {\n                     // Gobble\n@@ -1282,7 +1279,7 @@ impl Deserialize for IgnoredAny {\n \n             #[inline]\n             fn visit_map<V>(self, mut visitor: V) -> Result<IgnoredAny, V::Error>\n-                where V: MapVisitor,\n+                where V: MapVisitor\n             {\n                 while let Some((_, _)) = try!(visitor.visit::<IgnoredAny, IgnoredAny>()) {\n                     // Gobble\n@@ -1292,7 +1289,7 @@ impl Deserialize for IgnoredAny {\n \n             #[inline]\n             fn visit_bytes<E>(self, _: &[u8]) -> Result<IgnoredAny, E>\n-                where E: Error,\n+                where E: Error\n             {\n                 Ok(IgnoredAny)\n             }\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex f01988bb9..9ae0ba0c0 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -181,7 +181,10 @@ pub trait Error: Sized + error::Error {\n                 write!(formatter, \"invalid type: {}, expected {}\", self.unexp, self.exp)\n             }\n         }\n-        Error::custom(InvalidType { unexp: unexp, exp: exp })\n+        Error::custom(InvalidType {\n+            unexp: unexp,\n+            exp: exp,\n+        })\n     }\n \n     /// Raised when a `Deserialize` receives a value of the right type but that\n@@ -207,7 +210,10 @@ pub trait Error: Sized + error::Error {\n                 write!(formatter, \"invalid value: {}, expected {}\", self.unexp, self.exp)\n             }\n         }\n-        Error::custom(InvalidValue { unexp: unexp, exp: exp })\n+        Error::custom(InvalidValue {\n+            unexp: unexp,\n+            exp: exp,\n+        })\n     }\n \n     /// Raised when deserializing a sequence or map and the input data contains\n@@ -229,7 +235,10 @@ pub trait Error: Sized + error::Error {\n                 write!(formatter, \"invalid length {}, expected {}\", self.len, self.exp)\n             }\n         }\n-        Error::custom(InvalidLength { len: len, exp: exp })\n+        Error::custom(InvalidLength {\n+            len: len,\n+            exp: exp,\n+        })\n     }\n \n     /// Raised when a `Deserialize` enum type received a variant with an\n@@ -253,7 +262,10 @@ pub trait Error: Sized + error::Error {\n                 }\n             }\n         }\n-        Error::custom(UnknownVariant { variant: variant, expected: expected })\n+        Error::custom(UnknownVariant {\n+            variant: variant,\n+            expected: expected,\n+        })\n     }\n \n     /// Raised when a `Deserialize` struct type received a field with an\n@@ -277,7 +289,10 @@ pub trait Error: Sized + error::Error {\n                 }\n             }\n         }\n-        Error::custom(UnknownField { field: field, expected: expected })\n+        Error::custom(UnknownField {\n+            field: field,\n+            expected: expected,\n+        })\n     }\n \n     /// Raised when a `Deserialize` struct type expected to receive a required\n@@ -470,7 +485,9 @@ pub trait Expected {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result;\n }\n \n-impl<T> Expected for T where T: Visitor {\n+impl<T> Expected for T\n+    where T: Visitor\n+{\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n         self.expecting(formatter)\n     }\n@@ -521,8 +538,7 @@ pub trait Deserialize: Sized {\n     /// manual for more information about how to implement this method.\n     ///\n     /// [impl-deserialize]: https://serde.rs/impl-deserialize.html\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-        where D: Deserializer;\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error> where D: Deserializer;\n }\n \n /// `DeserializeSeed` is the stateful form of the `Deserialize` trait. If you\n@@ -670,8 +686,7 @@ pub trait DeserializeSeed: Sized {\n \n     /// Equivalent to the more common `Deserialize::deserialize` method, except\n     /// with some initial piece of data (the seed) passed in.\n-    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n-        where D: Deserializer;\n+    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error> where D: Deserializer;\n }\n \n impl<T> DeserializeSeed for PhantomData<T>\n@@ -784,56 +799,43 @@ pub trait Deserializer: Sized {\n     /// `Deserializer::deserialize` means your data type will be able to\n     /// deserialize from self-describing formats only, ruling out Bincode and\n     /// many others.\n-    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a `bool` value.\n-    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a `u8` value.\n-    fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a `u16` value.\n-    fn deserialize_u16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_u16<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a `u32` value.\n-    fn deserialize_u32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_u32<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a `u64` value.\n-    fn deserialize_u64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_u64<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting an `i8` value.\n-    fn deserialize_i8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_i8<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting an `i16` value.\n-    fn deserialize_i16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_i16<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting an `i32` value.\n-    fn deserialize_i32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_i32<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting an `i64` value.\n-    fn deserialize_i64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_i64<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a `f32` value.\n-    fn deserialize_f32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_f32<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a `f64` value.\n-    fn deserialize_f64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_f64<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a `char` value.\n-    fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a string value and does\n     /// not benefit from taking ownership of buffered data owned by the\n@@ -842,8 +844,7 @@ pub trait Deserializer: Sized {\n     /// If the `Visitor` would benefit from taking ownership of `String` data,\n     /// indiciate this to the `Deserializer` by using `deserialize_string`\n     /// instead.\n-    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a string value and would\n     /// benefit from taking ownership of buffered data owned by the\n@@ -852,8 +853,7 @@ pub trait Deserializer: Sized {\n     /// If the `Visitor` would not benefit from taking ownership of `String`\n     /// data, indicate that to the `Deserializer` by using `deserialize_str`\n     /// instead.\n-    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a byte array and does not\n     /// benefit from taking ownership of buffered data owned by the\n@@ -862,8 +862,7 @@ pub trait Deserializer: Sized {\n     /// If the `Visitor` would benefit from taking ownership of `Vec<u8>` data,\n     /// indicate this to the `Deserializer` by using `deserialize_byte_buf`\n     /// instead.\n-    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a byte array and would\n     /// benefit from taking ownership of buffered data owned by the\n@@ -872,44 +871,43 @@ pub trait Deserializer: Sized {\n     /// If the `Visitor` would not benefit from taking ownership of `Vec<u8>`\n     /// data, indicate that to the `Deserializer` by using `deserialize_bytes`\n     /// instead.\n-    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting an optional value.\n     ///\n     /// This allows deserializers that encode an optional value as a nullable\n     /// value to convert the null value into `None` and a regular value into\n     /// `Some(value)`.\n-    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a unit value.\n-    fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a unit struct with a\n     /// particular name.\n     fn deserialize_unit_struct<V>(self,\n                                   name: &'static str,\n-                                  visitor: V) -> Result<V::Value, Self::Error>\n+                                  visitor: V)\n+                                  -> Result<V::Value, Self::Error>\n         where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a newtype struct with a\n     /// particular name.\n     fn deserialize_newtype_struct<V>(self,\n                                      name: &'static str,\n-                                     visitor: V) -> Result<V::Value, Self::Error>\n+                                     visitor: V)\n+                                     -> Result<V::Value, Self::Error>\n         where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a sequence of values.\n-    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a sequence of values and\n     /// knows how many values there are without looking at the serialized data.\n     fn deserialize_seq_fixed_size<V>(self,\n                                      len: usize,\n-                                     visitor: V) -> Result<V::Value, Self::Error>\n+                                     visitor: V)\n+                                     -> Result<V::Value, Self::Error>\n         where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a tuple value with a\n@@ -922,19 +920,20 @@ pub trait Deserializer: Sized {\n     fn deserialize_tuple_struct<V>(self,\n                                    name: &'static str,\n                                    len: usize,\n-                                   visitor: V) -> Result<V::Value, Self::Error>\n+                                   visitor: V)\n+                                   -> Result<V::Value, Self::Error>\n         where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a map of key-value pairs.\n-    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n+    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error> where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting a struct with a particular\n     /// name and fields.\n     fn deserialize_struct<V>(self,\n                              name: &'static str,\n                              fields: &'static [&'static str],\n-                             visitor: V) -> Result<V::Value, Self::Error>\n+                             visitor: V)\n+                             -> Result<V::Value, Self::Error>\n         where V: Visitor;\n \n     /// Hint that the `Deserialize` type is expecting the name of a struct\n@@ -947,7 +946,8 @@ pub trait Deserializer: Sized {\n     fn deserialize_enum<V>(self,\n                            name: &'static str,\n                            variants: &'static [&'static str],\n-                           visitor: V) -> Result<V::Value, Self::Error>\n+                           visitor: V)\n+                           -> Result<V::Value, Self::Error>\n         where V: Visitor;\n \n     /// Hint that the `Deserialize` type needs to deserialize a value whose type\n@@ -1016,77 +1016,77 @@ pub trait Visitor: Sized {\n \n     /// Deserialize a `bool` into a `Value`.\n     fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Err(Error::invalid_type(Unexpected::Bool(v), &self))\n     }\n \n     /// Deserialize an `i8` into a `Value`.\n     fn visit_i8<E>(self, v: i8) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         self.visit_i64(v as i64)\n     }\n \n     /// Deserialize an `i16` into a `Value`.\n     fn visit_i16<E>(self, v: i16) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         self.visit_i64(v as i64)\n     }\n \n     /// Deserialize an `i32` into a `Value`.\n     fn visit_i32<E>(self, v: i32) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         self.visit_i64(v as i64)\n     }\n \n     /// Deserialize an `i64` into a `Value`.\n     fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Err(Error::invalid_type(Unexpected::Signed(v), &self))\n     }\n \n     /// Deserialize a `u8` into a `Value`.\n     fn visit_u8<E>(self, v: u8) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         self.visit_u64(v as u64)\n     }\n \n     /// Deserialize a `u16` into a `Value`.\n     fn visit_u16<E>(self, v: u16) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         self.visit_u64(v as u64)\n     }\n \n     /// Deserialize a `u32` into a `Value`.\n     fn visit_u32<E>(self, v: u32) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         self.visit_u64(v as u64)\n     }\n \n     /// Deserialize a `u64` into a `Value`.\n     fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Err(Error::invalid_type(Unexpected::Unsigned(v), &self))\n     }\n \n     /// Deserialize a `f32` into a `Value`.\n     fn visit_f32<E>(self, v: f32) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         self.visit_f64(v as f64)\n     }\n \n     /// Deserialize a `f64` into a `Value`.\n     fn visit_f64<E>(self, v: f64) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Err(Error::invalid_type(Unexpected::Float(v), &self))\n     }\n@@ -1094,7 +1094,7 @@ pub trait Visitor: Sized {\n     /// Deserialize a `char` into a `Value`.\n     #[inline]\n     fn visit_char<E>(self, v: char) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         self.visit_str(::utils::encode_utf8(v).as_str())\n     }\n@@ -1110,7 +1110,7 @@ pub trait Visitor: Sized {\n     /// It is never correct to implement `visit_string` without implementing\n     /// `visit_str`. Implement neither, both, or just `visit_str`.\n     fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Err(Error::invalid_type(Unexpected::Str(v), &self))\n     }\n@@ -1132,28 +1132,28 @@ pub trait Visitor: Sized {\n     #[inline]\n     #[cfg(any(feature = \"std\", feature = \"collections\"))]\n     fn visit_string<E>(self, v: String) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         self.visit_str(&v)\n     }\n \n     /// Deserialize a `()` into a `Value`.\n     fn visit_unit<E>(self) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Err(Error::invalid_type(Unexpected::Unit, &self))\n     }\n \n     /// Deserialize an absent optional `Value`.\n     fn visit_none<E>(self) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         Err(Error::invalid_type(Unexpected::Option, &self))\n     }\n \n     /// Deserialize a present optional `Value`.\n     fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let _ = deserializer;\n         Err(Error::invalid_type(Unexpected::Option, &self))\n@@ -1161,7 +1161,7 @@ pub trait Visitor: Sized {\n \n     /// Deserialize `Value` as a newtype struct.\n     fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n-        where D: Deserializer,\n+        where D: Deserializer\n     {\n         let _ = deserializer;\n         Err(Error::invalid_type(Unexpected::NewtypeStruct, &self))\n@@ -1169,7 +1169,7 @@ pub trait Visitor: Sized {\n \n     /// Deserialize `Value` as a sequence of elements.\n     fn visit_seq<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n-        where V: SeqVisitor,\n+        where V: SeqVisitor\n     {\n         let _ = visitor;\n         Err(Error::invalid_type(Unexpected::Seq, &self))\n@@ -1177,7 +1177,7 @@ pub trait Visitor: Sized {\n \n     /// Deserialize `Value` as a key-value map.\n     fn visit_map<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n-        where V: MapVisitor,\n+        where V: MapVisitor\n     {\n         let _ = visitor;\n         Err(Error::invalid_type(Unexpected::Map, &self))\n@@ -1185,7 +1185,7 @@ pub trait Visitor: Sized {\n \n     /// Deserialize `Value` as an enum.\n     fn visit_enum<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n-        where V: EnumVisitor,\n+        where V: EnumVisitor\n     {\n         let _ = visitor;\n         Err(Error::invalid_type(Unexpected::Enum, &self))\n@@ -1202,7 +1202,7 @@ pub trait Visitor: Sized {\n     /// It is never correct to implement `visit_byte_buf` without implementing\n     /// `visit_bytes`. Implement neither, both, or just `visit_bytes`.\n     fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         let _ = v;\n         Err(Error::invalid_type(Unexpected::Bytes(v), &self))\n@@ -1225,7 +1225,7 @@ pub trait Visitor: Sized {\n     /// `Vec<u8>`.\n     #[cfg(any(feature = \"std\", feature = \"collections\"))]\n     fn visit_byte_buf<E>(self, v: Vec<u8>) -> Result<Self::Value, E>\n-        where E: Error,\n+        where E: Error\n     {\n         self.visit_bytes(&v)\n     }\n@@ -1269,7 +1269,9 @@ pub trait SeqVisitor {\n     }\n }\n \n-impl<'a, V> SeqVisitor for &'a mut V where V: SeqVisitor {\n+impl<'a, V> SeqVisitor for &'a mut V\n+    where V: SeqVisitor\n+{\n     type Error = V::Error;\n \n     #[inline]\n@@ -1326,7 +1328,10 @@ pub trait MapVisitor {\n     /// `Deserialize` implementations should typically use `MapVisitor::visit`\n     /// instead.\n     #[inline]\n-    fn visit_seed<K, V>(&mut self, kseed: K, vseed: V) -> Result<Option<(K::Value, V::Value)>, Self::Error>\n+    fn visit_seed<K, V>(&mut self,\n+                        kseed: K,\n+                        vseed: V)\n+                        -> Result<Option<(K::Value, V::Value)>, Self::Error>\n         where K: DeserializeSeed,\n               V: DeserializeSeed\n     {\n@@ -1335,7 +1340,7 @@ pub trait MapVisitor {\n                 let value = try!(self.visit_value_seed(vseed));\n                 Ok(Some((key, value)))\n             }\n-            None => Ok(None)\n+            None => Ok(None),\n         }\n     }\n \n@@ -1370,7 +1375,7 @@ pub trait MapVisitor {\n     #[inline]\n     fn visit<K, V>(&mut self) -> Result<Option<(K, V)>, Self::Error>\n         where K: Deserialize,\n-              V: Deserialize,\n+              V: Deserialize\n     {\n         self.visit_seed(PhantomData, PhantomData)\n     }\n@@ -1382,7 +1387,9 @@ pub trait MapVisitor {\n     }\n }\n \n-impl<'a, V_> MapVisitor for &'a mut V_ where V_: MapVisitor {\n+impl<'a, V_> MapVisitor for &'a mut V_\n+    where V_: MapVisitor\n+{\n     type Error = V_::Error;\n \n     #[inline]\n@@ -1400,7 +1407,10 @@ impl<'a, V_> MapVisitor for &'a mut V_ where V_: MapVisitor {\n     }\n \n     #[inline]\n-    fn visit_seed<K, V>(&mut self, kseed: K, vseed: V) -> Result<Option<(K::Value, V::Value)>, Self::Error>\n+    fn visit_seed<K, V>(&mut self,\n+                        kseed: K,\n+                        vseed: V)\n+                        -> Result<Option<(K::Value, V::Value)>, Self::Error>\n         where K: DeserializeSeed,\n               V: DeserializeSeed\n     {\n@@ -1410,7 +1420,7 @@ impl<'a, V_> MapVisitor for &'a mut V_ where V_: MapVisitor {\n     #[inline]\n     fn visit<K, V>(&mut self) -> Result<Option<(K, V)>, V_::Error>\n         where K: Deserialize,\n-              V: Deserialize,\n+              V: Deserialize\n     {\n         (**self).visit()\n     }\n@@ -1446,7 +1456,7 @@ pub trait EnumVisitor: Sized {\n     type Error: Error;\n     /// The `Visitor` that will be used to deserialize the content of the enum\n     /// variant.\n-    type Variant: VariantVisitor<Error=Self::Error>;\n+    type Variant: VariantVisitor<Error = Self::Error>;\n \n     /// `visit_variant` is called to identify which variant to deserialize.\n     ///\n@@ -1539,9 +1549,7 @@ pub trait VariantVisitor: Sized {\n     ///     Err(Error::invalid_type(unexp, &\"tuple variant\"))\n     /// }\n     /// ```\n-    fn visit_tuple<V>(self,\n-                      len: usize,\n-                      visitor: V) -> Result<V::Value, Self::Error>\n+    fn visit_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor;\n \n     /// Called when deserializing a struct-like variant.\n@@ -1564,7 +1572,8 @@ pub trait VariantVisitor: Sized {\n     /// ```\n     fn visit_struct<V>(self,\n                        fields: &'static [&'static str],\n-                       visitor: V) -> Result<V::Value, Self::Error>\n+                       visitor: V)\n+                       -> Result<V::Value, Self::Error>\n         where V: Visitor;\n }\n \ndiff --git a/serde/src/de/private.rs b/serde/src/de/private.rs\nindex 566c4b112..8ef622316 100644\n--- a/serde/src/de/private.rs\n+++ b/serde/src/de/private.rs\n@@ -3,14 +3,8 @@ use core::marker::PhantomData;\n use de::{Deserialize, Deserializer, Error, Visitor};\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-pub use de::content::{\n-    Content,\n-    ContentRefDeserializer,\n-    ContentDeserializer,\n-    TaggedContentVisitor,\n-    InternallyTaggedUnitVisitor,\n-    UntaggedUnitVisitor,\n-};\n+pub use de::content::{Content, ContentRefDeserializer, ContentDeserializer, TaggedContentVisitor,\n+                      InternallyTaggedUnitVisitor, UntaggedUnitVisitor};\n \n /// If the missing field is of type `Option<T>` then treat is as `None`,\n /// otherwise it is an error.\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 85d152678..264cdc799 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -1,31 +1,15 @@\n //! This module supports deserializing from primitives with the `ValueDeserializer` trait.\n \n #[cfg(feature = \"std\")]\n-use std::collections::{\n-    BTreeMap,\n-    BTreeSet,\n-    HashMap,\n-    HashSet,\n-    btree_map,\n-    btree_set,\n-    hash_map,\n-    hash_set,\n-};\n+use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet, btree_map, btree_set, hash_map,\n+                       hash_set};\n #[cfg(feature = \"std\")]\n use std::borrow::Cow;\n #[cfg(feature = \"std\")]\n use std::vec;\n \n #[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n-use collections::{\n-    BTreeMap,\n-    BTreeSet,\n-    Vec,\n-    String,\n-    btree_map,\n-    btree_set,\n-    vec,\n-};\n+use collections::{BTreeMap, BTreeSet, Vec, String, btree_map, btree_set, vec};\n #[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n use collections::borrow::Cow;\n #[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n@@ -41,7 +25,7 @@ use std::error;\n use error;\n \n use core::fmt::{self, Display};\n-use core::iter::{self,  Iterator};\n+use core::iter::{self, Iterator};\n use core::marker::PhantomData;\n \n use de::{self, Expected, SeqVisitor};\n@@ -63,16 +47,12 @@ type ErrorImpl = ();\n impl de::Error for Error {\n     #[cfg(any(feature = \"std\", feature = \"collections\"))]\n     fn custom<T: Display>(msg: T) -> Self {\n-        Error {\n-            err: msg.to_string().into_boxed_str(),\n-        }\n+        Error { err: msg.to_string().into_boxed_str() }\n     }\n \n     #[cfg(not(any(feature = \"std\", feature = \"collections\")))]\n     fn custom<T: Display>(_msg: T) -> Self {\n-        Error {\n-            err: (),\n-        }\n+        Error { err: () }\n     }\n }\n \n@@ -105,7 +85,7 @@ impl error::Error for Error {\n /// This trait converts primitive types into a deserializer.\n pub trait ValueDeserializer<E: de::Error = Error> {\n     /// The actual deserializer type.\n-    type Deserializer: de::Deserializer<Error=E>;\n+    type Deserializer: de::Deserializer<Error = E>;\n \n     /// Convert this value into a deserializer.\n     fn into_deserializer(self) -> Self::Deserializer;\n@@ -114,14 +94,12 @@ pub trait ValueDeserializer<E: de::Error = Error> {\n ///////////////////////////////////////////////////////////////////////////////\n \n impl<E> ValueDeserializer<E> for ()\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Deserializer = UnitDeserializer<E>;\n \n     fn into_deserializer(self) -> UnitDeserializer<E> {\n-        UnitDeserializer {\n-            marker: PhantomData,\n-        }\n+        UnitDeserializer { marker: PhantomData }\n     }\n }\n \n@@ -142,13 +120,13 @@ impl<E> de::Deserializer for UnitDeserializer<E>\n     }\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+        where V: de::Visitor\n     {\n         visitor.visit_unit()\n     }\n \n     fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+        where V: de::Visitor\n     {\n         visitor.visit_none()\n     }\n@@ -221,7 +199,7 @@ pub struct StrDeserializer<'a, E> {\n }\n \n impl<'a, E> ValueDeserializer<E> for &'a str\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Deserializer = StrDeserializer<'a, E>;\n \n@@ -234,21 +212,22 @@ impl<'a, E> ValueDeserializer<E> for &'a str\n }\n \n impl<'a, E> de::Deserializer for StrDeserializer<'a, E>\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Error = E;\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+        where V: de::Visitor\n     {\n         visitor.visit_str(self.value)\n     }\n \n     fn deserialize_enum<V>(self,\n-                     _name: &str,\n-                     _variants: &'static [&'static str],\n-                     visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+                           _name: &str,\n+                           _variants: &'static [&'static str],\n+                           visitor: V)\n+                           -> Result<V::Value, Self::Error>\n+        where V: de::Visitor\n     {\n         visitor.visit_enum(self)\n     }\n@@ -261,13 +240,13 @@ impl<'a, E> de::Deserializer for StrDeserializer<'a, E>\n }\n \n impl<'a, E> de::EnumVisitor for StrDeserializer<'a, E>\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Error = E;\n     type Variant = private::UnitOnly<E>;\n \n     fn visit_variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n-        where T: de::DeserializeSeed,\n+        where T: de::DeserializeSeed\n     {\n         seed.deserialize(self).map(private::unit_only)\n     }\n@@ -284,7 +263,7 @@ pub struct StringDeserializer<E> {\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<E> ValueDeserializer<E> for String\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Deserializer = StringDeserializer<E>;\n \n@@ -298,21 +277,22 @@ impl<E> ValueDeserializer<E> for String\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<E> de::Deserializer for StringDeserializer<E>\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Error = E;\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+        where V: de::Visitor\n     {\n         visitor.visit_string(self.value)\n     }\n \n     fn deserialize_enum<V>(self,\n-                     _name: &str,\n-                     _variants: &'static [&'static str],\n-                     visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+                           _name: &str,\n+                           _variants: &'static [&'static str],\n+                           visitor: V)\n+                           -> Result<V::Value, Self::Error>\n+        where V: de::Visitor\n     {\n         visitor.visit_enum(self)\n     }\n@@ -326,13 +306,13 @@ impl<E> de::Deserializer for StringDeserializer<E>\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<'a, E> de::EnumVisitor for StringDeserializer<E>\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Error = E;\n     type Variant = private::UnitOnly<E>;\n \n     fn visit_variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n-        where T: de::DeserializeSeed,\n+        where T: de::DeserializeSeed\n     {\n         seed.deserialize(self).map(private::unit_only)\n     }\n@@ -349,7 +329,7 @@ pub struct CowStrDeserializer<'a, E> {\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<'a, E> ValueDeserializer<E> for Cow<'a, str>\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Deserializer = CowStrDeserializer<'a, E>;\n \n@@ -363,12 +343,12 @@ impl<'a, E> ValueDeserializer<E> for Cow<'a, str>\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<'a, E> de::Deserializer for CowStrDeserializer<'a, E>\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Error = E;\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+        where V: de::Visitor\n     {\n         match self.value {\n             Cow::Borrowed(string) => visitor.visit_str(string),\n@@ -377,10 +357,11 @@ impl<'a, E> de::Deserializer for CowStrDeserializer<'a, E>\n     }\n \n     fn deserialize_enum<V>(self,\n-                     _name: &str,\n-                     _variants: &'static [&'static str],\n-                     visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+                           _name: &str,\n+                           _variants: &'static [&'static str],\n+                           visitor: V)\n+                           -> Result<V::Value, Self::Error>\n+        where V: de::Visitor\n     {\n         visitor.visit_enum(self)\n     }\n@@ -394,13 +375,13 @@ impl<'a, E> de::Deserializer for CowStrDeserializer<'a, E>\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<'a, E> de::EnumVisitor for CowStrDeserializer<'a, E>\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Error = E;\n     type Variant = private::UnitOnly<E>;\n \n     fn visit_variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n-        where T: de::DeserializeSeed,\n+        where T: de::DeserializeSeed\n     {\n         seed.deserialize(self).map(private::unit_only)\n     }\n@@ -417,7 +398,7 @@ pub struct SeqDeserializer<I, E> {\n \n impl<I, E> SeqDeserializer<I, E>\n     where I: Iterator,\n-          E: de::Error,\n+          E: de::Error\n {\n     /// Construct a new `SeqDeserializer<I>`.\n     pub fn new(iter: I) -> Self {\n@@ -446,14 +427,14 @@ impl<I, E> SeqDeserializer<I, E>\n }\n \n impl<I, T, E> de::Deserializer for SeqDeserializer<I, E>\n-    where I: Iterator<Item=T>,\n+    where I: Iterator<Item = T>,\n           T: ValueDeserializer<E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Error = E;\n \n     fn deserialize<V>(mut self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+        where V: de::Visitor\n     {\n         let v = try!(visitor.visit_seq(&mut self));\n         try!(self.end());\n@@ -468,9 +449,9 @@ impl<I, T, E> de::Deserializer for SeqDeserializer<I, E>\n }\n \n impl<I, T, E> de::SeqVisitor for SeqDeserializer<I, E>\n-    where I: Iterator<Item=T>,\n+    where I: Iterator<Item = T>,\n           T: ValueDeserializer<E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Error = E;\n \n@@ -508,7 +489,7 @@ impl Expected for ExpectedInSeq {\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<T, E> ValueDeserializer<E> for Vec<T>\n     where T: ValueDeserializer<E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Deserializer = SeqDeserializer<vec::IntoIter<T>, E>;\n \n@@ -520,7 +501,7 @@ impl<T, E> ValueDeserializer<E> for Vec<T>\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<T, E> ValueDeserializer<E> for BTreeSet<T>\n     where T: ValueDeserializer<E> + Eq + Ord,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Deserializer = SeqDeserializer<btree_set::IntoIter<T>, E>;\n \n@@ -532,7 +513,7 @@ impl<T, E> ValueDeserializer<E> for BTreeSet<T>\n #[cfg(feature = \"std\")]\n impl<T, E> ValueDeserializer<E> for HashSet<T>\n     where T: ValueDeserializer<E> + Eq + Hash,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Deserializer = SeqDeserializer<hash_set::IntoIter<T>, E>;\n \n@@ -551,20 +532,20 @@ pub struct SeqVisitorDeserializer<V_, E> {\n \n impl<V_, E> SeqVisitorDeserializer<V_, E>\n     where V_: de::SeqVisitor<Error = E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     /// Construct a new `SeqVisitorDeserializer<V_, E>`.\n     pub fn new(visitor: V_) -> Self {\n-        SeqVisitorDeserializer{\n+        SeqVisitorDeserializer {\n             visitor: visitor,\n-            marker: PhantomData\n+            marker: PhantomData,\n         }\n     }\n }\n \n impl<V_, E> de::Deserializer for SeqVisitorDeserializer<V_, E>\n     where V_: de::SeqVisitor<Error = E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Error = E;\n \n@@ -587,7 +568,7 @@ pub struct MapDeserializer<I, E>\n           I::Item: private::Pair,\n           <I::Item as private::Pair>::First: ValueDeserializer<E>,\n           <I::Item as private::Pair>::Second: ValueDeserializer<E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     iter: iter::Fuse<I>,\n     value: Option<<I::Item as private::Pair>::Second>,\n@@ -600,7 +581,7 @@ impl<I, E> MapDeserializer<I, E>\n           I::Item: private::Pair,\n           <I::Item as private::Pair>::First: ValueDeserializer<E>,\n           <I::Item as private::Pair>::Second: ValueDeserializer<E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     /// Construct a new `MapDeserializer<I, K, V, E>`.\n     pub fn new(iter: I) -> Self {\n@@ -628,7 +609,9 @@ impl<I, E> MapDeserializer<I, E>\n         }\n     }\n \n-    fn next_pair(&mut self) -> Option<(<I::Item as private::Pair>::First, <I::Item as private::Pair>::Second)> {\n+    fn next_pair\n+        (&mut self)\n+         -> Option<(<I::Item as private::Pair>::First, <I::Item as private::Pair>::Second)> {\n         match self.iter.next() {\n             Some(kv) => {\n                 self.count += 1;\n@@ -644,12 +627,12 @@ impl<I, E> de::Deserializer for MapDeserializer<I, E>\n           I::Item: private::Pair,\n           <I::Item as private::Pair>::First: ValueDeserializer<E>,\n           <I::Item as private::Pair>::Second: ValueDeserializer<E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Error = E;\n \n     fn deserialize<V_>(mut self, visitor: V_) -> Result<V_::Value, Self::Error>\n-        where V_: de::Visitor,\n+        where V_: de::Visitor\n     {\n         let value = try!(visitor.visit_map(&mut self));\n         try!(self.end());\n@@ -657,15 +640,18 @@ impl<I, E> de::Deserializer for MapDeserializer<I, E>\n     }\n \n     fn deserialize_seq<V_>(mut self, visitor: V_) -> Result<V_::Value, Self::Error>\n-        where V_: de::Visitor,\n+        where V_: de::Visitor\n     {\n         let value = try!(visitor.visit_seq(&mut self));\n         try!(self.end());\n         Ok(value)\n     }\n \n-    fn deserialize_seq_fixed_size<V_>(self, _len: usize, visitor: V_) -> Result<V_::Value, Self::Error>\n-        where V_: de::Visitor,\n+    fn deserialize_seq_fixed_size<V_>(self,\n+                                      _len: usize,\n+                                      visitor: V_)\n+                                      -> Result<V_::Value, Self::Error>\n+        where V_: de::Visitor\n     {\n         self.deserialize_seq(visitor)\n     }\n@@ -682,12 +668,12 @@ impl<I, E> de::MapVisitor for MapDeserializer<I, E>\n           I::Item: private::Pair,\n           <I::Item as private::Pair>::First: ValueDeserializer<E>,\n           <I::Item as private::Pair>::Second: ValueDeserializer<E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Error = E;\n \n     fn visit_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n-        where T: de::DeserializeSeed,\n+        where T: de::DeserializeSeed\n     {\n         match self.next_pair() {\n             Some((key, value)) => {\n@@ -699,7 +685,7 @@ impl<I, E> de::MapVisitor for MapDeserializer<I, E>\n     }\n \n     fn visit_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n-        where T: de::DeserializeSeed,\n+        where T: de::DeserializeSeed\n     {\n         let value = self.value.take();\n         // Panic because this indicates a bug in the program rather than an\n@@ -708,7 +694,10 @@ impl<I, E> de::MapVisitor for MapDeserializer<I, E>\n         seed.deserialize(value.into_deserializer())\n     }\n \n-    fn visit_seed<TK, TV>(&mut self, kseed: TK, vseed: TV) -> Result<Option<(TK::Value, TV::Value)>, Self::Error>\n+    fn visit_seed<TK, TV>(&mut self,\n+                          kseed: TK,\n+                          vseed: TV)\n+                          -> Result<Option<(TK::Value, TV::Value)>, Self::Error>\n         where TK: de::DeserializeSeed,\n               TV: de::DeserializeSeed\n     {\n@@ -718,7 +707,7 @@ impl<I, E> de::MapVisitor for MapDeserializer<I, E>\n                 let value = try!(vseed.deserialize(value.into_deserializer()));\n                 Ok(Some((key, value)))\n             }\n-            None => Ok(None)\n+            None => Ok(None),\n         }\n     }\n \n@@ -732,12 +721,12 @@ impl<I, E> de::SeqVisitor for MapDeserializer<I, E>\n           I::Item: private::Pair,\n           <I::Item as private::Pair>::First: ValueDeserializer<E>,\n           <I::Item as private::Pair>::Second: ValueDeserializer<E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Error = E;\n \n     fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n-        where T: de::DeserializeSeed,\n+        where T: de::DeserializeSeed\n     {\n         match self.next_pair() {\n             Some((k, v)) => {\n@@ -771,13 +760,13 @@ impl<A, B, E> de::Deserializer for PairDeserializer<A, B, E>\n     }\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+        where V: de::Visitor\n     {\n         self.deserialize_seq(visitor)\n     }\n \n     fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+        where V: de::Visitor\n     {\n         let mut pair_visitor = PairVisitor(Some(self.0), Some(self.1), PhantomData);\n         let pair = try!(visitor.visit_seq(&mut pair_visitor));\n@@ -792,7 +781,7 @@ impl<A, B, E> de::Deserializer for PairDeserializer<A, B, E>\n     }\n \n     fn deserialize_seq_fixed_size<V>(self, len: usize, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+        where V: de::Visitor\n     {\n         if len == 2 {\n             self.deserialize_seq(visitor)\n@@ -809,12 +798,12 @@ struct PairVisitor<A, B, E>(Option<A>, Option<B>, PhantomData<E>);\n impl<A, B, E> de::SeqVisitor for PairVisitor<A, B, E>\n     where A: ValueDeserializer<E>,\n           B: ValueDeserializer<E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Error = E;\n \n     fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n-        where T: de::DeserializeSeed,\n+        where T: de::DeserializeSeed\n     {\n         if let Some(k) = self.0.take() {\n             seed.deserialize(k.into_deserializer()).map(Some)\n@@ -855,7 +844,7 @@ impl Expected for ExpectedInMap {\n impl<K, V, E> ValueDeserializer<E> for BTreeMap<K, V>\n     where K: ValueDeserializer<E> + Eq + Ord,\n           V: ValueDeserializer<E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Deserializer = MapDeserializer<btree_map::IntoIter<K, V>, E>;\n \n@@ -868,7 +857,7 @@ impl<K, V, E> ValueDeserializer<E> for BTreeMap<K, V>\n impl<K, V, E> ValueDeserializer<E> for HashMap<K, V>\n     where K: ValueDeserializer<E> + Eq + Hash,\n           V: ValueDeserializer<E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Deserializer = MapDeserializer<hash_map::IntoIter<K, V>, E>;\n \n@@ -887,20 +876,20 @@ pub struct MapVisitorDeserializer<V_, E> {\n \n impl<V_, E> MapVisitorDeserializer<V_, E>\n     where V_: de::MapVisitor<Error = E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     /// Construct a new `MapVisitorDeserializer<V_, E>`.\n     pub fn new(visitor: V_) -> Self {\n-        MapVisitorDeserializer{\n+        MapVisitorDeserializer {\n             visitor: visitor,\n-            marker: PhantomData\n+            marker: PhantomData,\n         }\n     }\n }\n \n impl<V_, E> de::Deserializer for MapVisitorDeserializer<V_, E>\n     where V_: de::MapVisitor<Error = E>,\n-          E: de::Error,\n+          E: de::Error\n {\n     type Error = E;\n \n@@ -918,7 +907,7 @@ impl<V_, E> de::Deserializer for MapVisitorDeserializer<V_, E>\n ///////////////////////////////////////////////////////////////////////////////\n \n impl<'a, E> ValueDeserializer<E> for bytes::Bytes<'a>\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Deserializer = BytesDeserializer<'a, E>;\n \n@@ -942,7 +931,7 @@ impl<'a, E> de::Deserializer for BytesDeserializer<'a, E>\n     type Error = E;\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+        where V: de::Visitor\n     {\n         visitor.visit_bytes(self.value)\n     }\n@@ -958,7 +947,7 @@ impl<'a, E> de::Deserializer for BytesDeserializer<'a, E>\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<E> ValueDeserializer<E> for bytes::ByteBuf\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Deserializer = ByteBufDeserializer<E>;\n \n@@ -979,12 +968,12 @@ pub struct ByteBufDeserializer<E> {\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<E> de::Deserializer for ByteBufDeserializer<E>\n-    where E: de::Error,\n+    where E: de::Error\n {\n     type Error = E;\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: de::Visitor,\n+        where V: de::Visitor\n     {\n         visitor.visit_byte_buf(self.value)\n     }\n@@ -1020,14 +1009,12 @@ mod private {\n         }\n \n         fn visit_newtype_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>\n-            where T: de::DeserializeSeed,\n+            where T: de::DeserializeSeed\n         {\n             Err(de::Error::invalid_type(Unexpected::UnitVariant, &\"newtype variant\"))\n         }\n \n-        fn visit_tuple<V>(self,\n-                          _len: usize,\n-                          _visitor: V) -> Result<V::Value, Self::Error>\n+        fn visit_tuple<V>(self, _len: usize, _visitor: V) -> Result<V::Value, Self::Error>\n             where V: de::Visitor\n         {\n             Err(de::Error::invalid_type(Unexpected::UnitVariant, &\"tuple variant\"))\n@@ -1035,7 +1022,8 @@ mod private {\n \n         fn visit_struct<V>(self,\n                            _fields: &'static [&'static str],\n-                           _visitor: V) -> Result<V::Value, Self::Error>\n+                           _visitor: V)\n+                           -> Result<V::Value, Self::Error>\n             where V: de::Visitor\n         {\n             Err(de::Error::invalid_type(Unexpected::UnitVariant, &\"struct variant\"))\n@@ -1053,6 +1041,8 @@ mod private {\n     impl<A, B> Pair for (A, B) {\n         type First = A;\n         type Second = B;\n-        fn split(self) -> (A, B) { self }\n+        fn split(self) -> (A, B) {\n+            self\n+        }\n     }\n }\ndiff --git a/serde/src/error.rs b/serde/src/error.rs\nindex 6c411f847..fe91c28f7 100644\n--- a/serde/src/error.rs\n+++ b/serde/src/error.rs\n@@ -11,5 +11,7 @@ pub trait Error: Debug + Display {\n     fn description(&self) -> &str;\n \n     /// The lower-level cause of this error, if any.\n-    fn cause(&self) -> Option<&Error> { None }\n+    fn cause(&self) -> Option<&Error> {\n+        None\n+    }\n }\ndiff --git a/serde/src/iter.rs b/serde/src/iter.rs\nindex 24a6bf307..784fe9bcf 100644\n--- a/serde/src/iter.rs\n+++ b/serde/src/iter.rs\n@@ -4,13 +4,13 @@ use std::io;\n use std::iter::Peekable;\n \n /// Iterator over a byte stream that tracks the current position's line and column.\n-pub struct LineColIterator<Iter: Iterator<Item=io::Result<u8>>> {\n+pub struct LineColIterator<Iter: Iterator<Item = io::Result<u8>>> {\n     iter: Iter,\n     line: usize,\n     col: usize,\n }\n \n-impl<Iter: Iterator<Item=io::Result<u8>>> LineColIterator<Iter> {\n+impl<Iter: Iterator<Item = io::Result<u8>>> LineColIterator<Iter> {\n     /// Construct a new `LineColIterator<Iter>`.\n     pub fn new(iter: Iter) -> LineColIterator<Iter> {\n         LineColIterator {\n@@ -21,27 +21,39 @@ impl<Iter: Iterator<Item=io::Result<u8>>> LineColIterator<Iter> {\n     }\n \n     /// Report the current line inside the iterator.\n-    pub fn line(&self) -> usize { self.line }\n+    pub fn line(&self) -> usize {\n+        self.line\n+    }\n \n     /// Report the current column inside the iterator.\n-    pub fn col(&self) -> usize { self.col }\n+    pub fn col(&self) -> usize {\n+        self.col\n+    }\n \n     /// Gets a reference to the underlying iterator.\n-    pub fn get_ref(&self) -> &Iter { &self.iter }\n+    pub fn get_ref(&self) -> &Iter {\n+        &self.iter\n+    }\n \n     /// Gets a mutable reference to the underlying iterator.\n-    pub fn get_mut(&mut self) -> &mut Iter { &mut self.iter }\n+    pub fn get_mut(&mut self) -> &mut Iter {\n+        &mut self.iter\n+    }\n \n     /// Unwraps this `LineColIterator`, returning the underlying iterator.\n-    pub fn into_inner(self) -> Iter { self.iter }\n+    pub fn into_inner(self) -> Iter {\n+        self.iter\n+    }\n }\n \n-impl<Iter: Iterator<Item=io::Result<u8>>> LineColIterator<Peekable<Iter>> {\n+impl<Iter: Iterator<Item = io::Result<u8>>> LineColIterator<Peekable<Iter>> {\n     /// peeks at the next value\n-    pub fn peek(&mut self) -> Option<&io::Result<u8>> { self.iter.peek() }\n+    pub fn peek(&mut self) -> Option<&io::Result<u8>> {\n+        self.iter.peek()\n+    }\n }\n \n-impl<Iter: Iterator<Item=io::Result<u8>>> Iterator for LineColIterator<Iter> {\n+impl<Iter: Iterator<Item = io::Result<u8>>> Iterator for LineColIterator<Iter> {\n     type Item = io::Result<u8>;\n     fn next(&mut self) -> Option<io::Result<u8>> {\n         match self.iter.next() {\n@@ -50,11 +62,11 @@ impl<Iter: Iterator<Item=io::Result<u8>>> Iterator for LineColIterator<Iter> {\n                 self.line += 1;\n                 self.col = 0;\n                 Some(Ok(b'\\n'))\n-            },\n+            }\n             Some(Ok(c)) => {\n                 self.col += 1;\n                 Some(Ok(c))\n-            },\n+            }\n             Some(Err(e)) => Some(Err(e)),\n         }\n     }\ndiff --git a/serde/src/lib.rs b/serde/src/lib.rs\nindex 467a22669..9560ecb6e 100644\n--- a/serde/src/lib.rs\n+++ b/serde/src/lib.rs\n@@ -79,7 +79,7 @@ extern crate core as actual_core;\n #[cfg(feature = \"std\")]\n mod core {\n     pub use std::{ops, hash, fmt, cmp, marker, mem, i8, i16, i32, i64, u8, u16, u32, u64, isize,\n-            usize, f32, f64, char, str, num, slice, iter, cell, default, result, option};\n+                  usize, f32, f64, char, str, num, slice, iter, cell, default, result, option};\n     #[cfg(feature = \"unstable\")]\n     pub use actual_core::nonzero;\n }\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex f54161fac..745903fae 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -4,25 +4,9 @@ use std::borrow::Cow;\n use collections::borrow::Cow;\n \n #[cfg(feature = \"std\")]\n-use std::collections::{\n-    BinaryHeap,\n-    BTreeMap,\n-    BTreeSet,\n-    LinkedList,\n-    HashMap,\n-    HashSet,\n-    VecDeque,\n-};\n+use std::collections::{BinaryHeap, BTreeMap, BTreeSet, LinkedList, HashMap, HashSet, VecDeque};\n #[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n-use collections::{\n-    BinaryHeap,\n-    BTreeMap,\n-    BTreeSet,\n-    LinkedList,\n-    VecDeque,\n-    String,\n-    Vec,\n-};\n+use collections::{BinaryHeap, BTreeMap, BTreeSet, LinkedList, VecDeque, String, Vec};\n \n #[cfg(feature = \"collections\")]\n use collections::borrow::ToOwned;\n@@ -57,12 +41,7 @@ use core::marker::PhantomData;\n #[cfg(feature = \"unstable\")]\n use core::nonzero::{NonZero, Zeroable};\n \n-use super::{\n-    Serialize,\n-    SerializeSeq,\n-    SerializeTuple,\n-    Serializer,\n-};\n+use super::{Serialize, SerializeSeq, SerializeTuple, Serializer};\n #[cfg(feature = \"std\")]\n use super::Error;\n \n@@ -101,7 +80,7 @@ impl_visit!(char, serialize_char);\n impl Serialize for str {\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         serializer.serialize_str(self)\n     }\n@@ -111,7 +90,7 @@ impl Serialize for str {\n impl Serialize for String {\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         (&self[..]).serialize(serializer)\n     }\n@@ -124,7 +103,7 @@ impl<T> Serialize for Option<T>\n {\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         match *self {\n             Some(ref value) => serializer.serialize_some(value),\n@@ -138,7 +117,7 @@ impl<T> Serialize for Option<T>\n impl<T> Serialize for PhantomData<T> {\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         serializer.serialize_unit_struct(\"PhantomData\")\n     }\n@@ -211,7 +190,7 @@ macro_rules! serialize_seq {\n }\n \n impl<T> Serialize for [T]\n-    where T: Serialize,\n+    where T: Serialize\n {\n     serialize_seq!();\n }\n@@ -225,7 +204,7 @@ impl<T> Serialize for BinaryHeap<T>\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<T> Serialize for BTreeSet<T>\n-    where T: Serialize + Ord,\n+    where T: Serialize + Ord\n {\n     serialize_seq!();\n }\n@@ -233,14 +212,14 @@ impl<T> Serialize for BTreeSet<T>\n #[cfg(feature = \"std\")]\n impl<T, H> Serialize for HashSet<T, H>\n     where T: Serialize + Eq + Hash,\n-          H: BuildHasher,\n+          H: BuildHasher\n {\n     serialize_seq!();\n }\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<T> Serialize for LinkedList<T>\n-    where T: Serialize,\n+    where T: Serialize\n {\n     serialize_seq!();\n }\n@@ -262,11 +241,11 @@ impl<T> Serialize for VecDeque<T>\n #[cfg(feature = \"unstable\")]\n impl<A> Serialize for ops::Range<A>\n     where ops::Range<A>: ExactSizeIterator + iter::Iterator<Item = A> + Clone,\n-          A: Serialize,\n+          A: Serialize\n {\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         let mut seq = try!(serializer.serialize_seq(Some(self.len())));\n         for e in self.clone() {\n@@ -279,11 +258,11 @@ impl<A> Serialize for ops::Range<A>\n #[cfg(feature = \"unstable\")]\n impl<A> Serialize for ops::RangeInclusive<A>\n     where ops::RangeInclusive<A>: ExactSizeIterator + iter::Iterator<Item = A> + Clone,\n-          A: Serialize,\n+          A: Serialize\n {\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         let mut seq = try!(serializer.serialize_seq(Some(self.len())));\n         for e in self.clone() {\n@@ -298,7 +277,7 @@ impl<A> Serialize for ops::RangeInclusive<A>\n impl Serialize for () {\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         serializer.serialize_unit()\n     }\n@@ -518,7 +497,7 @@ macro_rules! serialize_map {\n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n impl<K, V> Serialize for BTreeMap<K, V>\n     where K: Serialize + Ord,\n-          V: Serialize,\n+          V: Serialize\n {\n     serialize_map!();\n }\n@@ -527,26 +506,30 @@ impl<K, V> Serialize for BTreeMap<K, V>\n impl<K, V, H> Serialize for HashMap<K, V, H>\n     where K: Serialize + Eq + Hash,\n           V: Serialize,\n-          H: BuildHasher,\n+          H: BuildHasher\n {\n     serialize_map!();\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-impl<'a, T: ?Sized> Serialize for &'a T where T: Serialize {\n+impl<'a, T: ?Sized> Serialize for &'a T\n+    where T: Serialize\n+{\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         (**self).serialize(serializer)\n     }\n }\n \n-impl<'a, T: ?Sized> Serialize for &'a mut T where T: Serialize {\n+impl<'a, T: ?Sized> Serialize for &'a mut T\n+    where T: Serialize\n+{\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         (**self).serialize(serializer)\n     }\n@@ -558,7 +541,7 @@ impl<T: ?Sized> Serialize for Box<T>\n {\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         (**self).serialize(serializer)\n     }\n@@ -570,7 +553,7 @@ impl<T> Serialize for Rc<T>\n {\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         (**self).serialize(serializer)\n     }\n@@ -582,7 +565,7 @@ impl<T> Serialize for Arc<T>\n {\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         (**self).serialize(serializer)\n     }\n@@ -594,7 +577,7 @@ impl<'a, T: ?Sized> Serialize for Cow<'a, T>\n {\n     #[inline]\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         (**self).serialize(serializer)\n     }\n@@ -610,9 +593,7 @@ impl<T, E> Serialize for Result<T, E>\n         where S: Serializer\n     {\n         match *self {\n-            Result::Ok(ref value) => {\n-                serializer.serialize_newtype_variant(\"Result\", 0, \"Ok\", value)\n-            }\n+            Result::Ok(ref value) => serializer.serialize_newtype_variant(\"Result\", 0, \"Ok\", value),\n             Result::Err(ref value) => {\n                 serializer.serialize_newtype_variant(\"Result\", 1, \"Err\", value)\n             }\n@@ -625,7 +606,7 @@ impl<T, E> Serialize for Result<T, E>\n #[cfg(feature = \"std\")]\n impl Serialize for Duration {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         use super::SerializeStruct;\n         let mut state = try!(serializer.serialize_struct(\"Duration\", 2));\n@@ -640,7 +621,7 @@ impl Serialize for Duration {\n #[cfg(feature = \"std\")]\n impl Serialize for net::IpAddr {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         self.to_string().serialize(serializer)\n     }\n@@ -649,7 +630,7 @@ impl Serialize for net::IpAddr {\n #[cfg(feature = \"std\")]\n impl Serialize for net::Ipv4Addr {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         self.to_string().serialize(serializer)\n     }\n@@ -658,7 +639,7 @@ impl Serialize for net::Ipv4Addr {\n #[cfg(feature = \"std\")]\n impl Serialize for net::Ipv6Addr {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         self.to_string().serialize(serializer)\n     }\n@@ -669,7 +650,7 @@ impl Serialize for net::Ipv6Addr {\n #[cfg(feature = \"std\")]\n impl Serialize for net::SocketAddr {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         match *self {\n             net::SocketAddr::V4(ref addr) => addr.serialize(serializer),\n@@ -681,7 +662,7 @@ impl Serialize for net::SocketAddr {\n #[cfg(feature = \"std\")]\n impl Serialize for net::SocketAddrV4 {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         self.to_string().serialize(serializer)\n     }\n@@ -690,7 +671,7 @@ impl Serialize for net::SocketAddrV4 {\n #[cfg(feature = \"std\")]\n impl Serialize for net::SocketAddrV6 {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         self.to_string().serialize(serializer)\n     }\n@@ -701,7 +682,7 @@ impl Serialize for net::SocketAddrV6 {\n #[cfg(feature = \"std\")]\n impl Serialize for path::Path {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         match self.to_str() {\n             Some(s) => s.serialize(serializer),\n@@ -713,7 +694,7 @@ impl Serialize for path::Path {\n #[cfg(feature = \"std\")]\n impl Serialize for path::PathBuf {\n     fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer,\n+        where S: Serializer\n     {\n         self.as_path().serialize(serializer)\n     }\ndiff --git a/serde/src/ser/impossible.rs b/serde/src/ser/impossible.rs\nindex 8c9bf40d6..6b8e7c28b 100644\n--- a/serde/src/ser/impossible.rs\n+++ b/serde/src/ser/impossible.rs\n@@ -2,17 +2,8 @@\n \n use core::marker::PhantomData;\n \n-use ser::{\n-    self,\n-    Serialize,\n-    SerializeSeq,\n-    SerializeTuple,\n-    SerializeTupleStruct,\n-    SerializeTupleVariant,\n-    SerializeMap,\n-    SerializeStruct,\n-    SerializeStructVariant,\n-};\n+use ser::{self, Serialize, SerializeSeq, SerializeTuple, SerializeTupleStruct,\n+          SerializeTupleVariant, SerializeMap, SerializeStruct, SerializeStructVariant};\n \n /// Helper type for implementing a `Serializer` that does not support\n /// serializing one of the compound types.\n@@ -50,14 +41,12 @@ pub struct Impossible<Ok, E> {\n enum Void {}\n \n impl<Ok, E> SerializeSeq for Impossible<Ok, E>\n-    where E: ser::Error,\n+    where E: ser::Error\n {\n     type Ok = Ok;\n     type Error = E;\n \n-    fn serialize_element<T: ?Sized + Serialize>(&mut self,\n-                                                _value: &T)\n-                                                -> Result<(), E> {\n+    fn serialize_element<T: ?Sized + Serialize>(&mut self, _value: &T) -> Result<(), E> {\n         match self.void {}\n     }\n \n@@ -67,14 +56,12 @@ impl<Ok, E> SerializeSeq for Impossible<Ok, E>\n }\n \n impl<Ok, E> SerializeTuple for Impossible<Ok, E>\n-    where E: ser::Error,\n+    where E: ser::Error\n {\n     type Ok = Ok;\n     type Error = E;\n \n-    fn serialize_element<T: ?Sized + Serialize>(&mut self,\n-                                                _value: &T)\n-                                                -> Result<(), E> {\n+    fn serialize_element<T: ?Sized + Serialize>(&mut self, _value: &T) -> Result<(), E> {\n         match self.void {}\n     }\n \n@@ -84,14 +71,12 @@ impl<Ok, E> SerializeTuple for Impossible<Ok, E>\n }\n \n impl<Ok, E> SerializeTupleStruct for Impossible<Ok, E>\n-    where E: ser::Error,\n+    where E: ser::Error\n {\n     type Ok = Ok;\n     type Error = E;\n \n-    fn serialize_field<T: ?Sized + Serialize>(&mut self,\n-                                              _value: &T)\n-                                              -> Result<(), E> {\n+    fn serialize_field<T: ?Sized + Serialize>(&mut self, _value: &T) -> Result<(), E> {\n         match self.void {}\n     }\n \n@@ -101,14 +86,12 @@ impl<Ok, E> SerializeTupleStruct for Impossible<Ok, E>\n }\n \n impl<Ok, E> SerializeTupleVariant for Impossible<Ok, E>\n-    where E: ser::Error,\n+    where E: ser::Error\n {\n     type Ok = Ok;\n     type Error = E;\n \n-    fn serialize_field<T: ?Sized + Serialize>(&mut self,\n-                                              _value: &T)\n-                                              -> Result<(), E> {\n+    fn serialize_field<T: ?Sized + Serialize>(&mut self, _value: &T) -> Result<(), E> {\n         match self.void {}\n     }\n \n@@ -118,20 +101,16 @@ impl<Ok, E> SerializeTupleVariant for Impossible<Ok, E>\n }\n \n impl<Ok, E> SerializeMap for Impossible<Ok, E>\n-    where E: ser::Error,\n+    where E: ser::Error\n {\n     type Ok = Ok;\n     type Error = E;\n \n-    fn serialize_key<T: ?Sized + Serialize>(&mut self,\n-                                                 _key: &T)\n-                                            -> Result<(), E> {\n+    fn serialize_key<T: ?Sized + Serialize>(&mut self, _key: &T) -> Result<(), E> {\n         match self.void {}\n     }\n \n-    fn serialize_value<T: ?Sized + Serialize>(&mut self,\n-                                              _value: &T)\n-                                              -> Result<(), E> {\n+    fn serialize_value<T: ?Sized + Serialize>(&mut self, _value: &T) -> Result<(), E> {\n         match self.void {}\n     }\n \n@@ -141,13 +120,13 @@ impl<Ok, E> SerializeMap for Impossible<Ok, E>\n }\n \n impl<Ok, E> SerializeStruct for Impossible<Ok, E>\n-    where E: ser::Error,\n+    where E: ser::Error\n {\n     type Ok = Ok;\n     type Error = E;\n \n     fn serialize_field<T: ?Sized + Serialize>(&mut self,\n-                                                   _key: &'static str,\n+                                              _key: &'static str,\n                                               _value: &T)\n                                               -> Result<(), E> {\n         match self.void {}\n@@ -159,13 +138,13 @@ impl<Ok, E> SerializeStruct for Impossible<Ok, E>\n }\n \n impl<Ok, E> SerializeStructVariant for Impossible<Ok, E>\n-    where E: ser::Error,\n+    where E: ser::Error\n {\n     type Ok = Ok;\n     type Error = E;\n \n     fn serialize_field<T: ?Sized + Serialize>(&mut self,\n-                                                   _key: &'static str,\n+                                              _key: &'static str,\n                                               _value: &T)\n                                               -> Result<(), E> {\n         match self.void {}\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 331928a36..369d68b6c 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -174,8 +174,7 @@ pub trait Serialize {\n     /// for more information about how to implement this method.\n     ///\n     /// [impl-serialize]: https://serde.rs/impl-serialize.html\n-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-        where S: Serializer;\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer;\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -254,31 +253,31 @@ pub trait Serializer: Sized {\n \n     /// Type returned from `serialize_seq` and `serialize_seq_fixed_size` for\n     /// serializing the content of the sequence.\n-    type SerializeSeq: SerializeSeq<Ok=Self::Ok, Error=Self::Error>;\n+    type SerializeSeq: SerializeSeq<Ok = Self::Ok, Error = Self::Error>;\n \n     /// Type returned from `serialize_tuple` for serializing the content of the\n     /// tuple.\n-    type SerializeTuple: SerializeTuple<Ok=Self::Ok, Error=Self::Error>;\n+    type SerializeTuple: SerializeTuple<Ok = Self::Ok, Error = Self::Error>;\n \n     /// Type returned from `serialize_tuple_struct` for serializing the content\n     /// of the tuple struct.\n-    type SerializeTupleStruct: SerializeTupleStruct<Ok=Self::Ok, Error=Self::Error>;\n+    type SerializeTupleStruct: SerializeTupleStruct<Ok = Self::Ok, Error = Self::Error>;\n \n     /// Type returned from `serialize_tuple_variant` for serializing the content\n     /// of the tuple variant.\n-    type SerializeTupleVariant: SerializeTupleVariant<Ok=Self::Ok, Error=Self::Error>;\n+    type SerializeTupleVariant: SerializeTupleVariant<Ok = Self::Ok, Error = Self::Error>;\n \n     /// Type returned from `serialize_map` for serializing the content of the\n     /// map.\n-    type SerializeMap: SerializeMap<Ok=Self::Ok, Error=Self::Error>;\n+    type SerializeMap: SerializeMap<Ok = Self::Ok, Error = Self::Error>;\n \n     /// Type returned from `serialize_struct` for serializing the content of the\n     /// struct.\n-    type SerializeStruct: SerializeStruct<Ok=Self::Ok, Error=Self::Error>;\n+    type SerializeStruct: SerializeStruct<Ok = Self::Ok, Error = Self::Error>;\n \n     /// Type returned from `serialize_struct_variant` for serializing the\n     /// content of the struct variant.\n-    type SerializeStructVariant: SerializeStructVariant<Ok=Self::Ok, Error=Self::Error>;\n+    type SerializeStructVariant: SerializeStructVariant<Ok = Self::Ok, Error = Self::Error>;\n \n     /// Serialize a `bool` value.\n     fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error>;\n@@ -371,10 +370,7 @@ pub trait Serializer: Sized {\n     fn serialize_none(self) -> Result<Self::Ok, Self::Error>;\n \n     /// Serialize a `Some(T)` value.\n-    fn serialize_some<T: ?Sized + Serialize>(\n-        self,\n-        value: &T,\n-    ) -> Result<Self::Ok, Self::Error>;\n+    fn serialize_some<T: ?Sized + Serialize>(self, value: &T) -> Result<Self::Ok, Self::Error>;\n \n     /// Serialize a `()` value.\n     fn serialize_unit(self) -> Result<Self::Ok, Self::Error>;\n@@ -382,10 +378,7 @@ pub trait Serializer: Sized {\n     /// Serialize a unit struct like `struct Unit` or `PhantomData<T>`.\n     ///\n     /// A reasonable implementation would be to forward to `serialize_unit`.\n-    fn serialize_unit_struct(\n-        self,\n-        name: &'static str,\n-    ) -> Result<Self::Ok, Self::Error>;\n+    fn serialize_unit_struct(self, name: &'static str) -> Result<Self::Ok, Self::Error>;\n \n     /// Serialize a unit variant like `E::A` in `enum E { A, B }`.\n     ///\n@@ -401,12 +394,11 @@ pub trait Serializer: Sized {\n     ///     E::B => serializer.serialize_unit_variant(\"E\", 1, \"B\"),\n     /// }\n     /// ```\n-    fn serialize_unit_variant(\n-        self,\n-        name: &'static str,\n-        variant_index: usize,\n-        variant: &'static str,\n-    ) -> Result<Self::Ok, Self::Error>;\n+    fn serialize_unit_variant(self,\n+                              name: &'static str,\n+                              variant_index: usize,\n+                              variant: &'static str)\n+                              -> Result<Self::Ok, Self::Error>;\n \n     /// Serialize a newtype struct like `struct Millimeters(u8)`.\n     ///\n@@ -417,11 +409,10 @@ pub trait Serializer: Sized {\n     /// ```rust,ignore\n     /// serializer.serialize_newtype_struct(\"Millimeters\", &self.0)\n     /// ```\n-    fn serialize_newtype_struct<T: ?Sized + Serialize>(\n-        self,\n-        name: &'static str,\n-        value: &T,\n-    ) -> Result<Self::Ok, Self::Error>;\n+    fn serialize_newtype_struct<T: ?Sized + Serialize>(self,\n+                                                       name: &'static str,\n+                                                       value: &T)\n+                                                       -> Result<Self::Ok, Self::Error>;\n \n     /// Serialize a newtype variant like `E::N` in `enum E { N(u8) }`.\n     ///\n@@ -434,13 +425,12 @@ pub trait Serializer: Sized {\n     ///     E::N(ref n) => serializer.serialize_newtype_variant(\"E\", 0, \"N\", n),\n     /// }\n     /// ```\n-    fn serialize_newtype_variant<T: ?Sized + Serialize>(\n-        self,\n-        name: &'static str,\n-        variant_index: usize,\n-        variant: &'static str,\n-        value: &T,\n-    ) -> Result<Self::Ok, Self::Error>;\n+    fn serialize_newtype_variant<T: ?Sized + Serialize>(self,\n+                                                        name: &'static str,\n+                                                        variant_index: usize,\n+                                                        variant: &'static str,\n+                                                        value: &T)\n+                                                        -> Result<Self::Ok, Self::Error>;\n \n     /// Begin to serialize a dynamically sized sequence. This call must be\n     /// followed by zero or more calls to `serialize_element`, then a call to\n@@ -457,10 +447,7 @@ pub trait Serializer: Sized {\n     /// }\n     /// seq.end()\n     /// ```\n-    fn serialize_seq(\n-        self,\n-        len: Option<usize>,\n-    ) -> Result<Self::SerializeSeq, Self::Error>;\n+    fn serialize_seq(self, len: Option<usize>) -> Result<Self::SerializeSeq, Self::Error>;\n \n     /// Begin to serialize a statically sized sequence whose length will be\n     /// known at deserialization time without looking at the serialized data.\n@@ -474,10 +461,7 @@ pub trait Serializer: Sized {\n     /// }\n     /// seq.end()\n     /// ```\n-    fn serialize_seq_fixed_size(\n-        self,\n-        size: usize,\n-    ) -> Result<Self::SerializeSeq, Self::Error>;\n+    fn serialize_seq_fixed_size(self, size: usize) -> Result<Self::SerializeSeq, Self::Error>;\n \n     /// Begin to serialize a tuple. This call must be followed by zero or more\n     /// calls to `serialize_field`, then a call to `end`.\n@@ -489,10 +473,7 @@ pub trait Serializer: Sized {\n     /// tup.serialize_field(&self.2)?;\n     /// tup.end()\n     /// ```\n-    fn serialize_tuple(\n-        self,\n-        len: usize,\n-    ) -> Result<Self::SerializeTuple, Self::Error>;\n+    fn serialize_tuple(self, len: usize) -> Result<Self::SerializeTuple, Self::Error>;\n \n     /// Begin to serialize a tuple struct like `struct Rgb(u8, u8, u8)`. This\n     /// call must be followed by zero or more calls to `serialize_field`, then a\n@@ -508,11 +489,10 @@ pub trait Serializer: Sized {\n     /// ts.serialize_field(&self.2)?;\n     /// ts.end()\n     /// ```\n-    fn serialize_tuple_struct(\n-        self,\n-        name: &'static str,\n-        len: usize,\n-    ) -> Result<Self::SerializeTupleStruct, Self::Error>;\n+    fn serialize_tuple_struct(self,\n+                              name: &'static str,\n+                              len: usize)\n+                              -> Result<Self::SerializeTupleStruct, Self::Error>;\n \n     /// Begin to serialize a tuple variant like `E::T` in `enum E { T(u8, u8)\n     /// }`. This call must be followed by zero or more calls to\n@@ -532,13 +512,12 @@ pub trait Serializer: Sized {\n     ///     }\n     /// }\n     /// ```\n-    fn serialize_tuple_variant(\n-        self,\n-        name: &'static str,\n-        variant_index: usize,\n-        variant: &'static str,\n-        len: usize,\n-    ) -> Result<Self::SerializeTupleVariant, Self::Error>;\n+    fn serialize_tuple_variant(self,\n+                               name: &'static str,\n+                               variant_index: usize,\n+                               variant: &'static str,\n+                               len: usize)\n+                               -> Result<Self::SerializeTupleVariant, Self::Error>;\n \n     /// Begin to serialize a map. This call must be followed by zero or more\n     /// calls to `serialize_key` and `serialize_value`, then a call to `end`.\n@@ -554,10 +533,7 @@ pub trait Serializer: Sized {\n     /// }\n     /// map.end()\n     /// ```\n-    fn serialize_map(\n-        self,\n-        len: Option<usize>,\n-    ) -> Result<Self::SerializeMap, Self::Error>;\n+    fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, Self::Error>;\n \n     /// Begin to serialize a struct like `struct Rgb { r: u8, g: u8, b: u8 }`.\n     /// This call must be followed by zero or more calls to `serialize_field`,\n@@ -573,11 +549,10 @@ pub trait Serializer: Sized {\n     /// struc.serialize_field(\"b\", &self.b)?;\n     /// struc.end()\n     /// ```\n-    fn serialize_struct(\n-        self,\n-        name: &'static str,\n-        len: usize,\n-    ) -> Result<Self::SerializeStruct, Self::Error>;\n+    fn serialize_struct(self,\n+                        name: &'static str,\n+                        len: usize)\n+                        -> Result<Self::SerializeStruct, Self::Error>;\n \n     /// Begin to serialize a struct variant like `E::S` in `enum E { S { r: u8,\n     /// g: u8, b: u8 } }`. This call must be followed by zero or more calls to\n@@ -598,13 +573,12 @@ pub trait Serializer: Sized {\n     ///     }\n     /// }\n     /// ```\n-    fn serialize_struct_variant(\n-        self,\n-        name: &'static str,\n-        variant_index: usize,\n-        variant: &'static str,\n-        len: usize,\n-    ) -> Result<Self::SerializeStructVariant, Self::Error>;\n+    fn serialize_struct_variant(self,\n+                                name: &'static str,\n+                                variant_index: usize,\n+                                variant: &'static str,\n+                                len: usize)\n+                                -> Result<Self::SerializeStructVariant, Self::Error>;\n \n     /// Collect an iterator as a sequence.\n     ///\n@@ -613,7 +587,7 @@ pub trait Serializer: Sized {\n     /// this method.\n     fn collect_seq<I>(self, iter: I) -> Result<Self::Ok, Self::Error>\n         where I: IntoIterator,\n-              <I as IntoIterator>::Item: Serialize,\n+              <I as IntoIterator>::Item: Serialize\n     {\n         let iter = iter.into_iter();\n         let mut serializer = try!(self.serialize_seq(iter.len_hint()));\n@@ -631,7 +605,7 @@ pub trait Serializer: Sized {\n     fn collect_map<K, V, I>(self, iter: I) -> Result<Self::Ok, Self::Error>\n         where K: Serialize,\n               V: Serialize,\n-              I: IntoIterator<Item = (K, V)>,\n+              I: IntoIterator<Item = (K, V)>\n     {\n         let iter = iter.into_iter();\n         let mut serializer = try!(self.serialize_map(iter.len_hint()));\n@@ -773,11 +747,10 @@ pub trait SerializeMap {\n     /// `serialize_value`. This is appropriate for serializers that do not care\n     /// about performance or are not able to optimize `serialize_entry` any\n     /// better than this.\n-    fn serialize_entry<K: ?Sized + Serialize, V: ?Sized + Serialize>(\n-        &mut self,\n-        key: &K,\n-        value: &V,\n-    ) -> Result<(), Self::Error> {\n+    fn serialize_entry<K: ?Sized + Serialize, V: ?Sized + Serialize>(&mut self,\n+                                                                     key: &K,\n+                                                                     value: &V)\n+                                                                     -> Result<(), Self::Error> {\n         try!(self.serialize_key(key));\n         self.serialize_value(value)\n     }\n@@ -803,7 +776,10 @@ pub trait SerializeStruct {\n     type Error: Error;\n \n     /// Serialize a struct field.\n-    fn serialize_field<T: ?Sized + Serialize>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>;\n+    fn serialize_field<T: ?Sized + Serialize>(&mut self,\n+                                              key: &'static str,\n+                                              value: &T)\n+                                              -> Result<(), Self::Error>;\n \n     /// Finish serializing a struct.\n     fn end(self) -> Result<Self::Ok, Self::Error>;\n@@ -830,7 +806,10 @@ pub trait SerializeStructVariant {\n     type Error: Error;\n \n     /// Serialize a struct variant field.\n-    fn serialize_field<T: ?Sized + Serialize>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>;\n+    fn serialize_field<T: ?Sized + Serialize>(&mut self,\n+                                              key: &'static str,\n+                                              value: &T)\n+                                              -> Result<(), Self::Error>;\n \n     /// Finish serializing a struct variant.\n     fn end(self) -> Result<Self::Ok, Self::Error>;\ndiff --git a/serde/src/ser/private.rs b/serde/src/ser/private.rs\nindex 9d17ec789..9ee926840 100644\n--- a/serde/src/ser/private.rs\n+++ b/serde/src/ser/private.rs\n@@ -3,14 +3,13 @@ use core::fmt::{self, Display};\n use ser::{self, Serialize, Serializer, SerializeMap, SerializeStruct};\n \n /// Not public API.\n-pub fn serialize_tagged_newtype<S, T>(\n-    serializer: S,\n-    type_ident: &'static str,\n-    variant_ident: &'static str,\n-    tag: &'static str,\n-    variant_name: &'static str,\n-    value: T,\n-) -> Result<S::Ok, S::Error>\n+pub fn serialize_tagged_newtype<S, T>(serializer: S,\n+                                      type_ident: &'static str,\n+                                      variant_ident: &'static str,\n+                                      tag: &'static str,\n+                                      variant_name: &'static str,\n+                                      value: T)\n+                                      -> Result<S::Ok, S::Error>\n     where S: Serializer,\n           T: Serialize\n {\n@@ -181,17 +180,29 @@ impl<S> Serializer for TaggedSerializer<S>\n         Err(self.bad_type(Unsupported::UnitStruct))\n     }\n \n-    fn serialize_unit_variant(self, _: &'static str, _: usize, _: &'static str) -> Result<Self::Ok, Self::Error> {\n+    fn serialize_unit_variant(self,\n+                              _: &'static str,\n+                              _: usize,\n+                              _: &'static str)\n+                              -> Result<Self::Ok, Self::Error> {\n         Err(self.bad_type(Unsupported::Enum))\n     }\n \n-    fn serialize_newtype_struct<T: ?Sized>(self, _: &'static str, value: &T) -> Result<Self::Ok, Self::Error>\n+    fn serialize_newtype_struct<T: ?Sized>(self,\n+                                           _: &'static str,\n+                                           value: &T)\n+                                           -> Result<Self::Ok, Self::Error>\n         where T: Serialize\n     {\n         value.serialize(self)\n     }\n \n-    fn serialize_newtype_variant<T: ?Sized>(self, _: &'static str, _: usize, _: &'static str, _: &T) -> Result<Self::Ok, Self::Error>\n+    fn serialize_newtype_variant<T: ?Sized>(self,\n+                                            _: &'static str,\n+                                            _: usize,\n+                                            _: &'static str,\n+                                            _: &T)\n+                                            -> Result<Self::Ok, Self::Error>\n         where T: Serialize\n     {\n         Err(self.bad_type(Unsupported::Enum))\n@@ -209,11 +220,19 @@ impl<S> Serializer for TaggedSerializer<S>\n         Err(self.bad_type(Unsupported::Tuple))\n     }\n \n-    fn serialize_tuple_struct(self, _: &'static str, _: usize) -> Result<Self::SerializeTupleStruct, Self::Error> {\n+    fn serialize_tuple_struct(self,\n+                              _: &'static str,\n+                              _: usize)\n+                              -> Result<Self::SerializeTupleStruct, Self::Error> {\n         Err(self.bad_type(Unsupported::TupleStruct))\n     }\n \n-    fn serialize_tuple_variant(self, _: &'static str, _: usize, _: &'static str, _: usize) -> Result<Self::SerializeTupleVariant, Self::Error> {\n+    fn serialize_tuple_variant(self,\n+                               _: &'static str,\n+                               _: usize,\n+                               _: &'static str,\n+                               _: usize)\n+                               -> Result<Self::SerializeTupleVariant, Self::Error> {\n         Err(self.bad_type(Unsupported::Enum))\n     }\n \n@@ -223,13 +242,21 @@ impl<S> Serializer for TaggedSerializer<S>\n         Ok(map)\n     }\n \n-    fn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct, Self::Error> {\n+    fn serialize_struct(self,\n+                        name: &'static str,\n+                        len: usize)\n+                        -> Result<Self::SerializeStruct, Self::Error> {\n         let mut state = try!(self.delegate.serialize_struct(name, len + 1));\n         try!(state.serialize_field(self.tag, self.variant_name));\n         Ok(state)\n     }\n \n-    fn serialize_struct_variant(self, _: &'static str, _: usize, _: &'static str, _: usize) -> Result<Self::SerializeStructVariant, Self::Error> {\n+    fn serialize_struct_variant(self,\n+                                _: &'static str,\n+                                _: usize,\n+                                _: &'static str,\n+                                _: usize)\n+                                -> Result<Self::SerializeStructVariant, Self::Error> {\n         Err(self.bad_type(Unsupported::Enum))\n     }\n }\ndiff --git a/serde/src/utils.rs b/serde/src/utils.rs\nindex 708eb4274..7df7b6cf2 100644\n--- a/serde/src/utils.rs\n+++ b/serde/src/utils.rs\n@@ -1,12 +1,12 @@\n //! Private utility functions\n \n-const TAG_CONT: u8    = 0b1000_0000;\n-const TAG_TWO_B: u8   = 0b1100_0000;\n+const TAG_CONT: u8 = 0b1000_0000;\n+const TAG_TWO_B: u8 = 0b1100_0000;\n const TAG_THREE_B: u8 = 0b1110_0000;\n-const TAG_FOUR_B: u8  = 0b1111_0000;\n-const MAX_ONE_B: u32   =     0x80;\n-const MAX_TWO_B: u32   =    0x800;\n-const MAX_THREE_B: u32 =  0x10000;\n+const TAG_FOUR_B: u8 = 0b1111_0000;\n+const MAX_ONE_B: u32 = 0x80;\n+const MAX_TWO_B: u32 = 0x800;\n+const MAX_THREE_B: u32 = 0x10000;\n \n #[inline]\n pub fn encode_utf8(c: char) -> EncodeUtf8 {\n@@ -21,17 +21,20 @@ pub fn encode_utf8(c: char) -> EncodeUtf8 {\n         2\n     } else if code < MAX_THREE_B {\n         buf[1] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-        buf[2] = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+        buf[2] = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n         buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n         1\n     } else {\n         buf[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n         buf[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-        buf[2] = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+        buf[2] = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n         buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n         0\n     };\n-    EncodeUtf8 { buf: buf, pos: pos }\n+    EncodeUtf8 {\n+        buf: buf,\n+        pos: pos,\n+    }\n }\n \n pub struct EncodeUtf8 {\n@@ -47,23 +50,22 @@ impl EncodeUtf8 {\n }\n \n #[allow(non_upper_case_globals)]\n-const Pattern_White_Space_table: &'static [(char, char)] = &[\n-    ('\\u{9}', '\\u{d}'), ('\\u{20}', '\\u{20}'), ('\\u{85}', '\\u{85}'), ('\\u{200e}', '\\u{200f}'),\n-    ('\\u{2028}', '\\u{2029}')\n-];\n+const Pattern_White_Space_table: &'static [(char, char)] = &[('\\u{9}', '\\u{d}'),\n+                                                             ('\\u{20}', '\\u{20}'),\n+                                                             ('\\u{85}', '\\u{85}'),\n+                                                             ('\\u{200e}', '\\u{200f}'),\n+                                                             ('\\u{2028}', '\\u{2029}')];\n \n fn bsearch_range_table(c: char, r: &'static [(char, char)]) -> bool {\n     use core::cmp::Ordering::{Equal, Less, Greater};\n-    r.binary_search_by(|&(lo, hi)| {\n-        if c < lo {\n+    r.binary_search_by(|&(lo, hi)| if c < lo {\n             Greater\n         } else if hi < c {\n             Less\n         } else {\n             Equal\n-        }\n-    })\n-    .is_ok()\n+        })\n+        .is_ok()\n }\n \n #[allow(non_snake_case)]\ndiff --git a/serde_codegen_internals/src/ast.rs b/serde_codegen_internals/src/ast.rs\nindex 2941c1641..ea598d80a 100644\n--- a/serde_codegen_internals/src/ast.rs\n+++ b/serde_codegen_internals/src/ast.rs\n@@ -39,9 +39,7 @@ impl<'a> Item<'a> {\n         let attrs = attr::Item::from_ast(cx, item);\n \n         let body = match item.body {\n-            syn::Body::Enum(ref variants) => {\n-                Body::Enum(enum_from_ast(cx, variants))\n-            }\n+            syn::Body::Enum(ref variants) => Body::Enum(enum_from_ast(cx, variants)),\n             syn::Body::Struct(ref variant_data) => {\n                 let (style, fields) = struct_from_ast(cx, variant_data);\n                 Body::Struct(style, fields)\n@@ -58,15 +56,13 @@ impl<'a> Item<'a> {\n }\n \n impl<'a> Body<'a> {\n-    pub fn all_fields(&'a self) -> Box<Iterator<Item=&'a Field<'a>> + 'a> {\n+    pub fn all_fields(&'a self) -> Box<Iterator<Item = &'a Field<'a>> + 'a> {\n         match *self {\n             Body::Enum(ref variants) => {\n                 Box::new(variants.iter()\n-                             .flat_map(|variant| variant.fields.iter()))\n-            }\n-            Body::Struct(_, ref fields) => {\n-                Box::new(fields.iter())\n+                    .flat_map(|variant| variant.fields.iter()))\n             }\n+            Body::Struct(_, ref fields) => Box::new(fields.iter()),\n         }\n     }\n }\n@@ -87,18 +83,12 @@ fn enum_from_ast<'a>(cx: &Ctxt, variants: &'a [syn::Variant]) -> Vec<Variant<'a>\n \n fn struct_from_ast<'a>(cx: &Ctxt, data: &'a syn::VariantData) -> (Style, Vec<Field<'a>>) {\n     match *data {\n-        syn::VariantData::Struct(ref fields) => {\n-            (Style::Struct, fields_from_ast(cx, fields))\n-        }\n+        syn::VariantData::Struct(ref fields) => (Style::Struct, fields_from_ast(cx, fields)),\n         syn::VariantData::Tuple(ref fields) if fields.len() == 1 => {\n             (Style::Newtype, fields_from_ast(cx, fields))\n         }\n-        syn::VariantData::Tuple(ref fields) => {\n-            (Style::Tuple, fields_from_ast(cx, fields))\n-        }\n-        syn::VariantData::Unit => {\n-            (Style::Unit, Vec::new())\n-        }\n+        syn::VariantData::Tuple(ref fields) => (Style::Tuple, fields_from_ast(cx, fields)),\n+        syn::VariantData::Unit => (Style::Unit, Vec::new()),\n     }\n }\n \ndiff --git a/serde_codegen_internals/src/attr.rs b/serde_codegen_internals/src/attr.rs\nindex 97fa4650b..224bb9398 100644\n--- a/serde_codegen_internals/src/attr.rs\n+++ b/serde_codegen_internals/src/attr.rs\n@@ -157,7 +157,8 @@ impl Item {\n \n                     // Parse `#[serde(bound=\"D: Serialize\")]`\n                     MetaItem(NameValue(ref name, ref lit)) if name == \"bound\" => {\n-                        if let Ok(where_predicates) = parse_lit_into_where(cx, name.as_ref(), name.as_ref(), lit) {\n+                        if let Ok(where_predicates) =\n+                            parse_lit_into_where(cx, name.as_ref(), name.as_ref(), lit) {\n                             ser_bound.set(where_predicates.clone());\n                             de_bound.set(where_predicates);\n                         }\n@@ -217,10 +218,12 @@ impl Item {\n                 if let syn::Body::Enum(ref variants) = item.body {\n                     for variant in variants {\n                         match variant.data {\n-                            syn::VariantData::Struct(_) | syn::VariantData::Unit => {}\n+                            syn::VariantData::Struct(_) |\n+                            syn::VariantData::Unit => {}\n                             syn::VariantData::Tuple(ref fields) => {\n                                 if fields.len() != 1 {\n-                                    cx.error(\"#[serde(tag = \\\"...\\\")] cannot be used with tuple variants\");\n+                                    cx.error(\"#[serde(tag = \\\"...\\\")] cannot be used with tuple \\\n+                                              variants\");\n                                     break;\n                                 }\n                             }\n@@ -311,8 +314,7 @@ impl Variant {\n                     }\n \n                     MetaItem(ref meta_item) => {\n-                        cx.error(format!(\"unknown serde variant attribute `{}`\",\n-                                         meta_item.name()));\n+                        cx.error(format!(\"unknown serde variant attribute `{}`\", meta_item.name()));\n                     }\n \n                     Literal(_) => {\n@@ -372,9 +374,7 @@ pub enum FieldDefault {\n \n impl Field {\n     /// Extract out the `#[serde(...)]` attributes from a struct field.\n-    pub fn from_ast(cx: &Ctxt,\n-                    index: usize,\n-                    field: &syn::Field) -> Self {\n+    pub fn from_ast(cx: &Ctxt, index: usize, field: &syn::Field) -> Self {\n         let mut ser_name = Attr::none(cx, \"rename\");\n         let mut de_name = Attr::none(cx, \"rename\");\n         let mut skip_serializing = BoolAttr::none(cx, \"skip_serializing\");\n@@ -455,7 +455,8 @@ impl Field {\n \n                     // Parse `#[serde(bound=\"D: Serialize\")]`\n                     MetaItem(NameValue(ref name, ref lit)) if name == \"bound\" => {\n-                        if let Ok(where_predicates) = parse_lit_into_where(cx, name.as_ref(), name.as_ref(), lit) {\n+                        if let Ok(where_predicates) =\n+                            parse_lit_into_where(cx, name.as_ref(), name.as_ref(), lit) {\n                             ser_bound.set(where_predicates.clone());\n                             de_bound.set(where_predicates);\n                         }\n@@ -470,8 +471,7 @@ impl Field {\n                     }\n \n                     MetaItem(ref meta_item) => {\n-                        cx.error(format!(\"unknown serde field attribute `{}`\",\n-                                         meta_item.name()));\n+                        cx.error(format!(\"unknown serde field attribute `{}`\", meta_item.name()));\n                     }\n \n                     Literal(_) => {\n@@ -542,13 +542,12 @@ impl Field {\n \n type SerAndDe<T> = (Option<T>, Option<T>);\n \n-fn get_ser_and_de<T, F>(\n-    cx: &Ctxt,\n-    attr_name: &'static str,\n-    items: &[syn::NestedMetaItem],\n-    f: F\n-) -> Result<SerAndDe<T>, ()>\n-    where F: Fn(&Ctxt, &str, &str, &syn::Lit) -> Result<T, ()>,\n+fn get_ser_and_de<T, F>(cx: &Ctxt,\n+                        attr_name: &'static str,\n+                        items: &[syn::NestedMetaItem],\n+                        f: F)\n+                        -> Result<SerAndDe<T>, ()>\n+    where F: Fn(&Ctxt, &str, &str, &syn::Lit) -> Result<T, ()>\n {\n     let mut ser_item = Attr::none(cx, attr_name);\n     let mut de_item = Attr::none(cx, attr_name);\n@@ -568,7 +567,8 @@ fn get_ser_and_de<T, F>(\n             }\n \n             _ => {\n-                cx.error(format!(\"malformed {0} attribute, expected `{0}(serialize = ..., deserialize = ...)`\",\n+                cx.error(format!(\"malformed {0} attribute, expected `{0}(serialize = ..., \\\n+                                  deserialize = ...)`\",\n                                  attr_name));\n                 return Err(());\n             }\n@@ -578,35 +578,34 @@ fn get_ser_and_de<T, F>(\n     Ok((ser_item.get(), de_item.get()))\n }\n \n-fn get_renames(\n-    cx: &Ctxt,\n-    items: &[syn::NestedMetaItem],\n-) -> Result<SerAndDe<String>, ()> {\n+fn get_renames(cx: &Ctxt, items: &[syn::NestedMetaItem]) -> Result<SerAndDe<String>, ()> {\n     get_ser_and_de(cx, \"rename\", items, get_string_from_lit)\n }\n \n-fn get_where_predicates(\n-    cx: &Ctxt,\n-    items: &[syn::NestedMetaItem],\n-) -> Result<SerAndDe<Vec<syn::WherePredicate>>, ()> {\n+fn get_where_predicates(cx: &Ctxt,\n+                        items: &[syn::NestedMetaItem])\n+                        -> Result<SerAndDe<Vec<syn::WherePredicate>>, ()> {\n     get_ser_and_de(cx, \"bound\", items, parse_lit_into_where)\n }\n \n pub fn get_serde_meta_items(attr: &syn::Attribute) -> Option<Vec<syn::NestedMetaItem>> {\n     match attr.value {\n-        List(ref name, ref items) if name == \"serde\" => {\n-            Some(items.iter().cloned().collect())\n-        }\n-        _ => None\n+        List(ref name, ref items) if name == \"serde\" => Some(items.iter().cloned().collect()),\n+        _ => None,\n     }\n }\n \n-fn get_string_from_lit(cx: &Ctxt, attr_name: &str, meta_item_name: &str, lit: &syn::Lit) -> Result<String, ()> {\n+fn get_string_from_lit(cx: &Ctxt,\n+                       attr_name: &str,\n+                       meta_item_name: &str,\n+                       lit: &syn::Lit)\n+                       -> Result<String, ()> {\n     if let syn::Lit::Str(ref s, _) = *lit {\n         Ok(s.clone())\n     } else {\n         cx.error(format!(\"expected serde {} attribute to be a string: `{} = \\\"...\\\"`\",\n-                         attr_name, meta_item_name));\n+                         attr_name,\n+                         meta_item_name));\n         Err(())\n     }\n }\n@@ -616,7 +615,11 @@ fn parse_lit_into_path(cx: &Ctxt, attr_name: &str, lit: &syn::Lit) -> Result<syn\n     syn::parse_path(&string).map_err(|err| cx.error(err))\n }\n \n-fn parse_lit_into_where(cx: &Ctxt, attr_name: &str, meta_item_name: &str, lit: &syn::Lit) -> Result<Vec<syn::WherePredicate>, ()> {\n+fn parse_lit_into_where(cx: &Ctxt,\n+                        attr_name: &str,\n+                        meta_item_name: &str,\n+                        lit: &syn::Lit)\n+                        -> Result<Vec<syn::WherePredicate>, ()> {\n     let string = try!(get_string_from_lit(cx, attr_name, meta_item_name, lit));\n     if string.is_empty() {\n         return Ok(Vec::new());\ndiff --git a/serde_codegen_internals/src/ctxt.rs b/serde_codegen_internals/src/ctxt.rs\nindex a1455332c..a112c7e96 100644\n--- a/serde_codegen_internals/src/ctxt.rs\n+++ b/serde_codegen_internals/src/ctxt.rs\n@@ -8,9 +8,7 @@ pub struct Ctxt {\n \n impl Ctxt {\n     pub fn new() -> Self {\n-        Ctxt {\n-            errors: RefCell::new(Some(Vec::new())),\n-        }\n+        Ctxt { errors: RefCell::new(Some(Vec::new())) }\n     }\n \n     pub fn error<T: Display>(&self, msg: T) {\ndiff --git a/serde_derive/src/bound.rs b/serde_derive/src/bound.rs\nindex fef77ba38..e386e2a31 100644\n--- a/serde_derive/src/bound.rs\n+++ b/serde_derive/src/bound.rs\n@@ -10,36 +10,33 @@ use internals::attr;\n // allowed here\".\n pub fn without_defaults(generics: &syn::Generics) -> syn::Generics {\n     syn::Generics {\n-        ty_params: generics.ty_params.iter().map(|ty_param| {\n-            syn::TyParam {\n-                default: None,\n-                .. ty_param.clone()\n-            }}).collect(),\n-        .. generics.clone()\n+        ty_params: generics.ty_params\n+            .iter()\n+            .map(|ty_param| syn::TyParam { default: None, ..ty_param.clone() })\n+            .collect(),\n+        ..generics.clone()\n     }\n }\n \n-pub fn with_where_predicates(\n-    generics: &syn::Generics,\n-    predicates: &[syn::WherePredicate],\n-) -> syn::Generics {\n+pub fn with_where_predicates(generics: &syn::Generics,\n+                             predicates: &[syn::WherePredicate])\n+                             -> syn::Generics {\n     aster::from_generics(generics.clone())\n         .with_predicates(predicates.to_vec())\n         .build()\n }\n \n-pub fn with_where_predicates_from_fields<F>(\n-    item: &Item,\n-    generics: &syn::Generics,\n-    from_field: F,\n-) -> syn::Generics\n-    where F: Fn(&attr::Field) -> Option<&[syn::WherePredicate]>,\n+pub fn with_where_predicates_from_fields<F>(item: &Item,\n+                                            generics: &syn::Generics,\n+                                            from_field: F)\n+                                            -> syn::Generics\n+    where F: Fn(&attr::Field) -> Option<&[syn::WherePredicate]>\n {\n     aster::from_generics(generics.clone())\n-        .with_predicates(\n-            item.body.all_fields()\n-                .flat_map(|field| from_field(&field.attrs))\n-                .flat_map(|predicates| predicates.to_vec()))\n+        .with_predicates(item.body\n+            .all_fields()\n+            .flat_map(|field| from_field(&field.attrs))\n+            .flat_map(|predicates| predicates.to_vec()))\n         .build()\n }\n \n@@ -54,13 +51,12 @@ pub fn with_where_predicates_from_fields<F>(\n //         #[serde(skip_serializing)]\n //         c: C,\n //     }\n-pub fn with_bound<F>(\n-    item: &Item,\n-    generics: &syn::Generics,\n-    filter: F,\n-    bound: &syn::Path,\n-) -> syn::Generics\n-    where F: Fn(&attr::Field) -> bool,\n+pub fn with_bound<F>(item: &Item,\n+                     generics: &syn::Generics,\n+                     filter: F,\n+                     bound: &syn::Path)\n+                     -> syn::Generics\n+    where F: Fn(&attr::Field) -> bool\n {\n     struct FindTyParams {\n         // Set of all generic type parameters on the current struct (A, B, C in\n@@ -90,11 +86,13 @@ pub fn with_bound<F>(\n         }\n     }\n \n-    let all_ty_params: HashSet<_> = generics.ty_params.iter()\n+    let all_ty_params: HashSet<_> = generics.ty_params\n+        .iter()\n         .map(|ty_param| ty_param.ident.clone())\n         .collect();\n \n-    let relevant_tys = item.body.all_fields()\n+    let relevant_tys = item.body\n+        .all_fields()\n         .filter(|&field| filter(&field.attrs))\n         .map(|field| &field.ty);\n \n@@ -107,15 +105,17 @@ pub fn with_bound<F>(\n     }\n \n     aster::from_generics(generics.clone())\n-        .with_predicates(\n-            generics.ty_params.iter()\n-                .map(|ty_param| ty_param.ident.clone())\n-                .filter(|id| visitor.relevant_ty_params.contains(id))\n-                .map(|id| aster::where_predicate()\n+        .with_predicates(generics.ty_params\n+            .iter()\n+            .map(|ty_param| ty_param.ident.clone())\n+            .filter(|id| visitor.relevant_ty_params.contains(id))\n+            .map(|id| {\n+                aster::where_predicate()\n                     // the type parameter that is being bounded e.g. T\n                     .bound().build(aster::ty().id(id))\n                     // the bound e.g. Serialize\n                     .bound().trait_(bound.clone()).build()\n-                    .build()))\n+                    .build()\n+            }))\n         .build()\n }\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 95abd5f0c..9e203ec98 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -18,13 +18,14 @@ pub fn expand_derive_deserialize(item: &syn::DeriveInput) -> Result<Tokens, Stri\n \n     let impl_generics = build_impl_generics(&item);\n \n-    let ty = aster::ty().path()\n-        .segment(item.ident.clone()).with_generics(impl_generics.clone()).build()\n+    let ty = aster::ty()\n+        .path()\n+        .segment(item.ident.clone())\n+        .with_generics(impl_generics.clone())\n+        .build()\n         .build();\n \n-    let body = deserialize_body(&item,\n-                                &impl_generics,\n-                                ty.clone());\n+    let body = deserialize_body(&item, &impl_generics, ty.clone());\n \n     let where_clause = &impl_generics.where_clause;\n \n@@ -50,21 +51,21 @@ pub fn expand_derive_deserialize(item: &syn::DeriveInput) -> Result<Tokens, Stri\n fn build_impl_generics(item: &Item) -> syn::Generics {\n     let generics = bound::without_defaults(item.generics);\n \n-    let generics = bound::with_where_predicates_from_fields(\n-        item, &generics,\n-        |attrs| attrs.de_bound());\n+    let generics =\n+        bound::with_where_predicates_from_fields(item, &generics, |attrs| attrs.de_bound());\n \n     match item.attrs.de_bound() {\n-        Some(predicates) => {\n-            bound::with_where_predicates(&generics, predicates)\n-        }\n+        Some(predicates) => bound::with_where_predicates(&generics, predicates),\n         None => {\n-            let generics = bound::with_bound(item, &generics,\n-                needs_deserialize_bound,\n-                &aster::path().ids(&[\"_serde\", \"Deserialize\"]).build());\n-            bound::with_bound(item, &generics,\n-                requires_default,\n-                &aster::path().global().ids(&[\"std\", \"default\", \"Default\"]).build())\n+            let generics =\n+                bound::with_bound(item,\n+                                  &generics,\n+                                  needs_deserialize_bound,\n+                                  &aster::path().ids(&[\"_serde\", \"Deserialize\"]).build());\n+            bound::with_bound(item,\n+                              &generics,\n+                              requires_default,\n+                              &aster::path().global().ids(&[\"std\", \"default\", \"Default\"]).build())\n         }\n     }\n }\n@@ -74,9 +75,7 @@ fn build_impl_generics(item: &Item) -> syn::Generics {\n // attribute specify their own bound so we do not generate one. All other fields\n // may need a `T: Deserialize` bound where T is the type of the field.\n fn needs_deserialize_bound(attrs: &attr::Field) -> bool {\n-    !attrs.skip_deserializing()\n-        && attrs.deserialize_with().is_none()\n-        && attrs.de_bound().is_none()\n+    !attrs.skip_deserializing() && attrs.deserialize_with().is_none() && attrs.de_bound().is_none()\n }\n \n // Fields with a `default` attribute (not `default=...`), and fields with a\n@@ -85,33 +84,23 @@ fn requires_default(attrs: &attr::Field) -> bool {\n     attrs.default() == &attr::FieldDefault::Default\n }\n \n-fn deserialize_body(\n-    item: &Item,\n-    impl_generics: &syn::Generics,\n-    ty: syn::Ty,\n-) -> Tokens {\n+fn deserialize_body(item: &Item, impl_generics: &syn::Generics, ty: syn::Ty) -> Tokens {\n     match item.body {\n         Body::Enum(ref variants) => {\n-            deserialize_item_enum(\n-                &item.ident,\n-                impl_generics,\n-                ty,\n-                variants,\n-                &item.attrs)\n+            deserialize_item_enum(&item.ident, impl_generics, ty, variants, &item.attrs)\n         }\n         Body::Struct(Style::Struct, ref fields) => {\n             if fields.iter().any(|field| field.ident.is_none()) {\n                 panic!(\"struct has unnamed fields\");\n             }\n \n-            deserialize_struct(\n-                &item.ident,\n-                None,\n-                impl_generics,\n-                ty,\n-                fields,\n-                &item.attrs,\n-                None)\n+            deserialize_struct(&item.ident,\n+                               None,\n+                               impl_generics,\n+                               ty,\n+                               fields,\n+                               &item.attrs,\n+                               None)\n         }\n         Body::Struct(Style::Tuple, ref fields) |\n         Body::Struct(Style::Newtype, ref fields) => {\n@@ -119,20 +108,15 @@ fn deserialize_body(\n                 panic!(\"tuple struct has named fields\");\n             }\n \n-            deserialize_tuple(\n-                &item.ident,\n-                None,\n-                impl_generics,\n-                ty,\n-                fields,\n-                &item.attrs,\n-                None)\n-        }\n-        Body::Struct(Style::Unit, _) => {\n-            deserialize_unit_struct(\n-                &item.ident,\n-                &item.attrs)\n+            deserialize_tuple(&item.ident,\n+                              None,\n+                              impl_generics,\n+                              ty,\n+                              fields,\n+                              &item.attrs,\n+                              None)\n         }\n+        Body::Struct(Style::Unit, _) => deserialize_unit_struct(&item.ident, &item.attrs),\n     }\n }\n \n@@ -145,33 +129,37 @@ fn deserialize_body(\n //     3. the expression for instantiating the visitor\n fn deserialize_visitor(generics: &syn::Generics) -> (Tokens, Tokens, Tokens) {\n     if generics.lifetimes.is_empty() && generics.ty_params.is_empty() {\n-        (\n-            quote! {\n+        (quote! {\n                 struct __Visitor;\n             },\n-            quote!(__Visitor),\n-            quote!(__Visitor),\n-        )\n+         quote!(__Visitor),\n+         quote!(__Visitor))\n     } else {\n         let where_clause = &generics.where_clause;\n \n         let num_phantoms = generics.lifetimes.len() + generics.ty_params.len();\n \n-        let phantom_types = generics.lifetimes.iter()\n+        let phantom_types = generics.lifetimes\n+            .iter()\n             .map(|lifetime_def| {\n                 let lifetime = &lifetime_def.lifetime;\n                 quote!(_serde::export::PhantomData<& #lifetime ()>)\n-            }).chain(generics.ty_params.iter()\n+            })\n+            .chain(generics.ty_params\n+                .iter()\n                 .map(|ty_param| {\n                     let ident = &ty_param.ident;\n                     quote!(_serde::export::PhantomData<#ident>)\n                 }));\n \n-        let all_params = generics.lifetimes.iter()\n+        let all_params = generics.lifetimes\n+            .iter()\n             .map(|lifetime_def| {\n                 let lifetime = &lifetime_def.lifetime;\n                 quote!(#lifetime)\n-            }).chain(generics.ty_params.iter()\n+            })\n+            .chain(generics.ty_params\n+                .iter()\n                 .map(|ty_param| {\n                     let ident = &ty_param.ident;\n                     quote!(#ident)\n@@ -186,20 +174,15 @@ fn deserialize_visitor(generics: &syn::Generics) -> (Tokens, Tokens, Tokens) {\n \n         let phantom_exprs = iter::repeat(quote!(_serde::export::PhantomData)).take(num_phantoms);\n \n-        (\n-            quote! {\n+        (quote! {\n                 struct __Visitor #generics ( #(#phantom_types),* ) #where_clause;\n             },\n-            quote!(__Visitor <#(#all_params),*> ),\n-            quote!(__Visitor #ty_param_idents ( #(#phantom_exprs),* )),\n-        )\n+         quote!(__Visitor <#(#all_params),*> ),\n+         quote!(__Visitor #ty_param_idents ( #(#phantom_exprs),* )))\n     }\n }\n \n-fn deserialize_unit_struct(\n-    type_ident: &syn::Ident,\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n+fn deserialize_unit_struct(type_ident: &syn::Ident, item_attrs: &attr::Item) -> Tokens {\n     let type_name = item_attrs.name().deserialize_name();\n \n     let expecting = format!(\"unit struct {}\", type_ident);\n@@ -233,15 +216,14 @@ fn deserialize_unit_struct(\n     })\n }\n \n-fn deserialize_tuple(\n-    type_ident: &syn::Ident,\n-    variant_ident: Option<&syn::Ident>,\n-    impl_generics: &syn::Generics,\n-    ty: syn::Ty,\n-    fields: &[Field],\n-    item_attrs: &attr::Item,\n-    deserializer: Option<Tokens>,\n-) -> Tokens {\n+fn deserialize_tuple(type_ident: &syn::Ident,\n+                     variant_ident: Option<&syn::Ident>,\n+                     impl_generics: &syn::Generics,\n+                     ty: syn::Ty,\n+                     fields: &[Field],\n+                     item_attrs: &attr::Item,\n+                     deserializer: Option<Tokens>)\n+                     -> Tokens {\n     let where_clause = &impl_generics.where_clause;\n \n     let (visitor_item, visitor_ty, visitor_expr) = deserialize_visitor(impl_generics);\n@@ -259,23 +241,12 @@ fn deserialize_tuple(\n     let nfields = fields.len();\n \n     let visit_newtype_struct = if !is_enum && nfields == 1 {\n-        Some(deserialize_newtype_struct(\n-            type_ident,\n-            &type_path,\n-            impl_generics,\n-            &fields[0],\n-        ))\n+        Some(deserialize_newtype_struct(type_ident, &type_path, impl_generics, &fields[0]))\n     } else {\n         None\n     };\n \n-    let visit_seq = deserialize_seq(\n-        type_ident,\n-        &type_path,\n-        impl_generics,\n-        fields,\n-        false,\n-    );\n+    let visit_seq = deserialize_seq(type_ident, &type_path, impl_generics, fields, false);\n \n     let dispatch = if let Some(deserializer) = deserializer {\n         quote!(_serde::Deserializer::deserialize(#deserializer, #visitor_expr))\n@@ -320,13 +291,12 @@ fn deserialize_tuple(\n     })\n }\n \n-fn deserialize_seq(\n-    type_ident: &syn::Ident,\n-    type_path: &Tokens,\n-    impl_generics: &syn::Generics,\n-    fields: &[Field],\n-    is_struct: bool,\n-) -> Tokens {\n+fn deserialize_seq(type_ident: &syn::Ident,\n+                   type_path: &Tokens,\n+                   impl_generics: &syn::Generics,\n+                   fields: &[Field],\n+                   is_struct: bool)\n+                   -> Tokens {\n     let vars = (0..fields.len()).map(field_i as fn(_) -> _);\n \n     let deserialized_count = fields.iter()\n@@ -389,12 +359,11 @@ fn deserialize_seq(\n     }\n }\n \n-fn deserialize_newtype_struct(\n-    type_ident: &syn::Ident,\n-    type_path: &Tokens,\n-    impl_generics: &syn::Generics,\n-    field: &Field,\n-) -> Tokens {\n+fn deserialize_newtype_struct(type_ident: &syn::Ident,\n+                              type_path: &Tokens,\n+                              impl_generics: &syn::Generics,\n+                              field: &Field)\n+                              -> Tokens {\n     let value = match field.attrs.deserialize_with() {\n         None => {\n             let field_ty = &field.ty;\n@@ -403,8 +372,8 @@ fn deserialize_newtype_struct(\n             }\n         }\n         Some(path) => {\n-            let (wrapper, wrapper_impl, wrapper_ty) = wrap_deserialize_with(\n-                type_ident, impl_generics, field.ty, path);\n+            let (wrapper, wrapper_impl, wrapper_ty) =\n+                wrap_deserialize_with(type_ident, impl_generics, field.ty, path);\n             quote!({\n                 #wrapper\n                 #wrapper_impl\n@@ -422,15 +391,14 @@ fn deserialize_newtype_struct(\n     }\n }\n \n-fn deserialize_struct(\n-    type_ident: &syn::Ident,\n-    variant_ident: Option<&syn::Ident>,\n-    impl_generics: &syn::Generics,\n-    ty: syn::Ty,\n-    fields: &[Field],\n-    item_attrs: &attr::Item,\n-    deserializer: Option<Tokens>,\n-) -> Tokens {\n+fn deserialize_struct(type_ident: &syn::Ident,\n+                      variant_ident: Option<&syn::Ident>,\n+                      impl_generics: &syn::Generics,\n+                      ty: syn::Ty,\n+                      fields: &[Field],\n+                      item_attrs: &attr::Item,\n+                      deserializer: Option<Tokens>)\n+                      -> Tokens {\n     let is_enum = variant_ident.is_some();\n     let is_untagged = deserializer.is_some();\n \n@@ -447,21 +415,10 @@ fn deserialize_struct(\n         None => format!(\"struct {}\", type_ident),\n     };\n \n-    let visit_seq = deserialize_seq(\n-        type_ident,\n-        &type_path,\n-        impl_generics,\n-        fields,\n-        true,\n-    );\n-\n-    let (field_visitor, fields_stmt, visit_map) = deserialize_struct_visitor(\n-        type_ident,\n-        type_path,\n-        impl_generics,\n-        fields,\n-        item_attrs,\n-    );\n+    let visit_seq = deserialize_seq(type_ident, &type_path, impl_generics, fields, true);\n+\n+    let (field_visitor, fields_stmt, visit_map) =\n+        deserialize_struct_visitor(type_ident, type_path, impl_generics, fields, item_attrs);\n \n     let dispatch = if let Some(deserializer) = deserializer {\n         quote! {\n@@ -527,52 +484,36 @@ fn deserialize_struct(\n     })\n }\n \n-fn deserialize_item_enum(\n-    type_ident: &syn::Ident,\n-    impl_generics: &syn::Generics,\n-    ty: syn::Ty,\n-    variants: &[Variant],\n-    item_attrs: &attr::Item\n-) -> Tokens {\n+fn deserialize_item_enum(type_ident: &syn::Ident,\n+                         impl_generics: &syn::Generics,\n+                         ty: syn::Ty,\n+                         variants: &[Variant],\n+                         item_attrs: &attr::Item)\n+                         -> Tokens {\n     match *item_attrs.tag() {\n         attr::EnumTag::External => {\n-            deserialize_externally_tagged_enum(\n-                type_ident,\n-                impl_generics,\n-                ty,\n-                variants,\n-                item_attrs,\n-            )\n+            deserialize_externally_tagged_enum(type_ident, impl_generics, ty, variants, item_attrs)\n         }\n         attr::EnumTag::Internal(ref tag) => {\n-            deserialize_internally_tagged_enum(\n-                type_ident,\n-                impl_generics,\n-                ty,\n-                variants,\n-                item_attrs,\n-                tag,\n-            )\n+            deserialize_internally_tagged_enum(type_ident,\n+                                               impl_generics,\n+                                               ty,\n+                                               variants,\n+                                               item_attrs,\n+                                               tag)\n         }\n         attr::EnumTag::None => {\n-            deserialize_untagged_enum(\n-                type_ident,\n-                impl_generics,\n-                ty,\n-                variants,\n-                item_attrs,\n-            )\n+            deserialize_untagged_enum(type_ident, impl_generics, ty, variants, item_attrs)\n         }\n     }\n }\n \n-fn deserialize_externally_tagged_enum(\n-    type_ident: &syn::Ident,\n-    impl_generics: &syn::Generics,\n-    ty: syn::Ty,\n-    variants: &[Variant],\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n+fn deserialize_externally_tagged_enum(type_ident: &syn::Ident,\n+                                      impl_generics: &syn::Generics,\n+                                      ty: syn::Ty,\n+                                      variants: &[Variant],\n+                                      item_attrs: &attr::Item)\n+                                      -> Tokens {\n     let where_clause = &impl_generics.where_clause;\n \n     let type_name = item_attrs.name().deserialize_name();\n@@ -592,11 +533,7 @@ fn deserialize_externally_tagged_enum(\n         }\n     };\n \n-    let variant_visitor = deserialize_field_visitor(\n-        variant_names_idents,\n-        item_attrs,\n-        true,\n-    );\n+    let variant_visitor = deserialize_field_visitor(variant_names_idents, item_attrs, true);\n \n     // Match arms to extract a variant from a string\n     let variant_arms = variants.iter()\n@@ -605,13 +542,11 @@ fn deserialize_externally_tagged_enum(\n         .map(|(i, variant)| {\n             let variant_name = field_i(i);\n \n-            let block = deserialize_externally_tagged_variant(\n-                type_ident,\n-                impl_generics,\n-                ty.clone(),\n-                variant,\n-                item_attrs,\n-            );\n+            let block = deserialize_externally_tagged_variant(type_ident,\n+                                                              impl_generics,\n+                                                              ty.clone(),\n+                                                              variant,\n+                                                              item_attrs);\n \n             quote! {\n                 (__Field::#variant_name, visitor) => #block\n@@ -664,14 +599,13 @@ fn deserialize_externally_tagged_enum(\n     })\n }\n \n-fn deserialize_internally_tagged_enum(\n-    type_ident: &syn::Ident,\n-    impl_generics: &syn::Generics,\n-    ty: syn::Ty,\n-    variants: &[Variant],\n-    item_attrs: &attr::Item,\n-    tag: &str,\n-) -> Tokens {\n+fn deserialize_internally_tagged_enum(type_ident: &syn::Ident,\n+                                      impl_generics: &syn::Generics,\n+                                      ty: syn::Ty,\n+                                      variants: &[Variant],\n+                                      item_attrs: &attr::Item,\n+                                      tag: &str)\n+                                      -> Tokens {\n     let variant_names_idents: Vec<_> = variants.iter()\n         .enumerate()\n         .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n@@ -685,11 +619,7 @@ fn deserialize_internally_tagged_enum(\n         }\n     };\n \n-    let variant_visitor = deserialize_field_visitor(\n-        variant_names_idents,\n-        item_attrs,\n-        true,\n-    );\n+    let variant_visitor = deserialize_field_visitor(variant_names_idents, item_attrs, true);\n \n     // Match arms to extract a variant from a string\n     let variant_arms = variants.iter()\n@@ -727,13 +657,12 @@ fn deserialize_internally_tagged_enum(\n     })\n }\n \n-fn deserialize_untagged_enum(\n-    type_ident: &syn::Ident,\n-    impl_generics: &syn::Generics,\n-    ty: syn::Ty,\n-    variants: &[Variant],\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n+fn deserialize_untagged_enum(type_ident: &syn::Ident,\n+                             impl_generics: &syn::Generics,\n+                             ty: syn::Ty,\n+                             variants: &[Variant],\n+                             item_attrs: &attr::Item)\n+                             -> Tokens {\n     let attempts = variants.iter()\n         .filter(|variant| !variant.attrs.skip_deserializing())\n         .map(|variant| {\n@@ -768,13 +697,12 @@ fn deserialize_untagged_enum(\n     })\n }\n \n-fn deserialize_externally_tagged_variant(\n-    type_ident: &syn::Ident,\n-    generics: &syn::Generics,\n-    ty: syn::Ty,\n-    variant: &Variant,\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n+fn deserialize_externally_tagged_variant(type_ident: &syn::Ident,\n+                                         generics: &syn::Generics,\n+                                         ty: syn::Ty,\n+                                         variant: &Variant,\n+                                         item_attrs: &attr::Item)\n+                                         -> Tokens {\n     let variant_ident = &variant.ident;\n \n     match variant.style {\n@@ -785,46 +713,39 @@ fn deserialize_externally_tagged_variant(\n             })\n         }\n         Style::Newtype => {\n-            deserialize_externally_tagged_newtype_variant(\n-                type_ident,\n-                variant_ident,\n-                generics,\n-                &variant.fields[0],\n-            )\n+            deserialize_externally_tagged_newtype_variant(type_ident,\n+                                                          variant_ident,\n+                                                          generics,\n+                                                          &variant.fields[0])\n         }\n         Style::Tuple => {\n-            deserialize_tuple(\n-                type_ident,\n-                Some(variant_ident),\n-                generics,\n-                ty,\n-                &variant.fields,\n-                item_attrs,\n-                None,\n-            )\n+            deserialize_tuple(type_ident,\n+                              Some(variant_ident),\n+                              generics,\n+                              ty,\n+                              &variant.fields,\n+                              item_attrs,\n+                              None)\n         }\n         Style::Struct => {\n-            deserialize_struct(\n-                type_ident,\n-                Some(variant_ident),\n-                generics,\n-                ty,\n-                &variant.fields,\n-                item_attrs,\n-                None,\n-            )\n+            deserialize_struct(type_ident,\n+                               Some(variant_ident),\n+                               generics,\n+                               ty,\n+                               &variant.fields,\n+                               item_attrs,\n+                               None)\n         }\n     }\n }\n \n-fn deserialize_internally_tagged_variant(\n-    type_ident: &syn::Ident,\n-    generics: &syn::Generics,\n-    ty: syn::Ty,\n-    variant: &Variant,\n-    item_attrs: &attr::Item,\n-    deserializer: Tokens,\n-) -> Tokens {\n+fn deserialize_internally_tagged_variant(type_ident: &syn::Ident,\n+                                         generics: &syn::Generics,\n+                                         ty: syn::Ty,\n+                                         variant: &Variant,\n+                                         item_attrs: &attr::Item,\n+                                         deserializer: Tokens)\n+                                         -> Tokens {\n     let variant_ident = &variant.ident;\n \n     match variant.style {\n@@ -837,27 +758,24 @@ fn deserialize_internally_tagged_variant(\n             })\n         }\n         Style::Newtype | Style::Struct => {\n-            deserialize_untagged_variant(\n-                type_ident,\n-                generics,\n-                ty,\n-                variant,\n-                item_attrs,\n-                deserializer,\n-            )\n+            deserialize_untagged_variant(type_ident,\n+                                         generics,\n+                                         ty,\n+                                         variant,\n+                                         item_attrs,\n+                                         deserializer)\n         }\n         Style::Tuple => unreachable!(\"checked in serde_codegen_internals\"),\n     }\n }\n \n-fn deserialize_untagged_variant(\n-    type_ident: &syn::Ident,\n-    generics: &syn::Generics,\n-    ty: syn::Ty,\n-    variant: &Variant,\n-    item_attrs: &attr::Item,\n-    deserializer: Tokens,\n-) -> Tokens {\n+fn deserialize_untagged_variant(type_ident: &syn::Ident,\n+                                generics: &syn::Generics,\n+                                ty: syn::Ty,\n+                                variant: &Variant,\n+                                item_attrs: &attr::Item,\n+                                deserializer: Tokens)\n+                                -> Tokens {\n     let variant_ident = &variant.ident;\n \n     match variant.style {\n@@ -874,45 +792,38 @@ fn deserialize_untagged_variant(\n             }\n         }\n         Style::Newtype => {\n-            deserialize_untagged_newtype_variant(\n-                type_ident,\n-                variant_ident,\n-                generics,\n-                &variant.fields[0],\n-                deserializer,\n-            )\n+            deserialize_untagged_newtype_variant(type_ident,\n+                                                 variant_ident,\n+                                                 generics,\n+                                                 &variant.fields[0],\n+                                                 deserializer)\n         }\n         Style::Tuple => {\n-            deserialize_tuple(\n-                type_ident,\n-                Some(variant_ident),\n-                generics,\n-                ty,\n-                &variant.fields,\n-                item_attrs,\n-                Some(deserializer),\n-            )\n+            deserialize_tuple(type_ident,\n+                              Some(variant_ident),\n+                              generics,\n+                              ty,\n+                              &variant.fields,\n+                              item_attrs,\n+                              Some(deserializer))\n         }\n         Style::Struct => {\n-            deserialize_struct(\n-                type_ident,\n-                Some(variant_ident),\n-                generics,\n-                ty,\n-                &variant.fields,\n-                item_attrs,\n-                Some(deserializer),\n-            )\n+            deserialize_struct(type_ident,\n+                               Some(variant_ident),\n+                               generics,\n+                               ty,\n+                               &variant.fields,\n+                               item_attrs,\n+                               Some(deserializer))\n         }\n     }\n }\n \n-fn deserialize_externally_tagged_newtype_variant(\n-    type_ident: &syn::Ident,\n-    variant_ident: &syn::Ident,\n-    impl_generics: &syn::Generics,\n-    field: &Field,\n-) -> Tokens {\n+fn deserialize_externally_tagged_newtype_variant(type_ident: &syn::Ident,\n+                                                 variant_ident: &syn::Ident,\n+                                                 impl_generics: &syn::Generics,\n+                                                 field: &Field)\n+                                                 -> Tokens {\n     match field.attrs.deserialize_with() {\n         None => {\n             let field_ty = &field.ty;\n@@ -923,8 +834,8 @@ fn deserialize_externally_tagged_newtype_variant(\n             }\n         }\n         Some(path) => {\n-            let (wrapper, wrapper_impl, wrapper_ty) = wrap_deserialize_with(\n-                type_ident, impl_generics, field.ty, path);\n+            let (wrapper, wrapper_impl, wrapper_ty) =\n+                wrap_deserialize_with(type_ident, impl_generics, field.ty, path);\n             quote!({\n                 #wrapper\n                 #wrapper_impl\n@@ -936,13 +847,12 @@ fn deserialize_externally_tagged_newtype_variant(\n     }\n }\n \n-fn deserialize_untagged_newtype_variant(\n-    type_ident: &syn::Ident,\n-    variant_ident: &syn::Ident,\n-    impl_generics: &syn::Generics,\n-    field: &Field,\n-    deserializer: Tokens,\n-) -> Tokens {\n+fn deserialize_untagged_newtype_variant(type_ident: &syn::Ident,\n+                                        variant_ident: &syn::Ident,\n+                                        impl_generics: &syn::Generics,\n+                                        field: &Field,\n+                                        deserializer: Tokens)\n+                                        -> Tokens {\n     match field.attrs.deserialize_with() {\n         None => {\n             let field_ty = &field.ty;\n@@ -953,8 +863,8 @@ fn deserialize_untagged_newtype_variant(\n             })\n         }\n         Some(path) => {\n-            let (wrapper, wrapper_impl, wrapper_ty) = wrap_deserialize_with(\n-                type_ident, impl_generics, field.ty, path);\n+            let (wrapper, wrapper_impl, wrapper_ty) =\n+                wrap_deserialize_with(type_ident, impl_generics, field.ty, path);\n             quote!({\n                 #wrapper\n                 #wrapper_impl\n@@ -966,11 +876,10 @@ fn deserialize_untagged_newtype_variant(\n     }\n }\n \n-fn deserialize_field_visitor(\n-    fields: Vec<(String, Ident)>,\n-    item_attrs: &attr::Item,\n-    is_variant: bool,\n-) -> Tokens {\n+fn deserialize_field_visitor(fields: Vec<(String, Ident)>,\n+                             item_attrs: &attr::Item,\n+                             is_variant: bool)\n+                             -> Tokens {\n     let field_strs = fields.iter().map(|&(ref name, _)| name);\n     let field_bytes = fields.iter().map(|&(ref name, _)| quote::ByteStr(name));\n     let field_idents: &Vec<_> = &fields.iter().map(|&(_, ref ident)| ident).collect();\n@@ -1081,13 +990,12 @@ fn deserialize_field_visitor(\n     }\n }\n \n-fn deserialize_struct_visitor(\n-    type_ident: &syn::Ident,\n-    struct_path: Tokens,\n-    impl_generics: &syn::Generics,\n-    fields: &[Field],\n-    item_attrs: &attr::Item,\n-) -> (Tokens, Tokens, Tokens) {\n+fn deserialize_struct_visitor(type_ident: &syn::Ident,\n+                              struct_path: Tokens,\n+                              impl_generics: &syn::Generics,\n+                              fields: &[Field],\n+                              item_attrs: &attr::Item)\n+                              -> (Tokens, Tokens, Tokens) {\n     let field_names_idents: Vec<_> = fields.iter()\n         .enumerate()\n         .filter(|&(_, field)| !field.attrs.skip_deserializing())\n@@ -1101,30 +1009,19 @@ fn deserialize_struct_visitor(\n         }\n     };\n \n-    let field_visitor = deserialize_field_visitor(\n-        field_names_idents,\n-        item_attrs,\n-        false,\n-    );\n+    let field_visitor = deserialize_field_visitor(field_names_idents, item_attrs, false);\n \n-    let visit_map = deserialize_map(\n-        type_ident,\n-        struct_path,\n-        impl_generics,\n-        fields,\n-        item_attrs,\n-    );\n+    let visit_map = deserialize_map(type_ident, struct_path, impl_generics, fields, item_attrs);\n \n     (field_visitor, fields_stmt, visit_map)\n }\n \n-fn deserialize_map(\n-    type_ident: &syn::Ident,\n-    struct_path: Tokens,\n-    impl_generics: &syn::Generics,\n-    fields: &[Field],\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n+fn deserialize_map(type_ident: &syn::Ident,\n+                   struct_path: Tokens,\n+                   impl_generics: &syn::Generics,\n+                   fields: &[Field],\n+                   item_attrs: &attr::Item)\n+                   -> Tokens {\n     // Create the field names for the fields.\n     let fields_names: Vec<_> = fields.iter()\n         .enumerate()\n@@ -1243,38 +1140,36 @@ fn field_i(i: usize) -> Ident {\n \n /// This function wraps the expression in `#[serde(deserialize_with=\"...\")]` in\n /// a trait to prevent it from accessing the internal `Deserialize` state.\n-fn wrap_deserialize_with(\n-    type_ident: &syn::Ident,\n-    impl_generics: &syn::Generics,\n-    field_ty: &syn::Ty,\n-    deserialize_with: &syn::Path,\n-) -> (Tokens, Tokens, syn::Path) {\n+fn wrap_deserialize_with(type_ident: &syn::Ident,\n+                         impl_generics: &syn::Generics,\n+                         field_ty: &syn::Ty,\n+                         deserialize_with: &syn::Path)\n+                         -> (Tokens, Tokens, syn::Path) {\n     // Quasi-quoting doesn't do a great job of expanding generics into paths,\n     // so manually build it.\n     let wrapper_ty = aster::path()\n         .segment(\"__SerdeDeserializeWithStruct\")\n-            .with_generics(impl_generics.clone())\n-            .build()\n+        .with_generics(impl_generics.clone())\n+        .build()\n         .build();\n \n     let where_clause = &impl_generics.where_clause;\n \n     let phantom_ty = aster::path()\n         .segment(type_ident)\n-            .with_generics(aster::from_generics(impl_generics.clone())\n-                .strip_ty_params()\n-                .build())\n-            .build()\n+        .with_generics(aster::from_generics(impl_generics.clone())\n+            .strip_ty_params()\n+            .build())\n+        .build()\n         .build();\n \n-    (\n-        quote! {\n+    (quote! {\n             struct __SerdeDeserializeWithStruct #impl_generics #where_clause {\n                 value: #field_ty,\n                 phantom: _serde::export::PhantomData<#phantom_ty>,\n             }\n         },\n-        quote! {\n+     quote! {\n             impl #impl_generics _serde::Deserialize for #wrapper_ty #where_clause {\n                 fn deserialize<__D>(__d: __D) -> _serde::export::Result<Self, __D::Error>\n                     where __D: _serde::Deserializer\n@@ -1287,8 +1182,7 @@ fn wrap_deserialize_with(\n                 }\n             }\n         },\n-        wrapper_ty,\n-    )\n+     wrapper_ty)\n }\n \n fn expr_is_missing(attrs: &attr::Field) -> Tokens {\n@@ -1319,14 +1213,14 @@ fn expr_is_missing(attrs: &attr::Field) -> Tokens {\n \n fn check_no_str(cx: &internals::Ctxt, item: &Item) {\n     let fail = || {\n-        cx.error(\n-            \"Serde does not support deserializing fields of type &str; \\\n-             consider using String instead\");\n+        cx.error(\"Serde does not support deserializing fields of type &str; consider using \\\n+                  String instead\");\n     };\n \n     for field in item.body.all_fields() {\n-        if field.attrs.skip_deserializing()\n-            || field.attrs.deserialize_with().is_some() { continue }\n+        if field.attrs.skip_deserializing() || field.attrs.deserialize_with().is_some() {\n+            continue;\n+        }\n \n         if let syn::Ty::Rptr(_, ref inner) = *field.ty {\n             if let syn::Ty::Path(_, ref path) = inner.ty {\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 52c86c7e7..62786f33b 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -12,13 +12,14 @@ pub fn expand_derive_serialize(item: &syn::DeriveInput) -> Result<Tokens, String\n \n     let impl_generics = build_impl_generics(&item);\n \n-    let ty = aster::ty().path()\n-        .segment(item.ident.clone()).with_generics(impl_generics.clone()).build()\n+    let ty = aster::ty()\n+        .path()\n+        .segment(item.ident.clone())\n+        .with_generics(impl_generics.clone())\n+        .build()\n         .build();\n \n-    let body = serialize_body(&item,\n-                              &impl_generics,\n-                              ty.clone());\n+    let body = serialize_body(&item, &impl_generics, ty.clone());\n \n     let where_clause = &impl_generics.where_clause;\n \n@@ -45,18 +46,16 @@ pub fn expand_derive_serialize(item: &syn::DeriveInput) -> Result<Tokens, String\n fn build_impl_generics(item: &Item) -> syn::Generics {\n     let generics = bound::without_defaults(item.generics);\n \n-    let generics = bound::with_where_predicates_from_fields(\n-        item, &generics,\n-        |attrs| attrs.ser_bound());\n+    let generics =\n+        bound::with_where_predicates_from_fields(item, &generics, |attrs| attrs.ser_bound());\n \n     match item.attrs.ser_bound() {\n-        Some(predicates) => {\n-            bound::with_where_predicates(&generics, predicates)\n-        }\n+        Some(predicates) => bound::with_where_predicates(&generics, predicates),\n         None => {\n-            bound::with_bound(item, &generics,\n-                needs_serialize_bound,\n-                &aster::path().ids(&[\"_serde\", \"Serialize\"]).build())\n+            bound::with_bound(item,\n+                              &generics,\n+                              needs_serialize_bound,\n+                              &aster::path().ids(&[\"_serde\", \"Serialize\"]).build())\n         }\n     }\n }\n@@ -66,58 +65,32 @@ fn build_impl_generics(item: &Item) -> syn::Generics {\n // attribute specify their own bound so we do not generate one. All other fields\n // may need a `T: Serialize` bound where T is the type of the field.\n fn needs_serialize_bound(attrs: &attr::Field) -> bool {\n-    !attrs.skip_serializing()\n-        && attrs.serialize_with().is_none()\n-        && attrs.ser_bound().is_none()\n+    !attrs.skip_serializing() && attrs.serialize_with().is_none() && attrs.ser_bound().is_none()\n }\n \n-fn serialize_body(\n-    item: &Item,\n-    impl_generics: &syn::Generics,\n-    ty: syn::Ty,\n-) -> Tokens {\n+fn serialize_body(item: &Item, impl_generics: &syn::Generics, ty: syn::Ty) -> Tokens {\n     match item.body {\n         Body::Enum(ref variants) => {\n-            serialize_item_enum(\n-                &item.ident,\n-                impl_generics,\n-                ty,\n-                variants,\n-                &item.attrs)\n+            serialize_item_enum(&item.ident, impl_generics, ty, variants, &item.attrs)\n         }\n         Body::Struct(Style::Struct, ref fields) => {\n             if fields.iter().any(|field| field.ident.is_none()) {\n                 panic!(\"struct has unnamed fields\");\n             }\n \n-            serialize_struct(\n-                impl_generics,\n-                ty,\n-                fields,\n-                &item.attrs)\n+            serialize_struct(impl_generics, ty, fields, &item.attrs)\n         }\n         Body::Struct(Style::Tuple, ref fields) => {\n             if fields.iter().any(|field| field.ident.is_some()) {\n                 panic!(\"tuple struct has named fields\");\n             }\n \n-            serialize_tuple_struct(\n-                impl_generics,\n-                ty,\n-                fields,\n-                &item.attrs)\n+            serialize_tuple_struct(impl_generics, ty, fields, &item.attrs)\n         }\n         Body::Struct(Style::Newtype, ref fields) => {\n-            serialize_newtype_struct(\n-                impl_generics,\n-                ty,\n-                &fields[0],\n-                &item.attrs)\n-        }\n-        Body::Struct(Style::Unit, _) => {\n-            serialize_unit_struct(\n-                &item.attrs)\n+            serialize_newtype_struct(impl_generics, ty, &fields[0], &item.attrs)\n         }\n+        Body::Struct(Style::Unit, _) => serialize_unit_struct(&item.attrs),\n     }\n }\n \n@@ -129,18 +102,16 @@ fn serialize_unit_struct(item_attrs: &attr::Item) -> Tokens {\n     }\n }\n \n-fn serialize_newtype_struct(\n-    impl_generics: &syn::Generics,\n-    item_ty: syn::Ty,\n-    field: &Field,\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n+fn serialize_newtype_struct(impl_generics: &syn::Generics,\n+                            item_ty: syn::Ty,\n+                            field: &Field,\n+                            item_attrs: &attr::Item)\n+                            -> Tokens {\n     let type_name = item_attrs.name().serialize_name();\n \n     let mut field_expr = quote!(&self.0);\n     if let Some(path) = field.attrs.serialize_with() {\n-        field_expr = wrap_serialize_with(\n-            &item_ty, impl_generics, field.ty, path, field_expr);\n+        field_expr = wrap_serialize_with(&item_ty, impl_generics, field.ty, path, field_expr);\n     }\n \n     quote! {\n@@ -148,19 +119,17 @@ fn serialize_newtype_struct(\n     }\n }\n \n-fn serialize_tuple_struct(\n-    impl_generics: &syn::Generics,\n-    ty: syn::Ty,\n-    fields: &[Field],\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n-    let serialize_stmts = serialize_tuple_struct_visitor(\n-        ty.clone(),\n-        fields,\n-        impl_generics,\n-        false,\n-        quote!(_serde::ser::SerializeTupleStruct::serialize_field),\n-    );\n+fn serialize_tuple_struct(impl_generics: &syn::Generics,\n+                          ty: syn::Ty,\n+                          fields: &[Field],\n+                          item_attrs: &attr::Item)\n+                          -> Tokens {\n+    let serialize_stmts =\n+        serialize_tuple_struct_visitor(ty.clone(),\n+                                       fields,\n+                                       impl_generics,\n+                                       false,\n+                                       quote!(_serde::ser::SerializeTupleStruct::serialize_field));\n \n     let type_name = item_attrs.name().serialize_name();\n     let len = serialize_stmts.len();\n@@ -173,19 +142,17 @@ fn serialize_tuple_struct(\n     }\n }\n \n-fn serialize_struct(\n-    impl_generics: &syn::Generics,\n-    ty: syn::Ty,\n-    fields: &[Field],\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n-    let serialize_fields = serialize_struct_visitor(\n-        ty.clone(),\n-        fields,\n-        impl_generics,\n-        false,\n-        quote!(_serde::ser::SerializeStruct::serialize_field),\n-    );\n+fn serialize_struct(impl_generics: &syn::Generics,\n+                    ty: syn::Ty,\n+                    fields: &[Field],\n+                    item_attrs: &attr::Item)\n+                    -> Tokens {\n+    let serialize_fields =\n+        serialize_struct_visitor(ty.clone(),\n+                                 fields,\n+                                 impl_generics,\n+                                 false,\n+                                 quote!(_serde::ser::SerializeStruct::serialize_field));\n \n     let type_name = item_attrs.name().serialize_name();\n \n@@ -195,8 +162,7 @@ fn serialize_struct(\n \n     let let_mut = mut_if(serialized_fields.peek().is_some());\n \n-    let len = serialized_fields\n-        .map(|field| {\n+    let len = serialized_fields.map(|field| {\n             let ident = field.ident.clone().expect(\"struct has unnamed fields\");\n             let field_expr = quote!(&self.#ident);\n \n@@ -204,7 +170,7 @@ fn serialize_struct(\n                 Some(path) => quote!(if #path(#field_expr) { 0 } else { 1 }),\n                 None => quote!(1),\n             }\n-         })\n+        })\n         .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n \n     quote! {\n@@ -214,27 +180,23 @@ fn serialize_struct(\n     }\n }\n \n-fn serialize_item_enum(\n-    type_ident: &syn::Ident,\n-    impl_generics: &syn::Generics,\n-    ty: syn::Ty,\n-    variants: &[Variant],\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n-    let arms: Vec<_> =\n-        variants.iter()\n-            .enumerate()\n-            .map(|(variant_index, variant)| {\n-                serialize_variant(\n-                    type_ident,\n-                    impl_generics,\n-                    ty.clone(),\n-                    variant,\n-                    variant_index,\n-                    item_attrs,\n-                )\n-            })\n-            .collect();\n+fn serialize_item_enum(type_ident: &syn::Ident,\n+                       impl_generics: &syn::Generics,\n+                       ty: syn::Ty,\n+                       variants: &[Variant],\n+                       item_attrs: &attr::Item)\n+                       -> Tokens {\n+    let arms: Vec<_> = variants.iter()\n+        .enumerate()\n+        .map(|(variant_index, variant)| {\n+            serialize_variant(type_ident,\n+                              impl_generics,\n+                              ty.clone(),\n+                              variant,\n+                              variant_index,\n+                              item_attrs)\n+        })\n+        .collect();\n \n     quote! {\n         match *self {\n@@ -243,14 +205,13 @@ fn serialize_item_enum(\n     }\n }\n \n-fn serialize_variant(\n-    type_ident: &syn::Ident,\n-    generics: &syn::Generics,\n-    ty: syn::Ty,\n-    variant: &Variant,\n-    variant_index: usize,\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n+fn serialize_variant(type_ident: &syn::Ident,\n+                     generics: &syn::Generics,\n+                     ty: syn::Ty,\n+                     variant: &Variant,\n+                     variant_index: usize,\n+                     item_attrs: &attr::Item)\n+                     -> Tokens {\n     let variant_ident = variant.ident.clone();\n \n     if variant.attrs.skip_serializing() {\n@@ -267,7 +228,8 @@ fn serialize_variant(\n         quote! {\n             #type_ident::#variant_ident #fields_pat => #skipped_err,\n         }\n-    } else { // variant wasn't skipped\n+    } else {\n+        // variant wasn't skipped\n         let case = match variant.style {\n             Style::Unit => {\n                 quote! {\n@@ -280,14 +242,15 @@ fn serialize_variant(\n                 }\n             }\n             Style::Tuple => {\n-                let field_names = (0 .. variant.fields.len())\n+                let field_names = (0..variant.fields.len())\n                     .map(|i| Ident::new(format!(\"__field{}\", i)));\n                 quote! {\n                     #type_ident::#variant_ident(#(ref #field_names),*)\n                 }\n             }\n             Style::Struct => {\n-                let fields = variant.fields.iter()\n+                let fields = variant.fields\n+                    .iter()\n                     .map(|f| f.ident.clone().expect(\"struct variant has unnamed fields\"));\n                 quote! {\n                     #type_ident::#variant_ident { #(ref #fields),* }\n@@ -297,33 +260,22 @@ fn serialize_variant(\n \n         let body = match *item_attrs.tag() {\n             attr::EnumTag::External => {\n-                serialize_externally_tagged_variant(\n-                    generics,\n-                    ty,\n-                    variant,\n-                    variant_index,\n-                    item_attrs,\n-                )\n+                serialize_externally_tagged_variant(generics,\n+                                                    ty,\n+                                                    variant,\n+                                                    variant_index,\n+                                                    item_attrs)\n             }\n             attr::EnumTag::Internal(ref tag) => {\n-                serialize_internally_tagged_variant(\n-                    type_ident.as_ref(),\n-                    variant_ident.as_ref(),\n-                    generics,\n-                    ty,\n-                    variant,\n-                    item_attrs,\n-                    tag,\n-                )\n-            }\n-            attr::EnumTag::None => {\n-                serialize_untagged_variant(\n-                    generics,\n-                    ty,\n-                    variant,\n-                    item_attrs,\n-                )\n-            }\n+                serialize_internally_tagged_variant(type_ident.as_ref(),\n+                                                    variant_ident.as_ref(),\n+                                                    generics,\n+                                                    ty,\n+                                                    variant,\n+                                                    item_attrs,\n+                                                    tag)\n+            }\n+            attr::EnumTag::None => serialize_untagged_variant(generics, ty, variant, item_attrs),\n         };\n \n         quote! {\n@@ -332,13 +284,12 @@ fn serialize_variant(\n     }\n }\n \n-fn serialize_externally_tagged_variant(\n-    generics: &syn::Generics,\n-    ty: syn::Ty,\n-    variant: &Variant,\n-    variant_index: usize,\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n+fn serialize_externally_tagged_variant(generics: &syn::Generics,\n+                                       ty: syn::Ty,\n+                                       variant: &Variant,\n+                                       variant_index: usize,\n+                                       item_attrs: &attr::Item)\n+                                       -> Tokens {\n     let type_name = item_attrs.name().serialize_name();\n     let variant_name = variant.attrs.name().serialize_name();\n \n@@ -357,8 +308,7 @@ fn serialize_externally_tagged_variant(\n             let field = &variant.fields[0];\n             let mut field_expr = quote!(__simple_value);\n             if let Some(path) = field.attrs.serialize_with() {\n-                field_expr = wrap_serialize_with(\n-                    &ty, generics, field.ty, path, field_expr);\n+                field_expr = wrap_serialize_with(&ty, generics, field.ty, path, field_expr);\n             }\n \n             quote! {\n@@ -372,32 +322,28 @@ fn serialize_externally_tagged_variant(\n             }\n         }\n         Style::Tuple => {\n-            let block = serialize_tuple_variant(\n-                TupleVariant::ExternallyTagged {\n-                    type_name: type_name,\n-                    variant_index: variant_index,\n-                    variant_name: variant_name,\n-                },\n-                generics,\n-                ty,\n-                &variant.fields,\n-            );\n+            let block = serialize_tuple_variant(TupleVariant::ExternallyTagged {\n+                                                    type_name: type_name,\n+                                                    variant_index: variant_index,\n+                                                    variant_name: variant_name,\n+                                                },\n+                                                generics,\n+                                                ty,\n+                                                &variant.fields);\n \n             quote! {\n                 { #block }\n             }\n         }\n         Style::Struct => {\n-            let block = serialize_struct_variant(\n-                StructVariant::ExternallyTagged {\n-                    variant_index: variant_index,\n-                    variant_name: variant_name,\n-                },\n-                generics,\n-                ty,\n-                &variant.fields,\n-                item_attrs,\n-            );\n+            let block = serialize_struct_variant(StructVariant::ExternallyTagged {\n+                                                     variant_index: variant_index,\n+                                                     variant_name: variant_name,\n+                                                 },\n+                                                 generics,\n+                                                 ty,\n+                                                 &variant.fields,\n+                                                 item_attrs);\n \n             quote! {\n                 { #block }\n@@ -406,15 +352,14 @@ fn serialize_externally_tagged_variant(\n     }\n }\n \n-fn serialize_internally_tagged_variant(\n-    type_ident: &str,\n-    variant_ident: &str,\n-    generics: &syn::Generics,\n-    ty: syn::Ty,\n-    variant: &Variant,\n-    item_attrs: &attr::Item,\n-    tag: &str,\n-) -> Tokens {\n+fn serialize_internally_tagged_variant(type_ident: &str,\n+                                       variant_ident: &str,\n+                                       generics: &syn::Generics,\n+                                       ty: syn::Ty,\n+                                       variant: &Variant,\n+                                       item_attrs: &attr::Item,\n+                                       tag: &str)\n+                                       -> Tokens {\n     let type_name = item_attrs.name().serialize_name();\n     let variant_name = variant.attrs.name().serialize_name();\n \n@@ -432,8 +377,7 @@ fn serialize_internally_tagged_variant(\n             let field = &variant.fields[0];\n             let mut field_expr = quote!(__simple_value);\n             if let Some(path) = field.attrs.serialize_with() {\n-                field_expr = wrap_serialize_with(\n-                    &ty, generics, field.ty, path, field_expr);\n+                field_expr = wrap_serialize_with(&ty, generics, field.ty, path, field_expr);\n             }\n \n             quote! {\n@@ -448,16 +392,14 @@ fn serialize_internally_tagged_variant(\n             }\n         }\n         Style::Struct => {\n-            let block = serialize_struct_variant(\n-                StructVariant::InternallyTagged {\n-                    tag: tag,\n-                    variant_name: variant_name,\n-                },\n-                generics,\n-                ty,\n-                &variant.fields,\n-                item_attrs,\n-            );\n+            let block = serialize_struct_variant(StructVariant::InternallyTagged {\n+                                                     tag: tag,\n+                                                     variant_name: variant_name,\n+                                                 },\n+                                                 generics,\n+                                                 ty,\n+                                                 &variant.fields,\n+                                                 item_attrs);\n \n             quote! {\n                 { #block }\n@@ -467,12 +409,11 @@ fn serialize_internally_tagged_variant(\n     }\n }\n \n-fn serialize_untagged_variant(\n-    generics: &syn::Generics,\n-    ty: syn::Ty,\n-    variant: &Variant,\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n+fn serialize_untagged_variant(generics: &syn::Generics,\n+                              ty: syn::Ty,\n+                              variant: &Variant,\n+                              item_attrs: &attr::Item)\n+                              -> Tokens {\n     match variant.style {\n         Style::Unit => {\n             quote! {\n@@ -483,8 +424,7 @@ fn serialize_untagged_variant(\n             let field = &variant.fields[0];\n             let mut field_expr = quote!(__simple_value);\n             if let Some(path) = field.attrs.serialize_with() {\n-                field_expr = wrap_serialize_with(\n-                    &ty, generics, field.ty, path, field_expr);\n+                field_expr = wrap_serialize_with(&ty, generics, field.ty, path, field_expr);\n             }\n \n             quote! {\n@@ -492,25 +432,19 @@ fn serialize_untagged_variant(\n             }\n         }\n         Style::Tuple => {\n-            let block = serialize_tuple_variant(\n-                TupleVariant::Untagged,\n-                generics,\n-                ty,\n-                &variant.fields,\n-            );\n+            let block =\n+                serialize_tuple_variant(TupleVariant::Untagged, generics, ty, &variant.fields);\n \n             quote! {\n                 { #block }\n             }\n         }\n         Style::Struct => {\n-            let block = serialize_struct_variant(\n-                StructVariant::Untagged,\n-                generics,\n-                ty,\n-                &variant.fields,\n-                item_attrs,\n-            );\n+            let block = serialize_struct_variant(StructVariant::Untagged,\n+                                                 generics,\n+                                                 ty,\n+                                                 &variant.fields,\n+                                                 item_attrs);\n \n             quote! {\n                 { #block }\n@@ -528,28 +462,20 @@ enum TupleVariant {\n     Untagged,\n }\n \n-fn serialize_tuple_variant(\n-    context: TupleVariant,\n-    generics: &syn::Generics,\n-    structure_ty: syn::Ty,\n-    fields: &[Field],\n-) -> Tokens {\n+fn serialize_tuple_variant(context: TupleVariant,\n+                           generics: &syn::Generics,\n+                           structure_ty: syn::Ty,\n+                           fields: &[Field])\n+                           -> Tokens {\n     let method = match context {\n-        TupleVariant::ExternallyTagged{..} => {\n+        TupleVariant::ExternallyTagged { .. } => {\n             quote!(_serde::ser::SerializeTupleVariant::serialize_field)\n         }\n-        TupleVariant::Untagged => {\n-            quote!(_serde::ser::SerializeTuple::serialize_element)\n-        }\n+        TupleVariant::Untagged => quote!(_serde::ser::SerializeTuple::serialize_element),\n     };\n \n-    let serialize_stmts = serialize_tuple_struct_visitor(\n-        structure_ty,\n-        fields,\n-        generics,\n-        true,\n-        method,\n-    );\n+    let serialize_stmts =\n+        serialize_tuple_struct_visitor(structure_ty, fields, generics, true, method);\n \n     let len = serialize_stmts.len();\n     let let_mut = mut_if(len > 0);\n@@ -584,36 +510,25 @@ enum StructVariant<'a> {\n         variant_index: usize,\n         variant_name: String,\n     },\n-    InternallyTagged {\n-        tag: &'a str,\n-        variant_name: String,\n-    },\n+    InternallyTagged { tag: &'a str, variant_name: String },\n     Untagged,\n }\n \n-fn serialize_struct_variant<'a>(\n-    context: StructVariant<'a>,\n-    generics: &syn::Generics,\n-    ty: syn::Ty,\n-    fields: &[Field],\n-    item_attrs: &attr::Item,\n-) -> Tokens {\n+fn serialize_struct_variant<'a>(context: StructVariant<'a>,\n+                                generics: &syn::Generics,\n+                                ty: syn::Ty,\n+                                fields: &[Field],\n+                                item_attrs: &attr::Item)\n+                                -> Tokens {\n     let method = match context {\n-        StructVariant::ExternallyTagged{..} => {\n+        StructVariant::ExternallyTagged { .. } => {\n             quote!(_serde::ser::SerializeStructVariant::serialize_field)\n         }\n-        StructVariant::InternallyTagged{..} | StructVariant::Untagged => {\n-            quote!(_serde::ser::SerializeStruct::serialize_field)\n-        }\n+        StructVariant::InternallyTagged { .. } |\n+        StructVariant::Untagged => quote!(_serde::ser::SerializeStruct::serialize_field),\n     };\n \n-    let serialize_fields = serialize_struct_visitor(\n-        ty.clone(),\n-        fields,\n-        generics,\n-        true,\n-        method,\n-    );\n+    let serialize_fields = serialize_struct_visitor(ty.clone(), fields, generics, true, method);\n \n     let item_name = item_attrs.name().serialize_name();\n \n@@ -623,15 +538,14 @@ fn serialize_struct_variant<'a>(\n \n     let let_mut = mut_if(serialized_fields.peek().is_some());\n \n-    let len = serialized_fields\n-        .map(|field| {\n+    let len = serialized_fields.map(|field| {\n             let ident = field.ident.clone().expect(\"struct has unnamed fields\");\n \n             match field.attrs.skip_serializing_if() {\n                 Some(path) => quote!(if #path(#ident) { 0 } else { 1 }),\n                 None => quote!(1),\n             }\n-         })\n+        })\n         .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n \n     match context {\n@@ -678,13 +592,12 @@ fn serialize_struct_variant<'a>(\n     }\n }\n \n-fn serialize_tuple_struct_visitor(\n-    structure_ty: syn::Ty,\n-    fields: &[Field],\n-    generics: &syn::Generics,\n-    is_enum: bool,\n-    func: Tokens,\n-) -> Vec<Tokens> {\n+fn serialize_tuple_struct_visitor(structure_ty: syn::Ty,\n+                                  fields: &[Field],\n+                                  generics: &syn::Generics,\n+                                  is_enum: bool,\n+                                  func: Tokens)\n+                                  -> Vec<Tokens> {\n     fields.iter()\n         .enumerate()\n         .map(|(i, field)| {\n@@ -696,12 +609,13 @@ fn serialize_tuple_struct_visitor(\n                 quote!(&self.#i)\n             };\n \n-            let skip = field.attrs.skip_serializing_if()\n+            let skip = field.attrs\n+                .skip_serializing_if()\n                 .map(|path| quote!(#path(#field_expr)));\n \n             if let Some(path) = field.attrs.serialize_with() {\n-                field_expr = wrap_serialize_with(\n-                    &structure_ty, generics, field.ty, path, field_expr);\n+                field_expr =\n+                    wrap_serialize_with(&structure_ty, generics, field.ty, path, field_expr);\n             }\n \n             let ser = quote! {\n@@ -716,13 +630,12 @@ fn serialize_tuple_struct_visitor(\n         .collect()\n }\n \n-fn serialize_struct_visitor(\n-    structure_ty: syn::Ty,\n-    fields: &[Field],\n-    generics: &syn::Generics,\n-    is_enum: bool,\n-    func: Tokens,\n-) -> Vec<Tokens> {\n+fn serialize_struct_visitor(structure_ty: syn::Ty,\n+                            fields: &[Field],\n+                            generics: &syn::Generics,\n+                            is_enum: bool,\n+                            func: Tokens)\n+                            -> Vec<Tokens> {\n     fields.iter()\n         .filter(|&field| !field.attrs.skip_serializing())\n         .map(|field| {\n@@ -735,12 +648,13 @@ fn serialize_struct_visitor(\n \n             let key_expr = field.attrs.name().serialize_name();\n \n-            let skip = field.attrs.skip_serializing_if()\n+            let skip = field.attrs\n+                .skip_serializing_if()\n                 .map(|path| quote!(#path(#field_expr)));\n \n             if let Some(path) = field.attrs.serialize_with() {\n-                field_expr = wrap_serialize_with(\n-                    &structure_ty, generics, field.ty, path, field_expr)\n+                field_expr =\n+                    wrap_serialize_with(&structure_ty, generics, field.ty, path, field_expr)\n             }\n \n             let ser = quote! {\n@@ -755,13 +669,12 @@ fn serialize_struct_visitor(\n         .collect()\n }\n \n-fn wrap_serialize_with(\n-    item_ty: &syn::Ty,\n-    generics: &syn::Generics,\n-    field_ty: &syn::Ty,\n-    path: &syn::Path,\n-    value: Tokens,\n-) -> Tokens {\n+fn wrap_serialize_with(item_ty: &syn::Ty,\n+                       generics: &syn::Generics,\n+                       field_ty: &syn::Ty,\n+                       path: &syn::Path,\n+                       value: Tokens)\n+                       -> Tokens {\n     let where_clause = &generics.where_clause;\n \n     let wrapper_generics = aster::from_generics(generics.clone())\n@@ -771,8 +684,8 @@ fn wrap_serialize_with(\n \n     let wrapper_ty = aster::path()\n         .segment(\"__SerializeWith\")\n-            .with_generics(wrapper_generics.clone())\n-            .build()\n+        .with_generics(wrapper_generics.clone())\n+        .build()\n         .build();\n \n     quote!({\n@@ -803,9 +716,5 @@ fn wrap_serialize_with(\n //\n // where we want to omit the `mut` to avoid a warning.\n fn mut_if(is_mut: bool) -> Option<Tokens> {\n-    if is_mut {\n-        Some(quote!(mut))\n-    } else {\n-        None\n-    }\n+    if is_mut { Some(quote!(mut)) } else { None }\n }\n", "test_patch": "diff --git a/serde_test/src/assert.rs b/serde_test/src/assert.rs\nindex b5e03f52e..3abb87d71 100644\n--- a/serde_test/src/assert.rs\n+++ b/serde_test/src/assert.rs\n@@ -8,14 +8,14 @@ use token::Token;\n use std::fmt::Debug;\n \n pub fn assert_tokens<T>(value: &T, tokens: &[Token<'static>])\n-    where T: Serialize + Deserialize + PartialEq + Debug,\n+    where T: Serialize + Deserialize + PartialEq + Debug\n {\n     assert_ser_tokens(value, tokens);\n     assert_de_tokens(value, tokens);\n }\n \n pub fn assert_ser_tokens<T>(value: &T, tokens: &[Token])\n-    where T: Serialize,\n+    where T: Serialize\n {\n     let mut ser = Serializer::new(tokens.iter());\n     assert_eq!(Serialize::serialize(value, &mut ser), Ok(()));\n@@ -24,7 +24,7 @@ pub fn assert_ser_tokens<T>(value: &T, tokens: &[Token])\n \n /// Expect an error serializing `T`.\n pub fn assert_ser_tokens_error<T>(value: &T, tokens: &[Token], error: Error)\n-    where T: Serialize + PartialEq + Debug,\n+    where T: Serialize + PartialEq + Debug\n {\n     let mut ser = Serializer::new(tokens.iter());\n     let v: Result<(), Error> = Serialize::serialize(value, &mut ser);\n@@ -33,7 +33,7 @@ pub fn assert_ser_tokens_error<T>(value: &T, tokens: &[Token], error: Error)\n }\n \n pub fn assert_de_tokens<T>(value: &T, tokens: &[Token<'static>])\n-    where T: Deserialize + PartialEq + Debug,\n+    where T: Deserialize + PartialEq + Debug\n {\n     let mut de = Deserializer::new(tokens.to_vec().into_iter());\n     let v: Result<T, Error> = Deserialize::deserialize(&mut de);\n@@ -43,7 +43,7 @@ pub fn assert_de_tokens<T>(value: &T, tokens: &[Token<'static>])\n \n /// Expect an error deserializing tokens into a `T`.\n pub fn assert_de_tokens_error<T>(tokens: &[Token<'static>], error: Error)\n-    where T: Deserialize + PartialEq + Debug,\n+    where T: Deserialize + PartialEq + Debug\n {\n     let mut de = Deserializer::new(tokens.to_vec().into_iter());\n     let v: Result<T, Error> = Deserialize::deserialize(&mut de);\ndiff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 138ed0cd9..816c7d37c 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -1,33 +1,23 @@\n use std::iter;\n \n-use serde::de::{\n-    self,\n-    Deserialize,\n-    DeserializeSeed,\n-    EnumVisitor,\n-    MapVisitor,\n-    SeqVisitor,\n-    VariantVisitor,\n-    Visitor,\n-};\n+use serde::de::{self, Deserialize, DeserializeSeed, EnumVisitor, MapVisitor, SeqVisitor,\n+                VariantVisitor, Visitor};\n use serde::de::value::ValueDeserializer;\n \n use error::Error;\n use token::Token;\n \n pub struct Deserializer<I>\n-    where I: Iterator<Item=Token<'static>>,\n+    where I: Iterator<Item = Token<'static>>\n {\n     tokens: iter::Peekable<I>,\n }\n \n impl<I> Deserializer<I>\n-    where I: Iterator<Item=Token<'static>>,\n+    where I: Iterator<Item = Token<'static>>\n {\n     pub fn new(tokens: I) -> Deserializer<I> {\n-        Deserializer {\n-            tokens: tokens.peekable(),\n-        }\n+        Deserializer { tokens: tokens.peekable() }\n     }\n \n     pub fn next_token(&mut self) -> Option<Token<'static>> {\n@@ -47,8 +37,13 @@ impl<I> Deserializer<I>\n         }\n     }\n \n-    fn visit_seq<V>(&mut self, len: Option<usize>, sep: Token<'static>, end: Token<'static>, visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+    fn visit_seq<V>(&mut self,\n+                    len: Option<usize>,\n+                    sep: Token<'static>,\n+                    end: Token<'static>,\n+                    visitor: V)\n+                    -> Result<V::Value, Error>\n+        where V: Visitor\n     {\n         let value = try!(visitor.visit_seq(DeserializerSeqVisitor {\n             de: self,\n@@ -60,8 +55,13 @@ impl<I> Deserializer<I>\n         Ok(value)\n     }\n \n-    fn visit_map<V>(&mut self, len: Option<usize>, sep: Token<'static>, end: Token<'static>, visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+    fn visit_map<V>(&mut self,\n+                    len: Option<usize>,\n+                    sep: Token<'static>,\n+                    end: Token<'static>,\n+                    visitor: V)\n+                    -> Result<V::Value, Error>\n+        where V: Visitor\n     {\n         let value = try!(visitor.visit_map(DeserializerMapVisitor {\n             de: self,\n@@ -75,7 +75,7 @@ impl<I> Deserializer<I>\n }\n \n impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n-    where I: Iterator<Item=Token<'static>>,\n+    where I: Iterator<Item = Token<'static>>\n {\n     type Error = Error;\n \n@@ -85,7 +85,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n     }\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+        where V: Visitor\n     {\n         match self.tokens.next() {\n             Some(Token::Bool(v)) => visitor.visit_bool(v),\n@@ -118,7 +118,10 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n                 self.visit_seq(Some(len), Token::TupleSep, Token::TupleEnd, visitor)\n             }\n             Some(Token::TupleStructStart(_, len)) => {\n-                self.visit_seq(Some(len), Token::TupleStructSep, Token::TupleStructEnd, visitor)\n+                self.visit_seq(Some(len),\n+                               Token::TupleStructSep,\n+                               Token::TupleStructEnd,\n+                               visitor)\n             }\n             Some(Token::MapStart(len)) => {\n                 self.visit_map(len, Token::MapSep, Token::MapEnd, visitor)\n@@ -134,10 +137,11 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n     /// Hook into `Option` deserializing so we can treat `Unit` as a\n     /// `None`, or a regular value as `Some(value)`.\n     fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+        where V: Visitor\n     {\n         match self.tokens.peek() {\n-            Some(&Token::Unit) | Some(&Token::Option(false)) => {\n+            Some(&Token::Unit) |\n+            Some(&Token::Option(false)) => {\n                 self.tokens.next();\n                 visitor.visit_none()\n             }\n@@ -151,26 +155,23 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n     }\n \n     fn deserialize_enum<V>(self,\n-                     name: &str,\n-                     _variants: &'static [&'static str],\n-                     visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+                           name: &str,\n+                           _variants: &'static [&'static str],\n+                           visitor: V)\n+                           -> Result<V::Value, Error>\n+        where V: Visitor\n     {\n         match self.tokens.peek() {\n             Some(&Token::EnumStart(n)) if name == n => {\n                 self.tokens.next();\n \n-                visitor.visit_enum(DeserializerEnumVisitor {\n-                    de: self,\n-                })\n+                visitor.visit_enum(DeserializerEnumVisitor { de: self })\n             }\n-            Some(&Token::EnumUnit(n, _))\n-            | Some(&Token::EnumNewType(n, _))\n-            | Some(&Token::EnumSeqStart(n, _, _))\n-            | Some(&Token::EnumMapStart(n, _, _)) if name == n => {\n-                visitor.visit_enum(DeserializerEnumVisitor {\n-                    de: self,\n-                })\n+            Some(&Token::EnumUnit(n, _)) |\n+            Some(&Token::EnumNewType(n, _)) |\n+            Some(&Token::EnumSeqStart(n, _, _)) |\n+            Some(&Token::EnumMapStart(n, _, _)) if name == n => {\n+                visitor.visit_enum(DeserializerEnumVisitor { de: self })\n             }\n             Some(_) => {\n                 let token = self.tokens.next().unwrap();\n@@ -181,7 +182,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n     }\n \n     fn deserialize_unit_struct<V>(self, name: &str, visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+        where V: Visitor\n     {\n         match self.tokens.peek() {\n             Some(&Token::UnitStruct(n)) => {\n@@ -197,10 +198,8 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n         }\n     }\n \n-    fn deserialize_newtype_struct<V>(self,\n-                                     name: &str,\n-                                     visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+    fn deserialize_newtype_struct<V>(self, name: &str, visitor: V) -> Result<V::Value, Error>\n+        where V: Visitor\n     {\n         match self.tokens.peek() {\n             Some(&Token::StructNewType(n)) => {\n@@ -216,10 +215,8 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n         }\n     }\n \n-    fn deserialize_seq_fixed_size<V>(self,\n-                                       len: usize,\n-                                       visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+    fn deserialize_seq_fixed_size<V>(self, len: usize, visitor: V) -> Result<V::Value, Error>\n+        where V: Visitor\n     {\n         match self.tokens.peek() {\n             Some(&Token::SeqArrayStart(_)) => {\n@@ -231,13 +228,12 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n         }\n     }\n \n-    fn deserialize_tuple<V>(self,\n-                            len: usize,\n-                            visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+    fn deserialize_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Error>\n+        where V: Visitor\n     {\n         match self.tokens.peek() {\n-            Some(&Token::Unit) | Some(&Token::UnitStruct(_)) => {\n+            Some(&Token::Unit) |\n+            Some(&Token::UnitStruct(_)) => {\n                 self.tokens.next();\n                 visitor.visit_unit()\n             }\n@@ -255,7 +251,10 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n             }\n             Some(&Token::TupleStructStart(_, _)) => {\n                 self.tokens.next();\n-                self.visit_seq(Some(len), Token::TupleStructSep, Token::TupleStructEnd, visitor)\n+                self.visit_seq(Some(len),\n+                               Token::TupleStructSep,\n+                               Token::TupleStructEnd,\n+                               visitor)\n             }\n             Some(_) => self.deserialize(visitor),\n             None => Err(Error::EndOfTokens),\n@@ -265,8 +264,9 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n     fn deserialize_tuple_struct<V>(self,\n                                    name: &str,\n                                    len: usize,\n-                                   visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+                                   visitor: V)\n+                                   -> Result<V::Value, Error>\n+        where V: Visitor\n     {\n         match self.tokens.peek() {\n             Some(&Token::Unit) => {\n@@ -296,7 +296,10 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n             Some(&Token::TupleStructStart(n, _)) => {\n                 self.tokens.next();\n                 if name == n {\n-                    self.visit_seq(Some(len), Token::TupleStructSep, Token::TupleStructEnd, visitor)\n+                    self.visit_seq(Some(len),\n+                                   Token::TupleStructSep,\n+                                   Token::TupleStructEnd,\n+                                   visitor)\n                 } else {\n                     Err(Error::InvalidName(n))\n                 }\n@@ -309,14 +312,18 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n     fn deserialize_struct<V>(self,\n                              name: &str,\n                              fields: &'static [&'static str],\n-                             visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+                             visitor: V)\n+                             -> Result<V::Value, Error>\n+        where V: Visitor\n     {\n         match self.tokens.peek() {\n             Some(&Token::StructStart(n, _)) => {\n                 self.tokens.next();\n                 if name == n {\n-                    self.visit_map(Some(fields.len()), Token::StructSep, Token::StructEnd, visitor)\n+                    self.visit_map(Some(fields.len()),\n+                                   Token::StructSep,\n+                                   Token::StructEnd,\n+                                   visitor)\n                 } else {\n                     Err(Error::InvalidName(n))\n                 }\n@@ -333,7 +340,9 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n \n //////////////////////////////////////////////////////////////////////////\n \n-struct DeserializerSeqVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n+struct DeserializerSeqVisitor<'a, I: 'a>\n+    where I: Iterator<Item = Token<'static>>\n+{\n     de: &'a mut Deserializer<I>,\n     len: Option<usize>,\n     sep: Token<'static>,\n@@ -341,12 +350,12 @@ struct DeserializerSeqVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>>\n }\n \n impl<'a, I> SeqVisitor for DeserializerSeqVisitor<'a, I>\n-    where I: Iterator<Item=Token<'static>>,\n+    where I: Iterator<Item = Token<'static>>\n {\n     type Error = Error;\n \n     fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n-        where T: DeserializeSeed,\n+        where T: DeserializeSeed\n     {\n         if self.de.tokens.peek() == Some(&self.end) {\n             return Ok(None);\n@@ -369,7 +378,9 @@ impl<'a, I> SeqVisitor for DeserializerSeqVisitor<'a, I>\n \n //////////////////////////////////////////////////////////////////////////\n \n-struct DeserializerMapVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n+struct DeserializerMapVisitor<'a, I: 'a>\n+    where I: Iterator<Item = Token<'static>>\n+{\n     de: &'a mut Deserializer<I>,\n     len: Option<usize>,\n     sep: Token<'static>,\n@@ -377,12 +388,12 @@ struct DeserializerMapVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>>\n }\n \n impl<'a, I> MapVisitor for DeserializerMapVisitor<'a, I>\n-    where I: Iterator<Item=Token<'static>>,\n+    where I: Iterator<Item = Token<'static>>\n {\n     type Error = Error;\n \n     fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n-        where K: DeserializeSeed,\n+        where K: DeserializeSeed\n     {\n         if self.de.tokens.peek() == Some(&self.end) {\n             return Ok(None);\n@@ -398,7 +409,7 @@ impl<'a, I> MapVisitor for DeserializerMapVisitor<'a, I>\n     }\n \n     fn visit_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n-        where V: DeserializeSeed,\n+        where V: DeserializeSeed\n     {\n         seed.deserialize(&mut *self.de)\n     }\n@@ -411,24 +422,26 @@ impl<'a, I> MapVisitor for DeserializerMapVisitor<'a, I>\n \n //////////////////////////////////////////////////////////////////////////\n \n-struct DeserializerEnumVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n+struct DeserializerEnumVisitor<'a, I: 'a>\n+    where I: Iterator<Item = Token<'static>>\n+{\n     de: &'a mut Deserializer<I>,\n }\n \n impl<'a, I> EnumVisitor for DeserializerEnumVisitor<'a, I>\n-    where I: Iterator<Item=Token<'static>>,\n+    where I: Iterator<Item = Token<'static>>\n {\n     type Error = Error;\n     type Variant = Self;\n \n     fn visit_variant_seed<V>(self, seed: V) -> Result<(V::Value, Self), Error>\n-        where V: DeserializeSeed,\n+        where V: DeserializeSeed\n     {\n         match self.de.tokens.peek() {\n-            Some(&Token::EnumUnit(_, v))\n-            | Some(&Token::EnumNewType(_, v))\n-            | Some(&Token::EnumSeqStart(_, v, _))\n-            | Some(&Token::EnumMapStart(_, v, _)) => {\n+            Some(&Token::EnumUnit(_, v)) |\n+            Some(&Token::EnumNewType(_, v)) |\n+            Some(&Token::EnumSeqStart(_, v, _)) |\n+            Some(&Token::EnumMapStart(_, v, _)) => {\n                 let de = v.into_deserializer();\n                 let value = try!(seed.deserialize(de));\n                 Ok((value, self))\n@@ -443,7 +456,7 @@ impl<'a, I> EnumVisitor for DeserializerEnumVisitor<'a, I>\n }\n \n impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n-    where I: Iterator<Item=Token<'static>>\n+    where I: Iterator<Item = Token<'static>>\n {\n     type Error = Error;\n \n@@ -453,32 +466,26 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n                 self.de.tokens.next();\n                 Ok(())\n             }\n-            Some(_) => {\n-                Deserialize::deserialize(self.de)\n-            }\n+            Some(_) => Deserialize::deserialize(self.de),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n \n     fn visit_newtype_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n-        where T: DeserializeSeed,\n+        where T: DeserializeSeed\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumNewType(_, _)) => {\n                 self.de.tokens.next();\n                 seed.deserialize(self.de)\n             }\n-            Some(_) => {\n-                seed.deserialize(self.de)\n-            }\n+            Some(_) => seed.deserialize(self.de),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n \n-    fn visit_tuple<V>(self,\n-                      len: usize,\n-                      visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+    fn visit_tuple<V>(self, len: usize, visitor: V) -> Result<V::Value, Error>\n+        where V: Visitor\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumSeqStart(_, _, enum_len)) => {\n@@ -499,24 +506,23 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n                     Err(Error::UnexpectedToken(token))\n                 }\n             }\n-            Some(_) => {\n-                de::Deserializer::deserialize(self.de, visitor)\n-            }\n+            Some(_) => de::Deserializer::deserialize(self.de, visitor),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n \n-    fn visit_struct<V>(self,\n-                       fields: &'static [&'static str],\n-                       visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n+    fn visit_struct<V>(self, fields: &'static [&'static str], visitor: V) -> Result<V::Value, Error>\n+        where V: Visitor\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumMapStart(_, _, enum_len)) => {\n                 let token = self.de.tokens.next().unwrap();\n \n                 if fields.len() == enum_len {\n-                    self.de.visit_map(Some(fields.len()), Token::EnumMapSep, Token::EnumMapEnd, visitor)\n+                    self.de.visit_map(Some(fields.len()),\n+                                      Token::EnumMapSep,\n+                                      Token::EnumMapEnd,\n+                                      visitor)\n                 } else {\n                     Err(Error::UnexpectedToken(token))\n                 }\n@@ -530,9 +536,7 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n                     Err(Error::UnexpectedToken(token))\n                 }\n             }\n-            Some(_) => {\n-                de::Deserializer::deserialize(self.de, visitor)\n-            }\n+            Some(_) => de::Deserializer::deserialize(self.de, visitor),\n             None => Err(Error::EndOfTokens),\n         }\n     }\ndiff --git a/serde_test/src/lib.rs b/serde_test/src/lib.rs\nindex 53f966f67..29668e8c0 100644\n--- a/serde_test/src/lib.rs\n+++ b/serde_test/src/lib.rs\n@@ -2,13 +2,8 @@\n extern crate serde;\n \n mod assert;\n-pub use assert::{\n-    assert_tokens,\n-    assert_ser_tokens,\n-    assert_ser_tokens_error,\n-    assert_de_tokens,\n-    assert_de_tokens_error,\n-};\n+pub use assert::{assert_tokens, assert_ser_tokens, assert_ser_tokens_error, assert_de_tokens,\n+                 assert_de_tokens_error};\n \n mod ser;\n pub use ser::Serializer;\ndiff --git a/serde_test/src/ser.rs b/serde_test/src/ser.rs\nindex 4327733fb..620976a37 100644\n--- a/serde_test/src/ser.rs\n+++ b/serde_test/src/ser.rs\n@@ -6,14 +6,14 @@ use error::Error;\n use token::Token;\n \n pub struct Serializer<'a, I>\n-    where I: Iterator<Item=&'a Token<'a>>,\n+    where I: Iterator<Item = &'a Token<'a>>\n {\n     tokens: I,\n     phantom: PhantomData<&'a Token<'a>>,\n }\n \n impl<'a, I> Serializer<'a, I>\n-    where I: Iterator<Item=&'a Token<'a>>,\n+    where I: Iterator<Item = &'a Token<'a>>\n {\n     pub fn new(tokens: I) -> Serializer<'a, I> {\n         Serializer {\n@@ -28,7 +28,7 @@ impl<'a, I> Serializer<'a, I>\n }\n \n impl<'s, 'a, I> ser::Serializer for &'s mut Serializer<'a, I>\n-    where I: Iterator<Item=&'a Token<'a>>,\n+    where I: Iterator<Item = &'a Token<'a>>\n {\n     type Ok = ();\n     type Error = Error;\n@@ -124,15 +124,14 @@ impl<'s, 'a, I> ser::Serializer for &'s mut Serializer<'a, I>\n     fn serialize_unit_variant(self,\n                               name: &str,\n                               _variant_index: usize,\n-                              variant: &str) -> Result<(), Error> {\n+                              variant: &str)\n+                              -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::EnumUnit(name, variant)));\n         Ok(())\n     }\n \n-    fn serialize_newtype_struct<T: ?Sized>(self,\n-                                           name: &'static str,\n-                                           value: &T) -> Result<(), Error>\n-        where T: Serialize,\n+    fn serialize_newtype_struct<T: ?Sized>(self, name: &'static str, value: &T) -> Result<(), Error>\n+        where T: Serialize\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::StructNewType(name)));\n         value.serialize(self)\n@@ -142,8 +141,9 @@ impl<'s, 'a, I> ser::Serializer for &'s mut Serializer<'a, I>\n                                             name: &str,\n                                             _variant_index: usize,\n                                             variant: &str,\n-                                            value: &T) -> Result<(), Error>\n-        where T: Serialize,\n+                                            value: &T)\n+                                            -> Result<(), Error>\n+        where T: Serialize\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::EnumNewType(name, variant)));\n         value.serialize(self)\n@@ -155,7 +155,7 @@ impl<'s, 'a, I> ser::Serializer for &'s mut Serializer<'a, I>\n     }\n \n     fn serialize_some<T: ?Sized>(self, value: &T) -> Result<(), Error>\n-        where T: Serialize,\n+        where T: Serialize\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::Option(true)));\n         value.serialize(self)\n@@ -177,7 +177,8 @@ impl<'s, 'a, I> ser::Serializer for &'s mut Serializer<'a, I>\n     }\n \n     fn serialize_tuple_struct(self, name: &'static str, len: usize) -> Result<Self, Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::TupleStructStart(name, len)));\n+        assert_eq!(self.tokens.next(),\n+                   Some(&Token::TupleStructStart(name, len)));\n         Ok(self)\n     }\n \n@@ -185,9 +186,10 @@ impl<'s, 'a, I> ser::Serializer for &'s mut Serializer<'a, I>\n                                name: &str,\n                                _variant_index: usize,\n                                variant: &str,\n-                               len: usize) -> Result<Self, Error>\n-    {\n-        assert_eq!(self.tokens.next(), Some(&Token::EnumSeqStart(name, variant, len)));\n+                               len: usize)\n+                               -> Result<Self, Error> {\n+        assert_eq!(self.tokens.next(),\n+                   Some(&Token::EnumSeqStart(name, variant, len)));\n         Ok(self)\n     }\n \n@@ -205,15 +207,16 @@ impl<'s, 'a, I> ser::Serializer for &'s mut Serializer<'a, I>\n                                 name: &str,\n                                 _variant_index: usize,\n                                 variant: &str,\n-                                len: usize) -> Result<Self, Error>\n-    {\n-        assert_eq!(self.tokens.next(), Some(&Token::EnumMapStart(name, variant, len)));\n+                                len: usize)\n+                                -> Result<Self, Error> {\n+        assert_eq!(self.tokens.next(),\n+                   Some(&Token::EnumMapStart(name, variant, len)));\n         Ok(self)\n     }\n }\n \n impl<'s, 'a, I> ser::SerializeSeq for &'s mut Serializer<'a, I>\n-    where I: Iterator<Item=&'a Token<'a>>,\n+    where I: Iterator<Item = &'a Token<'a>>\n {\n     type Ok = ();\n     type Error = Error;\n@@ -232,7 +235,7 @@ impl<'s, 'a, I> ser::SerializeSeq for &'s mut Serializer<'a, I>\n }\n \n impl<'s, 'a, I> ser::SerializeTuple for &'s mut Serializer<'a, I>\n-    where I: Iterator<Item=&'a Token<'a>>,\n+    where I: Iterator<Item = &'a Token<'a>>\n {\n     type Ok = ();\n     type Error = Error;\n@@ -251,7 +254,7 @@ impl<'s, 'a, I> ser::SerializeTuple for &'s mut Serializer<'a, I>\n }\n \n impl<'s, 'a, I> ser::SerializeTupleStruct for &'s mut Serializer<'a, I>\n-    where I: Iterator<Item=&'a Token<'a>>,\n+    where I: Iterator<Item = &'a Token<'a>>\n {\n     type Ok = ();\n     type Error = Error;\n@@ -270,7 +273,7 @@ impl<'s, 'a, I> ser::SerializeTupleStruct for &'s mut Serializer<'a, I>\n }\n \n impl<'s, 'a, I> ser::SerializeTupleVariant for &'s mut Serializer<'a, I>\n-    where I: Iterator<Item=&'a Token<'a>>,\n+    where I: Iterator<Item = &'a Token<'a>>\n {\n     type Ok = ();\n     type Error = Error;\n@@ -289,17 +292,21 @@ impl<'s, 'a, I> ser::SerializeTupleVariant for &'s mut Serializer<'a, I>\n }\n \n impl<'s, 'a, I> ser::SerializeMap for &'s mut Serializer<'a, I>\n-    where I: Iterator<Item=&'a Token<'a>>,\n+    where I: Iterator<Item = &'a Token<'a>>\n {\n     type Ok = ();\n     type Error = Error;\n \n-    fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), Self::Error> where T: Serialize {\n+    fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), Self::Error>\n+        where T: Serialize\n+    {\n         assert_eq!(self.tokens.next(), Some(&Token::MapSep));\n         key.serialize(&mut **self)\n     }\n \n-    fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> where T: Serialize {\n+    fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error>\n+        where T: Serialize\n+    {\n         value.serialize(&mut **self)\n     }\n \n@@ -310,12 +317,17 @@ impl<'s, 'a, I> ser::SerializeMap for &'s mut Serializer<'a, I>\n }\n \n impl<'s, 'a, I> ser::SerializeStruct for &'s mut Serializer<'a, I>\n-    where I: Iterator<Item=&'a Token<'a>>,\n+    where I: Iterator<Item = &'a Token<'a>>\n {\n     type Ok = ();\n     type Error = Error;\n \n-    fn serialize_field<T: ?Sized>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error> where T: Serialize {\n+    fn serialize_field<T: ?Sized>(&mut self,\n+                                  key: &'static str,\n+                                  value: &T)\n+                                  -> Result<(), Self::Error>\n+        where T: Serialize\n+    {\n         assert_eq!(self.tokens.next(), Some(&Token::StructSep));\n         try!(key.serialize(&mut **self));\n         value.serialize(&mut **self)\n@@ -328,12 +340,17 @@ impl<'s, 'a, I> ser::SerializeStruct for &'s mut Serializer<'a, I>\n }\n \n impl<'s, 'a, I> ser::SerializeStructVariant for &'s mut Serializer<'a, I>\n-    where I: Iterator<Item=&'a Token<'a>>,\n+    where I: Iterator<Item = &'a Token<'a>>\n {\n     type Ok = ();\n     type Error = Error;\n \n-    fn serialize_field<T: ?Sized>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error> where T: Serialize {\n+    fn serialize_field<T: ?Sized>(&mut self,\n+                                  key: &'static str,\n+                                  value: &T)\n+                                  -> Result<(), Self::Error>\n+        where T: Serialize\n+    {\n         assert_eq!(self.tokens.next(), Some(&Token::EnumMapSep));\n         try!(key.serialize(&mut **self));\n         value.serialize(&mut **self)\n", "problem_statement": "Consider using rustfmt\n\n", "hints_text": "Overall I am very happy with the formatting in #439. There are a few bugs to iron out and maybe we need to develop new idioms around chained aster builders but I think rustfmt will be a net benefit.\n", "created_at": "2017-02-13T06:17:21Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 739, "instance_id": "serde-rs__serde-739", "issue_numbers": ["415"], "base_commit": "faaa4945790646aa89cd03baf4fc04fd190e8146", "patch": "diff --git a/serde/src/de/content.rs b/serde/src/de/content.rs\nnew file mode 100644\nindex 000000000..fa8875c89\n--- /dev/null\n+++ b/serde/src/de/content.rs\n@@ -0,0 +1,743 @@\n+// This module is doc(hidden) and nothing here should be used outside of\n+// generated code.\n+//\n+// We will iterate on the implementation for a few releases and only have to\n+// worry about backward compatibility for the `untagged` and `tag` attributes\n+// rather than for this entire mechanism.\n+//\n+// This issue is tracking making some of this stuff public:\n+// https://github.com/serde-rs/serde/issues/741\n+\n+#![doc(hidden)]\n+\n+use core::fmt;\n+use core::marker::PhantomData;\n+\n+#[cfg(all(not(feature = \"std\"), feature = \"collections\"))]\n+use collections::{String, Vec};\n+\n+#[cfg(all(feature = \"alloc\", not(feature = \"std\")))]\n+use alloc::boxed::Box;\n+\n+use de::{\n+    self,\n+    Deserialize,\n+    DeserializeSeed,\n+    Deserializer,\n+    Visitor,\n+    SeqVisitor,\n+    MapVisitor,\n+    EnumVisitor,\n+};\n+\n+/// Used from generated code to buffer the contents of the Deserializer when\n+/// deserializing untagged enums and internally tagged enums.\n+///\n+/// Not public API. Use serde-value instead.\n+#[derive(Debug)]\n+pub enum Content<E> {\n+    // Don't mind the PhantomData, just need to use E somewhere.\n+    Bool(bool, PhantomData<E>),\n+\n+    U8(u8),\n+    U16(u16),\n+    U32(u32),\n+    U64(u64),\n+\n+    I8(i8),\n+    I16(i16),\n+    I32(i32),\n+    I64(i64),\n+\n+    F32(f32),\n+    F64(f64),\n+\n+    Char(char),\n+    String(String),\n+    Bytes(Vec<u8>),\n+\n+    None,\n+    Some(Box<Content<E>>),\n+\n+    Unit,\n+    Newtype(Box<Content<E>>),\n+    Seq(Vec<Content<E>>),\n+    Map(Vec<(Content<E>, Content<E>)>),\n+}\n+\n+impl<E> Deserialize for Content<E> {\n+    fn deserialize<D: Deserializer>(deserializer: D) -> Result<Self, D::Error> {\n+        // Untagged and internally tagged enums are only supported in\n+        // self-describing formats.\n+        deserializer.deserialize(ContentVisitor::new())\n+    }\n+}\n+\n+struct ContentVisitor<E> {\n+    err: PhantomData<E>,\n+}\n+\n+impl<E> ContentVisitor<E> {\n+    fn new() -> Self {\n+        ContentVisitor {\n+            err: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<E> Visitor for ContentVisitor<E> {\n+    type Value = Content<E>;\n+\n+    fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt.write_str(\"any value\")\n+    }\n+\n+    fn visit_bool<F>(self, value: bool) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::Bool(value, PhantomData))\n+    }\n+\n+    fn visit_i8<F>(self, value: i8) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::I8(value))\n+    }\n+\n+    fn visit_i16<F>(self, value: i16) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::I16(value))\n+    }\n+\n+    fn visit_i32<F>(self, value: i32) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::I32(value))\n+    }\n+\n+    fn visit_i64<F>(self, value: i64) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::I64(value))\n+    }\n+\n+    fn visit_u8<F>(self, value: u8) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::U8(value))\n+    }\n+\n+    fn visit_u16<F>(self, value: u16) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::U16(value))\n+    }\n+\n+    fn visit_u32<F>(self, value: u32) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::U32(value))\n+    }\n+\n+    fn visit_u64<F>(self, value: u64) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::U64(value))\n+    }\n+\n+    fn visit_f32<F>(self, value: f32) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::F32(value))\n+    }\n+\n+    fn visit_f64<F>(self, value: f64) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::F64(value))\n+    }\n+\n+    fn visit_char<F>(self, value: char) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::Char(value))\n+    }\n+\n+    fn visit_str<F>(self, value: &str) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::String(value.into()))\n+    }\n+\n+    fn visit_string<F>(self, value: String) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::String(value))\n+    }\n+\n+    fn visit_bytes<F>(self, value: &[u8]) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::Bytes(value.into()))\n+    }\n+\n+    fn visit_byte_buf<F>(self, value: Vec<u8>) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::Bytes(value))\n+    }\n+\n+    fn visit_unit<F>(self) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::Unit)\n+    }\n+\n+    fn visit_none<F>(self) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        Ok(Content::None)\n+    }\n+\n+    fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n+        where D: Deserializer\n+    {\n+        Deserialize::deserialize(deserializer).map(|v| Content::Some(Box::new(v)))\n+    }\n+\n+    fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n+        where D: Deserializer\n+    {\n+        Deserialize::deserialize(deserializer).map(|v| Content::Newtype(Box::new(v)))\n+    }\n+\n+    fn visit_seq<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n+        where V: SeqVisitor\n+    {\n+        let mut vec = Vec::with_capacity(visitor.size_hint().0);\n+        while let Some(e) = try!(visitor.visit()) {\n+            vec.push(e);\n+        }\n+        Ok(Content::Seq(vec))\n+    }\n+\n+    fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n+        where V: MapVisitor\n+    {\n+        let mut vec = Vec::with_capacity(visitor.size_hint().0);\n+        while let Some(kv) = try!(visitor.visit()) {\n+            vec.push(kv);\n+        }\n+        Ok(Content::Map(vec))\n+    }\n+\n+    fn visit_enum<V>(self, _visitor: V) -> Result<Self::Value, V::Error>\n+        where V: EnumVisitor\n+    {\n+        Err(de::Error::custom(\"untagged and internally tagged enums do not support enum input\"))\n+    }\n+}\n+\n+/// This is the type of the map keys in an internally tagged enum.\n+///\n+/// Not public API.\n+pub enum TagOrContent<E> {\n+    Tag,\n+    Content(Content<E>),\n+}\n+\n+struct TagOrContentVisitor<E> {\n+    name: &'static str,\n+    err: PhantomData<E>,\n+}\n+\n+impl<E> TagOrContentVisitor<E> {\n+    fn new(name: &'static str) -> Self {\n+        TagOrContentVisitor {\n+            name: name,\n+            err: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<E> DeserializeSeed for TagOrContentVisitor<E> {\n+    type Value = TagOrContent<E>;\n+\n+    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n+        where D: Deserializer\n+    {\n+        // Internally tagged enums are only supported in self-describing\n+        // formats.\n+        deserializer.deserialize(self)\n+    }\n+}\n+\n+impl<E> Visitor for TagOrContentVisitor<E> {\n+    type Value = TagOrContent<E>;\n+\n+    fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"a type tag `{}` or any other value\", self.name)\n+    }\n+\n+    fn visit_bool<F>(self, value: bool) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_bool(value).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_i8<F>(self, value: i8) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_i8(value).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_i16<F>(self, value: i16) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_i16(value).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_i32<F>(self, value: i32) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_i32(value).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_i64<F>(self, value: i64) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_i64(value).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_u8<F>(self, value: u8) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_u8(value).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_u16<F>(self, value: u16) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_u16(value).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_u32<F>(self, value: u32) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_u32(value).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_u64<F>(self, value: u64) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_u64(value).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_f32<F>(self, value: f32) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_f32(value).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_f64<F>(self, value: f64) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_f64(value).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_char<F>(self, value: char) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_char(value).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_str<F>(self, value: &str) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        if value == self.name {\n+            Ok(TagOrContent::Tag)\n+        } else {\n+            ContentVisitor::new().visit_str(value).map(TagOrContent::Content)\n+        }\n+    }\n+\n+    fn visit_string<F>(self, value: String) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        if value == self.name {\n+            Ok(TagOrContent::Tag)\n+        } else {\n+            ContentVisitor::new().visit_string(value).map(TagOrContent::Content)\n+        }\n+    }\n+\n+    fn visit_bytes<F>(self, value: &[u8]) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        if value == self.name.as_bytes() {\n+            Ok(TagOrContent::Tag)\n+        } else {\n+            ContentVisitor::new().visit_bytes(value).map(TagOrContent::Content)\n+        }\n+    }\n+\n+    fn visit_byte_buf<F>(self, value: Vec<u8>) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        if value == self.name.as_bytes() {\n+            Ok(TagOrContent::Tag)\n+        } else {\n+            ContentVisitor::new().visit_byte_buf(value).map(TagOrContent::Content)\n+        }\n+    }\n+\n+    fn visit_unit<F>(self) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_unit().map(TagOrContent::Content)\n+    }\n+\n+    fn visit_none<F>(self) -> Result<Self::Value, F>\n+        where F: de::Error\n+    {\n+        ContentVisitor::new().visit_none().map(TagOrContent::Content)\n+    }\n+\n+    fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n+        where D: Deserializer\n+    {\n+        ContentVisitor::new().visit_some(deserializer).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_newtype_struct<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n+        where D: Deserializer\n+    {\n+        ContentVisitor::new().visit_newtype_struct(deserializer).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_seq<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n+        where V: SeqVisitor\n+    {\n+        ContentVisitor::new().visit_seq(visitor).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_map<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n+        where V: MapVisitor\n+    {\n+        ContentVisitor::new().visit_map(visitor).map(TagOrContent::Content)\n+    }\n+\n+    fn visit_enum<V>(self, visitor: V) -> Result<Self::Value, V::Error>\n+        where V: EnumVisitor\n+    {\n+        ContentVisitor::new().visit_enum(visitor).map(TagOrContent::Content)\n+    }\n+}\n+\n+/// Used by generated code to deserialize an internally tagged enum.\n+///\n+/// Not public API.\n+pub struct TaggedContent<T, E> {\n+    pub tag: T,\n+    pub content: Content<E>,\n+}\n+\n+/// Not public API.\n+pub struct TaggedContentVisitor<T, E> {\n+    tag_name: &'static str,\n+    tag: PhantomData<T>,\n+    err: PhantomData<E>,\n+}\n+\n+impl<T, E> TaggedContentVisitor<T, E> {\n+    /// Visitor for the content of an internally tagged enum with the given tag\n+    /// name.\n+    pub fn new(name: &'static str) -> Self {\n+        TaggedContentVisitor {\n+            tag_name: name,\n+            tag: PhantomData,\n+            err: PhantomData,\n+        }\n+    }\n+}\n+\n+impl<T, E> DeserializeSeed for TaggedContentVisitor<T, E>\n+    where T: Deserialize\n+{\n+    type Value = TaggedContent<T, E>;\n+\n+    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n+        where D: Deserializer\n+    {\n+        // Internally tagged enums are only supported in self-describing\n+        // formats.\n+        deserializer.deserialize(self)\n+    }\n+}\n+\n+impl<T, E> Visitor for TaggedContentVisitor<T, E>\n+    where T: Deserialize\n+{\n+    type Value = TaggedContent<T, E>;\n+\n+    fn expecting(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt.write_str(\"any value\")\n+    }\n+\n+    fn visit_map<V>(self, mut visitor: V) -> Result<Self::Value, V::Error>\n+        where V: MapVisitor\n+    {\n+        let mut tag = None;\n+        let mut vec = Vec::with_capacity(visitor.size_hint().0);\n+        while let Some(k) = try!(visitor.visit_key_seed(TagOrContentVisitor::new(self.tag_name))) {\n+            match k {\n+                TagOrContent::Tag => {\n+                    if tag.is_some() {\n+                        return Err(de::Error::duplicate_field(self.tag_name));\n+                    }\n+                    tag = Some(try!(visitor.visit_value()));\n+                }\n+                TagOrContent::Content(k) => {\n+                    let v = try!(visitor.visit_value());\n+                    vec.push((k, v));\n+                }\n+            }\n+        }\n+        match tag {\n+            None => {\n+                Err(de::Error::missing_field(self.tag_name))\n+            }\n+            Some(tag) => {\n+                Ok(TaggedContent {\n+                    tag: tag,\n+                    content: Content::Map(vec),\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+/// Used when deserializing an internally tagged enum because the content will\n+/// be used exactly once.\n+impl<E> Deserializer for Content<E>\n+    where E: de::Error\n+{\n+    type Error = E;\n+\n+    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+        where V: Visitor\n+    {\n+        match self {\n+            Content::Bool(v, _) => visitor.visit_bool(v),\n+            Content::U8(v) => visitor.visit_u8(v),\n+            Content::U16(v) => visitor.visit_u16(v),\n+            Content::U32(v) => visitor.visit_u32(v),\n+            Content::U64(v) => visitor.visit_u64(v),\n+            Content::I8(v) => visitor.visit_i8(v),\n+            Content::I16(v) => visitor.visit_i16(v),\n+            Content::I32(v) => visitor.visit_i32(v),\n+            Content::I64(v) => visitor.visit_i64(v),\n+            Content::F32(v) => visitor.visit_f32(v),\n+            Content::F64(v) => visitor.visit_f64(v),\n+            Content::Char(v) => visitor.visit_char(v),\n+            Content::String(v) => visitor.visit_string(v),\n+            Content::Unit => visitor.visit_unit(),\n+            Content::None => visitor.visit_none(),\n+            Content::Some(v) => visitor.visit_some(*v),\n+            Content::Newtype(v) => visitor.visit_newtype_struct(*v),\n+            Content::Seq(v) => {\n+                let seq = v.into_iter();\n+                let mut seq_visitor = de::value::SeqDeserializer::new(seq);\n+                let value = try!(visitor.visit_seq(&mut seq_visitor));\n+                try!(seq_visitor.end());\n+                Ok(value)\n+            },\n+            Content::Map(v) => {\n+                let map = v.into_iter();\n+                let mut map_visitor = de::value::MapDeserializer::new(map);\n+                let value = try!(visitor.visit_map(&mut map_visitor));\n+                try!(map_visitor.end());\n+                Ok(value)\n+            },\n+            Content::Bytes(v) => visitor.visit_byte_buf(v),\n+        }\n+    }\n+\n+    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+        where V: Visitor\n+    {\n+        match self {\n+            Content::None => visitor.visit_none(),\n+            Content::Some(v) => visitor.visit_some(*v),\n+            Content::Unit => visitor.visit_unit(),\n+            _ => visitor.visit_some(self)\n+        }\n+    }\n+\n+    fn deserialize_newtype_struct<V>(self, _name: &str, visitor: V) -> Result<V::Value, Self::Error>\n+        where V: Visitor\n+    {\n+        visitor.visit_newtype_struct(self)\n+    }\n+\n+    forward_to_deserialize! {\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n+        seq_fixed_size bytes byte_buf map unit_struct tuple_struct struct\n+        struct_field tuple enum ignored_any\n+    }\n+}\n+\n+impl<E> de::value::ValueDeserializer<E> for Content<E>\n+    where E: de::Error\n+{\n+    type Deserializer = Self;\n+\n+    fn into_deserializer(self) -> Self {\n+        self\n+    }\n+}\n+\n+/// Used when deserializing an untagged enum because the content may need to be\n+/// used more than once.\n+impl<'a, E> Deserializer for &'a Content<E>\n+    where E: de::Error\n+{\n+    type Error = E;\n+\n+    fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+        where V: Visitor\n+    {\n+        match *self {\n+            Content::Bool(v, _) => visitor.visit_bool(v),\n+            Content::U8(v) => visitor.visit_u8(v),\n+            Content::U16(v) => visitor.visit_u16(v),\n+            Content::U32(v) => visitor.visit_u32(v),\n+            Content::U64(v) => visitor.visit_u64(v),\n+            Content::I8(v) => visitor.visit_i8(v),\n+            Content::I16(v) => visitor.visit_i16(v),\n+            Content::I32(v) => visitor.visit_i32(v),\n+            Content::I64(v) => visitor.visit_i64(v),\n+            Content::F32(v) => visitor.visit_f32(v),\n+            Content::F64(v) => visitor.visit_f64(v),\n+            Content::Char(v) => visitor.visit_char(v),\n+            Content::String(ref v) => visitor.visit_str(v),\n+            Content::Unit => visitor.visit_unit(),\n+            Content::None => visitor.visit_none(),\n+            Content::Some(ref v) => visitor.visit_some(&**v),\n+            Content::Newtype(ref v) => visitor.visit_newtype_struct(&**v),\n+            Content::Seq(ref v) => {\n+                let seq = v.into_iter();\n+                let mut seq_visitor = de::value::SeqDeserializer::new(seq);\n+                let value = try!(visitor.visit_seq(&mut seq_visitor));\n+                try!(seq_visitor.end());\n+                Ok(value)\n+            },\n+            Content::Map(ref v) => {\n+                let map = v.into_iter().map(|&(ref k, ref v)| (k, v));\n+                let mut map_visitor = de::value::MapDeserializer::new(map);\n+                let value = try!(visitor.visit_map(&mut map_visitor));\n+                try!(map_visitor.end());\n+                Ok(value)\n+            },\n+            Content::Bytes(ref v) => visitor.visit_bytes(v),\n+        }\n+    }\n+\n+    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+        where V: Visitor\n+    {\n+        match *self {\n+            Content::None => visitor.visit_none(),\n+            Content::Some(ref v) => visitor.visit_some(&**v),\n+            Content::Unit => visitor.visit_unit(),\n+            _ => visitor.visit_some(self)\n+        }\n+    }\n+\n+    fn deserialize_newtype_struct<V>(self, _name: &str, visitor: V) -> Result<V::Value, Self::Error>\n+        where V: Visitor\n+    {\n+        visitor.visit_newtype_struct(self)\n+    }\n+\n+    forward_to_deserialize! {\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n+        seq_fixed_size bytes byte_buf map unit_struct tuple_struct struct\n+        struct_field tuple enum ignored_any\n+    }\n+}\n+\n+impl<'a, E> de::value::ValueDeserializer<E> for &'a Content<E>\n+    where E: de::Error\n+{\n+    type Deserializer = Self;\n+\n+    fn into_deserializer(self) -> Self {\n+        self\n+    }\n+}\n+\n+/// Visitor for deserializing an internally tagged unit variant.\n+///\n+/// Not public API.\n+pub struct InternallyTaggedUnitVisitor<'a> {\n+    type_name: &'a str,\n+    variant_name: &'a str,\n+}\n+\n+impl<'a> InternallyTaggedUnitVisitor<'a> {\n+    /// Not public API.\n+    pub fn new(type_name: &'a str, variant_name: &'a str) -> Self {\n+        InternallyTaggedUnitVisitor {\n+            type_name: type_name,\n+            variant_name: variant_name,\n+        }\n+    }\n+}\n+\n+impl<'a> Visitor for InternallyTaggedUnitVisitor<'a> {\n+    type Value = ();\n+\n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        write!(formatter, \"unit variant {}::{}\", self.type_name, self.variant_name)\n+    }\n+\n+    fn visit_map<V>(self, _: V) -> Result<(), V::Error>\n+        where V: MapVisitor\n+    {\n+        Ok(())\n+    }\n+}\n+\n+/// Visitor for deserializing an untagged unit variant.\n+///\n+/// Not public API.\n+pub struct UntaggedUnitVisitor<'a> {\n+    type_name: &'a str,\n+    variant_name: &'a str,\n+}\n+\n+impl<'a> UntaggedUnitVisitor<'a> {\n+    /// Not public API.\n+    pub fn new(type_name: &'a str, variant_name: &'a str) -> Self {\n+        UntaggedUnitVisitor {\n+            type_name: type_name,\n+            variant_name: variant_name,\n+        }\n+    }\n+}\n+\n+impl<'a> Visitor for UntaggedUnitVisitor<'a> {\n+    type Value = ();\n+\n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        write!(formatter, \"unit variant {}::{}\", self.type_name, self.variant_name)\n+    }\n+\n+    fn visit_unit<E>(self) -> Result<(), E>\n+        where E: de::Error\n+    {\n+        Ok(())\n+    }\n+}\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex ce86ce1ea..8471c9953 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -115,6 +115,8 @@ mod from_primitive;\n // Helpers used by generated code. Not public API.\n #[doc(hidden)]\n pub mod private;\n+#[cfg(any(feature = \"std\", feature = \"collections\"))]\n+mod content;\n \n ///////////////////////////////////////////////////////////////////////////////\n \ndiff --git a/serde/src/de/private.rs b/serde/src/de/private.rs\nindex 1ff206cdb..750eecdc8 100644\n--- a/serde/src/de/private.rs\n+++ b/serde/src/de/private.rs\n@@ -2,6 +2,14 @@ use core::marker::PhantomData;\n \n use de::{Deserialize, Deserializer, Error, Visitor};\n \n+#[cfg(any(feature = \"std\", feature = \"collections\"))]\n+pub use de::content::{\n+    Content,\n+    TaggedContentVisitor,\n+    InternallyTaggedUnitVisitor,\n+    UntaggedUnitVisitor,\n+};\n+\n /// If the missing field is of type `Option<T>` then treat is as `None`,\n /// otherwise it is an error.\n pub fn missing_field<V, E>(field: &'static str) -> Result<V, E>\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 32b69d5ff..85d152678 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -428,7 +428,9 @@ impl<I, E> SeqDeserializer<I, E>\n         }\n     }\n \n-    fn end(&mut self) -> Result<(), E> {\n+    /// Check for remaining elements after passing a `SeqDeserializer` to\n+    /// `Visitor::visit_seq`.\n+    pub fn end(mut self) -> Result<(), E> {\n         let mut remaining = 0;\n         while self.iter.next().is_some() {\n             remaining += 1;\n@@ -610,17 +612,9 @@ impl<I, E> MapDeserializer<I, E>\n         }\n     }\n \n-    fn next_pair(&mut self) -> Option<(<I::Item as private::Pair>::First, <I::Item as private::Pair>::Second)> {\n-        match self.iter.next() {\n-            Some(kv) => {\n-                self.count += 1;\n-                Some(private::Pair::split(kv))\n-            }\n-            None => None,\n-        }\n-    }\n-\n-    fn end(&mut self) -> Result<(), E> {\n+    /// Check for remaining elements after passing a `MapDeserializer` to\n+    /// `Visitor::visit_map`.\n+    pub fn end(mut self) -> Result<(), E> {\n         let mut remaining = 0;\n         while self.iter.next().is_some() {\n             remaining += 1;\n@@ -633,6 +627,16 @@ impl<I, E> MapDeserializer<I, E>\n             Err(de::Error::invalid_length(self.count + remaining, &ExpectedInMap(self.count)))\n         }\n     }\n+\n+    fn next_pair(&mut self) -> Option<(<I::Item as private::Pair>::First, <I::Item as private::Pair>::Second)> {\n+        match self.iter.next() {\n+            Some(kv) => {\n+                self.count += 1;\n+                Some(private::Pair::split(kv))\n+            }\n+            None => None,\n+        }\n+    }\n }\n \n impl<I, E> de::Deserializer for MapDeserializer<I, E>\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex a18346cec..42ccd169d 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -106,6 +106,10 @@ use core::fmt::Display;\n mod impls;\n mod impossible;\n \n+// Helpers used by generated code. Not public API.\n+#[doc(hidden)]\n+pub mod private;\n+\n pub use self::impossible::Impossible;\n \n ///////////////////////////////////////////////////////////////////////////////\ndiff --git a/serde/src/ser/private.rs b/serde/src/ser/private.rs\nnew file mode 100644\nindex 000000000..9d17ec789\n--- /dev/null\n+++ b/serde/src/ser/private.rs\n@@ -0,0 +1,235 @@\n+use core::fmt::{self, Display};\n+\n+use ser::{self, Serialize, Serializer, SerializeMap, SerializeStruct};\n+\n+/// Not public API.\n+pub fn serialize_tagged_newtype<S, T>(\n+    serializer: S,\n+    type_ident: &'static str,\n+    variant_ident: &'static str,\n+    tag: &'static str,\n+    variant_name: &'static str,\n+    value: T,\n+) -> Result<S::Ok, S::Error>\n+    where S: Serializer,\n+          T: Serialize\n+{\n+    value.serialize(TaggedSerializer {\n+        type_ident: type_ident,\n+        variant_ident: variant_ident,\n+        tag: tag,\n+        variant_name: variant_name,\n+        delegate: serializer,\n+    })\n+}\n+\n+struct TaggedSerializer<S> {\n+    type_ident: &'static str,\n+    variant_ident: &'static str,\n+    tag: &'static str,\n+    variant_name: &'static str,\n+    delegate: S,\n+}\n+\n+enum Unsupported {\n+    Boolean,\n+    Integer,\n+    Float,\n+    Char,\n+    String,\n+    ByteArray,\n+    Optional,\n+    Unit,\n+    UnitStruct,\n+    Sequence,\n+    Tuple,\n+    TupleStruct,\n+    Enum,\n+}\n+\n+impl Display for Unsupported {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Unsupported::Boolean => formatter.write_str(\"a boolean\"),\n+            Unsupported::Integer => formatter.write_str(\"an integer\"),\n+            Unsupported::Float => formatter.write_str(\"a float\"),\n+            Unsupported::Char => formatter.write_str(\"a char\"),\n+            Unsupported::String => formatter.write_str(\"a string\"),\n+            Unsupported::ByteArray => formatter.write_str(\"a byte array\"),\n+            Unsupported::Optional => formatter.write_str(\"an optional\"),\n+            Unsupported::Unit => formatter.write_str(\"unit\"),\n+            Unsupported::UnitStruct => formatter.write_str(\"a unit struct\"),\n+            Unsupported::Sequence => formatter.write_str(\"a sequence\"),\n+            Unsupported::Tuple => formatter.write_str(\"a tuple\"),\n+            Unsupported::TupleStruct => formatter.write_str(\"a tuple struct\"),\n+            Unsupported::Enum => formatter.write_str(\"an enum\"),\n+        }\n+    }\n+}\n+\n+struct Error {\n+    type_ident: &'static str,\n+    variant_ident: &'static str,\n+    ty: Unsupported,\n+}\n+\n+impl Display for Error {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        write!(formatter,\n+               \"cannot serialize tagged newtype variant {}::{} containing {}\",\n+               self.type_ident, self.variant_ident, self.ty)\n+    }\n+}\n+\n+impl<S> TaggedSerializer<S>\n+    where S: Serializer\n+{\n+    fn bad_type(self, what: Unsupported) -> S::Error {\n+        ser::Error::custom(Error {\n+            type_ident: self.type_ident,\n+            variant_ident: self.variant_ident,\n+            ty: what,\n+        })\n+    }\n+}\n+\n+impl<S> Serializer for TaggedSerializer<S>\n+    where S: Serializer\n+{\n+    type Ok = S::Ok;\n+    type Error = S::Error;\n+\n+    type SerializeSeq = S::SerializeSeq;\n+    type SerializeTuple = S::SerializeTuple;\n+    type SerializeTupleStruct = S::SerializeTupleStruct;\n+    type SerializeTupleVariant = S::SerializeTupleVariant;\n+    type SerializeMap = S::SerializeMap;\n+    type SerializeStruct = S::SerializeStruct;\n+    type SerializeStructVariant = S::SerializeStructVariant;\n+\n+    fn serialize_bool(self, _: bool) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Boolean))\n+    }\n+\n+    fn serialize_i8(self, _: i8) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Integer))\n+    }\n+\n+    fn serialize_i16(self, _: i16) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Integer))\n+    }\n+\n+    fn serialize_i32(self, _: i32) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Integer))\n+    }\n+\n+    fn serialize_i64(self, _: i64) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Integer))\n+    }\n+\n+    fn serialize_u8(self, _: u8) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Integer))\n+    }\n+\n+    fn serialize_u16(self, _: u16) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Integer))\n+    }\n+\n+    fn serialize_u32(self, _: u32) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Integer))\n+    }\n+\n+    fn serialize_u64(self, _: u64) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Integer))\n+    }\n+\n+    fn serialize_f32(self, _: f32) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Float))\n+    }\n+\n+    fn serialize_f64(self, _: f64) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Float))\n+    }\n+\n+    fn serialize_char(self, _: char) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Char))\n+    }\n+\n+    fn serialize_str(self, _: &str) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::String))\n+    }\n+\n+    fn serialize_bytes(self, _: &[u8]) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::ByteArray))\n+    }\n+\n+    fn serialize_none(self) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Optional))\n+    }\n+\n+    fn serialize_some<T: ?Sized>(self, _: &T) -> Result<Self::Ok, Self::Error>\n+        where T: Serialize\n+    {\n+        Err(self.bad_type(Unsupported::Optional))\n+    }\n+\n+    fn serialize_unit(self) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Unit))\n+    }\n+\n+    fn serialize_unit_struct(self, _: &'static str) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::UnitStruct))\n+    }\n+\n+    fn serialize_unit_variant(self, _: &'static str, _: usize, _: &'static str) -> Result<Self::Ok, Self::Error> {\n+        Err(self.bad_type(Unsupported::Enum))\n+    }\n+\n+    fn serialize_newtype_struct<T: ?Sized>(self, _: &'static str, value: &T) -> Result<Self::Ok, Self::Error>\n+        where T: Serialize\n+    {\n+        value.serialize(self)\n+    }\n+\n+    fn serialize_newtype_variant<T: ?Sized>(self, _: &'static str, _: usize, _: &'static str, _: &T) -> Result<Self::Ok, Self::Error>\n+        where T: Serialize\n+    {\n+        Err(self.bad_type(Unsupported::Enum))\n+    }\n+\n+    fn serialize_seq(self, _: Option<usize>) -> Result<Self::SerializeSeq, Self::Error> {\n+        Err(self.bad_type(Unsupported::Sequence))\n+    }\n+\n+    fn serialize_seq_fixed_size(self, _: usize) -> Result<Self::SerializeSeq, Self::Error> {\n+        Err(self.bad_type(Unsupported::Sequence))\n+    }\n+\n+    fn serialize_tuple(self, _: usize) -> Result<Self::SerializeTuple, Self::Error> {\n+        Err(self.bad_type(Unsupported::Tuple))\n+    }\n+\n+    fn serialize_tuple_struct(self, _: &'static str, _: usize) -> Result<Self::SerializeTupleStruct, Self::Error> {\n+        Err(self.bad_type(Unsupported::TupleStruct))\n+    }\n+\n+    fn serialize_tuple_variant(self, _: &'static str, _: usize, _: &'static str, _: usize) -> Result<Self::SerializeTupleVariant, Self::Error> {\n+        Err(self.bad_type(Unsupported::Enum))\n+    }\n+\n+    fn serialize_map(self, len: Option<usize>) -> Result<Self::SerializeMap, Self::Error> {\n+        let mut map = try!(self.delegate.serialize_map(len.map(|len| len + 1)));\n+        try!(map.serialize_entry(self.tag, self.variant_name));\n+        Ok(map)\n+    }\n+\n+    fn serialize_struct(self, name: &'static str, len: usize) -> Result<Self::SerializeStruct, Self::Error> {\n+        let mut state = try!(self.delegate.serialize_struct(name, len + 1));\n+        try!(state.serialize_field(self.tag, self.variant_name));\n+        Ok(state)\n+    }\n+\n+    fn serialize_struct_variant(self, _: &'static str, _: usize, _: &'static str, _: usize) -> Result<Self::SerializeStructVariant, Self::Error> {\n+        Err(self.bad_type(Unsupported::Enum))\n+    }\n+}\ndiff --git a/serde_codegen_internals/src/attr.rs b/serde_codegen_internals/src/attr.rs\nindex 575dad5ab..97fa4650b 100644\n--- a/serde_codegen_internals/src/attr.rs\n+++ b/serde_codegen_internals/src/attr.rs\n@@ -92,6 +92,32 @@ pub struct Item {\n     deny_unknown_fields: bool,\n     ser_bound: Option<Vec<syn::WherePredicate>>,\n     de_bound: Option<Vec<syn::WherePredicate>>,\n+    tag: EnumTag,\n+}\n+\n+/// Styles of representing an enum.\n+#[derive(Debug)]\n+pub enum EnumTag {\n+    /// The default.\n+    ///\n+    /// ```json\n+    /// {\"variant1\": {\"key1\": \"value1\", \"key2\": \"value2\"}}\n+    /// ```\n+    External,\n+\n+    /// `#[serde(tag = \"type\")]`\n+    ///\n+    /// ```json\n+    /// {\"type\": \"variant1\", \"key1\": \"value1\", \"key2\": \"value2\"}\n+    /// ```\n+    Internal(String),\n+\n+    /// `#[serde(untagged)]`\n+    ///\n+    /// ```json\n+    /// {\"key1\": \"value1\", \"key2\": \"value2\"}\n+    /// ```\n+    None,\n }\n \n impl Item {\n@@ -102,6 +128,8 @@ impl Item {\n         let mut deny_unknown_fields = BoolAttr::none(cx, \"deny_unknown_fields\");\n         let mut ser_bound = Attr::none(cx, \"bound\");\n         let mut de_bound = Attr::none(cx, \"bound\");\n+        let mut untagged = BoolAttr::none(cx, \"untagged\");\n+        let mut internal_tag = Attr::none(cx, \"tag\");\n \n         for meta_items in item.attrs.iter().filter_map(get_serde_meta_items) {\n             for meta_item in meta_items {\n@@ -143,6 +171,32 @@ impl Item {\n                         }\n                     }\n \n+                    // Parse `#[serde(untagged)]`\n+                    MetaItem(Word(ref name)) if name == \"untagged\" => {\n+                        match item.body {\n+                            syn::Body::Enum(_) => {\n+                                untagged.set_true();\n+                            }\n+                            syn::Body::Struct(_) => {\n+                                cx.error(\"#[serde(untagged)] can only be used on enums\")\n+                            }\n+                        }\n+                    }\n+\n+                    // Parse `#[serde(tag = \"type\")]`\n+                    MetaItem(NameValue(ref name, ref lit)) if name == \"tag\" => {\n+                        if let Ok(s) = get_string_from_lit(cx, name.as_ref(), name.as_ref(), lit) {\n+                            match item.body {\n+                                syn::Body::Enum(_) => {\n+                                    internal_tag.set(s);\n+                                }\n+                                syn::Body::Struct(_) => {\n+                                    cx.error(\"#[serde(tag = \\\"...\\\")] can only be used on enums\")\n+                                }\n+                            }\n+                        }\n+                    }\n+\n                     MetaItem(ref meta_item) => {\n                         cx.error(format!(\"unknown serde container attribute `{}`\",\n                                          meta_item.name()));\n@@ -155,6 +209,32 @@ impl Item {\n             }\n         }\n \n+        let tag = match (untagged.get(), internal_tag.get()) {\n+            (false, None) => EnumTag::External,\n+            (true, None) => EnumTag::None,\n+            (false, Some(tag)) => {\n+                // Check that there are no tuple variants.\n+                if let syn::Body::Enum(ref variants) = item.body {\n+                    for variant in variants {\n+                        match variant.data {\n+                            syn::VariantData::Struct(_) | syn::VariantData::Unit => {}\n+                            syn::VariantData::Tuple(ref fields) => {\n+                                if fields.len() != 1 {\n+                                    cx.error(\"#[serde(tag = \\\"...\\\")] cannot be used with tuple variants\");\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                EnumTag::Internal(tag)\n+            }\n+            (true, Some(_)) => {\n+                cx.error(\"enum cannot be both untagged and internally tagged\");\n+                EnumTag::External // doesn't matter, will error\n+            }\n+        };\n+\n         Item {\n             name: Name {\n                 serialize: ser_name.get().unwrap_or_else(|| item.ident.to_string()),\n@@ -163,6 +243,7 @@ impl Item {\n             deny_unknown_fields: deny_unknown_fields.get(),\n             ser_bound: ser_bound.get(),\n             de_bound: de_bound.get(),\n+            tag: tag,\n         }\n     }\n \n@@ -181,6 +262,10 @@ impl Item {\n     pub fn de_bound(&self) -> Option<&[syn::WherePredicate]> {\n         self.de_bound.as_ref().map(|vec| &vec[..])\n     }\n+\n+    pub fn tag(&self) -> &EnumTag {\n+        &self.tag\n+    }\n }\n \n /// Represents variant attribute information\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex 3d7b5d1f0..b72d78ad4 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -110,7 +110,8 @@ fn deserialize_body(\n                 impl_generics,\n                 ty,\n                 fields,\n-                &item.attrs)\n+                &item.attrs,\n+                None)\n         }\n         Body::Struct(Style::Tuple, ref fields) |\n         Body::Struct(Style::Newtype, ref fields) => {\n@@ -124,7 +125,8 @@ fn deserialize_body(\n                 impl_generics,\n                 ty,\n                 fields,\n-                &item.attrs)\n+                &item.attrs,\n+                None)\n         }\n         Body::Struct(Style::Unit, _) => {\n             deserialize_unit_struct(\n@@ -238,6 +240,7 @@ fn deserialize_tuple(\n     ty: syn::Ty,\n     fields: &[Field],\n     item_attrs: &attr::Item,\n+    deserializer: Option<Tokens>,\n ) -> Tokens {\n     let where_clause = &impl_generics.where_clause;\n \n@@ -274,7 +277,9 @@ fn deserialize_tuple(\n         false,\n     );\n \n-    let dispatch = if is_enum {\n+    let dispatch = if let Some(deserializer) = deserializer {\n+        quote!(_serde::Deserializer::deserialize(#deserializer, #visitor_expr))\n+    } else if is_enum {\n         quote!(_serde::de::VariantVisitor::visit_tuple(visitor, #nfields, #visitor_expr))\n     } else if nfields == 1 {\n         let type_name = item_attrs.name().deserialize_name();\n@@ -424,7 +429,11 @@ fn deserialize_struct(\n     ty: syn::Ty,\n     fields: &[Field],\n     item_attrs: &attr::Item,\n+    deserializer: Option<Tokens>,\n ) -> Tokens {\n+    let is_enum = variant_ident.is_some();\n+    let is_untagged = deserializer.is_some();\n+\n     let where_clause = &impl_generics.where_clause;\n \n     let (visitor_item, visitor_ty, visitor_expr) = deserialize_visitor(impl_generics);\n@@ -454,8 +463,11 @@ fn deserialize_struct(\n         item_attrs,\n     );\n \n-    let is_enum = variant_ident.is_some();\n-    let dispatch = if is_enum {\n+    let dispatch = if let Some(deserializer) = deserializer {\n+        quote! {\n+            _serde::Deserializer::deserialize(#deserializer, #visitor_expr)\n+        }\n+    } else if is_enum {\n         quote! {\n             _serde::de::VariantVisitor::visit_struct(visitor, FIELDS, #visitor_expr)\n         }\n@@ -473,6 +485,20 @@ fn deserialize_struct(\n         quote!(mut visitor)\n     };\n \n+    let visit_seq = if is_untagged {\n+        // untagged struct variants do not get a visit_seq method\n+        None\n+    } else {\n+        Some(quote! {\n+            #[inline]\n+            fn visit_seq<__V>(self, #visitor_var: __V) -> _serde::export::Result<#ty, __V::Error>\n+                where __V: _serde::de::SeqVisitor\n+            {\n+                #visit_seq\n+            }\n+        })\n+    };\n+\n     quote!({\n         #field_visitor\n \n@@ -485,12 +511,7 @@ fn deserialize_struct(\n                 _serde::export::fmt::Formatter::write_str(formatter, #expecting)\n             }\n \n-            #[inline]\n-            fn visit_seq<__V>(self, #visitor_var: __V) -> _serde::export::Result<#ty, __V::Error>\n-                where __V: _serde::de::SeqVisitor\n-            {\n-                #visit_seq\n-            }\n+            #visit_seq\n \n             #[inline]\n             fn visit_map<__V>(self, mut visitor: __V) -> _serde::export::Result<#ty, __V::Error>\n@@ -512,6 +533,45 @@ fn deserialize_item_enum(\n     ty: syn::Ty,\n     variants: &[Variant],\n     item_attrs: &attr::Item\n+) -> Tokens {\n+    match *item_attrs.tag() {\n+        attr::EnumTag::External => {\n+            deserialize_externally_tagged_enum(\n+                type_ident,\n+                impl_generics,\n+                ty,\n+                variants,\n+                item_attrs,\n+            )\n+        }\n+        attr::EnumTag::Internal(ref tag) => {\n+            deserialize_internally_tagged_enum(\n+                type_ident,\n+                impl_generics,\n+                ty,\n+                variants,\n+                item_attrs,\n+                tag,\n+            )\n+        }\n+        attr::EnumTag::None => {\n+            deserialize_untagged_enum(\n+                type_ident,\n+                impl_generics,\n+                ty,\n+                variants,\n+                item_attrs,\n+            )\n+        }\n+    }\n+}\n+\n+fn deserialize_externally_tagged_enum(\n+    type_ident: &syn::Ident,\n+    impl_generics: &syn::Generics,\n+    ty: syn::Ty,\n+    variants: &[Variant],\n+    item_attrs: &attr::Item,\n ) -> Tokens {\n     let where_clause = &impl_generics.where_clause;\n \n@@ -545,7 +605,7 @@ fn deserialize_item_enum(\n         .map(|(i, variant)| {\n             let variant_name = field_i(i);\n \n-            let block = deserialize_variant(\n+            let block = deserialize_externally_tagged_variant(\n                 type_ident,\n                 impl_generics,\n                 ty.clone(),\n@@ -604,7 +664,111 @@ fn deserialize_item_enum(\n     })\n }\n \n-fn deserialize_variant(\n+fn deserialize_internally_tagged_enum(\n+    type_ident: &syn::Ident,\n+    impl_generics: &syn::Generics,\n+    ty: syn::Ty,\n+    variants: &[Variant],\n+    item_attrs: &attr::Item,\n+    tag: &str,\n+) -> Tokens {\n+    let variant_names_idents: Vec<_> = variants.iter()\n+        .enumerate()\n+        .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n+        .map(|(i, variant)| (variant.attrs.name().deserialize_name(), field_i(i)))\n+        .collect();\n+\n+    let variants_stmt = {\n+        let variant_names = variant_names_idents.iter().map(|&(ref name, _)| name);\n+        quote! {\n+            const VARIANTS: &'static [&'static str] = &[ #(#variant_names),* ];\n+        }\n+    };\n+\n+    let variant_visitor = deserialize_field_visitor(\n+        variant_names_idents,\n+        item_attrs,\n+        true,\n+    );\n+\n+    // Match arms to extract a variant from a string\n+    let variant_arms = variants.iter()\n+        .enumerate()\n+        .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n+        .map(|(i, variant)| {\n+            let variant_name = field_i(i);\n+\n+            let block = deserialize_internally_tagged_variant(\n+                type_ident,\n+                impl_generics,\n+                ty.clone(),\n+                variant,\n+                item_attrs,\n+                quote!(_tagged.content),\n+            );\n+\n+            quote! {\n+                __Field::#variant_name => #block\n+            }\n+        });\n+\n+    quote!({\n+        #variant_visitor\n+\n+        #variants_stmt\n+\n+        let _tagged = try!(_serde::Deserializer::deserialize(\n+            deserializer,\n+            _serde::de::private::TaggedContentVisitor::<__Field, __D::Error>::new(#tag)));\n+\n+        match _tagged.tag {\n+            #(#variant_arms)*\n+        }\n+    })\n+}\n+\n+fn deserialize_untagged_enum(\n+    type_ident: &syn::Ident,\n+    impl_generics: &syn::Generics,\n+    ty: syn::Ty,\n+    variants: &[Variant],\n+    item_attrs: &attr::Item,\n+) -> Tokens {\n+    let attempts = variants.iter()\n+        .filter(|variant| !variant.attrs.skip_deserializing())\n+        .map(|variant| {\n+            deserialize_untagged_variant(\n+                type_ident,\n+                impl_generics,\n+                ty.clone(),\n+                variant,\n+                item_attrs,\n+                quote!(&_content),\n+            )\n+        });\n+\n+    // TODO this message could be better by saving the errors from the failed\n+    // attempts. The heuristic used by TOML was to count the number of fields\n+    // processed before an error, and use the error that happened after the\n+    // largest number of fields. I'm not sure I like that. Maybe it would be\n+    // better to save all the errors and combine them into one message that\n+    // explains why none of the variants matched.\n+    let fallthrough_msg = format!(\"data did not match any variant of untagged enum {}\", type_ident);\n+\n+    quote!({\n+        let _content = try!(<_serde::de::private::Content<__D::Error> as _serde::Deserialize>::deserialize(deserializer));\n+\n+        #(\n+            if let _serde::export::Ok(ok) = #attempts {\n+                return _serde::export::Ok(ok);\n+            }\n+        )*\n+\n+        _serde::export::Err(_serde::de::Error::custom(#fallthrough_msg))\n+    })\n+}\n+\n+fn deserialize_externally_tagged_variant(\n     type_ident: &syn::Ident,\n     generics: &syn::Generics,\n     ty: syn::Ty,\n@@ -621,7 +785,7 @@ fn deserialize_variant(\n             })\n         }\n         Style::Newtype => {\n-            deserialize_newtype_variant(\n+            deserialize_externally_tagged_newtype_variant(\n                 type_ident,\n                 variant_ident,\n                 generics,\n@@ -636,6 +800,7 @@ fn deserialize_variant(\n                 ty,\n                 &variant.fields,\n                 item_attrs,\n+                None,\n             )\n         }\n         Style::Struct => {\n@@ -646,22 +811,115 @@ fn deserialize_variant(\n                 ty,\n                 &variant.fields,\n                 item_attrs,\n+                None,\n+            )\n+        }\n+    }\n+}\n+\n+fn deserialize_internally_tagged_variant(\n+    type_ident: &syn::Ident,\n+    generics: &syn::Generics,\n+    ty: syn::Ty,\n+    variant: &Variant,\n+    item_attrs: &attr::Item,\n+    deserializer: Tokens,\n+) -> Tokens {\n+    let variant_ident = &variant.ident;\n+\n+    match variant.style {\n+        Style::Unit => {\n+            let type_name = type_ident.as_ref();\n+            let variant_name = variant.ident.as_ref();\n+            quote!({\n+                try!(_serde::Deserializer::deserialize(#deserializer, _serde::de::private::InternallyTaggedUnitVisitor::new(#type_name, #variant_name)));\n+                _serde::export::Ok(#type_ident::#variant_ident)\n+            })\n+        }\n+        Style::Newtype | Style::Struct => {\n+            deserialize_untagged_variant(\n+                type_ident,\n+                generics,\n+                ty,\n+                variant,\n+                item_attrs,\n+                deserializer,\n             )\n         }\n+        Style::Tuple => unreachable!(\"checked in serde_codegen_internals\"),\n     }\n }\n \n-fn deserialize_newtype_variant(\n+fn deserialize_untagged_variant(\n+    type_ident: &syn::Ident,\n+    generics: &syn::Generics,\n+    ty: syn::Ty,\n+    variant: &Variant,\n+    item_attrs: &attr::Item,\n+    deserializer: Tokens,\n+) -> Tokens {\n+    let variant_ident = &variant.ident;\n+\n+    match variant.style {\n+        Style::Unit => {\n+            let type_name = type_ident.as_ref();\n+            let variant_name = variant.ident.as_ref();\n+            quote! {\n+                _serde::export::Result::map(\n+                    _serde::Deserializer::deserialize(\n+                        #deserializer,\n+                        _serde::de::private::UntaggedUnitVisitor::new(#type_name, #variant_name)\n+                    ),\n+                    |()| #type_ident::#variant_ident)\n+            }\n+        }\n+        Style::Newtype => {\n+            deserialize_untagged_newtype_variant(\n+                type_ident,\n+                variant_ident,\n+                generics,\n+                &variant.fields[0],\n+                deserializer,\n+            )\n+        }\n+        Style::Tuple => {\n+            deserialize_tuple(\n+                type_ident,\n+                Some(variant_ident),\n+                generics,\n+                ty,\n+                &variant.fields,\n+                item_attrs,\n+                Some(deserializer),\n+            )\n+        }\n+        Style::Struct => {\n+            deserialize_struct(\n+                type_ident,\n+                Some(variant_ident),\n+                generics,\n+                ty,\n+                &variant.fields,\n+                item_attrs,\n+                Some(deserializer),\n+            )\n+        }\n+    }\n+}\n+\n+fn deserialize_externally_tagged_newtype_variant(\n     type_ident: &syn::Ident,\n     variant_ident: &syn::Ident,\n     impl_generics: &syn::Generics,\n     field: &Field,\n ) -> Tokens {\n-    let visit = match field.attrs.deserialize_with() {\n+    match field.attrs.deserialize_with() {\n         None => {\n             let field_ty = &field.ty;\n             quote! {\n-                try!(_serde::de::VariantVisitor::visit_newtype::<#field_ty>(visitor))\n+                _serde::export::Result::map(\n+                    _serde::de::VariantVisitor::visit_newtype::<#field_ty>(visitor),\n+                    #type_ident::#variant_ident),\n             }\n         }\n         Some(path) => {\n@@ -670,12 +928,41 @@ fn deserialize_newtype_variant(\n             quote!({\n                 #wrapper\n                 #wrapper_impl\n-                try!(_serde::de::VariantVisitor::visit_newtype::<#wrapper_ty>(visitor)).value\n+                _serde::export::Result::map(\n+                    _serde::de::VariantVisitor::visit_newtype::<#wrapper_ty>(visitor),\n+                    |_wrapper| #type_ident::#variant_ident(_wrapper.value))\n+            })\n+        }\n+    }\n+}\n+\n+fn deserialize_untagged_newtype_variant(\n+    type_ident: &syn::Ident,\n+    variant_ident: &syn::Ident,\n+    impl_generics: &syn::Generics,\n+    field: &Field,\n+    deserializer: Tokens,\n+) -> Tokens {\n+    match field.attrs.deserialize_with() {\n+        None => {\n+            let field_ty = &field.ty;\n+            quote!({\n+                _serde::export::Result::map(\n+                    <#field_ty as _serde::Deserialize>::deserialize(#deserializer),\n+                    #type_ident::#variant_ident)\n+            })\n+        }\n+        Some(path) => {\n+            let (wrapper, wrapper_impl, wrapper_ty) = wrap_deserialize_with(\n+                type_ident, impl_generics, field.ty, path);\n+            quote!({\n+                #wrapper\n+                #wrapper_impl\n+                _serde::export::Result::map(\n+                    <#wrapper_ty as _serde::Deserialize>::deserialize(#deserializer),\n+                    |_wrapper| #type_ident::#variant_ident(_wrapper.value))\n             })\n         }\n-    };\n-    quote! {\n-        _serde::export::Ok(#type_ident::#variant_ident(#visit)),\n     }\n }\n \ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex 6478de411..52c86c7e7 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -251,14 +251,11 @@ fn serialize_variant(\n     variant_index: usize,\n     item_attrs: &attr::Item,\n ) -> Tokens {\n-    let type_name = item_attrs.name().serialize_name();\n-\n     let variant_ident = variant.ident.clone();\n-    let variant_name = variant.attrs.name().serialize_name();\n \n     if variant.attrs.skip_serializing() {\n         let skipped_msg = format!(\"the enum variant {}::{} cannot be serialized\",\n-                                type_ident, variant_ident);\n+                                  type_ident, variant_ident);\n         let skipped_err = quote! {\n             _serde::export::Err(_serde::ser::Error::custom(#skipped_msg))\n         };\n@@ -271,140 +268,351 @@ fn serialize_variant(\n             #type_ident::#variant_ident #fields_pat => #skipped_err,\n         }\n     } else { // variant wasn't skipped\n-        match variant.style {\n+        let case = match variant.style {\n             Style::Unit => {\n                 quote! {\n-                    #type_ident::#variant_ident =>\n-                        _serde::Serializer::serialize_unit_variant(\n-                            _serializer,\n-                            #type_name,\n-                            #variant_index,\n-                            #variant_name,\n-                        ),\n+                    #type_ident::#variant_ident\n                 }\n-            },\n+            }\n             Style::Newtype => {\n-                let block = serialize_newtype_variant(\n-                    type_name,\n-                    variant_index,\n-                    variant_name,\n-                    ty,\n-                    generics,\n-                    &variant.fields[0],\n-                );\n-\n                 quote! {\n-                    #type_ident::#variant_ident(ref __simple_value) => #block,\n+                    #type_ident::#variant_ident(ref __simple_value)\n                 }\n-            },\n+            }\n             Style::Tuple => {\n                 let field_names = (0 .. variant.fields.len())\n                     .map(|i| Ident::new(format!(\"__field{}\", i)));\n-\n-                let block = serialize_tuple_variant(\n-                    type_name,\n-                    variant_index,\n-                    variant_name,\n-                    generics,\n-                    ty,\n-                    &variant.fields,\n-                );\n-\n                 quote! {\n-                    #type_ident::#variant_ident(#(ref #field_names),*) => { #block }\n+                    #type_ident::#variant_ident(#(ref #field_names),*)\n                 }\n             }\n             Style::Struct => {\n                 let fields = variant.fields.iter()\n                     .map(|f| f.ident.clone().expect(\"struct variant has unnamed fields\"));\n+                quote! {\n+                    #type_ident::#variant_ident { #(ref #fields),* }\n+                }\n+            }\n+        };\n \n-                let block = serialize_struct_variant(\n+        let body = match *item_attrs.tag() {\n+            attr::EnumTag::External => {\n+                serialize_externally_tagged_variant(\n+                    generics,\n+                    ty,\n+                    variant,\n                     variant_index,\n-                    variant_name,\n+                    item_attrs,\n+                )\n+            }\n+            attr::EnumTag::Internal(ref tag) => {\n+                serialize_internally_tagged_variant(\n+                    type_ident.as_ref(),\n+                    variant_ident.as_ref(),\n                     generics,\n                     ty,\n-                    &variant.fields,\n+                    variant,\n                     item_attrs,\n-                );\n-\n-                quote! {\n-                    #type_ident::#variant_ident { #(ref #fields),* } => { #block }\n-                }\n+                    tag,\n+                )\n+            }\n+            attr::EnumTag::None => {\n+                serialize_untagged_variant(\n+                    generics,\n+                    ty,\n+                    variant,\n+                    item_attrs,\n+                )\n             }\n+        };\n+\n+        quote! {\n+            #case => #body\n         }\n     }\n }\n \n-fn serialize_newtype_variant(\n-    type_name: String,\n+fn serialize_externally_tagged_variant(\n+    generics: &syn::Generics,\n+    ty: syn::Ty,\n+    variant: &Variant,\n     variant_index: usize,\n-    variant_name: String,\n-    item_ty: syn::Ty,\n+    item_attrs: &attr::Item,\n+) -> Tokens {\n+    let type_name = item_attrs.name().serialize_name();\n+    let variant_name = variant.attrs.name().serialize_name();\n+\n+    match variant.style {\n+        Style::Unit => {\n+            quote! {\n+                _serde::Serializer::serialize_unit_variant(\n+                    _serializer,\n+                    #type_name,\n+                    #variant_index,\n+                    #variant_name,\n+                ),\n+            }\n+        }\n+        Style::Newtype => {\n+            let field = &variant.fields[0];\n+            let mut field_expr = quote!(__simple_value);\n+            if let Some(path) = field.attrs.serialize_with() {\n+                field_expr = wrap_serialize_with(\n+                    &ty, generics, field.ty, path, field_expr);\n+            }\n+\n+            quote! {\n+                _serde::Serializer::serialize_newtype_variant(\n+                    _serializer,\n+                    #type_name,\n+                    #variant_index,\n+                    #variant_name,\n+                    #field_expr,\n+                ),\n+            }\n+        }\n+        Style::Tuple => {\n+            let block = serialize_tuple_variant(\n+                TupleVariant::ExternallyTagged {\n+                    type_name: type_name,\n+                    variant_index: variant_index,\n+                    variant_name: variant_name,\n+                },\n+                generics,\n+                ty,\n+                &variant.fields,\n+            );\n+\n+            quote! {\n+                { #block }\n+            }\n+        }\n+        Style::Struct => {\n+            let block = serialize_struct_variant(\n+                StructVariant::ExternallyTagged {\n+                    variant_index: variant_index,\n+                    variant_name: variant_name,\n+                },\n+                generics,\n+                ty,\n+                &variant.fields,\n+                item_attrs,\n+            );\n+\n+            quote! {\n+                { #block }\n+            }\n+        }\n+    }\n+}\n+\n+fn serialize_internally_tagged_variant(\n+    type_ident: &str,\n+    variant_ident: &str,\n     generics: &syn::Generics,\n-    field: &Field,\n+    ty: syn::Ty,\n+    variant: &Variant,\n+    item_attrs: &attr::Item,\n+    tag: &str,\n ) -> Tokens {\n-    let mut field_expr = quote!(__simple_value);\n-    if let Some(path) = field.attrs.serialize_with() {\n-        field_expr = wrap_serialize_with(\n-            &item_ty, generics, field.ty, path, field_expr);\n+    let type_name = item_attrs.name().serialize_name();\n+    let variant_name = variant.attrs.name().serialize_name();\n+\n+    match variant.style {\n+        Style::Unit => {\n+            quote!({\n+                let mut __struct = try!(_serde::Serializer::serialize_struct(\n+                    _serializer, #type_name, 1));\n+                try!(_serde::ser::SerializeStruct::serialize_field(\n+                    &mut __struct, #tag, #variant_name));\n+                _serde::ser::SerializeStruct::end(__struct)\n+            })\n+        }\n+        Style::Newtype => {\n+            let field = &variant.fields[0];\n+            let mut field_expr = quote!(__simple_value);\n+            if let Some(path) = field.attrs.serialize_with() {\n+                field_expr = wrap_serialize_with(\n+                    &ty, generics, field.ty, path, field_expr);\n+            }\n+\n+            quote! {\n+                _serde::ser::private::serialize_tagged_newtype(\n+                    _serializer,\n+                    #type_ident,\n+                    #variant_ident,\n+                    #tag,\n+                    #variant_name,\n+                    #field_expr,\n+                ),\n+            }\n+        }\n+        Style::Struct => {\n+            let block = serialize_struct_variant(\n+                StructVariant::InternallyTagged {\n+                    tag: tag,\n+                    variant_name: variant_name,\n+                },\n+                generics,\n+                ty,\n+                &variant.fields,\n+                item_attrs,\n+            );\n+\n+            quote! {\n+                { #block }\n+            }\n+        }\n+        Style::Tuple => unreachable!(\"checked in serde_codegen_internals\"),\n     }\n+}\n \n-    quote! {\n-        _serde::Serializer::serialize_newtype_variant(\n-            _serializer,\n-            #type_name,\n-            #variant_index,\n-            #variant_name,\n-            #field_expr,\n-        )\n+fn serialize_untagged_variant(\n+    generics: &syn::Generics,\n+    ty: syn::Ty,\n+    variant: &Variant,\n+    item_attrs: &attr::Item,\n+) -> Tokens {\n+    match variant.style {\n+        Style::Unit => {\n+            quote! {\n+                _serde::Serializer::serialize_unit(_serializer),\n+            }\n+        }\n+        Style::Newtype => {\n+            let field = &variant.fields[0];\n+            let mut field_expr = quote!(__simple_value);\n+            if let Some(path) = field.attrs.serialize_with() {\n+                field_expr = wrap_serialize_with(\n+                    &ty, generics, field.ty, path, field_expr);\n+            }\n+\n+            quote! {\n+                _serde::Serialize::serialize(#field_expr, _serializer),\n+            }\n+        }\n+        Style::Tuple => {\n+            let block = serialize_tuple_variant(\n+                TupleVariant::Untagged,\n+                generics,\n+                ty,\n+                &variant.fields,\n+            );\n+\n+            quote! {\n+                { #block }\n+            }\n+        }\n+        Style::Struct => {\n+            let block = serialize_struct_variant(\n+                StructVariant::Untagged,\n+                generics,\n+                ty,\n+                &variant.fields,\n+                item_attrs,\n+            );\n+\n+            quote! {\n+                { #block }\n+            }\n+        }\n     }\n }\n \n+enum TupleVariant {\n+    ExternallyTagged {\n+        type_name: String,\n+        variant_index: usize,\n+        variant_name: String,\n+    },\n+    Untagged,\n+}\n+\n fn serialize_tuple_variant(\n-    type_name: String,\n-    variant_index: usize,\n-    variant_name: String,\n+    context: TupleVariant,\n     generics: &syn::Generics,\n     structure_ty: syn::Ty,\n     fields: &[Field],\n ) -> Tokens {\n+    let method = match context {\n+        TupleVariant::ExternallyTagged{..} => {\n+            quote!(_serde::ser::SerializeTupleVariant::serialize_field)\n+        }\n+        TupleVariant::Untagged => {\n+            quote!(_serde::ser::SerializeTuple::serialize_element)\n+        }\n+    };\n+\n     let serialize_stmts = serialize_tuple_struct_visitor(\n         structure_ty,\n         fields,\n         generics,\n         true,\n-        quote!(_serde::ser::SerializeTupleVariant::serialize_field),\n+        method,\n     );\n \n     let len = serialize_stmts.len();\n     let let_mut = mut_if(len > 0);\n \n-    quote! {\n-        let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple_variant(\n-            _serializer,\n-            #type_name,\n-            #variant_index,\n-            #variant_name,\n-            #len));\n-        #(#serialize_stmts)*\n-        _serde::ser::SerializeTupleVariant::end(__serde_state)\n+    match context {\n+        TupleVariant::ExternallyTagged { type_name, variant_index, variant_name } => {\n+            quote! {\n+                let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple_variant(\n+                    _serializer,\n+                    #type_name,\n+                    #variant_index,\n+                    #variant_name,\n+                    #len));\n+                #(#serialize_stmts)*\n+                _serde::ser::SerializeTupleVariant::end(__serde_state)\n+            }\n+        }\n+        TupleVariant::Untagged => {\n+            quote! {\n+                let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple(\n+                    _serializer,\n+                    #len));\n+                #(#serialize_stmts)*\n+                _serde::ser::SerializeTuple::end(__serde_state)\n+            }\n+        }\n     }\n }\n \n-fn serialize_struct_variant(\n-    variant_index: usize,\n-    variant_name: String,\n+enum StructVariant<'a> {\n+    ExternallyTagged {\n+        variant_index: usize,\n+        variant_name: String,\n+    },\n+    InternallyTagged {\n+        tag: &'a str,\n+        variant_name: String,\n+    },\n+    Untagged,\n+}\n+\n+fn serialize_struct_variant<'a>(\n+    context: StructVariant<'a>,\n     generics: &syn::Generics,\n     ty: syn::Ty,\n     fields: &[Field],\n     item_attrs: &attr::Item,\n ) -> Tokens {\n+    let method = match context {\n+        StructVariant::ExternallyTagged{..} => {\n+            quote!(_serde::ser::SerializeStructVariant::serialize_field)\n+        }\n+        StructVariant::InternallyTagged{..} | StructVariant::Untagged => {\n+            quote!(_serde::ser::SerializeStruct::serialize_field)\n+        }\n+    };\n+\n     let serialize_fields = serialize_struct_visitor(\n         ty.clone(),\n         fields,\n         generics,\n         true,\n-        quote!(_serde::ser::SerializeStructVariant::serialize_field),\n+        method,\n     );\n \n     let item_name = item_attrs.name().serialize_name();\n@@ -426,16 +634,47 @@ fn serialize_struct_variant(\n          })\n         .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n \n-    quote! {\n-        let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct_variant(\n-            _serializer,\n-            #item_name,\n-            #variant_index,\n-            #variant_name,\n-            #len,\n-        ));\n-        #(#serialize_fields)*\n-        _serde::ser::SerializeStructVariant::end(__serde_state)\n+    match context {\n+        StructVariant::ExternallyTagged { variant_index, variant_name } => {\n+            quote! {\n+                let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct_variant(\n+                    _serializer,\n+                    #item_name,\n+                    #variant_index,\n+                    #variant_name,\n+                    #len,\n+                ));\n+                #(#serialize_fields)*\n+                _serde::ser::SerializeStructVariant::end(__serde_state)\n+            }\n+        }\n+        StructVariant::InternallyTagged { tag, variant_name } => {\n+            quote! {\n+                let mut __serde_state = try!(_serde::Serializer::serialize_struct(\n+                    _serializer,\n+                    #item_name,\n+                    #len + 1,\n+                ));\n+                try!(_serde::ser::SerializeStruct::serialize_field(\n+                    &mut __serde_state,\n+                    #tag,\n+                    #variant_name,\n+                ));\n+                #(#serialize_fields)*\n+                _serde::ser::SerializeStruct::end(__serde_state)\n+            }\n+        }\n+        StructVariant::Untagged => {\n+            quote! {\n+                let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct(\n+                    _serializer,\n+                    #item_name,\n+                    #len,\n+                ));\n+                #(#serialize_fields)*\n+                _serde::ser::SerializeStruct::end(__serde_state)\n+            }\n+        }\n     }\n }\n \n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 8bdfdcee0..138ed0cd9 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -47,91 +47,29 @@ impl<I> Deserializer<I>\n         }\n     }\n \n-    fn visit_seq<V>(&mut self, len: Option<usize>, visitor: V) -> Result<V::Value, Error>\n+    fn visit_seq<V>(&mut self, len: Option<usize>, sep: Token<'static>, end: Token<'static>, visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n         let value = try!(visitor.visit_seq(DeserializerSeqVisitor {\n             de: self,\n             len: len,\n+            sep: sep,\n+            end: end.clone(),\n         }));\n-        try!(self.expect_token(Token::SeqEnd));\n+        try!(self.expect_token(end));\n         Ok(value)\n     }\n \n-    fn visit_array<V>(&mut self, len: usize, visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n-    {\n-        let value = try!(visitor.visit_seq(DeserializerArrayVisitor {\n-            de: self,\n-            len: len,\n-        }));\n-        try!(self.expect_token(Token::SeqEnd));\n-        Ok(value)\n-    }\n-\n-    fn visit_tuple<V>(&mut self, len: usize, visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n-    {\n-        let value = try!(visitor.visit_seq(DeserializerTupleVisitor {\n-            de: self,\n-            len: len,\n-        }));\n-        try!(self.expect_token(Token::TupleEnd));\n-        Ok(value)\n-    }\n-\n-    fn visit_tuple_struct<V>(&mut self, len: usize, visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n-    {\n-        let value = try!(visitor.visit_seq(DeserializerTupleStructVisitor {\n-            de: self,\n-            len: len,\n-        }));\n-        try!(self.expect_token(Token::TupleStructEnd));\n-        Ok(value)\n-    }\n-\n-    fn visit_variant_seq<V>(&mut self, len: Option<usize>, visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n-    {\n-        let value = try!(visitor.visit_seq(DeserializerVariantSeqVisitor {\n-            de: self,\n-            len: len,\n-        }));\n-        try!(self.expect_token(Token::EnumSeqEnd));\n-        Ok(value)\n-    }\n-\n-    fn visit_map<V>(&mut self, len: Option<usize>, visitor: V) -> Result<V::Value, Error>\n+    fn visit_map<V>(&mut self, len: Option<usize>, sep: Token<'static>, end: Token<'static>, visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n         let value = try!(visitor.visit_map(DeserializerMapVisitor {\n             de: self,\n             len: len,\n+            sep: sep,\n+            end: end.clone(),\n         }));\n-        try!(self.expect_token(Token::MapEnd));\n-        Ok(value)\n-    }\n-\n-    fn visit_struct<V>(&mut self, fields: &'static [&'static str], visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n-    {\n-        let value = try!(visitor.visit_map(DeserializerStructVisitor {\n-            de: self,\n-            len: fields.len(),\n-        }));\n-        try!(self.expect_token(Token::StructEnd));\n-        Ok(value)\n-    }\n-\n-    fn visit_variant_map<V>(&mut self, len: Option<usize>, visitor: V) -> Result<V::Value, Error>\n-        where V: Visitor,\n-    {\n-        let value = try!(visitor.visit_map(DeserializerVariantMapVisitor {\n-            de: self,\n-            len: len,\n-        }));\n-        try!(self.expect_token(Token::EnumMapEnd));\n+        try!(self.expect_token(end));\n         Ok(value)\n     }\n }\n@@ -141,89 +79,9 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n {\n     type Error = Error;\n \n-    fn deserialize_seq<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_struct_field<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_map<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_unit<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_bytes<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_byte_buf<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_ignored_any<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_string<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_str<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_char<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_i64<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_i32<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_i16<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_i8<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_u64<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_u32<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_u16<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_u8<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_f32<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_f64<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_bool<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n+    forward_to_deserialize! {\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit\n+        seq bytes byte_buf map struct_field ignored_any\n     }\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n@@ -251,16 +109,22 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n             Some(Token::Unit) => visitor.visit_unit(),\n             Some(Token::UnitStruct(_name)) => visitor.visit_unit(),\n             Some(Token::SeqStart(len)) => {\n-                self.visit_seq(len, visitor)\n+                self.visit_seq(len, Token::SeqSep, Token::SeqEnd, visitor)\n             }\n-            Some(Token::SeqArrayStart(len))| Some(Token::TupleStructStart(_, len)) => {\n-                self.visit_seq(Some(len), visitor)\n+            Some(Token::SeqArrayStart(len)) => {\n+                self.visit_seq(Some(len), Token::SeqSep, Token::SeqEnd, visitor)\n+            }\n+            Some(Token::TupleStart(len)) => {\n+                self.visit_seq(Some(len), Token::TupleSep, Token::TupleEnd, visitor)\n+            }\n+            Some(Token::TupleStructStart(_, len)) => {\n+                self.visit_seq(Some(len), Token::TupleStructSep, Token::TupleStructEnd, visitor)\n             }\n             Some(Token::MapStart(len)) => {\n-                self.visit_map(len, visitor)\n+                self.visit_map(len, Token::MapSep, Token::MapEnd, visitor)\n             }\n             Some(Token::StructStart(_, len)) => {\n-                self.visit_map(Some(len), visitor)\n+                self.visit_map(Some(len), Token::StructSep, Token::StructEnd, visitor)\n             }\n             Some(token) => Err(Error::UnexpectedToken(token)),\n             None => Err(Error::EndOfTokens),\n@@ -360,7 +224,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n         match self.tokens.peek() {\n             Some(&Token::SeqArrayStart(_)) => {\n                 self.tokens.next();\n-                self.visit_array(len, visitor)\n+                self.visit_seq(Some(len), Token::SeqSep, Token::SeqEnd, visitor)\n             }\n             Some(_) => self.deserialize(visitor),\n             None => Err(Error::EndOfTokens),\n@@ -379,19 +243,19 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n             }\n             Some(&Token::SeqStart(_)) => {\n                 self.tokens.next();\n-                self.visit_seq(Some(len), visitor)\n+                self.visit_seq(Some(len), Token::SeqSep, Token::SeqEnd, visitor)\n             }\n             Some(&Token::SeqArrayStart(_)) => {\n                 self.tokens.next();\n-                self.visit_array(len, visitor)\n+                self.visit_seq(Some(len), Token::SeqSep, Token::SeqEnd, visitor)\n             }\n             Some(&Token::TupleStart(_)) => {\n                 self.tokens.next();\n-                self.visit_tuple(len, visitor)\n+                self.visit_seq(Some(len), Token::TupleSep, Token::TupleEnd, visitor)\n             }\n             Some(&Token::TupleStructStart(_, _)) => {\n                 self.tokens.next();\n-                self.visit_tuple_struct(len, visitor)\n+                self.visit_seq(Some(len), Token::TupleStructSep, Token::TupleStructEnd, visitor)\n             }\n             Some(_) => self.deserialize(visitor),\n             None => Err(Error::EndOfTokens),\n@@ -419,20 +283,20 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n             }\n             Some(&Token::SeqStart(_)) => {\n                 self.tokens.next();\n-                self.visit_seq(Some(len), visitor)\n+                self.visit_seq(Some(len), Token::SeqSep, Token::SeqEnd, visitor)\n             }\n             Some(&Token::SeqArrayStart(_)) => {\n                 self.tokens.next();\n-                self.visit_array(len, visitor)\n+                self.visit_seq(Some(len), Token::SeqSep, Token::SeqEnd, visitor)\n             }\n             Some(&Token::TupleStart(_)) => {\n                 self.tokens.next();\n-                self.visit_tuple(len, visitor)\n+                self.visit_seq(Some(len), Token::TupleSep, Token::TupleEnd, visitor)\n             }\n             Some(&Token::TupleStructStart(n, _)) => {\n                 self.tokens.next();\n                 if name == n {\n-                    self.visit_tuple_struct(len, visitor)\n+                    self.visit_seq(Some(len), Token::TupleStructSep, Token::TupleStructEnd, visitor)\n                 } else {\n                     Err(Error::InvalidName(n))\n                 }\n@@ -452,14 +316,14 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n             Some(&Token::StructStart(n, _)) => {\n                 self.tokens.next();\n                 if name == n {\n-                    self.visit_struct(fields, visitor)\n+                    self.visit_map(Some(fields.len()), Token::StructSep, Token::StructEnd, visitor)\n                 } else {\n                     Err(Error::InvalidName(n))\n                 }\n             }\n             Some(&Token::MapStart(_)) => {\n                 self.tokens.next();\n-                self.visit_map(Some(fields.len()), visitor)\n+                self.visit_map(Some(fields.len()), Token::MapSep, Token::MapEnd, visitor)\n             }\n             Some(_) => self.deserialize(visitor),\n             None => Err(Error::EndOfTokens),\n@@ -472,6 +336,8 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n struct DeserializerSeqVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n     de: &'a mut Deserializer<I>,\n     len: Option<usize>,\n+    sep: Token<'static>,\n+    end: Token<'static>,\n }\n \n impl<'a, I> SeqVisitor for DeserializerSeqVisitor<'a, I>\n@@ -482,158 +348,15 @@ impl<'a, I> SeqVisitor for DeserializerSeqVisitor<'a, I>\n     fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n         where T: DeserializeSeed,\n     {\n-        match self.de.tokens.peek() {\n-            Some(&Token::SeqSep) => {\n-                self.de.tokens.next();\n-                self.len = self.len.map(|len| len - 1);\n-                seed.deserialize(&mut *self.de).map(Some)\n-            }\n-            Some(&Token::SeqEnd) => Ok(None),\n-            Some(_) => {\n-                let token = self.de.tokens.next().unwrap();\n-                Err(Error::UnexpectedToken(token))\n-            }\n-            None => Err(Error::EndOfTokens),\n+        if self.de.tokens.peek() == Some(&self.end) {\n+            return Ok(None);\n         }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.len.unwrap_or(0);\n-        (len, self.len)\n-    }\n-}\n-\n-//////////////////////////////////////////////////////////////////////////\n-\n-struct DeserializerArrayVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n-    de: &'a mut Deserializer<I>,\n-    len: usize,\n-}\n-\n-impl<'a, I> SeqVisitor for DeserializerArrayVisitor<'a, I>\n-    where I: Iterator<Item=Token<'static>>,\n-{\n-    type Error = Error;\n-\n-    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n-        where T: DeserializeSeed,\n-    {\n-        match self.de.tokens.peek() {\n-            Some(&Token::SeqSep) => {\n-                self.de.tokens.next();\n-                self.len -= 1;\n+        match self.de.tokens.next() {\n+            Some(ref token) if *token == self.sep => {\n+                self.len = self.len.map(|len| len.saturating_sub(1));\n                 seed.deserialize(&mut *self.de).map(Some)\n             }\n-            Some(&Token::SeqEnd) => Ok(None),\n-            Some(_) => {\n-                let token = self.de.tokens.next().unwrap();\n-                Err(Error::UnexpectedToken(token))\n-            }\n-            None => Err(Error::EndOfTokens),\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.len, Some(self.len))\n-    }\n-}\n-\n-//////////////////////////////////////////////////////////////////////////\n-\n-struct DeserializerTupleVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n-    de: &'a mut Deserializer<I>,\n-    len: usize,\n-}\n-\n-impl<'a, I> SeqVisitor for DeserializerTupleVisitor<'a, I>\n-    where I: Iterator<Item=Token<'static>>,\n-{\n-    type Error = Error;\n-\n-    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n-        where T: DeserializeSeed,\n-    {\n-        match self.de.tokens.peek() {\n-            Some(&Token::TupleSep) => {\n-                self.de.tokens.next();\n-                self.len -= 1;\n-                seed.deserialize(&mut *self.de).map(Some)\n-            }\n-            Some(&Token::TupleEnd) => Ok(None),\n-            Some(_) => {\n-                let token = self.de.tokens.next().unwrap();\n-                Err(Error::UnexpectedToken(token))\n-            }\n-            None => Err(Error::EndOfTokens),\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.len, Some(self.len))\n-    }\n-}\n-\n-//////////////////////////////////////////////////////////////////////////\n-\n-struct DeserializerTupleStructVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n-    de: &'a mut Deserializer<I>,\n-    len: usize,\n-}\n-\n-impl<'a, I> SeqVisitor for DeserializerTupleStructVisitor<'a, I>\n-    where I: Iterator<Item=Token<'static>>,\n-{\n-    type Error = Error;\n-\n-    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n-        where T: DeserializeSeed,\n-    {\n-        match self.de.tokens.peek() {\n-            Some(&Token::TupleStructSep) => {\n-                self.de.tokens.next();\n-                self.len -= 1;\n-                seed.deserialize(&mut *self.de).map(Some)\n-            }\n-            Some(&Token::TupleStructEnd) => Ok(None),\n-            Some(_) => {\n-                let token = self.de.tokens.next().unwrap();\n-                Err(Error::UnexpectedToken(token))\n-            }\n-            None => Err(Error::EndOfTokens),\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.len, Some(self.len))\n-    }\n-}\n-\n-//////////////////////////////////////////////////////////////////////////\n-\n-struct DeserializerVariantSeqVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n-    de: &'a mut Deserializer<I>,\n-    len: Option<usize>,\n-}\n-\n-impl<'a, I> SeqVisitor for DeserializerVariantSeqVisitor<'a, I>\n-    where I: Iterator<Item=Token<'static>>,\n-{\n-    type Error = Error;\n-\n-    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n-        where T: DeserializeSeed,\n-    {\n-        match self.de.tokens.peek() {\n-            Some(&Token::EnumSeqSep) => {\n-                self.de.tokens.next();\n-                self.len = self.len.map(|len| len - 1);\n-                seed.deserialize(&mut *self.de).map(Some)\n-            }\n-            Some(&Token::EnumSeqEnd) => Ok(None),\n-            Some(_) => {\n-                let token = self.de.tokens.next().unwrap();\n-                Err(Error::UnexpectedToken(token))\n-            }\n+            Some(other) => Err(Error::UnexpectedToken(other)),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n@@ -649,6 +372,8 @@ impl<'a, I> SeqVisitor for DeserializerVariantSeqVisitor<'a, I>\n struct DeserializerMapVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n     de: &'a mut Deserializer<I>,\n     len: Option<usize>,\n+    sep: Token<'static>,\n+    end: Token<'static>,\n }\n \n impl<'a, I> MapVisitor for DeserializerMapVisitor<'a, I>\n@@ -659,17 +384,15 @@ impl<'a, I> MapVisitor for DeserializerMapVisitor<'a, I>\n     fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n         where K: DeserializeSeed,\n     {\n-        match self.de.tokens.peek() {\n-            Some(&Token::MapSep) => {\n-                self.de.tokens.next();\n-                self.len = self.len.map(|len| if len > 0 { len - 1} else { 0 });\n+        if self.de.tokens.peek() == Some(&self.end) {\n+            return Ok(None);\n+        }\n+        match self.de.tokens.next() {\n+            Some(ref token) if *token == self.sep => {\n+                self.len = self.len.map(|len| len.saturating_sub(1));\n                 seed.deserialize(&mut *self.de).map(Some)\n             }\n-            Some(&Token::MapEnd) => Ok(None),\n-            Some(_) => {\n-                let token = self.de.tokens.next().unwrap();\n-                Err(Error::UnexpectedToken(token))\n-            }\n+            Some(other) => Err(Error::UnexpectedToken(other)),\n             None => Err(Error::EndOfTokens),\n         }\n     }\n@@ -688,47 +411,6 @@ impl<'a, I> MapVisitor for DeserializerMapVisitor<'a, I>\n \n //////////////////////////////////////////////////////////////////////////\n \n-struct DeserializerStructVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n-    de: &'a mut Deserializer<I>,\n-    len: usize,\n-}\n-\n-impl<'a, I> MapVisitor for DeserializerStructVisitor<'a, I>\n-    where I: Iterator<Item=Token<'static>>,\n-{\n-    type Error = Error;\n-\n-    fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n-        where K: DeserializeSeed,\n-    {\n-        match self.de.tokens.peek() {\n-            Some(&Token::StructSep) => {\n-                self.de.tokens.next();\n-                self.len = self.len.saturating_sub(1);\n-                seed.deserialize(&mut *self.de).map(Some)\n-            }\n-            Some(&Token::StructEnd) => Ok(None),\n-            Some(_) => {\n-                let token = self.de.tokens.next().unwrap();\n-                Err(Error::UnexpectedToken(token))\n-            }\n-            None => Err(Error::EndOfTokens),\n-        }\n-    }\n-\n-    fn visit_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n-        where V: DeserializeSeed,\n-    {\n-        seed.deserialize(&mut *self.de)\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.len, Some(self.len))\n-    }\n-}\n-\n-//////////////////////////////////////////////////////////////////////////\n-\n struct DeserializerEnumVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n     de: &'a mut Deserializer<I>,\n }\n@@ -803,7 +485,7 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n                 let token = self.de.tokens.next().unwrap();\n \n                 if len == enum_len {\n-                    self.de.visit_variant_seq(Some(len), visitor)\n+                    self.de.visit_seq(Some(len), Token::EnumSeqSep, Token::EnumSeqEnd, visitor)\n                 } else {\n                     Err(Error::UnexpectedToken(token))\n                 }\n@@ -812,7 +494,7 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n                 let token = self.de.tokens.next().unwrap();\n \n                 if len == enum_len {\n-                    self.de.visit_seq(Some(len), visitor)\n+                    self.de.visit_seq(Some(len), Token::SeqSep, Token::SeqEnd, visitor)\n                 } else {\n                     Err(Error::UnexpectedToken(token))\n                 }\n@@ -834,7 +516,7 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n                 let token = self.de.tokens.next().unwrap();\n \n                 if fields.len() == enum_len {\n-                    self.de.visit_variant_map(Some(fields.len()), visitor)\n+                    self.de.visit_map(Some(fields.len()), Token::EnumMapSep, Token::EnumMapEnd, visitor)\n                 } else {\n                     Err(Error::UnexpectedToken(token))\n                 }\n@@ -843,7 +525,7 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n                 let token = self.de.tokens.next().unwrap();\n \n                 if fields.len() == enum_len {\n-                    self.de.visit_map(Some(fields.len()), visitor)\n+                    self.de.visit_map(Some(fields.len()), Token::MapSep, Token::MapEnd, visitor)\n                 } else {\n                     Err(Error::UnexpectedToken(token))\n                 }\n@@ -855,45 +537,3 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n         }\n     }\n }\n-\n-//////////////////////////////////////////////////////////////////////////\n-\n-struct DeserializerVariantMapVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n-    de: &'a mut Deserializer<I>,\n-    len: Option<usize>,\n-}\n-\n-impl<'a, I> MapVisitor for DeserializerVariantMapVisitor<'a, I>\n-    where I: Iterator<Item=Token<'static>>,\n-{\n-    type Error = Error;\n-\n-    fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n-        where K: DeserializeSeed,\n-    {\n-        match self.de.tokens.peek() {\n-            Some(&Token::EnumMapSep) => {\n-                self.de.tokens.next();\n-                self.len = self.len.map(|len| if len > 0 { len - 1} else { 0 });\n-                seed.deserialize(&mut *self.de).map(Some)\n-            }\n-            Some(&Token::EnumMapEnd) => Ok(None),\n-            Some(_) => {\n-                let token = self.de.tokens.next().unwrap();\n-                Err(Error::UnexpectedToken(token))\n-            }\n-            None => Err(Error::EndOfTokens),\n-        }\n-    }\n-\n-    fn visit_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n-        where V: DeserializeSeed,\n-    {\n-        seed.deserialize(&mut *self.de)\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.len.unwrap_or(0);\n-        (len, self.len)\n-    }\n-}\ndiff --git a/serde_test/src/lib.rs b/serde_test/src/lib.rs\nindex 945262c02..53f966f67 100644\n--- a/serde_test/src/lib.rs\n+++ b/serde_test/src/lib.rs\n@@ -1,3 +1,4 @@\n+#[macro_use]\n extern crate serde;\n \n mod assert;\ndiff --git a/test_suite/tests/compile-fail/enum-representation/internal-tuple-variant.rs b/test_suite/tests/compile-fail/enum-representation/internal-tuple-variant.rs\nnew file mode 100644\nindex 000000000..950e8d027\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/enum-representation/internal-tuple-variant.rs\n@@ -0,0 +1,10 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+#[serde(tag = \"type\")] //~^ HELP: #[serde(tag = \"...\")] cannot be used with tuple variants\n+enum E {\n+    Tuple(u8, u8),\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/enum-representation/internally-tagged-struct.rs b/test_suite/tests/compile-fail/enum-representation/internally-tagged-struct.rs\nnew file mode 100644\nindex 000000000..358dfde45\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/enum-representation/internally-tagged-struct.rs\n@@ -0,0 +1,8 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+#[serde(tag = \"type\")] //~^ HELP: #[serde(tag = \"...\")] can only be used on enums\n+struct S;\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/enum-representation/untagged-and-internal.rs b/test_suite/tests/compile-fail/enum-representation/untagged-and-internal.rs\nnew file mode 100644\nindex 000000000..7442679c5\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/enum-representation/untagged-and-internal.rs\n@@ -0,0 +1,12 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+#[serde(untagged)]\n+#[serde(tag = \"type\")] //~^^ HELP: enum cannot be both untagged and internally tagged\n+enum E {\n+    A(u8),\n+    B(String),\n+}\n+\n+fn main() {}\ndiff --git a/test_suite/tests/compile-fail/enum-representation/untagged-struct.rs b/test_suite/tests/compile-fail/enum-representation/untagged-struct.rs\nnew file mode 100644\nindex 000000000..611f8416a\n--- /dev/null\n+++ b/test_suite/tests/compile-fail/enum-representation/untagged-struct.rs\n@@ -0,0 +1,8 @@\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize)] //~ ERROR: custom derive attribute panicked\n+#[serde(untagged)] //~^ HELP: #[serde(untagged)] can only be used on enums\n+struct S;\n+\n+fn main() {}\ndiff --git a/test_suite/tests/test_de.rs b/test_suite/tests/test_de.rs\nindex b748bb125..6ae92129d 100644\n--- a/test_suite/tests/test_de.rs\n+++ b/test_suite/tests/test_de.rs\n@@ -225,7 +225,7 @@ declare_tests! {\n         ],\n         () => &[\n             Token::TupleStructStart(\"Anything\", 0),\n-            Token::SeqEnd,\n+            Token::TupleStructEnd,\n         ],\n     }\n     test_unit_struct {\n@@ -330,7 +330,7 @@ declare_tests! {\n         ],\n         BTreeSet::<isize>::new() => &[\n             Token::TupleStructStart(\"Anything\", 0),\n-            Token::SeqEnd,\n+            Token::TupleStructEnd,\n         ],\n     }\n     test_hashset {\n@@ -358,7 +358,7 @@ declare_tests! {\n         ],\n         HashSet::<isize>::new() => &[\n             Token::TupleStructStart(\"Anything\", 0),\n-            Token::SeqEnd,\n+            Token::TupleStructEnd,\n         ],\n         hashset![FnvHasher @ 1, 2, 3] => &[\n             Token::SeqStart(Some(3)),\n@@ -408,7 +408,7 @@ declare_tests! {\n         ],\n         Vec::<isize>::new() => &[\n             Token::TupleStructStart(\"Anything\", 0),\n-            Token::SeqEnd,\n+            Token::TupleStructEnd,\n         ],\n     }\n     test_array {\n@@ -472,7 +472,7 @@ declare_tests! {\n         ],\n         [0; 0] => &[\n             Token::TupleStructStart(\"Anything\", 0),\n-            Token::SeqEnd,\n+            Token::TupleStructEnd,\n         ],\n     }\n     test_tuple {\n@@ -564,7 +564,7 @@ declare_tests! {\n         ],\n         BTreeMap::<isize, isize>::new() => &[\n             Token::StructStart(\"Anything\", 0),\n-            Token::MapEnd,\n+            Token::StructEnd,\n         ],\n     }\n     test_hashmap {\n@@ -618,7 +618,7 @@ declare_tests! {\n         ],\n         HashMap::<isize, isize>::new() => &[\n             Token::StructStart(\"Anything\", 0),\n-            Token::MapEnd,\n+            Token::StructEnd,\n         ],\n         hashmap![FnvHasher @ 1 => 2, 3 => 4] => &[\n             Token::MapStart(Some(2)),\ndiff --git a/test_suite/tests/test_macros.rs b/test_suite/tests/test_macros.rs\nindex 6e5e1d823..21185412b 100644\n--- a/test_suite/tests/test_macros.rs\n+++ b/test_suite/tests/test_macros.rs\n@@ -1,11 +1,14 @@\n extern crate serde_test;\n use self::serde_test::{\n+    Error,\n     Token,\n     assert_tokens,\n     assert_ser_tokens,\n     assert_de_tokens,\n+    assert_de_tokens_error,\n };\n \n+use std::collections::BTreeMap;\n use std::marker::PhantomData;\n \n // That tests that the derived Serialize implementation doesn't trigger\n@@ -625,3 +628,256 @@ fn test_enum_state_field() {\n         ]\n     );\n }\n+\n+#[test]\n+fn test_untagged_enum() {\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    #[serde(untagged)]\n+    enum Untagged {\n+        A {\n+            a: u8,\n+        },\n+        B {\n+            b: u8,\n+        },\n+        C,\n+        D(u8),\n+        E(String),\n+        F(u8, u8),\n+    }\n+\n+    assert_tokens(\n+        &Untagged::A { a: 1 },\n+        &[\n+            Token::StructStart(\"Untagged\", 1),\n+\n+            Token::StructSep,\n+            Token::Str(\"a\"),\n+            Token::U8(1),\n+\n+            Token::StructEnd,\n+        ]\n+    );\n+\n+    assert_tokens(\n+        &Untagged::B { b: 2 },\n+        &[\n+            Token::StructStart(\"Untagged\", 1),\n+\n+            Token::StructSep,\n+            Token::Str(\"b\"),\n+            Token::U8(2),\n+\n+            Token::StructEnd,\n+        ]\n+    );\n+\n+    assert_tokens(\n+        &Untagged::C,\n+        &[\n+            Token::Unit,\n+        ]\n+    );\n+\n+    assert_tokens(\n+        &Untagged::D(4),\n+        &[\n+            Token::U8(4),\n+        ]\n+    );\n+    assert_tokens(\n+        &Untagged::E(\"e\".to_owned()),\n+        &[\n+            Token::Str(\"e\"),\n+        ]\n+    );\n+\n+    assert_tokens(\n+        &Untagged::F(1, 2),\n+        &[\n+            Token::TupleStart(2),\n+\n+            Token::TupleSep,\n+            Token::U8(1),\n+\n+            Token::TupleSep,\n+            Token::U8(2),\n+\n+            Token::TupleEnd,\n+        ]\n+    );\n+\n+    assert_de_tokens_error::<Untagged>(\n+        &[\n+            Token::Option(false),\n+        ],\n+        Error::Message(\"data did not match any variant of untagged enum Untagged\".to_owned()),\n+    );\n+\n+    assert_de_tokens_error::<Untagged>(\n+        &[\n+            Token::TupleStart(1),\n+\n+            Token::TupleSep,\n+            Token::U8(1),\n+\n+            Token::TupleEnd,\n+        ],\n+        Error::Message(\"data did not match any variant of untagged enum Untagged\".to_owned()),\n+    );\n+\n+    assert_de_tokens_error::<Untagged>(\n+        &[\n+            Token::TupleStart(3),\n+\n+            Token::TupleSep,\n+            Token::U8(1),\n+\n+            Token::TupleSep,\n+            Token::U8(2),\n+\n+            Token::TupleSep,\n+            Token::U8(3),\n+\n+            Token::TupleEnd,\n+        ],\n+        Error::Message(\"data did not match any variant of untagged enum Untagged\".to_owned()),\n+    );\n+}\n+\n+#[test]\n+fn test_internally_tagged_enum() {\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    struct Newtype(BTreeMap<String, String>);\n+\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    struct Struct {\n+        f: u8,\n+    }\n+\n+    #[derive(Debug, PartialEq, Serialize, Deserialize)]\n+    #[serde(tag = \"type\")]\n+    enum InternallyTagged {\n+        A {\n+            a: u8,\n+        },\n+        B {\n+            b: u8,\n+        },\n+        C,\n+        D(BTreeMap<String, String>),\n+        E(Newtype),\n+        F(Struct),\n+    }\n+\n+    assert_tokens(\n+        &InternallyTagged::A { a: 1 },\n+        &[\n+            Token::StructStart(\"InternallyTagged\", 2),\n+\n+            Token::StructSep,\n+            Token::Str(\"type\"),\n+            Token::Str(\"A\"),\n+\n+            Token::StructSep,\n+            Token::Str(\"a\"),\n+            Token::U8(1),\n+\n+            Token::StructEnd,\n+        ]\n+    );\n+\n+    assert_tokens(\n+        &InternallyTagged::B { b: 2 },\n+        &[\n+            Token::StructStart(\"InternallyTagged\", 2),\n+\n+            Token::StructSep,\n+            Token::Str(\"type\"),\n+            Token::Str(\"B\"),\n+\n+            Token::StructSep,\n+            Token::Str(\"b\"),\n+            Token::U8(2),\n+\n+            Token::StructEnd,\n+        ]\n+    );\n+\n+    assert_tokens(\n+        &InternallyTagged::C,\n+        &[\n+            Token::StructStart(\"InternallyTagged\", 1),\n+\n+            Token::StructSep,\n+            Token::Str(\"type\"),\n+            Token::Str(\"C\"),\n+\n+            Token::StructEnd,\n+        ]\n+    );\n+\n+    assert_tokens(\n+        &InternallyTagged::D(BTreeMap::new()),\n+        &[\n+            Token::MapStart(Some(1)),\n+\n+            Token::MapSep,\n+            Token::Str(\"type\"),\n+            Token::Str(\"D\"),\n+\n+            Token::MapEnd,\n+        ]\n+    );\n+\n+    assert_tokens(\n+        &InternallyTagged::E(Newtype(BTreeMap::new())),\n+        &[\n+            Token::MapStart(Some(1)),\n+\n+            Token::MapSep,\n+            Token::Str(\"type\"),\n+            Token::Str(\"E\"),\n+\n+            Token::MapEnd,\n+        ]\n+    );\n+\n+    assert_tokens(\n+        &InternallyTagged::F(Struct { f: 6 }),\n+        &[\n+            Token::StructStart(\"Struct\", 2),\n+\n+            Token::StructSep,\n+            Token::Str(\"type\"),\n+            Token::Str(\"F\"),\n+\n+            Token::StructSep,\n+            Token::Str(\"f\"),\n+            Token::U8(6),\n+\n+            Token::StructEnd,\n+        ]\n+    );\n+\n+    assert_de_tokens_error::<InternallyTagged>(\n+        &[\n+            Token::MapStart(Some(0)),\n+            Token::MapEnd,\n+        ],\n+        Error::Message(\"missing field `type`\".to_owned()),\n+    );\n+\n+    assert_de_tokens_error::<InternallyTagged>(\n+        &[\n+            Token::MapStart(Some(1)),\n+\n+            Token::MapSep,\n+            Token::Str(\"type\"),\n+            Token::Str(\"Z\"),\n+\n+            Token::MapEnd,\n+        ],\n+        Error::Message(\"unknown variant `Z`, expected one of `A`, `B`, `C`, `D`, `E`, `F`\".to_owned()),\n+    );\n+}\n", "problem_statement": "Is it possible to handle tagged enums?\n``` rust\n#[derive(Serialize, Deserialize, Debug)]\nenum Motion {\n  Column(i32),\n  Line(i32),\n}\n\n#[derive(Serialize, Deserialize, Debug)]\nenum Command {\n  Move(Motion),\n  Delete(Motion),\n  Input(String),\n}\n\nfn main() {\n  let cmd = Command::Move(Motion::Column(1));\n  let cmd_str = serde_json::to_string(&cmd).unwrap();\n  println!(\"result: {}\", cmd_str);\n}\n```\n\nthis will get result like this:\n\n``` json\n{\n  \"Move\": {\n    \"Column\": 1\n  }\n}\n```\n\nIs it possible to make it be:\n\n``` json\n{\n  \"type\": \"Move\",\n  \"content\": {\n    \"type\": \"Column\",\n    \"content\": 1\n  }\n}\n```\n\n", "hints_text": "Here is one approach. Manually implement Serialize for a `Wrapper<T>` type that contains \"type\" and \"content\".\n\n``` rust\n#[derive(Serialize)]\nstruct Wrapper<T> {\n    #[serde(rename = \"type\")]\n    name: String,\n    content: T,\n}\n\nimpl<T> Wrapper<T> {\n    fn new(name: &'static str, content: T) -> Self {\n        Wrapper {\n            name: name.to_string(),\n            content: content,\n        }\n    }\n}\n\nimpl serde::Serialize for Motion {\n    fn serialize<S>(&self, ser: &mut S) -> Result<(), S::Error>\n        where S: serde::Serializer\n    {\n        match *self {\n            Motion::Column(ref i) => Wrapper::new(\"Column\", i).serialize(ser),\n            Motion::Line(ref i) => Wrapper::new(\"Line\", i).serialize(ser),\n        }\n    }\n}\n\nimpl serde::Serialize for Command {\n    fn serialize<S>(&self, ser: &mut S) -> Result<(), S::Error>\n        where S: serde::Serializer\n    {\n        match *self {\n            Command::Move(ref m) => Wrapper::new(\"Move\", m).serialize(ser),\n            Command::Delete(ref m) => Wrapper::new(\"Delete\", m).serialize(ser),\n            Command::Input(ref s) => Wrapper::new(\"Input\", s).serialize(ser),\n        }\n    }\n}\n```\n\nYou could use a macro to make this a lot nicer so it becomes just something like:\n\n``` rust\ntagged_enum!(Motion {\n    Column(i32),\n    Line(i32),\n});\n```\n\nrelated discussion: https://github.com/serde-rs/json/issues/67\n\nHere is a complete working solution. For deserialization it uses a `serde_json::Value` to partially deserialize the input, check the \"type\", then deserialize the \"content\" into the correct Rust type. It has readable error messages when things go wrong, for example if the input is `{\"type\":\"Bla\",\"content\":1}` you get \"unrecognized Command type: Bla\" and if the input is `{\"type\":\"Move\",\"content\":[0]}` you get \"bad Move content: [0]\".\n\n``` rust\n#![feature(plugin, custom_derive)]\n#![plugin(serde_macros)]\n\nextern crate serde;\nextern crate serde_json as json;\n\n////////////////////////////////////////////////////////////////////////////////\n\n#[derive(Serialize, Deserialize)]\nstruct Wrapper {\n    #[serde(rename = \"type\")]\n    name: String,\n    content: json::Value,\n}\n\nimpl Wrapper {\n    fn new<T>(name: &'static str, content: T) -> Self\n        where T: serde::Serialize\n    {\n        Wrapper {\n            name: name.to_string(),\n            content: json::to_value(&content),\n        }\n    }\n}\n\nmacro_rules! tagged_enum {\n    ($name:ident { $( $variant:ident ( $content:ty ), )* }) => {\n        #[derive(Debug)]\n        enum $name {\n            $(\n                $variant($content),\n            )*\n        }\n\n        impl ::serde::Serialize for $name {\n            fn serialize<S>(&self, ser: &mut S) -> Result<(), S::Error>\n                where S: ::serde::Serializer\n            {\n                match *self {\n                    $(\n                        $name::$variant(ref content) => {\n                            Wrapper::new(stringify!($variant), content)\n                        }\n                    )*\n                }.serialize(ser)\n            }\n        }\n\n        impl ::serde::Deserialize for $name {\n            fn deserialize<D>(des: &mut D) -> Result<Self, D::Error>\n                where D: ::serde::Deserializer,\n            {\n                use ::serde::Error;\n                let wrapper = try!(Wrapper::deserialize(des));\n                let str_for_error = wrapper.content.to_string();\n                match &wrapper.name[..] {\n                    $(\n                        stringify!($variant) => Ok($name::$variant(try!(\n                            json::from_value(wrapper.content)\n                            .map_err(|_| D::Error::custom(format!(\n                                \"bad {} content: {}\", stringify!($variant), str_for_error)))\n                        ))),\n                    )*\n                    other => {\n                        Err(D::Error::custom(format!(\n                            \"unrecognized {} type: {}\", stringify!($name), other)))\n                    }\n                }\n            }\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\ntagged_enum!(Motion {\n    Column(i32),\n    Line(i32),\n});\n\ntagged_enum!(Command {\n    Move(Motion),\n    Delete(Motion),\n    Input(String),\n});\n\nfn main() {\n    let cmd = Command::Move(Motion::Column(1));\n    let cmd_str = json::to_string_pretty(&cmd).unwrap();\n    println!(\"serialized command - {}\", cmd_str);\n\n    let cmd: Command = json::from_str(&cmd_str).unwrap();\n    println!(\"deserialized command - {:?}\", cmd);\n}\n```\n\nthank you all, @dtolnay your solution is great.\n\nAny plans of having something like the `tagged_enum!()` above (possibly with a configurable name for the typefield) exposed directly by serde or serde-json? This data layout seems common enough, at least in JSON world.\nYes we need to provide some way to make this easier. https://github.com/serde-rs/json/issues/67 is tracking a similar request.", "created_at": "2017-02-03T03:01:50Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 738, "instance_id": "serde-rs__serde-738", "issue_numbers": ["737"], "base_commit": "d9605714395a983649d82b03394ccaa9db596399", "patch": "diff --git a/serde/src/export.rs b/serde/src/export.rs\nindex 61c9ba67c..9c635457e 100644\n--- a/serde/src/export.rs\n+++ b/serde/src/export.rs\n@@ -9,7 +9,8 @@ use collections::borrow::Cow;\n pub use core::default::Default;\n pub use core::fmt;\n pub use core::marker::PhantomData;\n-pub use core::result::Result;\n+pub use core::option::Option::{self, None, Some};\n+pub use core::result::Result::{self, Ok, Err};\n \n #[cfg(any(feature = \"collections\", feature = \"std\"))]\n pub fn from_utf8_lossy(bytes: &[u8]) -> Cow<str> {\ndiff --git a/serde/src/lib.rs b/serde/src/lib.rs\nindex eb07bbbff..f22f167a6 100644\n--- a/serde/src/lib.rs\n+++ b/serde/src/lib.rs\n@@ -79,7 +79,7 @@ extern crate core as actual_core;\n #[cfg(feature = \"std\")]\n mod core {\n     pub use std::{ops, hash, fmt, cmp, marker, mem, i8, i16, i32, i64, u8, u16, u32, u64, isize,\n-            usize, f32, f64, char, str, num, slice, iter, cell, default, result};\n+            usize, f32, f64, char, str, num, slice, iter, cell, default, result, option};\n     #[cfg(feature = \"unstable\")]\n     pub use actual_core::nonzero;\n }\ndiff --git a/serde_derive/src/de.rs b/serde_derive/src/de.rs\nindex f371680e4..3d7b5d1f0 100644\n--- a/serde_derive/src/de.rs\n+++ b/serde_derive/src/de.rs\n@@ -209,21 +209,21 @@ fn deserialize_unit_struct(\n             type Value = #type_ident;\n \n             fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n-                formatter.write_str(#expecting)\n+                _serde::export::fmt::Formatter::write_str(formatter, #expecting)\n             }\n \n             #[inline]\n             fn visit_unit<__E>(self) -> _serde::export::Result<#type_ident, __E>\n                 where __E: _serde::de::Error,\n             {\n-                Ok(#type_ident)\n+                _serde::export::Ok(#type_ident)\n             }\n \n             #[inline]\n             fn visit_seq<__V>(self, _: __V) -> _serde::export::Result<#type_ident, __V::Error>\n                 where __V: _serde::de::SeqVisitor,\n             {\n-                Ok(#type_ident)\n+                _serde::export::Ok(#type_ident)\n             }\n         }\n \n@@ -278,10 +278,10 @@ fn deserialize_tuple(\n         quote!(_serde::de::VariantVisitor::visit_tuple(visitor, #nfields, #visitor_expr))\n     } else if nfields == 1 {\n         let type_name = item_attrs.name().deserialize_name();\n-        quote!(deserializer.deserialize_newtype_struct(#type_name, #visitor_expr))\n+        quote!(_serde::Deserializer::deserialize_newtype_struct(deserializer, #type_name, #visitor_expr))\n     } else {\n         let type_name = item_attrs.name().deserialize_name();\n-        quote!(deserializer.deserialize_tuple_struct(#type_name, #nfields, #visitor_expr))\n+        quote!(_serde::Deserializer::deserialize_tuple_struct(deserializer, #type_name, #nfields, #visitor_expr))\n     };\n \n     let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n@@ -298,7 +298,7 @@ fn deserialize_tuple(\n             type Value = #ty;\n \n             fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n-                formatter.write_str(#expecting)\n+                _serde::export::fmt::Formatter::write_str(formatter, #expecting)\n             }\n \n             #visit_newtype_struct\n@@ -341,7 +341,7 @@ fn deserialize_seq(\n                 let visit = match field.attrs.deserialize_with() {\n                     None => {\n                         let field_ty = &field.ty;\n-                        quote!(try!(visitor.visit::<#field_ty>()))\n+                        quote!(try!(_serde::de::SeqVisitor::visit::<#field_ty>(&mut visitor)))\n                     }\n                     Some(path) => {\n                         let (wrapper, wrapper_impl, wrapper_ty) = wrap_deserialize_with(\n@@ -349,7 +349,8 @@ fn deserialize_seq(\n                         quote!({\n                             #wrapper\n                             #wrapper_impl\n-                            try!(visitor.visit::<#wrapper_ty>()).map(|wrap| wrap.value)\n+                            try!(_serde::de::SeqVisitor::visit::<#wrapper_ty>(&mut visitor))\n+                                .map(|wrap| wrap.value)\n                         })\n                     }\n                 };\n@@ -357,7 +358,7 @@ fn deserialize_seq(\n                     let #var = match #visit {\n                         Some(value) => { value },\n                         None => {\n-                            return Err(_serde::de::Error::invalid_length(#index_in_seq, &#expecting));\n+                            return _serde::export::Err(_serde::de::Error::invalid_length(#index_in_seq, &#expecting));\n                         }\n                     };\n                 };\n@@ -379,7 +380,7 @@ fn deserialize_seq(\n \n     quote! {\n         #(#let_values)*\n-        Ok(#result)\n+        _serde::export::Ok(#result)\n     }\n }\n \n@@ -411,7 +412,7 @@ fn deserialize_newtype_struct(\n         fn visit_newtype_struct<__E>(self, __e: __E) -> _serde::export::Result<Self::Value, __E::Error>\n             where __E: _serde::Deserializer,\n         {\n-            Ok(#type_path(#value))\n+            _serde::export::Ok(#type_path(#value))\n         }\n     }\n }\n@@ -461,7 +462,7 @@ fn deserialize_struct(\n     } else {\n         let type_name = item_attrs.name().deserialize_name();\n         quote! {\n-            deserializer.deserialize_struct(#type_name, FIELDS, #visitor_expr)\n+            _serde::Deserializer::deserialize_struct(deserializer, #type_name, FIELDS, #visitor_expr)\n         }\n     };\n \n@@ -481,7 +482,7 @@ fn deserialize_struct(\n             type Value = #ty;\n \n             fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n-                formatter.write_str(#expecting)\n+                _serde::export::fmt::Formatter::write_str(formatter, #expecting)\n             }\n \n             #[inline]\n@@ -563,13 +564,14 @@ fn deserialize_item_enum(\n         // all variants have `#[serde(skip_deserializing)]`.\n         quote! {\n             // FIXME: Once we drop support for Rust 1.15:\n-            // let Err(err) = visitor.visit_variant::<__Field>();\n-            // Err(err)\n-            visitor.visit_variant::<__Field>().map(|(impossible, _)| match impossible {})\n+            // let _serde::export::Err(err) = _serde::de::EnumVisitor::visit_variant::<__Field>(visitor);\n+            // _serde::export::Err(err)\n+            _serde::de::EnumVisitor::visit_variant::<__Field>(visitor)\n+                .map(|(impossible, _)| match impossible {})\n         }\n     } else {\n         quote! {\n-            match try!(visitor.visit_variant()) {\n+            match try!(_serde::de::EnumVisitor::visit_variant(visitor)) {\n                 #(#variant_arms)*\n             }\n         }\n@@ -586,7 +588,7 @@ fn deserialize_item_enum(\n             type Value = #ty;\n \n             fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n-                formatter.write_str(#expecting)\n+                _serde::export::fmt::Formatter::write_str(formatter, #expecting)\n             }\n \n             fn visit_enum<__V>(self, visitor: __V) -> _serde::export::Result<#ty, __V::Error>\n@@ -598,7 +600,7 @@ fn deserialize_item_enum(\n \n         #variants_stmt\n \n-        deserializer.deserialize_enum(#type_name, VARIANTS, #visitor_expr)\n+        _serde::Deserializer::deserialize_enum(deserializer, #type_name, VARIANTS, #visitor_expr)\n     })\n }\n \n@@ -615,7 +617,7 @@ fn deserialize_variant(\n         Style::Unit => {\n             quote!({\n                 try!(_serde::de::VariantVisitor::visit_unit(visitor));\n-                Ok(#type_ident::#variant_ident)\n+                _serde::export::Ok(#type_ident::#variant_ident)\n             })\n         }\n         Style::Newtype => {\n@@ -673,7 +675,7 @@ fn deserialize_newtype_variant(\n         }\n     };\n     quote! {\n-        Ok(#type_ident::#variant_ident(#visit)),\n+        _serde::export::Ok(#type_ident::#variant_ident(#visit)),\n     }\n }\n \n@@ -701,9 +703,9 @@ fn deserialize_field_visitor(\n             {\n                 match value {\n                     #(\n-                        #variant_indices => Ok(__Field::#field_idents),\n+                        #variant_indices => _serde::export::Ok(__Field::#field_idents),\n                     )*\n-                    _ => Err(_serde::de::Error::invalid_value(\n+                    _ => _serde::export::Err(_serde::de::Error::invalid_value(\n                                 _serde::de::Unexpected::Unsigned(value as u64),\n                                 &#fallthrough_msg))\n                 }\n@@ -715,15 +717,15 @@ fn deserialize_field_visitor(\n \n     let fallthrough_arm = if is_variant {\n         quote! {\n-            Err(_serde::de::Error::unknown_variant(value, VARIANTS))\n+            _serde::export::Err(_serde::de::Error::unknown_variant(value, VARIANTS))\n         }\n     } else if item_attrs.deny_unknown_fields() {\n         quote! {\n-            Err(_serde::de::Error::unknown_field(value, FIELDS))\n+            _serde::export::Err(_serde::de::Error::unknown_field(value, FIELDS))\n         }\n     } else {\n         quote! {\n-            Ok(__Field::__ignore)\n+            _serde::export::Ok(__Field::__ignore)\n         }\n     };\n \n@@ -755,7 +757,7 @@ fn deserialize_field_visitor(\n                     type Value = __Field;\n \n                     fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n-                        formatter.write_str(\"field name\")\n+                        _serde::export::fmt::Formatter::write_str(formatter, \"field name\")\n                     }\n \n                     #visit_index\n@@ -765,7 +767,7 @@ fn deserialize_field_visitor(\n                     {\n                         match value {\n                             #(\n-                                #field_strs => Ok(__Field::#field_idents),\n+                                #field_strs => _serde::export::Ok(__Field::#field_idents),\n                             )*\n                             _ => #fallthrough_arm\n                         }\n@@ -776,7 +778,7 @@ fn deserialize_field_visitor(\n                     {\n                         match value {\n                             #(\n-                                #field_bytes => Ok(__Field::#field_idents),\n+                                #field_bytes => _serde::export::Ok(__Field::#field_idents),\n                             )*\n                             _ => {\n                                 #bytes_to_str\n@@ -786,7 +788,7 @@ fn deserialize_field_visitor(\n                     }\n                 }\n \n-                deserializer.deserialize_struct_field(__FieldVisitor)\n+                _serde::Deserializer::deserialize_struct_field(deserializer, __FieldVisitor)\n             }\n         }\n     }\n@@ -848,7 +850,7 @@ fn deserialize_map(\n         .map(|&(field, ref name)| {\n             let field_ty = &field.ty;\n             quote! {\n-                let mut #name: Option<#field_ty> = None;\n+                let mut #name: _serde::export::Option<#field_ty> = _serde::export::None;\n             }\n         });\n \n@@ -862,7 +864,7 @@ fn deserialize_map(\n                 None => {\n                     let field_ty = &field.ty;\n                     quote! {\n-                        try!(visitor.visit_value::<#field_ty>())\n+                        try!(_serde::de::MapVisitor::visit_value::<#field_ty>(&mut visitor))\n                     }\n                 }\n                 Some(path) => {\n@@ -871,16 +873,16 @@ fn deserialize_map(\n                     quote!({\n                         #wrapper\n                         #wrapper_impl\n-                        try!(visitor.visit_value::<#wrapper_ty>()).value\n+                        try!(_serde::de::MapVisitor::visit_value::<#wrapper_ty>(&mut visitor)).value\n                     })\n                 }\n             };\n             quote! {\n                 __Field::#name => {\n-                    if #name.is_some() {\n-                        return Err(<__V::Error as _serde::de::Error>::duplicate_field(#deser_name));\n+                    if _serde::export::Option::is_some(&#name) {\n+                        return _serde::export::Err(<__V::Error as _serde::de::Error>::duplicate_field(#deser_name));\n                     }\n-                    #name = Some(#visit);\n+                    #name = _serde::export::Some(#visit);\n                 }\n             }\n         });\n@@ -890,7 +892,7 @@ fn deserialize_map(\n         None\n     } else {\n         Some(quote! {\n-            _ => { let _ = try!(visitor.visit_value::<_serde::de::impls::IgnoredAny>()); }\n+            _ => { let _ = try!(_serde::de::MapVisitor::visit_value::<_serde::de::impls::IgnoredAny>(&mut visitor)); }\n         })\n     };\n \n@@ -898,12 +900,13 @@ fn deserialize_map(\n     let match_keys = if item_attrs.deny_unknown_fields() && all_skipped {\n         quote! {\n             // FIXME: Once we drop support for Rust 1.15:\n-            // let None::<__Field> = try!(visitor.visit_key());\n-            try!(visitor.visit_key::<__Field>()).map(|impossible| match impossible {});\n+            // let _serde::export::None::<__Field> = try!(_serde::de::MapVisitor::visit_key(&mut visitor));\n+            try!(_serde::de::MapVisitor::visit_key::<__Field>(&mut visitor))\n+                .map(|impossible| match impossible {});\n         }\n     } else {\n         quote! {\n-            while let Some(key) = try!(visitor.visit_key::<__Field>()) {\n+            while let _serde::export::Some(key) = try!(_serde::de::MapVisitor::visit_key::<__Field>(&mut visitor)) {\n                 match key {\n                     #(#value_arms)*\n                     #ignored_arm\n@@ -919,8 +922,8 @@ fn deserialize_map(\n \n             quote! {\n                 let #name = match #name {\n-                    Some(#name) => #name,\n-                    None => #missing_expr\n+                    _serde::export::Some(#name) => #name,\n+                    _serde::export::None => #missing_expr\n                 };\n             }\n         });\n@@ -943,7 +946,7 @@ fn deserialize_map(\n \n         #(#extract_values)*\n \n-        Ok(#struct_path { #(#result),* })\n+        _serde::export::Ok(#struct_path { #(#result),* })\n     }\n }\n \n@@ -990,7 +993,7 @@ fn wrap_deserialize_with(\n                     where __D: _serde::Deserializer\n                 {\n                     let value = try!(#deserialize_with(__d));\n-                    Ok(__SerdeDeserializeWithStruct {\n+                    _serde::export::Ok(__SerdeDeserializeWithStruct {\n                         value: value,\n                         phantom: _serde::export::PhantomData,\n                     })\n@@ -1021,7 +1024,7 @@ fn expr_is_missing(attrs: &attr::Field) -> Tokens {\n         }\n         Some(_) => {\n             quote! {\n-                return Err(<__V::Error as _serde::de::Error>::missing_field(#name))\n+                return _serde::export::Err(<__V::Error as _serde::de::Error>::missing_field(#name))\n             }\n         }\n     }\ndiff --git a/serde_derive/src/ser.rs b/serde_derive/src/ser.rs\nindex f85839e53..6478de411 100644\n--- a/serde_derive/src/ser.rs\n+++ b/serde_derive/src/ser.rs\n@@ -125,7 +125,7 @@ fn serialize_unit_struct(item_attrs: &attr::Item) -> Tokens {\n     let type_name = item_attrs.name().serialize_name();\n \n     quote! {\n-        _serializer.serialize_unit_struct(#type_name)\n+        _serde::Serializer::serialize_unit_struct(_serializer, #type_name)\n     }\n }\n \n@@ -144,7 +144,7 @@ fn serialize_newtype_struct(\n     }\n \n     quote! {\n-        _serializer.serialize_newtype_struct(#type_name, #field_expr)\n+        _serde::Serializer::serialize_newtype_struct(_serializer, #type_name, #field_expr)\n     }\n }\n \n@@ -167,7 +167,7 @@ fn serialize_tuple_struct(\n     let let_mut = mut_if(len > 0);\n \n     quote! {\n-        let #let_mut __serde_state = try!(_serializer.serialize_tuple_struct(#type_name, #len));\n+        let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple_struct(_serializer, #type_name, #len));\n         #(#serialize_stmts)*\n         _serde::ser::SerializeTupleStruct::end(__serde_state)\n     }\n@@ -208,7 +208,7 @@ fn serialize_struct(\n         .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n \n     quote! {\n-        let #let_mut __serde_state = try!(_serializer.serialize_struct(#type_name, #len));\n+        let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct(_serializer, #type_name, #len));\n         #(#serialize_fields)*\n         _serde::ser::SerializeStruct::end(__serde_state)\n     }\n@@ -260,7 +260,7 @@ fn serialize_variant(\n         let skipped_msg = format!(\"the enum variant {}::{} cannot be serialized\",\n                                 type_ident, variant_ident);\n         let skipped_err = quote! {\n-            Err(_serde::ser::Error::custom(#skipped_msg))\n+            _serde::export::Err(_serde::ser::Error::custom(#skipped_msg))\n         };\n         let fields_pat = match variant.style {\n             Style::Unit => quote!(),\n@@ -380,7 +380,8 @@ fn serialize_tuple_variant(\n     let let_mut = mut_if(len > 0);\n \n     quote! {\n-        let #let_mut __serde_state = try!(_serializer.serialize_tuple_variant(\n+        let #let_mut __serde_state = try!(_serde::Serializer::serialize_tuple_variant(\n+            _serializer,\n             #type_name,\n             #variant_index,\n             #variant_name,\n@@ -426,7 +427,8 @@ fn serialize_struct_variant(\n         .fold(quote!(0), |sum, expr| quote!(#sum + #expr));\n \n     quote! {\n-        let #let_mut __serde_state = try!(_serializer.serialize_struct_variant(\n+        let #let_mut __serde_state = try!(_serde::Serializer::serialize_struct_variant(\n+            _serializer,\n             #item_name,\n             #variant_index,\n             #variant_name,\n@@ -537,7 +539,7 @@ fn wrap_serialize_with(\n     quote!({\n         struct __SerializeWith #wrapper_generics #where_clause {\n             value: &'__a #field_ty,\n-            phantom: ::std::marker::PhantomData<#item_ty>,\n+            phantom: _serde::export::PhantomData<#item_ty>,\n         }\n \n         impl #wrapper_generics _serde::Serialize for #wrapper_ty #where_clause {\n@@ -550,7 +552,7 @@ fn wrap_serialize_with(\n \n         &__SerializeWith {\n             value: #value,\n-            phantom: ::std::marker::PhantomData::<#item_ty>,\n+            phantom: _serde::export::PhantomData::<#item_ty>,\n         }\n     })\n }\n", "test_patch": "diff --git a/test_suite/tests/test_gen.rs b/test_suite/tests/test_gen.rs\nindex 34b5c469f..2f53a00e4 100644\n--- a/test_suite/tests/test_gen.rs\n+++ b/test_suite/tests/test_gen.rs\n@@ -8,11 +8,15 @@ use self::serde::de::{Deserialize, Deserializer};\n \n use std::borrow::Cow;\n use std::marker::PhantomData;\n+use std::result::Result as StdResult;\n \n // Try to trip up the generated code if it fails to use fully qualified paths.\n #[allow(dead_code)]\n struct Result;\n-use std::result::Result as StdResult;\n+#[allow(dead_code)]\n+struct Ok;\n+#[allow(dead_code)]\n+struct Err;\n \n //////////////////////////////////////////////////////////////////////////\n \n", "problem_statement": "Generated code is wrong if Ok or Err are redefined\n```rust\r\n#[macro_use]\r\nextern crate serde_derive;\r\n\r\nstruct Ok;\r\nstruct Err;\r\n\r\n#[derive(Deserialize)]\r\nstruct S {\r\n    x: ()\r\n}\r\n```\r\n\r\n```rust\r\nerror: expected function, found `Ok`\r\n --> src/main.rs:7:10\r\n  |\r\n7 | #[derive(Deserialize)]\r\n  |          ^^^^^^^^^^^\r\n  |\r\nnote: defined here\r\n --> src/main.rs:4:1\r\n  |\r\n4 | struct Ok;\r\n  | ^^^^^^^^^^\r\n\r\nerror: expected function, found `Err`\r\n --> src/main.rs:7:10\r\n  |\r\n7 | #[derive(Deserialize)]\r\n  |          ^^^^^^^^^^^\r\n  |\r\nnote: defined here\r\n --> src/main.rs:5:1\r\n  |\r\n5 | struct Err;\r\n  | ^^^^^^^^^^^\r\n```\n", "hints_text": "", "created_at": "2017-02-01T20:14:24Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 733, "instance_id": "serde-rs__serde-733", "issue_numbers": ["729"], "base_commit": "74cf80989d06210c9309e82549a51ff6d0b4ed94", "patch": "diff --git a/.travis.yml b/.travis.yml\nindex aca19dc87..c415551ee 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -1,5 +1,6 @@\n sudo: false\n language: rust\n+cache: cargo\n \n # run builds for all the trains (and more)\n rust:\n@@ -8,20 +9,16 @@ rust:\n   - beta\n   - nightly\n \n+matrix:\n+  include:\n+    - rust: nightly\n+      env: CLIPPY=true\n+\n before_script:\n   - pip install 'travis-cargo<0.2' --user\n   - export PATH=$HOME/.local/bin:$PATH\n \n-script:\n-  - (cd serde && travis-cargo build)\n-  - (cd serde && travis-cargo --only beta test)\n-  - (cd serde && travis-cargo --only nightly test -- --features unstable-testing)\n-  - (cd serde && travis-cargo build -- --no-default-features)\n-  - (cd serde && travis-cargo --only nightly build -- --no-default-features --features alloc)\n-  - (cd serde && travis-cargo --only nightly build -- --no-default-features --features collections)\n-  - (cd test_suite && travis-cargo --only beta test)\n-  - (cd test_suite/deps && travis-cargo --only nightly build && cd .. && travis-cargo --only nightly test -- --features unstable-testing)\n-  - (cd test_suite/no_std && travis-cargo --only nightly build)\n+script: sh travis.sh\n \n env:\n   global:\ndiff --git a/serde/Cargo.toml b/serde/Cargo.toml\nindex 2cc5dca4c..357fff3af 100644\n--- a/serde/Cargo.toml\n+++ b/serde/Cargo.toml\n@@ -22,10 +22,7 @@ std = []\n unstable = []\n alloc = [\"unstable\"]\n collections = [\"alloc\"]\n-unstable-testing = [\"clippy\", \"unstable\", \"std\"]\n-\n-[dependencies]\n-clippy = { version = \"0.*\", optional = true }\n+unstable-testing = [\"unstable\", \"std\"]\n \n [dev-dependencies]\n serde_derive = \"0.9\"\ndiff --git a/serde/src/lib.rs b/serde/src/lib.rs\nindex efb29411e..eb07bbbff 100644\n--- a/serde/src/lib.rs\n+++ b/serde/src/lib.rs\n@@ -64,9 +64,7 @@\n #![cfg_attr(feature = \"unstable\", feature(nonzero, inclusive_range, zero_one))]\n #![cfg_attr(feature = \"alloc\", feature(alloc))]\n #![cfg_attr(feature = \"collections\", feature(collections, enumset))]\n-#![cfg_attr(feature = \"clippy\", feature(plugin))]\n-#![cfg_attr(feature = \"clippy\", plugin(clippy))]\n-#![cfg_attr(feature = \"clippy\", allow(linkedlist, type_complexity, doc_markdown))]\n+#![cfg_attr(feature = \"cargo-clippy\", allow(linkedlist, type_complexity, doc_markdown))]\n #![deny(missing_docs)]\n \n #[cfg(feature = \"collections\")]\ndiff --git a/serde_codegen_internals/Cargo.toml b/serde_codegen_internals/Cargo.toml\nindex 9d9bfb658..36ec99aab 100644\n--- a/serde_codegen_internals/Cargo.toml\n+++ b/serde_codegen_internals/Cargo.toml\n@@ -10,11 +10,7 @@ documentation = \"https://docs.serde.rs/serde_codegen_internals/\"\n keywords = [\"serde\", \"serialization\"]\n include = [\"Cargo.toml\", \"src/**/*.rs\"]\n \n-[features]\n-unstable-testing = [\"clippy\"]\n-\n [dependencies]\n-clippy = { version = \"0.*\", optional = true }\n syn = \"0.11\"\n \n [badges]\ndiff --git a/serde_codegen_internals/src/lib.rs b/serde_codegen_internals/src/lib.rs\nindex 0f37f5fa2..cd998deb9 100644\n--- a/serde_codegen_internals/src/lib.rs\n+++ b/serde_codegen_internals/src/lib.rs\n@@ -1,6 +1,3 @@\n-#![cfg_attr(feature = \"clippy\", plugin(clippy))]\n-#![cfg_attr(feature = \"clippy\", feature(plugin))]\n-\n extern crate syn;\n \n pub mod ast;\ndiff --git a/serde_derive/Cargo.toml b/serde_derive/Cargo.toml\nindex 419cd9624..e3c5f3599 100644\n--- a/serde_derive/Cargo.toml\n+++ b/serde_derive/Cargo.toml\n@@ -12,7 +12,6 @@ include = [\"Cargo.toml\", \"src/**/*.rs\"]\n \n [features]\n unstable = []\n-unstable-testing = [\"clippy\", \"serde_codegen_internals/unstable-testing\"]\n \n [badges]\n travis-ci = { repository = \"serde-rs/serde\" }\n@@ -22,7 +21,6 @@ name = \"serde_derive\"\n proc-macro = true\n \n [dependencies]\n-clippy = { version = \"0.*\", optional = true }\n quote = \"0.3.8\"\n serde_codegen_internals = { version = \"=0.12.0\", default-features = false, path = \"../serde_codegen_internals\" }\n syn = { version = \"0.11\", features = [\"aster\", \"visit\"] }\ndiff --git a/serde_derive/src/lib.rs b/serde_derive/src/lib.rs\nindex cf80dc64f..6e6a8c3af 100644\n--- a/serde_derive/src/lib.rs\n+++ b/serde_derive/src/lib.rs\n@@ -1,7 +1,5 @@\n-#![cfg_attr(feature = \"clippy\", plugin(clippy))]\n-#![cfg_attr(feature = \"clippy\", feature(plugin))]\n-#![cfg_attr(feature = \"clippy\", allow(too_many_arguments))]\n-#![cfg_attr(feature = \"clippy\", allow(used_underscore_binding))]\n+#![cfg_attr(feature = \"cargo-clippy\", allow(too_many_arguments))]\n+#![cfg_attr(feature = \"cargo-clippy\", allow(used_underscore_binding))]\n \n // The `quote!` macro requires deep recursion.\n #![recursion_limit = \"192\"]\ndiff --git a/travis.sh b/travis.sh\nnew file mode 100644\nindex 000000000..225869ee7\n--- /dev/null\n+++ b/travis.sh\n@@ -0,0 +1,24 @@\n+#!/bin/bash\n+set -ev\n+if [ \"${CLIPPY}\" = \"true\" ]; then\n+    if cargo install clippy -f; then\n+        (cd serde && cargo clippy --features unstable-testing -- -Dclippy)\n+        (cd serde_derive && cargo clippy --features unstable-testing -- -Dclippy)\n+        (cd test_suite && cargo clippy --features unstable-testing -- -Dclippy)\n+        (cd test_suite/deps && cargo clippy -- -Dclippy)\n+        (cd test_suite/no_std && cargo clippy -- -Dclippy)\n+    else\n+        echo \"could not compile clippy, ignoring clippy tests\"\n+    fi\n+else\n+    (cd serde && travis-cargo build)\n+    (cd serde && travis-cargo --only beta test)\n+    (cd serde && travis-cargo --only nightly test -- --features unstable-testing)\n+    (cd serde && travis-cargo build -- --no-default-features)\n+    (cd serde && travis-cargo --only nightly build -- --no-default-features --features alloc)\n+    (cd serde && travis-cargo --only nightly build -- --no-default-features --features collections)\n+    (cd test_suite && travis-cargo --only beta test)\n+    (cd test_suite/deps && travis-cargo --only nightly build)\n+    (cd test_suite travis-cargo --only nightly test -- --features unstable-testing)\n+    (cd test_suite/no_std && travis-cargo --only nightly build)\n+fi\n\\ No newline at end of file\n", "test_patch": "diff --git a/serde_test/Cargo.toml b/serde_test/Cargo.toml\nindex 94f6a409b..83d90e971 100644\n--- a/serde_test/Cargo.toml\n+++ b/serde_test/Cargo.toml\n@@ -11,11 +11,7 @@ readme = \"../README.md\"\n keywords = [\"serde\", \"serialization\"]\n include = [\"Cargo.toml\", \"src/**/*.rs\"]\n \n-[features]\n-unstable-testing = [\"clippy\"]\n-\n [dependencies]\n-clippy = { version = \"0.*\", optional = true }\n serde = { version = \"0.9\", path = \"../serde\" }\n \n [badges]\ndiff --git a/serde_test/src/lib.rs b/serde_test/src/lib.rs\nindex 4c9397e60..945262c02 100644\n--- a/serde_test/src/lib.rs\n+++ b/serde_test/src/lib.rs\n@@ -1,6 +1,3 @@\n-#![cfg_attr(feature = \"clippy\", feature(plugin))]\n-#![cfg_attr(feature = \"clippy\", plugin(clippy))]\n-\n extern crate serde;\n \n mod assert;\ndiff --git a/test_suite/Cargo.toml b/test_suite/Cargo.toml\nindex 20039a9c7..86ac863fd 100644\n--- a/test_suite/Cargo.toml\n+++ b/test_suite/Cargo.toml\n@@ -13,11 +13,8 @@ publish = false\n \n [features]\n unstable-testing = [\n-    \"clippy\",\n     \"compiletest_rs\",\n     \"serde/unstable-testing\",\n-    \"serde_derive/unstable-testing\",\n-    \"serde_test/unstable-testing\",\n ]\n \n [dev-dependencies]\n@@ -28,7 +25,6 @@ serde_derive = { path = \"../serde_derive\" }\n serde_test = { path = \"../serde_test\" }\n \n [dependencies]\n-clippy = { version = \"0.*\", optional = true }\n compiletest_rs = { version = \"0.2\", optional = true }\n \n [[test]]\ndiff --git a/test_suite/no_std/src/main.rs b/test_suite/no_std/src/main.rs\nindex 5eae52672..6639b5ccc 100644\n--- a/test_suite/no_std/src/main.rs\n+++ b/test_suite/no_std/src/main.rs\n@@ -21,7 +21,9 @@ pub extern fn rust_eh_unwind_resume() {}\n pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n                                _file: &'static str,\n                                _line: u32) -> ! {\n-    loop {}\n+    unsafe {\n+        libc::abort()\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////////\ndiff --git a/test_suite/tests/test.rs b/test_suite/tests/test.rs\nindex 7c1b06b53..b83be6366 100644\n--- a/test_suite/tests/test.rs\n+++ b/test_suite/tests/test.rs\n@@ -1,6 +1,3 @@\n-#![cfg_attr(feature = \"clippy\", feature(plugin))]\n-#![cfg_attr(feature = \"clippy\", plugin(clippy))]\n-\n #![cfg_attr(feature = \"unstable-testing\", feature(test, non_ascii_idents))]\n \n #[cfg(feature = \"unstable-testing\")]\n", "problem_statement": "Cannot publish serde_derive\n```\r\n$ git checkout v0.9.3\r\n  HEAD is now at 8624ca6... Release 0.9.3\r\n\r\n$ cd serde_derive\r\n\r\n$ cargo publish\r\n      Updating registry `https://github.com/rust-lang/crates.io-index`\r\n     Packaging serde_derive v0.9.3 (file://../serde_derive)\r\n     Verifying serde_derive v0.9.3 (file://../serde_derive)\r\n      Updating registry `https://github.com/rust-lang/crates.io-index`\r\n  error: failed to verify package tarball\r\n\r\n  Caused by:\r\n    cyclic package dependency: package `cargo_metadata v0.1.1` depends on itself\r\n\r\n$ cargo tree --features clippy\r\n  serde_derive v0.9.3 (file://../serde_derive)\r\n  \u251c\u2500\u2500 clippy v0.0.112\r\n  \u2502   \u251c\u2500\u2500 cargo_metadata v0.1.1\r\n  \u2502   \u2502   \u251c\u2500\u2500 serde v0.9.3\r\n  \u2502   \u2502   \u251c\u2500\u2500 serde_derive v0.9.2\r\n  \u2502   \u2502   \u2502   \u251c\u2500\u2500 quote v0.3.12\r\n  \u2502   \u2502   \u2502   \u251c\u2500\u2500 serde_codegen_internals v0.12.0\r\n  \u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 syn v0.11.4\r\n  \u2502   \u2502   \u2502   \u2502       \u251c\u2500\u2500 quote v0.3.12 (*)\r\n  \u2502   \u2502   \u2502   \u2502       \u2514\u2500\u2500 unicode-xid v0.0.4\r\n  \u2502   \u2502   \u2502   \u2514\u2500\u2500 syn v0.11.4 (*)\r\n  \u2502   \u2502   \u2514\u2500\u2500 serde_json v0.9.1\r\n  \u2502   \u2502       \u251c\u2500\u2500 dtoa v0.3.1\r\n  \u2502   \u2502       \u251c\u2500\u2500 itoa v0.2.1\r\n  \u2502   \u2502       \u251c\u2500\u2500 num-traits v0.1.36\r\n  \u2502   \u2502       \u2514\u2500\u2500 serde v0.9.3 (*)\r\n  \u2502   \u2514\u2500\u2500 clippy_lints v0.0.112\r\n  \u2502       \u251c\u2500\u2500 matches v0.1.4\r\n  \u2502       \u251c\u2500\u2500 quine-mc_cluskey v0.2.4\r\n  \u2502       \u251c\u2500\u2500 regex-syntax v0.4.0\r\n  \u2502       \u251c\u2500\u2500 semver v0.2.3\r\n  \u2502       \u2502   \u2514\u2500\u2500 nom v1.2.4\r\n  \u2502       \u251c\u2500\u2500 toml v0.2.1\r\n  \u2502       \u2502   \u2514\u2500\u2500 rustc-serialize v0.3.22\r\n  \u2502       \u2514\u2500\u2500 unicode-normalization v0.1.3\r\n  \u251c\u2500\u2500 quote v0.3.12 (*)\r\n  \u251c\u2500\u2500 serde_codegen_internals v0.12.0 (file://../serde_codegen_internals)\r\n  \u2502   \u2514\u2500\u2500 syn v0.11.4 (*)\r\n  \u2514\u2500\u2500 syn v0.11.4 (*)\r\n```\r\n\r\n@oli-obk any ideas? Serde_derive depends on clippy which depends on cargo_metadata which depends on serde_derive.\n", "hints_text": "I got around it by `cargo publish --no-verify` but obviously that is not ideal...\nlol I so did not see that one coming.\r\n\r\nCan we just move to cargo clippy instead of depending on clippy?\r\n\r\nI could even set up clippy testing as a separate travis job, so it wouldn't break our nightly job\n> cargo clippy\r\n\r\n> separate travis job\r\n\r\nYes let's do both of those!", "created_at": "2017-01-31T08:35:07Z", "version": "0.9"}, {"repo": "serde-rs/serde", "pull_number": 721, "instance_id": "serde-rs__serde-721", "issue_numbers": ["718"], "base_commit": "8cb6607e827717136a819caa44d8e43702724883", "patch": "diff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex 496e5bb71..d28dba028 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -180,12 +180,10 @@ macro_rules! impl_deserialize_num {\n                         formatter.write_str(stringify!($ty))\n                     }\n \n-                    impl_deserialize_num_method!($ty, isize, visit_isize, from_isize, Signed, i64);\n                     impl_deserialize_num_method!($ty, i8, visit_i8, from_i8, Signed, i64);\n                     impl_deserialize_num_method!($ty, i16, visit_i16, from_i16, Signed, i64);\n                     impl_deserialize_num_method!($ty, i32, visit_i32, from_i32, Signed, i64);\n                     impl_deserialize_num_method!($ty, i64, visit_i64, from_i64, Signed, i64);\n-                    impl_deserialize_num_method!($ty, usize, visit_usize, from_usize, Unsigned, u64);\n                     impl_deserialize_num_method!($ty, u8, visit_u8, from_u8, Unsigned, u64);\n                     impl_deserialize_num_method!($ty, u16, visit_u16, from_u16, Unsigned, u64);\n                     impl_deserialize_num_method!($ty, u32, visit_u32, from_u32, Unsigned, u64);\n@@ -209,12 +207,12 @@ macro_rules! impl_deserialize_num {\n     }\n }\n \n-impl_deserialize_num!(isize, deserialize_isize);\n+impl_deserialize_num!(isize, deserialize_i64);\n impl_deserialize_num!(i8, deserialize_i8);\n impl_deserialize_num!(i16, deserialize_i16);\n impl_deserialize_num!(i32, deserialize_i32);\n impl_deserialize_num!(i64, deserialize_i64);\n-impl_deserialize_num!(usize, deserialize_usize);\n+impl_deserialize_num!(usize, deserialize_u64);\n impl_deserialize_num!(u8, deserialize_u8);\n impl_deserialize_num!(u16, deserialize_u16);\n impl_deserialize_num!(u32, deserialize_u32);\n@@ -1150,7 +1148,7 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n                         formatter.write_str(\"`Ok` or `Err`\")\n                     }\n \n-                    fn visit_usize<E>(self, value: usize) -> Result<Field, E> where E: Error {\n+                    fn visit_u32<E>(self, value: u32) -> Result<Field, E> where E: Error {\n                         match value {\n                             0 => Ok(Field::Ok),\n                             1 => Ok(Field::Err),\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex e45b20af1..e053b3dfb 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -339,12 +339,12 @@ pub enum Unexpected<'a> {\n     /// The input contained a boolean value that was not expected.\n     Bool(bool),\n \n-    /// The input contained an unsigned integer `usize`, `u8`, `u16`, `u32` or\n-    /// `u64` that was not expected.\n+    /// The input contained an unsigned integer `u8`, `u16`, `u32` or `u64` that\n+    /// was not expected.\n     Unsigned(u64),\n \n-    /// The input contained a signed integer `isize`, `i8`, `i16`, `i32` or\n-    /// `i64` that was not expected.\n+    /// The input contained a signed integer `i8`, `i16`, `i32` or `i64` that\n+    /// was not expected.\n     Signed(i64),\n \n     /// The input contained a floating point `f32` or `f64` that was not\n@@ -694,7 +694,7 @@ impl<T> DeserializeSeed for PhantomData<T>\n /// any data structure supported by Serde.\n ///\n /// The role of this trait is to define the deserialization half of the Serde\n-/// data model, which is a way to categorize every Rust data type into one of 30\n+/// data model, which is a way to categorize every Rust data type into one of 28\n /// possible types. Each method of the `Serializer` trait corresponds to one of\n /// the types of the data model.\n ///\n@@ -704,13 +704,13 @@ impl<T> DeserializeSeed for PhantomData<T>\n ///\n /// The types that make up the Serde data model are:\n ///\n-///  - 15 primitive types:\n+///  - 12 primitive types:\n ///    - bool\n-///    - isize, i8, i16, i32, i64\n-///    - usize, u8, u16, u32, u64\n+///    - i8, i16, i32, i64\n+///    - u8, u16, u32, u64\n ///    - f32, f64\n ///    - char\n-///    - string\n+///  - string\n ///  - byte array - [u8]\n ///  - option\n ///    - either none or some value\n@@ -792,10 +792,6 @@ pub trait Deserializer: Sized {\n     fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor;\n \n-    /// Hint that the `Deserialize` type is expecting a `usize` value.\n-    fn deserialize_usize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n-\n     /// Hint that the `Deserialize` type is expecting a `u8` value.\n     fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor;\n@@ -812,10 +808,6 @@ pub trait Deserializer: Sized {\n     fn deserialize_u64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor;\n \n-    /// Hint that the `Deserialize` type is expecting an `isize` value.\n-    fn deserialize_isize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n-        where V: Visitor;\n-\n     /// Hint that the `Deserialize` type is expecting an `i8` value.\n     fn deserialize_i8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor;\n@@ -1030,13 +1022,6 @@ pub trait Visitor: Sized {\n         Err(Error::invalid_type(Unexpected::Bool(v), &self))\n     }\n \n-    /// Deserialize an `isize` into a `Value`.\n-    fn visit_isize<E>(self, v: isize) -> Result<Self::Value, E>\n-        where E: Error,\n-    {\n-        self.visit_i64(v as i64)\n-    }\n-\n     /// Deserialize an `i8` into a `Value`.\n     fn visit_i8<E>(self, v: i8) -> Result<Self::Value, E>\n         where E: Error,\n@@ -1065,13 +1050,6 @@ pub trait Visitor: Sized {\n         Err(Error::invalid_type(Unexpected::Signed(v), &self))\n     }\n \n-    /// Deserialize a `usize` into a `Value`.\n-    fn visit_usize<E>(self, v: usize) -> Result<Self::Value, E>\n-        where E: Error,\n-    {\n-        self.visit_u64(v as u64)\n-    }\n-\n     /// Deserialize a `u8` into a `Value`.\n     fn visit_u8<E>(self, v: u8) -> Result<Self::Value, E>\n         where E: Error,\ndiff --git a/serde/src/de/private.rs b/serde/src/de/private.rs\nindex 92e71cf86..1ff206cdb 100644\n--- a/serde/src/de/private.rs\n+++ b/serde/src/de/private.rs\n@@ -28,10 +28,9 @@ pub fn missing_field<V, E>(field: &'static str) -> Result<V, E>\n         }\n \n         forward_to_deserialize! {\n-            bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str\n-            string unit seq seq_fixed_size bytes byte_buf map unit_struct\n-            newtype_struct tuple_struct struct struct_field tuple enum\n-            ignored_any\n+            bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n+            seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n+            tuple_struct struct struct_field tuple enum ignored_any\n         }\n     }\n \ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 38f993940..ae5c93afb 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -126,9 +126,9 @@ impl<E> de::Deserializer for UnitDeserializer<E>\n     type Error = E;\n \n     forward_to_deserialize! {\n-        bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n-        unit seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple enum ignored_any byte_buf\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit seq\n+        seq_fixed_size bytes map unit_struct newtype_struct tuple_struct struct\n+        struct_field tuple enum ignored_any byte_buf\n     }\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n@@ -147,7 +147,7 @@ impl<E> de::Deserializer for UnitDeserializer<E>\n ///////////////////////////////////////////////////////////////////////////////\n \n macro_rules! primitive_deserializer {\n-    ($ty:ty, $name:ident, $method:ident) => {\n+    ($ty:ty, $name:ident, $method:ident $($cast:tt)*) => {\n         /// A helper deserializer that deserializes a number.\n         pub struct $name<E>($ty, PhantomData<E>);\n \n@@ -167,16 +167,15 @@ macro_rules! primitive_deserializer {\n             type Error = E;\n \n             forward_to_deserialize! {\n-                bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str\n-                string unit option seq seq_fixed_size bytes map unit_struct\n-                newtype_struct tuple_struct struct struct_field tuple enum\n-                ignored_any byte_buf\n+                bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit\n+                option seq seq_fixed_size bytes map unit_struct newtype_struct\n+                tuple_struct struct struct_field tuple enum ignored_any byte_buf\n             }\n \n             fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n                 where V: de::Visitor,\n             {\n-                visitor.$method(self.0)\n+                visitor.$method(self.0 $($cast)*)\n             }\n         }\n     }\n@@ -187,12 +186,12 @@ primitive_deserializer!(i8, I8Deserializer, visit_i8);\n primitive_deserializer!(i16, I16Deserializer, visit_i16);\n primitive_deserializer!(i32, I32Deserializer, visit_i32);\n primitive_deserializer!(i64, I64Deserializer, visit_i64);\n-primitive_deserializer!(isize, IsizeDeserializer, visit_isize);\n+primitive_deserializer!(isize, IsizeDeserializer, visit_i64 as i64);\n primitive_deserializer!(u8, U8Deserializer, visit_u8);\n primitive_deserializer!(u16, U16Deserializer, visit_u16);\n primitive_deserializer!(u32, U32Deserializer, visit_u32);\n primitive_deserializer!(u64, U64Deserializer, visit_u64);\n-primitive_deserializer!(usize, UsizeDeserializer, visit_usize);\n+primitive_deserializer!(usize, UsizeDeserializer, visit_u64 as u64);\n primitive_deserializer!(f32, F32Deserializer, visit_f32);\n primitive_deserializer!(f64, F64Deserializer, visit_f64);\n primitive_deserializer!(char, CharDeserializer, visit_char);\n@@ -233,9 +232,9 @@ impl<'a, E> de::Deserializer for StrDeserializer<'a, E>\n     }\n \n     forward_to_deserialize! {\n-        bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n-        unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple ignored_any byte_buf\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n+        seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n+        struct struct_field tuple ignored_any byte_buf\n     }\n }\n \n@@ -291,9 +290,9 @@ impl<E> de::Deserializer for StringDeserializer<E>\n     }\n \n     forward_to_deserialize! {\n-        bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n-        unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple ignored_any byte_buf\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n+        seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n+        struct struct_field tuple ignored_any byte_buf\n     }\n }\n \n@@ -353,9 +352,9 @@ impl<'a, E> de::Deserializer for CowStrDeserializer<'a, E>\n     }\n \n     forward_to_deserialize! {\n-        bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n-        unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple ignored_any byte_buf\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n+        seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n+        struct struct_field tuple ignored_any byte_buf\n     }\n }\n \n@@ -426,9 +425,9 @@ impl<I, T, E> de::Deserializer for SeqDeserializer<I, E>\n     }\n \n     forward_to_deserialize! {\n-        bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n-        unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple enum ignored_any byte_buf\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n+        seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n+        struct struct_field tuple enum ignored_any byte_buf\n     }\n }\n \n@@ -538,9 +537,9 @@ impl<V_, E> de::Deserializer for SeqVisitorDeserializer<V_, E>\n     }\n \n     forward_to_deserialize! {\n-        bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n-        unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple enum ignored_any byte_buf\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n+        seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n+        struct struct_field tuple enum ignored_any byte_buf\n     }\n }\n \n@@ -634,9 +633,9 @@ impl<I, E> de::Deserializer for MapDeserializer<I, E>\n     }\n \n     forward_to_deserialize! {\n-        bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n-        unit option bytes map unit_struct newtype_struct tuple_struct struct\n-        struct_field tuple enum ignored_any byte_buf\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n+        bytes map unit_struct newtype_struct tuple_struct struct struct_field\n+        tuple enum ignored_any byte_buf\n     }\n }\n \n@@ -728,9 +727,9 @@ impl<A, B, E> de::Deserializer for PairDeserializer<A, B, E>\n     type Error = E;\n \n     forward_to_deserialize! {\n-        bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n-        unit option bytes map unit_struct newtype_struct tuple_struct struct\n-        struct_field tuple enum ignored_any byte_buf\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n+        bytes map unit_struct newtype_struct tuple_struct struct struct_field\n+        tuple enum ignored_any byte_buf\n     }\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n@@ -872,9 +871,9 @@ impl<V_, E> de::Deserializer for MapVisitorDeserializer<V_, E>\n     }\n \n     forward_to_deserialize! {\n-        bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n-        unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple enum ignored_any byte_buf\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n+        seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n+        struct struct_field tuple enum ignored_any byte_buf\n     }\n }\n \n@@ -905,9 +904,9 @@ impl<'a, E> de::Deserializer for BytesDeserializer<'a, E>\n     }\n \n     forward_to_deserialize! {\n-        bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n-        unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple enum ignored_any byte_buf\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n+        seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n+        struct struct_field tuple enum ignored_any byte_buf\n     }\n }\n \n@@ -941,9 +940,9 @@ impl<E> de::Deserializer for ByteBufDeserializer<E>\n     }\n \n     forward_to_deserialize! {\n-        bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n-        unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple enum ignored_any byte_buf\n+        bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n+        seq seq_fixed_size bytes map unit_struct newtype_struct tuple_struct\n+        struct struct_field tuple enum ignored_any byte_buf\n     }\n }\n \ndiff --git a/serde/src/macros.rs b/serde/src/macros.rs\nindex 0a8416ac7..8050e8b59 100644\n--- a/serde/src/macros.rs\n+++ b/serde/src/macros.rs\n@@ -32,9 +32,6 @@ macro_rules! forward_to_deserialize_helper {\n     (bool) => {\n         forward_to_deserialize_method!{deserialize_bool()}\n     };\n-    (usize) => {\n-        forward_to_deserialize_method!{deserialize_usize()}\n-    };\n     (u8) => {\n         forward_to_deserialize_method!{deserialize_u8()}\n     };\n@@ -47,9 +44,6 @@ macro_rules! forward_to_deserialize_helper {\n     (u64) => {\n         forward_to_deserialize_method!{deserialize_u64()}\n     };\n-    (isize) => {\n-        forward_to_deserialize_method!{deserialize_isize()}\n-    };\n     (i8) => {\n         forward_to_deserialize_method!{deserialize_i8()}\n     };\n@@ -154,9 +148,9 @@ macro_rules! forward_to_deserialize_helper {\n ///     self.deserialize(visitor)\n /// }\n /// #     forward_to_deserialize! {\n-/// #         usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n-/// #         unit option seq seq_fixed_size bytes byte_buf map unit_struct\n-/// #         newtype_struct tuple_struct struct struct_field tuple enum ignored_any\n+/// #         u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n+/// #         seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n+/// #         tuple_struct struct struct_field tuple enum ignored_any\n /// #     }\n /// # }\n /// # fn main() {}\n@@ -181,9 +175,9 @@ macro_rules! forward_to_deserialize_helper {\n ///     }\n ///\n ///     forward_to_deserialize! {\n-///         bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str\n-///         string unit option seq seq_fixed_size bytes byte_buf map unit_struct\n-///         newtype_struct tuple_struct struct struct_field tuple enum ignored_any\n+///         bool u8 u16 u32 u64 i8 i16 i32 i64 f32 f64 char str string unit option\n+///         seq seq_fixed_size bytes byte_buf map unit_struct newtype_struct\n+///         tuple_struct struct struct_field tuple enum ignored_any\n ///     }\n /// }\n /// # fn main() {}\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex c08f56ecc..5eb36c568 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -74,25 +74,25 @@ use super::Iterator;\n ///////////////////////////////////////////////////////////////////////////////\n \n macro_rules! impl_visit {\n-    ($ty:ty, $method:ident) => {\n+    ($ty:ty, $method:ident $($cast:tt)*) => {\n         impl Serialize for $ty {\n             #[inline]\n             fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n                 where S: Serializer,\n             {\n-                serializer.$method(*self)\n+                serializer.$method(*self $($cast)*)\n             }\n         }\n     }\n }\n \n impl_visit!(bool, serialize_bool);\n-impl_visit!(isize, serialize_isize);\n+impl_visit!(isize, serialize_i64 as i64);\n impl_visit!(i8, serialize_i8);\n impl_visit!(i16, serialize_i16);\n impl_visit!(i32, serialize_i32);\n impl_visit!(i64, serialize_i64);\n-impl_visit!(usize, serialize_usize);\n+impl_visit!(usize, serialize_u64 as u64);\n impl_visit!(u8, serialize_u8);\n impl_visit!(u16, serialize_u16);\n impl_visit!(u32, serialize_u32);\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 1fa471148..e4df61b44 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -179,7 +179,7 @@ pub trait Serialize {\n /// data structure supported by Serde.\n ///\n /// The role of this trait is to define the serialization half of the Serde data\n-/// model, which is a way to categorize every Rust data structure into one of 30\n+/// model, which is a way to categorize every Rust data structure into one of 28\n /// possible types. Each method of the `Serializer` trait corresponds to one of\n /// the types of the data model.\n ///\n@@ -188,13 +188,13 @@ pub trait Serialize {\n ///\n /// The types that make up the Serde data model are:\n ///\n-///  - 15 primitive types:\n+///  - 12 primitive types:\n ///    - bool\n-///    - isize, i8, i16, i32, i64\n-///    - usize, u8, u16, u32, u64\n+///    - i8, i16, i32, i64\n+///    - u8, u16, u32, u64\n ///    - f32, f64\n ///    - char\n-///    - string\n+///  - string\n ///  - byte array - [u8]\n ///  - option\n ///    - either none or some value\n@@ -279,13 +279,6 @@ pub trait Serializer {\n     /// Serialize a `bool` value.\n     fn serialize_bool(self, v: bool) -> Result<Self::Ok, Self::Error>;\n \n-    /// Serialize an `isize` value.\n-    ///\n-    /// If the format does not differentiate between `isize` and `i64`, a\n-    /// reasonable implementation would be to cast the value to `i64` and\n-    /// forward to `serialize_i64`.\n-    fn serialize_isize(self, v: isize) -> Result<Self::Ok, Self::Error>;\n-\n     /// Serialize an `i8` value.\n     ///\n     /// If the format does not differentiate between `i8` and `i64`, a\n@@ -310,13 +303,6 @@ pub trait Serializer {\n     /// Serialize an `i64` value.\n     fn serialize_i64(self, v: i64) -> Result<Self::Ok, Self::Error>;\n \n-    /// Serialize a `usize` value.\n-    ///\n-    /// If the format does not differentiate between `usize` and `u64`, a\n-    /// reasonable implementation would be to cast the value to `u64` and\n-    /// forward to `serialize_u64`.\n-    fn serialize_usize(self, v: usize) -> Result<Self::Ok, Self::Error>;\n-\n     /// Serialize a `u8` value.\n     ///\n     /// If the format does not differentiate between `u8` and `u64`, a\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex 65f4905c6..e73193b0f 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -692,11 +692,11 @@ fn deserialize_field_visitor(\n         Some(quote!(__ignore,))\n     };\n \n-    let visit_usize = if is_variant {\n-        let variant_indices = 0usize..;\n+    let visit_index = if is_variant {\n+        let variant_indices = 0u32..;\n         let fallthrough_msg = format!(\"variant index 0 <= i < {}\", fields.len());\n         Some(quote! {\n-            fn visit_usize<__E>(self, value: usize) -> _serde::export::Result<__Field, __E>\n+            fn visit_u32<__E>(self, value: u32) -> _serde::export::Result<__Field, __E>\n                 where __E: _serde::de::Error\n             {\n                 match value {\n@@ -758,7 +758,7 @@ fn deserialize_field_visitor(\n                         formatter.write_str(\"field name\")\n                     }\n \n-                    #visit_usize\n+                    #visit_index\n \n                     fn visit_str<__E>(self, value: &str) -> _serde::export::Result<__Field, __E>\n                         where __E: _serde::de::Error\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex fc29ccd94..cb41ab15c 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -225,26 +225,16 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n         where __V: de::Visitor {\n         self.deserialize(visitor)\n     }\n-    fn deserialize_usize<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_isize<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n         match self.tokens.next() {\n             Some(Token::Bool(v)) => visitor.visit_bool(v),\n-            Some(Token::Isize(v)) => visitor.visit_isize(v),\n             Some(Token::I8(v)) => visitor.visit_i8(v),\n             Some(Token::I16(v)) => visitor.visit_i16(v),\n             Some(Token::I32(v)) => visitor.visit_i32(v),\n             Some(Token::I64(v)) => visitor.visit_i64(v),\n-            Some(Token::Usize(v)) => visitor.visit_usize(v),\n             Some(Token::U8(v)) => visitor.visit_u8(v),\n             Some(Token::U16(v)) => visitor.visit_u16(v),\n             Some(Token::U32(v)) => visitor.visit_u32(v),\ndiff --git a/serde_test/src/ser.rs b/serde_test/src/ser.rs\nindex c97de428e..4327733fb 100644\n--- a/serde_test/src/ser.rs\n+++ b/serde_test/src/ser.rs\n@@ -46,11 +46,6 @@ impl<'s, 'a, I> ser::Serializer for &'s mut Serializer<'a, I>\n         Ok(())\n     }\n \n-    fn serialize_isize(self, v: isize) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::Isize(v)));\n-        Ok(())\n-    }\n-\n     fn serialize_i8(self, v: i8) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::I8(v)));\n         Ok(())\n@@ -71,11 +66,6 @@ impl<'s, 'a, I> ser::Serializer for &'s mut Serializer<'a, I>\n         Ok(())\n     }\n \n-    fn serialize_usize(self, v: usize) -> Result<(), Error> {\n-        assert_eq!(self.tokens.next(), Some(&Token::Usize(v)));\n-        Ok(())\n-    }\n-\n     fn serialize_u8(self, v: u8) -> Result<(), Error> {\n         assert_eq!(self.tokens.next(), Some(&Token::U8(v)));\n         Ok(())\ndiff --git a/serde_test/src/token.rs b/serde_test/src/token.rs\nindex b8bd23c66..b2d2a6ef2 100644\n--- a/serde_test/src/token.rs\n+++ b/serde_test/src/token.rs\n@@ -1,12 +1,10 @@\n #[derive(Clone, PartialEq, Debug)]\n pub enum Token<'a> {\n     Bool(bool),\n-    Isize(isize),\n     I8(i8),\n     I16(i16),\n     I32(i32),\n     I64(i64),\n-    Usize(usize),\n     U8(u8),\n     U16(u16),\n     U32(u32),\ndiff --git a/testing/tests/test_de.rs b/testing/tests/test_de.rs\nindex 83c3eabf5..97481b594 100644\n--- a/testing/tests/test_de.rs\n+++ b/testing/tests/test_de.rs\n@@ -155,12 +155,10 @@ declare_tests! {\n         false => &[Token::Bool(false)],\n     }\n     test_isize {\n-        0isize => &[Token::Isize(0)],\n         0isize => &[Token::I8(0)],\n         0isize => &[Token::I16(0)],\n         0isize => &[Token::I32(0)],\n         0isize => &[Token::I64(0)],\n-        0isize => &[Token::Usize(0)],\n         0isize => &[Token::U8(0)],\n         0isize => &[Token::U16(0)],\n         0isize => &[Token::U32(0)],\n@@ -169,14 +167,12 @@ declare_tests! {\n         0isize => &[Token::F64(0.)],\n     }\n     test_ints {\n-        0isize => &[Token::Isize(0)],\n         0i8 => &[Token::I8(0)],\n         0i16 => &[Token::I16(0)],\n         0i32 => &[Token::I32(0)],\n         0i64 => &[Token::I64(0)],\n     }\n     test_uints {\n-        0usize => &[Token::Usize(0)],\n         0u8 => &[Token::U8(0)],\n         0u16 => &[Token::U16(0)],\n         0u32 => &[Token::U32(0)],\n@@ -777,7 +773,7 @@ declare_tests! {\n     test_enum_unit_usize {\n         Enum::Unit => &[\n             Token::EnumStart(\"Enum\"),\n-            Token::Usize(0),\n+            Token::U32(0),\n             Token::Unit,\n         ],\n     }\n@@ -935,7 +931,7 @@ declare_error_tests! {\n     test_enum_out_of_range<Enum> {\n         &[\n             Token::EnumStart(\"Enum\"),\n-            Token::Usize(4),\n+            Token::U32(4),\n             Token::Unit,\n         ],\n         Error::Message(\"invalid value: integer `4`, expected variant index 0 <= i < 4\".into()),\ndiff --git a/testing/tests/test_ser.rs b/testing/tests/test_ser.rs\nindex 4d8e0f0e8..852c57001 100644\n--- a/testing/tests/test_ser.rs\n+++ b/testing/tests/test_ser.rs\n@@ -60,14 +60,12 @@ declare_ser_tests! {\n         false => &[Token::Bool(false)],\n     }\n     test_isizes {\n-        0isize => &[Token::Isize(0)],\n         0i8 => &[Token::I8(0)],\n         0i16 => &[Token::I16(0)],\n         0i32 => &[Token::I32(0)],\n         0i64 => &[Token::I64(0)],\n     }\n     test_usizes {\n-        0usize => &[Token::Usize(0)],\n         0u8 => &[Token::U8(0)],\n         0u16 => &[Token::U16(0)],\n         0u32 => &[Token::U32(0)],\n", "problem_statement": "Remove usize and isize from Serializer, Deserializer, Visitor\nWhy do we need usize and isize as types in our data model? Can we get away with just the specific bit width types? For the most part data formats just treat these as u64 and i64 right?\n", "hints_text": "That would probably be better. Apparently we will never (for reasonable definitions of \"never\") get a `usize` that is bigger than 64 bits\n@oli-obk how would you feel about squeezing this into 0.9?\r\n\r\nOne thing we still need to settle is the convention for deserializing enum variants by index, which currently uses usize. I guess `visit_u32`?", "created_at": "2017-01-25T17:00:47Z"}, {"repo": "serde-rs/serde", "pull_number": 716, "instance_id": "serde-rs__serde-716", "issue_numbers": ["467"], "base_commit": "b9d865d8e7ee61a0578db0301dd3a933af695019", "patch": "diff --git a/serde/Cargo.toml b/serde/Cargo.toml\nindex a57ff9543..175f0c635 100644\n--- a/serde/Cargo.toml\n+++ b/serde/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde\"\n-version = \"0.9.0-rc2\"\n+version = \"0.9.0-rc3\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"A generic serialization/deserialization framework\"\ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex 257893566..734337e95 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -247,7 +247,7 @@ impl<'a, I> Serialize for Iterator<I>\n         };\n         let mut seq = try!(serializer.serialize_seq(size));\n         for e in iter {\n-            try!(seq.serialize_element(e));\n+            try!(seq.serialize_element(&e));\n         }\n         seq.end()\n     }\n@@ -263,7 +263,7 @@ macro_rules! serialize_seq {\n         {\n             let mut seq = try!(serializer.serialize_seq(Some(self.len())));\n             for e in self {\n-                try!(seq.serialize_element(e));\n+                try!(seq.serialize_element(&e));\n             }\n             seq.end()\n         }\n@@ -331,7 +331,7 @@ impl<A> Serialize for ops::Range<A>\n     {\n         let mut seq = try!(serializer.serialize_seq(Some(self.len())));\n         for e in self.clone() {\n-            try!(seq.serialize_element(e));\n+            try!(seq.serialize_element(&e));\n         }\n         seq.end()\n     }\n@@ -348,7 +348,7 @@ impl<A> Serialize for ops::RangeInclusive<A>\n     {\n         let mut seq = try!(serializer.serialize_seq(Some(self.len())));\n         for e in self.clone() {\n-            try!(seq.serialize_element(e));\n+            try!(seq.serialize_element(&e));\n         }\n         seq.end()\n     }\n@@ -696,8 +696,8 @@ impl Serialize for Duration {\n     {\n         use super::SerializeStruct;\n         let mut state = try!(serializer.serialize_struct(\"Duration\", 2));\n-        try!(state.serialize_field(\"secs\", self.as_secs()));\n-        try!(state.serialize_field(\"nanos\", self.subsec_nanos()));\n+        try!(state.serialize_field(\"secs\", &self.as_secs()));\n+        try!(state.serialize_field(\"nanos\", &self.subsec_nanos()));\n         state.end()\n     }\n }\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 4131f0b2b..f755579dd 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -200,30 +200,30 @@ pub trait Serializer {\n     /// struct, to be more efficiently serialized than a tuple struct with\n     /// multiple items. A reasonable implementation would be to forward to\n     /// `serialize_tuple_struct` or to just serialize the inner value without wrapping.\n-    fn serialize_newtype_struct<T: Serialize>(\n+    fn serialize_newtype_struct<T: ?Sized + Serialize>(\n         self,\n         name: &'static str,\n-        value: T,\n+        value: &T,\n     ) -> Result<Self::Ok, Self::Error>;\n \n     /// Allows a variant with a single item to be more efficiently serialized\n     /// than a variant with multiple items. A reasonable implementation would be\n     /// to forward to `serialize_tuple_variant`.\n-    fn serialize_newtype_variant<T: Serialize>(\n+    fn serialize_newtype_variant<T: ?Sized + Serialize>(\n         self,\n         name: &'static str,\n         variant_index: usize,\n         variant: &'static str,\n-        value: T,\n+        value: &T,\n     ) -> Result<Self::Ok, Self::Error>;\n \n     /// Serializes a `None` value.\n     fn serialize_none(self) -> Result<Self::Ok, Self::Error>;\n \n     /// Serializes a `Some(...)` value.\n-    fn serialize_some<T: Serialize>(\n+    fn serialize_some<T: ?Sized + Serialize>(\n         self,\n-        value: T,\n+        value: &T,\n     ) -> Result<Self::Ok, Self::Error>;\n \n     /// Begins to serialize a sequence. This call must be followed by zero or\n@@ -311,7 +311,7 @@ pub trait SerializeSeq {\n     type Error: Error;\n \n     /// Serializes a sequence element.\n-    fn serialize_element<T: Serialize>(&mut self, value: T) -> Result<(), Self::Error>;\n+    fn serialize_element<T: ?Sized + Serialize>(&mut self, value: &T) -> Result<(), Self::Error>;\n \n     /// Finishes serializing a sequence.\n     fn end(self) -> Result<Self::Ok, Self::Error>;\n@@ -327,7 +327,7 @@ pub trait SerializeTuple {\n     type Error: Error;\n \n     /// Serializes a tuple element.\n-    fn serialize_element<T: Serialize>(&mut self, value: T) -> Result<(), Self::Error>;\n+    fn serialize_element<T: ?Sized + Serialize>(&mut self, value: &T) -> Result<(), Self::Error>;\n \n     /// Finishes serializing a tuple.\n     fn end(self) -> Result<Self::Ok, Self::Error>;\n@@ -343,7 +343,7 @@ pub trait SerializeTupleStruct {\n     type Error: Error;\n \n     /// Serializes a tuple struct element.\n-    fn serialize_field<T: Serialize>(&mut self, value: T) -> Result<(), Self::Error>;\n+    fn serialize_field<T: ?Sized + Serialize>(&mut self, value: &T) -> Result<(), Self::Error>;\n \n     /// Finishes serializing a tuple struct.\n     fn end(self) -> Result<Self::Ok, Self::Error>;\n@@ -359,7 +359,7 @@ pub trait SerializeTupleVariant {\n     type Error: Error;\n \n     /// Serializes a tuple variant element.\n-    fn serialize_field<T: Serialize>(&mut self, value: T) -> Result<(), Self::Error>;\n+    fn serialize_field<T: ?Sized + Serialize>(&mut self, value: &T) -> Result<(), Self::Error>;\n \n     /// Finishes serializing a tuple variant.\n     fn end(self) -> Result<Self::Ok, Self::Error>;\n@@ -375,10 +375,10 @@ pub trait SerializeMap {\n     type Error: Error;\n \n     /// Serialize a map key.\n-    fn serialize_key<T: Serialize>(&mut self, key: T) -> Result<(), Self::Error>;\n+    fn serialize_key<T: ?Sized + Serialize>(&mut self, key: &T) -> Result<(), Self::Error>;\n \n     /// Serialize a map value.\n-    fn serialize_value<T: Serialize>(&mut self, value: T) -> Result<(), Self::Error>;\n+    fn serialize_value<T: ?Sized + Serialize>(&mut self, value: &T) -> Result<(), Self::Error>;\n \n     /// Finishes serializing a map.\n     fn end(self) -> Result<Self::Ok, Self::Error>;\n@@ -394,7 +394,7 @@ pub trait SerializeStruct {\n     type Error: Error;\n \n     /// Serializes a struct field.\n-    fn serialize_field<V: Serialize>(&mut self, key: &'static str, value: V) -> Result<(), Self::Error>;\n+    fn serialize_field<T: ?Sized + Serialize>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>;\n \n     /// Finishes serializing a struct.\n     fn end(self) -> Result<Self::Ok, Self::Error>;\n@@ -410,7 +410,7 @@ pub trait SerializeStructVariant {\n     type Error: Error;\n \n     /// Serialize a struct variant element.\n-    fn serialize_field<V: Serialize>(&mut self, key: &'static str, value: V) -> Result<(), Self::Error>;\n+    fn serialize_field<T: ?Sized + Serialize>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error>;\n \n     /// Finishes serializing a struct variant.\n     fn end(self) -> Result<Self::Ok, Self::Error>;\ndiff --git a/serde_codegen/Cargo.toml b/serde_codegen/Cargo.toml\nindex 6161e373e..a8e5a5414 100644\n--- a/serde_codegen/Cargo.toml\n+++ b/serde_codegen/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_codegen\"\n-version = \"0.9.0-rc2\"\n+version = \"0.9.0-rc3\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"Macros to auto-generate implementations for the serde framework\"\ndiff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex ae3a6c7fa..c8efe1afa 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -548,7 +548,7 @@ fn wrap_serialize_with(\n             }\n         }\n \n-        __SerializeWith {\n+        &__SerializeWith {\n             value: #value,\n             phantom: ::std::marker::PhantomData::<#item_ty>,\n         }\ndiff --git a/serde_derive/Cargo.toml b/serde_derive/Cargo.toml\nindex ddc3f62f8..3b3171cb6 100644\n--- a/serde_derive/Cargo.toml\n+++ b/serde_derive/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_derive\"\n-version = \"0.9.0-rc2\"\n+version = \"0.9.0-rc3\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"Macros 1.1 implementation of #[derive(Serialize, Deserialize)]\"\n@@ -15,7 +15,7 @@ name = \"serde_derive\"\n proc-macro = true\n \n [dependencies.serde_codegen]\n-version = \"=0.9.0-rc2\"\n+version = \"=0.9.0-rc3\"\n path = \"../serde_codegen\"\n default-features = false\n features = [\"with-syn\"]\n@@ -23,5 +23,5 @@ features = [\"with-syn\"]\n [dev-dependencies]\n compiletest_rs = \"^0.2.0\"\n fnv = \"1.0\"\n-serde = { version = \"0.9.0-rc2\", path = \"../serde\" }\n-serde_test = { version = \"0.9.0-rc2\", path = \"../serde_test\" }\n+serde = { version = \"0.9.0-rc3\", path = \"../serde\" }\n+serde_test = { version = \"0.9.0-rc3\", path = \"../serde_test\" }\n", "test_patch": "diff --git a/serde_derive/no-std-tests/Cargo.toml b/serde_derive/no-std-tests/Cargo.toml\nindex 432a962c7..ec5de0a34 100644\n--- a/serde_derive/no-std-tests/Cargo.toml\n+++ b/serde_derive/no-std-tests/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_derive_tests_no_std\"\n-version = \"0.9.0-rc2\"\n+version = \"0.9.0-rc3\"\n publish = false\n \n [dependencies]\ndiff --git a/serde_test/Cargo.toml b/serde_test/Cargo.toml\nindex b4ea1c74e..cee7fe169 100644\n--- a/serde_test/Cargo.toml\n+++ b/serde_test/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_test\"\n-version = \"0.9.0-rc2\"\n+version = \"0.9.0-rc3\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"Token De/Serializer for testing De/Serialize implementations\"\n@@ -12,4 +12,4 @@ keywords = [\"serde\", \"serialization\"]\n include = [\"Cargo.toml\", \"src/**/*.rs\"]\n \n [dependencies]\n-serde = { version = \"0.9.0-rc2\", path = \"../serde\" }\n+serde = { version = \"0.9.0-rc3\", path = \"../serde\" }\ndiff --git a/serde_test/src/ser.rs b/serde_test/src/ser.rs\nindex 60c501254..c97de428e 100644\n--- a/serde_test/src/ser.rs\n+++ b/serde_test/src/ser.rs\n@@ -139,20 +139,20 @@ impl<'s, 'a, I> ser::Serializer for &'s mut Serializer<'a, I>\n         Ok(())\n     }\n \n-    fn serialize_newtype_struct<T>(self,\n-                                   name: &'static str,\n-                                   value: T) -> Result<(), Error>\n+    fn serialize_newtype_struct<T: ?Sized>(self,\n+                                           name: &'static str,\n+                                           value: &T) -> Result<(), Error>\n         where T: Serialize,\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::StructNewType(name)));\n         value.serialize(self)\n     }\n \n-    fn serialize_newtype_variant<T>(self,\n-                                    name: &str,\n-                                    _variant_index: usize,\n-                                    variant: &str,\n-                                    value: T) -> Result<(), Error>\n+    fn serialize_newtype_variant<T: ?Sized>(self,\n+                                            name: &str,\n+                                            _variant_index: usize,\n+                                            variant: &str,\n+                                            value: &T) -> Result<(), Error>\n         where T: Serialize,\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::EnumNewType(name, variant)));\n@@ -164,8 +164,8 @@ impl<'s, 'a, I> ser::Serializer for &'s mut Serializer<'a, I>\n         Ok(())\n     }\n \n-    fn serialize_some<V>(self, value: V) -> Result<(), Error>\n-        where V: Serialize,\n+    fn serialize_some<T: ?Sized>(self, value: &T) -> Result<(), Error>\n+        where T: Serialize,\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::Option(true)));\n         value.serialize(self)\n@@ -228,7 +228,7 @@ impl<'s, 'a, I> ser::SerializeSeq for &'s mut Serializer<'a, I>\n     type Ok = ();\n     type Error = Error;\n \n-    fn serialize_element<T>(&mut self, value: T) -> Result<(), Error>\n+    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n         where T: Serialize\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::SeqSep));\n@@ -247,7 +247,7 @@ impl<'s, 'a, I> ser::SerializeTuple for &'s mut Serializer<'a, I>\n     type Ok = ();\n     type Error = Error;\n \n-    fn serialize_element<T>(&mut self, value: T) -> Result<(), Error>\n+    fn serialize_element<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n         where T: Serialize\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::TupleSep));\n@@ -266,7 +266,7 @@ impl<'s, 'a, I> ser::SerializeTupleStruct for &'s mut Serializer<'a, I>\n     type Ok = ();\n     type Error = Error;\n \n-    fn serialize_field<T>(&mut self, value: T) -> Result<(), Error>\n+    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n         where T: Serialize\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::TupleStructSep));\n@@ -285,7 +285,7 @@ impl<'s, 'a, I> ser::SerializeTupleVariant for &'s mut Serializer<'a, I>\n     type Ok = ();\n     type Error = Error;\n \n-    fn serialize_field<T>(&mut self, value: T) -> Result<(), Error>\n+    fn serialize_field<T: ?Sized>(&mut self, value: &T) -> Result<(), Error>\n         where T: Serialize\n     {\n         assert_eq!(self.tokens.next(), Some(&Token::EnumSeqSep));\n@@ -304,12 +304,12 @@ impl<'s, 'a, I> ser::SerializeMap for &'s mut Serializer<'a, I>\n     type Ok = ();\n     type Error = Error;\n \n-    fn serialize_key<T>(&mut self, key: T) -> Result<(), Self::Error> where T: Serialize {\n+    fn serialize_key<T: ?Sized>(&mut self, key: &T) -> Result<(), Self::Error> where T: Serialize {\n         assert_eq!(self.tokens.next(), Some(&Token::MapSep));\n         key.serialize(&mut **self)\n     }\n \n-    fn serialize_value<T>(&mut self, value: T) -> Result<(), Self::Error> where T: Serialize {\n+    fn serialize_value<T: ?Sized>(&mut self, value: &T) -> Result<(), Self::Error> where T: Serialize {\n         value.serialize(&mut **self)\n     }\n \n@@ -325,7 +325,7 @@ impl<'s, 'a, I> ser::SerializeStruct for &'s mut Serializer<'a, I>\n     type Ok = ();\n     type Error = Error;\n \n-    fn serialize_field<V>(&mut self, key: &'static str, value: V) -> Result<(), Self::Error> where V: Serialize {\n+    fn serialize_field<T: ?Sized>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error> where T: Serialize {\n         assert_eq!(self.tokens.next(), Some(&Token::StructSep));\n         try!(key.serialize(&mut **self));\n         value.serialize(&mut **self)\n@@ -343,7 +343,7 @@ impl<'s, 'a, I> ser::SerializeStructVariant for &'s mut Serializer<'a, I>\n     type Ok = ();\n     type Error = Error;\n \n-    fn serialize_field<V>(&mut self, key: &'static str, value: V) -> Result<(), Self::Error> where V: Serialize {\n+    fn serialize_field<T: ?Sized>(&mut self, key: &'static str, value: &T) -> Result<(), Self::Error> where T: Serialize {\n         assert_eq!(self.tokens.next(), Some(&Token::EnumMapSep));\n         try!(key.serialize(&mut **self));\n         value.serialize(&mut **self)\ndiff --git a/testing/Cargo.toml b/testing/Cargo.toml\nindex b592a2143..9088a779b 100644\n--- a/testing/Cargo.toml\n+++ b/testing/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_testing\"\n-version = \"0.9.0-rc2\"\n+version = \"0.9.0-rc3\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"A generic serialization/deserialization framework\"\n", "problem_statement": "Serializer methods with `T: Serialize` arguments would make more sense as `&T`\nFrom @sfackler in IRC:\n\n> the signatures of methods implies things about how they're expected to be used. If a method takes something by value, I'm going to assume it needs ownership of the value, and I can only find that the \"normal\" intent is to pass by reference if I find that forwarding implementation buried in the pile of 100 or however many there are in rustdoc\n\n(the forwarding implementation is `impl<'a, T: ?Sized> Serialize for &'a T where T: Serialize`)\n\n", "hints_text": "This was the response in IRC:\r\n\r\n> **\\<erickt>** It possibly takes things by value because it'll let you potentially serialize some value without a copy\r\n> **\\<sfackler>** ah that makes sense\r\n\r\n@erickt do you have an example of this? Serialize::serialize is defined on &self so I'm not sure where it would avoid a copy.\r\n\nThe same question applies to `serde_json::to_*`, for example [`to_writer`](https://docs.serde.rs/serde_json/ser/fn.to_writer.html). Those currently take &T which is inconsistent with the Serializer methods taking T.\n\nIt would only make sense for serializing to `json::Value` or similar types. It's probably not worth the effort, but strictly more powerful for the future. My slight preference is thus to move everything to by val.\nI have tried to implement #571 with a wrapper type, but it's not possible without some `RefCell<Option<T>>` dance, because to iterate over an iterator, you need mutable access to the iterator. If we moved `Serialize::serialize` to take `self` by value and suggest that users implement it for `&'a TheirType` then we could do it without any `RefCell` code.\r\n\r\nI'll try other workarounds, maybe this is unnecessary, it seems inelegant to me.\nThe backend has moved to by value. So now this is mainly a question of how the helper functions of specific serializers expose it.\nWe still need to evaluate these methods:\r\n\r\n- `Serializer::serialize_newtype_struct`\r\n- `Serializer::serialize_newtype_variant`\r\n- `Serializer::serialize_some`\r\n- `SerializeSeq::serialize_element`\r\n- `SerializeTuple::serialize_element`\r\n- `SerializeTupleStruct::serialize_field`\r\n- `SerializeTupleVariant::serialize_field`\r\n- `SerializeMap::serialize_key`\r\n- `SerializeMap::serialize_value`\r\n- `SerializeStruct::serialize_field`\r\n- `SerializeStructVariant::serialize_field`\r\n\r\nAll of those currently take T by value which is inconsistent with Serialize taking Self by reference. I think I am still in favor of updating it all to be &T.\nGah, neither solution is obviously better. I don't think we should spend more time on this. The current approach is decent and consistent enough.\nIf we are not moving to changing `Serialize::serialize` to take the argument by value, we should move all functions to by ref and remove the impl for references.\r\n\r\nThe only advantage of moving to values is wrapper helpers not requiring any runtime checks.", "created_at": "2017-01-24T00:53:01Z"}, {"repo": "serde-rs/serde", "pull_number": 715, "instance_id": "serde-rs__serde-715", "issue_numbers": ["666"], "base_commit": "a982d275369f3c8949026f7d3b540ca9f1cae6ba", "patch": "diff --git a/.travis.yml b/.travis.yml\nindex 729796b5b..ea9e7fe83 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -18,6 +18,7 @@ script:\n - (cd testing && travis-cargo --skip nightly test)\n - (cd testing && travis-cargo --only nightly test -- --features unstable-testing)\n - (cd serde_derive && travis-cargo --only nightly test)\n+- (cd serde_derive/no-std-tests && travis-cargo --only nightly build)\n #- (cd examples/serde-syntex-example && travis-cargo --skip nightly run)\n #- (cd examples/serde-syntex-example && travis-cargo --only nightly run -- --no-default-features --features unstable)\n - (cd serde && travis-cargo --only stable doc)\ndiff --git a/serde/src/export.rs b/serde/src/export.rs\nnew file mode 100644\nindex 000000000..61c9ba67c\n--- /dev/null\n+++ b/serde/src/export.rs\n@@ -0,0 +1,33 @@\n+#[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n+use collections::String;\n+\n+#[cfg(feature = \"std\")]\n+use std::borrow::Cow;\n+#[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n+use collections::borrow::Cow;\n+\n+pub use core::default::Default;\n+pub use core::fmt;\n+pub use core::marker::PhantomData;\n+pub use core::result::Result;\n+\n+#[cfg(any(feature = \"collections\", feature = \"std\"))]\n+pub fn from_utf8_lossy(bytes: &[u8]) -> Cow<str> {\n+    String::from_utf8_lossy(bytes)\n+}\n+\n+// The generated code calls this like:\n+//\n+//     let value = &_serde::export::from_utf8_lossy(bytes);\n+//     Err(_serde::de::Error::unknown_variant(value, VARIANTS))\n+//\n+// so it is okay for the return type to be different from the std case as long\n+// as the above works.\n+#[cfg(not(any(feature = \"collections\", feature = \"std\")))]\n+pub fn from_utf8_lossy(bytes: &[u8]) -> &str {\n+    use core::str;\n+    // Three unicode replacement characters if it fails. They look like a\n+    // white-on-black question mark. The user will recognize it as invalid\n+    // UTF-8.\n+    str::from_utf8(bytes).unwrap_or(\"\\u{fffd}\\u{fffd}\\u{fffd}\")\n+}\ndiff --git a/serde/src/lib.rs b/serde/src/lib.rs\nindex 093fa2860..77a04932d 100644\n--- a/serde/src/lib.rs\n+++ b/serde/src/lib.rs\n@@ -31,7 +31,7 @@ extern crate core as actual_core;\n #[cfg(feature = \"std\")]\n mod core {\n     pub use std::{ops, hash, fmt, cmp, marker, mem, i8, i16, i32, i64, u8, u16, u32, u64, isize,\n-            usize, f32, f64, char, str, num, slice, iter, cell};\n+            usize, f32, f64, char, str, num, slice, iter, cell, default, result};\n     #[cfg(feature = \"unstable\")]\n     pub use actual_core::nonzero;\n }\n@@ -50,3 +50,7 @@ pub mod ser;\n #[cfg_attr(feature = \"std\", doc(hidden))]\n pub mod error;\n mod utils;\n+\n+// Generated code uses these to support no_std. Not public API.\n+#[doc(hidden)]\n+pub mod export;\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex eda81859b..65f4905c6 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -36,7 +36,7 @@ pub fn expand_derive_deserialize(item: &syn::MacroInput) -> Result<Tokens, Strin\n             extern crate serde as _serde;\n             #[automatically_derived]\n             impl #impl_generics _serde::Deserialize for #ty #where_clause {\n-                fn deserialize<__D>(deserializer: __D) -> ::std::result::Result<#ty, __D::Error>\n+                fn deserialize<__D>(deserializer: __D) -> _serde::export::Result<#ty, __D::Error>\n                     where __D: _serde::Deserializer\n                 #body\n             }\n@@ -158,11 +158,11 @@ fn deserialize_visitor(generics: &syn::Generics) -> (Tokens, Tokens, Tokens) {\n         let phantom_types = generics.lifetimes.iter()\n             .map(|lifetime_def| {\n                 let lifetime = &lifetime_def.lifetime;\n-                quote!(::std::marker::PhantomData<& #lifetime ()>)\n+                quote!(_serde::export::PhantomData<& #lifetime ()>)\n             }).chain(generics.ty_params.iter()\n                 .map(|ty_param| {\n                     let ident = &ty_param.ident;\n-                    quote!(::std::marker::PhantomData<#ident>)\n+                    quote!(_serde::export::PhantomData<#ident>)\n                 }));\n \n         let all_params = generics.lifetimes.iter()\n@@ -182,7 +182,7 @@ fn deserialize_visitor(generics: &syn::Generics) -> (Tokens, Tokens, Tokens) {\n             Some(quote!(::<#(#ty_param_idents),*>))\n         };\n \n-        let phantom_exprs = iter::repeat(quote!(::std::marker::PhantomData)).take(num_phantoms);\n+        let phantom_exprs = iter::repeat(quote!(_serde::export::PhantomData)).take(num_phantoms);\n \n         (\n             quote! {\n@@ -208,19 +208,19 @@ fn deserialize_unit_struct(\n         impl _serde::de::Visitor for __Visitor {\n             type Value = #type_ident;\n \n-            fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+            fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n                 formatter.write_str(#expecting)\n             }\n \n             #[inline]\n-            fn visit_unit<__E>(self) -> ::std::result::Result<#type_ident, __E>\n+            fn visit_unit<__E>(self) -> _serde::export::Result<#type_ident, __E>\n                 where __E: _serde::de::Error,\n             {\n                 Ok(#type_ident)\n             }\n \n             #[inline]\n-            fn visit_seq<__V>(self, _: __V) -> ::std::result::Result<#type_ident, __V::Error>\n+            fn visit_seq<__V>(self, _: __V) -> _serde::export::Result<#type_ident, __V::Error>\n                 where __V: _serde::de::SeqVisitor,\n             {\n                 Ok(#type_ident)\n@@ -297,14 +297,14 @@ fn deserialize_tuple(\n         impl #impl_generics _serde::de::Visitor for #visitor_ty #where_clause {\n             type Value = #ty;\n \n-            fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+            fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n                 formatter.write_str(#expecting)\n             }\n \n             #visit_newtype_struct\n \n             #[inline]\n-            fn visit_seq<__V>(self, #visitor_var: __V) -> ::std::result::Result<#ty, __V::Error>\n+            fn visit_seq<__V>(self, #visitor_var: __V) -> _serde::export::Result<#ty, __V::Error>\n                 where __V: _serde::de::SeqVisitor\n             {\n                 #visit_seq\n@@ -408,7 +408,7 @@ fn deserialize_newtype_struct(\n     };\n     quote! {\n         #[inline]\n-        fn visit_newtype_struct<__E>(self, __e: __E) -> ::std::result::Result<Self::Value, __E::Error>\n+        fn visit_newtype_struct<__E>(self, __e: __E) -> _serde::export::Result<Self::Value, __E::Error>\n             where __E: _serde::Deserializer,\n         {\n             Ok(#type_path(#value))\n@@ -480,19 +480,19 @@ fn deserialize_struct(\n         impl #impl_generics _serde::de::Visitor for #visitor_ty #where_clause {\n             type Value = #ty;\n \n-            fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+            fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n                 formatter.write_str(#expecting)\n             }\n \n             #[inline]\n-            fn visit_seq<__V>(self, #visitor_var: __V) -> ::std::result::Result<#ty, __V::Error>\n+            fn visit_seq<__V>(self, #visitor_var: __V) -> _serde::export::Result<#ty, __V::Error>\n                 where __V: _serde::de::SeqVisitor\n             {\n                 #visit_seq\n             }\n \n             #[inline]\n-            fn visit_map<__V>(self, mut visitor: __V) -> ::std::result::Result<#ty, __V::Error>\n+            fn visit_map<__V>(self, mut visitor: __V) -> _serde::export::Result<#ty, __V::Error>\n                 where __V: _serde::de::MapVisitor\n             {\n                 #visit_map\n@@ -585,11 +585,11 @@ fn deserialize_item_enum(\n         impl #impl_generics _serde::de::Visitor for #visitor_ty #where_clause {\n             type Value = #ty;\n \n-            fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+            fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n                 formatter.write_str(#expecting)\n             }\n \n-            fn visit_enum<__V>(self, visitor: __V) -> ::std::result::Result<#ty, __V::Error>\n+            fn visit_enum<__V>(self, visitor: __V) -> _serde::export::Result<#ty, __V::Error>\n                 where __V: _serde::de::EnumVisitor,\n             {\n                 #match_variant\n@@ -696,7 +696,7 @@ fn deserialize_field_visitor(\n         let variant_indices = 0usize..;\n         let fallthrough_msg = format!(\"variant index 0 <= i < {}\", fields.len());\n         Some(quote! {\n-            fn visit_usize<__E>(self, value: usize) -> ::std::result::Result<__Field, __E>\n+            fn visit_usize<__E>(self, value: usize) -> _serde::export::Result<__Field, __E>\n                 where __E: _serde::de::Error\n             {\n                 match value {\n@@ -731,7 +731,7 @@ fn deserialize_field_visitor(\n         Some(quote! {\n             // TODO https://github.com/serde-rs/serde/issues/666\n             // update this to use str::from_utf8(value).unwrap_or(\"\ufffd\ufffd\ufffd\") on no_std\n-            let value = &::std::string::String::from_utf8_lossy(value);\n+            let value = &_serde::export::from_utf8_lossy(value);\n         })\n     } else {\n         None\n@@ -746,7 +746,7 @@ fn deserialize_field_visitor(\n \n         impl _serde::Deserialize for __Field {\n             #[inline]\n-            fn deserialize<__D>(deserializer: __D) -> ::std::result::Result<__Field, __D::Error>\n+            fn deserialize<__D>(deserializer: __D) -> _serde::export::Result<__Field, __D::Error>\n                 where __D: _serde::Deserializer,\n             {\n                 struct __FieldVisitor;\n@@ -754,13 +754,13 @@ fn deserialize_field_visitor(\n                 impl _serde::de::Visitor for __FieldVisitor {\n                     type Value = __Field;\n \n-                    fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+                    fn expecting(&self, formatter: &mut _serde::export::fmt::Formatter) -> _serde::export::fmt::Result {\n                         formatter.write_str(\"field name\")\n                     }\n \n                     #visit_usize\n \n-                    fn visit_str<__E>(self, value: &str) -> ::std::result::Result<__Field, __E>\n+                    fn visit_str<__E>(self, value: &str) -> _serde::export::Result<__Field, __E>\n                         where __E: _serde::de::Error\n                     {\n                         match value {\n@@ -771,7 +771,7 @@ fn deserialize_field_visitor(\n                         }\n                     }\n \n-                    fn visit_bytes<__E>(self, value: &[u8]) -> ::std::result::Result<__Field, __E>\n+                    fn visit_bytes<__E>(self, value: &[u8]) -> _serde::export::Result<__Field, __E>\n                         where __E: _serde::de::Error\n                     {\n                         match value {\n@@ -981,18 +981,18 @@ fn wrap_deserialize_with(\n         quote! {\n             struct __SerdeDeserializeWithStruct #impl_generics #where_clause {\n                 value: #field_ty,\n-                phantom: ::std::marker::PhantomData<#phantom_ty>,\n+                phantom: _serde::export::PhantomData<#phantom_ty>,\n             }\n         },\n         quote! {\n             impl #impl_generics _serde::Deserialize for #wrapper_ty #where_clause {\n-                fn deserialize<__D>(__d: __D) -> ::std::result::Result<Self, __D::Error>\n+                fn deserialize<__D>(__d: __D) -> _serde::export::Result<Self, __D::Error>\n                     where __D: _serde::Deserializer\n                 {\n                     let value = try!(#deserialize_with(__d));\n                     Ok(__SerdeDeserializeWithStruct {\n                         value: value,\n-                        phantom: ::std::marker::PhantomData,\n+                        phantom: _serde::export::PhantomData,\n                     })\n                 }\n             }\n@@ -1004,7 +1004,7 @@ fn wrap_deserialize_with(\n fn expr_is_missing(attrs: &attr::Field) -> Tokens {\n     match *attrs.default() {\n         attr::FieldDefault::Default => {\n-            return quote!(::std::default::Default::default());\n+            return quote!(_serde::export::Default::default());\n         }\n         attr::FieldDefault::Path(ref path) => {\n             return quote!(#path());\ndiff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex 3374d5acf..ae3a6c7fa 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -30,7 +30,7 @@ pub fn expand_derive_serialize(item: &syn::MacroInput) -> Result<Tokens, String>\n             extern crate serde as _serde;\n             #[automatically_derived]\n             impl #impl_generics _serde::Serialize for #ty #where_clause {\n-                fn serialize<__S>(&self, _serializer: __S) -> ::std::result::Result<__S::Ok, __S::Error>\n+                fn serialize<__S>(&self, _serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n                     where __S: _serde::Serializer\n                 {\n                     #body\n@@ -541,7 +541,7 @@ fn wrap_serialize_with(\n         }\n \n         impl #wrapper_generics _serde::Serialize for #wrapper_ty #where_clause {\n-            fn serialize<__S>(&self, __s: __S) -> ::std::result::Result<__S::Ok, __S::Error>\n+            fn serialize<__S>(&self, __s: __S) -> _serde::export::Result<__S::Ok, __S::Error>\n                 where __S: _serde::Serializer\n             {\n                 #path(self.value, __s)\n", "test_patch": "diff --git a/serde_derive/no-std-tests/Cargo.toml b/serde_derive/no-std-tests/Cargo.toml\nnew file mode 100644\nindex 000000000..432a962c7\n--- /dev/null\n+++ b/serde_derive/no-std-tests/Cargo.toml\n@@ -0,0 +1,8 @@\n+[package]\n+name = \"serde_derive_tests_no_std\"\n+version = \"0.9.0-rc2\"\n+publish = false\n+\n+[dependencies]\n+serde = { path = \"../../serde\", default-features = false }\n+serde_derive = { path = \"..\" }\ndiff --git a/serde_derive/no-std-tests/src/main.rs b/serde_derive/no-std-tests/src/main.rs\nnew file mode 100644\nindex 000000000..5eae52672\n--- /dev/null\n+++ b/serde_derive/no-std-tests/src/main.rs\n@@ -0,0 +1,50 @@\n+#![feature(lang_items, start, libc)]\n+#![no_std]\n+\n+extern crate libc;\n+\n+#[start]\n+fn start(_argc: isize, _argv: *const *const u8) -> isize {\n+    0\n+}\n+\n+#[lang = \"eh_personality\"]\n+#[no_mangle]\n+pub extern fn rust_eh_personality() {}\n+\n+#[lang = \"eh_unwind_resume\"]\n+#[no_mangle]\n+pub extern fn rust_eh_unwind_resume() {}\n+\n+#[lang = \"panic_fmt\"]\n+#[no_mangle]\n+pub extern fn rust_begin_panic(_msg: core::fmt::Arguments,\n+                               _file: &'static str,\n+                               _line: u32) -> ! {\n+    loop {}\n+}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+\n+#[macro_use]\n+extern crate serde_derive;\n+\n+#[derive(Serialize, Deserialize)]\n+struct Unit;\n+\n+#[derive(Serialize, Deserialize)]\n+struct Newtype(u8);\n+\n+#[derive(Serialize, Deserialize)]\n+struct Tuple(u8, u8);\n+\n+#[derive(Serialize, Deserialize)]\n+struct Struct { f: u8 }\n+\n+#[derive(Serialize, Deserialize)]\n+enum Enum {\n+    Unit,\n+    Newtype(u8),\n+    Tuple(u8, u8),\n+    Struct { f: u8 },\n+}\n", "problem_statement": "Use serde_derive with no_std\n```rust\r\n#![no_std]\r\n\r\n#[macro_use]\r\nextern crate serde_derive;\r\n\r\n#[derive(Serialize, Deserialize)]\r\nstruct S;\r\n```\r\n\r\n```\r\nerror[E0433]: failed to resolve. Maybe a missing `extern crate std;`?\r\n --> src/lib.rs:6:21\r\n  |\r\n6 | #[derive(Serialize, Deserialize)]\r\n  |                     ^^^^^^^^^^^ Maybe a missing `extern crate std;`?\r\n\r\nerror[E0433]: failed to resolve. Maybe a missing `extern crate std;`?\r\n --> src/lib.rs:6:21\r\n  |\r\n6 | #[derive(Serialize, Deserialize)]\r\n  |                     ^^^^^^^^^^^ Maybe a missing `extern crate std;`?\r\n\r\nerror[E0433]: failed to resolve. Maybe a missing `extern crate std;`?\r\n --> src/lib.rs:6:21\r\n  |\r\n6 | #[derive(Serialize, Deserialize)]\r\n  |                     ^^^^^^^^^^^ Maybe a missing `extern crate std;`?\r\n\r\nerror[E0433]: failed to resolve. Maybe a missing `extern crate std;`?\r\n --> src/lib.rs:6:10\r\n  |\r\n6 | #[derive(Serialize, Deserialize)]\r\n  |          ^^^^^^^^^ Maybe a missing `extern crate std;`?\r\n\r\nerror: aborting due to 4 previous errors\r\n```\r\n\r\nThe culprit is `::std::result::Result`. We can get around it by reexporting Result as serde::Result and generating code against that.\n", "hints_text": "This line is the only thing causing trouble: [`serde_codegen/src/de.rs#L729`](https://github.com/serde-rs/serde/blob/v0.8.21/serde_codegen/src/de.rs#L729)\nI filed https://github.com/serde-rs/serde/issues/667 to eliminate the obstacle.\nA hack of a workaround:\r\n\r\n```rust\r\nmod std {\r\n    pub use core::*;\r\n    pub mod string {\r\n        pub struct String;\r\n        impl String {\r\n            pub fn from_utf8_lossy(_value: &[u8]) -> &'static str {\r\n                \"\"\r\n            }\r\n        }\r\n    }\r\n}\r\n```", "created_at": "2017-01-24T00:04:38Z"}, {"repo": "serde-rs/serde", "pull_number": 710, "instance_id": "serde-rs__serde-710", "issue_numbers": ["528", "702"], "base_commit": "530c29466e53995508b6980f496231ea2d212799", "patch": "diff --git a/serde/Cargo.toml b/serde/Cargo.toml\nindex ef3dd26d7..a57ff9543 100644\n--- a/serde/Cargo.toml\n+++ b/serde/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde\"\n-version = \"0.9.0-rc1\"\n+version = \"0.9.0-rc2\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"A generic serialization/deserialization framework\"\ndiff --git a/serde/src/bytes.rs b/serde/src/bytes.rs\nindex 8402b4bd1..10e95eb8d 100644\n--- a/serde/src/bytes.rs\n+++ b/serde/src/bytes.rs\n@@ -181,6 +181,10 @@ mod bytebuf {\n     impl de::Visitor for ByteBufVisitor {\n         type Value = ByteBuf;\n \n+        fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+            formatter.write_str(\"byte array\")\n+        }\n+\n         #[inline]\n         fn visit_unit<E>(self) -> Result<ByteBuf, E>\n             where E: de::Error,\ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex ea17afd25..9c12a6e2c 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -32,6 +32,7 @@ use collections::enum_set::{CLike, EnumSet};\n #[cfg(all(feature = \"unstable\", feature = \"collections\"))]\n use collections::borrow::ToOwned;\n \n+use core::fmt;\n use core::hash::{Hash, BuildHasher};\n use core::marker::PhantomData;\n #[cfg(feature = \"std\")]\n@@ -69,7 +70,7 @@ use de::{\n     Error,\n     MapVisitor,\n     SeqVisitor,\n-    Type,\n+    Unexpected,\n     VariantVisitor,\n     Visitor,\n };\n@@ -83,6 +84,10 @@ pub struct UnitVisitor;\n impl Visitor for UnitVisitor {\n     type Value = ();\n \n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        formatter.write_str(\"unit\")\n+    }\n+\n     fn visit_unit<E>(self) -> Result<(), E>\n         where E: Error,\n     {\n@@ -112,6 +117,10 @@ pub struct BoolVisitor;\n impl Visitor for BoolVisitor {\n     type Value = bool;\n \n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        formatter.write_str(\"a boolean\")\n+    }\n+\n     fn visit_bool<E>(self, v: bool) -> Result<bool, E>\n         where E: Error,\n     {\n@@ -124,7 +133,7 @@ impl Visitor for BoolVisitor {\n         match s.trim_matches(::utils::Pattern_White_Space) {\n             \"true\" => Ok(true),\n             \"false\" => Ok(false),\n-            _ => Err(Error::invalid_type(Type::Bool)),\n+            _ => Err(Error::invalid_type(Unexpected::Str(s), &self)),\n         }\n     }\n }\n@@ -140,70 +149,59 @@ impl Deserialize for bool {\n ///////////////////////////////////////////////////////////////////////////////\n \n macro_rules! impl_deserialize_num_method {\n-    ($src_ty:ty, $method:ident, $from_method:ident, $ty:expr) => {\n+    ($ty:ident, $src_ty:ident, $method:ident, $from_method:ident, $group:ident, $group_ty:ident) => {\n         #[inline]\n-        fn $method<E>(self, v: $src_ty) -> Result<T, E>\n+        fn $method<E>(self, v: $src_ty) -> Result<$ty, E>\n             where E: Error,\n         {\n             match FromPrimitive::$from_method(v) {\n                 Some(v) => Ok(v),\n-                None => Err(Error::invalid_type($ty)),\n+                None => Err(Error::invalid_value(Unexpected::$group(v as $group_ty), &self)),\n             }\n         }\n     }\n }\n \n-/// A visitor that produces a primitive type.\n-struct PrimitiveVisitor<T> {\n-    marker: PhantomData<T>,\n-}\n-\n-impl<T> PrimitiveVisitor<T> {\n-    /// Construct a new `PrimitiveVisitor`.\n-    #[inline]\n-    fn new() -> Self {\n-        PrimitiveVisitor {\n-            marker: PhantomData,\n-        }\n-    }\n-}\n-\n-impl<T> Visitor for PrimitiveVisitor<T>\n-    where T: Deserialize + FromPrimitive + str::FromStr\n-{\n-    type Value = T;\n-\n-    impl_deserialize_num_method!(isize, visit_isize, from_isize, Type::Isize);\n-    impl_deserialize_num_method!(i8, visit_i8, from_i8, Type::I8);\n-    impl_deserialize_num_method!(i16, visit_i16, from_i16, Type::I16);\n-    impl_deserialize_num_method!(i32, visit_i32, from_i32, Type::I32);\n-    impl_deserialize_num_method!(i64, visit_i64, from_i64, Type::I64);\n-    impl_deserialize_num_method!(usize, visit_usize, from_usize, Type::Usize);\n-    impl_deserialize_num_method!(u8, visit_u8, from_u8, Type::U8);\n-    impl_deserialize_num_method!(u16, visit_u16, from_u16, Type::U16);\n-    impl_deserialize_num_method!(u32, visit_u32, from_u32, Type::U32);\n-    impl_deserialize_num_method!(u64, visit_u64, from_u64, Type::U64);\n-    impl_deserialize_num_method!(f32, visit_f32, from_f32, Type::F32);\n-    impl_deserialize_num_method!(f64, visit_f64, from_f64, Type::F64);\n-\n-    #[inline]\n-    fn visit_str<E>(self, s: &str) -> Result<T, E>\n-        where E: Error,\n-    {\n-        str::FromStr::from_str(s.trim_matches(::utils::Pattern_White_Space)).or_else(|_| {\n-            Err(Error::invalid_type(Type::Str))\n-        })\n-    }\n-}\n-\n macro_rules! impl_deserialize_num {\n-    ($ty:ty, $method:ident) => {\n+    ($ty:ident, $method:ident) => {\n         impl Deserialize for $ty {\n             #[inline]\n             fn deserialize<D>(deserializer: D) -> Result<$ty, D::Error>\n                 where D: Deserializer,\n             {\n-                deserializer.$method(PrimitiveVisitor::new())\n+                struct PrimitiveVisitor;\n+\n+                impl Visitor for PrimitiveVisitor {\n+                    type Value = $ty;\n+\n+                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                        formatter.write_str(stringify!($ty))\n+                    }\n+\n+                    impl_deserialize_num_method!($ty, isize, visit_isize, from_isize, Signed, i64);\n+                    impl_deserialize_num_method!($ty, i8, visit_i8, from_i8, Signed, i64);\n+                    impl_deserialize_num_method!($ty, i16, visit_i16, from_i16, Signed, i64);\n+                    impl_deserialize_num_method!($ty, i32, visit_i32, from_i32, Signed, i64);\n+                    impl_deserialize_num_method!($ty, i64, visit_i64, from_i64, Signed, i64);\n+                    impl_deserialize_num_method!($ty, usize, visit_usize, from_usize, Unsigned, u64);\n+                    impl_deserialize_num_method!($ty, u8, visit_u8, from_u8, Unsigned, u64);\n+                    impl_deserialize_num_method!($ty, u16, visit_u16, from_u16, Unsigned, u64);\n+                    impl_deserialize_num_method!($ty, u32, visit_u32, from_u32, Unsigned, u64);\n+                    impl_deserialize_num_method!($ty, u64, visit_u64, from_u64, Unsigned, u64);\n+                    impl_deserialize_num_method!($ty, f32, visit_f32, from_f32, Float, f64);\n+                    impl_deserialize_num_method!($ty, f64, visit_f64, from_f64, Float, f64);\n+\n+                    #[inline]\n+                    fn visit_str<E>(self, s: &str) -> Result<$ty, E>\n+                        where E: Error,\n+                    {\n+                        str::FromStr::from_str(s.trim_matches(::utils::Pattern_White_Space)).or_else(|_| {\n+                            Err(Error::invalid_type(Unexpected::Str(s), &self))\n+                        })\n+                    }\n+                }\n+\n+                deserializer.$method(PrimitiveVisitor)\n             }\n         }\n     }\n@@ -229,6 +227,10 @@ struct CharVisitor;\n impl Visitor for CharVisitor {\n     type Value = char;\n \n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        formatter.write_str(\"a character\")\n+    }\n+\n     #[inline]\n     fn visit_char<E>(self, v: char) -> Result<char, E>\n         where E: Error,\n@@ -241,14 +243,9 @@ impl Visitor for CharVisitor {\n         where E: Error,\n     {\n         let mut iter = v.chars();\n-        if let Some(v) = iter.next() {\n-            if iter.next().is_some() {\n-                Err(Error::invalid_type(Type::Char))\n-            } else {\n-                Ok(v)\n-            }\n-        } else {\n-            Err(Error::end_of_stream())\n+        match (iter.next(), iter.next()) {\n+            (Some(c), None) => Ok(c),\n+            _ => Err(Error::invalid_value(Unexpected::Str(v), &self)),\n         }\n     }\n }\n@@ -271,6 +268,10 @@ struct StringVisitor;\n impl Visitor for StringVisitor {\n     type Value = String;\n \n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        formatter.write_str(\"a string\")\n+    }\n+\n     fn visit_str<E>(self, v: &str) -> Result<String, E>\n         where E: Error,\n     {\n@@ -294,7 +295,7 @@ impl Visitor for StringVisitor {\n     {\n         match str::from_utf8(v) {\n             Ok(s) => Ok(s.to_owned()),\n-            Err(_) => Err(Error::invalid_type(Type::String)),\n+            Err(_) => Err(Error::invalid_value(Unexpected::Bytes(v), &self)),\n         }\n     }\n \n@@ -303,7 +304,7 @@ impl Visitor for StringVisitor {\n     {\n         match String::from_utf8(v) {\n             Ok(s) => Ok(s),\n-            Err(_) => Err(Error::invalid_type(Type::String)),\n+            Err(e) => Err(Error::invalid_value(Unexpected::Bytes(&e.into_bytes()), &self)),\n         }\n     }\n }\n@@ -328,6 +329,10 @@ impl<\n > Visitor for OptionVisitor<T> {\n     type Value = Option<T>;\n \n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        formatter.write_str(\"option\")\n+    }\n+\n     #[inline]\n     fn visit_unit<E>(self) -> Result<Option<T>, E>\n         where E: Error,\n@@ -368,6 +373,10 @@ pub struct PhantomDataVisitor<T> {\n impl<T> Visitor for PhantomDataVisitor<T> {\n     type Value = PhantomData<T>;\n \n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        formatter.write_str(\"unit\")\n+    }\n+\n     #[inline]\n     fn visit_unit<E>(self) -> Result<PhantomData<T>, E>\n         where E: Error,\n@@ -417,6 +426,10 @@ macro_rules! seq_impl {\n         {\n             type Value = $ty;\n \n+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                formatter.write_str(\"a sequence\")\n+            }\n+\n             #[inline]\n             fn visit_unit<E>(self) -> Result<$ty, E>\n                 where E: Error,\n@@ -531,6 +544,10 @@ impl<A> ArrayVisitor<A> {\n impl<T> Visitor for ArrayVisitor<[T; 0]> where T: Deserialize {\n     type Value = [T; 0];\n \n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        formatter.write_str(\"an empty array\")\n+    }\n+\n     #[inline]\n     fn visit_unit<E>(self) -> Result<[T; 0], E>\n         where E: Error,\n@@ -562,6 +579,10 @@ macro_rules! array_impls {\n             impl<T> Visitor for ArrayVisitor<[T; $len]> where T: Deserialize {\n                 type Value = [T; $len];\n \n+                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                    formatter.write_str(concat!(\"an array of length \", $len))\n+                }\n+\n                 #[inline]\n                 fn visit_seq<V>(self, mut visitor: V) -> Result<[T; $len], V::Error>\n                     where V: SeqVisitor,\n@@ -569,7 +590,7 @@ macro_rules! array_impls {\n                     $(\n                         let $name = match try!(visitor.visit()) {\n                             Some(val) => val,\n-                            None => return Err(Error::end_of_stream()),\n+                            None => return Err(Error::invalid_length(0, &self)),\n                         };\n                     )+\n \n@@ -645,6 +666,10 @@ macro_rules! tuple_impls {\n             impl<$($name: Deserialize),+> Visitor for $visitor<$($name,)+> {\n                 type Value = ($($name,)+);\n \n+                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                    formatter.write_str(concat!(\"a tuple of size \", $len))\n+                }\n+\n                 #[inline]\n                 #[allow(non_snake_case)]\n                 fn visit_seq<V>(self, mut visitor: V) -> Result<($($name,)+), V::Error>\n@@ -653,7 +678,7 @@ macro_rules! tuple_impls {\n                     $(\n                         let $name = match try!(visitor.visit()) {\n                             Some(value) => value,\n-                            None => return Err(Error::end_of_stream()),\n+                            None => return Err(Error::invalid_length(0, &self)),\n                         };\n                     )+\n \n@@ -723,6 +748,10 @@ macro_rules! map_impl {\n         {\n             type Value = $ty;\n \n+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                formatter.write_str(\"a map\")\n+            }\n+\n             #[inline]\n             fn visit_unit<E>(self) -> Result<$ty, E>\n                 where E: Error,\n@@ -785,7 +814,7 @@ impl Deserialize for net::IpAddr {\n         let s = try!(String::deserialize(deserializer));\n         match s.parse() {\n             Ok(s) => Ok(s),\n-            Err(err) => Err(D::Error::invalid_value(&err.to_string())),\n+            Err(err) => Err(D::Error::custom(err)),\n         }\n     }\n }\n@@ -798,7 +827,7 @@ impl Deserialize for net::Ipv4Addr {\n         let s = try!(String::deserialize(deserializer));\n         match s.parse() {\n             Ok(s) => Ok(s),\n-            Err(err) => Err(D::Error::invalid_value(&err.to_string())),\n+            Err(err) => Err(D::Error::custom(err)),\n         }\n     }\n }\n@@ -811,7 +840,7 @@ impl Deserialize for net::Ipv6Addr {\n         let s = try!(String::deserialize(deserializer));\n         match s.parse() {\n             Ok(s) => Ok(s),\n-            Err(err) => Err(D::Error::invalid_value(&err.to_string())),\n+            Err(err) => Err(D::Error::custom(err)),\n         }\n     }\n }\n@@ -826,7 +855,7 @@ impl Deserialize for net::SocketAddr {\n         let s = try!(String::deserialize(deserializer));\n         match s.parse() {\n             Ok(s) => Ok(s),\n-            Err(err) => Err(D::Error::invalid_value(&err.to_string())),\n+            Err(err) => Err(D::Error::custom(err)),\n         }\n     }\n }\n@@ -839,7 +868,7 @@ impl Deserialize for net::SocketAddrV4 {\n         let s = try!(String::deserialize(deserializer));\n         match s.parse() {\n             Ok(s) => Ok(s),\n-            Err(err) => Err(D::Error::invalid_value(&err.to_string())),\n+            Err(err) => Err(D::Error::custom(err)),\n         }\n     }\n }\n@@ -852,7 +881,7 @@ impl Deserialize for net::SocketAddrV6 {\n         let s = try!(String::deserialize(deserializer));\n         match s.parse() {\n             Ok(s) => Ok(s),\n-            Err(err) => Err(D::Error::invalid_value(&err.to_string())),\n+            Err(err) => Err(D::Error::custom(err)),\n         }\n     }\n }\n@@ -866,6 +895,10 @@ struct PathBufVisitor;\n impl Visitor for PathBufVisitor {\n     type Value = path::PathBuf;\n \n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        formatter.write_str(\"path string\")\n+    }\n+\n     fn visit_str<E>(self, v: &str) -> Result<path::PathBuf, E>\n         where E: Error,\n     {\n@@ -875,7 +908,7 @@ impl Visitor for PathBufVisitor {\n     fn visit_string<E>(self, v: String) -> Result<path::PathBuf, E>\n         where E: Error,\n     {\n-        self.visit_str(&v)\n+        Ok(From::from(v))\n     }\n }\n \n@@ -977,13 +1010,17 @@ impl Deserialize for Duration {\n                 impl Visitor for FieldVisitor {\n                     type Value = Field;\n \n+                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                        formatter.write_str(\"`secs` or `nanos`\")\n+                    }\n+\n                     fn visit_usize<E>(self, value: usize) -> Result<Field, E>\n                         where E: Error,\n                     {\n                         match value {\n                             0usize => Ok(Field::Secs),\n                             1usize => Ok(Field::Nanos),\n-                            _ => Err(Error::invalid_value(\"expected a field\")),\n+                            _ => Err(Error::invalid_value(Unexpected::Unsigned(value as u64), &self)),\n                         }\n                     }\n \n@@ -993,7 +1030,7 @@ impl Deserialize for Duration {\n                         match value {\n                             \"secs\" => Ok(Field::Secs),\n                             \"nanos\" => Ok(Field::Nanos),\n-                            _ => Err(Error::unknown_field(value)),\n+                            _ => Err(Error::unknown_field(value, FIELDS)),\n                         }\n                     }\n \n@@ -1005,7 +1042,7 @@ impl Deserialize for Duration {\n                             b\"nanos\" => Ok(Field::Nanos),\n                             _ => {\n                                 let value = String::from_utf8_lossy(value);\n-                                Err(Error::unknown_field(&value))\n+                                Err(Error::unknown_field(&value, FIELDS))\n                             }\n                         }\n                     }\n@@ -1020,19 +1057,23 @@ impl Deserialize for Duration {\n         impl Visitor for DurationVisitor {\n             type Value = Duration;\n \n+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                formatter.write_str(\"struct Duration\")\n+            }\n+\n             fn visit_seq<V>(self, mut visitor: V) -> Result<Duration, V::Error>\n                 where V: SeqVisitor,\n             {\n                 let secs: u64 = match try!(visitor.visit()) {\n                     Some(value) => value,\n                     None => {\n-                        return Err(Error::invalid_length(0));\n+                        return Err(Error::invalid_length(0, &self));\n                     }\n                 };\n                 let nanos: u32 = match try!(visitor.visit()) {\n                     Some(value) => value,\n                     None => {\n-                        return Err(Error::invalid_length(1));\n+                        return Err(Error::invalid_length(1, &self));\n                     }\n                 };\n                 Ok(Duration::new(secs, nanos))\n@@ -1061,11 +1102,11 @@ impl Deserialize for Duration {\n                 }\n                 let secs = match secs {\n                     Some(secs) => secs,\n-                    None => try!(visitor.missing_field(\"secs\")),\n+                    None => return Err(<V::Error as Error>::missing_field(\"secs\")),\n                 };\n                 let nanos = match nanos {\n                     Some(nanos) => nanos,\n-                    None => try!(visitor.missing_field(\"nanos\")),\n+                    None => return Err(<V::Error as Error>::missing_field(\"nanos\")),\n                 };\n                 Ok(Duration::new(secs, nanos))\n             }\n@@ -1083,7 +1124,7 @@ impl<T> Deserialize for NonZero<T> where T: Deserialize + PartialEq + Zeroable +\n     fn deserialize<D>(deserializer: D) -> Result<NonZero<T>, D::Error> where D: Deserializer {\n         let value = try!(Deserialize::deserialize(deserializer));\n         if value == Zero::zero() {\n-            return Err(Error::invalid_value(\"expected a non-zero value\"))\n+            return Err(Error::custom(\"expected a non-zero value\"))\n         }\n         unsafe {\n             Ok(NonZero::new(value))\n@@ -1112,23 +1153,15 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n                 impl Visitor for FieldVisitor {\n                     type Value = Field;\n \n-                    #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-                    fn visit_usize<E>(self, value: usize) -> Result<Field, E> where E: Error {\n-                        #[cfg(feature = \"collections\")]\n-                        use collections::string::ToString;\n-                        match value {\n-                            0 => Ok(Field::Ok),\n-                            1 => Ok(Field::Err),\n-                            _ => Err(Error::unknown_field(&value.to_string())),\n-                        }\n+                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                        formatter.write_str(\"`Ok` or `Err`\")\n                     }\n \n-                    #[cfg(all(not(feature = \"std\"), not(feature = \"collections\")))]\n                     fn visit_usize<E>(self, value: usize) -> Result<Field, E> where E: Error {\n                         match value {\n                             0 => Ok(Field::Ok),\n                             1 => Ok(Field::Err),\n-                            _ => Err(Error::unknown_field(\"some number\")),\n+                            _ => Err(Error::invalid_value(Unexpected::Unsigned(value as u64), &self)),\n                         }\n                     }\n \n@@ -1136,7 +1169,7 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n                         match value {\n                             \"Ok\" => Ok(Field::Ok),\n                             \"Err\" => Ok(Field::Err),\n-                            _ => Err(Error::unknown_field(value)),\n+                            _ => Err(Error::unknown_variant(value, VARIANTS)),\n                         }\n                     }\n \n@@ -1146,8 +1179,8 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n                             b\"Err\" => Ok(Field::Err),\n                             _ => {\n                                 match str::from_utf8(value) {\n-                                    Ok(value) => Err(Error::unknown_field(value)),\n-                                    Err(_) => Err(Error::invalid_type(Type::String)),\n+                                    Ok(value) => Err(Error::unknown_variant(value, VARIANTS)),\n+                                    Err(_) => Err(Error::invalid_value(Unexpected::Bytes(value), &self)),\n                                 }\n                             }\n                         }\n@@ -1166,6 +1199,10 @@ impl<T, E> Deserialize for Result<T, E> where T: Deserialize, E: Deserialize {\n         {\n             type Value = Result<T, E>;\n \n+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                formatter.write_str(\"enum Result\")\n+            }\n+\n             fn visit_enum<V>(self, visitor: V) -> Result<Result<T, E>, V::Error>\n                 where V: EnumVisitor\n             {\n@@ -1198,6 +1235,10 @@ impl Deserialize for IgnoredAny {\n         impl Visitor for IgnoredAnyVisitor {\n             type Value = IgnoredAny;\n \n+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                formatter.write_str(\"anything at all\")\n+            }\n+\n             #[inline]\n             fn visit_bool<E>(self, _: bool) -> Result<IgnoredAny, E> {\n                 Ok(IgnoredAny)\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 57616bcb0..967af3504 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -8,7 +8,7 @@ use error;\n #[cfg(all(not(feature = \"std\"), feature = \"collections\"))]\n use collections::{String, Vec};\n \n-use core::fmt;\n+use core::fmt::{self, Display};\n use core::marker::PhantomData;\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -17,208 +17,352 @@ pub mod impls;\n pub mod value;\n mod from_primitive;\n \n+// Helpers used by generated code. Not public API.\n+#[doc(hidden)]\n+pub mod private;\n+\n ///////////////////////////////////////////////////////////////////////////////\n \n-/// `Error` is a trait that allows a `Deserialize` to generically create a\n-/// `Deserializer` error.\n+/// The `Error` trait allows `Deserialize` implementations to create descriptive\n+/// error messages belonging to the `Deserializer` against which they are\n+/// currently running.\n+///\n+/// Every `Deserializer` declares an `Error` type that encompasses both\n+/// general-purpose deserialization errors as well as errors specific to the\n+/// particular deserialization format. For example the `Error` type of\n+/// `serde_json` can represent errors like an invalid JSON escape sequence or an\n+/// unterminated string literal, in addition to the error cases that are part of\n+/// this trait.\n+///\n+/// Most deserializers should only need to provide the `Error::custom` method\n+/// and inherit the default behavior for the other methods.\n pub trait Error: Sized + error::Error {\n     /// Raised when there is general error when deserializing a type.\n-    #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-    fn custom<T: Into<String>>(msg: T) -> Self;\n-\n-    /// Raised when there is general error when deserializing a type.\n-    #[cfg(all(not(feature = \"std\"), not(feature = \"collections\")))]\n-    fn custom<T: Into<&'static str>>(msg: T) -> Self;\n-\n-    /// Raised when a `Deserialize` type unexpectedly hit the end of the stream.\n-    fn end_of_stream() -> Self;\n+    fn custom<T: Display>(msg: T) -> Self;\n \n-    /// Raised when a `Deserialize` was passed an incorrect type.\n-    fn invalid_type(ty: Type) -> Self {\n-        Error::custom(format!(\"Invalid type. Expected `{:?}`\", ty))\n+    /// Raised when a `Deserialize` receives a type different from what it was\n+    /// expecting.\n+    ///\n+    /// The `unexp` argument provides information about what type was received.\n+    /// This is the type that was present in the input file or other source data\n+    /// of the Deserializer.\n+    ///\n+    /// The `exp` argument provides information about what type was being\n+    /// expected. This is the type that is written in the program.\n+    ///\n+    /// For example if we try to deserialize a String out of a JSON file\n+    /// containing an integer, the unexpected type is the integer and the\n+    /// expected type is the string.\n+    fn invalid_type(unexp: Unexpected, exp: &Expected) -> Self {\n+        struct InvalidType<'a> {\n+            unexp: Unexpected<'a>,\n+            exp: &'a Expected,\n+        }\n+        impl<'a> Display for InvalidType<'a> {\n+            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                write!(formatter, \"invalid type: {}, expected {}\", self.unexp, self.exp)\n+            }\n+        }\n+        Error::custom(InvalidType { unexp: unexp, exp: exp })\n     }\n \n-    /// Raised when a `Deserialize` was passed an incorrect value.\n-    fn invalid_value(msg: &str) -> Self {\n-        Error::custom(format!(\"Invalid value: {}\", msg))\n+    /// Raised when a `Deserialize` receives a value of the right type but that\n+    /// is wrong for some other reason.\n+    ///\n+    /// The `unexp` argument provides information about what value was received.\n+    /// This is the value that was present in the input file or other source\n+    /// data of the Deserializer.\n+    ///\n+    /// The `exp` argument provides information about what value was being\n+    /// expected. This is the type that is written in the program.\n+    ///\n+    /// For example if we try to deserialize a String out of some binary data\n+    /// that is not valid UTF-8, the unexpected value is the bytes and the\n+    /// expected value is a string.\n+    fn invalid_value(unexp: Unexpected, exp: &Expected) -> Self {\n+        struct InvalidValue<'a> {\n+            unexp: Unexpected<'a>,\n+            exp: &'a Expected,\n+        }\n+        impl<'a> Display for InvalidValue<'a> {\n+            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                write!(formatter, \"invalid value: {}, expected {}\", self.unexp, self.exp)\n+            }\n+        }\n+        Error::custom(InvalidValue { unexp: unexp, exp: exp })\n     }\n \n-    /// Raised when a fixed sized sequence or map was passed in the wrong amount of arguments.\n+    /// Raised when deserializing a sequence or map and the input data contains\n+    /// too many or too few elements.\n     ///\n-    /// The parameter `len` is the number of arguments found in the serialization. The sequence\n-    /// may either expect more arguments or less arguments.\n-    fn invalid_length(len: usize) -> Self {\n-        Error::custom(format!(\"Invalid length: {}\", len))\n+    /// The `len` argument is the number of elements encountered. The sequence\n+    /// or map may have expected more arguments or fewer arguments.\n+    ///\n+    /// The `exp` argument provides information about what data was being\n+    /// expected. For example `exp` might say that a tuple of size 6 was\n+    /// expected.\n+    fn invalid_length(len: usize, exp: &Expected) -> Self {\n+        struct InvalidLength<'a> {\n+            len: usize,\n+            exp: &'a Expected,\n+        }\n+        impl<'a> Display for InvalidLength<'a> {\n+            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                write!(formatter, \"invalid length {}, expected {}\", self.len, self.exp)\n+            }\n+        }\n+        Error::custom(InvalidLength { len: len, exp: exp })\n     }\n \n-    /// Raised when a `Deserialize` enum type received an unexpected variant.\n-    fn unknown_variant(field: &str) -> Self {\n-        Error::custom(format!(\"Unknown variant `{}`\", field))\n+    /// Raised when a `Deserialize` enum type received a variant with an\n+    /// unrecognized name.\n+    fn unknown_variant(variant: &str, expected: &'static [&'static str]) -> Self {\n+        struct UnknownVariant<'a> {\n+            variant: &'a str,\n+            expected: &'static [&'static str],\n+        }\n+        impl<'a> Display for UnknownVariant<'a> {\n+            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                if self.expected.is_empty() {\n+                    write!(formatter,\n+                           \"unknown variant `{}`, there are no variants\",\n+                           self.variant)\n+                } else {\n+                    write!(formatter,\n+                           \"unknown variant `{}`, expected {}\",\n+                           self.variant,\n+                           OneOf { names: self.expected })\n+                }\n+            }\n+        }\n+        Error::custom(UnknownVariant { variant: variant, expected: expected })\n     }\n \n-    /// Raised when a `Deserialize` struct type received an unexpected struct field.\n-    fn unknown_field(field: &str) -> Self {\n-        Error::custom(format!(\"Unknown field `{}`\", field))\n+    /// Raised when a `Deserialize` struct type received a field with an\n+    /// unrecognized name.\n+    fn unknown_field(field: &str, expected: &'static [&'static str]) -> Self {\n+        struct UnknownField<'a> {\n+            field: &'a str,\n+            expected: &'static [&'static str],\n+        }\n+        impl<'a> Display for UnknownField<'a> {\n+            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                if self.expected.is_empty() {\n+                    write!(formatter,\n+                           \"unknown field `{}`, there are no fields\",\n+                           self.field)\n+                } else {\n+                    write!(formatter,\n+                           \"unknown field `{}`, expected {}\",\n+                           self.field,\n+                           OneOf { names: self.expected })\n+                }\n+            }\n+        }\n+        Error::custom(UnknownField { field: field, expected: expected })\n     }\n \n-    /// raised when a `deserialize` struct type did not receive a field.\n+    /// Raised when a `Deserialize` struct type expected to receive a required\n+    /// field with a particular name but that field was not present in the\n+    /// input.\n     fn missing_field(field: &'static str) -> Self {\n-        Error::custom(format!(\"Missing field `{}`\", field))\n+        struct MissingField {\n+            field: &'static str,\n+        }\n+        impl Display for MissingField {\n+            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                write!(formatter, \"missing field `{}`\", self.field)\n+            }\n+        }\n+        Error::custom(MissingField { field: field })\n     }\n \n     /// Raised when a `Deserialize` struct type received more than one of the\n-    /// same struct field.\n+    /// same field.\n     fn duplicate_field(field: &'static str) -> Self {\n-        Error::custom(format!(\"Duplicate field `{}`\", field))\n+        struct DuplicateField {\n+            field: &'static str,\n+        }\n+        impl Display for DuplicateField {\n+            fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                write!(formatter, \"duplicate field `{}`\", self.field)\n+            }\n+        }\n+        Error::custom(DuplicateField { field: field })\n     }\n }\n \n-/// `Type` represents all the primitive types that can be deserialized. This is used by\n-/// `Error::invalid_type`.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum Type {\n-    /// Represents a `bool` type.\n-    Bool,\n-\n-    /// Represents a `usize` type.\n-    Usize,\n-\n-    /// Represents a `u8` type.\n-    U8,\n-\n-    /// Represents a `u16` type.\n-    U16,\n-\n-    /// Represents a `u32` type.\n-    U32,\n-\n-    /// Represents a `u64` type.\n-    U64,\n-\n-    /// Represents a `isize` type.\n-    Isize,\n-\n-    /// Represents a `i8` type.\n-    I8,\n-\n-    /// Represents a `i16` type.\n-    I16,\n-\n-    /// Represents a `i32` type.\n-    I32,\n+/// `Unexpected` represents an unexpected invocation of any one of the `Visitor`\n+/// trait methods.\n+///\n+/// This is used as an argument to the `invalid_type`, `invalid_value`, and\n+/// `invalid_length` methods of the `Error` trait to build error messages.\n+///\n+/// ```rust\n+/// # use serde::de::{Error, Unexpected, Visitor};\n+/// # use std::fmt;\n+/// # struct Example;\n+/// # impl Visitor for Example {\n+/// # type Value = ();\n+/// fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n+///     where E: Error\n+/// {\n+///     Err(Error::invalid_type(Unexpected::Bool(v), &self))\n+/// }\n+/// # fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+/// #     write!(formatter, \"definitely not a boolean\")\n+/// # }\n+/// # }\n+/// ```\n+#[derive(Clone, PartialEq, Debug)]\n+pub enum Unexpected<'a> {\n+    /// The input contained a boolean value that was not expected.\n+    Bool(bool),\n \n-    /// Represents a `i64` type.\n-    I64,\n+    /// The input contained an unsigned integer `usize`, `u8`, `u16`, `u32` or\n+    /// `u64` that was not expected.\n+    Unsigned(u64),\n \n-    /// Represents a `f32` type.\n-    F32,\n+    /// The input contained a signed integer `isize`, `i8`, `i16`, `i32` or\n+    /// `i64` that was not expected.\n+    Signed(i64),\n \n-    /// Represents a `f64` type.\n-    F64,\n+    /// The input contained a floating point `f32` or `f64` that was not\n+    /// expected.\n+    Float(f64),\n \n-    /// Represents a `char` type.\n-    Char,\n+    /// The input contained a `char` that was not expected.\n+    Char(char),\n \n-    /// Represents a `&str` type.\n-    Str,\n+    /// The input contained a `&str` or `String` that was not expected.\n+    Str(&'a str),\n \n-    /// Represents a `String` type.\n-    String,\n+    /// The input contained a `&[u8]` or `Vec<u8>` that was not expected.\n+    Bytes(&'a [u8]),\n \n-    /// Represents a `()` type.\n+    /// The input contained a unit `()` that was not expected.\n     Unit,\n \n-    /// Represents an `Option<T>` type.\n+    /// The input contained an `Option<T>` that was not expected.\n     Option,\n \n-    /// Represents a sequence type.\n-    Seq,\n-\n-    /// Represents a map type.\n-    Map,\n-\n-    /// Represents a unit struct type.\n-    UnitStruct,\n-\n-    /// Represents a newtype type.\n+    /// The input contained a newtype struct that was not expected.\n     NewtypeStruct,\n \n-    /// Represents a tuple struct type.\n-    TupleStruct,\n+    /// The input contained a sequence that was not expected.\n+    Seq,\n \n-    /// Represents a struct type.\n-    Struct,\n+    /// The input contained a map that was not expected.\n+    Map,\n \n-    /// Represents a struct field name.\n-    FieldName,\n+    /// The input contained an enum that was not expected.\n+    Enum,\n \n-    /// Represents a tuple type.\n-    Tuple,\n+    /// The input contained a unit variant that was not expected.\n+    UnitVariant,\n \n-    /// Represents an `enum` type.\n-    Enum,\n+    /// The input contained a newtype variant that was not expected.\n+    NewtypeVariant,\n \n-    /// Represents an enum variant name.\n-    VariantName,\n+    /// The input contained a tuple variant that was not expected.\n+    TupleVariant,\n \n-    /// Represents a struct variant.\n+    /// The input contained a struct variant that was not expected.\n     StructVariant,\n \n-    /// Represents a tuple variant.\n-    TupleVariant,\n+    /// A message stating what uncategorized thing the input contained that was\n+    /// not expected.\n+    ///\n+    /// The message should be a noun or noun phrase, not capitalized and without\n+    /// a period. An example message is \"unoriginal superhero\".\n+    Other(&'a str),\n+}\n \n-    /// Represents a unit variant.\n-    UnitVariant,\n+impl<'a> fmt::Display for Unexpected<'a> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        use self::Unexpected::*;\n+        match *self {\n+            Bool(b) => write!(formatter, \"boolean `{}`\", b),\n+            Unsigned(i) => write!(formatter, \"integer `{}`\", i),\n+            Signed(i) => write!(formatter, \"integer `{}`\", i),\n+            Float(f) => write!(formatter, \"floating point `{}`\", f),\n+            Char(c) => write!(formatter, \"character `{}`\", c),\n+            Str(s) => write!(formatter, \"string {:?}\", s),\n+            Bytes(_) => write!(formatter, \"byte array\"),\n+            Unit => write!(formatter, \"unit value\"),\n+            Option => write!(formatter, \"Option value\"),\n+            NewtypeStruct => write!(formatter, \"newtype struct\"),\n+            Seq => write!(formatter, \"sequence\"),\n+            Map => write!(formatter, \"map\"),\n+            Enum => write!(formatter, \"enum\"),\n+            UnitVariant => write!(formatter, \"unit variant\"),\n+            NewtypeVariant => write!(formatter, \"newtype variant\"),\n+            TupleVariant => write!(formatter, \"tuple variant\"),\n+            StructVariant => write!(formatter, \"struct variant\"),\n+            Other(other) => formatter.write_str(other),\n+        }\n+    }\n+}\n \n-    /// Represents a newtype variant.\n-    NewtypeVariant,\n+/// `Expected` represents an explanation of what data a `Visitor` was expecting\n+/// to receive.\n+///\n+/// This is used as an argument to the `invalid_type`, `invalid_value`, and\n+/// `invalid_length` methods of the `Error` trait to build error messages. The\n+/// message should complete the sentence \"This Visitor expects to receive ...\",\n+/// for example the message could be \"an integer between 0 and 64\". The message\n+/// should not be capitalized and should not end with a period.\n+///\n+/// Within the context of a `Visitor` implementation, the `Visitor` itself\n+/// (`&self`) is an implementation of this trait.\n+///\n+/// ```rust\n+/// # use serde::de::{Error, Unexpected, Visitor};\n+/// # use std::fmt;\n+/// # struct Example;\n+/// # impl Visitor for Example {\n+/// # type Value = ();\n+/// fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n+///     where E: Error\n+/// {\n+///     Err(Error::invalid_type(Unexpected::Bool(v), &self))\n+/// }\n+/// # fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+/// #     write!(formatter, \"definitely not a boolean\")\n+/// # }\n+/// # }\n+/// ```\n+///\n+/// Outside of a `Visitor`, `&\"...\"` can be used.\n+///\n+/// ```rust\n+/// # use serde::de::{Error, Unexpected};\n+/// # fn example<E: Error>() -> Result<(), E> {\n+/// # let v = true;\n+/// return Err(Error::invalid_type(Unexpected::Bool(v), &\"a negative integer\"));\n+/// # }\n+/// ```\n+pub trait Expected {\n+    /// Format an explanation of what data was being expected. Same signature as\n+    /// the `Display` and `Debug` traits.\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result;\n+}\n \n-    /// Represents a `&[u8]` type.\n-    Bytes,\n+impl<T> Expected for T where T: Visitor {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        self.expecting(formatter)\n+    }\n+}\n \n-    /// Represents a `Vec<u8>` type.\n-    ByteBuf,\n+impl<'a> Expected for &'a str {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        formatter.write_str(self)\n+    }\n }\n \n-impl fmt::Display for Type {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        let display = match *self {\n-            Type::Bool           => \"bool\",\n-            Type::Usize          => \"usize\",\n-            Type::U8             => \"u8\",\n-            Type::U16            => \"u16\",\n-            Type::U32            => \"u32\",\n-            Type::U64            => \"u64\",\n-            Type::Isize          => \"isize\",\n-            Type::I8             => \"i8\",\n-            Type::I16            => \"i16\",\n-            Type::I32            => \"i32\",\n-            Type::I64            => \"i64\",\n-            Type::F32            => \"f32\",\n-            Type::F64            => \"f64\",\n-            Type::Char           => \"char\",\n-            Type::Str            => \"str\",\n-            Type::String         => \"string\",\n-            Type::Unit           => \"unit\",\n-            Type::Option         => \"option\",\n-            Type::Seq            => \"seq\",\n-            Type::Map            => \"map\",\n-            Type::UnitStruct     => \"unit struct\",\n-            Type::NewtypeStruct  => \"newtype struct\",\n-            Type::TupleStruct    => \"tuple struct\",\n-            Type::Struct         => \"struct\",\n-            Type::FieldName      => \"field name\",\n-            Type::Tuple          => \"tuple\",\n-            Type::Enum           => \"enum\",\n-            Type::VariantName    => \"variant name\",\n-            Type::StructVariant  => \"struct variant\",\n-            Type::TupleVariant   => \"tuple variant\",\n-            Type::UnitVariant    => \"unit variant\",\n-            Type::NewtypeVariant => \"newtype variant\",\n-            Type::Bytes          => \"bytes\",\n-            Type::ByteBuf        => \"bytes buf\",\n-        };\n-        display.fmt(formatter)\n+impl<'a> Display for Expected + 'a {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        Expected::fmt(self, formatter)\n     }\n }\n \n@@ -276,6 +420,7 @@ pub trait Deserialize: Sized {\n ///\n /// ```rust\n /// # use serde::de::{Deserialize, DeserializeSeed, Deserializer, Visitor, SeqVisitor};\n+/// # use std::fmt;\n /// # use std::marker::PhantomData;\n /// #\n /// // A DeserializeSeed implementation that uses stateful deserialization to\n@@ -315,6 +460,10 @@ pub trait Deserialize: Sized {\n ///                 }\n ///                 Ok(())\n ///             }\n+/// #\n+/// #           fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+/// #               write!(formatter, \"an array of integers\")\n+/// #           }\n ///         }\n ///\n ///         deserializer.deserialize_seq(ExtendVecVisitor(self.0))\n@@ -345,6 +494,10 @@ pub trait Deserialize: Sized {\n ///         // Return the finished vec.\n ///         Ok(vec)\n ///     }\n+/// #\n+/// #   fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+/// #       write!(formatter, \"an array of arrays\")\n+/// #   }\n /// }\n ///\n /// # fn example<D: Deserializer>(deserializer: D) -> Result<(), D::Error> {\n@@ -570,16 +723,62 @@ pub trait Deserializer: Sized {\n ///////////////////////////////////////////////////////////////////////////////\n \n /// This trait represents a visitor that walks through a deserializer.\n+///\n+/// ```rust\n+/// # use serde::de::{Error, Unexpected, Visitor};\n+/// # use std::fmt;\n+/// /// A visitor that deserializes a long string - a string containing at least\n+/// /// some minimum number of bytes.\n+/// struct LongString {\n+///     min: usize,\n+/// }\n+///\n+/// impl Visitor for LongString {\n+///     type Value = String;\n+///\n+///     fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+///         write!(formatter, \"a string containing at least {} bytes\", self.min)\n+///     }\n+///\n+///     fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>\n+///         where E: Error\n+///     {\n+///         if s.len() >= self.min {\n+///             Ok(s.to_owned())\n+///         } else {\n+///             Err(Error::invalid_value(Unexpected::Str(s), &self))\n+///         }\n+///     }\n+/// }\n+/// ```\n pub trait Visitor: Sized {\n     /// The value produced by this visitor.\n     type Value;\n \n+    /// Format a message stating what data this Visitor expects to receive.\n+    ///\n+    /// This is used in error messages. The message should complete the sentence\n+    /// \"This Visitor expects to receive ...\", for example the message could be\n+    /// \"an integer between 0 and 64\". The message should not be capitalized and\n+    /// should not end with a period.\n+    ///\n+    /// ```rust\n+    /// # use std::fmt;\n+    /// # struct S { max: usize }\n+    /// # impl serde::de::Visitor for S {\n+    /// # type Value = ();\n+    /// fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+    ///     write!(formatter, \"an integer between 0 and {}\", self.max)\n+    /// }\n+    /// # }\n+    /// ```\n+    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result;\n+\n     /// `visit_bool` deserializes a `bool` into a `Value`.\n     fn visit_bool<E>(self, v: bool) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        let _ = v;\n-        Err(Error::invalid_type(Type::Bool))\n+        Err(Error::invalid_type(Unexpected::Bool(v), &self))\n     }\n \n     /// `visit_isize` deserializes a `isize` into a `Value`.\n@@ -614,8 +813,7 @@ pub trait Visitor: Sized {\n     fn visit_i64<E>(self, v: i64) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        let _ = v;\n-        Err(Error::invalid_type(Type::I64))\n+        Err(Error::invalid_type(Unexpected::Signed(v), &self))\n     }\n \n     /// `visit_usize` deserializes a `usize` into a `Value`.\n@@ -650,8 +848,7 @@ pub trait Visitor: Sized {\n     fn visit_u64<E>(self, v: u64) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        let _ = v;\n-        Err(Error::invalid_type(Type::U64))\n+        Err(Error::invalid_type(Unexpected::Unsigned(v), &self))\n     }\n \n     /// `visit_f32` deserializes a `f32` into a `Value`.\n@@ -665,8 +862,7 @@ pub trait Visitor: Sized {\n     fn visit_f64<E>(self, v: f64) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        let _ = v;\n-        Err(Error::invalid_type(Type::F64))\n+        Err(Error::invalid_type(Unexpected::Float(v), &self))\n     }\n \n     /// `visit_char` deserializes a `char` into a `Value`.\n@@ -681,8 +877,7 @@ pub trait Visitor: Sized {\n     fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        let _ = v;\n-        Err(Error::invalid_type(Type::Str))\n+        Err(Error::invalid_type(Unexpected::Str(v), &self))\n     }\n \n     /// `visit_string` deserializes a `String` into a `Value`.  This allows a deserializer to avoid\n@@ -700,23 +895,14 @@ pub trait Visitor: Sized {\n     fn visit_unit<E>(self) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::invalid_type(Type::Unit))\n-    }\n-\n-    /// `visit_unit_struct` deserializes a unit struct into a `Value`.\n-    #[inline]\n-    fn visit_unit_struct<E>(self, name: &'static str) -> Result<Self::Value, E>\n-        where E: Error,\n-    {\n-        let _ = name;\n-        self.visit_unit()\n+        Err(Error::invalid_type(Unexpected::Unit, &self))\n     }\n \n     /// `visit_none` deserializes a none value into a `Value`.\n     fn visit_none<E>(self) -> Result<Self::Value, E>\n         where E: Error,\n     {\n-        Err(Error::invalid_type(Type::Option))\n+        Err(Error::invalid_type(Unexpected::Option, &self))\n     }\n \n     /// `visit_some` deserializes a value into a `Value`.\n@@ -724,7 +910,7 @@ pub trait Visitor: Sized {\n         where D: Deserializer,\n     {\n         let _ = deserializer;\n-        Err(Error::invalid_type(Type::Option))\n+        Err(Error::invalid_type(Unexpected::Option, &self))\n     }\n \n     /// `visit_newtype_struct` deserializes a value into a `Value`.\n@@ -732,7 +918,7 @@ pub trait Visitor: Sized {\n         where D: Deserializer,\n     {\n         let _ = deserializer;\n-        Err(Error::invalid_type(Type::NewtypeStruct))\n+        Err(Error::invalid_type(Unexpected::NewtypeStruct, &self))\n     }\n \n     /// `visit_seq` deserializes a `SeqVisitor` into a `Value`.\n@@ -740,7 +926,7 @@ pub trait Visitor: Sized {\n         where V: SeqVisitor,\n     {\n         let _ = visitor;\n-        Err(Error::invalid_type(Type::Seq))\n+        Err(Error::invalid_type(Unexpected::Seq, &self))\n     }\n \n     /// `visit_map` deserializes a `MapVisitor` into a `Value`.\n@@ -748,7 +934,7 @@ pub trait Visitor: Sized {\n         where V: MapVisitor,\n     {\n         let _ = visitor;\n-        Err(Error::invalid_type(Type::Map))\n+        Err(Error::invalid_type(Unexpected::Map, &self))\n     }\n \n     /// `visit_enum` deserializes a `EnumVisitor` into a `Value`.\n@@ -756,7 +942,7 @@ pub trait Visitor: Sized {\n         where V: EnumVisitor,\n     {\n         let _ = visitor;\n-        Err(Error::invalid_type(Type::Enum))\n+        Err(Error::invalid_type(Unexpected::Enum, &self))\n     }\n \n     /// `visit_bytes` deserializes a `&[u8]` into a `Value`.\n@@ -764,7 +950,7 @@ pub trait Visitor: Sized {\n         where E: Error,\n     {\n         let _ = v;\n-        Err(Error::invalid_type(Type::Bytes))\n+        Err(Error::invalid_type(Unexpected::Bytes(v), &self))\n     }\n \n     /// `visit_byte_buf` deserializes a `Vec<u8>` into a `Value`.\n@@ -927,31 +1113,6 @@ pub trait MapVisitor {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (0, None)\n     }\n-\n-    /// Report that the struct has a field that wasn't deserialized. The\n-    /// MapVisitor may consider this an error or it may return a default value\n-    /// for the field.\n-    ///\n-    /// `Deserialize` implementations should typically use\n-    /// `MapVisitor::missing_field` instead.\n-    fn missing_field_seed<V>(&mut self, _seed: V, field: &'static str) -> Result<V::Value, Self::Error>\n-        where V: DeserializeSeed\n-    {\n-        Err(Error::missing_field(field))\n-    }\n-\n-    /// Report that the struct has a field that wasn't deserialized. The\n-    /// MapVisitor may consider this an error or it may return a default value\n-    /// for the field.\n-    ///\n-    /// This method exists as a convenience for `Deserialize` implementations.\n-    /// `MapVisitor` implementations should not need to override the default\n-    /// behavior.\n-    fn missing_field<V>(&mut self, field: &'static str) -> Result<V, Self::Error>\n-        where V: Deserialize,\n-    {\n-        self.missing_field_seed(PhantomData, field)\n-    }\n }\n \n impl<'a, V_> MapVisitor for &'a mut V_ where V_: MapVisitor {\n@@ -1005,20 +1166,6 @@ impl<'a, V_> MapVisitor for &'a mut V_ where V_: MapVisitor {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (**self).size_hint()\n     }\n-\n-    #[inline]\n-    fn missing_field_seed<V>(&mut self, seed: V, field: &'static str) -> Result<V::Value, Self::Error>\n-        where V: DeserializeSeed\n-    {\n-        (**self).missing_field_seed(seed, field)\n-    }\n-\n-    #[inline]\n-    fn missing_field<V>(&mut self, field: &'static str) -> Result<V, Self::Error>\n-        where V: Deserialize\n-    {\n-        (**self).missing_field(field)\n-    }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -1100,3 +1247,34 @@ pub trait VariantVisitor: Sized {\n                        visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor;\n }\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/// Used in error messages.\n+///\n+/// - expected `a`\n+/// - expected `a` or `b`\n+/// - expected one of `a`, `b`, `c`\n+struct OneOf {\n+    names: &'static [&'static str],\n+}\n+\n+impl Display for OneOf {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        match self.names.len() {\n+            0 => panic!(), // special case elsewhere\n+            1 => write!(formatter, \"`{}`\", self.names[0]),\n+            2 => write!(formatter, \"`{}` or `{}`\", self.names[0], self.names[1]),\n+            _ => {\n+                try!(write!(formatter, \"one of \"));\n+                for (i, alt) in self.names.iter().enumerate() {\n+                    if i > 0 {\n+                        try!(write!(formatter, \", \"));\n+                    }\n+                    try!(write!(formatter, \"`{}`\", alt));\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+}\ndiff --git a/serde/src/de/private.rs b/serde/src/de/private.rs\nnew file mode 100644\nindex 000000000..92e71cf86\n--- /dev/null\n+++ b/serde/src/de/private.rs\n@@ -0,0 +1,40 @@\n+use core::marker::PhantomData;\n+\n+use de::{Deserialize, Deserializer, Error, Visitor};\n+\n+/// If the missing field is of type `Option<T>` then treat is as `None`,\n+/// otherwise it is an error.\n+pub fn missing_field<V, E>(field: &'static str) -> Result<V, E>\n+    where V: Deserialize,\n+          E: Error\n+{\n+    struct MissingFieldDeserializer<E>(&'static str, PhantomData<E>);\n+\n+    impl<E> Deserializer for MissingFieldDeserializer<E>\n+        where E: Error\n+    {\n+        type Error = E;\n+\n+        fn deserialize<V>(self, _visitor: V) -> Result<V::Value, E>\n+            where V: Visitor\n+        {\n+            Err(Error::missing_field(self.0))\n+        }\n+\n+        fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, E>\n+            where V: Visitor\n+        {\n+            visitor.visit_none()\n+        }\n+\n+        forward_to_deserialize! {\n+            bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str\n+            string unit seq seq_fixed_size bytes byte_buf map unit_struct\n+            newtype_struct tuple_struct struct struct_field tuple enum\n+            ignored_any\n+        }\n+    }\n+\n+    let deserializer = MissingFieldDeserializer(field, PhantomData);\n+    Deserialize::deserialize(deserializer)\n+}\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 9e2bdf76f..f34fb0873 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -28,6 +28,10 @@ use collections::{\n };\n #[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n use collections::borrow::Cow;\n+#[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n+use collections::boxed::Box;\n+#[cfg(all(feature = \"collections\", not(feature = \"std\")))]\n+use collections::string::ToString;\n \n #[cfg(all(feature = \"unstable\", feature = \"collections\"))]\n use collections::borrow::ToOwned;\n@@ -38,112 +42,57 @@ use std::error;\n #[cfg(not(feature = \"std\"))]\n use error;\n \n-use core::fmt;\n+use core::fmt::{self, Display};\n+use core::iter::{self,  Iterator};\n use core::marker::PhantomData;\n \n-use de::{self, SeqVisitor};\n+use de::{self, Expected, SeqVisitor};\n use bytes;\n \n ///////////////////////////////////////////////////////////////////////////////\n \n /// This represents all the possible errors that can occur using the `ValueDeserializer`.\n #[derive(Clone, Debug, PartialEq)]\n-pub enum Error {\n-    /// The value had some custom error.\n-    #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-    Custom(String),\n-    /// The value had some custom error.\n-    #[cfg(all(not(feature = \"std\"), not(feature = \"collections\")))]\n-    Custom(&'static str),\n+pub struct Error(ErrorImpl);\n \n-    /// The value had an incorrect type.\n-    InvalidType(de::Type),\n-\n-    /// The value had an invalid length.\n-    InvalidLength(usize),\n-\n-    /// The value is invalid and cannot be deserialized.\n-    #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-    InvalidValue(String),\n-    /// The value is invalid and cannot be deserialized.\n-    #[cfg(all(not(feature = \"std\"), not(feature = \"collections\")))]\n-    InvalidValue(&'static str),\n-\n-    /// EOF while deserializing a value.\n-    EndOfStream,\n-\n-    /// Unknown variant in enum.\n-    #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-    UnknownVariant(String),\n-    /// Unknown variant in enum.\n-    #[cfg(all(not(feature = \"std\"), not(feature = \"collections\")))]\n-    UnknownVariant(&'static str),\n-\n-    /// Unknown field in struct.\n-    #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-    UnknownField(String),\n-    /// Unknown field in struct.\n-    #[cfg(all(not(feature = \"std\"), not(feature = \"collections\")))]\n-    UnknownField(&'static str),\n-\n-    /// Struct is missing a field.\n-    MissingField(&'static str),\n-}\n+#[cfg(any(feature = \"std\", feature = \"collections\"))]\n+type ErrorImpl = Box<str>;\n+#[cfg(not(any(feature = \"std\", feature = \"collections\")))]\n+type ErrorImpl = ();\n \n impl de::Error for Error {\n     #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-    fn custom<T: Into<String>>(msg: T) -> Self { Error::Custom(msg.into()) }\n-\n-    #[cfg(all(not(feature = \"std\"), not(feature = \"collections\")))]\n-    fn custom<T: Into<&'static str>>(msg: T) -> Self { Error::Custom(msg.into()) }\n-\n-    fn end_of_stream() -> Self { Error::EndOfStream }\n-    fn invalid_type(ty: de::Type) -> Self { Error::InvalidType(ty) }\n-\n-    #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-    fn invalid_value(msg: &str) -> Self { Error::InvalidValue(msg.to_owned()) }\n-\n-    #[cfg(all(not(feature = \"std\"), not(feature = \"collections\")))]\n-    fn invalid_value(msg: &str) -> Self { Error::InvalidValue(\"invalid value\") }\n+    fn custom<T: Display>(msg: T) -> Self {\n+        Error(msg.to_string().into_boxed_str())\n+    }\n \n-    fn invalid_length(len: usize) -> Self { Error::InvalidLength(len) }\n+    #[cfg(not(any(feature = \"std\", feature = \"collections\")))]\n+    fn custom<T: Display>(msg: T) -> Self {\n+        Error(())\n+    }\n+}\n \n+impl Display for Error {\n     #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-    fn unknown_variant(variant: &str) -> Self { Error::UnknownVariant(String::from(variant)) }\n-    #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-    fn unknown_field(field: &str) -> Self { Error::UnknownField(String::from(field)) }\n-\n-    #[cfg(all(not(feature = \"std\"), not(feature = \"collections\")))]\n-    fn unknown_variant(variant: &str) -> Self { Error::UnknownVariant(\"unknown variant\") }\n-    #[cfg(all(not(feature = \"std\"), not(feature = \"collections\")))]\n-    fn unknown_field(field: &str) -> Self { Error::UnknownField(\"unknown field\") }\n-    fn missing_field(field: &'static str) -> Self { Error::MissingField(field) }\n-}\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        formatter.write_str(&self.0)\n+    }\n \n-impl fmt::Display for Error {\n+    #[cfg(not(any(feature = \"std\", feature = \"collections\")))]\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        match *self {\n-            Error::Custom(ref s) => write!(formatter, \"{}\", s),\n-            Error::EndOfStream => formatter.write_str(\"End of stream\"),\n-            Error::InvalidType(ty) => write!(formatter, \"Invalid type, expected `{:?}`\", ty),\n-            Error::InvalidValue(ref value) => write!(formatter, \"Invalid value: {}\", value),\n-            Error::InvalidLength(len) => write!(formatter, \"Invalid length: {}\", len),\n-            Error::UnknownVariant(ref variant) => {\n-                write!(formatter, \"Unknown variant: {}\", variant)\n-            }\n-            Error::UnknownField(ref field) => write!(formatter, \"Unknown field: {}\", field),\n-            Error::MissingField(field) => write!(formatter, \"Missing field: {}\", field),\n-        }\n+        formatter.write_str(\"Serde deserialization error\")\n     }\n }\n \n impl error::Error for Error {\n+    #[cfg(any(feature = \"std\", feature = \"collections\"))]\n     fn description(&self) -> &str {\n-        \"Serde Deserialization Error\"\n+        &self.0\n     }\n \n-    fn cause(&self) -> Option<&error::Error> {\n-        None\n+    #[cfg(not(any(feature = \"std\", feature = \"collections\")))]\n+    fn description(&self) -> &str {\n+        \"Serde deserialization error\"\n     }\n }\n \n@@ -430,22 +379,37 @@ impl<'a, E> de::EnumVisitor for CowStrDeserializer<'a, E>\n \n /// A helper deserializer that deserializes a sequence.\n pub struct SeqDeserializer<I, E> {\n-    iter: I,\n-    len: usize,\n+    iter: iter::Fuse<I>,\n+    count: usize,\n     marker: PhantomData<E>,\n }\n \n impl<I, E> SeqDeserializer<I, E>\n-    where E: de::Error,\n+    where I: Iterator,\n+          E: de::Error,\n {\n     /// Construct a new `SeqDeserializer<I>`.\n-    pub fn new(iter: I, len: usize) -> Self {\n+    pub fn new(iter: I) -> Self {\n         SeqDeserializer {\n-            iter: iter,\n-            len: len,\n+            iter: iter.fuse(),\n+            count: 0,\n             marker: PhantomData,\n         }\n     }\n+\n+    fn end(&mut self) -> Result<(), E> {\n+        let mut remaining = 0;\n+        while self.iter.next().is_some() {\n+            remaining += 1;\n+        }\n+        if remaining == 0 {\n+            Ok(())\n+        } else {\n+            // First argument is the number of elements in the data, second\n+            // argument is the number of elements expected by the Deserialize.\n+            Err(de::Error::invalid_length(self.count + remaining, &ExpectedInSeq(self.count)))\n+        }\n+    }\n }\n \n impl<I, T, E> de::Deserializer for SeqDeserializer<I, E>\n@@ -459,11 +423,8 @@ impl<I, T, E> de::Deserializer for SeqDeserializer<I, E>\n         where V: de::Visitor,\n     {\n         let v = try!(visitor.visit_seq(&mut self));\n-        if self.len == 0 {\n-            Ok(v)\n-        } else {\n-            Err(de::Error::invalid_length(self.len))\n-        }\n+        try!(self.end());\n+        Ok(v)\n     }\n \n     forward_to_deserialize! {\n@@ -485,7 +446,7 @@ impl<I, T, E> de::SeqVisitor for SeqDeserializer<I, E>\n     {\n         match self.iter.next() {\n             Some(value) => {\n-                self.len -= 1;\n+                self.count += 1;\n                 seed.deserialize(value.into_deserializer()).map(Some)\n             }\n             None => Ok(None),\n@@ -493,7 +454,19 @@ impl<I, T, E> de::SeqVisitor for SeqDeserializer<I, E>\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.len, Some(self.len))\n+        self.iter.size_hint()\n+    }\n+}\n+\n+struct ExpectedInSeq(usize);\n+\n+impl Expected for ExpectedInSeq {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        if self.0 == 1 {\n+            write!(formatter, \"1 element in sequence\")\n+        } else {\n+            write!(formatter, \"{} elements in sequence\", self.0)\n+        }\n     }\n }\n \n@@ -507,8 +480,7 @@ impl<T, E> ValueDeserializer<E> for Vec<T>\n     type Deserializer = SeqDeserializer<vec::IntoIter<T>, E>;\n \n     fn into_deserializer(self) -> Self::Deserializer {\n-        let len = self.len();\n-        SeqDeserializer::new(self.into_iter(), len)\n+        SeqDeserializer::new(self.into_iter())\n     }\n }\n \n@@ -520,8 +492,7 @@ impl<T, E> ValueDeserializer<E> for BTreeSet<T>\n     type Deserializer = SeqDeserializer<btree_set::IntoIter<T>, E>;\n \n     fn into_deserializer(self) -> Self::Deserializer {\n-        let len = self.len();\n-        SeqDeserializer::new(self.into_iter(), len)\n+        SeqDeserializer::new(self.into_iter())\n     }\n }\n \n@@ -533,8 +504,7 @@ impl<T, E> ValueDeserializer<E> for HashSet<T>\n     type Deserializer = SeqDeserializer<hash_set::IntoIter<T>, E>;\n \n     fn into_deserializer(self) -> Self::Deserializer {\n-        let len = self.len();\n-        SeqDeserializer::new(self.into_iter(), len)\n+        SeqDeserializer::new(self.into_iter())\n     }\n }\n \n@@ -579,66 +549,66 @@ impl<V_, E> de::Deserializer for SeqVisitorDeserializer<V_, E>\n ///////////////////////////////////////////////////////////////////////////////\n \n /// A helper deserializer that deserializes a map.\n-pub struct MapDeserializer<I, K, V, E>\n-    where I: Iterator<Item=(K, V)>,\n-          K: ValueDeserializer<E>,\n-          V: ValueDeserializer<E>,\n+pub struct MapDeserializer<I, E>\n+    where I: Iterator,\n+          I::Item: private::Pair,\n+          <I::Item as private::Pair>::First: ValueDeserializer<E>,\n+          <I::Item as private::Pair>::Second: ValueDeserializer<E>,\n           E: de::Error,\n {\n-    iter: I,\n-    value: Option<V>,\n-    len: Option<usize>,\n+    iter: iter::Fuse<I>,\n+    value: Option<<I::Item as private::Pair>::Second>,\n+    count: usize,\n     marker: PhantomData<E>,\n }\n \n-impl<I, K, V, E> MapDeserializer<I, K, V, E>\n-    where I: Iterator<Item=(K, V)>,\n-          K: ValueDeserializer<E>,\n-          V: ValueDeserializer<E>,\n+impl<I, E> MapDeserializer<I, E>\n+    where I: Iterator,\n+          I::Item: private::Pair,\n+          <I::Item as private::Pair>::First: ValueDeserializer<E>,\n+          <I::Item as private::Pair>::Second: ValueDeserializer<E>,\n           E: de::Error,\n {\n-    /// Construct a new `MapDeserializer<I, K, V, E>` with a specific length.\n-    pub fn new(iter: I, len: usize) -> Self {\n+    /// Construct a new `MapDeserializer<I, K, V, E>`.\n+    pub fn new(iter: I) -> Self {\n         MapDeserializer {\n-            iter: iter,\n+            iter: iter.fuse(),\n             value: None,\n-            len: Some(len),\n+            count: 0,\n             marker: PhantomData,\n         }\n     }\n \n-    /// Construct a new `MapDeserializer<I, K, V, E>` that is not bounded\n-    /// by a specific length and that delegates to `iter` for its size hint.\n-    pub fn unbounded(iter: I) -> Self {\n-        MapDeserializer {\n-            iter: iter,\n-            value: None,\n-            len: None,\n-            marker: PhantomData,\n-        }\n-    }\n-\n-    fn next(&mut self) -> Option<(K, V)> {\n-        self.iter.next().map(|(k, v)| {\n-            if let Some(len) = self.len.as_mut() {\n-                *len -= 1;\n+    fn next(&mut self) -> Option<(<I::Item as private::Pair>::First, <I::Item as private::Pair>::Second)> {\n+        match self.iter.next() {\n+            Some(kv) => {\n+                self.count += 1;\n+                Some(private::Pair::split(kv))\n             }\n-            (k, v)\n-        })\n+            None => None,\n+        }\n     }\n \n     fn end(&mut self) -> Result<(), E> {\n-        match self.len {\n-            Some(len) if len > 0 => Err(de::Error::invalid_length(len)),\n-            _ => Ok(())\n+        let mut remaining = 0;\n+        while self.iter.next().is_some() {\n+            remaining += 1;\n+        }\n+        if remaining == 0 {\n+            Ok(())\n+        } else {\n+            // First argument is the number of elements in the data, second\n+            // argument is the number of elements expected by the Deserialize.\n+            Err(de::Error::invalid_length(self.count + remaining, &ExpectedInMap(self.count)))\n         }\n     }\n }\n \n-impl<I, K, V, E> de::Deserializer for MapDeserializer<I, K, V, E>\n-    where I: Iterator<Item=(K, V)>,\n-          K: ValueDeserializer<E>,\n-          V: ValueDeserializer<E>,\n+impl<I, E> de::Deserializer for MapDeserializer<I, E>\n+    where I: Iterator,\n+          I::Item: private::Pair,\n+          <I::Item as private::Pair>::First: ValueDeserializer<E>,\n+          <I::Item as private::Pair>::Second: ValueDeserializer<E>,\n           E: de::Error,\n {\n     type Error = E;\n@@ -659,17 +629,10 @@ impl<I, K, V, E> de::Deserializer for MapDeserializer<I, K, V, E>\n         Ok(value)\n     }\n \n-    fn deserialize_seq_fixed_size<V_>(mut self, len: usize, visitor: V_) -> Result<V_::Value, Self::Error>\n+    fn deserialize_seq_fixed_size<V_>(self, _len: usize, visitor: V_) -> Result<V_::Value, Self::Error>\n         where V_: de::Visitor,\n     {\n-        match self.len {\n-            Some(map_len) if map_len != len => Err(de::Error::invalid_length(len)),\n-            _ => {\n-                let value = try!(visitor.visit_seq(&mut self));\n-                try!(self.end());\n-                Ok(value)\n-            }\n-        }\n+        self.deserialize_seq(visitor)\n     }\n \n     forward_to_deserialize! {\n@@ -679,10 +642,11 @@ impl<I, K, V, E> de::Deserializer for MapDeserializer<I, K, V, E>\n     }\n }\n \n-impl<I, K, V, E> de::MapVisitor for MapDeserializer<I, K, V, E>\n-    where I: Iterator<Item=(K, V)>,\n-          K: ValueDeserializer<E>,\n-          V: ValueDeserializer<E>,\n+impl<I, E> de::MapVisitor for MapDeserializer<I, E>\n+    where I: Iterator,\n+          I::Item: private::Pair,\n+          <I::Item as private::Pair>::First: ValueDeserializer<E>,\n+          <I::Item as private::Pair>::Second: ValueDeserializer<E>,\n           E: de::Error,\n {\n     type Error = E;\n@@ -702,14 +666,11 @@ impl<I, K, V, E> de::MapVisitor for MapDeserializer<I, K, V, E>\n     fn visit_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n         where T: de::DeserializeSeed,\n     {\n-        match self.value.take() {\n-            Some(value) => {\n-                seed.deserialize(value.into_deserializer())\n-            }\n-            None => {\n-                Err(de::Error::end_of_stream())\n-            }\n-        }\n+        let value = self.value.take();\n+        // Panic because this indicates a bug in the program rather than an\n+        // expected failure.\n+        let value = value.expect(\"MapVisitor::visit_value called before visit_key\");\n+        seed.deserialize(value.into_deserializer())\n     }\n \n     fn visit_seed<TK, TV>(&mut self, kseed: TK, vseed: TV) -> Result<Option<(TK::Value, TV::Value)>, Self::Error>\n@@ -727,16 +688,15 @@ impl<I, K, V, E> de::MapVisitor for MapDeserializer<I, K, V, E>\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.len.map_or_else(\n-            || self.iter.size_hint(),\n-            |len| (len, Some(len)))\n+        self.iter.size_hint()\n     }\n }\n \n-impl<I, K, V, E> de::SeqVisitor for MapDeserializer<I, K, V, E>\n-    where I: Iterator<Item=(K, V)>,\n-          K: ValueDeserializer<E>,\n-          V: ValueDeserializer<E>,\n+impl<I, E> de::SeqVisitor for MapDeserializer<I, E>\n+    where I: Iterator,\n+          I::Item: private::Pair,\n+          <I::Item as private::Pair>::First: ValueDeserializer<E>,\n+          <I::Item as private::Pair>::Second: ValueDeserializer<E>,\n           E: de::Error,\n {\n     type Error = E;\n@@ -754,7 +714,7 @@ impl<I, K, V, E> de::SeqVisitor for MapDeserializer<I, K, V, E>\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        de::MapVisitor::size_hint(self)\n+        self.iter.size_hint()\n     }\n }\n \n@@ -789,7 +749,10 @@ impl<A, B, E> de::Deserializer for PairDeserializer<A, B, E>\n         if pair_visitor.1.is_none() {\n             Ok(pair)\n         } else {\n-            Err(de::Error::invalid_length(pair_visitor.size_hint().0))\n+            let remaining = pair_visitor.size_hint().0;\n+            // First argument is the number of elements in the data, second\n+            // argument is the number of elements expected by the Deserialize.\n+            Err(de::Error::invalid_length(2, &ExpectedInSeq(2 - remaining)))\n         }\n     }\n \n@@ -799,7 +762,9 @@ impl<A, B, E> de::Deserializer for PairDeserializer<A, B, E>\n         if len == 2 {\n             self.deserialize_seq(visitor)\n         } else {\n-            Err(de::Error::invalid_length(len))\n+            // First argument is the number of elements in the data, second\n+            // argument is the number of elements expected by the Deserialize.\n+            Err(de::Error::invalid_length(2, &ExpectedInSeq(len)))\n         }\n     }\n }\n@@ -837,6 +802,18 @@ impl<A, B, E> de::SeqVisitor for PairVisitor<A, B, E>\n     }\n }\n \n+struct ExpectedInMap(usize);\n+\n+impl Expected for ExpectedInMap {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        if self.0 == 1 {\n+            write!(formatter, \"1 element in map\")\n+        } else {\n+            write!(formatter, \"{} elements in map\", self.0)\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////////\n \n #[cfg(any(feature = \"std\", feature = \"collections\"))]\n@@ -845,11 +822,10 @@ impl<K, V, E> ValueDeserializer<E> for BTreeMap<K, V>\n           V: ValueDeserializer<E>,\n           E: de::Error,\n {\n-    type Deserializer = MapDeserializer<btree_map::IntoIter<K, V>, K, V, E>;\n+    type Deserializer = MapDeserializer<btree_map::IntoIter<K, V>, E>;\n \n     fn into_deserializer(self) -> Self::Deserializer {\n-        let len = self.len();\n-        MapDeserializer::new(self.into_iter(), len)\n+        MapDeserializer::new(self.into_iter())\n     }\n }\n \n@@ -859,11 +835,10 @@ impl<K, V, E> ValueDeserializer<E> for HashMap<K, V>\n           V: ValueDeserializer<E>,\n           E: de::Error,\n {\n-    type Deserializer = MapDeserializer<hash_map::IntoIter<K, V>, K, V, E>;\n+    type Deserializer = MapDeserializer<hash_map::IntoIter<K, V>, E>;\n \n     fn into_deserializer(self) -> Self::Deserializer {\n-        let len = self.len();\n-        MapDeserializer::new(self.into_iter(), len)\n+        MapDeserializer::new(self.into_iter())\n     }\n }\n \n@@ -977,7 +952,7 @@ impl<E> de::Deserializer for ByteBufDeserializer<E>\n ///////////////////////////////////////////////////////////////////////////////\n \n mod private {\n-    use de;\n+    use de::{self, Unexpected};\n     use core::marker::PhantomData;\n \n     pub struct UnitOnly<E>(PhantomData<E>);\n@@ -998,7 +973,7 @@ mod private {\n         fn visit_newtype_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>\n             where T: de::DeserializeSeed,\n         {\n-            Err(de::Error::invalid_type(de::Type::NewtypeVariant))\n+            Err(de::Error::invalid_type(Unexpected::UnitVariant, &\"newtype variant\"))\n         }\n \n         fn visit_tuple<V>(self,\n@@ -1006,7 +981,7 @@ mod private {\n                         _visitor: V) -> Result<V::Value, Self::Error>\n             where V: de::Visitor\n         {\n-            Err(de::Error::invalid_type(de::Type::TupleVariant))\n+            Err(de::Error::invalid_type(Unexpected::UnitVariant, &\"tuple variant\"))\n         }\n \n         fn visit_struct<V>(self,\n@@ -1014,7 +989,21 @@ mod private {\n                         _visitor: V) -> Result<V::Value, Self::Error>\n             where V: de::Visitor\n         {\n-            Err(de::Error::invalid_type(de::Type::StructVariant))\n+            Err(de::Error::invalid_type(Unexpected::UnitVariant, &\"struct variant\"))\n         }\n     }\n+\n+    /// Avoid having to restate the generic types on MapDeserializer. The\n+    /// Iterator::Item contains enough information to figure out K and V.\n+    pub trait Pair {\n+        type First;\n+        type Second;\n+        fn split(self) -> (Self::First, Self::Second);\n+    }\n+\n+    impl<A, B> Pair for (A, B) {\n+        type First = A;\n+        type Second = B;\n+        fn split(self) -> (A, B) { self }\n+    }\n }\ndiff --git a/serde/src/error.rs b/serde/src/error.rs\nindex f6b704c74..6c411f847 100644\n--- a/serde/src/error.rs\n+++ b/serde/src/error.rs\n@@ -1,5 +1,4 @@\n //! A stand-in for `std::error`\n-use core::any::TypeId;\n use core::fmt::{Debug, Display};\n \n /// A stand-in for `std::error::Error`, which requires no allocation.\n@@ -13,10 +12,4 @@ pub trait Error: Debug + Display {\n \n     /// The lower-level cause of this error, if any.\n     fn cause(&self) -> Option<&Error> { None }\n-\n-    /// Get the `TypeId` of `self`\n-    #[doc(hidden)]\n-    fn type_id(&self) -> TypeId where Self: 'static {\n-        TypeId::of::<Self>()\n-    }\n }\ndiff --git a/serde/src/lib.rs b/serde/src/lib.rs\nindex 2046872bb..24f2a6772 100644\n--- a/serde/src/lib.rs\n+++ b/serde/src/lib.rs\n@@ -40,11 +40,6 @@ mod core {\n pub use ser::{Serialize, Serializer};\n pub use de::{Deserialize, Deserializer};\n \n-#[cfg(not(feature = \"std\"))]\n-macro_rules! format {\n-    ($s:expr, $($rest:tt)*) => ($s)\n-}\n-\n #[macro_use]\n mod macros;\n \ndiff --git a/serde/src/ser/impls.rs b/serde/src/ser/impls.rs\nindex f09b28718..e89f0cd3f 100644\n--- a/serde/src/ser/impls.rs\n+++ b/serde/src/ser/impls.rs\n@@ -772,7 +772,7 @@ impl Serialize for path::Path {\n     {\n         match self.to_str() {\n             Some(s) => s.serialize(serializer),\n-            None => Err(Error::invalid_value(\"Path contains invalid UTF-8 characters\")),\n+            None => Err(Error::custom(\"Path contains invalid UTF-8 characters\")),\n         }\n     }\n }\ndiff --git a/serde/src/ser/mod.rs b/serde/src/ser/mod.rs\nindex 3b2e3d342..10b14fdac 100644\n--- a/serde/src/ser/mod.rs\n+++ b/serde/src/ser/mod.rs\n@@ -23,6 +23,8 @@ use core::marker::PhantomData;\n #[cfg(feature = \"unstable\")]\n use core::cell::RefCell;\n \n+use core::fmt::Display;\n+\n pub mod impls;\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -31,17 +33,7 @@ pub mod impls;\n /// `Serializer` error.\n pub trait Error: Sized + error::Error {\n     /// Raised when there is a general error when serializing a type.\n-    #[cfg(any(feature = \"std\", feature = \"collections\"))]\n-    fn custom<T: Into<String>>(msg: T) -> Self;\n-\n-    /// Raised when there is a general error when serializing a type.\n-    #[cfg(all(not(feature = \"std\"), not(feature = \"collections\")))]\n-    fn custom<T: Into<&'static str>>(msg: T) -> Self;\n-\n-    /// Raised when a `Serialize` was passed an incorrect value.\n-    fn invalid_value(msg: &str) -> Self {\n-        Error::custom(format!(\"invalid value: {}\", msg))\n-    }\n+    fn custom<T: Display>(msg: T) -> Self;\n }\n \n ///////////////////////////////////////////////////////////////////////////////\ndiff --git a/serde_codegen/Cargo.toml b/serde_codegen/Cargo.toml\nindex 757e838f3..6161e373e 100644\n--- a/serde_codegen/Cargo.toml\n+++ b/serde_codegen/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_codegen\"\n-version = \"0.9.0-rc1\"\n+version = \"0.9.0-rc2\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"Macros to auto-generate implementations for the serde framework\"\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex e9771247c..f1274bca6 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -200,12 +200,18 @@ fn deserialize_unit_struct(\n ) -> Tokens {\n     let type_name = item_attrs.name().deserialize_name();\n \n+    let expecting = format!(\"unit struct {}\", type_ident);\n+\n     quote!({\n         struct __Visitor;\n \n         impl _serde::de::Visitor for __Visitor {\n             type Value = #type_ident;\n \n+            fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+                formatter.write_str(#expecting)\n+            }\n+\n             #[inline]\n             fn visit_unit<__E>(self) -> ::std::result::Result<#type_ident, __E>\n                 where __E: _serde::de::Error,\n@@ -242,6 +248,10 @@ fn deserialize_tuple(\n         Some(variant_ident) => quote!(#type_ident::#variant_ident),\n         None => quote!(#type_ident),\n     };\n+    let expecting = match variant_ident {\n+        Some(variant_ident) => format!(\"tuple variant {}::{}\", type_ident, variant_ident),\n+        None => format!(\"tuple struct {}\", type_ident),\n+    };\n \n     let nfields = fields.len();\n \n@@ -287,6 +297,10 @@ fn deserialize_tuple(\n         impl #impl_generics _serde::de::Visitor for #visitor_ty #where_clause {\n             type Value = #ty;\n \n+            fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+                formatter.write_str(#expecting)\n+            }\n+\n             #visit_newtype_struct\n \n             #[inline]\n@@ -310,6 +324,11 @@ fn deserialize_seq(\n ) -> Tokens {\n     let vars = (0..fields.len()).map(field_i as fn(_) -> _);\n \n+    let deserialized_count = fields.iter()\n+        .filter(|field| !field.attrs.skip_deserializing())\n+        .count();\n+    let expecting = format!(\"tuple of {} elements\", deserialized_count);\n+\n     let mut index_in_seq = 0usize;\n     let let_values = vars.clone().zip(fields)\n         .map(|(var, field)| {\n@@ -338,7 +357,7 @@ fn deserialize_seq(\n                     let #var = match #visit {\n                         Some(value) => { value },\n                         None => {\n-                            return Err(_serde::de::Error::invalid_length(#index_in_seq));\n+                            return Err(_serde::de::Error::invalid_length(#index_in_seq, &#expecting));\n                         }\n                     };\n                 };\n@@ -413,6 +432,10 @@ fn deserialize_struct(\n         Some(variant_ident) => quote!(#type_ident::#variant_ident),\n         None => quote!(#type_ident),\n     };\n+    let expecting = match variant_ident {\n+        Some(variant_ident) => format!(\"struct variant {}::{}\", type_ident, variant_ident),\n+        None => format!(\"struct {}\", type_ident),\n+    };\n \n     let visit_seq = deserialize_seq(\n         type_ident,\n@@ -457,6 +480,10 @@ fn deserialize_struct(\n         impl #impl_generics _serde::de::Visitor for #visitor_ty #where_clause {\n             type Value = #ty;\n \n+            fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+                formatter.write_str(#expecting)\n+            }\n+\n             #[inline]\n             fn visit_seq<__V>(self, #visitor_var: __V) -> ::std::result::Result<#ty, __V::Error>\n                 where __V: _serde::de::SeqVisitor\n@@ -489,6 +516,8 @@ fn deserialize_item_enum(\n \n     let type_name = item_attrs.name().deserialize_name();\n \n+    let expecting = format!(\"enum {}\", type_ident);\n+\n     let variant_names_idents: Vec<_> = variants.iter()\n         .enumerate()\n         .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n@@ -556,6 +585,10 @@ fn deserialize_item_enum(\n         impl #impl_generics _serde::de::Visitor for #visitor_ty #where_clause {\n             type Value = #ty;\n \n+            fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+                formatter.write_str(#expecting)\n+            }\n+\n             fn visit_enum<__V>(self, visitor: __V) -> ::std::result::Result<#ty, __V::Error>\n                 where __V: _serde::de::EnumVisitor,\n             {\n@@ -660,11 +693,11 @@ fn deserialize_field_visitor(\n \n     let fallthrough_arm = if is_variant {\n         quote! {\n-            Err(_serde::de::Error::unknown_variant(value))\n+            Err(_serde::de::Error::unknown_variant(value, VARIANTS))\n         }\n     } else if item_attrs.deny_unknown_fields() {\n         quote! {\n-            Err(_serde::de::Error::unknown_field(value))\n+            Err(_serde::de::Error::unknown_field(value, FIELDS))\n         }\n     } else {\n         quote! {\n@@ -689,6 +722,10 @@ fn deserialize_field_visitor(\n                 impl _serde::de::Visitor for __FieldVisitor {\n                     type Value = __Field;\n \n+                    fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+                        formatter.write_str(\"field name\")\n+                    }\n+\n                     fn visit_str<__E>(self, value: &str) -> ::std::result::Result<__Field, __E>\n                         where __E: _serde::de::Error\n                     {\n@@ -931,7 +968,7 @@ fn expr_is_missing(attrs: &attr::Field) -> Tokens {\n     match attrs.deserialize_with() {\n         None => {\n             quote! {\n-                try!(visitor.missing_field(#name))\n+                try!(_serde::de::private::missing_field(#name))\n             }\n         }\n         Some(_) => {\ndiff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex acd9973cd..3374d5acf 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -257,10 +257,10 @@ fn serialize_variant(\n     let variant_name = variant.attrs.name().serialize_name();\n \n     if variant.attrs.skip_serializing() {\n-        let skipped_msg = format!(\"The enum variant {}::{} cannot be serialized\",\n+        let skipped_msg = format!(\"the enum variant {}::{} cannot be serialized\",\n                                 type_ident, variant_ident);\n         let skipped_err = quote! {\n-            Err(_serde::ser::Error::invalid_value(#skipped_msg))\n+            Err(_serde::ser::Error::custom(#skipped_msg))\n         };\n         let fields_pat = match variant.style {\n             Style::Unit => quote!(),\ndiff --git a/serde_derive/Cargo.toml b/serde_derive/Cargo.toml\nindex 183370454..ddc3f62f8 100644\n--- a/serde_derive/Cargo.toml\n+++ b/serde_derive/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_derive\"\n-version = \"0.9.0-rc1\"\n+version = \"0.9.0-rc2\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"Macros 1.1 implementation of #[derive(Serialize, Deserialize)]\"\n@@ -15,7 +15,7 @@ name = \"serde_derive\"\n proc-macro = true\n \n [dependencies.serde_codegen]\n-version = \"=0.9.0-rc1\"\n+version = \"=0.9.0-rc2\"\n path = \"../serde_codegen\"\n default-features = false\n features = [\"with-syn\"]\n@@ -23,5 +23,5 @@ features = [\"with-syn\"]\n [dev-dependencies]\n compiletest_rs = \"^0.2.0\"\n fnv = \"1.0\"\n-serde = { version = \"0.9.0-rc1\", path = \"../serde\" }\n-serde_test = { version = \"0.9.0-rc1\", path = \"../serde_test\" }\n+serde = { version = \"0.9.0-rc2\", path = \"../serde\" }\n+serde_test = { version = \"0.9.0-rc2\", path = \"../serde_test\" }\n", "test_patch": "diff --git a/serde_test/Cargo.toml b/serde_test/Cargo.toml\nindex de037b79e..b4ea1c74e 100644\n--- a/serde_test/Cargo.toml\n+++ b/serde_test/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_test\"\n-version = \"0.9.0-rc1\"\n+version = \"0.9.0-rc2\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"Token De/Serializer for testing De/Serialize implementations\"\n@@ -12,4 +12,4 @@ keywords = [\"serde\", \"serialization\"]\n include = [\"Cargo.toml\", \"src/**/*.rs\"]\n \n [dependencies]\n-serde = { version = \"0.9.0-rc1\", path = \"../serde\" }\n+serde = { version = \"0.9.0-rc2\", path = \"../serde\" }\ndiff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 3630d7247..fc29ccd94 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -43,7 +43,7 @@ impl<I> Deserializer<I>\n                     Err(Error::UnexpectedToken(token))\n                 }\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -259,7 +259,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n             Some(Token::Option(false)) => visitor.visit_none(),\n             Some(Token::Option(true)) => visitor.visit_some(self),\n             Some(Token::Unit) => visitor.visit_unit(),\n-            Some(Token::UnitStruct(name)) => visitor.visit_unit_struct(name),\n+            Some(Token::UnitStruct(_name)) => visitor.visit_unit(),\n             Some(Token::SeqStart(len)) => {\n                 self.visit_seq(len, visitor)\n             }\n@@ -273,7 +273,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n                 self.visit_map(Some(len), visitor)\n             }\n             Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -296,7 +296,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n                 visitor.visit_none()\n             }\n             Some(_) => visitor.visit_some(self),\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -326,7 +326,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n                 let token = self.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => { return Err(Error::EndOfStream); }\n+            None => { return Err(Error::EndOfTokens); }\n         }\n     }\n \n@@ -343,7 +343,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n                 }\n             }\n             Some(_) => self.deserialize(visitor),\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -362,7 +362,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n                 }\n             }\n             Some(_) => self.deserialize(visitor),\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -377,7 +377,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n                 self.visit_array(len, visitor)\n             }\n             Some(_) => self.deserialize(visitor),\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -412,7 +412,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n                 self.visit_tuple_struct(len, visitor)\n             }\n             Some(_) => self.deserialize(visitor),\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -456,7 +456,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n                 }\n             }\n             Some(_) => self.deserialize(visitor),\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -480,7 +480,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n                 self.visit_map(Some(fields.len()), visitor)\n             }\n             Some(_) => self.deserialize(visitor),\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n }\n@@ -511,7 +511,7 @@ impl<'a, I> SeqVisitor for DeserializerSeqVisitor<'a, I>\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -547,7 +547,7 @@ impl<'a, I> SeqVisitor for DeserializerArrayVisitor<'a, I>\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -582,7 +582,7 @@ impl<'a, I> SeqVisitor for DeserializerTupleVisitor<'a, I>\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -617,7 +617,7 @@ impl<'a, I> SeqVisitor for DeserializerTupleStructVisitor<'a, I>\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -652,7 +652,7 @@ impl<'a, I> SeqVisitor for DeserializerVariantSeqVisitor<'a, I>\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -688,7 +688,7 @@ impl<'a, I> MapVisitor for DeserializerMapVisitor<'a, I>\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -730,7 +730,7 @@ impl<'a, I> MapVisitor for DeserializerStructVisitor<'a, I>\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -773,7 +773,7 @@ impl<'a, I> EnumVisitor for DeserializerEnumVisitor<'a, I>\n                 let value = try!(seed.deserialize(&mut *self.de));\n                 Ok((value, self))\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n }\n@@ -792,7 +792,7 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n             Some(_) => {\n                 Deserialize::deserialize(self.de)\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -807,7 +807,7 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n             Some(_) => {\n                 seed.deserialize(self.de)\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -838,7 +838,7 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n             Some(_) => {\n                 de::Deserializer::deserialize(self.de, visitor)\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \n@@ -869,7 +869,7 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n             Some(_) => {\n                 de::Deserializer::deserialize(self.de, visitor)\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n }\n@@ -900,7 +900,7 @@ impl<'a, I> MapVisitor for DeserializerVariantMapVisitor<'a, I>\n                 let token = self.de.tokens.next().unwrap();\n                 Err(Error::UnexpectedToken(token))\n             }\n-            None => Err(Error::EndOfStream),\n+            None => Err(Error::EndOfTokens),\n         }\n     }\n \ndiff --git a/serde_test/src/error.rs b/serde_test/src/error.rs\nindex d5c4c6e72..a09252ab2 100644\n--- a/serde_test/src/error.rs\n+++ b/serde_test/src/error.rs\n@@ -1,4 +1,5 @@\n-use std::{error, fmt};\n+use std::error;\n+use std::fmt::{self, Display};\n \n use serde::{ser, de};\n \n@@ -6,82 +7,42 @@ use token::Token;\n \n #[derive(Clone, PartialEq, Debug)]\n pub enum Error {\n-    // Shared\n-    Custom(String),\n-    InvalidValue(String),\n-\n-    // De\n-    EndOfStream,\n-    InvalidType(de::Type),\n-    InvalidLength(usize),\n-    UnknownVariant(String),\n-    UnknownField(String),\n-    MissingField(&'static str),\n-    DuplicateField(&'static str),\n+    Message(String),\n     InvalidName(&'static str),\n     UnexpectedToken(Token<'static>),\n+    EndOfTokens,\n }\n \n impl ser::Error for Error {\n-    fn custom<T: Into<String>>(msg: T) -> Error {\n-        Error::Custom(msg.into())\n-    }\n-\n-    fn invalid_value(msg: &str) -> Error {\n-        Error::InvalidValue(msg.to_owned())\n+    fn custom<T: Display>(msg: T) -> Error {\n+        Error::Message(msg.to_string())\n     }\n }\n \n impl de::Error for Error {\n-    fn custom<T: Into<String>>(msg: T) -> Error {\n-        Error::Custom(msg.into())\n-    }\n-\n-    fn end_of_stream() -> Error {\n-        Error::EndOfStream\n-    }\n-\n-    fn invalid_type(ty: de::Type) -> Error {\n-        Error::InvalidType(ty)\n-    }\n-\n-    fn invalid_value(msg: &str) -> Error {\n-        Error::InvalidValue(msg.to_owned())\n-    }\n-\n-    fn invalid_length(len: usize) -> Error {\n-        Error::InvalidLength(len)\n-    }\n-\n-    fn unknown_variant(variant: &str) -> Error {\n-        Error::UnknownVariant(variant.to_owned())\n-    }\n-\n-    fn unknown_field(field: &str) -> Error {\n-        Error::UnknownField(field.to_owned())\n-    }\n-\n-    fn missing_field(field: &'static str) -> Error {\n-        Error::MissingField(field)\n-    }\n-\n-    fn duplicate_field(field: &'static str) -> Error {\n-        Error::DuplicateField(field)\n+    fn custom<T: Display>(msg: T) -> Error {\n+        Error::Message(msg.to_string())\n     }\n }\n \n impl fmt::Display for Error {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        formatter.write_str(format!(\"{:?}\", self).as_ref())\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Error::Message(ref msg) => formatter.write_str(msg),\n+            Error::InvalidName(name) => write!(formatter, \"invalid name `{}`\", name),\n+            Error::UnexpectedToken(_) => formatter.write_str(\"unexpected token\"),\n+            Error::EndOfTokens => formatter.write_str(\"end of tokens\"),\n+        }\n     }\n }\n \n impl error::Error for Error {\n     fn description(&self) -> &str {\n-        \"Serde Error\"\n-    }\n-\n-    fn cause(&self) -> Option<&error::Error> {\n-        None\n+        match *self {\n+            Error::Message(ref msg) => msg,\n+            Error::InvalidName(_) => \"invalid name\",\n+            Error::UnexpectedToken(_) => \"unexpected token\",\n+            Error::EndOfTokens => \"end of tokens\",\n+        }\n     }\n }\ndiff --git a/testing/Cargo.toml b/testing/Cargo.toml\nindex 7a31c31ed..b592a2143 100644\n--- a/testing/Cargo.toml\n+++ b/testing/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"serde_testing\"\n-version = \"0.9.0-rc1\"\n+version = \"0.9.0-rc2\"\n authors = [\"Erick Tryzelaar <erick.tryzelaar@gmail.com>\"]\n license = \"MIT/Apache-2.0\"\n description = \"A generic serialization/deserialization framework\"\ndiff --git a/testing/tests/test_annotations.rs b/testing/tests/test_annotations.rs\nindex e17741223..7df8bb1c7 100644\n--- a/testing/tests/test_annotations.rs\n+++ b/testing/tests/test_annotations.rs\n@@ -343,7 +343,7 @@ fn test_ignore_unknown() {\n             Token::StructSep,\n             Token::Str(\"whoops\"),\n         ],\n-        Error::UnknownField(\"whoops\".to_owned())\n+        Error::Message(\"unknown field `whoops`, expected `a1`\".to_owned())\n     );\n }\n \n@@ -905,7 +905,7 @@ fn test_missing_renamed_field_struct() {\n \n             Token::StructEnd,\n         ],\n-        Error::MissingField(\"a3\"),\n+        Error::Message(\"missing field `a3`\".to_owned()),\n     );\n \n     assert_de_tokens_error::<RenameStructSerializeDeserialize>(\n@@ -918,7 +918,7 @@ fn test_missing_renamed_field_struct() {\n \n             Token::StructEnd,\n         ],\n-        Error::MissingField(\"a5\"),\n+        Error::Message(\"missing field `a5`\".to_owned()),\n     );\n }\n \n@@ -930,7 +930,7 @@ fn test_missing_renamed_field_enum() {\n \n             Token::EnumMapEnd,\n         ],\n-        Error::MissingField(\"b\"),\n+        Error::Message(\"missing field `b`\".to_owned()),\n     );\n \n     assert_de_tokens_error::<RenameEnumSerializeDeserialize<i8>>(\n@@ -943,7 +943,7 @@ fn test_missing_renamed_field_enum() {\n \n             Token::EnumMapEnd,\n         ],\n-        Error::MissingField(\"d\"),\n+        Error::Message(\"missing field `d`\".to_owned()),\n     );\n }\n \n@@ -962,7 +962,7 @@ fn test_invalid_length_enum() {\n                 Token::I32(1),\n             Token::EnumSeqEnd,\n         ],\n-        Error::InvalidLength(1),\n+        Error::Message(\"invalid length 1, expected tuple of 3 elements\".to_owned()),\n     );\n     assert_de_tokens_error::<InvalidLengthEnum>(\n         &[\n@@ -971,6 +971,6 @@ fn test_invalid_length_enum() {\n                 Token::I32(1),\n             Token::EnumSeqEnd,\n         ],\n-        Error::InvalidLength(1),\n+        Error::Message(\"invalid length 1, expected tuple of 2 elements\".to_owned()),\n     );\n }\ndiff --git a/testing/tests/test_de.rs b/testing/tests/test_de.rs\nindex 3359492e8..451d3d891 100644\n--- a/testing/tests/test_de.rs\n+++ b/testing/tests/test_de.rs\n@@ -3,7 +3,7 @@ use std::net;\n use std::path::PathBuf;\n use std::time::Duration;\n \n-use serde::de::{Deserialize, Type};\n+use serde::Deserialize;\n \n extern crate fnv;\n use self::fnv::FnvHasher;\n@@ -849,7 +849,7 @@ declare_error_tests! {\n                 Token::StructSep,\n                 Token::Str(\"d\"),\n         ],\n-        Error::UnknownField(\"d\".to_owned()),\n+        Error::Message(\"unknown field `d`, expected `a`\".to_owned()),\n     }\n     test_skipped_field_is_unknown<StructDenyUnknown> {\n         &[\n@@ -857,7 +857,7 @@ declare_error_tests! {\n                 Token::StructSep,\n                 Token::Str(\"b\"),\n         ],\n-        Error::UnknownField(\"b\".to_owned()),\n+        Error::Message(\"unknown field `b`, expected `a`\".to_owned()),\n     }\n     test_skip_all_deny_unknown<StructSkipAllDenyUnknown> {\n         &[\n@@ -865,25 +865,25 @@ declare_error_tests! {\n                 Token::StructSep,\n                 Token::Str(\"a\"),\n         ],\n-        Error::UnknownField(\"a\".to_owned()),\n+        Error::Message(\"unknown field `a`, there are no fields\".to_owned()),\n     }\n     test_unknown_variant<Enum> {\n         &[\n             Token::EnumUnit(\"Enum\", \"Foo\"),\n         ],\n-        Error::UnknownVariant(\"Foo\".to_owned()),\n+        Error::Message(\"unknown variant `Foo`, expected one of `Unit`, `Simple`, `Seq`, `Map`\".to_owned()),\n     }\n     test_enum_skipped_variant<Enum> {\n         &[\n             Token::EnumUnit(\"Enum\", \"Skipped\"),\n         ],\n-        Error::UnknownVariant(\"Skipped\".to_owned()),\n+        Error::Message(\"unknown variant `Skipped`, expected one of `Unit`, `Simple`, `Seq`, `Map`\".to_owned()),\n     }\n     test_enum_skip_all<EnumSkipAll> {\n         &[\n             Token::EnumUnit(\"EnumSkipAll\", \"Skipped\"),\n         ],\n-        Error::UnknownVariant(\"Skipped\".to_owned()),\n+        Error::Message(\"unknown variant `Skipped`, there are no variants\".to_owned()),\n     }\n     test_struct_seq_too_long<Struct> {\n         &[\n@@ -904,7 +904,7 @@ declare_error_tests! {\n                 Token::MapSep,\n                 Token::Str(\"a\"),\n         ],\n-        Error::DuplicateField(\"a\"),\n+        Error::Message(\"duplicate field `a`\".to_owned()),\n     }\n     test_duplicate_field_enum<Enum> {\n         &[\n@@ -916,7 +916,7 @@ declare_error_tests! {\n                 Token::EnumMapSep,\n                 Token::Str(\"a\"),\n         ],\n-        Error::DuplicateField(\"a\"),\n+        Error::Message(\"duplicate field `a`\".to_owned()),\n     }\n     test_enum_unit_usize<Enum> {\n         &[\n@@ -924,7 +924,7 @@ declare_error_tests! {\n             Token::Usize(0),\n             Token::Unit,\n         ],\n-        Error::InvalidType(Type::U64),\n+        Error::Message(\"invalid type: integer `0`, expected field name\".into()),\n     }\n     test_enum_unit_bytes<Enum> {\n         &[\n@@ -932,6 +932,6 @@ declare_error_tests! {\n             Token::Bytes(b\"Unit\"),\n             Token::Unit,\n         ],\n-        Error::InvalidType(Type::Bytes),\n+        Error::Message(\"invalid type: byte array, expected field name\".into()),\n     }\n }\ndiff --git a/testing/tests/test_ser.rs b/testing/tests/test_ser.rs\nindex 5d54b4327..25df26d1e 100644\n--- a/testing/tests/test_ser.rs\n+++ b/testing/tests/test_ser.rs\n@@ -432,7 +432,7 @@ fn test_cannot_serialize_paths() {\n     assert_ser_tokens_error(\n         &Path::new(path),\n         &[],\n-        Error::InvalidValue(\"Path contains invalid UTF-8 characters\".to_owned()));\n+        Error::Message(\"Path contains invalid UTF-8 characters\".to_owned()));\n \n     let mut path_buf = PathBuf::new();\n     path_buf.push(path);\n@@ -440,7 +440,7 @@ fn test_cannot_serialize_paths() {\n     assert_ser_tokens_error(\n         &path_buf,\n         &[],\n-        Error::InvalidValue(\"Path contains invalid UTF-8 characters\".to_owned()));\n+        Error::Message(\"Path contains invalid UTF-8 characters\".to_owned()));\n }\n \n #[test]\n@@ -448,17 +448,17 @@ fn test_enum_skipped() {\n     assert_ser_tokens_error(\n         &Enum::SkippedUnit,\n         &[],\n-        Error::InvalidValue(\"The enum variant Enum::SkippedUnit cannot be serialized\".to_owned()));\n+        Error::Message(\"the enum variant Enum::SkippedUnit cannot be serialized\".to_owned()));\n     assert_ser_tokens_error(\n         &Enum::SkippedOne(42),\n         &[],\n-        Error::InvalidValue(\"The enum variant Enum::SkippedOne cannot be serialized\".to_owned()));\n+        Error::Message(\"the enum variant Enum::SkippedOne cannot be serialized\".to_owned()));\n     assert_ser_tokens_error(\n         &Enum::SkippedSeq(1, 2),\n         &[],\n-        Error::InvalidValue(\"The enum variant Enum::SkippedSeq cannot be serialized\".to_owned()));\n+        Error::Message(\"the enum variant Enum::SkippedSeq cannot be serialized\".to_owned()));\n     assert_ser_tokens_error(\n         &Enum::SkippedMap { _a: 1, _b: 2 },\n         &[],\n-        Error::InvalidValue(\"The enum variant Enum::SkippedMap cannot be serialized\".to_owned()));\n+        Error::Message(\"the enum variant Enum::SkippedMap cannot be serialized\".to_owned()));\n }\n", "problem_statement": "Deserialization errors like \"Error: Invalid type. Expected `I64`\" are hard for users to understand\nThank you for your help parsing mixed strings and structs! Here's a second issue to think over. :-)\n\nHere, I'm parsing a 1,300-line `docker-compose.yml` file which uses bare string notation, and which therefore sometimes accidentally uses an integer value like `1` where it should have used a string:\n\n``` yaml\nversion: 2\nservices:\n  foo:\n    environment:\n      NOKOGIRI_USE_SYSTEM_LIBRARIES: 1\n      REDIS_URL: redis://redis:6379\n```\n\nI deserialize this with the following declaration:\n\n``` rust\n    #[serde(default, skip_serializing_if = \"BTreeMap::is_empty\",\n            deserialize_with = \"deserialize_map_or_key_value_list\")]\n    pub environment: BTreeMap<String, String>,\n```\n\nThe function `deserialize_map_or_key_value_list` contains a `visit_map` function which calls `visitor.visit_value::<String>()` to read a string.\n\nWhen I run this program over the 1,300 line input file, it gives me the following error:\n\n```\ntarget/debug/examples/normalize < docker-compose.yml > test.yml\nError: Invalid type. Expected `I64`\n```\n\nThere are several problems here:\n1. The error message should be the \"other way around\", and include both the expected type and the one we actually got.\n2. The error message should ideally include a line number so the user knows where in the enormous file the error occurs.\n3. The error message should include the actual I64 value.\n\nThis would ideally give us something like:\n\n```\n<input>:869: Expected String, got I64 value `1`.\n```\n\nThis would make my program much more user friendly. :-) I can easily provide a slightly better workaround in this particular case, but I'd love to find a more general solution.\n\nReconsider MapVisitor::missing_field\nOut of all the Serde deserializers on GitHub, there are exactly four distinct behaviors for missing_field:\r\n\r\n- Unconditionally an error\r\n- For options treat it as None, otherwise error\r\n- Treat it as unit\r\n- [Whatever serde_xml is doing](https://github.com/serde-rs/xml/blob/f9330b703c7405ea8f54e1adfa972cb869924e38/src/de/value.rs#L358-L382)\r\n\r\nIdeally I would like to standardize on one of these (my preference is None/error) and remove the ability for deserializers to modify the behavior. This would improve consistency and predictability across the ecosystem.\r\n\r\n@oli-obk can you explain the various cases that serde_xml needs to handle in missing_field and whether you can think of any alternative ways to accomplish this?\n", "hints_text": "\nmwhaha, `serde_xml` should not be a benchmark of good `Deserializer` design. It's what you'd get if you wrote a test-suite and threw a neural network against it that gets encouraged to pass more tests.\r\n\r\nWhat we do at the location you linked is to rename a field to `$value`, and in case a tag like `<tag>content</tag>` comes along, you end up triggering `missing_field` for the `$value` field and extract \"content\" to be the value of that field. One would think that a string-newtype or similar could also suffice, but we can also have `<tag attr=\"foo\">content</tag>`, where we need a field named `attr`.\r\n\r\nMapping xml schemata to Rust types is a nightmare, the experiment is a failure in my opinion. It's not serde's fault, it's just that xml schemata have many weird things that basically only work with object oriented systems with inheritance.\nWhat would serde_xml do if we take away missing_field?\nProbably match on an error\nAnd use a seed\nLet's do that then. I think this would be a net benefit for every other use case except serde_xml. We replace the three different behaviors with one consistent approach and no longer need this awkwardly placed API. What do you think?\r\n\r\nWe would still need to settle which behavior to use:\r\n\r\n- For options treat missing field as None, otherwise error\r\n- Treat missing field as unit\r\n\r\nIn practice this matters most for collection types like Vec\\<T>. The first one makes it an error, the second one makes it empty vec. I prefer the first approach and if you want the second behavior you can either put #[serde(default)] on the vec field or use Option\\<Vec\\<T>>.\r\n\r\nIn theory we could also unconditionally make missing field an error, and require #[serde(default)] on Option\\<T> fields to make it None. That seems excessive to me. Option is already a special case in the Serializer and Deserializer traits and it seems pretty intuitive that if your field is optional and it isn't there then it is None.", "created_at": "2017-01-21T10:36:09Z"}, {"repo": "serde-rs/serde", "pull_number": 703, "instance_id": "serde-rs__serde-703", "issue_numbers": ["650"], "base_commit": "aa88f01cdcf26509c46bc6bfa68f43cc0bd0588e", "patch": "diff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex f6307eabe..12fc98c87 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -9,6 +9,7 @@ use error;\n use collections::{String, Vec};\n \n use core::fmt;\n+use core::marker::PhantomData;\n \n ///////////////////////////////////////////////////////////////////////////////\n \n@@ -230,6 +231,149 @@ pub trait Deserialize: Sized {\n         where D: Deserializer;\n }\n \n+/// `DeserializeSeed` is the stateful form of the `Deserialize` trait. If you\n+/// ever find yourself looking for a way to pass data into a `Deserialize` impl,\n+/// this trait is the way to do it.\n+///\n+/// As one example of stateful deserialization consider deserializing a JSON\n+/// array into an existing buffer. Using the `Deserialize` trait we could\n+/// deserialize a JSON array into a `Vec<T>` but it would be a freshly allocated\n+/// `Vec<T>`; there is no way for `Deserialize` to reuse a previously allocated\n+/// buffer. Using `DeserializeSeed` instead makes this possible as in the\n+/// example code below.\n+///\n+/// The canonical API for stateless deserialization looks like this:\n+///\n+/// ```rust\n+/// # use serde::Deserialize;\n+/// # enum Error {}\n+/// fn func<T: Deserialize>() -> Result<T, Error>\n+/// # { unimplemented!() }\n+/// ```\n+///\n+/// Adjusting an API like this to support stateful deserialization is a matter\n+/// of accepting a seed as input:\n+///\n+/// ```rust\n+/// # use serde::de::DeserializeSeed;\n+/// # enum Error {}\n+/// fn func_seed<T: DeserializeSeed>(seed: T) -> Result<T::Value, Error>\n+/// # { unimplemented!() }\n+/// ```\n+///\n+/// In practice the majority of deserialization is stateless. An API expecting a\n+/// seed can be appeased by passing `std::marker::PhantomData` as a seed in the\n+/// case of stateless deserialization.\n+///\n+/// # Example\n+///\n+/// Suppose we have JSON that looks like `[[1, 2], [3, 4, 5], [6]]` and we need\n+/// to deserialize it into a flat representation like `vec![1, 2, 3, 4, 5, 6]`.\n+/// Allocating a brand new `Vec<T>` for each subarray would be slow. Instead we\n+/// would like to allocate a single `Vec<T>` and then deserialize each subarray\n+/// into it. This requires stateful deserialization using the DeserializeSeed\n+/// trait.\n+///\n+/// ```rust\n+/// # use serde::de::{Deserialize, DeserializeSeed, Deserializer, Visitor, SeqVisitor};\n+/// # use std::marker::PhantomData;\n+/// #\n+/// // A DeserializeSeed implementation that uses stateful deserialization to\n+/// // append array elements onto the end of an existing vector. The preexisting\n+/// // state (\"seed\") in this case is the Vec<T>. The `deserialize` method of\n+/// // `ExtendVec` will be traversing the inner arrays of the JSON input and\n+/// // appending each integer into the existing Vec.\n+/// struct ExtendVec<'a, T: 'a>(&'a mut Vec<T>);\n+///\n+/// impl<'a, T> DeserializeSeed for ExtendVec<'a, T>\n+///     where T: Deserialize\n+/// {\n+///     // The return type of the `deserialize` method. This implementation\n+///     // appends onto an existing vector but does not create any new data\n+///     // structure, so the return type is ().\n+///     type Value = ();\n+///\n+///     fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n+///         where D: Deserializer\n+///     {\n+///         // Visitor implementation that will walk an inner array of the JSON\n+///         // input.\n+///         struct ExtendVecVisitor<'a, T: 'a>(&'a mut Vec<T>);\n+///\n+///         impl<'a, T> Visitor for ExtendVecVisitor<'a, T>\n+///             where T: Deserialize\n+///         {\n+///             type Value = ();\n+///\n+///             fn visit_seq<V>(self, mut visitor: V) -> Result<(), V::Error>\n+///                 where V: SeqVisitor\n+///             {\n+///                 // Visit each element in the inner array and push it onto\n+///                 // the existing vector.\n+///                 while let Some(elem) = visitor.visit()? {\n+///                     self.0.push(elem);\n+///                 }\n+///                 Ok(())\n+///             }\n+///         }\n+///\n+///         deserializer.deserialize_seq(ExtendVecVisitor(self.0))\n+///     }\n+/// }\n+///\n+/// // Visitor implementation that will walk the outer array of the JSON input.\n+/// struct FlattenedVecVisitor<T>(PhantomData<T>);\n+///\n+/// impl<T> Visitor for FlattenedVecVisitor<T>\n+///     where T: Deserialize\n+/// {\n+///     // This Visitor constructs a single Vec<T> to hold the flattened\n+///     // contents of the inner arrays.\n+///     type Value = Vec<T>;\n+///\n+///     fn visit_seq<V>(self, mut visitor: V) -> Result<Vec<T>, V::Error>\n+///         where V: SeqVisitor\n+///     {\n+///         // Create a single Vec to hold the flattened contents.\n+///         let mut vec = Vec::new();\n+///\n+///         // Each iteration through this loop is one inner array.\n+///         while let Some(()) = visitor.visit_seed(ExtendVec(&mut vec))? {\n+///             // Nothing to do; inner array has been appended into `vec`.\n+///         }\n+///\n+///         // Return the finished vec.\n+///         Ok(vec)\n+///     }\n+/// }\n+///\n+/// # fn example<D: Deserializer>(deserializer: D) -> Result<(), D::Error> {\n+/// let visitor = FlattenedVecVisitor(PhantomData);\n+/// let flattened: Vec<u64> = deserializer.deserialize_seq(visitor)?;\n+/// # Ok(()) }\n+/// ```\n+pub trait DeserializeSeed: Sized {\n+    /// The type produced by using this seed.\n+    type Value;\n+\n+    /// Equivalent to the more common `Deserialize::deserialize` method, except\n+    /// with some initial piece of data (the seed) passed in.\n+    fn deserialize<D>(self, deserializer: D) -> Result<Self::Value, D::Error>\n+        where D: Deserializer;\n+}\n+\n+impl<T> DeserializeSeed for PhantomData<T>\n+    where T: Deserialize\n+{\n+    type Value = T;\n+\n+    fn deserialize<D>(self, deserializer: D) -> Result<T, D::Error>\n+        where D: Deserializer\n+    {\n+        T::deserialize(deserializer)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////////\n \n /// `Deserializer` is a trait that can deserialize values by threading a `Visitor` trait through a\n@@ -244,7 +388,7 @@ pub trait Deserialize: Sized {\n ///    with the `deserialize_*` methods how it should parse the next value. One downside though to\n ///    only supporting the `deserialize_*` types is that it does not allow for deserializing into a\n ///    generic `json::Value`-esque type.\n-pub trait Deserializer {\n+pub trait Deserializer: Sized {\n     /// The error type that can be returned if some error occurs during deserialization.\n     type Error: Error;\n \n@@ -641,10 +785,26 @@ pub trait SeqVisitor {\n     /// The error type that can be returned if some error occurs during deserialization.\n     type Error: Error;\n \n-    /// This returns a `Ok(Some(value))` for the next value in the sequence, or `Ok(None)` if there\n-    /// are no more remaining items.\n+    /// This returns `Ok(Some(value))` for the next value in the sequence, or\n+    /// `Ok(None)` if there are no more remaining items.\n+    ///\n+    /// `Deserialize` implementations should typically use `SeqVisitor::visit`\n+    /// instead.\n+    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+        where T: DeserializeSeed;\n+\n+    /// This returns `Ok(Some(value))` for the next value in the sequence, or\n+    /// `Ok(None)` if there are no more remaining items.\n+    ///\n+    /// This method exists as a convenience for `Deserialize` implementations.\n+    /// `SeqVisitor` implementations should not need to override the default\n+    /// behavior.\n+    #[inline]\n     fn visit<T>(&mut self) -> Result<Option<T>, Self::Error>\n-        where T: Deserialize;\n+        where T: Deserialize\n+    {\n+        self.visit_seed(PhantomData)\n+    }\n \n     /// Return the lower and upper bound of items remaining in the sequence.\n     #[inline]\n@@ -656,6 +816,13 @@ pub trait SeqVisitor {\n impl<'a, V> SeqVisitor for &'a mut V where V: SeqVisitor {\n     type Error = V::Error;\n \n+    #[inline]\n+    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, V::Error>\n+        where T: DeserializeSeed\n+    {\n+        (**self).visit_seed(seed)\n+    }\n+\n     #[inline]\n     fn visit<T>(&mut self) -> Result<Option<T>, V::Error>\n         where T: Deserialize\n@@ -678,30 +845,81 @@ pub trait MapVisitor {\n     /// The error type that can be returned if some error occurs during deserialization.\n     type Error: Error;\n \n-    /// This returns a `Ok(Some((key, value)))` for the next (key-value) pair in the map, or\n-    /// `Ok(None)` if there are no more remaining items.\n+    /// This returns `Ok(Some(key))` for the next key in the map, or `Ok(None)`\n+    /// if there are no more remaining entries.\n+    ///\n+    /// `Deserialize` implementations should typically use\n+    /// `MapVisitor::visit_key` or `MapVisitor::visit` instead.\n+    fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n+        where K: DeserializeSeed;\n+\n+    /// This returns a `Ok(value)` for the next value in the map.\n+    ///\n+    /// `Deserialize` implementations should typically use\n+    /// `MapVisitor::visit_value` instead.\n+    fn visit_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n+        where V: DeserializeSeed;\n+\n+    /// This returns `Ok(Some((key, value)))` for the next (key-value) pair in\n+    /// the map, or `Ok(None)` if there are no more remaining items.\n+    ///\n+    /// `MapVisitor` implementations should override the default behavior if a\n+    /// more efficient implementation is possible.\n+    ///\n+    /// `Deserialize` implementations should typically use `MapVisitor::visit`\n+    /// instead.\n     #[inline]\n-    fn visit<K, V>(&mut self) -> Result<Option<(K, V)>, Self::Error>\n-        where K: Deserialize,\n-              V: Deserialize,\n+    fn visit_seed<K, V>(&mut self, key_seed: K, vseed: V) -> Result<Option<(K::Value, V::Value)>, Self::Error>\n+        where K: DeserializeSeed,\n+              V: DeserializeSeed\n     {\n-        match try!(self.visit_key()) {\n+        match try!(self.visit_key_seed(key_seed)) {\n             Some(key) => {\n-                let value = try!(self.visit_value());\n+                let value = try!(self.visit_value_seed(vseed));\n                 Ok(Some((key, value)))\n             }\n             None => Ok(None)\n         }\n     }\n \n-    /// This returns a `Ok(Some(key))` for the next key in the map, or `Ok(None)` if there are no\n-    /// more remaining items.\n+    /// This returns `Ok(Some(key))` for the next key in the map, or `Ok(None)`\n+    /// if there are no more remaining entries.\n+    ///\n+    /// This method exists as a convenience for `Deserialize` implementations.\n+    /// `MapVisitor` implementations should not need to override the default\n+    /// behavior.\n+    #[inline]\n     fn visit_key<K>(&mut self) -> Result<Option<K>, Self::Error>\n-        where K: Deserialize;\n+        where K: Deserialize\n+    {\n+        self.visit_key_seed(PhantomData)\n+    }\n \n     /// This returns a `Ok(value)` for the next value in the map.\n+    ///\n+    /// This method exists as a convenience for `Deserialize` implementations.\n+    /// `MapVisitor` implementations should not need to override the default\n+    /// behavior.\n+    #[inline]\n     fn visit_value<V>(&mut self) -> Result<V, Self::Error>\n-        where V: Deserialize;\n+        where V: Deserialize\n+    {\n+        self.visit_value_seed(PhantomData)\n+    }\n+\n+    /// This returns `Ok(Some((key, value)))` for the next (key-value) pair in\n+    /// the map, or `Ok(None)` if there are no more remaining items.\n+    ///\n+    /// This method exists as a convenience for `Deserialize` implementations.\n+    /// `MapVisitor` implementations should not need to override the default\n+    /// behavior.\n+    #[inline]\n+    fn visit<K, V>(&mut self) -> Result<Option<(K, V)>, Self::Error>\n+        where K: Deserialize,\n+              V: Deserialize,\n+    {\n+        self.visit_seed(PhantomData, PhantomData)\n+    }\n \n     /// Return the lower and upper bound of items remaining in the sequence.\n     #[inline]\n@@ -709,17 +927,57 @@ pub trait MapVisitor {\n         (0, None)\n     }\n \n-    /// Report that the struct has a field that wasn't deserialized\n+    /// Report that the struct has a field that wasn't deserialized. The\n+    /// MapVisitor may consider this an error or it may return a default value\n+    /// for the field.\n+    ///\n+    /// `Deserialize` implementations should typically use\n+    /// `MapVisitor::missing_field` instead.\n+    fn missing_field_seed<V>(&mut self, _seed: V, field: &'static str) -> Result<V::Value, Self::Error>\n+        where V: DeserializeSeed\n+    {\n+        Err(Error::missing_field(field))\n+    }\n+\n+    /// Report that the struct has a field that wasn't deserialized. The\n+    /// MapVisitor may consider this an error or it may return a default value\n+    /// for the field.\n+    ///\n+    /// This method exists as a convenience for `Deserialize` implementations.\n+    /// `MapVisitor` implementations should not need to override the default\n+    /// behavior.\n     fn missing_field<V>(&mut self, field: &'static str) -> Result<V, Self::Error>\n         where V: Deserialize,\n     {\n-        Err(Error::missing_field(field))\n+        self.missing_field_seed(PhantomData, field)\n     }\n }\n \n impl<'a, V_> MapVisitor for &'a mut V_ where V_: MapVisitor {\n     type Error = V_::Error;\n \n+    #[inline]\n+    fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Self::Error>\n+        where K: DeserializeSeed\n+    {\n+        (**self).visit_key_seed(seed)\n+    }\n+\n+    #[inline]\n+    fn visit_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Self::Error>\n+        where V: DeserializeSeed\n+    {\n+        (**self).visit_value_seed(seed)\n+    }\n+\n+    #[inline]\n+    fn visit_seed<K, V>(&mut self, kseed: K, value_seed: V) -> Result<Option<(K::Value, V::Value)>, Self::Error>\n+        where K: DeserializeSeed,\n+              V: DeserializeSeed\n+    {\n+        (**self).visit_seed(kseed, value_seed)\n+    }\n+\n     #[inline]\n     fn visit<K, V>(&mut self) -> Result<Option<(K, V)>, V_::Error>\n         where K: Deserialize,\n@@ -747,6 +1005,13 @@ impl<'a, V_> MapVisitor for &'a mut V_ where V_: MapVisitor {\n         (**self).size_hint()\n     }\n \n+    #[inline]\n+    fn missing_field_seed<V>(&mut self, seed: V, field: &'static str) -> Result<V::Value, Self::Error>\n+        where V: DeserializeSeed\n+    {\n+        (**self).missing_field_seed(seed, field)\n+    }\n+\n     #[inline]\n     fn missing_field<V>(&mut self, field: &'static str) -> Result<V, Self::Error>\n         where V: Deserialize\n@@ -760,7 +1025,7 @@ impl<'a, V_> MapVisitor for &'a mut V_ where V_: MapVisitor {\n /// `EnumVisitor` is a visitor that is created by the `Deserializer` and passed\n /// to the `Deserialize` in order to identify which variant of an enum to\n /// deserialize.\n-pub trait EnumVisitor {\n+pub trait EnumVisitor: Sized {\n     /// The error type that can be returned if some error occurs during deserialization.\n     type Error: Error;\n     /// The `Visitor` that will be used to deserialize the content of the enum\n@@ -768,14 +1033,29 @@ pub trait EnumVisitor {\n     type Variant: VariantVisitor<Error=Self::Error>;\n \n     /// `visit_variant` is called to identify which variant to deserialize.\n+    ///\n+    /// `Deserialize` implementations should typically use\n+    /// `EnumVisitor::visit_variant` instead.\n+    fn visit_variant_seed<V>(self, seed: V) -> Result<(V::Value, Self::Variant), Self::Error>\n+        where V: DeserializeSeed;\n+\n+    /// `visit_variant` is called to identify which variant to deserialize.\n+    ///\n+    /// This method exists as a convenience for `Deserialize` implementations.\n+    /// `EnumVisitor` implementations should not need to override the default\n+    /// behavior.\n+    #[inline]\n     fn visit_variant<V>(self) -> Result<(V, Self::Variant), Self::Error>\n-        where V: Deserialize;\n+        where V: Deserialize\n+    {\n+        self.visit_variant_seed(PhantomData)\n+    }\n }\n \n /// `VariantVisitor` is a visitor that is created by the `Deserializer` and\n /// passed to the `Deserialize` to deserialize the content of a particular enum\n /// variant.\n-pub trait VariantVisitor {\n+pub trait VariantVisitor: Sized {\n     /// The error type that can be returned if some error occurs during deserialization.\n     type Error: Error;\n \n@@ -784,8 +1064,24 @@ pub trait VariantVisitor {\n \n     /// `visit_newtype` is called when deserializing a variant with a single value.\n     /// A good default is often to use the `visit_tuple` method to deserialize a `(value,)`.\n+    ///\n+    /// `Deserialize` implementations should typically use\n+    /// `VariantVisitor::visit_newtype` instead.\n+    fn visit_newtype_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n+        where T: DeserializeSeed;\n+\n+    /// `visit_newtype` is called when deserializing a variant with a single value.\n+    /// A good default is often to use the `visit_tuple` method to deserialize a `(value,)`.\n+    ///\n+    /// This method exists as a convenience for `Deserialize` implementations.\n+    /// `VariantVisitor` implementations should not need to override the default\n+    /// behavior.\n+    #[inline]\n     fn visit_newtype<T>(self) -> Result<T, Self::Error>\n-        where T: Deserialize;\n+        where T: Deserialize\n+    {\n+        self.visit_newtype_seed(PhantomData)\n+    }\n \n     /// `visit_tuple` is called when deserializing a tuple-like variant.\n     /// If no tuple variants are expected, yield a\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex c64724742..9e2bdf76f 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -298,10 +298,10 @@ impl<'a, E> de::EnumVisitor for StrDeserializer<'a, E>\n     type Error = E;\n     type Variant = private::UnitOnly<E>;\n \n-    fn visit_variant<T>(self) -> Result<(T, Self::Variant), Self::Error>\n-        where T: de::Deserialize,\n+    fn visit_variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n+        where T: de::DeserializeSeed,\n     {\n-        de::Deserialize::deserialize(self).map(private::unit_only)\n+        seed.deserialize(self).map(private::unit_only)\n     }\n }\n \n@@ -357,10 +357,10 @@ impl<'a, E> de::EnumVisitor for StringDeserializer<E>\n     type Error = E;\n     type Variant = private::UnitOnly<E>;\n \n-    fn visit_variant<T>(self) -> Result<(T, Self::Variant), Self::Error>\n-        where T: de::Deserialize,\n+    fn visit_variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n+        where T: de::DeserializeSeed,\n     {\n-        de::Deserialize::deserialize(self).map(private::unit_only)\n+        seed.deserialize(self).map(private::unit_only)\n     }\n }\n \n@@ -419,10 +419,10 @@ impl<'a, E> de::EnumVisitor for CowStrDeserializer<'a, E>\n     type Error = E;\n     type Variant = private::UnitOnly<E>;\n \n-    fn visit_variant<T>(self) -> Result<(T, Self::Variant), Self::Error>\n-        where T: de::Deserialize,\n+    fn visit_variant_seed<T>(self, seed: T) -> Result<(T::Value, Self::Variant), Self::Error>\n+        where T: de::DeserializeSeed,\n     {\n-        de::Deserialize::deserialize(self).map(private::unit_only)\n+        seed.deserialize(self).map(private::unit_only)\n     }\n }\n \n@@ -480,13 +480,13 @@ impl<I, T, E> de::SeqVisitor for SeqDeserializer<I, E>\n {\n     type Error = E;\n \n-    fn visit<V>(&mut self) -> Result<Option<V>, Self::Error>\n-        where V: de::Deserialize\n+    fn visit_seed<V>(&mut self, seed: V) -> Result<Option<V::Value>, Self::Error>\n+        where V: de::DeserializeSeed\n     {\n         match self.iter.next() {\n             Some(value) => {\n                 self.len -= 1;\n-                de::Deserialize::deserialize(value.into_deserializer()).map(Some)\n+                seed.deserialize(value.into_deserializer()).map(Some)\n             }\n             None => Ok(None),\n         }\n@@ -687,24 +687,24 @@ impl<I, K, V, E> de::MapVisitor for MapDeserializer<I, K, V, E>\n {\n     type Error = E;\n \n-    fn visit_key<T>(&mut self) -> Result<Option<T>, Self::Error>\n-        where T: de::Deserialize,\n+    fn visit_key_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+        where T: de::DeserializeSeed,\n     {\n         match self.next() {\n             Some((key, value)) => {\n                 self.value = Some(value);\n-                de::Deserialize::deserialize(key.into_deserializer()).map(Some)\n+                seed.deserialize(key.into_deserializer()).map(Some)\n             }\n             None => Ok(None),\n         }\n     }\n \n-    fn visit_value<T>(&mut self) -> Result<T, Self::Error>\n-        where T: de::Deserialize,\n+    fn visit_value_seed<T>(&mut self, seed: T) -> Result<T::Value, Self::Error>\n+        where T: de::DeserializeSeed,\n     {\n         match self.value.take() {\n             Some(value) => {\n-                de::Deserialize::deserialize(value.into_deserializer())\n+                seed.deserialize(value.into_deserializer())\n             }\n             None => {\n                 Err(de::Error::end_of_stream())\n@@ -712,14 +712,14 @@ impl<I, K, V, E> de::MapVisitor for MapDeserializer<I, K, V, E>\n         }\n     }\n \n-    fn visit<TK, TV>(&mut self) -> Result<Option<(TK, TV)>, Self::Error>\n-        where TK: de::Deserialize,\n-              TV: de::Deserialize\n+    fn visit_seed<TK, TV>(&mut self, kseed: TK, vseed: TV) -> Result<Option<(TK::Value, TV::Value)>, Self::Error>\n+        where TK: de::DeserializeSeed,\n+              TV: de::DeserializeSeed\n     {\n         match self.next() {\n             Some((key, value)) => {\n-                let key = try!(de::Deserialize::deserialize(key.into_deserializer()));\n-                let value = try!(de::Deserialize::deserialize(value.into_deserializer()));\n+                let key = try!(kseed.deserialize(key.into_deserializer()));\n+                let value = try!(vseed.deserialize(value.into_deserializer()));\n                 Ok(Some((key, value)))\n             }\n             None => Ok(None)\n@@ -741,13 +741,13 @@ impl<I, K, V, E> de::SeqVisitor for MapDeserializer<I, K, V, E>\n {\n     type Error = E;\n \n-    fn visit<T>(&mut self) -> Result<Option<T>, Self::Error>\n-        where T: de::Deserialize,\n+    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+        where T: de::DeserializeSeed,\n     {\n         match self.next() {\n             Some((k, v)) => {\n                 let de = PairDeserializer(k, v, PhantomData);\n-                de::Deserialize::deserialize(de).map(Some)\n+                seed.deserialize(de).map(Some)\n             }\n             None => Ok(None),\n         }\n@@ -813,13 +813,13 @@ impl<A, B, E> de::SeqVisitor for PairVisitor<A, B, E>\n {\n     type Error = E;\n \n-    fn visit<T>(&mut self) -> Result<Option<T>, Self::Error>\n-        where T: de::Deserialize,\n+    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Self::Error>\n+        where T: de::DeserializeSeed,\n     {\n         if let Some(k) = self.0.take() {\n-            de::Deserialize::deserialize(k.into_deserializer()).map(Some)\n+            seed.deserialize(k.into_deserializer()).map(Some)\n         } else if let Some(v) = self.1.take() {\n-            de::Deserialize::deserialize(v.into_deserializer()).map(Some)\n+            seed.deserialize(v.into_deserializer()).map(Some)\n         } else {\n             Ok(None)\n         }\n@@ -995,8 +995,8 @@ mod private {\n             Ok(())\n         }\n \n-        fn visit_newtype<T>(self) -> Result<T, Self::Error>\n-            where T: de::Deserialize,\n+        fn visit_newtype_seed<T>(self, _seed: T) -> Result<T::Value, Self::Error>\n+            where T: de::DeserializeSeed,\n         {\n             Err(de::Error::invalid_type(de::Type::NewtypeVariant))\n         }\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 849bdf27c..3630d7247 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -3,6 +3,7 @@ use std::iter;\n use serde::de::{\n     self,\n     Deserialize,\n+    DeserializeSeed,\n     EnumVisitor,\n     MapVisitor,\n     SeqVisitor,\n@@ -496,14 +497,14 @@ impl<'a, I> SeqVisitor for DeserializerSeqVisitor<'a, I>\n {\n     type Error = Error;\n \n-    fn visit<T>(&mut self) -> Result<Option<T>, Error>\n-        where T: Deserialize,\n+    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n+        where T: DeserializeSeed,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::SeqSep) => {\n                 self.de.tokens.next();\n                 self.len = self.len.map(|len| len - 1);\n-                Deserialize::deserialize(&mut *self.de).map(Some)\n+                seed.deserialize(&mut *self.de).map(Some)\n             }\n             Some(&Token::SeqEnd) => Ok(None),\n             Some(_) => {\n@@ -532,14 +533,14 @@ impl<'a, I> SeqVisitor for DeserializerArrayVisitor<'a, I>\n {\n     type Error = Error;\n \n-    fn visit<T>(&mut self) -> Result<Option<T>, Error>\n-        where T: Deserialize,\n+    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n+        where T: DeserializeSeed,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::SeqSep) => {\n                 self.de.tokens.next();\n                 self.len -= 1;\n-                Deserialize::deserialize(&mut *self.de).map(Some)\n+                seed.deserialize(&mut *self.de).map(Some)\n             }\n             Some(&Token::SeqEnd) => Ok(None),\n             Some(_) => {\n@@ -567,14 +568,14 @@ impl<'a, I> SeqVisitor for DeserializerTupleVisitor<'a, I>\n {\n     type Error = Error;\n \n-    fn visit<T>(&mut self) -> Result<Option<T>, Error>\n-        where T: Deserialize,\n+    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n+        where T: DeserializeSeed,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::TupleSep) => {\n                 self.de.tokens.next();\n                 self.len -= 1;\n-                Deserialize::deserialize(&mut *self.de).map(Some)\n+                seed.deserialize(&mut *self.de).map(Some)\n             }\n             Some(&Token::TupleEnd) => Ok(None),\n             Some(_) => {\n@@ -602,14 +603,14 @@ impl<'a, I> SeqVisitor for DeserializerTupleStructVisitor<'a, I>\n {\n     type Error = Error;\n \n-    fn visit<T>(&mut self) -> Result<Option<T>, Error>\n-        where T: Deserialize,\n+    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n+        where T: DeserializeSeed,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::TupleStructSep) => {\n                 self.de.tokens.next();\n                 self.len -= 1;\n-                Deserialize::deserialize(&mut *self.de).map(Some)\n+                seed.deserialize(&mut *self.de).map(Some)\n             }\n             Some(&Token::TupleStructEnd) => Ok(None),\n             Some(_) => {\n@@ -637,14 +638,14 @@ impl<'a, I> SeqVisitor for DeserializerVariantSeqVisitor<'a, I>\n {\n     type Error = Error;\n \n-    fn visit<T>(&mut self) -> Result<Option<T>, Error>\n-        where T: Deserialize,\n+    fn visit_seed<T>(&mut self, seed: T) -> Result<Option<T::Value>, Error>\n+        where T: DeserializeSeed,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumSeqSep) => {\n                 self.de.tokens.next();\n                 self.len = self.len.map(|len| len - 1);\n-                Deserialize::deserialize(&mut *self.de).map(Some)\n+                seed.deserialize(&mut *self.de).map(Some)\n             }\n             Some(&Token::EnumSeqEnd) => Ok(None),\n             Some(_) => {\n@@ -673,14 +674,14 @@ impl<'a, I> MapVisitor for DeserializerMapVisitor<'a, I>\n {\n     type Error = Error;\n \n-    fn visit_key<K>(&mut self) -> Result<Option<K>, Error>\n-        where K: Deserialize,\n+    fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n+        where K: DeserializeSeed,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::MapSep) => {\n                 self.de.tokens.next();\n                 self.len = self.len.map(|len| if len > 0 { len - 1} else { 0 });\n-                Deserialize::deserialize(&mut *self.de).map(Some)\n+                seed.deserialize(&mut *self.de).map(Some)\n             }\n             Some(&Token::MapEnd) => Ok(None),\n             Some(_) => {\n@@ -691,10 +692,10 @@ impl<'a, I> MapVisitor for DeserializerMapVisitor<'a, I>\n         }\n     }\n \n-    fn visit_value<V>(&mut self) -> Result<V, Error>\n-        where V: Deserialize,\n+    fn visit_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n+        where V: DeserializeSeed,\n     {\n-        Deserialize::deserialize(&mut *self.de)\n+        seed.deserialize(&mut *self.de)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -715,14 +716,14 @@ impl<'a, I> MapVisitor for DeserializerStructVisitor<'a, I>\n {\n     type Error = Error;\n \n-    fn visit_key<K>(&mut self) -> Result<Option<K>, Error>\n-        where K: Deserialize,\n+    fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n+        where K: DeserializeSeed,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::StructSep) => {\n                 self.de.tokens.next();\n                 self.len = self.len.saturating_sub(1);\n-                Deserialize::deserialize(&mut *self.de).map(Some)\n+                seed.deserialize(&mut *self.de).map(Some)\n             }\n             Some(&Token::StructEnd) => Ok(None),\n             Some(_) => {\n@@ -733,10 +734,10 @@ impl<'a, I> MapVisitor for DeserializerStructVisitor<'a, I>\n         }\n     }\n \n-    fn visit_value<V>(&mut self) -> Result<V, Error>\n-        where V: Deserialize,\n+    fn visit_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n+        where V: DeserializeSeed,\n     {\n-        Deserialize::deserialize(&mut *self.de)\n+        seed.deserialize(&mut *self.de)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -756,8 +757,8 @@ impl<'a, I> EnumVisitor for DeserializerEnumVisitor<'a, I>\n     type Error = Error;\n     type Variant = Self;\n \n-    fn visit_variant<V>(self) -> Result<(V, Self), Error>\n-        where V: Deserialize,\n+    fn visit_variant_seed<V>(self, seed: V) -> Result<(V::Value, Self), Error>\n+        where V: DeserializeSeed,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumUnit(_, v))\n@@ -765,11 +766,11 @@ impl<'a, I> EnumVisitor for DeserializerEnumVisitor<'a, I>\n             | Some(&Token::EnumSeqStart(_, v, _))\n             | Some(&Token::EnumMapStart(_, v, _)) => {\n                 let de = v.into_deserializer();\n-                let value = try!(Deserialize::deserialize(de));\n+                let value = try!(seed.deserialize(de));\n                 Ok((value, self))\n             }\n             Some(_) => {\n-                let value = try!(Deserialize::deserialize(&mut *self.de));\n+                let value = try!(seed.deserialize(&mut *self.de));\n                 Ok((value, self))\n             }\n             None => Err(Error::EndOfStream),\n@@ -795,16 +796,16 @@ impl<'a, I> VariantVisitor for DeserializerEnumVisitor<'a, I>\n         }\n     }\n \n-    fn visit_newtype<T>(self) -> Result<T, Self::Error>\n-        where T: Deserialize,\n+    fn visit_newtype_seed<T>(self, seed: T) -> Result<T::Value, Self::Error>\n+        where T: DeserializeSeed,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumNewType(_, _)) => {\n                 self.de.tokens.next();\n-                Deserialize::deserialize(self.de)\n+                seed.deserialize(self.de)\n             }\n             Some(_) => {\n-                Deserialize::deserialize(self.de)\n+                seed.deserialize(self.de)\n             }\n             None => Err(Error::EndOfStream),\n         }\n@@ -885,14 +886,14 @@ impl<'a, I> MapVisitor for DeserializerVariantMapVisitor<'a, I>\n {\n     type Error = Error;\n \n-    fn visit_key<K>(&mut self) -> Result<Option<K>, Error>\n-        where K: Deserialize,\n+    fn visit_key_seed<K>(&mut self, seed: K) -> Result<Option<K::Value>, Error>\n+        where K: DeserializeSeed,\n     {\n         match self.de.tokens.peek() {\n             Some(&Token::EnumMapSep) => {\n                 self.de.tokens.next();\n                 self.len = self.len.map(|len| if len > 0 { len - 1} else { 0 });\n-                Deserialize::deserialize(&mut *self.de).map(Some)\n+                seed.deserialize(&mut *self.de).map(Some)\n             }\n             Some(&Token::EnumMapEnd) => Ok(None),\n             Some(_) => {\n@@ -903,10 +904,10 @@ impl<'a, I> MapVisitor for DeserializerVariantMapVisitor<'a, I>\n         }\n     }\n \n-    fn visit_value<V>(&mut self) -> Result<V, Error>\n-        where V: Deserialize,\n+    fn visit_value_seed<V>(&mut self, seed: V) -> Result<V::Value, Error>\n+        where V: DeserializeSeed,\n     {\n-        Deserialize::deserialize(&mut *self.de)\n+        seed.deserialize(&mut *self.de)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n", "problem_statement": "Stateful deserialization\nIn many places the current Serde API has reasonable support for deserializing in a stateful way - where the deserialization depends on some data structure that previously exists. As a concrete example the following code deserializes a JSON array into a preallocated slice. Something similar could be useful in a time series database that wants to reuse a single buffer rather than allocating a new Vec for each array in the input.\r\n\r\n```rust\r\nextern crate serde;\r\nextern crate serde_json;\r\n\r\nuse serde::de::{Deserialize, Deserializer, Visitor, SeqVisitor};\r\n\r\nfn main() {\r\n    let j = \"[10, 20, 30]\";\r\n    let mut vec = vec![0; 5];\r\n\r\n    deserialize_into_slice(&mut vec, j).unwrap();\r\n\r\n    println!(\"{:?}\", vec); // [10, 20, 30, 0, 0]\r\n}\r\n\r\nfn deserialize_into_slice<T>(out: &mut [T], j: &str) -> Result<(), serde_json::Error>\r\n    where T: Deserialize\r\n{\r\n    struct IntoSlice<'a, T: 'a>(&'a mut [T]);\r\n\r\n    impl<'a, T> Visitor for IntoSlice<'a, T>\r\n        where T: Deserialize\r\n    {\r\n        type Value = ();\r\n\r\n        fn visit_seq<V>(&mut self, mut visitor: V) -> Result<Self::Value, V::Error>\r\n            where V: SeqVisitor\r\n        {\r\n            let mut iter = self.0.iter_mut();\r\n            while let Some(elem) = visitor.visit()? {\r\n                iter.next().map(|spot| *spot = elem);\r\n            }\r\n            visitor.end()\r\n        }\r\n    }\r\n\r\n    let mut deserializer = serde_json::Deserializer::new(j.bytes().map(Ok));\r\n    deserializer.deserialize_seq(IntoSlice(out))\r\n}\r\n```\r\n\r\nIn other places the support is a lot worse. Some libraries ([serde-transcode](https://github.com/sfackler/serde-transcode), [erased-serde](https://github.com/dtolnay/erased-serde)) are able to work around the limitations by using a thread_local stack to pass state into Deserialize::deserialize but this is confusing and unsafe.\r\n\r\nLet's see if we can come up with an API that supports stateful use case in a better way. It may even be possible to prototype a solution as a helper crate which uses thread_local behind the scenes.\r\n\r\nCC @sfackler who has been hoping for progress on this.\n", "hints_text": "This would also enable things like\r\n\r\n```rust\r\n#[derive(Deserialize)]\r\nstruct Foo {\r\n    #[serde(deserialize_keys_using = \"key_deserializer\")]\r\n    bar: Map<String, String>,\r\n}\r\n\r\nfn key_deserializer<D>(d: &mut D) -> Result<String, D::Error>\r\n    where D: Deserializer\r\n{\r\n    // ...\r\n}\r\n```\nThis may be as simple as any place we do `fn<T: Deserialize>(...) -> Result<T>`, instead doing `fn<X: DeserializeState>(x: X, ...) -> Result<X::Value>`.\r\n\r\nThen providing:\r\n\r\n```rust\r\npub use std::marker::PhantomData as Stateless;\r\n\r\nimpl<T> DeserializeState for Stateless<T>\r\n    where T: Deserialize\r\n{\r\n    type Value = T;\r\n\r\n    fn deserialize<D>(self, deserializer: &mut D) -> Result<Self::Value, D::Error>\r\n        where D: Deserializer\r\n    {\r\n        T::deserialize(deserializer)\r\n    }\r\n}\r\n```\nYep, that's about it I think. I'm writing up a quick `serde-stateful-deserialize` crate right now and I think all it is is the trait definition, that, and a proxy object to use with current serde.\nhttps://github.com/sfackler/serde-stateful-deserialize\nOk, implementation is actually pretty simple! https://github.com/sfackler/serde-stateful-deserialize/blob/master/src/lib.rs\nUsing it in serde-transcode: https://github.com/sfackler/serde-transcode/commit/16b770e3c8637875a45e62c38b6c914911907276\nI updated erased-serde: https://github.com/dtolnay/erased-serde/commit/d3ac4bbf84606c26a8482404667ba508cdbc1e95. It compiles but the tests fail, still investigating. I think I actually rely on there being a stack of states rather than a single one at a time.\nI though I could get away with not needing an explicit stack since the states should be moved out immediately, but that could be wrong?\nIn any case, it's only broken because of the thread_local hack and it would definitely work fine if this were the actual SeqVisitor / MapVisitor API. So far this seems like a promising direction.\r\n\r\nThe next step is to mitigate the damage as much as possible given that the vast majority of calls are going to be with stateless Deserialize.\nThe best name I have so far is `Seed` which is more concise and also more evocative than DeserializeState. It means seed in the same sense that PRNGs have a seed - some initial state that exists before you start using the thing. Also google search for `serde state` returns a bunch of unrelated results, especially since we already  used the word \"state\" in the Serializer. Google search for `serde seed` returns low-quality results which means it will be easy to search for after we add it.\r\n\r\nFor the stateless case I like `Scratch` which means deserialize the thing \"from scratch\" without relying on any pre-existing state. Is this usage confusing for non-native english speakers? `Void` could also be good although it is used by the void crate. That may be less of a concern now that `!` exists and pretty much supersedes `Void`.\r\n\r\nAny other suggestions?\nI personally find `Seed` and `Scratch` too confusing initially. `DeserializeState ` is more verbose, but more straightforward as well\nHow about `Initializer` + `Stateless` or `Factory` + `Stateless`?\r\n\r\nIs it better to scrap the Stateless / Scratch / Void idea and ask people to pass PhantomData directly?", "created_at": "2017-01-19T09:13:57Z"}, {"repo": "serde-rs/serde", "pull_number": 692, "instance_id": "serde-rs__serde-692", "issue_numbers": ["647"], "base_commit": "bc6bc9e3f089e159515349fe5d2e4c673afea803", "patch": "diff --git a/serde/src/bytes.rs b/serde/src/bytes.rs\nindex 574a673d4..8402b4bd1 100644\n--- a/serde/src/bytes.rs\n+++ b/serde/src/bytes.rs\n@@ -234,7 +234,7 @@ mod bytebuf {\n         fn deserialize<D>(deserializer: D) -> Result<ByteBuf, D::Error>\n             where D: de::Deserializer\n         {\n-            deserializer.deserialize_bytes(ByteBufVisitor)\n+            deserializer.deserialize_byte_buf(ByteBufVisitor)\n         }\n     }\n }\ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex af488dd42..f6307eabe 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -174,6 +174,9 @@ pub enum Type {\n \n     /// Represents a `&[u8]` type.\n     Bytes,\n+\n+    /// Represents a `Vec<u8>` type.\n+    ByteBuf,\n }\n \n impl fmt::Display for Type {\n@@ -212,6 +215,7 @@ impl fmt::Display for Type {\n             Type::UnitVariant    => \"unit variant\",\n             Type::NewtypeVariant => \"newtype variant\",\n             Type::Bytes          => \"bytes\",\n+            Type::ByteBuf        => \"bytes buf\",\n         };\n         display.fmt(formatter)\n     }\n@@ -343,12 +347,19 @@ pub trait Deserializer {\n                                      visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor;\n \n-    /// This method hints that the `Deserialize` type is expecting a `Vec<u8>`. This allows\n+    /// This method hints that the `Deserialize` type is expecting a `&[u8]`. This allows\n     /// deserializers that provide a custom byte vector serialization to properly deserialize the\n     /// type.\n     fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n         where V: Visitor;\n \n+    /// This method hints that the `Deserialize` type is expecting a `Vec<u8>`. This allows\n+    /// deserializers that provide a custom byte vector serialization to properly deserialize the\n+    /// type and prevent needless intermediate allocations that would occur when going through\n+    /// `&[u8]`.\n+    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n+        where V: Visitor;\n+\n     /// This method hints that the `Deserialize` type is expecting a map of values. This allows\n     /// deserializers to parse sequences that aren't tagged as maps.\n     fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex 52342cec6..c64724742 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -181,7 +181,7 @@ impl<E> de::Deserializer for UnitDeserializer<E>\n     forward_to_deserialize! {\n         bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n         unit seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple enum ignored_any\n+        tuple_struct struct struct_field tuple enum ignored_any byte_buf\n     }\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n@@ -223,7 +223,7 @@ macro_rules! primitive_deserializer {\n                 bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str\n                 string unit option seq seq_fixed_size bytes map unit_struct\n                 newtype_struct tuple_struct struct struct_field tuple enum\n-                ignored_any\n+                ignored_any byte_buf\n             }\n \n             fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n@@ -288,7 +288,7 @@ impl<'a, E> de::Deserializer for StrDeserializer<'a, E>\n     forward_to_deserialize! {\n         bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n         unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple ignored_any\n+        tuple_struct struct struct_field tuple ignored_any byte_buf\n     }\n }\n \n@@ -346,7 +346,7 @@ impl<E> de::Deserializer for StringDeserializer<E>\n     forward_to_deserialize! {\n         bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n         unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple ignored_any\n+        tuple_struct struct struct_field tuple ignored_any byte_buf\n     }\n }\n \n@@ -408,7 +408,7 @@ impl<'a, E> de::Deserializer for CowStrDeserializer<'a, E>\n     forward_to_deserialize! {\n         bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n         unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple ignored_any\n+        tuple_struct struct struct_field tuple ignored_any byte_buf\n     }\n }\n \n@@ -469,7 +469,7 @@ impl<I, T, E> de::Deserializer for SeqDeserializer<I, E>\n     forward_to_deserialize! {\n         bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n         unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple enum ignored_any\n+        tuple_struct struct struct_field tuple enum ignored_any byte_buf\n     }\n }\n \n@@ -572,7 +572,7 @@ impl<V_, E> de::Deserializer for SeqVisitorDeserializer<V_, E>\n     forward_to_deserialize! {\n         bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n         unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple enum ignored_any\n+        tuple_struct struct struct_field tuple enum ignored_any byte_buf\n     }\n }\n \n@@ -675,7 +675,7 @@ impl<I, K, V, E> de::Deserializer for MapDeserializer<I, K, V, E>\n     forward_to_deserialize! {\n         bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n         unit option bytes map unit_struct newtype_struct tuple_struct struct\n-        struct_field tuple enum ignored_any\n+        struct_field tuple enum ignored_any byte_buf\n     }\n }\n \n@@ -772,7 +772,7 @@ impl<A, B, E> de::Deserializer for PairDeserializer<A, B, E>\n     forward_to_deserialize! {\n         bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n         unit option bytes map unit_struct newtype_struct tuple_struct struct\n-        struct_field tuple enum ignored_any\n+        struct_field tuple enum ignored_any byte_buf\n     }\n \n     fn deserialize<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n@@ -901,7 +901,7 @@ impl<V_, E> de::Deserializer for MapVisitorDeserializer<V_, E>\n     forward_to_deserialize! {\n         bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n         unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple enum ignored_any\n+        tuple_struct struct struct_field tuple enum ignored_any byte_buf\n     }\n }\n \n@@ -934,7 +934,7 @@ impl<'a, E> de::Deserializer for BytesDeserializer<'a, E>\n     forward_to_deserialize! {\n         bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n         unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple enum ignored_any\n+        tuple_struct struct struct_field tuple enum ignored_any byte_buf\n     }\n }\n \n@@ -970,7 +970,7 @@ impl<E> de::Deserializer for ByteBufDeserializer<E>\n     forward_to_deserialize! {\n         bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 char str string\n         unit option seq seq_fixed_size bytes map unit_struct newtype_struct\n-        tuple_struct struct struct_field tuple enum ignored_any\n+        tuple_struct struct struct_field tuple enum ignored_any byte_buf\n     }\n }\n \ndiff --git a/serde/src/macros.rs b/serde/src/macros.rs\nindex 2580980f3..447181087 100644\n--- a/serde/src/macros.rs\n+++ b/serde/src/macros.rs\n@@ -92,6 +92,9 @@ macro_rules! forward_to_deserialize_helper {\n     (bytes) => {\n         forward_to_deserialize_method!{deserialize_bytes()}\n     };\n+    (byte_buf) => {\n+        forward_to_deserialize_method!{deserialize_byte_buf()}\n+    };\n     (map) => {\n         forward_to_deserialize_method!{deserialize_map()}\n     };\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 80ba9e803..849bdf27c 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -160,6 +160,10 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n         where __V: de::Visitor {\n         self.deserialize(visitor)\n     }\n+    fn deserialize_byte_buf<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n+        where __V: de::Visitor {\n+        self.deserialize(visitor)\n+    }\n     fn deserialize_ignored_any<__V>(self, visitor: __V) -> Result<__V::Value, Self::Error>\n         where __V: de::Visitor {\n         self.deserialize(visitor)\n@@ -250,6 +254,7 @@ impl<'a, I> de::Deserializer for &'a mut Deserializer<I>\n             Some(Token::Str(v)) => visitor.visit_str(v),\n             Some(Token::String(v)) => visitor.visit_string(v),\n             Some(Token::Bytes(v)) => visitor.visit_bytes(v),\n+            Some(Token::ByteBuf(v)) => visitor.visit_byte_buf(v),\n             Some(Token::Option(false)) => visitor.visit_none(),\n             Some(Token::Option(true)) => visitor.visit_some(self),\n             Some(Token::Unit) => visitor.visit_unit(),\ndiff --git a/serde_test/src/token.rs b/serde_test/src/token.rs\nindex e4b3a8253..b8bd23c66 100644\n--- a/serde_test/src/token.rs\n+++ b/serde_test/src/token.rs\n@@ -17,6 +17,7 @@ pub enum Token<'a> {\n     Str(&'a str),\n     String(String),\n     Bytes(&'a [u8]),\n+    ByteBuf(Vec<u8>),\n \n     Option(bool),\n \ndiff --git a/testing/tests/test_bytes.rs b/testing/tests/test_bytes.rs\nindex 6968f9001..86067627c 100644\n--- a/testing/tests/test_bytes.rs\n+++ b/testing/tests/test_bytes.rs\n@@ -15,6 +15,7 @@ fn test_bytes() {\n fn test_byte_buf() {\n     let empty = ByteBuf::new();\n     assert_tokens(&empty, &[Token::Bytes(b\"\")]);\n+    assert_de_tokens(&empty, &[Token::ByteBuf(Vec::new())]);\n     assert_de_tokens(&empty, &[Token::Str(\"\")]);\n     assert_de_tokens(&empty, &[Token::String(String::new())]);\n     assert_de_tokens(&empty, &[\n@@ -28,6 +29,7 @@ fn test_byte_buf() {\n \n     let buf = ByteBuf::from(vec![65, 66, 67]);\n     assert_tokens(&buf, &[Token::Bytes(b\"ABC\")]);\n+    assert_de_tokens(&buf, &[Token::ByteBuf(vec![65, 66, 67])]);\n     assert_de_tokens(&buf, &[Token::Str(\"ABC\")]);\n     assert_de_tokens(&buf, &[Token::String(\"ABC\".to_owned())]);\n     assert_de_tokens(&buf, &[\n", "problem_statement": "Deserializer::deserialize_byte_buf\nFor strings we have deserialize_str and deserialize_string which allows the Deserialize to indicate to the Deserializer whether it would prefer to take ownership of the data. Correspondingly we have Visitor::visit_str and visit_string. Visitor also has visit_bytes and visit_byte_buf but Deserializer only has deserialize_bytes. There is no way to indicate the Deserialize's preference around ownership.\r\n\r\nWe could add this with a default implementation of forwarding to deserialize_bytes, then remove the default in a breaking change.\n", "hints_text": "Correspondingly - we need to add `serde_test::Token::ByteBuf`.", "created_at": "2017-01-16T15:59:09Z"}, {"repo": "serde-rs/serde", "pull_number": 684, "instance_id": "serde-rs__serde-684", "issue_numbers": ["656"], "base_commit": "88a4ed9cd72c7901b025dd8c8d86c69cfc6b157f", "patch": "diff --git a/.travis.yml b/.travis.yml\nindex 87e33f84b..9ef108a71 100644\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -19,8 +19,8 @@ script:\n - (cd testing && travis-cargo --skip nightly test)\n - (cd testing && travis-cargo --only nightly test -- --features unstable-testing)\n - (cd serde_derive && travis-cargo --only nightly test)\n-- (cd examples/serde-syntex-example && travis-cargo --skip nightly run)\n-- (cd examples/serde-syntex-example && travis-cargo --only nightly run -- --no-default-features --features unstable)\n+#- (cd examples/serde-syntex-example && travis-cargo --skip nightly run)\n+#- (cd examples/serde-syntex-example && travis-cargo --only nightly run -- --no-default-features --features unstable)\n - (cd serde && travis-cargo --only stable doc)\n env:\n   global:\ndiff --git a/serde/src/bytes.rs b/serde/src/bytes.rs\nindex 988c24a55..5fa995fb4 100644\n--- a/serde/src/bytes.rs\n+++ b/serde/src/bytes.rs\n@@ -199,8 +199,6 @@ mod bytebuf {\n                 values.push(value);\n             }\n \n-            try!(visitor.end());\n-\n             Ok(ByteBuf::from(values))\n         }\n \ndiff --git a/serde/src/de/impls.rs b/serde/src/de/impls.rs\nindex b6c67451a..5f70466f5 100644\n--- a/serde/src/de/impls.rs\n+++ b/serde/src/de/impls.rs\n@@ -88,10 +88,10 @@ impl Visitor for UnitVisitor {\n         Ok(())\n     }\n \n-    fn visit_seq<V>(&mut self, mut visitor: V) -> Result<(), V::Error>\n+    fn visit_seq<V>(&mut self, _: V) -> Result<(), V::Error>\n         where V: SeqVisitor,\n     {\n-        visitor.end()\n+        Ok(())\n     }\n }\n \n@@ -433,8 +433,6 @@ macro_rules! seq_impl {\n                     $insert(&mut values, value);\n                 }\n \n-                try!($visitor.end());\n-\n                 Ok(values)\n             }\n         }\n@@ -540,10 +538,9 @@ impl<T> Visitor for ArrayVisitor<[T; 0]> where T: Deserialize {\n     }\n \n     #[inline]\n-    fn visit_seq<V>(&mut self, mut visitor: V) -> Result<[T; 0], V::Error>\n+    fn visit_seq<V>(&mut self, _: V) -> Result<[T; 0], V::Error>\n         where V: SeqVisitor,\n     {\n-        try!(visitor.end());\n         Ok([])\n     }\n }\n@@ -575,8 +572,6 @@ macro_rules! array_impls {\n                         };\n                     )+\n \n-                    try!(visitor.end());\n-\n                     Ok([$($name),+])\n                 }\n             }\n@@ -661,8 +656,6 @@ macro_rules! tuple_impls {\n                         };\n                     )+\n \n-                    try!(visitor.end());\n-\n                     Ok(($($name,)+))\n                 }\n             }\n@@ -746,8 +739,6 @@ macro_rules! map_impl {\n                     values.insert(key, value);\n                 }\n \n-                try!($visitor.end());\n-\n                 Ok(values)\n             }\n         }\n@@ -1034,18 +1025,15 @@ impl Deserialize for Duration {\n                 let secs: u64 = match try!(visitor.visit()) {\n                     Some(value) => value,\n                     None => {\n-                        try!(visitor.end());\n                         return Err(Error::invalid_length(0));\n                     }\n                 };\n                 let nanos: u32 = match try!(visitor.visit()) {\n                     Some(value) => value,\n                     None => {\n-                        try!(visitor.end());\n                         return Err(Error::invalid_length(1));\n                     }\n                 };\n-                try!(visitor.end());\n                 Ok(Duration::new(secs, nanos))\n             }\n \n@@ -1070,7 +1058,6 @@ impl Deserialize for Duration {\n                         }\n                     }\n                 }\n-                try!(visitor.end());\n                 let secs = match secs {\n                     Some(secs) => secs,\n                     None => try!(visitor.missing_field(\"secs\")),\n@@ -1274,8 +1261,6 @@ impl Deserialize for IgnoredAny {\n                 while let Some(_) = try!(visitor.visit::<IgnoredAny>()) {\n                     // Gobble\n                 }\n-\n-                try!(visitor.end());\n                 Ok(IgnoredAny)\n             }\n \n@@ -1286,8 +1271,6 @@ impl Deserialize for IgnoredAny {\n                 while let Some((_, _)) = try!(visitor.visit::<IgnoredAny, IgnoredAny>()) {\n                     // Gobble\n                 }\n-\n-                try!(visitor.end());\n                 Ok(IgnoredAny)\n             }\n \ndiff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex c4bb1fc04..bd3b2a7c1 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -635,9 +635,6 @@ pub trait SeqVisitor {\n     fn visit<T>(&mut self) -> Result<Option<T>, Self::Error>\n         where T: Deserialize;\n \n-    /// This signals to the `SeqVisitor` that the `Visitor` does not expect any more items.\n-    fn end(&mut self) -> Result<(), Self::Error>;\n-\n     /// Return the lower and upper bound of items remaining in the sequence.\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -655,11 +652,6 @@ impl<'a, V> SeqVisitor for &'a mut V where V: SeqVisitor {\n         (**self).visit()\n     }\n \n-    #[inline]\n-    fn end(&mut self) -> Result<(), V::Error> {\n-        (**self).end()\n-    }\n-\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (**self).size_hint()\n@@ -700,9 +692,6 @@ pub trait MapVisitor {\n     fn visit_value<V>(&mut self) -> Result<V, Self::Error>\n         where V: Deserialize;\n \n-    /// This signals to the `MapVisitor` that the `Visitor` does not expect any more items.\n-    fn end(&mut self) -> Result<(), Self::Error>;\n-\n     /// Return the lower and upper bound of items remaining in the sequence.\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -742,11 +731,6 @@ impl<'a, V_> MapVisitor for &'a mut V_ where V_: MapVisitor {\n         (**self).visit_value()\n     }\n \n-    #[inline]\n-    fn end(&mut self) -> Result<(), V_::Error> {\n-        (**self).end()\n-    }\n-\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (**self).size_hint()\ndiff --git a/serde/src/de/value.rs b/serde/src/de/value.rs\nindex def6814e5..c97e70b7d 100644\n--- a/serde/src/de/value.rs\n+++ b/serde/src/de/value.rs\n@@ -41,7 +41,7 @@ use error;\n use core::fmt;\n use core::marker::PhantomData;\n \n-use de;\n+use de::{self, SeqVisitor};\n use bytes;\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -543,7 +543,12 @@ impl<I, T, E> de::Deserializer for SeqDeserializer<I, E>\n     fn deserialize<V>(&mut self, mut visitor: V) -> Result<V::Value, Self::Error>\n         where V: de::Visitor,\n     {\n-        visitor.visit_seq(self)\n+        let v = try!(visitor.visit_seq(&mut *self));\n+        if self.len == 0 {\n+            Ok(v)\n+        } else {\n+            Err(de::Error::invalid_length(self.len))\n+        }\n     }\n \n     forward_to_deserialize! {\n@@ -573,14 +578,6 @@ impl<I, T, E> de::SeqVisitor for SeqDeserializer<I, E>\n         }\n     }\n \n-    fn end(&mut self) -> Result<(), Self::Error> {\n-        if self.len == 0 {\n-            Ok(())\n-        } else {\n-            Err(de::Error::invalid_length(self.len))\n-        }\n-    }\n-\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.len, Some(self.len))\n     }\n@@ -715,6 +712,13 @@ impl<I, K, V, E> MapDeserializer<I, K, V, E>\n             (k, v)\n         })\n     }\n+\n+    fn end(&mut self) -> Result<(), E> {\n+        match self.len {\n+            Some(len) if len > 0 => Err(de::Error::invalid_length(len)),\n+            _ => Ok(())\n+        }\n+    }\n }\n \n impl<I, K, V, E> de::Deserializer for MapDeserializer<I, K, V, E>\n@@ -728,22 +732,29 @@ impl<I, K, V, E> de::Deserializer for MapDeserializer<I, K, V, E>\n     fn deserialize<V_>(&mut self, mut visitor: V_) -> Result<V_::Value, Self::Error>\n         where V_: de::Visitor,\n     {\n-        visitor.visit_map(self)\n+        let value = try!(visitor.visit_map(&mut *self));\n+        try!(self.end());\n+        Ok(value)\n     }\n \n     fn deserialize_seq<V_>(&mut self, mut visitor: V_) -> Result<V_::Value, Self::Error>\n         where V_: de::Visitor,\n     {\n-        visitor.visit_seq(self)\n+        let value = try!(visitor.visit_seq(&mut *self));\n+        try!(self.end());\n+        Ok(value)\n     }\n \n     fn deserialize_seq_fixed_size<V_>(&mut self, len: usize, mut visitor: V_) -> Result<V_::Value, Self::Error>\n         where V_: de::Visitor,\n     {\n         match self.len {\n-            Some(map_len) if map_len == len => visitor.visit_seq(self),\n-            Some(_) => Err(de::Error::invalid_length(len)),\n-            None => visitor.visit_seq(self),\n+            Some(map_len) if map_len != len => Err(de::Error::invalid_length(len)),\n+            _ => {\n+                let value = try!(visitor.visit_seq(&mut *self));\n+                try!(self.end());\n+                Ok(value)\n+            }\n         }\n     }\n \n@@ -789,13 +800,6 @@ impl<I, K, V, E> de::MapVisitor for MapDeserializer<I, K, V, E>\n         }\n     }\n \n-    fn end(&mut self) -> Result<(), Self::Error> {\n-        match self.len {\n-            Some(len) if len > 0 => Err(de::Error::invalid_length(len)),\n-            _ => Ok(())\n-        }\n-    }\n-\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.len.map_or_else(\n             || self.iter.size_hint(),\n@@ -823,10 +827,6 @@ impl<I, K, V, E> de::SeqVisitor for MapDeserializer<I, K, V, E>\n         }\n     }\n \n-    fn end(&mut self) -> Result<(), Self::Error> {\n-        de::MapVisitor::end(self)\n-    }\n-\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         de::MapVisitor::size_hint(self)\n     }\n@@ -860,7 +860,13 @@ impl<A, B, E> de::Deserializer for PairDeserializer<A, B, E>\n     {\n         match self.0.take() {\n             Some((k, v)) => {\n-                visitor.visit_seq(PairVisitor(Some(k), Some(v), PhantomData))\n+                let mut pair_visitor = PairVisitor(Some(k), Some(v), PhantomData);\n+                let pair = try!(visitor.visit_seq(&mut pair_visitor));\n+                if pair_visitor.1.is_none() {\n+                    Ok(pair)\n+                } else {\n+                    Err(de::Error::invalid_length(pair_visitor.size_hint().0))\n+                }\n             }\n             None => Err(de::Error::end_of_stream()),\n         }\n@@ -900,14 +906,6 @@ impl<A, B, E> de::SeqVisitor for PairVisitor<A, B, E>\n         }\n     }\n \n-    fn end(&mut self) -> Result<(), Self::Error> {\n-        if self.1.is_none() {\n-            Ok(())\n-        } else {\n-            Err(de::Error::invalid_length(self.size_hint().0))\n-        }\n-    }\n-\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = if self.0.is_some() {\n             2\ndiff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex ed4f9e0aa..808bdabcb 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -214,11 +214,10 @@ fn deserialize_unit_struct(\n             }\n \n             #[inline]\n-            fn visit_seq<__V>(&mut self, mut visitor: __V) -> ::std::result::Result<#type_ident, __V::Error>\n+            fn visit_seq<__V>(&mut self, _: __V) -> ::std::result::Result<#type_ident, __V::Error>\n                 where __V: _serde::de::SeqVisitor,\n             {\n-                try!(visitor.end());\n-                self.visit_unit()\n+                Ok(#type_ident)\n             }\n         }\n \n@@ -275,6 +274,13 @@ fn deserialize_tuple(\n         quote!(deserializer.deserialize_tuple_struct(#type_name, #nfields, #visitor_expr))\n     };\n \n+    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n+    let visitor_var = if all_skipped {\n+        quote!(_)\n+    } else {\n+        quote!(mut visitor)\n+    };\n+\n     quote!({\n         #visitor_item\n \n@@ -284,7 +290,7 @@ fn deserialize_tuple(\n             #visit_newtype_struct\n \n             #[inline]\n-            fn visit_seq<__V>(&mut self, mut visitor: __V) -> ::std::result::Result<#ty, __V::Error>\n+            fn visit_seq<__V>(&mut self, #visitor_var: __V) -> ::std::result::Result<#ty, __V::Error>\n                 where __V: _serde::de::SeqVisitor\n             {\n                 #visit_seq\n@@ -332,7 +338,6 @@ fn deserialize_seq(\n                     let #var = match #visit {\n                         Some(value) => { value },\n                         None => {\n-                            try!(visitor.end());\n                             return Err(_serde::de::Error::invalid_length(#index_in_seq));\n                         }\n                     };\n@@ -355,9 +360,6 @@ fn deserialize_seq(\n \n     quote! {\n         #(#let_values)*\n-\n-        try!(visitor.end());\n-\n         Ok(#result)\n     }\n }\n@@ -440,6 +442,13 @@ fn deserialize_struct(\n         }\n     };\n \n+    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n+    let visitor_var = if all_skipped {\n+        quote!(_)\n+    } else {\n+        quote!(mut visitor)\n+    };\n+\n     quote!({\n         #field_visitor\n \n@@ -449,7 +458,7 @@ fn deserialize_struct(\n             type Value = #ty;\n \n             #[inline]\n-            fn visit_seq<__V>(&mut self, mut visitor: __V) -> ::std::result::Result<#ty, __V::Error>\n+            fn visit_seq<__V>(&mut self, #visitor_var: __V) -> ::std::result::Result<#ty, __V::Error>\n                 where __V: _serde::de::SeqVisitor\n             {\n                 #visit_seq\n@@ -842,8 +851,6 @@ fn deserialize_map(\n \n         #match_keys\n \n-        try!(visitor.end());\n-\n         #(#extract_values)*\n \n         Ok(#struct_path { #(#result),* })\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 2ad0c9be1..559e9972d 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -31,76 +31,105 @@ impl<I> Deserializer<I>\n         self.tokens.next()\n     }\n \n+    pub fn expect_token(&mut self, expected: Token) -> Result<(), Error> {\n+        match self.tokens.next() {\n+            Some(token) => {\n+                if expected == token {\n+                    Ok(())\n+                } else {\n+                    Err(Error::UnexpectedToken(token))\n+                }\n+            }\n+            None => Err(Error::EndOfStream),\n+        }\n+    }\n+\n     fn visit_seq<V>(&mut self, len: Option<usize>, mut visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n-        visitor.visit_seq(DeserializerSeqVisitor {\n+        let value = try!(visitor.visit_seq(DeserializerSeqVisitor {\n             de: self,\n             len: len,\n-        })\n+        }));\n+        try!(self.expect_token(Token::SeqEnd));\n+        Ok(value)\n     }\n \n     fn visit_array<V>(&mut self, len: usize, mut visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n-        visitor.visit_seq(DeserializerArrayVisitor {\n+        let value = try!(visitor.visit_seq(DeserializerArrayVisitor {\n             de: self,\n             len: len,\n-        })\n+        }));\n+        try!(self.expect_token(Token::SeqEnd));\n+        Ok(value)\n     }\n \n     fn visit_tuple<V>(&mut self, len: usize, mut visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n-        visitor.visit_seq(DeserializerTupleVisitor {\n+        let value = try!(visitor.visit_seq(DeserializerTupleVisitor {\n             de: self,\n             len: len,\n-        })\n+        }));\n+        try!(self.expect_token(Token::TupleEnd));\n+        Ok(value)\n     }\n \n     fn visit_tuple_struct<V>(&mut self, len: usize, mut visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n-        visitor.visit_seq(DeserializerTupleStructVisitor {\n+        let value = try!(visitor.visit_seq(DeserializerTupleStructVisitor {\n             de: self,\n             len: len,\n-        })\n+        }));\n+        try!(self.expect_token(Token::TupleStructEnd));\n+        Ok(value)\n     }\n \n     fn visit_variant_seq<V>(&mut self, len: Option<usize>, mut visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n-        visitor.visit_seq(DeserializerVariantSeqVisitor {\n+        let value = try!(visitor.visit_seq(DeserializerVariantSeqVisitor {\n             de: self,\n             len: len,\n-        })\n+        }));\n+        try!(self.expect_token(Token::EnumSeqEnd));\n+        Ok(value)\n     }\n \n     fn visit_map<V>(&mut self, len: Option<usize>, mut visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n-        visitor.visit_map(DeserializerMapVisitor {\n+        let value = try!(visitor.visit_map(DeserializerMapVisitor {\n             de: self,\n             len: len,\n-        })\n+        }));\n+        try!(self.expect_token(Token::MapEnd));\n+        Ok(value)\n     }\n \n     fn visit_struct<V>(&mut self, fields: &'static [&'static str], mut visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n-        visitor.visit_map(DeserializerStructVisitor {\n+        let value = try!(visitor.visit_map(DeserializerStructVisitor {\n             de: self,\n             len: fields.len(),\n-        })\n+        }));\n+        try!(self.expect_token(Token::StructEnd));\n+        Ok(value)\n     }\n \n     fn visit_variant_map<V>(&mut self, len: Option<usize>, mut visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n-        visitor.visit_map(DeserializerVariantMapVisitor {\n+        let value = try!(visitor.visit_map(DeserializerVariantMapVisitor {\n             de: self,\n             len: len,\n-        })\n+        }));\n+        try!(self.expect_token(Token::EnumMapEnd));\n+        Ok(value)\n     }\n }\n \n@@ -478,15 +507,6 @@ impl<'a, I> SeqVisitor for DeserializerSeqVisitor<'a, I>\n         }\n     }\n \n-    fn end(&mut self) -> Result<(), Error> {\n-        //assert_eq!(self.len.unwrap_or(0), 0);\n-        match self.de.tokens.next() {\n-            Some(Token::SeqEnd) => Ok(()),\n-            Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStream),\n-        }\n-    }\n-\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = self.len.unwrap_or(0);\n         (len, self.len)\n@@ -523,15 +543,6 @@ impl<'a, I> SeqVisitor for DeserializerArrayVisitor<'a, I>\n         }\n     }\n \n-    fn end(&mut self) -> Result<(), Error> {\n-        assert_eq!(self.len, 0);\n-        match self.de.tokens.next() {\n-            Some(Token::SeqEnd) => Ok(()),\n-            Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStream),\n-        }\n-    }\n-\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.len, Some(self.len))\n     }\n@@ -567,15 +578,6 @@ impl<'a, I> SeqVisitor for DeserializerTupleVisitor<'a, I>\n         }\n     }\n \n-    fn end(&mut self) -> Result<(), Error> {\n-        assert_eq!(self.len, 0);\n-        match self.de.tokens.next() {\n-            Some(Token::TupleEnd) => Ok(()),\n-            Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStream),\n-        }\n-    }\n-\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.len, Some(self.len))\n     }\n@@ -611,15 +613,6 @@ impl<'a, I> SeqVisitor for DeserializerTupleStructVisitor<'a, I>\n         }\n     }\n \n-    fn end(&mut self) -> Result<(), Error> {\n-        assert_eq!(self.len, 0);\n-        match self.de.tokens.next() {\n-            Some(Token::TupleStructEnd) => Ok(()),\n-            Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStream),\n-        }\n-    }\n-\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.len, Some(self.len))\n     }\n@@ -655,15 +648,6 @@ impl<'a, I> SeqVisitor for DeserializerVariantSeqVisitor<'a, I>\n         }\n     }\n \n-    fn end(&mut self) -> Result<(), Error> {\n-        //assert_eq!(self.len.unwrap_or(0), 0);\n-        match self.de.tokens.next() {\n-            Some(Token::EnumSeqEnd) => Ok(()),\n-            Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStream),\n-        }\n-    }\n-\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = self.len.unwrap_or(0);\n         (len, self.len)\n@@ -706,15 +690,6 @@ impl<'a, I> MapVisitor for DeserializerMapVisitor<'a, I>\n         Ok(try!(Deserialize::deserialize(self.de)))\n     }\n \n-    fn end(&mut self) -> Result<(), Error> {\n-        //assert_eq!(self.len.unwrap_or(0), 0);\n-        match self.de.tokens.next() {\n-            Some(Token::MapEnd) => Ok(()),\n-            Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStream),\n-        }\n-    }\n-\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = self.len.unwrap_or(0);\n         (len, self.len)\n@@ -757,15 +732,6 @@ impl<'a, I> MapVisitor for DeserializerStructVisitor<'a, I>\n         Ok(try!(Deserialize::deserialize(self.de)))\n     }\n \n-    fn end(&mut self) -> Result<(), Error> {\n-        //assert_eq!(self.len.unwrap_or(0), 0);\n-        match self.de.tokens.next() {\n-            Some(Token::StructEnd) => Ok(()),\n-            Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStream),\n-        }\n-    }\n-\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.len, Some(self.len))\n     }\n@@ -928,15 +894,6 @@ impl<'a, I> MapVisitor for DeserializerVariantMapVisitor<'a, I>\n         Ok(try!(Deserialize::deserialize(self.de)))\n     }\n \n-    fn end(&mut self) -> Result<(), Error> {\n-        //assert_eq!(self.len.unwrap_or(0), 0);\n-        match self.de.tokens.next() {\n-            Some(Token::EnumMapEnd) => Ok(()),\n-            Some(token) => Err(Error::UnexpectedToken(token)),\n-            None => Err(Error::EndOfStream),\n-        }\n-    }\n-\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let len = self.len.unwrap_or(0);\n         (len, self.len)\n", "problem_statement": "Simplify contract around SeqVisitor::end() and MapVisitor::end()\nThese are really easy to screw up when implementing visit_seq and visit_map. If you forget to call them, things may work in some formats and fail in really confusing ways in other formats.\r\n\r\nHopefully we can find a way for the type system to enforce correct behavior here.\n", "hints_text": "I think we can just get rid of end() and handle their job inside whatever calls visit_seq or visit_map. ", "created_at": "2017-01-13T18:24:06Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 682, "instance_id": "serde-rs__serde-682", "issue_numbers": ["444"], "base_commit": "c008c6d3a8e5315667c0380df1d91ff1daa5d71d", "patch": "diff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex b2d64a9bf..ed4f9e0aa 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -480,11 +480,14 @@ fn deserialize_item_enum(\n \n     let type_name = item_attrs.name().deserialize_name();\n \n+    let variant_names_idents = variants.iter()\n+        .enumerate()\n+        .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n+        .map(|(i, variant)| (variant.attrs.name().deserialize_name(), field_i(i)))\n+        .collect();\n+\n     let variant_visitor = deserialize_field_visitor(\n-        variants.iter()\n-            .filter(|variant| !variant.attrs.skip_deserializing())\n-            .map(|variant| variant.attrs.name().deserialize_name())\n-            .collect(),\n+        variant_names_idents,\n         item_attrs,\n         true,\n     );\n@@ -496,25 +499,27 @@ fn deserialize_item_enum(\n     };\n \n     // Match arms to extract a variant from a string\n-    let mut variant_arms = vec![];\n-    for (i, variant) in variants.iter().filter(|variant| !variant.attrs.skip_deserializing()).enumerate() {\n-        let variant_name = field_i(i);\n+    let variant_arms = variants.iter()\n+        .enumerate()\n+        .filter(|&(_, variant)| !variant.attrs.skip_deserializing())\n+        .map(|(i, variant)| {\n+            let variant_name = field_i(i);\n \n-        let block = deserialize_variant(\n-            type_ident,\n-            impl_generics,\n-            ty.clone(),\n-            variant,\n-            item_attrs,\n-        );\n+            let block = deserialize_variant(\n+                type_ident,\n+                impl_generics,\n+                ty.clone(),\n+                variant,\n+                item_attrs,\n+            );\n \n-        let arm = quote! {\n-            __Field::#variant_name => #block\n-        };\n-        variant_arms.push(arm);\n-    }\n+            quote! {\n+                __Field::#variant_name => #block\n+            }\n+        });\n \n-    let match_variant = if variant_arms.is_empty() {\n+    let all_skipped = variants.iter().all(|variant| variant.attrs.skip_deserializing());\n+    let match_variant = if all_skipped {\n         // This is an empty enum like `enum Impossible {}` or an enum in which\n         // all variants have `#[serde(skip_deserializing)]`.\n         quote! {\n@@ -628,12 +633,12 @@ fn deserialize_newtype_variant(\n }\n \n fn deserialize_field_visitor(\n-    field_names: Vec<String>,\n+    fields: Vec<(String, Ident)>,\n     item_attrs: &attr::Item,\n     is_variant: bool,\n ) -> Tokens {\n-    // Create the field names for the fields.\n-    let field_idents: &Vec<_> = &(0 .. field_names.len()).map(field_i).collect();\n+    let field_names = fields.iter().map(|&(ref name, _)| name);\n+    let field_idents: &Vec<_> = &fields.iter().map(|&(_, ref ident)| ident).collect();\n \n     let ignore_variant = if is_variant || item_attrs.deny_unknown_fields() {\n         None\n@@ -697,13 +702,14 @@ fn deserialize_struct_visitor(\n     fields: &[Field],\n     item_attrs: &attr::Item,\n ) -> (Tokens, Tokens, Tokens) {\n-    let field_exprs: Vec<_> = fields.iter()\n-        .map(|field| field.attrs.name().deserialize_name())\n+    let field_names_idents = fields.iter()\n+        .enumerate()\n+        .filter(|&(_, field)| !field.attrs.skip_deserializing())\n+        .map(|(i, field)| (field.attrs.name().deserialize_name(), field_i(i)))\n         .collect();\n-    let field_names = field_exprs.clone();\n \n     let field_visitor = deserialize_field_visitor(\n-        field_exprs,\n+        field_names_idents,\n         item_attrs,\n         false,\n     );\n@@ -716,6 +722,7 @@ fn deserialize_struct_visitor(\n         item_attrs,\n     );\n \n+    let field_names = fields.iter().map(|field| field.attrs.name().deserialize_name());\n     let fields_stmt = quote! {\n         const FIELDS: &'static [&'static str] = &[ #(#field_names),* ];\n     };\n@@ -730,16 +737,6 @@ fn deserialize_map(\n     fields: &[Field],\n     item_attrs: &attr::Item,\n ) -> Tokens {\n-    if fields.is_empty() && item_attrs.deny_unknown_fields() {\n-        return quote! {\n-            // FIXME: Once we drop support for Rust 1.15:\n-            // let None::<__Field> = try!(visitor.visit_key());\n-            try!(visitor.visit_key::<__Field>()).map(|impossible| match impossible {});\n-            try!(visitor.end());\n-            Ok(#struct_path {})\n-        };\n-    }\n-\n     // Create the field names for the fields.\n     let fields_names: Vec<_> = fields.iter()\n         .enumerate()\n@@ -789,18 +786,6 @@ fn deserialize_map(\n             }\n         });\n \n-    // Match arms to ignore value for fields that have `skip_deserializing`.\n-    // Ignored even if `deny_unknown_fields` is set.\n-    let skipped_arms = fields_names.iter()\n-        .filter(|&&(field, _)| field.attrs.skip_deserializing())\n-        .map(|&(_, ref name)| {\n-            quote! {\n-                __Field::#name => {\n-                    let _ = try!(visitor.visit_value::<_serde::de::impls::IgnoredAny>());\n-                }\n-            }\n-        });\n-\n     // Visit ignored values to consume them\n     let ignored_arm = if item_attrs.deny_unknown_fields() {\n         None\n@@ -810,6 +795,24 @@ fn deserialize_map(\n         })\n     };\n \n+    let all_skipped = fields.iter().all(|field| field.attrs.skip_deserializing());\n+    let match_keys = if item_attrs.deny_unknown_fields() && all_skipped {\n+        quote! {\n+            // FIXME: Once we drop support for Rust 1.15:\n+            // let None::<__Field> = try!(visitor.visit_key());\n+            try!(visitor.visit_key::<__Field>()).map(|impossible| match impossible {});\n+        }\n+    } else {\n+        quote! {\n+            while let Some(key) = try!(visitor.visit_key::<__Field>()) {\n+                match key {\n+                    #(#value_arms)*\n+                    #ignored_arm\n+                }\n+            }\n+        }\n+    };\n+\n     let extract_values = fields_names.iter()\n         .filter(|&&(field, _)| !field.attrs.skip_deserializing())\n         .map(|&(field, ref name)| {\n@@ -837,13 +840,7 @@ fn deserialize_map(\n     quote! {\n         #(#let_values)*\n \n-        while let Some(key) = try!(visitor.visit_key::<__Field>()) {\n-            match key {\n-                #(#value_arms)*\n-                #(#skipped_arms)*\n-                #ignored_arm\n-            }\n-        }\n+        #match_keys\n \n         try!(visitor.end());\n \n", "test_patch": "diff --git a/testing/tests/test_de.rs b/testing/tests/test_de.rs\nindex d1879fe84..3359492e8 100644\n--- a/testing/tests/test_de.rs\n+++ b/testing/tests/test_de.rs\n@@ -32,12 +32,40 @@ struct Struct {\n     c: i32,\n }\n \n+#[derive(PartialEq, Debug, Deserialize)]\n+#[serde(deny_unknown_fields)]\n+struct StructDenyUnknown {\n+    a: i32,\n+    #[serde(skip_deserializing)]\n+    b: i32,\n+}\n+\n+#[derive(PartialEq, Debug, Deserialize)]\n+struct StructSkipAll {\n+    #[serde(skip_deserializing)]\n+    a: i32,\n+}\n+\n+#[derive(PartialEq, Debug, Deserialize)]\n+#[serde(deny_unknown_fields)]\n+struct StructSkipAllDenyUnknown {\n+    #[serde(skip_deserializing)]\n+    a: i32,\n+}\n+\n #[derive(PartialEq, Debug, Deserialize)]\n enum Enum {\n+    #[allow(dead_code)]\n+    #[serde(skip_deserializing)]\n+    Skipped,\n     Unit,\n     Simple(i32),\n     Seq(i32, i32, i32),\n     Map { a: i32, b: i32, c: i32 },\n+}\n+\n+#[derive(PartialEq, Debug, Deserialize)]\n+enum EnumSkipAll {\n     #[allow(dead_code)]\n     #[serde(skip_deserializing)]\n     Skipped,\n@@ -681,6 +709,29 @@ declare_tests! {\n             Token::StructEnd,\n         ],\n     }\n+    test_struct_skip_all {\n+        StructSkipAll { a: 0 } => &[\n+            Token::StructStart(\"StructSkipAll\", 0),\n+            Token::StructEnd,\n+        ],\n+        StructSkipAll { a: 0 } => &[\n+            Token::StructStart(\"StructSkipAll\", 1),\n+                Token::StructSep,\n+                Token::Str(\"a\"),\n+                Token::I32(1),\n+\n+                Token::StructSep,\n+                Token::Str(\"b\"),\n+                Token::I32(2),\n+            Token::StructEnd,\n+        ],\n+    }\n+    test_struct_skip_all_deny_unknown {\n+        StructSkipAllDenyUnknown { a: 0 } => &[\n+            Token::StructStart(\"StructSkipAllDenyUnknown\", 0),\n+            Token::StructEnd,\n+        ],\n+    }\n     test_enum_unit {\n         Enum::Unit => &[\n             Token::EnumUnit(\"Enum\", \"Unit\"),\n@@ -788,6 +839,34 @@ fn test_net_ipaddr() {\n }\n \n declare_error_tests! {\n+    test_unknown_field<StructDenyUnknown> {\n+        &[\n+            Token::StructStart(\"StructDenyUnknown\", 2),\n+                Token::StructSep,\n+                Token::Str(\"a\"),\n+                Token::I32(0),\n+\n+                Token::StructSep,\n+                Token::Str(\"d\"),\n+        ],\n+        Error::UnknownField(\"d\".to_owned()),\n+    }\n+    test_skipped_field_is_unknown<StructDenyUnknown> {\n+        &[\n+            Token::StructStart(\"StructDenyUnknown\", 2),\n+                Token::StructSep,\n+                Token::Str(\"b\"),\n+        ],\n+        Error::UnknownField(\"b\".to_owned()),\n+    }\n+    test_skip_all_deny_unknown<StructSkipAllDenyUnknown> {\n+        &[\n+            Token::StructStart(\"StructSkipAllDenyUnknown\", 1),\n+                Token::StructSep,\n+                Token::Str(\"a\"),\n+        ],\n+        Error::UnknownField(\"a\".to_owned()),\n+    }\n     test_unknown_variant<Enum> {\n         &[\n             Token::EnumUnit(\"Enum\", \"Foo\"),\n@@ -800,6 +879,12 @@ declare_error_tests! {\n         ],\n         Error::UnknownVariant(\"Skipped\".to_owned()),\n     }\n+    test_enum_skip_all<EnumSkipAll> {\n+        &[\n+            Token::EnumUnit(\"EnumSkipAll\", \"Skipped\"),\n+        ],\n+        Error::UnknownVariant(\"Skipped\".to_owned()),\n+    }\n     test_struct_seq_too_long<Struct> {\n         &[\n             Token::SeqStart(Some(4)),\n", "problem_statement": "Fields marked skip_deserializing are ignored even if deny_unknown_fields is set\nI have [this struct definition](https://github.com/sfackler/log4rs/blob/6eea8767b5ed5c014d06685d78a6df8c54147a92/src/file/serde.rs.in#L1-L14). It is configured to derive `Deserialize` and deny unknown fields. I have a field  marked to be skipped, but [the generated implementation](https://github.com/sfackler/log4rs/blob/6eea8767b5ed5c014d06685d78a6df8c54147a92/src/file/serde.rs#L9-L397) appears to [explicitly ignore](https://github.com/sfackler/log4rs/blob/6eea8767b5ed5c014d06685d78a6df8c54147a92/src/file/serde.rs#L347-L350) the skipped field.\n\nI would expect the implementation would treat that field as not even existing, in which case we would see an error if `_p` is referenced in the input being deserialized.\n\n", "hints_text": "@oli-obk @erickt opinion on this?\n\nIt seems like there are two different use cases for `skip_deserializing`.\n1. A field of the struct is not present in the serialized form.\n2. A field of the struct is present in the serialized form but should not be deserialized.\n\nIf we make this change, there would be no way to handle the second type together with `deny_unknown_fields`.\n\nMaybe we need a second attribute to differentiate the two cases.\n\nAs an initial proposal to iterate on, how about the following change:\n- Keep the current behavior of `skip_deserializing` instead of what @sfackler suggests. **\"Skip deserializing\"** means the field may (or may not) be present in the serialized form, even when using `deny_unknown_fields`.\n- Add an attribute `#[serde(not_serialized)]` as the equivalent of the current `#[serde(skip_serializing, skip_deserializing)]` but which behaves the way @sfackler wants when using `deny_unknown_fields`. If a field is **\"not serialized\"**, it is an error for it to show up when deserializing.\n\n@sfackler please confirm that this would fit your use case.\n\n`#[serde(not_serialized)]` would do what I'm looking for, though it seems confusingly similar to the existing modifiers. In what contexts would someone be looking for the \"A field of the struct is present in the serialized form but should not be deserialized.\" use case?\n\n> In what contexts would someone be looking for the \"A field of the struct is present in the serialized form but should not be deserialized.\" use case?\n\nWhen the user doesn't care about the value, but wants to prevent additional fields from being silently ignored through `deny_unknown_fields`, they can do `skip_deserializing`, thus acknowledging that the field is there, but shouldn't trigger the `unknown_fields`\n\nIf the user doesn't care about the value, then it seems a bit unfortunate to have to include the field in the struct at all. It seems like something like `#[serde(deny_unknown_fields(allow = \"foo\"))]` would work better there, right?\n\nindeed\n", "created_at": "2017-01-13T07:29:07Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 681, "instance_id": "serde-rs__serde-681", "issue_numbers": ["559"], "base_commit": "110d36fa1469375ad00dcd0f460451e6e390f1ed", "patch": "diff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex 8eb699701..84cbaa7da 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -503,7 +503,7 @@ fn deserialize_item_enum(\n         true,\n     );\n \n-    let variant_names = variants.iter().map(|variant| variant.ident.to_string());\n+    let variant_names = variants.iter().map(|variant| variant.attrs.name().deserialize_name());\n \n     let variants_stmt = quote! {\n         const VARIANTS: &'static [&'static str] = &[ #(#variant_names),* ];\n@@ -714,9 +714,10 @@ fn deserialize_struct_visitor(\n     fields: &[Field],\n     item_attrs: &attr::Item,\n ) -> (Tokens, Tokens, Tokens) {\n-    let field_exprs = fields.iter()\n+    let field_exprs: Vec<_> = fields.iter()\n         .map(|field| field.attrs.name().deserialize_name())\n         .collect();\n+    let field_names = field_exprs.clone();\n \n     let field_visitor = deserialize_field_visitor(\n         field_exprs,\n@@ -732,10 +733,6 @@ fn deserialize_struct_visitor(\n         item_attrs,\n     );\n \n-    let field_names = fields.iter().map(|field| {\n-        field.ident.clone().expect(\"struct contains unnamed field\").to_string()\n-    });\n-\n     let fields_stmt = quote! {\n         const FIELDS: &'static [&'static str] = &[ #(#field_names),* ];\n     };\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 39e14faaa..2ad0c9be1 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -85,12 +85,12 @@ impl<I> Deserializer<I>\n         })\n     }\n \n-    fn visit_struct<V>(&mut self, len: Option<usize>, mut visitor: V) -> Result<V::Value, Error>\n+    fn visit_struct<V>(&mut self, fields: &'static [&'static str], mut visitor: V) -> Result<V::Value, Error>\n         where V: Visitor,\n     {\n         visitor.visit_map(DeserializerStructVisitor {\n             de: self,\n-            len: len,\n+            len: fields.len(),\n         })\n     }\n \n@@ -433,7 +433,7 @@ impl<I> de::Deserializer for Deserializer<I>\n             Some(&Token::StructStart(n, _)) => {\n                 self.tokens.next();\n                 if name == n {\n-                    self.visit_struct(Some(fields.len()), visitor)\n+                    self.visit_struct(fields, visitor)\n                 } else {\n                     Err(Error::InvalidName(n))\n                 }\n@@ -725,7 +725,7 @@ impl<'a, I> MapVisitor for DeserializerMapVisitor<'a, I>\n \n struct DeserializerStructVisitor<'a, I: 'a> where I: Iterator<Item=Token<'static>> {\n     de: &'a mut Deserializer<I>,\n-    len: Option<usize>,\n+    len: usize,\n }\n \n impl<'a, I> MapVisitor for DeserializerStructVisitor<'a, I>\n@@ -739,7 +739,7 @@ impl<'a, I> MapVisitor for DeserializerStructVisitor<'a, I>\n         match self.de.tokens.peek() {\n             Some(&Token::StructSep) => {\n                 self.de.tokens.next();\n-                self.len = self.len.map(|len| if len > 0 { len - 1} else { 0 });\n+                self.len = self.len.saturating_sub(1);\n                 Ok(Some(try!(Deserialize::deserialize(self.de))))\n             }\n             Some(&Token::StructEnd) => Ok(None),\n@@ -767,8 +767,7 @@ impl<'a, I> MapVisitor for DeserializerStructVisitor<'a, I>\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.len.unwrap_or(0);\n-        (len, self.len)\n+        (self.len, Some(self.len))\n     }\n }\n \n", "problem_statement": "`deserialize_struct` is called with real field names instead of deserializable names\n``` rust\n#[derive(Deserialize)]\npub struct S {\n    #[serde(rename = \"A\")]\n    a: u8,\n    #[serde(skip_deserializing)]\n    b: u8,\n}\n```\n\nI was surprised to see this in the generated code:\n\n``` rust\nconst FIELDS: &'static [&'static str] = &[\"a\", \"b\"];\ndeserializer.deserialize_struct(\"S\", FIELDS, __Visitor)\n```\n\nIf I had been asked to guess, I would have guessed it would be `[\"A\"]` instead of `[\"a\", \"b\"]`. Unclear whether this affects anything because I don't know what uses those field names.\n\n", "hints_text": "@dtolnay: yeah I think this would make sense to change. There isn't much reason for the deserializer to get passed the rust-field-specific names. This must have just been something we missed when we added field renaming. I'm not sure if anyone uses them. Maybe toml? I remember it did some funky things with trying to reparse fields a few different ways to see if the types were correct.\n\nSame thing for renamed variants:\n\n``` rust\n#[derive(Deserialize)]\npub enum E {\n    #[serde(rename = \"B\")]\n    A,\n}\n```\n\n``` rust\nconst VARIANTS: &'static [&'static str] = &[\"A\"];\ndeserializer.deserialize_enum(\"E\", VARIANTS, __Visitor)\n```\n", "created_at": "2017-01-12T19:24:34Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 678, "instance_id": "serde-rs__serde-678", "issue_numbers": ["676"], "base_commit": "8242c64152d2d13ec4ebc4e197db709500cc9fce", "patch": "diff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex e75a7c961..9e0b6bee9 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -509,14 +509,6 @@ fn deserialize_item_enum(\n         const VARIANTS: &'static [&'static str] = &[ #(#variant_names),* ];\n     };\n \n-    let ignored_arm = if item_attrs.deny_unknown_fields() {\n-        None\n-    } else {\n-        Some(quote! {\n-            __Field::__ignore => { Err(_serde::de::Error::end_of_stream()) }\n-        })\n-    };\n-\n     // Match arms to extract a variant from a string\n     let mut variant_arms = vec![];\n     for (i, variant) in variants.iter().filter(|variant| !variant.attrs.skip_deserializing()).enumerate() {\n@@ -536,7 +528,23 @@ fn deserialize_item_enum(\n         };\n         variant_arms.push(arm);\n     }\n-    variant_arms.extend(ignored_arm.into_iter());\n+\n+    let match_variant = if variant_arms.is_empty() {\n+        // This is an empty enum like `enum Impossible {}` or an enum in which\n+        // all variants have `#[serde(skip_deserializing)]`.\n+        quote! {\n+            // FIXME: Once we drop support for Rust 1.15:\n+            // let Err(err) = visitor.visit_variant::<__Field>();\n+            // Err(err)\n+            visitor.visit_variant::<__Field>().map(|impossible| match impossible {})\n+        }\n+    } else {\n+        quote! {\n+            match try!(visitor.visit_variant()) {\n+                #(#variant_arms)*\n+            }\n+        }\n+    };\n \n     let (visitor_item, visitor_ty, visitor_expr) = deserialize_visitor(impl_generics);\n \n@@ -551,9 +559,7 @@ fn deserialize_item_enum(\n             fn visit_enum<__V>(&mut self, mut visitor: __V) -> ::std::result::Result<#ty, __V::Error>\n                 where __V: _serde::de::VariantVisitor,\n             {\n-                match try!(visitor.visit_variant()) {\n-                    #(#variant_arms)*\n-                }\n+                #match_variant\n             }\n         }\n \n@@ -646,7 +652,7 @@ fn deserialize_field_visitor(\n         .map(|i| aster::id(format!(\"__field{}\", i)))\n         .collect();\n \n-    let ignore_variant = if item_attrs.deny_unknown_fields() {\n+    let ignore_variant = if is_variant || item_attrs.deny_unknown_fields() {\n         None\n     } else {\n         Some(quote!(__ignore,))\n@@ -744,6 +750,16 @@ fn deserialize_map(\n     fields: &[Field],\n     item_attrs: &attr::Item,\n ) -> Tokens {\n+    if fields.is_empty() && item_attrs.deny_unknown_fields() {\n+        return quote! {\n+            // FIXME: Once we drop support for Rust 1.15:\n+            // let None::<__Field> = try!(visitor.visit_key());\n+            try!(visitor.visit_key::<__Field>()).map(|impossible| match impossible {});\n+            try!(visitor.end());\n+            Ok(#struct_path {})\n+        };\n+    }\n+\n     // Create the field names for the fields.\n     let fields_names = fields.iter()\n         .enumerate()\n", "test_patch": "diff --git a/testing/tests/test_gen.rs b/testing/tests/test_gen.rs\nindex 660eb52e1..24338312e 100644\n--- a/testing/tests/test_gen.rs\n+++ b/testing/tests/test_gen.rs\n@@ -208,6 +208,85 @@ fn test_gen() {\n     struct NonAsciiIdents {\n         \u03c3: f64\n     }\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct EmptyBraced {}\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(deny_unknown_fields)]\n+    struct EmptyBracedDenyUnknown {}\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct BracedSkipAll {\n+        #[serde(skip_deserializing)]\n+        f: u8,\n+    }\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(deny_unknown_fields)]\n+    struct BracedSkipAllDenyUnknown {\n+        #[serde(skip_deserializing)]\n+        f: u8,\n+    }\n+\n+    #[cfg(feature = \"unstable-testing\")]\n+    #[cfg_attr(feature = \"unstable-testing\", derive(Serialize, Deserialize))]\n+    struct EmptyTuple();\n+\n+    #[cfg(feature = \"unstable-testing\")]\n+    #[cfg_attr(feature = \"unstable-testing\", derive(Serialize, Deserialize))]\n+    #[serde(deny_unknown_fields)]\n+    struct EmptyTupleDenyUnknown();\n+\n+    #[derive(Serialize, Deserialize)]\n+    struct TupleSkipAll(#[serde(skip_deserializing)] u8);\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(deny_unknown_fields)]\n+    struct TupleSkipAllDenyUnknown(#[serde(skip_deserializing)] u8);\n+\n+    #[derive(Serialize, Deserialize)]\n+    enum EmptyEnum {}\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(deny_unknown_fields)]\n+    enum EmptyEnumDenyUnknown {}\n+\n+    #[derive(Serialize, Deserialize)]\n+    enum EnumSkipAll {\n+        #[serde(skip_deserializing)]\n+        #[allow(dead_code)]\n+        Variant,\n+    }\n+\n+    #[cfg(feature = \"unstable-testing\")]\n+    #[cfg_attr(feature = \"unstable-testing\", derive(Serialize, Deserialize))]\n+    enum EmptyVariants {\n+        Braced {},\n+        Tuple(),\n+        BracedSkip {\n+            #[serde(skip_deserializing)]\n+            f: u8,\n+        },\n+        TupleSkip(#[serde(skip_deserializing)] u8),\n+    }\n+\n+    #[cfg(feature = \"unstable-testing\")]\n+    #[cfg_attr(feature = \"unstable-testing\", derive(Serialize, Deserialize))]\n+    #[serde(deny_unknown_fields)]\n+    enum EmptyVariantsDenyUnknown {\n+        Braced {},\n+        Tuple(),\n+        BracedSkip {\n+            #[serde(skip_deserializing)]\n+            f: u8,\n+        },\n+        TupleSkip(#[serde(skip_deserializing)] u8),\n+    }\n+\n+    #[derive(Serialize, Deserialize)]\n+    #[serde(deny_unknown_fields)]\n+    struct UnitDenyUnknown;\n }\n \n //////////////////////////////////////////////////////////////////////////\n", "problem_statement": "Empty braced struct generates dead code\n```rust\r\n#[derive(Deserialize)]\r\n#[serde(deny_unknown_fields)]\r\npub struct Config {\r\n}\r\n```\r\n\r\nThe generated code (cleaned up) looks like:\r\n\r\n```rust\r\nimpl Deserialize for Config {\r\n    fn deserialize<D>(deserializer: &mut D) -> Result<Config, D::Error>\r\n        where D: Deserializer\r\n    {\r\n        enum Field {}\r\n\r\n        impl Deserialize for Field {\r\n            /* ... */\r\n        }\r\n\r\n        struct Visitor<D: Deserializer>(PhantomData<D>);\r\n\r\n        impl<D: Deserializer> Visitor for Visitor<D> {\r\n            type Value = Config;\r\n            fn visit_seq<V>(&mut self, mut visitor: V) -> Result<Config, V::Error>\r\n                where V: SeqVisitor\r\n            {\r\n                try!(visitor.end());\r\n                Ok(Config{})\r\n            }\r\n            fn visit_map<V>(&mut self, mut visitor: V) -> Result<Config, V::Error>\r\n                where V: MapVisitor\r\n            {\r\n                // ERROR: irrefutable while-let pattern\r\n                while let Some(key) = try!(visitor.visit_key::<Field>()) {\r\n                    match key {}\r\n                }\r\n                try!(visitor.end());\r\n                Ok(Config{})\r\n            }\r\n        }\r\n\r\n        const FIELDS: &'static [&'static str] = &[];\r\n        deserializer.deserialize_struct(\"Config\", FIELDS, Visitor::<D>(PhantomData))\r\n    }\r\n}\r\n```\r\n\r\nThis is an error on Rust 1.16. We need to omit the Field enum and the while loop in the empty braced struct case.\n", "hints_text": "", "created_at": "2017-01-11T19:03:35Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 671, "instance_id": "serde-rs__serde-671", "issue_numbers": ["667"], "base_commit": "41931224721513c95c4f70ed953ad258d96ebec3", "patch": "diff --git a/serde_codegen/src/de.rs b/serde_codegen/src/de.rs\nindex 163874bd4..e75a7c961 100644\n--- a/serde_codegen/src/de.rs\n+++ b/serde_codegen/src/de.rs\n@@ -1,5 +1,5 @@\n use syn::{self, aster};\n-use quote::{self, Tokens};\n+use quote::Tokens;\n \n use bound;\n use internals::ast::{Body, Field, Item, Style, Variant};\n@@ -642,7 +642,7 @@ fn deserialize_field_visitor(\n     is_variant: bool,\n ) -> Tokens {\n     // Create the field names for the fields.\n-    let field_idents: Vec<_> = (0 .. field_names.len())\n+    let ref field_idents: Vec<_> = (0 .. field_names.len())\n         .map(|i| aster::id(format!(\"__field{}\", i)))\n         .collect();\n \n@@ -652,90 +652,18 @@ fn deserialize_field_visitor(\n         Some(quote!(__ignore,))\n     };\n \n-    let index_field_arms: Vec<_> = field_idents.iter()\n-        .enumerate()\n-        .map(|(field_index, field_ident)| {\n-            quote! {\n-                #field_index => { Ok(__Field::#field_ident) }\n-            }\n-        })\n-        .collect();\n-\n-    let (index_error_msg, unknown_ident) = if is_variant {\n-        (\"expected a variant\", aster::id(\"unknown_variant\"))\n-    } else {\n-        (\"expected a field\", aster::id(\"unknown_field\"))\n-    };\n-\n-    let fallthrough_index_arm_expr = if !is_variant && !item_attrs.deny_unknown_fields() {\n+    let fallthrough_arm = if is_variant {\n         quote! {\n-            Ok(__Field::__ignore)\n+            Err(_serde::de::Error::unknown_variant(value))\n         }\n-    } else {\n+    } else if item_attrs.deny_unknown_fields() {\n         quote! {\n-            Err(_serde::de::Error::invalid_value(#index_error_msg))\n-        }\n-    };\n-\n-    let index_body = quote! {\n-        match value {\n-            #(#index_field_arms)*\n-            _ => #fallthrough_index_arm_expr\n-        }\n-    };\n-\n-    // Match arms to extract a field from a string\n-    let str_field_arms: Vec<_> = field_idents.iter().zip(field_names.iter())\n-        .map(|(field_ident, field_name)| {\n-            quote! {\n-                #field_name => { Ok(__Field::#field_ident) }\n-            }\n-        })\n-        .collect();\n-\n-    let fallthrough_str_arm_expr = if !is_variant && !item_attrs.deny_unknown_fields() {\n-        quote! {\n-            Ok(__Field::__ignore)\n+            Err(_serde::de::Error::unknown_field(value))\n         }\n     } else {\n-        quote! {\n-            Err(_serde::de::Error::#unknown_ident(value))\n-        }\n-    };\n-\n-    let str_body = quote! {\n-        match value {\n-            #(#str_field_arms)*\n-            _ => #fallthrough_str_arm_expr\n-        }\n-    };\n-\n-    // Match arms to extract a field from a string\n-    let bytes_field_arms: Vec<_> = field_idents.iter().zip(field_names.iter())\n-        .map(|(field_ident, field_name)| {\n-            let bytes_field_name = quote::ByteStr(field_name);\n-            quote! {\n-                #bytes_field_name => { Ok(__Field::#field_ident) }\n-            }\n-        })\n-        .collect();\n-\n-    let fallthrough_bytes_arm_expr = if !is_variant && !item_attrs.deny_unknown_fields() {\n         quote! {\n             Ok(__Field::__ignore)\n         }\n-    } else {\n-        quote!({\n-            let value = ::std::string::String::from_utf8_lossy(value);\n-            Err(_serde::de::Error::#unknown_ident(&value))\n-        })\n-    };\n-\n-    let bytes_body = quote! {\n-        match value {\n-            #(#bytes_field_arms)*\n-            _ => #fallthrough_bytes_arm_expr\n-        }\n     };\n \n     quote! {\n@@ -755,22 +683,15 @@ fn deserialize_field_visitor(\n                 impl _serde::de::Visitor for __FieldVisitor {\n                     type Value = __Field;\n \n-                    fn visit_usize<__E>(&mut self, value: usize) -> ::std::result::Result<__Field, __E>\n-                        where __E: _serde::de::Error\n-                    {\n-                        #index_body\n-                    }\n-\n                     fn visit_str<__E>(&mut self, value: &str) -> ::std::result::Result<__Field, __E>\n                         where __E: _serde::de::Error\n                     {\n-                        #str_body\n-                    }\n-\n-                    fn visit_bytes<__E>(&mut self, value: &[u8]) -> ::std::result::Result<__Field, __E>\n-                        where __E: _serde::de::Error\n-                    {\n-                        #bytes_body\n+                        match value {\n+                            #(\n+                                #field_names => Ok(__Field::#field_idents),\n+                            )*\n+                            _ => #fallthrough_arm\n+                        }\n                     }\n                 }\n \n", "test_patch": "diff --git a/testing/tests/test_de.rs b/testing/tests/test_de.rs\nindex 280d427f8..d1879fe84 100644\n--- a/testing/tests/test_de.rs\n+++ b/testing/tests/test_de.rs\n@@ -3,7 +3,7 @@ use std::net;\n use std::path::PathBuf;\n use std::time::Duration;\n \n-use serde::Deserialize;\n+use serde::de::{Deserialize, Type};\n \n extern crate fnv;\n use self::fnv::FnvHasher;\n@@ -723,20 +723,6 @@ declare_tests! {\n             Token::EnumMapEnd,\n         ],\n     }\n-    test_enum_unit_usize {\n-        Enum::Unit => &[\n-            Token::EnumStart(\"Enum\"),\n-            Token::Usize(0),\n-            Token::Unit,\n-        ],\n-    }\n-    test_enum_unit_bytes {\n-        Enum::Unit => &[\n-            Token::EnumStart(\"Enum\"),\n-            Token::Bytes(b\"Unit\"),\n-            Token::Unit,\n-        ],\n-    }\n     test_box {\n         Box::new(0i32) => &[Token::I32(0)],\n     }\n@@ -847,4 +833,20 @@ declare_error_tests! {\n         ],\n         Error::DuplicateField(\"a\"),\n     }\n+    test_enum_unit_usize<Enum> {\n+        &[\n+            Token::EnumStart(\"Enum\"),\n+            Token::Usize(0),\n+            Token::Unit,\n+        ],\n+        Error::InvalidType(Type::U64),\n+    }\n+    test_enum_unit_bytes<Enum> {\n+        &[\n+            Token::EnumStart(\"Enum\"),\n+            Token::Bytes(b\"Unit\"),\n+            Token::Unit,\n+        ],\n+        Error::InvalidType(Type::Bytes),\n+    }\n }\n", "problem_statement": "Stop generating visit_usize and visit_bytes for FieldVisitor\nAs far as I know, not a single format uses these. The visit_usize case is better served by going through visit_seq like Bincode does. The visit_bytes case causes problems with supporting no_std: https://github.com/serde-rs/serde/issues/666#issuecomment-271109830.\r\n\r\nWe can reconsider later if someone comes up with a compelling use case.\n", "hints_text": "", "created_at": "2017-01-08T09:02:40Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 664, "instance_id": "serde-rs__serde-664", "issue_numbers": ["657"], "base_commit": "a3f556959f18c33388a3e4d4498c1b7abf6197e4", "patch": "diff --git a/serde/src/de/mod.rs b/serde/src/de/mod.rs\nindex 210b36b03..9c930a9ff 100644\n--- a/serde/src/de/mod.rs\n+++ b/serde/src/de/mod.rs\n@@ -412,7 +412,7 @@ pub trait Deserializer {\n /// This trait represents a visitor that walks through a deserializer.\n pub trait Visitor {\n     /// The value produced by this visitor.\n-    type Value: Deserialize;\n+    type Value;\n \n     /// `visit_bool` deserializes a `bool` into a `Value`.\n     fn visit_bool<E>(&mut self, v: bool) -> Result<Self::Value, E>\n", "test_patch": "diff --git a/serde_test/src/de.rs b/serde_test/src/de.rs\nindex 121dcd3db..101cc8110 100644\n--- a/serde_test/src/de.rs\n+++ b/serde_test/src/de.rs\n@@ -856,7 +856,7 @@ impl<'a, I> VariantVisitor for DeserializerVariantVisitor<'a, I>\n                 }\n             }\n             Some(_) => {\n-                Deserialize::deserialize(self.de)\n+                de::Deserializer::deserialize(self.de, visitor)\n             }\n             None => Err(Error::EndOfStream),\n         }\n@@ -887,7 +887,7 @@ impl<'a, I> VariantVisitor for DeserializerVariantVisitor<'a, I>\n                 }\n             }\n             Some(_) => {\n-                Deserialize::deserialize(self.de)\n+                de::Deserializer::deserialize(self.de, visitor)\n             }\n             None => Err(Error::EndOfStream),\n         }\n", "problem_statement": "Remove the Deserialize trait bound on Visitor::Value\nThe deserializer should not be able to produce an Ok(Value) any other way - it should be forced to call one of the Visitor methods.\r\n\r\nAlso the type may legitimately not implement Deserialize, for example if you are doing stateful deserialization https://github.com/serde-rs/serde/issues/650.\n", "hints_text": "An example of doing it wrong: [`serde_test::DeserializerVariantVisitor`](https://github.com/serde-rs/serde/blob/v0.8.21/serde_test/src/de.rs#L859) (this is a bug).", "created_at": "2017-01-03T09:53:24Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 653, "instance_id": "serde-rs__serde-653", "issue_numbers": ["638"], "base_commit": "2c984980a0faf0670d1d461aac2527feecf9de30", "patch": "diff --git a/serde_codegen/src/ser.rs b/serde_codegen/src/ser.rs\nindex 449a24904..531604169 100644\n--- a/serde_codegen/src/ser.rs\n+++ b/serde_codegen/src/ser.rs\n@@ -255,77 +255,123 @@ fn serialize_variant(\n \n     let variant_ident = variant.ident.clone();\n     let variant_name = variant.attrs.name().serialize_name();\n-\n-    match variant.style {\n-        Style::Unit => {\n-            quote! {\n-                #type_ident::#variant_ident =>\n-                    _serde::ser::Serializer::serialize_unit_variant(\n-                        _serializer,\n-                        #type_name,\n-                        #variant_index,\n-                        #variant_name,\n-                    ),\n-            }\n-        },\n-        Style::Newtype => {\n-            let block = serialize_newtype_variant(\n-                type_name,\n-                variant_index,\n-                variant_name,\n-                ty,\n-                generics,\n-                &variant.fields[0],\n-            );\n-\n-            quote! {\n-                #type_ident::#variant_ident(ref __simple_value) => #block,\n+    let skipped_err = quote! {\n+        Err(_serde::ser::Error::invalid_value(\"The enum variant was skipped for serialization\"))\n+    };\n+\n+    if variant.attrs.skip_serializing() {\n+        match variant.style {\n+            Style::Unit => {\n+                quote! {\n+                    #type_ident::#variant_ident =>  #skipped_err,\n+                }\n+            },\n+            Style::Newtype => {\n+                quote! {\n+                    #type_ident::#variant_ident(ref __simple_value) => #skipped_err,\n+                }\n+            },\n+            Style::Tuple => {\n+                let field_names: Vec<Tokens> = (0 .. variant.fields.len())\n+                    .map(|i| {\n+                        let id = aster::id(format!(\"__field{}\", i));\n+                        quote!(ref #id)\n+                    })\n+                    .collect();\n+\n+                let pat = quote!(#type_ident::#variant_ident(#(#field_names),*));\n+\n+                quote! {\n+                    #pat => #skipped_err,\n+                }\n             }\n-        },\n-        Style::Tuple => {\n-            let field_names: Vec<Tokens> = (0 .. variant.fields.len())\n-                .map(|i| {\n-                    let id = aster::id(format!(\"__field{}\", i));\n+            Style::Struct => {\n+                let fields = variant.fields.iter().map(|field| {\n+                    let id = match field.ident {\n+                        Some(ref name) => name.clone(),\n+                        None => panic!(\"struct variant has unnamed fields\"),\n+                    };\n                     quote!(ref #id)\n-                })\n-                .collect();\n-\n-            let pat = quote!(#type_ident::#variant_ident(#(#field_names),*));\n-\n-            let block = serialize_tuple_variant(\n-                type_name,\n-                variant_index,\n-                variant_name,\n-                generics,\n-                ty,\n-                &variant.fields,\n-            );\n+                });\n+                let pat = quote!(#type_ident::#variant_ident { #(#fields),* });\n \n-            quote! {\n-                #pat => { #block }\n+                quote! {\n+                    #pat => #skipped_err,\n+                }\n             }\n         }\n-        Style::Struct => {\n-            let fields = variant.fields.iter().map(|field| {\n-                let id = match field.ident {\n-                    Some(ref name) => name.clone(),\n-                    None => panic!(\"struct variant has unnamed fields\"),\n-                };\n-                quote!(ref #id)\n-            });\n-            let pat = quote!(#type_ident::#variant_ident { #(#fields),* });\n-\n-            let block = serialize_struct_variant(\n-                variant_index,\n-                variant_name,\n-                generics,\n-                ty,\n-                &variant.fields,\n-                item_attrs,\n-            );\n+    } else { // variant wasn't skipped\n+        match variant.style {\n+            Style::Unit => {\n+                quote! {\n+                    #type_ident::#variant_ident =>\n+                        _serde::ser::Serializer::serialize_unit_variant(\n+                            _serializer,\n+                            #type_name,\n+                            #variant_index,\n+                            #variant_name,\n+                        ),\n+                }\n+            },\n+            Style::Newtype => {\n+                let block = serialize_newtype_variant(\n+                    type_name,\n+                    variant_index,\n+                    variant_name,\n+                    ty,\n+                    generics,\n+                    &variant.fields[0],\n+                );\n+\n+                quote! {\n+                    #type_ident::#variant_ident(ref __simple_value) => #block,\n+                }\n+            },\n+            Style::Tuple => {\n+                let field_names: Vec<Tokens> = (0 .. variant.fields.len())\n+                    .map(|i| {\n+                        let id = aster::id(format!(\"__field{}\", i));\n+                        quote!(ref #id)\n+                    })\n+                    .collect();\n+\n+                let pat = quote!(#type_ident::#variant_ident(#(#field_names),*));\n+\n+                let block = serialize_tuple_variant(\n+                    type_name,\n+                    variant_index,\n+                    variant_name,\n+                    generics,\n+                    ty,\n+                    &variant.fields,\n+                );\n+\n+                quote! {\n+                    #pat => { #block }\n+                }\n+            }\n+            Style::Struct => {\n+                let fields = variant.fields.iter().map(|field| {\n+                    let id = match field.ident {\n+                        Some(ref name) => name.clone(),\n+                        None => panic!(\"struct variant has unnamed fields\"),\n+                    };\n+                    quote!(ref #id)\n+                });\n+                let pat = quote!(#type_ident::#variant_ident { #(#fields),* });\n \n-            quote! {\n-                #pat => { #block }\n+                let block = serialize_struct_variant(\n+                    variant_index,\n+                    variant_name,\n+                    generics,\n+                    ty,\n+                    &variant.fields,\n+                    item_attrs,\n+                );\n+\n+                quote! {\n+                    #pat => { #block }\n+                }\n             }\n         }\n     }\ndiff --git a/serde_codegen_internals/src/attr.rs b/serde_codegen_internals/src/attr.rs\nindex a9a691694..632dd508d 100644\n--- a/serde_codegen_internals/src/attr.rs\n+++ b/serde_codegen_internals/src/attr.rs\n@@ -188,6 +188,7 @@ impl Item {\n pub struct Variant {\n     name: Name,\n     skip_deserializing: bool,\n+    skip_serializing: bool,\n }\n \n impl Variant {\n@@ -195,6 +196,7 @@ impl Variant {\n         let mut ser_name = Attr::none(cx, \"rename\");\n         let mut de_name = Attr::none(cx, \"rename\");\n         let mut skip_deserializing = BoolAttr::none(cx, \"skip_deserializing\");\n+        let mut skip_serializing = BoolAttr::none(cx, \"skip_serializing\");\n \n         for meta_items in variant.attrs.iter().filter_map(get_serde_meta_items) {\n             for meta_item in meta_items {\n@@ -218,6 +220,10 @@ impl Variant {\n                     MetaItem(Word(ref name)) if name == \"skip_deserializing\" => {\n                         skip_deserializing.set_true();\n                     }\n+                    // Parse `#[serde(skip_serializing)]`\n+                    MetaItem(Word(ref name)) if name == \"skip_serializing\" => {\n+                        skip_serializing.set_true();\n+                    }\n \n                     MetaItem(ref meta_item) => {\n                         cx.error(format!(\"unknown serde variant attribute `{}`\",\n@@ -237,6 +243,7 @@ impl Variant {\n                 deserialize: de_name.get().unwrap_or_else(|| variant.ident.to_string()),\n             },\n             skip_deserializing: skip_deserializing.get(),\n+            skip_serializing: skip_serializing.get(),\n         }\n     }\n \n@@ -247,6 +254,10 @@ impl Variant {\n     pub fn skip_deserializing(&self) -> bool {\n         self.skip_deserializing\n     }\n+\n+    pub fn skip_serializing(&self) -> bool {\n+        self.skip_serializing\n+    }\n }\n \n /// Represents field attribute information\n", "test_patch": "diff --git a/testing/tests/test_ser.rs b/testing/tests/test_ser.rs\nindex 525735339..afc850700 100644\n--- a/testing/tests/test_ser.rs\n+++ b/testing/tests/test_ser.rs\n@@ -30,12 +30,20 @@ struct Struct {\n     c: i32,\n }\n \n-#[derive(Serialize)]\n+#[derive(Serialize, PartialEq, Debug)]\n enum Enum {\n     Unit,\n     One(i32),\n     Seq(i32, i32),\n     Map { a: i32, b: i32 },\n+    #[serde(skip_serializing)]\n+    SkippedUnit,\n+    #[serde(skip_serializing)]\n+    SkippedOne(i32),\n+    #[serde(skip_serializing)]\n+    SkippedSeq(i32, i32),\n+    #[serde(skip_serializing)]\n+    SkippedMap { _a: i32, _b: i32 },\n }\n \n //////////////////////////////////////////////////////////////////////////\n@@ -388,3 +396,23 @@ fn test_cannot_serialize_paths() {\n         &[],\n         Error::InvalidValue(\"Path contains invalid UTF-8 characters\".to_owned()));\n }\n+\n+#[test]\n+fn test_enum_skipped() {\n+    assert_ser_tokens_error(\n+        &Enum::SkippedUnit,\n+        &[],\n+        Error::InvalidValue(\"The enum variant was skipped for serialization\".to_owned()));\n+    assert_ser_tokens_error(\n+        &Enum::SkippedOne(42),\n+        &[],\n+        Error::InvalidValue(\"The enum variant was skipped for serialization\".to_owned()));\n+    assert_ser_tokens_error(\n+        &Enum::SkippedSeq(1, 2),\n+        &[],\n+        Error::InvalidValue(\"The enum variant was skipped for serialization\".to_owned()));\n+    assert_ser_tokens_error(\n+        &Enum::SkippedMap { _a: 1, _b: 2 },\n+        &[],\n+        Error::InvalidValue(\"The enum variant was skipped for serialization\".to_owned()));\n+}\n", "problem_statement": "Attribute skip_(de)serializing for enum variants\n```rust\r\n#[derive(Serialize, Deserialize)]\r\nenum E {\r\n    A,\r\n    B,\r\n    #[serde(skip_serializing, skip_deserializing)]\r\n    C,\r\n}\r\n```\r\n\r\nWhen serializing, it should error when the value is that variant. When deserializing, it should be like the variant doesn't exist.\n", "hints_text": "#641 handles `skip_deserializing`. We still need to do `skip_serializing`.", "created_at": "2016-12-24T12:01:17Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 652, "instance_id": "serde-rs__serde-652", "issue_numbers": ["645"], "base_commit": "2c984980a0faf0670d1d461aac2527feecf9de30", "patch": "diff --git a/serde/src/bytes.rs b/serde/src/bytes.rs\nindex a732712cf..988c24a55 100644\n--- a/serde/src/bytes.rs\n+++ b/serde/src/bytes.rs\n@@ -84,7 +84,7 @@ mod bytebuf {\n     use de;\n \n     #[cfg(feature = \"collections\")]\n-    use collections::Vec;\n+    use collections::{String, Vec};\n \n     /// `ByteBuf` wraps a `Vec<u8>` and serializes as a byte array.\n     #[derive(Clone, Default, Eq, Hash, PartialEq, PartialOrd, Ord)]\n@@ -208,7 +208,7 @@ mod bytebuf {\n         fn visit_bytes<E>(&mut self, v: &[u8]) -> Result<ByteBuf, E>\n             where E: de::Error,\n         {\n-            self.visit_byte_buf(v.to_vec())\n+            Ok(ByteBuf::from(v))\n         }\n \n         #[inline]\n@@ -217,6 +217,18 @@ mod bytebuf {\n         {\n             Ok(ByteBuf::from(v))\n         }\n+\n+        fn visit_str<E>(&mut self, v: &str) -> Result<ByteBuf, E>\n+            where E: de::Error,\n+        {\n+            Ok(ByteBuf::from(v))\n+        }\n+\n+        fn visit_string<E>(&mut self, v: String) -> Result<ByteBuf, E>\n+            where E: de::Error,\n+        {\n+            Ok(ByteBuf::from(v))\n+        }\n     }\n \n     impl de::Deserialize for ByteBuf {\n", "test_patch": "diff --git a/testing/tests/test.rs.in b/testing/tests/test.rs.in\nindex fca1ff465..04c69bdba 100644\n--- a/testing/tests/test.rs.in\n+++ b/testing/tests/test.rs.in\n@@ -1,4 +1,5 @@\n extern crate serde;\n+extern crate serde_test;\n \n #[macro_use]\n mod macros;\ndiff --git a/testing/tests/test_bytes.rs b/testing/tests/test_bytes.rs\nindex fd707e21f..a0e5fbcc3 100644\n--- a/testing/tests/test_bytes.rs\n+++ b/testing/tests/test_bytes.rs\n@@ -1,11 +1,13 @@\n use std::fmt;\n use std::error;\n \n-use serde::{Serialize, Serializer, Deserialize, Deserializer};\n+use serde::{Serialize, Serializer};\n use serde::bytes::{ByteBuf, Bytes};\n use serde::ser;\n use serde::de;\n \n+use serde_test::{assert_de_tokens, Token};\n+\n ///////////////////////////////////////////////////////////////////////////////\n \n #[derive(Debug, PartialEq)]\n@@ -286,153 +288,6 @@ impl Serializer for BytesSerializer {\n \n ///////////////////////////////////////////////////////////////////////////////\n \n-struct BytesDeserializer {\n-    bytes: Option<Vec<u8>>,\n-}\n-\n-impl BytesDeserializer {\n-    fn new(bytes: Vec<u8>) -> Self {\n-        BytesDeserializer {\n-            bytes: Some(bytes),\n-        }\n-    }\n-}\n-\n-impl Deserializer for BytesDeserializer {\n-    type Error = Error;\n-\n-    fn deserialize<V>(&mut self, _visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n-    {\n-        Err(Error)\n-    }\n-\n-    fn deserialize_bytes<V>(&mut self, mut visitor: V) -> Result<V::Value, Error>\n-        where V: de::Visitor,\n-    {\n-        visitor.visit_byte_buf(self.bytes.take().unwrap())\n-    }\n-\n-    fn deserialize_seq<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_struct_field<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_map<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_unit<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_ignored_any<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_string<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_str<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_char<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_i64<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_i32<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_i16<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_i8<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_u64<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_u32<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_u16<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_u8<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_f32<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_f64<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_bool<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_usize<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_isize<__V>(&mut self, visitor: __V) -> Result<__V::Value, Self::Error>\n-        where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_option<__V>(&mut self, visitor: __V)\n-     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_seq_fixed_size<__V>(&mut self, _: usize, visitor: __V)\n-     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_unit_struct<__V>(&mut self, _: &str, visitor: __V)\n-     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_newtype_struct<__V>(&mut self, _: &str, visitor: __V)\n-     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_tuple_struct<__V>(&mut self, _: &str, _: usize, visitor: __V)\n-     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_struct<__V>(&mut self, _: &str, _: &[&str], visitor: __V)\n-     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_tuple<__V>(&mut self, _: usize, visitor: __V)\n-     -> Result<__V::Value, Self::Error> where __V: de::Visitor {\n-        self.deserialize(visitor)\n-    }\n-    fn deserialize_enum<__V>(&mut self, _: &str, _: &[&str], _visitor: __V)\n-     -> Result<__V::Value, Self::Error> where __V: de::EnumVisitor {\n-        Err(Error)\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////////\n-\n #[test]\n fn test_bytes_ser_bytes() {\n     let buf = vec![];\n@@ -449,12 +304,42 @@ fn test_bytes_ser_bytes() {\n ///////////////////////////////////////////////////////////////////////////////\n \n #[test]\n-fn test_byte_buf_de_bytes() {\n-    let mut de = BytesDeserializer::new(vec![]);\n-    let bytes = Deserialize::deserialize(&mut de);\n-    assert_eq!(bytes, Ok(ByteBuf::new()));\n-\n-    let mut de = BytesDeserializer::new(vec![1, 2, 3]);\n-    let bytes = Deserialize::deserialize(&mut de);\n-    assert_eq!(bytes, Ok(ByteBuf::from(vec![1, 2, 3])));\n+fn test_byte_buf_de() {\n+    let empty = ByteBuf::new();\n+    assert_de_tokens(&empty, &[Token::Bytes(b\"\"),]);\n+    assert_de_tokens(&empty, &[Token::Str(\"\")]);\n+    assert_de_tokens(&empty, &[Token::String(String::new())]);\n+    assert_de_tokens(&empty, &[\n+        Token::SeqStart(None),\n+        Token::SeqEnd,\n+    ]);\n+    assert_de_tokens(&empty, &[\n+        Token::SeqStart(Some(0)),\n+        Token::SeqEnd,\n+    ]);\n+\n+    let buf = ByteBuf::from(vec![65, 66, 67]);\n+    assert_de_tokens(&buf, &[Token::Bytes(b\"ABC\")]);\n+    assert_de_tokens(&buf, &[Token::Str(\"ABC\")]);\n+    assert_de_tokens(&buf, &[Token::String(\"ABC\".to_owned())]);\n+    assert_de_tokens(&buf, &[\n+        Token::SeqStart(None),\n+        Token::SeqSep,\n+        Token::U8(65),\n+        Token::SeqSep,\n+        Token::U8(66),\n+        Token::SeqSep,\n+        Token::U8(67),\n+        Token::SeqEnd,\n+    ]);\n+    assert_de_tokens(&buf, &[\n+        Token::SeqStart(Some(3)),\n+        Token::SeqSep,\n+        Token::U8(65),\n+        Token::SeqSep,\n+        Token::U8(66),\n+        Token::SeqSep,\n+        Token::U8(67),\n+        Token::SeqEnd,\n+    ]);\n }\n", "problem_statement": "Support deserializing ByteBuf from string\nA Deserializer should be able to call visit_str or visit_string to deserialize a ByteBuf. The ByteBuf should contain the bytes of the string.\r\n\r\nRelevant to https://github.com/traviskaufman/serde_bencode/issues/7.\n", "hints_text": "", "created_at": "2016-12-24T04:18:37Z", "version": "0.8"}, {"repo": "serde-rs/serde", "pull_number": 578, "instance_id": "serde-rs__serde-578", "issue_numbers": ["575"], "base_commit": "e547a06639ee62dff40813afbbdbf1ed1d792e99", "patch": "diff --git a/README.md b/README.md\nindex 448d9ed28..f0c6ec643 100644\n--- a/README.md\n+++ b/README.md\n@@ -15,7 +15,7 @@ You may be looking for:\n ## Serde in action\n \n ```rust\n-#![feature(rustc_macro)]\n+#![feature(proc_macro)]\n \n #[macro_use]\n extern crate serde_derive;\ndiff --git a/examples/serde-syntex-example/src/main.rs b/examples/serde-syntex-example/src/main.rs\nindex 46e7d1dcf..1d6e20585 100644\n--- a/examples/serde-syntex-example/src/main.rs\n+++ b/examples/serde-syntex-example/src/main.rs\n@@ -1,4 +1,4 @@\n-#![cfg_attr(feature = \"serde_derive\", feature(rustc_macro))]\n+#![cfg_attr(feature = \"serde_derive\", feature(proc_macro))]\n \n #[cfg(feature = \"serde_derive\")]\n #[macro_use]\ndiff --git a/serde_derive/Cargo.toml b/serde_derive/Cargo.toml\nindex 6ee9949d3..a8288a22e 100644\n--- a/serde_derive/Cargo.toml\n+++ b/serde_derive/Cargo.toml\n@@ -12,7 +12,7 @@ include = [\"Cargo.toml\", \"src/**/*.rs\"]\n \n [lib]\n name = \"serde_derive\"\n-rustc-macro = true\n+proc-macro = true\n \n [dependencies.serde_codegen]\n version = \"=0.8.11\"\ndiff --git a/serde_derive/src/lib.rs b/serde_derive/src/lib.rs\nindex 0f4351423..8dd4e6ffd 100644\n--- a/serde_derive/src/lib.rs\n+++ b/serde_derive/src/lib.rs\n@@ -1,12 +1,12 @@\n-#![feature(rustc_macro, rustc_macro_lib)]\n+#![feature(proc_macro, proc_macro_lib)]\n #![cfg(not(test))]\n \n-extern crate rustc_macro;\n+extern crate proc_macro;\n extern crate serde_codegen;\n \n-use rustc_macro::TokenStream;\n+use proc_macro::TokenStream;\n \n-#[rustc_macro_derive(Serialize)]\n+#[proc_macro_derive(Serialize)]\n pub fn derive_serialize(input: TokenStream) -> TokenStream {\n     let item = format!(\"#[derive(Serialize)]\\n{}\", input);\n     match serde_codegen::expand_single_item(&item) {\n@@ -15,7 +15,7 @@ pub fn derive_serialize(input: TokenStream) -> TokenStream {\n     }\n }\n \n-#[rustc_macro_derive(Deserialize)]\n+#[proc_macro_derive(Deserialize)]\n pub fn derive_deserialize(input: TokenStream) -> TokenStream {\n     let item = format!(\"#[derive(Deserialize)]\\n{}\", input);\n     match serde_codegen::expand_single_item(&item) {\n", "test_patch": "diff --git a/serde_derive/tests/compile-fail/duplicate-attribute/rename-and-ser.rs b/serde_derive/tests/compile-fail/duplicate-attribute/rename-and-ser.rs\nindex 312583af1..2f3950f8e 100644\n--- a/serde_derive/tests/compile-fail/duplicate-attribute/rename-and-ser.rs\n+++ b/serde_derive/tests/compile-fail/duplicate-attribute/rename-and-ser.rs\n@@ -1,4 +1,4 @@\n-#![feature(rustc_macro)]\n+#![feature(proc_macro)]\n \n #[macro_use]\n extern crate serde_derive;\ndiff --git a/serde_derive/tests/compile-fail/duplicate-attribute/rename-rename-de.rs b/serde_derive/tests/compile-fail/duplicate-attribute/rename-rename-de.rs\nindex e6d6876a0..04718a0e2 100644\n--- a/serde_derive/tests/compile-fail/duplicate-attribute/rename-rename-de.rs\n+++ b/serde_derive/tests/compile-fail/duplicate-attribute/rename-rename-de.rs\n@@ -1,4 +1,4 @@\n-#![feature(rustc_macro)]\n+#![feature(proc_macro)]\n \n #[macro_use]\n extern crate serde_derive;\ndiff --git a/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename-ser.rs b/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename-ser.rs\nindex d6937559a..420182c45 100644\n--- a/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename-ser.rs\n+++ b/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename-ser.rs\n@@ -1,4 +1,4 @@\n-#![feature(rustc_macro)]\n+#![feature(proc_macro)]\n \n #[macro_use]\n extern crate serde_derive;\ndiff --git a/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename.rs b/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename.rs\nindex dcb0f69e0..52715b9db 100644\n--- a/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename.rs\n+++ b/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-rename.rs\n@@ -1,4 +1,4 @@\n-#![feature(rustc_macro)]\n+#![feature(proc_macro)]\n \n #[macro_use]\n extern crate serde_derive;\ndiff --git a/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-ser.rs b/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-ser.rs\nindex af9116e53..31264c6be 100644\n--- a/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-ser.rs\n+++ b/serde_derive/tests/compile-fail/duplicate-attribute/rename-ser-ser.rs\n@@ -1,4 +1,4 @@\n-#![feature(rustc_macro)]\n+#![feature(proc_macro)]\n \n #[macro_use]\n extern crate serde_derive;\ndiff --git a/serde_derive/tests/compile-fail/duplicate-attribute/two-rename-ser.rs b/serde_derive/tests/compile-fail/duplicate-attribute/two-rename-ser.rs\nindex a518839d4..d60545290 100644\n--- a/serde_derive/tests/compile-fail/duplicate-attribute/two-rename-ser.rs\n+++ b/serde_derive/tests/compile-fail/duplicate-attribute/two-rename-ser.rs\n@@ -1,4 +1,4 @@\n-#![feature(rustc_macro)]\n+#![feature(proc_macro)]\n \n #[macro_use]\n extern crate serde_derive;\ndiff --git a/serde_derive/tests/compile-fail/str_ref_deser.rs b/serde_derive/tests/compile-fail/str_ref_deser.rs\nindex 9a99e72b4..58ae577c1 100644\n--- a/serde_derive/tests/compile-fail/str_ref_deser.rs\n+++ b/serde_derive/tests/compile-fail/str_ref_deser.rs\n@@ -1,4 +1,4 @@\n-#![feature(rustc_macro)]\n+#![feature(proc_macro)]\n \n #[macro_use]\n extern crate serde_derive;\ndiff --git a/serde_derive/tests/compile-fail/unknown-attribute/container.rs b/serde_derive/tests/compile-fail/unknown-attribute/container.rs\nindex 2b0e1cb22..575cc10cb 100644\n--- a/serde_derive/tests/compile-fail/unknown-attribute/container.rs\n+++ b/serde_derive/tests/compile-fail/unknown-attribute/container.rs\n@@ -1,4 +1,4 @@\n-#![feature(rustc_macro)]\n+#![feature(proc_macro)]\n \n #[macro_use]\n extern crate serde_derive;\ndiff --git a/serde_derive/tests/compile-fail/unknown-attribute/field.rs b/serde_derive/tests/compile-fail/unknown-attribute/field.rs\nindex 1b2d8e6c1..457ce5202 100644\n--- a/serde_derive/tests/compile-fail/unknown-attribute/field.rs\n+++ b/serde_derive/tests/compile-fail/unknown-attribute/field.rs\n@@ -1,4 +1,4 @@\n-#![feature(rustc_macro)]\n+#![feature(proc_macro)]\n \n #[macro_use]\n extern crate serde_derive;\ndiff --git a/serde_derive/tests/compile-fail/unknown-attribute/variant.rs b/serde_derive/tests/compile-fail/unknown-attribute/variant.rs\nindex 239fcc89d..af5c323a7 100644\n--- a/serde_derive/tests/compile-fail/unknown-attribute/variant.rs\n+++ b/serde_derive/tests/compile-fail/unknown-attribute/variant.rs\n@@ -1,4 +1,4 @@\n-#![feature(rustc_macro)]\n+#![feature(proc_macro)]\n \n #[macro_use]\n extern crate serde_derive;\ndiff --git a/serde_derive/tests/run-pass/identity-op.rs b/serde_derive/tests/run-pass/identity-op.rs\nindex 47e2c750a..0def143e2 100644\n--- a/serde_derive/tests/run-pass/identity-op.rs\n+++ b/serde_derive/tests/run-pass/identity-op.rs\n@@ -1,4 +1,4 @@\n-#![feature(rustc_macro)]\n+#![feature(proc_macro)]\n #![deny(identity_op)]\n \n #[macro_use]\ndiff --git a/serde_derive/tests/test.rs b/serde_derive/tests/test.rs\nindex 80239edf9..696a4bc44 100644\n--- a/serde_derive/tests/test.rs\n+++ b/serde_derive/tests/test.rs\n@@ -1,4 +1,4 @@\n-#![feature(test, rustc_macro, rustc_attrs)]\n+#![feature(test, proc_macro, rustc_attrs)]\n \n #[macro_use]\n extern crate serde_derive;\n", "problem_statement": "Update from rustc_macro to proc_macro\nThe name of attributes / libraries / feature flags / everything related to Macros 1.1 has changed from rustc_macro to proc_macro in https://github.com/rust-lang/rust/pull/36945 and https://github.com/rust-lang/cargo/pull/3160. We need to update serde_derive to use the new names.\n\n", "hints_text": "", "created_at": "2016-10-08T22:32:45Z", "version": "0.8"}]