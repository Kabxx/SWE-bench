[{"repo": "bottlerocket-os/bottlerocket", "pull_number": 2476, "instance_id": "bottlerocket-os__bottlerocket-2476", "issue_numbers": ["2412"], "base_commit": "a90cc5f7e019fb67dccf5af2e3eea2190e529cf6", "patch": "diff --git a/sources/Cargo.lock b/sources/Cargo.lock\nindex 0252b80b229..f1954ef41d6 100644\n--- a/sources/Cargo.lock\n+++ b/sources/Cargo.lock\n@@ -459,9 +459,9 @@ checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n \n [[package]]\n name = \"aws-config\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"11a8c971b0cb0484fc9436a291a44503b95141edc36ce7a6af6b6d7a06a02ab0\"\n+checksum = \"7d4cf4608abd7c8038a4c609a1270e61b73c86550f5655654ca28322e0a2e2c1\"\n dependencies = [\n  \"aws-http\",\n  \"aws-sdk-sso\",\n@@ -478,6 +478,7 @@ dependencies = [\n  \"http\",\n  \"hyper\",\n  \"ring\",\n+ \"time 0.3.14\",\n  \"tokio\",\n  \"tower\",\n  \"tracing\",\n@@ -486,11 +487,12 @@ dependencies = [\n \n [[package]]\n name = \"aws-endpoint\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4bc956f415dda77215372e5bc751a2463d1f9a1ec34edf3edc6c0ff67e5c8e43\"\n+checksum = \"7ffaf1da7a11d38a5afe7cdd202ab2e25528de7cf38c47b571c0dde4008d98ae\"\n dependencies = [\n  \"aws-smithy-http\",\n+ \"aws-smithy-types\",\n  \"aws-types\",\n  \"http\",\n  \"regex\",\n@@ -499,9 +501,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-http\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3a0d98a1d606aa24554e604f220878db4aa3b525b72f88798524497cc3867fc6\"\n+checksum = \"8309108743e2e74f249ff29a7c7be79c6343ea649dd8c31e4c0e07ca6946d8ed\"\n dependencies = [\n  \"aws-smithy-http\",\n  \"aws-smithy-types\",\n@@ -517,9 +519,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sdk-cloudformation\"\n-version = \"0.16.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"11ee3a29cc2cea6ab8bf930f03a2c926430c686a5bd58d8f0f8b9f5d5c386f47\"\n+checksum = \"cafaf0b9199f52cd69ef07c1d15fc7a57bf3ff53a8b0885cf708110fa49f6450\"\n dependencies = [\n  \"aws-endpoint\",\n  \"aws-http\",\n@@ -541,9 +543,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sdk-eks\"\n-version = \"0.16.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18165a110897844ed983b2e4fd339c09a77c0c9cec4ffe50452d0da361f3a503\"\n+checksum = \"0279da965d60a577f3e7a200f5df0586aea060a8ab2c09e691e29710a4ad9145\"\n dependencies = [\n  \"aws-endpoint\",\n  \"aws-http\",\n@@ -564,9 +566,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sdk-sso\"\n-version = \"0.16.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"baa0c66fab12976065403cf4cafacffe76afa91d0da335d195af379d4223d235\"\n+checksum = \"f7a0659e5269f8c4bd06f362ec7e35b4f55956c4d60e0ca177b575db80584a45\"\n dependencies = [\n  \"aws-endpoint\",\n  \"aws-http\",\n@@ -586,9 +588,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sdk-sts\"\n-version = \"0.16.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"048037cdfd7f42fb29b5f969c7f639b4b7eac00e8f911e4eac4f89fb7b3a0500\"\n+checksum = \"edc795c7851c0e9bcefde5e6bb610c16a9e03220e0336fc12f75bb80d9ce7e80\"\n dependencies = [\n  \"aws-endpoint\",\n  \"aws-http\",\n@@ -608,9 +610,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sig-auth\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e8386fc0d218dbf2011f65bd8300d21ba98603fd150b962f61239be8b02d1fc6\"\n+checksum = \"0ee4bf20136757fd9f606bb4adafe6d19fb02bc48033a8d4f205f21d56fa783a\"\n dependencies = [\n  \"aws-sigv4\",\n  \"aws-smithy-http\",\n@@ -621,9 +623,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sigv4\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cd866926c2c4978210bcb01d7d1b431c794f0c23ca9ee1e420204b018836b5fb\"\n+checksum = \"b99b21b3aceaf224cccd693b353e1f38af4ede8c5fc618b97dd458bb63238efc\"\n dependencies = [\n  \"aws-smithy-http\",\n  \"form_urlencoded\",\n@@ -639,9 +641,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-async\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"deb59cfdd21143006c01b9ca4dc4a9190b8c50c2ef831f9eb36f54f69efa42f1\"\n+checksum = \"ef79062cf5fa881dd156938ca438ec2de0f7ec9342c2f84fa6303274e1484b43\"\n dependencies = [\n  \"futures-util\",\n  \"pin-project-lite\",\n@@ -651,9 +653,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-client\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"44243329ba8618474c3b7f396de281f175ae172dd515b3d35648671a3cf51871\"\n+checksum = \"13f402fa9a45353f7f02f8046a6a568143844d201c5b4cc3bedb6442058538c8\"\n dependencies = [\n  \"aws-smithy-async\",\n  \"aws-smithy-http\",\n@@ -674,9 +676,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-http\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fba78f69a5bbe7ac1826389304c67b789032d813574e78f9a2d450634277f833\"\n+checksum = \"23861d0b53a1369eab1e8d48c8bb3492eb3def1c2f2222dfb1bad58dd03914a5\"\n dependencies = [\n  \"aws-smithy-types\",\n  \"bytes\",\n@@ -695,9 +697,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-http-tower\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ff8a512d68350561e901626baa08af9491cfbd54596201b84b4da846a59e4da3\"\n+checksum = \"04f6b3ae42d5c52bbaadfdd31c09fd11c92b823d329915dedbb08c0e9525755c\"\n dependencies = [\n  \"aws-smithy-http\",\n  \"bytes\",\n@@ -710,18 +712,18 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-json\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"31b7633698853aae80bd8b26866531420138eca91ea4620735d20b0537c93c2e\"\n+checksum = \"5048b693643803c001f88fad36c5a7aa1159e56b0025527fadc57e830aa48b11\"\n dependencies = [\n  \"aws-smithy-types\",\n ]\n \n [[package]]\n name = \"aws-smithy-query\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"95a94b5a8cc94a85ccbff89eb7bc80dc135ede02847a73d68c04ac2a3e4cf6b7\"\n+checksum = \"b317cd3b326444e659a2f287f67e8c72903495c71a3473b0764880454b3aa25c\"\n dependencies = [\n  \"aws-smithy-types\",\n  \"urlencoding\",\n@@ -729,9 +731,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-types\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d230d281653de22fb0e9c7c74d18d724a39d7148e2165b1e760060064c4967c0\"\n+checksum = \"4149b09b9d8cf37f0afc390144f5d71b8f4daadfd9540ddf43ad27b54d407470\"\n dependencies = [\n  \"itoa\",\n  \"num-integer\",\n@@ -741,18 +743,18 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-xml\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4aacaf6c0fa549ebe5d9daa96233b8635965721367ee7c69effc8d8078842df3\"\n+checksum = \"2c6d8e7a15feb04f041cf0ede8f6c16e03fe5a4b03e164ae3a090e829404d925\"\n dependencies = [\n  \"xmlparser\",\n ]\n \n [[package]]\n name = \"aws-types\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fb54f097516352475a0159c9355f8b4737c54044538a4d9aca4d376ef2361ccc\"\n+checksum = \"1bba03e59e1a0223a2bd3567da2b07a458b067ccf7846996b82406e80008ebc1\"\n dependencies = [\n  \"aws-smithy-async\",\n  \"aws-smithy-client\",\n@@ -2445,9 +2447,9 @@ dependencies = [\n \n [[package]]\n name = \"olpc-cjson\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"72ca49fe685014bbf124ee547da94ed7bb65a6eb9dc9c4711773c081af96a39c\"\n+checksum = \"87dc75cf72208cd853671c1abccc5d5d1e43b1e378dde67340ef933219a8c13c\"\n dependencies = [\n  \"serde\",\n  \"serde_json\",\n@@ -3715,9 +3717,9 @@ dependencies = [\n \n [[package]]\n name = \"tough\"\n-version = \"0.12.4\"\n+version = \"0.12.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"70a537c6b4307f5401e82a0196e97aaab9599e9c0f880e168eafb176abbac63d\"\n+checksum = \"dc636dd1ee889a366af6731f1b63b60baf19528b46df5a7c2d4b3bf8b60bca2d\"\n dependencies = [\n  \"chrono\",\n  \"dyn-clone\",\ndiff --git a/sources/api/pluto/Cargo.toml b/sources/api/pluto/Cargo.toml\nindex e0727172d38..438f44ec20f 100644\n--- a/sources/api/pluto/Cargo.toml\n+++ b/sources/api/pluto/Cargo.toml\n@@ -17,10 +17,10 @@ hyper-proxy = {  version = \"0.9\", default-features = false, features = [\"rustls\"\n hyper-rustls = { version = \"0.23\", default-features = false, features = [\"http2\", \"native-tokio\", \"tls12\", \"logging\"] }\n imdsclient = { path = \"../../imdsclient\", version = \"0.1.0\" }\n models = { path = \"../../models\", version = \"0.1.0\" }\n-aws-config = \"0.46.0\"\n-aws-sdk-eks = \"0.16.0\"\n-aws-types = \"0.46.0\"\n-aws-smithy-client = { version = \"0.46.0\", default-features = false, features = [\"rustls\"] }\n+aws-config = \"0.48.0\"\n+aws-sdk-eks = \"0.18.0\"\n+aws-types = \"0.48.0\"\n+aws-smithy-client = { version = \"0.48.0\", default-features = false, features = [\"rustls\"] }\n serde_json = \"1\"\n snafu = \"0.7\"\n tokio = { version = \"~1.14\", default-features = false, features = [\"macros\", \"rt-multi-thread\"] }  # LTS\ndiff --git a/sources/cfsignal/Cargo.toml b/sources/cfsignal/Cargo.toml\nindex a3ce9f566e1..7a01a49d0c1 100644\n--- a/sources/cfsignal/Cargo.toml\n+++ b/sources/cfsignal/Cargo.toml\n@@ -14,9 +14,9 @@ simplelog = \"0.12\"\n snafu = { version = \"0.7\" }\n toml = \"0.5.1\"\n tokio = { version = \"~1.14\", default-features = false, features = [\"macros\", \"rt-multi-thread\"] }\n-aws-config = \"0.46.0\"\n-aws-sdk-cloudformation = \"0.16.0\"\n-aws-types = \"0.46.0\"\n+aws-config = \"0.48.0\"\n+aws-sdk-cloudformation = \"0.18.0\"\n+aws-types = \"0.48.0\"\n imdsclient = { path = \"../imdsclient\", version = \"0.1.0\" }\n hyper = \"0.14.2\"\n \ndiff --git a/tools/Cargo.lock b/tools/Cargo.lock\nindex d78f9919212..6ae14c31b4a 100644\n--- a/tools/Cargo.lock\n+++ b/tools/Cargo.lock\n@@ -130,9 +130,9 @@ checksum = \"d468802bab17cbc0cc575e9b053f41e72aa36bfa6b7f55e3529ffa43161b97fa\"\n \n [[package]]\n name = \"aws-config\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"11a8c971b0cb0484fc9436a291a44503b95141edc36ce7a6af6b6d7a06a02ab0\"\n+checksum = \"7d4cf4608abd7c8038a4c609a1270e61b73c86550f5655654ca28322e0a2e2c1\"\n dependencies = [\n  \"aws-http\",\n  \"aws-sdk-sso\",\n@@ -149,6 +149,7 @@ dependencies = [\n  \"http\",\n  \"hyper\",\n  \"ring\",\n+ \"time 0.3.14\",\n  \"tokio\",\n  \"tower\",\n  \"tracing\",\n@@ -157,11 +158,12 @@ dependencies = [\n \n [[package]]\n name = \"aws-endpoint\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4bc956f415dda77215372e5bc751a2463d1f9a1ec34edf3edc6c0ff67e5c8e43\"\n+checksum = \"7ffaf1da7a11d38a5afe7cdd202ab2e25528de7cf38c47b571c0dde4008d98ae\"\n dependencies = [\n  \"aws-smithy-http\",\n+ \"aws-smithy-types\",\n  \"aws-types\",\n  \"http\",\n  \"regex\",\n@@ -170,9 +172,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-http\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3a0d98a1d606aa24554e604f220878db4aa3b525b72f88798524497cc3867fc6\"\n+checksum = \"8309108743e2e74f249ff29a7c7be79c6343ea649dd8c31e4c0e07ca6946d8ed\"\n dependencies = [\n  \"aws-smithy-http\",\n  \"aws-smithy-types\",\n@@ -188,9 +190,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sdk-ebs\"\n-version = \"0.16.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"702e6f505ce8d61f0bef4d2b2747f156dcbd6ba23b2a870ad9aa868830f026c5\"\n+checksum = \"e901db77b1cbdce5804ee5587882aceac22250171dfdde51f6a2f95161bd1394\"\n dependencies = [\n  \"aws-endpoint\",\n  \"aws-http\",\n@@ -211,9 +213,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sdk-ec2\"\n-version = \"0.16.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"85b6c04720f5846edb80aa8c4dda848b77efdf99597f1ae48e12ea6b1ad1d3ce\"\n+checksum = \"e17191be59536e96d100c9dca58f6807fc8d2b0848a06c360b1ffa164bf16bca\"\n dependencies = [\n  \"aws-endpoint\",\n  \"aws-http\",\n@@ -235,9 +237,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sdk-kms\"\n-version = \"0.16.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6fee45083be6f062676aaeab0fe16c931a4e188d2ddce6f2c8d17399c014dc81\"\n+checksum = \"829bf306cb8d20fc1d5d08a8dc440f37d24bfe6690657f55612ccc8a0c083675\"\n dependencies = [\n  \"aws-endpoint\",\n  \"aws-http\",\n@@ -257,9 +259,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sdk-ssm\"\n-version = \"0.16.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"df79d41b62dcea814079c2f6540c465b6d45210b20a4e30efdcd24cc5dcf4aec\"\n+checksum = \"504854d33ea2be4f61391b5c701be7e411c212272367fd1f810e793d255a547d\"\n dependencies = [\n  \"aws-endpoint\",\n  \"aws-http\",\n@@ -280,9 +282,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sdk-sso\"\n-version = \"0.16.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"baa0c66fab12976065403cf4cafacffe76afa91d0da335d195af379d4223d235\"\n+checksum = \"f7a0659e5269f8c4bd06f362ec7e35b4f55956c4d60e0ca177b575db80584a45\"\n dependencies = [\n  \"aws-endpoint\",\n  \"aws-http\",\n@@ -302,9 +304,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sdk-sts\"\n-version = \"0.16.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"048037cdfd7f42fb29b5f969c7f639b4b7eac00e8f911e4eac4f89fb7b3a0500\"\n+checksum = \"edc795c7851c0e9bcefde5e6bb610c16a9e03220e0336fc12f75bb80d9ce7e80\"\n dependencies = [\n  \"aws-endpoint\",\n  \"aws-http\",\n@@ -324,9 +326,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sig-auth\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e8386fc0d218dbf2011f65bd8300d21ba98603fd150b962f61239be8b02d1fc6\"\n+checksum = \"0ee4bf20136757fd9f606bb4adafe6d19fb02bc48033a8d4f205f21d56fa783a\"\n dependencies = [\n  \"aws-sigv4\",\n  \"aws-smithy-http\",\n@@ -337,9 +339,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-sigv4\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cd866926c2c4978210bcb01d7d1b431c794f0c23ca9ee1e420204b018836b5fb\"\n+checksum = \"b99b21b3aceaf224cccd693b353e1f38af4ede8c5fc618b97dd458bb63238efc\"\n dependencies = [\n  \"aws-smithy-http\",\n  \"form_urlencoded\",\n@@ -355,9 +357,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-async\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"deb59cfdd21143006c01b9ca4dc4a9190b8c50c2ef831f9eb36f54f69efa42f1\"\n+checksum = \"ef79062cf5fa881dd156938ca438ec2de0f7ec9342c2f84fa6303274e1484b43\"\n dependencies = [\n  \"futures-util\",\n  \"pin-project-lite\",\n@@ -367,9 +369,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-client\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"44243329ba8618474c3b7f396de281f175ae172dd515b3d35648671a3cf51871\"\n+checksum = \"13f402fa9a45353f7f02f8046a6a568143844d201c5b4cc3bedb6442058538c8\"\n dependencies = [\n  \"aws-smithy-async\",\n  \"aws-smithy-http\",\n@@ -390,9 +392,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-http\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fba78f69a5bbe7ac1826389304c67b789032d813574e78f9a2d450634277f833\"\n+checksum = \"23861d0b53a1369eab1e8d48c8bb3492eb3def1c2f2222dfb1bad58dd03914a5\"\n dependencies = [\n  \"aws-smithy-types\",\n  \"bytes\",\n@@ -411,9 +413,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-http-tower\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ff8a512d68350561e901626baa08af9491cfbd54596201b84b4da846a59e4da3\"\n+checksum = \"04f6b3ae42d5c52bbaadfdd31c09fd11c92b823d329915dedbb08c0e9525755c\"\n dependencies = [\n  \"aws-smithy-http\",\n  \"bytes\",\n@@ -426,18 +428,18 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-json\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"31b7633698853aae80bd8b26866531420138eca91ea4620735d20b0537c93c2e\"\n+checksum = \"5048b693643803c001f88fad36c5a7aa1159e56b0025527fadc57e830aa48b11\"\n dependencies = [\n  \"aws-smithy-types\",\n ]\n \n [[package]]\n name = \"aws-smithy-query\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"95a94b5a8cc94a85ccbff89eb7bc80dc135ede02847a73d68c04ac2a3e4cf6b7\"\n+checksum = \"b317cd3b326444e659a2f287f67e8c72903495c71a3473b0764880454b3aa25c\"\n dependencies = [\n  \"aws-smithy-types\",\n  \"urlencoding\",\n@@ -445,9 +447,9 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-types\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d230d281653de22fb0e9c7c74d18d724a39d7148e2165b1e760060064c4967c0\"\n+checksum = \"4149b09b9d8cf37f0afc390144f5d71b8f4daadfd9540ddf43ad27b54d407470\"\n dependencies = [\n  \"itoa\",\n  \"num-integer\",\n@@ -457,18 +459,18 @@ dependencies = [\n \n [[package]]\n name = \"aws-smithy-xml\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4aacaf6c0fa549ebe5d9daa96233b8635965721367ee7c69effc8d8078842df3\"\n+checksum = \"2c6d8e7a15feb04f041cf0ede8f6c16e03fe5a4b03e164ae3a090e829404d925\"\n dependencies = [\n  \"xmlparser\",\n ]\n \n [[package]]\n name = \"aws-types\"\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fb54f097516352475a0159c9355f8b4737c54044538a4d9aca4d376ef2361ccc\"\n+checksum = \"1bba03e59e1a0223a2bd3567da2b07a458b067ccf7846996b82406e80008ebc1\"\n dependencies = [\n  \"aws-smithy-async\",\n  \"aws-smithy-client\",\n@@ -701,9 +703,9 @@ dependencies = [\n \n [[package]]\n name = \"coldsnap\"\n-version = \"0.4.1\"\n+version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"111badfcdc635ecbffc73bfa46ad0a83ae0c41bc01e09c4045ca3ffb1046c5c5\"\n+checksum = \"284c5dc4766d176cbd1ccc07cd5e0ffabe0e2abc1a944faa60fd6bd0de537f17\"\n dependencies = [\n  \"argh\",\n  \"async-trait\",\n@@ -733,6 +735,7 @@ dependencies = [\n  \"libc\",\n  \"once_cell\",\n  \"terminal_size\",\n+ \"unicode-width\",\n  \"winapi\",\n ]\n \n@@ -1395,14 +1398,13 @@ dependencies = [\n \n [[package]]\n name = \"indicatif\"\n-version = \"0.16.2\"\n+version = \"0.17.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2d207dc617c7a380ab07ff572a6e52fa202a2a8f355860ac9c38e23f8196be1b\"\n+checksum = \"bfddc9561e8baf264e0e45e197fd7696320026eb10a8180340debc27b18f535b\"\n dependencies = [\n  \"console\",\n- \"lazy_static\",\n  \"number_prefix\",\n- \"regex\",\n+ \"unicode-width\",\n ]\n \n [[package]]\n@@ -1726,10 +1728,11 @@ dependencies = [\n \n [[package]]\n name = \"nix\"\n-version = \"0.24.2\"\n+version = \"0.25.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"195cdbc1741b8134346d515b3a56a1c94b0912758009cfd53f99ea0f57b065fc\"\n+checksum = \"e322c04a9e3440c327fca7b6c8a63e6890a32fa2ad689db972425f07e0d22abb\"\n dependencies = [\n+ \"autocfg\",\n  \"bitflags\",\n  \"cfg-if\",\n  \"libc\",\n@@ -1796,9 +1799,9 @@ dependencies = [\n \n [[package]]\n name = \"olpc-cjson\"\n-version = \"0.1.1\"\n+version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"72ca49fe685014bbf124ee547da94ed7bb65a6eb9dc9c4711773c081af96a39c\"\n+checksum = \"87dc75cf72208cd853671c1abccc5d5d1e43b1e378dde67340ef933219a8c13c\"\n dependencies = [\n  \"serde\",\n  \"serde_json\",\n@@ -3142,9 +3145,9 @@ checksum = \"ea68304e134ecd095ac6c3574494fc62b909f416c4fca77e440530221e549d3d\"\n \n [[package]]\n name = \"tough\"\n-version = \"0.12.4\"\n+version = \"0.12.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"70a537c6b4307f5401e82a0196e97aaab9599e9c0f880e168eafb176abbac63d\"\n+checksum = \"dc636dd1ee889a366af6731f1b63b60baf19528b46df5a7c2d4b3bf8b60bca2d\"\n dependencies = [\n  \"chrono\",\n  \"dyn-clone\",\n@@ -3169,9 +3172,9 @@ dependencies = [\n \n [[package]]\n name = \"tough-kms\"\n-version = \"0.4.1\"\n+version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"52e17edfb12e2c08c9ac3fe6ebb43fafc82fa9ffbfffbe50030b7623f8f42f34\"\n+checksum = \"6d12f5356a5902062ec2aaf6ca003b8742c7c8f82e959698fee903275a8ba506\"\n dependencies = [\n  \"aws-config\",\n  \"aws-sdk-kms\",\n@@ -3184,9 +3187,9 @@ dependencies = [\n \n [[package]]\n name = \"tough-ssm\"\n-version = \"0.7.1\"\n+version = \"0.7.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"71e423321963b68b425bc844c01a16bfcab3b8300ab768dad46992201026421e\"\n+checksum = \"dffd50ee15d08e9b104b398e4537acfc3c02f76e1d0c569856290d278bb5180b\"\n dependencies = [\n  \"aws-config\",\n  \"aws-sdk-ssm\",\ndiff --git a/tools/deny.toml b/tools/deny.toml\nindex 372ac1aa821..9e050d23521 100644\n--- a/tools/deny.toml\n+++ b/tools/deny.toml\n@@ -70,7 +70,7 @@ skip-tree = [\n     { name = \"structopt\", version = \"0.3.26\" },\n \n     # aws-smithy-client uses an older hyper-rustls\n-    { name = \"aws-smithy-client\", version = \"0.46.0\" },\n+    { name = \"aws-smithy-client\", version = \"0.48.0\" },\n ]\n \n [sources]\ndiff --git a/tools/pubsys/Cargo.toml b/tools/pubsys/Cargo.toml\nindex 4d30af5c294..903909a0943 100644\n--- a/tools/pubsys/Cargo.toml\n+++ b/tools/pubsys/Cargo.toml\n@@ -8,21 +8,21 @@ publish = false\n \n [dependencies]\n async-trait = \"0.1.53\"\n-aws-config = \"0.46.0\"\n-aws-sdk-ebs = \"0.16.0\"\n-aws-sdk-ec2 = \"0.16.0\"\n-aws-sdk-kms = \"0.16.0\"\n-aws-sdk-ssm = \"0.16.0\"\n-aws-sdk-sts = \"0.16.0\"\n-aws-smithy-types = \"0.46.0\"\n-aws-types = \"0.46.0\"\n+aws-config = \"0.48.0\"\n+aws-sdk-ebs = \"0.18.0\"\n+aws-sdk-ec2 = \"0.18.0\"\n+aws-sdk-kms = \"0.18.0\"\n+aws-sdk-ssm = \"0.18.0\"\n+aws-sdk-sts = \"0.18.0\"\n+aws-smithy-types = \"0.48.0\"\n+aws-types = \"0.48.0\"\n chrono = \"0.4\"\n clap = \"3.1\"\n coldsnap = { version = \"0.4\", default-features = false, features = [\"aws-sdk-rust-rustls\"] }\n duct = \"0.13.0\"\n futures = \"0.3.5\"\n http = \"0.2.8\"\n-indicatif = \"0.16.0\"\n+indicatif = \"0.17.1\"\n lazy_static = \"1.4\"\n log = \"0.4\"\n num_cpus = \"1\"\ndiff --git a/tools/pubsys/src/aws/ami/snapshot.rs b/tools/pubsys/src/aws/ami/snapshot.rs\nindex b26249d85a5..15b25611910 100644\n--- a/tools/pubsys/src/aws/ami/snapshot.rs\n+++ b/tools/pubsys/src/aws/ami/snapshot.rs\n@@ -4,17 +4,18 @@ use snafu::{OptionExt, ResultExt};\n use std::path::Path;\n \n /// Create a progress bar to show status of snapshot blocks, if wanted.\n-fn build_progress_bar(no_progress: bool, verb: &str) -> Option<ProgressBar> {\n+fn build_progress_bar(no_progress: bool, verb: &str) -> Result<Option<ProgressBar>> {\n     if no_progress {\n-        return None;\n+        return Ok(None);\n     }\n     let progress_bar = ProgressBar::new(0);\n     progress_bar.set_style(\n         ProgressStyle::default_bar()\n             .template(&[\"  \", verb, \"  [{bar:50.white/black}] {pos}/{len} ({eta})\"].concat())\n+            .context(error::ProgressBarTemplateSnafu)?\n             .progress_chars(\"=> \"),\n     );\n-    Some(progress_bar)\n+    Ok(Some(progress_bar))\n }\n \n /// Uploads the given path into a snapshot.\n@@ -35,7 +36,7 @@ where\n         .to_string_lossy();\n \n     uploader\n-        .upload_from_file(path, desired_size, Some(&filename), progress_bar)\n+        .upload_from_file(path, desired_size, Some(&filename), progress_bar?)\n         .await\n         .context(error::UploadSnapshotSnafu)\n }\n@@ -51,6 +52,11 @@ mod error {\n         #[snafu(display(\"Invalid image path '{}'\", path.display()))]\n         InvalidImagePath { path: PathBuf },\n \n+        #[snafu(display(\"Failed to parse progress style template: {}\", source))]\n+        ProgressBarTemplate {\n+            source: indicatif::style::TemplateError,\n+        },\n+\n         #[snafu(display(\"Failed to upload snapshot: {}\", source))]\n         UploadSnapshot { source: coldsnap::UploadError },\n     }\n", "test_patch": "diff --git a/tools/testsys/Cargo.toml b/tools/testsys/Cargo.toml\nindex 0da89992484..a02b2636303 100644\n--- a/tools/testsys/Cargo.toml\n+++ b/tools/testsys/Cargo.toml\n@@ -8,8 +8,8 @@ publish = false\n \n [dependencies]\n anyhow = \"1.0\"\n-aws-config = \"0.46\"\n-aws-sdk-ec2 = \"0.16\"\n+aws-config = \"0.48\"\n+aws-sdk-ec2 = \"0.18\"\n bottlerocket-types = { git = \"https://github.com/bottlerocket-os/bottlerocket-test-system\", rev = \"07b9ae8\", version = \"0.0.1\"}\n bottlerocket-variant = { version = \"0.1\", path = \"../../sources/bottlerocket-variant\" }\n clap = { version = \"3\", features = [\"derive\", \"env\"] }\n", "problem_statement": "Update rust dependencies for 1.10.0\n<!--\r\nTips:\r\n- Please search for similar requests, including closed issues.\r\n- Please include details about the environment you're running in.\r\n-->\r\n\r\nWe should update dependencies of our Rust packages in Bottlerocket to prepare for 1.10.0. \r\n\r\nWe did this for 1.9.0 in https://github.com/bottlerocket-os/bottlerocket/pull/2303\r\n\r\n---\r\n**Update tasks:**\r\n- [x] cargo update `sources` #2458 \r\n- [x] cargo update `tools` #2458 \r\n- [x] Update `tough` https://github.com/awslabs/tough/pull/514 https://github.com/awslabs/tough/pull/516 https://github.com/awslabs/tough/pull/518\r\n- [x] Update `coldsnap` https://github.com/awslabs/coldsnap/pull/197 https://github.com/awslabs/coldsnap/pull/201\r\n- [x] Update AWS SDK for Rust and `tough` in `sources` https://github.com/bottlerocket-os/bottlerocket/pull/2476\r\n- [x] Update AWS SDK for Rust, `tough`, `coldsnap`, and `indicatif` in `tools` https://github.com/bottlerocket-os/bottlerocket/pull/2476\r\n\r\n\r\n\n", "hints_text": "", "created_at": "2022-10-03T23:41:47Z"}, {"repo": "bottlerocket-os/bottlerocket", "pull_number": 2445, "instance_id": "bottlerocket-os__bottlerocket-2445", "issue_numbers": ["2204"], "base_commit": "d04eaa730285cf32430c3897bf33b4593042242c", "patch": "diff --git a/PROVISIONING-METAL.md b/PROVISIONING-METAL.md\nindex 33427d52ded..ae9299769aa 100644\n--- a/PROVISIONING-METAL.md\n+++ b/PROVISIONING-METAL.md\n@@ -76,7 +76,7 @@ When these services fail, your machine will not connect to any cluster and will\n #### `net.toml` structure\n \n The configuration file must be valid TOML and have the filename `net.toml`.\n-The first and required top level key in the file is `version`, currently only `1` is supported.\n+The first and required top level key in the file is `version`; the latest is version `2`.\n The rest of the file is a map of interface name to supported settings.\n Interface names are expected to be correct as per `udevd` naming, no interface naming or matching is supported.\n (See the note below regarding `udevd` interface naming.)\n@@ -92,9 +92,22 @@ Interface names are expected to be correct as per `udevd` naming, no interface n\n   * `enabled` (boolean, required): Enables DHCP6.\n   * `optional` (boolean): the system will request a lease using this protocol, but will not wait for a valid lease to consider this interface configured.\n \n+As of version `2` static addressing with simple routes is supported via the below settings.\n+Please keep in mind that when using static addresses, DNS information must be supplied to the system via user data: [`settings.dns`](https://github.com/bottlerocket-os/bottlerocket#network-settings).\n+* `static4` (map): IPv4 static address settings.\n+  * `addresses` (list of quoted IPv4 address including prefix): The desired IPv4 IP addresses, including prefix i.e. `[\"192.168.14.2/24\"]`.  The first IP in the list will be used as the primary IP which `kubelet` will use when joining the cluster.  If IPv4 and IPv6 static addresses exist, the first IPv4 address is used.\n+* `static6` (map): IPv6 static address settings.\n+  * `addresses` (list of quoted IPv6 address including prefix): The desired IPv6 IP addresses, including prefix i.e. `[\"2001:dead:beef::2/64\"]`.  The first IP in the list will be used as the primary IP which `kubelet` will use when joining the cluster.  If IPv4 and IPv6 static addresses exist, the first IPv4 address is used.\n+\n+* `route` (map): Static route; multiple routes can be added. (cannot be used in conjuction with DHCP)\n+  * `to` (`\"default\"` or IP address with prefix, required): Destination address.\n+  * `from` (IP address): Source IP address.\n+  * `via` (IP address): Gateway IP address.  If no gateway is provided, a scope of `link` is assumed.\n+  * `route-metric` (integer): Relative route priority.\n+\n Example `net.toml` with comments:\n ```toml\n-version = 1\n+version = 2\n \n # \"eno1\" is the interface name\n [eno1]\n@@ -108,12 +121,35 @@ primary = true\n # `enabled` is a boolean and is a required key when\n # setting up DHCP this way\n enabled = true\n-# Route metric may be supplied for ipv4\n+# Route metric may be supplied for IPv4\n route-metric = 200\n \n [eno2.dhcp6]\n enabled = true\n optional = true\n+\n+[eno3.static4]\n+addresses = [\"10.0.0.10/24\", \"11.0.0.11/24\"]\n+\n+# Multiple routes may be configured\n+[[eno3.route]]\n+to = \"default\"\n+via = \"10.0.0.1\"\n+route-metric = 100\n+\n+[[eno3.route]]\n+to = \"default\"\n+via = \"11.0.0.1\"\n+route-metric = 200\n+\n+[eno4.static4]\n+addresses = [\"192.168.14.5/24\"]\n+\n+# Using a source IP and non-default route\n+[[eno4.route]]\n+to = \"10.10.10.0/24\"\n+from = \"192.168.14.5\"\n+via = \"192.168.14.25\"\n ```\n \n **An additional note on network device names**\ndiff --git a/sources/api/netdog/src/cli/install.rs b/sources/api/netdog/src/cli/install.rs\nindex 02fe3490668..6e5b9d9cdb7 100644\n--- a/sources/api/netdog/src/cli/install.rs\n+++ b/sources/api/netdog/src/cli/install.rs\n@@ -1,12 +1,12 @@\n use super::{error, InterfaceFamily, InterfaceType, Result};\n use crate::dns::DnsSettings;\n-use crate::lease::{lease_path, LeaseInfo};\n+use crate::lease::{dhcp_lease_path, static_lease_path, LeaseInfo};\n use crate::{CURRENT_IP, PRIMARY_INTERFACE};\n use argh::FromArgs;\n-use snafu::{OptionExt, ResultExt};\n+use snafu::{ensure, OptionExt, ResultExt};\n use std::fs;\n use std::net::IpAddr;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n #[derive(FromArgs, PartialEq, Debug)]\n #[argh(subcommand, name = \"install\")]\n@@ -50,36 +50,57 @@ pub(crate) fn run(args: InstallArgs) -> Result<()> {\n     }\n \n     match (&args.interface_type, &args.interface_family) {\n-        (InterfaceType::Dhcp, InterfaceFamily::Ipv4 | InterfaceFamily::Ipv6) => {\n-            // A lease should exist when using DHCP\n-            let primary_lease_path =\n-                lease_path(&primary_interface).context(error::MissingLeaseSnafu {\n-                    interface: primary_interface,\n-                })?;\n-            if args.data_file != primary_lease_path {\n-                return error::PrimaryLeaseConflictSnafu {\n-                    wicked_path: args.data_file,\n-                    generated_path: primary_lease_path,\n-                }\n-                .fail();\n-            }\n-\n-            // Use DNS API settings if they exist, supplementing any missing settings with settings\n-            // derived from the primary interface's DHCP lease\n-            let lease =\n-                LeaseInfo::from_lease(primary_lease_path).context(error::LeaseParseFailedSnafu)?;\n-            let dns_settings = DnsSettings::from_config_or_lease(Some(&lease))\n-                .context(error::GetDnsSettingsSnafu)?;\n-            dns_settings\n-                .write_resolv_conf()\n-                .context(error::ResolvConfWriteFailedSnafu)?;\n-\n+        (\n+            interface_type @ (InterfaceType::Dhcp | InterfaceType::Static),\n+            InterfaceFamily::Ipv4 | InterfaceFamily::Ipv6,\n+        ) => {\n+            let lease = fetch_lease(primary_interface, interface_type, args.data_file)?;\n+            write_resolv_conf(&lease)?;\n             write_current_ip(&lease.ip_address.addr())?;\n         }\n     }\n     Ok(())\n }\n \n+/// Given an interface, its type, and wicked's known location of the lease, compare our known lease\n+/// location, parse and return a LeaseInfo.\n+fn fetch_lease<S, P>(\n+    interface: S,\n+    interface_type: &InterfaceType,\n+    data_file: P,\n+) -> Result<LeaseInfo>\n+where\n+    S: AsRef<str>,\n+    P: AsRef<Path>,\n+{\n+    let interface = interface.as_ref();\n+    let data_file = data_file.as_ref();\n+    let lease_path = match interface_type {\n+        InterfaceType::Dhcp => dhcp_lease_path(interface),\n+        InterfaceType::Static => static_lease_path(interface),\n+    }\n+    .context(error::MissingLeaseSnafu { interface })?;\n+\n+    ensure!(\n+        data_file == lease_path,\n+        error::PrimaryLeaseConflictSnafu {\n+            wicked_path: data_file,\n+            generated_path: lease_path,\n+        }\n+    );\n+\n+    LeaseInfo::from_lease(&lease_path).context(error::LeaseParseFailedSnafu)\n+}\n+\n+/// Given a lease, fetch DNS settings from the lease and/or config and write the resolv.conf\n+fn write_resolv_conf(lease: &LeaseInfo) -> Result<()> {\n+    let dns_settings =\n+        DnsSettings::from_config_or_lease(Some(lease)).context(error::GetDnsSettingsSnafu)?;\n+    dns_settings\n+        .write_resolv_conf()\n+        .context(error::ResolvConfWriteFailedSnafu)\n+}\n+\n /// Persist the current IP address to file\n fn write_current_ip(ip: &IpAddr) -> Result<()> {\n     fs::write(CURRENT_IP, ip.to_string())\ndiff --git a/sources/api/netdog/src/cli/mod.rs b/sources/api/netdog/src/cli/mod.rs\nindex b43560ac1b5..de8709ffb1c 100644\n--- a/sources/api/netdog/src/cli/mod.rs\n+++ b/sources/api/netdog/src/cli/mod.rs\n@@ -22,6 +22,7 @@ pub(crate) use write_resolv_conf::WriteResolvConfArgs;\n #[serde(rename_all = \"kebab-case\")]\n enum InterfaceType {\n     Dhcp,\n+    Static,\n }\n \n #[derive(Debug, PartialEq, Deserialize)]\ndiff --git a/sources/api/netdog/src/cli/write_resolv_conf.rs b/sources/api/netdog/src/cli/write_resolv_conf.rs\nindex f15208f31e7..552c2ca0b01 100644\n--- a/sources/api/netdog/src/cli/write_resolv_conf.rs\n+++ b/sources/api/netdog/src/cli/write_resolv_conf.rs\n@@ -1,6 +1,6 @@\n use super::{error, Result};\n use crate::dns::DnsSettings;\n-use crate::lease::{lease_path, LeaseInfo};\n+use crate::lease::{dhcp_lease_path, LeaseInfo};\n use crate::PRIMARY_INTERFACE;\n use argh::FromArgs;\n use snafu::ResultExt;\n@@ -12,8 +12,9 @@ use std::fs;\n pub(crate) struct WriteResolvConfArgs {}\n \n pub(crate) fn run() -> Result<()> {\n-    // Use DNS API settings if they exist, supplementing any missing settings with settings\n-    // derived from the primary interface's DHCP lease if it exists\n+    // Use DNS API settings if they exist, supplementing any missing settings with settings derived\n+    // from the primary interface's DHCP lease if it exists.  Static leases don't contain any DNS\n+    // data, so don't bother looking there.\n     let primary_interface = fs::read_to_string(PRIMARY_INTERFACE)\n         .context(error::PrimaryInterfaceReadSnafu {\n             path: PRIMARY_INTERFACE,\n@@ -21,7 +22,7 @@ pub(crate) fn run() -> Result<()> {\n         .trim()\n         .to_lowercase();\n \n-    let primary_lease_path = lease_path(&primary_interface);\n+    let primary_lease_path = dhcp_lease_path(&primary_interface);\n     let dns_settings = if let Some(primary_lease_path) = primary_lease_path {\n         let lease =\n             LeaseInfo::from_lease(&primary_lease_path).context(error::LeaseParseFailedSnafu)?;\ndiff --git a/sources/api/netdog/src/dns.rs b/sources/api/netdog/src/dns.rs\nindex c76c7d88e14..10ccc5c3ffe 100644\n--- a/sources/api/netdog/src/dns.rs\n+++ b/sources/api/netdog/src/dns.rs\n@@ -37,7 +37,7 @@ impl DnsSettings {\n     /// Merge missing DNS settings into `self` using DHCP lease\n     fn merge_lease(&mut self, lease: &LeaseInfo) {\n         if self.nameservers.is_none() {\n-            self.nameservers = Some(lease.dns_servers.clone());\n+            self.nameservers = lease.dns_servers.clone();\n         }\n \n         if self.search.is_none() {\ndiff --git a/sources/api/netdog/src/lease.rs b/sources/api/netdog/src/lease.rs\nindex 81c4a0eb080..36772b93cb5 100644\n--- a/sources/api/netdog/src/lease.rs\n+++ b/sources/api/netdog/src/lease.rs\n@@ -21,10 +21,13 @@ lazy_static! {\n #[derive(Debug, Deserialize)]\n #[allow(dead_code)]\n pub(crate) struct LeaseInfo {\n+    // When multiple IP addresses exist for an interface, the second address's key in the lease\n+    // file will be `IPADDR_1`, `IPADDR_2`, and so on.  Parsing the lease for \"ipaddr\" means we\n+    // will always pick up the first configured IP address.\n     #[serde(rename = \"ipaddr\")]\n     pub(crate) ip_address: IpNet,\n     #[serde(rename = \"dnsservers\")]\n-    pub(crate) dns_servers: BTreeSet<IpAddr>,\n+    pub(crate) dns_servers: Option<BTreeSet<IpAddr>>,\n     #[serde(rename = \"dnsdomain\")]\n     pub(crate) dns_domain: Option<String>,\n     #[serde(rename = \"dnssearch\")]\n@@ -63,15 +66,36 @@ impl LeaseInfo {\n     }\n }\n \n-/// Return the path to a given interface's ipv4/ipv6 lease if it exists, favoring ipv4 if both\n+/// Return the path to a given interface's DHCP ipv4/ipv6 lease if it exists, favoring ipv4 if both\n /// ipv4 and ipv6 exist\n-pub(crate) fn lease_path<S>(interface: S) -> Option<PathBuf>\n+pub(crate) fn dhcp_lease_path<S>(interface: S) -> Option<PathBuf>\n where\n     S: AsRef<str>,\n {\n+    get_lease_path(\"dhcp\", interface)\n+}\n+\n+/// Return the path to a given interface's static ipv4/ipv6 lease if it exists, favoring ipv4 if\n+/// both ipv4 and ipv6 exist\n+pub(crate) fn static_lease_path<S>(interface: S) -> Option<PathBuf>\n+where\n+    S: AsRef<str>,\n+{\n+    get_lease_path(\"static\", interface)\n+}\n+\n+/// Given a lease type and interface, return the path to the ipv4/6 lease file if it exists,\n+/// favoring ipv4 if both ipv4 and ipv6 exist\n+fn get_lease_path<S1, S2>(lease_type: S1, interface: S2) -> Option<PathBuf>\n+where\n+    S1: AsRef<str>,\n+    S2: AsRef<str>,\n+{\n+    let lease_type = lease_type.as_ref();\n     let interface = interface.as_ref();\n-    let ipv4 = Path::new(LEASE_DIR).join(format!(\"leaseinfo.{}.dhcp.ipv4\", interface));\n-    let ipv6 = Path::new(LEASE_DIR).join(format!(\"leaseinfo.{}.dhcp.ipv6\", interface));\n+\n+    let ipv4 = Path::new(LEASE_DIR).join(format!(\"leaseinfo.{}.{}.ipv4\", interface, lease_type));\n+    let ipv6 = Path::new(LEASE_DIR).join(format!(\"leaseinfo.{}.{}.ipv6\", interface, lease_type));\n \n     // If both ipv4 and ipv6 leases exist, use the ipv4 lease for DNS settings\n     let ipv4_exists = Path::exists(&ipv4);\ndiff --git a/sources/api/netdog/src/net_config/mod.rs b/sources/api/netdog/src/net_config/mod.rs\nindex c76f3f81c02..977203eebce 100644\n--- a/sources/api/netdog/src/net_config/mod.rs\n+++ b/sources/api/netdog/src/net_config/mod.rs\n@@ -5,13 +5,16 @@\n //! These structures are the user-facing options for configuring one or more network interfaces.\n mod dhcp;\n mod error;\n+mod static_address;\n mod v1;\n+mod v2;\n \n use crate::wicked::WickedInterface;\n pub(crate) use dhcp::{Dhcp4ConfigV1, Dhcp4OptionsV1, Dhcp6ConfigV1, Dhcp6OptionsV1};\n pub(crate) use error::{Error, Result};\n use serde::Deserialize;\n use snafu::{ensure, ResultExt};\n+pub(crate) use static_address::{RouteTo, RouteV1, StaticConfigV1};\n use std::fs;\n use std::path::Path;\n use std::str::FromStr;\n@@ -93,7 +96,8 @@ fn deserialize_config(config_str: &str) -> Result<Box<dyn Interfaces>> {\n     } = toml::from_str(config_str).context(error::NetConfigParseSnafu)?;\n \n     let net_config: Box<dyn Interfaces> = match version {\n-        1 => validate_config::<NetConfigV1>(interface_config)?,\n+        1 => validate_config::<v1::NetConfigV1>(interface_config)?,\n+        2 => validate_config::<v2::NetConfigV2>(interface_config)?,\n         _ => {\n             return error::InvalidNetConfigSnafu {\n                 reason: format!(\"Unknown network config version: {}\", version),\ndiff --git a/sources/api/netdog/src/net_config/static_address.rs b/sources/api/netdog/src/net_config/static_address.rs\nnew file mode 100644\nindex 00000000000..9d4c7beceba\n--- /dev/null\n+++ b/sources/api/netdog/src/net_config/static_address.rs\n@@ -0,0 +1,65 @@\n+use ipnet::IpNet;\n+use serde::Deserialize;\n+use snafu::ResultExt;\n+use std::collections::BTreeSet;\n+use std::convert::TryFrom;\n+use std::net::IpAddr;\n+\n+#[derive(Clone, Debug, Deserialize)]\n+#[serde(deny_unknown_fields)]\n+pub(crate) struct StaticConfigV1 {\n+    pub(crate) addresses: BTreeSet<IpNet>,\n+}\n+\n+#[derive(Clone, Debug, Deserialize)]\n+#[serde(deny_unknown_fields)]\n+pub(crate) struct RouteV1 {\n+    pub(crate) to: RouteTo,\n+    pub(crate) from: Option<IpAddr>,\n+    pub(crate) via: Option<IpAddr>,\n+    #[serde(rename = \"route-metric\")]\n+    pub(crate) route_metric: Option<u32>,\n+}\n+\n+#[derive(Clone, Debug, Deserialize)]\n+#[serde(try_from = \"String\")]\n+pub(crate) enum RouteTo {\n+    DefaultRoute,\n+    Ip(IpNet),\n+}\n+\n+// Allows the user to pass the string \"default\" or a valid ip address prefix.  We can't use an\n+// untagged enum for this (#[serde(untagged)]) because \"default\" directly maps to one of the\n+// variants.  Serde will only allow the \"untagged\" attribute if neither variant directly matches.\n+impl TryFrom<String> for RouteTo {\n+    type Error = error::Error;\n+\n+    fn try_from(input: String) -> Result<Self> {\n+        let input = input.to_lowercase();\n+        Ok(match input.as_str() {\n+            \"default\" => RouteTo::DefaultRoute,\n+            _ => {\n+                let ip: IpNet = input\n+                    .parse()\n+                    .context(error::InvalidRouteDestinationSnafu { input })?;\n+                RouteTo::Ip(ip)\n+            }\n+        })\n+    }\n+}\n+\n+mod error {\n+    use snafu::Snafu;\n+\n+    #[derive(Debug, Snafu)]\n+    #[snafu(visibility(pub(crate)))]\n+    pub(crate) enum Error {\n+        #[snafu(display(\"Invalid route destination, must be 'default' or a valid IP address prefix.  Received '{}': {}\", input, source))]\n+        InvalidRouteDestination {\n+            input: String,\n+            source: ipnet::AddrParseError,\n+        },\n+    }\n+}\n+\n+type Result<T> = std::result::Result<T, error::Error>;\ndiff --git a/sources/api/netdog/src/net_config/v1.rs b/sources/api/netdog/src/net_config/v1.rs\nindex 1ecf7c08356..9b39ec37587 100644\n--- a/sources/api/netdog/src/net_config/v1.rs\n+++ b/sources/api/netdog/src/net_config/v1.rs\n@@ -5,7 +5,7 @@ use super::{error, Dhcp4ConfigV1, Dhcp6ConfigV1, Error, Interfaces, Result, Vali\n use crate::{\n     interface_name::InterfaceName,\n     net_config::{Dhcp4OptionsV1, Dhcp6OptionsV1},\n-    wicked::{WickedControl, WickedDhcp4, WickedDhcp6, WickedInterface},\n+    wicked::{WickedDhcp4, WickedDhcp6, WickedInterface},\n };\n use indexmap::indexmap;\n use indexmap::IndexMap;\n@@ -55,13 +55,11 @@ impl Interfaces for NetConfigV1 {\n         for (name, config) in &self.interfaces {\n             let wicked_dhcp4 = config.dhcp4.clone().map(WickedDhcp4::from);\n             let wicked_dhcp6 = config.dhcp6.clone().map(WickedDhcp6::from);\n-            let wicked_interface = WickedInterface {\n-                name: name.clone(),\n-                control: WickedControl::default(),\n-                ipv4_dhcp: wicked_dhcp4,\n-                ipv6_dhcp: wicked_dhcp6,\n-            };\n-            wicked_interfaces.push(wicked_interface)\n+            let mut interface = WickedInterface::new(name.clone());\n+            interface.ipv4_dhcp = wicked_dhcp4;\n+            interface.ipv6_dhcp = wicked_dhcp6;\n+\n+            wicked_interfaces.push(interface)\n         }\n \n         wicked_interfaces\ndiff --git a/sources/api/netdog/src/net_config/v2.rs b/sources/api/netdog/src/net_config/v2.rs\nnew file mode 100644\nindex 00000000000..1dd4965fd33\n--- /dev/null\n+++ b/sources/api/netdog/src/net_config/v2.rs\n@@ -0,0 +1,145 @@\n+//! The `v2` module contains the second version of the network configuration and implements the\n+//! appropriate traits.\n+\n+use super::static_address::{RouteV1, StaticConfigV1};\n+use super::{error, Dhcp4ConfigV1, Dhcp6ConfigV1, Interfaces, Result, Validate};\n+use crate::interface_name::InterfaceName;\n+use crate::wicked::{WickedDhcp4, WickedDhcp6, WickedInterface, WickedRoutes, WickedStaticAddress};\n+use indexmap::IndexMap;\n+use ipnet::IpNet;\n+use serde::Deserialize;\n+use snafu::ensure;\n+\n+#[derive(Debug, Deserialize)]\n+pub(crate) struct NetConfigV2 {\n+    #[serde(flatten)]\n+    pub(crate) interfaces: IndexMap<InterfaceName, NetInterfaceV2>,\n+}\n+\n+#[derive(Debug, Deserialize)]\n+#[serde(deny_unknown_fields)]\n+pub(crate) struct NetInterfaceV2 {\n+    // Use this interface as the primary interface for the system\n+    pub(crate) primary: Option<bool>,\n+    pub(crate) dhcp4: Option<Dhcp4ConfigV1>,\n+    pub(crate) dhcp6: Option<Dhcp6ConfigV1>,\n+    pub(crate) static4: Option<StaticConfigV1>,\n+    pub(crate) static6: Option<StaticConfigV1>,\n+    #[serde(rename = \"route\")]\n+    pub(crate) routes: Option<Vec<RouteV1>>,\n+}\n+\n+impl Interfaces for NetConfigV2 {\n+    fn primary_interface(&self) -> Option<String> {\n+        self.interfaces\n+            .iter()\n+            .find(|(_, v)| v.primary == Some(true))\n+            .or_else(|| self.interfaces.first())\n+            .map(|(n, _)| n.to_string())\n+    }\n+\n+    fn has_interfaces(&self) -> bool {\n+        !self.interfaces.is_empty()\n+    }\n+\n+    fn as_wicked_interfaces(&self) -> Vec<WickedInterface> {\n+        let mut wicked_interfaces = Vec::with_capacity(self.interfaces.len());\n+        for (name, config) in &self.interfaces {\n+            let mut interface = WickedInterface::new(name.clone());\n+            interface.ipv4_dhcp = config.dhcp4.clone().map(WickedDhcp4::from);\n+            interface.ipv6_dhcp = config.dhcp6.clone().map(WickedDhcp6::from);\n+\n+            // Based on the existence of static addresses and routes, create the ipv4/6_static\n+            // struct members.  They must be `Option`s because we want to avoid serializing empty\n+            // tags into the config file\n+            let maybe_routes = config.routes.clone().map(WickedRoutes::from);\n+            let maybe_ipv4_static = WickedStaticAddress::maybe_new(\n+                config.static4.clone(),\n+                maybe_routes.as_ref().and_then(|s| s.ipv4.clone()),\n+            );\n+            let maybe_ipv6_static = WickedStaticAddress::maybe_new(\n+                config.static6.clone(),\n+                maybe_routes.as_ref().and_then(|s| s.ipv6.clone()),\n+            );\n+            interface.ipv4_static = maybe_ipv4_static;\n+            interface.ipv6_static = maybe_ipv6_static;\n+\n+            wicked_interfaces.push(interface);\n+        }\n+\n+        wicked_interfaces\n+    }\n+}\n+\n+impl Validate for NetConfigV2 {\n+    fn validate(&self) -> Result<()> {\n+        for (_name, config) in &self.interfaces {\n+            let has_static = config.static4.is_some() || config.static6.is_some();\n+            let has_dhcp = config.dhcp4.is_some() || config.dhcp6.is_some();\n+            let has_routes = config.routes.is_some();\n+\n+            if !has_dhcp && !has_static {\n+                return error::InvalidNetConfigSnafu {\n+                    reason: \"each interface must configure dhcp and/or static addresses\",\n+                }\n+                .fail();\n+            }\n+\n+            // wicked doesn't support static routes with dhcp\n+            if has_dhcp && has_routes {\n+                return error::InvalidNetConfigSnafu {\n+                    reason: \"static routes are not supported with dhcp\",\n+                }\n+                .fail();\n+            }\n+\n+            if has_routes && !has_static {\n+                return error::InvalidNetConfigSnafu {\n+                    reason: \"interfaces must set static addresses in order to use routes\",\n+                }\n+                .fail();\n+            }\n+\n+            if let Some(config) = &config.static4 {\n+                ensure!(\n+                    config.addresses.iter().all(|a| matches!(a, IpNet::V4(_))),\n+                    error::InvalidNetConfigSnafu {\n+                        reason: \"'static4' may only contain IPv4 addresses\"\n+                    }\n+                )\n+            }\n+\n+            if let Some(config) = &config.static6 {\n+                ensure!(\n+                    config.addresses.iter().all(|a| matches!(a, IpNet::V6(_))),\n+                    error::InvalidNetConfigSnafu {\n+                        reason: \"'static6' may only contain IPv6 addresses\"\n+                    }\n+                )\n+            }\n+        }\n+\n+        let primary_count = self\n+            .interfaces\n+            .values()\n+            .filter(|v| v.primary == Some(true))\n+            .count();\n+        ensure!(\n+            primary_count <= 1,\n+            error::InvalidNetConfigSnafu {\n+                reason: \"multiple primary interfaces defined, expected 1\"\n+            }\n+        );\n+\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::net_config::test_macros::{basic_tests, dhcp_tests, static_address_tests};\n+\n+    basic_tests!(2);\n+    dhcp_tests!(2);\n+    static_address_tests!(2);\n+}\ndiff --git a/sources/api/netdog/src/wicked/dhcp.rs b/sources/api/netdog/src/wicked/dhcp.rs\nnew file mode 100644\nindex 00000000000..3caba072868\n--- /dev/null\n+++ b/sources/api/netdog/src/wicked/dhcp.rs\n@@ -0,0 +1,119 @@\n+use crate::net_config::{Dhcp4ConfigV1, Dhcp4OptionsV1, Dhcp6ConfigV1, Dhcp6OptionsV1};\n+use serde::Serialize;\n+\n+#[derive(Debug, Clone, Serialize, PartialEq)]\n+#[serde(rename_all = \"kebab-case\")]\n+pub(crate) struct WickedDhcp4 {\n+    #[serde(rename = \"$unflatten=enabled\")]\n+    enabled: bool,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    #[serde(rename = \"$unflatten=route-priority\")]\n+    route_priority: Option<u32>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    #[serde(rename = \"$unflatten=defer-timeout\")]\n+    defer_timeout: Option<u32>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    flags: Option<AddrConfFlags>,\n+}\n+\n+impl Default for WickedDhcp4 {\n+    fn default() -> Self {\n+        WickedDhcp4 {\n+            enabled: true,\n+            route_priority: None,\n+            defer_timeout: None,\n+            flags: None,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize, PartialEq)]\n+#[serde(rename_all = \"kebab-case\")]\n+pub(crate) struct WickedDhcp6 {\n+    #[serde(rename = \"$unflatten=enabled\")]\n+    enabled: bool,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    #[serde(rename = \"$unflatten=defer-timeout\")]\n+    defer_timeout: Option<u32>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    flags: Option<AddrConfFlags>,\n+}\n+\n+impl Default for WickedDhcp6 {\n+    fn default() -> Self {\n+        WickedDhcp6 {\n+            enabled: true,\n+            defer_timeout: None,\n+            flags: None,\n+        }\n+    }\n+}\n+\n+// This is technically an enum, but considering we don't expose anything other than \"optional\" to\n+// the user, a struct makes handling tags much simpler.\n+#[derive(Default, Clone, Debug, Serialize, PartialEq)]\n+struct AddrConfFlags {\n+    #[serde(rename = \"$unflatten=optional\")]\n+    optional: (),\n+}\n+\n+impl From<Dhcp4ConfigV1> for WickedDhcp4 {\n+    fn from(dhcp4: Dhcp4ConfigV1) -> Self {\n+        match dhcp4 {\n+            Dhcp4ConfigV1::DhcpEnabled(b) => WickedDhcp4 {\n+                enabled: b,\n+                ..Default::default()\n+            },\n+            Dhcp4ConfigV1::WithOptions(o) => WickedDhcp4::from(o),\n+        }\n+    }\n+}\n+\n+impl From<Dhcp4OptionsV1> for WickedDhcp4 {\n+    fn from(options: Dhcp4OptionsV1) -> Self {\n+        let mut defer_timeout = None;\n+        let mut flags = None;\n+\n+        if options.optional == Some(true) {\n+            defer_timeout = Some(1);\n+            flags = Some(AddrConfFlags::default());\n+        }\n+\n+        WickedDhcp4 {\n+            enabled: options.enabled,\n+            route_priority: options.route_metric,\n+            defer_timeout,\n+            flags,\n+        }\n+    }\n+}\n+\n+impl From<Dhcp6ConfigV1> for WickedDhcp6 {\n+    fn from(dhcp6: Dhcp6ConfigV1) -> Self {\n+        match dhcp6 {\n+            Dhcp6ConfigV1::DhcpEnabled(b) => WickedDhcp6 {\n+                enabled: b,\n+                ..Default::default()\n+            },\n+            Dhcp6ConfigV1::WithOptions(o) => WickedDhcp6::from(o),\n+        }\n+    }\n+}\n+\n+impl From<Dhcp6OptionsV1> for WickedDhcp6 {\n+    fn from(options: Dhcp6OptionsV1) -> Self {\n+        let mut defer_timeout = None;\n+        let mut flags = None;\n+\n+        if options.optional == Some(true) {\n+            defer_timeout = Some(1);\n+            flags = Some(AddrConfFlags::default());\n+        }\n+\n+        WickedDhcp6 {\n+            enabled: options.enabled,\n+            defer_timeout,\n+            flags,\n+        }\n+    }\n+}\ndiff --git a/sources/api/netdog/src/wicked.rs b/sources/api/netdog/src/wicked/mod.rs\nsimilarity index 56%\nrename from sources/api/netdog/src/wicked.rs\nrename to sources/api/netdog/src/wicked/mod.rs\nindex 3762c0a6e31..ad2f13a8986 100644\n--- a/sources/api/netdog/src/wicked.rs\n+++ b/sources/api/netdog/src/wicked/mod.rs\n@@ -3,10 +3,14 @@\n //!\n //! The structures in this module are meant to be created from the user-facing structures in the\n //! `net_config` module.  `Default` implementations for WickedInterface exist here as well.\n+mod dhcp;\n+mod static_address;\n+\n use crate::interface_name::InterfaceName;\n-use crate::net_config::{Dhcp4ConfigV1, Dhcp4OptionsV1, Dhcp6ConfigV1, Dhcp6OptionsV1};\n+pub(crate) use dhcp::{WickedDhcp4, WickedDhcp6};\n use serde::Serialize;\n use snafu::ResultExt;\n+pub(crate) use static_address::{WickedRoutes, WickedStaticAddress};\n use std::fs;\n use std::path::Path;\n \n@@ -25,6 +29,12 @@ pub(crate) struct WickedInterface {\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n     #[serde(rename = \"ipv6:dhcp\")]\n     pub(crate) ipv6_dhcp: Option<WickedDhcp6>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    #[serde(rename = \"ipv4:static\")]\n+    pub(crate) ipv4_static: Option<WickedStaticAddress>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    #[serde(rename = \"ipv6:static\")]\n+    pub(crate) ipv6_static: Option<WickedStaticAddress>,\n }\n \n #[derive(Debug, Serialize, PartialEq)]\n@@ -56,124 +66,18 @@ struct LinkDetection {\n     require_link: (),\n }\n \n-#[derive(Debug, Clone, Serialize, PartialEq)]\n-#[serde(rename_all = \"kebab-case\")]\n-pub(crate) struct WickedDhcp4 {\n-    #[serde(rename = \"$unflatten=enabled\")]\n-    enabled: bool,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    #[serde(rename = \"$unflatten=route-priority\")]\n-    route_priority: Option<u32>,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    #[serde(rename = \"$unflatten=defer-timeout\")]\n-    defer_timeout: Option<u32>,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    flags: Option<AddrConfFlags>,\n-}\n-\n-impl Default for WickedDhcp4 {\n-    fn default() -> Self {\n-        WickedDhcp4 {\n-            enabled: true,\n-            route_priority: None,\n-            defer_timeout: None,\n-            flags: None,\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Serialize, PartialEq)]\n-#[serde(rename_all = \"kebab-case\")]\n-pub(crate) struct WickedDhcp6 {\n-    #[serde(rename = \"$unflatten=enabled\")]\n-    enabled: bool,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    #[serde(rename = \"$unflatten=defer-timeout\")]\n-    defer_timeout: Option<u32>,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    flags: Option<AddrConfFlags>,\n-}\n-\n-impl Default for WickedDhcp6 {\n-    fn default() -> Self {\n-        WickedDhcp6 {\n-            enabled: true,\n-            defer_timeout: None,\n-            flags: None,\n-        }\n-    }\n-}\n-\n-// This is technically an enum, but considering we don't expose anything other than \"optional\" to\n-// the user, a struct makes handling tags much simpler.\n-#[derive(Default, Clone, Debug, Serialize, PartialEq)]\n-struct AddrConfFlags {\n-    #[serde(rename = \"$unflatten=optional\")]\n-    optional: (),\n-}\n-\n-impl From<Dhcp4ConfigV1> for WickedDhcp4 {\n-    fn from(dhcp4: Dhcp4ConfigV1) -> Self {\n-        match dhcp4 {\n-            Dhcp4ConfigV1::DhcpEnabled(b) => WickedDhcp4 {\n-                enabled: b,\n-                ..Default::default()\n-            },\n-            Dhcp4ConfigV1::WithOptions(o) => WickedDhcp4::from(o),\n-        }\n-    }\n-}\n-\n-impl From<Dhcp4OptionsV1> for WickedDhcp4 {\n-    fn from(options: Dhcp4OptionsV1) -> Self {\n-        let mut defer_timeout = None;\n-        let mut flags = None;\n-\n-        if options.optional == Some(true) {\n-            defer_timeout = Some(1);\n-            flags = Some(AddrConfFlags::default());\n-        }\n-\n-        WickedDhcp4 {\n-            enabled: options.enabled,\n-            route_priority: options.route_metric,\n-            defer_timeout,\n-            flags,\n-        }\n-    }\n-}\n-\n-impl From<Dhcp6ConfigV1> for WickedDhcp6 {\n-    fn from(dhcp6: Dhcp6ConfigV1) -> Self {\n-        match dhcp6 {\n-            Dhcp6ConfigV1::DhcpEnabled(b) => WickedDhcp6 {\n-                enabled: b,\n-                ..Default::default()\n-            },\n-            Dhcp6ConfigV1::WithOptions(o) => WickedDhcp6::from(o),\n-        }\n-    }\n-}\n-\n-impl From<Dhcp6OptionsV1> for WickedDhcp6 {\n-    fn from(options: Dhcp6OptionsV1) -> Self {\n-        let mut defer_timeout = None;\n-        let mut flags = None;\n-\n-        if options.optional == Some(true) {\n-            defer_timeout = Some(1);\n-            flags = Some(AddrConfFlags::default());\n-        }\n-\n-        WickedDhcp6 {\n-            enabled: options.enabled,\n-            defer_timeout,\n-            flags,\n+impl WickedInterface {\n+    pub(crate) fn new(name: InterfaceName) -> Self {\n+        Self {\n+            name,\n+            control: WickedControl::default(),\n+            ipv4_dhcp: None,\n+            ipv6_dhcp: None,\n+            ipv4_static: None,\n+            ipv6_static: None,\n         }\n     }\n-}\n \n-impl WickedInterface {\n     /// Serialize the interface's configuration file\n     pub(crate) fn write_config_file(&self) -> Result<()> {\n         let mut cfg_path = Path::new(WICKED_CONFIG_DIR).join(self.name.to_string());\n@@ -212,9 +116,13 @@ type Result<T> = std::result::Result<T, error::Error>;\n mod tests {\n     use super::*;\n     use crate::net_config::{self, Interfaces, NetConfigV1};\n+    use handlebars::Handlebars;\n+    use serde::Serialize;\n     use std::path::PathBuf;\n     use std::str::FromStr;\n \n+    static NET_CONFIG_VERSIONS: &[u8] = &[1, 2];\n+\n     fn test_data() -> PathBuf {\n         PathBuf::from(env!(\"CARGO_MANIFEST_DIR\")).join(\"test_data\")\n     }\n@@ -223,10 +131,6 @@ mod tests {\n         test_data().join(\"wicked\")\n     }\n \n-    fn net_config() -> PathBuf {\n-        test_data().join(\"net_config\")\n-    }\n-\n     // Test the end-to-end trip: \"net config from cmdline -> wicked -> serialized XML\"\n     #[test]\n     fn interface_config_from_str() {\n@@ -263,17 +167,52 @@ mod tests {\n     // Test the end to end trip: \"net config -> wicked -> serialized XML\"\n     #[test]\n     fn net_config_to_interface_config() {\n-        let net_config_path = net_config().join(\"net_config.toml\");\n-        let net_config = net_config::from_path(&net_config_path).unwrap().unwrap();\n+        let net_config_path = wicked_config().join(\"net_config.toml\");\n \n-        let wicked_interfaces = net_config.as_wicked_interfaces();\n-        for interface in wicked_interfaces {\n-            let mut path = wicked_config().join(interface.name.to_string());\n-            path.set_extension(\"xml\");\n-            let expected = fs::read_to_string(path).unwrap();\n-            let generated = quick_xml::se::to_string(&interface).unwrap();\n+        for version in NET_CONFIG_VERSIONS {\n+            let temp_config = tempfile::NamedTempFile::new().unwrap();\n \n-            assert_eq!(expected.trim(), generated)\n+            render_config_template(&net_config_path, &temp_config, &version);\n+            let net_config = net_config::from_path(&temp_config).unwrap().unwrap();\n+            let wicked_interfaces = net_config.as_wicked_interfaces();\n+            for interface in wicked_interfaces {\n+                let mut path = wicked_config().join(interface.name.to_string());\n+                path.set_extension(\"xml\");\n+                let expected = fs::read_to_string(path).unwrap();\n+                let generated = quick_xml::se::to_string(&interface).unwrap();\n+                dbg!(&generated);\n+\n+                assert_eq!(\n+                    expected.trim(),\n+                    generated,\n+                    \"failed test for net config version: '{}', interface: '{}'\",\n+                    version,\n+                    interface.name.to_string()\n+                )\n+            }\n+        }\n+    }\n+\n+    fn render_config_template<P1, P2>(template_path: P1, output_path: P2, version: &u8)\n+    where\n+        P1: AsRef<Path>,\n+        P2: AsRef<Path>,\n+    {\n+        #[derive(Serialize)]\n+        struct Context {\n+            version: u8,\n         }\n+\n+        let output_path = output_path.as_ref();\n+        let template_path = template_path.as_ref();\n+        let template_str = fs::read_to_string(template_path).unwrap();\n+\n+        let mut hb = Handlebars::new();\n+        hb.register_template_string(\"template\", &template_str)\n+            .unwrap();\n+\n+        let context = Context { version: *version };\n+        let rendered = hb.render(\"template\", &context).unwrap();\n+        fs::write(output_path, rendered).unwrap()\n     }\n }\ndiff --git a/sources/api/netdog/src/wicked/static_address.rs b/sources/api/netdog/src/wicked/static_address.rs\nnew file mode 100644\nindex 00000000000..fa252fec195\n--- /dev/null\n+++ b/sources/api/netdog/src/wicked/static_address.rs\n@@ -0,0 +1,146 @@\n+use crate::net_config::{RouteTo, RouteV1, StaticConfigV1};\n+use ipnet::IpNet;\n+use lazy_static::lazy_static;\n+use serde::Serialize;\n+use std::net::IpAddr;\n+\n+lazy_static! {\n+    static ref DEFAULT_ROUTE_IPV4: IpNet = \"0.0.0.0/0\".parse().unwrap();\n+    static ref DEFAULT_ROUTE_IPV6: IpNet = \"::/0\".parse().unwrap();\n+}\n+\n+#[derive(Default, Debug, Serialize, PartialEq)]\n+pub(crate) struct WickedStaticAddress {\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    address: Option<Vec<StaticAddress>>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    #[serde(rename = \"route\")]\n+    routes: Option<Vec<WickedRoute>>,\n+}\n+\n+impl WickedStaticAddress {\n+    /// Given the existence, or lack thereof, of addresses and routes, return a\n+    /// WickedStaticAddress.  The reason we return an `Option` here is that we don't want to\n+    /// serialize an empty tag if no addresses or routes exist.\n+    ///\n+    /// If routes exist, but no static addresses exist, we drop them on the floor since there is a\n+    /// guard for this condition when validating the network configuration,\n+    pub(crate) fn maybe_new(\n+        addresses: Option<StaticConfigV1>,\n+        routes: Option<Vec<WickedRoute>>,\n+    ) -> Option<Self> {\n+        let static_addresses: Option<Vec<StaticAddress>> = addresses.map(StaticConfigV1::into);\n+        // Wicked doesn't allow routes with DHCP, and routes are worthless without addresses, so\n+        // don't bother creating anything without addresses\n+        static_addresses.as_ref()?;\n+\n+        Some(WickedStaticAddress {\n+            address: static_addresses,\n+            routes,\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Serialize, PartialEq)]\n+pub(crate) struct StaticAddress {\n+    #[serde(rename = \"$unflatten=local\")]\n+    local: IpNet,\n+}\n+\n+impl From<StaticConfigV1> for Vec<StaticAddress> {\n+    fn from(s: StaticConfigV1) -> Self {\n+        s.addresses\n+            .into_iter()\n+            .map(|a| StaticAddress { local: a })\n+            .collect()\n+    }\n+}\n+\n+#[derive(Clone, Debug, Serialize, PartialEq)]\n+pub(crate) struct WickedRoute {\n+    #[serde(rename = \"$unflatten=destination\")]\n+    destination: IpNet,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    #[serde(rename = \"$unflatten=pref-source\")]\n+    pref_source: Option<IpAddr>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    nexthop: Option<WickedNextHop>,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    #[serde(rename = \"$unflatten=priority\")]\n+    priority: Option<u32>,\n+}\n+\n+impl WickedRoute {\n+    pub(crate) fn is_ipv4(&self) -> bool {\n+        match self.destination {\n+            IpNet::V4(_) => true,\n+            IpNet::V6(_) => false,\n+        }\n+    }\n+\n+    pub(crate) fn is_ipv6(&self) -> bool {\n+        match self.destination {\n+            IpNet::V4(_) => false,\n+            IpNet::V6(_) => true,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, Serialize, PartialEq)]\n+pub(crate) struct WickedNextHop {\n+    #[serde(rename = \"$unflatten=gateway\")]\n+    gateway: Option<IpAddr>,\n+}\n+\n+impl From<RouteV1> for WickedRoute {\n+    fn from(route: RouteV1) -> Self {\n+        let destination = match route.to {\n+            RouteTo::DefaultRoute => match route.via.or(route.from) {\n+                Some(IpAddr::V4(_)) => *DEFAULT_ROUTE_IPV4,\n+                Some(IpAddr::V6(_)) => *DEFAULT_ROUTE_IPV6,\n+                // If no gateway or from is given, assume the ipv4 default\n+                None => *DEFAULT_ROUTE_IPV4,\n+            },\n+            RouteTo::Ip(ip) => ip,\n+        };\n+\n+        let nexthop = WickedNextHop { gateway: route.via };\n+\n+        WickedRoute {\n+            destination,\n+            nexthop: Some(nexthop),\n+            pref_source: route.from,\n+            priority: route.route_metric,\n+        }\n+    }\n+}\n+\n+// This type is not meant to be serialized, it's only purpose is to aggregate and categorize the\n+// ipv4/6 routes on their way to (maybe) being included in a `WickedRoute` which ends up being\n+// serialized to file.\n+#[derive(Clone, Default, Debug, PartialEq)]\n+pub(crate) struct WickedRoutes {\n+    pub(crate) ipv4: Option<Vec<WickedRoute>>,\n+    pub(crate) ipv6: Option<Vec<WickedRoute>>,\n+}\n+\n+impl WickedRoutes {\n+    pub(crate) fn add_route(&mut self, route: WickedRoute) {\n+        if route.is_ipv4() {\n+            self.ipv4.get_or_insert_with(Vec::new).push(route)\n+        } else if route.is_ipv6() {\n+            self.ipv6.get_or_insert_with(Vec::new).push(route)\n+        }\n+    }\n+}\n+\n+impl From<Vec<RouteV1>> for WickedRoutes {\n+    fn from(routes: Vec<RouteV1>) -> Self {\n+        let mut wicked_routes = Self::default();\n+        for route in routes {\n+            let wicked_route = WickedRoute::from(route);\n+            wicked_routes.add_route(wicked_route);\n+        }\n+        wicked_routes\n+    }\n+}\n", "test_patch": "diff --git a/sources/api/netdog/src/net_config/test_macros/mod.rs b/sources/api/netdog/src/net_config/test_macros/mod.rs\nindex 782c7476a16..7677dfa02b6 100644\n--- a/sources/api/netdog/src/net_config/test_macros/mod.rs\n+++ b/sources/api/netdog/src/net_config/test_macros/mod.rs\n@@ -15,9 +15,12 @@\n pub(super) mod basic;\n #[cfg(test)]\n pub(super) mod dhcp;\n+#[cfg(test)]\n+pub(super) mod static_address;\n \n pub(super) use basic::basic_tests;\n pub(super) use dhcp::dhcp_tests;\n+pub(super) use static_address::static_address_tests;\n \n /// gen_boilerplate!() is a convenience macro meant to be used inside of test macros to generate\n /// some generally useful boilerplate code.  It creates a `VERSION` constant in case the test\ndiff --git a/sources/api/netdog/src/net_config/test_macros/static_address.rs b/sources/api/netdog/src/net_config/test_macros/static_address.rs\nnew file mode 100644\nindex 00000000000..0ad472f470e\n--- /dev/null\n+++ b/sources/api/netdog/src/net_config/test_macros/static_address.rs\n@@ -0,0 +1,67 @@\n+macro_rules! static_address_tests {\n+    ($version:expr) => {\n+        mod static_address {\n+            use $crate::net_config::deserialize_config;\n+            use $crate::net_config::test_macros::gen_boilerplate;\n+\n+            gen_boilerplate!($version, \"static_address\");\n+\n+            #[test]\n+            fn ok_config() {\n+                let ok = net_config().join(\"net_config.toml\");\n+                let rendered = render_config_template(ok);\n+                assert!(deserialize_config(&rendered).is_ok())\n+            }\n+\n+            #[test]\n+            fn dhcp_and_static_addresses() {\n+                let ok = net_config().join(\"dhcp_and_static.toml\");\n+                let rendered = render_config_template(ok);\n+                assert!(deserialize_config(&rendered).is_ok())\n+            }\n+\n+            #[test]\n+            fn dhcp_and_routes() {\n+                let bad = net_config().join(\"dhcp_and_routes.toml\");\n+                let rendered = render_config_template(bad);\n+                assert!(deserialize_config(&rendered).is_err())\n+            }\n+\n+            #[test]\n+            fn no_dhcp_or_static() {\n+                let bad = net_config().join(\"no_dhcp_or_static.toml\");\n+                let rendered = render_config_template(bad);\n+                assert!(deserialize_config(&rendered).is_err())\n+            }\n+\n+            #[test]\n+            fn routes_no_addresses() {\n+                let bad = net_config().join(\"routes_no_addresses.toml\");\n+                let rendered = render_config_template(bad);\n+                assert!(deserialize_config(&rendered).is_err())\n+            }\n+\n+            #[test]\n+            fn invalid_static_config() {\n+                let bad = net_config().join(\"invalid_static_config.toml\");\n+                let rendered = render_config_template(bad);\n+                assert!(deserialize_config(&rendered).is_err())\n+            }\n+\n+            #[test]\n+            fn ipv6_in_static4() {\n+                let bad = net_config().join(\"ipv6_in_static4.toml\");\n+                let rendered = render_config_template(bad);\n+                assert!(deserialize_config(&rendered).is_err())\n+            }\n+\n+            #[test]\n+            fn ipv4_in_static6() {\n+                let bad = net_config().join(\"ipv4_in_static6.toml\");\n+                let rendered = render_config_template(bad);\n+                assert!(deserialize_config(&rendered).is_err())\n+            }\n+        }\n+    };\n+}\n+pub(crate) use static_address_tests;\ndiff --git a/sources/api/netdog/test_data/net_config/static_address/dhcp_and_routes.toml b/sources/api/netdog/test_data/net_config/static_address/dhcp_and_routes.toml\nnew file mode 100644\nindex 00000000000..bcdc644b4af\n--- /dev/null\n+++ b/sources/api/netdog/test_data/net_config/static_address/dhcp_and_routes.toml\n@@ -0,0 +1,11 @@\n+version = {{version}}\n+\n+[eno1]\n+dhcp4 = true\n+\n+[eno1.static4]\n+addresses = [\"1.2.3.4/24\", \"2.3.4.5/25\"]\n+\n+[[eno1.route]]\n+to = \"4.5.6.7/24\"\n+via = \"10.0.0.1\"\ndiff --git a/sources/api/netdog/test_data/net_config/static_address/dhcp_and_static.toml b/sources/api/netdog/test_data/net_config/static_address/dhcp_and_static.toml\nnew file mode 100644\nindex 00000000000..4e3190de3ea\n--- /dev/null\n+++ b/sources/api/netdog/test_data/net_config/static_address/dhcp_and_static.toml\n@@ -0,0 +1,7 @@\n+version = {{version}}\n+\n+[eno1]\n+dhcp4 = true\n+\n+[eno1.static4]\n+addresses = [\"1.2.3.4/24\", \"2.3.4.5/25\"]\ndiff --git a/sources/api/netdog/test_data/net_config/static_address/invalid_static_config.toml b/sources/api/netdog/test_data/net_config/static_address/invalid_static_config.toml\nnew file mode 100644\nindex 00000000000..03b1d693cc6\n--- /dev/null\n+++ b/sources/api/netdog/test_data/net_config/static_address/invalid_static_config.toml\n@@ -0,0 +1,6 @@\n+version = {{version}}\n+\n+[eno1.static4]\n+addresses = [\"1.2.3.4/24\", \"2.3.4.5/25\"]\n+# `route-metric` is not a valid static4 option\n+route-metric = 100\ndiff --git a/sources/api/netdog/test_data/net_config/static_address/ipv4_in_static6.toml b/sources/api/netdog/test_data/net_config/static_address/ipv4_in_static6.toml\nnew file mode 100644\nindex 00000000000..bf84ee093fd\n--- /dev/null\n+++ b/sources/api/netdog/test_data/net_config/static_address/ipv4_in_static6.toml\n@@ -0,0 +1,4 @@\n+version = {{version}}\n+\n+[eno1.static6]\n+addresses = [\"1.2.3.4/24\", \"2.3.4.5/25\", \"2001:dead:beef::2/64\"]\ndiff --git a/sources/api/netdog/test_data/net_config/static_address/ipv6_in_static4.toml b/sources/api/netdog/test_data/net_config/static_address/ipv6_in_static4.toml\nnew file mode 100644\nindex 00000000000..03774c6740a\n--- /dev/null\n+++ b/sources/api/netdog/test_data/net_config/static_address/ipv6_in_static4.toml\n@@ -0,0 +1,4 @@\n+version = {{version}}\n+\n+[eno1.static4]\n+addresses = [\"2001:dead:beef::2/64\", \"10.0.0.10/24\"]\ndiff --git a/sources/api/netdog/test_data/net_config/static_address/net_config.toml b/sources/api/netdog/test_data/net_config/static_address/net_config.toml\nnew file mode 100644\nindex 00000000000..bf9cec7c248\n--- /dev/null\n+++ b/sources/api/netdog/test_data/net_config/static_address/net_config.toml\n@@ -0,0 +1,90 @@\n+version = {{version}}\n+\n+# IPv4 static addresses/routes\n+[eno11.static4]\n+addresses = [\"192.168.14.2/24\"]\n+\n+[eno12.static4]\n+addresses = [\"10.0.0.9/24\"]\n+\n+[[eno12.route]]\n+to = \"10.10.10.0/24\"\n+via = \"10.0.0.1\"\n+\n+[eno13.static4]\n+addresses = [\"192.168.14.2/24\"]\n+\n+[[eno13.route]]\n+to = \"9.9.0.0/16\"\n+via = \"192.168.1.1\"\n+\n+[[eno13.route]]\n+to = \"10.10.10.0/24\"\n+via = \"192.168.1.3\"\n+\n+[eno14.static4]\n+addresses = [\"10.0.0.10/24\", \"11.0.0.11/24\"]\n+\n+[[eno14.route]]\n+to = \"default\"\n+via = \"10.0.0.1\"\n+route-metric = 100\n+\n+[[eno14.route]]\n+to = \"default\"\n+via = \"11.0.0.1\"\n+route-metric = 200\n+\n+# IPv6 static addresses/routes\n+[eno15.static6]\n+addresses = [\"2001:cafe:face:beef::dead:dead/64\"]\n+\n+[eno16.static6]\n+addresses = [\"2001:dead:beef::2/64\"]\n+\n+[[eno16.route]]\n+to = \"default\"\n+via = \"2001:beef:beef::1\"\n+\n+[eno17.static6]\n+addresses = [\"3001:f00f:f00f::2/64\", \"3001:f00f:f00f::3/64\"]\n+\n+[[eno17.route]]\n+to = \"3001:dead:beef::2/64\"\n+via = \"3001:beef:beef::1\"\n+route-metric = 100\n+\n+[[eno17.route]]\n+to = \"3001:dead:feed::2/64\"\n+via = \"3001:beef:beef::2\"\n+route-metric = 200\n+\n+# DHCP4/6 and static addresses\n+[eno18]\n+dhcp4 = true\n+\n+[eno18.static4]\n+addresses = [\"10.0.0.10/24\", \"11.0.0.11/24\"]\n+\n+[eno19]\n+dhcp6 = true\n+\n+[eno19.static6]\n+addresses = [\"3001:f00f:f00f::2/64\", \"3001:f00f:f00f::3/64\"]\n+\n+# Source IP\n+[eno20.static4]\n+addresses = [\"192.168.14.5/24\"]\n+\n+[[eno20.route]]\n+to = \"10.10.10.0/24\"\n+from = \"192.168.14.5\"\n+via = \"192.168.14.25\"\n+\n+[eno21.static6]\n+addresses = [\"2001:dead:beef::2/64\"]\n+\n+[[eno21.route]]\n+to = \"3001:dead:beef::2/64\"\n+from = \"2001:dead:beef::2\"\n+via = \"2001:beef:beef::1\"\ndiff --git a/sources/api/netdog/test_data/net_config/static_address/no_dhcp_or_static.toml b/sources/api/netdog/test_data/net_config/static_address/no_dhcp_or_static.toml\nnew file mode 100644\nindex 00000000000..2a1c5698f18\n--- /dev/null\n+++ b/sources/api/netdog/test_data/net_config/static_address/no_dhcp_or_static.toml\n@@ -0,0 +1,3 @@\n+version = {{version}}\n+\n+[eno1]\ndiff --git a/sources/api/netdog/test_data/net_config/static_address/routes_no_addresses.toml b/sources/api/netdog/test_data/net_config/static_address/routes_no_addresses.toml\nnew file mode 100644\nindex 00000000000..933d0287eec\n--- /dev/null\n+++ b/sources/api/netdog/test_data/net_config/static_address/routes_no_addresses.toml\n@@ -0,0 +1,5 @@\n+version = {{version}}\n+\n+[[eno1.route]]\n+to = \"4.5.6.7/24\"\n+via = \"10.0.0.1\"\ndiff --git a/sources/api/netdog/test_data/wicked/eno11.xml b/sources/api/netdog/test_data/wicked/eno11.xml\nnew file mode 100644\nindex 00000000000..5dbd71fb438\n--- /dev/null\n+++ b/sources/api/netdog/test_data/wicked/eno11.xml\n@@ -0,0 +1,1 @@\n+<interface><name>eno11</name><control><mode>boot</mode><link-detection><require-link></require-link></link-detection></control><ipv4:static><address><local>192.168.14.2/24</local></address></ipv4:static></interface>\ndiff --git a/sources/api/netdog/test_data/wicked/eno12.xml b/sources/api/netdog/test_data/wicked/eno12.xml\nnew file mode 100644\nindex 00000000000..d8a371db5f1\n--- /dev/null\n+++ b/sources/api/netdog/test_data/wicked/eno12.xml\n@@ -0,0 +1,1 @@\n+<interface><name>eno12</name><control><mode>boot</mode><link-detection><require-link></require-link></link-detection></control><ipv4:static><address><local>10.0.0.9/24</local></address><route><destination>10.10.10.0/24</destination><nexthop><gateway>10.0.0.1</gateway></nexthop></route></ipv4:static></interface>\ndiff --git a/sources/api/netdog/test_data/wicked/eno13.xml b/sources/api/netdog/test_data/wicked/eno13.xml\nnew file mode 100644\nindex 00000000000..7a1ddd018ad\n--- /dev/null\n+++ b/sources/api/netdog/test_data/wicked/eno13.xml\n@@ -0,0 +1,1 @@\n+<interface><name>eno13</name><control><mode>boot</mode><link-detection><require-link></require-link></link-detection></control><ipv4:static><address><local>192.168.14.2/24</local></address><route><destination>9.9.0.0/16</destination><nexthop><gateway>192.168.1.1</gateway></nexthop></route><route><destination>10.10.10.0/24</destination><nexthop><gateway>192.168.1.3</gateway></nexthop></route></ipv4:static></interface>\ndiff --git a/sources/api/netdog/test_data/wicked/eno14.xml b/sources/api/netdog/test_data/wicked/eno14.xml\nnew file mode 100644\nindex 00000000000..28b55a50495\n--- /dev/null\n+++ b/sources/api/netdog/test_data/wicked/eno14.xml\n@@ -0,0 +1,1 @@\n+<interface><name>eno14</name><control><mode>boot</mode><link-detection><require-link></require-link></link-detection></control><ipv4:static><address><local>10.0.0.10/24</local></address><address><local>11.0.0.11/24</local></address><route><destination>0.0.0.0/0</destination><nexthop><gateway>10.0.0.1</gateway></nexthop><priority>100</priority></route><route><destination>0.0.0.0/0</destination><nexthop><gateway>11.0.0.1</gateway></nexthop><priority>200</priority></route></ipv4:static></interface>\ndiff --git a/sources/api/netdog/test_data/wicked/eno15.xml b/sources/api/netdog/test_data/wicked/eno15.xml\nnew file mode 100644\nindex 00000000000..c17f0fce1df\n--- /dev/null\n+++ b/sources/api/netdog/test_data/wicked/eno15.xml\n@@ -0,0 +1,1 @@\n+<interface><name>eno15</name><control><mode>boot</mode><link-detection><require-link></require-link></link-detection></control><ipv6:static><address><local>2001:cafe:face:beef::dead:dead/64</local></address></ipv6:static></interface>\ndiff --git a/sources/api/netdog/test_data/wicked/eno16.xml b/sources/api/netdog/test_data/wicked/eno16.xml\nnew file mode 100644\nindex 00000000000..76f650b2d26\n--- /dev/null\n+++ b/sources/api/netdog/test_data/wicked/eno16.xml\n@@ -0,0 +1,1 @@\n+<interface><name>eno16</name><control><mode>boot</mode><link-detection><require-link></require-link></link-detection></control><ipv6:static><address><local>2001:dead:beef::2/64</local></address><route><destination>::/0</destination><nexthop><gateway>2001:beef:beef::1</gateway></nexthop></route></ipv6:static></interface>\ndiff --git a/sources/api/netdog/test_data/wicked/eno17.xml b/sources/api/netdog/test_data/wicked/eno17.xml\nnew file mode 100644\nindex 00000000000..510b690fca5\n--- /dev/null\n+++ b/sources/api/netdog/test_data/wicked/eno17.xml\n@@ -0,0 +1,1 @@\n+<interface><name>eno17</name><control><mode>boot</mode><link-detection><require-link></require-link></link-detection></control><ipv6:static><address><local>3001:f00f:f00f::2/64</local></address><address><local>3001:f00f:f00f::3/64</local></address><route><destination>3001:dead:beef::2/64</destination><nexthop><gateway>3001:beef:beef::1</gateway></nexthop><priority>100</priority></route><route><destination>3001:dead:feed::2/64</destination><nexthop><gateway>3001:beef:beef::2</gateway></nexthop><priority>200</priority></route></ipv6:static></interface>\ndiff --git a/sources/api/netdog/test_data/wicked/eno18.xml b/sources/api/netdog/test_data/wicked/eno18.xml\nnew file mode 100644\nindex 00000000000..8dc6e886763\n--- /dev/null\n+++ b/sources/api/netdog/test_data/wicked/eno18.xml\n@@ -0,0 +1,1 @@\n+<interface><name>eno18</name><control><mode>boot</mode><link-detection><require-link></require-link></link-detection></control><ipv4:dhcp><enabled>true</enabled></ipv4:dhcp><ipv4:static><address><local>10.0.0.10/24</local></address><address><local>11.0.0.11/24</local></address></ipv4:static></interface>\ndiff --git a/sources/api/netdog/test_data/wicked/eno19.xml b/sources/api/netdog/test_data/wicked/eno19.xml\nnew file mode 100644\nindex 00000000000..5816d3e7ab1\n--- /dev/null\n+++ b/sources/api/netdog/test_data/wicked/eno19.xml\n@@ -0,0 +1,1 @@\n+<interface><name>eno19</name><control><mode>boot</mode><link-detection><require-link></require-link></link-detection></control><ipv6:dhcp><enabled>true</enabled></ipv6:dhcp><ipv6:static><address><local>3001:f00f:f00f::2/64</local></address><address><local>3001:f00f:f00f::3/64</local></address></ipv6:static></interface>\ndiff --git a/sources/api/netdog/test_data/wicked/eno20.xml b/sources/api/netdog/test_data/wicked/eno20.xml\nnew file mode 100644\nindex 00000000000..4ea7420e425\n--- /dev/null\n+++ b/sources/api/netdog/test_data/wicked/eno20.xml\n@@ -0,0 +1,1 @@\n+<interface><name>eno20</name><control><mode>boot</mode><link-detection><require-link></require-link></link-detection></control><ipv4:static><address><local>192.168.14.5/24</local></address><route><destination>10.10.10.0/24</destination><pref-source>192.168.14.5</pref-source><nexthop><gateway>192.168.14.25</gateway></nexthop></route></ipv4:static></interface>\ndiff --git a/sources/api/netdog/test_data/wicked/eno21.xml b/sources/api/netdog/test_data/wicked/eno21.xml\nnew file mode 100644\nindex 00000000000..f40d0150d77\n--- /dev/null\n+++ b/sources/api/netdog/test_data/wicked/eno21.xml\n@@ -0,0 +1,1 @@\n+<interface><name>eno21</name><control><mode>boot</mode><link-detection><require-link></require-link></link-detection></control><ipv6:static><address><local>2001:dead:beef::2/64</local></address><route><destination>3001:dead:beef::2/64</destination><pref-source>2001:dead:beef::2</pref-source><nexthop><gateway>2001:beef:beef::1</gateway></nexthop></route></ipv6:static></interface>\ndiff --git a/sources/api/netdog/test_data/wicked/net_config.toml b/sources/api/netdog/test_data/wicked/net_config.toml\nnew file mode 100644\nindex 00000000000..b3ad92b7452\n--- /dev/null\n+++ b/sources/api/netdog/test_data/wicked/net_config.toml\n@@ -0,0 +1,141 @@\n+version = {{version}}\n+\n+[eno1]\n+dhcp4 = true\n+\n+[eno2]\n+dhcp6 = true\n+primary = true\n+\n+[eno3]\n+dhcp4 = true\n+dhcp6 = false\n+\n+[eno4]\n+dhcp4 = false\n+dhcp6 = true\n+\n+[eno5]\n+dhcp4 = true\n+dhcp6 = true\n+\n+[eno6.dhcp4]\n+enabled = true\n+route-metric = 100\n+\n+[eno6]\n+dhcp6 = false\n+\n+[eno7]\n+dhcp4 = true\n+\n+[eno7.dhcp6]\n+enabled = true\n+optional = true\n+\n+[eno8.dhcp4]\n+enabled = true\n+optional = true\n+\n+[eno8.dhcp6]\n+enabled = true\n+optional = true\n+\n+[eno9.dhcp4]\n+enabled = true\n+optional = true\n+\n+[eno10.dhcp6]\n+enabled = true\n+optional = true\n+\n+{{#if (eq version 2)}}\n+# IPv4 static addresses/routes\n+[eno11.static4]\n+addresses = [\"192.168.14.2/24\"]\n+\n+[eno12.static4]\n+addresses = [\"10.0.0.9/24\"]\n+\n+[[eno12.route]]\n+to = \"10.10.10.0/24\"\n+via = \"10.0.0.1\"\n+\n+[eno13.static4]\n+addresses = [\"192.168.14.2/24\"]\n+\n+[[eno13.route]]\n+to = \"9.9.0.0/16\"\n+via = \"192.168.1.1\"\n+\n+[[eno13.route]]\n+to = \"10.10.10.0/24\"\n+via = \"192.168.1.3\"\n+\n+[eno14.static4]\n+addresses = [\"10.0.0.10/24\", \"11.0.0.11/24\"]\n+\n+[[eno14.route]]\n+to = \"default\"\n+via = \"10.0.0.1\"\n+route-metric = 100\n+\n+[[eno14.route]]\n+to = \"default\"\n+via = \"11.0.0.1\"\n+route-metric = 200\n+\n+# IPv6 static addresses/routes\n+[eno15.static6]\n+addresses = [\"2001:cafe:face:beef::dead:dead/64\"]\n+\n+[eno16.static6]\n+addresses = [\"2001:dead:beef::2/64\"]\n+\n+[[eno16.route]]\n+to = \"default\"\n+via = \"2001:beef:beef::1\"\n+\n+[eno17.static6]\n+addresses = [\"3001:f00f:f00f::2/64\", \"3001:f00f:f00f::3/64\"]\n+\n+[[eno17.route]]\n+to = \"3001:dead:beef::2/64\"\n+via = \"3001:beef:beef::1\"\n+route-metric = 100\n+\n+[[eno17.route]]\n+to = \"3001:dead:feed::2/64\"\n+via = \"3001:beef:beef::2\"\n+route-metric = 200\n+\n+# DHCP4/6 and static addresses\n+[eno18]\n+dhcp4 = true\n+\n+[eno18.static4]\n+addresses = [\"10.0.0.10/24\", \"11.0.0.11/24\"]\n+\n+[eno19]\n+dhcp6 = true\n+\n+[eno19.static6]\n+addresses = [\"3001:f00f:f00f::2/64\", \"3001:f00f:f00f::3/64\"]\n+\n+# Source IP\n+[eno20.static4]\n+addresses = [\"192.168.14.5/24\"]\n+\n+[[eno20.route]]\n+to = \"10.10.10.0/24\"\n+from = \"192.168.14.5\"\n+via = \"192.168.14.25\"\n+\n+[eno21.static6]\n+addresses = [\"2001:dead:beef::2/64\"]\n+\n+[[eno21.route]]\n+to = \"3001:dead:beef::2/64\"\n+from = \"2001:dead:beef::2\"\n+via = \"2001:beef:beef::1\"\n+{{/if}}\n", "problem_statement": "Support static addressing via `net.toml`\n- Depends on #2214 \r\n\r\n**What I'd like:**\r\nI would like the ability to set up a static IP for a network interface.\r\n\r\nThis means we will need to be able to set the following at the least\r\n\r\n- IPv4/6 IP\r\n- gateway\r\n- nameservers\r\n- destination IP\r\n\r\n\n", "hints_text": "", "created_at": "2022-09-20T20:38:21Z"}, {"repo": "bottlerocket-os/bottlerocket", "pull_number": 386, "instance_id": "bottlerocket-os__bottlerocket-386", "issue_numbers": ["314"], "base_commit": "a16dc3189f7b3b19e20e545bf95ad065b240ba7a", "patch": "diff --git a/Makefile.toml b/Makefile.toml\nindex 003acbdf10a..d4334fa1cb9 100644\n--- a/Makefile.toml\n+++ b/Makefile.toml\n@@ -34,7 +34,7 @@ for ws in workspaces packages images ; do\n done\n chmod o+r -R ${CARGO_HOME}\n \n-cd ${BUILDSYS_SOURCES_DIR}/host-containers/cmd/host-ctr\n+cd ${BUILDSYS_SOURCES_DIR}/host-ctr/cmd/host-ctr\n docker run --rm \\\n   -e GOPRIVATE='*' \\\n   -e GOCACHE='/tmp/.cache' \\\ndiff --git a/packages/Cargo.lock b/packages/Cargo.lock\nindex 7c6a6856eb6..8f4a2a9688c 100644\n--- a/packages/Cargo.lock\n+++ b/packages/Cargo.lock\n@@ -606,7 +606,7 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n-name = \"host-containers\"\n+name = \"host-ctr\"\n version = \"0.1.0\"\n dependencies = [\n  \"buildsys 0.1.0\",\ndiff --git a/packages/Cargo.toml b/packages/Cargo.toml\nindex 1841e1f5c3d..c6992d8f5c3 100644\n--- a/packages/Cargo.toml\n+++ b/packages/Cargo.toml\n@@ -22,7 +22,7 @@ members = [\n     \"golang\",\n     \"growpart\",\n     \"grub\",\n-    \"host-containers\",\n+    \"host-ctr\",\n     \"iproute\",\n     \"iptables\",\n     \"iputils\",\ndiff --git a/packages/api/api.spec b/packages/api/api.spec\nindex 4f5fb4e6eda..37a45157dd3 100644\n--- a/packages/api/api.spec\n+++ b/packages/api/api.spec\n@@ -22,6 +22,8 @@ Source7: settings-applier.service\n Source8: data-store-version\n Source9: migrator.service\n Source10: api-sysusers.conf\n+Source11: host-containers@.service\n+Source12: host-containers-tmpfiles.conf\n BuildRequires: gcc-%{_cross_target}\n BuildRequires: %{_cross_os}glibc-devel\n BuildRequires: %{_cross_os}systemd-devel\n@@ -83,6 +85,12 @@ Requires: %{_cross_os}apiserver = %{version}-%{release}\n %description -n %{_cross_os}servicedog\n %{summary}.\n \n+%package -n %{_cross_os}host-containers\n+Summary: Manages system- and user-defined host containers\n+Requires: %{_cross_os}apiserver = %{version}-%{release}\n+%description -n %{_cross_os}host-containers\n+%{summary}.\n+\n %package -n %{_cross_os}storewolf\n Summary: Data store creator\n Requires: %{_cross_os}apiserver = %{version}-%{release}\n@@ -109,7 +117,8 @@ Summary: Commits settings from user data, defaults, and generators at boot\n for p in \\\n   apiclient \\\n   moondog netdog sundog pluto bork \\\n-  thar-be-settings servicedog storewolf settings-committer \\\n+  thar-be-settings servicedog host-containers \\\n+  storewolf settings-committer \\\n   migration/migrator ;\n do\n   %cargo_build --path %{workspace_dir}/${p}\n@@ -128,7 +137,8 @@ install -d %{buildroot}%{_cross_bindir}\n for p in \\\n   apiclient apiserver \\\n   moondog netdog sundog pluto bork \\\n-  thar-be-settings servicedog storewolf settings-committer \\\n+  thar-be-settings servicedog host-containers \\\n+  storewolf settings-committer \\\n   migrator ;\n do\n   install -p -m 0755 bin/${p} %{buildroot}%{_cross_bindir}\n@@ -136,7 +146,7 @@ done\n \n install -d %{buildroot}%{_cross_unitdir}\n install -p -m 0644 \\\n-  %{S:1} %{S:2} %{S:3} %{S:4} %{S:5} %{S:7} %{S:9} \\\n+  %{S:1} %{S:2} %{S:3} %{S:4} %{S:5} %{S:7} %{S:9} %{S:11} \\\n   %{buildroot}%{_cross_unitdir}\n \n install -d %{buildroot}%{_cross_datadir}/thar\n@@ -150,6 +160,7 @@ done\n \n install -d %{buildroot}%{_cross_tmpfilesdir}\n install -p -m 0644 %{S:6} %{buildroot}%{_cross_tmpfilesdir}/migration.conf\n+install -p -m 0644 %{S:12} %{buildroot}%{_cross_tmpfilesdir}/host-containers.conf\n \n install -d %{buildroot}%{_cross_sysusersdir}\n install -p -m 0644 %{S:10} %{buildroot}%{_cross_sysusersdir}/api.conf\n@@ -188,6 +199,11 @@ install -p -m 0644 %{S:10} %{buildroot}%{_cross_sysusersdir}/api.conf\n %files -n %{_cross_os}servicedog\n %{_cross_bindir}/servicedog\n \n+%files -n %{_cross_os}host-containers\n+%{_cross_bindir}/host-containers\n+%{_cross_unitdir}/host-containers@.service\n+%{_cross_tmpfilesdir}/host-containers.conf\n+\n %files -n %{_cross_os}storewolf\n %{_cross_bindir}/storewolf\n %{_cross_unitdir}/storewolf.service\ndiff --git a/packages/api/host-containers-tmpfiles.conf b/packages/api/host-containers-tmpfiles.conf\nnew file mode 100644\nindex 00000000000..a200b7bef69\n--- /dev/null\n+++ b/packages/api/host-containers-tmpfiles.conf\n@@ -0,0 +1,1 @@\n+d /etc/host-containers 0755 root root -\ndiff --git a/packages/api/host-containers@.service b/packages/api/host-containers@.service\nnew file mode 100644\nindex 00000000000..993ec60cb7b\n--- /dev/null\n+++ b/packages/api/host-containers@.service\n@@ -0,0 +1,16 @@\n+[Unit]\n+Description=Host container: %i\n+After=host-containerd.service\n+Requires=host-containerd.service\n+\n+[Service]\n+Type=simple\n+EnvironmentFile=/etc/host-containers/%i.env\n+ExecStart=/usr/bin/host-ctr -ctr-id='%i' -source='${CTR_SOURCE}' -superpowered='${CTR_SUPERPOWERED}'\n+Restart=always\n+RestartSec=10\n+TimeoutStopSec=60\n+KillMode=mixed\n+\n+[Install]\n+WantedBy=multi-user.target\ndiff --git a/packages/host-containers/Cargo.toml b/packages/host-ctr/Cargo.toml\nsimilarity index 84%\nrename from packages/host-containers/Cargo.toml\nrename to packages/host-ctr/Cargo.toml\nindex 0e75ce2e1b0..d3f28e97121 100644\n--- a/packages/host-containers/Cargo.toml\n+++ b/packages/host-ctr/Cargo.toml\n@@ -1,12 +1,12 @@\n [package]\n-name = \"host-containers\"\n+name = \"host-ctr\"\n version = \"0.1.0\"\n edition = \"2018\"\n publish = false\n build = \"build.rs\"\n \n [package.metadata.build-package]\n-source-groups = [ \"host-containers\" ]\n+source-groups = [ \"host-ctr\" ]\n \n [lib]\n path = \"pkg.rs\"\ndiff --git a/packages/host-containers/build.rs b/packages/host-ctr/build.rs\nsimilarity index 100%\nrename from packages/host-containers/build.rs\nrename to packages/host-ctr/build.rs\ndiff --git a/packages/host-containers/host-containers.spec b/packages/host-ctr/host-ctr.spec\nsimilarity index 88%\nrename from packages/host-containers/host-containers.spec\nrename to packages/host-ctr/host-ctr.spec\nindex f87416fb92f..4e98559e95a 100644\n--- a/packages/host-containers/host-containers.spec\n+++ b/packages/host-ctr/host-ctr.spec\n@@ -1,10 +1,10 @@\n-%global workspace_name host-containers\n+%global workspace_name host-ctr\n %global systemd_systemdir %{_cross_libdir}/systemd/system\n \n Name: %{_cross_os}%{workspace_name}\n Version: 0.0\n Release: 0%{?dist}\n-Summary: Thar host container management\n+Summary: Thar host container runner\n License: FIXME\n BuildRequires: gcc-%{_cross_target}\n BuildRequires: %{_cross_os}glibc-devel\ndiff --git a/packages/host-containers/pkg.rs b/packages/host-ctr/pkg.rs\nsimilarity index 100%\nrename from packages/host-containers/pkg.rs\nrename to packages/host-ctr/pkg.rs\ndiff --git a/packages/release/host-containers-systemd-unit-admin.template b/packages/release/host-containers-systemd-unit-admin.template\ndeleted file mode 100644\nindex d4271812661..00000000000\n--- a/packages/release/host-containers-systemd-unit-admin.template\n+++ /dev/null\n@@ -1,15 +0,0 @@\n-[Unit]\n-Description=Admin container\n-After=host-containerd.service\n-Requires=host-containerd.service\n-\n-[Service]\n-Type=simple\n-ExecStart=/usr/bin/host-ctr -ctr-id admin -source {{ settings.host-containers.admin.source }} {{#if  settings.host-containers.admin.superpowered }}-superpowered{{/if}}\n-Restart=always\n-RestartSec=10\n-TimeoutStopSec=60\n-KillMode=mixed\n-\n-[Install]\n-WantedBy=multi-user.target\ndiff --git a/packages/release/host-containers-systemd-unit-control.template b/packages/release/host-containers-systemd-unit-control.template\ndeleted file mode 100644\nindex e3dc7c06a29..00000000000\n--- a/packages/release/host-containers-systemd-unit-control.template\n+++ /dev/null\n@@ -1,15 +0,0 @@\n-[Unit]\n-Description=Control container\n-After=host-containerd.service\n-Requires=host-containerd.service\n-\n-[Service]\n-Type=simple\n-ExecStart=/usr/bin/host-ctr -ctr-id control -source {{ settings.host-containers.control.source }} {{#if settings.host-containers.control.superpowered }}-superpowered{{/if}}\n-Restart=always\n-RestartSec=10\n-TimeoutStopSec=60\n-KillMode=mixed\n-\n-[Install]\n-WantedBy=multi-user.target\ndiff --git a/packages/release/release.spec b/packages/release/release.spec\nindex 05cd6aee688..fa1e3db8efe 100644\n--- a/packages/release/release.spec\n+++ b/packages/release/release.spec\n@@ -16,8 +16,6 @@ Source99: release-tmpfiles.conf\n \n # FIXME What should own system-level file templates?\n Source200: hostname.template\n-Source201: host-containers-systemd-unit-admin.template\n-Source202: host-containers-systemd-unit-control.template\n \n Source1000: eth0.xml\n Source1002: configured.target\n@@ -55,7 +53,7 @@ Requires: %{_cross_os}signpost\n Requires: %{_cross_os}sundog\n Requires: %{_cross_os}pluto\n Requires: %{_cross_os}storewolf\n-Requires: %{_cross_os}servicedog\n+Requires: %{_cross_os}host-containers\n Requires: %{_cross_os}settings-committer\n Requires: %{_cross_os}systemd\n Requires: %{_cross_os}thar-be-settings\n@@ -64,7 +62,7 @@ Requires: %{_cross_os}updog\n Requires: %{_cross_os}util-linux\n Requires: %{_cross_os}preinit\n Requires: %{_cross_os}wicked\n-Requires: %{_cross_os}host-containers\n+Requires: %{_cross_os}host-ctr\n \n %description\n %{summary}.\n@@ -107,8 +105,6 @@ install -p -m 0644 %{S:1002} %{S:1003} %{S:1006} %{S:1007} %{S:1008} %{S:1009} %\n \n install -d %{buildroot}%{_cross_templatedir}\n install -p -m 0644 %{S:200} %{buildroot}%{_cross_templatedir}/hostname\n-install -p -m 0644 %{S:201} %{buildroot}%{_cross_templatedir}/host-containers-systemd-unit-admin\n-install -p -m 0644 %{S:202} %{buildroot}%{_cross_templatedir}/host-containers-systemd-unit-control\n \n %files\n %if %{with shell}\n@@ -130,7 +126,5 @@ install -p -m 0644 %{S:202} %{buildroot}%{_cross_templatedir}/host-containers-sy\n %{_cross_unitdir}/var-lib-thar.mount\n %dir %{_cross_templatedir}\n %{_cross_templatedir}/hostname\n-%{_cross_templatedir}/host-containers-systemd-unit-admin\n-%{_cross_templatedir}/host-containers-systemd-unit-control\n \n %changelog\ndiff --git a/workspaces/Cargo.lock b/workspaces/Cargo.lock\nindex fe53b8033b9..6e38c07436b 100644\n--- a/workspaces/Cargo.lock\n+++ b/workspaces/Cargo.lock\n@@ -1024,6 +1024,21 @@ dependencies = [\n  \"digest 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"host-containers\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"apiclient 0.1.0\",\n+ \"apiserver 0.1.0\",\n+ \"cargo-readme 3.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"http 0.1.18 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.101 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.40 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"snafu 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tracing 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"tracing-subscriber 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"hostname\"\n version = \"0.1.5\"\ndiff --git a/workspaces/Cargo.toml b/workspaces/Cargo.toml\nindex 6a1f7a7ca61..5b79aaf67d8 100644\n--- a/workspaces/Cargo.toml\n+++ b/workspaces/Cargo.toml\n@@ -9,6 +9,7 @@ members = [\n     \"api/sundog\",\n     \"api/pluto\",\n     \"api/servicedog\",\n+    \"api/host-containers\",\n     \"api/storewolf\",\n     \"api/thar-be-settings\",\n     \"api/settings-committer\",\ndiff --git a/workspaces/api/apiserver/src/model.rs b/workspaces/api/apiserver/src/model.rs\nindex 9b2331d535e..b2d36cf0509 100644\n--- a/workspaces/api/apiserver/src/model.rs\n+++ b/workspaces/api/apiserver/src/model.rs\n@@ -7,7 +7,7 @@ use serde::{Deserialize, Serialize};\n use std::collections::HashMap;\n use std::net::Ipv4Addr;\n \n-use crate::modeled_types::ValidBase64;\n+use crate::modeled_types::{SingleLineString, ValidBase64};\n \n ///// Primary user-visible settings\n \n@@ -32,7 +32,7 @@ pub struct Settings {\n     pub updates: Option<UpdatesSettings>,\n \n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub host_containers: Option<HostContainersSettings>,\n+    pub host_containers: Option<HashMap<SingleLineString, ContainerImage>>,\n \n     #[serde(skip_serializing_if = \"Option::is_none\")]\n     pub ntp: Option<NtpSettings>,\n@@ -82,23 +82,11 @@ pub struct UpdatesSettings {\n     pub seed: Option<String>,\n }\n \n-// Settings for HostContainers, which manages the lifecycle of privileged, unorchestrated\n-// containers that are used for system management purposes.\n-#[derive(Debug, PartialEq, Serialize, Deserialize)]\n-#[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n-pub struct HostContainersSettings {\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub admin: Option<ContainerImage>,\n-\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub control: Option<ContainerImage>,\n-}\n-\n #[derive(Debug, PartialEq, Serialize, Deserialize)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n pub struct ContainerImage {\n     #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub source: Option<String>,\n+    pub source: Option<SingleLineString>,\n \n     #[serde(skip_serializing_if = \"Option::is_none\")]\n     pub enabled: Option<bool>,\ndiff --git a/workspaces/api/apiserver/src/modeled_types.rs b/workspaces/api/apiserver/src/modeled_types.rs\nindex 63776854729..23d7a7f6a86 100644\n--- a/workspaces/api/apiserver/src/modeled_types.rs\n+++ b/workspaces/api/apiserver/src/modeled_types.rs\n@@ -75,7 +75,7 @@ impl fmt::Display for ValidBase64 {\n }\n \n #[cfg(test)]\n-mod test {\n+mod test_valid_base64 {\n     use super::ValidBase64;\n \n     #[test]\n@@ -92,3 +92,116 @@ mod test {\n         assert!(serde_json::from_str::<ValidBase64>(\"\").is_err());\n     }\n }\n+\n+// =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=   =^..^=\n+\n+/// SingleLineString can only be created by deserializing from a string that contains at most one\n+/// line.  It stores the original form and makes it accessible through standard traits.  Its\n+/// purpose is input validation, for example in cases where you want to accept input for a\n+/// configuration file and want to ensure a user can't create a new line with extra configuration.\n+#[derive(Debug, Clone, Eq, PartialEq, Hash)]\n+pub struct SingleLineString {\n+    inner: String,\n+}\n+\n+/// Validate line count before we accept a deserialization.\n+impl<'de> Deserialize<'de> for SingleLineString {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let original = String::deserialize(deserializer)?;\n+\n+        // Rust does not treat all Unicode line terminators as starting a new line, so we check for\n+        // specific characters here, rather than just counting from lines().\n+        // https://en.wikipedia.org/wiki/Newline#Unicode\n+        let line_terminators = [\n+            '\\n',       // newline (0A)\n+            '\\r',       // carriage return (0D)\n+            '\\u{000B}', // vertical tab\n+            '\\u{000C}', // form feed\n+            '\\u{0085}', // next line\n+            '\\u{2028}', // line separator\n+            '\\u{2029}', // paragraph separator\n+        ];\n+        if let Some(term) = original.find(&line_terminators[..]) {\n+            Err(D::Error::custom(format!(\n+                \"Can't create SingleLineString with line terminator '{}'\",\n+                term,\n+            )))\n+        } else {\n+            Ok(SingleLineString { inner: original })\n+        }\n+    }\n+}\n+\n+/// Serialize the original string back out.\n+impl Serialize for SingleLineString {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        serializer.serialize_str(&self.inner)\n+    }\n+}\n+\n+impl Deref for SingleLineString {\n+    type Target = str;\n+    fn deref(&self) -> &Self::Target {\n+        &self.inner\n+    }\n+}\n+\n+impl Borrow<String> for SingleLineString {\n+    fn borrow(&self) -> &String {\n+        &self.inner\n+    }\n+}\n+\n+impl Borrow<str> for SingleLineString {\n+    fn borrow(&self) -> &str {\n+        &self.inner\n+    }\n+}\n+\n+impl AsRef<str> for SingleLineString {\n+    fn as_ref(&self) -> &str {\n+        &self.inner\n+    }\n+}\n+\n+impl fmt::Display for SingleLineString {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.inner)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test_single_line_string {\n+    use super::SingleLineString;\n+\n+    #[test]\n+    fn valid_single_line_string() {\n+        assert!(serde_json::from_str::<SingleLineString>(\"\\\"\\\"\").is_ok());\n+        assert!(serde_json::from_str::<SingleLineString>(\"\\\"hi\\\"\").is_ok());\n+        let long_string = std::iter::repeat(\" \").take(9999).collect::<String>();\n+        let json_long_string = format!(\"\\\"{}\\\"\", &long_string);\n+        assert!(serde_json::from_str::<SingleLineString>(&json_long_string).is_ok());\n+    }\n+\n+    #[test]\n+    fn invalid_single_line_string() {\n+        assert!(serde_json::from_str::<SingleLineString>(\"\\\"Hello\\nWorld\\\"\").is_err());\n+\n+        assert!(serde_json::from_str::<SingleLineString>(\"\\\"\\n\\\"\").is_err());\n+        assert!(serde_json::from_str::<SingleLineString>(\"\\\"\\r\\\"\").is_err());\n+        assert!(serde_json::from_str::<SingleLineString>(\"\\\"\\r\\n\\\"\").is_err());\n+\n+        assert!(serde_json::from_str::<SingleLineString>(\"\\\"\\u{000B}\\\"\").is_err()); // vertical tab\n+        assert!(serde_json::from_str::<SingleLineString>(\"\\\"\\u{000C}\\\"\").is_err()); // form feed\n+        assert!(serde_json::from_str::<SingleLineString>(\"\\\"\\u{0085}\\\"\").is_err()); // next line\n+        assert!(serde_json::from_str::<SingleLineString>(\"\\\"\\u{2028}\\\"\").is_err()); // line separator\n+        assert!(serde_json::from_str::<SingleLineString>(\"\\\"\\u{2029}\\\"\").is_err());\n+        // paragraph separator\n+    }\n+}\ndiff --git a/workspaces/api/host-containers/Cargo.toml b/workspaces/api/host-containers/Cargo.toml\nnew file mode 100644\nindex 00000000000..ca77b3f968a\n--- /dev/null\n+++ b/workspaces/api/host-containers/Cargo.toml\n@@ -0,0 +1,20 @@\n+[package]\n+name = \"host-containers\"\n+version = \"0.1.0\"\n+authors = [\"Tom Kirchner <tjk@amazon.com>\", \"Zac Mrowicki <mrowicki@amazon.com>\"]\n+edition = \"2018\"\n+publish = false\n+build = \"build.rs\"\n+\n+[dependencies]\n+apiclient = { path = \"../apiclient\" }\n+apiserver = { path = \"../apiserver\" }\n+http = \"0.1\"\n+tracing = \"0.1\"\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = \"1\"\n+snafu = \"0.5\"\n+tracing-subscriber = \"0.1\"\n+\n+[build-dependencies]\n+cargo-readme = \"3.1\"\ndiff --git a/workspaces/api/host-containers/README.md b/workspaces/api/host-containers/README.md\nnew file mode 100644\nindex 00000000000..fbdf82cc6e6\n--- /dev/null\n+++ b/workspaces/api/host-containers/README.md\n@@ -0,0 +1,13 @@\n+# host-containers\n+\n+Current version: 0.1.0\n+\n+## Background\n+\n+host-containers is a tool that queries the API for the currently enabled host containers and\n+ensures the relevant systemd service is enabled/started or disabled/stopped for each one depending\n+on its 'enabled' flag.\n+\n+## Colophon\n+\n+This text was generated using [cargo-readme](https://crates.io/crates/cargo-readme), and includes the rustdoc from `src/main.rs`.\n\\ No newline at end of file\ndiff --git a/workspaces/api/host-containers/README.tpl b/workspaces/api/host-containers/README.tpl\nnew file mode 100644\nindex 00000000000..bf207d023ff\n--- /dev/null\n+++ b/workspaces/api/host-containers/README.tpl\n@@ -0,0 +1,9 @@\n+# {{crate}}\n+\n+Current version: {{version}}\n+\n+{{readme}}\n+\n+## Colophon\n+\n+This text was generated using [cargo-readme](https://crates.io/crates/cargo-readme), and includes the rustdoc from `src/main.rs`.\ndiff --git a/workspaces/api/host-containers/build.rs b/workspaces/api/host-containers/build.rs\nnew file mode 100644\nindex 00000000000..49828a1c42f\n--- /dev/null\n+++ b/workspaces/api/host-containers/build.rs\n@@ -0,0 +1,32 @@\n+// Automatically generate README.md from rustdoc.\n+\n+use std::env;\n+use std::fs::File;\n+use std::io::Write;\n+use std::path::PathBuf;\n+\n+fn main() {\n+    // Check for environment variable \"SKIP_README\". If it is set,\n+    // skip README generation\n+    if env::var_os(\"SKIP_README\").is_some() {\n+        return;\n+    }\n+\n+    let mut source = File::open(\"src/main.rs\").unwrap();\n+    let mut template = File::open(\"README.tpl\").unwrap();\n+\n+    let content = cargo_readme::generate_readme(\n+        &PathBuf::from(\".\"), // root\n+        &mut source,         // source\n+        Some(&mut template), // template\n+        // The \"add x\" arguments don't apply when using a template.\n+        true,  // add title\n+        false, // add badges\n+        false, // add license\n+        true,  // indent headings\n+    )\n+    .unwrap();\n+\n+    let mut readme = File::create(\"README.md\").unwrap();\n+    readme.write_all(content.as_bytes()).unwrap();\n+}\ndiff --git a/workspaces/api/host-containers/src/main.rs b/workspaces/api/host-containers/src/main.rs\nnew file mode 100644\nindex 00000000000..c376623eab2\n--- /dev/null\n+++ b/workspaces/api/host-containers/src/main.rs\n@@ -0,0 +1,344 @@\n+/*!\n+# Background\n+\n+host-containers is a tool that queries the API for the currently enabled host containers and\n+ensures the relevant systemd service is enabled/started or disabled/stopped for each one depending\n+on its 'enabled' flag.\n+*/\n+\n+#![deny(rust_2018_idioms)]\n+\n+use snafu::{ensure, OptionExt, ResultExt};\n+use std::collections::HashMap;\n+use std::env;\n+use std::ffi::OsStr;\n+use std::fmt::Write;\n+use std::fs;\n+use std::path::{Path, PathBuf};\n+use std::process::{self, Command};\n+\n+use apiserver::model;\n+use apiserver::modeled_types::SingleLineString;\n+\n+#[macro_use]\n+extern crate tracing;\n+\n+use tracing_subscriber::{\n+    filter::{EnvFilter, LevelFilter},\n+    FmtSubscriber,\n+};\n+\n+// FIXME Get from configuration in the future\n+const DEFAULT_API_SOCKET: &str = \"/run/api.sock\";\n+const API_SETTINGS_URI: &str = \"/settings\";\n+const ENV_FILE_DIR: &str = \"/etc/host-containers\";\n+\n+const SYSTEMCTL_BIN: &str = \"/bin/systemctl\";\n+\n+mod error {\n+    use http::StatusCode;\n+    use snafu::Snafu;\n+    use std::fmt;\n+    use std::io;\n+    use std::path::PathBuf;\n+    use std::process::{Command, Output};\n+\n+    #[derive(Debug, Snafu)]\n+    #[snafu(visibility = \"pub(super)\")]\n+    pub(super) enum Error {\n+        #[snafu(display(\"Error sending {} to {}: {}\", method, uri, source))]\n+        APIRequest {\n+            method: String,\n+            uri: String,\n+            source: apiclient::Error,\n+        },\n+\n+        #[snafu(display(\"Error {} when sending {} to {}: {}\", code, method, uri, response_body))]\n+        APIResponse {\n+            method: String,\n+            uri: String,\n+            code: StatusCode,\n+            response_body: String,\n+        },\n+\n+        #[snafu(display(\n+            \"Error deserializing response as JSON from {} to {}: {}\",\n+            method,\n+            uri,\n+            source\n+        ))]\n+        ResponseJson {\n+            method: &'static str,\n+            uri: String,\n+            source: serde_json::Error,\n+        },\n+\n+        #[snafu(display(\"settings.host_containers missing in API response\"))]\n+        MissingSettings {},\n+\n+        #[snafu(display(\"Host containers '{}' missing field '{}'\", name, field))]\n+        MissingField { name: String, field: String },\n+\n+        #[snafu(display(\"Unable to create host-containers config dir {}: {}\", path.display(), source))]\n+        EnvFileDirCreate { path: PathBuf, source: io::Error },\n+\n+        #[snafu(display(\"Failed to build EnvironmentFile for {}: {}\", name, source))]\n+        EnvFileBuildFailed { name: String, source: fmt::Error },\n+\n+        #[snafu(display(\"Failed to write EnvironmentFile to {}: {}\", path.display(), source))]\n+        EnvFileWriteFailed { path: PathBuf, source: io::Error },\n+\n+        #[snafu(display(\"Failed to execute '{:?}': {}\", command, source))]\n+        ExecutionFailure {\n+            command: Command,\n+            source: std::io::Error,\n+        },\n+\n+        #[snafu(display(\"Systemd command failed - stderr: {}\",\n+                        std::str::from_utf8(&output.stderr).unwrap_or_else(|_| \"<invalid UTF-8>\")))]\n+        SystemdCommandFailure { output: Output },\n+\n+        #[snafu(display(\"Failed to parse provided directive: {}\", source))]\n+        TracingDirectiveParse {\n+            source: tracing_subscriber::filter::LevelParseError,\n+        },\n+\n+        #[snafu(display(\"Failed to manage {} of {} host containers\", failed, tried))]\n+        ManageContainersFailed { failed: usize, tried: usize },\n+    }\n+}\n+\n+type Result<T> = std::result::Result<T, error::Error>;\n+\n+/// Query the API for the currently defined host containers\n+fn get_host_containers<P>(socket_path: P) -> Result<HashMap<SingleLineString, model::ContainerImage>>\n+where\n+    P: AsRef<Path>,\n+{\n+    debug!(\"Querying the API for settings\");\n+\n+    let method = \"GET\";\n+    let uri = API_SETTINGS_URI;\n+    let (code, response_body) = apiclient::raw_request(&socket_path, uri, method, None)\n+        .context(error::APIRequest { method, uri })?;\n+    ensure!(\n+        code.is_success(),\n+        error::APIResponse {\n+            method,\n+            uri,\n+            code,\n+            response_body,\n+        }\n+    );\n+\n+    // Build a Settings struct from the response string\n+    let settings: model::Settings =\n+        serde_json::from_str(&response_body).context(error::ResponseJson { method, uri })?;\n+\n+    settings.host_containers.context(error::MissingSettings)\n+}\n+\n+/// SystemdUnit stores the systemd unit being manipulated\n+struct SystemdUnit<'a> {\n+    unit: &'a str,\n+}\n+\n+impl<'a> SystemdUnit<'a> {\n+    fn new(unit: &'a str) -> Self {\n+        SystemdUnit { unit }\n+    }\n+\n+    fn enable_and_start(&self) -> Result<()> {\n+        // We enable/start units with --no-block to work around cyclic dependency issues at boot\n+        // time.  It would probably be better to give systemd more of a chance to tell us that\n+        // something failed to start, if dependencies can be resolved in another way.\n+        systemctl(&[\"enable\", &self.unit, \"--now\", \"--no-block\"])\n+    }\n+\n+    fn disable_and_stop(&self) -> Result<()> {\n+        systemctl(&[\"disable\", &self.unit, \"--now\"])\n+    }\n+}\n+\n+/// Wrapper around process::Command for systemctl that adds error checking.\n+fn systemctl<I, S>(args: I) -> Result<()>\n+where\n+    I: IntoIterator<Item = S>,\n+    S: AsRef<OsStr>,\n+{\n+    let mut command = Command::new(SYSTEMCTL_BIN);\n+    command.args(args);\n+    let output = command\n+        .output()\n+        .context(error::ExecutionFailure { command })?;\n+\n+    trace!(\"stdout: {}\", String::from_utf8_lossy(&output.stdout));\n+    trace!(\"stderr: {}\", String::from_utf8_lossy(&output.stderr));\n+\n+    ensure!(\n+        output.status.success(),\n+        error::SystemdCommandFailure { output }\n+    );\n+    Ok(())\n+}\n+\n+/// Write out the EnvironmentFile that systemd uses to fill in arguments to host-ctr\n+fn write_env_file<S1, S2>(name: S1, source: S2, enabled: bool, superpowered: bool) -> Result<()>\n+where\n+    S1: AsRef<str>,\n+    S2: AsRef<str>,\n+{\n+    let name = name.as_ref();\n+    let filename = format!(\"{}.env\", name);\n+    let path = Path::new(ENV_FILE_DIR).join(filename);\n+\n+    let mut output = String::new();\n+    writeln!(output, \"CTR_SUPERPOWERED={}\", superpowered)\n+        .context(error::EnvFileBuildFailed { name })?;\n+    writeln!(output, \"CTR_SOURCE={}\", source.as_ref())\n+        .context(error::EnvFileBuildFailed { name })?;\n+\n+    writeln!(\n+        output,\n+        \"\\n# Just for reference; service is enabled or disabled by host-containers service\"\n+    )\n+    .context(error::EnvFileBuildFailed { name })?;\n+    writeln!(output, \"# CTR_ENABLED={}\", enabled).context(error::EnvFileBuildFailed { name })?;\n+\n+    fs::write(&path, output).context(error::EnvFileWriteFailed { path })?;\n+\n+    Ok(())\n+}\n+\n+/// Store the args we receive on the command line\n+struct Args {\n+    socket_path: PathBuf,\n+    verbosity: usize,\n+}\n+\n+/// Print a usage message in the event a bad arg is passed\n+fn usage() -> ! {\n+    let program_name = env::args().next().unwrap_or_else(|| \"program\".to_string());\n+    eprintln!(\n+        r\"Usage: {}\n+            [ --socket-path PATH ]\n+            [ --verbose --verbose ... ]\n+\n+    Socket path defaults to {}\",\n+        program_name, DEFAULT_API_SOCKET,\n+    );\n+    process::exit(2);\n+}\n+\n+/// Prints a more specific message before exiting through usage().\n+fn usage_msg<S: AsRef<str>>(msg: S) -> ! {\n+    eprintln!(\"{}\\n\", msg.as_ref());\n+    usage();\n+}\n+\n+/// Parse the args to the program and return an Args struct\n+fn parse_args(args: env::Args) -> Args {\n+    let mut socket_path = None;\n+    let mut verbosity = 3;\n+\n+    let mut iter = args.skip(1);\n+    while let Some(arg) = iter.next() {\n+        match arg.as_ref() {\n+            \"-v\" | \"--verbose\" => verbosity += 1,\n+\n+            \"--socket-path\" => {\n+                socket_path = Some(\n+                    iter.next()\n+                        .unwrap_or_else(|| usage_msg(\"Did not give argument to --socket-path\"))\n+                        .into(),\n+                )\n+            }\n+\n+            _ => usage(),\n+        }\n+    }\n+\n+    Args {\n+        socket_path: socket_path.unwrap_or_else(|| DEFAULT_API_SOCKET.into()),\n+        verbosity,\n+    }\n+}\n+\n+fn handle_host_container<S>(name: S, image_details: &model::ContainerImage) -> Result<()>\n+where\n+    S: AsRef<str>,\n+{\n+    let name = name.as_ref();\n+    let source = image_details.source.as_ref().context(error::MissingField {\n+        name,\n+        field: \"source\",\n+    })?;\n+    let enabled = image_details.enabled.context(error::MissingField {\n+        name,\n+        field: \"enabled\",\n+    })?;\n+    let superpowered = image_details.superpowered.context(error::MissingField {\n+        name,\n+        field: \"superpowered\",\n+    })?;\n+\n+    info!(\n+        \"Handling host container '{}' which is enabled: {}\",\n+        name, enabled\n+    );\n+\n+    // Write the environment file needed for the systemd service to have details about this\n+    // specific host container\n+    write_env_file(name, source, enabled, superpowered)?;\n+\n+    // Now start/stop the container according to the 'enabled' setting\n+    let unit_name = format!(\"host-containers@{}.service\", name);\n+    let systemd_unit = SystemdUnit::new(&unit_name);\n+\n+    if enabled {\n+        systemd_unit.enable_and_start()?;\n+    } else {\n+        systemd_unit.disable_and_stop()?;\n+    }\n+\n+    Ok(())\n+}\n+\n+fn main() -> Result<()> {\n+    let args = parse_args(env::args());\n+\n+    // Start the logger\n+    let level: LevelFilter = args\n+        .verbosity\n+        .to_string()\n+        .parse()\n+        .context(error::TracingDirectiveParse)?;\n+    let filter = EnvFilter::from_default_env().add_directive(level.into());\n+    let subscriber = FmtSubscriber::builder()\n+        .with_env_filter(filter)\n+        .with_writer(std::io::stderr)\n+        .finish();\n+    tracing::subscriber::set_global_default(subscriber).expect(\"setting tracing default failed\");\n+\n+    info!(\"host-containers started\");\n+\n+    let mut failed = 0usize;\n+    let host_containers = get_host_containers(args.socket_path)?;\n+    for (name, image_details) in host_containers.iter() {\n+        // Continue to handle other host containers if we fail one\n+        if let Err(e) = handle_host_container(name, image_details) {\n+            failed += 1;\n+            error!(\"Failed to handle host container '{}': {}\", &name, e);\n+        }\n+    }\n+\n+    ensure!(\n+        failed == 0,\n+        error::ManageContainersFailed {\n+            failed,\n+            tried: host_containers.len()\n+        }\n+    );\n+\n+    Ok(())\n+}\ndiff --git a/workspaces/api/storewolf/defaults.toml b/workspaces/api/storewolf/defaults.toml\nindex 14264b2a22e..78d260de9a3 100644\n--- a/workspaces/api/storewolf/defaults.toml\n+++ b/workspaces/api/storewolf/defaults.toml\n@@ -96,31 +96,14 @@ enabled = true\n source = \"328549459982.dkr.ecr.us-west-2.amazonaws.com/thar-control:v0.1\"\n superpowered = false\n \n-[services.host-containers-admin]\n-configuration-files = [\"host-containers-systemd-unit-admin\"]\n-restart-commands = [\"/usr/bin/servicedog -s settings.host-containers.admin.enabled -u host-containers@admin.service\"]\n-\n-[services.host-containers-control]\n-configuration-files = [\"host-containers-systemd-unit-control\"]\n-restart-commands = [\"/usr/bin/servicedog -s settings.host-containers.control.enabled -u host-containers@control.service\"]\n-\n-[configuration-files.host-containers-systemd-unit-admin]\n-path = \"/etc/systemd/system/host-containers@admin.service\"\n-template-path = \"/usr/share/templates/host-containers-systemd-unit-admin\"\n-\n-[configuration-files.host-containers-systemd-unit-control]\n-path = \"/etc/systemd/system/host-containers@control.service\"\n-template-path = \"/usr/share/templates/host-containers-systemd-unit-control\"\n-\n-[[metadata]]\n-key = \"settings.host-containers.admin\"\n-md = \"affected-services\"\n-val = [\"host-containers-admin\"]\n+[services.host-containers]\n+configuration-files = []\n+restart-commands = [\"/usr/bin/host-containers\"]\n \n [[metadata]]\n-key = \"settings.host-containers.control\"\n+key = \"settings.host-containers\"\n md = \"affected-services\"\n-val = [\"host-containers-control\"]\n+val = [\"host-containers\"]\n \n # NTP\n \ndiff --git a/workspaces/deny.toml b/workspaces/deny.toml\nindex cfbbdce9c3f..122dc7286ce 100644\n--- a/workspaces/deny.toml\n+++ b/workspaces/deny.toml\n@@ -33,6 +33,7 @@ skip = [\n     { name = \"bork\", licenses = [] },\n     { name = \"data_store_version\", licenses = [] },\n     { name = \"growpart\", licenses = [] },\n+    { name = \"host-containers\", licenses = [] },\n     { name = \"laika\", licenses = [] },\n     { name = \"migration-helpers\", licenses = [] },\n     { name = \"migrator\", licenses = [] },\ndiff --git a/workspaces/host-containers/cmd/host-ctr/.gitignore b/workspaces/host-ctr/cmd/host-ctr/.gitignore\nsimilarity index 100%\nrename from workspaces/host-containers/cmd/host-ctr/.gitignore\nrename to workspaces/host-ctr/cmd/host-ctr/.gitignore\ndiff --git a/workspaces/host-containers/cmd/host-ctr/go.mod b/workspaces/host-ctr/cmd/host-ctr/go.mod\nsimilarity index 100%\nrename from workspaces/host-containers/cmd/host-ctr/go.mod\nrename to workspaces/host-ctr/cmd/host-ctr/go.mod\ndiff --git a/workspaces/host-containers/cmd/host-ctr/go.sum b/workspaces/host-ctr/cmd/host-ctr/go.sum\nsimilarity index 100%\nrename from workspaces/host-containers/cmd/host-ctr/go.sum\nrename to workspaces/host-ctr/cmd/host-ctr/go.sum\ndiff --git a/workspaces/host-containers/cmd/host-ctr/main.go b/workspaces/host-ctr/cmd/host-ctr/main.go\nsimilarity index 100%\nrename from workspaces/host-containers/cmd/host-ctr/main.go\nrename to workspaces/host-ctr/cmd/host-ctr/main.go\n", "test_patch": "diff --git a/workspaces/host-containers/cmd/host-ctr/main_test.go b/workspaces/host-ctr/cmd/host-ctr/main_test.go\nsimilarity index 100%\nrename from workspaces/host-containers/cmd/host-ctr/main_test.go\nrename to workspaces/host-ctr/cmd/host-ctr/main_test.go\n", "problem_statement": "User defined host containers\n#229 implemented the initial work needed to make host containers functional.  However, limitations in the current `apiserver` and `thar-be-settings` design make it a bit of effort to add additional host containers.\r\n\r\nUsers should be able to easily define their own host containers.  Design to follow.  I imagine we will need to consider pieces of #159, #135 , and especially #10 .\n", "hints_text": "", "created_at": "2019-10-09T20:22:53Z"}, {"repo": "bottlerocket-os/bottlerocket", "pull_number": 382, "instance_id": "bottlerocket-os__bottlerocket-382", "issue_numbers": ["351"], "base_commit": "4360ac84b6314dfd24ab90a0c4d72888dda9e3e4", "patch": "diff --git a/packages/containerd/containerd-config.toml b/packages/containerd/containerd-config-toml\nsimilarity index 77%\nrename from packages/containerd/containerd-config.toml\nrename to packages/containerd/containerd-config-toml\nindex cd92491f484..4b62162599f 100644\n--- a/packages/containerd/containerd-config.toml\n+++ b/packages/containerd/containerd-config-toml\n@@ -10,6 +10,10 @@ disabled_plugins = [\n [grpc]\n address = \"/run/containerd/containerd.sock\"\n \n+[plugins.\"io.containerd.grpc.v1.cri\"]\n+# Pause container image is specified here, shares the same image as kubelet's pod-infra-container-image\n+sandbox_image = \"{{settings.kubernetes.pod-infra-container-image}}\"\n+\n [plugins.\"io.containerd.grpc.v1.cri\".containerd]\n default_runtime_name = \"runc\"\n \ndiff --git a/packages/containerd/containerd.spec b/packages/containerd/containerd.spec\nindex 1af5f5e795a..69f93d3d1cb 100644\n--- a/packages/containerd/containerd.spec\n+++ b/packages/containerd/containerd.spec\n@@ -15,7 +15,7 @@ License: ASL 2.0\n URL: https://%{goimport}\n Source0: https://%{goimport}/archive/v%{gover}/%{gorepo}-%{gover}.tar.gz\n Source1: containerd.service\n-Source2: containerd-config.toml\n+Source2: containerd-config-toml\n Source3: containerd-tmpfiles.conf\n BuildRequires: git\n BuildRequires: gcc-%{_cross_target}\n@@ -64,8 +64,9 @@ done\n install -d %{buildroot}%{_cross_unitdir}\n install -p -m 0644 %{S:1} %{buildroot}%{_cross_unitdir}/containerd.service\n \n+install -d %{buildroot}%{_cross_templatedir}\n install -d %{buildroot}%{_cross_factorydir}%{_cross_sysconfdir}/containerd\n-install -p -m 0644 %{S:2} %{buildroot}%{_cross_factorydir}%{_cross_sysconfdir}/containerd/config.toml\n+install -p -m 0644 %{S:2} %{buildroot}%{_cross_templatedir}/containerd-config-toml\n \n install -d %{buildroot}%{_cross_tmpfilesdir}\n install -p -m 0644 %{S:3} %{buildroot}%{_cross_tmpfilesdir}/containerd.conf\n@@ -78,7 +79,7 @@ install -p -m 0644 %{S:3} %{buildroot}%{_cross_tmpfilesdir}/containerd.conf\n %{_cross_bindir}/ctr\n %{_cross_unitdir}/containerd.service\n %dir %{_cross_factorydir}%{_cross_sysconfdir}/containerd\n-%{_cross_factorydir}%{_cross_sysconfdir}/containerd/config.toml\n+%{_cross_templatedir}/containerd-config-toml\n %{_cross_tmpfilesdir}/containerd.conf\n \n %changelog\ndiff --git a/packages/kubernetes/kubelet.service b/packages/kubernetes/kubelet.service\nindex ec050e3b35e..24578571a4c 100644\n--- a/packages/kubernetes/kubelet.service\n+++ b/packages/kubernetes/kubelet.service\n@@ -8,6 +8,11 @@ Requires=containerd.service\n [Service]\n EnvironmentFile=/etc/kubernetes/kubelet/env\n ExecStartPre=/sbin/iptables -P FORWARD ACCEPT\n+# Pull the pause container image before starting `kubelet` so `containerd/cri` wouldn't have to\n+ExecStartPre=/usr/bin/host-ctr -source ${POD_INFRA_CONTAINER_IMAGE} \\\n+    -pull-image-only \\\n+    -containerd-socket /run/containerd/containerd.sock \\\n+    -namespace k8s.io\n ExecStart=/usr/bin/kubelet \\\n     --cloud-provider aws \\\n     --config /etc/kubernetes/kubelet/config \\\ndiff --git a/workspaces/api/storewolf/defaults.toml b/workspaces/api/storewolf/defaults.toml\nindex b405bbde27a..f930837f20d 100644\n--- a/workspaces/api/storewolf/defaults.toml\n+++ b/workspaces/api/storewolf/defaults.toml\n@@ -25,7 +25,7 @@ val = [\"hostname\"]\n # Kubernetes.\n \n [services.kubernetes]\n-configuration-files = [\"kubelet-env\", \"kubelet-config\", \"kubelet-kubeconfig\", \"kubernetes-ca-crt\"]\n+configuration-files = [\"kubelet-env\", \"kubelet-config\", \"kubelet-kubeconfig\", \"kubernetes-ca-crt\", \"containerd-config-toml\"]\n restart-commands = []\n \n [configuration-files.kubelet-env]\n@@ -44,6 +44,10 @@ template-path = \"/usr/share/templates/kubelet-kubeconfig\"\n path = \"/etc/kubernetes/pki/ca.crt\"\n template-path = \"/usr/share/templates/kubernetes-ca-crt\"\n \n+[configuration-files.containerd-config-toml]\n+path = \"/etc/containerd/config.toml\"\n+template-path = \"/usr/share/templates/containerd-config-toml\"\n+\n [[metadata]]\n key = \"settings.kubernetes.max-pods\"\n md = \"setting-generator\"\ndiff --git a/workspaces/host-ctr/cmd/host-ctr/main.go b/workspaces/host-ctr/cmd/host-ctr/main.go\nindex 9553bfba698..80bac447f56 100644\n--- a/workspaces/host-ctr/cmd/host-ctr/main.go\n+++ b/workspaces/host-ctr/cmd/host-ctr/main.go\n@@ -29,20 +29,29 @@ func main() {\n \n func _main() int {\n \t// Parse command-line arguments\n-\ttargetCtr, source := \"\", \"\"\n-\tsuperpowered := false\n-\n+\tvar (\n+\t\ttargetCtr        string\n+\t\tsource           string\n+\t\tcontainerdSocket string\n+\t\tnamespace        string\n+\t\tsuperpowered     bool\n+\t\tpullImageOnly    bool\n+\t)\n \tflag.StringVar(&targetCtr, \"ctr-id\", \"\", \"The ID of the container to be started\")\n \tflag.StringVar(&source, \"source\", \"\", \"The image to be pulled\")\n \tflag.BoolVar(&superpowered, \"superpowered\", false, \"Specifies whether to launch the container in `superpowered` mode or not\")\n+\tflag.BoolVar(&pullImageOnly, \"pull-image-only\", false, \"Only pull and unpack the container image, do not start any container task\")\n+\tflag.StringVar(&containerdSocket, \"containerd-socket\", \"/run/host-containerd/containerd.sock\", \"Specifies the path to the containerd socket. Defaults to `/run/host-containerd/containerd.sock`\")\n+\tflag.StringVar(&namespace, \"namespace\", \"default\", \"Specifies the containerd namespace\")\n \tflag.Parse()\n \n-\tif targetCtr == \"\" || source == \"\" {\n+\tif source == \"\" || (targetCtr == \"\" && !pullImageOnly) {\n \t\tflag.Usage()\n \t\treturn 2\n \t}\n-\n-\tctx := namespaces.NamespaceFromEnv(context.Background())\n+\tctx, cancel := context.WithCancel(context.Background())\n+\tctx = namespaces.WithNamespace(ctx, namespace)\n+\tdefer cancel()\n \n \t// Set up channel on which to send signal notifications.\n \t// We must use a buffered channel or risk missing the signal\n@@ -52,21 +61,50 @@ func _main() int {\n \n \t// Set up containerd client\n \t// Use host containers' containerd socket\n-\tclient, err := containerd.New(\"/run/host-containerd/containerd.sock\")\n+\tclient, err := containerd.New(containerdSocket, containerd.WithDefaultNamespace(namespace))\n \tif err != nil {\n-\t\tlog.G(ctx).WithError(err).Error(\"Failed to connect to containerd\")\n+\t\tlog.G(ctx).WithError(err).WithFields(map[string]interface{}{\"containerdSocket\": containerdSocket, \"namespace\": namespace}).Error(\"Failed to connect to containerd\")\n \t\treturn 1\n \t}\n \tdefer client.Close()\n \n-\t// Clean up target container if it already exists before starting container task\n-\tif err := deleteCtrIfExists(ctx, client, targetCtr); err != nil {\n-\t\treturn 1\n+\t// Check if the image is from ECR, if it is, convert the image name into a resolvable reference\n+\tvar ref string\n+\tmatch := ecrRegex.MatchString(source)\n+\tif match {\n+\t\tvar err error\n+\t\tref, err = ecrImageNameToRef(source)\n+\t\tif err != nil {\n+\t\t\tlog.G(ctx).WithError(err).WithField(\"source\", source)\n+\t\t\treturn 1\n+\t\t}\n \t}\n \n-\timg, err := pullImage(ctx, source, client)\n+\timg, err := pullImage(ctx, ref, client)\n \tif err != nil {\n-\t\tlog.G(ctx).WithField(\"source\", source).Error(err)\n+\t\tlog.G(ctx).WithField(\"ref\", ref).Error(err)\n+\t\treturn 1\n+\t}\n+\n+\t// If the image is from ECR, the image reference will be converted into the form of\n+\t// `\"ecr.aws/\" + the ARN of the image repository + label/digest`.\n+\t// We tag the image with its original image name so other services can discover this image by its original image reference.\n+\t// After the tag operation, this image should be addressable by both its original image reference and its ECR resolver resolvable reference.\n+\tif match {\n+\t\t// Include original tag on ECR image for other consumers.\n+\t\tif err := tagImage(ctx, ref, source, client); err != nil {\n+\t\t\tlog.G(ctx).WithError(err).WithField(\"source\", source).Error(\"Failed to tag an image with original image name\")\n+\t\t\treturn 1\n+\t\t}\n+\t}\n+\n+\t// If we're only pulling and unpacking the image, we're done here\n+\tif pullImageOnly {\n+\t\treturn 0\n+\t}\n+\n+\t// Clean up target container if it already exists before starting container task\n+\tif err := deleteCtrIfExists(ctx, client, targetCtr); err != nil {\n \t\treturn 1\n \t}\n \n@@ -252,15 +290,7 @@ var ecrRegex = regexp.MustCompile(`(^[a-zA-Z0-9][a-zA-Z0-9-_]*)\\.dkr\\.ecr\\.([a-z\n \n // Pulls image from specified source\n func pullImage(ctx context.Context, source string, client *containerd.Client) (containerd.Image, error) {\n-\tif match := ecrRegex.MatchString(source); match {\n-\t\tvar err error\n-\t\tsource, err = ecrImageNameToRef(source)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t}\n-\n-\t// Pull the image from ECR\n+\t// Pull the image\n \timg, err := client.Pull(ctx, source,\n \t\twithDynamicResolver(ctx, source),\n \t\tcontainerd.WithSchema1Conversion)\n@@ -275,6 +305,35 @@ func pullImage(ctx context.Context, source string, client *containerd.Client) (c\n \treturn img, nil\n }\n \n+// Image tag logic derived from:\n+// https://github.com/containerd/containerd/blob/d80513ee8a6995bc7889c93e7858ddbbc51f063d/cmd/ctr/commands/images/tag.go#L67-L86\n+func tagImage(ctx context.Context, imageName string, newImageName string, client *containerd.Client) error {\n+\tlog.G(ctx).WithField(\"imageName\", newImageName).Info(\"Tagging image\")\n+\t// Retrieve image information\n+\timageService := client.ImageService()\n+\timage, err := imageService.Get(ctx, imageName)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\t// Tag with new image name\n+\timage.Name = newImageName\n+\t// Attempt to create the image first\n+\tif _, err = imageService.Create(ctx, image); err != nil {\n+\t\t// The image already exists then delete the original and attempt to create the new one\n+\t\tif errdefs.IsAlreadyExists(err) {\n+\t\t\tif err = imageService.Delete(ctx, newImageName); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif _, err = imageService.Create(ctx, image); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n // Return the resolver appropriate for the specified image reference\n func withDynamicResolver(ctx context.Context, ref string) containerd.RemoteOpt {\n \tif !strings.HasPrefix(ref, \"ecr.aws/\") {\n@@ -293,7 +352,7 @@ func withDynamicResolver(ctx context.Context, ref string) containerd.RemoteOpt {\n \t}\n }\n \n-// Transform an ECR image name into a reference resolvable by the Amazon ECR Containerd Resolver\n+// Transform an ECR image name into a reference resolvable by the Amazon ECR containerd Resolver\n // e.g. ecr.aws/arn:<partition>:ecr:<region>:<account>:repository/<name>:<tag>\n func ecrImageNameToRef(input string) (string, error) {\n \tref := \"ecr.aws/\"\n@@ -322,24 +381,27 @@ func ecrImageNameToRef(input string) (string, error) {\n \t} else if isGovCloudEndpoint {\n \t\tpartition = \"aws-us-gov\"\n \t}\n-\t// Separate out <name>:<tag>\n+\t// Separate out <name>:<tag> for checking validity\n \ttokens := strings.Split(input, \"/\")\n-\tif len(tokens) != 2 {\n+\tif len(tokens) < 2 {\n \t\treturn \"\", errors.New(\"No specified name and tag or digest\")\n \t}\n-\tfullImageId := tokens[1]\n+\tfullImageId := tokens[len(tokens)-1]\n \tmatchDigest, _ := regexp.MatchString(`^[a-zA-Z0-9-_]+@sha256:[A-Fa-f0-9]{64}$`, fullImageId)\n-\tmatchTag, _ := regexp.MatchString(`^[a-zA-Z0-9-_]+:[a-zA-Z0-9.-_]{1,128}$`, fullImageId)\n+\tmatchTag, _ := regexp.MatchString(`^[a-zA-Z0-9-_]+:[a-zA-Z0-9\\.\\-_]{1,128}$`, fullImageId)\n \tif !matchDigest && !matchTag {\n \t\treturn \"\", errors.New(\"Malformed name and tag or digest\")\n \t}\n+\t// Need to include the full repository path and the imageID (e.g. /eks/image-name:tag)\n+\ttokens = strings.SplitN(input, \"/\", 2)\n+\tfullPath := tokens[len(tokens)-1]\n \t// Build the ARN for the reference\n \tecrARN := &arn.ARN{\n \t\tPartition: partition,\n \t\tService:   \"ecr\",\n \t\tRegion:    region,\n \t\tAccountID: account,\n-\t\tResource:  \"repository/\" + fullImageId,\n+\t\tResource:  \"repository/\" + fullPath,\n \t}\n \treturn ref + ecrARN.String(), nil\n }\n", "test_patch": "diff --git a/workspaces/host-ctr/cmd/host-ctr/main_test.go b/workspaces/host-ctr/cmd/host-ctr/main_test.go\nindex 199c1f358f2..f4fa5ba16eb 100644\n--- a/workspaces/host-ctr/cmd/host-ctr/main_test.go\n+++ b/workspaces/host-ctr/cmd/host-ctr/main_test.go\n@@ -13,6 +13,7 @@ func TestECRImageNameToRefValid(t *testing.T) {\n \t\texpected  string\n \t}{\n \t\t{\"Standard\", \"777777777777.dkr.ecr.us-west-2.amazonaws.com/my_image:latest\", \"ecr.aws/arn:aws:ecr:us-west-2:777777777777:repository/my_image:latest\"},\n+\t\t{\"Standard: With additional repository path\", \"777777777777.dkr.ecr.us-west-2.amazonaws.com/foo/bar/my_image:latest\", \"ecr.aws/arn:aws:ecr:us-west-2:777777777777:repository/foo/bar/my_image:latest\"},\n \t\t{\"Standard: Digests\", \"777777777777.dkr.ecr.us-west-2.amazonaws.com/my_image@sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\", \"ecr.aws/arn:aws:ecr:us-west-2:777777777777:repository/my_image@sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"},\n \t\t{\"AWS CN partition\", \"777777777777.dkr.ecr.cn-north-1.amazonaws.com.cn/my_image:latest\", \"ecr.aws/arn:aws-cn:ecr:cn-north-1:777777777777:repository/my_image:latest\"},\n \t\t{\"AWS Gov Cloud West\", \"777777777777.dkr.ecr.us-gov-west-1.amazonaws.com/my_image:latest\", \"ecr.aws/arn:aws-us-gov:ecr:us-gov-west-1:777777777777:repository/my_image:latest\"},\n", "problem_statement": "kubelet: pod-infra-container-image flag does not work with containerd\n> Warning: For remote container runtime, --pod-infra-container-image is ignored in kubelet, which should be set in that remote runtime instead\r\n\r\nTo address this, we need to:\r\n- [ ] remove this flag from kubelet unit file\r\n- [ ] drop `settings.kubernetes.pod_infra_container_image`\r\n- [ ] add `settings.containerd.sandbox_image`\r\n- [ ] convert `/etc/containerd/config.toml` and `host-containerd-config.toml` to templates\r\n- [ ] modify `pluto` to support the renamed setting\n", "hints_text": "See containerd's [cri plugin config](https://github.com/containerd/cri/blob/master/docs/config.md) for the expected setting.", "created_at": "2019-10-08T22:57:30Z"}]