[{"repo": "asterinas/asterinas", "pull_number": 1369, "instance_id": "asterinas__asterinas-1369", "issue_numbers": ["919"], "base_commit": "ae4ac384713e63232b74915593ebdef680049d31", "patch": "diff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\nindex f691a40453..4cdd850def 100644\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -16,7 +16,7 @@ use align_ext::AlignExt;\n use aster_rights::Rights;\n use ostd::{\n     cpu::CpuExceptionInfo,\n-    mm::{VmSpace, MAX_USERSPACE_VADDR},\n+    mm::{tlb::TlbFlushOp, PageFlags, PageProperty, VmSpace, MAX_USERSPACE_VADDR},\n };\n \n use self::{\n@@ -220,13 +220,6 @@ impl Vmar_ {\n     }\n \n     fn new_root() -> Arc<Self> {\n-        fn handle_page_fault_wrapper(\n-            vm_space: &VmSpace,\n-            trap_info: &CpuExceptionInfo,\n-        ) -> core::result::Result<(), ()> {\n-            handle_page_fault_from_vm_space(vm_space, &trap_info.try_into().unwrap())\n-        }\n-\n         let mut free_regions = BTreeMap::new();\n         let root_region = FreeRegion::new(ROOT_VMAR_LOWEST_ADDR..ROOT_VMAR_CAP_ADDR);\n         free_regions.insert(root_region.start(), root_region);\n@@ -236,7 +229,7 @@ impl Vmar_ {\n             vm_mappings: BTreeMap::new(),\n             free_regions,\n         };\n-        let vm_space = VmSpace::new();\n+        let mut vm_space = VmSpace::new();\n         vm_space.register_page_fault_handler(handle_page_fault_wrapper);\n         Vmar_::new(vmar_inner, Arc::new(vm_space), 0, ROOT_VMAR_CAP_ADDR, None)\n     }\n@@ -668,17 +661,19 @@ impl Vmar_ {\n             let vm_space = if let Some(parent) = parent {\n                 parent.vm_space().clone()\n             } else {\n-                Arc::new(self.vm_space().fork_copy_on_write())\n+                let mut new_space = VmSpace::new();\n+                new_space.register_page_fault_handler(handle_page_fault_wrapper);\n+                Arc::new(new_space)\n             };\n             Vmar_::new(vmar_inner, vm_space, self.base, self.size, parent)\n         };\n \n         let inner = self.inner.lock();\n+        let mut new_inner = new_vmar_.inner.lock();\n+\n         // Clone free regions.\n         for (free_region_base, free_region) in &inner.free_regions {\n-            new_vmar_\n-                .inner\n-                .lock()\n+            new_inner\n                 .free_regions\n                 .insert(*free_region_base, free_region.clone());\n         }\n@@ -686,26 +681,49 @@ impl Vmar_ {\n         // Clone child vmars.\n         for (child_vmar_base, child_vmar_) in &inner.child_vmar_s {\n             let new_child_vmar = child_vmar_.new_fork(Some(&new_vmar_))?;\n-            new_vmar_\n-                .inner\n-                .lock()\n+            new_inner\n                 .child_vmar_s\n                 .insert(*child_vmar_base, new_child_vmar);\n         }\n \n         // Clone mappings.\n-        for (vm_mapping_base, vm_mapping) in &inner.vm_mappings {\n-            let new_mapping = Arc::new(vm_mapping.new_fork(&new_vmar_)?);\n-            new_vmar_\n-                .inner\n-                .lock()\n-                .vm_mappings\n-                .insert(*vm_mapping_base, new_mapping);\n+        {\n+            let new_vmspace = new_vmar_.vm_space();\n+            let range = self.base..(self.base + self.size);\n+            let mut new_cursor = new_vmspace.cursor_mut(&range).unwrap();\n+            let cur_vmspace = self.vm_space();\n+            let mut cur_cursor = cur_vmspace.cursor_mut(&range).unwrap();\n+            for (vm_mapping_base, vm_mapping) in &inner.vm_mappings {\n+                // Clone the `VmMapping` to the new VMAR.\n+                let new_mapping = Arc::new(vm_mapping.new_fork(&new_vmar_)?);\n+                new_inner.vm_mappings.insert(*vm_mapping_base, new_mapping);\n+\n+                // Protect the mapping and copy to the new page table for COW.\n+                cur_cursor.jump(*vm_mapping_base).unwrap();\n+                new_cursor.jump(*vm_mapping_base).unwrap();\n+                let mut op = |page: &mut PageProperty| {\n+                    page.flags -= PageFlags::W;\n+                };\n+                new_cursor.copy_from(&mut cur_cursor, vm_mapping.map_size(), &mut op);\n+            }\n+            cur_cursor.flusher().issue_tlb_flush(TlbFlushOp::All);\n+            cur_cursor.flusher().dispatch_tlb_flush();\n         }\n+\n+        drop(new_inner);\n+\n         Ok(new_vmar_)\n     }\n }\n \n+/// This is for fallible user space write handling.\n+fn handle_page_fault_wrapper(\n+    vm_space: &VmSpace,\n+    trap_info: &CpuExceptionInfo,\n+) -> core::result::Result<(), ()> {\n+    handle_page_fault_from_vm_space(vm_space, &trap_info.try_into().unwrap())\n+}\n+\n impl<R> Vmar<R> {\n     /// The base address, i.e., the offset relative to the root VMAR.\n     ///\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\nindex b5d818e668..87ed53d484 100644\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -11,7 +11,8 @@ use core::{\n use align_ext::AlignExt;\n use aster_rights::Rights;\n use ostd::mm::{\n-    vm_space::VmItem, CachePolicy, Frame, FrameAllocOptions, PageFlags, PageProperty, VmSpace,\n+    tlb::TlbFlushOp, vm_space::VmItem, CachePolicy, Frame, FrameAllocOptions, PageFlags,\n+    PageProperty, VmSpace,\n };\n \n use super::{interval::Interval, is_intersected, Vmar, Vmar_};\n@@ -224,7 +225,7 @@ impl VmMapping {\n \n         match cursor.query().unwrap() {\n             VmItem::Mapped {\n-                va: _,\n+                va,\n                 frame,\n                 mut prop,\n             } if is_write => {\n@@ -245,7 +246,9 @@ impl VmMapping {\n                 let new_flags = PageFlags::W | PageFlags::ACCESSED | PageFlags::DIRTY;\n \n                 if self.is_shared || only_reference {\n-                    cursor.protect(PAGE_SIZE, |p| p.flags |= new_flags);\n+                    cursor.protect_next(PAGE_SIZE, |p| p.flags |= new_flags);\n+                    cursor.flusher().issue_tlb_flush(TlbFlushOp::Address(va));\n+                    cursor.flusher().dispatch_tlb_flush();\n                 } else {\n                     let new_frame = duplicate_frame(&frame)?;\n                     prop.flags |= new_flags;\n@@ -558,7 +561,15 @@ impl VmMappingInner {\n         debug_assert!(range.start % PAGE_SIZE == 0);\n         debug_assert!(range.end % PAGE_SIZE == 0);\n         let mut cursor = vm_space.cursor_mut(&range).unwrap();\n-        cursor.protect(range.len(), |p| p.flags = perms.into());\n+        let op = |p: &mut PageProperty| p.flags = perms.into();\n+        while cursor.virt_addr() < range.end {\n+            if let Some(va) = cursor.protect_next(range.end - cursor.virt_addr(), op) {\n+                cursor.flusher().issue_tlb_flush(TlbFlushOp::Range(va));\n+            } else {\n+                break;\n+            }\n+        }\n+        cursor.flusher().dispatch_tlb_flush();\n         Ok(())\n     }\n \ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\nindex 6bea920ae0..bfe2cafec6 100644\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -18,6 +18,7 @@ pub(crate) mod page;\n pub(crate) mod page_prop;\n pub(crate) mod page_table;\n pub mod stat;\n+pub mod tlb;\n pub mod vm_space;\n \n use core::{fmt::Debug, ops::Range};\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\nindex a02f490dff..9a643ee1d9 100644\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -734,26 +734,93 @@ where\n         None\n     }\n \n-    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n-        &self.0.preempt_guard\n-    }\n-\n-    /// Consumes itself and leak the root guard for the caller if it locked the root level.\n+    /// Copies the mapping from the given cursor to the current cursor.\n     ///\n-    /// It is useful when the caller wants to keep the root guard while the cursor should be dropped.\n-    pub(super) fn leak_root_guard(mut self) -> Option<PageTableNode<E, C>> {\n-        if self.0.guard_level != C::NR_LEVELS {\n-            return None;\n-        }\n+    /// All the mappings in the current cursor's range must be empty. The\n+    /// function allows the source cursor to operate on the mapping before\n+    /// the copy happens. So it is equivalent to protect then duplicate.\n+    /// Only the mapping is copied, the mapped pages are not copied.\n+    ///\n+    /// It can only copy tracked mappings since we consider the untracked\n+    /// mappings not useful to be copied.\n+    ///\n+    /// After the operation, both cursors will advance by the specified length.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that\n+    ///  - the range being copied with the operation does not affect kernel's\n+    ///    memory safety.\n+    ///  - both of the cursors are in tracked mappings.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if:\n+    ///  - either one of the range to be copied is out of the range where any\n+    ///    of the cursor is required to operate;\n+    ///  - either one of the specified virtual address ranges only covers a\n+    ///    part of a page.\n+    ///  - the current cursor's range contains mapped pages.\n+    pub unsafe fn copy_from(\n+        &mut self,\n+        src: &mut Self,\n+        len: usize,\n+        op: &mut impl FnMut(&mut PageProperty),\n+    ) {\n+        assert!(len % page_size::<C>(1) == 0);\n+        let this_end = self.0.va + len;\n+        assert!(this_end <= self.0.barrier_va.end);\n+        let src_end = src.0.va + len;\n+        assert!(src_end <= src.0.barrier_va.end);\n \n-        while self.0.level < C::NR_LEVELS {\n-            self.0.level_up();\n-        }\n+        while self.0.va < this_end && src.0.va < src_end {\n+            let cur_pte = src.0.read_cur_pte();\n+            if !cur_pte.is_present() {\n+                src.0.move_forward();\n+                continue;\n+            }\n+\n+            // Go down if it's not a last node.\n+            if !cur_pte.is_last(src.0.level) {\n+                src.0.level_down();\n+\n+                // We have got down a level. If there's no mapped PTEs in\n+                // the current node, we can go back and skip to save time.\n+                if src.0.guards[(src.0.level - 1) as usize]\n+                    .as_ref()\n+                    .unwrap()\n+                    .nr_children()\n+                    == 0\n+                {\n+                    src.0.level_up();\n+                    src.0.move_forward();\n+                }\n+\n+                continue;\n+            }\n \n-        self.0.guards[(C::NR_LEVELS - 1) as usize].take()\n+            // Do protection.\n+            let mut pte_prop = cur_pte.prop();\n+            op(&mut pte_prop);\n+\n+            let idx = src.0.cur_idx();\n+            src.cur_node_mut().protect(idx, pte_prop);\n \n-        // Ok to drop the cursor here because we ensure not to access the page table if the current\n-        // level is the root level when running the dropping method.\n+            // Do copy.\n+            let child = src.cur_node_mut().child(idx, true);\n+            let Child::<E, C>::Page(page, prop) = child else {\n+                panic!(\"Unexpected child for source mapping: {:#?}\", child);\n+            };\n+            self.jump(src.0.va).unwrap();\n+            let mapped_page_size = page.size();\n+            let original = self.map(page, prop);\n+            debug_assert!(original.is_none());\n+\n+            // Only move the source cursor forward since `Self::map` will do it.\n+            // This assertion is to ensure that they move by the same length.\n+            debug_assert_eq!(mapped_page_size, page_size::<C>(src.0.level));\n+            src.0.move_forward();\n+        }\n     }\n \n     /// Goes down a level assuming the current slot is absent.\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\nindex 9bb1e2cc62..a8294c38da 100644\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -92,53 +92,29 @@ impl PageTable<UserMode> {\n             self.root.activate();\n         }\n     }\n-\n-    /// Create a cloned new page table.\n-    ///\n-    /// This method takes a mutable cursor to the old page table that locks the\n-    /// entire virtual address range. The caller may implement the copy-on-write\n-    /// mechanism by first protecting the old page table and then clone it using\n-    /// this method.\n-    ///\n-    /// TODO: We may consider making the page table itself copy-on-write.\n-    pub fn clone_with(\n-        &self,\n-        cursor: CursorMut<'_, UserMode, PageTableEntry, PagingConsts>,\n-    ) -> Self {\n-        let root_node = cursor.leak_root_guard().unwrap();\n-\n-        const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n-        let new_root_node = unsafe {\n-            root_node.make_copy(\n-                0..NR_PTES_PER_NODE / 2,\n-                NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE,\n-            )\n-        };\n-\n-        PageTable::<UserMode> {\n-            root: new_root_node.into_raw(),\n-            _phantom: PhantomData,\n-        }\n-    }\n }\n \n impl PageTable<KernelMode> {\n     /// Create a new user page table.\n     ///\n-    /// This should be the only way to create the first user page table, that is\n-    /// to fork the kernel page table with all the kernel mappings shared.\n-    ///\n-    /// Then, one can use a user page table to call [`fork_copy_on_write`], creating\n-    /// other child page tables.\n+    /// This should be the only way to create the user page table, that is to\n+    /// duplicate the kernel page table with all the kernel mappings shared.\n     pub fn create_user_page_table(&self) -> PageTable<UserMode> {\n         let root_node = self.root.clone_shallow().lock();\n+        let mut new_node = PageTableNode::alloc(PagingConsts::NR_LEVELS);\n \n+        // Make a shallow copy of the root node in the kernel space range.\n+        // The user space range is not copied.\n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n-        let new_root_node =\n-            unsafe { root_node.make_copy(0..0, NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE) };\n+        for i in NR_PTES_PER_NODE / 2..NR_PTES_PER_NODE {\n+            let child = root_node.child(i, /* meaningless */ true);\n+            if !child.is_none() {\n+                let _ = new_node.replace_child(i, child, /* meaningless */ true);\n+            }\n+        }\n \n         PageTable::<UserMode> {\n-            root: new_root_node.into_raw(),\n+            root: new_node.into_raw(),\n             _phantom: PhantomData,\n         }\n     }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\nindex 134cd112a0..f39d9daf57 100644\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -25,9 +25,7 @@\n //! the initialization of the entity that the PTE points to. This is taken care in this module.\n //!\n \n-use core::{\n-    fmt, marker::PhantomData, mem::ManuallyDrop, ops::Range, panic, sync::atomic::Ordering,\n-};\n+use core::{fmt, marker::PhantomData, mem::ManuallyDrop, panic, sync::atomic::Ordering};\n \n use super::{nr_subpage_per_huge, page_size, PageTableEntryTrait};\n use crate::{\n@@ -374,74 +372,6 @@ where\n         }\n     }\n \n-    /// Makes a copy of the page table node.\n-    ///\n-    /// This function allows you to control about the way to copy the children.\n-    /// For indexes in `deep`, the children are deep copied and this function will be recursively called.\n-    /// For indexes in `shallow`, the children are shallow copied as new references.\n-    ///\n-    /// You cannot shallow copy a child that is mapped to a page. Deep copying a page child will not\n-    /// copy the mapped page but will copy the handle to the page.\n-    ///\n-    /// You cannot either deep copy or shallow copy a child that is mapped to an untracked page.\n-    ///\n-    /// The ranges must be disjoint.\n-    pub(super) unsafe fn make_copy(&self, deep: Range<usize>, shallow: Range<usize>) -> Self {\n-        debug_assert!(deep.end <= nr_subpage_per_huge::<C>());\n-        debug_assert!(shallow.end <= nr_subpage_per_huge::<C>());\n-        debug_assert!(deep.end <= shallow.start || deep.start >= shallow.end);\n-\n-        let mut new_pt = Self::alloc(self.level());\n-        let mut copied_child_count = self.nr_children();\n-        for i in deep {\n-            if copied_child_count == 0 {\n-                return new_pt;\n-            }\n-            match self.child(i, true) {\n-                Child::PageTable(pt) => {\n-                    let guard = pt.clone_shallow().lock();\n-                    let new_child = guard.make_copy(0..nr_subpage_per_huge::<C>(), 0..0);\n-                    let old = new_pt.replace_child(i, Child::PageTable(new_child.into_raw()), true);\n-                    debug_assert!(old.is_none());\n-                    copied_child_count -= 1;\n-                }\n-                Child::Page(page, prop) => {\n-                    let old = new_pt.replace_child(i, Child::Page(page.clone(), prop), true);\n-                    debug_assert!(old.is_none());\n-                    copied_child_count -= 1;\n-                }\n-                Child::None => {}\n-                Child::Untracked(_, _) => {\n-                    unreachable!();\n-                }\n-            }\n-        }\n-\n-        for i in shallow {\n-            if copied_child_count == 0 {\n-                return new_pt;\n-            }\n-            debug_assert_eq!(self.level(), C::NR_LEVELS);\n-            match self.child(i, /*meaningless*/ true) {\n-                Child::PageTable(pt) => {\n-                    let old = new_pt.replace_child(\n-                        i,\n-                        Child::PageTable(pt.clone_shallow()),\n-                        /*meaningless*/ true,\n-                    );\n-                    debug_assert!(old.is_none());\n-                    copied_child_count -= 1;\n-                }\n-                Child::None => {}\n-                Child::Page(_, _) | Child::Untracked(_, _) => {\n-                    unreachable!();\n-                }\n-            }\n-        }\n-\n-        new_pt\n-    }\n-\n     /// Splits the untracked huge page mapped at `idx` to smaller pages.\n     pub(super) fn split_untracked_huge(&mut self, idx: usize) {\n         // These should be ensured by the cursor.\ndiff --git a/ostd/src/mm/tlb.rs b/ostd/src/mm/tlb.rs\nnew file mode 100644\nindex 0000000000..4ec58e091e\n--- /dev/null\n+++ b/ostd/src/mm/tlb.rs\n@@ -0,0 +1,222 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! TLB flush operations.\n+\n+use alloc::vec::Vec;\n+use core::ops::Range;\n+\n+use super::{page::DynPage, Vaddr, PAGE_SIZE};\n+use crate::{\n+    cpu::{CpuSet, PinCurrentCpu},\n+    cpu_local,\n+    sync::SpinLock,\n+    task::disable_preempt,\n+};\n+\n+/// A TLB flusher that is aware of which CPUs are needed to be flushed.\n+///\n+/// The flusher needs to stick to the current CPU.\n+pub struct TlbFlusher<G: PinCurrentCpu> {\n+    target_cpus: CpuSet,\n+    // Better to store them here since loading and counting them from the CPUs\n+    // list brings non-trivial overhead.\n+    need_remote_flush: bool,\n+    need_self_flush: bool,\n+    _pin_current: G,\n+}\n+\n+impl<G: PinCurrentCpu> TlbFlusher<G> {\n+    /// Creates a new TLB flusher with the specified CPUs to be flushed.\n+    ///\n+    /// The flusher needs to stick to the current CPU. So please provide a\n+    /// guard that implements [`PinCurrentCpu`].\n+    pub fn new(target_cpus: CpuSet, pin_current_guard: G) -> Self {\n+        let current_cpu = pin_current_guard.current_cpu();\n+\n+        let mut need_self_flush = false;\n+        let mut need_remote_flush = false;\n+\n+        for cpu in target_cpus.iter() {\n+            if cpu == current_cpu {\n+                need_self_flush = true;\n+            } else {\n+                need_remote_flush = true;\n+            }\n+        }\n+        Self {\n+            target_cpus,\n+            need_remote_flush,\n+            need_self_flush,\n+            _pin_current: pin_current_guard,\n+        }\n+    }\n+\n+    /// Issues a pending TLB flush request.\n+    ///\n+    /// On SMP systems, the notification is sent to all the relevant CPUs only\n+    /// when [`Self::dispatch_tlb_flush`] is called.\n+    pub fn issue_tlb_flush(&self, op: TlbFlushOp) {\n+        self.issue_tlb_flush_(op, None);\n+    }\n+\n+    /// Dispatches all the pending TLB flush requests.\n+    ///\n+    /// The pending requests are issued by [`Self::issue_tlb_flush`].\n+    pub fn dispatch_tlb_flush(&self) {\n+        if !self.need_remote_flush {\n+            return;\n+        }\n+\n+        crate::smp::inter_processor_call(&self.target_cpus, do_remote_flush);\n+    }\n+\n+    /// Issues a TLB flush request that must happen before dropping the page.\n+    ///\n+    /// If we need to remove a mapped page from the page table, we can only\n+    /// recycle the page after all the relevant TLB entries in all CPUs are\n+    /// flushed. Otherwise if the page is recycled for other purposes, the user\n+    /// space program can still access the page through the TLB entries. This\n+    /// method is designed to be used in such cases.\n+    pub fn issue_tlb_flush_with(&self, op: TlbFlushOp, drop_after_flush: DynPage) {\n+        self.issue_tlb_flush_(op, Some(drop_after_flush));\n+    }\n+\n+    /// Whether the TLB flusher needs to flush the TLB entries on other CPUs.\n+    pub fn need_remote_flush(&self) -> bool {\n+        self.need_remote_flush\n+    }\n+\n+    /// Whether the TLB flusher needs to flush the TLB entries on the current CPU.\n+    pub fn need_self_flush(&self) -> bool {\n+        self.need_self_flush\n+    }\n+\n+    fn issue_tlb_flush_(&self, op: TlbFlushOp, drop_after_flush: Option<DynPage>) {\n+        let op = op.optimize_for_large_range();\n+\n+        // Fast path for single CPU cases.\n+        if !self.need_remote_flush {\n+            if self.need_self_flush {\n+                op.perform_on_current();\n+            }\n+            return;\n+        }\n+\n+        // Slow path for multi-CPU cases.\n+        for cpu in self.target_cpus.iter() {\n+            let mut op_queue = FLUSH_OPS.get_on_cpu(cpu).lock();\n+            if let Some(drop_after_flush) = drop_after_flush.clone() {\n+                PAGE_KEEPER.get_on_cpu(cpu).lock().push(drop_after_flush);\n+            }\n+            op_queue.push(op.clone());\n+        }\n+    }\n+}\n+\n+/// The operation to flush TLB entries.\n+#[derive(Debug, Clone)]\n+pub enum TlbFlushOp {\n+    /// Flush all TLB entries except for the global entries.\n+    All,\n+    /// Flush the TLB entry for the specified virtual address.\n+    Address(Vaddr),\n+    /// Flush the TLB entries for the specified virtual address range.\n+    Range(Range<Vaddr>),\n+}\n+\n+impl TlbFlushOp {\n+    /// Performs the TLB flush operation on the current CPU.\n+    pub fn perform_on_current(&self) {\n+        use crate::arch::mm::{\n+            tlb_flush_addr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n+        };\n+        match self {\n+            TlbFlushOp::All => tlb_flush_all_excluding_global(),\n+            TlbFlushOp::Address(addr) => tlb_flush_addr(*addr),\n+            TlbFlushOp::Range(range) => tlb_flush_addr_range(range),\n+        }\n+    }\n+\n+    fn optimize_for_large_range(self) -> Self {\n+        match self {\n+            TlbFlushOp::Range(range) => {\n+                if range.len() > FLUSH_ALL_RANGE_THRESHOLD {\n+                    TlbFlushOp::All\n+                } else {\n+                    TlbFlushOp::Range(range)\n+                }\n+            }\n+            _ => self,\n+        }\n+    }\n+}\n+\n+// The queues of pending requests on each CPU.\n+//\n+// Lock ordering: lock FLUSH_OPS before PAGE_KEEPER.\n+cpu_local! {\n+    static FLUSH_OPS: SpinLock<OpsStack> = SpinLock::new(OpsStack::new());\n+    static PAGE_KEEPER: SpinLock<Vec<DynPage>> = SpinLock::new(Vec::new());\n+}\n+\n+fn do_remote_flush() {\n+    let preempt_guard = disable_preempt();\n+    let current_cpu = preempt_guard.current_cpu();\n+\n+    let mut op_queue = FLUSH_OPS.get_on_cpu(current_cpu).lock();\n+    op_queue.flush_all();\n+    PAGE_KEEPER.get_on_cpu(current_cpu).lock().clear();\n+}\n+\n+/// If a TLB flushing request exceeds this threshold, we flush all.\n+pub(crate) const FLUSH_ALL_RANGE_THRESHOLD: usize = 32 * PAGE_SIZE;\n+\n+/// If the number of pending requests exceeds this threshold, we flush all the\n+/// TLB entries instead of flushing them one by one.\n+const FLUSH_ALL_OPS_THRESHOLD: usize = 32;\n+\n+struct OpsStack {\n+    ops: [Option<TlbFlushOp>; FLUSH_ALL_OPS_THRESHOLD],\n+    need_flush_all: bool,\n+    size: usize,\n+}\n+\n+impl OpsStack {\n+    const fn new() -> Self {\n+        const ARRAY_REPEAT_VALUE: Option<TlbFlushOp> = None;\n+        Self {\n+            ops: [ARRAY_REPEAT_VALUE; FLUSH_ALL_OPS_THRESHOLD],\n+            need_flush_all: false,\n+            size: 0,\n+        }\n+    }\n+\n+    fn push(&mut self, op: TlbFlushOp) {\n+        if self.need_flush_all {\n+            return;\n+        }\n+\n+        if self.size < FLUSH_ALL_OPS_THRESHOLD {\n+            self.ops[self.size] = Some(op);\n+            self.size += 1;\n+        } else {\n+            self.need_flush_all = true;\n+            self.size = 0;\n+        }\n+    }\n+\n+    fn flush_all(&mut self) {\n+        if self.need_flush_all {\n+            crate::arch::mm::tlb_flush_all_excluding_global();\n+            self.need_flush_all = false;\n+        } else {\n+            for i in 0..self.size {\n+                if let Some(op) = &self.ops[i] {\n+                    op.perform_on_current();\n+                }\n+            }\n+        }\n+\n+        self.size = 0;\n+    }\n+}\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\nindex 78109d9b8e..3c55d6c3bd 100644\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -9,32 +9,25 @@\n //! powerful concurrent accesses to the page table, and suffers from the same\n //! validity concerns as described in [`super::page_table::cursor`].\n \n-use alloc::collections::vec_deque::VecDeque;\n use core::{\n     ops::Range,\n     sync::atomic::{AtomicPtr, Ordering},\n };\n \n-use spin::Once;\n-\n-use super::{\n-    io::Fallible,\n-    kspace::KERNEL_PAGE_TABLE,\n-    page::DynPage,\n-    page_table::{PageTable, UserMode},\n-    PageFlags, PageProperty, VmReader, VmWriter, PAGE_SIZE,\n-};\n use crate::{\n     arch::mm::{current_page_table_paddr, PageTableEntry, PagingConsts},\n     cpu::{num_cpus, CpuExceptionInfo, CpuSet, PinCurrentCpu},\n     cpu_local,\n     mm::{\n-        page_table::{self, PageTableItem},\n-        Frame, MAX_USERSPACE_VADDR,\n+        io::Fallible,\n+        kspace::KERNEL_PAGE_TABLE,\n+        page_table::{self, PageTable, PageTableItem, UserMode},\n+        tlb::{TlbFlushOp, TlbFlusher, FLUSH_ALL_RANGE_THRESHOLD},\n+        Frame, PageProperty, VmReader, VmWriter, MAX_USERSPACE_VADDR,\n     },\n     prelude::*,\n-    sync::{RwLock, RwLockReadGuard, SpinLock},\n-    task::disable_preempt,\n+    sync::{RwLock, RwLockReadGuard},\n+    task::{disable_preempt, DisabledPreemptGuard},\n     Error,\n };\n \n@@ -56,7 +49,7 @@ use crate::{\n #[derive(Debug)]\n pub struct VmSpace {\n     pt: PageTable<UserMode>,\n-    page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n+    page_fault_handler: Option<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n     /// A CPU can only activate a `VmSpace` when no mutable cursors are alive.\n     /// Cursors hold read locks and activation require a write lock.\n     activation_lock: RwLock<()>,\n@@ -67,7 +60,7 @@ impl VmSpace {\n     pub fn new() -> Self {\n         Self {\n             pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n-            page_fault_handler: Once::new(),\n+            page_fault_handler: None,\n             activation_lock: RwLock::new(()),\n         }\n     }\n@@ -98,11 +91,7 @@ impl VmSpace {\n         Ok(self.pt.cursor_mut(va).map(|pt_cursor| {\n             let activation_lock = self.activation_lock.read();\n \n-            let cur_cpu = pt_cursor.preempt_guard().current_cpu();\n-\n             let mut activated_cpus = CpuSet::new_empty();\n-            let mut need_self_flush = false;\n-            let mut need_remote_flush = false;\n \n             for cpu in 0..num_cpus() {\n                 // The activation lock is held; other CPUs cannot activate this `VmSpace`.\n@@ -110,20 +99,13 @@ impl VmSpace {\n                     ACTIVATED_VM_SPACE.get_on_cpu(cpu).load(Ordering::Relaxed) as *const VmSpace;\n                 if ptr == self as *const VmSpace {\n                     activated_cpus.add(cpu);\n-                    if cpu == cur_cpu {\n-                        need_self_flush = true;\n-                    } else {\n-                        need_remote_flush = true;\n-                    }\n                 }\n             }\n \n             CursorMut {\n                 pt_cursor,\n                 activation_lock,\n-                activated_cpus,\n-                need_remote_flush,\n-                need_self_flush,\n+                flusher: TlbFlusher::new(activated_cpus, disable_preempt()),\n             }\n         })?)\n     }\n@@ -156,63 +138,18 @@ impl VmSpace {\n         &self,\n         info: &CpuExceptionInfo,\n     ) -> core::result::Result<(), ()> {\n-        if let Some(func) = self.page_fault_handler.get() {\n+        if let Some(func) = self.page_fault_handler {\n             return func(self, info);\n         }\n         Err(())\n     }\n \n     /// Registers the page fault handler in this `VmSpace`.\n-    ///\n-    /// The page fault handler of a `VmSpace` can only be initialized once.\n-    /// If it has been initialized before, calling this method will have no effect.\n     pub fn register_page_fault_handler(\n-        &self,\n+        &mut self,\n         func: fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>,\n     ) {\n-        self.page_fault_handler.call_once(|| func);\n-    }\n-\n-    /// Forks a new VM space with copy-on-write semantics.\n-    ///\n-    /// Both the parent and the newly forked VM space will be marked as\n-    /// read-only. And both the VM space will take handles to the same\n-    /// physical memory pages.\n-    pub fn fork_copy_on_write(&self) -> Self {\n-        // Protect the parent VM space as read-only.\n-        let end = MAX_USERSPACE_VADDR;\n-        let mut cursor = self.cursor_mut(&(0..end)).unwrap();\n-        let mut op = |prop: &mut PageProperty| {\n-            prop.flags -= PageFlags::W;\n-        };\n-\n-        cursor.protect(end, &mut op);\n-\n-        let page_fault_handler = {\n-            let new_handler = Once::new();\n-            if let Some(handler) = self.page_fault_handler.get() {\n-                new_handler.call_once(|| *handler);\n-            }\n-            new_handler\n-        };\n-\n-        let CursorMut {\n-            pt_cursor,\n-            activation_lock,\n-            ..\n-        } = cursor;\n-\n-        let new_pt = self.pt.clone_with(pt_cursor);\n-\n-        // Release the activation lock after the page table is cloned to\n-        // prevent modification to the parent page table while cloning.\n-        drop(activation_lock);\n-\n-        Self {\n-            pt: new_pt,\n-            page_fault_handler,\n-            activation_lock: RwLock::new(()),\n-        }\n+        self.page_fault_handler = Some(func);\n     }\n \n     /// Creates a reader to read data from the user space of the current task.\n@@ -311,12 +248,9 @@ pub struct CursorMut<'a, 'b> {\n     pt_cursor: page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>,\n     #[allow(dead_code)]\n     activation_lock: RwLockReadGuard<'b, ()>,\n-    // Better to store them here since loading and counting them from the CPUs\n-    // list brings non-trivial overhead. We have a read lock so the stored set\n-    // is always a superset of actual activated CPUs.\n-    activated_cpus: CpuSet,\n-    need_remote_flush: bool,\n-    need_self_flush: bool,\n+    // We have a read lock so the CPU set in the flusher is always a superset\n+    // of actual activated CPUs.\n+    flusher: TlbFlusher<DisabledPreemptGuard>,\n }\n \n impl CursorMut<'_, '_> {\n@@ -345,6 +279,11 @@ impl CursorMut<'_, '_> {\n         self.pt_cursor.virt_addr()\n     }\n \n+    /// Get the dedicated TLB flusher for this cursor.\n+    pub fn flusher(&self) -> &TlbFlusher<DisabledPreemptGuard> {\n+        &self.flusher\n+    }\n+\n     /// Map a frame into the current slot.\n     ///\n     /// This method will bring the cursor to the next slot after the modification.\n@@ -353,9 +292,10 @@ impl CursorMut<'_, '_> {\n         // SAFETY: It is safe to map untyped memory into the userspace.\n         let old = unsafe { self.pt_cursor.map(frame.into(), prop) };\n \n-        if old.is_some() {\n-            self.issue_tlb_flush(TlbFlushOp::Address(start_va), old);\n-            self.dispatch_tlb_flush();\n+        if let Some(old) = old {\n+            self.flusher\n+                .issue_tlb_flush_with(TlbFlushOp::Address(start_va), old);\n+            self.flusher.dispatch_tlb_flush();\n         }\n     }\n \n@@ -367,25 +307,31 @@ impl CursorMut<'_, '_> {\n     /// Already-absent mappings encountered by the cursor will be skipped. It\n     /// is valid to unmap a range that is not mapped.\n     ///\n+    /// It must issue and dispatch a TLB flush after the operation. Otherwise,\n+    /// the memory safety will be compromised. Please call this function less\n+    /// to avoid the overhead of TLB flush. Using a large `len` is wiser than\n+    /// splitting the operation into multiple small ones.\n+    ///\n     /// # Panics\n     ///\n     /// This method will panic if `len` is not page-aligned.\n     pub fn unmap(&mut self, len: usize) {\n         assert!(len % super::PAGE_SIZE == 0);\n         let end_va = self.virt_addr() + len;\n-        let tlb_prefer_flush_all = len > TLB_FLUSH_ALL_THRESHOLD * PAGE_SIZE;\n+        let tlb_prefer_flush_all = len > FLUSH_ALL_RANGE_THRESHOLD;\n \n         loop {\n             // SAFETY: It is safe to un-map memory in the userspace.\n             let result = unsafe { self.pt_cursor.take_next(end_va - self.virt_addr()) };\n             match result {\n                 PageTableItem::Mapped { va, page, .. } => {\n-                    if !self.need_remote_flush && tlb_prefer_flush_all {\n+                    if !self.flusher.need_remote_flush() && tlb_prefer_flush_all {\n                         // Only on single-CPU cases we can drop the page immediately before flushing.\n                         drop(page);\n                         continue;\n                     }\n-                    self.issue_tlb_flush(TlbFlushOp::Address(va), Some(page));\n+                    self.flusher\n+                        .issue_tlb_flush_with(TlbFlushOp::Address(va), page);\n                 }\n                 PageTableItem::NotMapped { .. } => {\n                     break;\n@@ -396,103 +342,79 @@ impl CursorMut<'_, '_> {\n             }\n         }\n \n-        if !self.need_remote_flush && tlb_prefer_flush_all {\n-            self.issue_tlb_flush(TlbFlushOp::All, None);\n+        if !self.flusher.need_remote_flush() && tlb_prefer_flush_all {\n+            self.flusher.issue_tlb_flush(TlbFlushOp::All);\n         }\n \n-        self.dispatch_tlb_flush();\n+        self.flusher.dispatch_tlb_flush();\n     }\n \n-    /// Change the mapping property starting from the current slot.\n+    /// Applies the operation to the next slot of mapping within the range.\n     ///\n-    /// This method will bring the cursor forward by `len` bytes in the virtual\n-    /// address space after the modification.\n+    /// The range to be found in is the current virtual address with the\n+    /// provided length.\n+    ///\n+    /// The function stops and yields the actually protected range if it has\n+    /// actually protected a page, no matter if the following pages are also\n+    /// required to be protected.\n+    ///\n+    /// It also makes the cursor moves forward to the next page after the\n+    /// protected one. If no mapped pages exist in the following range, the\n+    /// cursor will stop at the end of the range and return [`None`].\n     ///\n-    /// The way to change the property is specified by the closure `op`.\n+    /// Note that it will **NOT** flush the TLB after the operation. Please\n+    /// make the decision yourself on when and how to flush the TLB using\n+    /// [`Self::flusher`].\n     ///\n     /// # Panics\n     ///\n-    /// This method will panic if `len` is not page-aligned.\n-    pub fn protect(&mut self, len: usize, mut op: impl FnMut(&mut PageProperty)) {\n-        assert!(len % super::PAGE_SIZE == 0);\n-        let end = self.virt_addr() + len;\n-        let tlb_prefer_flush_all = len > TLB_FLUSH_ALL_THRESHOLD * PAGE_SIZE;\n-\n+    /// This function will panic if:\n+    ///  - the range to be protected is out of the range where the cursor\n+    ///    is required to operate;\n+    ///  - the specified virtual address range only covers a part of a page.\n+    pub fn protect_next(\n+        &mut self,\n+        len: usize,\n+        mut op: impl FnMut(&mut PageProperty),\n+    ) -> Option<Range<Vaddr>> {\n         // SAFETY: It is safe to protect memory in the userspace.\n-        while let Some(range) =\n-            unsafe { self.pt_cursor.protect_next(end - self.virt_addr(), &mut op) }\n-        {\n-            if !tlb_prefer_flush_all {\n-                self.issue_tlb_flush(TlbFlushOp::Range(range), None);\n-            }\n-        }\n-\n-        if tlb_prefer_flush_all {\n-            self.issue_tlb_flush(TlbFlushOp::All, None);\n-        }\n-        self.dispatch_tlb_flush();\n+        unsafe { self.pt_cursor.protect_next(len, &mut op) }\n     }\n \n-    fn issue_tlb_flush(&self, op: TlbFlushOp, drop_after_flush: Option<DynPage>) {\n-        let request = TlbFlushRequest {\n-            op,\n-            drop_after_flush,\n-        };\n-\n-        // Fast path for single CPU cases.\n-        if !self.need_remote_flush {\n-            if self.need_self_flush {\n-                request.do_flush();\n-            }\n-            return;\n-        }\n-\n-        // Slow path for multi-CPU cases.\n-        for cpu in self.activated_cpus.iter() {\n-            let mut queue = TLB_FLUSH_REQUESTS.get_on_cpu(cpu).lock();\n-            queue.push_back(request.clone());\n-        }\n-    }\n-\n-    fn dispatch_tlb_flush(&self) {\n-        if !self.need_remote_flush {\n-            return;\n-        }\n-\n-        fn do_remote_flush() {\n-            let preempt_guard = disable_preempt();\n-            let mut requests = TLB_FLUSH_REQUESTS\n-                .get_on_cpu(preempt_guard.current_cpu())\n-                .lock();\n-            if requests.len() > TLB_FLUSH_ALL_THRESHOLD {\n-                // TODO: in most cases, we need only to flush all the TLB entries\n-                // for an ASID if it is enabled.\n-                crate::arch::mm::tlb_flush_all_excluding_global();\n-                requests.clear();\n-            } else {\n-                while let Some(request) = requests.pop_front() {\n-                    request.do_flush();\n-                    if matches!(request.op, TlbFlushOp::All) {\n-                        requests.clear();\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        crate::smp::inter_processor_call(&self.activated_cpus.clone(), do_remote_flush);\n+    /// Copies the mapping from the given cursor to the current cursor.\n+    ///\n+    /// All the mappings in the current cursor's range must be empty. The\n+    /// function allows the source cursor to operate on the mapping before\n+    /// the copy happens. So it is equivalent to protect then duplicate.\n+    /// Only the mapping is copied, the mapped pages are not copied.\n+    ///\n+    /// After the operation, both cursors will advance by the specified length.\n+    ///\n+    /// Note that it will **NOT** flush the TLB after the operation. Please\n+    /// make the decision yourself on when and how to flush the TLB using\n+    /// the source's [`CursorMut::flusher`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if:\n+    ///  - either one of the range to be copied is out of the range where any\n+    ///    of the cursor is required to operate;\n+    ///  - either one of the specified virtual address ranges only covers a\n+    ///    part of a page.\n+    ///  - the current cursor's range contains mapped pages.\n+    pub fn copy_from(\n+        &mut self,\n+        src: &mut Self,\n+        len: usize,\n+        op: &mut impl FnMut(&mut PageProperty),\n+    ) {\n+        // SAFETY: Operations on user memory spaces are safe if it doesn't\n+        // involve dropping any pages.\n+        unsafe { self.pt_cursor.copy_from(&mut src.pt_cursor, len, op) }\n     }\n }\n \n-/// The threshold used to determine whether we need to flush all TLB entries\n-/// when handling a bunch of TLB flush requests. If the number of requests\n-/// exceeds this threshold, the overhead incurred by flushing pages\n-/// individually would surpass the overhead of flushing all entries at once.\n-const TLB_FLUSH_ALL_THRESHOLD: usize = 32;\n-\n cpu_local! {\n-    /// The queue of pending requests.\n-    static TLB_FLUSH_REQUESTS: SpinLock<VecDeque<TlbFlushRequest>> = SpinLock::new(VecDeque::new());\n     /// The `Arc` pointer to the activated VM space on this CPU. If the pointer\n     /// is NULL, it means that the activated page table is merely the kernel\n     /// page table.\n@@ -502,38 +424,6 @@ cpu_local! {\n     static ACTIVATED_VM_SPACE: AtomicPtr<VmSpace> = AtomicPtr::new(core::ptr::null_mut());\n }\n \n-#[derive(Debug, Clone)]\n-struct TlbFlushRequest {\n-    op: TlbFlushOp,\n-    // If we need to remove a mapped page from the page table, we can only\n-    // recycle the page after all the relevant TLB entries in all CPUs are\n-    // flushed. Otherwise if the page is recycled for other purposes, the user\n-    // space program can still access the page through the TLB entries.\n-    #[allow(dead_code)]\n-    drop_after_flush: Option<DynPage>,\n-}\n-\n-#[derive(Debug, Clone)]\n-enum TlbFlushOp {\n-    All,\n-    Address(Vaddr),\n-    Range(Range<Vaddr>),\n-}\n-\n-impl TlbFlushRequest {\n-    /// Perform the TLB flush operation on the current CPU.\n-    fn do_flush(&self) {\n-        use crate::arch::mm::{\n-            tlb_flush_addr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n-        };\n-        match &self.op {\n-            TlbFlushOp::All => tlb_flush_all_excluding_global(),\n-            TlbFlushOp::Address(addr) => tlb_flush_addr(*addr),\n-            TlbFlushOp::Range(range) => tlb_flush_addr_range(range),\n-        }\n-    }\n-}\n-\n /// The result of a query over the VM space.\n #[derive(Debug)]\n pub enum VmItem {\n", "test_patch": "diff --git a/ostd/src/mm/page_table/test.rs b/ostd/src/mm/page_table/test.rs\nindex 834289a910..6acb5bc22b 100644\n--- a/ostd/src/mm/page_table/test.rs\n+++ b/ostd/src/mm/page_table/test.rs\n@@ -81,6 +81,10 @@ fn test_untracked_map_unmap() {\n \n #[ktest]\n fn test_user_copy_on_write() {\n+    fn prot_op(prop: &mut PageProperty) {\n+        prop.flags -= PageFlags::W;\n+    }\n+\n     let pt = PageTable::<UserMode>::empty();\n     let from = PAGE_SIZE..PAGE_SIZE * 2;\n     let page = allocator::alloc_single(FrameMeta::default()).unwrap();\n@@ -96,7 +100,14 @@ fn test_user_copy_on_write() {\n     unsafe { pt.cursor_mut(&from).unwrap().map(page.clone().into(), prop) };\n     assert_eq!(pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n \n-    let child_pt = pt.clone_with(pt.cursor_mut(&(0..MAX_USERSPACE_VADDR)).unwrap());\n+    let child_pt = {\n+        let child_pt = PageTable::<UserMode>::empty();\n+        let range = 0..MAX_USERSPACE_VADDR;\n+        let mut child_cursor = child_pt.cursor_mut(&range).unwrap();\n+        let mut parent_cursor = pt.cursor_mut(&range).unwrap();\n+        unsafe { child_cursor.copy_from(&mut parent_cursor, range.len(), &mut prot_op) };\n+        child_pt\n+    };\n     assert_eq!(pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n     assert_eq!(child_pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n     assert!(matches!(\n@@ -106,7 +117,14 @@ fn test_user_copy_on_write() {\n     assert!(pt.query(from.start + 10).is_none());\n     assert_eq!(child_pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n \n-    let sibling_pt = pt.clone_with(pt.cursor_mut(&(0..MAX_USERSPACE_VADDR)).unwrap());\n+    let sibling_pt = {\n+        let sibling_pt = PageTable::<UserMode>::empty();\n+        let range = 0..MAX_USERSPACE_VADDR;\n+        let mut sibling_cursor = sibling_pt.cursor_mut(&range).unwrap();\n+        let mut parent_cursor = pt.cursor_mut(&range).unwrap();\n+        unsafe { sibling_cursor.copy_from(&mut parent_cursor, range.len(), &mut prot_op) };\n+        sibling_pt\n+    };\n     assert!(sibling_pt.query(from.start + 10).is_none());\n     assert_eq!(child_pt.query(from.start + 10).unwrap().0, start_paddr + 10);\n     drop(pt);\n", "problem_statement": "[RFC] Safety model about the page tables\n# Background\r\n\r\nThis issue discusses the internal APIs of the page table. More specifically, the following two sets of APIs:\r\n - The APIs provided by `RawPageTableNode`/`PageTableNode`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/node.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/node.rs)\r\n - The APIs provided by `PageTable`/`Cursor`/`CursorMut`\r\n   - Files: [`framework/aster-frame/src/mm/page_table/mod.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/mod.rs) and [`framework/aster-frame/src/mm/page_table/cursor.rs`](https://github.com/asterinas/asterinas/blob/main/framework/aster-frame/src/mm/page_table/cursor.rs)\r\n\r\nThe focus is on what kind of safety guarantees they can provide.\r\n\r\nCurrently, this question is not clearly answered. For example, consider the following API in `PageTableNode`:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L383-L388\r\n\r\nThis method is marked as unsafe because it can create arbitrary mappings. This is not a valid reason to mark it as unsafe, as the activation of a `RawPageTableNode` is already marked as unsafe, as shown in the following code snippet:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L112-L124\r\n\r\n_If_ the above reason is considered valid, then _every_ modification method of `PageTableNode` must also be marked as unsafe. This is because a `PageTableNode` does not know its exact position in the page table, so it can be at a critical position (e.g. the kernel text). In such cases, its modification will never be safe in the sense of mapping safety.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L372-L373\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L356-L362\r\n\r\nFortunately, the unsafety of the activation method `RawPageTableNode::activate` should have already captured the mapping safety, so I argue that all other modification methods like `PageTableNode::set_child_untracked` mentioned above should not consider the mapping safety again. However, it should consider the safety of the page tables themselves.\r\n\r\nBut the safety of the page tables themselves still involves a lot of things, like the following:\r\n - **Property 1**: If any PTE points to another page table, it must point to a valid page table.\r\n - **Property 2**: If any PTE points to a physical page, it can point to either a tracked frame or an untracked region of memory.\r\n - **Property 3**: If any PTE points to a physical page and the current page table node can only represent tracked mappings, the PTE must point to a tracked frame.\r\n - **Property 4**: If any PTE points to a physical page and the current page table node can only represent untracked mappings, the PTE must point to an untracked region of memory.\r\n - **Property 5**: If any PTE points to another page table, it must point to a page table that is on the next page level. If the next page level does not exist, the PTE cannot point to a page table.\r\n\r\nThe current design does indeed guarantee **Property 1** and **Property 2**, but the APIs need some revision to make them truly safe. However, it runs into difficulties when dropping the page tables, because the page table nodes do not know whether PTEs point to tracked frames or untracked regions of memory. The API change and the difficulties are described below as **Solution 1**.\r\n\r\nTo address the above difficulties, I think that it is possible to additionally guarantee **Property 3** and **Property 4** through safe APIs of page table nodes. I call this **Solution 2** below.\r\n\r\nI don't think that **Property 5** needs to be guaranteed by `PageTableNode`. The reason is that it can be trivially guaranteed by the page table cursors. The page table cursors maintain a fixed-length array, where each slot can have a page table node at a certain level. It is clear enough, so there is little benefit to enforce these guarantees to the page table nodes.\r\n\r\n# Solution 0\r\n\r\nDo nothing.\r\n\r\n**Pros:**\r\n - No more work to do!\r\n\r\n**Cons:**\r\n - The current APIs are not as good as I would like them to be, and I think they are hard to maintain.\r\n\r\n# Solution 1\r\n\r\nThe current design guarantees **Property 1** and **Property 2**. However, most of the `PageTableNode` APIs cannot be considered safe because they rely on the correctness of the input argument `in_untracked_range` to be memory safe:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L267-L268\r\n\r\nFor example, if someone passes `in_untracked_range = false` to `PageTableNode::child`, but the corresponding PTE actually points to an untracked memory range, then the untracked memory range will be cast to an tracked frame. This will cause serve memory safety issues.\r\n\r\nTo solve this problem, it is possible to create a new type called `MaybeTrackedPage`, which can be converted into a tracked frame (via the unsafe `assume_tracked` method) or an untracked region of memory (via the `assume_untracked` method) by the user:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L253-L268\r\n\r\nThen the `PageTableNode::child` method can be made to return a wrapped type of `MaybeTrackedPage` (the `Child` wrapper handles cases where the PTE is empty or points to another page table):\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L447-L448\r\n\r\nI think this solution works well, _except_ for the annoying `Drop` implementation. Since the page table node has no way of knowing whether PTEs point to tracked frames or untracked regions of memory, it won't know how to drop them if such PTEs are encountered in the `Drop` method. So far it is assumed that only tracked frames can be dropped, as shown in the following code snippet:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L536-L540\r\n\r\nBut this assumption can easily be wrong. For example, a page table containing untracked regions of memory can be dropped if a huge page overwrites the PTE on a page table:\r\n\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/node.rs#L474-L476\r\n\r\nIt is possible to work around this problem by adding methods such as `drop_deep_untracked` and `drop_deep_tracked`, which recursively drop all descendants of the current page table node, assuming they contain only tracked frames or untracked regions of memory. Then the `drop` method should not see any PTEs pointing to physical pages.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/7f45a1bb29f5bf6d6ddb0d12fdb48dc1ca15852c/framework/aster-frame/src/mm/page_table/node.rs#L303-L325\r\n\r\nHowever, this solution is not very elegant.\r\n\r\n**Pro:**\r\n - It was implemented in #918, see commits \"Implement `MaybeTracked{,Page,PageRef}`\" and \"Clarify the safety model in `PageTableNode`\".\r\n\r\n**Cons:**\r\n - The dropping implementation is not ideal.\r\n - The cursor (and its users) must be careful about whether the PTE represents tracked frames or untracked regions of memory.\r\n\r\n# Solution 2\r\n\r\nOne possible solution to solve the problem above is to make page table nodes aware whether it contains tracked frames or untracked regions of memory.\r\n\r\nI think it is reasonable to make an additional assumption: a page table node cannot _directly_ contain both PTEs to tracked frames and PTEs to regions of memory. This limits the power of the page table a bit, but is still reasonable. On x86-64, each page table node representing a 1GiB mapping can have either tracked frames or untracked regions of memory, but not both, as 2MiB huge pages, which still seems flexible to me.\r\n\r\nThis information can be recorded in the page metadata, marking each page table as `Tracked` (diretly containing PTEs only to tracked frames), `Untracked` (directly contains PTEs only to untracked regions of memory), or `None` (directly containing no PTEs to physical pages). Then when dropping a page table, it is clear the PTEs can be dropped without problems.\r\n\r\nA simple way to enforce the page metadata is to add assertions at the beginning of methods like `PageTableNode::set_child_frame` and `PageTableNode::set_child_untracked`. Compilers may be smart to check once and update a number of PTEs.\r\n\r\nAlternatively, I think a better solution is to make page table cursors that operate on tracked frames and untracked regions of memory _different modes_ (like the existing `UserMode` and `KernelMode`). This way, whether a cursor operates on tracked frames or untracked regions can be determined at compile time, instead of at runtime as it is now:\r\nhttps://github.com/asterinas/asterinas/blob/c6aa9f9ee860bbdcb8bb3444b630aff9f0ac14af/framework/aster-frame/src/mm/page_table/cursor.rs#L278-L282\r\n\r\nThen the page table cursor and page table node implementation should be much clearer:\r\n```rust\r\nimpl TrackedNode {\r\n    fn set_child(&mut self, idx: usize, frame: Frame);\r\n}\r\n\r\nimpl UntrackedNode {\r\n    fn set_child(&mut self, idx: usize, paddr: Paddr);\r\n}\r\n```\r\n```rust\r\n// `TrackedMode` associates with `TrackedNode`\r\nimpl<M: TrackedMode> Cursor<M> {\r\n    fn map(&mut self, frame: Frame, prop: PageProperty);\r\n}\r\n\r\n// `UntrackedMode` associates with `UntrackedNode`\r\nimpl<M: UntrackedMode> Cursor {\r\n    fn map(&mut self, pa: &Range<Paddr>, prop: PageProperty);\r\n}\r\n```\r\n\r\n**Pros:**\r\n - Improves clarity of cursor and node implementation.\r\n - Addresses the above problem.\r\n\r\n**Cons:**\r\n - Cursor implementation requires more refactoring.\r\n - Cursor may not be as flexible as it is now, but are there use cases where accesses to tracked frames and untracked regions of memory have be mixed in one cursor?\r\n\r\ncc @junyang-zh \n", "hints_text": "I've already checked out your PR #918 addressing issues raised in this RFC, and find it convincing.\r\n\r\nTo sum up, the current inner API designs do have the 2 following major weaknesses:\r\n\r\n - The \"tracked\" and \"untracked\" ranges are all managed by the page table, but the node is agnostic to it to some extent;\r\n - The safety guarantee are not perfectly modeled.\r\n\r\nI need some time carefully think about the solution. And thanks for proposing such a fix quickly.", "created_at": "2024-09-23T14:17:42Z", "version": "0.8"}, {"repo": "asterinas/asterinas", "pull_number": 1362, "instance_id": "asterinas__asterinas-1362", "issue_numbers": ["964"], "base_commit": "f7932595125a0bba8230b5f8d3b110c687d6f3b2", "patch": "diff --git a/Makefile b/Makefile\nindex 55e0f3885f..b820be36b7 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -1,13 +1,14 @@\n # SPDX-License-Identifier: MPL-2.0\n \n-# Global options.\n+# =========================== Makefile options. ===============================\n+\n+# Global build options.\n ARCH ?= x86_64\n BENCHMARK ?= none\n BOOT_METHOD ?= grub-rescue-iso\n BOOT_PROTOCOL ?= multiboot2\n BUILD_SYSCALL_TEST ?= 0\n ENABLE_KVM ?= 1\n-GDB_TCP_PORT ?= 1234\n INTEL_TDX ?= 0\n MEM ?= 8G\n RELEASE ?= 0\n@@ -16,7 +17,14 @@ LOG_LEVEL ?= error\n SCHEME ?= \"\"\n SMP ?= 1\n OSTD_TASK_STACK_SIZE_IN_PAGES ?= 64\n-# End of global options.\n+# End of global build options.\n+\n+# GDB debugging and profiling options.\n+GDB_TCP_PORT ?= 1234\n+GDB_PROFILE_FORMAT ?= flame-graph\n+GDB_PROFILE_COUNT ?= 200\n+GDB_PROFILE_INTERVAL ?= 0.1\n+# End of GDB options.\n \n # The Makefile provides a way to run arbitrary tests in the kernel\n # mode using the kernel command line.\n@@ -26,6 +34,8 @@ EXTRA_BLOCKLISTS_DIRS ?= \"\"\n SYSCALL_TEST_DIR ?= /tmp\n # End of auto test features.\n \n+# ========================= End of Makefile options. ==========================\n+\n CARGO_OSDK := ~/.cargo/bin/cargo-osdk\n \n CARGO_OSDK_ARGS := --target-arch=$(ARCH) --kcmd-args=\"ostd.log_level=$(LOG_LEVEL)\"\n@@ -189,11 +199,20 @@ endif\n \n .PHONY: gdb_server\n gdb_server: initramfs $(CARGO_OSDK)\n-\t@cargo osdk run $(CARGO_OSDK_ARGS) -G --vsc --gdb-server-addr :$(GDB_TCP_PORT)\n+\t@cargo osdk run $(CARGO_OSDK_ARGS) --gdb-server wait-client,vscode,addr=:$(GDB_TCP_PORT)\n \n .PHONY: gdb_client\n gdb_client: $(CARGO_OSDK)\n-\t@cd kernel && cargo osdk debug $(CARGO_OSDK_ARGS) --remote :$(GDB_TCP_PORT)\n+\t@cargo osdk debug $(CARGO_OSDK_ARGS) --remote :$(GDB_TCP_PORT)\n+\n+.PHONY: profile_server\n+profile_server: initramfs $(CARGO_OSDK)\n+\t@cargo osdk run $(CARGO_OSDK_ARGS) --gdb-server addr=:$(GDB_TCP_PORT)\n+\n+.PHONY: profile_client\n+profile_client: $(CARGO_OSDK)\n+\t@cargo osdk profile $(CARGO_OSDK_ARGS) --remote :$(GDB_TCP_PORT) \\\n+\t\t--samples $(GDB_PROFILE_COUNT) --interval $(GDB_PROFILE_INTERVAL) --format $(GDB_PROFILE_FORMAT)\n \n .PHONY: test\n test:\ndiff --git a/docs/src/osdk/reference/commands/README.md b/docs/src/osdk/reference/commands/README.md\nindex a2c6a915ce..fc8abb4c8e 100644\n--- a/docs/src/osdk/reference/commands/README.md\n+++ b/docs/src/osdk/reference/commands/README.md\n@@ -11,6 +11,7 @@ Currently, OSDK supports the following subcommands:\n - **run**: Run the kernel with a VMM\n - **test**: Execute kernel mode unit test by starting a VMM\n - **debug**: Debug a remote target via GDB\n+- **profile**: Profile a remote GDB debug target to collect stack traces\n - **check**: Analyze the current package and report errors\n - **clippy**: Check the current package and catch common mistakes\n \ndiff --git a/docs/src/osdk/reference/commands/debug.md b/docs/src/osdk/reference/commands/debug.md\nindex d21a19b6de..5c79ad7eb5 100644\n--- a/docs/src/osdk/reference/commands/debug.md\n+++ b/docs/src/osdk/reference/commands/debug.md\n@@ -2,29 +2,39 @@\n \n ## Overview\n \n-`cargo osdk debug` is used to debug a remote target via GDB.\n-The usage is as follows:\n+`cargo osdk debug` is used to debug a remote target via GDB. You need to start\n+a running server to debug with. This is accomplished by the `run` subcommand\n+with `--gdb-server`. Then you can use the following command to attach to the\n+server and do debugging.\n \n ```bash\n cargo osdk debug [OPTIONS]\n ```\n \n+Note that when KVM is enabled, hardware-assisted break points (`hbreak`) are\n+needed instead of the normal break points (`break`/`b`) in GDB.\n+\n ## Options\n \n `--remote <REMOTE>`:\n-Specify the address of the remote target [default: .aster-gdb-socket].\n+Specify the address of the remote target [default: .osdk-gdb-socket].\n The address can be either a path for the UNIX domain socket\n or a TCP port on an IP address.\n \n ## Examples\n \n-- To debug a remote target via a\n-[QEMU GDB stub](https://www.qemu.org/docs/master/system/gdb.html),\n-    - connect to an unix socket, e.g., `./debug`;\n-    ```bash\n-    cargo osdk debug --remote ./debug\n-    ```\n-    - connect to a TCP port (`[IP]:PORT`), e.g., `localhost:1234`.\n-    ```bash\n-    cargo osdk debug --remote localhost:1234\n-    ```\n+To debug a remote target started with\n+[QEMU GDB stub](https://www.qemu.org/docs/master/system/gdb.html) or the `run`\n+subcommand, use the following commands.\n+\n+Connect to an unix socket, e.g., `./debug`:\n+\n+```bash\n+cargo osdk debug --remote ./debug\n+```\n+\n+Connect to a TCP port (`[IP]:PORT`), e.g., `localhost:1234`:\n+\n+```bash\n+cargo osdk debug --remote localhost:1234\n+```\ndiff --git a/docs/src/osdk/reference/commands/profile.md b/docs/src/osdk/reference/commands/profile.md\nnew file mode 100644\nindex 0000000000..c2ec6afbc1\n--- /dev/null\n+++ b/docs/src/osdk/reference/commands/profile.md\n@@ -0,0 +1,75 @@\n+# cargo osdk profile\n+\n+## Overview\n+\n+The profile command is used to collect stack traces when running the target\n+kernel in QEMU. It attaches to the GDB server initiated with the run subcommand\n+and collects the stack trace periodically. The collected information can be\n+used to directly generate a flame graph, or be stored for later analysis using\n+[the original flame graph tool](https://github.com/brendangregg/FlameGraph).\n+\n+## Options\n+\n+`--remote <REMOTE>`:\n+\n+Specify the address of the remote target.\n+By default this is `.osdk-gdb-socket`\n+\n+`--samples <SAMPLES>`:\n+\n+The number of samples to collect (default 200).\n+It is recommended to go beyond 100 for performance analysis.\n+\n+`--interval <INTERVAL>`:\n+\n+The interval between samples in seconds (default 0.1).\n+\n+`--parse <PATH>`:\n+\n+Parse a collected JSON profile file into other formats.\n+\n+`--format <FORMAT>`:\n+\n+Possible values:\n+    - `json`:   The parsed stack trace log from GDB in JSON.\n+    - `folded`: The folded stack trace for flame graph.\n+    - `flame-graph`: A SVG flame graph.\n+\n+If the user does not specify the format, it will be inferred from the\n+output file extension. If the output file does not have an extension,\n+the default format is flame graph.\n+\n+`--cpu-mask <CPU_MASK>`:\n+\n+The mask of the CPU to generate traces for in the output profile data\n+(default first 128 cores). This mask is presented as an integer.\n+\n+`--output <PATH>`:\n+\n+The path to the output profile data file.\n+\n+If the user does not specify the output path, it will be generated from\n+the crate name, current time stamp and the format.\n+\n+## Examples\n+\n+To profile a remote QEMU GDB server running some workload for flame graph, do:\n+\n+```bash\n+cargo osdk profile --remote :1234 \\\n+\t--samples 100 --interval 0.01\n+```\n+\n+If wanted a detailed analysis, do:\n+\n+```bash\n+cargo osdk profile --remote :1234 \\\n+\t--samples 100 --interval 0.01 --output trace.json\n+```\n+\n+When you get the above detailed analysis, you can also use the JSON file\n+to generate the folded format for flame graph.\n+\n+```bash\n+cargo osdk profile --parse trace.json --output trace.folded\n+```\ndiff --git a/docs/src/osdk/reference/commands/run.md b/docs/src/osdk/reference/commands/run.md\nindex 049ac5984a..7729adb3d4 100644\n--- a/docs/src/osdk/reference/commands/run.md\n+++ b/docs/src/osdk/reference/commands/run.md\n@@ -15,34 +15,34 @@ Most options are the same as those of `cargo osdk build`.\n Refer to the [documentation](build.md) of `cargo osdk build`\n for more details.\n \n-Options related with debugging:\n+Additionally, when running the kernel using QEMU, we can setup the QEMU as a\n+debug server using option `--gdb-server`. This option supports an additional\n+comma separated configuration list:\n \n-- `-G, --enable-gdb`: Enable QEMU GDB server for debugging.\n-- `--vsc`: Generate a '.vscode/launch.json' for debugging kernel with Visual Studio Code\n-(only works when QEMU GDB server is enabled, i.e., `--enable-gdb`).\n-Requires [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb).\n-- `--gdb-server-addr <ADDR>`: The network address on which the GDB server listens,\n-it can be either a path for the UNIX domain socket or a TCP port on an IP address.\n-[default: `.aster-gdb-socket`(a local UNIX socket)]\n+ - `addr=ADDR`: the network or unix socket address on which the GDB server listens\n+    (default: `.osdk-gdb-socket`, a local UNIX socket);\n+ - `wait-client`: let the GDB server wait for the GDB client before execution;\n+ - `vscode`: generate a '.vscode/launch.json' for debugging with Visual Studio Code\n+    (Requires [CodeLLDB](https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb)).\n \n See [Debug Command](debug.md) to interact with the GDB server in terminal.\n \n ## Examples\n \n-- Launch a debug server via QEMU with an unix socket stub, e.g. `.debug`:\n+Launch a debug server via QEMU with an unix socket stub, e.g. `.debug`:\n \n ```bash\n-cargo osdk run --enable-gdb --gdb-server-addr .debug\n+cargo osdk run --gdb-server addr=.debug\n ```\n \n-- Launch a debug server via QEMU with a TCP stub, e.g., `localhost:1234`:\n+Launch a debug server via QEMU with a TCP stub, e.g., `localhost:1234`:\n \n ```bash\n-cargo osdk run --enable-gdb --gdb-server-addr :1234\n+cargo osdk run --gdb-server addr=:1234\n ```\n \n-- Launch a debug server via QEMU and use VSCode to interact:\n+Launch a debug server via QEMU and use VSCode to interact with:\n \n ```bash\n-cargo osdk run --enable-gdb --vsc --gdb-server-addr :1234\n+cargo osdk run --gdb-server wait-client,vscode,addr=:1234\n ```\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\nindex 681d6b55b0..c50b84b429 100644\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -15,6 +15,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e89da841a80418a9b391ebaea17f5c112ffaaa96f621d2c285b5174da76b9011\"\n dependencies = [\n  \"cfg-if\",\n+ \"getrandom\",\n  \"once_cell\",\n  \"version_check\",\n  \"zerocopy\",\n@@ -35,6 +36,21 @@ version = \"0.2.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5c6cb57a04249c6480766f7f7cef5467412af1490f8d1e243141daddada3264f\"\n \n+[[package]]\n+name = \"android-tzdata\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0\"\n+\n+[[package]]\n+name = \"android_system_properties\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"anstream\"\n version = \"0.6.12\"\n@@ -83,6 +99,12 @@ dependencies = [\n  \"windows-sys\",\n ]\n \n+[[package]]\n+name = \"arrayvec\"\n+version = \"0.7.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50\"\n+\n [[package]]\n name = \"assert_cmd\"\n version = \"2.0.14\"\n@@ -98,12 +120,24 @@ dependencies = [\n  \"wait-timeout\",\n ]\n \n+[[package]]\n+name = \"autocfg\"\n+version = \"1.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0c4b4d0bd25bd0b74681c0ad21497610ce1b7c91b1022cd21c80c6fbdd9476b0\"\n+\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n+[[package]]\n+name = \"bitflags\"\n+version = \"2.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b048fb63fd8b5923fc5aa7b340d8e156aec7ec02f0c78fa8a6ddc2613f6f71de\"\n+\n [[package]]\n name = \"block-buffer\"\n version = \"0.10.4\"\n@@ -124,6 +158,12 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"bumpalo\"\n+version = \"3.16.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"79296716171880943b8470b5f8d03aa55eb2e645a4874bdbb28adb49162e012c\"\n+\n [[package]]\n name = \"bytemuck\"\n version = \"1.17.0\"\n@@ -149,9 +189,12 @@ name = \"cargo-osdk\"\n version = \"0.8.3\"\n dependencies = [\n  \"assert_cmd\",\n+ \"chrono\",\n  \"clap\",\n  \"env_logger\",\n  \"indexmap\",\n+ \"indicatif\",\n+ \"inferno\",\n  \"lazy_static\",\n  \"linux-bzimage-builder\",\n  \"log\",\n@@ -166,12 +209,35 @@ dependencies = [\n  \"toml\",\n ]\n \n+[[package]]\n+name = \"cc\"\n+version = \"1.1.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"07b1695e2c7e8fc85310cde85aeaab7e3097f593c91d209d3f9df76c928100f0\"\n+dependencies = [\n+ \"shlex\",\n+]\n+\n [[package]]\n name = \"cfg-if\"\n version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n+[[package]]\n+name = \"chrono\"\n+version = \"0.4.38\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a21f936df1771bf62b77f047b726c4625ff2e8aa607c01ec06e5a05bd8463401\"\n+dependencies = [\n+ \"android-tzdata\",\n+ \"iana-time-zone\",\n+ \"js-sys\",\n+ \"num-traits\",\n+ \"wasm-bindgen\",\n+ \"windows-targets\",\n+]\n+\n [[package]]\n name = \"clap\"\n version = \"4.5.1\"\n@@ -218,6 +284,25 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"acbf1af155f9b9ef647e42cdc158db4b64a1b61f743629225fde6f3e0be2a7c7\"\n \n+[[package]]\n+name = \"console\"\n+version = \"0.15.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0e1f83fc076bd6dd27517eacdf25fef6c4dfe5f1d7448bafaaf3a26f13b5e4eb\"\n+dependencies = [\n+ \"encode_unicode\",\n+ \"lazy_static\",\n+ \"libc\",\n+ \"unicode-width\",\n+ \"windows-sys\",\n+]\n+\n+[[package]]\n+name = \"core-foundation-sys\"\n+version = \"0.8.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b\"\n+\n [[package]]\n name = \"core2\"\n version = \"0.4.0\"\n@@ -245,6 +330,21 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"crossbeam-channel\"\n+version = \"0.5.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"33480d6946193aa8033910124896ca395333cae7e2d1113d1fef6c3272217df2\"\n+dependencies = [\n+ \"crossbeam-utils\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.8.20\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"22ec99545bb0ed0ea7bb9b8e1e9122ea386ff8a48c0922e43f36d45ab09e0e80\"\n+\n [[package]]\n name = \"crypto-common\"\n version = \"0.1.6\"\n@@ -261,6 +361,20 @@ version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7762d17f1241643615821a8455a0b2c3e803784b058693d990b11f2dce25a0ca\"\n \n+[[package]]\n+name = \"dashmap\"\n+version = \"6.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5041cc499144891f3790297212f32a74fb938e5136a14943f338ef9e0ae276cf\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"crossbeam-utils\",\n+ \"hashbrown\",\n+ \"lock_api\",\n+ \"once_cell\",\n+ \"parking_lot_core\",\n+]\n+\n [[package]]\n name = \"difflib\"\n version = \"0.4.0\"\n@@ -283,6 +397,12 @@ version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fea41bba32d969b513997752735605054bc0dfa92b4c56bf1189f2e174be7a10\"\n \n+[[package]]\n+name = \"encode_unicode\"\n+version = \"0.3.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a357d28ed41a50f9c765dbfe56cbc04a64e53e5fc58ba79fbc34c10ef3df831f\"\n+\n [[package]]\n name = \"env_filter\"\n version = \"0.1.0\"\n@@ -322,6 +442,17 @@ dependencies = [\n  \"version_check\",\n ]\n \n+[[package]]\n+name = \"getrandom\"\n+version = \"0.2.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c4567c8db10ae91089c99af84c68c38da3ec2f087c3f82960bcdbf3656b6f4d7\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"wasi\",\n+]\n+\n [[package]]\n name = \"hashbrown\"\n version = \"0.14.3\"\n@@ -338,12 +469,41 @@ version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8\"\n \n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fbf6a919d6cf397374f7dfeeea91d974c7c0a7221d0d0f4f20d859d329e53fcc\"\n+\n [[package]]\n name = \"humantime\"\n version = \"2.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a3a5bfb195931eeb336b2a7b4d761daec841b97f947d34394601737a7bba5e4\"\n \n+[[package]]\n+name = \"iana-time-zone\"\n+version = \"0.1.61\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"235e081f3925a06703c2d0117ea8b91f042756fd6e7a6e5d901e8ca1a996b220\"\n+dependencies = [\n+ \"android_system_properties\",\n+ \"core-foundation-sys\",\n+ \"iana-time-zone-haiku\",\n+ \"js-sys\",\n+ \"wasm-bindgen\",\n+ \"windows-core\",\n+]\n+\n+[[package]]\n+name = \"iana-time-zone-haiku\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f\"\n+dependencies = [\n+ \"cc\",\n+]\n+\n [[package]]\n name = \"indexmap\"\n version = \"2.2.3\"\n@@ -354,12 +514,77 @@ dependencies = [\n  \"hashbrown\",\n ]\n \n+[[package]]\n+name = \"indicatif\"\n+version = \"0.17.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"763a5a8f45087d6bcea4222e7b72c291a054edf80e4ef6efd2a4979878c7bea3\"\n+dependencies = [\n+ \"console\",\n+ \"instant\",\n+ \"number_prefix\",\n+ \"portable-atomic\",\n+ \"unicode-width\",\n+]\n+\n+[[package]]\n+name = \"inferno\"\n+version = \"0.11.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"232929e1d75fe899576a3d5c7416ad0d88dbfbb3c3d6aa00873a7408a50ddb88\"\n+dependencies = [\n+ \"ahash\",\n+ \"clap\",\n+ \"crossbeam-channel\",\n+ \"crossbeam-utils\",\n+ \"dashmap\",\n+ \"env_logger\",\n+ \"indexmap\",\n+ \"is-terminal\",\n+ \"itoa\",\n+ \"log\",\n+ \"num-format\",\n+ \"once_cell\",\n+ \"quick-xml\",\n+ \"rgb\",\n+ \"str_stack\",\n+]\n+\n+[[package]]\n+name = \"instant\"\n+version = \"0.1.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"is-terminal\"\n+version = \"0.4.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"261f68e344040fbd0edea105bef17c66edf46f984ddb1115b775ce31be948f4b\"\n+dependencies = [\n+ \"hermit-abi\",\n+ \"libc\",\n+ \"windows-sys\",\n+]\n+\n [[package]]\n name = \"itoa\"\n version = \"1.0.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b1a46d1a171d865aa5f83f92695765caa047a9b4cbae2cbf37dbd613a793fd4c\"\n \n+[[package]]\n+name = \"js-sys\"\n+version = \"0.3.70\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1868808506b929d7b0cfa8f75951347aa71bb21144b7791bae35d9bccfcfe37a\"\n+dependencies = [\n+ \"wasm-bindgen\",\n+]\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\"\n@@ -368,9 +593,9 @@ checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.153\"\n+version = \"0.2.159\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9c198f91728a82281a64e1f4f9eeb25d82cb32a5de251c6bd1b5154d63a8e7bd\"\n+checksum = \"561d97a539a36e26a9a5fad1ea11a3039a67714694aaa379433e580854bc3dc5\"\n \n [[package]]\n name = \"libflate\"\n@@ -400,13 +625,23 @@ dependencies = [\n name = \"linux-bzimage-builder\"\n version = \"0.2.0\"\n dependencies = [\n- \"bitflags\",\n+ \"bitflags 1.3.2\",\n  \"bytemuck\",\n  \"libflate\",\n  \"serde\",\n  \"xmas-elf\",\n ]\n \n+[[package]]\n+name = \"lock_api\"\n+version = \"0.4.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"07af8b9cdd281b7915f413fa73f29ebd5d55d0d3f0155584dade1ff18cea1b17\"\n+dependencies = [\n+ \"autocfg\",\n+ \"scopeguard\",\n+]\n+\n [[package]]\n name = \"log\"\n version = \"0.4.20\"\n@@ -419,12 +654,56 @@ version = \"2.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149\"\n \n+[[package]]\n+name = \"num-format\"\n+version = \"0.4.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a652d9771a63711fd3c3deb670acfbe5c30a4072e664d7a3bf5a9e1056ac72c3\"\n+dependencies = [\n+ \"arrayvec\",\n+ \"itoa\",\n+]\n+\n+[[package]]\n+name = \"num-traits\"\n+version = \"0.2.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841\"\n+dependencies = [\n+ \"autocfg\",\n+]\n+\n+[[package]]\n+name = \"number_prefix\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"830b246a0e5f20af87141b25c173cd1b609bd7779a4617d6ec582abaf90870f3\"\n+\n [[package]]\n name = \"once_cell\"\n version = \"1.19.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3fdb12b2476b595f9358c5161aa467c2438859caa136dec86c26fdd2efe17b92\"\n \n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.9.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1e401f977ab385c9e4e3ab30627d6f26d00e2c73eef317493c4ec6d468726cf8\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"smallvec\",\n+ \"windows-targets\",\n+]\n+\n+[[package]]\n+name = \"portable-atomic\"\n+version = \"1.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d30538d42559de6b034bc76fd6dd4c38961b1ee5c6c56e3808c50128fdbc22ce\"\n+\n [[package]]\n name = \"predicates\"\n version = \"3.1.0\"\n@@ -461,6 +740,15 @@ dependencies = [\n  \"unicode-ident\",\n ]\n \n+[[package]]\n+name = \"quick-xml\"\n+version = \"0.26.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7f50b1c63b38611e7d4d7f68b82d3ad0cc71a2ad2e7f61fc10f1328d917c93cd\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n [[package]]\n name = \"quote\"\n version = \"1.0.35\"\n@@ -470,6 +758,15 @@ dependencies = [\n  \"proc-macro2\",\n ]\n \n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.5.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"355ae415ccd3a04315d3f8246e86d67689ea74d88d915576e1589a351062a13b\"\n+dependencies = [\n+ \"bitflags 2.6.0\",\n+]\n+\n [[package]]\n name = \"regex\"\n version = \"1.10.4\"\n@@ -508,6 +805,15 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"rgb\"\n+version = \"0.8.50\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"57397d16646700483b67d2dd6511d79318f9d057fdbd21a4066aeac8b41d310a\"\n+dependencies = [\n+ \"bytemuck\",\n+]\n+\n [[package]]\n name = \"rle-decode-fast\"\n version = \"1.0.3\"\n@@ -520,6 +826,12 @@ version = \"1.0.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e86697c916019a8588c99b5fac3cead74ec0b4b819707a682fd4d23fa0ce1ba1\"\n \n+[[package]]\n+name = \"scopeguard\"\n+version = \"1.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49\"\n+\n [[package]]\n name = \"serde\"\n version = \"1.0.197\"\n@@ -577,6 +889,18 @@ version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64\"\n \n+[[package]]\n+name = \"smallvec\"\n+version = \"1.13.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67\"\n+\n+[[package]]\n+name = \"str_stack\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9091b6114800a5f2141aee1d1b9d6ca3592ac062dc5decb3764ec5895a47b4eb\"\n+\n [[package]]\n name = \"strsim\"\n version = \"0.11.0\"\n@@ -647,6 +971,12 @@ version = \"1.0.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3354b9ac3fae1ff6755cb6db53683adb661634f67557942dea4facebec0fee4b\"\n \n+[[package]]\n+name = \"unicode-width\"\n+version = \"0.1.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7dd6e30e90baa6f72411720665d41d89b9a3d039dc45b8faea1ddd07f617f6af\"\n+\n [[package]]\n name = \"utf8parse\"\n version = \"0.2.1\"\n@@ -668,6 +998,76 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"wasi\"\n+version = \"0.11.0+wasi-snapshot-preview1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9c8d87e72b64a3b4db28d11ce29237c246188f4f51057d65a7eab63b7987e423\"\n+\n+[[package]]\n+name = \"wasm-bindgen\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a82edfc16a6c469f5f44dc7b571814045d60404b55a0ee849f9bcfa2e63dd9b5\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"once_cell\",\n+ \"wasm-bindgen-macro\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-backend\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9de396da306523044d3302746f1208fa71d7532227f15e347e2d93e4145dd77b\"\n+dependencies = [\n+ \"bumpalo\",\n+ \"log\",\n+ \"once_cell\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"wasm-bindgen-shared\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-macro\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"585c4c91a46b072c92e908d99cb1dcdf95c5218eeb6f3bf1efa991ee7a68cccf\"\n+dependencies = [\n+ \"quote\",\n+ \"wasm-bindgen-macro-support\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-macro-support\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"afc340c74d9005395cf9dd098506f7f44e38f2b4a21c6aaacf9a105ea5e1e836\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"wasm-bindgen-backend\",\n+ \"wasm-bindgen-shared\",\n+]\n+\n+[[package]]\n+name = \"wasm-bindgen-shared\"\n+version = \"0.2.93\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c62a0a307cb4a311d3a07867860911ca130c3494e8c2719593806c08bc5d0484\"\n+\n+[[package]]\n+name = \"windows-core\"\n+version = \"0.52.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"33ab640c8d7e35bf8ba19b884ba838ceb4fba93a4e8c65a9059d08afcfc683d9\"\n+dependencies = [\n+ \"windows-targets\",\n+]\n+\n [[package]]\n name = \"windows-sys\"\n version = \"0.52.0\"\ndiff --git a/osdk/Cargo.toml b/osdk/Cargo.toml\nindex 5001dabcee..2b00eb81aa 100644\n--- a/osdk/Cargo.toml\n+++ b/osdk/Cargo.toml\n@@ -19,8 +19,11 @@ version = \"0.2.0\"\n \n [dependencies]\n clap = { version = \"4.4.17\", features = [\"cargo\", \"derive\"] }\n+chrono = \"0.4.38\"\n env_logger = \"0.11.0\"\n+inferno = \"0.11.21\"\n indexmap = \"2.2.1\"\n+indicatif = \"0.17.8\" # For a commandline progress bar\n lazy_static = \"1.4.0\"\n log = \"0.4.20\"\n quote = \"1.0.35\"\ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\nindex ba052e3621..0692a1a6da 100644\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -2,13 +2,13 @@\n \n use std::path::PathBuf;\n \n-use clap::{crate_version, Args, Parser};\n+use clap::{crate_version, Args, Parser, ValueEnum};\n \n use crate::{\n     arch::Arch,\n     commands::{\n         execute_build_command, execute_debug_command, execute_forwarded_command,\n-        execute_new_command, execute_run_command, execute_test_command,\n+        execute_new_command, execute_profile_command, execute_run_command, execute_test_command,\n     },\n     config::{\n         manifest::{ProjectType, TomlManifest},\n@@ -37,7 +37,7 @@ pub fn main() {\n         OsdkSubcommand::Run(run_args) => {\n             execute_run_command(\n                 &load_config(&run_args.common_args),\n-                &run_args.gdb_server_args,\n+                run_args.gdb_server.as_deref(),\n             );\n         }\n         OsdkSubcommand::Debug(debug_args) => {\n@@ -46,6 +46,12 @@ pub fn main() {\n                 debug_args,\n             );\n         }\n+        OsdkSubcommand::Profile(profile_args) => {\n+            execute_profile_command(\n+                &load_config(&profile_args.common_args).run.build.profile,\n+                profile_args,\n+            );\n+        }\n         OsdkSubcommand::Test(test_args) => {\n             execute_test_command(&load_config(&test_args.common_args), test_args);\n         }\n@@ -79,6 +85,8 @@ pub enum OsdkSubcommand {\n     Run(RunArgs),\n     #[command(about = \"Debug a remote target via GDB\")]\n     Debug(DebugArgs),\n+    #[command(about = \"Profile a remote GDB debug target to collect stack traces for flame graph\")]\n+    Profile(ProfileArgs),\n     #[command(about = \"Execute kernel mode unit test by starting a VMM\")]\n     Test(TestArgs),\n     #[command(about = \"Check a local package and all of its dependencies for errors\")]\n@@ -160,49 +168,150 @@ pub struct BuildArgs {\n \n #[derive(Debug, Parser)]\n pub struct RunArgs {\n+    #[arg(\n+        long = \"gdb-server\",\n+        help = \"Enable the QEMU GDB server for debugging\\n\\\n+                This option supports an additional comma separated configuration list:\\n\\t \\\n+                    addr=ADDR:   the network or unix socket address on which the GDB server listens, \\\n+                                 `.osdk-gdb-socket` by default;\\n\\t \\\n+                    wait-client: let the GDB server wait for the GDB client before execution;\\n\\t \\\n+                    vscode:      generate a '.vscode/launch.json' for debugging with Visual Studio Code.\",\n+        value_name = \"[addr=ADDR][,wait-client][,vscode]\",\n+        default_missing_value = \"\"\n+    )]\n+    pub gdb_server: Option<String>,\n     #[command(flatten)]\n-    pub gdb_server_args: GdbServerArgs,\n+    pub common_args: CommonArgs,\n+}\n+\n+#[derive(Debug, Parser)]\n+pub struct DebugArgs {\n+    #[arg(\n+        long,\n+        help = \"Specify the address of the remote target\",\n+        default_value = \".osdk-gdb-socket\"\n+    )]\n+    pub remote: String,\n     #[command(flatten)]\n     pub common_args: CommonArgs,\n }\n \n-#[derive(Debug, Args, Clone, Default)]\n-pub struct GdbServerArgs {\n-    /// Whether to enable QEMU GDB server for debugging\n+#[derive(Debug, Parser)]\n+pub struct ProfileArgs {\n     #[arg(\n-        long = \"enable-gdb\",\n-        short = 'G',\n-        help = \"Enable QEMU GDB server for debugging\",\n-        default_value_t\n+        long,\n+        help = \"Specify the address of the remote target\",\n+        default_value = \".osdk-gdb-socket\"\n     )]\n-    pub is_gdb_enabled: bool,\n+    pub remote: String,\n+    #[arg(long, help = \"The number of samples to collect\", default_value = \"200\")]\n+    pub samples: usize,\n     #[arg(\n-        long = \"vsc\",\n-        help = \"Generate a '.vscode/launch.json' for debugging with Visual Studio Code \\\n-                (only works when '--enable-gdb' is enabled)\",\n-        default_value_t\n+        long,\n+        help = \"The interval between samples in seconds\",\n+        default_value = \"0.1\"\n     )]\n-    pub vsc_launch_file: bool,\n+    pub interval: f64,\n     #[arg(\n-        long = \"gdb-server-addr\",\n-        help = \"The network address on which the GDB server listens, \\\n-        it can be either a path for the UNIX domain socket or a TCP port on an IP address.\",\n-        value_name = \"ADDR\",\n-        default_value = \".aster-gdb-socket\"\n+        long,\n+        help = \"Parse a collected JSON profile file into other formats\",\n+        value_name = \"PATH\",\n+        conflicts_with = \"samples\",\n+        conflicts_with = \"interval\"\n     )]\n-    pub gdb_server_addr: String,\n+    pub parse: Option<PathBuf>,\n+    #[command(flatten)]\n+    pub out_args: DebugProfileOutArgs,\n+    #[command(flatten)]\n+    pub common_args: CommonArgs,\n+}\n+\n+#[derive(Clone, Copy, Debug, ValueEnum)]\n+pub enum ProfileFormat {\n+    /// The raw stack trace log parsed from GDB in JSON\n+    Json,\n+    /// The folded stack trace for generating a flame graph later using\n+    /// [the original tool](https://github.com/brendangregg/FlameGraph)\n+    Folded,\n+    /// A SVG flame graph\n+    FlameGraph,\n+}\n+\n+impl ProfileFormat {\n+    pub fn file_extension(&self) -> &'static str {\n+        match self {\n+            ProfileFormat::Json => \"json\",\n+            ProfileFormat::Folded => \"folded\",\n+            ProfileFormat::FlameGraph => \"svg\",\n+        }\n+    }\n }\n \n #[derive(Debug, Parser)]\n-pub struct DebugArgs {\n+pub struct DebugProfileOutArgs {\n+    #[arg(long, help = \"The output format for the profile data\")]\n+    format: Option<ProfileFormat>,\n     #[arg(\n         long,\n-        help = \"Specify the address of the remote target\",\n-        default_value = \".aster-gdb-socket\"\n+        help = \"The mask of the CPU to generate traces for in the output profile data\",\n+        default_value_t = u128::MAX\n     )]\n-    pub remote: String,\n-    #[command(flatten)]\n-    pub common_args: CommonArgs,\n+    pub cpu_mask: u128,\n+    #[arg(\n+        long,\n+        help = \"The path to the output profile data file\",\n+        value_name = \"PATH\"\n+    )]\n+    output: Option<PathBuf>,\n+}\n+\n+impl DebugProfileOutArgs {\n+    /// Get the output format for the profile data.\n+    ///\n+    /// If the user does not specify the format, it will be inferred from the\n+    /// output file extension. If the output file does not have an extension,\n+    /// the default format is flame graph.\n+    pub fn format(&self) -> ProfileFormat {\n+        self.format.unwrap_or_else(|| {\n+            if self.output.is_some() {\n+                match self.output.as_ref().unwrap().extension() {\n+                    Some(ext) if ext == \"folded\" => ProfileFormat::Folded,\n+                    Some(ext) if ext == \"json\" => ProfileFormat::Json,\n+                    Some(ext) if ext == \"svg\" => ProfileFormat::FlameGraph,\n+                    _ => ProfileFormat::FlameGraph,\n+                }\n+            } else {\n+                ProfileFormat::FlameGraph\n+            }\n+        })\n+    }\n+\n+    /// Get the output path for the profile data.\n+    ///\n+    /// If the user does not specify the output path, it will be generated from\n+    /// the current time stamp and the format. The caller can provide a hint\n+    /// output path to the file to override the file name.\n+    pub fn output_path(&self, hint: Option<&PathBuf>) -> PathBuf {\n+        self.output.clone().unwrap_or_else(|| {\n+            use chrono::{offset::Local, DateTime};\n+            let file_stem = if let Some(hint) = hint {\n+                format!(\n+                    \"{}\",\n+                    hint.parent()\n+                        .unwrap()\n+                        .join(hint.file_stem().unwrap())\n+                        .display()\n+                )\n+            } else {\n+                let crate_name = crate::util::get_current_crate_info().name;\n+                let time_stamp = std::time::SystemTime::now();\n+                let time_stamp: DateTime<Local> = time_stamp.into();\n+                let time_stamp = time_stamp.format(\"%H%M%S\");\n+                format!(\"{}-profile-{}\", crate_name, time_stamp)\n+            };\n+            PathBuf::from(format!(\"{}.{}\", file_stem, self.format().file_extension()))\n+        })\n+    }\n }\n \n #[derive(Debug, Parser)]\ndiff --git a/osdk/src/commands/debug.rs b/osdk/src/commands/debug.rs\nindex 46247abedd..a80f9c289f 100644\n--- a/osdk/src/commands/debug.rs\n+++ b/osdk/src/commands/debug.rs\n@@ -18,10 +18,9 @@ pub fn execute_debug_command(_profile: &str, args: &DebugArgs) {\n \n     let mut gdb = Command::new(\"gdb\");\n     gdb.args([\n+        format!(\"{}\", file_path.display()).as_str(),\n         \"-ex\",\n         format!(\"target remote {}\", remote).as_str(),\n-        \"-ex\",\n-        format!(\"file {}\", file_path.display()).as_str(),\n     ]);\n     gdb.status().unwrap();\n }\ndiff --git a/osdk/src/commands/mod.rs b/osdk/src/commands/mod.rs\nindex 22f6b074c7..875bf4a657 100644\n--- a/osdk/src/commands/mod.rs\n+++ b/osdk/src/commands/mod.rs\n@@ -5,13 +5,14 @@\n mod build;\n mod debug;\n mod new;\n+mod profile;\n mod run;\n mod test;\n mod util;\n \n pub use self::{\n     build::execute_build_command, debug::execute_debug_command, new::execute_new_command,\n-    run::execute_run_command, test::execute_test_command,\n+    profile::execute_profile_command, run::execute_run_command, test::execute_test_command,\n };\n \n use crate::arch::get_default_arch;\ndiff --git a/osdk/src/commands/profile.rs b/osdk/src/commands/profile.rs\nnew file mode 100644\nindex 0000000000..587a645de3\n--- /dev/null\n+++ b/osdk/src/commands/profile.rs\n@@ -0,0 +1,383 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! OSDK profile command implementation.\n+//!\n+//! The profile command is used to collect stack traces when running the target\n+//! kernel in QEMU. It attaches to the GDB server initiated with [`super::run`]\n+//! and collects the stack trace periodically. The collected data can be\n+//! further analyzed using tools like\n+//! [flame graph](https://github.com/brendangregg/FlameGraph).\n+\n+use inferno::flamegraph;\n+\n+use crate::{\n+    cli::{ProfileArgs, ProfileFormat},\n+    commands::util::bin_file_name,\n+    util::{get_current_crate_info, get_target_directory},\n+};\n+use regex::Regex;\n+use std::{collections::HashMap, fs::File, io::Write, path::PathBuf, process::Command};\n+\n+pub fn execute_profile_command(_profile: &str, args: &ProfileArgs) {\n+    if let Some(parse_input) = &args.parse {\n+        do_parse_stack_traces(parse_input, args);\n+    } else {\n+        do_collect_stack_traces(args);\n+    }\n+}\n+\n+fn do_parse_stack_traces(target_file: &PathBuf, args: &ProfileArgs) {\n+    let out_args = &args.out_args;\n+    let in_file = File::open(target_file).expect(\"Failed to open input file\");\n+    let profile: Profile =\n+        serde_json::from_reader(in_file).expect(\"Failed to parse the input JSON file\");\n+    let out_file = File::create(out_args.output_path(Some(target_file)))\n+        .expect(\"Failed to create output file\");\n+\n+    let out_format = out_args.format();\n+    if matches!(out_format, ProfileFormat::Json) {\n+        println!(\"Warning: parsing JSON profile to the same format.\");\n+        return;\n+    }\n+    profile.serialize_to(out_format, out_args.cpu_mask, out_file);\n+}\n+\n+fn do_collect_stack_traces(args: &ProfileArgs) {\n+    let file_path = get_target_directory()\n+        .join(\"osdk\")\n+        .join(get_current_crate_info().name)\n+        .join(bin_file_name());\n+\n+    let remote = &args.remote;\n+    let samples = &args.samples;\n+    let interval = &args.interval;\n+\n+    let mut profile_buffer = ProfileBuffer::new();\n+\n+    println!(\"Profiling \\\"{}\\\" at \\\"{}\\\".\", file_path.display(), remote);\n+    use indicatif::{ProgressIterator, ProgressStyle};\n+    let style = ProgressStyle::default_bar().progress_chars(\"#>-\");\n+    for _ in (0..*samples).progress_with_style(style) {\n+        // Use GDB to halt the remote, get stack traces, and resume\n+        let output = Command::new(\"gdb\")\n+            .args([\n+                \"-batch\",\n+                \"-ex\",\n+                \"set pagination 0\",\n+                \"-ex\",\n+                &format!(\"file {}\", file_path.display()),\n+                \"-ex\",\n+                &format!(\"target remote {}\", remote),\n+                \"-ex\",\n+                \"thread apply all bt -frame-arguments presence -frame-info short-location\",\n+            ])\n+            .output()\n+            .expect(\"Failed to execute gdb\");\n+\n+        for line in String::from_utf8_lossy(&output.stdout).lines() {\n+            profile_buffer.append_raw_line(line);\n+        }\n+\n+        // Sleep between samples\n+        std::thread::sleep(std::time::Duration::from_secs_f64(*interval));\n+    }\n+\n+    let out_args = &args.out_args;\n+    let out_path = out_args.output_path(None);\n+    println!(\n+        \"Profile data collected. Writing the output to \\\"{}\\\".\",\n+        out_path.display()\n+    );\n+\n+    let out_file = File::create(out_path).expect(\"Failed to create output file\");\n+    profile_buffer\n+        .cur_profile\n+        .serialize_to(out_args.format(), out_args.cpu_mask, out_file);\n+}\n+\n+#[derive(Debug, Default, Serialize, Deserialize)]\n+struct Profile {\n+    // Index 0: capture; Index 1: CPU ID; Index 2: stack frame\n+    stack_traces: Vec<HashMap<u32, Vec<String>>>,\n+}\n+\n+impl Profile {\n+    fn serialize_to<W: Write>(&self, format: ProfileFormat, cpu_mask: u128, mut target: W) {\n+        match format {\n+            ProfileFormat::Folded => {\n+                let folded = self.fold(cpu_mask);\n+\n+                // Write the folded traces to the target text writer.\n+                for (key, count) in folded {\n+                    writeln!(&mut target, \"{} {}\", key, count)\n+                        .expect(\"Failed to write folded output\");\n+                }\n+            }\n+            ProfileFormat::Json => {\n+                let filtered = self.filter_cpu(cpu_mask);\n+\n+                serde_json::to_writer(target, &filtered).expect(\"Failed to write JSON output\");\n+            }\n+            ProfileFormat::FlameGraph => {\n+                let folded = self.fold(cpu_mask);\n+\n+                // Generate the flame graph folded text lines.\n+                let lines = folded\n+                    .iter()\n+                    .map(|(key, count)| format!(\"{} {}\", key, count))\n+                    .collect::<Vec<_>>();\n+\n+                // Generate the flame graph to the target SVG writer.\n+                let mut opt = flamegraph::Options::default();\n+                flamegraph::from_lines(&mut opt, lines.iter().map(|s| s.as_str()), target).unwrap();\n+            }\n+        }\n+    }\n+\n+    fn filter_cpu(&self, cpu_mask: u128) -> Profile {\n+        let filtered_traces = self\n+            .stack_traces\n+            .iter()\n+            .map(|capture| {\n+                capture\n+                    .iter()\n+                    .filter(|(cpu_id, _)| **cpu_id < 128 && cpu_mask & (1u128 << **cpu_id) != 0)\n+                    .map(|(cpu_id, stack)| (*cpu_id, stack.clone()))\n+                    .collect::<HashMap<_, _>>()\n+            })\n+            .collect::<Vec<_>>();\n+\n+        Self {\n+            stack_traces: filtered_traces,\n+        }\n+    }\n+\n+    fn fold(&self, cpu_mask: u128) -> HashMap<String, u32> {\n+        let mut folded = HashMap::new();\n+\n+        for capture in &self.stack_traces {\n+            for (cpu_id, stack) in capture {\n+                if *cpu_id >= 128 || cpu_mask & (1u128 << *cpu_id) == 0 {\n+                    continue;\n+                }\n+\n+                let folded_key = stack.iter().rev().cloned().collect::<Vec<_>>().join(\";\");\n+                *folded.entry(folded_key).or_insert(0) += 1;\n+            }\n+        }\n+\n+        folded\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct ProfileBuffer {\n+    cur_profile: Profile,\n+    // Pre-compile regex patterns for cleaning the input.\n+    hex_in_pattern: Regex,\n+    impl_pattern: Regex,\n+    // The state\n+    cur_cpu: Option<u32>,\n+}\n+\n+impl ProfileBuffer {\n+    fn new() -> Self {\n+        Self {\n+            cur_profile: Profile::default(),\n+            hex_in_pattern: Regex::new(r\"0x[0-9a-f]+ in\").unwrap(),\n+            impl_pattern: Regex::new(r\"::\\{.*?\\}\").unwrap(),\n+            cur_cpu: None,\n+        }\n+    }\n+\n+    fn append_raw_line(&mut self, line: &str) {\n+        // Lines starting with '#' are stack frames\n+        if !line.starts_with('#') {\n+            // Otherwise it may initiate a new capture or a new CPU stack trace\n+\n+            // Check if this is a new CPU trace (starts with `Thread` and contains `CPU#N`)\n+            if line.starts_with(\"Thread\") {\n+                let cpu_id_idx = line.find(\"CPU#\").unwrap();\n+                let cpu_id = line[cpu_id_idx + 4..]\n+                    .split_whitespace()\n+                    .next()\n+                    .unwrap()\n+                    .parse::<u32>()\n+                    .unwrap();\n+                self.cur_cpu = Some(cpu_id);\n+\n+                // if the new CPU id is already in the stack traces, start a new capture\n+                match self.cur_profile.stack_traces.last() {\n+                    Some(capture) => {\n+                        if capture.contains_key(&cpu_id) {\n+                            self.cur_profile.stack_traces.push(HashMap::new());\n+                        }\n+                    }\n+                    None => {\n+                        self.cur_profile.stack_traces.push(HashMap::new());\n+                    }\n+                }\n+            }\n+\n+            return;\n+        }\n+\n+        // Clean the input line\n+        let mut processed = line.trim().to_string();\n+\n+        // Remove everything between angle brackets '<...>'\n+        processed = Self::remove_generics(&processed);\n+\n+        // Remove \"::impl{}\" and hex addresses\n+        processed = self.impl_pattern.replace_all(&processed, \"\").to_string();\n+        processed = self.hex_in_pattern.replace_all(&processed, \"\").to_string();\n+\n+        // Remove unnecessary parts like \"()\" and \"(...)\"\n+        processed = processed.replace(\"(...)\", \"\");\n+        processed = processed.replace(\"()\", \"\");\n+\n+        // Split the line by spaces and expect the second part to be the function name\n+        let parts: Vec<&str> = processed.split_whitespace().collect();\n+        if parts.len() > 1 {\n+            let func_name = parts[1].to_string();\n+\n+            // Append the function name to the latest stack trace\n+            let current_capture = self.cur_profile.stack_traces.last_mut().unwrap();\n+            let cur_cpu = self.cur_cpu.unwrap();\n+            current_capture.entry(cur_cpu).or_default().push(func_name);\n+        }\n+    }\n+\n+    fn remove_generics(line: &str) -> String {\n+        let mut result = String::new();\n+        let mut bracket_depth = 0;\n+\n+        for c in line.chars() {\n+            match c {\n+                '<' => bracket_depth += 1,\n+                '>' => {\n+                    if bracket_depth > 0 {\n+                        bracket_depth -= 1;\n+                    }\n+                }\n+                _ => {\n+                    if bracket_depth == 0 {\n+                        result.push(c);\n+                    }\n+                }\n+            }\n+        }\n+\n+        result\n+    }\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_profile_parse_raw() {\n+    let test_case = r#\"\n+0xffffffff880b0f6f in aster_nix::sched::priority_scheduler::{impl#4}::pick_next_current<ostd::task::Task> (self=0xffffffff88489808 <_ZN4ostd2mm14heap_allocator10HEAP_SPACE17h85a5340e6564f69dE.llvm.15305379556759765072+992480>) at src/sched/priority_scheduler.rs:156\n+156\t        let next_entity = if !self.real_time_entities.is_empty() {\n+\n+Thread 2 (Thread 1.2 (CPU#1 [running])):\n+#0  ostd::sync::spin::SpinLock<aster_nix::sched::priority_scheduler::PreemptRunQueue<ostd::task::Task>, ostd::sync::spin::PreemptDisabled>::acquire_lock<aster_nix::sched::priority_scheduler::PreemptRunQueue<ostd::task::Task>, ostd::sync::spin::PreemptDisabled> (...)\n+#1  ostd::sync::spin::SpinLock<aster_nix::sched::priority_scheduler::PreemptRunQueue<ostd::task::Task>, ostd::sync::spin::PreemptDisabled>::lock<aster_nix::sched::priority_scheduler::PreemptRunQueue<ostd::task::Task>, ostd::sync::spin::PreemptDisabled> (...)\n+#2  aster_nix::sched::priority_scheduler::{impl#1}::local_mut_rq_with<ostd::task::Task> (...)\n+#3  0xffffffff8826b205 in ostd::task::scheduler::reschedule<ostd::task::scheduler::yield_now::{closure_env#0}> (...)\n+#4  ostd::task::scheduler::yield_now ()\n+#5  0xffffffff880a92c5 in ostd::task::Task::yield_now ()\n+#6  aster_nix::thread::Thread::yield_now ()\n+#7  aster_nix::ap_init::ap_idle_thread ()\n+#8  core::ops::function::Fn::call<fn(), ()> ()\n+#9  0xffffffff880b341e in alloc::boxed::{impl#50}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (...)\n+#10 aster_nix::thread::kernel_thread::create_new_kernel_task::{closure#0} ()\n+#11 0xffffffff882a3ea8 in alloc::boxed::{impl#50}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (...)\n+#12 ostd::task::{impl#2}::build::kernel_task_entry ()\n+#13 0x0000000000000000 in ?? ()\n+\n+Thread 1 (Thread 1.1 (CPU#0 [running])):\n+#0  aster_nix::sched::priority_scheduler::{impl#1}::local_mut_rq_with<ostd::task::Task> (...)\n+#1  0xffffffff8826b205 in ostd::task::scheduler::reschedule<ostd::task::scheduler::yield_now::{closure_env#0}> (...)\n+#2  ostd::task::scheduler::yield_now ()\n+#3  0xffffffff880a92c5 in ostd::task::Task::yield_now ()\n+#4  aster_nix::thread::Thread::yield_now ()\n+#5  aster_nix::ap_init::ap_idle_thread ()\n+#6  core::ops::function::Fn::call<fn(), ()> ()\n+#7  0xffffffff880b341e in alloc::boxed::{impl#50}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (...)\n+#8  aster_nix::thread::kernel_thread::create_new_kernel_task::{closure#0} ()\n+#9  0xffffffff882a3ea8 in alloc::boxed::{impl#50}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (...)\n+#10 ostd::task::{impl#2}::build::kernel_task_entry ()\n+#11 0x0000000000000000 in ?? ()\n+[Inferior 1 (process 1) detached]\n+0xffffffff880b0f6f in aster_nix::sched::priority_scheduler::{impl#4}::pick_next_current<ostd::task::Task> (self=0xffffffff88489808 <_ZN4ostd2mm14heap_allocator10HEAP_SPACE17h85a5340e6564f69dE.llvm.15305379556759765072+992480>) at src/sched/priority_scheduler.rs:156\n+156\t        let next_entity = if !self.real_time_entities.is_empty() {\n+\n+Thread 2 (Thread 1.2 (CPU#1 [running])):\n+#0  0xffffffff880b0f6f in aster_nix::sched::priority_scheduler::{impl#4}::pick_next_current<ostd::task::Task> (...)\n+#1  0xffffffff8826b3e0 in ostd::task::scheduler::yield_now::{closure#0} (...)\n+#2  ostd::task::scheduler::reschedule::{closure#0}<ostd::task::scheduler::yield_now::{closure_env#0}> (...)\n+#3  0xffffffff880b0cff in aster_nix::sched::priority_scheduler::{impl#1}::local_mut_rq_with<ostd::task::Task> (...)\n+#4  0xffffffff8826b205 in ostd::task::scheduler::reschedule<ostd::task::scheduler::yield_now::{closure_env#0}> (...)\n+#5  ostd::task::scheduler::yield_now ()\n+#6  0xffffffff880a92c5 in ostd::task::Task::yield_now ()\n+#7  aster_nix::thread::Thread::yield_now ()\n+#8  aster_nix::ap_init::ap_idle_thread ()\n+#9  core::ops::function::Fn::call<fn(), ()> ()\n+#10 0xffffffff880b341e in alloc::boxed::{impl#50}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (...)\n+#11 aster_nix::thread::kernel_thread::create_new_kernel_task::{closure#0} ()\n+#12 0xffffffff882a3ea8 in alloc::boxed::{impl#50}::call<(), (dyn core::ops::function::Fn<(), Output=()> + core::marker::Send + core::marker::Sync), alloc::alloc::Global> (...)\n+#13 ostd::task::{impl#2}::build::kernel_task_entry ()\n+#14 0x0000000000000000 in ?? ()\n+\n+Thread 1 (Thread 1.1 (CPU#0 [running])):\n+#0  ostd::arch::x86::interrupts_ack (...)\n+#1  0xffffffff8828d704 in ostd::trap::handler::call_irq_callback_functions (...)\n+#2  0xffffffff88268e48 in ostd::arch::x86::trap::trap_handler (...)\n+#3  0xffffffff88274db6 in __from_kernel ()\n+#4  0x0000000000000001 in ?? ()\n+#5  0x0000000000000001 in ?? ()\n+#6  0x00000000000001c4 in ?? ()\n+#7  0xffffffff882c8580 in ?? ()\n+#8  0x0000000000000002 in ?? ()\n+#9  0xffffffff88489808 in _ZN4ostd2mm14heap_allocator10HEAP_SPACE17h85a5340e6564f69dE.llvm.15305379556759765072 ()\n+#10 0x0000000000000000 in ?? ()\n+[Inferior 1 (process 1) detached]\n+\"#;\n+\n+    let mut buffer = ProfileBuffer::new();\n+    for line in test_case.lines() {\n+        buffer.append_raw_line(line);\n+    }\n+\n+    let profile = &buffer.cur_profile;\n+    assert_eq!(profile.stack_traces.len(), 2);\n+    assert_eq!(profile.stack_traces[0].len(), 2);\n+    assert_eq!(profile.stack_traces[1].len(), 2);\n+\n+    let stack00 = profile.stack_traces[0].get(&0).unwrap();\n+    assert_eq!(stack00.len(), 12);\n+    assert_eq!(\n+        stack00[0],\n+        \"aster_nix::sched::priority_scheduler::local_mut_rq_with\"\n+    );\n+    assert_eq!(stack00[11], \"??\");\n+\n+    let stack01 = profile.stack_traces[0].get(&1).unwrap();\n+    assert_eq!(stack01.len(), 14);\n+    assert_eq!(stack01[9], \"alloc::boxed::call\");\n+\n+    let stack10 = profile.stack_traces[1].get(&0).unwrap();\n+    assert_eq!(stack10.len(), 11);\n+    assert_eq!(\n+        stack10[9],\n+        \"_ZN4ostd2mm14heap_allocator10HEAP_SPACE17h85a5340e6564f69dE.llvm.15305379556759765072\"\n+    );\n+\n+    let stack11 = profile.stack_traces[1].get(&1).unwrap();\n+    assert_eq!(stack11.len(), 15);\n+    assert_eq!(\n+        stack11[0],\n+        \"aster_nix::sched::priority_scheduler::pick_next_current\"\n+    );\n+    assert_eq!(stack11[14], \"??\");\n+}\ndiff --git a/osdk/src/commands/run.rs b/osdk/src/commands/run.rs\nindex e751956c8f..223f9ddf60 100644\n--- a/osdk/src/commands/run.rs\n+++ b/osdk/src/commands/run.rs\n@@ -1,60 +1,29 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+use std::process::exit;\n+\n+use vsc::VscLaunchConfig;\n+\n use super::{build::create_base_and_cached_build, util::DEFAULT_TARGET_RELPATH};\n use crate::{\n-    cli::GdbServerArgs,\n     config::{scheme::ActionChoice, Config},\n+    error::Errno,\n+    error_msg,\n     util::{get_current_crate_info, get_target_directory},\n };\n \n-pub fn execute_run_command(config: &Config, gdb_server_args: &GdbServerArgs) {\n-    if gdb_server_args.is_gdb_enabled {\n-        use std::env;\n-        env::set_var(\n-            \"RUSTFLAGS\",\n-            env::var(\"RUSTFLAGS\").unwrap_or_default() + \" -g\",\n-        );\n-    }\n-\n+pub fn execute_run_command(config: &Config, gdb_server_args: Option<&str>) {\n     let cargo_target_directory = get_target_directory();\n     let osdk_output_directory = cargo_target_directory.join(DEFAULT_TARGET_RELPATH);\n     let target_name = get_current_crate_info().name;\n \n     let mut config = config.clone();\n-    if gdb_server_args.is_gdb_enabled {\n-        let qemu_gdb_args = {\n-            let gdb_stub_addr = gdb_server_args.gdb_server_addr.as_str();\n-            match gdb::stub_type_of(gdb_stub_addr) {\n-                gdb::StubAddrType::Unix => {\n-                    format!(\n-                        \" -chardev socket,path={},server=on,wait=off,id=gdb0 -gdb chardev:gdb0 -S\",\n-                        gdb_stub_addr\n-                    )\n-                }\n-                gdb::StubAddrType::Tcp => {\n-                    format!(\n-                        \" -gdb tcp:{} -S\",\n-                        gdb::tcp_addr_util::format_tcp_addr(gdb_stub_addr)\n-                    )\n-                }\n-            }\n-        };\n-        config.run.qemu.args += &qemu_gdb_args;\n-\n-        // Ensure debug info added when debugging in the release profile.\n-        if config.run.build.profile.contains(\"release\") {\n-            config\n-                .run\n-                .build\n-                .override_configs\n-                .push(format!(\"profile.{}.debug=true\", config.run.build.profile));\n-        }\n-    }\n-    let _vsc_launch_file = gdb_server_args.vsc_launch_file.then(|| {\n-        vsc::check_gdb_config(gdb_server_args);\n-        let profile = super::util::profile_name_adapter(&config.run.build.profile);\n-        vsc::VscLaunchConfig::new(profile, &gdb_server_args.gdb_server_addr)\n-    });\n+\n+    let _vsc_launch_file = if let Some(gdb_server_str) = gdb_server_args {\n+        adapt_for_gdb_server(&mut config, gdb_server_str)\n+    } else {\n+        None\n+    };\n \n     let default_bundle_directory = osdk_output_directory.join(target_name);\n     let bundle = create_base_and_cached_build(\n@@ -69,6 +38,82 @@ pub fn execute_run_command(config: &Config, gdb_server_args: &GdbServerArgs) {\n     bundle.run(&config, ActionChoice::Run);\n }\n \n+fn adapt_for_gdb_server(config: &mut Config, gdb_server_str: &str) -> Option<VscLaunchConfig> {\n+    let gdb_server_args = GdbServerArgs::from_str(gdb_server_str);\n+\n+    // Add GDB server arguments to QEMU.\n+    let qemu_gdb_args = {\n+        let gdb_stub_addr = gdb_server_args.host_addr.as_str();\n+        match gdb::stub_type_of(gdb_stub_addr) {\n+            gdb::StubAddrType::Unix => {\n+                format!(\n+                    \" -chardev socket,path={},server=on,wait=off,id=gdb0 -gdb chardev:gdb0\",\n+                    gdb_stub_addr\n+                )\n+            }\n+            gdb::StubAddrType::Tcp => {\n+                format!(\n+                    \" -gdb tcp:{}\",\n+                    gdb::tcp_addr_util::format_tcp_addr(gdb_stub_addr)\n+                )\n+            }\n+        }\n+    };\n+    config.run.qemu.args += &qemu_gdb_args;\n+\n+    if gdb_server_args.wait_client {\n+        config.run.qemu.args += \" -S\";\n+    }\n+\n+    // Ensure debug info added when debugging in the release profile.\n+    if config.run.build.profile.contains(\"release\") {\n+        config\n+            .run\n+            .build\n+            .override_configs\n+            .push(format!(\"profile.{}.debug=true\", config.run.build.profile));\n+    }\n+\n+    gdb_server_args.vsc_launch_file.then(|| {\n+        vsc::check_gdb_config(&gdb_server_args);\n+        let profile = super::util::profile_name_adapter(&config.run.build.profile);\n+        vsc::VscLaunchConfig::new(profile, &gdb_server_args.host_addr)\n+    })\n+}\n+\n+struct GdbServerArgs {\n+    host_addr: String,\n+    wait_client: bool,\n+    vsc_launch_file: bool,\n+}\n+\n+impl GdbServerArgs {\n+    fn from_str(args: &str) -> Self {\n+        let mut host_addr = \".osdk-gdb-socket\".to_string();\n+        let mut wait_client = false;\n+        let mut vsc_launch_file = false;\n+\n+        for arg in args.split(\",\") {\n+            let kv = arg.split('=').collect::<Vec<_>>();\n+            match kv.as_slice() {\n+                [\"addr\", addr] => host_addr = addr.to_string(),\n+                [\"wait-client\"] => wait_client = true,\n+                [\"vscode\"] => vsc_launch_file = true,\n+                _ => {\n+                    error_msg!(\"Invalid GDB server argument: {}\", arg);\n+                    exit(Errno::Cli as _);\n+                }\n+            }\n+        }\n+\n+        GdbServerArgs {\n+            host_addr,\n+            wait_client,\n+            vsc_launch_file,\n+        }\n+    }\n+}\n+\n mod gdb {\n     #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n     pub enum StubAddrType {\n@@ -111,7 +156,6 @@ mod gdb {\n \n mod vsc {\n     use crate::{\n-        cli::GdbServerArgs,\n         commands::util::bin_file_name,\n         util::{get_cargo_metadata, get_current_crate_info},\n     };\n@@ -121,7 +165,7 @@ mod vsc {\n         path::Path,\n     };\n \n-    use super::gdb;\n+    use super::{gdb, GdbServerArgs};\n \n     const VSC_DIR: &str = \".vscode\";\n \n@@ -170,6 +214,7 @@ mod vsc {\n             }\n         }\n     }\n+\n     impl Drop for VscLaunchConfig {\n         fn drop(&mut self) {\n             // remove generated files\n@@ -205,22 +250,16 @@ mod vsc {\n         use crate::{error::Errno, error_msg};\n         use std::process::exit;\n \n-        if !args.is_gdb_enabled {\n-            error_msg!(\n-                \"No need for a VSCode launch file without launching GDB server,\\\n-                    pass '-h' for help\"\n-            );\n-            exit(Errno::ParseMetadata as _);\n-        }\n-\n         // check GDB server address\n-        let gdb_stub_addr = args.gdb_server_addr.as_str();\n+        let gdb_stub_addr = args.host_addr.as_str();\n         if gdb_stub_addr.is_empty() {\n             error_msg!(\"GDB server address is required to generate a VSCode launch file\");\n             exit(Errno::ParseMetadata as _);\n         }\n         if gdb::stub_type_of(gdb_stub_addr) != gdb::StubAddrType::Tcp {\n-            error_msg!(\"Non-TCP GDB server address is not supported under '--vsc' currently\");\n+            error_msg!(\n+                \"Non-TCP GDB server address is not supported under '--gdb-server vscode' currently\"\n+            );\n             exit(Errno::ParseMetadata as _);\n         }\n     }\ndiff --git a/osdk/src/error.rs b/osdk/src/error.rs\nindex 1dfdeaa17f..41260a993b 100644\n--- a/osdk/src/error.rs\n+++ b/osdk/src/error.rs\n@@ -3,14 +3,15 @@\n #[repr(i32)]\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum Errno {\n-    CreateCrate = 1,\n-    GetMetadata = 2,\n-    AddRustToolchain = 3,\n-    ParseMetadata = 4,\n-    ExecuteCommand = 5,\n-    BuildCrate = 6,\n-    RunBundle = 7,\n-    BadCrateName = 8,\n+    Cli = 1,\n+    CreateCrate = 2,\n+    GetMetadata = 3,\n+    AddRustToolchain = 4,\n+    ParseMetadata = 5,\n+    ExecuteCommand = 6,\n+    BuildCrate = 7,\n+    RunBundle = 8,\n+    BadCrateName = 9,\n }\n \n /// Print error message to console\n", "test_patch": "diff --git a/osdk/tests/commands/run.rs b/osdk/tests/commands/run.rs\nindex 693f68e9cc..716286abf0 100644\n--- a/osdk/tests/commands/run.rs\n+++ b/osdk/tests/commands/run.rs\n@@ -79,7 +79,11 @@ mod qemu_gdb_feature {\n             path.to_string_lossy().to_string()\n         };\n \n-        let mut instance = cargo_osdk([\"run\", \"-G\", \"--gdb-server-addr\", unix_socket.as_str()]);\n+        let mut instance = cargo_osdk([\n+            \"run\",\n+            \"--gdb-server\",\n+            format!(\"addr={},wait-client\", unix_socket.as_str()).as_str(),\n+        ]);\n         instance.current_dir(&workspace.os_dir());\n \n         let sock = unix_socket.clone();\n@@ -106,8 +110,8 @@ mod qemu_gdb_feature {\n         let mut gdb = Command::new(\"gdb\");\n         gdb.args([\"-ex\", format!(\"target remote {}\", addr).as_str()]);\n         gdb.write_stdin(\"\\n\")\n-            .write_stdin(\"c\\n\")\n-            .write_stdin(\"quit\\n\");\n+            .write_stdin(\"quit\\n\")\n+            .write_stdin(\"y\\n\");\n         gdb.assert().success();\n     }\n     mod vsc {\n@@ -123,14 +127,18 @@ mod qemu_gdb_feature {\n             let workspace = workspace::WorkSpace::new(WORKSPACE, kernel_name);\n             let addr = \":50001\";\n \n-            let mut instance = cargo_osdk([\"run\", \"-G\", \"--vsc\", \"--gdb-server-addr\", addr]);\n+            let mut instance = cargo_osdk([\n+                \"run\",\n+                \"--gdb-server\",\n+                format!(\"wait-client,vscode,addr={}\", addr).as_str(),\n+            ]);\n             instance.current_dir(&workspace.os_dir());\n \n             let dir = workspace.os_dir();\n             let bin_file_path = Path::new(&workspace.os_dir())\n                 .join(\"target\")\n-                .join(\"x86_64-unknown-none\")\n-                .join(\"debug\")\n+                .join(\"osdk\")\n+                .join(kernel_name)\n                 .join(format!(\"{}-osdk-bin\", kernel_name));\n             let _gdb = std::thread::spawn(move || {\n                 while !bin_file_path.exists() {\n", "problem_statement": "[Perf Guide] Flame graph scripts on Asterinas\n[Flame graph](https://github.com/brendangregg/FlameGraph) is a well known and powerful tool for performance (bottoleneck) analysis. It's based on sampling. If you inspect the call stack 100 times per second, the function that appears more often, would like to consume more time. The flame graph helps you to visualize it.\r\n\r\nHere's my experience about how to capture a flame graph for Asterinas.\r\n\r\nJust like what's proposed in #691, the first step is to launch a GDB server (`make gdb_server RELEASE=1`), attach to it (`make gdb_client`) and quit to leave the kernel running.\r\n\r\nThen, use the following script to sample call stacks using GDB:\r\n\r\n<details><summary>script to sample</summary>\r\n<p>\r\n\r\n```bash\r\n#!/bin/bash\r\n\r\n# Number of samples\r\nnsamples=100\r\n# Sleep time between samples (in seconds)\r\nsleeptime=0.1\r\n\r\n# Hostname or IP address of the machine running QEMU with GDB server\r\nremote_host=\"localhost\"\r\n# Port number where QEMU GDB server is listening\r\nremote_port=\"1234\"\r\n\r\nsleep 0.1\r\n\r\nfor x in $(seq 1 $nsamples)\r\ndo\r\n\tgdb -batch \\\r\n\t\t-ex \"set pagination 0\" \\\r\n\t\t-ex \"file target/osdk/aster-nix/aster-nix-osdk-bin\" \\\r\n\t\t-ex \"target remote $remote_host:$remote_port\" \\\r\n\t\t-ex \"bt -frame-arguments presence -frame-info short-location\" >> gdb_perf.log\r\n\tsleep $sleeptime\r\ndone\r\n```\r\n\r\n</p>\r\n</details> \r\n\r\nAfter that, the text log is dumped to `gdb_perf.log`. Use a python script to generate folded stack traces for the flame graph:\r\n\r\n<details><summary>Details</summary>\r\n<p>\r\n\r\n```python\r\nimport re\r\n\r\ndef process_stack_trace(file_path):\r\n    with open(file_path, 'r') as file:\r\n        lines = file.readlines()\r\n\r\n    captures = []\r\n    current_capture = []\r\n\r\n    for line in lines:\r\n        if not line.startswith('#'):\r\n            continue\r\n        if line.startswith('#0'):\r\n            if current_capture:\r\n                captures.append(current_capture)\r\n                current_capture = []\r\n        processed = line.strip()\r\n        # remove all things between < and >, use bracket matching\r\n        cut_generic = ''\r\n        cnt = 0\r\n        for c in processed:\r\n            if c == '<':\r\n                cnt += 1\r\n            if cnt == 0:\r\n                cut_generic += c\r\n            if c == '>':\r\n                cnt -= 1\r\n        processed = cut_generic\r\n        # remove all things like \"::{impl#70}\"\r\n        processed = re.sub(r'::\\{.*?\\}', '', processed)\r\n        # remove all \"(...)\"\r\n        processed = processed.replace('(...)', '')\r\n        # remove all \"()\"\r\n        processed = processed.replace('()', '')\r\n        # remove all things like \"0xffffffff8819d0fb in\"\r\n        processed = re.sub(r'0x[0-9a-f]+ in', '', processed)\r\n\r\n        # split by spaces, the first is number and the second is function name\r\n        parts = [s for s in processed.split(' ') if s != '']\r\n\r\n        current_capture.append(parts[1])\r\n\r\n    if current_capture:\r\n        captures.append(current_capture)\r\n\r\n    folded = {} # { bt: value }\r\n\r\n    for capture in captures:\r\n        bt_from_butt = []\r\n        for frame in reversed(capture):\r\n            bt_from_butt.append(frame)\r\n        folded_key = ';'.join(bt_from_butt)\r\n        if folded_key in folded:\r\n            folded[folded_key] += 1\r\n        else:\r\n            folded[folded_key] = 1\r\n\r\n    with open('out.folded', 'w') as out_file:\r\n        for key, v in folded.items():\r\n            out_file.write(f\"{key} {v}\\n\")\r\n\r\nif __name__ == \"__main__\":\r\n    process_stack_trace('gdb_perf.log')\r\n\r\n```\r\n\r\n</p>\r\n</details> \r\n\r\nThis script generates a file `out.folded`. Then the file is ready to be processed using [Flame graph](https://github.com/brendangregg/FlameGraph). Follow the guide to have an SVG.\r\n\r\nTLDR:\r\n\r\n```shell\r\n./FlameGraph/flamegraph.pl ./asterinas/out.folded > kernel.svg\r\n```\r\n\r\nHere's an example on the unixbench spawn benchmark (on [c75a373](https://github.com/asterinas/asterinas/commit/c75a3732b9a6a7f0dbf11a839affaf2c126ecdc5)):\r\n\r\n![kernel](https://github.com/asterinas/asterinas/assets/30975570/0ea5b99b-c769-4342-b17f-0d17e100ef8d)\r\n\r\n([An interactive one](https://github.com/asterinas/asterinas/assets/30975570/0ea5b99b-c769-4342-b17f-0d17e100ef8d))\r\n\r\nHere's also another example using #895 to optimize it:\r\n\r\n![kernel_vmspacerw](https://github.com/asterinas/asterinas/assets/30975570/6e960bd7-ed26-49d0-91a5-1289673b6215)\r\n\r\n([An interactive one](https://github.com/asterinas/asterinas/assets/30975570/6e960bd7-ed26-49d0-91a5-1289673b6215))\r\n\r\nYou can clearly see that when the bottleneck `read_val_from_user` is optimized, the performance boosts significantly and the bottleneck becomes the `ProcessBuilder`.\r\n\n", "hints_text": "", "created_at": "2024-09-21T13:48:03Z", "version": "0.8"}, {"repo": "asterinas/asterinas", "pull_number": 1328, "instance_id": "asterinas__asterinas-1328", "issue_numbers": ["1244"], "base_commit": "42e28763c59202486af4298d5305e5c5e5ab9b54", "patch": "diff --git a/kernel/src/lib.rs b/kernel/src/lib.rs\nindex c8f1e1bb7c..42390338cb 100644\n--- a/kernel/src/lib.rs\n+++ b/kernel/src/lib.rs\n@@ -133,10 +133,7 @@ fn ap_init() -> ! {\n }\n \n fn init_thread() {\n-    println!(\n-        \"[kernel] Spawn init thread, tid = {}\",\n-        current_thread!().tid()\n-    );\n+    println!(\"[kernel] Spawn init thread\");\n     // Work queue should be initialized before interrupt is enabled,\n     // in case any irq handler uses work queue as bottom half\n     thread::work_queue::init();\n@@ -146,15 +143,8 @@ fn init_thread() {\n     // driver::pci::virtio::block::block_device_test();\n     let thread = Thread::spawn_kernel_thread(ThreadOptions::new(|| {\n         println!(\"[kernel] Hello world from kernel!\");\n-        let current = current_thread!();\n-        let tid = current.tid();\n-        debug!(\"current tid = {}\", tid);\n     }));\n     thread.join();\n-    info!(\n-        \"[aster-nix/lib.rs] spawn kernel thread, tid = {}\",\n-        thread.tid()\n-    );\n \n     print_banner();\n \ndiff --git a/kernel/src/process/clone.rs b/kernel/src/process/clone.rs\nindex 29a23f07fe..f6233f314f 100644\n--- a/kernel/src/process/clone.rs\n+++ b/kernel/src/process/clone.rs\n@@ -4,11 +4,12 @@ use core::sync::atomic::Ordering;\n \n use ostd::{\n     cpu::UserContext,\n+    task::Task,\n     user::{UserContextApi, UserSpace},\n };\n \n use super::{\n-    posix_thread::{PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName},\n+    posix_thread::{thread_table, PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName},\n     process_table,\n     process_vm::ProcessVm,\n     signal::sig_disposition::SigDispositions,\n@@ -18,7 +19,8 @@ use crate::{\n     cpu::LinuxAbi,\n     fs::{file_table::FileTable, fs_resolver::FsResolver, utils::FileCreationMask},\n     prelude::*,\n-    thread::{allocate_tid, thread_table, Thread, Tid},\n+    process::posix_thread::allocate_posix_tid,\n+    thread::{Thread, Tid},\n };\n \n bitflags! {\n@@ -132,7 +134,8 @@ pub fn clone_child(\n ) -> Result<Tid> {\n     clone_args.clone_flags.check_unsupported_flags()?;\n     if clone_args.clone_flags.contains(CloneFlags::CLONE_THREAD) {\n-        let child_thread = clone_child_thread(ctx, parent_context, clone_args)?;\n+        let child_task = clone_child_task(ctx, parent_context, clone_args)?;\n+        let child_thread = Thread::borrow_from_task(&child_task);\n         child_thread.run();\n \n         let child_tid = child_thread.tid();\n@@ -146,11 +149,11 @@ pub fn clone_child(\n     }\n }\n \n-fn clone_child_thread(\n+fn clone_child_task(\n     ctx: &Context,\n     parent_context: &UserContext,\n     clone_args: CloneArgs,\n-) -> Result<Arc<Thread>> {\n+) -> Result<Arc<Task>> {\n     let Context {\n         process,\n         posix_thread,\n@@ -180,8 +183,8 @@ fn clone_child_thread(\n     // Inherit sigmask from current thread\n     let sig_mask = posix_thread.sig_mask().load(Ordering::Relaxed).into();\n \n-    let child_tid = allocate_tid();\n-    let child_thread = {\n+    let child_tid = allocate_posix_tid();\n+    let child_task = {\n         let credentials = {\n             let credentials = ctx.posix_thread.credentials();\n             Credentials::new_from(&credentials)\n@@ -193,13 +196,13 @@ fn clone_child_thread(\n         thread_builder.build()\n     };\n \n-    process.threads().lock().push(child_thread.clone());\n+    process.tasks().lock().push(child_task.clone());\n \n-    let child_posix_thread = child_thread.as_posix_thread().unwrap();\n+    let child_posix_thread = child_task.as_posix_thread().unwrap();\n     clone_parent_settid(child_tid, clone_args.parent_tidptr, clone_flags)?;\n     clone_child_cleartid(child_posix_thread, clone_args.child_tidptr, clone_flags)?;\n     clone_child_settid(child_posix_thread, clone_args.child_tidptr, clone_flags)?;\n-    Ok(child_thread)\n+    Ok(child_task)\n }\n \n fn clone_child_process(\n@@ -262,7 +265,7 @@ fn clone_child_process(\n     // inherit parent's nice value\n     let child_nice = process.nice().load(Ordering::Relaxed);\n \n-    let child_tid = allocate_tid();\n+    let child_tid = allocate_posix_tid();\n \n     let child = {\n         let child_elf_path = process.executable_path();\ndiff --git a/kernel/src/process/exit.rs b/kernel/src/process/exit.rs\nindex 8580e49fc3..c0fedd853a 100644\n--- a/kernel/src/process/exit.rs\n+++ b/kernel/src/process/exit.rs\n@@ -4,9 +4,10 @@ use super::{process_table, Pid, Process, TermStatus};\n use crate::{\n     prelude::*,\n     process::{\n-        posix_thread::do_exit,\n+        posix_thread::{do_exit, PosixThreadExt},\n         signal::{constants::SIGCHLD, signals::kernel::KernelSignal},\n     },\n+    thread::Thread,\n };\n \n pub fn do_exit_group(term_status: TermStatus) {\n@@ -18,9 +19,11 @@ pub fn do_exit_group(term_status: TermStatus) {\n     current.set_zombie(term_status);\n \n     // Exit all threads\n-    let threads = current.threads().lock().clone();\n-    for thread in threads {\n-        if let Err(e) = do_exit(thread, term_status) {\n+    let tasks = current.tasks().lock().clone();\n+    for task in tasks {\n+        let thread = Thread::borrow_from_task(&task);\n+        let posix_thread = thread.as_posix_thread().unwrap();\n+        if let Err(e) = do_exit(thread, posix_thread, term_status) {\n             debug!(\"Ignore error when call exit: {:?}\", e);\n         }\n     }\ndiff --git a/kernel/src/process/kill.rs b/kernel/src/process/kill.rs\nindex 3ed3f5e4b9..29cfaf63f2 100644\n--- a/kernel/src/process/kill.rs\n+++ b/kernel/src/process/kill.rs\n@@ -1,7 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use super::{\n-    posix_thread::PosixThreadExt,\n+    posix_thread::{thread_table, PosixThreadExt},\n     process_table,\n     signal::{\n         constants::SIGCONT,\n@@ -10,10 +10,7 @@ use super::{\n     },\n     Pgid, Pid, Process, Sid, Uid,\n };\n-use crate::{\n-    prelude::*,\n-    thread::{thread_table, Tid},\n-};\n+use crate::{prelude::*, thread::Tid};\n \n /// Sends a signal to a process, using the current process as the sender.\n ///\n@@ -120,14 +117,14 @@ pub fn kill_all(signal: Option<UserSignal>, ctx: &Context) -> Result<()> {\n }\n \n fn kill_process(process: &Process, signal: Option<UserSignal>, ctx: &Context) -> Result<()> {\n-    let threads = process.threads().lock();\n+    let tasks = process.tasks().lock();\n \n     let signum = signal.map(|signal| signal.num());\n     let sender_ids = current_thread_sender_ids(signum.as_ref(), ctx);\n \n     let mut permitted_thread = None;\n-    for thread in threads.iter() {\n-        let posix_thread = thread.as_posix_thread().unwrap();\n+    for task in tasks.iter() {\n+        let posix_thread = task.as_posix_thread().unwrap();\n \n         // First check permission\n         if posix_thread\ndiff --git a/kernel/src/process/posix_thread/builder.rs b/kernel/src/process/posix_thread/builder.rs\nindex b7ae0d6762..c2467fbfd3 100644\n--- a/kernel/src/process/posix_thread/builder.rs\n+++ b/kernel/src/process/posix_thread/builder.rs\n@@ -2,9 +2,9 @@\n \n #![allow(dead_code)]\n \n-use ostd::user::UserSpace;\n+use ostd::{task::Task, user::UserSpace};\n \n-use super::PosixThread;\n+use super::{thread_table, PosixThread};\n use crate::{\n     prelude::*,\n     process::{\n@@ -12,7 +12,7 @@ use crate::{\n         signal::{sig_mask::AtomicSigMask, sig_queues::SigQueues},\n         Credentials, Process,\n     },\n-    thread::{status::ThreadStatus, task, thread_table, Thread, Tid},\n+    thread::{status::ThreadStatus, task, Thread, Tid},\n     time::{clocks::ProfClock, TimerManager},\n };\n \n@@ -72,7 +72,7 @@ impl PosixThreadBuilder {\n         self\n     }\n \n-    pub fn build(self) -> Arc<Thread> {\n+    pub fn build(self) -> Arc<Task> {\n         let Self {\n             tid,\n             user_space,\n@@ -85,34 +85,36 @@ impl PosixThreadBuilder {\n             sig_queues,\n         } = self;\n \n-        let thread = Arc::new_cyclic(|thread_ref| {\n-            let task = task::create_new_user_task(user_space, thread_ref.clone());\n-            let status = ThreadStatus::Init;\n-\n-            let prof_clock = ProfClock::new();\n-            let virtual_timer_manager = TimerManager::new(prof_clock.user_clock().clone());\n-            let prof_timer_manager = TimerManager::new(prof_clock.clone());\n-\n-            let posix_thread = PosixThread {\n-                process,\n-                name: Mutex::new(thread_name),\n-                set_child_tid: Mutex::new(set_child_tid),\n-                clear_child_tid: Mutex::new(clear_child_tid),\n-                credentials,\n-                sig_mask,\n-                sig_queues,\n-                sig_context: Mutex::new(None),\n-                sig_stack: Mutex::new(None),\n-                signalled_waker: SpinLock::new(None),\n-                robust_list: Mutex::new(None),\n-                prof_clock,\n-                virtual_timer_manager,\n-                prof_timer_manager,\n+        Arc::new_cyclic(|weak_task| {\n+            let posix_thread = {\n+                let prof_clock = ProfClock::new();\n+                let virtual_timer_manager = TimerManager::new(prof_clock.user_clock().clone());\n+                let prof_timer_manager = TimerManager::new(prof_clock.clone());\n+\n+                PosixThread {\n+                    process,\n+                    tid,\n+                    name: Mutex::new(thread_name),\n+                    set_child_tid: Mutex::new(set_child_tid),\n+                    clear_child_tid: Mutex::new(clear_child_tid),\n+                    credentials,\n+                    sig_mask,\n+                    sig_queues,\n+                    sig_context: Mutex::new(None),\n+                    sig_stack: Mutex::new(None),\n+                    signalled_waker: SpinLock::new(None),\n+                    robust_list: Mutex::new(None),\n+                    prof_clock,\n+                    virtual_timer_manager,\n+                    prof_timer_manager,\n+                }\n             };\n \n-            Thread::new(tid, task, posix_thread, status)\n-        });\n-        thread_table::add_thread(thread.clone());\n-        thread\n+            let status = ThreadStatus::Init;\n+            let thread = Arc::new(Thread::new(weak_task.clone(), posix_thread, status));\n+\n+            thread_table::add_thread(tid, thread.clone());\n+            task::create_new_user_task(user_space, thread)\n+        })\n     }\n }\ndiff --git a/kernel/src/process/posix_thread/exit.rs b/kernel/src/process/posix_thread/exit.rs\nindex 64a1d9d852..7143a7b6dc 100644\n--- a/kernel/src/process/posix_thread/exit.rs\n+++ b/kernel/src/process/posix_thread/exit.rs\n@@ -1,10 +1,10 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use super::{futex::futex_wake, robust_list::wake_robust_futex, PosixThread, PosixThreadExt};\n+use super::{futex::futex_wake, robust_list::wake_robust_futex, thread_table, PosixThread};\n use crate::{\n     prelude::*,\n     process::{do_exit_group, TermStatus},\n-    thread::{thread_table, Thread, Tid},\n+    thread::{Thread, Tid},\n };\n \n /// Exits the thread if the thread is a POSIX thread.\n@@ -12,15 +12,13 @@ use crate::{\n /// # Panics\n ///\n /// If the thread is not a POSIX thread, this method will panic.\n-pub fn do_exit(thread: Arc<Thread>, term_status: TermStatus) -> Result<()> {\n+pub fn do_exit(thread: &Thread, posix_thread: &PosixThread, term_status: TermStatus) -> Result<()> {\n     if thread.status().is_exited() {\n         return Ok(());\n     }\n     thread.exit();\n \n-    let tid = thread.tid();\n-\n-    let posix_thread = thread.as_posix_thread().unwrap();\n+    let tid = posix_thread.tid;\n \n     let mut clear_ctid = posix_thread.clear_child_tid().lock();\n     // If clear_ctid !=0 ,do a futex wake and write zero to the clear_ctid addr.\ndiff --git a/kernel/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\nindex 49f70f55f2..2cef30b227 100644\n--- a/kernel/src/process/posix_thread/mod.rs\n+++ b/kernel/src/process/posix_thread/mod.rs\n@@ -2,7 +2,7 @@\n \n #![allow(dead_code)]\n \n-use core::sync::atomic::Ordering;\n+use core::sync::atomic::{AtomicU32, Ordering};\n \n use aster_rights::{ReadOp, WriteOp};\n use ostd::sync::Waker;\n@@ -22,7 +22,7 @@ use crate::{\n     events::Observer,\n     prelude::*,\n     process::signal::constants::SIGCONT,\n-    thread::Tid,\n+    thread::{Thread, Tid},\n     time::{clocks::ProfClock, Timer, TimerManager},\n };\n \n@@ -32,16 +32,19 @@ pub mod futex;\n mod name;\n mod posix_thread_ext;\n mod robust_list;\n+pub mod thread_table;\n \n pub use builder::PosixThreadBuilder;\n pub use exit::do_exit;\n pub use name::{ThreadName, MAX_THREAD_NAME_LEN};\n-pub use posix_thread_ext::PosixThreadExt;\n+pub use posix_thread_ext::{create_posix_task_from_executable, PosixThreadExt};\n pub use robust_list::RobustListHead;\n \n pub struct PosixThread {\n     // Immutable part\n     process: Weak<Process>,\n+    tid: Tid,\n+\n     // Mutable part\n     name: Mutex<Option<ThreadName>>,\n \n@@ -87,6 +90,11 @@ impl PosixThread {\n         Weak::clone(&self.process)\n     }\n \n+    /// Returns the thread id\n+    pub fn tid(&self) -> Tid {\n+        self.tid\n+    }\n+\n     pub fn thread_name(&self) -> &Mutex<Option<ThreadName>> {\n         &self.name\n     }\n@@ -266,12 +274,10 @@ impl PosixThread {\n \n     fn is_last_thread(&self) -> bool {\n         let process = self.process.upgrade().unwrap();\n-        let threads = process.threads().lock();\n-        threads\n+        let tasks = process.tasks().lock();\n+        tasks\n             .iter()\n-            .filter(|thread| !thread.status().is_exited())\n-            .count()\n-            == 0\n+            .any(|task| !Thread::borrow_from_task(task).status().is_exited())\n     }\n \n     /// Gets the read-only credentials of the thread.\n@@ -292,3 +298,10 @@ impl PosixThread {\n         self.credentials.dup().restrict()\n     }\n }\n+\n+static POSIX_TID_ALLOCATOR: AtomicU32 = AtomicU32::new(0);\n+\n+/// Allocates a new tid for the new posix thread\n+pub fn allocate_posix_tid() -> Tid {\n+    POSIX_TID_ALLOCATOR.fetch_add(1, Ordering::SeqCst)\n+}\ndiff --git a/kernel/src/process/posix_thread/posix_thread_ext.rs b/kernel/src/process/posix_thread/posix_thread_ext.rs\nindex 012da12257..eac3cbb680 100644\n--- a/kernel/src/process/posix_thread/posix_thread_ext.rs\n+++ b/kernel/src/process/posix_thread/posix_thread_ext.rs\n@@ -2,6 +2,7 @@\n \n use ostd::{\n     cpu::UserContext,\n+    task::Task,\n     user::{UserContextApi, UserSpace},\n };\n \n@@ -13,52 +14,57 @@ use crate::{\n     thread::{Thread, Tid},\n };\n pub trait PosixThreadExt {\n+    /// Returns the thread id.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If the thread is not posix thread, this method will panic.\n+    fn tid(&self) -> Tid {\n+        self.as_posix_thread().unwrap().tid()\n+    }\n     fn as_posix_thread(&self) -> Option<&PosixThread>;\n-    #[allow(clippy::too_many_arguments)]\n-    fn new_posix_thread_from_executable(\n-        tid: Tid,\n-        credentials: Credentials,\n-        process_vm: &ProcessVm,\n-        fs_resolver: &FsResolver,\n-        executable_path: &str,\n-        process: Weak<Process>,\n-        argv: Vec<CString>,\n-        envp: Vec<CString>,\n-    ) -> Result<Arc<Self>>;\n }\n \n impl PosixThreadExt for Thread {\n-    /// This function should only be called when launch shell()\n-    fn new_posix_thread_from_executable(\n-        tid: Tid,\n-        credentials: Credentials,\n-        process_vm: &ProcessVm,\n-        fs_resolver: &FsResolver,\n-        executable_path: &str,\n-        process: Weak<Process>,\n-        argv: Vec<CString>,\n-        envp: Vec<CString>,\n-    ) -> Result<Arc<Self>> {\n-        let elf_file = {\n-            let fs_path = FsPath::new(AT_FDCWD, executable_path)?;\n-            fs_resolver.lookup(&fs_path)?\n-        };\n-        let (_, elf_load_info) =\n-            load_program_to_vm(process_vm, elf_file, argv, envp, fs_resolver, 1)?;\n-\n-        let vm_space = process_vm.root_vmar().vm_space().clone();\n-        let mut cpu_ctx = UserContext::default();\n-        cpu_ctx.set_instruction_pointer(elf_load_info.entry_point() as _);\n-        cpu_ctx.set_stack_pointer(elf_load_info.user_stack_top() as _);\n-        let user_space = Arc::new(UserSpace::new(vm_space, cpu_ctx));\n-        let thread_name = Some(ThreadName::new_from_executable_path(executable_path)?);\n-        let thread_builder = PosixThreadBuilder::new(tid, user_space, credentials)\n-            .thread_name(thread_name)\n-            .process(process);\n-        Ok(thread_builder.build())\n+    fn as_posix_thread(&self) -> Option<&PosixThread> {\n+        self.data().downcast_ref::<PosixThread>()\n     }\n+}\n \n+impl PosixThreadExt for Arc<Task> {\n     fn as_posix_thread(&self) -> Option<&PosixThread> {\n-        self.data().downcast_ref::<PosixThread>()\n+        Thread::borrow_from_task(self).as_posix_thread()\n     }\n }\n+\n+/// Creates a task for running an executable file.\n+///\n+/// This function should _only_ be used to create the init user task.\n+#[allow(clippy::too_many_arguments)]\n+pub fn create_posix_task_from_executable(\n+    tid: Tid,\n+    credentials: Credentials,\n+    process_vm: &ProcessVm,\n+    fs_resolver: &FsResolver,\n+    executable_path: &str,\n+    process: Weak<Process>,\n+    argv: Vec<CString>,\n+    envp: Vec<CString>,\n+) -> Result<Arc<Task>> {\n+    let elf_file = {\n+        let fs_path = FsPath::new(AT_FDCWD, executable_path)?;\n+        fs_resolver.lookup(&fs_path)?\n+    };\n+    let (_, elf_load_info) = load_program_to_vm(process_vm, elf_file, argv, envp, fs_resolver, 1)?;\n+\n+    let vm_space = process_vm.root_vmar().vm_space().clone();\n+    let mut cpu_ctx = UserContext::default();\n+    cpu_ctx.set_instruction_pointer(elf_load_info.entry_point() as _);\n+    cpu_ctx.set_stack_pointer(elf_load_info.user_stack_top() as _);\n+    let user_space = Arc::new(UserSpace::new(vm_space, cpu_ctx));\n+    let thread_name = Some(ThreadName::new_from_executable_path(executable_path)?);\n+    let thread_builder = PosixThreadBuilder::new(tid, user_space, credentials)\n+        .thread_name(thread_name)\n+        .process(process);\n+    Ok(thread_builder.build())\n+}\ndiff --git a/kernel/src/process/posix_thread/thread_table.rs b/kernel/src/process/posix_thread/thread_table.rs\nnew file mode 100644\nindex 0000000000..fc8f1e88da\n--- /dev/null\n+++ b/kernel/src/process/posix_thread/thread_table.rs\n@@ -0,0 +1,22 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+use super::{Thread, Tid};\n+use crate::{prelude::*, process::posix_thread::PosixThreadExt};\n+\n+static THREAD_TABLE: SpinLock<BTreeMap<Tid, Arc<Thread>>> = SpinLock::new(BTreeMap::new());\n+\n+/// Adds a posix thread to global thread table\n+pub fn add_thread(tid: Tid, thread: Arc<Thread>) {\n+    debug_assert_eq!(tid, thread.tid());\n+    THREAD_TABLE.lock().insert(tid, thread);\n+}\n+\n+/// Removes a posix thread to global thread table\n+pub fn remove_thread(tid: Tid) {\n+    THREAD_TABLE.lock().remove(&tid);\n+}\n+\n+/// Gets a posix thread from the global thread table\n+pub fn get_thread(tid: Tid) -> Option<Arc<Thread>> {\n+    THREAD_TABLE.lock().get(&tid).cloned()\n+}\ndiff --git a/kernel/src/process/process/builder.rs b/kernel/src/process/process/builder.rs\nindex f645221e64..5f296b6949 100644\n--- a/kernel/src/process/process/builder.rs\n+++ b/kernel/src/process/process/builder.rs\n@@ -7,14 +7,13 @@ use crate::{\n     fs::{file_table::FileTable, fs_resolver::FsResolver, utils::FileCreationMask},\n     prelude::*,\n     process::{\n-        posix_thread::{PosixThreadBuilder, PosixThreadExt},\n+        posix_thread::{create_posix_task_from_executable, PosixThreadBuilder},\n         process_vm::ProcessVm,\n         rlimit::ResourceLimits,\n         signal::sig_disposition::SigDispositions,\n         Credentials,\n     },\n     sched::nice::Nice,\n-    thread::Thread,\n };\n \n pub struct ProcessBuilder<'a> {\n@@ -190,11 +189,11 @@ impl<'a> ProcessBuilder<'a> {\n             )\n         };\n \n-        let thread = if let Some(thread_builder) = main_thread_builder {\n+        let task = if let Some(thread_builder) = main_thread_builder {\n             let builder = thread_builder.process(Arc::downgrade(&process));\n             builder.build()\n         } else {\n-            Thread::new_posix_thread_from_executable(\n+            create_posix_task_from_executable(\n                 pid,\n                 credentials.unwrap(),\n                 process.vm(),\n@@ -206,7 +205,7 @@ impl<'a> ProcessBuilder<'a> {\n             )?\n         };\n \n-        process.threads().lock().push(thread);\n+        process.tasks().lock().push(task);\n \n         process.set_runnable();\n \ndiff --git a/kernel/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\nindex 68381cf6c2..b8dc35da39 100644\n--- a/kernel/src/process/process/mod.rs\n+++ b/kernel/src/process/process/mod.rs\n@@ -4,7 +4,7 @@ use core::sync::atomic::Ordering;\n \n use self::timer_manager::PosixTimerManager;\n use super::{\n-    posix_thread::PosixThreadExt,\n+    posix_thread::{allocate_posix_tid, PosixThreadExt},\n     process_table,\n     process_vm::{Heap, InitStackReader, ProcessVm},\n     rlimit::ResourceLimits,\n@@ -21,7 +21,7 @@ use crate::{\n     fs::{file_table::FileTable, fs_resolver::FsResolver, utils::FileCreationMask},\n     prelude::*,\n     sched::nice::Nice,\n-    thread::{allocate_tid, Thread},\n+    thread::Thread,\n     time::clocks::ProfClock,\n     vm::vmar::Vmar,\n };\n@@ -37,7 +37,7 @@ use aster_rights::Full;\n use atomic::Atomic;\n pub use builder::ProcessBuilder;\n pub use job_control::JobControl;\n-use ostd::sync::WaitQueue;\n+use ostd::{sync::WaitQueue, task::Task};\n pub use process_group::ProcessGroup;\n pub use session::Session;\n pub use terminal::Terminal;\n@@ -68,7 +68,7 @@ pub struct Process {\n     /// The executable path.\n     executable_path: RwLock<String>,\n     /// The threads\n-    threads: Mutex<Vec<Arc<Thread>>>,\n+    tasks: Mutex<Vec<Arc<Task>>>,\n     /// Process status\n     status: ProcessStatus,\n     /// Parent process\n@@ -167,14 +167,20 @@ impl Process {\n     ///  - the function is called in the bootstrap context;\n     ///  - or if the current task is not associated with a process.\n     pub fn current() -> Option<Arc<Process>> {\n-        Some(Thread::current()?.as_posix_thread()?.process())\n+        Some(\n+            Task::current()?\n+                .data()\n+                .downcast_ref::<Arc<Thread>>()?\n+                .as_posix_thread()?\n+                .process(),\n+        )\n     }\n \n     #[allow(clippy::too_many_arguments)]\n     fn new(\n         pid: Pid,\n         parent: Weak<Process>,\n-        threads: Vec<Arc<Thread>>,\n+        tasks: Vec<Arc<Task>>,\n         executable_path: String,\n         process_vm: ProcessVm,\n \n@@ -194,7 +200,7 @@ impl Process {\n \n         Arc::new_cyclic(|process_ref: &Weak<Process>| Self {\n             pid,\n-            threads: Mutex::new(threads),\n+            tasks: Mutex::new(tasks),\n             executable_path: RwLock::new(executable_path),\n             process_vm,\n             children_wait_queue,\n@@ -236,7 +242,7 @@ impl Process {\n         envp: Vec<CString>,\n     ) -> Result<Arc<Self>> {\n         let process_builder = {\n-            let pid = allocate_tid();\n+            let pid = allocate_posix_tid();\n             let parent = Weak::new();\n \n             let credentials = Credentials::new_root();\n@@ -271,13 +277,14 @@ impl Process {\n \n     /// start to run current process\n     pub fn run(&self) {\n-        let threads = self.threads.lock();\n+        let tasks = self.tasks.lock();\n         // when run the process, the process should has only one thread\n-        debug_assert!(threads.len() == 1);\n+        debug_assert!(tasks.len() == 1);\n         debug_assert!(self.is_runnable());\n-        let thread = threads[0].clone();\n+        let task = tasks[0].clone();\n         // should not hold the lock when run thread\n-        drop(threads);\n+        drop(tasks);\n+        let thread = Thread::borrow_from_task(&task);\n         thread.run();\n     }\n \n@@ -297,8 +304,8 @@ impl Process {\n         &self.timer_manager\n     }\n \n-    pub fn threads(&self) -> &Mutex<Vec<Arc<Thread>>> {\n-        &self.threads\n+    pub fn tasks(&self) -> &Mutex<Vec<Arc<Task>>> {\n+        &self.tasks\n     }\n \n     pub fn executable_path(&self) -> String {\n@@ -318,10 +325,11 @@ impl Process {\n     }\n \n     pub fn main_thread(&self) -> Option<Arc<Thread>> {\n-        self.threads\n+        self.tasks\n             .lock()\n             .iter()\n-            .find(|thread| thread.tid() == self.pid)\n+            .find(|task| task.tid() == self.pid)\n+            .map(Thread::borrow_from_task)\n             .cloned()\n     }\n \n@@ -644,7 +652,7 @@ impl Process {\n         // TODO: check that the signal is not user signal\n \n         // Enqueue signal to the first thread that does not block the signal\n-        let threads = self.threads.lock();\n+        let threads = self.tasks.lock();\n         for thread in threads.iter() {\n             let posix_thread = thread.as_posix_thread().unwrap();\n             if !posix_thread.has_signal_blocked(signal.num()) {\n@@ -710,7 +718,7 @@ mod test {\n     fn new_process(parent: Option<Arc<Process>>) -> Arc<Process> {\n         crate::util::random::init();\n         crate::fs::rootfs::init_root_mount();\n-        let pid = allocate_tid();\n+        let pid = allocate_posix_tid();\n         let parent = if let Some(parent) = parent {\n             Arc::downgrade(&parent)\n         } else {\ndiff --git a/kernel/src/process/signal/pause.rs b/kernel/src/process/signal/pause.rs\nindex f003752639..f9e686ff89 100644\n--- a/kernel/src/process/signal/pause.rs\n+++ b/kernel/src/process/signal/pause.rs\n@@ -86,16 +86,9 @@ impl Pause for Waiter {\n             return Ok(res);\n         }\n \n-        let current_thread = self\n-            .task()\n-            .data()\n-            .downcast_ref::<Weak<Thread>>()\n-            .and_then(|thread| thread.upgrade());\n-\n-        let Some(posix_thread) = current_thread\n-            .as_ref()\n-            .and_then(|thread| thread.as_posix_thread())\n-        else {\n+        let current_thread = self.task().data().downcast_ref::<Arc<Thread>>();\n+\n+        let Some(posix_thread) = current_thread.and_then(|thread| thread.as_posix_thread()) else {\n             if let Some(timeout) = timeout {\n                 return self.wait_until_or_timeout(cond, timeout);\n             } else {\ndiff --git a/kernel/src/process/wait.rs b/kernel/src/process/wait.rs\nindex 668c340bc6..3dfe35d79e 100644\n--- a/kernel/src/process/wait.rs\n+++ b/kernel/src/process/wait.rs\n@@ -2,12 +2,15 @@\n \n #![allow(dead_code)]\n \n-use super::{\n-    process_filter::ProcessFilter,\n-    signal::{constants::SIGCHLD, with_signal_blocked},\n-    ExitCode, Pid, Process,\n+use super::{process_filter::ProcessFilter, signal::constants::SIGCHLD, ExitCode, Pid, Process};\n+use crate::{\n+    prelude::*,\n+    process::{\n+        posix_thread::{thread_table, PosixThreadExt},\n+        process_table,\n+        signal::with_signal_blocked,\n+    },\n };\n-use crate::{prelude::*, process::process_table, thread::thread_table};\n \n // The definition of WaitOptions is from Occlum\n bitflags! {\n@@ -85,8 +88,8 @@ pub fn wait_child_exit(\n fn reap_zombie_child(process: &Process, pid: Pid) -> ExitCode {\n     let child_process = process.children().lock().remove(&pid).unwrap();\n     assert!(child_process.is_zombie());\n-    for thread in &*child_process.threads().lock() {\n-        thread_table::remove_thread(thread.tid());\n+    for task in &*child_process.tasks().lock() {\n+        thread_table::remove_thread(task.tid());\n     }\n \n     // Lock order: session table -> group table -> process table -> group of process\ndiff --git a/kernel/src/syscall/clock_gettime.rs b/kernel/src/syscall/clock_gettime.rs\nindex c4a6031df9..725e2dc966 100644\n--- a/kernel/src/syscall/clock_gettime.rs\n+++ b/kernel/src/syscall/clock_gettime.rs\n@@ -7,8 +7,10 @@ use int_to_c_enum::TryFromInt;\n use super::SyscallReturn;\n use crate::{\n     prelude::*,\n-    process::{posix_thread::PosixThreadExt, process_table},\n-    thread::thread_table,\n+    process::{\n+        posix_thread::{thread_table, PosixThreadExt},\n+        process_table,\n+    },\n     time::{\n         clockid_t,\n         clocks::{\ndiff --git a/kernel/src/syscall/exit.rs b/kernel/src/syscall/exit.rs\nindex 48917479f9..d8c1805a14 100644\n--- a/kernel/src/syscall/exit.rs\n+++ b/kernel/src/syscall/exit.rs\n@@ -6,12 +6,11 @@ use crate::{\n     syscall::SyscallReturn,\n };\n \n-pub fn sys_exit(exit_code: i32, _ctx: &Context) -> Result<SyscallReturn> {\n+pub fn sys_exit(exit_code: i32, ctx: &Context) -> Result<SyscallReturn> {\n     debug!(\"exid code = {}\", exit_code);\n \n-    let current_thread = current_thread!();\n     let term_status = TermStatus::Exited(exit_code as _);\n-    do_exit(current_thread, term_status)?;\n+    do_exit(ctx.thread, ctx.posix_thread, term_status)?;\n \n     Ok(SyscallReturn::Return(0))\n }\ndiff --git a/kernel/src/syscall/futex.rs b/kernel/src/syscall/futex.rs\nindex b9fbcb888e..5e28a98799 100644\n--- a/kernel/src/syscall/futex.rs\n+++ b/kernel/src/syscall/futex.rs\n@@ -71,6 +71,6 @@ pub fn sys_futex(\n         _ => panic!(\"Unsupported futex operations\"),\n     }?;\n \n-    debug!(\"futex returns, tid= {} \", ctx.thread.tid());\n+    debug!(\"futex returns, tid= {} \", ctx.posix_thread.tid());\n     Ok(SyscallReturn::Return(res as _))\n }\ndiff --git a/kernel/src/syscall/gettid.rs b/kernel/src/syscall/gettid.rs\nindex b51f992c99..18f67c1471 100644\n--- a/kernel/src/syscall/gettid.rs\n+++ b/kernel/src/syscall/gettid.rs\n@@ -4,6 +4,6 @@ use super::SyscallReturn;\n use crate::prelude::*;\n \n pub fn sys_gettid(ctx: &Context) -> Result<SyscallReturn> {\n-    let tid = ctx.thread.tid();\n+    let tid = ctx.posix_thread.tid();\n     Ok(SyscallReturn::Return(tid as _))\n }\ndiff --git a/kernel/src/syscall/mod.rs b/kernel/src/syscall/mod.rs\nindex fbe453d1a5..9d96c90976 100644\n--- a/kernel/src/syscall/mod.rs\n+++ b/kernel/src/syscall/mod.rs\n@@ -345,7 +345,10 @@ macro_rules! log_syscall_entry {\n         if log::log_enabled!(log::Level::Info) {\n             let syscall_name_str = stringify!($syscall_name);\n             let pid = $crate::current!().pid();\n-            let tid = $crate::current_thread!().tid();\n+            let tid = {\n+                use $crate::process::posix_thread::PosixThreadExt;\n+                $crate::current_thread!().tid()\n+            };\n             log::info!(\n                 \"[pid={}][tid={}][id={}][{}]\",\n                 pid,\ndiff --git a/kernel/src/syscall/set_tid_address.rs b/kernel/src/syscall/set_tid_address.rs\nindex cc7e5df39f..d682d4cc82 100644\n--- a/kernel/src/syscall/set_tid_address.rs\n+++ b/kernel/src/syscall/set_tid_address.rs\n@@ -13,6 +13,6 @@ pub fn sys_set_tid_address(tidptr: Vaddr, ctx: &Context) -> Result<SyscallReturn\n     } else {\n         *clear_child_tid = tidptr;\n     }\n-    let tid = ctx.thread.tid();\n+    let tid = ctx.posix_thread.tid();\n     Ok(SyscallReturn::Return(tid as _))\n }\ndiff --git a/kernel/src/syscall/timer_create.rs b/kernel/src/syscall/timer_create.rs\nindex 297567aaaf..5723e36bb8 100644\n--- a/kernel/src/syscall/timer_create.rs\n+++ b/kernel/src/syscall/timer_create.rs\n@@ -7,7 +7,7 @@ use super::{\n use crate::{\n     prelude::*,\n     process::{\n-        posix_thread::PosixThreadExt,\n+        posix_thread::{thread_table, PosixThreadExt},\n         process_table,\n         signal::{\n             c_types::{sigevent_t, SigNotify},\n@@ -17,10 +17,7 @@ use crate::{\n         },\n     },\n     syscall::ClockId,\n-    thread::{\n-        thread_table,\n-        work_queue::{submit_work_item, work_item::WorkItem},\n-    },\n+    thread::work_queue::{submit_work_item, work_item::WorkItem},\n     time::{\n         clockid_t,\n         clocks::{BootTimeClock, MonotonicClock, RealTimeClock},\ndiff --git a/kernel/src/thread/kernel_thread.rs b/kernel/src/thread/kernel_thread.rs\nindex 461e22827a..e613ceccfb 100644\n--- a/kernel/src/thread/kernel_thread.rs\n+++ b/kernel/src/thread/kernel_thread.rs\n@@ -2,23 +2,22 @@\n \n use ostd::{\n     cpu::CpuSet,\n-    task::{Priority, TaskOptions},\n+    task::{Priority, Task, TaskOptions},\n };\n \n-use super::{allocate_tid, status::ThreadStatus, thread_table, Thread};\n+use super::{status::ThreadStatus, Thread};\n use crate::prelude::*;\n \n /// The inner data of a kernel thread\n pub struct KernelThread;\n \n pub trait KernelThreadExt {\n-    /// get the kernel_thread structure\n+    /// Gets the kernel_thread structure\n     fn as_kernel_thread(&self) -> Option<&KernelThread>;\n-    /// create a new kernel thread structure, **NOT** run the thread.\n-    fn new_kernel_thread(thread_options: ThreadOptions) -> Arc<Thread>;\n-    /// create a new kernel thread structure, and then run the thread.\n+    /// Creates a new kernel thread, and then run the thread.\n     fn spawn_kernel_thread(thread_options: ThreadOptions) -> Arc<Thread> {\n-        let thread = Self::new_kernel_thread(thread_options);\n+        let task = create_new_kernel_task(thread_options);\n+        let thread = Thread::borrow_from_task(&task).clone();\n         thread.run();\n         thread\n     }\n@@ -31,31 +30,6 @@ impl KernelThreadExt for Thread {\n         self.data().downcast_ref::<KernelThread>()\n     }\n \n-    fn new_kernel_thread(mut thread_options: ThreadOptions) -> Arc<Self> {\n-        let task_fn = thread_options.take_func();\n-        let thread_fn = move || {\n-            task_fn();\n-            let current_thread = current_thread!();\n-            // ensure the thread is exit\n-            current_thread.exit();\n-        };\n-        let tid = allocate_tid();\n-        let thread = Arc::new_cyclic(|thread_ref| {\n-            let weal_thread = thread_ref.clone();\n-            let task = TaskOptions::new(thread_fn)\n-                .data(weal_thread)\n-                .priority(thread_options.priority)\n-                .cpu_affinity(thread_options.cpu_affinity)\n-                .build()\n-                .unwrap();\n-            let status = ThreadStatus::Init;\n-            let kernel_thread = KernelThread;\n-            Thread::new(tid, task, kernel_thread, status)\n-        });\n-        thread_table::add_thread(thread.clone());\n-        thread\n-    }\n-\n     fn join(&self) {\n         loop {\n             if self.status().is_exited() {\n@@ -67,6 +41,31 @@ impl KernelThreadExt for Thread {\n     }\n }\n \n+/// Creates a new task of kernel thread, **NOT** run the thread.\n+pub fn create_new_kernel_task(mut thread_options: ThreadOptions) -> Arc<Task> {\n+    let task_fn = thread_options.take_func();\n+    let thread_fn = move || {\n+        task_fn();\n+        // Ensures the thread is exit\n+        current_thread!().exit();\n+    };\n+\n+    Arc::new_cyclic(|weak_task| {\n+        let thread = {\n+            let kernel_thread = KernelThread;\n+            let status = ThreadStatus::Init;\n+            Arc::new(Thread::new(weak_task.clone(), kernel_thread, status))\n+        };\n+\n+        TaskOptions::new(thread_fn)\n+            .data(thread)\n+            .priority(thread_options.priority)\n+            .cpu_affinity(thread_options.cpu_affinity)\n+            .build()\n+            .unwrap()\n+    })\n+}\n+\n /// Options to create or spawn a new thread.\n pub struct ThreadOptions {\n     func: Option<Box<dyn Fn() + Send + Sync>>,\ndiff --git a/kernel/src/thread/mod.rs b/kernel/src/thread/mod.rs\nindex cb7249fe75..43f27d59f2 100644\n--- a/kernel/src/thread/mod.rs\n+++ b/kernel/src/thread/mod.rs\n@@ -2,7 +2,7 @@\n \n //! Posix thread implementation\n \n-use core::sync::atomic::{AtomicU32, Ordering};\n+use core::sync::atomic::Ordering;\n \n use ostd::task::Task;\n \n@@ -13,20 +13,15 @@ pub mod exception;\n pub mod kernel_thread;\n pub mod status;\n pub mod task;\n-pub mod thread_table;\n pub mod work_queue;\n \n pub type Tid = u32;\n \n-static TID_ALLOCATOR: AtomicU32 = AtomicU32::new(0);\n-\n /// A thread is a wrapper on top of task.\n pub struct Thread {\n     // immutable part\n-    /// Thread id\n-    tid: Tid,\n     /// Low-level info\n-    task: Arc<Task>,\n+    task: Weak<Task>,\n     /// Data: Posix thread info/Kernel thread Info\n     data: Box<dyn Send + Sync + Any>,\n \n@@ -36,14 +31,8 @@ pub struct Thread {\n \n impl Thread {\n     /// Never call these function directly\n-    pub fn new(\n-        tid: Tid,\n-        task: Arc<Task>,\n-        data: impl Send + Sync + Any,\n-        status: ThreadStatus,\n-    ) -> Self {\n+    pub fn new(task: Weak<Task>, data: impl Send + Sync + Any, status: ThreadStatus) -> Self {\n         Thread {\n-            tid,\n             task,\n             data: Box::new(data),\n             status: AtomicThreadStatus::new(status),\n@@ -57,18 +46,23 @@ impl Thread {\n     pub fn current() -> Option<Arc<Self>> {\n         Task::current()?\n             .data()\n-            .downcast_ref::<Weak<Thread>>()?\n-            .upgrade()\n+            .downcast_ref::<Arc<Thread>>()\n+            .cloned()\n     }\n \n-    pub(in crate::thread) fn task(&self) -> &Arc<Task> {\n-        &self.task\n+    /// Gets the Thread from task's data.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method panics if the task is not a thread.\n+    pub fn borrow_from_task(task: &Arc<Task>) -> &Arc<Self> {\n+        task.data().downcast_ref::<Arc<Thread>>().unwrap()\n     }\n \n     /// Runs this thread at once.\n     pub fn run(&self) {\n         self.set_status(ThreadStatus::Running);\n-        self.task.run();\n+        self.task.upgrade().unwrap().run();\n     }\n \n     pub(super) fn exit(&self) {\n@@ -94,10 +88,6 @@ impl Thread {\n         Task::yield_now()\n     }\n \n-    pub fn tid(&self) -> Tid {\n-        self.tid\n-    }\n-\n     /// Returns the associated data.\n     ///\n     /// The return type must be borrowed box, otherwise the `downcast_ref` will fail.\n@@ -106,8 +96,3 @@ impl Thread {\n         &self.data\n     }\n }\n-\n-/// Allocates a new tid for the new thread\n-pub fn allocate_tid() -> Tid {\n-    TID_ALLOCATOR.fetch_add(1, Ordering::SeqCst)\n-}\ndiff --git a/kernel/src/thread/task.rs b/kernel/src/thread/task.rs\nindex d7b6ed3c45..ee8b120d8e 100644\n--- a/kernel/src/thread/task.rs\n+++ b/kernel/src/thread/task.rs\n@@ -16,12 +16,12 @@ use crate::{\n };\n \n /// create new task with userspace and parent process\n-pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>) -> Arc<Task> {\n+pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Arc<Thread>) -> Task {\n     fn user_task_entry() {\n         let current_thread = current_thread!();\n         let current_posix_thread = current_thread.as_posix_thread().unwrap();\n         let current_process = current_posix_thread.process();\n-        let current_task = current_thread.task();\n+        let current_task = Task::current().unwrap();\n \n         let user_space = current_task\n             .user_space()\n@@ -47,7 +47,7 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n         // in the child process.\n         if is_userspace_vaddr(child_tid_ptr) {\n             CurrentUserSpace::get()\n-                .write_val(child_tid_ptr, &current_thread.tid())\n+                .write_val(child_tid_ptr, &current_posix_thread.tid())\n                 .unwrap();\n         }\n \n@@ -77,7 +77,7 @@ pub fn create_new_user_task(user_space: Arc<UserSpace>, thread_ref: Weak<Thread>\n             // If current is suspended, wait for a signal to wake up self\n             while current_thread.status().is_stopped() {\n                 Thread::yield_now();\n-                debug!(\"{} is suspended.\", current_thread.tid());\n+                debug!(\"{} is suspended.\", current_posix_thread.tid());\n                 handle_pending_signal(user_ctx, &current_thread).unwrap();\n             }\n             if current_thread.status().is_exited() {\ndiff --git a/kernel/src/thread/thread_table.rs b/kernel/src/thread/thread_table.rs\ndeleted file mode 100644\nindex 8f92a33403..0000000000\n--- a/kernel/src/thread/thread_table.rs\n+++ /dev/null\n@@ -1,21 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-use super::{Thread, Tid};\n-use crate::prelude::*;\n-\n-lazy_static! {\n-    static ref THREAD_TABLE: SpinLock<BTreeMap<Tid, Arc<Thread>>> = SpinLock::new(BTreeMap::new());\n-}\n-\n-pub fn add_thread(thread: Arc<Thread>) {\n-    let tid = thread.tid();\n-    THREAD_TABLE.lock().insert(tid, thread);\n-}\n-\n-pub fn remove_thread(tid: Tid) {\n-    THREAD_TABLE.lock().remove(&tid);\n-}\n-\n-pub fn get_thread(tid: Tid) -> Option<Arc<Thread>> {\n-    THREAD_TABLE.lock().get(&tid).cloned()\n-}\ndiff --git a/kernel/src/thread/work_queue/worker.rs b/kernel/src/thread/work_queue/worker.rs\nindex 173af08f99..0a38c2944b 100644\n--- a/kernel/src/thread/work_queue/worker.rs\n+++ b/kernel/src/thread/work_queue/worker.rs\n@@ -2,12 +2,15 @@\n \n #![allow(dead_code)]\n \n-use ostd::{cpu::CpuSet, task::Priority};\n+use ostd::{\n+    cpu::CpuSet,\n+    task::{Priority, Task},\n+};\n \n use super::worker_pool::WorkerPool;\n use crate::{\n     prelude::*,\n-    thread::kernel_thread::{KernelThreadExt, ThreadOptions},\n+    thread::kernel_thread::{create_new_kernel_task, ThreadOptions},\n     Thread,\n };\n \n@@ -17,7 +20,7 @@ use crate::{\n /// added to the `WorkerPool`.\n pub(super) struct Worker {\n     worker_pool: Weak<WorkerPool>,\n-    bound_thread: Arc<Thread>,\n+    bound_task: Arc<Task>,\n     bound_cpu: u32,\n     inner: SpinLock<WorkerInner>,\n }\n@@ -51,14 +54,14 @@ impl Worker {\n             if worker_pool.upgrade().unwrap().is_high_priority() {\n                 priority = Priority::high();\n             }\n-            let bound_thread = Thread::new_kernel_thread(\n+            let bound_task = create_new_kernel_task(\n                 ThreadOptions::new(task_fn)\n                     .cpu_affinity(cpu_affinity)\n                     .priority(priority),\n             );\n             Self {\n                 worker_pool,\n-                bound_thread,\n+                bound_task,\n                 bound_cpu,\n                 inner: SpinLock::new(WorkerInner {\n                     worker_status: WorkerStatus::Running,\n@@ -68,7 +71,8 @@ impl Worker {\n     }\n \n     pub(super) fn run(&self) {\n-        self.bound_thread.run();\n+        let thread = Thread::borrow_from_task(&self.bound_task);\n+        thread.run();\n     }\n \n     /// The thread function bound to normal workers.\n@@ -97,8 +101,8 @@ impl Worker {\n         self.exit();\n     }\n \n-    pub(super) fn bound_thread(&self) -> &Arc<Thread> {\n-        &self.bound_thread\n+    pub(super) fn bound_task(&self) -> &Arc<Task> {\n+        &self.bound_task\n     }\n \n     pub(super) fn is_idle(&self) -> bool {\ndiff --git a/kernel/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\nindex c1a5b467de..6b9425d371 100644\n--- a/kernel/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/src/thread/work_queue/worker_pool.rs\n@@ -7,12 +7,16 @@ use core::{\n     time::Duration,\n };\n \n-use ostd::{cpu::CpuSet, sync::WaitQueue, task::Priority};\n+use ostd::{\n+    cpu::CpuSet,\n+    sync::WaitQueue,\n+    task::{Priority, Task},\n+};\n \n use super::{simple_scheduler::SimpleScheduler, worker::Worker, WorkItem, WorkPriority, WorkQueue};\n use crate::{\n     prelude::*,\n-    thread::kernel_thread::{KernelThreadExt, ThreadOptions},\n+    thread::kernel_thread::{create_new_kernel_task, ThreadOptions},\n     Thread,\n };\n \n@@ -60,7 +64,7 @@ pub trait WorkerScheduler: Sync + Send {\n /// are found processing in the pool.\n pub struct Monitor {\n     worker_pool: Weak<WorkerPool>,\n-    bound_thread: Arc<Thread>,\n+    bound_task: Arc<Task>,\n }\n \n impl LocalWorkerPool {\n@@ -77,7 +81,7 @@ impl LocalWorkerPool {\n     fn add_worker(&self) {\n         let worker = Worker::new(self.parent.clone(), self.cpu_id);\n         self.workers.disable_irq().lock().push_back(worker.clone());\n-        worker.bound_thread().run();\n+        Thread::borrow_from_task(worker.bound_task()).run();\n     }\n \n     fn remove_worker(&self) {\n@@ -236,20 +240,20 @@ impl Monitor {\n                 WorkPriority::High => Priority::high(),\n                 WorkPriority::Normal => Priority::normal(),\n             };\n-            let bound_thread = Thread::new_kernel_thread(\n+            let bound_task = create_new_kernel_task(\n                 ThreadOptions::new(task_fn)\n                     .cpu_affinity(cpu_affinity)\n                     .priority(priority),\n             );\n             Self {\n                 worker_pool,\n-                bound_thread,\n+                bound_task,\n             }\n         })\n     }\n \n     pub fn run(&self) {\n-        self.bound_thread.run();\n+        Thread::borrow_from_task(&self.bound_task).run()\n     }\n \n     fn run_monitor_loop(self: &Arc<Self>) {\ndiff --git a/ostd/src/task/mod.rs b/ostd/src/task/mod.rs\nindex 253caf09a2..e99da2ba7f 100644\n--- a/ostd/src/task/mod.rs\n+++ b/ostd/src/task/mod.rs\n@@ -166,7 +166,7 @@ impl TaskOptions {\n     }\n \n     /// Builds a new task without running it immediately.\n-    pub fn build(self) -> Result<Arc<Task>> {\n+    pub fn build(self) -> Result<Task> {\n         /// all task will entering this function\n         /// this function is mean to executing the task_fn in Task\n         extern \"C\" fn kernel_task_entry() {\n@@ -201,12 +201,12 @@ impl TaskOptions {\n         // have any arguments, so we only need to align the stack pointer to 16 bytes.\n         ctx.set_stack_pointer(crate::mm::paddr_to_vaddr(new_task.kstack.end_paddr() - 16));\n \n-        Ok(Arc::new(new_task))\n+        Ok(new_task)\n     }\n \n     /// Builds a new task and run it immediately.\n     pub fn spawn(self) -> Result<Arc<Task>> {\n-        let task = self.build()?;\n+        let task = Arc::new(self.build()?);\n         task.run();\n         Ok(task)\n     }\n@@ -237,11 +237,13 @@ mod test {\n         let task = || {\n             assert_eq!(1, 1);\n         };\n-        let task_option = crate::task::TaskOptions::new(task)\n-            .data(())\n-            .build()\n-            .unwrap();\n-        task_option.run();\n+        let task = Arc::new(\n+            crate::task::TaskOptions::new(task)\n+                .data(())\n+                .build()\n+                .unwrap(),\n+        );\n+        task.run();\n     }\n \n     #[ktest]\n", "test_patch": "diff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\nindex 23618110b8..7c7c9f4348 100644\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -102,11 +102,13 @@ fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n     // Kernel tasks are managed by the Framework,\n     // while scheduling algorithms for them can be\n     // determined by the users of the Framework.\n-    TaskOptions::new(user_task)\n-        .user_space(Some(user_space))\n-        .data(0)\n-        .build()\n-        .unwrap()\n+    Arc::new(\n+        TaskOptions::new(user_task)\n+            .user_space(Some(user_space))\n+            .data(0)\n+            .build()\n+            .unwrap(),\n+    )\n }\n \n fn handle_syscall(user_context: &mut UserContext, user_space: &UserSpace) {\n", "problem_statement": "Reachable unwrap panic in `read_clock()`\n### Describe the bug\r\nThere is a reachable unwrap panic in `read_clock()` at kernel/src/syscall/clock_gettime.rs:141 when make a `clock_gettime` syscall with specific argument.\r\n\r\nhttps://github.com/asterinas/asterinas/blob/aa77747f94c4b1cb1237ba52414642827a6efc25/kernel/src/syscall/clock_gettime.rs#L141\r\n\r\n\r\n### To Reproduce\r\n1. Compile a program which calls `clock_gettime`:\r\n```C\r\n#include <errno.h>\r\n#include <stdio.h>\r\n#include <sys/syscall.h>\r\n#include <time.h>\r\n#include <unistd.h>\r\n\r\nint main() {\r\n  clock_gettime(-10, 0x1);\r\n  perror(\"clock_gettime\");\r\n\r\n  return 0;\r\n}\r\n```\r\n2. Run the compiled program in Asterinas.\r\n\r\n### Expected behavior\r\nAsterinas reports panic and is terminated.\r\n\r\n### Environment\r\n- Official docker asterinas/asterinas:0.8.0\r\n- 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz\r\n- Asterinas version: main aa77747f\r\n\r\n### Logs\r\n\r\n```\r\n~ # /root/clock_gettime.c \r\npanicked at /root/asterinas/kernel/src/syscall/clock_gettime.rs:141:61:\r\ncalled `Option::unwrap()` on a `None` value\r\nPrinting stack trace:\r\n   1: fn 0xffffffff8880e1c0 - pc 0xffffffff8880e1d8 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f6297c0;\r\n\r\n   2: fn 0xffffffff8880dfa0 - pc 0xffffffff8880e118 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f6297d0;\r\n\r\n   3: fn 0xffffffff88049000 - pc 0xffffffff8804900a / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629950;\r\n\r\n   4: fn 0xffffffff889b0fb0 - pc 0xffffffff889b1032 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629960;\r\n\r\n   5: fn 0xffffffff889b1150 - pc 0xffffffff889b1190 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f6299f0;\r\n\r\n   6: fn 0xffffffff8899a710 - pc 0xffffffff8899a725 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629a60;\r\n\r\n   7: fn 0xffffffff884f2290 - pc 0xffffffff884f289f / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629a70;\r\n\r\n   8: fn 0xffffffff884f1d20 - pc 0xffffffff884f1d81 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629d30;\r\n\r\n   9: fn 0xffffffff88161a50 - pc 0xffffffff8818d4ab / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f629f30;\r\n\r\n  10: fn 0xffffffff88152f60 - pc 0xffffffff88152fee / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f6403d0;\r\n\r\n  11: fn 0xffffffff88110380 - pc 0xffffffff88110eff / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f640570;\r\n\r\n  12: fn 0xffffffff8845cb70 - pc 0xffffffff8845cb7e / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f640f90;\r\n\r\n  13: fn 0xffffffff887cdc50 - pc 0xffffffff887cdc66 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f640fb0;\r\n\r\n  14: fn 0xffffffff887b0280 - pc 0xffffffff887b02e9 / registers:\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f640fd0;\r\n\r\n\r\n     rax               0x12; rdx 0xffffffff88a3a1a0; rcx                0x1; rbx                0x0;\r\n     rsi                0x0; rdi                0x0; rbp                0x0; rsp 0xffff80007f641000;\r\n\r\n[OSDK] The kernel seems panicked. Parsing stack trace for source lines:\r\n(  1) /root/asterinas/ostd/src/panicking.rs:106\r\n(  2) /root/asterinas/ostd/src/panicking.rs:59\r\n(  3) 89yvfinwjerz0clyodmhm6lzz:?\r\n(  4) ??:?\r\n(  5) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panicking.rs:220\r\n(  6) ??:?\r\n(  7) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:961\r\n(  8) /root/asterinas/kernel/src/syscall/clock_gettime.rs:29\r\n(  9) /root/asterinas/kernel/src/syscall/mod.rs:164\r\n( 10) /root/asterinas/kernel/src/syscall/mod.rs:328\r\n( 11) /root/asterinas/kernel/src/thread/task.rs:69\r\n( 12) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:79\r\n( 13) /root/.rustup/toolchains/nightly-2024-06-20-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/boxed.rs:2077\r\n( 14) /root/asterinas/ostd/src/task/task/mod.rs:341\r\nmake: *** [Makefile:167: run] Error 1\r\n```\n", "hints_text": "", "created_at": "2024-09-12T06:03:09Z", "version": "0.8"}, {"repo": "asterinas/asterinas", "pull_number": 1159, "instance_id": "asterinas__asterinas-1159", "issue_numbers": ["975"], "base_commit": "c2a83427520f8263a8eb2c36edacdba261ad5cae", "patch": "diff --git a/.github/workflows/benchmark_asterinas.yml b/.github/workflows/benchmark_asterinas.yml\nindex acdd3f0461..718e61be3b 100644\n--- a/.github/workflows/benchmark_asterinas.yml\n+++ b/.github/workflows/benchmark_asterinas.yml\n@@ -57,7 +57,7 @@ jobs:\n       fail-fast: false\n     timeout-minutes: 60\n     container: \n-      image: asterinas/asterinas:0.7.0\n+      image: asterinas/asterinas:0.8.0\n       options: --device=/dev/kvm\n     env:\n       # Need to set up proxy since the self-hosted CI server is located in China,\ndiff --git a/.github/workflows/publish_osdk_and_ostd.yml b/.github/workflows/publish_osdk_and_ostd.yml\nindex a6f2dcdc65..32f3c8b46e 100644\n--- a/.github/workflows/publish_osdk_and_ostd.yml\n+++ b/.github/workflows/publish_osdk_and_ostd.yml\n@@ -16,7 +16,7 @@ jobs:\n   osdk-publish:\n     runs-on: ubuntu-latest\n     timeout-minutes: 10\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     steps:\n       - uses: actions/checkout@v4\n \n@@ -39,7 +39,7 @@ jobs:\n   ostd-publish:\n     runs-on: ubuntu-latest\n     timeout-minutes: 10\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     strategy:\n       matrix:\n         # All supported targets, this array should keep consistent with\n@@ -48,15 +48,18 @@ jobs:\n     steps:\n       - uses: actions/checkout@v4\n \n-      - name: Check Publish OSTD\n+      - name: Check Publish OSTD and the test runner\n         # On pull request, set `--dry-run` to check whether OSDK can publish\n         if: github.event_name == 'pull_request'\n         run: |\n           cd ostd\n           cargo publish --target ${{ matrix.target }} --dry-run\n           cargo doc --target ${{ matrix.target }}\n+          cd osdk/test-kernel\n+          cargo publish --target ${{ matrix.target }} --dry-run\n+          cargo doc --target ${{ matrix.target }}\n       \n-      - name: Publish OSTD\n+      - name: Publish OSTD and the test runner\n         if: github.event_name == 'push'\n         env:\n           REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}\n@@ -66,4 +69,6 @@ jobs:\n         run: |\n           cd ostd\n           cargo publish --target x86_64-unknown-none --token ${REGISTRY_TOKEN}\n-      \n+          cd osdk/test-kernel\n+          cargo publish --target x86_64-unknown-none --token ${REGISTRY_TOKEN}\n+      \n\\ No newline at end of file\ndiff --git a/.github/workflows/publish_website.yml b/.github/workflows/publish_website.yml\nindex d89b5ebbc4..af23d7b1f2 100644\n--- a/.github/workflows/publish_website.yml\n+++ b/.github/workflows/publish_website.yml\n@@ -16,7 +16,7 @@ jobs:\n   build_and_deploy:\n     runs-on: ubuntu-latest\n     timeout-minutes: 15\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     steps:\n       - uses: actions/checkout@v2\n         with:\ndiff --git a/.github/workflows/push_git_tag.yml b/.github/workflows/push_git_tag.yml\nindex edf500ce53..a70a63a84f 100644\n--- a/.github/workflows/push_git_tag.yml\n+++ b/.github/workflows/push_git_tag.yml\n@@ -17,4 +17,4 @@ jobs:\n         uses: pxpm/github-tag-action@1.0.1\n         with:\n           repo-token: ${{ secrets.GITHUB_TOKEN }}\n-          tag: v0.7.0\n+          tag: v0.8.0\ndiff --git a/Cargo.lock b/Cargo.lock\nindex 117acb1d2e..57ad547f93 100644\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -153,6 +153,7 @@ dependencies = [\n  \"ascii\",\n  \"aster-block\",\n  \"aster-console\",\n+ \"aster-framebuffer\",\n  \"aster-input\",\n  \"aster-network\",\n  \"aster-rights\",\n@@ -166,6 +167,7 @@ dependencies = [\n  \"bytemuck\",\n  \"bytemuck_derive\",\n  \"cfg-if\",\n+ \"component\",\n  \"controlled\",\n  \"core2\",\n  \"cpio-decoder\",\n@@ -262,19 +264,6 @@ dependencies = [\n  \"typeflags-util\",\n ]\n \n-[[package]]\n-name = \"asterinas\"\n-version = \"0.4.0\"\n-dependencies = [\n- \"aster-framebuffer\",\n- \"aster-nix\",\n- \"aster-time\",\n- \"component\",\n- \"id-alloc\",\n- \"ostd\",\n- \"x86_64 0.14.11\",\n-]\n-\n [[package]]\n name = \"atomic\"\n version = \"0.6.0\"\n@@ -1045,9 +1034,18 @@ version = \"1.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dd8b5dd2ae5ed71462c540258bedcb51965123ad7e7ccf4b9a8cafaa4a63576d\"\n \n+[[package]]\n+name = \"osdk-test-kernel\"\n+version = \"0.8.0\"\n+dependencies = [\n+ \"ostd\",\n+ \"owo-colors 4.0.0\",\n+ \"unwinding\",\n+]\n+\n [[package]]\n name = \"ostd\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n dependencies = [\n  \"acpi\",\n  \"align_ext\",\n@@ -1075,7 +1073,7 @@ dependencies = [\n  \"ostd-macros\",\n  \"ostd-pod\",\n  \"ostd-test\",\n- \"owo-colors\",\n+ \"owo-colors 3.5.0\",\n  \"rsdp\",\n  \"spin 0.9.8\",\n  \"static_assertions\",\n@@ -1119,9 +1117,6 @@ dependencies = [\n [[package]]\n name = \"ostd-test\"\n version = \"0.1.0\"\n-dependencies = [\n- \"owo-colors\",\n-]\n \n [[package]]\n name = \"owo-colors\"\n@@ -1129,6 +1124,12 @@ version = \"3.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c1b04fb49957986fdce4d6ee7a65027d55d4b6d2265e5848bbb507b58ccfdb6f\"\n \n+[[package]]\n+name = \"owo-colors\"\n+version = \"4.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"caff54706df99d2a78a5a4e3455ff45448d81ef1bb63c22cd14052ca0e993a3f\"\n+\n [[package]]\n name = \"paste\"\n version = \"1.0.14\"\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 26ab93e796..64ffc7e587 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -1,6 +1,7 @@\n [workspace]\n resolver = \"2\"\n members = [\n+    \"osdk/test-kernel\",\n     \"ostd\",\n     \"ostd/libs/align_ext\",\n     \"ostd/libs/ostd-macros\",\n@@ -10,7 +11,6 @@ members = [\n     \"ostd/libs/linux-bzimage/setup\",\n     \"ostd/libs/ostd-test\",\n     \"kernel\",\n-    \"kernel/aster-nix\",\n     \"kernel/comps/block\",\n     \"kernel/comps/console\",\n     \"kernel/comps/framebuffer\",\ndiff --git a/Components.toml b/Components.toml\nindex ba1b5572ae..f442c589ea 100644\n--- a/Components.toml\n+++ b/Components.toml\n@@ -8,8 +8,7 @@ console = { name = \"aster-console\" }\n time = { name = \"aster-time\" }\n framebuffer = { name = \"aster-framebuffer\" }\n network = { name = \"aster-network\" }\n-main = { name = \"asterinas\" }\n \n [whitelist]\n-[whitelist.nix.run_first_process]\n+[whitelist.nix.main]\n main = true\ndiff --git a/Makefile b/Makefile\nindex 8b85e848fa..227088ff9a 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -110,10 +110,10 @@ NON_OSDK_CRATES := \\\n # In contrast, OSDK crates depend on OSTD (or being `ostd` itself)\n # and need to be built or tested with OSDK.\n OSDK_CRATES := \\\n+\tosdk/test-kernel \\\n \tostd \\\n \tostd/libs/linux-bzimage/setup \\\n \tkernel \\\n-\tkernel/aster-nix \\\n \tkernel/comps/block \\\n \tkernel/comps/console \\\n \tkernel/comps/framebuffer \\\n@@ -130,7 +130,10 @@ all: build\n # To uninstall, do `cargo uninstall cargo-osdk`\n .PHONY: install_osdk\n install_osdk:\n-\t@cargo install cargo-osdk --path osdk\n+\t@# The `OSDK_LOCAL_DEV` environment variable is used for local development\n+\t@# without the need to publish the changes of OSDK's self-hosted\n+\t@# dependencies to `crates.io`.\n+\t@OSDK_LOCAL_DEV=1 cargo install cargo-osdk --path osdk\n \n # This will install OSDK if it is not already installed\n # To update OSDK, we need to run `install_osdk` manually\n@@ -206,7 +209,7 @@ format:\n \t@make --no-print-directory -C test format\n \n .PHONY: check\n-check: $(CARGO_OSDK)\n+check: initramfs $(CARGO_OSDK)\n \t@./tools/format_all.sh --check   \t# Check Rust format issues\n \t@# Check if STD_CRATES and NOSTD_CRATES combined is the same as all workspace members\n \t@sed -n '/^\\[workspace\\]/,/^\\[.*\\]/{/members = \\[/,/\\]/p}' Cargo.toml | \\\ndiff --git a/README.md b/README.md\nindex 26832d32e8..41c4e203fc 100644\n--- a/README.md\n+++ b/README.md\n@@ -52,7 +52,7 @@ git clone https://github.com/asterinas/asterinas\n 2. Run a Docker container as the development environment.\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0\n ```\n \n 3. Inside the container, go to the project folder to build and run Asterinas.\ndiff --git a/README_CN.md b/README_CN.md\nindex d825b72ace..f840de52c3 100644\n--- a/README_CN.md\n+++ b/README_CN.md\n@@ -49,7 +49,7 @@ git clone https://github.com/asterinas/asterinas\n 2. \u8fd0\u884c\u4e00\u4e2a\u4f5c\u4e3a\u5f00\u53d1\u73af\u5883\u7684Docker\u5bb9\u5668\u3002\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0\n ```\n \n 3. \u5728\u5bb9\u5668\u5185\uff0c\u8fdb\u5165\u9879\u76ee\u6587\u4ef6\u5939\u6784\u5efa\u5e76\u8fd0\u884c\u661f\u7efd\u3002\ndiff --git a/VERSION b/VERSION\nindex bcaffe19b5..8adc70fdd9 100644\n--- a/VERSION\n+++ b/VERSION\n@@ -1,1 +1,1 @@\n-0.7.0\n\\ No newline at end of file\n+0.8.0\n\\ No newline at end of file\ndiff --git a/docs/src/kernel/README.md b/docs/src/kernel/README.md\nindex da180fe146..e66756912b 100644\n--- a/docs/src/kernel/README.md\n+++ b/docs/src/kernel/README.md\n@@ -44,7 +44,7 @@ git clone https://github.com/asterinas/asterinas\n 2. Run a Docker container as the development environment.\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0\n ```\n \n 3. Inside the container, go to the project folder to build and run Asterinas.\ndiff --git a/docs/src/kernel/intel_tdx.md b/docs/src/kernel/intel_tdx.md\nindex 294caedc92..acfdfa2055 100644\n--- a/docs/src/kernel/intel_tdx.md\n+++ b/docs/src/kernel/intel_tdx.md\n@@ -66,7 +66,7 @@ git clone https://github.com/asterinas/asterinas\n 2. Run a Docker container as the development environment.\n \n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.7.0-tdx\n+docker run -it --privileged --network=host --device=/dev/kvm -v $(pwd)/asterinas:/root/asterinas asterinas/asterinas:0.8.0-tdx\n ```\n \n 3. Inside the container,\ndiff --git a/docs/src/osdk/reference/manifest.md b/docs/src/osdk/reference/manifest.md\nindex 74c60a4c10..aeceb262e9 100644\n--- a/docs/src/osdk/reference/manifest.md\n+++ b/docs/src/osdk/reference/manifest.md\n@@ -15,10 +15,10 @@ one is of the workspace\n (in the same directory as the workspace's `Cargo.toml`)\n and one of the crate\n (in the same directory as the crate's `Cargo.toml`).\n-OSDK will first refer to the crate-level manifest, then\n-query the workspace-level manifest for undefined fields.\n-In other words, missing fields of the crate manifest\n-will inherit values from the workspace manifest.\n+OSDK will firstly try to find the crate-level manifest.\n+If the crate-level manifest is found, OSDK uses it only.\n+If the manifest is not found, OSDK will look into the\n+workspace-level manifest.\n \n ## Configurations\n \ndiff --git a/kernel/Cargo.toml b/kernel/Cargo.toml\nindex 8ceec4a481..5351b489a8 100644\n--- a/kernel/Cargo.toml\n+++ b/kernel/Cargo.toml\n@@ -1,18 +1,82 @@\n [package]\n-name = \"asterinas\"\n-version = \"0.4.0\"\n+name = \"aster-nix\"\n+version = \"0.1.0\"\n edition = \"2021\"\n \n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n [dependencies]\n-id-alloc = { path = \"../ostd/libs/id-alloc\" }\n-ostd = { path = \"../ostd\" }\n-aster-nix = { path = \"aster-nix\" }\n+align_ext = { path = \"../ostd/libs/align_ext\" }\n+aster-input = { path = \"comps/input\" }\n+aster-block = { path = \"comps/block\" }\n+aster-network = { path = \"comps/network\" }\n+aster-console = { path = \"comps/console\" }\n+aster-framebuffer = { path = \"comps/framebuffer\" }\n+aster-time = { path = \"comps/time\" }\n+aster-virtio = { path = \"comps/virtio\" }\n+aster-rights = { path = \"libs/aster-rights\" }\n component = { path = \"libs/comp-sys/component\" }\n+controlled = { path = \"libs/comp-sys/controlled\" }\n+ostd = { path = \"../ostd\" }\n+typeflags = { path = \"libs/typeflags\" }\n+typeflags-util = { path = \"libs/typeflags-util\" }\n+aster-rights-proc = { path = \"libs/aster-rights-proc\" }\n+aster-util = { path = \"libs/aster-util\" }\n+id-alloc = { path = \"../ostd/libs/id-alloc\" }\n+int-to-c-enum = { path = \"libs/int-to-c-enum\" }\n+cpio-decoder = { path = \"libs/cpio-decoder\" }\n+ascii = { version = \"1.1\", default-features = false, features = [\"alloc\"] }\n+intrusive-collections = \"0.9.5\"\n+paste = \"1.0\"\n+time = { version = \"0.3\", default-features = false, features = [\"alloc\"] }\n+smoltcp = { git = \"https://github.com/smoltcp-rs/smoltcp\", rev = \"dc08e0b\", default-features = false, features = [\n+    \"alloc\",\n+    \"log\",\n+    \"medium-ethernet\",\n+    \"medium-ip\",\n+    \"proto-dhcpv4\",\n+    \"proto-ipv4\",\n+    \"proto-igmp\",\n+    \"socket-icmp\",\n+    \"socket-udp\",\n+    \"socket-tcp\",\n+    \"socket-raw\",\n+    \"socket-dhcpv4\",\n+] }\n+tdx-guest = { version = \"0.1.7\", optional = true }\n \n-[dev-dependencies]\n-x86_64 = \"0.14.2\"\n-aster-time = { path = \"comps/time\" }\n-aster-framebuffer = { path = \"comps/framebuffer\" }\n+# parse elf file\n+xmas-elf = \"0.8.0\"\n+# data-structures\n+bitflags = \"1.3\"\n+ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n+keyable-arc = { path = \"libs/keyable-arc\" }\n+# unzip initramfs\n+libflate = { version = \"2\", default-features = false }\n+core2 = { version = \"0.4\", default-features = false, features = [\"alloc\"] }\n+lending-iterator = \"0.1.7\"\n+spin = \"0.9.4\"\n+vte = \"0.10\"\n+lru = \"0.12.3\"\n+log = \"0.4\"\n+bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n+hashbrown = \"0.14\"\n+rand = { version = \"0.8.5\", default-features = false, features = [\n+    \"small_rng\",\n+    \"std_rng\",\n+] }\n+static_assertions = \"1.1.0\"\n+inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\" }\n+getset = \"0.1.2\"\n+atomic = \"0.6\"\n+bytemuck = \"1.14.3\"\n+bytemuck_derive = \"1.5.0\"\n+takeable = \"0.2.2\"\n+cfg-if = \"1.0\"\n+\n+[dependencies.lazy_static]\n+version = \"1.0\"\n+features = [\"spin_no_std\"]\n \n [features]\n-cvm_guest = [\"ostd/cvm_guest\", \"aster-nix/cvm_guest\"]\n+cvm_guest = [\"dep:tdx-guest\", \"ostd/cvm_guest\"]\ndiff --git a/kernel/aster-nix/Cargo.toml b/kernel/aster-nix/Cargo.toml\ndeleted file mode 100644\nindex 219b372561..0000000000\n--- a/kernel/aster-nix/Cargo.toml\n+++ /dev/null\n@@ -1,81 +0,0 @@\n-[package]\n-name = \"aster-nix\"\n-version = \"0.1.0\"\n-edition = \"2021\"\n-\n-# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-align_ext = { path = \"../../ostd/libs/align_ext\" }\n-aster-input = { path = \"../comps/input\" }\n-aster-block = { path = \"../comps/block\" }\n-aster-network = { path = \"../comps/network\" }\n-aster-console = { path = \"../comps/console\" }\n-aster-time = { path = \"../comps/time\" }\n-aster-virtio = { path = \"../comps/virtio\" }\n-aster-rights = { path = \"../libs/aster-rights\" }\n-controlled = { path = \"../libs/comp-sys/controlled\" }\n-ostd = { path = \"../../ostd\" }\n-typeflags = { path = \"../libs/typeflags\" }\n-typeflags-util = { path = \"../libs/typeflags-util\" }\n-aster-rights-proc = { path = \"../libs/aster-rights-proc\" }\n-aster-util = { path = \"../libs/aster-util\" }\n-id-alloc = { path = \"../../ostd/libs/id-alloc\" }\n-int-to-c-enum = { path = \"../libs/int-to-c-enum\" }\n-cpio-decoder = { path = \"../libs/cpio-decoder\" }\n-ascii = { version = \"1.1\", default-features = false, features = [\"alloc\"] }\n-intrusive-collections = \"0.9.5\"\n-paste = \"1.0\"\n-time = { version = \"0.3\", default-features = false, features = [\"alloc\"] }\n-smoltcp = { git = \"https://github.com/smoltcp-rs/smoltcp\", rev = \"dc08e0b\", default-features = false, features = [\n-    \"alloc\",\n-    \"log\",\n-    \"medium-ethernet\",\n-    \"medium-ip\",\n-    \"proto-dhcpv4\",\n-    \"proto-ipv4\",\n-    \"proto-igmp\",\n-    \"socket-icmp\",\n-    \"socket-udp\",\n-    \"socket-tcp\",\n-    \"socket-raw\",\n-    \"socket-dhcpv4\",\n-] }\n-tdx-guest = { version = \"0.1.7\", optional = true }\n-\n-# parse elf file\n-xmas-elf = \"0.8.0\"\n-# goblin = {version= \"0.5.3\", default-features = false, features = [\"elf64\"]}\n-# data-structures\n-bitflags = \"1.3\"\n-ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n-keyable-arc = { path = \"../libs/keyable-arc\" }\n-# unzip initramfs\n-libflate = { version = \"2\", default-features = false }\n-core2 = { version = \"0.4\", default-features = false, features = [\"alloc\"] }\n-lending-iterator = \"0.1.7\"\n-spin = \"0.9.4\"\n-vte = \"0.10\"\n-lru = \"0.12.3\"\n-log = \"0.4\"\n-bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n-hashbrown = \"0.14\"\n-rand = { version = \"0.8.5\", default-features = false, features = [\n-    \"small_rng\",\n-    \"std_rng\",\n-] }\n-static_assertions = \"1.1.0\"\n-inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\" }\n-getset = \"0.1.2\"\n-atomic = \"0.6\"\n-bytemuck = \"1.14.3\"\n-bytemuck_derive = \"1.5.0\"\n-takeable = \"0.2.2\"\n-cfg-if = \"1.0\"\n-\n-[dependencies.lazy_static]\n-version = \"1.0\"\n-features = [\"spin_no_std\"]\n-\n-[features]\n-cvm_guest = [\"dep:tdx-guest\"]\ndiff --git a/kernel/aster-nix/src/lib.rs b/kernel/aster-nix/src/lib.rs\ndeleted file mode 100644\nindex 72ea970ee7..0000000000\n--- a/kernel/aster-nix/src/lib.rs\n+++ /dev/null\n@@ -1,154 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! The std library of Asterinas.\n-#![no_std]\n-#![deny(unsafe_code)]\n-#![allow(incomplete_features)]\n-#![feature(btree_cursors)]\n-#![feature(btree_extract_if)]\n-#![feature(const_option)]\n-#![feature(extend_one)]\n-#![feature(fn_traits)]\n-#![feature(format_args_nl)]\n-#![feature(int_roundings)]\n-#![feature(iter_repeat_n)]\n-#![feature(let_chains)]\n-#![feature(linked_list_remove)]\n-#![feature(negative_impls)]\n-#![feature(register_tool)]\n-// FIXME: This feature is used to support vm capbility now as a work around.\n-// Since this is an incomplete feature, use this feature is unsafe.\n-// We should find a proper method to replace this feature with min_specialization, which is a sound feature.\n-#![feature(specialization)]\n-#![feature(step_trait)]\n-#![feature(trait_alias)]\n-#![feature(trait_upcasting)]\n-#![feature(linked_list_retain)]\n-#![register_tool(component_access_control)]\n-\n-use ostd::{\n-    arch::qemu::{exit_qemu, QemuExitCode},\n-    boot,\n-};\n-use process::Process;\n-\n-use crate::{\n-    prelude::*,\n-    thread::{\n-        kernel_thread::{KernelThreadExt, ThreadOptions},\n-        Thread,\n-    },\n-};\n-\n-extern crate alloc;\n-extern crate lru;\n-#[macro_use]\n-extern crate controlled;\n-#[macro_use]\n-extern crate getset;\n-\n-pub mod arch;\n-pub mod console;\n-pub mod context;\n-pub mod cpu;\n-pub mod device;\n-pub mod driver;\n-pub mod error;\n-pub mod events;\n-pub mod fs;\n-pub mod ipc;\n-pub mod net;\n-pub mod prelude;\n-mod process;\n-mod sched;\n-pub mod softirq_id;\n-pub mod syscall;\n-mod taskless;\n-pub mod thread;\n-pub mod time;\n-mod util;\n-pub(crate) mod vdso;\n-pub mod vm;\n-\n-pub fn init() {\n-    util::random::init();\n-    driver::init();\n-    time::init();\n-    net::init();\n-    sched::init();\n-    fs::rootfs::init(boot::initramfs()).unwrap();\n-    device::init().unwrap();\n-    vdso::init();\n-    taskless::init();\n-    process::init();\n-}\n-\n-fn init_thread() {\n-    println!(\n-        \"[kernel] Spawn init thread, tid = {}\",\n-        current_thread!().tid()\n-    );\n-    // Work queue should be initialized before interrupt is enabled,\n-    // in case any irq handler uses work queue as bottom half\n-    thread::work_queue::init();\n-    net::lazy_init();\n-    fs::lazy_init();\n-    ipc::init();\n-    // driver::pci::virtio::block::block_device_test();\n-    let thread = Thread::spawn_kernel_thread(ThreadOptions::new(|| {\n-        println!(\"[kernel] Hello world from kernel!\");\n-        let current = current_thread!();\n-        let tid = current.tid();\n-        debug!(\"current tid = {}\", tid);\n-    }));\n-    thread.join();\n-    info!(\n-        \"[aster-nix/lib.rs] spawn kernel thread, tid = {}\",\n-        thread.tid()\n-    );\n-\n-    print_banner();\n-\n-    let karg = boot::kernel_cmdline();\n-\n-    let initproc = Process::spawn_user_process(\n-        karg.get_initproc_path().unwrap(),\n-        karg.get_initproc_argv().to_vec(),\n-        karg.get_initproc_envp().to_vec(),\n-    )\n-    .expect(\"Run init process failed.\");\n-    // Wait till initproc become zombie.\n-    while !initproc.is_zombie() {\n-        // We don't have preemptive scheduler now.\n-        // The long running init thread should yield its own execution to allow other tasks to go on.\n-        Thread::yield_now();\n-    }\n-\n-    // TODO: exit via qemu isa debug device should not be the only way.\n-    let exit_code = if initproc.exit_code().unwrap() == 0 {\n-        QemuExitCode::Success\n-    } else {\n-        QemuExitCode::Failed\n-    };\n-    exit_qemu(exit_code);\n-}\n-\n-/// first process never return\n-#[controlled]\n-pub fn run_first_process() -> ! {\n-    Thread::spawn_kernel_thread(ThreadOptions::new(init_thread));\n-    unreachable!()\n-}\n-\n-fn print_banner() {\n-    println!(\"\\x1B[36m\");\n-    println!(\n-        r\"\n-   _   ___ _____ ___ ___ ___ _  _   _   ___\n-  /_\\ / __|_   _| __| _ \\_ _| \\| | /_\\ / __|\n- / _ \\\\__ \\ | | | _||   /| || .` |/ _ \\\\__ \\\n-/_/ \\_\\___/ |_| |___|_|_\\___|_|\\_/_/ \\_\\___/\n-\"\n-    );\n-    println!(\"\\x1B[0m\");\n-}\ndiff --git a/kernel/libs/aster-util/src/coeff.rs b/kernel/libs/aster-util/src/coeff.rs\nindex 7cf1eed61c..1a86f898d0 100644\n--- a/kernel/libs/aster-util/src/coeff.rs\n+++ b/kernel/libs/aster-util/src/coeff.rs\n@@ -134,8 +134,8 @@ mod test {\n     #[ktest]\n     fn calculation() {\n         let coeff = Coeff::new(23456, 56789, 1_000_000_000);\n-        assert!(coeff * 0 as u64 == 0);\n-        assert!(coeff * 100 as u64 == 100 * 23456 / 56789);\n-        assert!(coeff * 1_000_000_000 as u64 == 1_000_000_000 * 23456 / 56789);\n+        assert!(coeff * 0_u64 == 0);\n+        assert!(coeff * 100_u64 == 100 * 23456 / 56789);\n+        assert!(coeff * 1_000_000_000_u64 == 1_000_000_000 * 23456 / 56789);\n     }\n }\ndiff --git a/kernel/aster-nix/src/arch/mod.rs b/kernel/src/arch/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/arch/mod.rs\nrename to kernel/src/arch/mod.rs\ndiff --git a/kernel/aster-nix/src/arch/x86/cpu.rs b/kernel/src/arch/x86/cpu.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/arch/x86/cpu.rs\nrename to kernel/src/arch/x86/cpu.rs\ndiff --git a/kernel/aster-nix/src/arch/x86/mod.rs b/kernel/src/arch/x86/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/arch/x86/mod.rs\nrename to kernel/src/arch/x86/mod.rs\ndiff --git a/kernel/aster-nix/src/arch/x86/signal.rs b/kernel/src/arch/x86/signal.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/arch/x86/signal.rs\nrename to kernel/src/arch/x86/signal.rs\ndiff --git a/kernel/aster-nix/src/console.rs b/kernel/src/console.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/console.rs\nrename to kernel/src/console.rs\ndiff --git a/kernel/aster-nix/src/context.rs b/kernel/src/context.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/context.rs\nrename to kernel/src/context.rs\ndiff --git a/kernel/aster-nix/src/cpu.rs b/kernel/src/cpu.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/cpu.rs\nrename to kernel/src/cpu.rs\ndiff --git a/kernel/aster-nix/src/device/mod.rs b/kernel/src/device/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/mod.rs\nrename to kernel/src/device/mod.rs\ndiff --git a/kernel/aster-nix/src/device/null.rs b/kernel/src/device/null.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/null.rs\nrename to kernel/src/device/null.rs\ndiff --git a/kernel/aster-nix/src/device/pty/mod.rs b/kernel/src/device/pty/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/pty/mod.rs\nrename to kernel/src/device/pty/mod.rs\ndiff --git a/kernel/aster-nix/src/device/pty/pty.rs b/kernel/src/device/pty/pty.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/pty/pty.rs\nrename to kernel/src/device/pty/pty.rs\ndiff --git a/kernel/aster-nix/src/device/random.rs b/kernel/src/device/random.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/random.rs\nrename to kernel/src/device/random.rs\ndiff --git a/kernel/aster-nix/src/device/tdxguest/mod.rs b/kernel/src/device/tdxguest/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/tdxguest/mod.rs\nrename to kernel/src/device/tdxguest/mod.rs\ndiff --git a/kernel/aster-nix/src/device/tty/device.rs b/kernel/src/device/tty/device.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/tty/device.rs\nrename to kernel/src/device/tty/device.rs\ndiff --git a/kernel/aster-nix/src/device/tty/driver.rs b/kernel/src/device/tty/driver.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/tty/driver.rs\nrename to kernel/src/device/tty/driver.rs\ndiff --git a/kernel/aster-nix/src/device/tty/line_discipline.rs b/kernel/src/device/tty/line_discipline.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/tty/line_discipline.rs\nrename to kernel/src/device/tty/line_discipline.rs\ndiff --git a/kernel/aster-nix/src/device/tty/mod.rs b/kernel/src/device/tty/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/tty/mod.rs\nrename to kernel/src/device/tty/mod.rs\ndiff --git a/kernel/aster-nix/src/device/tty/termio.rs b/kernel/src/device/tty/termio.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/tty/termio.rs\nrename to kernel/src/device/tty/termio.rs\ndiff --git a/kernel/aster-nix/src/device/urandom.rs b/kernel/src/device/urandom.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/urandom.rs\nrename to kernel/src/device/urandom.rs\ndiff --git a/kernel/aster-nix/src/device/zero.rs b/kernel/src/device/zero.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/device/zero.rs\nrename to kernel/src/device/zero.rs\ndiff --git a/kernel/aster-nix/src/driver/mod.rs b/kernel/src/driver/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/driver/mod.rs\nrename to kernel/src/driver/mod.rs\ndiff --git a/kernel/aster-nix/src/error.rs b/kernel/src/error.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/error.rs\nrename to kernel/src/error.rs\ndiff --git a/kernel/aster-nix/src/events/events.rs b/kernel/src/events/events.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/events/events.rs\nrename to kernel/src/events/events.rs\ndiff --git a/kernel/aster-nix/src/events/io_events.rs b/kernel/src/events/io_events.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/events/io_events.rs\nrename to kernel/src/events/io_events.rs\ndiff --git a/kernel/aster-nix/src/events/mod.rs b/kernel/src/events/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/events/mod.rs\nrename to kernel/src/events/mod.rs\ndiff --git a/kernel/aster-nix/src/events/observer.rs b/kernel/src/events/observer.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/events/observer.rs\nrename to kernel/src/events/observer.rs\ndiff --git a/kernel/aster-nix/src/events/subject.rs b/kernel/src/events/subject.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/events/subject.rs\nrename to kernel/src/events/subject.rs\ndiff --git a/kernel/aster-nix/src/fs/device.rs b/kernel/src/fs/device.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/device.rs\nrename to kernel/src/fs/device.rs\ndiff --git a/kernel/aster-nix/src/fs/devpts/mod.rs b/kernel/src/fs/devpts/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/devpts/mod.rs\nrename to kernel/src/fs/devpts/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/devpts/ptmx.rs b/kernel/src/fs/devpts/ptmx.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/devpts/ptmx.rs\nrename to kernel/src/fs/devpts/ptmx.rs\ndiff --git a/kernel/aster-nix/src/fs/devpts/slave.rs b/kernel/src/fs/devpts/slave.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/devpts/slave.rs\nrename to kernel/src/fs/devpts/slave.rs\ndiff --git a/kernel/aster-nix/src/fs/epoll/epoll_file.rs b/kernel/src/fs/epoll/epoll_file.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/epoll/epoll_file.rs\nrename to kernel/src/fs/epoll/epoll_file.rs\ndiff --git a/kernel/aster-nix/src/fs/epoll/mod.rs b/kernel/src/fs/epoll/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/epoll/mod.rs\nrename to kernel/src/fs/epoll/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/exfat/bitmap.rs b/kernel/src/fs/exfat/bitmap.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/exfat/bitmap.rs\nrename to kernel/src/fs/exfat/bitmap.rs\ndiff --git a/kernel/aster-nix/src/fs/exfat/constants.rs b/kernel/src/fs/exfat/constants.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/exfat/constants.rs\nrename to kernel/src/fs/exfat/constants.rs\ndiff --git a/kernel/aster-nix/src/fs/exfat/dentry.rs b/kernel/src/fs/exfat/dentry.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/exfat/dentry.rs\nrename to kernel/src/fs/exfat/dentry.rs\ndiff --git a/kernel/aster-nix/src/fs/exfat/fat.rs b/kernel/src/fs/exfat/fat.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/exfat/fat.rs\nrename to kernel/src/fs/exfat/fat.rs\ndiff --git a/kernel/aster-nix/src/fs/exfat/fs.rs b/kernel/src/fs/exfat/fs.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/exfat/fs.rs\nrename to kernel/src/fs/exfat/fs.rs\ndiff --git a/kernel/aster-nix/src/fs/exfat/inode.rs b/kernel/src/fs/exfat/inode.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/exfat/inode.rs\nrename to kernel/src/fs/exfat/inode.rs\ndiff --git a/kernel/aster-nix/src/fs/exfat/mod.rs b/kernel/src/fs/exfat/mod.rs\nsimilarity index 99%\nrename from kernel/aster-nix/src/fs/exfat/mod.rs\nrename to kernel/src/fs/exfat/mod.rs\nindex fb2a770091..b748f32a2d 100644\n--- a/kernel/aster-nix/src/fs/exfat/mod.rs\n+++ b/kernel/src/fs/exfat/mod.rs\n@@ -107,7 +107,7 @@ mod test {\n         }\n     }\n     /// Exfat disk image\n-    static EXFAT_IMAGE: &[u8] = include_bytes!(\"../../../../../test/build/exfat.img\");\n+    static EXFAT_IMAGE: &[u8] = include_bytes!(\"../../../../test/build/exfat.img\");\n \n     /// Read exfat disk image\n     fn new_vm_segment_from_image() -> Segment {\n@@ -484,7 +484,7 @@ mod test {\n         let mut read = vec![0u8; BUF_SIZE];\n         let read_after_rename = a_inode_new.read_bytes_at(0, &mut read);\n         assert!(\n-            read_after_rename.is_ok() && read_after_rename.clone().unwrap() == BUF_SIZE,\n+            read_after_rename.is_ok() && read_after_rename.unwrap() == BUF_SIZE,\n             \"Fail to read after rename: {:?}\",\n             read_after_rename.unwrap_err()\n         );\n@@ -495,8 +495,7 @@ mod test {\n         let new_buf = vec![7u8; NEW_BUF_SIZE];\n         let new_write_after_rename = a_inode_new.write_bytes_at(0, &new_buf);\n         assert!(\n-            new_write_after_rename.is_ok()\n-                && new_write_after_rename.clone().unwrap() == NEW_BUF_SIZE,\n+            new_write_after_rename.is_ok() && new_write_after_rename.unwrap() == NEW_BUF_SIZE,\n             \"Fail to write file after rename: {:?}\",\n             new_write_after_rename.unwrap_err()\n         );\n@@ -984,7 +983,7 @@ mod test {\n         let mut file_names: Vec<String> = (0..file_num).map(|x| x.to_string()).collect();\n         file_names.sort();\n         let mut file_inodes: Vec<Arc<dyn Inode>> = Vec::new();\n-        for (_file_id, file_name) in file_names.iter().enumerate() {\n+        for file_name in file_names.iter() {\n             let inode = create_file(root.clone(), file_name);\n             file_inodes.push(inode);\n         }\ndiff --git a/kernel/aster-nix/src/fs/exfat/super_block.rs b/kernel/src/fs/exfat/super_block.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/exfat/super_block.rs\nrename to kernel/src/fs/exfat/super_block.rs\ndiff --git a/kernel/aster-nix/src/fs/exfat/upcase_table.rs b/kernel/src/fs/exfat/upcase_table.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/exfat/upcase_table.rs\nrename to kernel/src/fs/exfat/upcase_table.rs\ndiff --git a/kernel/aster-nix/src/fs/exfat/utils.rs b/kernel/src/fs/exfat/utils.rs\nsimilarity index 98%\nrename from kernel/aster-nix/src/fs/exfat/utils.rs\nrename to kernel/src/fs/exfat/utils.rs\nindex 3eb2355afe..41e41979af 100644\n--- a/kernel/aster-nix/src/fs/exfat/utils.rs\n+++ b/kernel/src/fs/exfat/utils.rs\n@@ -60,7 +60,6 @@ impl DosTimestamp {\n         #[cfg(not(ktest))]\n         {\n             use crate::time::clocks::RealTimeClock;\n-\n             DosTimestamp::from_duration(RealTimeClock::get().read_time())\n         }\n \n@@ -68,9 +67,9 @@ impl DosTimestamp {\n         #[cfg(ktest)]\n         {\n             use crate::time::SystemTime;\n-            return DosTimestamp::from_duration(\n+            DosTimestamp::from_duration(\n                 SystemTime::UNIX_EPOCH.duration_since(&SystemTime::UNIX_EPOCH)?,\n-            );\n+            )\n         }\n     }\n \ndiff --git a/kernel/aster-nix/src/fs/ext2/block_group.rs b/kernel/src/fs/ext2/block_group.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/block_group.rs\nrename to kernel/src/fs/ext2/block_group.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/block_ptr.rs b/kernel/src/fs/ext2/block_ptr.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/block_ptr.rs\nrename to kernel/src/fs/ext2/block_ptr.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/blocks_hole.rs b/kernel/src/fs/ext2/blocks_hole.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/blocks_hole.rs\nrename to kernel/src/fs/ext2/blocks_hole.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/dir.rs b/kernel/src/fs/ext2/dir.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/dir.rs\nrename to kernel/src/fs/ext2/dir.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/fs.rs b/kernel/src/fs/ext2/fs.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/fs.rs\nrename to kernel/src/fs/ext2/fs.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/impl_for_vfs/fs.rs b/kernel/src/fs/ext2/impl_for_vfs/fs.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/impl_for_vfs/fs.rs\nrename to kernel/src/fs/ext2/impl_for_vfs/fs.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/impl_for_vfs/inode.rs b/kernel/src/fs/ext2/impl_for_vfs/inode.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/impl_for_vfs/inode.rs\nrename to kernel/src/fs/ext2/impl_for_vfs/inode.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/impl_for_vfs/mod.rs b/kernel/src/fs/ext2/impl_for_vfs/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/impl_for_vfs/mod.rs\nrename to kernel/src/fs/ext2/impl_for_vfs/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/indirect_block_cache.rs b/kernel/src/fs/ext2/indirect_block_cache.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/indirect_block_cache.rs\nrename to kernel/src/fs/ext2/indirect_block_cache.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/inode.rs b/kernel/src/fs/ext2/inode.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/inode.rs\nrename to kernel/src/fs/ext2/inode.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/mod.rs b/kernel/src/fs/ext2/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/mod.rs\nrename to kernel/src/fs/ext2/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/prelude.rs b/kernel/src/fs/ext2/prelude.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/prelude.rs\nrename to kernel/src/fs/ext2/prelude.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/super_block.rs b/kernel/src/fs/ext2/super_block.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/super_block.rs\nrename to kernel/src/fs/ext2/super_block.rs\ndiff --git a/kernel/aster-nix/src/fs/ext2/utils.rs b/kernel/src/fs/ext2/utils.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ext2/utils.rs\nrename to kernel/src/fs/ext2/utils.rs\ndiff --git a/kernel/aster-nix/src/fs/file_handle.rs b/kernel/src/fs/file_handle.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/file_handle.rs\nrename to kernel/src/fs/file_handle.rs\ndiff --git a/kernel/aster-nix/src/fs/file_table.rs b/kernel/src/fs/file_table.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/file_table.rs\nrename to kernel/src/fs/file_table.rs\ndiff --git a/kernel/aster-nix/src/fs/fs_resolver.rs b/kernel/src/fs/fs_resolver.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/fs_resolver.rs\nrename to kernel/src/fs/fs_resolver.rs\ndiff --git a/kernel/aster-nix/src/fs/inode_handle/dyn_cap.rs b/kernel/src/fs/inode_handle/dyn_cap.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/inode_handle/dyn_cap.rs\nrename to kernel/src/fs/inode_handle/dyn_cap.rs\ndiff --git a/kernel/aster-nix/src/fs/inode_handle/mod.rs b/kernel/src/fs/inode_handle/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/inode_handle/mod.rs\nrename to kernel/src/fs/inode_handle/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/inode_handle/static_cap.rs b/kernel/src/fs/inode_handle/static_cap.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/inode_handle/static_cap.rs\nrename to kernel/src/fs/inode_handle/static_cap.rs\ndiff --git a/kernel/aster-nix/src/fs/mod.rs b/kernel/src/fs/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/mod.rs\nrename to kernel/src/fs/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/named_pipe.rs b/kernel/src/fs/named_pipe.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/named_pipe.rs\nrename to kernel/src/fs/named_pipe.rs\ndiff --git a/kernel/aster-nix/src/fs/path/dentry.rs b/kernel/src/fs/path/dentry.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/path/dentry.rs\nrename to kernel/src/fs/path/dentry.rs\ndiff --git a/kernel/aster-nix/src/fs/path/mod.rs b/kernel/src/fs/path/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/path/mod.rs\nrename to kernel/src/fs/path/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/path/mount.rs b/kernel/src/fs/path/mount.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/path/mount.rs\nrename to kernel/src/fs/path/mount.rs\ndiff --git a/kernel/aster-nix/src/fs/pipe.rs b/kernel/src/fs/pipe.rs\nsimilarity index 99%\nrename from kernel/aster-nix/src/fs/pipe.rs\nrename to kernel/src/fs/pipe.rs\nindex 2340437729..ee676475c3 100644\n--- a/kernel/aster-nix/src/fs/pipe.rs\n+++ b/kernel/src/fs/pipe.rs\n@@ -331,7 +331,7 @@ mod test {\n     #[ktest]\n     fn test_read_closed() {\n         test_blocking(\n-            |writer| drop(writer),\n+            drop,\n             |reader| {\n                 let mut buf = [0; 1];\n                 assert_eq!(reader.read(&mut writer_from(&mut buf)).unwrap(), 0);\n@@ -350,7 +350,7 @@ mod test {\n                     Errno::EPIPE\n                 );\n             },\n-            |reader| drop(reader),\n+            drop,\n             Ordering::WriteThenRead,\n         );\n     }\ndiff --git a/kernel/aster-nix/src/fs/procfs/filesystems.rs b/kernel/src/fs/procfs/filesystems.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/filesystems.rs\nrename to kernel/src/fs/procfs/filesystems.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/meminfo.rs b/kernel/src/fs/procfs/meminfo.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/meminfo.rs\nrename to kernel/src/fs/procfs/meminfo.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/mod.rs b/kernel/src/fs/procfs/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/mod.rs\nrename to kernel/src/fs/procfs/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/pid/cmdline.rs b/kernel/src/fs/procfs/pid/cmdline.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/pid/cmdline.rs\nrename to kernel/src/fs/procfs/pid/cmdline.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/pid/comm.rs b/kernel/src/fs/procfs/pid/comm.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/pid/comm.rs\nrename to kernel/src/fs/procfs/pid/comm.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/pid/exe.rs b/kernel/src/fs/procfs/pid/exe.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/pid/exe.rs\nrename to kernel/src/fs/procfs/pid/exe.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/pid/fd.rs b/kernel/src/fs/procfs/pid/fd.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/pid/fd.rs\nrename to kernel/src/fs/procfs/pid/fd.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/pid/mod.rs b/kernel/src/fs/procfs/pid/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/pid/mod.rs\nrename to kernel/src/fs/procfs/pid/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/self_.rs b/kernel/src/fs/procfs/self_.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/self_.rs\nrename to kernel/src/fs/procfs/self_.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/sys/kernel/cap_last_cap.rs b/kernel/src/fs/procfs/sys/kernel/cap_last_cap.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/sys/kernel/cap_last_cap.rs\nrename to kernel/src/fs/procfs/sys/kernel/cap_last_cap.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/sys/kernel/mod.rs b/kernel/src/fs/procfs/sys/kernel/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/sys/kernel/mod.rs\nrename to kernel/src/fs/procfs/sys/kernel/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/sys/mod.rs b/kernel/src/fs/procfs/sys/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/sys/mod.rs\nrename to kernel/src/fs/procfs/sys/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/template/builder.rs b/kernel/src/fs/procfs/template/builder.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/template/builder.rs\nrename to kernel/src/fs/procfs/template/builder.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/template/dir.rs b/kernel/src/fs/procfs/template/dir.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/template/dir.rs\nrename to kernel/src/fs/procfs/template/dir.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/template/file.rs b/kernel/src/fs/procfs/template/file.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/template/file.rs\nrename to kernel/src/fs/procfs/template/file.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/template/mod.rs b/kernel/src/fs/procfs/template/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/template/mod.rs\nrename to kernel/src/fs/procfs/template/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/procfs/template/sym.rs b/kernel/src/fs/procfs/template/sym.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/procfs/template/sym.rs\nrename to kernel/src/fs/procfs/template/sym.rs\ndiff --git a/kernel/aster-nix/src/fs/ramfs/fs.rs b/kernel/src/fs/ramfs/fs.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ramfs/fs.rs\nrename to kernel/src/fs/ramfs/fs.rs\ndiff --git a/kernel/aster-nix/src/fs/ramfs/mod.rs b/kernel/src/fs/ramfs/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/ramfs/mod.rs\nrename to kernel/src/fs/ramfs/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/rootfs.rs b/kernel/src/fs/rootfs.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/rootfs.rs\nrename to kernel/src/fs/rootfs.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/access_mode.rs b/kernel/src/fs/utils/access_mode.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/access_mode.rs\nrename to kernel/src/fs/utils/access_mode.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/channel.rs b/kernel/src/fs/utils/channel.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/channel.rs\nrename to kernel/src/fs/utils/channel.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/creation_flags.rs b/kernel/src/fs/utils/creation_flags.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/creation_flags.rs\nrename to kernel/src/fs/utils/creation_flags.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/dirent_visitor.rs b/kernel/src/fs/utils/dirent_visitor.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/dirent_visitor.rs\nrename to kernel/src/fs/utils/dirent_visitor.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/direntry_vec.rs b/kernel/src/fs/utils/direntry_vec.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/direntry_vec.rs\nrename to kernel/src/fs/utils/direntry_vec.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/falloc_mode.rs b/kernel/src/fs/utils/falloc_mode.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/falloc_mode.rs\nrename to kernel/src/fs/utils/falloc_mode.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/file_creation_mask.rs b/kernel/src/fs/utils/file_creation_mask.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/file_creation_mask.rs\nrename to kernel/src/fs/utils/file_creation_mask.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/flock.rs b/kernel/src/fs/utils/flock.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/flock.rs\nrename to kernel/src/fs/utils/flock.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/fs.rs b/kernel/src/fs/utils/fs.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/fs.rs\nrename to kernel/src/fs/utils/fs.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/inode.rs b/kernel/src/fs/utils/inode.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/inode.rs\nrename to kernel/src/fs/utils/inode.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/ioctl.rs b/kernel/src/fs/utils/ioctl.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/ioctl.rs\nrename to kernel/src/fs/utils/ioctl.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/mod.rs b/kernel/src/fs/utils/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/mod.rs\nrename to kernel/src/fs/utils/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/page_cache.rs b/kernel/src/fs/utils/page_cache.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/page_cache.rs\nrename to kernel/src/fs/utils/page_cache.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/range_lock/builder.rs b/kernel/src/fs/utils/range_lock/builder.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/range_lock/builder.rs\nrename to kernel/src/fs/utils/range_lock/builder.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/range_lock/mod.rs b/kernel/src/fs/utils/range_lock/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/range_lock/mod.rs\nrename to kernel/src/fs/utils/range_lock/mod.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/range_lock/range.rs b/kernel/src/fs/utils/range_lock/range.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/range_lock/range.rs\nrename to kernel/src/fs/utils/range_lock/range.rs\ndiff --git a/kernel/aster-nix/src/fs/utils/status_flags.rs b/kernel/src/fs/utils/status_flags.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/status_flags.rs\nrename to kernel/src/fs/utils/status_flags.rs\ndiff --git a/kernel/aster-nix/src/ipc/mod.rs b/kernel/src/ipc/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/ipc/mod.rs\nrename to kernel/src/ipc/mod.rs\ndiff --git a/kernel/aster-nix/src/ipc/semaphore/mod.rs b/kernel/src/ipc/semaphore/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/ipc/semaphore/mod.rs\nrename to kernel/src/ipc/semaphore/mod.rs\ndiff --git a/kernel/aster-nix/src/ipc/semaphore/posix/mod.rs b/kernel/src/ipc/semaphore/posix/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/ipc/semaphore/posix/mod.rs\nrename to kernel/src/ipc/semaphore/posix/mod.rs\ndiff --git a/kernel/aster-nix/src/ipc/semaphore/system_v/mod.rs b/kernel/src/ipc/semaphore/system_v/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/ipc/semaphore/system_v/mod.rs\nrename to kernel/src/ipc/semaphore/system_v/mod.rs\ndiff --git a/kernel/aster-nix/src/ipc/semaphore/system_v/sem.rs b/kernel/src/ipc/semaphore/system_v/sem.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/ipc/semaphore/system_v/sem.rs\nrename to kernel/src/ipc/semaphore/system_v/sem.rs\ndiff --git a/kernel/aster-nix/src/ipc/semaphore/system_v/sem_set.rs b/kernel/src/ipc/semaphore/system_v/sem_set.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/ipc/semaphore/system_v/sem_set.rs\nrename to kernel/src/ipc/semaphore/system_v/sem_set.rs\ndiff --git a/kernel/src/lib.rs b/kernel/src/lib.rs\nindex dd59f76b09..96e14678ff 100644\n--- a/kernel/src/lib.rs\n+++ b/kernel/src/lib.rs\n@@ -1,16 +1,161 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+//! Aster-nix is the Asterinas kernel, a safe, efficient unix-like\n+//! operating system kernel built on top of OSTD and OSDK.\n+\n #![no_std]\n #![no_main]\n #![deny(unsafe_code)]\n-extern crate ostd;\n+#![allow(incomplete_features)]\n+#![feature(btree_cursors)]\n+#![feature(btree_extract_if)]\n+#![feature(const_option)]\n+#![feature(extend_one)]\n+#![feature(fn_traits)]\n+#![feature(format_args_nl)]\n+#![feature(int_roundings)]\n+#![feature(iter_repeat_n)]\n+#![feature(let_chains)]\n+#![feature(linkage)]\n+#![feature(linked_list_remove)]\n+#![feature(negative_impls)]\n+#![feature(register_tool)]\n+// FIXME: This feature is used to support vm capbility now as a work around.\n+// Since this is an incomplete feature, use this feature is unsafe.\n+// We should find a proper method to replace this feature with min_specialization, which is a sound feature.\n+#![feature(specialization)]\n+#![feature(step_trait)]\n+#![feature(trait_alias)]\n+#![feature(trait_upcasting)]\n+#![feature(linked_list_retain)]\n+#![register_tool(component_access_control)]\n+\n+use ostd::{\n+    arch::qemu::{exit_qemu, QemuExitCode},\n+    boot,\n+};\n+use process::Process;\n+\n+use crate::{\n+    prelude::*,\n+    thread::{\n+        kernel_thread::{KernelThreadExt, ThreadOptions},\n+        Thread,\n+    },\n+};\n+\n+extern crate alloc;\n+extern crate lru;\n+#[macro_use]\n+extern crate controlled;\n+#[macro_use]\n+extern crate getset;\n \n-use ostd::prelude::*;\n+pub mod arch;\n+pub mod console;\n+pub mod context;\n+pub mod cpu;\n+pub mod device;\n+pub mod driver;\n+pub mod error;\n+pub mod events;\n+pub mod fs;\n+pub mod ipc;\n+pub mod net;\n+pub mod prelude;\n+mod process;\n+mod sched;\n+pub mod softirq_id;\n+pub mod syscall;\n+mod taskless;\n+pub mod thread;\n+pub mod time;\n+mod util;\n+pub(crate) mod vdso;\n+pub mod vm;\n \n #[ostd::main]\n+#[controlled]\n pub fn main() {\n-    println!(\"[kernel] finish init ostd\");\n+    ostd::early_println!(\"[kernel] OSTD initialized. Preparing components.\");\n     component::init_all(component::parse_metadata!()).unwrap();\n-    aster_nix::init();\n-    aster_nix::run_first_process();\n+    init();\n+    Thread::spawn_kernel_thread(ThreadOptions::new(init_thread));\n+    unreachable!()\n+}\n+\n+pub fn init() {\n+    util::random::init();\n+    driver::init();\n+    time::init();\n+    net::init();\n+    sched::init();\n+    fs::rootfs::init(boot::initramfs()).unwrap();\n+    device::init().unwrap();\n+    vdso::init();\n+    taskless::init();\n+    process::init();\n+}\n+\n+fn init_thread() {\n+    println!(\n+        \"[kernel] Spawn init thread, tid = {}\",\n+        current_thread!().tid()\n+    );\n+    // Work queue should be initialized before interrupt is enabled,\n+    // in case any irq handler uses work queue as bottom half\n+    thread::work_queue::init();\n+    net::lazy_init();\n+    fs::lazy_init();\n+    ipc::init();\n+    // driver::pci::virtio::block::block_device_test();\n+    let thread = Thread::spawn_kernel_thread(ThreadOptions::new(|| {\n+        println!(\"[kernel] Hello world from kernel!\");\n+        let current = current_thread!();\n+        let tid = current.tid();\n+        debug!(\"current tid = {}\", tid);\n+    }));\n+    thread.join();\n+    info!(\n+        \"[aster-nix/lib.rs] spawn kernel thread, tid = {}\",\n+        thread.tid()\n+    );\n+\n+    print_banner();\n+\n+    let karg = boot::kernel_cmdline();\n+\n+    let initproc = Process::spawn_user_process(\n+        karg.get_initproc_path().unwrap(),\n+        karg.get_initproc_argv().to_vec(),\n+        karg.get_initproc_envp().to_vec(),\n+    )\n+    .expect(\"Run init process failed.\");\n+    // Wait till initproc become zombie.\n+    while !initproc.is_zombie() {\n+        // We don't have preemptive scheduler now.\n+        // The long running init thread should yield its own execution to allow other tasks to go on.\n+        Thread::yield_now();\n+    }\n+\n+    // TODO: exit via qemu isa debug device should not be the only way.\n+    let exit_code = if initproc.exit_code().unwrap() == 0 {\n+        QemuExitCode::Success\n+    } else {\n+        QemuExitCode::Failed\n+    };\n+    exit_qemu(exit_code);\n+}\n+\n+fn print_banner() {\n+    println!(\"\\x1B[36m\");\n+    println!(\n+        r\"\n+   _   ___ _____ ___ ___ ___ _  _   _   ___\n+  /_\\ / __|_   _| __| _ \\_ _| \\| | /_\\ / __|\n+ / _ \\\\__ \\ | | | _||   /| || .` |/ _ \\\\__ \\\n+/_/ \\_\\___/ |_| |___|_|_\\___|_|\\_/_/ \\_\\___/\n+\"\n+    );\n+    println!(\"\\x1B[0m\");\n }\ndiff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/src/net/iface/any_socket.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/iface/any_socket.rs\nrename to kernel/src/net/iface/any_socket.rs\ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/src/net/iface/common.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/iface/common.rs\nrename to kernel/src/net/iface/common.rs\ndiff --git a/kernel/aster-nix/src/net/iface/loopback.rs b/kernel/src/net/iface/loopback.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/iface/loopback.rs\nrename to kernel/src/net/iface/loopback.rs\ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/src/net/iface/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/iface/mod.rs\nrename to kernel/src/net/iface/mod.rs\ndiff --git a/kernel/aster-nix/src/net/iface/time.rs b/kernel/src/net/iface/time.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/iface/time.rs\nrename to kernel/src/net/iface/time.rs\ndiff --git a/kernel/aster-nix/src/net/iface/util.rs b/kernel/src/net/iface/util.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/iface/util.rs\nrename to kernel/src/net/iface/util.rs\ndiff --git a/kernel/aster-nix/src/net/iface/virtio.rs b/kernel/src/net/iface/virtio.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/iface/virtio.rs\nrename to kernel/src/net/iface/virtio.rs\ndiff --git a/kernel/aster-nix/src/net/mod.rs b/kernel/src/net/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/mod.rs\nrename to kernel/src/net/mod.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/addr.rs b/kernel/src/net/socket/ip/addr.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/addr.rs\nrename to kernel/src/net/socket/ip/addr.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/common.rs b/kernel/src/net/socket/ip/common.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/common.rs\nrename to kernel/src/net/socket/ip/common.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs b/kernel/src/net/socket/ip/datagram/bound.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\nrename to kernel/src/net/socket/ip/datagram/bound.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/datagram/mod.rs b/kernel/src/net/socket/ip/datagram/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/datagram/mod.rs\nrename to kernel/src/net/socket/ip/datagram/mod.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/datagram/unbound.rs b/kernel/src/net/socket/ip/datagram/unbound.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/datagram/unbound.rs\nrename to kernel/src/net/socket/ip/datagram/unbound.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/mod.rs b/kernel/src/net/socket/ip/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/mod.rs\nrename to kernel/src/net/socket/ip/mod.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs b/kernel/src/net/socket/ip/stream/connected.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/stream/connected.rs\nrename to kernel/src/net/socket/ip/stream/connected.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs b/kernel/src/net/socket/ip/stream/connecting.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\nrename to kernel/src/net/socket/ip/stream/connecting.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/init.rs b/kernel/src/net/socket/ip/stream/init.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/stream/init.rs\nrename to kernel/src/net/socket/ip/stream/init.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs b/kernel/src/net/socket/ip/stream/listen.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/stream/listen.rs\nrename to kernel/src/net/socket/ip/stream/listen.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/mod.rs b/kernel/src/net/socket/ip/stream/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/stream/mod.rs\nrename to kernel/src/net/socket/ip/stream/mod.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/options.rs b/kernel/src/net/socket/ip/stream/options.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/stream/options.rs\nrename to kernel/src/net/socket/ip/stream/options.rs\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/util.rs b/kernel/src/net/socket/ip/stream/util.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/ip/stream/util.rs\nrename to kernel/src/net/socket/ip/stream/util.rs\ndiff --git a/kernel/aster-nix/src/net/socket/mod.rs b/kernel/src/net/socket/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/mod.rs\nrename to kernel/src/net/socket/mod.rs\ndiff --git a/kernel/aster-nix/src/net/socket/options/macros.rs b/kernel/src/net/socket/options/macros.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/options/macros.rs\nrename to kernel/src/net/socket/options/macros.rs\ndiff --git a/kernel/aster-nix/src/net/socket/options/mod.rs b/kernel/src/net/socket/options/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/options/mod.rs\nrename to kernel/src/net/socket/options/mod.rs\ndiff --git a/kernel/aster-nix/src/net/socket/unix/addr.rs b/kernel/src/net/socket/unix/addr.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/unix/addr.rs\nrename to kernel/src/net/socket/unix/addr.rs\ndiff --git a/kernel/aster-nix/src/net/socket/unix/mod.rs b/kernel/src/net/socket/unix/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/unix/mod.rs\nrename to kernel/src/net/socket/unix/mod.rs\ndiff --git a/kernel/aster-nix/src/net/socket/unix/stream/connected.rs b/kernel/src/net/socket/unix/stream/connected.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/unix/stream/connected.rs\nrename to kernel/src/net/socket/unix/stream/connected.rs\ndiff --git a/kernel/aster-nix/src/net/socket/unix/stream/init.rs b/kernel/src/net/socket/unix/stream/init.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/unix/stream/init.rs\nrename to kernel/src/net/socket/unix/stream/init.rs\ndiff --git a/kernel/aster-nix/src/net/socket/unix/stream/listener.rs b/kernel/src/net/socket/unix/stream/listener.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/unix/stream/listener.rs\nrename to kernel/src/net/socket/unix/stream/listener.rs\ndiff --git a/kernel/aster-nix/src/net/socket/unix/stream/mod.rs b/kernel/src/net/socket/unix/stream/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/unix/stream/mod.rs\nrename to kernel/src/net/socket/unix/stream/mod.rs\ndiff --git a/kernel/aster-nix/src/net/socket/unix/stream/socket.rs b/kernel/src/net/socket/unix/stream/socket.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/unix/stream/socket.rs\nrename to kernel/src/net/socket/unix/stream/socket.rs\ndiff --git a/kernel/aster-nix/src/net/socket/util/message_header.rs b/kernel/src/net/socket/util/message_header.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/util/message_header.rs\nrename to kernel/src/net/socket/util/message_header.rs\ndiff --git a/kernel/aster-nix/src/net/socket/util/mod.rs b/kernel/src/net/socket/util/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/util/mod.rs\nrename to kernel/src/net/socket/util/mod.rs\ndiff --git a/kernel/aster-nix/src/net/socket/util/options.rs b/kernel/src/net/socket/util/options.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/util/options.rs\nrename to kernel/src/net/socket/util/options.rs\ndiff --git a/kernel/aster-nix/src/net/socket/util/send_recv_flags.rs b/kernel/src/net/socket/util/send_recv_flags.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/util/send_recv_flags.rs\nrename to kernel/src/net/socket/util/send_recv_flags.rs\ndiff --git a/kernel/aster-nix/src/net/socket/util/shutdown_cmd.rs b/kernel/src/net/socket/util/shutdown_cmd.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/util/shutdown_cmd.rs\nrename to kernel/src/net/socket/util/shutdown_cmd.rs\ndiff --git a/kernel/aster-nix/src/net/socket/util/socket_addr.rs b/kernel/src/net/socket/util/socket_addr.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/util/socket_addr.rs\nrename to kernel/src/net/socket/util/socket_addr.rs\ndiff --git a/kernel/aster-nix/src/net/socket/vsock/addr.rs b/kernel/src/net/socket/vsock/addr.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/vsock/addr.rs\nrename to kernel/src/net/socket/vsock/addr.rs\ndiff --git a/kernel/aster-nix/src/net/socket/vsock/common.rs b/kernel/src/net/socket/vsock/common.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/vsock/common.rs\nrename to kernel/src/net/socket/vsock/common.rs\ndiff --git a/kernel/aster-nix/src/net/socket/vsock/mod.rs b/kernel/src/net/socket/vsock/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/vsock/mod.rs\nrename to kernel/src/net/socket/vsock/mod.rs\ndiff --git a/kernel/aster-nix/src/net/socket/vsock/stream/connected.rs b/kernel/src/net/socket/vsock/stream/connected.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/vsock/stream/connected.rs\nrename to kernel/src/net/socket/vsock/stream/connected.rs\ndiff --git a/kernel/aster-nix/src/net/socket/vsock/stream/connecting.rs b/kernel/src/net/socket/vsock/stream/connecting.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/vsock/stream/connecting.rs\nrename to kernel/src/net/socket/vsock/stream/connecting.rs\ndiff --git a/kernel/aster-nix/src/net/socket/vsock/stream/init.rs b/kernel/src/net/socket/vsock/stream/init.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/vsock/stream/init.rs\nrename to kernel/src/net/socket/vsock/stream/init.rs\ndiff --git a/kernel/aster-nix/src/net/socket/vsock/stream/listen.rs b/kernel/src/net/socket/vsock/stream/listen.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/vsock/stream/listen.rs\nrename to kernel/src/net/socket/vsock/stream/listen.rs\ndiff --git a/kernel/aster-nix/src/net/socket/vsock/stream/mod.rs b/kernel/src/net/socket/vsock/stream/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/vsock/stream/mod.rs\nrename to kernel/src/net/socket/vsock/stream/mod.rs\ndiff --git a/kernel/aster-nix/src/net/socket/vsock/stream/socket.rs b/kernel/src/net/socket/vsock/stream/socket.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/net/socket/vsock/stream/socket.rs\nrename to kernel/src/net/socket/vsock/stream/socket.rs\ndiff --git a/kernel/aster-nix/src/prelude.rs b/kernel/src/prelude.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/prelude.rs\nrename to kernel/src/prelude.rs\ndiff --git a/kernel/aster-nix/src/process/clone.rs b/kernel/src/process/clone.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/clone.rs\nrename to kernel/src/process/clone.rs\ndiff --git a/kernel/aster-nix/src/process/credentials/c_types.rs b/kernel/src/process/credentials/c_types.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/credentials/c_types.rs\nrename to kernel/src/process/credentials/c_types.rs\ndiff --git a/kernel/aster-nix/src/process/credentials/capabilities.rs b/kernel/src/process/credentials/capabilities.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/credentials/capabilities.rs\nrename to kernel/src/process/credentials/capabilities.rs\ndiff --git a/kernel/aster-nix/src/process/credentials/credentials_.rs b/kernel/src/process/credentials/credentials_.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/credentials/credentials_.rs\nrename to kernel/src/process/credentials/credentials_.rs\ndiff --git a/kernel/aster-nix/src/process/credentials/group.rs b/kernel/src/process/credentials/group.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/credentials/group.rs\nrename to kernel/src/process/credentials/group.rs\ndiff --git a/kernel/aster-nix/src/process/credentials/mod.rs b/kernel/src/process/credentials/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/credentials/mod.rs\nrename to kernel/src/process/credentials/mod.rs\ndiff --git a/kernel/aster-nix/src/process/credentials/static_cap.rs b/kernel/src/process/credentials/static_cap.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/credentials/static_cap.rs\nrename to kernel/src/process/credentials/static_cap.rs\ndiff --git a/kernel/aster-nix/src/process/credentials/user.rs b/kernel/src/process/credentials/user.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/credentials/user.rs\nrename to kernel/src/process/credentials/user.rs\ndiff --git a/kernel/aster-nix/src/process/exit.rs b/kernel/src/process/exit.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/exit.rs\nrename to kernel/src/process/exit.rs\ndiff --git a/kernel/aster-nix/src/process/kill.rs b/kernel/src/process/kill.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/kill.rs\nrename to kernel/src/process/kill.rs\ndiff --git a/kernel/aster-nix/src/process/mod.rs b/kernel/src/process/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/mod.rs\nrename to kernel/src/process/mod.rs\ndiff --git a/kernel/aster-nix/src/process/posix_thread/builder.rs b/kernel/src/process/posix_thread/builder.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/posix_thread/builder.rs\nrename to kernel/src/process/posix_thread/builder.rs\ndiff --git a/kernel/aster-nix/src/process/posix_thread/exit.rs b/kernel/src/process/posix_thread/exit.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/posix_thread/exit.rs\nrename to kernel/src/process/posix_thread/exit.rs\ndiff --git a/kernel/aster-nix/src/process/posix_thread/futex.rs b/kernel/src/process/posix_thread/futex.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/posix_thread/futex.rs\nrename to kernel/src/process/posix_thread/futex.rs\ndiff --git a/kernel/aster-nix/src/process/posix_thread/mod.rs b/kernel/src/process/posix_thread/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/posix_thread/mod.rs\nrename to kernel/src/process/posix_thread/mod.rs\ndiff --git a/kernel/aster-nix/src/process/posix_thread/name.rs b/kernel/src/process/posix_thread/name.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/posix_thread/name.rs\nrename to kernel/src/process/posix_thread/name.rs\ndiff --git a/kernel/aster-nix/src/process/posix_thread/posix_thread_ext.rs b/kernel/src/process/posix_thread/posix_thread_ext.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/posix_thread/posix_thread_ext.rs\nrename to kernel/src/process/posix_thread/posix_thread_ext.rs\ndiff --git a/kernel/aster-nix/src/process/posix_thread/robust_list.rs b/kernel/src/process/posix_thread/robust_list.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/posix_thread/robust_list.rs\nrename to kernel/src/process/posix_thread/robust_list.rs\ndiff --git a/kernel/aster-nix/src/process/process/builder.rs b/kernel/src/process/process/builder.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process/builder.rs\nrename to kernel/src/process/process/builder.rs\ndiff --git a/kernel/aster-nix/src/process/process/job_control.rs b/kernel/src/process/process/job_control.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process/job_control.rs\nrename to kernel/src/process/process/job_control.rs\ndiff --git a/kernel/aster-nix/src/process/process/mod.rs b/kernel/src/process/process/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process/mod.rs\nrename to kernel/src/process/process/mod.rs\ndiff --git a/kernel/aster-nix/src/process/process/process_group.rs b/kernel/src/process/process/process_group.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process/process_group.rs\nrename to kernel/src/process/process/process_group.rs\ndiff --git a/kernel/aster-nix/src/process/process/session.rs b/kernel/src/process/process/session.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process/session.rs\nrename to kernel/src/process/process/session.rs\ndiff --git a/kernel/aster-nix/src/process/process/terminal.rs b/kernel/src/process/process/terminal.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process/terminal.rs\nrename to kernel/src/process/process/terminal.rs\ndiff --git a/kernel/aster-nix/src/process/process/timer_manager.rs b/kernel/src/process/process/timer_manager.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process/timer_manager.rs\nrename to kernel/src/process/process/timer_manager.rs\ndiff --git a/kernel/aster-nix/src/process/process_filter.rs b/kernel/src/process/process_filter.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process_filter.rs\nrename to kernel/src/process/process_filter.rs\ndiff --git a/kernel/aster-nix/src/process/process_table.rs b/kernel/src/process/process_table.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process_table.rs\nrename to kernel/src/process/process_table.rs\ndiff --git a/kernel/aster-nix/src/process/process_vm/heap.rs b/kernel/src/process/process_vm/heap.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process_vm/heap.rs\nrename to kernel/src/process/process_vm/heap.rs\ndiff --git a/kernel/aster-nix/src/process/process_vm/init_stack/aux_vec.rs b/kernel/src/process/process_vm/init_stack/aux_vec.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process_vm/init_stack/aux_vec.rs\nrename to kernel/src/process/process_vm/init_stack/aux_vec.rs\ndiff --git a/kernel/aster-nix/src/process/process_vm/init_stack/mod.rs b/kernel/src/process/process_vm/init_stack/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process_vm/init_stack/mod.rs\nrename to kernel/src/process/process_vm/init_stack/mod.rs\ndiff --git a/kernel/aster-nix/src/process/process_vm/mod.rs b/kernel/src/process/process_vm/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/process_vm/mod.rs\nrename to kernel/src/process/process_vm/mod.rs\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/elf_file.rs b/kernel/src/process/program_loader/elf/elf_file.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/program_loader/elf/elf_file.rs\nrename to kernel/src/process/program_loader/elf/elf_file.rs\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/load_elf.rs b/kernel/src/process/program_loader/elf/load_elf.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/program_loader/elf/load_elf.rs\nrename to kernel/src/process/program_loader/elf/load_elf.rs\ndiff --git a/kernel/aster-nix/src/process/program_loader/elf/mod.rs b/kernel/src/process/program_loader/elf/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/program_loader/elf/mod.rs\nrename to kernel/src/process/program_loader/elf/mod.rs\ndiff --git a/kernel/aster-nix/src/process/program_loader/mod.rs b/kernel/src/process/program_loader/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/program_loader/mod.rs\nrename to kernel/src/process/program_loader/mod.rs\ndiff --git a/kernel/aster-nix/src/process/program_loader/shebang.rs b/kernel/src/process/program_loader/shebang.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/program_loader/shebang.rs\nrename to kernel/src/process/program_loader/shebang.rs\ndiff --git a/kernel/aster-nix/src/process/rlimit.rs b/kernel/src/process/rlimit.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/rlimit.rs\nrename to kernel/src/process/rlimit.rs\ndiff --git a/kernel/aster-nix/src/process/signal/c_types.rs b/kernel/src/process/signal/c_types.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/c_types.rs\nrename to kernel/src/process/signal/c_types.rs\ndiff --git a/kernel/aster-nix/src/process/signal/constants.rs b/kernel/src/process/signal/constants.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/constants.rs\nrename to kernel/src/process/signal/constants.rs\ndiff --git a/kernel/aster-nix/src/process/signal/events.rs b/kernel/src/process/signal/events.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/events.rs\nrename to kernel/src/process/signal/events.rs\ndiff --git a/kernel/aster-nix/src/process/signal/mod.rs b/kernel/src/process/signal/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/mod.rs\nrename to kernel/src/process/signal/mod.rs\ndiff --git a/kernel/aster-nix/src/process/signal/pauser.rs b/kernel/src/process/signal/pauser.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/pauser.rs\nrename to kernel/src/process/signal/pauser.rs\ndiff --git a/kernel/aster-nix/src/process/signal/poll.rs b/kernel/src/process/signal/poll.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/poll.rs\nrename to kernel/src/process/signal/poll.rs\ndiff --git a/kernel/aster-nix/src/process/signal/sig_action.rs b/kernel/src/process/signal/sig_action.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/sig_action.rs\nrename to kernel/src/process/signal/sig_action.rs\ndiff --git a/kernel/aster-nix/src/process/signal/sig_disposition.rs b/kernel/src/process/signal/sig_disposition.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/sig_disposition.rs\nrename to kernel/src/process/signal/sig_disposition.rs\ndiff --git a/kernel/aster-nix/src/process/signal/sig_mask.rs b/kernel/src/process/signal/sig_mask.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/sig_mask.rs\nrename to kernel/src/process/signal/sig_mask.rs\ndiff --git a/kernel/aster-nix/src/process/signal/sig_num.rs b/kernel/src/process/signal/sig_num.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/sig_num.rs\nrename to kernel/src/process/signal/sig_num.rs\ndiff --git a/kernel/aster-nix/src/process/signal/sig_queues.rs b/kernel/src/process/signal/sig_queues.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/sig_queues.rs\nrename to kernel/src/process/signal/sig_queues.rs\ndiff --git a/kernel/aster-nix/src/process/signal/sig_stack.rs b/kernel/src/process/signal/sig_stack.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/sig_stack.rs\nrename to kernel/src/process/signal/sig_stack.rs\ndiff --git a/kernel/aster-nix/src/process/signal/signals/fault.rs b/kernel/src/process/signal/signals/fault.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/signals/fault.rs\nrename to kernel/src/process/signal/signals/fault.rs\ndiff --git a/kernel/aster-nix/src/process/signal/signals/kernel.rs b/kernel/src/process/signal/signals/kernel.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/signals/kernel.rs\nrename to kernel/src/process/signal/signals/kernel.rs\ndiff --git a/kernel/aster-nix/src/process/signal/signals/mod.rs b/kernel/src/process/signal/signals/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/signals/mod.rs\nrename to kernel/src/process/signal/signals/mod.rs\ndiff --git a/kernel/aster-nix/src/process/signal/signals/user.rs b/kernel/src/process/signal/signals/user.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/signal/signals/user.rs\nrename to kernel/src/process/signal/signals/user.rs\ndiff --git a/kernel/aster-nix/src/process/status.rs b/kernel/src/process/status.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/status.rs\nrename to kernel/src/process/status.rs\ndiff --git a/kernel/aster-nix/src/process/sync/condvar.rs b/kernel/src/process/sync/condvar.rs\nsimilarity index 98%\nrename from kernel/aster-nix/src/process/sync/condvar.rs\nrename to kernel/src/process/sync/condvar.rs\nindex 2f18bc2cec..45ec27e039 100644\n--- a/kernel/aster-nix/src/process/sync/condvar.rs\n+++ b/kernel/src/process/sync/condvar.rs\n@@ -291,7 +291,7 @@ mod test {\n             while !*started {\n                 started = cvar.wait(started).unwrap_or_else(|err| err.into_guard());\n             }\n-            assert_eq!(*started, true);\n+            assert!(*started);\n         }\n     }\n \n@@ -316,7 +316,7 @@ mod test {\n                     .wait_timeout(started, Duration::from_secs(1))\n                     .unwrap_or_else(|err| err.into_guard());\n             }\n-            assert_eq!(*started, true);\n+            assert!(*started);\n         }\n     }\n \n@@ -338,7 +338,7 @@ mod test {\n             let started = cvar\n                 .wait_while(lock.lock(), |started| *started)\n                 .unwrap_or_else(|err| err.into_guard());\n-            assert_eq!(*started, false);\n+            assert!(!*started);\n         }\n     }\n \n@@ -360,7 +360,7 @@ mod test {\n             let (started, _) = cvar\n                 .wait_timeout_while(lock.lock(), Duration::from_secs(1), |started| *started)\n                 .unwrap_or_else(|err| err.into_guard());\n-            assert_eq!(*started, false);\n+            assert!(!*started);\n         }\n     }\n }\ndiff --git a/kernel/aster-nix/src/process/sync/mod.rs b/kernel/src/process/sync/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/sync/mod.rs\nrename to kernel/src/process/sync/mod.rs\ndiff --git a/kernel/aster-nix/src/process/term_status.rs b/kernel/src/process/term_status.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/term_status.rs\nrename to kernel/src/process/term_status.rs\ndiff --git a/kernel/aster-nix/src/process/wait.rs b/kernel/src/process/wait.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/process/wait.rs\nrename to kernel/src/process/wait.rs\ndiff --git a/kernel/aster-nix/src/sched/mod.rs b/kernel/src/sched/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/sched/mod.rs\nrename to kernel/src/sched/mod.rs\ndiff --git a/kernel/aster-nix/src/sched/nice.rs b/kernel/src/sched/nice.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/sched/nice.rs\nrename to kernel/src/sched/nice.rs\ndiff --git a/kernel/aster-nix/src/sched/priority_scheduler.rs b/kernel/src/sched/priority_scheduler.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/sched/priority_scheduler.rs\nrename to kernel/src/sched/priority_scheduler.rs\ndiff --git a/kernel/aster-nix/src/softirq_id.rs b/kernel/src/softirq_id.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/softirq_id.rs\nrename to kernel/src/softirq_id.rs\ndiff --git a/kernel/aster-nix/src/syscall/accept.rs b/kernel/src/syscall/accept.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/accept.rs\nrename to kernel/src/syscall/accept.rs\ndiff --git a/kernel/aster-nix/src/syscall/access.rs b/kernel/src/syscall/access.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/access.rs\nrename to kernel/src/syscall/access.rs\ndiff --git a/kernel/aster-nix/src/syscall/alarm.rs b/kernel/src/syscall/alarm.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/alarm.rs\nrename to kernel/src/syscall/alarm.rs\ndiff --git a/kernel/aster-nix/src/syscall/arch/mod.rs b/kernel/src/syscall/arch/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/arch/mod.rs\nrename to kernel/src/syscall/arch/mod.rs\ndiff --git a/kernel/aster-nix/src/syscall/arch/x86.rs b/kernel/src/syscall/arch/x86.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/arch/x86.rs\nrename to kernel/src/syscall/arch/x86.rs\ndiff --git a/kernel/aster-nix/src/syscall/arch_prctl.rs b/kernel/src/syscall/arch_prctl.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/arch_prctl.rs\nrename to kernel/src/syscall/arch_prctl.rs\ndiff --git a/kernel/aster-nix/src/syscall/bind.rs b/kernel/src/syscall/bind.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/bind.rs\nrename to kernel/src/syscall/bind.rs\ndiff --git a/kernel/aster-nix/src/syscall/brk.rs b/kernel/src/syscall/brk.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/brk.rs\nrename to kernel/src/syscall/brk.rs\ndiff --git a/kernel/aster-nix/src/syscall/capget.rs b/kernel/src/syscall/capget.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/capget.rs\nrename to kernel/src/syscall/capget.rs\ndiff --git a/kernel/aster-nix/src/syscall/capset.rs b/kernel/src/syscall/capset.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/capset.rs\nrename to kernel/src/syscall/capset.rs\ndiff --git a/kernel/aster-nix/src/syscall/chdir.rs b/kernel/src/syscall/chdir.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/chdir.rs\nrename to kernel/src/syscall/chdir.rs\ndiff --git a/kernel/aster-nix/src/syscall/chmod.rs b/kernel/src/syscall/chmod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/chmod.rs\nrename to kernel/src/syscall/chmod.rs\ndiff --git a/kernel/aster-nix/src/syscall/chown.rs b/kernel/src/syscall/chown.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/chown.rs\nrename to kernel/src/syscall/chown.rs\ndiff --git a/kernel/aster-nix/src/syscall/chroot.rs b/kernel/src/syscall/chroot.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/chroot.rs\nrename to kernel/src/syscall/chroot.rs\ndiff --git a/kernel/aster-nix/src/syscall/clock_gettime.rs b/kernel/src/syscall/clock_gettime.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/clock_gettime.rs\nrename to kernel/src/syscall/clock_gettime.rs\ndiff --git a/kernel/aster-nix/src/syscall/clone.rs b/kernel/src/syscall/clone.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/clone.rs\nrename to kernel/src/syscall/clone.rs\ndiff --git a/kernel/aster-nix/src/syscall/close.rs b/kernel/src/syscall/close.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/close.rs\nrename to kernel/src/syscall/close.rs\ndiff --git a/kernel/aster-nix/src/syscall/connect.rs b/kernel/src/syscall/connect.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/connect.rs\nrename to kernel/src/syscall/connect.rs\ndiff --git a/kernel/aster-nix/src/syscall/constants.rs b/kernel/src/syscall/constants.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/constants.rs\nrename to kernel/src/syscall/constants.rs\ndiff --git a/kernel/aster-nix/src/syscall/dup.rs b/kernel/src/syscall/dup.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/dup.rs\nrename to kernel/src/syscall/dup.rs\ndiff --git a/kernel/aster-nix/src/syscall/epoll.rs b/kernel/src/syscall/epoll.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/epoll.rs\nrename to kernel/src/syscall/epoll.rs\ndiff --git a/kernel/aster-nix/src/syscall/eventfd.rs b/kernel/src/syscall/eventfd.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/eventfd.rs\nrename to kernel/src/syscall/eventfd.rs\ndiff --git a/kernel/aster-nix/src/syscall/execve.rs b/kernel/src/syscall/execve.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/execve.rs\nrename to kernel/src/syscall/execve.rs\ndiff --git a/kernel/aster-nix/src/syscall/exit.rs b/kernel/src/syscall/exit.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/exit.rs\nrename to kernel/src/syscall/exit.rs\ndiff --git a/kernel/aster-nix/src/syscall/exit_group.rs b/kernel/src/syscall/exit_group.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/exit_group.rs\nrename to kernel/src/syscall/exit_group.rs\ndiff --git a/kernel/aster-nix/src/syscall/fallocate.rs b/kernel/src/syscall/fallocate.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/fallocate.rs\nrename to kernel/src/syscall/fallocate.rs\ndiff --git a/kernel/aster-nix/src/syscall/fcntl.rs b/kernel/src/syscall/fcntl.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/fcntl.rs\nrename to kernel/src/syscall/fcntl.rs\ndiff --git a/kernel/aster-nix/src/syscall/flock.rs b/kernel/src/syscall/flock.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/flock.rs\nrename to kernel/src/syscall/flock.rs\ndiff --git a/kernel/aster-nix/src/syscall/fork.rs b/kernel/src/syscall/fork.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/fork.rs\nrename to kernel/src/syscall/fork.rs\ndiff --git a/kernel/aster-nix/src/syscall/fsync.rs b/kernel/src/syscall/fsync.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/fsync.rs\nrename to kernel/src/syscall/fsync.rs\ndiff --git a/kernel/aster-nix/src/syscall/futex.rs b/kernel/src/syscall/futex.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/futex.rs\nrename to kernel/src/syscall/futex.rs\ndiff --git a/kernel/aster-nix/src/syscall/getcwd.rs b/kernel/src/syscall/getcwd.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getcwd.rs\nrename to kernel/src/syscall/getcwd.rs\ndiff --git a/kernel/aster-nix/src/syscall/getdents64.rs b/kernel/src/syscall/getdents64.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getdents64.rs\nrename to kernel/src/syscall/getdents64.rs\ndiff --git a/kernel/aster-nix/src/syscall/getegid.rs b/kernel/src/syscall/getegid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getegid.rs\nrename to kernel/src/syscall/getegid.rs\ndiff --git a/kernel/aster-nix/src/syscall/geteuid.rs b/kernel/src/syscall/geteuid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/geteuid.rs\nrename to kernel/src/syscall/geteuid.rs\ndiff --git a/kernel/aster-nix/src/syscall/getgid.rs b/kernel/src/syscall/getgid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getgid.rs\nrename to kernel/src/syscall/getgid.rs\ndiff --git a/kernel/aster-nix/src/syscall/getgroups.rs b/kernel/src/syscall/getgroups.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getgroups.rs\nrename to kernel/src/syscall/getgroups.rs\ndiff --git a/kernel/aster-nix/src/syscall/getpeername.rs b/kernel/src/syscall/getpeername.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getpeername.rs\nrename to kernel/src/syscall/getpeername.rs\ndiff --git a/kernel/aster-nix/src/syscall/getpgrp.rs b/kernel/src/syscall/getpgrp.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getpgrp.rs\nrename to kernel/src/syscall/getpgrp.rs\ndiff --git a/kernel/aster-nix/src/syscall/getpid.rs b/kernel/src/syscall/getpid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getpid.rs\nrename to kernel/src/syscall/getpid.rs\ndiff --git a/kernel/aster-nix/src/syscall/getppid.rs b/kernel/src/syscall/getppid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getppid.rs\nrename to kernel/src/syscall/getppid.rs\ndiff --git a/kernel/aster-nix/src/syscall/getrandom.rs b/kernel/src/syscall/getrandom.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getrandom.rs\nrename to kernel/src/syscall/getrandom.rs\ndiff --git a/kernel/aster-nix/src/syscall/getresgid.rs b/kernel/src/syscall/getresgid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getresgid.rs\nrename to kernel/src/syscall/getresgid.rs\ndiff --git a/kernel/aster-nix/src/syscall/getresuid.rs b/kernel/src/syscall/getresuid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getresuid.rs\nrename to kernel/src/syscall/getresuid.rs\ndiff --git a/kernel/aster-nix/src/syscall/getrusage.rs b/kernel/src/syscall/getrusage.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getrusage.rs\nrename to kernel/src/syscall/getrusage.rs\ndiff --git a/kernel/aster-nix/src/syscall/getsid.rs b/kernel/src/syscall/getsid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getsid.rs\nrename to kernel/src/syscall/getsid.rs\ndiff --git a/kernel/aster-nix/src/syscall/getsockname.rs b/kernel/src/syscall/getsockname.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getsockname.rs\nrename to kernel/src/syscall/getsockname.rs\ndiff --git a/kernel/aster-nix/src/syscall/getsockopt.rs b/kernel/src/syscall/getsockopt.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getsockopt.rs\nrename to kernel/src/syscall/getsockopt.rs\ndiff --git a/kernel/aster-nix/src/syscall/gettid.rs b/kernel/src/syscall/gettid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/gettid.rs\nrename to kernel/src/syscall/gettid.rs\ndiff --git a/kernel/aster-nix/src/syscall/gettimeofday.rs b/kernel/src/syscall/gettimeofday.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/gettimeofday.rs\nrename to kernel/src/syscall/gettimeofday.rs\ndiff --git a/kernel/aster-nix/src/syscall/getuid.rs b/kernel/src/syscall/getuid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/getuid.rs\nrename to kernel/src/syscall/getuid.rs\ndiff --git a/kernel/aster-nix/src/syscall/ioctl.rs b/kernel/src/syscall/ioctl.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/ioctl.rs\nrename to kernel/src/syscall/ioctl.rs\ndiff --git a/kernel/aster-nix/src/syscall/kill.rs b/kernel/src/syscall/kill.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/kill.rs\nrename to kernel/src/syscall/kill.rs\ndiff --git a/kernel/aster-nix/src/syscall/link.rs b/kernel/src/syscall/link.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/link.rs\nrename to kernel/src/syscall/link.rs\ndiff --git a/kernel/aster-nix/src/syscall/listen.rs b/kernel/src/syscall/listen.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/listen.rs\nrename to kernel/src/syscall/listen.rs\ndiff --git a/kernel/aster-nix/src/syscall/lseek.rs b/kernel/src/syscall/lseek.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/lseek.rs\nrename to kernel/src/syscall/lseek.rs\ndiff --git a/kernel/aster-nix/src/syscall/madvise.rs b/kernel/src/syscall/madvise.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/madvise.rs\nrename to kernel/src/syscall/madvise.rs\ndiff --git a/kernel/aster-nix/src/syscall/mkdir.rs b/kernel/src/syscall/mkdir.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/mkdir.rs\nrename to kernel/src/syscall/mkdir.rs\ndiff --git a/kernel/aster-nix/src/syscall/mknod.rs b/kernel/src/syscall/mknod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/mknod.rs\nrename to kernel/src/syscall/mknod.rs\ndiff --git a/kernel/aster-nix/src/syscall/mmap.rs b/kernel/src/syscall/mmap.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/mmap.rs\nrename to kernel/src/syscall/mmap.rs\ndiff --git a/kernel/aster-nix/src/syscall/mod.rs b/kernel/src/syscall/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/mod.rs\nrename to kernel/src/syscall/mod.rs\ndiff --git a/kernel/aster-nix/src/syscall/mount.rs b/kernel/src/syscall/mount.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/mount.rs\nrename to kernel/src/syscall/mount.rs\ndiff --git a/kernel/aster-nix/src/syscall/mprotect.rs b/kernel/src/syscall/mprotect.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/mprotect.rs\nrename to kernel/src/syscall/mprotect.rs\ndiff --git a/kernel/aster-nix/src/syscall/msync.rs b/kernel/src/syscall/msync.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/msync.rs\nrename to kernel/src/syscall/msync.rs\ndiff --git a/kernel/aster-nix/src/syscall/munmap.rs b/kernel/src/syscall/munmap.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/munmap.rs\nrename to kernel/src/syscall/munmap.rs\ndiff --git a/kernel/aster-nix/src/syscall/nanosleep.rs b/kernel/src/syscall/nanosleep.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/nanosleep.rs\nrename to kernel/src/syscall/nanosleep.rs\ndiff --git a/kernel/aster-nix/src/syscall/open.rs b/kernel/src/syscall/open.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/open.rs\nrename to kernel/src/syscall/open.rs\ndiff --git a/kernel/aster-nix/src/syscall/pause.rs b/kernel/src/syscall/pause.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/pause.rs\nrename to kernel/src/syscall/pause.rs\ndiff --git a/kernel/aster-nix/src/syscall/pipe.rs b/kernel/src/syscall/pipe.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/pipe.rs\nrename to kernel/src/syscall/pipe.rs\ndiff --git a/kernel/aster-nix/src/syscall/poll.rs b/kernel/src/syscall/poll.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/poll.rs\nrename to kernel/src/syscall/poll.rs\ndiff --git a/kernel/aster-nix/src/syscall/prctl.rs b/kernel/src/syscall/prctl.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/prctl.rs\nrename to kernel/src/syscall/prctl.rs\ndiff --git a/kernel/aster-nix/src/syscall/pread64.rs b/kernel/src/syscall/pread64.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/pread64.rs\nrename to kernel/src/syscall/pread64.rs\ndiff --git a/kernel/aster-nix/src/syscall/preadv.rs b/kernel/src/syscall/preadv.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/preadv.rs\nrename to kernel/src/syscall/preadv.rs\ndiff --git a/kernel/aster-nix/src/syscall/prlimit64.rs b/kernel/src/syscall/prlimit64.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/prlimit64.rs\nrename to kernel/src/syscall/prlimit64.rs\ndiff --git a/kernel/aster-nix/src/syscall/pselect6.rs b/kernel/src/syscall/pselect6.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/pselect6.rs\nrename to kernel/src/syscall/pselect6.rs\ndiff --git a/kernel/aster-nix/src/syscall/pwrite64.rs b/kernel/src/syscall/pwrite64.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/pwrite64.rs\nrename to kernel/src/syscall/pwrite64.rs\ndiff --git a/kernel/aster-nix/src/syscall/pwritev.rs b/kernel/src/syscall/pwritev.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/pwritev.rs\nrename to kernel/src/syscall/pwritev.rs\ndiff --git a/kernel/aster-nix/src/syscall/read.rs b/kernel/src/syscall/read.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/read.rs\nrename to kernel/src/syscall/read.rs\ndiff --git a/kernel/aster-nix/src/syscall/readlink.rs b/kernel/src/syscall/readlink.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/readlink.rs\nrename to kernel/src/syscall/readlink.rs\ndiff --git a/kernel/aster-nix/src/syscall/recvfrom.rs b/kernel/src/syscall/recvfrom.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/recvfrom.rs\nrename to kernel/src/syscall/recvfrom.rs\ndiff --git a/kernel/aster-nix/src/syscall/recvmsg.rs b/kernel/src/syscall/recvmsg.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/recvmsg.rs\nrename to kernel/src/syscall/recvmsg.rs\ndiff --git a/kernel/aster-nix/src/syscall/rename.rs b/kernel/src/syscall/rename.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/rename.rs\nrename to kernel/src/syscall/rename.rs\ndiff --git a/kernel/aster-nix/src/syscall/rmdir.rs b/kernel/src/syscall/rmdir.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/rmdir.rs\nrename to kernel/src/syscall/rmdir.rs\ndiff --git a/kernel/aster-nix/src/syscall/rt_sigaction.rs b/kernel/src/syscall/rt_sigaction.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/rt_sigaction.rs\nrename to kernel/src/syscall/rt_sigaction.rs\ndiff --git a/kernel/aster-nix/src/syscall/rt_sigpending.rs b/kernel/src/syscall/rt_sigpending.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/rt_sigpending.rs\nrename to kernel/src/syscall/rt_sigpending.rs\ndiff --git a/kernel/aster-nix/src/syscall/rt_sigprocmask.rs b/kernel/src/syscall/rt_sigprocmask.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/rt_sigprocmask.rs\nrename to kernel/src/syscall/rt_sigprocmask.rs\ndiff --git a/kernel/aster-nix/src/syscall/rt_sigreturn.rs b/kernel/src/syscall/rt_sigreturn.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/rt_sigreturn.rs\nrename to kernel/src/syscall/rt_sigreturn.rs\ndiff --git a/kernel/aster-nix/src/syscall/rt_sigsuspend.rs b/kernel/src/syscall/rt_sigsuspend.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/rt_sigsuspend.rs\nrename to kernel/src/syscall/rt_sigsuspend.rs\ndiff --git a/kernel/aster-nix/src/syscall/sched_getaffinity.rs b/kernel/src/syscall/sched_getaffinity.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/sched_getaffinity.rs\nrename to kernel/src/syscall/sched_getaffinity.rs\ndiff --git a/kernel/aster-nix/src/syscall/sched_yield.rs b/kernel/src/syscall/sched_yield.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/sched_yield.rs\nrename to kernel/src/syscall/sched_yield.rs\ndiff --git a/kernel/aster-nix/src/syscall/select.rs b/kernel/src/syscall/select.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/select.rs\nrename to kernel/src/syscall/select.rs\ndiff --git a/kernel/aster-nix/src/syscall/semctl.rs b/kernel/src/syscall/semctl.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/semctl.rs\nrename to kernel/src/syscall/semctl.rs\ndiff --git a/kernel/aster-nix/src/syscall/semget.rs b/kernel/src/syscall/semget.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/semget.rs\nrename to kernel/src/syscall/semget.rs\ndiff --git a/kernel/aster-nix/src/syscall/semop.rs b/kernel/src/syscall/semop.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/semop.rs\nrename to kernel/src/syscall/semop.rs\ndiff --git a/kernel/aster-nix/src/syscall/sendfile.rs b/kernel/src/syscall/sendfile.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/sendfile.rs\nrename to kernel/src/syscall/sendfile.rs\ndiff --git a/kernel/aster-nix/src/syscall/sendmsg.rs b/kernel/src/syscall/sendmsg.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/sendmsg.rs\nrename to kernel/src/syscall/sendmsg.rs\ndiff --git a/kernel/aster-nix/src/syscall/sendto.rs b/kernel/src/syscall/sendto.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/sendto.rs\nrename to kernel/src/syscall/sendto.rs\ndiff --git a/kernel/aster-nix/src/syscall/set_get_priority.rs b/kernel/src/syscall/set_get_priority.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/set_get_priority.rs\nrename to kernel/src/syscall/set_get_priority.rs\ndiff --git a/kernel/aster-nix/src/syscall/set_robust_list.rs b/kernel/src/syscall/set_robust_list.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/set_robust_list.rs\nrename to kernel/src/syscall/set_robust_list.rs\ndiff --git a/kernel/aster-nix/src/syscall/set_tid_address.rs b/kernel/src/syscall/set_tid_address.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/set_tid_address.rs\nrename to kernel/src/syscall/set_tid_address.rs\ndiff --git a/kernel/aster-nix/src/syscall/setfsgid.rs b/kernel/src/syscall/setfsgid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setfsgid.rs\nrename to kernel/src/syscall/setfsgid.rs\ndiff --git a/kernel/aster-nix/src/syscall/setfsuid.rs b/kernel/src/syscall/setfsuid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setfsuid.rs\nrename to kernel/src/syscall/setfsuid.rs\ndiff --git a/kernel/aster-nix/src/syscall/setgid.rs b/kernel/src/syscall/setgid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setgid.rs\nrename to kernel/src/syscall/setgid.rs\ndiff --git a/kernel/aster-nix/src/syscall/setgroups.rs b/kernel/src/syscall/setgroups.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setgroups.rs\nrename to kernel/src/syscall/setgroups.rs\ndiff --git a/kernel/aster-nix/src/syscall/setitimer.rs b/kernel/src/syscall/setitimer.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setitimer.rs\nrename to kernel/src/syscall/setitimer.rs\ndiff --git a/kernel/aster-nix/src/syscall/setpgid.rs b/kernel/src/syscall/setpgid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setpgid.rs\nrename to kernel/src/syscall/setpgid.rs\ndiff --git a/kernel/aster-nix/src/syscall/setregid.rs b/kernel/src/syscall/setregid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setregid.rs\nrename to kernel/src/syscall/setregid.rs\ndiff --git a/kernel/aster-nix/src/syscall/setresgid.rs b/kernel/src/syscall/setresgid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setresgid.rs\nrename to kernel/src/syscall/setresgid.rs\ndiff --git a/kernel/aster-nix/src/syscall/setresuid.rs b/kernel/src/syscall/setresuid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setresuid.rs\nrename to kernel/src/syscall/setresuid.rs\ndiff --git a/kernel/aster-nix/src/syscall/setreuid.rs b/kernel/src/syscall/setreuid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setreuid.rs\nrename to kernel/src/syscall/setreuid.rs\ndiff --git a/kernel/aster-nix/src/syscall/setsid.rs b/kernel/src/syscall/setsid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setsid.rs\nrename to kernel/src/syscall/setsid.rs\ndiff --git a/kernel/aster-nix/src/syscall/setsockopt.rs b/kernel/src/syscall/setsockopt.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setsockopt.rs\nrename to kernel/src/syscall/setsockopt.rs\ndiff --git a/kernel/aster-nix/src/syscall/setuid.rs b/kernel/src/syscall/setuid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/setuid.rs\nrename to kernel/src/syscall/setuid.rs\ndiff --git a/kernel/aster-nix/src/syscall/shutdown.rs b/kernel/src/syscall/shutdown.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/shutdown.rs\nrename to kernel/src/syscall/shutdown.rs\ndiff --git a/kernel/aster-nix/src/syscall/sigaltstack.rs b/kernel/src/syscall/sigaltstack.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/sigaltstack.rs\nrename to kernel/src/syscall/sigaltstack.rs\ndiff --git a/kernel/aster-nix/src/syscall/socket.rs b/kernel/src/syscall/socket.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/socket.rs\nrename to kernel/src/syscall/socket.rs\ndiff --git a/kernel/aster-nix/src/syscall/socketpair.rs b/kernel/src/syscall/socketpair.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/socketpair.rs\nrename to kernel/src/syscall/socketpair.rs\ndiff --git a/kernel/aster-nix/src/syscall/stat.rs b/kernel/src/syscall/stat.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/stat.rs\nrename to kernel/src/syscall/stat.rs\ndiff --git a/kernel/aster-nix/src/syscall/statfs.rs b/kernel/src/syscall/statfs.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/statfs.rs\nrename to kernel/src/syscall/statfs.rs\ndiff --git a/kernel/aster-nix/src/syscall/symlink.rs b/kernel/src/syscall/symlink.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/symlink.rs\nrename to kernel/src/syscall/symlink.rs\ndiff --git a/kernel/aster-nix/src/syscall/sync.rs b/kernel/src/syscall/sync.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/sync.rs\nrename to kernel/src/syscall/sync.rs\ndiff --git a/kernel/aster-nix/src/syscall/tgkill.rs b/kernel/src/syscall/tgkill.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/tgkill.rs\nrename to kernel/src/syscall/tgkill.rs\ndiff --git a/kernel/aster-nix/src/syscall/time.rs b/kernel/src/syscall/time.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/time.rs\nrename to kernel/src/syscall/time.rs\ndiff --git a/kernel/aster-nix/src/syscall/timer_create.rs b/kernel/src/syscall/timer_create.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/timer_create.rs\nrename to kernel/src/syscall/timer_create.rs\ndiff --git a/kernel/aster-nix/src/syscall/timer_settime.rs b/kernel/src/syscall/timer_settime.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/timer_settime.rs\nrename to kernel/src/syscall/timer_settime.rs\ndiff --git a/kernel/aster-nix/src/syscall/truncate.rs b/kernel/src/syscall/truncate.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/truncate.rs\nrename to kernel/src/syscall/truncate.rs\ndiff --git a/kernel/aster-nix/src/syscall/umask.rs b/kernel/src/syscall/umask.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/umask.rs\nrename to kernel/src/syscall/umask.rs\ndiff --git a/kernel/aster-nix/src/syscall/umount.rs b/kernel/src/syscall/umount.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/umount.rs\nrename to kernel/src/syscall/umount.rs\ndiff --git a/kernel/aster-nix/src/syscall/uname.rs b/kernel/src/syscall/uname.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/uname.rs\nrename to kernel/src/syscall/uname.rs\ndiff --git a/kernel/aster-nix/src/syscall/unlink.rs b/kernel/src/syscall/unlink.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/unlink.rs\nrename to kernel/src/syscall/unlink.rs\ndiff --git a/kernel/aster-nix/src/syscall/utimens.rs b/kernel/src/syscall/utimens.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/utimens.rs\nrename to kernel/src/syscall/utimens.rs\ndiff --git a/kernel/aster-nix/src/syscall/wait4.rs b/kernel/src/syscall/wait4.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/wait4.rs\nrename to kernel/src/syscall/wait4.rs\ndiff --git a/kernel/aster-nix/src/syscall/waitid.rs b/kernel/src/syscall/waitid.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/waitid.rs\nrename to kernel/src/syscall/waitid.rs\ndiff --git a/kernel/aster-nix/src/syscall/write.rs b/kernel/src/syscall/write.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/syscall/write.rs\nrename to kernel/src/syscall/write.rs\ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/src/taskless.rs\nsimilarity index 98%\nrename from kernel/aster-nix/src/taskless.rs\nrename to kernel/src/taskless.rs\nindex fc3f668945..a5b8f89eb1 100644\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/src/taskless.rs\n@@ -216,7 +216,7 @@ mod test {\n         let mut counter = 0;\n \n         // Schedule this taskless for `SCHEDULE_TIMES`.\n-        while taskless.is_scheduled.load(Ordering::Acquire) == false {\n+        while !taskless.is_scheduled.load(Ordering::Acquire) {\n             taskless.schedule();\n             counter += 1;\n             if counter == SCHEDULE_TIMES {\n@@ -227,7 +227,9 @@ mod test {\n         // Wait for all taskless having finished.\n         while taskless.is_running.load(Ordering::Acquire)\n             || taskless.is_scheduled.load(Ordering::Acquire)\n-        {}\n+        {\n+            core::hint::spin_loop()\n+        }\n \n         assert_eq!(counter, COUNTER.load(Ordering::Relaxed));\n     }\ndiff --git a/kernel/aster-nix/src/thread/exception.rs b/kernel/src/thread/exception.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/thread/exception.rs\nrename to kernel/src/thread/exception.rs\ndiff --git a/kernel/aster-nix/src/thread/kernel_thread.rs b/kernel/src/thread/kernel_thread.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/thread/kernel_thread.rs\nrename to kernel/src/thread/kernel_thread.rs\ndiff --git a/kernel/aster-nix/src/thread/mod.rs b/kernel/src/thread/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/thread/mod.rs\nrename to kernel/src/thread/mod.rs\ndiff --git a/kernel/aster-nix/src/thread/status.rs b/kernel/src/thread/status.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/thread/status.rs\nrename to kernel/src/thread/status.rs\ndiff --git a/kernel/aster-nix/src/thread/task.rs b/kernel/src/thread/task.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/thread/task.rs\nrename to kernel/src/thread/task.rs\ndiff --git a/kernel/aster-nix/src/thread/thread_table.rs b/kernel/src/thread/thread_table.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/thread/thread_table.rs\nrename to kernel/src/thread/thread_table.rs\ndiff --git a/kernel/aster-nix/src/thread/work_queue/mod.rs b/kernel/src/thread/work_queue/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/thread/work_queue/mod.rs\nrename to kernel/src/thread/work_queue/mod.rs\ndiff --git a/kernel/aster-nix/src/thread/work_queue/simple_scheduler.rs b/kernel/src/thread/work_queue/simple_scheduler.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/thread/work_queue/simple_scheduler.rs\nrename to kernel/src/thread/work_queue/simple_scheduler.rs\ndiff --git a/kernel/aster-nix/src/thread/work_queue/work_item.rs b/kernel/src/thread/work_queue/work_item.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/thread/work_queue/work_item.rs\nrename to kernel/src/thread/work_queue/work_item.rs\ndiff --git a/kernel/aster-nix/src/thread/work_queue/worker.rs b/kernel/src/thread/work_queue/worker.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/thread/work_queue/worker.rs\nrename to kernel/src/thread/work_queue/worker.rs\ndiff --git a/kernel/aster-nix/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/thread/work_queue/worker_pool.rs\nrename to kernel/src/thread/work_queue/worker_pool.rs\ndiff --git a/kernel/aster-nix/src/time/clocks/cpu_clock.rs b/kernel/src/time/clocks/cpu_clock.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/time/clocks/cpu_clock.rs\nrename to kernel/src/time/clocks/cpu_clock.rs\ndiff --git a/kernel/aster-nix/src/time/clocks/mod.rs b/kernel/src/time/clocks/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/time/clocks/mod.rs\nrename to kernel/src/time/clocks/mod.rs\ndiff --git a/kernel/aster-nix/src/time/clocks/system_wide.rs b/kernel/src/time/clocks/system_wide.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/time/clocks/system_wide.rs\nrename to kernel/src/time/clocks/system_wide.rs\ndiff --git a/kernel/aster-nix/src/time/core/mod.rs b/kernel/src/time/core/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/time/core/mod.rs\nrename to kernel/src/time/core/mod.rs\ndiff --git a/kernel/aster-nix/src/time/core/timer.rs b/kernel/src/time/core/timer.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/time/core/timer.rs\nrename to kernel/src/time/core/timer.rs\ndiff --git a/kernel/aster-nix/src/time/mod.rs b/kernel/src/time/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/time/mod.rs\nrename to kernel/src/time/mod.rs\ndiff --git a/kernel/aster-nix/src/time/softirq.rs b/kernel/src/time/softirq.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/time/softirq.rs\nrename to kernel/src/time/softirq.rs\ndiff --git a/kernel/aster-nix/src/time/system_time.rs b/kernel/src/time/system_time.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/time/system_time.rs\nrename to kernel/src/time/system_time.rs\ndiff --git a/kernel/aster-nix/src/time/wait.rs b/kernel/src/time/wait.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/time/wait.rs\nrename to kernel/src/time/wait.rs\ndiff --git a/kernel/aster-nix/src/util/iovec.rs b/kernel/src/util/iovec.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/iovec.rs\nrename to kernel/src/util/iovec.rs\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/src/util/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/mod.rs\nrename to kernel/src/util/mod.rs\ndiff --git a/kernel/aster-nix/src/util/net/addr/family.rs b/kernel/src/util/net/addr/family.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/net/addr/family.rs\nrename to kernel/src/util/net/addr/family.rs\ndiff --git a/kernel/aster-nix/src/util/net/addr/ip.rs b/kernel/src/util/net/addr/ip.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/net/addr/ip.rs\nrename to kernel/src/util/net/addr/ip.rs\ndiff --git a/kernel/aster-nix/src/util/net/addr/mod.rs b/kernel/src/util/net/addr/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/net/addr/mod.rs\nrename to kernel/src/util/net/addr/mod.rs\ndiff --git a/kernel/aster-nix/src/util/net/addr/unix.rs b/kernel/src/util/net/addr/unix.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/net/addr/unix.rs\nrename to kernel/src/util/net/addr/unix.rs\ndiff --git a/kernel/aster-nix/src/util/net/addr/vsock.rs b/kernel/src/util/net/addr/vsock.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/net/addr/vsock.rs\nrename to kernel/src/util/net/addr/vsock.rs\ndiff --git a/kernel/aster-nix/src/util/net/mod.rs b/kernel/src/util/net/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/net/mod.rs\nrename to kernel/src/util/net/mod.rs\ndiff --git a/kernel/aster-nix/src/util/net/options/mod.rs b/kernel/src/util/net/options/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/net/options/mod.rs\nrename to kernel/src/util/net/options/mod.rs\ndiff --git a/kernel/aster-nix/src/util/net/options/socket.rs b/kernel/src/util/net/options/socket.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/net/options/socket.rs\nrename to kernel/src/util/net/options/socket.rs\ndiff --git a/kernel/aster-nix/src/util/net/options/tcp.rs b/kernel/src/util/net/options/tcp.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/net/options/tcp.rs\nrename to kernel/src/util/net/options/tcp.rs\ndiff --git a/kernel/aster-nix/src/util/net/options/utils.rs b/kernel/src/util/net/options/utils.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/net/options/utils.rs\nrename to kernel/src/util/net/options/utils.rs\ndiff --git a/kernel/aster-nix/src/util/net/socket.rs b/kernel/src/util/net/socket.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/net/socket.rs\nrename to kernel/src/util/net/socket.rs\ndiff --git a/kernel/aster-nix/src/util/random.rs b/kernel/src/util/random.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/util/random.rs\nrename to kernel/src/util/random.rs\ndiff --git a/kernel/aster-nix/src/vdso.rs b/kernel/src/vdso.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vdso.rs\nrename to kernel/src/vdso.rs\ndiff --git a/kernel/aster-nix/src/vm/mod.rs b/kernel/src/vm/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/mod.rs\nrename to kernel/src/vm/mod.rs\ndiff --git a/kernel/aster-nix/src/vm/page_fault_handler.rs b/kernel/src/vm/page_fault_handler.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/page_fault_handler.rs\nrename to kernel/src/vm/page_fault_handler.rs\ndiff --git a/kernel/aster-nix/src/vm/perms.rs b/kernel/src/vm/perms.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/perms.rs\nrename to kernel/src/vm/perms.rs\ndiff --git a/kernel/aster-nix/src/vm/util.rs b/kernel/src/vm/util.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/util.rs\nrename to kernel/src/vm/util.rs\ndiff --git a/kernel/aster-nix/src/vm/vmar/dyn_cap.rs b/kernel/src/vm/vmar/dyn_cap.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/vmar/dyn_cap.rs\nrename to kernel/src/vm/vmar/dyn_cap.rs\ndiff --git a/kernel/aster-nix/src/vm/vmar/interval.rs b/kernel/src/vm/vmar/interval.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/vmar/interval.rs\nrename to kernel/src/vm/vmar/interval.rs\ndiff --git a/kernel/aster-nix/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/vmar/mod.rs\nrename to kernel/src/vm/vmar/mod.rs\ndiff --git a/kernel/aster-nix/src/vm/vmar/options.rs b/kernel/src/vm/vmar/options.rs\nsimilarity index 99%\nrename from kernel/aster-nix/src/vm/vmar/options.rs\nrename to kernel/src/vm/vmar/options.rs\nindex 95f9cd4d15..8af45336f8 100644\n--- a/kernel/aster-nix/src/vm/vmar/options.rs\n+++ b/kernel/src/vm/vmar/options.rs\n@@ -136,7 +136,7 @@ impl<R> VmarChildOptions<R> {\n #[cfg(ktest)]\n mod test {\n     use aster_rights::Full;\n-    use ostd::{mm::VmIo, prelude::*};\n+    use ostd::prelude::*;\n \n     use super::*;\n     use crate::vm::{\ndiff --git a/kernel/aster-nix/src/vm/vmar/static_cap.rs b/kernel/src/vm/vmar/static_cap.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/vmar/static_cap.rs\nrename to kernel/src/vm/vmar/static_cap.rs\ndiff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/vmar/vm_mapping.rs\nrename to kernel/src/vm/vmar/vm_mapping.rs\ndiff --git a/kernel/aster-nix/src/vm/vmo/dyn_cap.rs b/kernel/src/vm/vmo/dyn_cap.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/vmo/dyn_cap.rs\nrename to kernel/src/vm/vmo/dyn_cap.rs\ndiff --git a/kernel/aster-nix/src/vm/vmo/mod.rs b/kernel/src/vm/vmo/mod.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/vmo/mod.rs\nrename to kernel/src/vm/vmo/mod.rs\ndiff --git a/kernel/aster-nix/src/vm/vmo/options.rs b/kernel/src/vm/vmo/options.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/vmo/options.rs\nrename to kernel/src/vm/vmo/options.rs\ndiff --git a/kernel/aster-nix/src/vm/vmo/pager.rs b/kernel/src/vm/vmo/pager.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/vmo/pager.rs\nrename to kernel/src/vm/vmo/pager.rs\ndiff --git a/kernel/aster-nix/src/vm/vmo/static_cap.rs b/kernel/src/vm/vmo/static_cap.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/vm/vmo/static_cap.rs\nrename to kernel/src/vm/vmo/static_cap.rs\ndiff --git a/osdk/Cargo.lock b/osdk/Cargo.lock\nindex 4eefec4c61..6ee3668a08 100644\n--- a/osdk/Cargo.lock\n+++ b/osdk/Cargo.lock\n@@ -146,7 +146,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo-osdk\"\n-version = \"0.6.2\"\n+version = \"0.7.0\"\n dependencies = [\n  \"assert_cmd\",\n  \"clap\",\ndiff --git a/osdk/Cargo.toml b/osdk/Cargo.toml\nindex 7fbcb3abf5..00f4f978ad 100644\n--- a/osdk/Cargo.toml\n+++ b/osdk/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"cargo-osdk\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n edition = \"2021\"\n description = \"Accelerate OS development with Asterinas OSDK\"\n license = \"MPL-2.0\"\ndiff --git a/osdk/src/base_crate/mod.rs b/osdk/src/base_crate/mod.rs\nindex 4f1b727ae3..f7a4820526 100644\n--- a/osdk/src/base_crate/mod.rs\n+++ b/osdk/src/base_crate/mod.rs\n@@ -1,8 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n //! The base crate is the OSDK generated crate that is ultimately built by cargo.\n-//! It will depend on the kernel crate.\n-//!\n+//! It will depend on the to-be-built kernel crate or the to-be-tested crate.\n \n use std::{\n     fs,\n@@ -12,10 +11,16 @@ use std::{\n \n use crate::util::get_cargo_metadata;\n \n+/// Create a new base crate that will be built by cargo.\n+///\n+/// The dependencies of the base crate will be the target crate. If\n+/// `link_unit_test_runner` is set to true, the base crate will also depend on\n+/// the `ostd-test-runner` crate.\n pub fn new_base_crate(\n     base_crate_path: impl AsRef<Path>,\n     dep_crate_name: &str,\n     dep_crate_path: impl AsRef<Path>,\n+    link_unit_test_runner: bool,\n ) {\n     let workspace_root = {\n         let meta = get_cargo_metadata(None::<&str>, None::<&[&str]>).unwrap();\n@@ -82,7 +87,7 @@ pub fn new_base_crate(\n     fs::write(\"src/main.rs\", main_rs).unwrap();\n \n     // Add dependencies to the Cargo.toml\n-    add_manifest_dependency(dep_crate_name, dep_crate_path);\n+    add_manifest_dependency(dep_crate_name, dep_crate_path, link_unit_test_runner);\n \n     // Copy the manifest configurations from the target crate to the base crate\n     copy_profile_configurations(workspace_root);\n@@ -94,7 +99,11 @@ pub fn new_base_crate(\n     std::env::set_current_dir(original_dir).unwrap();\n }\n \n-fn add_manifest_dependency(crate_name: &str, crate_path: impl AsRef<Path>) {\n+fn add_manifest_dependency(\n+    crate_name: &str,\n+    crate_path: impl AsRef<Path>,\n+    link_unit_test_runner: bool,\n+) {\n     let mainfest_path = \"Cargo.toml\";\n \n     let mut manifest: toml::Table = {\n@@ -112,13 +121,26 @@ fn add_manifest_dependency(crate_name: &str, crate_path: impl AsRef<Path>) {\n \n     let dependencies = manifest.get_mut(\"dependencies\").unwrap();\n \n-    let dep = toml::Table::from_str(&format!(\n+    let target_dep = toml::Table::from_str(&format!(\n         \"{} = {{ path = \\\"{}\\\", default-features = false }}\",\n         crate_name,\n         crate_path.as_ref().display()\n     ))\n     .unwrap();\n-    dependencies.as_table_mut().unwrap().extend(dep);\n+    dependencies.as_table_mut().unwrap().extend(target_dep);\n+\n+    if link_unit_test_runner {\n+        let dep_str = match option_env!(\"OSDK_LOCAL_DEV\") {\n+            Some(\"1\") => \"osdk-test-kernel = { path = \\\"../../../osdk/test-kernel\\\" }\",\n+            _ => concat!(\n+                \"osdk-test-kernel = { version = \\\"\",\n+                env!(\"CARGO_PKG_VERSION\"),\n+                \"\\\" }\"\n+            ),\n+        };\n+        let test_runner_dep = toml::Table::from_str(dep_str).unwrap();\n+        dependencies.as_table_mut().unwrap().extend(test_runner_dep);\n+    }\n \n     let content = toml::to_string(&manifest).unwrap();\n     fs::write(mainfest_path, content).unwrap();\ndiff --git a/osdk/src/cli.rs b/osdk/src/cli.rs\nindex 33e29b80d6..ba052e3621 100644\n--- a/osdk/src/cli.rs\n+++ b/osdk/src/cli.rs\n@@ -49,9 +49,9 @@ pub fn main() {\n         OsdkSubcommand::Test(test_args) => {\n             execute_test_command(&load_config(&test_args.common_args), test_args);\n         }\n-        OsdkSubcommand::Check(args) => execute_forwarded_command(\"check\", &args.args),\n-        OsdkSubcommand::Clippy(args) => execute_forwarded_command(\"clippy\", &args.args),\n-        OsdkSubcommand::Doc(args) => execute_forwarded_command(\"doc\", &args.args),\n+        OsdkSubcommand::Check(args) => execute_forwarded_command(\"check\", &args.args, true),\n+        OsdkSubcommand::Clippy(args) => execute_forwarded_command(\"clippy\", &args.args, true),\n+        OsdkSubcommand::Doc(args) => execute_forwarded_command(\"doc\", &args.args, false),\n     }\n }\n \ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\nindex 10d9073079..29194b0f2f 100644\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -171,7 +171,7 @@ fn install_setup_with_arch(\n     cmd.arg(\"install\").arg(\"linux-bzimage-setup\");\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\n-    if std::env::var(\"AUTO_TEST\").is_ok() || std::env::var(\"OSDK_INTEGRATION_TEST\").is_ok() {\n+    if matches!(option_env!(\"OSDK_LOCAL_DEV\"), Some(\"1\")) {\n         cmd.arg(\"--path\")\n             .arg(\"../../../ostd/libs/linux-bzimage/setup\");\n     }\ndiff --git a/osdk/src/commands/build/mod.rs b/osdk/src/commands/build/mod.rs\nindex 8252402b2b..7f680b214e 100644\n--- a/osdk/src/commands/build/mod.rs\n+++ b/osdk/src/commands/build/mod.rs\n@@ -72,6 +72,7 @@ pub fn create_base_and_cached_build(\n         &base_crate_path,\n         &get_current_crate_info().name,\n         get_current_crate_info().path,\n+        false,\n     );\n     let original_dir = std::env::current_dir().unwrap();\n     std::env::set_current_dir(&base_crate_path).unwrap();\ndiff --git a/osdk/src/commands/mod.rs b/osdk/src/commands/mod.rs\nindex 0e279b933d..22f6b074c7 100644\n--- a/osdk/src/commands/mod.rs\n+++ b/osdk/src/commands/mod.rs\n@@ -16,8 +16,10 @@ pub use self::{\n \n use crate::arch::get_default_arch;\n \n-/// Execute the forwarded cargo command with args containing the subcommand and its arguments.\n-pub fn execute_forwarded_command(subcommand: &str, args: &Vec<String>) -> ! {\n+/// Execute the forwarded cargo command with arguments.\n+///\n+/// The `cfg_ktest` parameter controls whether `cfg(ktest)` is enabled.\n+pub fn execute_forwarded_command(subcommand: &str, args: &Vec<String>, cfg_ktest: bool) -> ! {\n     let mut cargo = util::cargo();\n     cargo.arg(subcommand).args(util::COMMON_CARGO_ARGS);\n     if !args.contains(&\"--target\".to_owned()) {\n@@ -27,6 +29,11 @@ pub fn execute_forwarded_command(subcommand: &str, args: &Vec<String>) -> ! {\n \n     let env_rustflags = std::env::var(\"RUSTFLAGS\").unwrap_or_default();\n     let rustflags = env_rustflags + \" --check-cfg cfg(ktest)\";\n+    let rustflags = if cfg_ktest {\n+        rustflags + \" --cfg ktest\"\n+    } else {\n+        rustflags\n+    };\n \n     cargo.env(\"RUSTFLAGS\", rustflags);\n \ndiff --git a/osdk/src/commands/new/kernel.template b/osdk/src/commands/new/kernel.template\nindex bb5486add9..c92050d16a 100644\n--- a/osdk/src/commands/new/kernel.template\n+++ b/osdk/src/commands/new/kernel.template\n@@ -1,4 +1,6 @@\n #![no_std]\n+// The feature `linkage` is required for `ostd::main` to work.\n+#![feature(linkage)]\n #![deny(unsafe_code)]\n \n use ostd::prelude::*;\ndiff --git a/osdk/src/config/manifest.rs b/osdk/src/config/manifest.rs\nindex 2cb750e63a..287461003f 100644\n--- a/osdk/src/config/manifest.rs\n+++ b/osdk/src/config/manifest.rs\n@@ -50,60 +50,33 @@ impl TomlManifest {\n                     .unwrap(),\n             )\n         };\n-        // All the custom schemes should inherit settings from the default scheme, this is a helper.\n-        fn finalize(current_manifest: Option<TomlManifest>) -> TomlManifest {\n-            let Some(mut current_manifest) = current_manifest else {\n-                error_msg!(\n-                    \"Cannot find `OSDK.toml` in the current directory or the workspace root\"\n-                );\n-                process::exit(Errno::GetMetadata as _);\n-            };\n-            for scheme in current_manifest.map.values_mut() {\n-                scheme.inherit(&current_manifest.default_scheme);\n-            }\n-            current_manifest\n-        }\n \n         // Search for OSDK.toml in the current directory first.\n-        let current_manifest_path = PathBuf::from(\"OSDK.toml\").canonicalize().ok();\n-        let mut current_manifest = match &current_manifest_path {\n-            Some(path) => deserialize_toml_manifest(path),\n-            None => None,\n-        };\n-        // Then search in the workspace root.\n-        let workspace_manifest_path = workspace_root.join(\"OSDK.toml\").canonicalize().ok();\n-        // The case that the current directory is also the workspace root.\n-        if let Some(current) = &current_manifest_path {\n-            if let Some(workspace) = &workspace_manifest_path {\n-                if current == workspace {\n-                    return finalize(current_manifest);\n+        let current_manifest_path = PathBuf::from(\"OSDK.toml\").canonicalize();\n+        let current_manifest = match &current_manifest_path {\n+            Ok(path) => deserialize_toml_manifest(path),\n+            Err(_) => {\n+                // If not found, search in the workspace root.\n+                if let Ok(workspace_manifest_path) = workspace_root.join(\"OSDK.toml\").canonicalize()\n+                {\n+                    deserialize_toml_manifest(workspace_manifest_path)\n+                } else {\n+                    None\n                 }\n             }\n-        }\n-        let workspace_manifest = match workspace_manifest_path {\n-            Some(path) => deserialize_toml_manifest(path),\n-            None => None,\n         };\n-        // The current manifest should inherit settings from the workspace manifest.\n-        if let Some(workspace_manifest) = workspace_manifest {\n-            if current_manifest.is_none() {\n-                current_manifest = Some(workspace_manifest);\n-            } else {\n-                // Inherit one scheme at a time.\n-                let current_manifest = current_manifest.as_mut().unwrap();\n-                current_manifest\n-                    .default_scheme\n-                    .inherit(&workspace_manifest.default_scheme);\n-                for (scheme_string, scheme) in workspace_manifest.map {\n-                    let current_scheme = current_manifest\n-                        .map\n-                        .entry(scheme_string)\n-                        .or_insert_with(Scheme::empty);\n-                    current_scheme.inherit(&scheme);\n-                }\n-            }\n+\n+        let Some(mut current_manifest) = current_manifest else {\n+            error_msg!(\"Cannot find `OSDK.toml` in the current directory or the workspace root\");\n+            process::exit(Errno::GetMetadata as _);\n+        };\n+\n+        // All the schemes should inherit from the default scheme.\n+        for scheme in current_manifest.map.values_mut() {\n+            scheme.inherit(&current_manifest.default_scheme);\n         }\n-        finalize(current_manifest)\n+\n+        current_manifest\n     }\n \n     /// Get the scheme given the scheme from the command line arguments.\ndiff --git a/osdk/src/error.rs b/osdk/src/error.rs\nindex b266c8f593..1dfdeaa17f 100644\n--- a/osdk/src/error.rs\n+++ b/osdk/src/error.rs\n@@ -10,6 +10,7 @@ pub enum Errno {\n     ExecuteCommand = 5,\n     BuildCrate = 6,\n     RunBundle = 7,\n+    BadCrateName = 8,\n }\n \n /// Print error message to console\ndiff --git a/ostd/Cargo.toml b/ostd/Cargo.toml\nindex c1d357cf0d..e232964a9e 100644\n--- a/ostd/Cargo.toml\n+++ b/ostd/Cargo.toml\n@@ -1,6 +1,6 @@\n [package]\n name = \"ostd\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n edition = \"2021\"\n description = \"Rust OS framework that facilitates the development of and innovation in OS kernels\"\n license = \"MPL-2.0\"\ndiff --git a/ostd/libs/ostd-macros/src/lib.rs b/ostd/libs/ostd-macros/src/lib.rs\nindex 93466626b9..869d75a182 100644\n--- a/ostd/libs/ostd-macros/src/lib.rs\n+++ b/ostd/libs/ostd-macros/src/lib.rs\n@@ -7,12 +7,13 @@ use quote::quote;\n use rand::{distributions::Alphanumeric, Rng};\n use syn::{parse_macro_input, Expr, Ident, ItemFn};\n \n-/// This macro is used to mark the kernel entry point.\n+/// A macro attribute to mark the kernel entry point.\n ///\n /// # Example\n ///\n /// ```ignore\n /// #![no_std]\n+/// #![feature(linkage)]\n ///\n /// use ostd::prelude::*;\n ///\n@@ -28,8 +29,37 @@ pub fn main(_attr: TokenStream, item: TokenStream) -> TokenStream {\n \n     quote!(\n         #[no_mangle]\n-        pub fn __ostd_main() -> ! {\n-            ostd::init();\n+        #[linkage = \"weak\"]\n+        extern \"Rust\" fn __ostd_main() -> ! {\n+            // SAFETY: The function is called only once on the BSP.\n+            unsafe { ostd::init() };\n+            #main_fn_name();\n+            ostd::prelude::abort();\n+        }\n+\n+        #main_fn\n+    )\n+    .into()\n+}\n+\n+/// A macro attribute for the unit test kernel entry point.\n+///\n+/// This macro is used for internal OSDK implementation. Do not use it\n+/// directly.\n+///\n+/// It is a strong version of the `main` macro attribute. So if it exists (\n+/// which means the unit test kernel is linked to perform testing), the actual\n+/// kernel entry point will be replaced by this one.\n+#[proc_macro_attribute]\n+pub fn test_main(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    let main_fn = parse_macro_input!(item as ItemFn);\n+    let main_fn_name = &main_fn.sig.ident;\n+\n+    quote!(\n+        #[no_mangle]\n+        extern \"Rust\" fn __ostd_main() -> ! {\n+            // SAFETY: The function is called only once on the BSP.\n+            unsafe { ostd::init() };\n             #main_fn_name();\n             ostd::prelude::abort();\n         }\ndiff --git a/ostd/src/boot/mod.rs b/ostd/src/boot/mod.rs\nindex 627c674aa5..2bd462f25b 100644\n--- a/ostd/src/boot/mod.rs\n+++ b/ostd/src/boot/mod.rs\n@@ -115,8 +115,9 @@ pub fn init() {\n ///\n /// Any kernel that uses the `ostd` crate should define a function marked with\n /// `ostd::main` as the entrypoint.\n-pub fn call_ostd_main() -> ! {\n-    #[cfg(not(ktest))]\n+///\n+/// This function should be only called from the bootloader-specific module.\n+pub(crate) fn call_ostd_main() -> ! {\n     unsafe {\n         // The entry point of kernel code, which should be defined by the package that\n         // uses OSTD.\n@@ -125,42 +126,4 @@ pub fn call_ostd_main() -> ! {\n         }\n         __ostd_main();\n     }\n-    #[cfg(ktest)]\n-    unsafe {\n-        use crate::task::TaskOptions;\n-\n-        crate::init();\n-        // The whitelists that will be generated by OSDK runner as static consts.\n-        extern \"Rust\" {\n-            static KTEST_TEST_WHITELIST: Option<&'static [&'static str]>;\n-            static KTEST_CRATE_WHITELIST: Option<&'static [&'static str]>;\n-        }\n-\n-        let test_task = move || {\n-            run_ktests(KTEST_TEST_WHITELIST, KTEST_CRATE_WHITELIST);\n-        };\n-        let _ = TaskOptions::new(test_task).data(()).spawn();\n-        unreachable!(\"The spawn method will NOT return in the boot context\")\n-    }\n-}\n-\n-fn run_ktests(test_whitelist: Option<&[&str]>, crate_whitelist: Option<&[&str]>) -> ! {\n-    use alloc::{boxed::Box, string::ToString};\n-    use core::any::Any;\n-\n-    use crate::arch::qemu::{exit_qemu, QemuExitCode};\n-\n-    let fn_catch_unwind = &(unwinding::panic::catch_unwind::<(), fn()>\n-        as fn(fn()) -> Result<(), Box<(dyn Any + Send + 'static)>>);\n-\n-    use ostd_test::runner::{run_ktests, KtestResult};\n-    match run_ktests(\n-        &crate::console::early_print,\n-        fn_catch_unwind,\n-        test_whitelist.map(|s| s.iter().map(|s| s.to_string())),\n-        crate_whitelist,\n-    ) {\n-        KtestResult::Ok => exit_qemu(QemuExitCode::Success),\n-        KtestResult::Failed => exit_qemu(QemuExitCode::Failed),\n-    };\n }\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\nindex 215d57e4e5..4d25097733 100644\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -56,10 +56,15 @@ pub(crate) use crate::cpu::local::cpu_local_cell;\n /// This function represents the first phase booting up the system. It makes\n /// all functionalities of OSTD available after the call.\n ///\n-/// TODO: We need to refactor this function to make it more modular and\n-/// make inter-initialization-dependencies more clear and reduce usages of\n-/// boot stage only global variables.\n-pub fn init() {\n+/// # Safety\n+///\n+/// This function should be called only once and only on the BSP.\n+//\n+// TODO: We need to refactor this function to make it more modular and\n+// make inter-initialization-dependencies more clear and reduce usages of\n+// boot stage only global variables.\n+#[doc(hidden)]\n+pub unsafe fn init() {\n     arch::enable_cpu_features();\n     arch::serial::init();\n \n@@ -114,6 +119,7 @@ mod test {\n     use crate::prelude::*;\n \n     #[ktest]\n+    #[allow(clippy::eq_op)]\n     fn trivial_assertion() {\n         assert_eq!(0, 0);\n     }\n@@ -131,8 +137,14 @@ mod test {\n     }\n }\n \n-/// The module re-exports everything from the ktest crate\n-#[cfg(ktest)]\n+#[doc(hidden)]\n pub mod ktest {\n+    //! The module re-exports everything from the [`ostd_test`] crate, as well\n+    //! as the test entry point macro.\n+    //!\n+    //! It is rather discouraged to use the definitions here directly. The\n+    //! `ktest` attribute is sufficient for all normal use cases.\n+\n+    pub use ostd_macros::test_main as main;\n     pub use ostd_test::*;\n }\ndiff --git a/ostd/src/mm/dma/dma_stream.rs b/ostd/src/mm/dma/dma_stream.rs\nindex 56d9828add..00dd6f961d 100644\n--- a/ostd/src/mm/dma/dma_stream.rs\n+++ b/ostd/src/mm/dma/dma_stream.rs\n@@ -334,9 +334,10 @@ mod test {\n             .alloc_contiguous()\n             .unwrap();\n         let vm_segment_child = vm_segment_parent.range(0..1);\n-        let _dma_stream_parent =\n+        let dma_stream_parent =\n             DmaStream::map(vm_segment_parent, DmaDirection::Bidirectional, false);\n         let dma_stream_child = DmaStream::map(vm_segment_child, DmaDirection::Bidirectional, false);\n+        assert!(dma_stream_parent.is_ok());\n         assert!(dma_stream_child.is_err());\n     }\n \ndiff --git a/ostd/src/sync/atomic_bits.rs b/ostd/src/sync/atomic_bits.rs\nindex 1b92799e81..3ddeeac4bb 100644\n--- a/ostd/src/sync/atomic_bits.rs\n+++ b/ostd/src/sync/atomic_bits.rs\n@@ -313,24 +313,24 @@ mod test {\n     fn set_get() {\n         let bits = AtomicBits::new_zeroes(128);\n         for i in 0..bits.len() {\n-            assert!(bits.get(i) == false);\n+            assert!(!bits.get(i));\n \n             bits.set(i, true);\n-            assert!(bits.get(i) == true);\n+            assert!(bits.get(i));\n \n             bits.set(i, false);\n-            assert!(bits.get(i) == false);\n+            assert!(!bits.get(i));\n         }\n \n         let bits = AtomicBits::new_ones(128);\n         for i in 0..bits.len() {\n-            assert!(bits.get(i) == true);\n+            assert!(bits.get(i));\n \n             bits.set(i, false);\n-            assert!(bits.get(i) == false);\n+            assert!(!bits.get(i));\n \n             bits.set(i, true);\n-            assert!(bits.get(i) == true);\n+            assert!(bits.get(i));\n         }\n     }\n \n@@ -389,9 +389,9 @@ mod test {\n     #[ktest]\n     fn iter() {\n         let bits = AtomicBits::new_zeroes(7);\n-        assert!(bits.iter().all(|bit| bit == false));\n+        assert!(bits.iter().all(|bit| !bit));\n \n         let bits = AtomicBits::new_ones(128);\n-        assert!(bits.iter().all(|bit| bit == true));\n+        assert!(bits.iter().all(|bit| bit));\n     }\n }\ndiff --git a/ostd/src/sync/wait.rs b/ostd/src/sync/wait.rs\nindex 2aa6011706..56ca700c05 100644\n--- a/ostd/src/sync/wait.rs\n+++ b/ostd/src/sync/wait.rs\n@@ -293,7 +293,7 @@ mod test {\n             Task::yield_now();\n \n             cond_cloned.store(true, Ordering::Relaxed);\n-            wake(&*queue_cloned);\n+            wake(&queue_cloned);\n         })\n         .data(())\n         .spawn()\ndiff --git a/ostd/src/task/task/mod.rs b/ostd/src/task/task/mod.rs\nindex 9604232a2f..8bf1cc93d7 100644\n--- a/ostd/src/task/task/mod.rs\n+++ b/ostd/src/task/task/mod.rs\n@@ -383,6 +383,7 @@ mod test {\n \n     #[ktest]\n     fn create_task() {\n+        #[allow(clippy::eq_op)]\n         let task = || {\n             assert_eq!(1, 1);\n         };\n@@ -395,6 +396,7 @@ mod test {\n \n     #[ktest]\n     fn spawn_task() {\n+        #[allow(clippy::eq_op)]\n         let task = || {\n             assert_eq!(1, 1);\n         };\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\nindex ecf828d2bc..410fcb63c6 100755\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -20,6 +20,13 @@ update_package_version() {\n     sed -i \"0,/${pattern}/s/${pattern}/version = \\\"${new_version}\\\"/1\" $1\n }\n \n+# Update the version of the `ostd` dependency (`ostd = { version = \"\", ...`) in file $1\n+update_ostd_dep_version() {\n+    echo \"Updating file $1\"\n+    pattern=\"^ostd = { version = \\\"[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+\\\"\"\n+    sed -i \"0,/${pattern}/s/${pattern}/ostd = { version = \\\"${new_version}\\\"/1\" $1\n+}\n+\n # Update Docker image versions (`asterinas/asterinas:{version}`) in file $1\n update_image_versions() {\n     echo \"Updating file $1\"\n@@ -98,6 +105,7 @@ ASTER_SRC_DIR=${SCRIPT_DIR}/..\n DOCS_DIR=${ASTER_SRC_DIR}/docs\n OSTD_CARGO_TOML_PATH=${ASTER_SRC_DIR}/ostd/Cargo.toml\n OSDK_CARGO_TOML_PATH=${ASTER_SRC_DIR}/osdk/Cargo.toml\n+OSTD_TEST_RUNNER_CARGO_TOML_PATH=${ASTER_SRC_DIR}/osdk/test-kernel/Cargo.toml\n VERSION_PATH=${ASTER_SRC_DIR}/VERSION\n \n current_version=$(cat ${VERSION_PATH})\n@@ -114,9 +122,11 @@ new_version=$(bump_version ${current_version})\n # Update the package version in Cargo.toml\n update_package_version ${OSTD_CARGO_TOML_PATH}\n update_package_version ${OSDK_CARGO_TOML_PATH}\n+update_package_version ${OSTD_TEST_RUNNER_CARGO_TOML_PATH}\n+update_ostd_dep_version ${OSTD_TEST_RUNNER_CARGO_TOML_PATH}\n \n # Automatically bump Cargo.lock file\n-cargo update -p asterinas --precise $new_version\n+cargo update -p aster-nix --precise $new_version\n \n # Update Docker image versions in README files\n update_image_versions ${ASTER_SRC_DIR}/README.md\n@@ -142,4 +152,4 @@ update_image_versions $GET_STARTED_PATH\n # `-n` is used to avoid adding a '\\n' in the VERSION file.\n echo -n \"${new_version}\" > ${VERSION_PATH}\n \n-echo \"Bumped Asterinas & OSDK version to $new_version\"\n+echo \"Bumped Asterinas OSTD & OSDK version to $new_version\"\n", "test_patch": "diff --git a/.github/workflows/test_asterinas.yml b/.github/workflows/test_asterinas.yml\nindex 5e299f64c9..1a4d1f4060 100644\n--- a/.github/workflows/test_asterinas.yml\n+++ b/.github/workflows/test_asterinas.yml\n@@ -14,9 +14,9 @@ jobs:\n     if: github.event_name == 'push' || github.event_name == 'pull_request'\n     runs-on: ubuntu-latest\n     timeout-minutes: 15\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     steps:\n-      - run: echo \"Running in asterinas/asterinas:0.7.0\"\n+      - run: echo \"Running in asterinas/asterinas:0.8.0\"\n \n       - uses: actions/checkout@v4\n       \n@@ -28,9 +28,9 @@ jobs:\n     if: github.event_name == 'push' || github.event_name == 'pull_request'\n     runs-on: ubuntu-latest\n     timeout-minutes: 15\n-    container: asterinas/asterinas:0.7.0\n+    container: asterinas/asterinas:0.8.0\n     steps:\n-      - run: echo \"Running in asterinas/asterinas:0.7.0\"\n+      - run: echo \"Running in asterinas/asterinas:0.8.0\"\n \n       - uses: actions/checkout@v4\n \n@@ -49,10 +49,10 @@ jobs:\n     runs-on: ubuntu-latest\n     timeout-minutes: 30\n     container:\n-      image: asterinas/asterinas:0.7.0\n+      image: asterinas/asterinas:0.8.0\n       options: --device=/dev/kvm\n     steps:\n-      - run: echo \"Running in asterinas/asterinas:0.7.0\"\n+      - run: echo \"Running in asterinas/asterinas:0.8.0\"\n \n       - uses: actions/checkout@v4\n \n@@ -88,7 +88,7 @@ jobs:\n     runs-on: self-hosted\n     timeout-minutes: 30\n     container:\n-      image: asterinas/asterinas:0.7.0-tdx\n+      image: asterinas/asterinas:0.8.0-tdx\n       options: --device=/dev/kvm --privileged\n     env:\n       # Need to set up proxy since the self-hosted CI server is located in China,\n@@ -96,7 +96,7 @@ jobs:\n       RUSTUP_DIST_SERVER: https://mirrors.ustc.edu.cn/rust-static\n       RUSTUP_UPDATE_ROOT: https://mirrors.ustc.edu.cn/rust-static/rustup\n     steps:\n-      - run: echo \"Running in asterinas/asterinas:0.7.0-tdx\"\n+      - run: echo \"Running in asterinas/asterinas:0.8.0-tdx\"\n       - uses: actions/checkout@v4\n       - name: Set up the environment\n         run: |\ndiff --git a/.github/workflows/test_asterinas_vsock.yml b/.github/workflows/test_asterinas_vsock.yml\nindex 97b1a83d41..1125ba8d68 100644\n--- a/.github/workflows/test_asterinas_vsock.yml\n+++ b/.github/workflows/test_asterinas_vsock.yml\n@@ -23,7 +23,7 @@ jobs:\n         run: |\n             docker run \\\n               --privileged --network=host --device=/dev/kvm \\\n-              -v ./:/root/asterinas asterinas/asterinas:0.7.0 \\\n+              -v ./:/root/asterinas asterinas/asterinas:0.8.0 \\\n               make run AUTO_TEST=vsock ENABLE_KVM=0 SCHEME=microvm RELEASE_MODE=1 &\n       - name: Run Vsock Client on Host\n         id: host_vsock_client\ndiff --git a/.github/workflows/test_osdk.yml b/.github/workflows/test_osdk.yml\nindex e07e53358a..71b1d3617a 100644\n--- a/.github/workflows/test_osdk.yml\n+++ b/.github/workflows/test_osdk.yml\n@@ -21,9 +21,9 @@ jobs:\n     timeout-minutes: 30\n     strategy:\n       matrix:\n-        # asterinas/asterinas:0.7.0 container is the developing container of asterinas,\n-        # asterinas/osdk:0.7.0 container is built with the intructions from Asterinas Book\n-        container: ['asterinas/asterinas:0.7.0', 'asterinas/osdk:0.7.0']\n+        # asterinas/asterinas:0.8.0 container is the developing container of asterinas,\n+        # asterinas/osdk:0.8.0 container is built with the intructions from Asterinas Book\n+        container: ['asterinas/asterinas:0.8.0', 'asterinas/osdk:0.8.0']\n     container: ${{ matrix.container }}\n     steps:\n       - run: echo \"Running in ${{ matrix.container }}\"\n@@ -32,7 +32,7 @@ jobs:\n \n       - name: Lint\n         id: lint\n-        if: matrix.container == 'asterinas/asterinas:0.7.0'\n+        if: matrix.container == 'asterinas/asterinas:0.8.0'\n         run: make check_osdk\n \n       # Github's actions/checkout@v4 will result in a new user (not root) \n@@ -56,9 +56,9 @@ jobs:\n       RUSTUP_UPDATE_ROOT: https://mirrors.ustc.edu.cn/rust-static/rustup\n     strategy:\n       matrix:\n-        # asterinas/asterinas:0.7.0-tdx container is the developing container of asterinas,\n-        # asterinas/osdk:0.7.0-tdx container is built with the intructions from Asterinas Book\n-        container: ['asterinas/asterinas:0.7.0-tdx', 'asterinas/osdk:0.7.0-tdx']\n+        # asterinas/asterinas:0.8.0-tdx container is the developing container of asterinas,\n+        # asterinas/osdk:0.8.0-tdx container is built with the intructions from Asterinas Book\n+        container: ['asterinas/asterinas:0.8.0-tdx', 'asterinas/osdk:0.8.0-tdx']\n     container: \n       image: ${{ matrix.container }}\n       options: --device=/dev/kvm --privileged\n@@ -67,7 +67,7 @@ jobs:\n       - uses: actions/checkout@v4\n       - name: Lint\n         id: lint\n-        if: matrix.container == 'asterinas/asterinas:0.7.0-tdx'\n+        if: matrix.container == 'asterinas/asterinas:0.8.0-tdx'\n         run: make check_osdk\n       # Github's actions/checkout@v4 will result in a new user (not root) \n       # and thus not using the Rust environment we set up in the container. \ndiff --git a/kernel/aster-nix/src/fs/utils/random_test.rs b/kernel/src/fs/utils/random_test.rs\nsimilarity index 100%\nrename from kernel/aster-nix/src/fs/utils/random_test.rs\nrename to kernel/src/fs/utils/random_test.rs\ndiff --git a/osdk/src/commands/test.rs b/osdk/src/commands/test.rs\nindex e3d0865e86..327ebd476a 100644\n--- a/osdk/src/commands/test.rs\n+++ b/osdk/src/commands/test.rs\n@@ -7,6 +7,8 @@ use crate::{\n     base_crate::new_base_crate,\n     cli::TestArgs,\n     config::{scheme::ActionChoice, Config},\n+    error::Errno,\n+    error_msg,\n     util::{\n         get_cargo_metadata, get_current_crate_info, get_target_directory, parse_package_id_string,\n     },\n@@ -25,7 +27,26 @@ pub fn test_current_crate(config: &Config, args: &TestArgs) {\n     let cargo_target_directory = get_target_directory();\n     let osdk_output_directory = cargo_target_directory.join(DEFAULT_TARGET_RELPATH);\n     let target_crate_dir = osdk_output_directory.join(\"base\");\n-    new_base_crate(&target_crate_dir, &current_crate.name, &current_crate.path);\n+\n+    // A special case is that we use OSDK to test the OSDK test runner crate\n+    // itself. We check it by name.\n+    let runner_self_test = if current_crate.name == \"osdk-test-kernel\" {\n+        if matches!(option_env!(\"OSDK_LOCAL_DEV\"), Some(\"1\")) {\n+            true\n+        } else {\n+            error_msg!(\"The tested crate name collides with the OSDK test runner crate\");\n+            std::process::exit(Errno::BadCrateName as _);\n+        }\n+    } else {\n+        false\n+    };\n+\n+    new_base_crate(\n+        &target_crate_dir,\n+        &current_crate.name,\n+        &current_crate.path,\n+        !runner_self_test,\n+    );\n \n     let main_rs_path = target_crate_dir.join(\"src\").join(\"main.rs\");\n \n@@ -39,19 +60,29 @@ pub fn test_current_crate(config: &Config, args: &TestArgs) {\n         ktest_crate_whitelist.push(name.clone());\n     }\n \n-    let ktest_static_var = format!(\n+    // Append the ktest static variable and the runner reference to the\n+    // `main.rs` file.\n+    let ktest_main_rs = format!(\n         r#\"\n+\n+{}\n+\n #[no_mangle]\n pub static KTEST_TEST_WHITELIST: Option<&[&str]> = {};\n #[no_mangle]\n pub static KTEST_CRATE_WHITELIST: Option<&[&str]> = Some(&{:#?});\n+\n \"#,\n-        ktest_test_whitelist, ktest_crate_whitelist,\n+        if runner_self_test {\n+            \"\"\n+        } else {\n+            \"extern crate osdk_test_kernel;\"\n+        },\n+        ktest_test_whitelist,\n+        ktest_crate_whitelist,\n     );\n-\n-    // Append the ktest static variable to the main.rs file\n     let mut main_rs_content = fs::read_to_string(&main_rs_path).unwrap();\n-    main_rs_content.push_str(&ktest_static_var);\n+    main_rs_content.push_str(&ktest_main_rs);\n     fs::write(&main_rs_path, main_rs_content).unwrap();\n \n     // Build the kernel with the given base crate\ndiff --git a/osdk/test-kernel/Cargo.toml b/osdk/test-kernel/Cargo.toml\nnew file mode 100644\nindex 0000000000..c2e1bac1b4\n--- /dev/null\n+++ b/osdk/test-kernel/Cargo.toml\n@@ -0,0 +1,14 @@\n+[package]\n+name = \"osdk-test-kernel\"\n+version = \"0.8.0\"\n+edition = \"2021\"\n+description = \"The OSTD-based kernel for running unit tests with OSDK.\"\n+license = \"MPL-2.0\"\n+repository =\"https://github.com/asterinas/asterinas\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+ostd = { version = \"0.8.0\", path = \"../../ostd\" }\n+owo-colors = \"4.0.0\"\n+unwinding = { version = \"0.2.2\", default-features = false, features = [\"fde-gnu-eh-frame-hdr\", \"hide-trace\", \"panic\", \"personality\", \"unwinder\"] }\ndiff --git a/ostd/libs/ostd-test/src/runner.rs b/osdk/test-kernel/src/lib.rs\nsimilarity index 57%\nrename from ostd/libs/ostd-test/src/runner.rs\nrename to osdk/test-kernel/src/lib.rs\nindex 1fc16fd00f..164ce20ce3 100644\n--- a/ostd/libs/ostd-test/src/runner.rs\n+++ b/osdk/test-kernel/src/lib.rs\n@@ -1,24 +1,59 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-//! Test runner enabling control over the tests.\n-//!\n+//! The OSTD unit test runner is a kernel that runs the tests defined by the\n+//! `#[ostd::ktest]` attribute. The kernel should be automatically selected to\n+//! run when OSDK is used to test a specific crate.\n \n-use alloc::{collections::BTreeSet, string::String, vec::Vec};\n-use core::format_args;\n+#![no_std]\n+#![forbid(unsafe_code)]\n \n-use owo_colors::OwoColorize;\n+extern crate alloc;\n+\n+mod path;\n+mod tree;\n+\n+use alloc::{boxed::Box, collections::BTreeSet, string::String, vec::Vec};\n+use core::{any::Any, format_args};\n \n-use crate::{\n-    path::{KtestPath, SuffixTrie},\n-    tree::{KtestCrate, KtestTree},\n-    CatchUnwindImpl, KtestError, KtestItem, KtestIter,\n+use ostd::{\n+    early_print,\n+    ktest::{\n+        get_ktest_crate_whitelist, get_ktest_test_whitelist, KtestError, KtestItem, KtestIter,\n+    },\n };\n+use owo_colors::OwoColorize;\n+use path::{KtestPath, SuffixTrie};\n+use tree::{KtestCrate, KtestTree};\n \n pub enum KtestResult {\n     Ok,\n     Failed,\n }\n \n+/// The entry point of the test runner.\n+#[ostd::ktest::main]\n+fn main() {\n+    use ostd::task::TaskOptions;\n+\n+    let test_task = move || {\n+        use alloc::string::ToString;\n+\n+        use ostd::arch::qemu::{exit_qemu, QemuExitCode};\n+\n+        match run_ktests(\n+            get_ktest_test_whitelist().map(|s| s.iter().map(|s| s.to_string())),\n+            get_ktest_crate_whitelist(),\n+        ) {\n+            KtestResult::Ok => exit_qemu(QemuExitCode::Success),\n+            KtestResult::Failed => exit_qemu(QemuExitCode::Failed),\n+        };\n+    };\n+\n+    let _ = TaskOptions::new(test_task).data(()).spawn();\n+\n+    unreachable!(\"The spawn method will NOT return in the boot context\")\n+}\n+\n /// Run all the tests registered by `#[ktest]` in the `.ktest_array` section.\n ///\n /// Need to provide a print function `print` to print the test result, and a `catch_unwind`\n@@ -32,27 +67,18 @@ pub enum KtestResult {\n ///\n /// If a test inside a crate fails, the test runner will continue to run the rest of the tests\n /// inside the crate. But the tests in the following crates will not be run.\n-pub fn run_ktests<PrintFn, PathsIter>(\n-    print: &PrintFn,\n-    catch_unwind: &CatchUnwindImpl,\n+fn run_ktests<PathsIter>(\n     test_whitelist: Option<PathsIter>,\n     crate_whitelist: Option<&[&str]>,\n ) -> KtestResult\n where\n-    PrintFn: Fn(core::fmt::Arguments),\n     PathsIter: Iterator<Item = String>,\n {\n-    macro_rules! print {\n-        ($fmt: literal $(, $($arg: tt)+)?) => {\n-            print(format_args!($fmt $(, $($arg)+)?))\n-        }\n-    }\n-\n     let whitelist_trie =\n         test_whitelist.map(|paths| SuffixTrie::from_paths(paths.map(|p| KtestPath::from(&p))));\n \n     let tree = KtestTree::from_iter(KtestIter::new());\n-    print!(\n+    early_print!(\n         \"\\n[ktest runner] running {} tests in {} crates\\n\",\n         tree.nr_tot_tests(),\n         tree.nr_tot_crates()\n@@ -62,36 +88,22 @@ where\n     for crate_ in tree.iter() {\n         if let Some(crate_set) = &crate_set {\n             if !crate_set.contains(crate_.name()) {\n-                print!(\"\\n[ktest runner] skipping crate \\\"{}\\\".\\n\", crate_.name());\n+                early_print!(\"\\n[ktest runner] skipping crate \\\"{}\\\".\\n\", crate_.name());\n                 continue;\n             }\n         }\n-        match run_crate_ktests(crate_, print, catch_unwind, &whitelist_trie) {\n+        match run_crate_ktests(crate_, &whitelist_trie) {\n             KtestResult::Ok => {}\n             KtestResult::Failed => return KtestResult::Failed,\n         }\n     }\n-    print!(\"\\n[ktest runner] All crates tested.\\n\");\n+    early_print!(\"\\n[ktest runner] All crates tested.\\n\");\n     KtestResult::Ok\n }\n \n-fn run_crate_ktests<PrintFn>(\n-    crate_: &KtestCrate,\n-    print: &PrintFn,\n-    catch_unwind: &CatchUnwindImpl,\n-    whitelist: &Option<SuffixTrie>,\n-) -> KtestResult\n-where\n-    PrintFn: Fn(core::fmt::Arguments),\n-{\n-    macro_rules! print {\n-        ($fmt: literal $(, $($arg: tt)+)?) => {\n-            print(format_args!($fmt $(, $($arg)+)?))\n-        }\n-    }\n-\n+fn run_crate_ktests(crate_: &KtestCrate, whitelist: &Option<SuffixTrie>) -> KtestResult {\n     let crate_name = crate_.name();\n-    print!(\n+    early_print!(\n         \"\\nrunning {} tests in crate \\\"{}\\\"\\n\\n\",\n         crate_.nr_tot_tests(),\n         crate_name\n@@ -110,19 +122,22 @@ where\n                     continue;\n                 }\n             }\n-            print!(\n+            early_print!(\n                 \"test {}::{} ...\",\n                 test.info().module_path,\n                 test.info().fn_name\n             );\n             debug_assert_eq!(test.info().package, crate_name);\n-            match test.run(catch_unwind) {\n+            match test.run(\n+                &(unwinding::panic::catch_unwind::<(), fn()>\n+                    as fn(fn()) -> Result<(), Box<(dyn Any + Send + 'static)>>),\n+            ) {\n                 Ok(()) => {\n-                    print!(\" {}\\n\", \"ok\".green());\n+                    early_print!(\" {}\\n\", \"ok\".green());\n                     passed += 1;\n                 }\n                 Err(e) => {\n-                    print!(\" {}\\n\", \"FAILED\".red());\n+                    early_print!(\" {}\\n\", \"FAILED\".red());\n                     failed_tests.push((test.clone(), e.clone()));\n                 }\n             }\n@@ -130,19 +145,21 @@ where\n     }\n     let failed = failed_tests.len();\n     if failed == 0 {\n-        print!(\"\\ntest result: {}.\", \"ok\".green());\n+        early_print!(\"\\ntest result: {}.\", \"ok\".green());\n     } else {\n-        print!(\"\\ntest result: {}.\", \"FAILED\".red());\n+        early_print!(\"\\ntest result: {}.\", \"FAILED\".red());\n     }\n-    print!(\n+    early_print!(\n         \" {} passed; {} failed; {} filtered out.\\n\",\n-        passed, failed, filtered\n+        passed,\n+        failed,\n+        filtered\n     );\n     assert!(passed + failed + filtered == crate_.nr_tot_tests());\n     if failed > 0 {\n-        print!(\"\\nfailures:\\n\\n\");\n+        early_print!(\"\\nfailures:\\n\\n\");\n         for (t, e) in failed_tests {\n-            print!(\n+            early_print!(\n                 \"---- {}:{}:{} - {} ----\\n\\n\",\n                 t.info().source,\n                 t.info().line,\n@@ -151,18 +168,18 @@ where\n             );\n             match e {\n                 KtestError::Panic(s) => {\n-                    print!(\"[caught panic] {}\\n\", s);\n+                    early_print!(\"[caught panic] {}\\n\", s);\n                 }\n                 KtestError::ShouldPanicButNoPanic => {\n-                    print!(\"test did not panic as expected\\n\");\n+                    early_print!(\"test did not panic as expected\\n\");\n                 }\n                 KtestError::ExpectedPanicNotMatch(expected, s) => {\n-                    print!(\"[caught panic] expected panic not match\\n\");\n-                    print!(\"expected: {}\\n\", expected);\n-                    print!(\"caught: {}\\n\", s);\n+                    early_print!(\"[caught panic] expected panic not match\\n\");\n+                    early_print!(\"expected: {}\\n\", expected);\n+                    early_print!(\"caught: {}\\n\", s);\n                 }\n                 KtestError::Unknown => {\n-                    print!(\"[caught panic] unknown panic payload! (fatal panic handling error in ktest)\\n\");\n+                    early_print!(\"[caught panic] unknown panic payload! (fatal panic handling error in ktest)\\n\");\n                 }\n             }\n         }\ndiff --git a/ostd/libs/ostd-test/src/path.rs b/osdk/test-kernel/src/path.rs\nsimilarity index 98%\nrename from ostd/libs/ostd-test/src/path.rs\nrename to osdk/test-kernel/src/path.rs\nindex 434acb49be..b6a973e711 100644\n--- a/ostd/libs/ostd-test/src/path.rs\n+++ b/osdk/test-kernel/src/path.rs\n@@ -112,11 +112,13 @@ impl Display for KtestPath {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(ktest)]\n mod path_test {\n+    use ostd::prelude::ktest;\n+\n     use super::*;\n \n-    #[test]\n+    #[ktest]\n     fn test_ktest_path() {\n         let mut path = KtestPath::new();\n         path.push_back(\"a\");\n@@ -129,7 +131,7 @@ mod path_test {\n         assert_eq!(path.pop_back(), None);\n     }\n \n-    #[test]\n+    #[ktest]\n     fn test_ktest_path_starts_with() {\n         let mut path = KtestPath::new();\n         path.push_back(\"a\");\n@@ -144,7 +146,7 @@ mod path_test {\n         assert!(!path.starts_with(&KtestPath::from(\"d\")));\n     }\n \n-    #[test]\n+    #[ktest]\n     fn test_ktest_path_ends_with() {\n         let mut path = KtestPath::new();\n         path.push_back(\"a\");\n@@ -238,8 +240,10 @@ impl Default for SuffixTrie {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(ktest)]\n mod suffix_trie_test {\n+    use ostd::prelude::ktest;\n+\n     use super::*;\n \n     static TEST_PATHS: &[&str] = &[\n@@ -252,7 +256,7 @@ mod suffix_trie_test {\n         \"m::n\",\n     ];\n \n-    #[test]\n+    #[ktest]\n     fn test_contains() {\n         let trie = SuffixTrie::from_paths(TEST_PATHS.iter().map(|&s| KtestPath::from(s)));\n \n@@ -269,7 +273,7 @@ mod suffix_trie_test {\n         assert!(!trie.contains(KtestPath::from(\"n\").iter()));\n     }\n \n-    #[test]\n+    #[ktest]\n     fn test_matches() {\n         let trie = SuffixTrie::from_paths(TEST_PATHS.iter().map(|&s| KtestPath::from(s)));\n \ndiff --git a/ostd/libs/ostd-test/src/tree.rs b/osdk/test-kernel/src/tree.rs\nsimilarity index 97%\nrename from ostd/libs/ostd-test/src/tree.rs\nrename to osdk/test-kernel/src/tree.rs\nindex 3d908fd9aa..a822a776a6 100644\n--- a/ostd/libs/ostd-test/src/tree.rs\n+++ b/osdk/test-kernel/src/tree.rs\n@@ -213,21 +213,21 @@ impl<'a> Iterator for KtestModuleIter<'a> {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(ktest)]\n mod tests {\n+    use ostd::prelude::ktest;\n+\n     use super::*;\n \n     macro_rules! gen_test_case {\n         () => {{\n-            fn dummy_fn() {\n-                ()\n-            }\n+            fn dummy_fn() {}\n             let mut tree = KtestTree::new();\n             let new = |m: &'static str, f: &'static str, p: &'static str| {\n                 KtestItem::new(\n                     dummy_fn,\n                     (false, None),\n-                    crate::KtestItemInfo {\n+                    ostd::ktest::KtestItemInfo {\n                         module_path: m,\n                         fn_name: f,\n                         package: p,\n@@ -250,7 +250,7 @@ mod tests {\n         }};\n     }\n \n-    #[test]\n+    #[ktest]\n     fn test_tree_iter() {\n         let tree = gen_test_case!();\n         let mut iter = tree.iter();\n@@ -261,7 +261,7 @@ mod tests {\n         assert!(iter.next().is_none());\n     }\n \n-    #[test]\n+    #[ktest]\n     fn test_crate_iter() {\n         let tree = gen_test_case!();\n         for crate_ in tree.iter() {\n@@ -285,7 +285,7 @@ mod tests {\n         }\n     }\n \n-    #[test]\n+    #[ktest]\n     fn test_module_iter() {\n         let tree = gen_test_case!();\n         let mut collection = Vec::<&KtestItem>::new();\n@@ -293,7 +293,7 @@ mod tests {\n             for mov in crate_.iter() {\n                 let module = mov;\n                 for test in module.iter() {\n-                    collection.push(&test);\n+                    collection.push(test);\n                 }\n             }\n         }\ndiff --git a/osdk/tests/examples_in_book/work_in_workspace_templates/myos/src/lib.rs b/osdk/tests/examples_in_book/work_in_workspace_templates/myos/src/lib.rs\nindex a8fc07f1d0..a5cd52cd9d 100644\n--- a/osdk/tests/examples_in_book/work_in_workspace_templates/myos/src/lib.rs\n+++ b/osdk/tests/examples_in_book/work_in_workspace_templates/myos/src/lib.rs\n@@ -1,6 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n #![no_std]\n+#![feature(linkage)]\n #![deny(unsafe_code)]\n \n use ostd::prelude::*;\ndiff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\nindex 9fbfde5115..b7d9235425 100644\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -1,6 +1,8 @@\n // SPDX-License-Identifier: MPL-2.0\n \n #![no_std]\n+// The feature `linkage` is required for `ostd::main` to work.\n+#![feature(linkage)]\n \n extern crate alloc;\n \ndiff --git a/ostd/libs/ostd-test/Cargo.toml b/ostd/libs/ostd-test/Cargo.toml\nindex 82d4bcacf7..5b8e6f9492 100644\n--- a/ostd/libs/ostd-test/Cargo.toml\n+++ b/ostd/libs/ostd-test/Cargo.toml\n@@ -2,11 +2,8 @@\n name = \"ostd-test\"\n version = \"0.1.0\"\n edition = \"2021\"\n-description = \"The kernel mode testing framework of OSTD\"\n+description = \"The kernel mode unit testing framework of OSTD\"\n license = \"MPL-2.0\"\n repository =\"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n-\n-[dependencies]\n-owo-colors = \"3.5.0\"\ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\nindex 3ec04c6085..b4fd65d595 100644\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -45,12 +45,6 @@\n //!\n //! Any crates using the ostd-test framework should be linked with ostd.\n //!\n-//! ```toml\n-//! # Cargo.toml\n-//! [dependencies]\n-//! ostd = { path = \"relative/path/to/ostd\" }\n-//! ```\n-//!\n //! By the way, `#[ktest]` attribute along also works, but it hinders test control\n //! using cfgs since plain attribute marked test will be executed in all test runs\n //! no matter what cfgs are passed to the compiler. More importantly, using `#[ktest]`\n@@ -58,27 +52,10 @@\n //! explicitly stripped in normal builds.\n //!\n //! Rust cfg is used to control the compilation of the test module. In cooperation\n-//! with the `ktest` framework, the Makefile will set the `RUSTFLAGS` environment\n-//! variable to pass the cfgs to all rustc invocations. To run the tests, you simply\n-//! need to set a list of cfgs by specifying `KTEST=1` to the Makefile, e.g.:\n-//!\n-//! ```bash\n-//! make run KTEST=1\n-//! ```\n-//!\n-//! Also, you can run a subset of tests by specifying the `KTEST_WHITELIST` variable.\n-//! This is achieved by a whitelist filter on the test name.\n-//!\n-//! ```bash\n-//! make run KTEST=1 KTEST_WHITELIST=failing_assertion,ostd::test::expect_panic\n-//! ```\n-//!\n-//! `KTEST_CRATES` variable is used to specify in which crates the tests to be run.\n-//! This is achieved by conditionally compiling the test module using the `#[cfg]`.\n-//!\n-//! ```bash\n-//! make run KTEST=1 KTEST_CRATES=ostd\n-//! ``\n+//! with the `ktest` framework, OSDK will set the `RUSTFLAGS` environment variable\n+//! to pass the cfgs to all rustc invocations. To run the tests, you simply need\n+//! to use the command `cargo osdk test` in the crate directory. For more information,\n+//! please refer to the OSDK documentation.\n //!\n //! We support the `#[should_panic]` attribute just in the same way as the standard\n //! library do, but the implementation is quite slow currently. Use it with cautious.\n@@ -90,10 +67,6 @@\n #![cfg_attr(not(test), no_std)]\n #![feature(panic_info_message)]\n \n-pub mod path;\n-pub mod runner;\n-pub mod tree;\n-\n extern crate alloc;\n use alloc::{boxed::Box, string::String};\n \n@@ -113,6 +86,7 @@ impl core::fmt::Display for PanicInfo {\n     }\n }\n \n+/// The error that may occur during the test.\n #[derive(Clone)]\n pub enum KtestError {\n     Panic(Box<PanicInfo>),\n@@ -121,13 +95,22 @@ pub enum KtestError {\n     Unknown,\n }\n \n+/// The information of the unit test.\n #[derive(Clone, PartialEq, Debug)]\n pub struct KtestItemInfo {\n+    /// The path of the module, not including the function name.\n+    ///\n+    /// It would be separated by `::`.\n     pub module_path: &'static str,\n+    /// The name of the unit test function.\n     pub fn_name: &'static str,\n+    /// The name of the crate.\n     pub package: &'static str,\n+    /// The source file where the test function resides.\n     pub source: &'static str,\n+    /// The line number of the test function in the file.\n     pub line: usize,\n+    /// The column number of the test function in the file.\n     pub col: usize,\n }\n \n@@ -141,6 +124,11 @@ pub struct KtestItem {\n type CatchUnwindImpl = fn(f: fn() -> ()) -> Result<(), Box<dyn core::any::Any + Send>>;\n \n impl KtestItem {\n+    /// Create a new [`KtestItem`].\n+    ///\n+    /// Do not use this function directly. Instead, use the `#[ktest]`\n+    /// attribute to mark the test function.\n+    #[doc(hidden)]\n     pub const fn new(\n         fn_: fn() -> (),\n         should_panic: (bool, Option<&'static str>),\n@@ -153,6 +141,7 @@ impl KtestItem {\n         }\n     }\n \n+    /// Get the information of the test.\n     pub fn info(&self) -> &KtestItemInfo {\n         &self.info\n     }\n@@ -206,12 +195,22 @@ macro_rules! ktest_array {\n     }};\n }\n \n+/// The iterator of the ktest array.\n pub struct KtestIter {\n     index: usize,\n }\n \n+impl Default for KtestIter {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n impl KtestIter {\n-    fn new() -> Self {\n+    /// Create a new [`KtestIter`].\n+    ///\n+    /// It will iterate over all the tests (marked with `#[ktest]`).\n+    pub fn new() -> Self {\n         Self { index: 0 }\n     }\n }\n@@ -225,3 +224,28 @@ impl core::iter::Iterator for KtestIter {\n         Some(ktest_item.clone())\n     }\n }\n+\n+// The whitelists that will be generated by the OSDK as static consts.\n+// They deliver the target tests that the user wants to run.\n+extern \"Rust\" {\n+    static KTEST_TEST_WHITELIST: Option<&'static [&'static str]>;\n+    static KTEST_CRATE_WHITELIST: Option<&'static [&'static str]>;\n+}\n+\n+/// Get the whitelist of the tests.\n+///\n+/// The whitelist is generated by the OSDK runner, indicating name of the\n+/// target tests that the user wants to run.\n+pub fn get_ktest_test_whitelist() -> Option<&'static [&'static str]> {\n+    // SAFETY: The two extern statics in the base crate are generated by OSDK.\n+    unsafe { KTEST_TEST_WHITELIST }\n+}\n+\n+/// Get the whitelist of the crates.\n+///\n+/// The whitelist is generated by the OSDK runner, indicating the target crate\n+/// that the user wants to test.\n+pub fn get_ktest_crate_whitelist() -> Option<&'static [&'static str]> {\n+    // SAFETY: The two extern statics in the base crate are generated by OSDK.\n+    unsafe { KTEST_CRATE_WHITELIST }\n+}\n", "problem_statement": "ktest as a kernel\n<!-- Thank you for taking the time to propose a new idea or significant change. Please provide a comprehensive overview of the concepts and motivations at play. -->\r\n\r\n### Summary\r\n\r\n<!-- Briefly summarize the idea, change, or feature you are proposing. What is it about, and what does it aim to achieve? -->\r\n\r\nWell, I want to make ktest as a kernel built on top of aster-frame (OSTD), and run as a kernel. Currently the ktest crate is a dependency of aster-frame, which leads to many problems such as:\r\n - a lot of runtime needed when running ktest, which need to be passed as parameters #834 ;\r\n - need to pass cfg to aster-frame when rebuilding the test #974 ;\r\n\r\nBy making ktest a kernel depending on aster-frame, which has it's entrypoint as `#[aster_main]` (`#[ostd::main]`), it works for all the above problems.\r\n\r\n### Context and Problem Statement\r\n\r\n<!-- Describe the problem or inadequacy of the current situation/state that your proposal is addressing. This is a key aspect of putting your RFC into context. -->\r\n\r\n### Proposal\r\n\r\n<!-- Clearly and comprehensively describe your proposal including high-level technical specifics, any new interfaces or APIs, and how it should integrate into the existing system. -->\r\n\r\nOriginally the dependency chain of testing a target crate `A` is:\r\n\r\n```text\r\nktest <---------------- ostd <--- A <--- base_crate\r\n                       /         / \r\nktest_proc_macro <----'---------'\r\n```\r\n\r\nThe proposed one is:\r\n\r\n```text\r\n\r\n        .-- ktest <----(if testing)----.\r\n        v                               \\\r\n  .-- ostd <---------- A <--------- base_crate\r\n  v                   /\r\nktest_proc_macro <---'\r\n```\r\n\r\nInstead of a conditional compilation to choose the ktest entry point at `aster_frame::boot::call_aster_main`, the ktest entry point should be registered as **STRONG** `#[aster_main]`, while other kernel's `#[aster_main]` should be WEAK. So during linking, if the ktest main exist ktests will be excecuted, other wise kernel main would be executed.\r\n\r\n### Motivation and Rationale\r\n\r\n<!-- Elaborate on why this proposal is important. Provide justifications for why it should be considered and what benefits it brings. Include use cases, user stories, and pain points it intends to solve. -->\r\n\r\n### Detailed Design\r\n\r\n<!-- Dive into the nitty-gritty details of your proposal. Discuss possible implementation strategies, potential issues, and how the proposal would alter workflows, behaviors, or structures. Include pseudocode, diagrams, or mock-ups if possible. -->\r\n\r\n### Alternatives Considered\r\n\r\n<!-- Detail any alternative solutions or features you've considered. Why were they discarded in favor of this proposal? -->\r\n\r\n### Additional Information and Resources\r\n\r\n<!-- Offer any additional information, context, links, or resources that stakeholders might find helpful for understanding the proposal. -->\r\n\r\n### Open Questions\r\n\r\n<!-- List any questions that you have that might need further discussion. This can include areas where you are seeking feedback or require input to finalize decisions. -->\r\n\r\n### Future Possibilities\r\n\r\n<!-- If your RFC is likely to lead to subsequent changes, provide a brief outline of what those might be and how your proposal may lay the groundwork for them. -->\r\n\r\n<!-- We appreciate your effort in contributing to the evolution of our system and look forward to reviewing and discussing your ideas! -->\r\n\n", "hints_text": "This proposal aims to address to problems.\r\n\r\n> * a lot of runtime needed when running ktest, which need to be passed as parameters https://github.com/asterinas/asterinas/pull/834 ;\r\n> * need to pass cfg to aster-frame when rebuilding the test https://github.com/asterinas/asterinas/issues/974 ;\r\n\r\nI can see why this proposal is able to resolve the first problem. But why can it address the second?\n> The proposed one is:\r\n\r\n```plain\r\n        .-- ktest <----(if testing)----.\r\n        v                               \\\r\n  .-- ostd <---------- A <--------- base_crate\r\n  v                   /\r\nktest_proc_macro <---'\r\n```\r\n\r\nUsers don't need to be aware of the existence of the `ktest_proc_macro` and `ktest` crates, correct? The `ktest` crate is solely a dependency of the `base_crate`, and the `ktest_proc_macro` is now re-exported from `ostd`. Therefore, the crate A to be tested can only depend on `ostd`.\nDue to the current implementation of both `#[ostd::ktest]` and `ktest` relying on `KtestItem` and `KtestItemInfo`, we cannot directly move `ktest` above `ostd`.\r\n\r\nThe most naive implementation would be to move the logic for running `ktest` to the top level, creating a `ktest_run`. However, the definition of `KtestItem` would still need to be retained within `OSTD` to allow the use of `#[ostd::ktest]`. This approach would still leave `OSTD` partially dependent on `ktest`.\r\n\r\n```text\r\n\t\t            .-- ktest_run <---(if testing)---.\r\n\t\t            v                                 \\\r\n  ktest_proc_macro <-----ostd <---------- A <------------- base_crate\r\n               \\\t  v            \r\n                .----->  ktest \r\n```\r\n\r\nAn alternative solution might be to place the parameters that originally needed to be wrapped in `KtestItem` into a `.ktest_array`, and then retrieve these parameters to generate `KtestItem` objects during execution. However, this might not be an elegant solution.\r\n\r\nI haven't been able to think of a better approach\u2639\ufe0f. Could you give me some input @junyang-zh ?\n> The most naive implementation would be to move the logic for running `ktest` to the top level, creating a `ktest_run`. However, the definition of `KtestItem` would still need to be retained within `OSTD` to allow the use of `#[ostd::ktest]`. This approach would still leave `OSTD` partially dependent on `ktest`.\r\n> \r\n> ```\r\n> \t\t            .-- ktest_run <---(if testing)---.\r\n> \t\t            v                                 \\\r\n>   ktest_proc_macro <-----ostd <---------- A <------------- base_crate\r\n>                \\\t  v            \r\n>                 .----->  ktest \r\n> ```\r\n\r\nYour question makes sense. And the best solution I can think of is just like yours, splitting the crate into two.\r\n\r\nSo it seems that we are just making the ktest runner a kernel. The ktest item definitions are still a dependency of OSTD.", "created_at": "2024-08-13T11:21:28Z", "version": "0.7"}, {"repo": "asterinas/asterinas", "pull_number": 1158, "instance_id": "asterinas__asterinas-1158", "issue_numbers": ["1264"], "base_commit": "c68302f7007225fa47f22a1085a8c59dcdae2ad4", "patch": "diff --git a/kernel/src/sched/priority_scheduler.rs b/kernel/src/sched/priority_scheduler.rs\nindex b2aaecdad6..dc33bd12f1 100644\n--- a/kernel/src/sched/priority_scheduler.rs\n+++ b/kernel/src/sched/priority_scheduler.rs\n@@ -50,12 +50,12 @@ impl<T: PreemptSchedInfo> PreemptScheduler<T> {\n         let mut minimum_load = usize::MAX;\n \n         for candidate in runnable.cpu_affinity().iter() {\n-            let rq = self.rq[candidate].lock();\n+            let rq = self.rq[candidate as usize].lock();\n             // A wild guess measuring the load of a runqueue. We assume that\n             // real-time tasks are 4-times as important as normal tasks.\n             let load = rq.real_time_entities.len() * 4 + rq.normal_entities.len();\n             if load < minimum_load {\n-                selected = candidate as u32;\n+                selected = candidate;\n                 minimum_load = load;\n             }\n         }\ndiff --git a/kernel/src/thread/work_queue/simple_scheduler.rs b/kernel/src/thread/work_queue/simple_scheduler.rs\nindex 963b44dd9f..4cc8bb99ba 100644\n--- a/kernel/src/thread/work_queue/simple_scheduler.rs\n+++ b/kernel/src/thread/work_queue/simple_scheduler.rs\n@@ -24,12 +24,12 @@ impl WorkerScheduler for SimpleScheduler {\n     fn schedule(&self) {\n         let worker_pool = self.worker_pool.upgrade().unwrap();\n         for cpu_id in worker_pool.cpu_set().iter() {\n-            if !worker_pool.heartbeat(cpu_id as u32)\n-                && worker_pool.has_pending_work_items(cpu_id as u32)\n-                && !worker_pool.wake_worker(cpu_id as u32)\n-                && worker_pool.num_workers(cpu_id as u32) < WORKER_LIMIT\n+            if !worker_pool.heartbeat(cpu_id)\n+                && worker_pool.has_pending_work_items(cpu_id)\n+                && !worker_pool.wake_worker(cpu_id)\n+                && worker_pool.num_workers(cpu_id) < WORKER_LIMIT\n             {\n-                worker_pool.add_worker(cpu_id as u32);\n+                worker_pool.add_worker(cpu_id);\n             }\n         }\n     }\ndiff --git a/kernel/src/thread/work_queue/worker_pool.rs b/kernel/src/thread/work_queue/worker_pool.rs\nindex c3fd6dd0b7..c12167b0ee 100644\n--- a/kernel/src/thread/work_queue/worker_pool.rs\n+++ b/kernel/src/thread/work_queue/worker_pool.rs\n@@ -128,10 +128,7 @@ impl WorkerPool {\n         Arc::new_cyclic(|pool_ref| {\n             let mut local_pools = Vec::new();\n             for cpu_id in cpu_set.iter() {\n-                local_pools.push(Arc::new(LocalWorkerPool::new(\n-                    pool_ref.clone(),\n-                    cpu_id as u32,\n-                )));\n+                local_pools.push(Arc::new(LocalWorkerPool::new(pool_ref.clone(), cpu_id)));\n             }\n             WorkerPool {\n                 local_pools,\ndiff --git a/kernel/src/vm/vmar/mod.rs b/kernel/src/vm/vmar/mod.rs\nindex af91f2e647..b46f55b957 100644\n--- a/kernel/src/vm/vmar/mod.rs\n+++ b/kernel/src/vm/vmar/mod.rs\n@@ -336,7 +336,7 @@ impl Vmar_ {\n         if !self.is_root_vmar() {\n             return_errno_with_message!(Errno::EACCES, \"The vmar is not root vmar\");\n         }\n-        self.vm_space.clear();\n+        self.clear_vm_space();\n         let mut inner = self.inner.lock();\n         inner.child_vmar_s.clear();\n         inner.vm_mappings.clear();\n@@ -346,6 +346,13 @@ impl Vmar_ {\n         Ok(())\n     }\n \n+    fn clear_vm_space(&self) {\n+        let start = ROOT_VMAR_LOWEST_ADDR;\n+        let end = ROOT_VMAR_CAP_ADDR;\n+        let mut cursor = self.vm_space.cursor_mut(&(start..end)).unwrap();\n+        cursor.unmap(end - start);\n+    }\n+\n     pub fn destroy(&self, range: Range<usize>) -> Result<()> {\n         self.check_destroy_range(&range)?;\n         let mut inner = self.inner.lock();\ndiff --git a/kernel/src/vm/vmar/vm_mapping.rs b/kernel/src/vm/vmar/vm_mapping.rs\nindex 6fc0a6ff7c..3ced68bcaf 100644\n--- a/kernel/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/src/vm/vmar/vm_mapping.rs\n@@ -167,16 +167,6 @@ impl VmMapping {\n         self.vmo.as_ref()\n     }\n \n-    /// Adds a new committed page and map it to vmspace. If copy on write is set, it's allowed to unmap the page at the same address.\n-    /// FIXME: This implementation based on the truth that we map one page at a time. If multiple pages are mapped together, this implementation may have problems\n-    fn map_one_page(&self, map_addr: usize, frame: Frame, is_readonly: bool) -> Result<()> {\n-        let parent = self.parent.upgrade().unwrap();\n-        let vm_space = parent.vm_space();\n-        self.inner\n-            .lock()\n-            .map_one_page(vm_space, map_addr, frame, is_readonly)\n-    }\n-\n     /// Returns the mapping's start address.\n     pub fn map_to_addr(&self) -> Vaddr {\n         self.inner.lock().map_to_addr\n@@ -193,11 +183,6 @@ impl VmMapping {\n         self.inner.lock().map_size\n     }\n \n-    /// Returns the mapping's offset in the VMO.\n-    pub fn vmo_offset(&self) -> Option<usize> {\n-        self.inner.lock().vmo_offset\n-    }\n-\n     /// Unmaps pages in the range\n     pub fn unmap(&self, range: &Range<usize>, may_destroy: bool) -> Result<()> {\n         let parent = self.parent.upgrade().unwrap();\n@@ -234,43 +219,84 @@ impl VmMapping {\n \n         let page_aligned_addr = page_fault_addr.align_down(PAGE_SIZE);\n \n+        let root_vmar = self.parent.upgrade().unwrap();\n+        let mut cursor = root_vmar\n+            .vm_space()\n+            .cursor_mut(&(page_aligned_addr..page_aligned_addr + PAGE_SIZE))?;\n+        let current_mapping = cursor.query().unwrap();\n+\n+        // Perform COW if it is a write access to a shared mapping.\n         if write && !not_present {\n-            // Perform COW at page table.\n-            let root_vmar = self.parent.upgrade().unwrap();\n-            let mut cursor = root_vmar\n-                .vm_space()\n-                .cursor_mut(&(page_aligned_addr..page_aligned_addr + PAGE_SIZE))?;\n             let VmItem::Mapped {\n                 va: _,\n                 frame,\n                 mut prop,\n-            } = cursor.query().unwrap()\n+            } = current_mapping\n             else {\n                 return Err(Error::new(Errno::EFAULT));\n             };\n \n-            if self.is_shared {\n+            // Skip if the page fault is already handled.\n+            if prop.flags.contains(PageFlags::W) {\n+                return Ok(());\n+            }\n+\n+            // If the forked child or parent immediately unmaps the page after\n+            // the fork without accessing it, we are the only reference to the\n+            // frame. We can directly map the frame as writable without\n+            // copying. In this case, the reference count of the frame is 2 (\n+            // one for the mapping and one for the frame handle itself).\n+            let only_reference = frame.reference_count() == 2;\n+\n+            if self.is_shared || only_reference {\n                 cursor.protect(PAGE_SIZE, |p| p.flags |= PageFlags::W);\n             } else {\n                 let new_frame = duplicate_frame(&frame)?;\n-                prop.flags |= PageFlags::W;\n+                prop.flags |= PageFlags::W | PageFlags::ACCESSED | PageFlags::DIRTY;\n                 cursor.map(new_frame, prop);\n             }\n             return Ok(());\n         }\n \n-        let (frame, is_readonly) = self.prepare_page(page_fault_addr, write)?;\n+        // Map a new frame to the page fault address.\n+        // Skip if the page fault is already handled.\n+        if let VmItem::NotMapped { .. } = current_mapping {\n+            let inner_lock = self.inner.lock();\n+            let (frame, is_readonly) = self.prepare_page(&inner_lock, page_fault_addr, write)?;\n+\n+            let vm_perms = {\n+                let mut perms = inner_lock.perms;\n+                if is_readonly {\n+                    // COW pages are forced to be read-only.\n+                    perms -= VmPerms::WRITE;\n+                }\n+                perms\n+            };\n+            let mut page_flags = vm_perms.into();\n+            page_flags |= PageFlags::ACCESSED;\n+            if write {\n+                page_flags |= PageFlags::DIRTY;\n+            }\n+            let map_prop = PageProperty::new(page_flags, CachePolicy::Writeback);\n+\n+            cursor.map(frame, map_prop);\n+        }\n \n-        self.map_one_page(page_aligned_addr, frame, is_readonly)\n+        Ok(())\n     }\n \n-    fn prepare_page(&self, page_fault_addr: Vaddr, write: bool) -> Result<(Frame, bool)> {\n+    fn prepare_page(\n+        &self,\n+        inner_lock: &MutexGuard<VmMappingInner>,\n+        page_fault_addr: Vaddr,\n+        write: bool,\n+    ) -> Result<(Frame, bool)> {\n         let mut is_readonly = false;\n         let Some(vmo) = &self.vmo else {\n             return Ok((FrameAllocOptions::new(1).alloc_single()?, is_readonly));\n         };\n \n-        let vmo_offset = self.vmo_offset().unwrap() + page_fault_addr - self.map_to_addr();\n+        let vmo_offset = inner_lock.vmo_offset.unwrap() + page_fault_addr - inner_lock.map_to_addr;\n         let page_idx = vmo_offset / PAGE_SIZE;\n         let Ok(page) = vmo.get_committed_frame(page_idx) else {\n             if !self.is_shared {\n@@ -314,14 +340,18 @@ impl VmMapping {\n         );\n \n         let vm_perms = inner.perms - VmPerms::WRITE;\n-        let vm_map_options = { PageProperty::new(vm_perms.into(), CachePolicy::Writeback) };\n         let parent = self.parent.upgrade().unwrap();\n         let vm_space = parent.vm_space();\n         let mut cursor = vm_space.cursor_mut(&(start_addr..end_addr))?;\n         let operate = move |commit_fn: &mut dyn FnMut() -> Result<Frame>| {\n-            if let VmItem::NotMapped { .. } = cursor.query().unwrap() {\n+            if let VmItem::NotMapped { va, len } = cursor.query().unwrap() {\n+                let mut page_flags = vm_perms.into();\n+                if (va..len).contains(&page_fault_addr) {\n+                    page_flags |= PageFlags::ACCESSED;\n+                }\n+                let page_prop = PageProperty::new(page_flags, CachePolicy::Writeback);\n                 let frame = commit_fn()?;\n-                cursor.map(frame, vm_map_options);\n+                cursor.map(frame, page_prop);\n             } else {\n                 let next_addr = cursor.virt_addr() + PAGE_SIZE;\n                 if next_addr < end_addr {\n@@ -507,30 +537,6 @@ impl VmMapping {\n }\n \n impl VmMappingInner {\n-    fn map_one_page(\n-        &mut self,\n-        vm_space: &VmSpace,\n-        map_addr: usize,\n-        frame: Frame,\n-        is_readonly: bool,\n-    ) -> Result<()> {\n-        let map_range = map_addr..map_addr + PAGE_SIZE;\n-\n-        let vm_perms = {\n-            let mut perms = self.perms;\n-            if is_readonly {\n-                // COW pages are forced to be read-only.\n-                perms -= VmPerms::WRITE;\n-            }\n-            perms\n-        };\n-        let map_prop = PageProperty::new(vm_perms.into(), CachePolicy::Writeback);\n-\n-        let mut cursor = vm_space.cursor_mut(&map_range).unwrap();\n-        cursor.map(frame, map_prop);\n-        Ok(())\n-    }\n-\n     /// Unmap pages in the range.\n     fn unmap(&mut self, vm_space: &VmSpace, range: &Range<usize>, may_destroy: bool) -> Result<()> {\n         let map_addr = range.start.align_down(PAGE_SIZE);\ndiff --git a/ostd/src/arch/x86/boot/smp.rs b/ostd/src/arch/x86/boot/smp.rs\nindex 5a2596e01c..55df785205 100644\n--- a/ostd/src/arch/x86/boot/smp.rs\n+++ b/ostd/src/arch/x86/boot/smp.rs\n@@ -150,7 +150,7 @@ fn send_startup_to_all_aps() {\n         (AP_BOOT_START_PA / PAGE_SIZE) as u8,\n     );\n     // SAFETY: we are sending startup IPI to all APs.\n-    apic::borrow(|apic| unsafe { apic.send_ipi(icr) });\n+    apic::with_borrow(|apic| unsafe { apic.send_ipi(icr) });\n }\n \n fn send_init_to_all_aps() {\n@@ -165,7 +165,7 @@ fn send_init_to_all_aps() {\n         0,\n     );\n     // SAFETY: we are sending init IPI to all APs.\n-    apic::borrow(|apic| unsafe { apic.send_ipi(icr) });\n+    apic::with_borrow(|apic| unsafe { apic.send_ipi(icr) });\n }\n \n fn send_init_deassert() {\n@@ -180,7 +180,7 @@ fn send_init_deassert() {\n         0,\n     );\n     // SAFETY: we are sending deassert IPI to all APs.\n-    apic::borrow(|apic| unsafe { apic.send_ipi(icr) });\n+    apic::with_borrow(|apic| unsafe { apic.send_ipi(icr) });\n }\n \n /// Spin wait approximately `c` cycles.\ndiff --git a/ostd/src/arch/x86/irq.rs b/ostd/src/arch/x86/irq.rs\nindex f4cb86548f..e3dbd329a8 100644\n--- a/ostd/src/arch/x86/irq.rs\n+++ b/ostd/src/arch/x86/irq.rs\n@@ -153,3 +153,27 @@ impl Drop for IrqCallbackHandle {\n         CALLBACK_ID_ALLOCATOR.get().unwrap().lock().free(self.id);\n     }\n }\n+\n+/// Sends a general inter-processor interrupt (IPI) to the specified CPU.\n+///\n+/// # Safety\n+///\n+/// The caller must ensure that the CPU ID and the interrupt number corresponds\n+/// to a safe function to call.\n+pub(crate) unsafe fn send_ipi(cpu_id: u32, irq_num: u8) {\n+    use crate::arch::kernel::apic::{self, Icr};\n+\n+    let icr = Icr::new(\n+        apic::ApicId::from(cpu_id),\n+        apic::DestinationShorthand::NoShorthand,\n+        apic::TriggerMode::Edge,\n+        apic::Level::Assert,\n+        apic::DeliveryStatus::Idle,\n+        apic::DestinationMode::Physical,\n+        apic::DeliveryMode::Fixed,\n+        irq_num,\n+    );\n+    apic::with_borrow(|apic| {\n+        apic.send_ipi(icr);\n+    });\n+}\ndiff --git a/ostd/src/arch/x86/kernel/apic/mod.rs b/ostd/src/arch/x86/kernel/apic/mod.rs\nindex 855bc83c41..e06370d584 100644\n--- a/ostd/src/arch/x86/kernel/apic/mod.rs\n+++ b/ostd/src/arch/x86/kernel/apic/mod.rs\n@@ -13,7 +13,7 @@ pub mod x2apic;\n pub mod xapic;\n \n cpu_local! {\n-    static APIC_INSTANCE: Once<RefCell<Box<dyn Apic + 'static>>> = Once::new();\n+    static APIC_INSTANCE: RefCell<Option<Box<dyn Apic + 'static>>> = RefCell::new(None);\n }\n \n static APIC_TYPE: Once<ApicType> = Once::new();\n@@ -24,23 +24,29 @@ static APIC_TYPE: Once<ApicType> = Once::new();\n /// local APIC instance. During the execution of the closure, the interrupts\n /// are guaranteed to be disabled.\n ///\n+/// This function also lazily initializes the Local APIC instance. It does\n+/// enable the Local APIC if it is not enabled.\n+///\n /// Example:\n /// ```rust\n /// use ostd::arch::x86::kernel::apic;\n ///\n-/// let ticks = apic::borrow(|apic| {\n+/// let ticks = apic::with_borrow(|apic| {\n ///     let ticks = apic.timer_current_count();\n ///     apic.set_timer_init_count(0);\n ///     ticks\n /// });\n /// ```\n-pub fn borrow<R>(f: impl FnOnce(&mut (dyn Apic + 'static)) -> R) -> R {\n+pub fn with_borrow<R>(f: impl FnOnce(&mut (dyn Apic + 'static)) -> R) -> R {\n     let irq_guard = crate::trap::disable_local();\n     let apic_guard = APIC_INSTANCE.get_with(&irq_guard);\n+    let mut apic_init_ref = apic_guard.borrow_mut();\n \n     // If it is not initialized, lazily initialize it.\n-    if !apic_guard.is_completed() {\n-        apic_guard.call_once(|| match APIC_TYPE.get().unwrap() {\n+    let apic_ref = if let Some(apic_ref) = apic_init_ref.as_mut() {\n+        apic_ref\n+    } else {\n+        *apic_init_ref = Some(match APIC_TYPE.get().unwrap() {\n             ApicType::XApic => {\n                 let mut xapic = xapic::XApic::new().unwrap();\n                 xapic.enable();\n@@ -51,7 +57,7 @@ pub fn borrow<R>(f: impl FnOnce(&mut (dyn Apic + 'static)) -> R) -> R {\n                     version & 0xff,\n                     (version >> 16) & 0xff\n                 );\n-                RefCell::new(Box::new(xapic))\n+                Box::new(xapic)\n             }\n             ApicType::X2Apic => {\n                 let mut x2apic = x2apic::X2Apic::new().unwrap();\n@@ -63,13 +69,12 @@ pub fn borrow<R>(f: impl FnOnce(&mut (dyn Apic + 'static)) -> R) -> R {\n                     version & 0xff,\n                     (version >> 16) & 0xff\n                 );\n-                RefCell::new(Box::new(x2apic))\n+                Box::new(x2apic)\n             }\n         });\n-    }\n \n-    let apic_cell = apic_guard.get().unwrap();\n-    let mut apic_ref = apic_cell.borrow_mut();\n+        apic_init_ref.as_mut().unwrap()\n+    };\n \n     let ret = f.call_once((apic_ref.as_mut(),));\n \n@@ -238,7 +243,6 @@ impl From<u32> for ApicId {\n /// in the system excluding the sender.\n #[repr(u64)]\n pub enum DestinationShorthand {\n-    #[allow(dead_code)]\n     NoShorthand = 0b00,\n     #[allow(dead_code)]\n     MySelf = 0b01,\n@@ -278,7 +282,6 @@ pub enum DestinationMode {\n #[repr(u64)]\n pub enum DeliveryMode {\n     /// Delivers the interrupt specified in the vector field to the target processor or processors.\n-    #[allow(dead_code)]\n     Fixed = 0b000,\n     /// Same as fixed mode, except that the interrupt is delivered to the processor executing at\n     /// the lowest priority among the set of processors specified in the destination field. The\ndiff --git a/ostd/src/arch/x86/mod.rs b/ostd/src/arch/x86/mod.rs\nindex 11475f0c21..21cd13b916 100644\n--- a/ostd/src/arch/x86/mod.rs\n+++ b/ostd/src/arch/x86/mod.rs\n@@ -108,10 +108,21 @@ pub(crate) fn init_on_bsp() {\n     kernel::pic::init();\n }\n \n+/// Architecture-specific initialization on the application processor.\n+///\n+/// # Safety\n+///\n+/// This function must be called only once on each application processor.\n+/// And it should be called after the BSP's call to [`init_on_bsp`].\n+pub(crate) unsafe fn init_on_ap() {\n+    // Trigger the initialization of the local APIC.\n+    crate::arch::x86::kernel::apic::with_borrow(|_| {});\n+}\n+\n pub(crate) fn interrupts_ack(irq_number: usize) {\n     if !cpu::CpuException::is_cpu_exception(irq_number as u16) {\n         kernel::pic::ack();\n-        kernel::apic::borrow(|apic| {\n+        kernel::apic::with_borrow(|apic| {\n             apic.eoi();\n         });\n     }\ndiff --git a/ostd/src/arch/x86/timer/apic.rs b/ostd/src/arch/x86/timer/apic.rs\nindex 8838357d12..a6fdc060c5 100644\n--- a/ostd/src/arch/x86/timer/apic.rs\n+++ b/ostd/src/arch/x86/timer/apic.rs\n@@ -54,7 +54,7 @@ fn is_tsc_deadline_mode_supported() -> bool {\n fn init_tsc_mode() -> IrqLine {\n     let timer_irq = IrqLine::alloc().unwrap();\n     // Enable tsc deadline mode\n-    apic::borrow(|apic| {\n+    apic::with_borrow(|apic| {\n         apic.set_lvt_timer(timer_irq.num() as u64 | (1 << 18));\n     });\n     let tsc_step = TSC_FREQ.load(Ordering::Relaxed) / TIMER_FREQ;\n@@ -81,7 +81,7 @@ fn init_periodic_mode() -> IrqLine {\n     super::pit::enable_ioapic_line(irq.clone());\n \n     // Set APIC timer count\n-    apic::borrow(|apic| {\n+    apic::with_borrow(|apic| {\n         apic.set_timer_div_config(DivideConfig::Divide64);\n         apic.set_timer_init_count(0xFFFF_FFFF);\n     });\n@@ -99,7 +99,7 @@ fn init_periodic_mode() -> IrqLine {\n     // Init APIC Timer\n     let timer_irq = IrqLine::alloc().unwrap();\n \n-    apic::borrow(|apic| {\n+    apic::with_borrow(|apic| {\n         apic.set_timer_init_count(INIT_COUNT.load(Ordering::Relaxed));\n         apic.set_lvt_timer(timer_irq.num() as u64 | (1 << 17));\n         apic.set_timer_div_config(DivideConfig::Divide64);\n@@ -115,7 +115,7 @@ fn init_periodic_mode() -> IrqLine {\n \n         if IN_TIME.load(Ordering::Relaxed) < CALLBACK_TIMES || IS_FINISH.load(Ordering::Acquire) {\n             if IN_TIME.load(Ordering::Relaxed) == 0 {\n-                let remain_ticks = apic::borrow(|apic| apic.timer_current_count());\n+                let remain_ticks = apic::with_borrow(|apic| apic.timer_current_count());\n                 APIC_FIRST_COUNT.store(0xFFFF_FFFF - remain_ticks, Ordering::Relaxed);\n             }\n             IN_TIME.fetch_add(1, Ordering::Relaxed);\n@@ -124,7 +124,7 @@ fn init_periodic_mode() -> IrqLine {\n \n         // Stop PIT and APIC Timer\n         super::pit::disable_ioapic_line();\n-        let remain_ticks = apic::borrow(|apic| {\n+        let remain_ticks = apic::with_borrow(|apic| {\n             let remain_ticks = apic.timer_current_count();\n             apic.set_timer_init_count(0);\n             remain_ticks\ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\nindex 6c4af14292..ef722663e1 100644\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -123,6 +123,13 @@ fn ap_early_entry(local_apic_id: u32) -> ! {\n     unsafe {\n         trapframe::init();\n     }\n+\n+    // SAFETY: this function is only called once on this AP, after the BSP has\n+    // done the architecture-specific initialization.\n+    unsafe {\n+        crate::arch::init_on_ap();\n+    }\n+\n     crate::arch::irq::enable_local();\n \n     // SAFETY: this function is only called once on this AP.\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\nindex bd98f8d7c7..309ec68d0e 100644\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -10,12 +10,7 @@ cfg_if::cfg_if! {\n     }\n }\n \n-use alloc::vec::Vec;\n-\n-use bitvec::{\n-    prelude::{BitVec, Lsb0},\n-    slice::IterOnes,\n-};\n+use bitvec::prelude::BitVec;\n use local::cpu_local_cell;\n use spin::Once;\n \n@@ -122,13 +117,6 @@ impl CpuSet {\n         self.bitset.set(cpu_id as usize, true);\n     }\n \n-    /// Adds a list of CPUs to the set.\n-    pub fn add_from_vec(&mut self, cpu_ids: Vec<u32>) {\n-        for cpu_id in cpu_ids {\n-            self.add(cpu_id)\n-        }\n-    }\n-\n     /// Adds all CPUs to the set.\n     pub fn add_all(&mut self) {\n         self.bitset.fill(true);\n@@ -139,13 +127,6 @@ impl CpuSet {\n         self.bitset.set(cpu_id as usize, false);\n     }\n \n-    /// Removes a list of CPUs from the set.\n-    pub fn remove_from_vec(&mut self, cpu_ids: Vec<u32>) {\n-        for cpu_id in cpu_ids {\n-            self.remove(cpu_id);\n-        }\n-    }\n-\n     /// Removes all CPUs from the set.\n     pub fn clear(&mut self) {\n         self.bitset.fill(false);\n@@ -162,8 +143,8 @@ impl CpuSet {\n     }\n \n     /// Iterates over the CPUs in the set.\n-    pub fn iter(&self) -> IterOnes<'_, usize, Lsb0> {\n-        self.bitset.iter_ones()\n+    pub fn iter(&self) -> impl Iterator<Item = u32> + '_ {\n+        self.bitset.iter_ones().map(|idx| idx as u32)\n     }\n }\n \ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\nindex 79b6d971b2..745668ab73 100644\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -39,6 +39,7 @@ pub mod logger;\n pub mod mm;\n pub mod panicking;\n pub mod prelude;\n+pub mod smp;\n pub mod sync;\n pub mod task;\n pub mod trap;\n@@ -90,6 +91,8 @@ pub unsafe fn init() {\n     unsafe { trap::softirq::init() };\n     arch::init_on_bsp();\n \n+    smp::init();\n+\n     bus::init();\n \n     // SAFETY: This function is called only once on the BSP.\ndiff --git a/ostd/src/mm/frame/mod.rs b/ostd/src/mm/frame/mod.rs\nindex bc41dc1ffe..dc01236865 100644\n--- a/ostd/src/mm/frame/mod.rs\n+++ b/ostd/src/mm/frame/mod.rs\n@@ -80,6 +80,21 @@ impl Frame {\n             core::ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr(), self.size());\n         }\n     }\n+\n+    /// Get the reference count of the frame.\n+    ///\n+    /// It returns the number of all references to the page, including all the\n+    /// existing page handles ([`Frame`]) and all the mappings in the page\n+    /// table that points to the page.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The function is safe to call, but using it requires extra care. The\n+    /// reference count can be changed by other threads at any time including\n+    /// potentially between calling this method and acting on the result.\n+    pub fn reference_count(&self) -> u32 {\n+        self.page.reference_count()\n+    }\n }\n \n impl From<Page<FrameMeta>> for Frame {\ndiff --git a/ostd/src/mm/kspace.rs b/ostd/src/mm/kspace.rs\nindex a9075d17ee..111b434a61 100644\n--- a/ostd/src/mm/kspace.rs\n+++ b/ostd/src/mm/kspace.rs\n@@ -156,7 +156,7 @@ pub fn init_kernel_page_table(meta_pages: Vec<Page<MetaPageMeta>>) {\n         for meta_page in meta_pages {\n             // SAFETY: we are doing the metadata mappings for the kernel.\n             unsafe {\n-                cursor.map(meta_page.into(), prop);\n+                let _old = cursor.map(meta_page.into(), prop);\n             }\n         }\n     }\n@@ -199,7 +199,7 @@ pub fn init_kernel_page_table(meta_pages: Vec<Page<MetaPageMeta>>) {\n             let page = Page::<KernelMeta>::from_unused(frame_paddr, KernelMeta::default());\n             // SAFETY: we are doing mappings for the kernel.\n             unsafe {\n-                cursor.map(page.into(), prop);\n+                let _old = cursor.map(page.into(), prop);\n             }\n         }\n     }\ndiff --git a/ostd/src/mm/page/mod.rs b/ostd/src/mm/page/mod.rs\nindex c74c087c1f..9c4004df91 100644\n--- a/ostd/src/mm/page/mod.rs\n+++ b/ostd/src/mm/page/mod.rs\n@@ -164,6 +164,21 @@ impl<M: PageMeta> Page<M> {\n         unsafe { &*(self.ptr as *const M) }\n     }\n \n+    /// Get the reference count of the page.\n+    ///\n+    /// It returns the number of all references to the page, including all the\n+    /// existing page handles ([`Page`], [`DynPage`]), and all the mappings in the\n+    /// page table that points to the page.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The function is safe to call, but using it requires extra care. The\n+    /// reference count can be changed by other threads at any time including\n+    /// potentially between calling this method and acting on the result.\n+    pub fn reference_count(&self) -> u32 {\n+        self.ref_count().load(Ordering::Relaxed)\n+    }\n+\n     fn ref_count(&self) -> &AtomicU32 {\n         unsafe { &(*self.ptr).ref_count }\n     }\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\nindex 75b1bdb9de..f9b6d0fafe 100644\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -73,7 +73,10 @@ use super::{\n     page_size, pte_index, Child, KernelMode, PageTable, PageTableEntryTrait, PageTableError,\n     PageTableMode, PageTableNode, PagingConstsTrait, PagingLevel, UserMode,\n };\n-use crate::mm::{page::DynPage, Paddr, PageProperty, Vaddr};\n+use crate::{\n+    mm::{page::DynPage, Paddr, PageProperty, Vaddr},\n+    task::{disable_preempt, DisabledPreemptGuard},\n+};\n \n #[derive(Clone, Debug)]\n pub enum PageTableItem {\n@@ -125,7 +128,8 @@ where\n     va: Vaddr,\n     /// The virtual address range that is locked.\n     barrier_va: Range<Vaddr>,\n-    phantom: PhantomData<&'a PageTable<M, E, C>>,\n+    preempt_guard: DisabledPreemptGuard,\n+    _phantom: PhantomData<&'a PageTable<M, E, C>>,\n }\n \n impl<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait> Cursor<'a, M, E, C>\n@@ -162,7 +166,8 @@ where\n             guard_level: C::NR_LEVELS,\n             va: va.start,\n             barrier_va: va.clone(),\n-            phantom: PhantomData,\n+            preempt_guard: disable_preempt(),\n+            _phantom: PhantomData,\n         };\n \n         // Go down and get proper locks. The cursor should hold a lock of a\n@@ -204,37 +209,28 @@ where\n             let level = self.level;\n             let va = self.va;\n \n-            let pte = self.read_cur_pte();\n-            if !pte.is_present() {\n-                return Ok(PageTableItem::NotMapped {\n-                    va,\n-                    len: page_size::<C>(level),\n-                });\n-            }\n-            if !pte.is_last(level) {\n-                self.level_down();\n-                continue;\n-            }\n-\n             match self.cur_child() {\n-                Child::Page(page) => {\n-                    return Ok(PageTableItem::Mapped {\n+                Child::PageTable(_) => {\n+                    self.level_down();\n+                    continue;\n+                }\n+                Child::None => {\n+                    return Ok(PageTableItem::NotMapped {\n                         va,\n-                        page,\n-                        prop: pte.prop(),\n+                        len: page_size::<C>(level),\n                     });\n                 }\n-                Child::Untracked(pa) => {\n+                Child::Page(page, prop) => {\n+                    return Ok(PageTableItem::Mapped { va, page, prop });\n+                }\n+                Child::Untracked(pa, prop) => {\n                     return Ok(PageTableItem::MappedUntracked {\n                         va,\n                         pa,\n                         len: page_size::<C>(level),\n-                        prop: pte.prop(),\n+                        prop,\n                     });\n                 }\n-                Child::None | Child::PageTable(_) => {\n-                    unreachable!(); // Already checked with the PTE.\n-                }\n             }\n         }\n     }\n@@ -289,6 +285,10 @@ where\n         self.va\n     }\n \n+    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n+        &self.preempt_guard\n+    }\n+\n     /// Goes up a level. We release the current page if it has no mappings since the cursor only moves\n     /// forward. And if needed we will do the final cleanup using this method after re-walk when the\n     /// cursor is dropped.\n@@ -423,6 +423,8 @@ where\n \n     /// Maps the range starting from the current address to a [`DynPage`].\n     ///\n+    /// It returns the previously mapped [`DynPage`] if that exists.\n+    ///\n     /// # Panics\n     ///\n     /// This function will panic if\n@@ -434,7 +436,7 @@ where\n     ///\n     /// The caller should ensure that the virtual range being mapped does\n     /// not affect kernel's memory safety.\n-    pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) {\n+    pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) -> Option<DynPage> {\n         let end = self.0.va + page.size();\n         assert!(end <= self.0.barrier_va.end);\n         debug_assert!(self.0.in_tracked_range());\n@@ -458,8 +460,19 @@ where\n \n         // Map the current page.\n         let idx = self.0.cur_idx();\n-        self.cur_node_mut().set_child_page(idx, page, prop);\n+        let old = self\n+            .cur_node_mut()\n+            .replace_child(idx, Child::Page(page, prop), true);\n         self.0.move_forward();\n+\n+        match old {\n+            Child::Page(old_page, _) => Some(old_page),\n+            Child::None => None,\n+            Child::PageTable(_) => {\n+                todo!(\"Dropping page table nodes while mapping requires TLB flush\")\n+            }\n+            Child::Untracked(_, _) => panic!(\"Mapping a tracked page in an untracked range\"),\n+        }\n     }\n \n     /// Maps the range starting from the current address to a physical address range.\n@@ -520,7 +533,9 @@ where\n             // Map the current page.\n             debug_assert!(!self.0.in_tracked_range());\n             let idx = self.0.cur_idx();\n-            self.cur_node_mut().set_child_untracked(idx, pa, prop);\n+            let _ = self\n+                .cur_node_mut()\n+                .replace_child(idx, Child::Untracked(pa, prop), false);\n \n             let level = self.0.level;\n             pa += page_size::<C>(level);\n@@ -605,23 +620,25 @@ where\n \n             // Unmap the current page and return it.\n             let idx = self.0.cur_idx();\n-            let ret = self.cur_node_mut().take_child(idx, is_tracked);\n+            let ret = self\n+                .cur_node_mut()\n+                .replace_child(idx, Child::None, is_tracked);\n             let ret_page_va = self.0.va;\n             let ret_page_size = page_size::<C>(self.0.level);\n \n             self.0.move_forward();\n \n             return match ret {\n-                Child::Page(page) => PageTableItem::Mapped {\n+                Child::Page(page, prop) => PageTableItem::Mapped {\n                     va: ret_page_va,\n                     page,\n-                    prop: cur_pte.prop(),\n+                    prop,\n                 },\n-                Child::Untracked(pa) => PageTableItem::MappedUntracked {\n+                Child::Untracked(pa, prop) => PageTableItem::MappedUntracked {\n                     va: ret_page_va,\n                     pa,\n                     len: ret_page_size,\n-                    prop: cur_pte.prop(),\n+                    prop,\n                 },\n                 Child::None | Child::PageTable(_) => unreachable!(),\n             };\n@@ -717,6 +734,10 @@ where\n         None\n     }\n \n+    pub fn preempt_guard(&self) -> &DisabledPreemptGuard {\n+        &self.0.preempt_guard\n+    }\n+\n     /// Consumes itself and leak the root guard for the caller if it locked the root level.\n     ///\n     /// It is useful when the caller wants to keep the root guard while the cursor should be dropped.\n@@ -743,8 +764,12 @@ where\n         let new_node = PageTableNode::<E, C>::alloc(self.0.level - 1);\n         let idx = self.0.cur_idx();\n         let is_tracked = self.0.in_tracked_range();\n-        self.cur_node_mut()\n-            .set_child_pt(idx, new_node.clone_raw(), is_tracked);\n+        let old = self.cur_node_mut().replace_child(\n+            idx,\n+            Child::PageTable(new_node.clone_raw()),\n+            is_tracked,\n+        );\n+        debug_assert!(old.is_none());\n         self.0.level -= 1;\n         self.0.guards[(self.0.level - 1) as usize] = Some(new_node);\n     }\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\nindex e54afc420b..9bb1e2cc62 100644\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -162,7 +162,11 @@ impl PageTable<KernelMode> {\n         for i in start..end {\n             if !root_node.read_pte(i).is_present() {\n                 let node = PageTableNode::alloc(PagingConsts::NR_LEVELS - 1);\n-                root_node.set_child_pt(i, node.into_raw(), i < NR_PTES_PER_NODE * 3 / 4);\n+                let _ = root_node.replace_child(\n+                    i,\n+                    Child::PageTable(node.into_raw()),\n+                    i < NR_PTES_PER_NODE * 3 / 4,\n+                );\n             }\n         }\n     }\ndiff --git a/ostd/src/mm/page_table/node.rs b/ostd/src/mm/page_table/node.rs\nindex 37e54ca74d..134cd112a0 100644\n--- a/ostd/src/mm/page_table/node.rs\n+++ b/ostd/src/mm/page_table/node.rs\n@@ -42,7 +42,6 @@ use crate::{\n         page_prop::PageProperty,\n         Paddr, PagingConstsTrait, PagingLevel, PAGE_SIZE,\n     },\n-    task::{disable_preempt, DisabledPreemptGuard},\n };\n \n /// The raw handle to a page table node.\n@@ -80,8 +79,6 @@ where\n         // count is needed.\n         let page = unsafe { Page::<PageTablePageMeta<E, C>>::from_raw(this.paddr()) };\n \n-        let disable_preempt = disable_preempt();\n-\n         // Acquire the lock.\n         while page\n             .meta()\n@@ -92,10 +89,7 @@ where\n             core::hint::spin_loop();\n         }\n \n-        PageTableNode::<E, C> {\n-            page,\n-            preempt_guard: disable_preempt,\n-        }\n+        PageTableNode::<E, C> { page, _private: () }\n     }\n \n     /// Creates a copy of the handle.\n@@ -190,7 +184,7 @@ pub(super) struct PageTableNode<\n     [(); C::NR_LEVELS as usize]:,\n {\n     pub(super) page: Page<PageTablePageMeta<E, C>>,\n-    preempt_guard: DisabledPreemptGuard,\n+    _private: (),\n }\n \n // FIXME: We cannot `#[derive(Debug)]` here due to `DisabledPreemptGuard`. Should we skip\n@@ -215,12 +209,21 @@ where\n     [(); C::NR_LEVELS as usize]:,\n {\n     PageTable(RawPageTableNode<E, C>),\n-    Page(DynPage),\n+    Page(DynPage, PageProperty),\n     /// Pages not tracked by handles.\n-    Untracked(Paddr),\n+    Untracked(Paddr, PageProperty),\n     None,\n }\n \n+impl<E: PageTableEntryTrait, C: PagingConstsTrait> Child<E, C>\n+where\n+    [(); C::NR_LEVELS as usize]:,\n+{\n+    pub(super) fn is_none(&self) -> bool {\n+        matches!(self, Child::None)\n+    }\n+}\n+\n impl<E: PageTableEntryTrait, C: PagingConstsTrait> PageTableNode<E, C>\n where\n     [(); C::NR_LEVELS as usize]:,\n@@ -241,10 +244,7 @@ where\n         unsafe { core::ptr::write_bytes(ptr, 0, PAGE_SIZE) };\n         debug_assert!(E::new_absent().as_bytes().iter().all(|&b| b == 0));\n \n-        Self {\n-            page,\n-            preempt_guard: disable_preempt(),\n-        }\n+        Self { page, _private: () }\n     }\n \n     pub fn level(&self) -> PagingLevel {\n@@ -253,16 +253,11 @@ where\n \n     /// Converts the handle into a raw handle to be stored in a PTE or CPU.\n     pub(super) fn into_raw(self) -> RawPageTableNode<E, C> {\n-        let mut this = ManuallyDrop::new(self);\n+        let this = ManuallyDrop::new(self);\n \n         let raw = this.page.paddr();\n \n         this.page.meta().lock.store(0, Ordering::Release);\n-        // SAFETY: The field will no longer be accessed and we need to drop the field to release\n-        // the preempt count.\n-        unsafe {\n-            core::ptr::drop_in_place(&mut this.preempt_guard);\n-        }\n \n         RawPageTableNode {\n             raw,\n@@ -300,40 +295,82 @@ where\n                     _phantom: PhantomData,\n                 })\n             } else if in_tracked_range {\n-                // SAFETY: We have a reference count to the page and can safely increase the reference\n-                // count by one more.\n+                // SAFETY: We have a reference count to the page and can safely\n+                // increase the reference count by one more.\n                 unsafe {\n                     DynPage::inc_ref_count(paddr);\n                 }\n-                Child::Page(unsafe { DynPage::from_raw(paddr) })\n+                // SAFETY: The physical address of the PTE points to a forgotten\n+                // page. It is reclaimed only once.\n+                Child::Page(unsafe { DynPage::from_raw(paddr) }, pte.prop())\n             } else {\n-                Child::Untracked(paddr)\n+                Child::Untracked(paddr, pte.prop())\n             }\n         }\n     }\n \n-    /// Remove the child at the given index and return it.\n-    pub(super) fn take_child(&mut self, idx: usize, in_tracked_range: bool) -> Child<E, C> {\n+    /// Replace the child at the given index with a new child.\n+    ///\n+    /// The old child is returned.\n+    pub(super) fn replace_child(\n+        &mut self,\n+        idx: usize,\n+        new_child: Child<E, C>,\n+        in_tracked_range: bool,\n+    ) -> Child<E, C> {\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n \n-        let pte = self.read_pte(idx);\n-        if !pte.is_present() {\n-            Child::None\n-        } else {\n-            let paddr = pte.paddr();\n-            let is_last = pte.is_last(self.level());\n-            *self.nr_children_mut() -= 1;\n-            self.write_pte(idx, E::new_absent());\n-            if !is_last {\n+        let old_pte = self.read_pte(idx);\n+\n+        let new_child_is_none = match new_child {\n+            Child::None => {\n+                if old_pte.is_present() {\n+                    self.write_pte(idx, E::new_absent());\n+                }\n+                true\n+            }\n+            Child::PageTable(pt) => {\n+                let pt = ManuallyDrop::new(pt);\n+                let new_pte = E::new_pt(pt.paddr());\n+                self.write_pte(idx, new_pte);\n+                false\n+            }\n+            Child::Page(page, prop) => {\n+                debug_assert!(in_tracked_range);\n+                let new_pte = E::new_page(page.into_raw(), self.level(), prop);\n+                self.write_pte(idx, new_pte);\n+                false\n+            }\n+            Child::Untracked(pa, prop) => {\n+                debug_assert!(!in_tracked_range);\n+                let new_pte = E::new_page(pa, self.level(), prop);\n+                self.write_pte(idx, new_pte);\n+                false\n+            }\n+        };\n+\n+        if old_pte.is_present() {\n+            if new_child_is_none {\n+                *self.nr_children_mut() -= 1;\n+            }\n+            let paddr = old_pte.paddr();\n+            if !old_pte.is_last(self.level()) {\n                 Child::PageTable(RawPageTableNode {\n                     raw: paddr,\n                     _phantom: PhantomData,\n                 })\n             } else if in_tracked_range {\n-                Child::Page(unsafe { DynPage::from_raw(paddr) })\n+                // SAFETY: The physical address of the old PTE points to a\n+                // forgotten page. It is reclaimed only once.\n+                Child::Page(unsafe { DynPage::from_raw(paddr) }, old_pte.prop())\n             } else {\n-                Child::Untracked(paddr)\n+                Child::Untracked(paddr, old_pte.prop())\n+            }\n+        } else {\n+            if !new_child_is_none {\n+                *self.nr_children_mut() += 1;\n             }\n+            Child::None\n         }\n     }\n \n@@ -364,16 +401,17 @@ where\n                 Child::PageTable(pt) => {\n                     let guard = pt.clone_shallow().lock();\n                     let new_child = guard.make_copy(0..nr_subpage_per_huge::<C>(), 0..0);\n-                    new_pt.set_child_pt(i, new_child.into_raw(), true);\n+                    let old = new_pt.replace_child(i, Child::PageTable(new_child.into_raw()), true);\n+                    debug_assert!(old.is_none());\n                     copied_child_count -= 1;\n                 }\n-                Child::Page(page) => {\n-                    let prop = self.read_pte_prop(i);\n-                    new_pt.set_child_page(i, page.clone(), prop);\n+                Child::Page(page, prop) => {\n+                    let old = new_pt.replace_child(i, Child::Page(page.clone(), prop), true);\n+                    debug_assert!(old.is_none());\n                     copied_child_count -= 1;\n                 }\n                 Child::None => {}\n-                Child::Untracked(_) => {\n+                Child::Untracked(_, _) => {\n                     unreachable!();\n                 }\n             }\n@@ -386,11 +424,16 @@ where\n             debug_assert_eq!(self.level(), C::NR_LEVELS);\n             match self.child(i, /*meaningless*/ true) {\n                 Child::PageTable(pt) => {\n-                    new_pt.set_child_pt(i, pt.clone_shallow(), /*meaningless*/ true);\n+                    let old = new_pt.replace_child(\n+                        i,\n+                        Child::PageTable(pt.clone_shallow()),\n+                        /*meaningless*/ true,\n+                    );\n+                    debug_assert!(old.is_none());\n                     copied_child_count -= 1;\n                 }\n                 Child::None => {}\n-                Child::Page(_) | Child::Untracked(_) => {\n+                Child::Page(_, _) | Child::Untracked(_, _) => {\n                     unreachable!();\n                 }\n             }\n@@ -399,73 +442,23 @@ where\n         new_pt\n     }\n \n-    /// Sets a child page table at a given index.\n-    pub(super) fn set_child_pt(\n-        &mut self,\n-        idx: usize,\n-        pt: RawPageTableNode<E, C>,\n-        in_tracked_range: bool,\n-    ) {\n-        // They should be ensured by the cursor.\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        // The ownership is transferred to a raw PTE. Don't drop the handle.\n-        let pt = ManuallyDrop::new(pt);\n-\n-        let pte = Some(E::new_pt(pt.paddr()));\n-        self.overwrite_pte(idx, pte, in_tracked_range);\n-    }\n-\n-    /// Map a page at a given index.\n-    pub(super) fn set_child_page(&mut self, idx: usize, page: DynPage, prop: PageProperty) {\n-        // They should be ensured by the cursor.\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-        debug_assert_eq!(page.level(), self.level());\n-\n-        // Use the physical address rather than the page handle to track\n-        // the page, and record the physical address in the PTE.\n-        let pte = Some(E::new_page(page.into_raw(), self.level(), prop));\n-        self.overwrite_pte(idx, pte, true);\n-    }\n-\n-    /// Sets an untracked child page at a given index.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The caller must ensure that the physical address is valid and safe to map.\n-    pub(super) unsafe fn set_child_untracked(&mut self, idx: usize, pa: Paddr, prop: PageProperty) {\n-        // It should be ensured by the cursor.\n-        debug_assert!(idx < nr_subpage_per_huge::<C>());\n-\n-        let pte = Some(E::new_page(pa, self.level(), prop));\n-        self.overwrite_pte(idx, pte, false);\n-    }\n-\n-    /// Reads the info from a page table entry at a given index.\n-    pub(super) fn read_pte_prop(&self, idx: usize) -> PageProperty {\n-        self.read_pte(idx).prop()\n-    }\n-\n     /// Splits the untracked huge page mapped at `idx` to smaller pages.\n     pub(super) fn split_untracked_huge(&mut self, idx: usize) {\n         // These should be ensured by the cursor.\n         debug_assert!(idx < nr_subpage_per_huge::<C>());\n         debug_assert!(self.level() > 1);\n \n-        let Child::Untracked(pa) = self.child(idx, false) else {\n+        let Child::Untracked(pa, prop) = self.child(idx, false) else {\n             panic!(\"`split_untracked_huge` not called on an untracked huge page\");\n         };\n-        let prop = self.read_pte_prop(idx);\n \n         let mut new_page = PageTableNode::<E, C>::alloc(self.level() - 1);\n         for i in 0..nr_subpage_per_huge::<C>() {\n             let small_pa = pa + i * page_size::<C>(self.level() - 1);\n-            // SAFETY: the index is within the bound and either physical address and\n-            // the property are valid.\n-            unsafe { new_page.set_child_untracked(i, small_pa, prop) };\n+            new_page.replace_child(i, Child::Untracked(small_pa, prop), false);\n         }\n \n-        self.set_child_pt(idx, new_page.into_raw(), false);\n+        self.replace_child(idx, Child::PageTable(new_page.into_raw()), false);\n     }\n \n     /// Protects an already mapped child at a given index.\n@@ -512,47 +505,6 @@ where\n         unsafe { &mut *self.meta().nr_children.get() }\n     }\n \n-    /// Replaces a page table entry at a given index.\n-    ///\n-    /// This method will ensure that the child presented by the overwritten\n-    /// PTE is dropped, and the child count is updated.\n-    ///\n-    /// The caller in this module will ensure that the PTE points to initialized\n-    /// memory if the child is a page table.\n-    fn overwrite_pte(&mut self, idx: usize, pte: Option<E>, in_tracked_range: bool) {\n-        let existing_pte = self.read_pte(idx);\n-\n-        if existing_pte.is_present() {\n-            self.write_pte(idx, pte.unwrap_or(E::new_absent()));\n-\n-            // Drop the child. We must set the PTE before dropping the child.\n-            // Just restore the handle and drop the handle.\n-\n-            let paddr = existing_pte.paddr();\n-            // SAFETY: Both the `from_raw` operations here are safe as the physical\n-            // address is valid and casted from a handle.\n-            unsafe {\n-                if !existing_pte.is_last(self.level()) {\n-                    // This is a page table.\n-                    drop(Page::<PageTablePageMeta<E, C>>::from_raw(paddr));\n-                } else if in_tracked_range {\n-                    // This is a frame.\n-                    drop(DynPage::from_raw(paddr));\n-                }\n-            }\n-\n-            // Update the child count.\n-            if pte.is_none() {\n-                *self.nr_children_mut() -= 1;\n-            }\n-        } else if let Some(e) = pte {\n-            // SAFETY: This is safe as described in the above branch.\n-            unsafe { (self.as_ptr() as *mut E).add(idx).write(e) };\n-\n-            *self.nr_children_mut() += 1;\n-        }\n-    }\n-\n     fn as_ptr(&self) -> *const E {\n         paddr_to_vaddr(self.start_paddr()) as *const E\n     }\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\nindex ae0c6b95cb..2bf24e3565 100644\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -9,29 +9,31 @@\n //! powerful concurrent accesses to the page table, and suffers from the same\n //! validity concerns as described in [`super::page_table::cursor`].\n \n-use core::ops::Range;\n+use alloc::collections::vec_deque::VecDeque;\n+use core::{\n+    ops::Range,\n+    sync::atomic::{AtomicPtr, Ordering},\n+};\n \n use spin::Once;\n \n use super::{\n     io::Fallible,\n     kspace::KERNEL_PAGE_TABLE,\n+    page::DynPage,\n     page_table::{PageTable, UserMode},\n     PageFlags, PageProperty, VmReader, VmWriter, PAGE_SIZE,\n };\n use crate::{\n-    arch::mm::{\n-        current_page_table_paddr, tlb_flush_addr, tlb_flush_addr_range,\n-        tlb_flush_all_excluding_global, PageTableEntry, PagingConsts,\n-    },\n-    cpu::{CpuExceptionInfo, CpuSet, PinCurrentCpu},\n-    cpu_local_cell,\n+    arch::mm::{current_page_table_paddr, PageTableEntry, PagingConsts},\n+    cpu::{num_cpus, CpuExceptionInfo, CpuSet, PinCurrentCpu},\n+    cpu_local,\n     mm::{\n         page_table::{self, PageTableItem},\n         Frame, MAX_USERSPACE_VADDR,\n     },\n     prelude::*,\n-    sync::SpinLock,\n+    sync::{RwLock, RwLockReadGuard, SpinLock},\n     task::disable_preempt,\n     Error,\n };\n@@ -55,28 +57,18 @@ use crate::{\n pub struct VmSpace {\n     pt: PageTable<UserMode>,\n     page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n-    /// The CPUs that the `VmSpace` is activated on.\n-    ///\n-    /// TODO: implement an atomic bitset to optimize the performance in cases\n-    /// that the number of CPUs is not large.\n-    activated_cpus: SpinLock<CpuSet>,\n+    /// A CPU can only activate a `VmSpace` when no mutable cursors are alive.\n+    /// Cursors hold read locks and activation require a write lock.\n+    activation_lock: RwLock<()>,\n }\n \n-// Notes on TLB flushing:\n-//\n-// We currently assume that:\n-// 1. `VmSpace` _might_ be activated on the current CPU and the user memory _might_ be used\n-//    immediately after we make changes to the page table entries. So we must invalidate the\n-//    corresponding TLB caches accordingly.\n-// 2. `VmSpace` must _not_ be activated on another CPU. This assumption is trivial, since SMP\n-//    support is not yet available. But we need to consider this situation in the future (TODO).\n impl VmSpace {\n     /// Creates a new VM address space.\n     pub fn new() -> Self {\n         Self {\n             pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n             page_fault_handler: Once::new(),\n-            activated_cpus: SpinLock::new(CpuSet::new_empty()),\n+            activation_lock: RwLock::new(()),\n         }\n     }\n \n@@ -102,74 +94,64 @@ impl VmSpace {\n     /// The creation of the cursor may block if another cursor having an\n     /// overlapping range is alive. The modification to the mapping by the\n     /// cursor may also block or be overridden the mapping of another cursor.\n-    pub fn cursor_mut(&self, va: &Range<Vaddr>) -> Result<CursorMut<'_>> {\n-        Ok(self.pt.cursor_mut(va).map(CursorMut)?)\n+    pub fn cursor_mut(&self, va: &Range<Vaddr>) -> Result<CursorMut<'_, '_>> {\n+        Ok(self.pt.cursor_mut(va).map(|pt_cursor| {\n+            let activation_lock = self.activation_lock.read();\n+\n+            let cur_cpu = pt_cursor.preempt_guard().current_cpu();\n+\n+            let mut activated_cpus = CpuSet::new_empty();\n+            let mut need_self_flush = false;\n+            let mut need_remote_flush = false;\n+\n+            for cpu in 0..num_cpus() {\n+                // The activation lock is held; other CPUs cannot activate this `VmSpace`.\n+                let ptr =\n+                    ACTIVATED_VM_SPACE.get_on_cpu(cpu).load(Ordering::Relaxed) as *const VmSpace;\n+                if ptr == self as *const VmSpace {\n+                    activated_cpus.add(cpu);\n+                    if cpu == cur_cpu {\n+                        need_self_flush = true;\n+                    } else {\n+                        need_remote_flush = true;\n+                    }\n+                }\n+            }\n+\n+            CursorMut {\n+                pt_cursor,\n+                activation_lock,\n+                activated_cpus,\n+                need_remote_flush,\n+                need_self_flush,\n+            }\n+        })?)\n     }\n \n     /// Activates the page table on the current CPU.\n     pub(crate) fn activate(self: &Arc<Self>) {\n-        cpu_local_cell! {\n-            /// The `Arc` pointer to the last activated VM space on this CPU. If the\n-            /// pointer is NULL, it means that the last activated page table is merely\n-            /// the kernel page table.\n-            static LAST_ACTIVATED_VM_SPACE: *const VmSpace = core::ptr::null();\n-        }\n-\n         let preempt_guard = disable_preempt();\n \n-        let mut activated_cpus = self.activated_cpus.lock();\n-        let cpu = preempt_guard.current_cpu();\n+        // Ensure no mutable cursors (which holds read locks) are alive.\n+        let _activation_lock = self.activation_lock.write();\n \n-        if !activated_cpus.contains(cpu) {\n-            activated_cpus.add(cpu);\n-            self.pt.activate();\n+        let cpu = preempt_guard.current_cpu();\n+        let activated_vm_space = ACTIVATED_VM_SPACE.get_on_cpu(cpu);\n \n-            let last_ptr = LAST_ACTIVATED_VM_SPACE.load();\n+        let last_ptr = activated_vm_space.load(Ordering::Relaxed) as *const VmSpace;\n \n+        if last_ptr != Arc::as_ptr(self) {\n+            self.pt.activate();\n+            let ptr = Arc::into_raw(Arc::clone(self)) as *mut VmSpace;\n+            activated_vm_space.store(ptr, Ordering::Relaxed);\n             if !last_ptr.is_null() {\n-                // SAFETY: If the pointer is not NULL, it must be a valid\n-                // pointer casted with `Arc::into_raw` on the last activated\n-                // `Arc<VmSpace>`.\n-                let last = unsafe { Arc::from_raw(last_ptr) };\n-                debug_assert!(!Arc::ptr_eq(self, &last));\n-                let mut last_cpus = last.activated_cpus.lock();\n-                debug_assert!(last_cpus.contains(cpu));\n-                last_cpus.remove(cpu);\n+                // SAFETY: The pointer is cast from an `Arc` when it's activated\n+                // the last time, so it can be restored and only restored once.\n+                drop(unsafe { Arc::from_raw(last_ptr) });\n             }\n-\n-            LAST_ACTIVATED_VM_SPACE.store(Arc::into_raw(Arc::clone(self)));\n-        }\n-\n-        if activated_cpus.count() > 1 {\n-            // We don't support remote TLB flushing yet. It is less desirable\n-            // to activate a `VmSpace` on more than one CPU.\n-            log::warn!(\"A `VmSpace` is activated on more than one CPU\");\n         }\n     }\n \n-    /// Clears all mappings.\n-    pub fn clear(&self) {\n-        let mut cursor = self.pt.cursor_mut(&(0..MAX_USERSPACE_VADDR)).unwrap();\n-        loop {\n-            // SAFETY: It is safe to un-map memory in the userspace.\n-            let result = unsafe { cursor.take_next(MAX_USERSPACE_VADDR - cursor.virt_addr()) };\n-            match result {\n-                PageTableItem::Mapped { page, .. } => {\n-                    drop(page);\n-                }\n-                PageTableItem::NotMapped { .. } => {\n-                    break;\n-                }\n-                PageTableItem::MappedUntracked { .. } => {\n-                    panic!(\"found untracked memory mapped into `VmSpace`\");\n-                }\n-            }\n-        }\n-        // TODO: currently this method calls x86_64::flush_all(), which rewrite the Cr3 register.\n-        // We should replace it with x86_64::flush_pcid(InvPicdCommand::AllExceptGlobal) after enabling PCID.\n-        tlb_flush_all_excluding_global();\n-    }\n-\n     pub(crate) fn handle_page_fault(\n         &self,\n         info: &CpuExceptionInfo,\n@@ -199,25 +181,12 @@ impl VmSpace {\n     pub fn fork_copy_on_write(&self) -> Self {\n         // Protect the parent VM space as read-only.\n         let end = MAX_USERSPACE_VADDR;\n-        let mut cursor = self.pt.cursor_mut(&(0..end)).unwrap();\n+        let mut cursor = self.cursor_mut(&(0..end)).unwrap();\n         let mut op = |prop: &mut PageProperty| {\n             prop.flags -= PageFlags::W;\n         };\n \n-        loop {\n-            // SAFETY: It is safe to protect memory in the userspace.\n-            unsafe {\n-                if cursor\n-                    .protect_next(end - cursor.virt_addr(), &mut op)\n-                    .is_none()\n-                {\n-                    break;\n-                }\n-            };\n-        }\n-        // TODO: currently this method calls x86_64::flush_all(), which rewrite the Cr3 register.\n-        // We should replace it with x86_64::flush_pcid(InvPicdCommand::AllExceptGlobal) after enabling PCID.\n-        tlb_flush_all_excluding_global();\n+        cursor.protect(end, &mut op);\n \n         let page_fault_handler = {\n             let new_handler = Once::new();\n@@ -227,10 +196,22 @@ impl VmSpace {\n             new_handler\n         };\n \n+        let CursorMut {\n+            pt_cursor,\n+            activation_lock,\n+            ..\n+        } = cursor;\n+\n+        let new_pt = self.pt.clone_with(pt_cursor);\n+\n+        // Release the activation lock after the page table is cloned to\n+        // prevent modification to the parent page table while cloning.\n+        drop(activation_lock);\n+\n         Self {\n-            pt: self.pt.clone_with(cursor),\n+            pt: new_pt,\n             page_fault_handler,\n-            activated_cpus: SpinLock::new(CpuSet::new_empty()),\n+            activation_lock: RwLock::new(()),\n         }\n     }\n \n@@ -326,52 +307,55 @@ impl Cursor<'_> {\n ///\n /// It exclusively owns a sub-tree of the page table, preventing others from\n /// reading or modifying the same sub-tree.\n-pub struct CursorMut<'a>(page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>);\n-\n-impl CursorMut<'_> {\n-    /// The threshold used to determine whether need to flush TLB all\n-    /// when flushing a range of TLB addresses. If the range of TLB entries\n-    /// to be flushed exceeds this threshold, the overhead incurred by\n-    /// flushing pages individually would surpass the overhead of flushing all entries at once.\n-    const TLB_FLUSH_THRESHOLD: usize = 32 * PAGE_SIZE;\n+pub struct CursorMut<'a, 'b> {\n+    pt_cursor: page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>,\n+    #[allow(dead_code)]\n+    activation_lock: RwLockReadGuard<'b, ()>,\n+    // Better to store them here since loading and counting them from the CPUs\n+    // list brings non-trivial overhead. We have a read lock so the stored set\n+    // is always a superset of actual activated CPUs.\n+    activated_cpus: CpuSet,\n+    need_remote_flush: bool,\n+    need_self_flush: bool,\n+}\n \n+impl CursorMut<'_, '_> {\n     /// Query about the current slot.\n     ///\n     /// This is the same as [`Cursor::query`].\n     ///\n     /// This function won't bring the cursor to the next slot.\n     pub fn query(&mut self) -> Result<VmItem> {\n-        Ok(self.0.query().map(|item| item.try_into().unwrap())?)\n+        Ok(self\n+            .pt_cursor\n+            .query()\n+            .map(|item| item.try_into().unwrap())?)\n     }\n \n     /// Jump to the virtual address.\n     ///\n     /// This is the same as [`Cursor::jump`].\n     pub fn jump(&mut self, va: Vaddr) -> Result<()> {\n-        self.0.jump(va)?;\n+        self.pt_cursor.jump(va)?;\n         Ok(())\n     }\n \n     /// Get the virtual address of the current slot.\n     pub fn virt_addr(&self) -> Vaddr {\n-        self.0.virt_addr()\n+        self.pt_cursor.virt_addr()\n     }\n \n     /// Map a frame into the current slot.\n     ///\n     /// This method will bring the cursor to the next slot after the modification.\n-    pub fn map(&mut self, frame: Frame, mut prop: PageProperty) {\n+    pub fn map(&mut self, frame: Frame, prop: PageProperty) {\n         let start_va = self.virt_addr();\n         let end_va = start_va + frame.size();\n-        // TODO: this is a temporary fix to avoid the overhead of setting ACCESSED bit in userspace.\n-        // When this bit is truly enabled, it needs to be set at a more appropriate location.\n-        prop.flags |= PageFlags::ACCESSED;\n         // SAFETY: It is safe to map untyped memory into the userspace.\n-        unsafe {\n-            self.0.map(frame.into(), prop);\n-        }\n+        let old = unsafe { self.pt_cursor.map(frame.into(), prop) };\n \n-        tlb_flush_addr_range(&(start_va..end_va));\n+        self.issue_tlb_flush(TlbFlushOp::Range(start_va..end_va), old);\n+        self.dispatch_tlb_flush();\n     }\n \n     /// Clear the mapping starting from the current slot.\n@@ -388,18 +372,13 @@ impl CursorMut<'_> {\n     pub fn unmap(&mut self, len: usize) {\n         assert!(len % super::PAGE_SIZE == 0);\n         let end_va = self.virt_addr() + len;\n-        let need_flush_all = len >= Self::TLB_FLUSH_THRESHOLD;\n+\n         loop {\n             // SAFETY: It is safe to un-map memory in the userspace.\n-            let result = unsafe { self.0.take_next(end_va - self.virt_addr()) };\n+            let result = unsafe { self.pt_cursor.take_next(end_va - self.virt_addr()) };\n             match result {\n                 PageTableItem::Mapped { va, page, .. } => {\n-                    if !need_flush_all {\n-                        // TODO: Ask other processors to flush the TLB before we\n-                        // release the page back to the allocator.\n-                        tlb_flush_addr(va);\n-                    }\n-                    drop(page);\n+                    self.issue_tlb_flush(TlbFlushOp::Address(va), Some(page));\n                 }\n                 PageTableItem::NotMapped { .. } => {\n                     break;\n@@ -409,9 +388,8 @@ impl CursorMut<'_> {\n                 }\n             }\n         }\n-        if need_flush_all {\n-            tlb_flush_all_excluding_global();\n-        }\n+\n+        self.dispatch_tlb_flush();\n     }\n \n     /// Change the mapping property starting from the current slot.\n@@ -426,17 +404,121 @@ impl CursorMut<'_> {\n     /// This method will panic if `len` is not page-aligned.\n     pub fn protect(&mut self, len: usize, mut op: impl FnMut(&mut PageProperty)) {\n         assert!(len % super::PAGE_SIZE == 0);\n-        let end = self.0.virt_addr() + len;\n-        let need_flush_all = len >= Self::TLB_FLUSH_THRESHOLD;\n+        let end = self.virt_addr() + len;\n+        let tlb_prefer_flush_all = len > TLB_FLUSH_ALL_THRESHOLD * PAGE_SIZE;\n+\n         // SAFETY: It is safe to protect memory in the userspace.\n-        while let Some(range) = unsafe { self.0.protect_next(end - self.0.virt_addr(), &mut op) } {\n-            if !need_flush_all {\n-                tlb_flush_addr(range.start);\n+        while let Some(range) =\n+            unsafe { self.pt_cursor.protect_next(end - self.virt_addr(), &mut op) }\n+        {\n+            if !tlb_prefer_flush_all {\n+                self.issue_tlb_flush(TlbFlushOp::Range(range), None);\n+            }\n+        }\n+\n+        if tlb_prefer_flush_all {\n+            self.issue_tlb_flush(TlbFlushOp::All, None);\n+        }\n+        self.dispatch_tlb_flush();\n+    }\n+\n+    fn issue_tlb_flush(&self, op: TlbFlushOp, drop_after_flush: Option<DynPage>) {\n+        let request = TlbFlushRequest {\n+            op,\n+            drop_after_flush,\n+        };\n+\n+        // Fast path for single CPU cases.\n+        if !self.need_remote_flush {\n+            if self.need_self_flush {\n+                request.do_flush();\n+            }\n+            return;\n+        }\n+\n+        // Slow path for multi-CPU cases.\n+        for cpu in self.activated_cpus.iter() {\n+            let mut queue = TLB_FLUSH_REQUESTS.get_on_cpu(cpu).lock();\n+            queue.push_back(request.clone());\n+        }\n+    }\n+\n+    fn dispatch_tlb_flush(&self) {\n+        if !self.need_remote_flush {\n+            return;\n+        }\n+\n+        fn do_remote_flush() {\n+            let preempt_guard = disable_preempt();\n+            let mut requests = TLB_FLUSH_REQUESTS\n+                .get_on_cpu(preempt_guard.current_cpu())\n+                .lock();\n+            if requests.len() > TLB_FLUSH_ALL_THRESHOLD {\n+                // TODO: in most cases, we need only to flush all the TLB entries\n+                // for an ASID if it is enabled.\n+                crate::arch::mm::tlb_flush_all_excluding_global();\n+                requests.clear();\n+            } else {\n+                while let Some(request) = requests.pop_front() {\n+                    request.do_flush();\n+                    if matches!(request.op, TlbFlushOp::All) {\n+                        requests.clear();\n+                        break;\n+                    }\n+                }\n             }\n         }\n \n-        if need_flush_all {\n-            tlb_flush_all_excluding_global();\n+        crate::smp::inter_processor_call(&self.activated_cpus.clone(), do_remote_flush);\n+    }\n+}\n+\n+/// The threshold used to determine whether we need to flush all TLB entries\n+/// when handling a bunch of TLB flush requests. If the number of requests\n+/// exceeds this threshold, the overhead incurred by flushing pages\n+/// individually would surpass the overhead of flushing all entries at once.\n+const TLB_FLUSH_ALL_THRESHOLD: usize = 32;\n+\n+cpu_local! {\n+    /// The queue of pending requests.\n+    static TLB_FLUSH_REQUESTS: SpinLock<VecDeque<TlbFlushRequest>> = SpinLock::new(VecDeque::new());\n+    /// The `Arc` pointer to the activated VM space on this CPU. If the pointer\n+    /// is NULL, it means that the activated page table is merely the kernel\n+    /// page table.\n+    // TODO: If we are enabling ASID, we need to maintain the TLB state of each\n+    // CPU, rather than merely the activated `VmSpace`. When ASID is enabled,\n+    // the non-active `VmSpace`s can still have their TLB entries in the CPU!\n+    static ACTIVATED_VM_SPACE: AtomicPtr<VmSpace> = AtomicPtr::new(core::ptr::null_mut());\n+}\n+\n+#[derive(Debug, Clone)]\n+struct TlbFlushRequest {\n+    op: TlbFlushOp,\n+    // If we need to remove a mapped page from the page table, we can only\n+    // recycle the page after all the relevant TLB entries in all CPUs are\n+    // flushed. Otherwise if the page is recycled for other purposes, the user\n+    // space program can still access the page through the TLB entries.\n+    #[allow(dead_code)]\n+    drop_after_flush: Option<DynPage>,\n+}\n+\n+#[derive(Debug, Clone)]\n+enum TlbFlushOp {\n+    All,\n+    Address(Vaddr),\n+    Range(Range<Vaddr>),\n+}\n+\n+impl TlbFlushRequest {\n+    /// Perform the TLB flush operation on the current CPU.\n+    fn do_flush(&self) {\n+        use crate::arch::mm::{\n+            tlb_flush_addr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n+        };\n+        match &self.op {\n+            TlbFlushOp::All => tlb_flush_all_excluding_global(),\n+            TlbFlushOp::Address(addr) => tlb_flush_addr(*addr),\n+            TlbFlushOp::Range(range) => tlb_flush_addr_range(range),\n         }\n     }\n }\ndiff --git a/ostd/src/smp.rs b/ostd/src/smp.rs\nnew file mode 100644\nindex 0000000000..910bb564a1\n--- /dev/null\n+++ b/ostd/src/smp.rs\n@@ -0,0 +1,87 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Symmetric Multi-Processing (SMP) support.\n+//!\n+//! This module provides a way to execute code on other processors via inter-\n+//! processor interrupts.\n+\n+use alloc::collections::VecDeque;\n+\n+use spin::Once;\n+\n+use crate::{\n+    cpu::{CpuSet, PinCurrentCpu},\n+    cpu_local,\n+    sync::SpinLock,\n+    trap::{self, IrqLine, TrapFrame},\n+};\n+\n+/// Execute a function on other processors.\n+///\n+/// The provided function `f` will be executed on all target processors\n+/// specified by `targets`. It can also be executed on the current processor.\n+/// The function should be short and non-blocking, as it will be executed in\n+/// interrupt context with interrupts disabled.\n+///\n+/// This function does not block until all the target processors acknowledges\n+/// the interrupt. So if any of the target processors disables IRQs for too\n+/// long that the controller cannot queue them, the function will not be\n+/// executed.\n+///\n+/// The function `f` will be executed asynchronously on the target processors.\n+/// However if called on the current processor, it will be synchronous.\n+pub fn inter_processor_call(targets: &CpuSet, f: fn()) {\n+    let irq_guard = trap::disable_local();\n+    let this_cpu_id = irq_guard.current_cpu();\n+    let irq_num = INTER_PROCESSOR_CALL_IRQ.get().unwrap().num();\n+\n+    let mut call_on_self = false;\n+    for cpu_id in targets.iter() {\n+        if cpu_id == this_cpu_id {\n+            call_on_self = true;\n+            continue;\n+        }\n+        CALL_QUEUES.get_on_cpu(cpu_id).lock().push_back(f);\n+    }\n+    for cpu_id in targets.iter() {\n+        if cpu_id == this_cpu_id {\n+            continue;\n+        }\n+        // SAFETY: It is safe to send inter processor call IPI to other CPUs.\n+        unsafe {\n+            crate::arch::irq::send_ipi(cpu_id, irq_num);\n+        }\n+    }\n+    if call_on_self {\n+        // Execute the function synchronously.\n+        f();\n+    }\n+}\n+\n+static INTER_PROCESSOR_CALL_IRQ: Once<IrqLine> = Once::new();\n+\n+cpu_local! {\n+    static CALL_QUEUES: SpinLock<VecDeque<fn()>> = SpinLock::new(VecDeque::new());\n+}\n+\n+fn do_inter_processor_call(_trapframe: &TrapFrame) {\n+    // TODO: in interrupt context, disabling interrupts is not necessary.\n+    let preempt_guard = trap::disable_local();\n+    let cur_cpu = preempt_guard.current_cpu();\n+\n+    let mut queue = CALL_QUEUES.get_on_cpu(cur_cpu).lock();\n+    while let Some(f) = queue.pop_front() {\n+        log::trace!(\n+            \"Performing inter-processor call to {:#?} on CPU {}\",\n+            f,\n+            cur_cpu\n+        );\n+        f();\n+    }\n+}\n+\n+pub(super) fn init() {\n+    let mut irq = IrqLine::alloc().unwrap();\n+    irq.on_active(do_inter_processor_call);\n+    INTER_PROCESSOR_CALL_IRQ.call_once(|| irq);\n+}\ndiff --git a/ostd/src/task/preempt/guard.rs b/ostd/src/task/preempt/guard.rs\nindex a8e9bd8d96..1aa88c6e1d 100644\n--- a/ostd/src/task/preempt/guard.rs\n+++ b/ostd/src/task/preempt/guard.rs\n@@ -3,6 +3,7 @@\n /// A guard for disable preempt.\n #[clippy::has_significant_drop]\n #[must_use]\n+#[derive(Debug)]\n pub struct DisabledPreemptGuard {\n     // This private field prevents user from constructing values of this type directly.\n     _private: (),\n", "test_patch": "diff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\nindex fcb2feb3b5..23618110b8 100644\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -57,6 +57,7 @@ fn create_user_space(program: &[u8]) -> UserSpace {\n         for frame in user_pages {\n             cursor.map(frame, map_prop);\n         }\n+        drop(cursor);\n         Arc::new(vm_space)\n     };\n     let user_cpu_state = {\n", "problem_statement": "Sporadic SMP syscall test aborts\n<!-- Thank you for taking the time to report a bug. Your input is valuable to us.\r\nPlease replace all the <angle brackets> below with your own information. -->\r\n\r\n### Describe the bug\r\n\r\n<!-- A clear and concise description of what the bug is. -->\r\n\r\nThe SMP syscall test aborts with no panicking information randomly. The abort does not happen in a specific test case. And there's possibility of such failures both in the CI ([an example](https://github.com/asterinas/asterinas/actions/runs/10615729536/job/29424463727)) and locally.\r\n\r\nOther CI failure logs:\r\n\r\nhttps://github.com/asterinas/asterinas/actions/runs/10600745276/job/29378943424\r\n\r\nLink #999 \r\n\n", "hints_text": "", "created_at": "2024-08-13T09:28:07Z", "version": "0.8"}, {"repo": "asterinas/asterinas", "pull_number": 1138, "instance_id": "asterinas__asterinas-1138", "issue_numbers": ["1135"], "base_commit": "6414111cc57b42db2bae1a0c8b01b85c3830a3b3", "patch": "diff --git a/osdk/src/commands/new/mod.rs b/osdk/src/commands/new/mod.rs\nindex 1c5c386004..7d4b9b0a4a 100644\n--- a/osdk/src/commands/new/mod.rs\n+++ b/osdk/src/commands/new/mod.rs\n@@ -163,18 +163,14 @@ fn get_manifest_path<'a>(cargo_metadata: &'a serde_json::Value, crate_name: &str\n fn get_src_path<'a>(cargo_metadata: &'a serde_json::Value, crate_name: &str) -> &'a str {\n     let metadata = get_package_metadata(cargo_metadata, crate_name);\n     let targets = metadata.get(\"targets\").unwrap().as_array().unwrap();\n-\n-    for target in targets {\n-        let name = target.get(\"name\").unwrap().as_str().unwrap();\n-        if name != crate_name {\n-            continue;\n-        }\n-\n-        let src_path = target.get(\"src_path\").unwrap();\n-        return src_path.as_str().unwrap();\n-    }\n-\n-    panic!(\"the crate name does not match with any target\");\n+    assert!(\n+        targets.len() == 1,\n+        \"there must be one and only one target generated\"\n+    );\n+\n+    let target = &targets[0];\n+    let src_path = target.get(\"src_path\").unwrap();\n+    return src_path.as_str().unwrap();\n }\n \n fn get_workspace_root(cargo_metadata: &serde_json::Value) -> &str {\n", "test_patch": "diff --git a/osdk/tests/cli/mod.rs b/osdk/tests/cli/mod.rs\nindex ed909baaf0..4a7fbc1fda 100644\n--- a/osdk/tests/cli/mod.rs\n+++ b/osdk/tests/cli/mod.rs\n@@ -1,5 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n+use std::fs;\n+\n use crate::util::*;\n \n #[test]\n@@ -50,3 +52,13 @@ fn cli_clippy_help_message() {\n     assert_success(&output);\n     assert_stdout_contains_msg(&output, \"cargo osdk clippy\");\n }\n+\n+#[test]\n+fn cli_new_crate_with_hyphen() {\n+    let output = cargo_osdk(&[\"new\", \"--kernel\", \"my-first-os\"])\n+        .output()\n+        .unwrap();\n+    assert_success(&output);\n+    assert!(fs::metadata(\"my-first-os\").is_ok());\n+    fs::remove_dir_all(\"my-first-os\");\n+}\n", "problem_statement": "OSDK should support creating crate with `-` in its name\nAs discovered by #1133, `cargo osdk new --kernel my-first-os` will panic due to `my-first-os` contains `-`.\r\n\r\nSince `cargo new my-first-os` is allowed, we should fix the problem to keep osdk consistent with cargo.\r\n\r\n\r\n\r\n\n", "hints_text": "", "created_at": "2024-08-08T01:38:09Z", "version": "0.6"}, {"repo": "asterinas/asterinas", "pull_number": 1125, "instance_id": "asterinas__asterinas-1125", "issue_numbers": ["1106"], "base_commit": "d04111079cb8edf03d9a58b2bd88d4af4b11543a", "patch": "diff --git a/kernel/aster-nix/src/prelude.rs b/kernel/aster-nix/src/prelude.rs\nindex dfff76268f..44357e6dd8 100644\n--- a/kernel/aster-nix/src/prelude.rs\n+++ b/kernel/aster-nix/src/prelude.rs\n@@ -26,7 +26,7 @@ pub(crate) use ostd::{\n #[macro_export]\n macro_rules! current {\n     () => {\n-        $crate::process::current()\n+        $crate::process::Process::current().unwrap()\n     };\n }\n \ndiff --git a/kernel/aster-nix/src/process/mod.rs b/kernel/aster-nix/src/process/mod.rs\nindex b0afbdac69..c701a5a7f7 100644\n--- a/kernel/aster-nix/src/process/mod.rs\n+++ b/kernel/aster-nix/src/process/mod.rs\n@@ -23,8 +23,7 @@ pub use credentials::{credentials, credentials_mut, Credentials, Gid, Uid};\n pub use exit::do_exit_group;\n pub use kill::{kill, kill_all, kill_group, tgkill};\n pub use process::{\n-    current, ExitCode, JobControl, Pgid, Pid, Process, ProcessBuilder, ProcessGroup, Session, Sid,\n-    Terminal,\n+    ExitCode, JobControl, Pgid, Pid, Process, ProcessBuilder, ProcessGroup, Session, Sid, Terminal,\n };\n pub use process_filter::ProcessFilter;\n pub use process_vm::{MAX_ARGV_NUMBER, MAX_ARG_LEN, MAX_ENVP_NUMBER, MAX_ENV_LEN};\ndiff --git a/kernel/aster-nix/src/process/process/mod.rs b/kernel/aster-nix/src/process/process/mod.rs\nindex 362d52df96..0b3a0ff468 100644\n--- a/kernel/aster-nix/src/process/process/mod.rs\n+++ b/kernel/aster-nix/src/process/process/mod.rs\n@@ -103,6 +103,15 @@ pub struct Process {\n }\n \n impl Process {\n+    /// Returns the current process.\n+    ///\n+    /// It returns `None` if:\n+    ///  - the function is called in the bootstrap context;\n+    ///  - or if the current task is not associated with a process.\n+    pub fn current() -> Option<Arc<Process>> {\n+        Some(Thread::current()?.as_posix_thread()?.process())\n+    }\n+\n     #[allow(clippy::too_many_arguments)]\n     fn new(\n         pid: Pid,\n@@ -636,15 +645,6 @@ impl Process {\n     }\n }\n \n-pub fn current() -> Arc<Process> {\n-    let current_thread = current_thread!();\n-    if let Some(posix_thread) = current_thread.as_posix_thread() {\n-        posix_thread.process()\n-    } else {\n-        panic!(\"[Internal error]The current thread does not belong to a process\");\n-    }\n-}\n-\n #[cfg(ktest)]\n mod test {\n \ndiff --git a/kernel/aster-nix/src/taskless.rs b/kernel/aster-nix/src/taskless.rs\nindex 14bd44fa9e..64ac8f82a0 100644\n--- a/kernel/aster-nix/src/taskless.rs\n+++ b/kernel/aster-nix/src/taskless.rs\n@@ -1,7 +1,5 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-#![allow(dead_code)]\n-\n use alloc::{boxed::Box, sync::Arc};\n use core::{\n     cell::RefCell,\n@@ -10,7 +8,7 @@ use core::{\n };\n \n use intrusive_collections::{intrusive_adapter, LinkedList, LinkedListAtomicLink};\n-use ostd::{cpu_local, trap::SoftIrqLine, CpuLocal};\n+use ostd::{cpu::local::CpuLocal, cpu_local, trap::SoftIrqLine};\n \n use crate::softirq_id::{TASKLESS_SOFTIRQ_ID, TASKLESS_URGENT_SOFTIRQ_ID};\n \ndiff --git a/kernel/aster-nix/src/thread/mod.rs b/kernel/aster-nix/src/thread/mod.rs\nindex 349c9eb0e0..cb7249fe75 100644\n--- a/kernel/aster-nix/src/thread/mod.rs\n+++ b/kernel/aster-nix/src/thread/mod.rs\n@@ -50,13 +50,12 @@ impl Thread {\n         }\n     }\n \n-    /// Returns the current thread, or `None` if the current task is not associated with a thread.\n+    /// Returns the current thread.\n     ///\n-    /// Except for unit tests, all tasks should be associated with threads. This method is useful\n-    /// when writing code that can be called directly by unit tests. If this isn't the case,\n-    /// consider using [`current_thread!`] instead.\n+    /// This function returns `None` if the current task is not associated with\n+    /// a thread, or if called within the bootstrap context.\n     pub fn current() -> Option<Arc<Self>> {\n-        Task::current()\n+        Task::current()?\n             .data()\n             .downcast_ref::<Weak<Thread>>()?\n             .upgrade()\ndiff --git a/kernel/aster-nix/src/util/mod.rs b/kernel/aster-nix/src/util/mod.rs\nindex a9f4fbf5a1..930978127a 100644\n--- a/kernel/aster-nix/src/util/mod.rs\n+++ b/kernel/aster-nix/src/util/mod.rs\n@@ -5,7 +5,7 @@ use core::mem;\n use aster_rights::Full;\n use ostd::{\n     mm::{KernelSpace, VmIo, VmReader, VmWriter},\n-    task::current_task,\n+    task::Task,\n };\n \n use crate::{prelude::*, vm::vmar::Vmar};\n@@ -34,14 +34,8 @@ pub fn read_bytes_from_user(src: Vaddr, dest: &mut VmWriter<'_>) -> Result<()> {\n         check_vaddr(src)?;\n     }\n \n-    let current_task = current_task().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the current task is missing\",\n-    ))?;\n-    let user_space = current_task.user_space().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the user space is missing\",\n-    ))?;\n+    let current_task = Task::current().unwrap();\n+    let user_space = current_task.user_space().unwrap();\n \n     let mut user_reader = user_space.vm_space().reader(src, copy_len)?;\n     user_reader.read_fallible(dest).map_err(|err| err.0)?;\n@@ -54,14 +48,8 @@ pub fn read_val_from_user<T: Pod>(src: Vaddr) -> Result<T> {\n         check_vaddr(src)?;\n     }\n \n-    let current_task = current_task().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the current task is missing\",\n-    ))?;\n-    let user_space = current_task.user_space().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the user space is missing\",\n-    ))?;\n+    let current_task = Task::current().unwrap();\n+    let user_space = current_task.user_space().unwrap();\n \n     let mut user_reader = user_space\n         .vm_space()\n@@ -88,14 +76,8 @@ pub fn write_bytes_to_user(dest: Vaddr, src: &mut VmReader<'_, KernelSpace>) ->\n         check_vaddr(dest)?;\n     }\n \n-    let current_task = current_task().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the current task is missing\",\n-    ))?;\n-    let user_space = current_task.user_space().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the user space is missing\",\n-    ))?;\n+    let current_task = Task::current().unwrap();\n+    let user_space = current_task.user_space().unwrap();\n \n     let mut user_writer = user_space.vm_space().writer(dest, copy_len)?;\n     user_writer.write_fallible(src).map_err(|err| err.0)?;\n@@ -108,14 +90,8 @@ pub fn write_val_to_user<T: Pod>(dest: Vaddr, val: &T) -> Result<()> {\n         check_vaddr(dest)?;\n     }\n \n-    let current_task = current_task().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the current task is missing\",\n-    ))?;\n-    let user_space = current_task.user_space().ok_or(Error::with_message(\n-        Errno::EFAULT,\n-        \"the user space is missing\",\n-    ))?;\n+    let current_task = Task::current().unwrap();\n+    let user_space = current_task.user_space().unwrap();\n \n     let mut user_writer = user_space\n         .vm_space()\ndiff --git a/osdk/src/base_crate/x86_64.ld.template b/osdk/src/base_crate/x86_64.ld.template\nindex 57087f86ef..2803d19538 100644\n--- a/osdk/src/base_crate/x86_64.ld.template\n+++ b/osdk/src/base_crate/x86_64.ld.template\n@@ -122,13 +122,7 @@ SECTIONS\n \n         # These 4 bytes are used to store the CPU ID.\n         . += 4;\n-\n-        # These 4 bytes are used to store the number of preemption locks held.\n-        # The reason is stated in the Rust documentation of\n-        # [`ostd::task::processor::PreemptInfo`].\n-        __cpu_local_preempt_lock_count = . - __cpu_local_start;\n-        . += 4;\n-\n+        \n         KEEP(*(SORT(.cpu_local)))\n         __cpu_local_end = .;\n     }\ndiff --git a/osdk/src/util.rs b/osdk/src/util.rs\nindex 2d629aa63b..0ff06dc44c 100644\n--- a/osdk/src/util.rs\n+++ b/osdk/src/util.rs\n@@ -230,7 +230,7 @@ pub fn trace_panic_from_log(qemu_log: File, bin_path: PathBuf) {\n         .spawn()\n         .unwrap();\n     for line in lines.into_iter().rev() {\n-        if line.contains(\"printing stack trace:\") {\n+        if line.contains(\"Printing stack trace:\") {\n             println!(\"[OSDK] The kernel seems panicked. Parsing stack trace for source lines:\");\n             trace_exists = true;\n         }\ndiff --git a/ostd/src/arch/x86/cpu/local.rs b/ostd/src/arch/x86/cpu/local.rs\nindex 325d692d2e..b5a6473271 100644\n--- a/ostd/src/arch/x86/cpu/local.rs\n+++ b/ostd/src/arch/x86/cpu/local.rs\n@@ -23,65 +23,205 @@ pub(crate) fn get_base() -> u64 {\n     FS::read_base().as_u64()\n }\n \n-pub mod preempt_lock_count {\n-    //! We need to increment/decrement the per-CPU preemption lock count using\n-    //! a single instruction. This requirement is stated by\n-    //! [`crate::task::processor::PreemptInfo`].\n-\n-    /// The GDT ensures that the FS segment is initialized to zero on boot.\n-    /// This assertion checks that the base address has been set.\n-    macro_rules! debug_assert_initialized {\n-        () => {\n-            // The compiler may think that [`super::get_base`] has side effects\n-            // so it may not be optimized out. We make sure that it will be\n-            // conditionally compiled only in debug builds.\n-            #[cfg(debug_assertions)]\n-            debug_assert_ne!(super::get_base(), 0);\n-        };\n-    }\n+use crate::cpu::local::single_instr::{\n+    SingleInstructionAddAssign, SingleInstructionBitAndAssign, SingleInstructionBitOrAssign,\n+    SingleInstructionBitXorAssign, SingleInstructionLoad, SingleInstructionStore,\n+    SingleInstructionSubAssign,\n+};\n \n-    /// Increments the per-CPU preemption lock count using one instruction.\n-    pub(crate) fn inc() {\n-        debug_assert_initialized!();\n+/// The GDT ensures that the FS segment is initialized to zero on boot.\n+/// This assertion checks that the base address has been set.\n+macro_rules! debug_assert_initialized {\n+    () => {\n+        // The compiler may think that [`super::get_base`] has side effects\n+        // so it may not be optimized out. We make sure that it will be\n+        // conditionally compiled only in debug builds.\n+        #[cfg(debug_assertions)]\n+        debug_assert_ne!(get_base(), 0);\n+    };\n+}\n+\n+macro_rules! impl_numeric_single_instruction_for {\n+    ($([$typ: ty, $inout_type: ident, $register_format: expr])*) => {$(\n+\n+        impl SingleInstructionAddAssign<$typ> for $typ {\n+            unsafe fn add_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n \n-        // SAFETY: The inline assembly increments the lock count in one\n-        // instruction without side effects.\n-        unsafe {\n-            core::arch::asm!(\n-                \"add dword ptr fs:[__cpu_local_preempt_lock_count], 1\",\n-                options(nostack),\n-            );\n+                core::arch::asm!(\n+                    concat!(\"add fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n         }\n-    }\n \n-    /// Decrements the per-CPU preemption lock count using one instruction.\n-    pub(crate) fn dec() {\n-        debug_assert_initialized!();\n+        impl SingleInstructionSubAssign<$typ> for $typ {\n+            unsafe fn sub_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"sub fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+        impl SingleInstructionBitAndAssign<$typ> for $typ {\n+            unsafe fn bitand_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"and fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+        impl SingleInstructionBitOrAssign<$typ> for $typ {\n+            unsafe fn bitor_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"or fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+        impl SingleInstructionBitXorAssign<$typ> for $typ {\n+            unsafe fn bitxor_assign(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"xor fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+        impl SingleInstructionLoad for $typ {\n+            unsafe fn load(offset: *const Self) -> Self {\n+                debug_assert_initialized!();\n+\n+                let val: Self;\n+                core::arch::asm!(\n+                    concat!(\"mov {0\", $register_format, \"}, fs:[{1}]\"),\n+                    out($inout_type) val,\n+                    in(reg) offset,\n+                    options(nostack, readonly),\n+                );\n+                val\n+            }\n+        }\n+\n+        impl SingleInstructionStore for $typ {\n+            unsafe fn store(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n+\n+                core::arch::asm!(\n+                    concat!(\"mov fs:[{0}], {1\", $register_format, \"}\"),\n+                    in(reg) offset,\n+                    in($inout_type) val,\n+                    options(nostack),\n+                );\n+            }\n+        }\n+\n+    )*};\n+}\n+\n+impl_numeric_single_instruction_for!(\n+    [u64,   reg,    \":r\"]\n+    [usize, reg,    \":r\"]\n+    [u32,   reg,    \":e\"]\n+    [u16,   reg,    \":x\"]\n+    [u8,    reg_byte, \"\"]\n+    [i64,   reg,    \":r\"]\n+    [isize, reg,    \":r\"]\n+    [i32,   reg,    \":e\"]\n+    [i16,   reg,    \":x\"]\n+    [i8,    reg_byte, \"\"]\n+);\n+\n+macro_rules! impl_generic_single_instruction_for {\n+    ($([<$gen_type:ident $(, $more_gen_type:ident)*>, $typ:ty])*) => {$(\n+\n+        impl<$gen_type $(, $more_gen_type)*> SingleInstructionLoad for $typ {\n+            unsafe fn load(offset: *const Self) -> Self {\n+                debug_assert_initialized!();\n+\n+                let val: Self;\n+                core::arch::asm!(\n+                    concat!(\"mov {0}, fs:[{1}]\"),\n+                    out(reg) val,\n+                    in(reg) offset,\n+                    options(nostack, readonly),\n+                );\n+                val\n+            }\n+        }\n+\n+        impl<$gen_type $(, $more_gen_type)*> SingleInstructionStore for $typ {\n+            unsafe fn store(offset: *mut Self, val: Self) {\n+                debug_assert_initialized!();\n \n-        // SAFETY: The inline assembly decrements the lock count in one\n-        // instruction without side effects.\n-        unsafe {\n-            core::arch::asm!(\n-                \"sub dword ptr fs:[__cpu_local_preempt_lock_count], 1\",\n-                options(nostack),\n-            );\n+                core::arch::asm!(\n+                    concat!(\"mov fs:[{0}], {1}\"),\n+                    in(reg) offset,\n+                    in(reg) val,\n+                    options(nostack),\n+                );\n+            }\n         }\n+    )*}\n+}\n+\n+impl_generic_single_instruction_for!(\n+    [<T>, *const T]\n+    [<T>, *mut T]\n+    [<T, R>, fn(T) -> R]\n+);\n+\n+// In this module, booleans are represented by the least significant bit of a\n+// `u8` type. Other bits must be zero. This definition is compatible with the\n+// Rust reference: <https://doc.rust-lang.org/reference/types/boolean.html>.\n+\n+impl SingleInstructionLoad for bool {\n+    unsafe fn load(offset: *const Self) -> Self {\n+        debug_assert_initialized!();\n+\n+        let val: u8;\n+        core::arch::asm!(\n+            \"mov {0}, fs:[{1}]\",\n+            out(reg_byte) val,\n+            in(reg) offset,\n+            options(nostack, readonly),\n+        );\n+        debug_assert!(val == 1 || val == 0);\n+        val == 1\n     }\n+}\n \n-    /// Gets the per-CPU preemption lock count using one instruction.\n-    pub(crate) fn get() -> u32 {\n+impl SingleInstructionStore for bool {\n+    unsafe fn store(offset: *mut Self, val: Self) {\n         debug_assert_initialized!();\n \n-        let count: u32;\n-        // SAFETY: The inline assembly reads the lock count in one instruction\n-        // without side effects.\n-        unsafe {\n-            core::arch::asm!(\n-                \"mov {0:e}, fs:[__cpu_local_preempt_lock_count]\",\n-                out(reg) count,\n-                options(nostack, readonly),\n-            );\n-        }\n-        count\n+        let val: u8 = if val { 1 } else { 0 };\n+        core::arch::asm!(\n+            \"mov fs:[{0}], {1}\",\n+            in(reg) offset,\n+            in(reg_byte) val,\n+            options(nostack),\n+        );\n     }\n }\ndiff --git a/ostd/src/arch/x86/mod.rs b/ostd/src/arch/x86/mod.rs\nindex 1693e0a8c6..3e9b3c36de 100644\n--- a/ostd/src/arch/x86/mod.rs\n+++ b/ostd/src/arch/x86/mod.rs\n@@ -73,7 +73,7 @@ pub(crate) fn init_on_bsp() {\n \n     // SAFETY: no CPU local objects have been accessed by this far. And\n     // we are on the BSP.\n-    unsafe { crate::cpu::cpu_local::init_on_bsp() };\n+    unsafe { crate::cpu::local::init_on_bsp() };\n \n     crate::boot::smp::boot_all_aps();\n \ndiff --git a/ostd/src/arch/x86/trap.rs b/ostd/src/arch/x86/trap.rs\nindex dc0ce89582..5ccc58f657 100644\n--- a/ostd/src/arch/x86/trap.rs\n+++ b/ostd/src/arch/x86/trap.rs\n@@ -2,8 +2,6 @@\n \n //! Handles trap.\n \n-use core::sync::atomic::{AtomicBool, Ordering};\n-\n use align_ext::AlignExt;\n use log::debug;\n #[cfg(feature = \"intel_tdx\")]\n@@ -15,25 +13,25 @@ use super::ex_table::ExTable;\n use crate::arch::{cpu::VIRTUALIZATION_EXCEPTION, tdx_guest::handle_virtual_exception};\n use crate::{\n     cpu::{CpuException, CpuExceptionInfo, PageFaultErrorCode, PAGE_FAULT},\n-    cpu_local,\n+    cpu_local_cell,\n     mm::{\n         kspace::{KERNEL_PAGE_TABLE, LINEAR_MAPPING_BASE_VADDR, LINEAR_MAPPING_VADDR_RANGE},\n         page_prop::{CachePolicy, PageProperty},\n         PageFlags, PrivilegedPageFlags as PrivFlags, MAX_USERSPACE_VADDR, PAGE_SIZE,\n     },\n-    task::current_task,\n+    task::Task,\n     trap::call_irq_callback_functions,\n };\n \n-cpu_local! {\n-    static IS_KERNEL_INTERRUPTED: AtomicBool = AtomicBool::new(false);\n+cpu_local_cell! {\n+    static IS_KERNEL_INTERRUPTED: bool = false;\n }\n \n /// Returns true if this function is called within the context of an IRQ handler\n /// and the IRQ occurs while the CPU is executing in the kernel mode.\n /// Otherwise, it returns false.\n pub fn is_kernel_interrupted() -> bool {\n-    IS_KERNEL_INTERRUPTED.load(Ordering::Acquire)\n+    IS_KERNEL_INTERRUPTED.load()\n }\n \n /// Only from kernel\n@@ -64,15 +62,15 @@ extern \"sysv64\" fn trap_handler(f: &mut TrapFrame) {\n             }\n         }\n     } else {\n-        IS_KERNEL_INTERRUPTED.store(true, Ordering::Release);\n+        IS_KERNEL_INTERRUPTED.store(true);\n         call_irq_callback_functions(f, f.trap_num);\n-        IS_KERNEL_INTERRUPTED.store(false, Ordering::Release);\n+        IS_KERNEL_INTERRUPTED.store(false);\n     }\n }\n \n /// Handles page fault from user space.\n fn handle_user_page_fault(f: &mut TrapFrame, page_fault_addr: u64) {\n-    let current_task = current_task().unwrap();\n+    let current_task = Task::current().unwrap();\n     let user_space = current_task\n         .user_space()\n         .expect(\"the user space is missing when a page fault from the user happens.\");\ndiff --git a/ostd/src/boot/smp.rs b/ostd/src/boot/smp.rs\nindex a40b417e7c..05b9384519 100644\n--- a/ostd/src/boot/smp.rs\n+++ b/ostd/src/boot/smp.rs\n@@ -115,7 +115,7 @@ fn ap_early_entry(local_apic_id: u32) -> ! {\n \n     // SAFETY: we are on the AP.\n     unsafe {\n-        cpu::cpu_local::init_on_ap(local_apic_id);\n+        cpu::local::init_on_ap(local_apic_id);\n     }\n \n     trap::init();\ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\ndeleted file mode 100644\nindex e72ed1ffcd..0000000000\n--- a/ostd/src/cpu/cpu_local.rs\n+++ /dev/null\n@@ -1,340 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! CPU local storage.\n-//!\n-//! This module provides a mechanism to define CPU-local objects.\n-//!\n-//! This is acheived by placing the CPU-local objects in a special section\n-//! `.cpu_local`. The bootstrap processor (BSP) uses the objects linked in this\n-//! section, and these objects are copied to dynamically allocated local\n-//! storage of each application processors (AP) during the initialization\n-//! process.\n-//!\n-//! Such a mechanism exploits the fact that constant values of non-[`Copy`]\n-//! types can be bitwise copied. For example, a [`Option<T>`] object, though\n-//! being not [`Copy`], have a constant constructor [`Option::None`] that\n-//! produces a value that can be bitwise copied to create a new instance.\n-//! [`alloc::sync::Arc`] however, don't have such a constructor, and thus cannot\n-//! be directly used as a CPU-local object. Wrapping it in a type that has a\n-//! constant constructor, like [`Option<T>`], can make it CPU-local.\n-\n-use alloc::vec::Vec;\n-use core::ops::Deref;\n-\n-use align_ext::AlignExt;\n-\n-use crate::{\n-    arch, cpu,\n-    mm::{\n-        paddr_to_vaddr,\n-        page::{self, meta::KernelMeta, ContPages},\n-        PAGE_SIZE,\n-    },\n-    trap::{disable_local, DisabledLocalIrqGuard},\n-};\n-\n-/// Defines a CPU-local variable.\n-///\n-/// # Example\n-///\n-/// ```rust\n-/// use crate::cpu_local;\n-/// use core::cell::RefCell;\n-///\n-/// cpu_local! {\n-///     static FOO: RefCell<u32> = RefCell::new(1);\n-///\n-///     #[allow(unused)]\n-///     pub static BAR: RefCell<f32> = RefCell::new(1.0);\n-/// }\n-///\n-/// println!(\"FOO VAL: {:?}\", *FOO.borrow());\n-/// ```\n-#[macro_export]\n-macro_rules! cpu_local {\n-    ($( $(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; )*) => {\n-        $(\n-            #[link_section = \".cpu_local\"]\n-            $(#[$attr])* $vis static $name: $crate::CpuLocal<$t> = {\n-                let val = $init;\n-                // SAFETY: The CPU local variable instantiated is statically\n-                // stored in the special `.cpu_local` section.\n-                unsafe {\n-                    $crate::CpuLocal::__new(val)\n-                }\n-            };\n-        )*\n-    };\n-}\n-\n-/// CPU-local objects.\n-///\n-/// A CPU-local object only gives you immutable references to the underlying value.\n-/// To mutate the value, one can use atomic values (e.g., [`AtomicU32`]) or internally mutable\n-/// objects (e.g., [`RefCell`]).\n-///\n-/// [`AtomicU32`]: core::sync::atomic::AtomicU32\n-/// [`RefCell`]: core::cell::RefCell\n-pub struct CpuLocal<T>(T);\n-\n-// SAFETY: At any given time, only one task can access the inner value T\n-// of a cpu-local variable even if `T` is not `Sync`.\n-unsafe impl<T> Sync for CpuLocal<T> {}\n-\n-// Prevent valid instances of CpuLocal from being copied to any memory\n-// area outside the .cpu_local section.\n-impl<T> !Copy for CpuLocal<T> {}\n-impl<T> !Clone for CpuLocal<T> {}\n-\n-// In general, it does not make any sense to send instances of CpuLocal to\n-// other tasks as they should live on other CPUs to make sending useful.\n-impl<T> !Send for CpuLocal<T> {}\n-\n-// A check to ensure that the CPU-local object is never accessed before the\n-// initialization for all CPUs.\n-#[cfg(debug_assertions)]\n-use core::sync::atomic::{AtomicBool, Ordering};\n-#[cfg(debug_assertions)]\n-static IS_INITIALIZED: AtomicBool = AtomicBool::new(false);\n-\n-impl<T> CpuLocal<T> {\n-    /// Initialize a CPU-local object.\n-    ///\n-    /// Please do not call this function directly. Instead, use the\n-    /// `cpu_local!` macro.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The caller should ensure that the object initialized by this\n-    /// function resides in the `.cpu_local` section. Otherwise the\n-    /// behavior is undefined.\n-    #[doc(hidden)]\n-    pub const unsafe fn __new(val: T) -> Self {\n-        Self(val)\n-    }\n-\n-    /// Get access to the underlying value with IRQs disabled.\n-    ///\n-    /// By this method, you can borrow a reference to the underlying value\n-    /// even if `T` is not `Sync`. Because that it is per-CPU and IRQs are\n-    /// disabled, no other running task can access it.\n-    pub fn borrow_irq_disabled(&self) -> CpuLocalDerefGuard<'_, T> {\n-        CpuLocalDerefGuard {\n-            cpu_local: self,\n-            _guard: disable_local(),\n-        }\n-    }\n-\n-    /// Get access to the underlying value through a raw pointer.\n-    ///\n-    /// This function calculates the virtual address of the CPU-local object based on the per-\n-    /// cpu base address and the offset in the BSP.\n-    fn get(&self) -> *const T {\n-        // CPU-local objects should be initialized before being accessed. It should be ensured\n-        // by the implementation of OSTD initialization.\n-        #[cfg(debug_assertions)]\n-        debug_assert!(IS_INITIALIZED.load(Ordering::Relaxed));\n-\n-        let offset = {\n-            let bsp_va = self as *const _ as usize;\n-            let bsp_base = __cpu_local_start as usize;\n-            // The implementation should ensure that the CPU-local object resides in the `.cpu_local`.\n-            debug_assert!(bsp_va + core::mem::size_of::<T>() <= __cpu_local_end as usize);\n-\n-            bsp_va - bsp_base as usize\n-        };\n-\n-        let local_base = arch::cpu::local::get_base() as usize;\n-        let local_va = local_base + offset;\n-\n-        // A sanity check about the alignment.\n-        debug_assert_eq!(local_va % core::mem::align_of::<T>(), 0);\n-\n-        local_va as *mut T\n-    }\n-}\n-\n-// Considering a preemptive kernel, a CPU-local object may be dereferenced\n-// when another task tries to access it. So, we need to ensure that `T` is\n-// `Sync` before allowing it to be dereferenced.\n-impl<T: Sync> Deref for CpuLocal<T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &Self::Target {\n-        // SAFETY: it should be properly initialized before accesses.\n-        // And we do not create a mutable reference over it. It is\n-        // `Sync` so it can be referenced from this task.\n-        unsafe { &*self.get() }\n-    }\n-}\n-\n-/// A guard for accessing the CPU-local object.\n-///\n-/// It ensures that the CPU-local object is accessed with IRQs\n-/// disabled. It is created by [`CpuLocal::borrow_irq_disabled`].\n-/// Do not hold this guard for a long time.\n-#[must_use]\n-pub struct CpuLocalDerefGuard<'a, T> {\n-    cpu_local: &'a CpuLocal<T>,\n-    _guard: DisabledLocalIrqGuard,\n-}\n-\n-impl<T> Deref for CpuLocalDerefGuard<'_, T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &Self::Target {\n-        // SAFETY: it should be properly initialized before accesses.\n-        // And we do not create a mutable reference over it. The IRQs\n-        // are disabled so it can be referenced from this task.\n-        unsafe { &*self.cpu_local.get() }\n-    }\n-}\n-\n-/// Sets the base address of the CPU-local storage for the bootstrap processor.\n-///\n-/// It should be called early to let [`crate::task::disable_preempt`] work,\n-/// which needs to update a CPU-local preempt lock count. Otherwise it may\n-/// panic when calling [`crate::task::disable_preempt`].\n-///\n-/// # Safety\n-///\n-/// It should be called only once and only on the BSP.\n-pub(crate) unsafe fn early_init_bsp_local_base() {\n-    let start_base_va = __cpu_local_start as usize as u64;\n-    // SAFETY: The base to be set is the start of the `.cpu_local` section,\n-    // where accessing the CPU-local objects have defined behaviors.\n-    unsafe {\n-        arch::cpu::local::set_base(start_base_va);\n-    }\n-}\n-\n-/// The BSP initializes the CPU-local areas for APs. Here we use a\n-/// non-disabling preempt version of lock because the [`crate::sync`]\n-/// version needs `cpu_local` to work. Preemption and interrupts are\n-/// disabled in this phase so it is safe to use this lock.\n-static CPU_LOCAL_STORAGES: spin::RwLock<Vec<ContPages<KernelMeta>>> = spin::RwLock::new(Vec::new());\n-\n-/// Initializes the CPU local data for the bootstrap processor (BSP).\n-///\n-/// # Safety\n-///\n-/// This function can only called on the BSP, for once.\n-///\n-/// It must be guaranteed that the BSP will not access local data before\n-/// this function being called, otherwise copying non-constant values\n-/// will result in pretty bad undefined behavior.\n-pub unsafe fn init_on_bsp() {\n-    let bsp_base_va = __cpu_local_start as usize;\n-    let bsp_end_va = __cpu_local_end as usize;\n-\n-    let num_cpus = super::num_cpus();\n-\n-    let mut cpu_local_storages = CPU_LOCAL_STORAGES.write();\n-    for cpu_i in 1..num_cpus {\n-        let ap_pages = {\n-            let nbytes = (bsp_end_va - bsp_base_va).align_up(PAGE_SIZE);\n-            page::allocator::alloc_contiguous(nbytes, |_| KernelMeta::default()).unwrap()\n-        };\n-        let ap_pages_ptr = paddr_to_vaddr(ap_pages.start_paddr()) as *mut u8;\n-\n-        // SAFETY: The BSP has not initialized the CPU-local area, so the objects in\n-        // in the `.cpu_local` section can be bitwise bulk copied to the AP's local\n-        // storage. The destination memory is allocated so it is valid to write to.\n-        unsafe {\n-            core::ptr::copy_nonoverlapping(\n-                bsp_base_va as *const u8,\n-                ap_pages_ptr,\n-                bsp_end_va - bsp_base_va,\n-            );\n-        }\n-\n-        // SAFETY: the first 4 bytes is reserved for storing CPU ID.\n-        unsafe {\n-            (ap_pages_ptr as *mut u32).write(cpu_i);\n-        }\n-\n-        // SAFETY: the second 4 bytes is reserved for storing the preemt count.\n-        unsafe {\n-            (ap_pages_ptr as *mut u32).add(1).write(0);\n-        }\n-\n-        cpu_local_storages.push(ap_pages);\n-    }\n-\n-    // Write the CPU ID of BSP to the first 4 bytes of the CPU-local area.\n-    let bsp_cpu_id_ptr = bsp_base_va as *mut u32;\n-    // SAFETY: the first 4 bytes is reserved for storing CPU ID.\n-    unsafe {\n-        bsp_cpu_id_ptr.write(0);\n-    }\n-\n-    cpu::local::set_base(bsp_base_va as u64);\n-\n-    #[cfg(debug_assertions)]\n-    IS_INITIALIZED.store(true, Ordering::Relaxed);\n-}\n-\n-/// Initializes the CPU local data for the application processor (AP).\n-///\n-/// # Safety\n-///\n-/// This function can only called on the AP.\n-pub unsafe fn init_on_ap(cpu_id: u32) {\n-    let rlock = CPU_LOCAL_STORAGES.read();\n-    let ap_pages = rlock.get(cpu_id as usize - 1).unwrap();\n-\n-    let ap_pages_ptr = paddr_to_vaddr(ap_pages.start_paddr()) as *mut u32;\n-\n-    debug_assert_eq!(\n-        cpu_id,\n-        // SAFETY: the CPU ID is stored at the beginning of the CPU local area.\n-        unsafe { ap_pages_ptr.read() }\n-    );\n-\n-    // SAFETY: the memory will be dedicated to the AP. And we are on the AP.\n-    unsafe {\n-        cpu::local::set_base(ap_pages_ptr as u64);\n-    }\n-}\n-\n-// These symbols are provided by the linker script.\n-extern \"C\" {\n-    fn __cpu_local_start();\n-    fn __cpu_local_end();\n-}\n-\n-#[cfg(ktest)]\n-mod test {\n-    use core::{\n-        cell::RefCell,\n-        sync::atomic::{AtomicU8, Ordering},\n-    };\n-\n-    use ostd_macros::ktest;\n-\n-    use super::*;\n-\n-    #[ktest]\n-    fn test_cpu_local() {\n-        cpu_local! {\n-            static FOO: RefCell<usize> = RefCell::new(1);\n-            static BAR: AtomicU8 = AtomicU8::new(3);\n-        }\n-        for _ in 0..10 {\n-            let foo_guard = FOO.borrow_irq_disabled();\n-            assert_eq!(*foo_guard.borrow(), 1);\n-            *foo_guard.borrow_mut() = 2;\n-            drop(foo_guard);\n-            for _ in 0..10 {\n-                assert_eq!(BAR.load(Ordering::Relaxed), 3);\n-                BAR.store(4, Ordering::Relaxed);\n-                assert_eq!(BAR.load(Ordering::Relaxed), 4);\n-                BAR.store(3, Ordering::Relaxed);\n-            }\n-            let foo_guard = FOO.borrow_irq_disabled();\n-            assert_eq!(*foo_guard.borrow(), 2);\n-            *foo_guard.borrow_mut() = 1;\n-            drop(foo_guard);\n-        }\n-    }\n-}\ndiff --git a/ostd/src/cpu/local/cell.rs b/ostd/src/cpu/local/cell.rs\nnew file mode 100644\nindex 0000000000..97c6ceca6a\n--- /dev/null\n+++ b/ostd/src/cpu/local/cell.rs\n@@ -0,0 +1,247 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! The implementaion of CPU-local variables that have inner mutability.\n+\n+use core::cell::UnsafeCell;\n+\n+use super::{__cpu_local_end, __cpu_local_start, single_instr::*};\n+use crate::arch;\n+\n+/// Defines an inner-mutable CPU-local variable.\n+///\n+/// The accessors of the CPU-local variables are defined with [`CpuLocalCell`].\n+///\n+/// It should be noted that if the interrupts or preemption is enabled, two\n+/// operations on the same CPU-local cell variable may access different objects\n+/// since the task may live on different CPUs.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use ostd::cpu_local_cell;\n+///\n+/// cpu_local_cell! {\n+///     static FOO: u32 = 1;\n+///     pub static BAR: *const usize = core::ptr::null();\n+/// }\n+///\n+/// fn not_an_atomic_function() {\n+///     let bar_var: usize = 1;\n+///     BAR.store(&bar_var as *const _);\n+///     // Note that the value of `BAR` here doesn't nessarily equal to the address\n+///     // of `bar_var`, since the task may be preempted and moved to another CPU.\n+///     // You can avoid this by disabling interrupts (and preemption, if needed).\n+///     println!(\"BAR VAL: {:?}\", BAR.load());\n+///\n+///     let _irq_guard = ostd::trap::disable_local_irq();\n+///     println!(\"1st FOO VAL: {:?}\", FOO.load());\n+///     // No suprises here, the two accesses must result in the same value.\n+///     println!(\"2nd FOO VAL: {:?}\", FOO.load());\n+/// }\n+/// ```\n+macro_rules! cpu_local_cell {\n+    ($( $(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; )*) => {\n+        $(\n+            #[link_section = \".cpu_local\"]\n+            $(#[$attr])* $vis static $name: $crate::cpu::local::CpuLocalCell<$t> = {\n+                let val = $init;\n+                // SAFETY: The CPU local variable instantiated is statically\n+                // stored in the special `.cpu_local` section.\n+                unsafe {\n+                    $crate::cpu::local::CpuLocalCell::__new(val)\n+                }\n+            };\n+        )*\n+    };\n+}\n+\n+pub(crate) use cpu_local_cell;\n+\n+/// Inner mutable CPU-local objects.\n+///\n+/// CPU-local cell objects are only accessible from the current CPU. When\n+/// accessing an underlying object using the same `CpuLocalCell` instance, the\n+/// actually accessed object is always on the current CPU. So in a preemptive\n+/// kernel task, the operated object may change if interrupts are enabled.\n+///\n+/// The inner mutability is provided by single instruction operations, and the\n+/// CPU-local cell objects will not ever be shared between CPUs. So it is safe\n+/// to modify the inner value without any locks.\n+///\n+/// You should only create the CPU-local cell object using the macro\n+/// [`cpu_local_cell!`].\n+///\n+/// For the difference between [`super::CpuLocal`] and [`CpuLocalCell`], see\n+/// [`super`].\n+pub struct CpuLocalCell<T: 'static>(UnsafeCell<T>);\n+\n+impl<T: 'static> CpuLocalCell<T> {\n+    /// Initialize a CPU-local object.\n+    ///\n+    /// Please do not call this function directly. Instead, use the\n+    /// `cpu_local!` macro.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that the object initialized by this\n+    /// function resides in the `.cpu_local` section. Otherwise the\n+    /// behavior is undefined.\n+    #[doc(hidden)]\n+    pub const unsafe fn __new(val: T) -> Self {\n+        Self(UnsafeCell::new(val))\n+    }\n+\n+    /// Get access to the underlying value through a raw pointer.\n+    ///\n+    /// This function calculates the virtual address of the CPU-local object\n+    /// based on the CPU-local base address and the offset in the BSP.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that within the entire execution of this\n+    /// function, no interrupt or preemption can occur. Otherwise, the\n+    /// returned pointer may points to the variable in another CPU.\n+    pub unsafe fn as_ptr_mut(&'static self) -> *mut T {\n+        super::has_init::assert_true();\n+\n+        let offset = {\n+            let bsp_va = self as *const _ as usize;\n+            let bsp_base = __cpu_local_start as usize;\n+            // The implementation should ensure that the CPU-local object resides in the `.cpu_local`.\n+            debug_assert!(bsp_va + core::mem::size_of::<T>() <= __cpu_local_end as usize);\n+\n+            bsp_va - bsp_base as usize\n+        };\n+\n+        let local_base = arch::cpu::local::get_base() as usize;\n+        let local_va = local_base + offset;\n+\n+        // A sanity check about the alignment.\n+        debug_assert_eq!(local_va % core::mem::align_of::<T>(), 0);\n+\n+        local_va as *mut T\n+    }\n+}\n+\n+// SAFETY: At any given time, only one task can access the inner value T\n+// of a cpu-local variable even if `T` is not `Sync`.\n+unsafe impl<T: 'static> Sync for CpuLocalCell<T> {}\n+\n+// Prevent valid instances of CpuLocalCell from being copied to any memory\n+// area outside the `.cpu_local` section.\n+impl<T: 'static> !Copy for CpuLocalCell<T> {}\n+impl<T: 'static> !Clone for CpuLocalCell<T> {}\n+\n+// In general, it does not make any sense to send instances of CpuLocalCell to\n+// other tasks as they should live on other CPUs to make sending useful.\n+impl<T: 'static> !Send for CpuLocalCell<T> {}\n+\n+// Accessors for the per-CPU objects whose type implements the single-\n+// instruction operations.\n+\n+impl<T: 'static + SingleInstructionAddAssign<T>> CpuLocalCell<T> {\n+    /// Adds a value to the per-CPU object in a single instruction.\n+    ///\n+    /// This operation wraps on overflow/underflow.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn add_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::add_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionSubAssign<T>> CpuLocalCell<T> {\n+    /// Subtracts a value to the per-CPU object in a single instruction.\n+    ///\n+    /// This operation wraps on overflow/underflow.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn sub_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::sub_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionBitAndAssign<T>> CpuLocalCell<T> {\n+    /// Bitwise ANDs a value to the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn bitand_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::bitand_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionBitOrAssign<T>> CpuLocalCell<T> {\n+    /// Bitwise ORs a value to the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn bitor_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::bitor_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionBitXorAssign<T>> CpuLocalCell<T> {\n+    /// Bitwise XORs a value to the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn bitxor_assign(&'static self, rhs: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::bitxor_assign(offset as *mut T, rhs);\n+        }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionLoad> CpuLocalCell<T> {\n+    /// Gets the value of the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn load(&'static self) -> T {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid.\n+        unsafe { T::load(offset as *const T) }\n+    }\n+}\n+\n+impl<T: 'static + SingleInstructionStore> CpuLocalCell<T> {\n+    /// Writes a value to the per-CPU object in a single instruction.\n+    ///\n+    /// Note that this memory operation will not be elided or reordered by the\n+    /// compiler since it is a black-box.\n+    pub fn store(&'static self, val: T) {\n+        let offset = self as *const _ as usize - __cpu_local_start as usize;\n+        // SAFETY: The CPU-local object is defined in the `.cpu_local` section,\n+        // so the pointer to the object is valid. And the reference is never shared.\n+        unsafe {\n+            T::store(offset as *mut T, val);\n+        }\n+    }\n+}\ndiff --git a/ostd/src/cpu/local/cpu_local.rs b/ostd/src/cpu/local/cpu_local.rs\nnew file mode 100644\nindex 0000000000..37724d2717\n--- /dev/null\n+++ b/ostd/src/cpu/local/cpu_local.rs\n@@ -0,0 +1,210 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! The CPU-local variable implementation.\n+\n+use core::{marker::Sync, ops::Deref};\n+\n+use super::{__cpu_local_end, __cpu_local_start};\n+use crate::{\n+    arch,\n+    trap::{self, DisabledLocalIrqGuard},\n+};\n+\n+/// Defines a CPU-local variable.\n+///\n+/// The accessors of the CPU-local variables are defined with [`CpuLocal`].\n+///\n+/// You can get the reference to the inner object by calling [`deref`]. But\n+/// it is worth noting that the object is always the one in the original core\n+/// when the reference is created. Use [`CpuLocal::borrow_irq_disabled`] if\n+/// this is not expected, or if the inner type can't be shared across CPUs.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use ostd::{cpu_local, sync::SpinLock};\n+/// use core::sync::atomic::{AtomicU32, Ordering};\n+///\n+/// cpu_local! {\n+///     static FOO: AtomicU32 = AtomicU32::new(1);\n+///     pub static BAR: SpinLock<usize> = SpinLock::new(2);\n+/// }\n+///\n+/// fn not_an_atomic_function() {\n+///     let ref_of_foo = FOO.deref();\n+///     // Note that the value of `FOO` here doesn't necessarily equal to the value\n+///     // of `FOO` of exactly the __current__ CPU. Since that task may be preempted\n+///     // and moved to another CPU since `ref_of_foo` is created.\n+///     let val_of_foo = ref_of_foo.load(Ordering::Relaxed);\n+///     println!(\"FOO VAL: {}\", val_of_foo);\n+///\n+///     let bar_guard = BAR.lock_irq_disabled();\n+///     // Here the value of `BAR` is always the one in the __current__ CPU since\n+///     // interrupts are disabled and we do not explicitly yield execution here.\n+///     let val_of_bar = *bar_guard;\n+///     println!(\"BAR VAL: {}\", val_of_bar);\n+/// }\n+/// ```\n+#[macro_export]\n+macro_rules! cpu_local {\n+    ($( $(#[$attr:meta])* $vis:vis static $name:ident: $t:ty = $init:expr; )*) => {\n+        $(\n+            #[link_section = \".cpu_local\"]\n+            $(#[$attr])* $vis static $name: $crate::cpu::local::CpuLocal<$t> = {\n+                let val = $init;\n+                // SAFETY: The per-CPU variable instantiated is statically\n+                // stored in the special `.cpu_local` section.\n+                unsafe {\n+                    $crate::cpu::local::CpuLocal::__new(val)\n+                }\n+            };\n+        )*\n+    };\n+}\n+\n+/// CPU-local objects.\n+///\n+/// CPU-local objects are instanciated once per CPU core. They can be shared to\n+/// other cores. In the context of a preemptible kernel task, when holding the\n+/// reference to the inner object, the object is always the one in the original\n+/// core (when the reference is created), no matter which core the code is\n+/// currently running on.\n+///\n+/// For the difference between [`CpuLocal`] and [`super::CpuLocalCell`], see\n+/// [`super`].\n+pub struct CpuLocal<T: 'static>(T);\n+\n+impl<T: 'static> CpuLocal<T> {\n+    /// Creates a new CPU-local object.\n+    ///\n+    /// Please do not call this function directly. Instead, use the\n+    /// `cpu_local!` macro.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller should ensure that the object initialized by this\n+    /// function resides in the `.cpu_local` section. Otherwise the\n+    /// behavior is undefined.\n+    #[doc(hidden)]\n+    pub const unsafe fn __new(val: T) -> Self {\n+        Self(val)\n+    }\n+\n+    /// Get access to the underlying value with IRQs disabled.\n+    ///\n+    /// By this method, you can borrow a reference to the underlying value\n+    /// even if `T` is not `Sync`. Because that it is per-CPU and IRQs are\n+    /// disabled, no other running tasks can access it.\n+    pub fn borrow_irq_disabled(&'static self) -> CpuLocalDerefGuard<'_, T> {\n+        CpuLocalDerefGuard {\n+            cpu_local: self,\n+            _guard: InnerGuard::Created(trap::disable_local()),\n+        }\n+    }\n+\n+    /// Get access to the underlying value with a provided guard.\n+    ///\n+    /// Similar to [`CpuLocal::borrow_irq_disabled`], but you can provide\n+    /// a guard to disable IRQs if you already have one.\n+    pub fn borrow_with<'a>(\n+        &'static self,\n+        guard: &'a DisabledLocalIrqGuard,\n+    ) -> CpuLocalDerefGuard<'a, T> {\n+        CpuLocalDerefGuard {\n+            cpu_local: self,\n+            _guard: InnerGuard::Provided(guard),\n+        }\n+    }\n+\n+    /// Get access to the underlying value through a raw pointer.\n+    ///\n+    /// This function calculates the virtual address of the CPU-local object\n+    /// based on the CPU-local base address and the offset in the BSP.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that the reference to `self` is static.\n+    unsafe fn as_ptr(&self) -> *const T {\n+        super::has_init::assert_true();\n+\n+        let offset = {\n+            let bsp_va = self as *const _ as usize;\n+            let bsp_base = __cpu_local_start as usize;\n+            // The implementation should ensure that the CPU-local object resides in the `.cpu_local`.\n+            debug_assert!(bsp_va + core::mem::size_of::<T>() <= __cpu_local_end as usize);\n+\n+            bsp_va - bsp_base as usize\n+        };\n+\n+        let local_base = arch::cpu::local::get_base() as usize;\n+        let local_va = local_base + offset;\n+\n+        // A sanity check about the alignment.\n+        debug_assert_eq!(local_va % core::mem::align_of::<T>(), 0);\n+\n+        local_va as *mut T\n+    }\n+}\n+\n+// SAFETY: At any given time, only one task can access the inner value `T` of a\n+// CPU-local variable if `T` is not `Sync`. We guarentee it by disabling the\n+// reference to the inner value, or turning off preemptions when creating\n+// the reference.\n+unsafe impl<T: 'static> Sync for CpuLocal<T> {}\n+\n+// Prevent valid instances of `CpuLocal` from being copied to any memory areas\n+// outside the `.cpu_local` section.\n+impl<T: 'static> !Copy for CpuLocal<T> {}\n+impl<T: 'static> !Clone for CpuLocal<T> {}\n+\n+// In general, it does not make any sense to send instances of `CpuLocal` to\n+// other tasks as they should live on other CPUs to make sending useful.\n+impl<T: 'static> !Send for CpuLocal<T> {}\n+\n+// For `Sync` types, we can create a reference over the inner type and allow\n+// it to be shared across CPUs. So it is sound to provide a `Deref`\n+// implementation. However it is up to the caller if sharing is desired.\n+impl<T: 'static + Sync> Deref for CpuLocal<T> {\n+    type Target = T;\n+\n+    /// Note that the reference to the inner object remains to the same object\n+    /// accessed on the original CPU where the reference is created. If this\n+    /// is not expected, turn off preemptions.\n+    fn deref(&self) -> &Self::Target {\n+        // SAFETY: it should be properly initialized before accesses.\n+        // And we do not create a mutable reference over it. It is\n+        // `Sync` so it can be referenced from this task. Here dereferencing\n+        // from non-static instances is not feasible since no one can create\n+        // a non-static instance of `CpuLocal`.\n+        unsafe { &*self.as_ptr() }\n+    }\n+}\n+\n+/// A guard for accessing the CPU-local object.\n+///\n+/// It ensures that the CPU-local object is accessed with IRQs disabled.\n+/// It is created by [`CpuLocal::borrow_irq_disabled`] or\n+/// [`CpuLocal::borrow_with`]. Do not hold this guard for a longtime.\n+#[must_use]\n+pub struct CpuLocalDerefGuard<'a, T: 'static> {\n+    cpu_local: &'static CpuLocal<T>,\n+    _guard: InnerGuard<'a>,\n+}\n+\n+enum InnerGuard<'a> {\n+    #[allow(dead_code)]\n+    Created(DisabledLocalIrqGuard),\n+    #[allow(dead_code)]\n+    Provided(&'a DisabledLocalIrqGuard),\n+}\n+\n+impl<T: 'static> Deref for CpuLocalDerefGuard<'_, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &Self::Target {\n+        // SAFETY: it should be properly initialized before accesses.\n+        // And we do not create a mutable reference over it. The IRQs\n+        // are disabled so it can only be referenced from this task.\n+        unsafe { &*self.cpu_local.as_ptr() }\n+    }\n+}\ndiff --git a/ostd/src/cpu/local/mod.rs b/ostd/src/cpu/local/mod.rs\nnew file mode 100644\nindex 0000000000..6e9c7b16f1\n--- /dev/null\n+++ b/ostd/src/cpu/local/mod.rs\n@@ -0,0 +1,246 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! CPU local storage.\n+//!\n+//! This module provides a mechanism to define CPU-local objects, by the macro\n+//! [`crate::cpu_local!`].\n+//!\n+//! Such a mechanism exploits the fact that constant values of non-[`Copy`]\n+//! types can be bitwise copied. For example, a [`Option<T>`] object, though\n+//! being not [`Copy`], have a constant constructor [`Option::None`] that\n+//! produces a value that can be bitwise copied to create a new instance.\n+//! [`alloc::sync::Arc`] however, don't have such a constructor, and thus cannot\n+//! be directly used as a CPU-local object. Wrapping it in a type that has a\n+//! constant constructor, like [`Option<T>`], can make it CPU-local.\n+//!\n+//! # Implementation\n+//!\n+//! These APIs are implemented by placing the CPU-local objects in a special\n+//! section `.cpu_local`. The bootstrap processor (BSP) uses the objects linked\n+//! in this section, and these objects are copied to dynamically allocated\n+//! local storage of each application processors (AP) during the initialization\n+//! process.\n+\n+// This module also, provide CPU-local cell objects that have inner mutability.\n+//\n+// The difference between CPU-local objects (defined by [`crate::cpu_local!`])\n+// and CPU-local cell objects (defined by [`crate::cpu_local_cell!`]) is that\n+// the CPU-local objects can be shared across CPUs. While through a CPU-local\n+// cell object you can only access the value on the current CPU, therefore\n+// enabling inner mutability without locks.\n+//\n+// The cell-variant is currently not a public API because that it is rather\n+// hard to be used without introducing races. But it is useful for OSTD's\n+// internal implementation.\n+\n+mod cell;\n+mod cpu_local;\n+\n+pub(crate) mod single_instr;\n+\n+use alloc::vec::Vec;\n+\n+use align_ext::AlignExt;\n+pub(crate) use cell::{cpu_local_cell, CpuLocalCell};\n+pub use cpu_local::{CpuLocal, CpuLocalDerefGuard};\n+\n+use crate::{\n+    arch,\n+    mm::{\n+        paddr_to_vaddr,\n+        page::{self, meta::KernelMeta, ContPages},\n+        PAGE_SIZE,\n+    },\n+};\n+\n+// These symbols are provided by the linker script.\n+extern \"C\" {\n+    fn __cpu_local_start();\n+    fn __cpu_local_end();\n+}\n+\n+cpu_local_cell! {\n+    /// The count of the preempt lock.\n+    ///\n+    /// We need to access the preemption count before we can copy the section\n+    /// for application processors. So, the preemption count is not copied from\n+    /// bootstrap processor's section as the initialization. Instead it is\n+    /// initialized to zero for application processors.\n+    pub(crate) static PREEMPT_LOCK_COUNT: u32 = 0;\n+}\n+\n+/// Sets the base address of the CPU-local storage for the bootstrap processor.\n+///\n+/// It should be called early to let [`crate::task::disable_preempt`] work,\n+/// which needs to update a CPU-local preempt lock count. Otherwise it may\n+/// panic when calling [`crate::task::disable_preempt`].\n+///\n+/// # Safety\n+///\n+/// It should be called only once and only on the BSP.\n+pub(crate) unsafe fn early_init_bsp_local_base() {\n+    let start_base_va = __cpu_local_start as usize as u64;\n+\n+    // SAFETY: The base to be set is the start of the `.cpu_local` section,\n+    // where accessing the CPU-local objects have defined behaviors.\n+    unsafe {\n+        arch::cpu::local::set_base(start_base_va);\n+    }\n+}\n+\n+/// The BSP initializes the CPU-local areas for APs. Here we use a\n+/// non-disabling preempt version of lock because the [`crate::sync`]\n+/// version needs `cpu_local` to work. Preemption and interrupts are\n+/// disabled in this phase so it is safe to use this lock.\n+static CPU_LOCAL_STORAGES: spin::RwLock<Vec<ContPages<KernelMeta>>> = spin::RwLock::new(Vec::new());\n+\n+/// Initializes the CPU local data for the bootstrap processor (BSP).\n+///\n+/// # Safety\n+///\n+/// This function can only called on the BSP, for once.\n+///\n+/// It must be guaranteed that the BSP will not access local data before\n+/// this function being called, otherwise copying non-constant values\n+/// will result in pretty bad undefined behavior.\n+pub unsafe fn init_on_bsp() {\n+    let bsp_base_va = __cpu_local_start as usize;\n+    let bsp_end_va = __cpu_local_end as usize;\n+\n+    let num_cpus = super::num_cpus();\n+\n+    let mut cpu_local_storages = CPU_LOCAL_STORAGES.write();\n+    for cpu_i in 1..num_cpus {\n+        let ap_pages = {\n+            let nbytes = (bsp_end_va - bsp_base_va).align_up(PAGE_SIZE);\n+            page::allocator::alloc_contiguous(nbytes, |_| KernelMeta::default()).unwrap()\n+        };\n+        let ap_pages_ptr = paddr_to_vaddr(ap_pages.start_paddr()) as *mut u8;\n+\n+        // SAFETY: The BSP has not initialized the CPU-local area, so the objects in\n+        // in the `.cpu_local` section can be bitwise bulk copied to the AP's local\n+        // storage. The destination memory is allocated so it is valid to write to.\n+        unsafe {\n+            core::ptr::copy_nonoverlapping(\n+                bsp_base_va as *const u8,\n+                ap_pages_ptr,\n+                bsp_end_va - bsp_base_va,\n+            );\n+        }\n+\n+        // SAFETY: bytes `0:4` are reserved for storing CPU ID.\n+        unsafe {\n+            (ap_pages_ptr as *mut u32).write(cpu_i);\n+        }\n+\n+        // SAFETY: the `PREEMPT_LOCK_COUNT` may be dirty on the BSP, so we need\n+        // to ensure that it is initialized to zero for APs. The safety\n+        // requirements are met since the static is defined in the `.cpu_local`\n+        // section and the pointer to that static is the offset in the CPU-\n+        // local area. It is a `usize` so it is safe to be overwritten.\n+        unsafe {\n+            let preempt_count_ptr = &PREEMPT_LOCK_COUNT as *const _ as usize;\n+            let preempt_count_offset = preempt_count_ptr - __cpu_local_start as usize;\n+            let ap_preempt_count_ptr = ap_pages_ptr.add(preempt_count_offset) as *mut usize;\n+            ap_preempt_count_ptr.write(0);\n+        }\n+\n+        // SAFETY: bytes `8:16` are reserved for storing the pointer to the\n+        // current task. We initialize it to null.\n+        unsafe {\n+            (ap_pages_ptr as *mut u64).add(1).write(0);\n+        }\n+\n+        cpu_local_storages.push(ap_pages);\n+    }\n+\n+    // Write the CPU ID of BSP to the first 4 bytes of the CPU-local area.\n+    let bsp_cpu_id_ptr = bsp_base_va as *mut u32;\n+    // SAFETY: the first 4 bytes is reserved for storing CPU ID.\n+    unsafe {\n+        bsp_cpu_id_ptr.write(0);\n+    }\n+\n+    arch::cpu::local::set_base(bsp_base_va as u64);\n+\n+    has_init::set_true();\n+}\n+\n+/// Initializes the CPU local data for the application processor (AP).\n+///\n+/// # Safety\n+///\n+/// This function can only called on the AP.\n+pub unsafe fn init_on_ap(cpu_id: u32) {\n+    let rlock = CPU_LOCAL_STORAGES.read();\n+    let ap_pages = rlock.get(cpu_id as usize - 1).unwrap();\n+\n+    let ap_pages_ptr = paddr_to_vaddr(ap_pages.start_paddr()) as *mut u32;\n+\n+    debug_assert_eq!(\n+        cpu_id,\n+        // SAFETY: the CPU ID is stored at the beginning of the CPU local area.\n+        unsafe { ap_pages_ptr.read() }\n+    );\n+\n+    // SAFETY: the memory will be dedicated to the AP. And we are on the AP.\n+    unsafe {\n+        arch::cpu::local::set_base(ap_pages_ptr as u64);\n+    }\n+}\n+\n+mod has_init {\n+    //! This module is used to detect the programming error of using the CPU-local\n+    //! mechanism before it is initialized. Such bugs have been found before and we\n+    //! do not want to repeat this error again. This module is only incurs runtime\n+    //! overhead if debug assertions are enabled.\n+    cfg_if::cfg_if! {\n+        if #[cfg(debug_assertions)] {\n+            use core::sync::atomic::{AtomicBool, Ordering};\n+\n+            static IS_INITIALIZED: AtomicBool = AtomicBool::new(false);\n+\n+            pub fn assert_true() {\n+                debug_assert!(IS_INITIALIZED.load(Ordering::Relaxed));\n+            }\n+\n+            pub fn set_true() {\n+                IS_INITIALIZED.store(true, Ordering::Relaxed);\n+            }\n+        } else {\n+            pub fn assert_true() {}\n+\n+            pub fn set_true() {}\n+        }\n+    }\n+}\n+\n+#[cfg(ktest)]\n+mod test {\n+    use core::cell::RefCell;\n+\n+    use ostd_macros::ktest;\n+\n+    #[ktest]\n+    fn test_cpu_local() {\n+        crate::cpu_local! {\n+            static FOO: RefCell<usize> = RefCell::new(1);\n+        }\n+        let foo_guard = FOO.borrow_irq_disabled();\n+        assert_eq!(*foo_guard.borrow(), 1);\n+        *foo_guard.borrow_mut() = 2;\n+        assert_eq!(*foo_guard.borrow(), 2);\n+        drop(foo_guard);\n+    }\n+\n+    #[ktest]\n+    fn test_cpu_local_cell() {\n+        crate::cpu_local_cell! {\n+            static BAR: usize = 3;\n+        }\n+        let _guard = crate::trap::disable_local();\n+        assert_eq!(BAR.load(), 3);\n+        BAR.store(4);\n+        assert_eq!(BAR.load(), 4);\n+    }\n+}\ndiff --git a/ostd/src/cpu/local/single_instr.rs b/ostd/src/cpu/local/single_instr.rs\nnew file mode 100644\nindex 0000000000..1ac436c0b2\n--- /dev/null\n+++ b/ostd/src/cpu/local/single_instr.rs\n@@ -0,0 +1,165 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Extensions for CPU-local types that allows single-instruction operations.\n+//!\n+//! For some per-CPU objects, fetching or modifying the values of them can be\n+//! done in a single instruction. Then we would avoid turning off interrupts\n+//! when accessing them, which incurs non-trivial overhead.\n+//!\n+//! These traits are the architecture-specific interface for single-instruction\n+//! operations. The architecture-specific module can implement these traits for\n+//! common integer types. For architectures that don't support such single-\n+//! instruction operations, we emulate a single-instruction implementation by\n+//! disabling interruptions and preemptions.\n+//!\n+//! Currently we implement some of the [`core::ops`] operations. Bitwise shift\n+//! implementations are missing. Also for less-fundamental types such as\n+//! enumerations or boolean types, the caller can cast it themselves to the\n+//! integer types, for which the operations are implemented.\n+//!\n+//! # Safety\n+//!\n+//! All operations in the provided traits are unsafe, and the caller should\n+//! ensure that the offset is a valid pointer to a static [`CpuLocalCell`]\n+//! object. The offset of the object is relative to the base address of the\n+//! CPU-local storage. These operations are not atomic. Accessing the same\n+//! address from multiple CPUs produces undefined behavior.\n+//!\n+//! [`CpuLocalCell`]: crate::cpu::local::CpuLocalCell\n+\n+/// An interface for architecture-specific single-instruction add operation.\n+pub trait SingleInstructionAddAssign<Rhs = Self> {\n+    /// Adds a value to the per-CPU object.\n+    ///\n+    /// This operation wraps on overflow.\n+    ///\n+    /// # Safety\n+    ///\n+    ///\n+    unsafe fn add_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: num_traits::WrappingAdd + Copy> SingleInstructionAddAssign<T> for T {\n+    default unsafe fn add_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read().wrapping_add(&rhs));\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction subtract operation.\n+pub trait SingleInstructionSubAssign<Rhs = Self> {\n+    /// Subtracts a value to the per-CPU object.\n+    ///\n+    /// This operation wraps on overflow.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn sub_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: num_traits::WrappingSub + Copy> SingleInstructionSubAssign<T> for T {\n+    default unsafe fn sub_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read().wrapping_sub(&rhs));\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction bitwise OR.\n+pub trait SingleInstructionBitOrAssign<Rhs = Self> {\n+    /// Bitwise ORs a value to the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn bitor_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: core::ops::BitOr<Output = T> + Copy> SingleInstructionBitOrAssign<T> for T {\n+    default unsafe fn bitor_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read() | rhs);\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction bitwise AND.\n+pub trait SingleInstructionBitAndAssign<Rhs = Self> {\n+    /// Bitwise ANDs a value to the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn bitand_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: core::ops::BitAnd<Output = T> + Copy> SingleInstructionBitAndAssign<T> for T {\n+    default unsafe fn bitand_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read() & rhs);\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction bitwise XOR.\n+pub trait SingleInstructionBitXorAssign<Rhs = Self> {\n+    /// Bitwise XORs a value to the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn bitxor_assign(offset: *mut Self, rhs: Rhs);\n+}\n+\n+impl<T: core::ops::BitXor<Output = T> + Copy> SingleInstructionBitXorAssign<T> for T {\n+    default unsafe fn bitxor_assign(offset: *mut Self, rhs: T) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let addr = (base + offset as usize) as *mut Self;\n+        addr.write(addr.read() ^ rhs);\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction get operation.\n+pub trait SingleInstructionLoad {\n+    /// Gets the value of the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn load(offset: *const Self) -> Self;\n+}\n+\n+impl<T: Copy> SingleInstructionLoad for T {\n+    default unsafe fn load(offset: *const Self) -> Self {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let ptr = (base + offset as usize) as *const Self;\n+        ptr.read()\n+    }\n+}\n+\n+/// An interface for architecture-specific single-instruction set operation.\n+pub trait SingleInstructionStore {\n+    /// Writes a value to the per-CPU object.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Please refer to the module-level documentation of [`self`].\n+    unsafe fn store(offset: *mut Self, val: Self);\n+}\n+\n+impl<T: Copy> SingleInstructionStore for T {\n+    default unsafe fn store(offset: *mut Self, val: Self) {\n+        let _guard = crate::trap::disable_local();\n+        let base = crate::arch::cpu::local::get_base() as usize;\n+        let ptr = (base + offset as usize) as *mut Self;\n+        ptr.write(val);\n+    }\n+}\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\nindex fa73c96ced..17289230c7 100644\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -2,7 +2,7 @@\n \n //! CPU-related definitions.\n \n-pub mod cpu_local;\n+pub mod local;\n \n cfg_if::cfg_if! {\n     if #[cfg(target_arch = \"x86_64\")]{\n@@ -18,7 +18,7 @@ use bitvec::{\n     slice::IterOnes,\n };\n \n-use crate::{arch::boot::smp::get_num_processors, cpu};\n+use crate::arch::{self, boot::smp::get_num_processors};\n \n /// The number of CPUs. Zero means uninitialized.\n static NUM_CPUS: AtomicU32 = AtomicU32::new(0);\n@@ -47,7 +47,7 @@ pub fn num_cpus() -> u32 {\n pub fn this_cpu() -> u32 {\n     // SAFETY: the cpu ID is stored at the beginning of the cpu local area, provided\n     // by the linker script.\n-    unsafe { (cpu::local::get_base() as usize as *mut u32).read() }\n+    unsafe { (arch::cpu::local::get_base() as usize as *mut u32).read() }\n }\n \n /// A subset of all CPUs in the system.\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\nindex eee80a8a21..f99bb07ecb 100644\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -11,6 +11,7 @@\n #![feature(generic_const_exprs)]\n #![feature(iter_from_coroutine)]\n #![feature(let_chains)]\n+#![feature(min_specialization)]\n #![feature(negative_impls)]\n #![feature(new_uninit)]\n #![feature(panic_info_message)]\n@@ -46,7 +47,9 @@ pub mod user;\n pub use ostd_macros::main;\n pub use ostd_pod::Pod;\n \n-pub use self::{cpu::cpu_local::CpuLocal, error::Error, prelude::Result};\n+pub use self::{error::Error, prelude::Result};\n+// [`CpuLocalCell`] is easy to be mis-used, so we don't expose it to the users.\n+pub(crate) use crate::cpu::local::cpu_local_cell;\n \n /// Initializes OSTD.\n ///\n@@ -64,7 +67,7 @@ pub fn init() {\n     arch::check_tdx_init();\n \n     // SAFETY: This function is called only once and only on the BSP.\n-    unsafe { cpu::cpu_local::early_init_bsp_local_base() };\n+    unsafe { cpu::local::early_init_bsp_local_base() };\n \n     mm::heap_allocator::init();\n \ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\nindex a37672eb37..f9f556d65e 100644\n--- a/ostd/src/mm/vm_space.rs\n+++ b/ostd/src/mm/vm_space.rs\n@@ -48,6 +48,7 @@ use crate::{\n /// A `VmSpace` can also attach a page fault handler, which will be invoked to\n /// handle page faults generated from user space.\n #[allow(clippy::type_complexity)]\n+#[derive(Debug)]\n pub struct VmSpace {\n     pt: PageTable<UserMode>,\n     page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\ndiff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\nindex 54d3de1e8c..c82bcab4da 100644\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -6,7 +6,7 @@ use core::ffi::c_void;\n \n use crate::{\n     arch::qemu::{exit_qemu, QemuExitCode},\n-    early_print, early_println,\n+    cpu_local_cell, early_print, early_println,\n };\n \n extern crate cfg_if;\n@@ -17,12 +17,24 @@ use unwinding::abi::{\n     _Unwind_GetGR, _Unwind_GetIP,\n };\n \n+cpu_local_cell! {\n+    static IN_PANIC: bool = false;\n+}\n+\n /// The panic handler must be defined in the binary crate or in the crate that the binary\n /// crate explicity declares by `extern crate`. We cannot let the base crate depend on OSTD\n /// due to prismatic dependencies. That's why we export this symbol and state the\n /// panic handler in the binary crate.\n #[export_name = \"__aster_panic_handler\"]\n pub fn panic_handler(info: &core::panic::PanicInfo) -> ! {\n+    let _irq_guard = crate::trap::disable_local();\n+\n+    if IN_PANIC.load() {\n+        early_println!(\"{}\", info);\n+        early_println!(\"The panic handler panicked when processing the above panic. Aborting.\");\n+        abort();\n+    }\n+\n     // If in ktest, we would like to catch the panics and resume the test.\n     #[cfg(ktest)]\n     {\n@@ -35,12 +47,15 @@ pub fn panic_handler(info: &core::panic::PanicInfo) -> ! {\n             file: info.location().unwrap().file().to_string(),\n             line: info.location().unwrap().line() as usize,\n             col: info.location().unwrap().column() as usize,\n+            resolve_panic: || {\n+                IN_PANIC.store(false);\n+            },\n         };\n         // Throw an exception and expecting it to be caught.\n         begin_panic(Box::new(throw_info.clone()));\n     }\n     early_println!(\"{}\", info);\n-    early_println!(\"printing stack trace:\");\n+    early_println!(\"Printing stack trace:\");\n     print_stack_trace();\n     abort();\n }\ndiff --git a/ostd/src/prelude.rs b/ostd/src/prelude.rs\nindex c8951d109d..2eb81b7996 100644\n--- a/ostd/src/prelude.rs\n+++ b/ostd/src/prelude.rs\n@@ -8,7 +8,6 @@\n pub type Result<T> = core::result::Result<T, crate::error::Error>;\n \n pub(crate) use alloc::{boxed::Box, sync::Arc, vec::Vec};\n-pub(crate) use core::any::Any;\n \n #[cfg(ktest)]\n pub use ostd_macros::ktest;\ndiff --git a/ostd/src/sync/wait.rs b/ostd/src/sync/wait.rs\nindex 430c5733a6..81cd950e80 100644\n--- a/ostd/src/sync/wait.rs\n+++ b/ostd/src/sync/wait.rs\n@@ -4,7 +4,7 @@ use alloc::{collections::VecDeque, sync::Arc};\n use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n \n use super::SpinLock;\n-use crate::task::{add_task, current_task, schedule, Task, TaskStatus};\n+use crate::task::{add_task, schedule, Task, TaskStatus};\n \n // # Explanation on the memory orders\n //\n@@ -209,7 +209,7 @@ impl Waiter {\n     pub fn new_pair() -> (Self, Arc<Waker>) {\n         let waker = Arc::new(Waker {\n             has_woken: AtomicBool::new(false),\n-            task: current_task().unwrap(),\n+            task: Task::current().unwrap(),\n         });\n         let waiter = Self {\n             waker: waker.clone(),\ndiff --git a/ostd/src/task/mod.rs b/ostd/src/task/mod.rs\nindex bfae2f3b37..61b76cd957 100644\n--- a/ostd/src/task/mod.rs\n+++ b/ostd/src/task/mod.rs\n@@ -10,7 +10,7 @@ mod task;\n \n pub use self::{\n     priority::Priority,\n-    processor::{current_task, disable_preempt, preempt, schedule, DisablePreemptGuard},\n+    processor::{disable_preempt, preempt, schedule, DisablePreemptGuard},\n     scheduler::{add_task, set_scheduler, FifoScheduler, Scheduler},\n     task::{Task, TaskAdapter, TaskContextApi, TaskOptions, TaskStatus},\n };\ndiff --git a/ostd/src/task/priority.rs b/ostd/src/task/priority.rs\nindex ee28a3ae53..4bbad8c5e8 100644\n--- a/ostd/src/task/priority.rs\n+++ b/ostd/src/task/priority.rs\n@@ -7,7 +7,7 @@ pub const REAL_TIME_TASK_PRIORITY: u16 = 100;\n /// Similar to Linux, a larger value represents a lower priority,\n /// with a range of 0 to 139. Priorities ranging from 0 to 99 are considered real-time,\n /// while those ranging from 100 to 139 are considered normal.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub struct Priority(u16);\n \n impl Priority {\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\nindex 71acd5ffcb..4588b6732b 100644\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -1,59 +1,40 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use alloc::sync::Arc;\n-use core::cell::RefCell;\n \n use super::{\n     scheduler::{fetch_task, GLOBAL_SCHEDULER},\n     task::{context_switch, TaskContext},\n     Task, TaskStatus,\n };\n-use crate::{arch, cpu_local};\n-\n-pub struct Processor {\n-    current: Option<Arc<Task>>,\n-    /// A temporary variable used in [`switch_to_task`] to avoid dropping `current` while running\n-    /// as `current`.\n-    prev_task: Option<Arc<Task>>,\n-    idle_task_ctx: TaskContext,\n+use crate::{cpu::local::PREEMPT_LOCK_COUNT, cpu_local_cell};\n+\n+cpu_local_cell! {\n+    /// The `Arc<Task>` (casted by [`Arc::into_raw`]) that is the current task.\n+    static CURRENT_TASK_PTR: *const Task = core::ptr::null();\n+    /// The previous task on the processor before switching to the current task.\n+    /// It is used for delayed resource release since it would be the current\n+    /// task's job to recycle the previous resources.\n+    static PREVIOUS_TASK_PTR: *const Task = core::ptr::null();\n+    /// An unsafe cell to store the context of the bootstrap code.\n+    static BOOTSTRAP_CONTEXT: TaskContext = TaskContext::new();\n }\n \n-impl Processor {\n-    pub const fn new() -> Self {\n-        Self {\n-            current: None,\n-            prev_task: None,\n-            idle_task_ctx: TaskContext::new(),\n-        }\n-    }\n-    fn get_idle_task_ctx_ptr(&mut self) -> *mut TaskContext {\n-        &mut self.idle_task_ctx as *mut _\n-    }\n-    pub fn take_current(&mut self) -> Option<Arc<Task>> {\n-        self.current.take()\n-    }\n-    pub fn current(&self) -> Option<Arc<Task>> {\n-        self.current.as_ref().map(Arc::clone)\n-    }\n-    pub fn set_current_task(&mut self, task: Arc<Task>) {\n-        self.current = Some(task.clone());\n-    }\n-}\n-\n-cpu_local! {\n-    static PROCESSOR: RefCell<Processor> = RefCell::new(Processor::new());\n-}\n-\n-/// Retrieves the current task running on the processor.\n-pub fn current_task() -> Option<Arc<Task>> {\n-    PROCESSOR.borrow_irq_disabled().borrow().current()\n-}\n-\n-pub(crate) fn get_idle_task_ctx_ptr() -> *mut TaskContext {\n-    PROCESSOR\n-        .borrow_irq_disabled()\n-        .borrow_mut()\n-        .get_idle_task_ctx_ptr()\n+/// Retrieves a reference to the current task running on the processor.\n+///\n+/// It returns `None` if the function is called in the bootstrap context.\n+pub(super) fn current_task() -> Option<Arc<Task>> {\n+    let ptr = CURRENT_TASK_PTR.load();\n+    if ptr.is_null() {\n+        return None;\n+    }\n+    // SAFETY: The pointer is set by `switch_to_task` and is guaranteed to be\n+    // built with `Arc::into_raw`.\n+    let restored = unsafe { Arc::from_raw(ptr) };\n+    // To let the `CURRENT_TASK_PTR` still own the task, we clone and forget it\n+    // to increment the reference count.\n+    let _ = core::mem::ManuallyDrop::new(restored.clone());\n+    Some(restored)\n }\n \n /// Calls this function to switch to other task by using GLOBAL_SCHEDULER\n@@ -85,36 +66,48 @@ pub fn preempt(task: &Arc<Task>) {\n \n /// Calls this function to switch to other task\n ///\n-/// if current task is none, then it will use the default task context and it will not return to this function again\n-///\n-/// if current task status is exit, then it will not add to the scheduler\n+/// If current task is none, then it will use the default task context and it\n+/// will not return to this function again.\n ///\n-/// before context switch, current task will switch to the next task\n+/// If the current task's status not [`TaskStatus::Runnable`], it will not be\n+/// added to the scheduler.\n fn switch_to_task(next_task: Arc<Task>) {\n-    if !PREEMPT_COUNT.is_preemptive() {\n+    let preemt_lock_count = PREEMPT_LOCK_COUNT.load();\n+    if preemt_lock_count != 0 {\n         panic!(\n             \"Calling schedule() while holding {} locks\",\n-            PREEMPT_COUNT.num_locks()\n+            preemt_lock_count\n         );\n     }\n \n-    let current_task_ctx_ptr = match current_task() {\n-        None => get_idle_task_ctx_ptr(),\n-        Some(current_task) => {\n-            let ctx_ptr = current_task.ctx().get();\n+    let irq_guard = crate::trap::disable_local();\n+\n+    let current_task_ptr = CURRENT_TASK_PTR.load();\n+\n+    let current_task_ctx_ptr = if current_task_ptr.is_null() {\n+        // SAFETY: Interrupts are disabled, so the pointer is safe to be fetched.\n+        unsafe { BOOTSTRAP_CONTEXT.as_ptr_mut() }\n+    } else {\n+        // SAFETY: The pointer is not NULL and set as the current task.\n+        let cur_task_arc = unsafe {\n+            let restored = Arc::from_raw(current_task_ptr);\n+            let _ = core::mem::ManuallyDrop::new(restored.clone());\n+            restored\n+        };\n \n-            let mut task_inner = current_task.inner_exclusive_access();\n+        let ctx_ptr = cur_task_arc.ctx().get();\n \n-            debug_assert_ne!(task_inner.task_status, TaskStatus::Sleeping);\n-            if task_inner.task_status == TaskStatus::Runnable {\n-                drop(task_inner);\n-                GLOBAL_SCHEDULER.lock_irq_disabled().enqueue(current_task);\n-            } else if task_inner.task_status == TaskStatus::Sleepy {\n-                task_inner.task_status = TaskStatus::Sleeping;\n-            }\n+        let mut task_inner = cur_task_arc.inner_exclusive_access();\n \n-            ctx_ptr\n+        debug_assert_ne!(task_inner.task_status, TaskStatus::Sleeping);\n+        if task_inner.task_status == TaskStatus::Runnable {\n+            drop(task_inner);\n+            GLOBAL_SCHEDULER.lock().enqueue(cur_task_arc);\n+        } else if task_inner.task_status == TaskStatus::Sleepy {\n+            task_inner.task_status = TaskStatus::Sleeping;\n         }\n+\n+        ctx_ptr\n     };\n \n     let next_task_ctx_ptr = next_task.ctx().get().cast_const();\n@@ -124,16 +117,21 @@ fn switch_to_task(next_task: Arc<Task>) {\n     }\n \n     // Change the current task to the next task.\n-    {\n-        let processor_guard = PROCESSOR.borrow_irq_disabled();\n-        let mut processor = processor_guard.borrow_mut();\n-\n-        // We cannot directly overwrite `current` at this point. Since we are running as `current`,\n-        // we must avoid dropping `current`. Otherwise, the kernel stack may be unmapped, leading\n-        // to soundness problems.\n-        let old_current = processor.current.replace(next_task);\n-        processor.prev_task = old_current;\n-    }\n+    //\n+    // We cannot directly drop `current` at this point. Since we are running as\n+    // `current`, we must avoid dropping `current`. Otherwise, the kernel stack\n+    // may be unmapped, leading to instant failure.\n+    let old_prev = PREVIOUS_TASK_PTR.load();\n+    PREVIOUS_TASK_PTR.store(current_task_ptr);\n+    CURRENT_TASK_PTR.store(Arc::into_raw(next_task));\n+    // Drop the old-previously running task.\n+    if !old_prev.is_null() {\n+        // SAFETY: The pointer is set by `switch_to_task` and is guaranteed to be\n+        // built with `Arc::into_raw`.\n+        drop(unsafe { Arc::from_raw(old_prev) });\n+    }\n+\n+    drop(irq_guard);\n \n     // SAFETY:\n     // 1. `ctx` is only used in `schedule()`. We have exclusive access to both the current task\n@@ -151,53 +149,6 @@ fn switch_to_task(next_task: Arc<Task>) {\n     // to the next task switching.\n }\n \n-static PREEMPT_COUNT: PreemptInfo = PreemptInfo::new();\n-\n-/// Currently, it only holds the number of preemption locks held by the\n-/// current CPU. When it has a non-zero value, the CPU cannot call\n-/// [`schedule()`].\n-///\n-/// For per-CPU preemption lock count, we cannot afford two non-atomic\n-/// operations to increment and decrement the count. The [`crate::cpu_local`]\n-/// implementation is free to read the base register and then calculate the\n-/// address of the per-CPU variable using an additional instruction. Interrupts\n-/// can happen between the address calculation and modification to that\n-/// address. If the task is preempted to another CPU by this interrupt, the\n-/// count of the original CPU will be mistakenly modified. To avoid this, we\n-/// introduce [`crate::arch::cpu::local::preempt_lock_count`]. For x86_64 we\n-/// can implement this using one instruction. In other less expressive\n-/// architectures, we may need to disable interrupts.\n-///\n-/// Also, the preemption count is reserved in the `.cpu_local` section\n-/// specified in the linker script. The reason is that we need to access the\n-/// preemption count before we can copy the section for application processors.\n-/// So, the preemption count is not copied from bootstrap processor's section\n-/// as the initialization. Instead it is initialized to zero for application\n-/// processors.\n-struct PreemptInfo {}\n-\n-impl PreemptInfo {\n-    const fn new() -> Self {\n-        Self {}\n-    }\n-\n-    fn increase_num_locks(&self) {\n-        arch::cpu::local::preempt_lock_count::inc();\n-    }\n-\n-    fn decrease_num_locks(&self) {\n-        arch::cpu::local::preempt_lock_count::dec();\n-    }\n-\n-    fn is_preemptive(&self) -> bool {\n-        arch::cpu::local::preempt_lock_count::get() == 0\n-    }\n-\n-    fn num_locks(&self) -> usize {\n-        arch::cpu::local::preempt_lock_count::get() as usize\n-    }\n-}\n-\n /// A guard for disable preempt.\n #[clippy::has_significant_drop]\n #[must_use]\n@@ -210,7 +161,7 @@ impl !Send for DisablePreemptGuard {}\n \n impl DisablePreemptGuard {\n     fn new() -> Self {\n-        PREEMPT_COUNT.increase_num_locks();\n+        PREEMPT_LOCK_COUNT.add_assign(1);\n         Self { _private: () }\n     }\n \n@@ -223,7 +174,7 @@ impl DisablePreemptGuard {\n \n impl Drop for DisablePreemptGuard {\n     fn drop(&mut self) {\n-        PREEMPT_COUNT.decrease_num_locks();\n+        PREEMPT_LOCK_COUNT.sub_assign(1);\n     }\n }\n \ndiff --git a/ostd/src/task/task.rs b/ostd/src/task/task.rs\nindex e18b079954..638591b3f5 100644\n--- a/ostd/src/task/task.rs\n+++ b/ostd/src/task/task.rs\n@@ -3,9 +3,9 @@\n // FIXME: the `intrusive_adapter` macro will generate methods without docs.\n // So we temporary allow missing_docs for this module.\n #![allow(missing_docs)]\n-#![allow(dead_code)]\n \n-use core::cell::UnsafeCell;\n+use alloc::{boxed::Box, sync::Arc};\n+use core::{any::Any, cell::UnsafeCell};\n \n use intrusive_collections::{intrusive_adapter, LinkedListAtomicLink};\n \n@@ -18,7 +18,7 @@ pub(crate) use crate::arch::task::{context_switch, TaskContext};\n use crate::{\n     arch::mm::tlb_flush_addr_range,\n     cpu::CpuSet,\n-    mm::{kspace::KERNEL_PAGE_TABLE, FrameAllocOptions, PageFlags, Segment, PAGE_SIZE},\n+    mm::{kspace::KERNEL_PAGE_TABLE, FrameAllocOptions, Paddr, PageFlags, Segment, PAGE_SIZE},\n     prelude::*,\n     sync::{SpinLock, SpinLockGuard},\n     user::UserSpace,\n@@ -41,6 +41,7 @@ pub trait TaskContextApi {\n     fn stack_pointer(&self) -> usize;\n }\n \n+#[derive(Debug)]\n pub struct KernelStack {\n     segment: Segment,\n     has_guard_page: bool,\n@@ -121,6 +122,7 @@ pub struct Task {\n     link: LinkedListAtomicLink,\n     priority: Priority,\n     // TODO: add multiprocessor support\n+    #[allow(dead_code)]\n     cpu_affinity: CpuSet,\n }\n \n@@ -131,14 +133,17 @@ intrusive_adapter!(pub TaskAdapter = Arc<Task>: Task { link: LinkedListAtomicLin\n // we have exclusive access to the field.\n unsafe impl Sync for Task {}\n \n+#[derive(Debug)]\n pub(crate) struct TaskInner {\n     pub task_status: TaskStatus,\n }\n \n impl Task {\n     /// Gets the current task.\n-    pub fn current() -> Arc<Task> {\n-        current_task().unwrap()\n+    ///\n+    /// It returns `None` if the function is called in the bootstrap context.\n+    pub fn current() -> Option<Arc<Task>> {\n+        current_task()\n     }\n \n     /// Gets inner\ndiff --git a/ostd/src/trap/handler.rs b/ostd/src/trap/handler.rs\nindex d61bd2b23a..3f359f7021 100644\n--- a/ostd/src/trap/handler.rs\n+++ b/ostd/src/trap/handler.rs\n@@ -1,17 +1,15 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use core::sync::atomic::{AtomicBool, Ordering};\n-\n use trapframe::TrapFrame;\n \n-use crate::{arch::irq::IRQ_LIST, cpu_local};\n+use crate::{arch::irq::IRQ_LIST, cpu_local_cell};\n \n pub(crate) fn call_irq_callback_functions(trap_frame: &TrapFrame, irq_number: usize) {\n     // For x86 CPUs, interrupts are not re-entrant. Local interrupts will be disabled when\n     // an interrupt handler is called (Unless interrupts are re-enabled in an interrupt handler).\n     //\n     // FIXME: For arch that supports re-entrant interrupts, we may need to record nested level here.\n-    IN_INTERRUPT_CONTEXT.store(true, Ordering::Release);\n+    IN_INTERRUPT_CONTEXT.store(true);\n \n     let irq_line = IRQ_LIST.get().unwrap().get(irq_number).unwrap();\n     let callback_functions = irq_line.callback_list();\n@@ -22,20 +20,17 @@ pub(crate) fn call_irq_callback_functions(trap_frame: &TrapFrame, irq_number: us\n \n     crate::arch::interrupts_ack(irq_number);\n \n-    IN_INTERRUPT_CONTEXT.store(false, Ordering::Release);\n-\n     crate::arch::irq::enable_local();\n     crate::trap::softirq::process_pending();\n+\n+    IN_INTERRUPT_CONTEXT.store(false);\n }\n \n-cpu_local! {\n-    static IN_INTERRUPT_CONTEXT: AtomicBool = AtomicBool::new(false);\n+cpu_local_cell! {\n+    static IN_INTERRUPT_CONTEXT: bool = false;\n }\n \n /// Returns whether we are in the interrupt context.\n-///\n-/// FIXME: Here only hardware irq is taken into account. According to linux implementation, if\n-/// we are in softirq context, or bottom half is disabled, this function also returns true.\n pub fn in_interrupt_context() -> bool {\n-    IN_INTERRUPT_CONTEXT.load(Ordering::Acquire)\n+    IN_INTERRUPT_CONTEXT.load()\n }\ndiff --git a/ostd/src/trap/softirq.rs b/ostd/src/trap/softirq.rs\nindex df08a08d41..3d9a136c1a 100644\n--- a/ostd/src/trap/softirq.rs\n+++ b/ostd/src/trap/softirq.rs\n@@ -2,14 +2,12 @@\n \n //! Software interrupt.\n \n-#![allow(unused_variables)]\n-\n use alloc::boxed::Box;\n-use core::sync::atomic::{AtomicBool, AtomicU8, Ordering};\n+use core::sync::atomic::{AtomicU8, Ordering};\n \n use spin::Once;\n \n-use crate::{cpu_local, task::disable_preempt};\n+use crate::{cpu_local_cell, task::disable_preempt};\n \n /// A representation of a software interrupt (softirq) line.\n ///\n@@ -70,7 +68,7 @@ impl SoftIrqLine {\n     ///\n     /// If this line is not enabled yet, the method has no effect.\n     pub fn raise(&self) {\n-        PENDING_MASK.fetch_or(1 << self.id, Ordering::Release);\n+        PENDING_MASK.bitor_assign(1 << self.id);\n     }\n \n     /// Enables a softirq line by registering its callback.\n@@ -105,24 +103,24 @@ pub(super) fn init() {\n \n static ENABLED_MASK: AtomicU8 = AtomicU8::new(0);\n \n-cpu_local! {\n-    static PENDING_MASK: AtomicU8 = AtomicU8::new(0);\n-    static IS_ENABLED: AtomicBool = AtomicBool::new(true);\n+cpu_local_cell! {\n+    static PENDING_MASK: u8 = 0;\n+    static IS_ENABLED: bool = true;\n }\n \n /// Enables softirq in current processor.\n fn enable_softirq_local() {\n-    IS_ENABLED.store(true, Ordering::Release);\n+    IS_ENABLED.store(true);\n }\n \n /// Disables softirq in current processor.\n fn disable_softirq_local() {\n-    IS_ENABLED.store(false, Ordering::Release);\n+    IS_ENABLED.store(false);\n }\n \n /// Checks whether the softirq is enabled in current processor.\n fn is_softirq_enabled() -> bool {\n-    IS_ENABLED.load(Ordering::Acquire)\n+    IS_ENABLED.load()\n }\n \n /// Processes pending softirqs.\n@@ -136,12 +134,13 @@ pub(crate) fn process_pending() {\n         return;\n     }\n \n-    let preempt_guard = disable_preempt();\n+    let _preempt_guard = disable_preempt();\n     disable_softirq_local();\n \n-    for i in 0..SOFTIRQ_RUN_TIMES {\n+    for _i in 0..SOFTIRQ_RUN_TIMES {\n         let mut action_mask = {\n-            let pending_mask = PENDING_MASK.fetch_and(0, Ordering::Acquire);\n+            let pending_mask = PENDING_MASK.load();\n+            PENDING_MASK.store(0);\n             pending_mask & ENABLED_MASK.load(Ordering::Acquire)\n         };\n \ndiff --git a/ostd/src/user.rs b/ostd/src/user.rs\nindex 2628ed4449..d52b224f09 100644\n--- a/ostd/src/user.rs\n+++ b/ostd/src/user.rs\n@@ -12,6 +12,7 @@ use crate::{cpu::UserContext, mm::VmSpace, prelude::*, task::Task};\n ///\n /// Each user space has a VM address space and allows a task to execute in\n /// user mode.\n+#[derive(Debug)]\n pub struct UserSpace {\n     /// vm space\n     vm_space: Arc<VmSpace>,\n@@ -94,7 +95,7 @@ pub trait UserContextApi {\n ///\n /// let current = Task::current();\n /// let user_space = current.user_space()\n-///     .expect(\"the current task is associated with a user space\");\n+///     .expect(\"the current task is not associated with a user space\");\n /// let mut user_mode = user_space.user_mode();\n /// loop {\n ///     // Execute in the user space until some interesting events occur.\n@@ -108,14 +109,14 @@ pub struct UserMode<'a> {\n     context: UserContext,\n }\n \n-// An instance of `UserMode` is bound to the current task. So it cannot be\n+// An instance of `UserMode` is bound to the current task. So it cannot be [`Send`].\n impl<'a> !Send for UserMode<'a> {}\n \n impl<'a> UserMode<'a> {\n     /// Creates a new `UserMode`.\n     pub fn new(user_space: &'a Arc<UserSpace>) -> Self {\n         Self {\n-            current: Task::current(),\n+            current: Task::current().unwrap(),\n             user_space,\n             context: user_space.init_ctx,\n         }\n@@ -136,7 +137,7 @@ impl<'a> UserMode<'a> {\n     where\n         F: FnMut() -> bool,\n     {\n-        debug_assert!(Arc::ptr_eq(&self.current, &Task::current()));\n+        debug_assert!(Arc::ptr_eq(&self.current, &Task::current().unwrap()));\n         self.context.execute(has_kernel_event)\n     }\n \n", "test_patch": "diff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\nindex 52dde2534b..21f60b1b6e 100644\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -72,7 +72,7 @@ fn create_user_space(program: &[u8]) -> UserSpace {\n \n fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n     fn user_task() {\n-        let current = Task::current();\n+        let current = Task::current().unwrap();\n         // Switching between user-kernel space is\n         // performed via the UserMode abstraction.\n         let mut user_mode = {\ndiff --git a/ostd/libs/ostd-test/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\nindex 94e2207f16..3ec04c6085 100644\n--- a/ostd/libs/ostd-test/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -103,6 +103,7 @@ pub struct PanicInfo {\n     pub file: String,\n     pub line: usize,\n     pub col: usize,\n+    pub resolve_panic: fn(),\n }\n \n impl core::fmt::Display for PanicInfo {\n@@ -174,6 +175,7 @@ impl KtestItem {\n                 Ok(()) => Err(KtestError::ShouldPanicButNoPanic),\n                 Err(e) => match e.downcast::<PanicInfo>() {\n                     Ok(s) => {\n+                        (s.resolve_panic)();\n                         if let Some(expected) = self.should_panic.1 {\n                             if s.message == expected {\n                                 Ok(())\n", "problem_statement": "Lockless mutability for current task data.\n**This is currently a work-in-progress RFC**\r\n\r\n<!-- Thank you for taking the time to propose a new idea or significant change. Please provide a comprehensive overview of the concepts and motivations at play. -->\r\n\r\n### Summary\r\n\r\n<!-- Briefly summarize the idea, change, or feature you are proposing. What is it about, and what does it aim to achieve? -->\r\n\r\nThis RFC plans to introduce a mechanism for implementing lock-less inner mutability of task data that would be only accessible through the current task.\r\n\r\n### Context and Problem Statement\r\n\r\n<!-- Describe the problem or inadequacy of the current situation/state that your proposal is addressing. This is a key aspect of putting your RFC into context. -->\r\n\r\nIn `aster-nix`, there would be a hell lot of inner mutability patterns using `Mutex` or `SpinLock` in the thread structures, such as `SigMask`, `SigStack` and `sig_context`, etc. They are all implemented with locks. However, they should only be accessed through the current thread. There would be no syncing required. Modifying them from non-current threads should be illegal. Locks are too heavy-weighted for such kind of inner mutability patterns.\r\n\r\nAlso, for shared thread/task data, we access them using `current!` in thread/task contexts. These operations would also require fetching the task from a `cpu_local!` object that incurs heavy type-checking and interrupt/preempt blocking operations. Such jobs can be ignored when the caller is definitely in the current task's contexts. As #1105 points out, even the most simple system call `getpid` would access such task exclusive variables many times. Current implementation would require multiple locking operations and IRQ/preempt guarding operations. Many cycles are wasted doing so.\r\n\r\nWe currently only have per-task data storage that is shared (the implementer should provide `Send + Sync` types). Most of the data that don't need to be shared are also stored here, which would require a lock for inner mutability. In this RFC, I would like to introduce a new kind of data in the `ostd::Task` that is exclusive (not shared, no need to be `Send + Sync`). It would offer a chance to implement the above mentioned per-task storage without locks, boosting the performance by a lot.\r\n\r\n### Proposal\r\n\r\nCurrently we access them via `current!()`, which would return a reference over the current task and it's corresponding data. The data is defined within a structure (either `PosixThread` or `KernelThread` currently).\r\n\r\nIn `aster-nix`, most code are running in the context of a task (other code runs in interrupt contexts). So the code would only have one replica of task local exclusive data that is accessible. Such data would only be accessed by the code in the corresponding task context also. Such kind of data should be safely mutably accessed. OSTD should provide a way to define task-context-global per-task mutable variables that are not visible in interrupt contexts. By doing so, many of the data specific to a task can be implemented lock-less.\r\n\r\n<!-- Clearly and comprehensively describe your proposal including high-level technical specifics, any new interfaces or APIs, and how it should integrate into the existing system. -->\r\n\r\n#### Task entry point\r\n\r\nThe optimal solution would let the task function receive references to the task data as arguments. Then all the functions that requires the data of the current task would like to receive arguments like so. This is the requirement of a function that should be used as a task entry point:\r\n\r\n```rust\r\n/// The entrypoint function of a task takes 4 arguments:\r\n///  1. the mutable task context,\r\n///  2. the shared task context,\r\n///  3. the reference to the mutable per-task data,\r\n///  4. and the reference to the per-task data.\r\npub trait TaskFn =\r\n    Fn(&mut MutTaskInfo, &SharedTaskInfo, &mut dyn Any, &(dyn Any + Send + Sync)) + 'static;\r\n```\r\n\r\nAn example of usage:\r\n\r\n```rust\r\n// In `aster-nix`\r\n\r\nuse ostd::task::{MutTaskInfo, Priority, SharedTaskInfo};\r\nuse crate::thread::{\r\n    MutKernelThreadInfo, MutThreadInfo, SharedKernelThreadInfo, SharedThreadInfo, ThreadExt,\r\n};\r\n\r\nfn init_thread(\r\n    task_ctx_mut: &mut MutTaskInfo,\r\n    task_ctx: &SharedTaskInfo,\r\n    thread_ctx_mut: &mut MutThreadInfo,\r\n    thread_ctx: &SharedThreadInfo,\r\n    kthread_ctx_mut: &mut MutKernelThreadInfo,\r\n    kthread_ctx: &SharedKernelThreadInfo,\r\n) {\r\n    println!(\r\n        \"[kernel] Spawn init thread, tid = {}\",\r\n        thread_ctx.tid\r\n    );\r\n    let initproc = Process::spawn_user_process(\r\n        karg.get_initproc_path().unwrap(),\r\n        karg.get_initproc_argv().to_vec(),\r\n        karg.get_initproc_envp().to_vec(),\r\n    )\r\n    .expect(\"Run init process failed.\");\r\n    // Wait till initproc become zombie.\r\n    while !initproc.is_zombie() {\r\n        // We don't have preemptive scheduler now.\r\n        // The long running init thread should yield its own execution to allow other tasks to go on.\r\n        task_ctx_mut.yield_now();\r\n    }\r\n}\r\n\r\n#[controlled]\r\npub fn run_first_process() -> ! {\r\n    let _thread = thread::new_kernel(init_thread, Priority::normal(), CpuSet::new_full());\r\n}\r\n```\r\n\r\nSuch approach can eliminate the need of neither `current!` nor `current_thread!`, but introduces verbose parameters for the functions. This approach would be implemented by #1108 .\r\n\r\n### Motivation and Rationale\r\n\r\n<!-- Elaborate on why this proposal is important. Provide justifications for why it should be considered and what benefits it brings. Include use cases, user stories, and pain points it intends to solve. -->\r\n\r\n### Detailed Design\r\n\r\n<!-- Dive into the nitty-gritty details of your proposal. Discuss possible implementation strategies, potential issues, and how the proposal would alter workflows, behaviors, or structures. Include pseudocode, diagrams, or mock-ups if possible. -->\r\n\r\n### Alternatives Considered\r\n\r\n<!-- Detail any alternative solutions or features you've considered. Why were they discarded in favor of this proposal? -->\r\n\r\n#### Context markers\r\n\r\nOf course, the easiest way to block IRQ code from accessing task exclusive local data is to have a global state `IN_INTERRUPT_CONTEXT` and check for this state every time when accessing the task exclusive local variables. This would incur some (but not much) runtime overhead. Such overhead can be eliminated by static analysis, which we would encourage.\r\n\r\nThere would be 3 kind of contexts: the bootstrap context, the task context and the interrupt context. So the code would have $2^3=8$ types of possibilities to run in different contexts. But there are only 4 types that are significant:\r\n\r\n 1. Utility code that could run in all 3 kind of contexts;\r\n 2. Bootstrap code that only runs in the bootstrap context;\r\n 3. The IRQ handler that would only run in the interrupt context;\r\n 4. Task code that would only run in the task context.\r\n\r\nOther code can be regarded as the type 1., since we do not know where would it run (for example, the page table cursor methods).\r\n\r\nCode must be written in functions (except for some really low level bootstrap code, which are all in OSTD). So we can mark functions with the above types, and check if type 1./2./3. functions accessed task local exclusive global variables.\r\n\r\nHere are the rules for function types:\r\n\r\n - All functions that may call 2. should be 2., the root of type 2. function is `ostd::main` and `ostd::ap_entry`;\r\n - all functions that may call 3. should be 3., the root of type 3. functions are send to `IrqLine::on_active`;\r\n - all functions that may call 4. should be 4., the root of type 4. functions are send to `TaskOptions`;\r\n - if a function can be call with multiple types of functions, it is type 1.\r\n\r\nIn this alternative, two tools will be introduced:\r\n\r\n 1. A procedural macro crate `code_context` (re-exported by OSTD) that provides function attributes `#[code_context::task]`, `#[code_context::interrupt]`, `#[code_context::boot]`. If not specified, the function is type 1.;\r\n 2. A tools that uses rustc to check the above rules ([an example](https://github.com/heinzelotto/rust-callgraph/tree/master)). OSDK would run this tool before compilation to reject unsound code.\r\n\r\n### Additional Information and Resources\r\n\r\n<!-- Offer any additional information, context, links, or resources that stakeholders might find helpful for understanding the proposal. -->\r\n\r\n### Open Questions\r\n\r\n<!-- List any questions that you have that might need further discussion. This can include areas where you are seeking feedback or require input to finalize decisions. -->\r\n\r\n### Future Possibilities\r\n\r\n<!-- If your RFC is likely to lead to subsequent changes, provide a brief outline of what those might be and how your proposal may lay the groundwork for them. -->\r\n\r\n<!-- We appreciate your effort in contributing to the evolution of our system and look forward to reviewing and discussing your ideas! -->\r\n\n", "hints_text": "Let's say we have a function `foo` with `#[code_context::task]` attribute. How would this `foo` function \"receive references to the task data as arguments\"? What would the user code look like?\n> ```rust\r\n> /// The entrypoint function of a task takes 4 arguments:\r\n> ///  1. the mutable task context,\r\n> ///  2. the shared task context,\r\n> ///  3. the reference to the mutable per-task data,\r\n> ///  4. and the reference to the per-task data.\r\n> pub trait TaskFn =\r\n>     Fn(&mut MutTaskInfo, &SharedTaskInfo, &mut dyn Any, &(dyn Any + Send + Sync)) + 'static;\r\n> ```\r\n\r\nCould you please change it to `FnOnce`?\r\n\r\nhttps://github.com/asterinas/asterinas/blob/20a856b07fa8210fdd2d46d3feb5087004c27afb/kernel/aster-nix/src/fs/pipe.rs#L233-L235", "created_at": "2024-08-03T03:09:32Z", "version": "0.6"}, {"repo": "asterinas/asterinas", "pull_number": 1098, "instance_id": "asterinas__asterinas-1098", "issue_numbers": ["819"], "base_commit": "e83e1fc01ba38ad2a405d7d710ec7258fb664f60", "patch": "diff --git a/kernel/aster-nix/src/net/iface/any_socket.rs b/kernel/aster-nix/src/net/iface/any_socket.rs\nindex 912c7e99e1..a95f0c04e2 100644\n--- a/kernel/aster-nix/src/net/iface/any_socket.rs\n+++ b/kernel/aster-nix/src/net/iface/any_socket.rs\n@@ -59,14 +59,7 @@ impl AnyUnboundSocket {\n     }\n }\n \n-pub struct AnyBoundSocket {\n-    iface: Arc<dyn Iface>,\n-    handle: smoltcp::iface::SocketHandle,\n-    port: u16,\n-    socket_family: SocketFamily,\n-    observer: RwLock<Weak<dyn Observer<()>>>,\n-    weak_self: Weak<Self>,\n-}\n+pub struct AnyBoundSocket(Arc<AnyBoundSocketInner>);\n \n impl AnyBoundSocket {\n     pub(super) fn new(\n@@ -75,21 +68,18 @@ impl AnyBoundSocket {\n         port: u16,\n         socket_family: SocketFamily,\n         observer: Weak<dyn Observer<()>>,\n-    ) -> Arc<Self> {\n-        Arc::new_cyclic(|weak_self| Self {\n+    ) -> Self {\n+        Self(Arc::new(AnyBoundSocketInner {\n             iface,\n             handle,\n             port,\n             socket_family,\n             observer: RwLock::new(observer),\n-            weak_self: weak_self.clone(),\n-        })\n+        }))\n     }\n \n-    pub(super) fn on_iface_events(&self) {\n-        if let Some(observer) = Weak::upgrade(&*self.observer.read()) {\n-            observer.on_events(&())\n-        }\n+    pub(super) fn inner(&self) -> &Arc<AnyBoundSocketInner> {\n+        &self.0\n     }\n \n     /// Set the observer whose `on_events` will be called when certain iface events happen. After\n@@ -99,34 +89,32 @@ impl AnyBoundSocket {\n     /// that the old observer will never be called after the setting. Users should be aware of this\n     /// and proactively handle the race conditions if necessary.\n     pub fn set_observer(&self, handler: Weak<dyn Observer<()>>) {\n-        *self.observer.write() = handler;\n+        *self.0.observer.write() = handler;\n \n-        self.on_iface_events();\n+        self.0.on_iface_events();\n     }\n \n     pub fn local_endpoint(&self) -> Option<IpEndpoint> {\n         let ip_addr = {\n-            let ipv4_addr = self.iface.ipv4_addr()?;\n+            let ipv4_addr = self.0.iface.ipv4_addr()?;\n             IpAddress::Ipv4(ipv4_addr)\n         };\n-        Some(IpEndpoint::new(ip_addr, self.port))\n+        Some(IpEndpoint::new(ip_addr, self.0.port))\n     }\n \n     pub fn raw_with<T: smoltcp::socket::AnySocket<'static>, R, F: FnMut(&mut T) -> R>(\n         &self,\n-        mut f: F,\n+        f: F,\n     ) -> R {\n-        let mut sockets = self.iface.sockets();\n-        let socket = sockets.get_mut::<T>(self.handle);\n-        f(socket)\n+        self.0.raw_with(f)\n     }\n \n     /// Try to connect to a remote endpoint. Tcp socket only.\n     pub fn do_connect(&self, remote_endpoint: IpEndpoint) -> Result<()> {\n-        let mut sockets = self.iface.sockets();\n-        let socket = sockets.get_mut::<RawTcpSocket>(self.handle);\n-        let port = self.port;\n-        let mut iface_inner = self.iface.iface_inner();\n+        let mut sockets = self.0.iface.sockets();\n+        let socket = sockets.get_mut::<RawTcpSocket>(self.0.handle);\n+        let port = self.0.port;\n+        let mut iface_inner = self.0.iface.iface_inner();\n         let cx = iface_inner.context();\n         socket\n             .connect(cx, remote_endpoint, port)\n@@ -135,28 +123,84 @@ impl AnyBoundSocket {\n     }\n \n     pub fn iface(&self) -> &Arc<dyn Iface> {\n-        &self.iface\n+        &self.0.iface\n     }\n+}\n \n-    pub(super) fn weak_ref(&self) -> Weak<Self> {\n-        self.weak_self.clone()\n+impl Drop for AnyBoundSocket {\n+    fn drop(&mut self) {\n+        if self.0.start_closing() {\n+            self.0.iface.common().remove_bound_socket_now(&self.0);\n+        } else {\n+            self.0\n+                .iface\n+                .common()\n+                .remove_bound_socket_when_closed(&self.0);\n+        }\n     }\n+}\n \n-    fn close(&self) {\n+pub(super) struct AnyBoundSocketInner {\n+    iface: Arc<dyn Iface>,\n+    handle: smoltcp::iface::SocketHandle,\n+    port: u16,\n+    socket_family: SocketFamily,\n+    observer: RwLock<Weak<dyn Observer<()>>>,\n+}\n+\n+impl AnyBoundSocketInner {\n+    pub(super) fn on_iface_events(&self) {\n+        if let Some(observer) = Weak::upgrade(&*self.observer.read()) {\n+            observer.on_events(&())\n+        }\n+    }\n+\n+    pub(super) fn is_closed(&self) -> bool {\n+        match self.socket_family {\n+            SocketFamily::Tcp => self.raw_with(|socket: &mut RawTcpSocket| {\n+                socket.state() == smoltcp::socket::tcp::State::Closed\n+            }),\n+            SocketFamily::Udp => true,\n+        }\n+    }\n+\n+    /// Starts closing the socket and returns whether the socket is closed.\n+    ///\n+    /// For sockets that can be closed immediately, such as UDP sockets and TCP listening sockets,\n+    /// this method will always return `true`.\n+    ///\n+    /// For other sockets, such as TCP connected sockets, they cannot be closed immediately because\n+    /// we at least need to send the FIN packet and wait for the remote end to send an ACK packet.\n+    /// In this case, this method will return `false` and [`Self::is_closed`] can be used to\n+    /// determine if the closing process is complete.\n+    fn start_closing(&self) -> bool {\n         match self.socket_family {\n-            SocketFamily::Tcp => self.raw_with(|socket: &mut RawTcpSocket| socket.close()),\n-            SocketFamily::Udp => self.raw_with(|socket: &mut RawUdpSocket| socket.close()),\n+            SocketFamily::Tcp => self.raw_with(|socket: &mut RawTcpSocket| {\n+                socket.close();\n+                socket.state() == smoltcp::socket::tcp::State::Closed\n+            }),\n+            SocketFamily::Udp => {\n+                self.raw_with(|socket: &mut RawUdpSocket| socket.close());\n+                true\n+            }\n         }\n     }\n+\n+    pub fn raw_with<T: smoltcp::socket::AnySocket<'static>, R, F: FnMut(&mut T) -> R>(\n+        &self,\n+        mut f: F,\n+    ) -> R {\n+        let mut sockets = self.iface.sockets();\n+        let socket = sockets.get_mut::<T>(self.handle);\n+        f(socket)\n+    }\n }\n \n-impl Drop for AnyBoundSocket {\n+impl Drop for AnyBoundSocketInner {\n     fn drop(&mut self) {\n-        self.close();\n-        self.iface.poll();\n-        self.iface.common().remove_socket(self.handle);\n-        self.iface.common().release_port(self.port);\n-        self.iface.common().remove_bound_socket(self.weak_ref());\n+        let iface_common = self.iface.common();\n+        iface_common.remove_socket(self.handle);\n+        iface_common.release_port(self.port);\n     }\n }\n \ndiff --git a/kernel/aster-nix/src/net/iface/common.rs b/kernel/aster-nix/src/net/iface/common.rs\nindex 787669245b..23bafa8f2d 100644\n--- a/kernel/aster-nix/src/net/iface/common.rs\n+++ b/kernel/aster-nix/src/net/iface/common.rs\n@@ -3,7 +3,7 @@\n use alloc::collections::btree_map::Entry;\n use core::sync::atomic::{AtomicU64, Ordering};\n \n-use keyable_arc::KeyableWeak;\n+use keyable_arc::KeyableArc;\n use ostd::sync::WaitQueue;\n use smoltcp::{\n     iface::{SocketHandle, SocketSet},\n@@ -12,10 +12,10 @@ use smoltcp::{\n };\n \n use super::{\n-    any_socket::{AnyBoundSocket, AnyRawSocket, AnyUnboundSocket, SocketFamily},\n+    any_socket::{AnyBoundSocketInner, AnyRawSocket, AnyUnboundSocket, SocketFamily},\n     time::get_network_timestamp,\n     util::BindPortConfig,\n-    Iface, Ipv4Address,\n+    AnyBoundSocket, Iface, Ipv4Address,\n };\n use crate::prelude::*;\n \n@@ -25,7 +25,8 @@ pub struct IfaceCommon {\n     used_ports: RwLock<BTreeMap<u16, usize>>,\n     /// The time should do next poll. We stores the total milliseconds since system boots up.\n     next_poll_at_ms: AtomicU64,\n-    bound_sockets: RwLock<BTreeSet<KeyableWeak<AnyBoundSocket>>>,\n+    bound_sockets: RwLock<BTreeSet<KeyableArc<AnyBoundSocketInner>>>,\n+    closing_sockets: SpinLock<BTreeSet<KeyableArc<AnyBoundSocketInner>>>,\n     /// The wait queue that background polling thread will sleep on\n     polling_wait_queue: WaitQueue,\n }\n@@ -40,14 +41,21 @@ impl IfaceCommon {\n             used_ports: RwLock::new(used_ports),\n             next_poll_at_ms: AtomicU64::new(0),\n             bound_sockets: RwLock::new(BTreeSet::new()),\n+            closing_sockets: SpinLock::new(BTreeSet::new()),\n             polling_wait_queue: WaitQueue::new(),\n         }\n     }\n \n+    /// Acquires the lock to the interface.\n+    ///\n+    /// *Lock ordering:* [`Self::sockets`] first, [`Self::interface`] second.\n     pub(super) fn interface(&self) -> SpinLockGuard<smoltcp::iface::Interface> {\n         self.interface.lock_irq_disabled()\n     }\n \n+    /// Acuqires the lock to the sockets.\n+    ///\n+    /// *Lock ordering:* [`Self::sockets`] first, [`Self::interface`] second.\n     pub(super) fn sockets(&self) -> SpinLockGuard<smoltcp::iface::SocketSet<'static>> {\n         self.sockets.lock_irq_disabled()\n     }\n@@ -109,7 +117,7 @@ impl IfaceCommon {\n         iface: Arc<dyn Iface>,\n         socket: Box<AnyUnboundSocket>,\n         config: BindPortConfig,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Box<AnyUnboundSocket>)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Box<AnyUnboundSocket>)> {\n         let port = if let Some(port) = config.port() {\n             port\n         } else {\n@@ -135,7 +143,7 @@ impl IfaceCommon {\n             ),\n         };\n         let bound_socket = AnyBoundSocket::new(iface, handle, port, socket_family, observer);\n-        self.insert_bound_socket(&bound_socket).unwrap();\n+        self.insert_bound_socket(bound_socket.inner());\n \n         Ok(bound_socket)\n     }\n@@ -146,37 +154,60 @@ impl IfaceCommon {\n     }\n \n     pub(super) fn poll<D: Device + ?Sized>(&self, device: &mut D) {\n+        let mut sockets = self.sockets.lock_irq_disabled();\n         let mut interface = self.interface.lock_irq_disabled();\n+\n         let timestamp = get_network_timestamp();\n-        let has_events = {\n-            let mut sockets = self.sockets.lock_irq_disabled();\n-            interface.poll(timestamp, device, &mut sockets)\n-            // drop sockets here to avoid deadlock\n-        };\n-        if has_events {\n-            self.bound_sockets.read().iter().for_each(|bound_socket| {\n-                if let Some(bound_socket) = bound_socket.upgrade() {\n-                    bound_socket.on_iface_events();\n+        let (has_events, poll_at) = {\n+            let mut has_events = false;\n+            let mut poll_at;\n+            loop {\n+                has_events |= interface.poll(timestamp, device, &mut sockets);\n+                poll_at = interface.poll_at(timestamp, &sockets);\n+                let Some(instant) = poll_at else {\n+                    break;\n+                };\n+                if instant > timestamp {\n+                    break;\n                 }\n-            });\n-        }\n+            }\n+            (has_events, poll_at)\n+        };\n+\n+        // drop sockets here to avoid deadlock\n+        drop(interface);\n+        drop(sockets);\n \n-        let sockets = self.sockets.lock_irq_disabled();\n-        if let Some(instant) = interface.poll_at(timestamp, &sockets) {\n-            let old_instant = self.next_poll_at_ms.load(Ordering::Acquire);\n+        if let Some(instant) = poll_at {\n+            let old_instant = self.next_poll_at_ms.load(Ordering::Relaxed);\n             let new_instant = instant.total_millis() as u64;\n             self.next_poll_at_ms.store(new_instant, Ordering::Relaxed);\n \n-            if new_instant < old_instant {\n+            if old_instant == 0 || new_instant < old_instant {\n                 self.polling_wait_queue.wake_all();\n             }\n         } else {\n             self.next_poll_at_ms.store(0, Ordering::Relaxed);\n         }\n+\n+        if has_events {\n+            // We never try to hold the write lock in the IRQ context, and we disable IRQ when\n+            // holding the write lock. So we don't need to disable IRQ when holding the read lock.\n+            self.bound_sockets.read().iter().for_each(|bound_socket| {\n+                bound_socket.on_iface_events();\n+            });\n+\n+            let closed_sockets = self\n+                .closing_sockets\n+                .lock_irq_disabled()\n+                .extract_if(|closing_socket| closing_socket.is_closed())\n+                .collect::<Vec<_>>();\n+            drop(closed_sockets);\n+        }\n     }\n \n     pub(super) fn next_poll_at_ms(&self) -> Option<u64> {\n-        let millis = self.next_poll_at_ms.load(Ordering::SeqCst);\n+        let millis = self.next_poll_at_ms.load(Ordering::Relaxed);\n         if millis == 0 {\n             None\n         } else {\n@@ -184,19 +215,44 @@ impl IfaceCommon {\n         }\n     }\n \n-    fn insert_bound_socket(&self, socket: &Arc<AnyBoundSocket>) -> Result<()> {\n-        let weak_ref = KeyableWeak::from(Arc::downgrade(socket));\n-        let mut bound_sockets = self.bound_sockets.write();\n-        if bound_sockets.contains(&weak_ref) {\n-            return_errno_with_message!(Errno::EINVAL, \"the socket is already bound\");\n-        }\n-        bound_sockets.insert(weak_ref);\n-        Ok(())\n+    fn insert_bound_socket(&self, socket: &Arc<AnyBoundSocketInner>) {\n+        let keyable_socket = KeyableArc::from(socket.clone());\n+\n+        let inserted = self\n+            .bound_sockets\n+            .write_irq_disabled()\n+            .insert(keyable_socket);\n+        assert!(inserted);\n     }\n \n-    pub(super) fn remove_bound_socket(&self, socket: Weak<AnyBoundSocket>) {\n-        let weak_ref = KeyableWeak::from(socket);\n-        self.bound_sockets.write().remove(&weak_ref);\n+    pub(super) fn remove_bound_socket_now(&self, socket: &Arc<AnyBoundSocketInner>) {\n+        let keyable_socket = KeyableArc::from(socket.clone());\n+\n+        let removed = self\n+            .bound_sockets\n+            .write_irq_disabled()\n+            .remove(&keyable_socket);\n+        assert!(removed);\n+    }\n+\n+    pub(super) fn remove_bound_socket_when_closed(&self, socket: &Arc<AnyBoundSocketInner>) {\n+        let keyable_socket = KeyableArc::from(socket.clone());\n+\n+        let removed = self\n+            .bound_sockets\n+            .write_irq_disabled()\n+            .remove(&keyable_socket);\n+        assert!(removed);\n+\n+        let mut closing_sockets = self.closing_sockets.lock_irq_disabled();\n+\n+        // Check `is_closed` after holding the lock to avoid race conditions.\n+        if keyable_socket.is_closed() {\n+            return;\n+        }\n+\n+        let inserted = closing_sockets.insert(keyable_socket);\n+        assert!(inserted);\n     }\n }\n \ndiff --git a/kernel/aster-nix/src/net/iface/mod.rs b/kernel/aster-nix/src/net/iface/mod.rs\nindex d90b746d94..47149a0e38 100644\n--- a/kernel/aster-nix/src/net/iface/mod.rs\n+++ b/kernel/aster-nix/src/net/iface/mod.rs\n@@ -45,7 +45,7 @@ pub trait Iface: internal::IfaceInternal + Send + Sync {\n         &self,\n         socket: Box<AnyUnboundSocket>,\n         config: BindPortConfig,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Box<AnyUnboundSocket>)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Box<AnyUnboundSocket>)> {\n         let common = self.common();\n         common.bind_socket(self.arc_self(), socket, config)\n     }\ndiff --git a/kernel/aster-nix/src/net/socket/ip/common.rs b/kernel/aster-nix/src/net/socket/ip/common.rs\nindex 5edfa2ebee..785bc5a03d 100644\n--- a/kernel/aster-nix/src/net/socket/ip/common.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/common.rs\n@@ -46,7 +46,7 @@ pub(super) fn bind_socket(\n     unbound_socket: Box<AnyUnboundSocket>,\n     endpoint: &IpEndpoint,\n     can_reuse: bool,\n-) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Box<AnyUnboundSocket>)> {\n+) -> core::result::Result<AnyBoundSocket, (Error, Box<AnyUnboundSocket>)> {\n     let iface = match get_iface_to_bind(&endpoint.addr) {\n         Some(iface) => iface,\n         None => {\ndiff --git a/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs b/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\nindex 4fc9f4bfd4..e8869bcb23 100644\n--- a/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/datagram/bound.rs\n@@ -13,12 +13,12 @@ use crate::{\n };\n \n pub struct BoundDatagram {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     remote_endpoint: Option<IpEndpoint>,\n }\n \n impl BoundDatagram {\n-    pub fn new(bound_socket: Arc<AnyBoundSocket>) -> Self {\n+    pub fn new(bound_socket: AnyBoundSocket) -> Self {\n         Self {\n             bound_socket,\n             remote_endpoint: None,\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\nindex afb4527c43..6ac2b91226 100644\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connected.rs\n@@ -15,7 +15,7 @@ use crate::{\n };\n \n pub struct ConnectedStream {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     remote_endpoint: IpEndpoint,\n     /// Indicates whether this connection is \"new\" in a `connect()` system call.\n     ///\n@@ -32,7 +32,7 @@ pub struct ConnectedStream {\n \n impl ConnectedStream {\n     pub fn new(\n-        bound_socket: Arc<AnyBoundSocket>,\n+        bound_socket: AnyBoundSocket,\n         remote_endpoint: IpEndpoint,\n         is_new_connection: bool,\n     ) -> Self {\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\nindex 3503a9afee..2aca5c52b5 100644\n--- a/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/connecting.rs\n@@ -8,7 +8,7 @@ use crate::{\n };\n \n pub struct ConnectingStream {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     remote_endpoint: IpEndpoint,\n     conn_result: RwLock<Option<ConnResult>>,\n }\n@@ -26,9 +26,9 @@ pub enum NonConnectedStream {\n \n impl ConnectingStream {\n     pub fn new(\n-        bound_socket: Arc<AnyBoundSocket>,\n+        bound_socket: AnyBoundSocket,\n         remote_endpoint: IpEndpoint,\n-    ) -> core::result::Result<Self, (Error, Arc<AnyBoundSocket>)> {\n+    ) -> core::result::Result<Self, (Error, AnyBoundSocket)> {\n         if let Err(err) = bound_socket.do_connect(remote_endpoint) {\n             return Err((err, bound_socket));\n         }\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/init.rs b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\nindex 8f103a4044..81c1df5185 100644\n--- a/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/init.rs\n@@ -15,7 +15,7 @@ use crate::{\n \n pub enum InitStream {\n     Unbound(Box<AnyUnboundSocket>),\n-    Bound(Arc<AnyBoundSocket>),\n+    Bound(AnyBoundSocket),\n }\n \n impl InitStream {\n@@ -23,14 +23,14 @@ impl InitStream {\n         InitStream::Unbound(Box::new(AnyUnboundSocket::new_tcp(observer)))\n     }\n \n-    pub fn new_bound(bound_socket: Arc<AnyBoundSocket>) -> Self {\n+    pub fn new_bound(bound_socket: AnyBoundSocket) -> Self {\n         InitStream::Bound(bound_socket)\n     }\n \n     pub fn bind(\n         self,\n         endpoint: &IpEndpoint,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Self)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Self)> {\n         let unbound_socket = match self {\n             InitStream::Unbound(unbound_socket) => unbound_socket,\n             InitStream::Bound(bound_socket) => {\n@@ -50,7 +50,7 @@ impl InitStream {\n     fn bind_to_ephemeral_endpoint(\n         self,\n         remote_endpoint: &IpEndpoint,\n-    ) -> core::result::Result<Arc<AnyBoundSocket>, (Error, Self)> {\n+    ) -> core::result::Result<AnyBoundSocket, (Error, Self)> {\n         let endpoint = get_ephemeral_endpoint(remote_endpoint);\n         self.bind(&endpoint)\n     }\ndiff --git a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\nindex ef63ce1561..d7bdc593c0 100644\n--- a/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n+++ b/kernel/aster-nix/src/net/socket/ip/stream/listen.rs\n@@ -13,16 +13,16 @@ use crate::{\n pub struct ListenStream {\n     backlog: usize,\n     /// A bound socket held to ensure the TCP port cannot be released\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n     /// Backlog sockets listening at the local endpoint\n     backlog_sockets: RwLock<Vec<BacklogSocket>>,\n }\n \n impl ListenStream {\n     pub fn new(\n-        bound_socket: Arc<AnyBoundSocket>,\n+        bound_socket: AnyBoundSocket,\n         backlog: usize,\n-    ) -> core::result::Result<Self, (Error, Arc<AnyBoundSocket>)> {\n+    ) -> core::result::Result<Self, (Error, AnyBoundSocket)> {\n         let listen_stream = Self {\n             backlog,\n             bound_socket,\n@@ -99,13 +99,13 @@ impl ListenStream {\n }\n \n struct BacklogSocket {\n-    bound_socket: Arc<AnyBoundSocket>,\n+    bound_socket: AnyBoundSocket,\n }\n \n impl BacklogSocket {\n     // FIXME: All of the error codes below seem to have no Linux equivalents, and I see no reason\n     // why the error may occur. Perhaps it is better to call `unwrap()` directly?\n-    fn new(bound_socket: &Arc<AnyBoundSocket>) -> Result<Self> {\n+    fn new(bound_socket: &AnyBoundSocket) -> Result<Self> {\n         let local_endpoint = bound_socket.local_endpoint().ok_or(Error::with_message(\n             Errno::EINVAL,\n             \"the socket is not bound\",\n@@ -143,7 +143,7 @@ impl BacklogSocket {\n             .raw_with(|socket: &mut RawTcpSocket| socket.remote_endpoint())\n     }\n \n-    fn into_bound_socket(self) -> Arc<AnyBoundSocket> {\n+    fn into_bound_socket(self) -> AnyBoundSocket {\n         self.bound_socket\n     }\n }\n", "test_patch": "diff --git a/test/apps/network/listen_backlog.c b/test/apps/network/listen_backlog.c\nindex 9491891655..301a90bde7 100644\n--- a/test/apps/network/listen_backlog.c\n+++ b/test/apps/network/listen_backlog.c\n@@ -131,7 +131,7 @@ int main(void)\n \n \tfor (backlog = 0; backlog <= MAX_TEST_BACKLOG; ++backlog) {\n \t\t// Avoid \"bind: Address already in use\"\n-\t\taddr.sin_port = htons(8080 + backlog);\n+\t\taddr.sin_port = htons(10000 + backlog);\n \n \t\terr = test_listen_backlog(&addr, backlog);\n \t\tif (err != 0)\ndiff --git a/test/apps/network/send_buf_full.c b/test/apps/network/send_buf_full.c\nindex d4b8671e9b..6889fe1a01 100644\n--- a/test/apps/network/send_buf_full.c\n+++ b/test/apps/network/send_buf_full.c\n@@ -265,7 +265,7 @@ int main(void)\n \tstruct sockaddr_in addr;\n \n \taddr.sin_family = AF_INET;\n-\taddr.sin_port = htons(8080);\n+\taddr.sin_port = htons(9999);\n \tif (inet_aton(\"127.0.0.1\", &addr.sin_addr) < 0) {\n \t\tfprintf(stderr, \"inet_aton cannot parse 127.0.0.1\\n\");\n \t\treturn -1;\ndiff --git a/test/apps/network/tcp_err.c b/test/apps/network/tcp_err.c\nindex 384f7d179d..d8247cecee 100644\n--- a/test/apps/network/tcp_err.c\n+++ b/test/apps/network/tcp_err.c\n@@ -338,26 +338,23 @@ FN_TEST(sendmsg_and_recvmsg)\n \n \t// Send two message and receive two message\n \n-\t// This test is commented out due to a known issue:\n-\t// See <https://github.com/asterinas/asterinas/issues/819>\n-\n-\t// iov[0].iov_base = message;\n-\t// iov[0].iov_len = strlen(message);\n-\t// msg.msg_iovlen = 1;\n-\t// TEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\n-\t// TEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\n-\n-\t// char first_buffer[BUFFER_SIZE] = { 0 };\n-\t// char second_buffer[BUFFER_SIZE] = { 0 };\n-\t// iov[0].iov_base = first_buffer;\n-\t// iov[0].iov_len = BUFFER_SIZE;\n-\t// iov[1].iov_base = second_buffer;\n-\t// iov[1].iov_len = BUFFER_SIZE;\n-\t// msg.msg_iovlen = 2;\n-\n-\t// // Ensure two messages are prepared for receiving\n-\t// sleep(1);\n-\n-\t// TEST_RES(recvmsg(sk_connected, &msg, 0), _ret == strlen(message) * 2);\n+\tiov[0].iov_base = message;\n+\tiov[0].iov_len = strlen(message);\n+\tmsg.msg_iovlen = 1;\n+\tTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\n+\tTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\n+\n+\tchar first_buffer[BUFFER_SIZE] = { 0 };\n+\tchar second_buffer[BUFFER_SIZE] = { 0 };\n+\tiov[0].iov_base = first_buffer;\n+\tiov[0].iov_len = BUFFER_SIZE;\n+\tiov[1].iov_base = second_buffer;\n+\tiov[1].iov_len = BUFFER_SIZE;\n+\tmsg.msg_iovlen = 2;\n+\n+\t// Ensure two messages are prepared for receiving\n+\tsleep(1);\n+\n+\tTEST_RES(recvmsg(sk_connected, &msg, 0), _ret == strlen(message) * 2);\n }\n END_TEST()\n", "problem_statement": "Polling ifaces may not ensure packets be transmitted\nThe problem occurs when I trying to send two messages to the same TCP socket, and trying to receive the two messages at once.\r\n\r\n```C\r\nTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\r\nTEST_RES(sendmsg(sk_accepted, &msg, 0), _ret == strlen(message));\r\n\r\n// Ensure two messages are ready for receiving\r\nsleep(1);\r\n\r\nTEST_RES(recvmsg(sk_connected, &msg, 0), _ret == strlen(message) * 2);\r\n```\r\n\r\nThe test program always succeeds when running on Linux.\r\n\r\nHowever, when running on Asterinas, `sk_connected` can only accept the first message.\r\n\r\nThe problem disappears when I running in set log level as TRACE. So it may be some problems with timeout.......\r\n\r\n# Possible solution\r\n\r\nThis problem may be related to the [nagle-enabled feature](https://docs.rs/smoltcp/latest/smoltcp/socket/tcp/struct.Socket.html#method.set_nagle_enabled), which disables small packets to be transmitted. If set `nagle-enabled` as false, the problem will also disappear.\r\n\r\nBut totally disabling this feature may affect performance. This feature is same as the `TCP_NODELAY` option in Linux, but Linux keeps this option on by default.\n", "hints_text": "", "created_at": "2024-07-26T01:51:02Z", "version": "0.6"}, {"repo": "asterinas/asterinas", "pull_number": 1073, "instance_id": "asterinas__asterinas-1073", "issue_numbers": ["1069"], "base_commit": "5aa28eae7e14594bbe68827114443b31002bf742", "patch": "diff --git a/osdk/src/base_crate/x86_64.ld.template b/osdk/src/base_crate/x86_64.ld.template\nindex 18539eb1fa..0682ed20d6 100644\n--- a/osdk/src/base_crate/x86_64.ld.template\n+++ b/osdk/src/base_crate/x86_64.ld.template\n@@ -58,6 +58,16 @@ SECTIONS\n     # areas for the application processors.\n     .cpu_local              : AT(ADDR(.cpu_local) - KERNEL_VMA) {\n         __cpu_local_start = .;\n+\n+        # These 4 bytes are used to store the CPU ID.\n+        . += 4;\n+\n+        # These 4 bytes are used to store the number of preemption locks held.\n+        # The reason is stated in the Rust documentation of\n+        # [`ostd::task::processor::PreemptInfo`].\n+        __cpu_local_preempt_lock_count = . - __cpu_local_start;\n+        . += 4;\n+\n         KEEP(*(SORT(.cpu_local)))\n         __cpu_local_end = .;\n     }\ndiff --git a/ostd/src/arch/x86/cpu/local.rs b/ostd/src/arch/x86/cpu/local.rs\nnew file mode 100644\nindex 0000000000..325d692d2e\n--- /dev/null\n+++ b/ostd/src/arch/x86/cpu/local.rs\n@@ -0,0 +1,87 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Architecture dependent CPU-local information utilities.\n+\n+use x86_64::registers::segmentation::{Segment64, FS};\n+\n+/// Sets the base address for the CPU local storage by writing to the FS base model-specific register.\n+/// This operation is marked as `unsafe` because it directly interfaces with low-level CPU registers.\n+///\n+/// # Safety\n+///\n+///  - This function is safe to call provided that the FS register is dedicated entirely for CPU local storage\n+///    and is not concurrently accessed for other purposes.\n+///  - The caller must ensure that `addr` is a valid address and properly aligned, as required by the CPU.\n+///  - This function should only be called in contexts where the CPU is in a state to accept such changes,\n+///    such as during processor initialization.\n+pub(crate) unsafe fn set_base(addr: u64) {\n+    FS::write_base(x86_64::addr::VirtAddr::new(addr));\n+}\n+\n+/// Gets the base address for the CPU local storage by reading the FS base model-specific register.\n+pub(crate) fn get_base() -> u64 {\n+    FS::read_base().as_u64()\n+}\n+\n+pub mod preempt_lock_count {\n+    //! We need to increment/decrement the per-CPU preemption lock count using\n+    //! a single instruction. This requirement is stated by\n+    //! [`crate::task::processor::PreemptInfo`].\n+\n+    /// The GDT ensures that the FS segment is initialized to zero on boot.\n+    /// This assertion checks that the base address has been set.\n+    macro_rules! debug_assert_initialized {\n+        () => {\n+            // The compiler may think that [`super::get_base`] has side effects\n+            // so it may not be optimized out. We make sure that it will be\n+            // conditionally compiled only in debug builds.\n+            #[cfg(debug_assertions)]\n+            debug_assert_ne!(super::get_base(), 0);\n+        };\n+    }\n+\n+    /// Increments the per-CPU preemption lock count using one instruction.\n+    pub(crate) fn inc() {\n+        debug_assert_initialized!();\n+\n+        // SAFETY: The inline assembly increments the lock count in one\n+        // instruction without side effects.\n+        unsafe {\n+            core::arch::asm!(\n+                \"add dword ptr fs:[__cpu_local_preempt_lock_count], 1\",\n+                options(nostack),\n+            );\n+        }\n+    }\n+\n+    /// Decrements the per-CPU preemption lock count using one instruction.\n+    pub(crate) fn dec() {\n+        debug_assert_initialized!();\n+\n+        // SAFETY: The inline assembly decrements the lock count in one\n+        // instruction without side effects.\n+        unsafe {\n+            core::arch::asm!(\n+                \"sub dword ptr fs:[__cpu_local_preempt_lock_count], 1\",\n+                options(nostack),\n+            );\n+        }\n+    }\n+\n+    /// Gets the per-CPU preemption lock count using one instruction.\n+    pub(crate) fn get() -> u32 {\n+        debug_assert_initialized!();\n+\n+        let count: u32;\n+        // SAFETY: The inline assembly reads the lock count in one instruction\n+        // without side effects.\n+        unsafe {\n+            core::arch::asm!(\n+                \"mov {0:e}, fs:[__cpu_local_preempt_lock_count]\",\n+                out(reg) count,\n+                options(nostack, readonly),\n+            );\n+        }\n+        count\n+    }\n+}\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu/mod.rs\nsimilarity index 95%\nrename from ostd/src/arch/x86/cpu.rs\nrename to ostd/src/arch/x86/cpu/mod.rs\nindex 7692d472b1..636fc41613 100644\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu/mod.rs\n@@ -2,6 +2,8 @@\n \n //! CPU.\n \n+pub mod local;\n+\n use alloc::vec::Vec;\n use core::{\n     arch::x86_64::{_fxrstor, _fxsave},\n@@ -18,10 +20,7 @@ use log::debug;\n use tdx_guest::tdcall;\n pub use trapframe::GeneralRegs as RawGeneralRegs;\n use trapframe::UserContext as RawUserContext;\n-use x86_64::registers::{\n-    rflags::RFlags,\n-    segmentation::{Segment64, FS},\n-};\n+use x86_64::registers::rflags::RFlags;\n \n #[cfg(feature = \"intel_tdx\")]\n use crate::arch::tdx_guest::{handle_virtual_exception, TdxTrapFrame};\n@@ -673,22 +672,3 @@ impl Default for FpRegs {\n struct FxsaveArea {\n     data: [u8; 512], // 512 bytes\n }\n-\n-/// Sets the base address for the CPU local storage by writing to the FS base model-specific register.\n-/// This operation is marked as `unsafe` because it directly interfaces with low-level CPU registers.\n-///\n-/// # Safety\n-///\n-///  - This function is safe to call provided that the FS register is dedicated entirely for CPU local storage\n-///    and is not concurrently accessed for other purposes.\n-///  - The caller must ensure that `addr` is a valid address and properly aligned, as required by the CPU.\n-///  - This function should only be called in contexts where the CPU is in a state to accept such changes,\n-///    such as during processor initialization.\n-pub(crate) unsafe fn set_cpu_local_base(addr: u64) {\n-    FS::write_base(x86_64::addr::VirtAddr::new(addr));\n-}\n-\n-/// Gets the base address for the CPU local storage by reading the FS base model-specific register.\n-pub(crate) fn get_cpu_local_base() -> u64 {\n-    FS::read_base().as_u64()\n-}\ndiff --git a/ostd/src/cpu/cpu_local.rs b/ostd/src/cpu/cpu_local.rs\nindex ef3f96c502..71beac6a50 100644\n--- a/ostd/src/cpu/cpu_local.rs\n+++ b/ostd/src/cpu/cpu_local.rs\n@@ -21,7 +21,7 @@\n use core::ops::Deref;\n \n use crate::{\n-    cpu::{get_cpu_local_base, set_cpu_local_base},\n+    arch,\n     trap::{disable_local, DisabledLocalIrqGuard},\n };\n \n@@ -82,6 +82,13 @@ impl<T> !Clone for CpuLocal<T> {}\n // other tasks as they should live on other CPUs to make sending useful.\n impl<T> !Send for CpuLocal<T> {}\n \n+// A check to ensure that the CPU-local object is never accessed before the\n+// initialization for all CPUs.\n+#[cfg(debug_assertions)]\n+use core::sync::atomic::{AtomicBool, Ordering};\n+#[cfg(debug_assertions)]\n+static IS_INITIALIZED: AtomicBool = AtomicBool::new(false);\n+\n impl<T> CpuLocal<T> {\n     /// Initialize a CPU-local object.\n     ///\n@@ -115,6 +122,11 @@ impl<T> CpuLocal<T> {\n     /// This function calculates the virtual address of the CPU-local object based on the per-\n     /// cpu base address and the offset in the BSP.\n     fn get(&self) -> *const T {\n+        // CPU-local objects should be initialized before being accessed. It should be ensured\n+        // by the implementation of OSTD initialization.\n+        #[cfg(debug_assertions)]\n+        debug_assert!(IS_INITIALIZED.load(Ordering::Relaxed));\n+\n         let offset = {\n             let bsp_va = self as *const _ as usize;\n             let bsp_base = __cpu_local_start as usize;\n@@ -124,7 +136,7 @@ impl<T> CpuLocal<T> {\n             bsp_va - bsp_base as usize\n         };\n \n-        let local_base = get_cpu_local_base() as usize;\n+        let local_base = arch::cpu::local::get_base() as usize;\n         let local_va = local_base + offset;\n \n         // A sanity check about the alignment.\n@@ -170,6 +182,24 @@ impl<T> Deref for CpuLocalDerefGuard<'_, T> {\n     }\n }\n \n+/// Sets the base address of the CPU-local storage for the bootstrap processor.\n+///\n+/// It should be called early to let [`crate::task::disable_preempt`] work,\n+/// which needs to update a CPU-local preempt lock count. Otherwise it may\n+/// panic when calling [`crate::task::disable_preempt`].\n+///\n+/// # Safety\n+///\n+/// It should be called only once and only on the BSP.\n+pub(crate) unsafe fn early_init_bsp_local_base() {\n+    let start_base_va = __cpu_local_start as usize as u64;\n+    // SAFETY: The base to be set is the start of the `.cpu_local` section,\n+    // where accessing the CPU-local objects have defined behaviors.\n+    unsafe {\n+        arch::cpu::local::set_base(start_base_va);\n+    }\n+}\n+\n /// Initializes the CPU local data for the bootstrap processor (BSP).\n ///\n /// # Safety\n@@ -179,9 +209,14 @@ impl<T> Deref for CpuLocalDerefGuard<'_, T> {\n /// It must be guaranteed that the BSP will not access local data before\n /// this function being called, otherwise copying non-constant values\n /// will result in pretty bad undefined behavior.\n-pub unsafe fn init_on_bsp() {\n-    let start_base_va = __cpu_local_start as usize as u64;\n-    set_cpu_local_base(start_base_va);\n+pub(crate) unsafe fn init_on_bsp() {\n+    // TODO: allocate the pages for application processors and copy the\n+    // CPU-local objects to the allocated pages.\n+\n+    #[cfg(debug_assertions)]\n+    {\n+        IS_INITIALIZED.store(true, Ordering::Relaxed);\n+    }\n }\n \n // These symbols are provided by the linker script.\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\nindex abc7e57733..83a9e42d68 100644\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -59,6 +59,9 @@ pub use self::{cpu::cpu_local::CpuLocal, error::Error, prelude::Result};\n pub fn init() {\n     arch::before_all_init();\n \n+    // SAFETY: This function is called only once and only on the BSP.\n+    unsafe { cpu::cpu_local::early_init_bsp_local_base() };\n+\n     mm::heap_allocator::init();\n \n     boot::init();\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\nindex d3dcd60d69..a4bdc385bb 100644\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -340,8 +340,10 @@ impl<'a> VmReader<'a, KernelSpace> {\n     /// it should _not_ overlap with other `VmWriter`s.\n     /// The user space memory is treated as untyped.\n     pub unsafe fn from_kernel_space(ptr: *const u8, len: usize) -> Self {\n-        debug_assert!(KERNEL_BASE_VADDR <= ptr as usize);\n-        debug_assert!(ptr.add(len) as usize <= KERNEL_END_VADDR);\n+        // If casting a zero sized slice to a pointer, the pointer may be null\n+        // and does not reside in our kernel space range.\n+        debug_assert!(len == 0 || KERNEL_BASE_VADDR <= ptr as usize);\n+        debug_assert!(len == 0 || ptr.add(len) as usize <= KERNEL_END_VADDR);\n \n         Self {\n             cursor: ptr,\n@@ -516,8 +518,10 @@ impl<'a> VmWriter<'a, KernelSpace> {\n     /// is typed, it should _not_ overlap with other `VmReader`s and `VmWriter`s.\n     /// The user space memory is treated as untyped.\n     pub unsafe fn from_kernel_space(ptr: *mut u8, len: usize) -> Self {\n-        debug_assert!(KERNEL_BASE_VADDR <= ptr as usize);\n-        debug_assert!(ptr.add(len) as usize <= KERNEL_END_VADDR);\n+        // If casting a zero sized slice to a pointer, the pointer may be null\n+        // and does not reside in our kernel space range.\n+        debug_assert!(len == 0 || KERNEL_BASE_VADDR <= ptr as usize);\n+        debug_assert!(len == 0 || ptr.add(len) as usize <= KERNEL_END_VADDR);\n \n         Self {\n             cursor: ptr,\ndiff --git a/ostd/src/task/processor.rs b/ostd/src/task/processor.rs\nindex c6dfb9932c..71acd5ffcb 100644\n--- a/ostd/src/task/processor.rs\n+++ b/ostd/src/task/processor.rs\n@@ -1,17 +1,14 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use alloc::sync::Arc;\n-use core::{\n-    cell::RefCell,\n-    sync::atomic::{AtomicUsize, Ordering::Relaxed},\n-};\n+use core::cell::RefCell;\n \n use super::{\n     scheduler::{fetch_task, GLOBAL_SCHEDULER},\n     task::{context_switch, TaskContext},\n     Task, TaskStatus,\n };\n-use crate::cpu_local;\n+use crate::{arch, cpu_local};\n \n pub struct Processor {\n     current: Option<Arc<Task>>,\n@@ -154,38 +151,50 @@ fn switch_to_task(next_task: Arc<Task>) {\n     // to the next task switching.\n }\n \n-cpu_local! {\n-    static PREEMPT_COUNT: PreemptInfo = PreemptInfo::new();\n-}\n+static PREEMPT_COUNT: PreemptInfo = PreemptInfo::new();\n \n-/// Currently, ``PreemptInfo`` only holds the number of spin\n-/// locks held by the current CPU. When it has a non-zero value,\n-/// the CPU cannot call ``schedule()``.\n-struct PreemptInfo {\n-    num_locks: AtomicUsize,\n-}\n+/// Currently, it only holds the number of preemption locks held by the\n+/// current CPU. When it has a non-zero value, the CPU cannot call\n+/// [`schedule()`].\n+///\n+/// For per-CPU preemption lock count, we cannot afford two non-atomic\n+/// operations to increment and decrement the count. The [`crate::cpu_local`]\n+/// implementation is free to read the base register and then calculate the\n+/// address of the per-CPU variable using an additional instruction. Interrupts\n+/// can happen between the address calculation and modification to that\n+/// address. If the task is preempted to another CPU by this interrupt, the\n+/// count of the original CPU will be mistakenly modified. To avoid this, we\n+/// introduce [`crate::arch::cpu::local::preempt_lock_count`]. For x86_64 we\n+/// can implement this using one instruction. In other less expressive\n+/// architectures, we may need to disable interrupts.\n+///\n+/// Also, the preemption count is reserved in the `.cpu_local` section\n+/// specified in the linker script. The reason is that we need to access the\n+/// preemption count before we can copy the section for application processors.\n+/// So, the preemption count is not copied from bootstrap processor's section\n+/// as the initialization. Instead it is initialized to zero for application\n+/// processors.\n+struct PreemptInfo {}\n \n impl PreemptInfo {\n     const fn new() -> Self {\n-        Self {\n-            num_locks: AtomicUsize::new(0),\n-        }\n+        Self {}\n     }\n \n     fn increase_num_locks(&self) {\n-        self.num_locks.fetch_add(1, Relaxed);\n+        arch::cpu::local::preempt_lock_count::inc();\n     }\n \n     fn decrease_num_locks(&self) {\n-        self.num_locks.fetch_sub(1, Relaxed);\n+        arch::cpu::local::preempt_lock_count::dec();\n     }\n \n     fn is_preemptive(&self) -> bool {\n-        self.num_locks.load(Relaxed) == 0\n+        arch::cpu::local::preempt_lock_count::get() == 0\n     }\n \n     fn num_locks(&self) -> usize {\n-        self.num_locks.load(Relaxed)\n+        arch::cpu::local::preempt_lock_count::get() as usize\n     }\n }\n \n", "test_patch": "diff --git a/.github/workflows/test_asterinas.yml b/.github/workflows/test_asterinas.yml\nindex 4147c50999..5fb1678a85 100644\n--- a/.github/workflows/test_asterinas.yml\n+++ b/.github/workflows/test_asterinas.yml\n@@ -60,36 +60,24 @@ jobs:\n         id: boot_test_mb\n         run: make run AUTO_TEST=boot ENABLE_KVM=1 BOOT_PROTOCOL=multiboot RELEASE=1\n \n-      - name: Boot Test (Multiboot2)\n-        id: boot_test_mb2\n-        run: make run AUTO_TEST=boot ENABLE_KVM=1 BOOT_PROTOCOL=multiboot2 RELEASE=1\n-\n-      - name: Boot Test (MicroVM)\n-        id: boot_test_microvm\n-        run: make run AUTO_TEST=boot ENABLE_KVM=1 SCHEME=microvm RELEASE=1\n-\n       - name: Boot Test (Linux Legacy 32-bit Boot Protocol)\n         id: boot_test_linux_legacy32\n         run: make run AUTO_TEST=boot ENABLE_KVM=1 BOOT_PROTOCOL=linux-legacy32 RELEASE=1\n \n-      - name: Boot Test (Linux EFI Handover Boot Protocol)\n-        id: boot_test_linux_efi_handover64\n-        run: make run AUTO_TEST=boot ENABLE_KVM=1 BOOT_PROTOCOL=linux-efi-handover64 RELEASE=1\n-\n-      - name: Syscall Test (Linux EFI Handover Boot Protocol)\n+      - name: Syscall Test (Linux EFI Handover Boot Protocol) (Debug Build)\n         id: syscall_test\n-        run: make run AUTO_TEST=syscall ENABLE_KVM=1 BOOT_PROTOCOL=linux-efi-handover64 RELEASE=1\n+        run: make run AUTO_TEST=syscall ENABLE_KVM=1 BOOT_PROTOCOL=linux-efi-handover64 RELEASE=0\n \n       - name: Syscall Test at Ext2 (MicroVM)\n         id: syscall_test_at_ext2\n         run: make run AUTO_TEST=syscall SYSCALL_TEST_DIR=/ext2 ENABLE_KVM=1 SCHEME=microvm RELEASE=1\n \n-      - name: Syscall Test at Exfat and without KVM enabled\n+      - name: Syscall Test at Exfat (Multiboot2) (without KVM enabled)\n         id: syscall_test_at_exfat_linux\n         run: |\n           make run AUTO_TEST=syscall \\\n             SYSCALL_TEST_DIR=/exfat EXTRA_BLOCKLISTS_DIRS=blocklists.exfat \\\n-            ENABLE_KVM=0 BOOT_PROTOCOL=linux-efi-handover64 RELEASE=1\n+            ENABLE_KVM=0 BOOT_PROTOCOL=multiboot2 RELEASE=1\n \n       - name: General Test (Linux EFI Handover Boot Protocol)\n         id: test_linux\n", "problem_statement": "CPU local memory is used before initialized\nThe use (in `ostd`):\r\n`init` \u2192 `mm::heap_allocator::init` \u2192 `HEAP_ALLOCATOR.init` \u2192 `SpinLock::lock_irq_disabled` \u2192 `trap::irq::disable_local` \u2192 `task::processor::disable_preempt` \u2192 `PREEMPT_COUNT.increase_num_locks`, where `PREEMPT_COUNT` is a cpu-local variable.\r\n\r\nThe initialization:\r\n`init` \u2192 `cpu::cpu_local::init_on_bsp` \u2192 ...\r\n\r\nThe use is before the initialization since `mm::heap_allocator::init` is called prior to `cpu::cpu_local::init_on_bsp`.\r\nhttps://github.com/asterinas/asterinas/blob/94eba6d85eb9e62ddd904c1132d556b808cc3174/ostd/src/lib.rs#L51-L82\r\n\r\n---\r\n\r\nIt does not fault in x86 because `fsbase` is by default `0`, and the OS has write access to the memory near `0x0`, so the error is silent. But in RISC-V, this memory region is not writable, so it faults.\r\n\r\nAnd I guess this is not the only case since `SpinLock` is widely used in `ostd`, it might be other uses of `SpinLock` before CPU local memory is initialized, for example, `mm::kspace::init_boot_page_table` \u2192 `BOOT_PAGE_TABLE.lock`.\n", "hints_text": "Modifying `ostd::arch::x86::cpu::get_cpu_local_base` to\r\n``` rust\r\n/// Gets the base address for the CPU local storage by reading the FS base model-specific register.\r\npub(crate) fn get_cpu_local_base() -> u64 {\r\n    let fsbase = FS::read_base().as_u64();\r\n    debug_assert_ne!(fsbase, 0, \"CPU local memory is used before initialized\");\r\n    fsbase\r\n}\r\n```\r\nmay help with discovering cpu local used before initialization bugs.\n> And I guess this is not the only case since SpinLock is widely used in ostd, it might be other uses of SpinLock before CPU local memory is initialized, for example, mm::kspace::init_boot_page_table \u2192 BOOT_PAGE_TABLE.lock.\r\n\r\nIndeed. CPU local variables should not be accessed before initialization of `mod cpu_local`. I will look into it.", "created_at": "2024-07-19T13:26:35Z", "version": "0.6"}, {"repo": "asterinas/asterinas", "pull_number": 1026, "instance_id": "asterinas__asterinas-1026", "issue_numbers": ["681"], "base_commit": "94eba6d85eb9e62ddd904c1132d556b808cc3174", "patch": "diff --git a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\nindex 6119c96d60..bdec0e5b95 100644\n--- a/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n+++ b/kernel/aster-nix/src/vm/vmar/vm_mapping.rs\n@@ -5,7 +5,9 @@\n \n use core::ops::Range;\n \n-use ostd::mm::{Frame, FrameVec, PageFlags, VmIo, VmMapOptions, VmSpace};\n+use ostd::mm::{\n+    vm_space::VmQueryResult, CachePolicy, Frame, PageFlags, PageProperty, VmIo, VmSpace,\n+};\n \n use super::{interval::Interval, is_intersected, Vmar, Vmar_};\n use crate::{\n@@ -194,22 +196,41 @@ impl VmMapping {\n         let write_perms = VmPerms::WRITE;\n         self.check_perms(&write_perms)?;\n \n-        let mut page_addr =\n-            self.map_to_addr() - self.vmo_offset() + page_idx_range.start * PAGE_SIZE;\n-        for page_idx in page_idx_range {\n-            let parent = self.parent.upgrade().unwrap();\n-            let vm_space = parent.vm_space();\n-\n-            // The `VmMapping` has the write permission but the corresponding PTE is present and is read-only.\n-            // This means this PTE is set to read-only due to the COW mechanism. In this situation we need to trigger a\n-            // page fault before writing at the VMO to guarantee the consistency between VMO and the page table.\n-            let need_page_fault = vm_space\n-                .query(page_addr)?\n-                .is_some_and(|prop| !prop.flags.contains(PageFlags::W));\n-            if need_page_fault {\n-                self.handle_page_fault(page_addr, false, true)?;\n+        // We need to make sure the mapping exists.\n+        //\n+        // Also, if the `VmMapping` has the write permission but the corresponding\n+        // PTE is present and is read-only, it would be a copy-on-write page. In\n+        // this situation we need to trigger a page fault before writing at the\n+        // VMO to guarantee the consistency between VMO and the page table.\n+        {\n+            let virt_addr =\n+                self.map_to_addr() - self.vmo_offset() + page_idx_range.start * PAGE_SIZE;\n+            let virt_range = virt_addr..virt_addr + page_idx_range.len() * PAGE_SIZE;\n+\n+            // FIXME: any sane developer would recommend using `parent.vm_space().cursor(&virt_range)`\n+            // to lock the range and check the mapping status. However, this will cause a deadlock because\n+            // `Self::handle_page_fault` would like to create a cursor again. The following implementation\n+            // indeed introduces a TOCTOU bug.\n+            for page_va in virt_range.step_by(PAGE_SIZE) {\n+                let parent = self.parent.upgrade().unwrap();\n+                let mut cursor = parent\n+                    .vm_space()\n+                    .cursor(&(page_va..page_va + PAGE_SIZE))\n+                    .unwrap();\n+                let map_info = cursor.query().unwrap();\n+                drop(cursor);\n+\n+                match map_info {\n+                    VmQueryResult::Mapped { va, prop, .. } => {\n+                        if !prop.flags.contains(PageFlags::W) {\n+                            self.handle_page_fault(va, false, true)?;\n+                        }\n+                    }\n+                    VmQueryResult::NotMapped { va, .. } => {\n+                        self.handle_page_fault(va, true, true)?;\n+                    }\n+                }\n             }\n-            page_addr += PAGE_SIZE;\n         }\n \n         self.vmo.write_bytes(vmo_write_offset, buf)?;\n@@ -458,7 +479,8 @@ impl VmMappingInner {\n         frame: Frame,\n         is_readonly: bool,\n     ) -> Result<()> {\n-        let map_addr = self.page_map_addr(page_idx);\n+        let map_va = self.page_map_addr(page_idx);\n+        let map_va = map_va..map_va + PAGE_SIZE;\n \n         let vm_perms = {\n             let mut perms = self.perms;\n@@ -468,23 +490,11 @@ impl VmMappingInner {\n             }\n             perms\n         };\n+        let map_prop = PageProperty::new(vm_perms.into(), CachePolicy::Writeback);\n \n-        let vm_map_options = {\n-            let mut options = VmMapOptions::new();\n-            options.addr(Some(map_addr));\n-            options.flags(vm_perms.into());\n-\n-            // After `fork()`, the entire memory space of the parent and child processes is\n-            // protected as read-only. Therefore, whether the pages need to be COWed (if the memory\n-            // region is private) or not (if the memory region is shared), it is necessary to\n-            // overwrite the page table entry to make the page writable again when the parent or\n-            // child process first tries to write to the memory region.\n-            options.can_overwrite(true);\n-\n-            options\n-        };\n+        let mut cursor = vm_space.cursor_mut(&map_va).unwrap();\n+        cursor.map(frame, map_prop);\n \n-        vm_space.map(FrameVec::from_one_frame(frame), &vm_map_options)?;\n         self.mapped_pages.insert(page_idx);\n         Ok(())\n     }\n@@ -492,9 +502,10 @@ impl VmMappingInner {\n     fn unmap_one_page(&mut self, vm_space: &VmSpace, page_idx: usize) -> Result<()> {\n         let map_addr = self.page_map_addr(page_idx);\n         let range = map_addr..(map_addr + PAGE_SIZE);\n-        if vm_space.query(map_addr)?.is_some() {\n-            vm_space.unmap(&range)?;\n-        }\n+\n+        let mut cursor = vm_space.cursor_mut(&range).unwrap();\n+        cursor.unmap(PAGE_SIZE);\n+\n         self.mapped_pages.remove(&page_idx);\n         Ok(())\n     }\n@@ -528,17 +539,8 @@ impl VmMappingInner {\n     ) -> Result<()> {\n         debug_assert!(range.start % PAGE_SIZE == 0);\n         debug_assert!(range.end % PAGE_SIZE == 0);\n-        let start_page = (range.start - self.map_to_addr + self.vmo_offset) / PAGE_SIZE;\n-        let end_page = (range.end - self.map_to_addr + self.vmo_offset) / PAGE_SIZE;\n-        let flags: PageFlags = perms.into();\n-        for page_idx in start_page..end_page {\n-            let page_addr = self.page_map_addr(page_idx);\n-            if vm_space.query(page_addr)?.is_some() {\n-                // If the page is already mapped, we will modify page table\n-                let page_range = page_addr..(page_addr + PAGE_SIZE);\n-                vm_space.protect(&page_range, |p| p.flags = flags)?;\n-            }\n-        }\n+        let mut cursor = vm_space.cursor_mut(&range).unwrap();\n+        cursor.protect(range.len(), |p| p.flags = perms.into(), true)?;\n         Ok(())\n     }\n \ndiff --git a/ostd/src/mm/frame/frame_vec.rs b/ostd/src/mm/frame/frame_vec.rs\ndeleted file mode 100644\nindex e37e84e56e..0000000000\n--- a/ostd/src/mm/frame/frame_vec.rs\n+++ /dev/null\n@@ -1,172 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-//! Page frames.\n-\n-use alloc::{vec, vec::Vec};\n-\n-use crate::{\n-    mm::{Frame, VmIo, VmReader, VmWriter, PAGE_SIZE},\n-    Error, Result,\n-};\n-\n-/// A collection of base page frames (regular physical memory pages).\n-///\n-/// For the most parts, `FrameVec` is like `Vec<Frame>`. But the\n-/// implementation may or may not be based on [`Vec`]. Having a dedicated\n-/// type to represent a series of page frames is convenient because,\n-/// more often than not, one needs to operate on a batch of frames rather\n-/// a single frame.\n-#[derive(Debug, Clone)]\n-pub struct FrameVec(pub(crate) Vec<Frame>);\n-\n-impl FrameVec {\n-    /// Retrieves a reference to a [`Frame`] at the specified index.\n-    pub fn get(&self, index: usize) -> Option<&Frame> {\n-        self.0.get(index)\n-    }\n-\n-    /// Creates an empty `FrameVec`.\n-    pub fn empty() -> Self {\n-        Self(Vec::new())\n-    }\n-\n-    /// Creates a new `FrameVec` with the specified capacity.\n-    pub fn new_with_capacity(capacity: usize) -> Self {\n-        Self(Vec::with_capacity(capacity))\n-    }\n-\n-    /// Pushes a new frame to the collection.\n-    pub fn push(&mut self, new_frame: Frame) {\n-        self.0.push(new_frame);\n-    }\n-\n-    /// Pops a frame from the collection.\n-    pub fn pop(&mut self) -> Option<Frame> {\n-        self.0.pop()\n-    }\n-\n-    /// Removes a frame at a position.\n-    pub fn remove(&mut self, at: usize) -> Frame {\n-        self.0.remove(at)\n-    }\n-\n-    /// Appends all the [`Frame`]s from `more` to the end of this collection.\n-    /// and clears the frames in `more`.\n-    pub fn append(&mut self, more: &mut FrameVec) -> Result<()> {\n-        self.0.append(&mut more.0);\n-        Ok(())\n-    }\n-\n-    /// Truncates the `FrameVec` to the specified length.\n-    ///\n-    /// If `new_len >= self.len()`, then this method has no effect.\n-    pub fn truncate(&mut self, new_len: usize) {\n-        if new_len >= self.0.len() {\n-            return;\n-        }\n-        self.0.truncate(new_len)\n-    }\n-\n-    /// Returns an iterator over all frames.\n-    pub fn iter(&self) -> core::slice::Iter<'_, Frame> {\n-        self.0.iter()\n-    }\n-\n-    /// Returns the number of frames.\n-    pub fn len(&self) -> usize {\n-        self.0.len()\n-    }\n-\n-    /// Returns whether the frame collection is empty.\n-    pub fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n-    }\n-\n-    /// Returns the number of bytes.\n-    ///\n-    /// This method is equivalent to `self.len() * BASE_PAGE_SIZE`.\n-    pub fn nbytes(&self) -> usize {\n-        self.0.len() * PAGE_SIZE\n-    }\n-\n-    /// Creates a new `FrameVec` from a single [`Frame`].\n-    pub fn from_one_frame(frame: Frame) -> Self {\n-        Self(vec![frame])\n-    }\n-}\n-\n-impl IntoIterator for FrameVec {\n-    type Item = Frame;\n-\n-    type IntoIter = alloc::vec::IntoIter<Self::Item>;\n-\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.0.into_iter()\n-    }\n-}\n-\n-impl VmIo for FrameVec {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> Result<()> {\n-        // Do bound check with potential integer overflow in mind\n-        let max_offset = offset.checked_add(buf.len()).ok_or(Error::Overflow)?;\n-        if max_offset > self.nbytes() {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let num_unread_pages = offset / PAGE_SIZE;\n-        let mut start = offset % PAGE_SIZE;\n-        let mut buf_writer: VmWriter = buf.into();\n-        for frame in self.0.iter().skip(num_unread_pages) {\n-            let read_len = frame.reader().skip(start).read(&mut buf_writer);\n-            if read_len == 0 {\n-                break;\n-            }\n-            start = 0;\n-        }\n-        Ok(())\n-    }\n-\n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> Result<()> {\n-        // Do bound check with potential integer overflow in mind\n-        let max_offset = offset.checked_add(buf.len()).ok_or(Error::Overflow)?;\n-        if max_offset > self.nbytes() {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let num_unwrite_pages = offset / PAGE_SIZE;\n-        let mut start = offset % PAGE_SIZE;\n-        let mut buf_reader: VmReader = buf.into();\n-        for frame in self.0.iter().skip(num_unwrite_pages) {\n-            let write_len = frame.writer().skip(start).write(&mut buf_reader);\n-            if write_len == 0 {\n-                break;\n-            }\n-            start = 0;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// An iterator for frames.\n-pub struct FrameVecIter<'a> {\n-    frames: &'a FrameVec,\n-    current: usize,\n-}\n-\n-impl<'a> FrameVecIter<'a> {\n-    /// Creates a new `FrameVecIter` from the given [`FrameVec`].\n-    pub fn new(frames: &'a FrameVec) -> Self {\n-        Self { frames, current: 0 }\n-    }\n-}\n-\n-impl<'a> Iterator for FrameVecIter<'a> {\n-    type Item = &'a Frame;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.current >= self.frames.0.len() {\n-            return None;\n-        }\n-        Some(self.frames.0.get(self.current).unwrap())\n-    }\n-}\ndiff --git a/ostd/src/mm/frame/mod.rs b/ostd/src/mm/frame/mod.rs\nindex 62a035288f..6a880af26b 100644\n--- a/ostd/src/mm/frame/mod.rs\n+++ b/ostd/src/mm/frame/mod.rs\n@@ -8,13 +8,11 @@\n //! frames. Frames, with all the properties of pages, can additionally be safely\n //! read and written by the kernel or the user.\n \n-pub mod frame_vec;\n pub mod options;\n pub mod segment;\n \n use core::mem::ManuallyDrop;\n \n-pub use frame_vec::{FrameVec, FrameVecIter};\n pub use segment::Segment;\n \n use super::page::{\n@@ -155,6 +153,48 @@ impl VmIo for Frame {\n     }\n }\n \n+impl VmIo for alloc::vec::Vec<Frame> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> Result<()> {\n+        // Do bound check with potential integer overflow in mind\n+        let max_offset = offset.checked_add(buf.len()).ok_or(Error::Overflow)?;\n+        if max_offset > self.len() * PAGE_SIZE {\n+            return Err(Error::InvalidArgs);\n+        }\n+\n+        let num_skip_pages = offset / PAGE_SIZE;\n+        let mut start = offset % PAGE_SIZE;\n+        let mut buf_writer: VmWriter = buf.into();\n+        for frame in self.iter().skip(num_skip_pages) {\n+            let read_len = frame.reader().skip(start).read(&mut buf_writer);\n+            if read_len == 0 {\n+                break;\n+            }\n+            start = 0;\n+        }\n+        Ok(())\n+    }\n+\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> Result<()> {\n+        // Do bound check with potential integer overflow in mind\n+        let max_offset = offset.checked_add(buf.len()).ok_or(Error::Overflow)?;\n+        if max_offset > self.len() * PAGE_SIZE {\n+            return Err(Error::InvalidArgs);\n+        }\n+\n+        let num_skip_pages = offset / PAGE_SIZE;\n+        let mut start = offset % PAGE_SIZE;\n+        let mut buf_reader: VmReader = buf.into();\n+        for frame in self.iter().skip(num_skip_pages) {\n+            let write_len = frame.writer().skip(start).write(&mut buf_reader);\n+            if write_len == 0 {\n+                break;\n+            }\n+            start = 0;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl PageMeta for FrameMeta {\n     const USAGE: PageUsage = PageUsage::Frame;\n \ndiff --git a/ostd/src/mm/frame/options.rs b/ostd/src/mm/frame/options.rs\nindex a5006a6bac..4bd3f627b9 100644\n--- a/ostd/src/mm/frame/options.rs\n+++ b/ostd/src/mm/frame/options.rs\n@@ -2,7 +2,7 @@\n \n //! Options for allocating frames\n \n-use super::{Frame, FrameVec, Segment};\n+use super::{Frame, Segment};\n use crate::{\n     mm::{\n         page::{self, meta::FrameMeta},\n@@ -55,7 +55,7 @@ impl FrameAllocOptions {\n     }\n \n     /// Allocates a collection of page frames according to the given options.\n-    pub fn alloc(&self) -> Result<FrameVec> {\n+    pub fn alloc(&self) -> Result<Vec<Frame>> {\n         let pages = if self.is_contiguous {\n             page::allocator::alloc(self.nframes * PAGE_SIZE).ok_or(Error::NoMemory)?\n         } else {\n@@ -63,7 +63,7 @@ impl FrameAllocOptions {\n                 .ok_or(Error::NoMemory)?\n                 .into()\n         };\n-        let frames = FrameVec(pages.into_iter().map(|page| Frame { page }).collect());\n+        let frames: Vec<_> = pages.into_iter().map(|page| Frame { page }).collect();\n         if !self.uninit {\n             for frame in frames.iter() {\n                 frame.writer().fill(0);\ndiff --git a/ostd/src/mm/frame/segment.rs b/ostd/src/mm/frame/segment.rs\nindex aeab21d261..d93adc33e3 100644\n--- a/ostd/src/mm/frame/segment.rs\n+++ b/ostd/src/mm/frame/segment.rs\n@@ -16,15 +16,10 @@ use crate::{\n \n /// A handle to a contiguous range of page frames (physical memory pages).\n ///\n-/// The biggest difference between `Segment` and [`FrameVec`] is that\n-/// the page frames must be contiguous for `Segment`.\n-///\n /// A cloned `Segment` refers to the same page frames as the original.\n /// As the original and cloned instances point to the same physical address,  \n /// they are treated as equal to each other.\n ///\n-/// [`FrameVec`]: crate::mm::FrameVec\n-///\n /// #Example\n ///\n /// ```rust\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\nindex e923f5d027..d3dcd60d69 100644\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -18,7 +18,7 @@ use crate::{\n };\n \n /// A trait that enables reading/writing data from/to a VM object,\n-/// e.g., [`VmSpace`], [`FrameVec`], and [`Frame`].\n+/// e.g., [`Segment`], [`Vec<Frame>`] and [`Frame`].\n ///\n /// # Concurrency\n ///\n@@ -27,8 +27,7 @@ use crate::{\n /// desire predictability or atomicity, the users should add extra mechanism\n /// for such properties.\n ///\n-/// [`VmSpace`]: crate::mm::VmSpace\n-/// [`FrameVec`]: crate::mm::FrameVec\n+/// [`Segment`]: crate::mm::Segment\n /// [`Frame`]: crate::mm::Frame\n pub trait VmIo: Send + Sync {\n     /// Reads a specified number of bytes at a specified offset into a given buffer.\ndiff --git a/ostd/src/mm/mod.rs b/ostd/src/mm/mod.rs\nindex ab7f995a04..3d6485ae15 100644\n--- a/ostd/src/mm/mod.rs\n+++ b/ostd/src/mm/mod.rs\n@@ -17,7 +17,7 @@ mod offset;\n pub(crate) mod page;\n pub(crate) mod page_prop;\n pub(crate) mod page_table;\n-mod space;\n+pub mod vm_space;\n \n use alloc::vec::Vec;\n use core::{fmt::Debug, ops::Range};\n@@ -26,10 +26,10 @@ use spin::Once;\n \n pub use self::{\n     dma::{Daddr, DmaCoherent, DmaDirection, DmaStream, DmaStreamSlice, HasDaddr},\n-    frame::{options::FrameAllocOptions, Frame, FrameVec, FrameVecIter, Segment},\n+    frame::{options::FrameAllocOptions, Frame, Segment},\n     io::{KernelSpace, UserSpace, VmIo, VmReader, VmWriter},\n     page_prop::{CachePolicy, PageFlags, PageProperty},\n-    space::{VmMapOptions, VmSpace},\n+    vm_space::VmSpace,\n };\n pub(crate) use self::{\n     kspace::paddr_to_vaddr, page::meta::init as init_page_meta, page_prop::PrivilegedPageFlags,\ndiff --git a/ostd/src/mm/page_table/cursor.rs b/ostd/src/mm/page_table/cursor.rs\nindex d24df70738..a5b2338003 100644\n--- a/ostd/src/mm/page_table/cursor.rs\n+++ b/ostd/src/mm/page_table/cursor.rs\n@@ -76,7 +76,7 @@ use super::{\n use crate::mm::{page::DynPage, Paddr, PageProperty, Vaddr};\n \n #[derive(Clone, Debug)]\n-pub(crate) enum PageTableQueryResult {\n+pub enum PageTableQueryResult {\n     NotMapped {\n         va: Vaddr,\n         len: usize,\n@@ -105,7 +105,7 @@ pub(crate) enum PageTableQueryResult {\n /// simulate the recursion, and adpot a page table locking protocol to\n /// provide concurrency.\n #[derive(Debug)]\n-pub(crate) struct Cursor<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait>\n+pub struct Cursor<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait>\n where\n     [(); C::NR_LEVELS as usize]:,\n {\n@@ -140,10 +140,7 @@ where\n     ///\n     /// Note that this function does not ensure exclusive access to the claimed\n     /// virtual address range. The accesses using this cursor may block or fail.\n-    pub(crate) fn new(\n-        pt: &'a PageTable<M, E, C>,\n-        va: &Range<Vaddr>,\n-    ) -> Result<Self, PageTableError> {\n+    pub fn new(pt: &'a PageTable<M, E, C>, va: &Range<Vaddr>) -> Result<Self, PageTableError> {\n         if !M::covers(va) {\n             return Err(PageTableError::InvalidVaddrRange(va.start, va.end));\n         }\n@@ -198,9 +195,9 @@ where\n     }\n \n     /// Gets the information of the current slot.\n-    pub(crate) fn query(&mut self) -> Option<PageTableQueryResult> {\n+    pub fn query(&mut self) -> Result<PageTableQueryResult, PageTableError> {\n         if self.va >= self.barrier_va.end {\n-            return None;\n+            return Err(PageTableError::InvalidVaddr(self.va));\n         }\n \n         loop {\n@@ -209,7 +206,7 @@ where\n \n             let pte = self.read_cur_pte();\n             if !pte.is_present() {\n-                return Some(PageTableQueryResult::NotMapped {\n+                return Ok(PageTableQueryResult::NotMapped {\n                     va,\n                     len: page_size::<C>(level),\n                 });\n@@ -221,14 +218,14 @@ where\n \n             match self.cur_child() {\n                 Child::Page(page) => {\n-                    return Some(PageTableQueryResult::Mapped {\n+                    return Ok(PageTableQueryResult::Mapped {\n                         va,\n                         page,\n                         prop: pte.prop(),\n                     });\n                 }\n                 Child::Untracked(pa) => {\n-                    return Some(PageTableQueryResult::MappedUntracked {\n+                    return Ok(PageTableQueryResult::MappedUntracked {\n                         va,\n                         pa,\n                         len: page_size::<C>(level),\n@@ -246,7 +243,7 @@ where\n     ///\n     /// If reached the end of a page table node, it leads itself up to the next page of the parent\n     /// page if possible.\n-    fn move_forward(&mut self) {\n+    pub(in crate::mm) fn move_forward(&mut self) {\n         let page_size = page_size::<C>(self.level);\n         let next_va = self.va.align_down(page_size) + page_size;\n         while self.level < self.guard_level && pte_index::<C>(next_va, self.level) == 0 {\n@@ -255,6 +252,41 @@ where\n         self.va = next_va;\n     }\n \n+    /// Jumps to the given virtual address.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method panics if the address is out of the range where the cursor is required to operate,\n+    /// or has bad alignment.\n+    pub fn jump(&mut self, va: Vaddr) {\n+        assert!(self.barrier_va.contains(&va));\n+        assert!(va % C::BASE_PAGE_SIZE == 0);\n+\n+        loop {\n+            let cur_node_start = self.va & !(page_size::<C>(self.level + 1) - 1);\n+            let cur_node_end = cur_node_start + page_size::<C>(self.level + 1);\n+            // If the address is within the current node, we can jump directly.\n+            if cur_node_start <= va && va < cur_node_end {\n+                self.va = va;\n+                return;\n+            }\n+\n+            // There is a corner case that the cursor is depleted, sitting at the start of the\n+            // next node but the next node is not locked because the parent is not locked.\n+            if self.va >= self.barrier_va.end && self.level == self.guard_level {\n+                self.va = va;\n+                return;\n+            }\n+\n+            debug_assert!(self.level < self.guard_level);\n+            self.level_up();\n+        }\n+    }\n+\n+    pub fn virt_addr(&self) -> Vaddr {\n+        self.va\n+    }\n+\n     /// Goes up a level. We release the current page if it has no mappings since the cursor only moves\n     /// forward. And if needed we will do the final cleanup using this method after re-walk when the\n     /// cursor is dropped.\n@@ -327,10 +359,10 @@ where\n \n     fn next(&mut self) -> Option<Self::Item> {\n         let result = self.query();\n-        if result.is_some() {\n+        if result.is_ok() {\n             self.move_forward();\n         }\n-        result\n+        result.ok()\n     }\n }\n \n@@ -339,7 +371,7 @@ where\n /// Also, it has all the capabilities of a [`Cursor`]. A virtual address range\n /// in a page table can only be accessed by one cursor whether it is mutable or not.\n #[derive(Debug)]\n-pub(crate) struct CursorMut<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait>(\n+pub struct CursorMut<'a, M: PageTableMode, E: PageTableEntryTrait, C: PagingConstsTrait>(\n     Cursor<'a, M, E, C>,\n )\n where\n@@ -365,43 +397,26 @@ where\n         Cursor::new(pt, va).map(|inner| Self(inner))\n     }\n \n-    /// Gets the information of the current slot and go to the next slot.\n-    ///\n-    /// We choose not to implement `Iterator` or `IterMut` for [`CursorMut`]\n-    /// because the mutable cursor is indeed not an iterator.\n-    pub(crate) fn next(&mut self) -> Option<PageTableQueryResult> {\n-        self.0.next()\n-    }\n-\n     /// Jumps to the given virtual address.\n     ///\n+    /// This is the same as [`Cursor::jump`].\n+    ///\n     /// # Panics\n     ///\n     /// This method panics if the address is out of the range where the cursor is required to operate,\n     /// or has bad alignment.\n-    pub(crate) fn jump(&mut self, va: Vaddr) {\n-        assert!(self.0.barrier_va.contains(&va));\n-        assert!(va % C::BASE_PAGE_SIZE == 0);\n-\n-        loop {\n-            let cur_node_start = self.0.va & !(page_size::<C>(self.0.level + 1) - 1);\n-            let cur_node_end = cur_node_start + page_size::<C>(self.0.level + 1);\n-            // If the address is within the current node, we can jump directly.\n-            if cur_node_start <= va && va < cur_node_end {\n-                self.0.va = va;\n-                return;\n-            }\n+    pub fn jump(&mut self, va: Vaddr) {\n+        self.0.jump(va)\n+    }\n \n-            // There is a corner case that the cursor is depleted, sitting at the start of the\n-            // next node but the next node is not locked because the parent is not locked.\n-            if self.0.va >= self.0.barrier_va.end && self.0.level == self.0.guard_level {\n-                self.0.va = va;\n-                return;\n-            }\n+    /// Gets the current virtual address.\n+    pub fn virt_addr(&self) -> Vaddr {\n+        self.0.virt_addr()\n+    }\n \n-            debug_assert!(self.0.level < self.0.guard_level);\n-            self.0.level_up();\n-        }\n+    /// Gets the information of the current slot.\n+    pub fn query(&mut self) -> Result<PageTableQueryResult, PageTableError> {\n+        self.0.query()\n     }\n \n     /// Maps the range starting from the current address to a [`DynPage`].\n@@ -417,7 +432,7 @@ where\n     ///\n     /// The caller should ensure that the virtual range being mapped does\n     /// not affect kernel's memory safety.\n-    pub(crate) unsafe fn map(&mut self, page: DynPage, prop: PageProperty) {\n+    pub unsafe fn map(&mut self, page: DynPage, prop: PageProperty) {\n         let end = self.0.va + page.size();\n         assert!(end <= self.0.barrier_va.end);\n         debug_assert!(self.0.in_tracked_range());\n@@ -472,7 +487,7 @@ where\n     ///  - the range being mapped does not affect kernel's memory safety;\n     ///  - the physical address to be mapped is valid and safe to use;\n     ///  - it is allowed to map untracked pages in this virtual address range.\n-    pub(crate) unsafe fn map_pa(&mut self, pa: &Range<Paddr>, prop: PageProperty) {\n+    pub unsafe fn map_pa(&mut self, pa: &Range<Paddr>, prop: PageProperty) {\n         let end = self.0.va + pa.len();\n         let mut pa = pa.start;\n         assert!(end <= self.0.barrier_va.end);\n@@ -522,7 +537,7 @@ where\n     /// This function will panic if:\n     ///  - the range to be unmapped is out of the range where the cursor is required to operate;\n     ///  - the range covers only a part of a page.\n-    pub(crate) unsafe fn unmap(&mut self, len: usize) {\n+    pub unsafe fn unmap(&mut self, len: usize) {\n         let end = self.0.va + len;\n         assert!(end <= self.0.barrier_va.end);\n         assert!(end % C::BASE_PAGE_SIZE == 0);\n@@ -579,7 +594,7 @@ where\n     ///\n     /// This function will panic if:\n     ///  - the range to be protected is out of the range where the cursor is required to operate.\n-    pub(crate) unsafe fn protect(\n+    pub unsafe fn protect(\n         &mut self,\n         len: usize,\n         mut op: impl FnMut(&mut PageProperty),\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\nindex 3b68869290..118f76de92 100644\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -3,7 +3,7 @@\n use core::{fmt::Debug, marker::PhantomData, ops::Range};\n \n use super::{\n-    nr_subpage_per_huge, paddr_to_vaddr,\n+    nr_subpage_per_huge,\n     page_prop::{PageFlags, PageProperty},\n     page_size, Paddr, PagingConstsTrait, PagingLevel, Vaddr,\n };\n@@ -14,8 +14,8 @@ use crate::{\n \n mod node;\n use node::*;\n-mod cursor;\n-pub(crate) use cursor::{Cursor, CursorMut, PageTableQueryResult};\n+pub mod cursor;\n+pub use cursor::{Cursor, CursorMut, PageTableQueryResult};\n #[cfg(ktest)]\n mod test;\n \n@@ -23,8 +23,10 @@ pub(in crate::mm) mod boot_pt;\n \n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum PageTableError {\n-    /// The virtual address range is invalid.\n+    /// The provided virtual address range is invalid.\n     InvalidVaddrRange(Vaddr, Vaddr),\n+    /// The provided virtual address is invalid.\n+    InvalidVaddr(Vaddr),\n     /// Using virtual address not aligned.\n     UnalignedVaddr,\n     /// Protecting a mapping that does not exist.\n@@ -76,7 +78,7 @@ const fn pte_index<C: PagingConstsTrait>(va: Vaddr, level: PagingLevel) -> usize\n /// A handle to a page table.\n /// A page table can track the lifetime of the mapped physical pages.\n #[derive(Debug)]\n-pub(crate) struct PageTable<\n+pub struct PageTable<\n     M: PageTableMode,\n     E: PageTableEntryTrait = PageTableEntry,\n     C: PagingConstsTrait = PagingConsts,\n@@ -88,7 +90,7 @@ pub(crate) struct PageTable<\n }\n \n impl PageTable<UserMode> {\n-    pub(crate) fn activate(&self) {\n+    pub fn activate(&self) {\n         // SAFETY: The usermode page table is safe to activate since the kernel\n         // mappings are shared.\n         unsafe {\n@@ -100,7 +102,7 @@ impl PageTable<UserMode> {\n     /// new page table.\n     ///\n     /// TODO: We may consider making the page table itself copy-on-write.\n-    pub(crate) fn fork_copy_on_write(&self) -> Self {\n+    pub fn fork_copy_on_write(&self) -> Self {\n         let mut cursor = self.cursor_mut(&UserMode::VADDR_RANGE).unwrap();\n \n         // SAFETY: Protecting the user page table is safe.\n@@ -139,7 +141,7 @@ impl PageTable<KernelMode> {\n     ///\n     /// Then, one can use a user page table to call [`fork_copy_on_write`], creating\n     /// other child page tables.\n-    pub(crate) fn create_user_page_table(&self) -> PageTable<UserMode> {\n+    pub fn create_user_page_table(&self) -> PageTable<UserMode> {\n         let root_node = self.root.clone_shallow().lock();\n \n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n@@ -157,7 +159,7 @@ impl PageTable<KernelMode> {\n     /// The virtual address range should be aligned to the root level page size. Considering\n     /// usize overflows, the caller should provide the index range of the root level pages\n     /// instead of the virtual address range.\n-    pub(crate) fn make_shared_tables(&self, root_index: Range<usize>) {\n+    pub fn make_shared_tables(&self, root_index: Range<usize>) {\n         const NR_PTES_PER_NODE: usize = nr_subpage_per_huge::<PagingConsts>();\n \n         let start = root_index.start;\n@@ -182,7 +184,7 @@ where\n     [(); C::NR_LEVELS as usize]:,\n {\n     /// Create a new empty page table. Useful for the kernel page table and IOMMU page tables only.\n-    pub(crate) fn empty() -> Self {\n+    pub fn empty() -> Self {\n         PageTable {\n             root: PageTableNode::<E, C>::alloc(C::NR_LEVELS).into_raw(),\n             _phantom: PhantomData,\n@@ -197,11 +199,11 @@ where\n     ///\n     /// It is dangerous to directly provide the physical address of the root page table to the\n     /// hardware since the page table node may be dropped, resulting in UAF.\n-    pub(crate) unsafe fn root_paddr(&self) -> Paddr {\n+    pub unsafe fn root_paddr(&self) -> Paddr {\n         self.root.paddr()\n     }\n \n-    pub(crate) unsafe fn map(\n+    pub unsafe fn map(\n         &self,\n         vaddr: &Range<Vaddr>,\n         paddr: &Range<Paddr>,\n@@ -211,12 +213,12 @@ where\n         Ok(())\n     }\n \n-    pub(crate) unsafe fn unmap(&self, vaddr: &Range<Vaddr>) -> Result<(), PageTableError> {\n+    pub unsafe fn unmap(&self, vaddr: &Range<Vaddr>) -> Result<(), PageTableError> {\n         self.cursor_mut(vaddr)?.unmap(vaddr.len());\n         Ok(())\n     }\n \n-    pub(crate) unsafe fn protect(\n+    pub unsafe fn protect(\n         &self,\n         vaddr: &Range<Vaddr>,\n         op: impl FnMut(&mut PageProperty),\n@@ -232,16 +234,17 @@ where\n     /// Note that this function may fail reflect an accurate result if there are\n     /// cursors concurrently accessing the same virtual address range, just like what\n     /// happens for the hardware MMU walk.\n-    pub(crate) fn query(&self, vaddr: Vaddr) -> Option<(Paddr, PageProperty)> {\n+    #[cfg(ktest)]\n+    pub fn query(&self, vaddr: Vaddr) -> Option<(Paddr, PageProperty)> {\n         // SAFETY: The root node is a valid page table node so the address is valid.\n         unsafe { page_walk::<E, C>(self.root_paddr(), vaddr) }\n     }\n \n     /// Create a new cursor exclusively accessing the virtual address range for mapping.\n     ///\n-    /// If another cursor is already accessing the range, the new cursor will wait until the\n+    /// If another cursor is already accessing the range, the new cursor may wait until the\n     /// previous cursor is dropped.\n-    pub(crate) fn cursor_mut(\n+    pub fn cursor_mut(\n         &'a self,\n         va: &Range<Vaddr>,\n     ) -> Result<CursorMut<'a, M, E, C>, PageTableError> {\n@@ -250,19 +253,17 @@ where\n \n     /// Create a new cursor exclusively accessing the virtual address range for querying.\n     ///\n-    /// If another cursor is already accessing the range, the new cursor will wait until the\n-    /// previous cursor is dropped.\n-    pub(crate) fn cursor(\n-        &'a self,\n-        va: &Range<Vaddr>,\n-    ) -> Result<Cursor<'a, M, E, C>, PageTableError> {\n+    /// If another cursor is already accessing the range, the new cursor may wait until the\n+    /// previous cursor is dropped. The modification to the mapping by the cursor may also\n+    /// block or be overriden by the mapping of another cursor.\n+    pub fn cursor(&'a self, va: &Range<Vaddr>) -> Result<Cursor<'a, M, E, C>, PageTableError> {\n         Cursor::new(self, va)\n     }\n \n     /// Create a new reference to the same page table.\n     /// The caller must ensure that the kernel page table is not copied.\n     /// This is only useful for IOMMU page tables. Think twice before using it in other cases.\n-    pub(crate) unsafe fn shallow_copy(&self) -> Self {\n+    pub unsafe fn shallow_copy(&self) -> Self {\n         PageTable {\n             root: self.root.clone_shallow(),\n             _phantom: PhantomData,\n@@ -288,13 +289,14 @@ where\n ///\n /// To mitigate this problem, the page table nodes are by default not\n /// actively recycled, until we find an appropriate solution.\n+#[cfg(ktest)]\n pub(super) unsafe fn page_walk<E: PageTableEntryTrait, C: PagingConstsTrait>(\n     root_paddr: Paddr,\n     vaddr: Vaddr,\n ) -> Option<(Paddr, PageProperty)> {\n-    // We disable preemt here to mimic the MMU walk, which will not be interrupted\n-    // then must finish within a given time.\n-    let _guard = crate::task::disable_preempt();\n+    use super::paddr_to_vaddr;\n+\n+    let preempt_guard = crate::task::disable_preempt();\n \n     let mut cur_level = C::NR_LEVELS;\n     let mut cur_pte = {\n@@ -336,9 +338,7 @@ pub(super) unsafe fn page_walk<E: PageTableEntryTrait, C: PagingConstsTrait>(\n /// The interface for defining architecture-specific page table entries.\n ///\n /// Note that a default PTE shoud be a PTE that points to nothing.\n-pub(crate) trait PageTableEntryTrait:\n-    Clone + Copy + Debug + Default + Pod + Sized + Sync\n-{\n+pub trait PageTableEntryTrait: Clone + Copy + Debug + Default + Pod + Sized + Sync {\n     /// Create a set of new invalid page table flags that indicates an absent page.\n     ///\n     /// Note that currently the implementation requires an all zero PTE to be an absent PTE.\ndiff --git a/ostd/src/mm/space.rs b/ostd/src/mm/space.rs\ndeleted file mode 100644\nindex 548348f763..0000000000\n--- a/ostd/src/mm/space.rs\n+++ /dev/null\n@@ -1,408 +0,0 @@\n-// SPDX-License-Identifier: MPL-2.0\n-\n-use core::ops::Range;\n-\n-use spin::Once;\n-\n-use super::{\n-    io::UserSpace,\n-    is_page_aligned,\n-    kspace::KERNEL_PAGE_TABLE,\n-    page_table::{PageTable, PageTableMode, UserMode},\n-    CachePolicy, FrameVec, PageFlags, PageProperty, PagingConstsTrait, PrivilegedPageFlags,\n-    VmReader, VmWriter, PAGE_SIZE,\n-};\n-use crate::{\n-    arch::mm::{\n-        current_page_table_paddr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n-        PageTableEntry, PagingConsts,\n-    },\n-    cpu::CpuExceptionInfo,\n-    mm::{\n-        page_table::{Cursor, PageTableQueryResult as PtQr},\n-        Frame, MAX_USERSPACE_VADDR,\n-    },\n-    prelude::*,\n-    Error,\n-};\n-\n-/// Virtual memory space.\n-///\n-/// A virtual memory space (`VmSpace`) can be created and assigned to a user space so that\n-/// the virtual memory of the user space can be manipulated safely. For example,\n-/// given an arbitrary user-space pointer, one can read and write the memory\n-/// location referred to by the user-space pointer without the risk of breaking the\n-/// memory safety of the kernel space.\n-///\n-/// A newly-created `VmSpace` is not backed by any physical memory pages.\n-/// To provide memory pages for a `VmSpace`, one can allocate and map\n-/// physical memory ([`Frame`]s) to the `VmSpace`.\n-///\n-/// A `VmSpace` can also attach a page fault handler, which will be invoked to handle\n-/// page faults generated from user space.\n-///\n-/// A `VmSpace` can also attach a page fault handler, which will be invoked to handle\n-/// page faults generated from user space.\n-#[allow(clippy::type_complexity)]\n-pub struct VmSpace {\n-    pt: PageTable<UserMode>,\n-    page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n-}\n-\n-// Notes on TLB flushing:\n-//\n-// We currently assume that:\n-// 1. `VmSpace` _might_ be activated on the current CPU and the user memory _might_ be used\n-//    immediately after we make changes to the page table entries. So we must invalidate the\n-//    corresponding TLB caches accordingly.\n-// 2. `VmSpace` must _not_ be activated on another CPU. This assumption is trivial, since SMP\n-//    support is not yet available. But we need to consider this situation in the future (TODO).\n-\n-impl VmSpace {\n-    /// Creates a new VM address space.\n-    pub fn new() -> Self {\n-        Self {\n-            pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n-            page_fault_handler: Once::new(),\n-        }\n-    }\n-\n-    /// Activates the page table.\n-    pub(crate) fn activate(&self) {\n-        self.pt.activate();\n-    }\n-\n-    pub(crate) fn handle_page_fault(\n-        &self,\n-        info: &CpuExceptionInfo,\n-    ) -> core::result::Result<(), ()> {\n-        if let Some(func) = self.page_fault_handler.get() {\n-            return func(self, info);\n-        }\n-        Err(())\n-    }\n-\n-    /// Registers the page fault handler in this `VmSpace`.\n-    ///\n-    /// The page fault handler of a `VmSpace` can only be initialized once.\n-    /// If it has been initialized before, calling this method will have no effect.\n-    pub fn register_page_fault_handler(\n-        &self,\n-        func: fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>,\n-    ) {\n-        self.page_fault_handler.call_once(|| func);\n-    }\n-\n-    /// Maps some physical memory pages into the VM space according to the given\n-    /// options, returning the address where the mapping is created.\n-    ///\n-    /// The ownership of the frames will be transferred to the `VmSpace`.\n-    ///\n-    /// For more information, see [`VmMapOptions`].\n-    pub fn map(&self, frames: FrameVec, options: &VmMapOptions) -> Result<Vaddr> {\n-        if options.addr.is_none() {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let addr = options.addr.unwrap();\n-\n-        if addr % PAGE_SIZE != 0 {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let size = frames.nbytes();\n-        let end = addr.checked_add(size).ok_or(Error::InvalidArgs)?;\n-\n-        let va_range = addr..end;\n-        if !UserMode::covers(&va_range) {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        let mut cursor = self.pt.cursor_mut(&va_range)?;\n-\n-        // If overwrite is forbidden, we should check if there are existing mappings\n-        if !options.can_overwrite {\n-            while let Some(qr) = cursor.next() {\n-                if matches!(qr, PtQr::Mapped { .. }) {\n-                    return Err(Error::MapAlreadyMappedVaddr);\n-                }\n-            }\n-            cursor.jump(va_range.start);\n-        }\n-\n-        let prop = PageProperty {\n-            flags: options.flags,\n-            cache: CachePolicy::Writeback,\n-            priv_flags: PrivilegedPageFlags::USER,\n-        };\n-\n-        for frame in frames.into_iter() {\n-            // SAFETY: mapping in the user space with `Frame` is safe.\n-            unsafe {\n-                cursor.map(frame.into(), prop);\n-            }\n-        }\n-\n-        drop(cursor);\n-        tlb_flush_addr_range(&va_range);\n-\n-        Ok(addr)\n-    }\n-\n-    /// Queries about a range of virtual memory.\n-    /// You will get an iterator of `VmQueryResult` which contains the information of\n-    /// each parts of the range.\n-    pub fn query_range(&self, range: &Range<Vaddr>) -> Result<VmQueryIter> {\n-        Ok(VmQueryIter {\n-            cursor: self.pt.cursor(range)?,\n-        })\n-    }\n-\n-    /// Queries about the mapping information about a byte in virtual memory.\n-    /// This is more handy than [`query_range`], but less efficient if you want\n-    /// to query in a batch.\n-    ///\n-    /// [`query_range`]: VmSpace::query_range\n-    pub fn query(&self, vaddr: Vaddr) -> Result<Option<PageProperty>> {\n-        if !(0..MAX_USERSPACE_VADDR).contains(&vaddr) {\n-            return Err(Error::AccessDenied);\n-        }\n-        Ok(self.pt.query(vaddr).map(|(_pa, prop)| prop))\n-    }\n-\n-    /// Unmaps the physical memory pages within the VM address range.\n-    ///\n-    /// The range is allowed to contain gaps, where no physical memory pages\n-    /// are mapped.\n-    pub fn unmap(&self, range: &Range<Vaddr>) -> Result<()> {\n-        if !is_page_aligned(range.start) || !is_page_aligned(range.end) {\n-            return Err(Error::InvalidArgs);\n-        }\n-        if !UserMode::covers(range) {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        // SAFETY: unmapping in the user space is safe.\n-        unsafe {\n-            self.pt.unmap(range)?;\n-        }\n-        tlb_flush_addr_range(range);\n-\n-        Ok(())\n-    }\n-\n-    /// Clears all mappings\n-    pub fn clear(&self) {\n-        // SAFETY: unmapping user space is safe, and we don't care unmapping\n-        // invalid ranges.\n-        unsafe {\n-            self.pt.unmap(&(0..MAX_USERSPACE_VADDR)).unwrap();\n-        }\n-        tlb_flush_all_excluding_global();\n-    }\n-\n-    /// Updates the VM protection permissions within the VM address range.\n-    ///\n-    /// If any of the page in the given range is not mapped, it is skipped.\n-    /// The method panics when virtual address is not aligned to base page\n-    /// size.\n-    ///\n-    /// It is guarenteed that the operation is called once for each valid\n-    /// page found in the range.\n-    ///\n-    /// TODO: It returns error when invalid operations such as protect\n-    /// partial huge page happens, and efforts are not reverted, leaving us\n-    /// in a bad state.\n-    pub fn protect(&self, range: &Range<Vaddr>, op: impl FnMut(&mut PageProperty)) -> Result<()> {\n-        if !is_page_aligned(range.start) || !is_page_aligned(range.end) {\n-            return Err(Error::InvalidArgs);\n-        }\n-        if !UserMode::covers(range) {\n-            return Err(Error::InvalidArgs);\n-        }\n-\n-        // SAFETY: protecting in the user space is safe.\n-        unsafe {\n-            self.pt.protect(range, op)?;\n-        }\n-        tlb_flush_addr_range(range);\n-\n-        Ok(())\n-    }\n-\n-    /// Forks a new VM space with copy-on-write semantics.\n-    ///\n-    /// Both the parent and the newly forked VM space will be marked as\n-    /// read-only. And both the VM space will take handles to the same\n-    /// physical memory pages.\n-    pub fn fork_copy_on_write(&self) -> Self {\n-        let page_fault_handler = {\n-            let new_handler = Once::new();\n-            if let Some(handler) = self.page_fault_handler.get() {\n-                new_handler.call_once(|| *handler);\n-            }\n-            new_handler\n-        };\n-        let new_space = Self {\n-            pt: self.pt.fork_copy_on_write(),\n-            page_fault_handler,\n-        };\n-        tlb_flush_all_excluding_global();\n-        new_space\n-    }\n-\n-    /// Creates a reader to read data from the user space of the current task.\n-    ///\n-    /// Returns `Err` if this `VmSpace` is not belonged to the user space of the current task\n-    /// or the `vaddr` and `len` do not represent a user space memory range.\n-    pub fn reader(&self, vaddr: Vaddr, len: usize) -> Result<VmReader<'_, UserSpace>> {\n-        if current_page_table_paddr() != unsafe { self.pt.root_paddr() } {\n-            return Err(Error::AccessDenied);\n-        }\n-\n-        if vaddr.checked_add(len).unwrap_or(usize::MAX) > MAX_USERSPACE_VADDR {\n-            return Err(Error::AccessDenied);\n-        }\n-\n-        // SAFETY: As long as the current task owns user space, the page table of\n-        // the current task will be activated during the execution of the current task.\n-        // Since `VmReader` is neither `Sync` nor `Send`, it will not live longer than\n-        // the current task. Hence, it is ensured that the correct page table\n-        // is activated during the usage period of the `VmReader`.\n-        Ok(unsafe { VmReader::<UserSpace>::from_user_space(vaddr as *const u8, len) })\n-    }\n-\n-    /// Creates a writer to write data into the user space.\n-    ///\n-    /// Returns `Err` if this `VmSpace` is not belonged to the user space of the current task\n-    /// or the `vaddr` and `len` do not represent a user space memory range.\n-    pub fn writer(&self, vaddr: Vaddr, len: usize) -> Result<VmWriter<'_, UserSpace>> {\n-        if current_page_table_paddr() != unsafe { self.pt.root_paddr() } {\n-            return Err(Error::AccessDenied);\n-        }\n-\n-        if vaddr.checked_add(len).unwrap_or(usize::MAX) > MAX_USERSPACE_VADDR {\n-            return Err(Error::AccessDenied);\n-        }\n-\n-        // SAFETY: As long as the current task owns user space, the page table of\n-        // the current task will be activated during the execution of the current task.\n-        // Since `VmWriter` is neither `Sync` nor `Send`, it will not live longer than\n-        // the current task. Hence, it is ensured that the correct page table\n-        // is activated during the usage period of the `VmWriter`.\n-        Ok(unsafe { VmWriter::<UserSpace>::from_user_space(vaddr as *mut u8, len) })\n-    }\n-}\n-\n-impl Default for VmSpace {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-/// Options for mapping physical memory pages into a VM address space.\n-/// See [`VmSpace::map`].\n-#[derive(Clone, Debug)]\n-pub struct VmMapOptions {\n-    /// Starting virtual address\n-    addr: Option<Vaddr>,\n-    /// Map align\n-    align: usize,\n-    /// Page permissions and status\n-    flags: PageFlags,\n-    /// Can overwrite\n-    can_overwrite: bool,\n-}\n-\n-impl VmMapOptions {\n-    /// Creates the default options.\n-    pub fn new() -> Self {\n-        Self {\n-            addr: None,\n-            align: PagingConsts::BASE_PAGE_SIZE,\n-            flags: PageFlags::empty(),\n-            can_overwrite: false,\n-        }\n-    }\n-\n-    /// Sets the alignment of the address of the mapping.\n-    ///\n-    /// The alignment must be a power-of-2 and greater than or equal to the\n-    /// page size.\n-    ///\n-    /// The default value of this option is the page size.\n-    pub fn align(&mut self, align: usize) -> &mut Self {\n-        self.align = align;\n-        self\n-    }\n-\n-    /// Sets the permissions of the mapping, which affects whether\n-    /// the mapping can be read, written, or executed.\n-    ///\n-    /// The default value of this option is read-only.\n-    pub fn flags(&mut self, flags: PageFlags) -> &mut Self {\n-        self.flags = flags;\n-        self\n-    }\n-\n-    /// Sets the address of the new mapping.\n-    ///\n-    /// The default value of this option is `None`.\n-    pub fn addr(&mut self, addr: Option<Vaddr>) -> &mut Self {\n-        if addr.is_none() {\n-            return self;\n-        }\n-        self.addr = Some(addr.unwrap());\n-        self\n-    }\n-\n-    /// Sets whether the mapping can overwrite any existing mappings.\n-    ///\n-    /// If this option is `true`, then the address option must be `Some(_)`.\n-    ///\n-    /// The default value of this option is `false`.\n-    pub fn can_overwrite(&mut self, can_overwrite: bool) -> &mut Self {\n-        self.can_overwrite = can_overwrite;\n-        self\n-    }\n-}\n-\n-impl Default for VmMapOptions {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-/// The iterator for querying over the VM space without modifying it.\n-pub struct VmQueryIter<'a> {\n-    cursor: Cursor<'a, UserMode, PageTableEntry, PagingConsts>,\n-}\n-\n-pub enum VmQueryResult {\n-    NotMapped {\n-        va: Vaddr,\n-        len: usize,\n-    },\n-    Mapped {\n-        va: Vaddr,\n-        frame: Frame,\n-        prop: PageProperty,\n-    },\n-}\n-\n-impl Iterator for VmQueryIter<'_> {\n-    type Item = VmQueryResult;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        self.cursor.next().map(|ptqr| match ptqr {\n-            PtQr::NotMapped { va, len } => VmQueryResult::NotMapped { va, len },\n-            PtQr::Mapped { va, page, prop } => VmQueryResult::Mapped {\n-                va,\n-                frame: page.try_into().unwrap(),\n-                prop,\n-            },\n-            // It is not possible to map untyped memory in user space.\n-            PtQr::MappedUntracked { .. } => unreachable!(),\n-        })\n-    }\n-}\ndiff --git a/ostd/src/mm/vm_space.rs b/ostd/src/mm/vm_space.rs\nnew file mode 100644\nindex 0000000000..72c799eea1\n--- /dev/null\n+++ b/ostd/src/mm/vm_space.rs\n@@ -0,0 +1,373 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+//! Virtual memory space management.\n+//!\n+//! The [`VmSpace`] struct is provided to manage the virtual memory space of a\n+//! user. Cursors are used to traverse and modify over the virtual memory space\n+//! concurrently. The VM space cursor [`self::Cursor`] is just a wrapper over\n+//! the page table cursor [`super::page_table::Cursor`], providing efficient,\n+//! powerful concurrent accesses to the page table, and suffers from the same\n+//! validity concerns as described in [`super::page_table::cursor`].\n+\n+use core::ops::Range;\n+\n+use spin::Once;\n+\n+use super::{\n+    io::UserSpace,\n+    kspace::KERNEL_PAGE_TABLE,\n+    page_table::{PageTable, UserMode},\n+    PageProperty, VmReader, VmWriter,\n+};\n+use crate::{\n+    arch::mm::{\n+        current_page_table_paddr, tlb_flush_addr_range, tlb_flush_all_excluding_global,\n+        PageTableEntry, PagingConsts,\n+    },\n+    cpu::CpuExceptionInfo,\n+    mm::{\n+        page_table::{self, PageTableQueryResult as PtQr},\n+        Frame, MAX_USERSPACE_VADDR,\n+    },\n+    prelude::*,\n+    Error,\n+};\n+\n+/// Virtual memory space.\n+///\n+/// A virtual memory space (`VmSpace`) can be created and assigned to a user\n+/// space so that the virtual memory of the user space can be manipulated\n+/// safely. For example,  given an arbitrary user-space pointer, one can read\n+/// and write the memory location referred to by the user-space pointer without\n+/// the risk of breaking the memory safety of the kernel space.\n+///\n+/// A newly-created `VmSpace` is not backed by any physical memory pages. To\n+/// provide memory pages for a `VmSpace`, one can allocate and map physical\n+/// memory ([`Frame`]s) to the `VmSpace` using the cursor.\n+///\n+/// A `VmSpace` can also attach a page fault handler, which will be invoked to\n+/// handle page faults generated from user space.\n+#[allow(clippy::type_complexity)]\n+pub struct VmSpace {\n+    pt: PageTable<UserMode>,\n+    page_fault_handler: Once<fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>>,\n+}\n+\n+// Notes on TLB flushing:\n+//\n+// We currently assume that:\n+// 1. `VmSpace` _might_ be activated on the current CPU and the user memory _might_ be used\n+//    immediately after we make changes to the page table entries. So we must invalidate the\n+//    corresponding TLB caches accordingly.\n+// 2. `VmSpace` must _not_ be activated on another CPU. This assumption is trivial, since SMP\n+//    support is not yet available. But we need to consider this situation in the future (TODO).\n+impl VmSpace {\n+    /// Creates a new VM address space.\n+    pub fn new() -> Self {\n+        Self {\n+            pt: KERNEL_PAGE_TABLE.get().unwrap().create_user_page_table(),\n+            page_fault_handler: Once::new(),\n+        }\n+    }\n+\n+    /// Gets an immutable cursor in the virtual address range.\n+    ///\n+    /// The cursor behaves like a lock guard, exclusively owning a sub-tree of\n+    /// the page table, preventing others from creating a cursor in it. So be\n+    /// sure to drop the cursor as soon as possible.\n+    ///\n+    /// The creation of the cursor may block if another cursor having an\n+    /// overlapping range is alive.\n+    pub fn cursor(&self, va: &Range<Vaddr>) -> Result<Cursor<'_>> {\n+        Ok(self.pt.cursor(va).map(Cursor)?)\n+    }\n+\n+    /// Gets an mutable cursor in the virtual address range.\n+    ///\n+    /// The same as [`Self::cursor`], the cursor behaves like a lock guard,\n+    /// exclusively owning a sub-tree of the page table, preventing others\n+    /// from creating a cursor in it. So be sure to drop the cursor as soon as\n+    /// possible.\n+    ///\n+    /// The creation of the cursor may block if another cursor having an\n+    /// overlapping range is alive. The modification to the mapping by the\n+    /// cursor may also block or be overriden the mapping of another cursor.\n+    pub fn cursor_mut(&self, va: &Range<Vaddr>) -> Result<CursorMut<'_>> {\n+        Ok(self.pt.cursor_mut(va).map(CursorMut)?)\n+    }\n+\n+    /// Activates the page table.\n+    pub(crate) fn activate(&self) {\n+        self.pt.activate();\n+    }\n+\n+    pub(crate) fn handle_page_fault(\n+        &self,\n+        info: &CpuExceptionInfo,\n+    ) -> core::result::Result<(), ()> {\n+        if let Some(func) = self.page_fault_handler.get() {\n+            return func(self, info);\n+        }\n+        Err(())\n+    }\n+\n+    /// Registers the page fault handler in this `VmSpace`.\n+    ///\n+    /// The page fault handler of a `VmSpace` can only be initialized once.\n+    /// If it has been initialized before, calling this method will have no effect.\n+    pub fn register_page_fault_handler(\n+        &self,\n+        func: fn(&VmSpace, &CpuExceptionInfo) -> core::result::Result<(), ()>,\n+    ) {\n+        self.page_fault_handler.call_once(|| func);\n+    }\n+\n+    /// Clears all mappings\n+    pub fn clear(&self) {\n+        // SAFETY: unmapping user space is safe, and we don't care unmapping\n+        // invalid ranges.\n+        unsafe {\n+            self.pt.unmap(&(0..MAX_USERSPACE_VADDR)).unwrap();\n+        }\n+        tlb_flush_all_excluding_global();\n+    }\n+\n+    /// Forks a new VM space with copy-on-write semantics.\n+    ///\n+    /// Both the parent and the newly forked VM space will be marked as\n+    /// read-only. And both the VM space will take handles to the same\n+    /// physical memory pages.\n+    pub fn fork_copy_on_write(&self) -> Self {\n+        let page_fault_handler = {\n+            let new_handler = Once::new();\n+            if let Some(handler) = self.page_fault_handler.get() {\n+                new_handler.call_once(|| *handler);\n+            }\n+            new_handler\n+        };\n+        let new_space = Self {\n+            pt: self.pt.fork_copy_on_write(),\n+            page_fault_handler,\n+        };\n+        tlb_flush_all_excluding_global();\n+        new_space\n+    }\n+\n+    /// Creates a reader to read data from the user space of the current task.\n+    ///\n+    /// Returns `Err` if this `VmSpace` is not belonged to the user space of the current task\n+    /// or the `vaddr` and `len` do not represent a user space memory range.\n+    pub fn reader(&self, vaddr: Vaddr, len: usize) -> Result<VmReader<'_, UserSpace>> {\n+        if current_page_table_paddr() != unsafe { self.pt.root_paddr() } {\n+            return Err(Error::AccessDenied);\n+        }\n+\n+        if vaddr.checked_add(len).unwrap_or(usize::MAX) > MAX_USERSPACE_VADDR {\n+            return Err(Error::AccessDenied);\n+        }\n+\n+        // SAFETY: As long as the current task owns user space, the page table of\n+        // the current task will be activated during the execution of the current task.\n+        // Since `VmReader` is neither `Sync` nor `Send`, it will not live longer than\n+        // the current task. Hence, it is ensured that the correct page table\n+        // is activated during the usage period of the `VmReader`.\n+        Ok(unsafe { VmReader::<UserSpace>::from_user_space(vaddr as *const u8, len) })\n+    }\n+\n+    /// Creates a writer to write data into the user space.\n+    ///\n+    /// Returns `Err` if this `VmSpace` is not belonged to the user space of the current task\n+    /// or the `vaddr` and `len` do not represent a user space memory range.\n+    pub fn writer(&self, vaddr: Vaddr, len: usize) -> Result<VmWriter<'_, UserSpace>> {\n+        if current_page_table_paddr() != unsafe { self.pt.root_paddr() } {\n+            return Err(Error::AccessDenied);\n+        }\n+\n+        if vaddr.checked_add(len).unwrap_or(usize::MAX) > MAX_USERSPACE_VADDR {\n+            return Err(Error::AccessDenied);\n+        }\n+\n+        // SAFETY: As long as the current task owns user space, the page table of\n+        // the current task will be activated during the execution of the current task.\n+        // Since `VmWriter` is neither `Sync` nor `Send`, it will not live longer than\n+        // the current task. Hence, it is ensured that the correct page table\n+        // is activated during the usage period of the `VmWriter`.\n+        Ok(unsafe { VmWriter::<UserSpace>::from_user_space(vaddr as *mut u8, len) })\n+    }\n+}\n+\n+impl Default for VmSpace {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+/// The cursor for querying over the VM space without modifying it.\n+///\n+/// It exclusively owns a sub-tree of the page table, preventing others from\n+/// reading or modifying the same sub-tree. Two read-only cursors can not be\n+/// created from the same virtual address range either.\n+pub struct Cursor<'a>(page_table::Cursor<'a, UserMode, PageTableEntry, PagingConsts>);\n+\n+impl Iterator for Cursor<'_> {\n+    type Item = VmQueryResult;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let result = self.query();\n+        if result.is_ok() {\n+            self.0.move_forward();\n+        }\n+        result.ok()\n+    }\n+}\n+\n+impl Cursor<'_> {\n+    /// Query about the current slot.\n+    ///\n+    /// This function won't bring the cursor to the next slot.\n+    pub fn query(&mut self) -> Result<VmQueryResult> {\n+        Ok(self.0.query().map(|ptqr| ptqr.try_into().unwrap())?)\n+    }\n+\n+    /// Jump to the virtual address.\n+    pub fn jump(&mut self, va: Vaddr) {\n+        self.0.jump(va);\n+    }\n+\n+    /// Get the virtual address of the current slot.\n+    pub fn virt_addr(&self) -> Vaddr {\n+        self.0.virt_addr()\n+    }\n+}\n+\n+/// The cursor for modifying the mappings in VM space.\n+///\n+/// It exclusively owns a sub-tree of the page table, preventing others from\n+/// reading or modifying the same sub-tree.\n+pub struct CursorMut<'a>(page_table::CursorMut<'a, UserMode, PageTableEntry, PagingConsts>);\n+\n+impl CursorMut<'_> {\n+    /// Query about the current slot.\n+    ///\n+    /// This is the same as [`Cursor::query`].\n+    ///\n+    /// This function won't bring the cursor to the next slot.\n+    pub fn query(&mut self) -> Result<VmQueryResult> {\n+        Ok(self.0.query().map(|ptqr| ptqr.try_into().unwrap())?)\n+    }\n+\n+    /// Jump to the virtual address.\n+    ///\n+    /// This is the same as [`Cursor::jump`].\n+    pub fn jump(&mut self, va: Vaddr) {\n+        self.0.jump(va);\n+    }\n+\n+    /// Get the virtual address of the current slot.\n+    pub fn virt_addr(&self) -> Vaddr {\n+        self.0.virt_addr()\n+    }\n+\n+    /// Map a frame into the current slot.\n+    ///\n+    /// This method will bring the cursor to the next slot after the modification.\n+    pub fn map(&mut self, frame: Frame, prop: PageProperty) {\n+        let start_va = self.virt_addr();\n+        let end_va = start_va + frame.size();\n+\n+        // SAFETY: It is safe to map untyped memory into the userspace.\n+        unsafe {\n+            self.0.map(frame.into(), prop);\n+        }\n+\n+        tlb_flush_addr_range(&(start_va..end_va));\n+    }\n+\n+    /// Clear the mapping starting from the current slot.\n+    ///\n+    /// This method will bring the cursor forward by `len` bytes in the virtual\n+    /// address space after the modification.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method will panic if `len` is not page-aligned.\n+    pub fn unmap(&mut self, len: usize) {\n+        assert!(len % super::PAGE_SIZE == 0);\n+        let start_va = self.virt_addr();\n+        let end_va = start_va + len;\n+\n+        // SAFETY: It is safe to un-map memory in the userspace.\n+        unsafe {\n+            self.0.unmap(len);\n+        }\n+\n+        tlb_flush_addr_range(&(start_va..end_va));\n+    }\n+\n+    /// Change the mapping property starting from the current slot.\n+    ///\n+    /// This method will bring the cursor forward by `len` bytes in the virtual\n+    /// address space after the modification.\n+    ///\n+    /// The way to change the property is specified by the closure `op`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This method will panic if `len` is not page-aligned.\n+    pub fn protect(\n+        &mut self,\n+        len: usize,\n+        op: impl FnMut(&mut PageProperty),\n+        allow_protect_absent: bool,\n+    ) -> Result<()> {\n+        assert!(len % super::PAGE_SIZE == 0);\n+        let start_va = self.virt_addr();\n+        let end_va = start_va + len;\n+\n+        // SAFETY: It is safe to protect memory in the userspace.\n+        let result = unsafe { self.0.protect(len, op, allow_protect_absent) };\n+\n+        tlb_flush_addr_range(&(start_va..end_va));\n+\n+        Ok(result?)\n+    }\n+}\n+\n+/// The result of a query over the VM space.\n+#[derive(Debug)]\n+pub enum VmQueryResult {\n+    /// The current slot is not mapped.\n+    NotMapped {\n+        /// The virtual address of the slot.\n+        va: Vaddr,\n+        /// The length of the slot.\n+        len: usize,\n+    },\n+    /// The current slot is mapped.\n+    Mapped {\n+        /// The virtual address of the slot.\n+        va: Vaddr,\n+        /// The mapped frame.\n+        frame: Frame,\n+        /// The property of the slot.\n+        prop: PageProperty,\n+    },\n+}\n+\n+impl TryFrom<PtQr> for VmQueryResult {\n+    type Error = &'static str;\n+\n+    fn try_from(ptqr: PtQr) -> core::result::Result<Self, Self::Error> {\n+        match ptqr {\n+            PtQr::NotMapped { va, len } => Ok(VmQueryResult::NotMapped { va, len }),\n+            PtQr::Mapped { va, page, prop } => Ok(VmQueryResult::Mapped {\n+                va,\n+                frame: page\n+                    .try_into()\n+                    .map_err(|_| \"found typed memory mapped into `VmSpace`\")?,\n+                prop,\n+            }),\n+            PtQr::MappedUntracked { .. } => Err(\"found untracked memory mapped into `VmSpace`\"),\n+        }\n+    }\n+}\ndiff --git a/tools/format_all.sh b/tools/format_all.sh\nindex c66baa29fe..eaf54478ab 100755\n--- a/tools/format_all.sh\n+++ b/tools/format_all.sh\n@@ -29,6 +29,14 @@ else\n     cargo fmt\n fi\n \n+# Format the 100-line kernel demo as well\n+KERNEL_DEMO_FILE=\"$WORKSPACE_ROOT/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\"\n+if [ \"$CHECK_MODE\" = true ]; then\n+    cargo fmt --check -- $KERNEL_DEMO_FILE\n+else\n+    cargo fmt -- $KERNEL_DEMO_FILE\n+fi\n+\n for CRATE in $EXCLUDED_CRATES; do\n     CRATE_DIR=\"$WORKSPACE_ROOT/$CRATE\"\n \n", "test_patch": "diff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\nindex 889779f7b7..52dde2534b 100644\n--- a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -13,7 +13,8 @@ use alloc::vec;\n use ostd::arch::qemu::{exit_qemu, QemuExitCode};\n use ostd::cpu::UserContext;\n use ostd::mm::{\n-    FrameAllocOptions, PageFlags, Vaddr, VmIo, VmMapOptions, VmSpace, VmWriter, PAGE_SIZE,\n+    CachePolicy, FrameAllocOptions, PageFlags, PageProperty, Vaddr, VmIo, VmSpace, VmWriter,\n+    PAGE_SIZE,\n };\n use ostd::prelude::*;\n use ostd::task::{Task, TaskOptions};\n@@ -32,8 +33,8 @@ pub fn main() {\n }\n \n fn create_user_space(program: &[u8]) -> UserSpace {\n+    let nframes = program.len().align_up(PAGE_SIZE) / PAGE_SIZE;\n     let user_pages = {\n-        let nframes = program.len().align_up(PAGE_SIZE) / PAGE_SIZE;\n         let vm_frames = FrameAllocOptions::new(nframes).alloc().unwrap();\n         // Phyiscal memory pages can be only accessed\n         // via the Frame abstraction.\n@@ -45,11 +46,15 @@ fn create_user_space(program: &[u8]) -> UserSpace {\n \n         // The page table of the user space can be\n         // created and manipulated safely through\n-        // the VmSpace abstraction.\n+        // the `VmSpace` abstraction.\n         let vm_space = VmSpace::new();\n-        let mut options = VmMapOptions::new();\n-        options.addr(Some(MAP_ADDR)).flags(PageFlags::RWX);\n-        vm_space.map(user_pages, &options).unwrap();\n+        let mut cursor = vm_space\n+            .cursor_mut(&(MAP_ADDR..MAP_ADDR + nframes * PAGE_SIZE))\n+            .unwrap();\n+        let map_prop = PageProperty::new(PageFlags::RWX, CachePolicy::Writeback);\n+        for frame in user_pages {\n+            cursor.map(frame, map_prop);\n+        }\n         Arc::new(vm_space)\n     };\n     let user_cpu_state = {\n", "problem_statement": "The APIs of `VmSpace` are vulnerable to race conditions\n```rust\r\n#[derive(Debug, Clone)]\r\npub struct VmSpace {\r\n    memory_set: Arc<Mutex<MemorySet>>,\r\n}\r\n\r\nimpl VmSpace {\r\n    /// determine whether a vaddr is already mapped\r\n    pub fn is_mapped(&self, vaddr: Vaddr) -> bool {\r\n        let memory_set = self.memory_set.lock();\r\n        memory_set.is_mapped(vaddr)\r\n    }\r\n}\r\n```\r\n\r\n- This API is racy by design *unless an external lock is used properly*.\r\n   - `is_mapped` returns whether the page is mapped or not *when the method is called*, but the result can be changed immediately just after the method returns (because it releases the `VmSpace`'s lock).\r\n - Even `type VmSpace = Arc<Mutex<MemorySet>>` is probably better, at least it makes the lock explicit.\r\n   - Something like `vm_space.lock().is_mapped(vaddr1) && vm_space.lock().is_mapped(vaddr2)` is obviously wrong (or at least not optimized) code.\n", "hints_text": "", "created_at": "2024-07-04T11:40:07Z", "version": "0.6"}, {"repo": "asterinas/asterinas", "pull_number": 1018, "instance_id": "asterinas__asterinas-1018", "issue_numbers": ["1009"], "base_commit": "8a9c012249d36c54712030c41388d20a608939f5", "patch": "diff --git a/.github/workflows/publish_api_docs.yml b/.github/workflows/publish_api_docs.yml\ndeleted file mode 100644\nindex 64c59ef4b5..0000000000\n--- a/.github/workflows/publish_api_docs.yml\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-name: Update API docs\n-\n-on:\n-  # Scheduled events for nightly API docs\n-  schedule:\n-    # UTC 00:00 everyday\n-    - cron: \"0 0 * * *\"\n-  # Events for API docs of new release\n-  push:\n-    branches:\n-      - main\n-    paths:\n-      - VERSION\n-\n-jobs:\n-  build_and_upload:\n-    runs-on: ubuntu-latest\n-    timeout-minutes: 15\n-    container: asterinas/asterinas:0.6.2\n-\n-    steps:\n-      - uses: actions/checkout@v2\n-        with:\n-          repository: 'asterinas/asterinas'\n-          path: 'asterinas'\n-\n-      - name: Build & Upload Nightly API Docs\n-        if: github.event_name == 'schedule'\n-        env:\n-          API_DOCS_NIGHTLY_PUBLISH_KEY: ${{ secrets.API_DOCS_NIGHTLY_PUBLISH_KEY }}\n-        run: |\n-          KEY_FILE=./api_docs_nightly_publish_key\n-          echo \"$API_DOCS_NIGHTLY_PUBLISH_KEY\\n\" > ${KEY_FILE}\n-          bash asterinas/tools/github_workflows/build_and_upload_api_docs.sh nightly ${KEY_FILE} \n-\n-      - name: Build & Upload Release API Docs\n-        if: github.event_name == 'push'\n-        env:\n-          API_DOCS_PUBLISH_KEY: ${{ secrets.API_DOCS_PUBLISH_KEY }}\n-        run: |\n-          KEY_FILE=./api_docs_publish_key\n-          echo \"$API_DOCS_PUBLISH_KEY\\n\" > ${KEY_FILE}\n-          bash asterinas/tools/github_workflows/build_and_upload_api_docs.sh release ${KEY_FILE} \ndiff --git a/.github/workflows/publish_osdk.yml b/.github/workflows/publish_osdk.yml\ndeleted file mode 100644\nindex 62a5580b49..0000000000\n--- a/.github/workflows/publish_osdk.yml\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-name: Publish OSDK\n-\n-on:\n-  pull_request:\n-    paths:\n-      - VERSION\n-      - osdk/Cargo.toml\n-  push:\n-    branches:\n-      - main\n-    paths: \n-      - VERSION\n-\n-jobs:\n-  osdk-publish:\n-    runs-on: ubuntu-latest\n-    timeout-minutes: 10\n-    container: asterinas/asterinas:0.6.2\n-    steps:\n-      - uses: actions/checkout@v4\n-\n-      - name: Check Publish\n-        # On pull request, set `--dry-run` to check whether OSDK can publish\n-        if: github.event_name == 'pull_request'\n-        run: |\n-          cd osdk\n-          cargo publish --dry-run\n-        \n-      - name: Publish\n-        # On push, OSDK will be published\n-        if: github.event_name == 'push'\n-        env:\n-          REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}\n-        run: |\n-          cd osdk\n-          cargo publish --token ${REGISTRY_TOKEN}\ndiff --git a/.github/workflows/publish_osdk_and_ostd.yml b/.github/workflows/publish_osdk_and_ostd.yml\nnew file mode 100644\nindex 0000000000..c9e4d2e520\n--- /dev/null\n+++ b/.github/workflows/publish_osdk_and_ostd.yml\n@@ -0,0 +1,69 @@\n+name: Publish OSDK and OSTD\n+\n+on:\n+  pull_request:\n+    paths:\n+      - VERSION\n+      - ostd/**\n+      - osdk/**\n+  push:\n+    branches:\n+      - main\n+    paths: \n+      - VERSION\n+\n+jobs:\n+  osdk-publish:\n+    runs-on: ubuntu-latest\n+    timeout-minutes: 10\n+    container: asterinas/asterinas:0.6.2\n+    steps:\n+      - uses: actions/checkout@v4\n+\n+      - name: Check Publish OSDK\n+        # On pull request, set `--dry-run` to check whether OSDK can publish\n+        if: github.event_name == 'pull_request'\n+        run: |\n+          cd osdk\n+          cargo publish --dry-run\n+        \n+      - name: Publish OSDK\n+        # On push, OSDK will be published\n+        if: github.event_name == 'push'\n+        env:\n+          REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}\n+        run: |\n+          cd osdk\n+          cargo publish --token ${REGISTRY_TOKEN}\n+\n+  ostd-publish:\n+    runs-on: ubuntu-latest\n+    timeout-minutes: 10\n+    container: asterinas/asterinas:0.6.2\n+    strategy:\n+      matrix:\n+        # All supported targets, this array should keep consistent with\n+        # `package.metadata.docs.rs.targets` in `ostd/Cargo.toml`\n+        target: ['x86_64-unknown-none']\n+    steps:\n+      - uses: actions/checkout@v4\n+\n+      - name: Check Publish OSTD\n+        # On pull request, set `--dry-run` to check whether OSDK can publish\n+        if: github.event_name == 'pull_request'\n+        run: |\n+          cd ostd\n+          cargo publish --target ${{ matrix.target }} --dry-run\n+          cargo doc --target ${{ matrix.target }}\n+      \n+      - name: Publish OSTD\n+        if: github.event_name == 'push'\n+        env:\n+          REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}\n+        # Using any target that OSTD supports for publishing is ok.\n+        # Here we use the same target as \n+        # `package.metadata.docs.rs.default-target` in `ostd/Cargo.toml`.\n+        run: |\n+          cd ostd\n+          cargo publish --target x86_64-unknown-none --token ${REGISTRY_TOKEN}\n+      \ndiff --git a/Cargo.lock b/Cargo.lock\nindex c70d7b0c6d..79dc2328da 100644\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -84,7 +84,6 @@ dependencies = [\n  \"lazy_static\",\n  \"log\",\n  \"ostd\",\n- \"pod\",\n  \"spin 0.9.8\",\n  \"static_assertions\",\n ]\n@@ -141,7 +140,6 @@ dependencies = [\n  \"int-to-c-enum\",\n  \"log\",\n  \"ostd\",\n- \"pod\",\n  \"ringbuf\",\n  \"smoltcp\",\n  \"spin 0.9.8\",\n@@ -185,7 +183,6 @@ dependencies = [\n  \"lru\",\n  \"ostd\",\n  \"paste\",\n- \"pod\",\n  \"rand\",\n  \"ringbuf\",\n  \"smoltcp\",\n@@ -238,7 +235,6 @@ dependencies = [\n  \"aster-rights-proc\",\n  \"inherit-methods-macro\",\n  \"ostd\",\n- \"pod\",\n  \"typeflags-util\",\n ]\n \n@@ -261,7 +257,6 @@ dependencies = [\n  \"int-to-c-enum\",\n  \"log\",\n  \"ostd\",\n- \"pod\",\n  \"smoltcp\",\n  \"spin 0.9.8\",\n  \"typeflags-util\",\n@@ -277,7 +272,7 @@ dependencies = [\n  \"component\",\n  \"id-alloc\",\n  \"ostd\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n ]\n \n [[package]]\n@@ -760,9 +755,9 @@ dependencies = [\n \n [[package]]\n name = \"intrusive-collections\"\n-version = \"0.9.5\"\n+version = \"0.9.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f4f90afb01281fdeffb0f8e082d230cbe4f888f837cc90759696b858db1a700\"\n+checksum = \"b694dc9f70c3bda874626d2aed13b780f137aab435f4e9814121955cf706122e\"\n dependencies = [\n  \"memoffset\",\n ]\n@@ -795,13 +790,6 @@ checksum = \"078e285eafdfb6c4b434e0d31e8cfcb5115b651496faca5749b88fafd4f23bfd\"\n name = \"keyable-arc\"\n version = \"0.1.0\"\n \n-[[package]]\n-name = \"ktest\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"owo-colors\",\n-]\n-\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\"\n@@ -891,7 +879,7 @@ dependencies = [\n  \"uart_16550\",\n  \"uefi\",\n  \"uefi-services\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n  \"xmas-elf 0.8.0\",\n ]\n \n@@ -950,9 +938,9 @@ checksum = \"523dc4f511e55ab87b694dc30d0f820d60906ef06413f93d4d7a1385599cc149\"\n \n [[package]]\n name = \"memoffset\"\n-version = \"0.8.0\"\n+version = \"0.9.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d61c719bcfbcf5d62b3a09efa6088de8c54bc0bfcd3ea7ae39fcc186108b8de1\"\n+checksum = \"488016bfae457b036d996092f6cb448677611ce4449e970ceaf42695203f218a\"\n dependencies = [\n  \"autocfg\",\n ]\n@@ -1094,7 +1082,6 @@ dependencies = [\n  \"inherit-methods-macro\",\n  \"int-to-c-enum\",\n  \"intrusive-collections\",\n- \"ktest\",\n  \"lazy_static\",\n  \"linux-boot-params\",\n  \"log\",\n@@ -1103,8 +1090,9 @@ dependencies = [\n  \"num-derive\",\n  \"num-traits\",\n  \"ostd-macros\",\n+ \"ostd-pod\",\n+ \"ostd-test\",\n  \"owo-colors\",\n- \"pod\",\n  \"rsdp\",\n  \"spin 0.9.8\",\n  \"static_assertions\",\n@@ -1113,13 +1101,13 @@ dependencies = [\n  \"unwinding\",\n  \"volatile\",\n  \"x86\",\n- \"x86_64\",\n+ \"x86_64 0.14.11\",\n  \"xarray\",\n ]\n \n [[package]]\n name = \"ostd-macros\"\n-version = \"0.1.0\"\n+version = \"0.1.4\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1127,6 +1115,31 @@ dependencies = [\n  \"syn 2.0.49\",\n ]\n \n+[[package]]\n+name = \"ostd-pod\"\n+version = \"0.1.1\"\n+source = \"git+https://github.com/asterinas/ostd-pod?rev=c4644be#c4644be401cae1e046a810574078b64e35924f5f\"\n+dependencies = [\n+ \"ostd-pod-derive\",\n+]\n+\n+[[package]]\n+name = \"ostd-pod-derive\"\n+version = \"0.1.1\"\n+source = \"git+https://github.com/asterinas/ostd-pod?rev=c4644be#c4644be401cae1e046a810574078b64e35924f5f\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 1.0.109\",\n+]\n+\n+[[package]]\n+name = \"ostd-test\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"owo-colors\",\n+]\n+\n [[package]]\n name = \"owo-colors\"\n version = \"3.5.0\"\n@@ -1139,24 +1152,6 @@ version = \"1.0.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c\"\n \n-[[package]]\n-name = \"pod\"\n-version = \"0.1.0\"\n-source = \"git+https://github.com/asterinas/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n-dependencies = [\n- \"pod-derive\",\n-]\n-\n-[[package]]\n-name = \"pod-derive\"\n-version = \"0.1.0\"\n-source = \"git+https://github.com/asterinas/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn 1.0.109\",\n-]\n-\n [[package]]\n name = \"polonius-the-crab\"\n version = \"0.2.1\"\n@@ -1276,6 +1271,15 @@ dependencies = [\n  \"bitflags 1.3.2\",\n ]\n \n+[[package]]\n+name = \"raw-cpuid\"\n+version = \"11.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e29830cbb1290e404f24c73af91c5d8d631ce7e128691e9477556b540cd01ecd\"\n+dependencies = [\n+ \"bitflags 2.4.1\",\n+]\n+\n [[package]]\n name = \"ringbuf\"\n version = \"0.3.3\"\n@@ -1358,9 +1362,9 @@ dependencies = [\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.13.1\"\n+version = \"1.13.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e6ecd384b10a64542d77071bd64bd7b231f4ed5940fba55e98c3de13824cf3d7\"\n+checksum = \"3c5e1a9a646d36c3599cd173a41282daf47c44583ad367b8e6837255952e5c67\"\n \n [[package]]\n name = \"smoltcp\"\n@@ -1462,8 +1466,8 @@ dependencies = [\n  \"bitflags 1.3.2\",\n  \"iced-x86\",\n  \"lazy_static\",\n- \"raw-cpuid\",\n- \"x86_64\",\n+ \"raw-cpuid 10.7.0\",\n+ \"x86_64 0.14.11\",\n ]\n \n [[package]]\n@@ -1539,13 +1543,12 @@ dependencies = [\n \n [[package]]\n name = \"trapframe\"\n-version = \"0.9.0\"\n-source = \"git+https://github.com/asterinas/trapframe-rs?rev=4739428#4739428fd51685c74e6e88e73e5f04cb89f465ee\"\n+version = \"0.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"105000258ba41c463b63403c9341c55a298f35f6137b1cca08c10f0409ef8d3a\"\n dependencies = [\n- \"log\",\n- \"pod\",\n- \"raw-cpuid\",\n- \"x86_64\",\n+ \"raw-cpuid 11.0.2\",\n+ \"x86_64 0.15.1\",\n ]\n \n [[package]]\n@@ -1723,7 +1726,7 @@ checksum = \"2781db97787217ad2a2845c396a5efe286f87467a5810836db6d74926e94a385\"\n dependencies = [\n  \"bit_field\",\n  \"bitflags 1.3.2\",\n- \"raw-cpuid\",\n+ \"raw-cpuid 10.7.0\",\n ]\n \n [[package]]\n@@ -1738,6 +1741,18 @@ dependencies = [\n  \"volatile\",\n ]\n \n+[[package]]\n+name = \"x86_64\"\n+version = \"0.15.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4bc79523af8abf92fb1a970c3e086c5a343f6bcc1a0eb890f575cbb3b45743df\"\n+dependencies = [\n+ \"bit_field\",\n+ \"bitflags 2.4.1\",\n+ \"rustversion\",\n+ \"volatile\",\n+]\n+\n [[package]]\n name = \"xarray\"\n version = \"0.1.0\"\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 9e47daa492..26ab93e796 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -8,7 +8,7 @@ members = [\n     \"ostd/libs/linux-bzimage/builder\",\n     \"ostd/libs/linux-bzimage/boot-params\",\n     \"ostd/libs/linux-bzimage/setup\",\n-    \"ostd/libs/ktest\",\n+    \"ostd/libs/ostd-test\",\n     \"kernel\",\n     \"kernel/aster-nix\",\n     \"kernel/comps/block\",\ndiff --git a/Makefile b/Makefile\nindex 0a02b8043d..56134ff5af 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -91,8 +91,8 @@ NON_OSDK_CRATES := \\\n \tostd/libs/id-alloc \\\n \tostd/libs/linux-bzimage/builder \\\n \tostd/libs/linux-bzimage/boot-params \\\n-\tostd/libs/ktest \\\n \tostd/libs/ostd-macros \\\n+\tostd/libs/ostd-test \\\n \tkernel/libs/cpio-decoder \\\n \tkernel/libs/int-to-c-enum \\\n \tkernel/libs/int-to-c-enum/derive \\\ndiff --git a/docs/src/ostd/README.md b/docs/src/ostd/README.md\nindex 7cd55ee321..9912a4ba91 100644\n--- a/docs/src/ostd/README.md\n+++ b/docs/src/ostd/README.md\n@@ -39,9 +39,7 @@ To explore how these APIs come into play,\n see [the example of a 100-line kernel in safe Rust](a-100-line-kernel.md).\n \n The OSTD APIs have been extensively documented.\n-You can access the comprehensive API documentation for each release by visiting the [API docs](https://asterinas.github.io/api-docs).\n-Additionally, you can refer to the latest nightly version API documentation at [API docs nightly](https://asterinas.github.io/api-docs-nightly),\n-which remains in sync with the latest changes in the main branch.\n+You can access the comprehensive API documentation by visiting the [docs.rs](https://docs.rs/ostd/latest/ostd).\n \n ## Four Requirements Satisfied\n \ndiff --git a/kernel/aster-nix/Cargo.toml b/kernel/aster-nix/Cargo.toml\nindex b2651c6b42..f5b52453e9 100644\n--- a/kernel/aster-nix/Cargo.toml\n+++ b/kernel/aster-nix/Cargo.toml\n@@ -6,9 +6,7 @@ edition = \"2021\"\n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-ostd = { path = \"../../ostd\" }\n align_ext = { path = \"../../ostd/libs/align_ext\" }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n aster-input = { path = \"../comps/input\" }\n aster-block = { path = \"../comps/block\" }\n aster-network = { path = \"../comps/network\" }\n@@ -17,6 +15,7 @@ aster-time = { path = \"../comps/time\" }\n aster-virtio = { path = \"../comps/virtio\" }\n aster-rights = { path = \"../libs/aster-rights\" }\n controlled = { path = \"../libs/comp-sys/controlled\" }\n+ostd = { path = \"../../ostd\" }\n typeflags = { path = \"../libs/typeflags\" }\n typeflags-util = { path = \"../libs/typeflags-util\" }\n aster-rights-proc = { path = \"../libs/aster-rights-proc\" }\ndiff --git a/kernel/aster-nix/src/arch/x86/cpu.rs b/kernel/aster-nix/src/arch/x86/cpu.rs\nindex b6b2572111..3bb49ce1bf 100644\n--- a/kernel/aster-nix/src/arch/x86/cpu.rs\n+++ b/kernel/aster-nix/src/arch/x86/cpu.rs\n@@ -1,6 +1,9 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use ostd::cpu::UserContext;\n+use ostd::{\n+    cpu::{RawGeneralRegs, UserContext},\n+    Pod,\n+};\n \n use crate::cpu::LinuxAbi;\n \n@@ -36,3 +39,64 @@ impl LinuxAbi for UserContext {\n         self.fsbase()\n     }\n }\n+\n+/// General-purpose registers.\n+#[derive(Debug, Clone, Copy, Pod, Default)]\n+#[repr(C)]\n+pub struct GpRegs {\n+    pub rax: usize,\n+    pub rbx: usize,\n+    pub rcx: usize,\n+    pub rdx: usize,\n+    pub rsi: usize,\n+    pub rdi: usize,\n+    pub rbp: usize,\n+    pub rsp: usize,\n+    pub r8: usize,\n+    pub r9: usize,\n+    pub r10: usize,\n+    pub r11: usize,\n+    pub r12: usize,\n+    pub r13: usize,\n+    pub r14: usize,\n+    pub r15: usize,\n+    pub rip: usize,\n+    pub rflags: usize,\n+    pub fsbase: usize,\n+    pub gsbase: usize,\n+}\n+\n+macro_rules! copy_gp_regs {\n+    ($src: ident, $dst: ident) => {\n+        $dst.rax = $src.rax;\n+        $dst.rbx = $src.rax;\n+        $dst.rcx = $src.rcx;\n+        $dst.rdx = $src.rdx;\n+        $dst.rsi = $src.rsi;\n+        $dst.rdi = $src.rdi;\n+        $dst.rbp = $src.rbp;\n+        $dst.rsp = $src.rsp;\n+        $dst.r8 = $src.r8;\n+        $dst.r9 = $src.r9;\n+        $dst.r10 = $src.r10;\n+        $dst.r11 = $src.r11;\n+        $dst.r12 = $src.r12;\n+        $dst.r13 = $src.r13;\n+        $dst.r14 = $src.r14;\n+        $dst.r15 = $src.r15;\n+        $dst.rip = $src.rip;\n+        $dst.rflags = $src.rflags;\n+        $dst.fsbase = $src.fsbase;\n+        $dst.gsbase = $src.gsbase;\n+    };\n+}\n+\n+impl GpRegs {\n+    pub fn copy_to_raw(&self, dst: &mut RawGeneralRegs) {\n+        copy_gp_regs!(self, dst);\n+    }\n+\n+    pub fn copy_from_raw(&mut self, src: &RawGeneralRegs) {\n+        copy_gp_regs!(src, self);\n+    }\n+}\ndiff --git a/kernel/aster-nix/src/fs/exfat/super_block.rs b/kernel/aster-nix/src/fs/exfat/super_block.rs\nindex eb422c463a..78225709c9 100644\n--- a/kernel/aster-nix/src/fs/exfat/super_block.rs\n+++ b/kernel/aster-nix/src/fs/exfat/super_block.rs\n@@ -1,6 +1,6 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-use pod::Pod;\n+use ostd::Pod;\n \n use super::constants::{EXFAT_FIRST_CLUSTER, EXFAT_RESERVED_CLUSTERS, MEDIA_FAILURE, VOLUME_DIRTY};\n use crate::prelude::*;\ndiff --git a/kernel/aster-nix/src/prelude.rs b/kernel/aster-nix/src/prelude.rs\nindex 701b8ed91d..dfff76268f 100644\n--- a/kernel/aster-nix/src/prelude.rs\n+++ b/kernel/aster-nix/src/prelude.rs\n@@ -19,8 +19,8 @@ pub(crate) use log::{debug, error, info, log_enabled, trace, warn};\n pub(crate) use ostd::{\n     mm::{Vaddr, VmReader, VmWriter, PAGE_SIZE},\n     sync::{Mutex, MutexGuard, RwLock, RwMutex, SpinLock, SpinLockGuard},\n+    Pod,\n };\n-pub(crate) use pod::Pod;\n \n /// return current process\n #[macro_export]\ndiff --git a/kernel/aster-nix/src/process/signal/c_types.rs b/kernel/aster-nix/src/process/signal/c_types.rs\nindex b2f39c9c45..5981cd165f 100644\n--- a/kernel/aster-nix/src/process/signal/c_types.rs\n+++ b/kernel/aster-nix/src/process/signal/c_types.rs\n@@ -6,10 +6,10 @@\n use core::mem::{self, size_of};\n \n use aster_util::{read_union_fields, union_read_ptr::UnionReadPtr};\n-use ostd::cpu::GeneralRegs;\n \n use super::sig_num::SigNum;\n use crate::{\n+    arch::cpu::GpRegs,\n     prelude::*,\n     process::{Pid, Uid},\n };\n@@ -206,7 +206,7 @@ pub struct mcontext_t {\n #[derive(Debug, Clone, Copy, Pod, Default)]\n #[repr(C)]\n pub struct SignalCpuContext {\n-    pub gp_regs: GeneralRegs,\n+    pub gp_regs: GpRegs,\n     pub fpregs_on_heap: u64,\n     pub fpregs: Vaddr, // *mut FpRegs,\n }\ndiff --git a/kernel/aster-nix/src/process/signal/mod.rs b/kernel/aster-nix/src/process/signal/mod.rs\nindex aba58e03ac..38a727a35a 100644\n--- a/kernel/aster-nix/src/process/signal/mod.rs\n+++ b/kernel/aster-nix/src/process/signal/mod.rs\n@@ -166,7 +166,11 @@ pub fn handle_user_signal(\n         uc_sigmask: mask.as_u64(),\n         ..Default::default()\n     };\n-    ucontext.uc_mcontext.inner.gp_regs = *context.general_regs();\n+    ucontext\n+        .uc_mcontext\n+        .inner\n+        .gp_regs\n+        .copy_from_raw(context.general_regs());\n     let mut sig_context = posix_thread.sig_context().lock();\n     if let Some(sig_context_addr) = *sig_context {\n         ucontext.uc_link = sig_context_addr;\ndiff --git a/kernel/aster-nix/src/syscall/rt_sigreturn.rs b/kernel/aster-nix/src/syscall/rt_sigreturn.rs\nindex a25258bba9..bd45365f9f 100644\n--- a/kernel/aster-nix/src/syscall/rt_sigreturn.rs\n+++ b/kernel/aster-nix/src/syscall/rt_sigreturn.rs\n@@ -38,7 +38,11 @@ pub fn sys_rt_sigreturn(context: &mut UserContext) -> Result<SyscallReturn> {\n     } else {\n         *sig_context = Some(ucontext.uc_link);\n     };\n-    *context.general_regs_mut() = ucontext.uc_mcontext.inner.gp_regs;\n+    ucontext\n+        .uc_mcontext\n+        .inner\n+        .gp_regs\n+        .copy_to_raw(context.general_regs_mut());\n     // unblock sig mask\n     let sig_mask = ucontext.uc_sigmask;\n     posix_thread.sig_mask().lock().unblock(sig_mask);\ndiff --git a/kernel/aster-nix/src/vdso.rs b/kernel/aster-nix/src/vdso.rs\nindex 1db2adbc7c..c1f9b70134 100644\n--- a/kernel/aster-nix/src/vdso.rs\n+++ b/kernel/aster-nix/src/vdso.rs\n@@ -23,8 +23,8 @@ use aster_util::coeff::Coeff;\n use ostd::{\n     mm::{Frame, VmIo, PAGE_SIZE},\n     sync::SpinLock,\n+    Pod,\n };\n-use pod::Pod;\n use spin::Once;\n \n use crate::{\ndiff --git a/kernel/comps/block/Cargo.toml b/kernel/comps/block/Cargo.toml\nindex 95af96b158..e0c8770f6b 100644\n--- a/kernel/comps/block/Cargo.toml\n+++ b/kernel/comps/block/Cargo.toml\n@@ -8,7 +8,6 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n ostd = { path = \"../../../ostd\" }\n align_ext = { path = \"../../../ostd/libs/align_ext\" }\n aster-util = { path = \"../../libs/aster-util\" }\ndiff --git a/kernel/comps/block/src/id.rs b/kernel/comps/block/src/id.rs\nindex 300817379d..6065f2397c 100644\n--- a/kernel/comps/block/src/id.rs\n+++ b/kernel/comps/block/src/id.rs\n@@ -5,7 +5,7 @@ use core::{\n     ops::{Add, Sub},\n };\n \n-use pod::Pod;\n+use ostd::Pod;\n use static_assertions::const_assert;\n \n /// The block index used in the filesystem.\ndiff --git a/kernel/comps/network/Cargo.toml b/kernel/comps/network/Cargo.toml\nindex 1da353f3d4..f57c9d2052 100644\n--- a/kernel/comps/network/Cargo.toml\n+++ b/kernel/comps/network/Cargo.toml\n@@ -15,7 +15,6 @@ component = { path = \"../../libs/comp-sys/component\" }\n int-to-c-enum = { path = \"../../libs/int-to-c-enum\" }\n log = \"0.4\"\n ostd = { path = \"../../../ostd\" }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n smoltcp = { version = \"0.9.1\", default-features = false, features = [\"alloc\", \"log\", \"medium-ethernet\", \"medium-ip\", \"proto-dhcpv4\", \"proto-ipv4\", \"proto-igmp\", \"socket-icmp\", \"socket-udp\", \"socket-tcp\", \"socket-raw\", \"socket-dhcpv4\"] }\n spin = \"0.9.4\"\ndiff --git a/kernel/comps/network/src/buffer.rs b/kernel/comps/network/src/buffer.rs\nindex c4fd2204c8..845fc26b28 100644\n--- a/kernel/comps/network/src/buffer.rs\n+++ b/kernel/comps/network/src/buffer.rs\n@@ -8,8 +8,8 @@ use ostd::{\n         Daddr, DmaDirection, DmaStream, FrameAllocOptions, HasDaddr, VmReader, VmWriter, PAGE_SIZE,\n     },\n     sync::SpinLock,\n+    Pod,\n };\n-use pod::Pod;\n use spin::Once;\n \n use crate::dma_pool::{DmaPool, DmaSegment};\ndiff --git a/kernel/comps/network/src/lib.rs b/kernel/comps/network/src/lib.rs\nindex 5c19dfa882..e5378f1248 100644\n--- a/kernel/comps/network/src/lib.rs\n+++ b/kernel/comps/network/src/lib.rs\n@@ -15,11 +15,10 @@ extern crate alloc;\n use alloc::{collections::BTreeMap, string::String, sync::Arc, vec::Vec};\n use core::{any::Any, fmt::Debug};\n \n-use aster_util::safe_ptr::Pod;\n pub use buffer::{RxBuffer, TxBuffer, RX_BUFFER_POOL, TX_BUFFER_POOL};\n use component::{init_component, ComponentInitError};\n pub use dma_pool::DmaSegment;\n-use ostd::sync::SpinLock;\n+use ostd::{sync::SpinLock, Pod};\n use smoltcp::phy;\n use spin::Once;\n \ndiff --git a/kernel/comps/virtio/Cargo.toml b/kernel/comps/virtio/Cargo.toml\nindex 9763a7738e..3347c8c8b8 100644\n--- a/kernel/comps/virtio/Cargo.toml\n+++ b/kernel/comps/virtio/Cargo.toml\n@@ -19,7 +19,6 @@ aster-rights = { path = \"../../libs/aster-rights\" }\n id-alloc = { path = \"../../../ostd/libs/id-alloc\" }\n typeflags-util = { path = \"../../libs/typeflags-util\" }\n ostd = { path = \"../../../ostd\" }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n bit_field = \"0.10.1\"\ndiff --git a/kernel/comps/virtio/src/device/block/device.rs b/kernel/comps/virtio/src/device/block/device.rs\nindex fce5c64e60..8c28d23146 100644\n--- a/kernel/comps/virtio/src/device/block/device.rs\n+++ b/kernel/comps/virtio/src/device/block/device.rs\n@@ -15,8 +15,8 @@ use ostd::{\n     mm::{DmaDirection, DmaStream, DmaStreamSlice, FrameAllocOptions, VmIo},\n     sync::SpinLock,\n     trap::TrapFrame,\n+    Pod,\n };\n-use pod::Pod;\n \n use super::{BlockFeatures, VirtioBlockConfig};\n use crate::{\ndiff --git a/kernel/comps/virtio/src/device/block/mod.rs b/kernel/comps/virtio/src/device/block/mod.rs\nindex 18faf8a184..e0970a8051 100644\n--- a/kernel/comps/virtio/src/device/block/mod.rs\n+++ b/kernel/comps/virtio/src/device/block/mod.rs\n@@ -5,8 +5,7 @@ pub mod device;\n use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/console/config.rs b/kernel/comps/virtio/src/device/console/config.rs\nindex 05d24ef1cb..49079e2747 100644\n--- a/kernel/comps/virtio/src/device/console/config.rs\n+++ b/kernel/comps/virtio/src/device/console/config.rs\n@@ -1,8 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use aster_util::safe_ptr::SafePtr;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/input/mod.rs b/kernel/comps/virtio/src/device/input/mod.rs\nindex e42a53e985..2823eaee18 100644\n--- a/kernel/comps/virtio/src/device/input/mod.rs\n+++ b/kernel/comps/virtio/src/device/input/mod.rs\n@@ -28,8 +28,7 @@\n \n pub mod device;\n use aster_util::safe_ptr::SafePtr;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/network/config.rs b/kernel/comps/virtio/src/device/network/config.rs\nindex aa2fe3874b..278d89265e 100644\n--- a/kernel/comps/virtio/src/device/network/config.rs\n+++ b/kernel/comps/virtio/src/device/network/config.rs\n@@ -3,8 +3,7 @@\n use aster_network::EthernetAddr;\n use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/network/header.rs b/kernel/comps/virtio/src/device/network/header.rs\nindex 2294fbb0ec..ca888a8cd2 100644\n--- a/kernel/comps/virtio/src/device/network/header.rs\n+++ b/kernel/comps/virtio/src/device/network/header.rs\n@@ -2,7 +2,7 @@\n \n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n-use pod::Pod;\n+use ostd::Pod;\n \n pub const VIRTIO_NET_HDR_LEN: usize = core::mem::size_of::<VirtioNetHdr>();\n \ndiff --git a/kernel/comps/virtio/src/device/socket/config.rs b/kernel/comps/virtio/src/device/socket/config.rs\nindex 8c1331f7b1..f2ce56f1d3 100644\n--- a/kernel/comps/virtio/src/device/socket/config.rs\n+++ b/kernel/comps/virtio/src/device/socket/config.rs\n@@ -2,8 +2,7 @@\n \n use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use crate::transport::VirtioTransport;\n \ndiff --git a/kernel/comps/virtio/src/device/socket/device.rs b/kernel/comps/virtio/src/device/socket/device.rs\nindex 3536c20c50..44fbc9a7fb 100644\n--- a/kernel/comps/virtio/src/device/socket/device.rs\n+++ b/kernel/comps/virtio/src/device/socket/device.rs\n@@ -6,8 +6,7 @@ use core::{fmt::Debug, hint::spin_loop, mem::size_of};\n use aster_network::{RxBuffer, TxBuffer};\n use aster_util::{field_ptr, slot_vec::SlotVec};\n use log::debug;\n-use ostd::{mm::VmWriter, offset_of, sync::SpinLock, trap::TrapFrame};\n-use pod::Pod;\n+use ostd::{mm::VmWriter, offset_of, sync::SpinLock, trap::TrapFrame, Pod};\n \n use super::{\n     config::{VirtioVsockConfig, VsockFeatures},\ndiff --git a/kernel/comps/virtio/src/device/socket/header.rs b/kernel/comps/virtio/src/device/socket/header.rs\nindex d66f37a6df..339e60c66b 100644\n--- a/kernel/comps/virtio/src/device/socket/header.rs\n+++ b/kernel/comps/virtio/src/device/socket/header.rs\n@@ -27,7 +27,7 @@\n //\n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n-use pod::Pod;\n+use ostd::Pod;\n \n use super::error::{self, SocketError};\n \ndiff --git a/kernel/comps/virtio/src/queue.rs b/kernel/comps/virtio/src/queue.rs\nindex c8a167668f..4a45f4a2bd 100644\n--- a/kernel/comps/virtio/src/queue.rs\n+++ b/kernel/comps/virtio/src/queue.rs\n@@ -15,9 +15,8 @@ use log::debug;\n use ostd::{\n     io_mem::IoMem,\n     mm::{DmaCoherent, FrameAllocOptions},\n-    offset_of,\n+    offset_of, Pod,\n };\n-use pod::Pod;\n \n use crate::{dma_buf::DmaBuf, transport::VirtioTransport};\n \ndiff --git a/kernel/comps/virtio/src/transport/mmio/layout.rs b/kernel/comps/virtio/src/transport/mmio/layout.rs\nindex 71bf7a2391..a6b601ee08 100644\n--- a/kernel/comps/virtio/src/transport/mmio/layout.rs\n+++ b/kernel/comps/virtio/src/transport/mmio/layout.rs\n@@ -2,7 +2,7 @@\n \n use core::fmt::Debug;\n \n-use pod::Pod;\n+use ostd::Pod;\n \n #[derive(Clone, Copy, Pod)]\n #[repr(C)]\ndiff --git a/kernel/comps/virtio/src/transport/pci/common_cfg.rs b/kernel/comps/virtio/src/transport/pci/common_cfg.rs\nindex a6e8b2e292..a3b022ba05 100644\n--- a/kernel/comps/virtio/src/transport/pci/common_cfg.rs\n+++ b/kernel/comps/virtio/src/transport/pci/common_cfg.rs\n@@ -1,8 +1,7 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use aster_util::safe_ptr::SafePtr;\n-use ostd::io_mem::IoMem;\n-use pod::Pod;\n+use ostd::{io_mem::IoMem, Pod};\n \n use super::capability::VirtioPciCapabilityData;\n use crate::transport::pci::capability::VirtioPciCpabilityType;\ndiff --git a/kernel/libs/aster-util/Cargo.toml b/kernel/libs/aster-util/Cargo.toml\nindex 321d5a74a0..7b6454e016 100644\n--- a/kernel/libs/aster-util/Cargo.toml\n+++ b/kernel/libs/aster-util/Cargo.toml\n@@ -7,7 +7,6 @@ edition = \"2021\"\n \n [dependencies]\n ostd = { path = \"../../../ostd\" }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n typeflags-util = { path = \"../typeflags-util\" }\n aster-rights-proc = { path = \"../aster-rights-proc\" }\n aster-rights = { path = \"../aster-rights\" }\ndiff --git a/kernel/libs/aster-util/src/safe_ptr.rs b/kernel/libs/aster-util/src/safe_ptr.rs\nindex dd9bde819f..0444a9f5d4 100644\n--- a/kernel/libs/aster-util/src/safe_ptr.rs\n+++ b/kernel/libs/aster-util/src/safe_ptr.rs\n@@ -5,11 +5,11 @@ use core::{fmt::Debug, marker::PhantomData};\n use aster_rights::{Dup, Exec, Full, Read, Signal, TRightSet, TRights, Write};\n use aster_rights_proc::require;\n use inherit_methods_macro::inherit_methods;\n+pub use ostd::Pod;\n use ostd::{\n     mm::{Daddr, DmaStream, HasDaddr, HasPaddr, Paddr, VmIo},\n     Result,\n };\n-pub use pod::Pod;\n pub use typeflags_util::SetContain;\n \n /// Safe pointers.\ndiff --git a/kernel/libs/aster-util/src/union_read_ptr.rs b/kernel/libs/aster-util/src/union_read_ptr.rs\nindex 3e811630c0..30d3b2e538 100644\n--- a/kernel/libs/aster-util/src/union_read_ptr.rs\n+++ b/kernel/libs/aster-util/src/union_read_ptr.rs\n@@ -2,7 +2,7 @@\n \n use core::marker::PhantomData;\n \n-use pod::Pod;\n+use ostd::Pod;\n \n /// This ptr is designed to read union field safely.\n /// Write to union field is safe operation. While reading union field is UB.\ndiff --git a/kernel/libs/int-to-c-enum/Cargo.toml b/kernel/libs/int-to-c-enum/Cargo.toml\nindex 09656d0c60..98443d32f8 100644\n--- a/kernel/libs/int-to-c-enum/Cargo.toml\n+++ b/kernel/libs/int-to-c-enum/Cargo.toml\n@@ -2,11 +2,15 @@\n name = \"int-to-c-enum\"\n version = \"0.1.0\"\n edition = \"2021\"\n+license = \"MPL-2.0\"\n+readme = \"README.md\"\n+description = \"TryFromInt - A convenient derive macro for converting an integer to an enum\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-int-to-c-enum-derive = { path = \"derive\", optional = true }\n+int-to-c-enum-derive = { path = \"derive\", optional = true, version = \"0.1.0\"}\n \n [features]\n default = [\"derive\"]\ndiff --git a/kernel/libs/int-to-c-enum/derive/Cargo.toml b/kernel/libs/int-to-c-enum/derive/Cargo.toml\nindex c235a57aa7..badab5b61a 100644\n--- a/kernel/libs/int-to-c-enum/derive/Cargo.toml\n+++ b/kernel/libs/int-to-c-enum/derive/Cargo.toml\n@@ -2,6 +2,9 @@\n name = \"int-to-c-enum-derive\"\n version = \"0.1.0\"\n edition = \"2021\"\n+license = \"MPL-2.0\"\n+description = \"int-to-c-enum's proc macros\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\nindex 977ade064e..f0dda6359f 100644\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -157,10 +157,9 @@ fn install_setup_with_arch(\n     cmd.arg(\"install\").arg(\"linux-bzimage-setup\");\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\n-    cmd.arg(\"--git\").arg(crate::util::ASTER_GIT_LINK);\n-    // FIXME: Uses a fixed tag instaed of relies on remote branch\n-    cmd.arg(\"--tag\").arg(\"v0.5.1\");\n-    // cmd.arg(\"--tag\").arg(crate::util::ASTER_GIT_TAG);\n+    // Remember to upgrade this version if new version of linux-bzimage-setup is released.\n+    const LINUX_BZIMAGE_SETUP_VERSION: &str = \"0.1.0\";\n+    cmd.arg(\"--version\").arg(LINUX_BZIMAGE_SETUP_VERSION);\n     cmd.arg(\"--target\").arg(match arch {\n         SetupInstallArch::X86_64 => \"x86_64-unknown-none\",\n         SetupInstallArch::Other(path) => path.to_str().unwrap(),\ndiff --git a/osdk/src/commands/new/mod.rs b/osdk/src/commands/new/mod.rs\nindex bc321cd7f8..1c5c386004 100644\n--- a/osdk/src/commands/new/mod.rs\n+++ b/osdk/src/commands/new/mod.rs\n@@ -7,7 +7,7 @@ use crate::{\n     config::manifest::ProjectType,\n     error::Errno,\n     error_msg,\n-    util::{aster_crate_dep, cargo_new_lib, get_cargo_metadata},\n+    util::{cargo_new_lib, get_cargo_metadata, ostd_dep},\n };\n \n pub fn execute_new_command(args: &NewArgs) {\n@@ -40,7 +40,7 @@ fn add_manifest_dependencies(cargo_metadata: &serde_json::Value, crate_name: &st\n \n     let dependencies = manifest.get_mut(\"dependencies\").unwrap();\n \n-    let ostd_dep = toml::Table::from_str(&aster_crate_dep(\"ostd\")).unwrap();\n+    let ostd_dep = toml::Table::from_str(&ostd_dep()).unwrap();\n     dependencies.as_table_mut().unwrap().extend(ostd_dep);\n \n     let content = toml::to_string(&manifest).unwrap();\ndiff --git a/osdk/src/util.rs b/osdk/src/util.rs\nindex 1f1e4b855f..2d629aa63b 100644\n--- a/osdk/src/util.rs\n+++ b/osdk/src/util.rs\n@@ -12,18 +12,12 @@ use crate::{error::Errno, error_msg};\n \n use quote::ToTokens;\n \n-/// FIXME: We should publish the asterinas crates to a public registry\n-/// and use the published version in the generated Cargo.toml.\n-pub const ASTER_GIT_LINK: &str = \"https://github.com/asterinas/asterinas\";\n-/// Make sure it syncs with the builder dependency in Cargo.toml.\n-/// We cannot use `include_str!(\"../../VERSION\")` here\n-/// because `cargo publish` does not allow using files outside of the crate directory.\n-pub const ASTER_GIT_TAG: &str = concat!(\"v\", env!(\"CARGO_PKG_VERSION\"));\n-pub fn aster_crate_dep(crate_name: &str) -> String {\n-    format!(\n-        \"{} = {{ git = \\\"{}\\\", tag = \\\"{}\\\" }}\",\n-        crate_name, ASTER_GIT_LINK, ASTER_GIT_TAG\n-    )\n+/// The version of OSTD on crates.io.\n+///\n+/// OSTD shares the same version with OSDK, so just use the version of OSDK here.\n+pub const OSTD_VERSION: &str = env!(\"CARGO_PKG_VERSION\");\n+pub fn ostd_dep() -> String {\n+    format!(\"ostd = {{ version = \\\"{}\\\" }}\", OSTD_VERSION)\n }\n \n fn cargo() -> Command {\ndiff --git a/ostd/Cargo.toml b/ostd/Cargo.toml\nindex bacfdf3d6d..b788274f1c 100644\n--- a/ostd/Cargo.toml\n+++ b/ostd/Cargo.toml\n@@ -2,41 +2,48 @@\n name = \"ostd\"\n version = \"0.6.2\"\n edition = \"2021\"\n+description = \"Rust OS framework that facilitates the development of and innovation in OS kernels\"\n+license = \"MPL-2.0\"\n+readme = \"README.md\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n+# Settings for publishing docs in docs.rs\n+[package.metadata.docs.rs]\n+default-target = \"x86_64-unknown-none\"\n+targets = [\"x86_64-unknown-none\"]\n+\n [dependencies]\n-align_ext = { path = \"libs/align_ext\" }\n-ostd-macros = { path = \"libs/ostd-macros\" }\n+align_ext = { path = \"libs/align_ext\", version = \"0.1.0\" }\n+array-init = \"2.0\"\n bit_field = \"0.10.1\"\n+buddy_system_allocator = \"0.9.0\"\n bitflags = \"1.3\"\n bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n-linux-boot-params = { path = \"libs/linux-bzimage/boot-params\" }\n-buddy_system_allocator = \"0.9.0\"\n cfg-if = \"1.0\"\n gimli = { version = \"0.28\", default-features = false, features = [\"read-core\"] }\n-inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\" }\n-xarray = { git = \"https://github.com/asterinas/xarray\", rev = \"72a4067\" }\n-int-to-c-enum = { path = \"../kernel/libs/int-to-c-enum\" }\n-# instrusive-collections of version 0.9.6 fails to compile with current rust toolchain,\n-# So we set a fixed version 0.9.5 for this crate\n-intrusive-collections = { version = \"=0.9.5\", features = [\"nightly\"] }\n-array-init = \"2.0\"\n-ktest = { path = \"libs/ktest\" }\n-id-alloc = { path = \"libs/id-alloc\" }\n+id-alloc = { path = \"libs/id-alloc\", version = \"0.1.0\" }\n+inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\", version = \"0.1.0\" }\n+int-to-c-enum = { path = \"../kernel/libs/int-to-c-enum\", version = \"0.1.0\" }\n+intrusive-collections = { version = \"0.9.6\", features = [\"nightly\"] }\n lazy_static = { version = \"1.0\", features = [\"spin_no_std\"] }\n+linux-boot-params = { path = \"libs/linux-bzimage/boot-params\", version = \"0.1.0\" }\n log = \"0.4\"\n num = { version = \"0.4\", default-features = false }\n num-derive = { version = \"0.4\", default-features = false }\n num-traits = { version = \"0.2\", default-features = false }\n-pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n+ostd-macros = { path = \"libs/ostd-macros\", version = \"0.1.4\" }\n+ostd-test = { path = \"libs/ostd-test\", version = \"0.1.0\" }\n+owo-colors = { version = \"3\", optional = true }\n+ostd-pod = { git = \"https://github.com/asterinas/ostd-pod\", rev = \"c4644be\", version = \"0.1.1\" }\n spin = \"0.9.4\"\n static_assertions = \"1.1.0\"\n tdx-guest = { version = \"0.1.5\", optional = true }\n-trapframe = { git = \"https://github.com/asterinas/trapframe-rs\", rev = \"4739428\" }\n+trapframe = \"0.10.0\"\n unwinding = { version = \"0.2.2\", default-features = false, features = [\"fde-gnu-eh-frame-hdr\", \"hide-trace\", \"panic\", \"personality\", \"unwinder\"] }\n volatile = { version = \"0.4.5\", features = [\"unstable\"] }\n-owo-colors = { version = \"3\", optional = true }\n+xarray = { git = \"https://github.com/asterinas/xarray\", rev = \"72a4067\", version = \"0.1.0\" }\n \n [target.x86_64-unknown-none.dependencies]\n x86_64 = \"0.14.2\"\ndiff --git a/ostd/README.md b/ostd/README.md\nindex fb2d163eda..bbb8c99c72 100644\n--- a/ostd/README.md\n+++ b/ostd/README.md\n@@ -18,12 +18,4 @@ Asterinas OSTD offers the following key values.\n \n ## OSTD APIs\n \n-TODO\n-\n-## Implementation status\n-\n-TODO\n-\n-## Roadmap and plan\n-\n-TODO\n\\ No newline at end of file\n+See [API docs](https://docs.rs/ostd/latest/ostd).\ndiff --git a/ostd/libs/id-alloc/Cargo.toml b/ostd/libs/id-alloc/Cargo.toml\nindex 1ccca34600..6a5bffc1c8 100644\n--- a/ostd/libs/id-alloc/Cargo.toml\n+++ b/ostd/libs/id-alloc/Cargo.toml\n@@ -2,6 +2,9 @@\n name = \"id-alloc\"\n version = \"0.1.0\"\n edition = \"2021\"\n+license = \"MPL-2.0\"\n+description = \"An id allocator implemented by the bitmap\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/ostd/libs/linux-bzimage/boot-params/Cargo.toml b/ostd/libs/linux-bzimage/boot-params/Cargo.toml\nindex 3b4b3459ba..a6942acaf3 100644\n--- a/ostd/libs/linux-bzimage/boot-params/Cargo.toml\n+++ b/ostd/libs/linux-bzimage/boot-params/Cargo.toml\n@@ -2,6 +2,9 @@\n name = \"linux-boot-params\"\n version = \"0.1.0\"\n edition = \"2021\"\n+description = \"The Boot Parameters for Linux Boot Protocol\"\n+license = \"MPL-2.0\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/ostd/libs/linux-bzimage/setup/Cargo.toml b/ostd/libs/linux-bzimage/setup/Cargo.toml\nindex 23b0f633e9..621829afb7 100644\n--- a/ostd/libs/linux-bzimage/setup/Cargo.toml\n+++ b/ostd/libs/linux-bzimage/setup/Cargo.toml\n@@ -2,6 +2,9 @@\n name = \"linux-bzimage-setup\"\n version = \"0.1.0\"\n edition = \"2021\"\n+description = \"The linux bzImage setup binary\"\n+license = \"MPL-2.0\"\n+repository = \"https://github.com/asterinas/asterinas\"\n \n [[bin]]\n name = \"linux-bzimage-setup\"\n@@ -11,7 +14,7 @@ path = \"src/main.rs\"\n \n [dependencies]\n cfg-if = \"1.0.0\"\n-linux-boot-params = { path = \"../boot-params\" }\n+linux-boot-params = { path = \"../boot-params\", version = \"0.1.0\" }\n uart_16550 = \"0.3.0\"\n xmas-elf = \"0.8.0\"\n \ndiff --git a/ostd/libs/ostd-macros/Cargo.toml b/ostd/libs/ostd-macros/Cargo.toml\nindex cc6d9946fb..816b8e0585 100644\n--- a/ostd/libs/ostd-macros/Cargo.toml\n+++ b/ostd/libs/ostd-macros/Cargo.toml\n@@ -1,7 +1,10 @@\n [package]\n name = \"ostd-macros\"\n-version = \"0.1.0\"\n+version = \"0.1.4\"\n edition = \"2021\"\n+description = \"OSTD's proc macros\"\n+license = \"MPL-2.0\"\n+repository =\"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/ostd/libs/ostd-macros/src/lib.rs b/ostd/libs/ostd-macros/src/lib.rs\nindex 3020e43883..93466626b9 100644\n--- a/ostd/libs/ostd-macros/src/lib.rs\n+++ b/ostd/libs/ostd-macros/src/lib.rs\n@@ -11,7 +11,9 @@ use syn::{parse_macro_input, Expr, Ident, ItemFn};\n ///\n /// # Example\n ///\n-/// ```norun\n+/// ```ignore\n+/// #![no_std]\n+///\n /// use ostd::prelude::*;\n ///\n /// #[ostd::main]\n@@ -44,7 +46,7 @@ pub fn main(_attr: TokenStream, item: TokenStream) -> TokenStream {\n /// For crates other than ostd,\n /// this macro can be used in the following form.\n ///\n-/// ```norun\n+/// ```ignore\n /// use ostd::prelude::*;\n ///\n /// #[ktest]\n@@ -56,7 +58,7 @@ pub fn main(_attr: TokenStream, item: TokenStream) -> TokenStream {\n /// For ostd crate itself,\n /// this macro can be used in the form\n ///\n-/// ```norun\n+/// ```ignore\n /// use crate::prelude::*;\n ///\n /// #[ktest]\n@@ -144,10 +146,10 @@ pub fn ktest(_attr: TokenStream, item: TokenStream) -> TokenStream {\n             #[cfg(ktest)]\n             #[used]\n             #[link_section = \".ktest_array\"]\n-            static #fn_ktest_item_name: ktest::KtestItem = ktest::KtestItem::new(\n+            static #fn_ktest_item_name: ostd_test::KtestItem = ostd_test::KtestItem::new(\n                 #fn_name,\n                 (#should_panic, #expectation_tokens),\n-                ktest::KtestItemInfo {\n+                ostd_test::KtestItemInfo {\n                     module_path: module_path!(),\n                     fn_name: stringify!(#fn_name),\n                     package: #package_name,\ndiff --git a/ostd/src/arch/x86/cpu.rs b/ostd/src/arch/x86/cpu.rs\nindex da7beea74d..5fbd567481 100644\n--- a/ostd/src/arch/x86/cpu.rs\n+++ b/ostd/src/arch/x86/cpu.rs\n@@ -16,7 +16,8 @@ use bitvec::{\n use log::debug;\n #[cfg(feature = \"intel_tdx\")]\n use tdx_guest::tdcall;\n-use trapframe::{GeneralRegs, UserContext as RawUserContext};\n+pub use trapframe::GeneralRegs as RawGeneralRegs;\n+use trapframe::UserContext as RawUserContext;\n use x86_64::registers::{\n     rflags::RFlags,\n     segmentation::{Segment64, FS},\n@@ -131,7 +132,7 @@ pub struct CpuExceptionInfo {\n }\n \n #[cfg(feature = \"intel_tdx\")]\n-impl TdxTrapFrame for GeneralRegs {\n+impl TdxTrapFrame for RawGeneralRegs {\n     fn rax(&self) -> usize {\n         self.rax\n     }\n@@ -258,12 +259,12 @@ impl UserPreemption {\n \n impl UserContext {\n     /// Returns a reference to the general registers.\n-    pub fn general_regs(&self) -> &GeneralRegs {\n+    pub fn general_regs(&self) -> &RawGeneralRegs {\n         &self.user_context.general\n     }\n \n     /// Returns a mutable reference to the general registers\n-    pub fn general_regs_mut(&mut self) -> &mut GeneralRegs {\n+    pub fn general_regs_mut(&mut self) -> &mut RawGeneralRegs {\n         &mut self.user_context.general\n     }\n \ndiff --git a/ostd/src/arch/x86/iommu/context_table.rs b/ostd/src/arch/x86/iommu/context_table.rs\nindex 4da92c8d20..ba2fbeb4fe 100644\n--- a/ostd/src/arch/x86/iommu/context_table.rs\n+++ b/ostd/src/arch/x86/iommu/context_table.rs\n@@ -6,7 +6,6 @@ use alloc::collections::BTreeMap;\n use core::mem::size_of;\n \n use log::warn;\n-use pod::Pod;\n \n use super::second_stage::{DeviceMode, PageTableEntry, PagingConsts};\n use crate::{\n@@ -17,6 +16,7 @@ use crate::{\n         page_table::PageTableError,\n         Frame, FrameAllocOptions, Paddr, PageFlags, PageTable, VmIo, PAGE_SIZE,\n     },\n+    Pod,\n };\n \n /// Bit 0 is `Present` bit, indicating whether this entry is present.\ndiff --git a/ostd/src/arch/x86/iommu/second_stage.rs b/ostd/src/arch/x86/iommu/second_stage.rs\nindex 521db1a092..907b770f14 100644\n--- a/ostd/src/arch/x86/iommu/second_stage.rs\n+++ b/ostd/src/arch/x86/iommu/second_stage.rs\n@@ -4,12 +4,13 @@\n \n use core::ops::Range;\n \n-use pod::Pod;\n-\n-use crate::mm::{\n-    page_prop::{CachePolicy, PageFlags, PrivilegedPageFlags as PrivFlags},\n-    page_table::{PageTableEntryTrait, PageTableMode},\n-    Paddr, PageProperty, PagingConstsTrait, PagingLevel, Vaddr,\n+use crate::{\n+    mm::{\n+        page_prop::{CachePolicy, PageFlags, PrivilegedPageFlags as PrivFlags},\n+        page_table::{PageTableEntryTrait, PageTableMode},\n+        Paddr, PageProperty, PagingConstsTrait, PagingLevel, Vaddr,\n+    },\n+    Pod,\n };\n \n /// The page table used by iommu maps the device address\ndiff --git a/ostd/src/arch/x86/mm/mod.rs b/ostd/src/arch/x86/mm/mod.rs\nindex 93d38baf7e..774a61deed 100644\n--- a/ostd/src/arch/x86/mm/mod.rs\n+++ b/ostd/src/arch/x86/mm/mod.rs\n@@ -5,14 +5,16 @@\n use alloc::fmt;\n use core::ops::Range;\n \n-use pod::Pod;\n pub(crate) use util::__memcpy_fallible;\n use x86_64::{instructions::tlb, structures::paging::PhysFrame, VirtAddr};\n \n-use crate::mm::{\n-    page_prop::{CachePolicy, PageFlags, PageProperty, PrivilegedPageFlags as PrivFlags},\n-    page_table::PageTableEntryTrait,\n-    Paddr, PagingConstsTrait, PagingLevel, Vaddr, PAGE_SIZE,\n+use crate::{\n+    mm::{\n+        page_prop::{CachePolicy, PageFlags, PageProperty, PrivilegedPageFlags as PrivFlags},\n+        page_table::PageTableEntryTrait,\n+        Paddr, PagingConstsTrait, PagingLevel, Vaddr, PAGE_SIZE,\n+    },\n+    Pod,\n };\n \n mod util;\ndiff --git a/ostd/src/boot/mod.rs b/ostd/src/boot/mod.rs\nindex 669e5fda0c..7604f9035b 100644\n--- a/ostd/src/boot/mod.rs\n+++ b/ostd/src/boot/mod.rs\n@@ -156,7 +156,7 @@ fn run_ktests(test_whitelist: Option<&[&str]>, crate_whitelist: Option<&[&str]>)\n     let fn_catch_unwind = &(unwinding::panic::catch_unwind::<(), fn()>\n         as fn(fn()) -> Result<(), Box<(dyn Any + Send + 'static)>>);\n \n-    use ktest::runner::{run_ktests, KtestResult};\n+    use ostd_test::runner::{run_ktests, KtestResult};\n     match run_ktests(\n         &crate::console::early_print,\n         fn_catch_unwind,\ndiff --git a/ostd/src/cpu/mod.rs b/ostd/src/cpu/mod.rs\nindex 63f84e9fa2..76f7d3032c 100644\n--- a/ostd/src/cpu/mod.rs\n+++ b/ostd/src/cpu/mod.rs\n@@ -6,7 +6,6 @@ pub mod cpu_local;\n \n cfg_if::cfg_if! {\n     if #[cfg(target_arch = \"x86_64\")]{\n-        pub use trapframe::GeneralRegs;\n         pub use crate::arch::x86::cpu::*;\n     }\n }\ndiff --git a/ostd/src/io_mem.rs b/ostd/src/io_mem.rs\nindex 249204fecb..9a17cd4310 100644\n--- a/ostd/src/io_mem.rs\n+++ b/ostd/src/io_mem.rs\n@@ -4,11 +4,9 @@\n \n use core::{mem::size_of, ops::Range};\n \n-use pod::Pod;\n-\n use crate::{\n     mm::{kspace::LINEAR_MAPPING_BASE_VADDR, paddr_to_vaddr, HasPaddr, Paddr, Vaddr, VmIo},\n-    Error, Result,\n+    Error, Pod, Result,\n };\n \n /// I/O memory.\ndiff --git a/ostd/src/lib.rs b/ostd/src/lib.rs\nindex e4db96a25a..abc7e57733 100644\n--- a/ostd/src/lib.rs\n+++ b/ostd/src/lib.rs\n@@ -44,6 +44,7 @@ pub mod trap;\n pub mod user;\n \n pub use ostd_macros::main;\n+pub use ostd_pod::Pod;\n \n pub use self::{cpu::cpu_local::CpuLocal, error::Error, prelude::Result};\n \n@@ -123,5 +124,5 @@ mod test {\n /// The module re-exports everything from the ktest crate\n #[cfg(ktest)]\n pub mod ktest {\n-    pub use ktest::*;\n+    pub use ostd_test::*;\n }\ndiff --git a/ostd/src/mm/io.rs b/ostd/src/mm/io.rs\nindex 869315d752..e923f5d027 100644\n--- a/ostd/src/mm/io.rs\n+++ b/ostd/src/mm/io.rs\n@@ -6,7 +6,6 @@ use core::marker::PhantomData;\n \n use align_ext::AlignExt;\n use inherit_methods_macro::inherit_methods;\n-use pod::Pod;\n \n use crate::{\n     arch::mm::__memcpy_fallible,\n@@ -15,7 +14,7 @@ use crate::{\n         MAX_USERSPACE_VADDR,\n     },\n     prelude::*,\n-    Error,\n+    Error, Pod,\n };\n \n /// A trait that enables reading/writing data from/to a VM object,\ndiff --git a/ostd/src/mm/page_table/mod.rs b/ostd/src/mm/page_table/mod.rs\nindex 0fc7487dc7..3b68869290 100644\n--- a/ostd/src/mm/page_table/mod.rs\n+++ b/ostd/src/mm/page_table/mod.rs\n@@ -2,14 +2,15 @@\n \n use core::{fmt::Debug, marker::PhantomData, ops::Range};\n \n-use pod::Pod;\n-\n use super::{\n     nr_subpage_per_huge, paddr_to_vaddr,\n     page_prop::{PageFlags, PageProperty},\n     page_size, Paddr, PagingConstsTrait, PagingLevel, Vaddr,\n };\n-use crate::arch::mm::{PageTableEntry, PagingConsts};\n+use crate::{\n+    arch::mm::{PageTableEntry, PagingConsts},\n+    Pod,\n+};\n \n mod node;\n use node::*;\ndiff --git a/ostd/src/panicking.rs b/ostd/src/panicking.rs\nindex bb24724039..d9e4cb1fbc 100644\n--- a/ostd/src/panicking.rs\n+++ b/ostd/src/panicking.rs\n@@ -29,7 +29,7 @@ use unwinding::{\n /// panic handler in the binary crate.\n #[export_name = \"__aster_panic_handler\"]\n pub fn panic_handler(info: &core::panic::PanicInfo) -> ! {\n-    let throw_info = ktest::PanicInfo {\n+    let throw_info = ostd_test::PanicInfo {\n         message: info.message().to_string(),\n         file: info.location().unwrap().file().to_string(),\n         line: info.location().unwrap().line() as usize,\ndiff --git a/ostd/src/sync/atomic_bits.rs b/ostd/src/sync/atomic_bits.rs\nindex a5fe3dfd0a..1b92799e81 100644\n--- a/ostd/src/sync/atomic_bits.rs\n+++ b/ostd/src/sync/atomic_bits.rs\n@@ -293,7 +293,6 @@ impl fmt::Debug for AtomicBits {\n #[cfg(ktest)]\n mod test {\n     use super::*;\n-    use crate::prelude::*;\n \n     #[ktest]\n     fn new() {\n", "test_patch": "diff --git a/osdk/tests/util/mod.rs b/osdk/tests/util/mod.rs\nindex 98ac7b614c..4f947ba48c 100644\n--- a/osdk/tests/util/mod.rs\n+++ b/osdk/tests/util/mod.rs\n@@ -88,7 +88,7 @@ pub fn add_member_to_workspace(workspace: impl AsRef<Path>, new_member: &str) {\n }\n \n /// Makes crates created by `cargo ostd new` depends on ostd locally,\n-/// instead of ostd from local branch.\n+/// instead of ostd from remote source(git repo/crates.io).\n ///\n /// Each crate created by `cargo ostd new` should add this patch.\n pub fn depends_on_local_ostd(manifest_path: impl AsRef<Path>) {\ndiff --git a/ostd/libs/ktest/Cargo.toml b/ostd/libs/ostd-test/Cargo.toml\nsimilarity index 54%\nrename from ostd/libs/ktest/Cargo.toml\nrename to ostd/libs/ostd-test/Cargo.toml\nindex db397f1ada..82d4bcacf7 100644\n--- a/ostd/libs/ktest/Cargo.toml\n+++ b/ostd/libs/ostd-test/Cargo.toml\n@@ -1,7 +1,10 @@\n [package]\n-name = \"ktest\"\n+name = \"ostd-test\"\n version = \"0.1.0\"\n edition = \"2021\"\n+description = \"The kernel mode testing framework of OSTD\"\n+license = \"MPL-2.0\"\n+repository =\"https://github.com/asterinas/asterinas\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \ndiff --git a/ostd/libs/ktest/src/lib.rs b/ostd/libs/ostd-test/src/lib.rs\nsimilarity index 92%\nrename from ostd/libs/ktest/src/lib.rs\nrename to ostd/libs/ostd-test/src/lib.rs\nindex f193a7ac6f..94e2207f16 100644\n--- a/ostd/libs/ktest/src/lib.rs\n+++ b/ostd/libs/ostd-test/src/lib.rs\n@@ -1,20 +1,20 @@\n // SPDX-License-Identifier: MPL-2.0\n \n-//! # The kernel mode testing framework of Asterinas.\n+//! # The kernel mode testing framework of OSTD.\n //!\n-//! `ktest` stands for kernel-mode testing framework. Its goal is to provide a\n+//! `ostd-test` stands for kernel-mode testing framework for OSTD. Its goal is to provide a\n //! `cargo test`-like experience for any `#![no_std]` bare metal crates.\n //!\n-//! In Asterinas, all the tests written in the source tree of the crates will be run\n+//! In OSTD, all the tests written in the source tree of the crates will be run\n //! immediately after the initialization of `ostd`. Thus you can use any\n //! feature provided by the frame including the heap allocator, etc.\n //!\n-//! By all means, ktest is an individule crate that only requires:\n+//! By all means, ostd-test is an individule crate that only requires:\n //!  - a custom linker script section `.ktest_array`,\n //!  - and an alloc implementation.\n //!\n-//! And the frame happens to provide both of them. Thus, any crates depending\n-//! on the frame can use ktest without any extra dependency.\n+//! And the OSTD happens to provide both of them. Thus, any crates depending\n+//! on the OSTD can use ostd-test without any extra dependency.\n //!\n //! ## Usage\n //!\n@@ -43,7 +43,7 @@\n //! }\n //! ```\n //!\n-//! Any crates using the ktest framework should be linked with ostd.\n+//! Any crates using the ostd-test framework should be linked with ostd.\n //!\n //! ```toml\n //! # Cargo.toml\ndiff --git a/ostd/libs/ktest/src/path.rs b/ostd/libs/ostd-test/src/path.rs\nsimilarity index 100%\nrename from ostd/libs/ktest/src/path.rs\nrename to ostd/libs/ostd-test/src/path.rs\ndiff --git a/ostd/libs/ktest/src/runner.rs b/ostd/libs/ostd-test/src/runner.rs\nsimilarity index 100%\nrename from ostd/libs/ktest/src/runner.rs\nrename to ostd/libs/ostd-test/src/runner.rs\ndiff --git a/ostd/libs/ktest/src/tree.rs b/ostd/libs/ostd-test/src/tree.rs\nsimilarity index 100%\nrename from ostd/libs/ktest/src/tree.rs\nrename to ostd/libs/ostd-test/src/tree.rs\n", "problem_statement": "Tracking issue for publishing OSTD to crates.io\n# Description\r\n\r\nThis issue tracks the issue of publishing OSTD to `crates.io`\r\n\r\n- [x] Publishing all dependent crates of OSTD to `crates.io`\r\n  - [x] align_ext ([v0.1.0](https://crates.io/crates/align_ext))\r\n  - [x] ostd-macros([v0.1.1](https://crates.io/crates/ostd-macros))\r\n  - [x] linux-boot-params([v0.1.0](https://crates.io/crates/linux-boot-params))\r\n  - [x] inherit-methods-macro([v0.1.0](https://crates.io/crates/inherit-methods-macro))\r\n  - [x] xarray([v0.1.0](https://crates.io/crates/xarray))\r\n  - [x] int-to-c-enum([v0.1.0](https://crates.io/crates/int-to-c-enum))\r\n  - [x] ktest(renamed as `ostd-test`, [v0.1.0](https://crates.io/crates/ostd-test))\r\n  - [x] id-alloc([v0.1.0](https://crates.io/crates/id-alloc))\r\n  - [x] pod(renamed as `pod-rs`, [v0.1.1](https://crates.io/crates/pod-rs))\r\n  - [x] trapframe([v0.9.0](https://crates.io/crates/trapframe) works, just without our patch to speed)\r\n  - [x] unwinding([v0.2.2](https://crates.io/crates/unwinding) works)\r\n- [x] Publish OSTD itself to `crate.io`\r\n- [x] Publish API documentation of OSTD to `docs.rs`\r\n\r\n\n", "hints_text": "", "created_at": "2024-07-03T08:57:04Z", "version": "0.6"}, {"repo": "asterinas/asterinas", "pull_number": 954, "instance_id": "asterinas__asterinas-954", "issue_numbers": ["871"], "base_commit": "cd2b305fa890bca9c4374ccd83c9ccb24bf8dda3", "patch": "diff --git a/docs/src/ostd/a-100-line-kernel.md b/docs/src/ostd/a-100-line-kernel.md\nindex 3962907a02..7cfa3bed60 100644\n--- a/docs/src/ostd/a-100-line-kernel.md\n+++ b/docs/src/ostd/a-100-line-kernel.md\n@@ -7,23 +7,7 @@ we will show a new kernel in about 100 lines of safe Rust.\n Our new kernel will be able to run the following Hello World program.\n \n ```s\n-.global _start                      # entry point\n-.section .text                      # code section\n-_start:\n-    mov     $1, %rax                # syscall number of write\n-    mov     $1, %rdi                # stdout\n-    mov     $message, %rsi          # address of message         \n-    mov     $message_end, %rdx\n-    sub     %rsi, %rdx              # calculate message len\n-    syscall\n-    mov     $60, %rax               # syscall number of exit, move it to rax\n-    mov     $0, %rdi                # exit code, move it to rdi\n-    syscall  \n-\n-.section .rodata                    # read only data section\n-message:\n-    .ascii  \"Hello, world\\n\"\n-message_end:\n+{{#include ../../../osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/hello.S}}\n ```\n \n The assembly program above can be compiled with the following command.\n@@ -42,131 +26,5 @@ Comments are added\n to highlight how the APIs of Asterinas OSTD enable safe kernel development.\n \n ```rust\n-#![no_std]\n-\n-extern crate alloc;\n-\n-use align_ext::AlignExt;\n-use core::str;\n-\n-use alloc::sync::Arc;\n-use alloc::vec;\n-\n-use ostd::cpu::UserContext;\n-use ostd::prelude::*;\n-use ostd::task::{Task, TaskOptions};\n-use ostd::user::{ReturnReason, UserMode, UserSpace};\n-use ostd::mm::{PageFlags, PAGE_SIZE, Vaddr, FrameAllocOptions, VmIo, VmMapOptions, VmSpace};\n-\n-/// The kernel's boot and initialization process is managed by Asterinas OSTD.\n-/// After the process is done, the kernel's execution environment\n-/// (e.g., stack, heap, tasks) will be ready for use and the entry function\n-/// labeled as `#[ostd::main]` will be called.\n-#[ostd::main]\n-pub fn main() {\n-    let program_binary = include_bytes!(\"../hello_world\");\n-    let user_space = create_user_space(program_binary);\n-    let user_task = create_user_task(Arc::new(user_space));\n-    user_task.run();\n-}\n-\n-fn create_user_space(program: &[u8]) -> UserSpace {\n-    let user_pages = {\n-        let nframes = program.len().align_up(PAGE_SIZE) / PAGE_SIZE;\n-        let vm_frames = FrameAllocOptions::new(nframes).alloc().unwrap();\n-        // Phyiscal memory pages can be only accessed\n-        // via the Frame abstraction.\n-        vm_frames.write_bytes(0, program).unwrap();\n-        vm_frames\n-    };\n-    let user_address_space = {\n-        const MAP_ADDR: Vaddr = 0x0040_0000; // The map addr for statically-linked executable\n-\n-        // The page table of the user space can be\n-        // created and manipulated safely through\n-        // the VmSpace abstraction.\n-        let vm_space = VmSpace::new();\n-        let mut options = VmMapOptions::new();\n-        options.addr(Some(MAP_ADDR)).flags(PageFlags::RWX);\n-        vm_space.map(user_pages, &options).unwrap();\n-        vm_space\n-    };\n-    let user_cpu_state = {\n-        const ENTRY_POINT: Vaddr = 0x0040_1000; // The entry point for statically-linked executable\n-\n-        // The user-space CPU states can be initialized\n-        // to arbitrary values via the UserContext\n-        // abstraction.\n-        let mut user_cpu_state = UserContext::default();\n-        user_cpu_state.set_rip(ENTRY_POINT);\n-        user_cpu_state\n-    };\n-    UserSpace::new(user_address_space, user_cpu_state)\n-}\n-\n-fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n-    fn user_task() {\n-        let current = Task::current();\n-        // Switching between user-kernel space is\n-        // performed via the UserMode abstraction.\n-        let mut user_mode = {\n-            let user_space = current.user_space().unwrap();\n-            UserMode::new(user_space)\n-        };\n-\n-        loop {\n-            // The execute method returns when system\n-            // calls or CPU exceptions occur or some\n-            // events specified by the kernel occur.\n-            let return_reason = user_mode.execute(|| false);\n-\n-            // The CPU registers of the user space\n-            // can be accessed and manipulated via\n-            // the `UserContext` abstraction.\n-            let user_context = user_mode.context_mut();\n-            if ReturnReason::UserSyscall == return_reason {\n-                handle_syscall(user_context, current.user_space().unwrap());\n-            }\n-        }\n-    }\n-\n-    // Kernel tasks are managed by OSTD,\n-    // while scheduling algorithms for them can be\n-    // determined by the users of OSTD.\n-    TaskOptions::new(user_task)\n-        .user_space(Some(user_space))\n-        .data(0)\n-        .build()\n-        .unwrap()\n-}\n-\n-fn handle_syscall(user_context: &mut UserContext, user_space: &UserSpace) {\n-    const SYS_WRITE: usize = 1;\n-    const SYS_EXIT: usize = 60;\n-\n-    match user_context.rax() {\n-        SYS_WRITE => {\n-            // Access the user-space CPU registers safely.\n-            let (_, buf_addr, buf_len) =\n-                (user_context.rdi(), user_context.rsi(), user_context.rdx());\n-            let buf = {\n-                let mut buf = vec![0u8; buf_len];\n-                // Copy data from the user space without\n-                // unsafe pointer dereferencing.\n-                user_space\n-                    .vm_space()\n-                    .read_bytes(buf_addr, &mut buf)\n-                    .unwrap();\n-                buf\n-            };\n-            // Use the console for output safely.\n-            println!(\"{}\", str::from_utf8(&buf).unwrap());\n-            // Manipulate the user-space CPU registers safely.\n-            user_context.set_rax(buf_len);\n-        }\n-        SYS_EXIT => Task::current().exit(),\n-        _ => unimplemented!(),\n-    }\n-}\n+{{#include ../../../osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs}}\n ```\n-\ndiff --git a/osdk/src/commands/build/bin.rs b/osdk/src/commands/build/bin.rs\nindex 4c96985542..977ade064e 100644\n--- a/osdk/src/commands/build/bin.rs\n+++ b/osdk/src/commands/build/bin.rs\n@@ -158,7 +158,9 @@ fn install_setup_with_arch(\n     cmd.arg(\"--force\");\n     cmd.arg(\"--root\").arg(install_dir.as_ref());\n     cmd.arg(\"--git\").arg(crate::util::ASTER_GIT_LINK);\n-    cmd.arg(\"--tag\").arg(crate::util::ASTER_GIT_TAG);\n+    // FIXME: Uses a fixed tag instaed of relies on remote branch\n+    cmd.arg(\"--tag\").arg(\"v0.5.1\");\n+    // cmd.arg(\"--tag\").arg(crate::util::ASTER_GIT_TAG);\n     cmd.arg(\"--target\").arg(match arch {\n         SetupInstallArch::X86_64 => \"x86_64-unknown-none\",\n         SetupInstallArch::Other(path) => path.to_str().unwrap(),\n", "test_patch": "diff --git a/osdk/tests/examples_in_book/mod.rs b/osdk/tests/examples_in_book/mod.rs\nindex 2fa4e61acd..9387dc507a 100644\n--- a/osdk/tests/examples_in_book/mod.rs\n+++ b/osdk/tests/examples_in_book/mod.rs\n@@ -5,3 +5,4 @@\n mod create_os_projects;\n mod test_and_run_projects;\n mod work_in_workspace;\n+mod write_a_kernel_in_100_lines;\ndiff --git a/osdk/tests/examples_in_book/work_in_workspace.rs b/osdk/tests/examples_in_book/work_in_workspace.rs\nindex 676c44d009..3061c071b7 100644\n--- a/osdk/tests/examples_in_book/work_in_workspace.rs\n+++ b/osdk/tests/examples_in_book/work_in_workspace.rs\n@@ -1,7 +1,6 @@\n // SPDX-License-Identifier: MPL-2.0\n \n use std::{\n-    env,\n     fs::{self, OpenOptions},\n     io::Write,\n     path::PathBuf,\n@@ -21,7 +20,6 @@ fn work_in_workspace() {\n     }\n \n     fs::create_dir_all(&workspace_dir).unwrap();\n-    env::set_current_dir(&workspace_dir).unwrap();\n \n     let workspace_toml = include_str!(\"work_in_workspace_templates/Cargo.toml\");\n     fs::write(workspace_dir.join(\"Cargo.toml\"), workspace_toml).unwrap();\n@@ -29,8 +27,14 @@ fn work_in_workspace() {\n     // Create a kernel project and a library project\n     let kernel = \"myos\";\n     let module = \"mylib\";\n-    cargo_osdk(&[\"new\", \"--kernel\", kernel]).ok().unwrap();\n-    cargo_osdk(&[\"new\", module]).ok().unwrap();\n+    cargo_osdk(&[\"new\", \"--kernel\", kernel])\n+        .current_dir(&workspace_dir)\n+        .ok()\n+        .unwrap();\n+    cargo_osdk(&[\"new\", module])\n+        .current_dir(&workspace_dir)\n+        .ok()\n+        .unwrap();\n \n     // Add a test function to mylib/src/lib.rs\n     let module_src_path = workspace_dir.join(module).join(\"src\").join(\"lib.rs\");\n@@ -75,13 +79,22 @@ fn work_in_workspace() {\n     .unwrap();\n \n     // Run subcommand build & run\n-    cargo_osdk(&[\"build\"]).ok().unwrap();\n-    let output = cargo_osdk(&[\"run\"]).output().unwrap();\n+    cargo_osdk(&[\"build\"])\n+        .current_dir(&workspace_dir)\n+        .ok()\n+        .unwrap();\n+    let output = cargo_osdk(&[\"run\"])\n+        .current_dir(&workspace_dir)\n+        .output()\n+        .unwrap();\n     let stdout = String::from_utf8_lossy(&output.stdout).to_string();\n     assert!(stdout.contains(\"The available memory is\"));\n \n     // Run subcommand test\n-    cargo_osdk(&[\"test\"]).ok().unwrap();\n+    cargo_osdk(&[\"test\"])\n+        .current_dir(&workspace_dir)\n+        .ok()\n+        .unwrap();\n \n     // Remove the directory\n     fs::remove_dir_all(&workspace_dir).unwrap();\ndiff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines.rs\nnew file mode 100644\nindex 0000000000..9c41a6f980\n--- /dev/null\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines.rs\n@@ -0,0 +1,65 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+use std::{fs, path::PathBuf, process::Command};\n+\n+use assert_cmd::output::OutputOkExt;\n+\n+use crate::util::{cargo_osdk, depends_on_local_ostd};\n+\n+#[test]\n+fn write_a_kernel_in_100_lines() {\n+    let workdir = \"/tmp\";\n+    let os_name = \"kernel_in_100_lines\";\n+\n+    let os_dir = PathBuf::from(workdir).join(os_name);\n+\n+    if os_dir.exists() {\n+        fs::remove_dir_all(&os_dir).unwrap()\n+    }\n+\n+    // Creates a new kernel project\n+    cargo_osdk(&[\"new\", \"--kernel\", os_name])\n+        .current_dir(&workdir)\n+        .ok()\n+        .unwrap();\n+\n+    // Depends on local OSTD\n+    let manifest_path = os_dir.join(\"Cargo.toml\");\n+    depends_on_local_ostd(manifest_path);\n+\n+    // Copies the kernel content\n+    let kernel_contents = include_str!(\"write_a_kernel_in_100_lines_templates/lib.rs\");\n+    fs::write(os_dir.join(\"src\").join(\"lib.rs\"), kernel_contents).unwrap();\n+\n+    // Copies and compiles the user program\n+    let user_program_contents = include_str!(\"write_a_kernel_in_100_lines_templates/hello.S\");\n+    fs::write(os_dir.join(\"hello.S\"), user_program_contents).unwrap();\n+    Command::new(\"gcc\")\n+        .args(&[\"-static\", \"-nostdlib\", \"hello.S\", \"-o\", \"hello\"])\n+        .current_dir(&os_dir)\n+        .ok()\n+        .unwrap();\n+\n+    // Adds align ext as the dependency\n+    let file_contents = fs::read_to_string(os_dir.join(\"Cargo.toml\")).unwrap();\n+    let mut manifest: toml::Table = toml::from_str(&file_contents).unwrap();\n+    let dependencies = manifest\n+        .get_mut(\"dependencies\")\n+        .unwrap()\n+        .as_table_mut()\n+        .unwrap();\n+    dependencies.insert(\n+        \"align_ext\".to_string(),\n+        toml::Value::String(\"0.1.0\".to_string()),\n+    );\n+\n+    let new_file_content = manifest.to_string();\n+    fs::write(os_dir.join(\"Cargo.toml\"), new_file_content).unwrap();\n+\n+    // Runs the kernel\n+    let output = cargo_osdk(&[\"run\"]).current_dir(&os_dir).ok().unwrap();\n+    let stdout = std::str::from_utf8(&output.stdout).unwrap();\n+    println!(\"stdout = {}\", stdout);\n+\n+    fs::remove_dir_all(&os_dir).unwrap();\n+}\ndiff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/hello.S b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/hello.S\nnew file mode 100644\nindex 0000000000..140432d095\n--- /dev/null\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/hello.S\n@@ -0,0 +1,19 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n+.global _start                      # entry point\n+.section .text                      # code section\n+_start:\n+    mov     $1, %rax                # syscall number of write\n+    mov     $1, %rdi                # stdout\n+    mov     $message, %rsi          # address of message         \n+    mov     $message_end, %rdx\n+    sub     %rsi, %rdx              # calculate message len\n+    syscall\n+    mov     $60, %rax               # syscall number of exit, move it to rax\n+    mov     $0, %rdi                # exit code, move it to rdi\n+    syscall  \n+\n+.section .rodata                    # read only data section\n+message:\n+    .ascii  \"Hello, world\\n\"\n+message_end:\n\\ No newline at end of file\ndiff --git a/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\nnew file mode 100644\nindex 0000000000..889779f7b7\n--- /dev/null\n+++ b/osdk/tests/examples_in_book/write_a_kernel_in_100_lines_templates/lib.rs\n@@ -0,0 +1,132 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n+#![no_std]\n+\n+extern crate alloc;\n+\n+use align_ext::AlignExt;\n+use core::str;\n+\n+use alloc::sync::Arc;\n+use alloc::vec;\n+\n+use ostd::arch::qemu::{exit_qemu, QemuExitCode};\n+use ostd::cpu::UserContext;\n+use ostd::mm::{\n+    FrameAllocOptions, PageFlags, Vaddr, VmIo, VmMapOptions, VmSpace, VmWriter, PAGE_SIZE,\n+};\n+use ostd::prelude::*;\n+use ostd::task::{Task, TaskOptions};\n+use ostd::user::{ReturnReason, UserMode, UserSpace};\n+\n+/// The kernel's boot and initialization process is managed by OSTD.\n+/// After the process is done, the kernel's execution environment\n+/// (e.g., stack, heap, tasks) will be ready for use and the entry function\n+/// labeled as `#[ostd::main]` will be called.\n+#[ostd::main]\n+pub fn main() {\n+    let program_binary = include_bytes!(\"../hello\");\n+    let user_space = create_user_space(program_binary);\n+    let user_task = create_user_task(Arc::new(user_space));\n+    user_task.run();\n+}\n+\n+fn create_user_space(program: &[u8]) -> UserSpace {\n+    let user_pages = {\n+        let nframes = program.len().align_up(PAGE_SIZE) / PAGE_SIZE;\n+        let vm_frames = FrameAllocOptions::new(nframes).alloc().unwrap();\n+        // Phyiscal memory pages can be only accessed\n+        // via the Frame abstraction.\n+        vm_frames.write_bytes(0, program).unwrap();\n+        vm_frames\n+    };\n+    let user_address_space = {\n+        const MAP_ADDR: Vaddr = 0x0040_0000; // The map addr for statically-linked executable\n+\n+        // The page table of the user space can be\n+        // created and manipulated safely through\n+        // the VmSpace abstraction.\n+        let vm_space = VmSpace::new();\n+        let mut options = VmMapOptions::new();\n+        options.addr(Some(MAP_ADDR)).flags(PageFlags::RWX);\n+        vm_space.map(user_pages, &options).unwrap();\n+        Arc::new(vm_space)\n+    };\n+    let user_cpu_state = {\n+        const ENTRY_POINT: Vaddr = 0x0040_1000; // The entry point for statically-linked executable\n+\n+        // The user-space CPU states can be initialized\n+        // to arbitrary values via the UserContext\n+        // abstraction.\n+        let mut user_cpu_state = UserContext::default();\n+        user_cpu_state.set_rip(ENTRY_POINT);\n+        user_cpu_state\n+    };\n+    UserSpace::new(user_address_space, user_cpu_state)\n+}\n+\n+fn create_user_task(user_space: Arc<UserSpace>) -> Arc<Task> {\n+    fn user_task() {\n+        let current = Task::current();\n+        // Switching between user-kernel space is\n+        // performed via the UserMode abstraction.\n+        let mut user_mode = {\n+            let user_space = current.user_space().unwrap();\n+            UserMode::new(user_space)\n+        };\n+\n+        loop {\n+            // The execute method returns when system\n+            // calls or CPU exceptions occur or some\n+            // events specified by the kernel occur.\n+            let return_reason = user_mode.execute(|| false);\n+\n+            // The CPU registers of the user space\n+            // can be accessed and manipulated via\n+            // the `UserContext` abstraction.\n+            let user_context = user_mode.context_mut();\n+            if ReturnReason::UserSyscall == return_reason {\n+                handle_syscall(user_context, current.user_space().unwrap());\n+            }\n+        }\n+    }\n+\n+    // Kernel tasks are managed by the Framework,\n+    // while scheduling algorithms for them can be\n+    // determined by the users of the Framework.\n+    TaskOptions::new(user_task)\n+        .user_space(Some(user_space))\n+        .data(0)\n+        .build()\n+        .unwrap()\n+}\n+\n+fn handle_syscall(user_context: &mut UserContext, user_space: &UserSpace) {\n+    const SYS_WRITE: usize = 1;\n+    const SYS_EXIT: usize = 60;\n+\n+    match user_context.rax() {\n+        SYS_WRITE => {\n+            // Access the user-space CPU registers safely.\n+            let (_, buf_addr, buf_len) =\n+                (user_context.rdi(), user_context.rsi(), user_context.rdx());\n+            let buf = {\n+                let mut buf = vec![0u8; buf_len];\n+                // Copy data from the user space without\n+                // unsafe pointer dereferencing.\n+                let current_vm_space = user_space.vm_space();\n+                let mut reader = current_vm_space.reader(buf_addr, buf_len).unwrap();\n+                reader\n+                    .read_fallible(&mut VmWriter::from(&mut buf as &mut [u8]))\n+                    .unwrap();\n+                buf\n+            };\n+            // Use the console for output safely.\n+            println!(\"{}\", str::from_utf8(&buf).unwrap());\n+            // Manipulate the user-space CPU registers safely.\n+            user_context.set_rax(buf_len);\n+        }\n+        SYS_EXIT => exit_qemu(QemuExitCode::Success),\n+        _ => unimplemented!(),\n+    }\n+}\n", "problem_statement": "\"[ERROR]: Uncaught panic!\" when running the 100-line kernel example in the asterinas book.\nWhen running the 100-line kernel example in the asterinas book [https://asterinas.github.io/book/framework/a-100-line-kernel.html ](url), the following error is reported:\r\n```\r\nDrive current: -outdev 'stdio:/root/workspace/asterinas/target/osdk/myos-osdk-bin.iso'\r\nMedia current: stdio file, overwriteable\r\nMedia status : is blank\r\nMedia summary: 0 sessions, 0 data blocks, 0 data,  931g free\r\nAdded to ISO image: directory '/'='/tmp/grub.CQmOUp'\r\nxorriso : UPDATE :     341 files added in 1 seconds\r\nAdded to ISO image: directory '/'='/root/workspace/asterinas/target/osdk/iso_root'\r\nxorriso : UPDATE :     346 files added in 1 seconds\r\nxorriso : UPDATE :  0.00% done\r\nBdsDxe: loading Boot0001 \"UEFI QEMU DVD-ROM QM00005 \" from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)\r\nBdsDxe: starting Boot0001 \"UEFI QEMU DVD-ROM QM00005 \" from PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)\r\nWARNING: no console will be available to OS\r\nerror: no suitable video mode found.\r\n[ERROR]: Uncaught panic!\r\npanicked at /root/workspace/asterinas/framework/aster-frame/src/task/scheduler.rs:44:24:\r\ncalled `Option::unwrap()` on a `None` value\r\nprinting stack trace:\r\n   1: fn 0xffffffff8809f660 - pc 0xffffffff8809f678 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047820;\r\n\r\n   2: fn 0xffffffff8809f160 - pc 0xffffffff8809f617 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047830;\r\n\r\n   3: fn 0xffffffff88048030 - pc 0xffffffff8804803a / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047a80;\r\n\r\n   4: fn 0xffffffff8818f4a0 - pc 0xffffffff8818f4ef / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047a90;\r\n\r\n   5: fn 0xffffffff8818f5d0 - pc 0xffffffff8818f615 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047ae0;\r\n\r\n   6: fn 0xffffffff88124fd0 - pc 0xffffffff88125011 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047b50;\r\n\r\n   7: fn 0xffffffff8806efa0 - pc 0xffffffff8806efce / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047b80;\r\n\r\n   8: fn 0xffffffff8806f0c0 - pc 0xffffffff8806f16e / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047bc0;\r\n\r\n   9: fn 0xffffffff8806e450 - pc 0xffffffff8806e462 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047c20;\r\n\r\n  10: fn 0xffffffff880489e0 - pc 0xffffffff88048a30 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047c30;\r\n\r\n  11: fn 0xffffffff880489d0 - pc 0xffffffff880489db / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047f50;\r\n\r\n  12: fn 0xffffffff880a3b00 - pc 0xffffffff880a3b06 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047f60;\r\n\r\n  13: fn 0xffffffff8810d3b0 - pc 0xffffffff8810d477 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88047f70;\r\n\r\n  14: fn                0x0 - pc 0xffffffff880ad052 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a43f0; rcx               0x16; rbx 0xffffffff80000000;\r\n     rsi 0xffffffff881a4358; rdi 0xffffffff880479e8; rbp                0x0; rsp 0xffffffff88048000;\r\n```\n", "hints_text": "It seems that the scheduler is not set. And the guide does not mention that.\r\n\r\n```rust\r\nuse aster_frame::task::{set_scheduler, FifoScheduler, Scheduler};\r\nlet simple_scheduler = Box::new(FifoScheduler::new());\r\nlet static_scheduler: &'static dyn Scheduler = Box::leak(simple_scheduler);\r\nset_scheduler(static_scheduler);\r\n```\r\n\r\nCould you please check if this works? If so you can help us improve the guide!\nThanks. After adding your code into the example, the program runs successfully and outputs \"Hello, world\". However, the below error message follows. Is this normal? \r\n```\r\nWARNING: no console will be available to OS\r\nerror: no suitable video mode found.\r\nHello, world\r\n\r\n[ERROR]: Uncaught panic!\r\npanicked at /root/workspace/asterinas/framework/aster-frame/src/task/task.rs:191:9:\r\ninternal error: entered unreachable code\r\nprinting stack trace:\r\n   1: fn 0xffffffff880a1840 - pc 0xffffffff880a1858 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c06d0;\r\n\r\n   2: fn 0xffffffff880a1340 - pc 0xffffffff880a17f7 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c06e0;\r\n\r\n   3: fn 0xffffffff88048030 - pc 0xffffffff8804803a / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0930;\r\n\r\n   4: fn 0xffffffff88191e30 - pc 0xffffffff88191e7f / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0940;\r\n\r\n   5: fn 0xffffffff88191f60 - pc 0xffffffff88191fa5 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0990;\r\n\r\n   6: fn 0xffffffff8806ee80 - pc 0xffffffff8806eef9 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0a00;\r\n\r\n   7: fn 0xffffffff88048660 - pc 0xffffffff880489c7 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0a40;\r\n\r\n   8: fn 0xffffffff880484d0 - pc 0xffffffff8804863c / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0c10;\r\n\r\n   9: fn 0xffffffff88049e60 - pc 0xffffffff88049e6e / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0f90;\r\n\r\n  10: fn 0xffffffff880bae20 - pc 0xffffffff880bae36 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0fb0;\r\n\r\n  11: fn 0xffffffff8806f710 - pc 0xffffffff8806f774 / registers:\r\n\r\n     rax                0x1; rdx 0xffffffff881a6db0; rcx               0x16; rbx                0x0;\r\n     rsi 0xffffffff881a6d18; rdi 0xffff8000083c0898; rbp                0x0; rsp 0xffff8000083c0fd0;\r\n```\nYes it is normal and the scheduler expect that the main task of the kernel will never return.\r\n\r\nSo a well formed hello world kernel may shut the system down after printing.\r\n\r\nHowever we do not have ACPI shutdown at this moment. Here is a debug fix.\r\n\r\n```rust\r\n#[aster_main]\r\npub fn main() {\r\n    let program_binary = include_bytes!(\"../hello_world\");\r\n    let user_space = create_user_space(program_binary);\r\n    let user_task = create_user_task(Arc::new(user_space));\r\n    user_task.run();\r\n    use aster_frame::arch::qemu::{exit_qemu, QemuExitCode};\r\n    exit_qemu(QemuExitCode::Success);\r\n}\r\n```\r\n\r\n\nOk! Thanks again.\n> It seems that the scheduler is not set. And the guide does not mention that.\r\n> \r\n> ```rust\r\n> use aster_frame::task::{set_scheduler, FifoScheduler, Scheduler};\r\n> let simple_scheduler = Box::new(FifoScheduler::new());\r\n> let static_scheduler: &'static dyn Scheduler = Box::leak(simple_scheduler);\r\n> set_scheduler(static_scheduler);\r\n> ```\r\n> \r\n> Could you please check if this works? If so you can help us improve the guide!\r\n\r\n#748 introduces such a scheduler initialization for `ktest`. Maybe it will be better to set the scheduler in `aster_frame::init()` and it will work for both.", "created_at": "2024-06-20T08:52:42Z", "version": "0.5"}, {"repo": "asterinas/asterinas", "pull_number": 567, "instance_id": "asterinas__asterinas-567", "issue_numbers": ["555"], "base_commit": "5fb8a9f7e558977a8027eec32565a2de6b87636b", "patch": "diff --git a/.github/workflows/license_check.yml b/.github/workflows/license_check.yml\nnew file mode 100644\nindex 0000000000..29fd6bb2f0\n--- /dev/null\n+++ b/.github/workflows/license_check.yml\n@@ -0,0 +1,14 @@\n+name: Check License\n+on:\n+  pull_request:\n+  push:\n+    branches: \n+      - main\n+jobs:\n+  check-license-lines:\n+    runs-on: ubuntu-latest\n+    steps:\n+    - uses: actions/checkout@master\n+    - name: Check License\n+      # Check license lines of each file in this repository.\n+      uses: apache/skywalking-eyes@v0.5.0\ndiff --git a/.licenserc.yaml b/.licenserc.yaml\nnew file mode 100644\nindex 0000000000..297579edba\n--- /dev/null\n+++ b/.licenserc.yaml\n@@ -0,0 +1,61 @@\n+# This is the configuration file for github action License Eye Header. The action is used \n+# to check that each source file contains the license header lines. For the configuration \n+# details, see https://github.com/marketplace/actions/license-eye-header#configurations.\n+\n+header:\n+  # Files are licensed under MPL-2.0, by default.\n+  - paths: \n+      - '**/*.rs'\n+      - '**/*.S'\n+      - '**/*.s'\n+      - '**/*.c'\n+      - '**/*.sh'\n+      - '**/Makefile'\n+      - '**/Dockerfile.*'\n+    paths-ignore:\n+      # These directories are licensed under licenses other than MPL-2.0.\n+      - 'services/libs/comp-sys/cargo-component'\n+      - 'framework/libs/tdx-guest'\n+    license:\n+      content: |\n+        SPDX-License-Identifier: MPL-2.0\n+    language: \n+      # License Eye Header cannot recognize files with extension .S, so we add\n+      # the definition here.\n+      Assembly: \n+        extensions:\n+          - \".S\"\n+        comment_style_id: SlashAsterisk\n+\n+  # Files under tdx-guest are licensed under BSD-3-Clause license.\n+  - paths: \n+      - 'framework/libs/tdx-guest/**'\n+    paths-ignore:\n+      - 'Cargo.toml'\n+      - '.gitignore'\n+    license:\n+      content: |\n+        SPDX-License-Identifier: BSD-3-Clause\n+        Copyright(c) 2023-2024 Intel Corporation.\n+\n+  # Files under cargo-component are licensed under Apache-2.0 or MIT license.\n+  - paths:\n+      - 'services/libs/comp-sys/cargo-component/**'\n+    paths-ignore:\n+      - '**/*.md'\n+      - '**/*.toml'\n+      - 'Cargo.lock'\n+      - '.gitignore'\n+      # These directories do not contain test source code and are just for test input.\n+      - '**/tests/duplicate_lib_name_test/**'\n+      - '**/tests/missing_toml_test/**'\n+      - '**/tests/reexport_test/**'\n+      - '**/tests/regression_test/**'\n+      - '**/tests/trait_method_test/**'\n+      - '**/tests/violate_policy_test/**'\n+      \n+    license:\n+      content: |\n+        Licensed under the Apache License, Version 2.0 or the MIT License.\n+        Copyright (C) 2023-2024 Ant Group.\n+  \n\\ No newline at end of file\ndiff --git a/Makefile b/Makefile\nindex ec7f5b34cc..d937389fd3 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n # Make varaiables and defaults, you should refer to aster-runner for more details\n AUTO_TEST ?= none\n BOOT_METHOD ?= qemu-grub\ndiff --git a/build.rs b/build.rs\nindex 0c2017fb8b..cff89a754b 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::{error::Error, path::PathBuf};\n \n fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\ndiff --git a/framework/aster-frame/src/arch/mod.rs b/framework/aster-frame/src/arch/mod.rs\nindex 2c243b413c..bd52ba4417 100644\n--- a/framework/aster-frame/src/arch/mod.rs\n+++ b/framework/aster-frame/src/arch/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #[cfg(target_arch = \"x86_64\")]\n pub mod x86;\n \ndiff --git a/framework/aster-frame/src/arch/x86/boot/boot.S b/framework/aster-frame/src/arch/x86/boot/boot.S\nindex 4150e70b51..cf758ec163 100644\n--- a/framework/aster-frame/src/arch/x86/boot/boot.S\n+++ b/framework/aster-frame/src/arch/x86/boot/boot.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // The boot header, initial boot setup code, temporary GDT and page tables are\n // in the boot section. The boot section is mapped writable since kernel may\n // modify the initial page table.\ndiff --git a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\nindex 1e94c0d644..d2df419919 100644\n--- a/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The Linux 64-bit Boot Protocol supporting module.\n //!\n \ndiff --git a/framework/aster-frame/src/arch/x86/boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/mod.rs\nindex ee4347c673..b23ebf0ebd 100644\n--- a/framework/aster-frame/src/arch/x86/boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The x86 boot module defines the entrypoints of Asterinas and\n //! the corresponding headers for different x86 boot protocols.\n //!\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot/header.S b/framework/aster-frame/src/arch/x86/boot/multiboot/header.S\nindex e7acd3ca26..fcdbde1be0 100644\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot/header.S\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/header.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // This is the GNU Multiboot header.\n // Reference: https://www.gnu.org/software/grub/manual/multiboot/multiboot.html\n .section \".multiboot_header\", \"a\"\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\nindex 3a27a515fb..227a135464 100644\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{string::String, vec::Vec};\n use multiboot2::MemoryAreaType;\n use spin::Once;\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S b/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S\nindex 3eb8334535..3819aff46b 100644\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // This is the GNU Multiboot 2 header.\n // Reference: https://www.gnu.org/software/grub/manual/multiboot2/html_node/Index.html//Index\n .section \".multiboot2_header\", \"a\"\ndiff --git a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\nindex ff8f9b191f..a5e358a8d1 100644\n--- a/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{\n     string::{String, ToString},\n     vec::Vec,\ndiff --git a/framework/aster-frame/src/arch/x86/console.rs b/framework/aster-frame/src/arch/x86/console.rs\nindex 826f59d869..a66f005fb1 100644\n--- a/framework/aster-frame/src/arch/x86/console.rs\n+++ b/framework/aster-frame/src/arch/x86/console.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Write;\n \n use crate::sync::SpinLock;\ndiff --git a/framework/aster-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\nindex 3bacaae656..492f40cefa 100644\n--- a/framework/aster-frame/src/arch/x86/cpu.rs\n+++ b/framework/aster-frame/src/arch/x86/cpu.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! CPU.\n \n use core::arch::x86_64::{_fxrstor, _fxsave};\ndiff --git a/framework/aster-frame/src/arch/x86/device/cmos.rs b/framework/aster-frame/src/arch/x86/device/cmos.rs\nindex 8916169186..fef7662045 100644\n--- a/framework/aster-frame/src/arch/x86/device/cmos.rs\n+++ b/framework/aster-frame/src/arch/x86/device/cmos.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use acpi::{fadt::Fadt, sdt::Signature};\n use x86_64::instructions::port::{ReadOnlyAccess, WriteOnlyAccess};\n \ndiff --git a/framework/aster-frame/src/arch/x86/device/io_port.rs b/framework/aster-frame/src/arch/x86/device/io_port.rs\nindex 42d329f4d1..e5c60c90bf 100644\n--- a/framework/aster-frame/src/arch/x86/device/io_port.rs\n+++ b/framework/aster-frame/src/arch/x86/device/io_port.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::marker::PhantomData;\n \n pub use x86_64::instructions::port::{\ndiff --git a/framework/aster-frame/src/arch/x86/device/mod.rs b/framework/aster-frame/src/arch/x86/device/mod.rs\nindex 9499ac3f29..d588d790ab 100644\n--- a/framework/aster-frame/src/arch/x86/device/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/device/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Device-related APIs.\n //! This module mainly contains the APIs that should exposed to the device driver like PCI, RTC\n \ndiff --git a/framework/aster-frame/src/arch/x86/device/serial.rs b/framework/aster-frame/src/arch/x86/device/serial.rs\nindex 8e628e9958..30ae618a10 100644\n--- a/framework/aster-frame/src/arch/x86/device/serial.rs\n+++ b/framework/aster-frame/src/arch/x86/device/serial.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! A port-mapped UART. Copied from uart_16550.\n \n use crate::arch::x86::device::io_port::{IoPort, ReadWriteAccess, WriteOnlyAccess};\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/context_table.rs b/framework/aster-frame/src/arch/x86/iommu/context_table.rs\nindex d98548167f..4aa2c3cd26 100644\n--- a/framework/aster-frame/src/arch/x86/iommu/context_table.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/context_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::mem::size_of;\n \n use alloc::collections::BTreeMap;\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/fault.rs b/framework/aster-frame/src/arch/x86/iommu/fault.rs\nindex df08aef4c3..a98c0667e6 100644\n--- a/framework/aster-frame/src/arch/x86/iommu/fault.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/fault.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use alloc::vec::Vec;\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/mod.rs b/framework/aster-frame/src/arch/x86/iommu/mod.rs\nindex 7f984b78ea..a40e3a072b 100644\n--- a/framework/aster-frame/src/arch/x86/iommu/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod context_table;\n mod fault;\n mod remapping;\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/remapping.rs b/framework/aster-frame/src/arch/x86/iommu/remapping.rs\nindex d584d69fbc..d670bc29fc 100644\n--- a/framework/aster-frame/src/arch/x86/iommu/remapping.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/remapping.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitflags::bitflags;\n use log::debug;\n use spin::Once;\ndiff --git a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\nindex 7e310d919d..ef8e55a382 100644\n--- a/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n+++ b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use pod::Pod;\n \n use crate::{\ndiff --git a/framework/aster-frame/src/arch/x86/irq.rs b/framework/aster-frame/src/arch/x86/irq.rs\nindex 2a54aa670f..0640178458 100644\n--- a/framework/aster-frame/src/arch/x86/irq.rs\n+++ b/framework/aster-frame/src/arch/x86/irq.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::sync::Mutex;\n use alloc::{boxed::Box, fmt::Debug, sync::Arc, vec::Vec};\n use spin::Once;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs b/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs\nindex 8c7e0130c7..02575ecfd6 100644\n--- a/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{fmt::Debug, mem::size_of, slice::Iter};\n \n use acpi::{sdt::Signature, AcpiTable};\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs b/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs\nindex afc9e10dc5..70e047f2d7 100644\n--- a/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod dmar;\n pub mod remapping;\n \ndiff --git a/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs b/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs\nindex 8c41e0889d..6a6eed745d 100644\n--- a/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Remapping structures of DMAR table.\n //! This file defines these structures and provides a \"Debug\" implementation to see the value inside these structures.\n //! Most of the introduction are copied from Intel vt-directed-io-specification.\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs b/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs\nindex f0addb37ae..36b3e74456 100644\n--- a/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use acpi::PlatformInfo;\n use alloc::vec;\n use alloc::vec::Vec;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs b/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs\nindex be4ecf4415..7847499f10 100644\n--- a/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::sync::Mutex;\n use alloc::boxed::Box;\n use alloc::sync::Arc;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs b/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs\nindex bf30afed81..da31bf41fe 100644\n--- a/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use x86::msr::{\n     rdmsr, wrmsr, IA32_APIC_BASE, IA32_X2APIC_APICID, IA32_X2APIC_CUR_COUNT, IA32_X2APIC_DIV_CONF,\n     IA32_X2APIC_EOI, IA32_X2APIC_INIT_COUNT, IA32_X2APIC_LVT_TIMER, IA32_X2APIC_SIVR,\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs b/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs\nindex 76ae1d1ee0..ea578dff84 100644\n--- a/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::sync::Mutex;\n use crate::vm;\n use spin::Once;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/mod.rs b/framework/aster-frame/src/arch/x86/kernel/mod.rs\nindex 008c9ec8ec..4af2b96602 100644\n--- a/framework/aster-frame/src/arch/x86/kernel/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub(super) mod acpi;\n pub(super) mod apic;\n pub(super) mod pic;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/pic.rs b/framework/aster-frame/src/arch/x86/kernel/pic.rs\nindex fbe04eaa03..719c8ee59f 100644\n--- a/framework/aster-frame/src/arch/x86/kernel/pic.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/pic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::arch::x86::device::io_port::{IoPort, WriteOnlyAccess};\n use crate::trap::IrqLine;\n use core::sync::atomic::Ordering::Relaxed;\ndiff --git a/framework/aster-frame/src/arch/x86/kernel/tsc.rs b/framework/aster-frame/src/arch/x86/kernel/tsc.rs\nindex f6cd07aa0f..41acea5820 100644\n--- a/framework/aster-frame/src/arch/x86/kernel/tsc.rs\n+++ b/framework/aster-frame/src/arch/x86/kernel/tsc.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::AtomicU64;\n use x86::cpuid::cpuid;\n \ndiff --git a/framework/aster-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\nindex 1386d7a0d2..2b53b00275 100644\n--- a/framework/aster-frame/src/arch/x86/mm/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mm/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::sync::Mutex;\n use alloc::{collections::BTreeMap, fmt};\n use pod::Pod;\ndiff --git a/framework/aster-frame/src/arch/x86/mod.rs b/framework/aster-frame/src/arch/x86/mod.rs\nindex 5d0dc6db43..ed27662381 100644\n--- a/framework/aster-frame/src/arch/x86/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod boot;\n pub mod console;\n pub(crate) mod cpu;\ndiff --git a/framework/aster-frame/src/arch/x86/pci.rs b/framework/aster-frame/src/arch/x86/pci.rs\nindex 34a8d9bcbd..00b66265bd 100644\n--- a/framework/aster-frame/src/arch/x86/pci.rs\n+++ b/framework/aster-frame/src/arch/x86/pci.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! PCI bus io port\n \n use super::device::io_port::{IoPort, ReadWriteAccess, WriteOnlyAccess};\ndiff --git a/framework/aster-frame/src/arch/x86/qemu.rs b/framework/aster-frame/src/arch/x86/qemu.rs\nindex 5d8fd7bfe1..db93a97ffe 100644\n--- a/framework/aster-frame/src/arch/x86/qemu.rs\n+++ b/framework/aster-frame/src/arch/x86/qemu.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Providing the ability to exit QEMU and return a value as debug result.\n \n /// The exit code of x86 QEMU isa debug device. In `qemu-system-x86_64` the\ndiff --git a/framework/aster-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\nindex 463b91dce6..1d506ab2f4 100644\n--- a/framework/aster-frame/src/arch/x86/tdx_guest.rs\n+++ b/framework/aster-frame/src/arch/x86/tdx_guest.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use tdx_guest::{\n     tdcall::TdgVeInfo,\n     tdvmcall::{cpuid, hlt, rdmsr, wrmsr, IoSize},\ndiff --git a/framework/aster-frame/src/arch/x86/timer/apic.rs b/framework/aster-frame/src/arch/x86/timer/apic.rs\nindex 81441e5e3d..437e21e89e 100644\n--- a/framework/aster-frame/src/arch/x86/timer/apic.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/apic.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use core::arch::x86_64::_rdtsc;\n use core::sync::atomic::{AtomicBool, AtomicU64, Ordering};\ndiff --git a/framework/aster-frame/src/arch/x86/timer/hpet.rs b/framework/aster-frame/src/arch/x86/timer/hpet.rs\nindex cc4ba75125..44d78c3ffc 100644\n--- a/framework/aster-frame/src/arch/x86/timer/hpet.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/hpet.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{trap::IrqLine, vm::paddr_to_vaddr};\n use acpi::{AcpiError, HpetInfo};\n use alloc::vec::Vec;\ndiff --git a/framework/aster-frame/src/arch/x86/timer/mod.rs b/framework/aster-frame/src/arch/x86/timer/mod.rs\nindex aee24d1f3b..4f3bccc9ea 100644\n--- a/framework/aster-frame/src/arch/x86/timer/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod apic;\n pub mod hpet;\n pub mod pit;\ndiff --git a/framework/aster-frame/src/arch/x86/timer/pit.rs b/framework/aster-frame/src/arch/x86/timer/pit.rs\nindex 69fce02ffa..2f830ee54b 100644\n--- a/framework/aster-frame/src/arch/x86/timer/pit.rs\n+++ b/framework/aster-frame/src/arch/x86/timer/pit.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! used for PIT Timer\n \n use crate::config::TIMER_FREQ;\ndiff --git a/framework/aster-frame/src/boot/kcmdline.rs b/framework/aster-frame/src/boot/kcmdline.rs\nindex f68dff1b09..b8158dd21b 100644\n--- a/framework/aster-frame/src/boot/kcmdline.rs\n+++ b/framework/aster-frame/src/boot/kcmdline.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The module to parse kernel command-line arguments.\n //!\n //! The format of the Asterinas command line string conforms\ndiff --git a/framework/aster-frame/src/boot/memory_region.rs b/framework/aster-frame/src/boot/memory_region.rs\nindex ac2fcdd243..10fa73f397 100644\n--- a/framework/aster-frame/src/boot/memory_region.rs\n+++ b/framework/aster-frame/src/boot/memory_region.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Information of memory regions in the boot phase.\n //!\n \ndiff --git a/framework/aster-frame/src/boot/mod.rs b/framework/aster-frame/src/boot/mod.rs\nindex 6afdc118ab..0e92fa6cc6 100644\n--- a/framework/aster-frame/src/boot/mod.rs\n+++ b/framework/aster-frame/src/boot/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The architecture-independent boot module, which provides a universal interface\n //! from the bootloader to the rest of the framework.\n //!\ndiff --git a/framework/aster-frame/src/bus/mmio/bus.rs b/framework/aster-frame/src/bus/mmio/bus.rs\nindex daf3b965da..38ddac64b3 100644\n--- a/framework/aster-frame/src/bus/mmio/bus.rs\n+++ b/framework/aster-frame/src/bus/mmio/bus.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{collections::VecDeque, fmt::Debug, sync::Arc, vec::Vec};\n use log::{debug, error};\n \ndiff --git a/framework/aster-frame/src/bus/mmio/device.rs b/framework/aster-frame/src/bus/mmio/device.rs\nindex 03e2e69738..1dd0a5fbac 100644\n--- a/framework/aster-frame/src/bus/mmio/device.rs\n+++ b/framework/aster-frame/src/bus/mmio/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use int_to_c_enum::TryFromInt;\n use log::info;\n \ndiff --git a/framework/aster-frame/src/bus/mmio/mod.rs b/framework/aster-frame/src/bus/mmio/mod.rs\nindex 4c58bd7401..f55f43e386 100644\n--- a/framework/aster-frame/src/bus/mmio/mod.rs\n+++ b/framework/aster-frame/src/bus/mmio/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtio over MMIO\n \n pub mod bus;\ndiff --git a/framework/aster-frame/src/bus/mod.rs b/framework/aster-frame/src/bus/mod.rs\nindex 24e5ef3473..3654081ec5 100644\n--- a/framework/aster-frame/src/bus/mod.rs\n+++ b/framework/aster-frame/src/bus/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod mmio;\n pub mod pci;\n \ndiff --git a/framework/aster-frame/src/bus/pci/bus.rs b/framework/aster-frame/src/bus/pci/bus.rs\nindex b487d8f07d..9082f69417 100644\n--- a/framework/aster-frame/src/bus/pci/bus.rs\n+++ b/framework/aster-frame/src/bus/pci/bus.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use alloc::{collections::VecDeque, sync::Arc, vec::Vec};\ndiff --git a/framework/aster-frame/src/bus/pci/capability/mod.rs b/framework/aster-frame/src/bus/pci/capability/mod.rs\nindex 63628e74f9..3cceb0354f 100644\n--- a/framework/aster-frame/src/bus/pci/capability/mod.rs\n+++ b/framework/aster-frame/src/bus/pci/capability/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n \n use self::{msix::CapabilityMsixData, vendor::CapabilityVndrData};\ndiff --git a/framework/aster-frame/src/bus/pci/capability/msix.rs b/framework/aster-frame/src/bus/pci/capability/msix.rs\nindex e162da67eb..5305afc160 100644\n--- a/framework/aster-frame/src/bus/pci/capability/msix.rs\n+++ b/framework/aster-frame/src/bus/pci/capability/msix.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{sync::Arc, vec::Vec};\n \n use crate::{\ndiff --git a/framework/aster-frame/src/bus/pci/capability/vendor.rs b/framework/aster-frame/src/bus/pci/capability/vendor.rs\nindex b1c5f36ec9..dea1beb1f1 100644\n--- a/framework/aster-frame/src/bus/pci/capability/vendor.rs\n+++ b/framework/aster-frame/src/bus/pci/capability/vendor.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::bus::pci::{common_device::PciCommonDevice, device_info::PciDeviceLocation};\n use crate::{Error, Result};\n \ndiff --git a/framework/aster-frame/src/bus/pci/cfg_space.rs b/framework/aster-frame/src/bus/pci/cfg_space.rs\nindex 7750238624..9965837ea1 100644\n--- a/framework/aster-frame/src/bus/pci/cfg_space.rs\n+++ b/framework/aster-frame/src/bus/pci/cfg_space.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use bitflags::bitflags;\n \ndiff --git a/framework/aster-frame/src/bus/pci/common_device.rs b/framework/aster-frame/src/bus/pci/common_device.rs\nindex 110fdad690..ba19c64fd1 100644\n--- a/framework/aster-frame/src/bus/pci/common_device.rs\n+++ b/framework/aster-frame/src/bus/pci/common_device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n \n use super::{\ndiff --git a/framework/aster-frame/src/bus/pci/device_info.rs b/framework/aster-frame/src/bus/pci/device_info.rs\nindex c767d742d7..46cc56d185 100644\n--- a/framework/aster-frame/src/bus/pci/device_info.rs\n+++ b/framework/aster-frame/src/bus/pci/device_info.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::iter;\n \n use crate::arch::pci::{PCI_ADDRESS_PORT, PCI_DATA_PORT};\ndiff --git a/framework/aster-frame/src/bus/pci/mod.rs b/framework/aster-frame/src/bus/pci/mod.rs\nindex d4497b5474..9552a86f44 100644\n--- a/framework/aster-frame/src/bus/pci/mod.rs\n+++ b/framework/aster-frame/src/bus/pci/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! PCI bus\n //!\n //! Users can implement the bus under the `PciDriver` to the PCI bus to register devices,\ndiff --git a/framework/aster-frame/src/config.rs b/framework/aster-frame/src/config.rs\nindex 416ade6c83..145e2c156b 100644\n--- a/framework/aster-frame/src/config.rs\n+++ b/framework/aster-frame/src/config.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(unused)]\n \n use log::Level;\ndiff --git a/framework/aster-frame/src/console.rs b/framework/aster-frame/src/console.rs\nindex d0a3193ef2..0f164f29ce 100644\n--- a/framework/aster-frame/src/console.rs\n+++ b/framework/aster-frame/src/console.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Arguments;\n \n pub fn print(args: Arguments) {\ndiff --git a/framework/aster-frame/src/cpu.rs b/framework/aster-frame/src/cpu.rs\nindex 4b94bf6b3b..96a6ec9813 100644\n--- a/framework/aster-frame/src/cpu.rs\n+++ b/framework/aster-frame/src/cpu.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! CPU.\n \n use crate::trap::disable_local;\ndiff --git a/framework/aster-frame/src/error.rs b/framework/aster-frame/src/error.rs\nindex fa6676d10e..bd859950b6 100644\n--- a/framework/aster-frame/src/error.rs\n+++ b/framework/aster-frame/src/error.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// The error type which is returned from the APIs of this crate.\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum Error {\ndiff --git a/framework/aster-frame/src/io_mem.rs b/framework/aster-frame/src/io_mem.rs\nindex 6ad3cb3de8..55c2e0a22a 100644\n--- a/framework/aster-frame/src/io_mem.rs\n+++ b/framework/aster-frame/src/io_mem.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{mem::size_of, ops::Range};\n use pod::Pod;\n \ndiff --git a/framework/aster-frame/src/lib.rs b/framework/aster-frame/src/lib.rs\nindex 9486c22598..01468fcea0 100644\n--- a/framework/aster-frame/src/lib.rs\n+++ b/framework/aster-frame/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The framework part of Asterinas.\n #![feature(alloc_error_handler)]\n #![feature(const_mut_refs)]\ndiff --git a/framework/aster-frame/src/logger.rs b/framework/aster-frame/src/logger.rs\nindex 8e5f0b868a..7b2316dcea 100644\n--- a/framework/aster-frame/src/logger.rs\n+++ b/framework/aster-frame/src/logger.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{config::DEFAULT_LOG_LEVEL, early_println};\n \n use log::{Metadata, Record};\ndiff --git a/framework/aster-frame/src/panicking.rs b/framework/aster-frame/src/panicking.rs\nindex 57d8a06649..b3786a44cb 100644\n--- a/framework/aster-frame/src/panicking.rs\n+++ b/framework/aster-frame/src/panicking.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Panic support.\n \n use alloc::{boxed::Box, string::ToString};\ndiff --git a/framework/aster-frame/src/prelude.rs b/framework/aster-frame/src/prelude.rs\nindex bc93334ac2..c7c196faac 100644\n--- a/framework/aster-frame/src/prelude.rs\n+++ b/framework/aster-frame/src/prelude.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The prelude.\n \n pub type Result<T> = core::result::Result<T, crate::error::Error>;\ndiff --git a/framework/aster-frame/src/sync/atomic_bits.rs b/framework/aster-frame/src/sync/atomic_bits.rs\nindex 85656935c5..3c6c5d34d2 100644\n--- a/framework/aster-frame/src/sync/atomic_bits.rs\n+++ b/framework/aster-frame/src/sync/atomic_bits.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::{self};\n use core::sync::atomic::{AtomicU64, Ordering::Relaxed};\n \ndiff --git a/framework/aster-frame/src/sync/mod.rs b/framework/aster-frame/src/sync/mod.rs\nindex 23b37ea10a..cbe24ad2b6 100644\n--- a/framework/aster-frame/src/sync/mod.rs\n+++ b/framework/aster-frame/src/sync/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod atomic_bits;\n mod mutex;\n // TODO: refactor this rcu implementation\ndiff --git a/framework/aster-frame/src/sync/mutex.rs b/framework/aster-frame/src/sync/mutex.rs\nindex 1e64144d57..74a740203a 100644\n--- a/framework/aster-frame/src/sync/mutex.rs\n+++ b/framework/aster-frame/src/sync/mutex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::WaitQueue;\n use core::cell::UnsafeCell;\n use core::ops::{Deref, DerefMut};\ndiff --git a/framework/aster-frame/src/sync/rcu/mod.rs b/framework/aster-frame/src/sync/rcu/mod.rs\nindex 360ba8ddb0..6bc7fffbab 100644\n--- a/framework/aster-frame/src/sync/rcu/mod.rs\n+++ b/framework/aster-frame/src/sync/rcu/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Read-copy update (RCU).\n \n use core::marker::PhantomData;\ndiff --git a/framework/aster-frame/src/sync/rcu/monitor.rs b/framework/aster-frame/src/sync/rcu/monitor.rs\nindex a39913fb34..d694bfa7ae 100644\n--- a/framework/aster-frame/src/sync/rcu/monitor.rs\n+++ b/framework/aster-frame/src/sync/rcu/monitor.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::collections::VecDeque;\n use core::sync::atomic::{\n     AtomicBool,\ndiff --git a/framework/aster-frame/src/sync/rcu/owner_ptr.rs b/framework/aster-frame/src/sync/rcu/owner_ptr.rs\nindex 97775de01d..7ea176fcf2 100644\n--- a/framework/aster-frame/src/sync/rcu/owner_ptr.rs\n+++ b/framework/aster-frame/src/sync/rcu/owner_ptr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::ptr::NonNull;\n \n use crate::prelude::*;\ndiff --git a/framework/aster-frame/src/sync/rwlock.rs b/framework/aster-frame/src/sync/rwlock.rs\nindex 7e8cbe46ba..ac0797474b 100644\n--- a/framework/aster-frame/src/sync/rwlock.rs\n+++ b/framework/aster-frame/src/sync/rwlock.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::ops::{Deref, DerefMut};\ndiff --git a/framework/aster-frame/src/sync/rwmutex.rs b/framework/aster-frame/src/sync/rwmutex.rs\nindex 46078ac42f..f08cf2003a 100644\n--- a/framework/aster-frame/src/sync/rwmutex.rs\n+++ b/framework/aster-frame/src/sync/rwmutex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::ops::{Deref, DerefMut};\ndiff --git a/framework/aster-frame/src/sync/spin.rs b/framework/aster-frame/src/sync/spin.rs\nindex 5981c83dcb..833ae871c5 100644\n--- a/framework/aster-frame/src/sync/spin.rs\n+++ b/framework/aster-frame/src/sync/spin.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::cell::UnsafeCell;\n use core::fmt;\n use core::ops::{Deref, DerefMut};\ndiff --git a/framework/aster-frame/src/sync/wait.rs b/framework/aster-frame/src/sync/wait.rs\nindex 0d042e2c74..991d006170 100644\n--- a/framework/aster-frame/src/sync/wait.rs\n+++ b/framework/aster-frame/src/sync/wait.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SpinLock;\n use crate::arch::timer::add_timeout_list;\n use crate::config::TIMER_FREQ;\ndiff --git a/framework/aster-frame/src/task/mod.rs b/framework/aster-frame/src/task/mod.rs\nindex 4f05e9ae23..ebd821c847 100644\n--- a/framework/aster-frame/src/task/mod.rs\n+++ b/framework/aster-frame/src/task/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Tasks are the unit of code execution.\n \n mod priority;\ndiff --git a/framework/aster-frame/src/task/priority.rs b/framework/aster-frame/src/task/priority.rs\nindex 6a577c4a3a..8f895d14b4 100644\n--- a/framework/aster-frame/src/task/priority.rs\n+++ b/framework/aster-frame/src/task/priority.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::config::REAL_TIME_TASK_PRI;\n \n /// The priority of a task.\ndiff --git a/framework/aster-frame/src/task/processor.rs b/framework/aster-frame/src/task/processor.rs\nindex d2bd40cda4..90034ae738 100644\n--- a/framework/aster-frame/src/task/processor.rs\n+++ b/framework/aster-frame/src/task/processor.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::AtomicUsize;\n \n use crate::cpu_local;\ndiff --git a/framework/aster-frame/src/task/scheduler.rs b/framework/aster-frame/src/task/scheduler.rs\nindex 40185cffda..260d14df33 100644\n--- a/framework/aster-frame/src/task/scheduler.rs\n+++ b/framework/aster-frame/src/task/scheduler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use crate::sync::SpinLock;\n use crate::task::Task;\ndiff --git a/framework/aster-frame/src/task/switch.S b/framework/aster-frame/src/task/switch.S\nindex 4456f19f15..1520392168 100644\n--- a/framework/aster-frame/src/task/switch.S\n+++ b/framework/aster-frame/src/task/switch.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n .text\n .global context_switch\n .code64\ndiff --git a/framework/aster-frame/src/task/task.rs b/framework/aster-frame/src/task/task.rs\nindex a8d5bae7b6..0b7f5d6a6a 100644\n--- a/framework/aster-frame/src/task/task.rs\n+++ b/framework/aster-frame/src/task/task.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::arch::mm::PageTableFlags;\n use crate::config::{KERNEL_STACK_SIZE, PAGE_SIZE};\n use crate::cpu::CpuSet;\ndiff --git a/framework/aster-frame/src/timer.rs b/framework/aster-frame/src/timer.rs\nindex 551528d7d6..dcccd0a7d0 100644\n--- a/framework/aster-frame/src/timer.rs\n+++ b/framework/aster-frame/src/timer.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Timer.\n \n #[cfg(target_arch = \"x86_64\")]\ndiff --git a/framework/aster-frame/src/trap/handler.rs b/framework/aster-frame/src/trap/handler.rs\nindex 2b945b6da7..43e53ac107 100644\n--- a/framework/aster-frame/src/trap/handler.rs\n+++ b/framework/aster-frame/src/trap/handler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{arch::irq::IRQ_LIST, cpu::CpuException};\n \n #[cfg(feature = \"intel_tdx\")]\ndiff --git a/framework/aster-frame/src/trap/irq.rs b/framework/aster-frame/src/trap/irq.rs\nindex 0f23b5b061..97851566b8 100644\n--- a/framework/aster-frame/src/trap/irq.rs\n+++ b/framework/aster-frame/src/trap/irq.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::arch::irq::{self, IrqCallbackHandle, NOT_USING_IRQ};\n use crate::task::{disable_preempt, DisablePreemptGuard};\n use crate::{prelude::*, Error};\ndiff --git a/framework/aster-frame/src/trap/mod.rs b/framework/aster-frame/src/trap/mod.rs\nindex 0c86e31c35..e4717e64b0 100644\n--- a/framework/aster-frame/src/trap/mod.rs\n+++ b/framework/aster-frame/src/trap/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod handler;\n mod irq;\n \ndiff --git a/framework/aster-frame/src/user.rs b/framework/aster-frame/src/user.rs\nindex 9b89bc6c4f..d351464d3d 100644\n--- a/framework/aster-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! User space.\n \n use crate::cpu::UserContext;\ndiff --git a/framework/aster-frame/src/util/mod.rs b/framework/aster-frame/src/util/mod.rs\nindex d5b1738f47..0c94155a99 100644\n--- a/framework/aster-frame/src/util/mod.rs\n+++ b/framework/aster-frame/src/util/mod.rs\n@@ -1,1 +1,3 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod recycle_allocator;\ndiff --git a/framework/aster-frame/src/util/recycle_allocator.rs b/framework/aster-frame/src/util/recycle_allocator.rs\nindex 265372801c..9d171a5386 100644\n--- a/framework/aster-frame/src/util/recycle_allocator.rs\n+++ b/framework/aster-frame/src/util/recycle_allocator.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n \n #[derive(Debug)]\ndiff --git a/framework/aster-frame/src/vm/dma/dma_coherent.rs b/framework/aster-frame/src/vm/dma/dma_coherent.rs\nindex 872de9788e..e49dbabc74 100644\n--- a/framework/aster-frame/src/vm/dma/dma_coherent.rs\n+++ b/framework/aster-frame/src/vm/dma/dma_coherent.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use core::ops::Deref;\n \ndiff --git a/framework/aster-frame/src/vm/dma/dma_stream.rs b/framework/aster-frame/src/vm/dma/dma_stream.rs\nindex f78aadfa50..6f5f5c084d 100644\n--- a/framework/aster-frame/src/vm/dma/dma_stream.rs\n+++ b/framework/aster-frame/src/vm/dma/dma_stream.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use core::arch::x86_64::_mm_clflush;\n use core::ops::Range;\ndiff --git a/framework/aster-frame/src/vm/dma/mod.rs b/framework/aster-frame/src/vm/dma/mod.rs\nindex 4f13e4055d..d611e17bf0 100644\n--- a/framework/aster-frame/src/vm/dma/mod.rs\n+++ b/framework/aster-frame/src/vm/dma/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod dma_coherent;\n mod dma_stream;\n \ndiff --git a/framework/aster-frame/src/vm/frame.rs b/framework/aster-frame/src/vm/frame.rs\nindex 35855adf9c..abd5bcebd4 100644\n--- a/framework/aster-frame/src/vm/frame.rs\n+++ b/framework/aster-frame/src/vm/frame.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec;\n use core::{\n     iter::Iterator,\ndiff --git a/framework/aster-frame/src/vm/frame_allocator.rs b/framework/aster-frame/src/vm/frame_allocator.rs\nindex 34fb73e459..f1b1c82a6c 100644\n--- a/framework/aster-frame/src/vm/frame_allocator.rs\n+++ b/framework/aster-frame/src/vm/frame_allocator.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use align_ext::AlignExt;\n use alloc::vec::Vec;\n use buddy_system_allocator::FrameAllocator;\ndiff --git a/framework/aster-frame/src/vm/heap_allocator.rs b/framework/aster-frame/src/vm/heap_allocator.rs\nindex 081c39718c..1d1bbaa299 100644\n--- a/framework/aster-frame/src/vm/heap_allocator.rs\n+++ b/framework/aster-frame/src/vm/heap_allocator.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::config::{KERNEL_HEAP_SIZE, PAGE_SIZE};\n use crate::prelude::*;\n use crate::sync::SpinLock;\ndiff --git a/framework/aster-frame/src/vm/io.rs b/framework/aster-frame/src/vm/io.rs\nindex f252defb71..1f71e01967 100644\n--- a/framework/aster-frame/src/vm/io.rs\n+++ b/framework/aster-frame/src/vm/io.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use pod::Pod;\n \ndiff --git a/framework/aster-frame/src/vm/memory_set.rs b/framework/aster-frame/src/vm/memory_set.rs\nindex 7776f6cd49..6bbd67be77 100644\n--- a/framework/aster-frame/src/vm/memory_set.rs\n+++ b/framework/aster-frame/src/vm/memory_set.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::page_table::{PageTable, PageTableConfig, UserMode};\n use crate::{\n     arch::mm::{PageTableEntry, PageTableFlags},\ndiff --git a/framework/aster-frame/src/vm/mod.rs b/framework/aster-frame/src/vm/mod.rs\nindex bdd36c1797..6aaed0245a 100644\n--- a/framework/aster-frame/src/vm/mod.rs\n+++ b/framework/aster-frame/src/vm/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtual memory (VM).\n \n /// Virtual addresses.\ndiff --git a/framework/aster-frame/src/vm/offset.rs b/framework/aster-frame/src/vm/offset.rs\nindex d89f970e9b..566d4238d7 100644\n--- a/framework/aster-frame/src/vm/offset.rs\n+++ b/framework/aster-frame/src/vm/offset.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// Get the offset of a field within a type as a pointer.\n ///\n /// ```rust\ndiff --git a/framework/aster-frame/src/vm/options.rs b/framework/aster-frame/src/vm/options.rs\nindex 14dcbc47a5..67c5c99862 100644\n--- a/framework/aster-frame/src/vm/options.rs\n+++ b/framework/aster-frame/src/vm/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{prelude::*, Error};\n \n use super::{frame::VmFrameFlags, frame_allocator, VmFrame, VmFrameVec, VmSegment};\ndiff --git a/framework/aster-frame/src/vm/page_table.rs b/framework/aster-frame/src/vm/page_table.rs\nindex d4d9b8d0b5..af0922a436 100644\n--- a/framework/aster-frame/src/vm/page_table.rs\n+++ b/framework/aster-frame/src/vm/page_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{paddr_to_vaddr, Paddr, Vaddr, VmAllocOptions};\n use crate::{\n     arch::mm::{is_kernel_vaddr, is_user_vaddr, tlb_flush, PageTableEntry},\ndiff --git a/framework/aster-frame/src/vm/space.rs b/framework/aster-frame/src/vm/space.rs\nindex 89a3df99bb..9db926ef8d 100644\n--- a/framework/aster-frame/src/vm/space.rs\n+++ b/framework/aster-frame/src/vm/space.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::arch::mm::PageTableFlags;\n use crate::config::PAGE_SIZE;\n use crate::sync::Mutex;\ndiff --git a/framework/libs/align_ext/src/lib.rs b/framework/libs/align_ext/src/lib.rs\nindex f3078beb94..f9692e86ce 100644\n--- a/framework/libs/align_ext/src/lib.rs\n+++ b/framework/libs/align_ext/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![cfg_attr(not(test), no_std)]\n \n /// An extension trait for Rust integer types, including `u8`, `u16`, `u32`,\ndiff --git a/framework/libs/linux-bzimage/boot-params/src/lib.rs b/framework/libs/linux-bzimage/boot-params/src/lib.rs\nindex 8d23876dc0..4cd390a87e 100644\n--- a/framework/libs/linux-bzimage/boot-params/src/lib.rs\n+++ b/framework/libs/linux-bzimage/boot-params/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The definition of Linux Boot Protocol boot_params struct.\n //!\n //! The bootloader will deliver the address of the `BootParams` struct\ndiff --git a/framework/libs/linux-bzimage/builder/src/lib.rs b/framework/libs/linux-bzimage/builder/src/lib.rs\nindex b62c925afd..34ee01ec4f 100644\n--- a/framework/libs/linux-bzimage/builder/src/lib.rs\n+++ b/framework/libs/linux-bzimage/builder/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The linux bzImage builder.\n //!\n //! This crate is responsible for building the bzImage. It contains methods to build\ndiff --git a/framework/libs/linux-bzimage/builder/src/mapping.rs b/framework/libs/linux-bzimage/builder/src/mapping.rs\nindex 9e7870000c..babb18cb67 100644\n--- a/framework/libs/linux-bzimage/builder/src/mapping.rs\n+++ b/framework/libs/linux-bzimage/builder/src/mapping.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! In the setup, VA - SETUP32_LMA == FileOffset - LEGACY_SETUP_SEC_SIZE.\n //! And the addresses are specified in the ELF file.\n //!\ndiff --git a/framework/libs/linux-bzimage/builder/src/pe_header.rs b/framework/libs/linux-bzimage/builder/src/pe_header.rs\nindex 16c83bef1b..740c5e15ea 100644\n--- a/framework/libs/linux-bzimage/builder/src/pe_header.rs\n+++ b/framework/libs/linux-bzimage/builder/src/pe_header.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Big zImage PE/COFF header generation.\n //!\n //! The definition of the PE/COFF header is in the Microsoft PE/COFF specification:\ndiff --git a/framework/libs/linux-bzimage/setup/build.rs b/framework/libs/linux-bzimage/setup/build.rs\nindex af5b57d4b7..66d4b53118 100644\n--- a/framework/libs/linux-bzimage/setup/build.rs\n+++ b/framework/libs/linux-bzimage/setup/build.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::path::PathBuf;\n \n fn main() {\ndiff --git a/framework/libs/linux-bzimage/setup/src/console.rs b/framework/libs/linux-bzimage/setup/src/console.rs\nindex 74ad42675c..386f991ebd 100644\n--- a/framework/libs/linux-bzimage/setup/src/console.rs\n+++ b/framework/libs/linux-bzimage/setup/src/console.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::{self, Write};\n \n use uart_16550::SerialPort;\ndiff --git a/framework/libs/linux-bzimage/setup/src/loader.rs b/framework/libs/linux-bzimage/setup/src/loader.rs\nindex 6f43a3d85c..158c92ee9d 100644\n--- a/framework/libs/linux-bzimage/setup/src/loader.rs\n+++ b/framework/libs/linux-bzimage/setup/src/loader.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use xmas_elf::program::{ProgramHeader, SegmentData};\n \n /// Load the kernel ELF payload to memory.\ndiff --git a/framework/libs/linux-bzimage/setup/src/main.rs b/framework/libs/linux-bzimage/setup/src/main.rs\nindex 7e90322691..bb972ea708 100644\n--- a/framework/libs/linux-bzimage/setup/src/main.rs\n+++ b/framework/libs/linux-bzimage/setup/src/main.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The linux bzImage setup binary.\n //!\n //! With respect to the format of the bzImage, we design our bzImage setup in the similar\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\nindex aeeaa8cb57..33a414e25b 100644\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/efi.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use uefi::{\n     data_types::Handle,\n     proto::loaded_image::LoadedImage,\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/header.S b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/header.S\nindex b458b50553..8637161325 100644\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/header.S\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/header.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // The compatibility file for the Linux x86 Boot Protocol.\n // See https://www.kernel.org/doc/html/v5.6/x86/boot.html for\n // more information on the Linux x86 Boot Protocol.\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/mod.rs b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/mod.rs\nindex d1022586a7..d3acbf7044 100644\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/mod.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod efi;\n mod paging;\n mod relocation;\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\nindex b11559c7a9..68f92fa361 100644\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/paging.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module provides abstraction over the Intel IA32E paging mechanism. And\n //! offers method to create linear page tables.\n //!\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\nindex 627019f3e7..d1e34bdac3 100644\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/relocation.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::x86::get_image_loaded_offset;\n \n struct Elf64Rela {\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/setup.S b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/setup.S\nindex 7a0f18fd55..89db788405 100644\n--- a/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/setup.S\n+++ b/framework/libs/linux-bzimage/setup/src/x86/amd64_efi/setup.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n .section \".setup\", \"ax\"\n .code64\n // start_of_setup32 should be loaded at CODE32_START, which is our base.\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/header.S b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/header.S\nindex 32a48f1ec3..199f9b3993 100644\n--- a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/header.S\n+++ b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/header.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // The compatibility file for the Linux x86 Boot Protocol.\n // See https://www.kernel.org/doc/html/v5.6/x86/boot.html for\n // more information on the Linux x86 Boot Protocol.\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/mod.rs b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/mod.rs\nindex 504063a71a..131e44a01e 100644\n--- a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/mod.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use linux_boot_params::BootParams;\n \n use core::arch::{asm, global_asm};\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/setup.S b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/setup.S\nindex 29d47f6242..9d75959d53 100644\n--- a/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/setup.S\n+++ b/framework/libs/linux-bzimage/setup/src/x86/legacy_i386/setup.S\n@@ -1,3 +1,5 @@\n+/* SPDX-License-Identifier: MPL-2.0 */\n+\n // 32-bit setup code starts here, and will be loaded at CODE32_START.\n .section \".setup\", \"ax\"\n .code32\ndiff --git a/framework/libs/linux-bzimage/setup/src/x86/mod.rs b/framework/libs/linux-bzimage/setup/src/x86/mod.rs\nindex d500efeeae..350f28c348 100644\n--- a/framework/libs/linux-bzimage/setup/src/x86/mod.rs\n+++ b/framework/libs/linux-bzimage/setup/src/x86/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n cfg_if::cfg_if! {\n     if #[cfg(target_arch = \"x86_64\")] {\n         mod amd64_efi;\ndiff --git a/framework/libs/tdx-guest/src/asm/mod.rs b/framework/libs/tdx-guest/src/asm/mod.rs\nindex 1eaf81a83d..c9884c97af 100644\n--- a/framework/libs/tdx-guest/src/asm/mod.rs\n+++ b/framework/libs/tdx-guest/src/asm/mod.rs\n@@ -1,3 +1,6 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+// Copyright(c) 2023-2024 Intel Corporation.\n+\n use crate::{tdcall::TdcallArgs, tdvmcall::TdVmcallArgs};\n use core::arch::global_asm;\n \ndiff --git a/framework/libs/tdx-guest/src/asm/tdcall.asm b/framework/libs/tdx-guest/src/asm/tdcall.asm\nindex 2d0d54e25a..77de60dfd8 100644\n--- a/framework/libs/tdx-guest/src/asm/tdcall.asm\n+++ b/framework/libs/tdx-guest/src/asm/tdcall.asm\n@@ -1,3 +1,6 @@\n+# SPDX-License-Identifier: BSD-3-Clause\n+# Copyright(c) 2023-2024 Intel Corporation.\n+\n .section .text\n \n # Arguments offsets in TdVmcallArgs struct\ndiff --git a/framework/libs/tdx-guest/src/asm/tdvmcall.asm b/framework/libs/tdx-guest/src/asm/tdvmcall.asm\nindex dba18d0729..fb47221104 100644\n--- a/framework/libs/tdx-guest/src/asm/tdvmcall.asm\n+++ b/framework/libs/tdx-guest/src/asm/tdvmcall.asm\n@@ -1,3 +1,6 @@\n+# SPDX-License-Identifier: BSD-3-Clause\n+# Copyright(c) 2023-2024 Intel Corporation.\n+\n .section .text\n \n # Mask used to control which part of the guest TD GPR and XMM\ndiff --git a/framework/libs/tdx-guest/src/lib.rs b/framework/libs/tdx-guest/src/lib.rs\nindex 68cd6e29b5..6b32e65c7e 100644\n--- a/framework/libs/tdx-guest/src/lib.rs\n+++ b/framework/libs/tdx-guest/src/lib.rs\n@@ -1,3 +1,6 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+// Copyright(c) 2023-2024 Intel Corporation.\n+\n #![no_std]\n #![allow(dead_code)]\n #![allow(unused_variables)]\ndiff --git a/framework/libs/tdx-guest/src/tdcall.rs b/framework/libs/tdx-guest/src/tdcall.rs\nindex 409e34f352..fc99b71aa7 100644\n--- a/framework/libs/tdx-guest/src/tdcall.rs\n+++ b/framework/libs/tdx-guest/src/tdcall.rs\n@@ -1,3 +1,6 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+// Copyright(c) 2023-2024 Intel Corporation.\n+\n //! The TDCALL instruction causes a VM exit to the Intel TDX module.\n //! It is used to call guest-side Intel TDX functions. For more information about\n //! TDCALL, please refer to the [Intel\u00ae TDX Module v1.5 ABI Specification](https://cdrdv2.intel.com/v1/dl/getContent/733579)\ndiff --git a/framework/libs/tdx-guest/src/tdvmcall.rs b/framework/libs/tdx-guest/src/tdvmcall.rs\nindex 7ccc418a9e..f3477110d3 100644\n--- a/framework/libs/tdx-guest/src/tdvmcall.rs\n+++ b/framework/libs/tdx-guest/src/tdvmcall.rs\n@@ -1,3 +1,6 @@\n+// SPDX-License-Identifier: BSD-3-Clause\n+// Copyright(c) 2023-2024 Intel Corporation.\n+\n //! The TDVMCALL helps invoke services from the host VMM. From the perspective of the host VMM, the TDVMCALL is a trap-like, VM exit into\n //! the host VMM, reported via the SEAMRET instruction flow.\n //! By design, after the SEAMRET, the host VMM services the request specified in the parameters\ndiff --git a/kernel/main.rs b/kernel/main.rs\nindex bbb7737d2a..6e7a577d7b 100644\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![no_std]\n #![no_main]\n // The `export_name` attribute for the `aster_main` entrypoint requires the removal of safety check.\ndiff --git a/regression/Makefile b/regression/Makefile\nindex 64da749303..7d17163dbd 100644\n--- a/regression/Makefile\n+++ b/regression/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n BUILD_DIR := $(CUR_DIR)/build\ndiff --git a/regression/apps/Makefile b/regression/apps/Makefile\nindex 5f70f66350..9f616d2847 100644\n--- a/regression/apps/Makefile\n+++ b/regression/apps/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n MAKEFLAGS += --no-builtin-rules # Prevent the implicit rules from compiling \".c\" or \".s\" files automatically.\n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\ndiff --git a/regression/apps/execve/Makefile b/regression/apps/execve/Makefile\nindex d393e1212e..bf39ea0bf8 100644\n--- a/regression/apps/execve/Makefile\n+++ b/regression/apps/execve/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static\ndiff --git a/regression/apps/execve/execve.c b/regression/apps/execve/execve.c\nindex a7bda5d968..45bd90a0f0 100644\n--- a/regression/apps/execve/execve.c\n+++ b/regression/apps/execve/execve.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <unistd.h>\n \ndiff --git a/regression/apps/execve/hello.c b/regression/apps/execve/hello.c\nindex 014411efd2..4402eac96f 100644\n--- a/regression/apps/execve/hello.c\n+++ b/regression/apps/execve/hello.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n \n int main(int argc, char *argv[], char *envp[]) {\ndiff --git a/regression/apps/fork/Makefile b/regression/apps/fork/Makefile\nindex 238cf33ab7..00cb44cdff 100644\n--- a/regression/apps/fork/Makefile\n+++ b/regression/apps/fork/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static -nostdlib\ndiff --git a/regression/apps/fork/fork.s b/regression/apps/fork/fork.s\nindex d818c62861..3bdfa103dc 100644\n--- a/regression/apps/fork/fork.s\n+++ b/regression/apps/fork/fork.s\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n .global _start\n \n .section .text\ndiff --git a/regression/apps/fork_c/Makefile b/regression/apps/fork_c/Makefile\nindex d393e1212e..bf39ea0bf8 100644\n--- a/regression/apps/fork_c/Makefile\n+++ b/regression/apps/fork_c/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static\ndiff --git a/regression/apps/fork_c/fork.c b/regression/apps/fork_c/fork.c\nindex dfbfc2efc8..47dd6246b2 100644\n--- a/regression/apps/fork_c/fork.c\n+++ b/regression/apps/fork_c/fork.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <unistd.h>\n \ndiff --git a/regression/apps/hello_c/Makefile b/regression/apps/hello_c/Makefile\nindex d6dcb9e580..e299341f1d 100644\n--- a/regression/apps/hello_c/Makefile\n+++ b/regression/apps/hello_c/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static -mno-sse\ndiff --git a/regression/apps/hello_c/hello.c b/regression/apps/hello_c/hello.c\nindex d7f033f7e2..f77edde9cc 100644\n--- a/regression/apps/hello_c/hello.c\n+++ b/regression/apps/hello_c/hello.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n \n int main() {\ndiff --git a/regression/apps/hello_pie/Makefile b/regression/apps/hello_pie/Makefile\nindex 05ff449d2d..c603a781ad 100644\n--- a/regression/apps/hello_pie/Makefile\n+++ b/regression/apps/hello_pie/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=\ndiff --git a/regression/apps/hello_pie/hello.c b/regression/apps/hello_pie/hello.c\nindex 5deb4f724b..e2eb146a91 100644\n--- a/regression/apps/hello_pie/hello.c\n+++ b/regression/apps/hello_pie/hello.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n \n int main() {\ndiff --git a/regression/apps/hello_world/Makefile b/regression/apps/hello_world/Makefile\nindex 238cf33ab7..00cb44cdff 100644\n--- a/regression/apps/hello_world/Makefile\n+++ b/regression/apps/hello_world/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static -nostdlib\ndiff --git a/regression/apps/hello_world/hello_world.s b/regression/apps/hello_world/hello_world.s\nindex 3cf6c075a6..b18b834834 100644\n--- a/regression/apps/hello_world/hello_world.s\n+++ b/regression/apps/hello_world/hello_world.s\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n .global _start\n \n .section .text\ndiff --git a/regression/apps/network/Makefile b/regression/apps/network/Makefile\nindex 05ff449d2d..c603a781ad 100644\n--- a/regression/apps/network/Makefile\n+++ b/regression/apps/network/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=\ndiff --git a/regression/apps/network/listen_backlog.c b/regression/apps/network/listen_backlog.c\nindex a54c79b969..da57117ce2 100644\n--- a/regression/apps/network/listen_backlog.c\n+++ b/regression/apps/network/listen_backlog.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <arpa/inet.h>\n #include <netinet/in.h>\n #include <stdio.h>\ndiff --git a/regression/apps/network/send_buf_full.c b/regression/apps/network/send_buf_full.c\nindex 23b5388b33..9d47b8d7f4 100644\n--- a/regression/apps/network/send_buf_full.c\n+++ b/regression/apps/network/send_buf_full.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <arpa/inet.h>\n #include <netinet/in.h>\n #include <stdio.h>\ndiff --git a/regression/apps/network/socketpair.c b/regression/apps/network/socketpair.c\nindex 0441cc00bc..73e66f53c1 100644\n--- a/regression/apps/network/socketpair.c\n+++ b/regression/apps/network/socketpair.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <sys/socket.h>\n #include <stdlib.h>\ndiff --git a/regression/apps/network/sockoption.c b/regression/apps/network/sockoption.c\nindex b4fa0b258e..91996bd8c2 100644\n--- a/regression/apps/network/sockoption.c\n+++ b/regression/apps/network/sockoption.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <sys/socket.h>\ndiff --git a/regression/apps/network/tcp_client.c b/regression/apps/network/tcp_client.c\nindex a290bf3f27..8302ed0dd3 100644\n--- a/regression/apps/network/tcp_client.c\n+++ b/regression/apps/network/tcp_client.c\n@@ -1,51 +1,44 @@\n-// From: https://www.geeksforgeeks.org/socket-programming-cc/.\n-// Some minor modifications are made to the original code base.\n-// Lisenced under CCBY-SA.\n+// SPDX-License-Identifier: MPL-2.0\n \n-// Client side C/C++ program to demonstrate socket programming\n-#include <arpa/inet.h>\n #include <stdio.h>\n+#include <stdlib.h>\n #include <string.h>\n-#include <sys/socket.h>\n #include <unistd.h>\n+#include <arpa/inet.h>\n+\n #define PORT 8080\n-  \n-int main(int argc, char const* argv[])\n-{\n-    int status, valread, client_fd;\n+\n+int main() {\n+    int sock = 0, valread;\n     struct sockaddr_in serv_addr;\n-    char* hello = \"Hello from client\";\n-    char buffer[1024] = { 0 };\n-    if ((client_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n+    char *hello = \"Hello from client\";\n+    char buffer[1024] = {0};\n+\n+    // Create socket\n+    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n         printf(\"\\n Socket creation error \\n\");\n         return -1;\n     }\n-  \n+\n     serv_addr.sin_family = AF_INET;\n     serv_addr.sin_port = htons(PORT);\n-  \n-    // Convert IPv4 and IPv6 addresses from text to binary\n-    // form\n-    if (inet_pton(AF_INET, \"127.0.0.1\", &serv_addr.sin_addr)\n-        <= 0) {\n-        printf(\n-            \"\\nInvalid address/ Address not supported \\n\");\n+\n+    // Convert IPv4 address from text to binary form\n+    if (inet_pton(AF_INET, \"127.0.0.1\", &(serv_addr.sin_addr)) <= 0) {\n+        printf(\"\\n Invalid address/ Address not supported \\n\");\n         return -1;\n     }\n-  \n-    if ((status\n-         = connect(client_fd, (struct sockaddr*)&serv_addr,\n-                   sizeof(serv_addr)))\n-        < 0) {\n-        printf(\"\\nConnection Failed \\n\");\n+\n+    // Connect to the server\n+    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n+        printf(\"\\n Connection Failed \\n\");\n         return -1;\n     }\n-    send(client_fd, hello, strlen(hello), 0);\n+\n+    // Send message to the server and receive the reply\n+    send(sock, hello, strlen(hello), 0);\n     printf(\"Hello message sent\\n\");\n-    valread = read(client_fd, buffer, 1024);\n-    printf(\"%s\\n\", buffer);\n-  \n-    // closing the connected socket\n-    close(client_fd);\n+    valread = read(sock, buffer, 1024);\n+    printf(\"Server: %s\\n\", buffer);\n     return 0;\n-}\n\\ No newline at end of file\n+}\ndiff --git a/regression/apps/network/tcp_server.c b/regression/apps/network/tcp_server.c\nindex 1709914768..49c2be8763 100644\n--- a/regression/apps/network/tcp_server.c\n+++ b/regression/apps/network/tcp_server.c\n@@ -1,75 +1,65 @@\n-// From: https://www.geeksforgeeks.org/socket-programming-cc/.\n-// Some minor modifications are made to the original code base.\n-// Lisenced under CCBY-SA.\n+// SPDX-License-Identifier: MPL-2.0\n \n-// Server side C/C++ program to demonstrate socket programming\n-#include <arpa/inet.h>\n-#include <netinet/in.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n-#include <sys/socket.h>\n #include <unistd.h>\n+#include <arpa/inet.h>\n+\n #define PORT 8080\n-int main(int argc, char const* argv[])\n-{\n+\n+int main() {\n     int server_fd, new_socket, valread;\n     struct sockaddr_in address;\n     int opt = 1;\n     int addrlen = sizeof(address);\n-    char buffer[1024] = { 0 };\n-    char* hello = \"Hello from server\";\n-  \n-    // Creating socket file descriptor\n-    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n+    char buffer[1024] = {0};\n+    char *hello = \"Hello from server\";\n+\n+    // Create socket\n+    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {\n         perror(\"socket failed\");\n         exit(EXIT_FAILURE);\n     }\n-  \n-    // Forcefully attaching socket to the port 8080\n-    if (setsockopt(server_fd, SOL_SOCKET,\n-                   SO_REUSEADDR | SO_REUSEPORT, &opt,\n-                   sizeof(opt))) {\n-        perror(\"setsockopt\");\n+\n+    // Set socket options\n+    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {\n+        perror(\"setsockopt failed\");\n         exit(EXIT_FAILURE);\n     }\n+    \n     address.sin_family = AF_INET;\n+    address.sin_addr.s_addr = INADDR_ANY;\n     address.sin_port = htons(PORT);\n-    // Convert IPv4 and IPv6 addresses from text to binary\n-    // form\n-    if (inet_pton(AF_INET, \"127.0.0.1\", &address.sin_addr)\n-        <= 0) {\n-        printf(\n-            \"\\nInvalid address/ Address not supported \\n\");\n+\n+    // Convert IPv4 address from text to binary form\n+    if (inet_pton(AF_INET, \"127.0.0.1\", &(address.sin_addr)) <= 0) {\n+        printf(\"\\n Invalid address/ Address not supported \\n\");\n         return -1;\n     }\n-  \n-    // Forcefully attaching socket to the port 8080\n-    if (bind(server_fd, (struct sockaddr*)&address,\n-             sizeof(address))\n-        < 0) {\n+\n+    // Bind the socket to specified IP and port\n+    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {\n         perror(\"bind failed\");\n         exit(EXIT_FAILURE);\n     }\n+\n+    // Listen for connections\n     if (listen(server_fd, 3) < 0) {\n-        perror(\"listen\");\n+        perror(\"listen failed\");\n         exit(EXIT_FAILURE);\n     }\n-    if ((new_socket\n-         = accept(server_fd, (struct sockaddr*)&address,\n-                  (socklen_t*)&addrlen))\n-        < 0) {\n-        perror(\"accept\");\n+\n+    // Accept the connection\n+    if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen)) < 0) {\n+        perror(\"accept failed\");\n         exit(EXIT_FAILURE);\n     }\n+\n+    // Read the message from the client and reply\n     valread = read(new_socket, buffer, 1024);\n-    printf(\"%s\\n\", buffer);\n+    printf(\"Client: %s\\n\", buffer);\n     send(new_socket, hello, strlen(hello), 0);\n     printf(\"Hello message sent\\n\");\n-  \n-    // closing the connected socket\n-    close(new_socket);\n-    // closing the listening socket\n-    shutdown(server_fd, SHUT_RDWR);\n     return 0;\n-}\n\\ No newline at end of file\n+}\ndiff --git a/regression/apps/network/udp_client.c b/regression/apps/network/udp_client.c\nindex 2ad81b8de7..0f5ce5cf04 100644\n--- a/regression/apps/network/udp_client.c\n+++ b/regression/apps/network/udp_client.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\ndiff --git a/regression/apps/network/udp_server.c b/regression/apps/network/udp_server.c\nindex 435097d97d..12bb8c991d 100644\n--- a/regression/apps/network/udp_server.c\n+++ b/regression/apps/network/udp_server.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\ndiff --git a/regression/apps/network/unix_client.c b/regression/apps/network/unix_client.c\nindex 041ab1f06f..0befa4ee2e 100644\n--- a/regression/apps/network/unix_client.c\n+++ b/regression/apps/network/unix_client.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\ndiff --git a/regression/apps/network/unix_server.c b/regression/apps/network/unix_server.c\nindex f2ca1c9ccb..064b769dd3 100644\n--- a/regression/apps/network/unix_server.c\n+++ b/regression/apps/network/unix_server.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\ndiff --git a/regression/apps/pthread/Makefile b/regression/apps/pthread/Makefile\nindex 2eef3474a6..8f1ee0ae68 100644\n--- a/regression/apps/pthread/Makefile\n+++ b/regression/apps/pthread/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static -lpthread\ndiff --git a/regression/apps/pty/Makefile b/regression/apps/pty/Makefile\nindex 05ff449d2d..c603a781ad 100644\n--- a/regression/apps/pty/Makefile\n+++ b/regression/apps/pty/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=\ndiff --git a/regression/apps/pty/open_pty.c b/regression/apps/pty/open_pty.c\nindex 220d2f3eb3..2ef2e04ffa 100644\n--- a/regression/apps/pty/open_pty.c\n+++ b/regression/apps/pty/open_pty.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #include <stdio.h>\n #include <stdlib.h>\n #include <unistd.h>\ndiff --git a/regression/apps/scripts/Makefile b/regression/apps/scripts/Makefile\nindex f2b54367a5..2e1e19d5a1 100644\n--- a/regression/apps/scripts/Makefile\n+++ b/regression/apps/scripts/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n .PHONY: all\n \n all: ./*.sh\ndiff --git a/regression/apps/scripts/network.sh b/regression/apps/scripts/network.sh\nindex 432272b5d7..0dfbc0f10c 100755\n--- a/regression/apps/scripts/network.sh\n+++ b/regression/apps/scripts/network.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n \n NETTEST_DIR=/regression/network\ndiff --git a/regression/apps/scripts/process.sh b/regression/apps/scripts/process.sh\nindex 9e8145891a..3b00757e26 100755\n--- a/regression/apps/scripts/process.sh\n+++ b/regression/apps/scripts/process.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n \n SCRIPT_DIR=/regression\ndiff --git a/regression/apps/scripts/shell_cmd.sh b/regression/apps/scripts/shell_cmd.sh\nindex 7136d793ac..49d6ab2c47 100755\n--- a/regression/apps/scripts/shell_cmd.sh\n+++ b/regression/apps/scripts/shell_cmd.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n set -x\n \ndiff --git a/regression/apps/signal_c/Makefile b/regression/apps/signal_c/Makefile\nindex d393e1212e..bf39ea0bf8 100644\n--- a/regression/apps/signal_c/Makefile\n+++ b/regression/apps/signal_c/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n include ../test_common.mk\n \n EXTRA_C_FLAGS :=-static\ndiff --git a/runner/src/gdb.rs b/runner/src/gdb.rs\nindex 209680b4b7..1985d002c5 100644\n--- a/runner/src/gdb.rs\n+++ b/runner/src/gdb.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Providing the utility to run the GDB scripts for the runner.\n \n use crate::qemu_grub_efi;\ndiff --git a/runner/src/machine/microvm.rs b/runner/src/machine/microvm.rs\nindex 3e8e9b1041..f92a18b6db 100644\n--- a/runner/src/machine/microvm.rs\n+++ b/runner/src/machine/microvm.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::{\n     fs::OpenOptions,\n     io::{Seek, SeekFrom, Write},\ndiff --git a/runner/src/machine/mod.rs b/runner/src/machine/mod.rs\nindex da68453ad0..fb7c0255b1 100644\n--- a/runner/src/machine/mod.rs\n+++ b/runner/src/machine/mod.rs\n@@ -1,2 +1,4 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod microvm;\n pub mod qemu_grub_efi;\ndiff --git a/runner/src/machine/qemu_grub_efi.rs b/runner/src/machine/qemu_grub_efi.rs\nindex f2051d99bc..46f7dd6273 100644\n--- a/runner/src/machine/qemu_grub_efi.rs\n+++ b/runner/src/machine/qemu_grub_efi.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use linux_bzimage_builder::{make_bzimage, BzImageType};\n \n use std::{\ndiff --git a/runner/src/main.rs b/runner/src/main.rs\nindex 78be09ff36..f3141d8398 100644\n--- a/runner/src/main.rs\n+++ b/runner/src/main.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! aster-runner is the Asterinas runner script to ease the pain of running\n //! and testing Asterinas inside a QEMU VM. It should be built and run as the\n //! cargo runner: https://doc.rust-lang.org/cargo/reference/config.html\ndiff --git a/services/comps/block/src/bio.rs b/services/comps/block/src/bio.rs\nindex dbdc2a7b99..f3ee10acd5 100644\n--- a/services/comps/block/src/bio.rs\n+++ b/services/comps/block/src/bio.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{id::Sid, BlockDevice};\ndiff --git a/services/comps/block/src/id.rs b/services/comps/block/src/id.rs\nindex a193cfd336..13eb6c96e9 100644\n--- a/services/comps/block/src/id.rs\n+++ b/services/comps/block/src/id.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{\n     iter::Step,\n     ops::{Add, Sub},\ndiff --git a/services/comps/block/src/impl_block_device.rs b/services/comps/block/src/impl_block_device.rs\nindex 6bc00e4d2d..447a79a852 100644\n--- a/services/comps/block/src/impl_block_device.rs\n+++ b/services/comps/block/src/impl_block_device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{\ndiff --git a/services/comps/block/src/lib.rs b/services/comps/block/src/lib.rs\nindex 409907417b..723f9c3902 100644\n--- a/services/comps/block/src/lib.rs\n+++ b/services/comps/block/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The block devices of Asterinas.\n //\uff01\n //\uff01This crate provides a number of base components for block devices, including\ndiff --git a/services/comps/block/src/prelude.rs b/services/comps/block/src/prelude.rs\nindex dca1f8ff2f..77dc3c68ab 100644\n--- a/services/comps/block/src/prelude.rs\n+++ b/services/comps/block/src/prelude.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub(crate) use alloc::collections::{BTreeMap, VecDeque};\n pub(crate) use alloc::string::String;\n pub(crate) use alloc::sync::Arc;\ndiff --git a/services/comps/block/src/request_queue.rs b/services/comps/block/src/request_queue.rs\nindex d0403e9c43..749a8b15d4 100644\n--- a/services/comps/block/src/request_queue.rs\n+++ b/services/comps/block/src/request_queue.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{\ndiff --git a/services/comps/console/src/lib.rs b/services/comps/console/src/lib.rs\nindex 431856d1f7..c223cd9944 100644\n--- a/services/comps/console/src/lib.rs\n+++ b/services/comps/console/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The console device of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/framebuffer/src/lib.rs b/services/comps/framebuffer/src/lib.rs\nindex 05c8820b75..221e69cc57 100644\n--- a/services/comps/framebuffer/src/lib.rs\n+++ b/services/comps/framebuffer/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The framebuffer of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/input/src/lib.rs b/services/comps/input/src/lib.rs\nindex 3edf755095..815a1e8221 100644\n--- a/services/comps/input/src/lib.rs\n+++ b/services/comps/input/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The input devices of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/network/src/buffer.rs b/services/comps/network/src/buffer.rs\nindex 0769b40fb6..e0322c2736 100644\n--- a/services/comps/network/src/buffer.rs\n+++ b/services/comps/network/src/buffer.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::mem::size_of;\n \n use align_ext::AlignExt;\ndiff --git a/services/comps/network/src/driver.rs b/services/comps/network/src/driver.rs\nindex b2d2b9c447..118a8d94e3 100644\n--- a/services/comps/network/src/driver.rs\n+++ b/services/comps/network/src/driver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec;\n use smoltcp::{phy, time::Instant};\n \ndiff --git a/services/comps/network/src/lib.rs b/services/comps/network/src/lib.rs\nindex 04ea774669..9e4af881ec 100644\n--- a/services/comps/network/src/lib.rs\n+++ b/services/comps/network/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(trait_alias)]\ndiff --git a/services/comps/time/src/clocksource.rs b/services/comps/time/src/clocksource.rs\nindex b688d42355..a3a003e8f1 100644\n--- a/services/comps/time/src/clocksource.rs\n+++ b/services/comps/time/src/clocksource.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module provides abstractions for hardware-assisted timing mechanisms, encapsulated by the `ClockSource` struct.\n //! A `ClockSource` can be constructed from any counter with a stable frequency, enabling precise time measurements to be taken\n //! by retrieving instances of `Instant`.\ndiff --git a/services/comps/time/src/lib.rs b/services/comps/time/src/lib.rs\nindex 9c165d56bb..1f81930b1e 100644\n--- a/services/comps/time/src/lib.rs\n+++ b/services/comps/time/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The system time of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/time/src/rtc.rs b/services/comps/time/src/rtc.rs\nindex a6dc47b6c4..92ed6476a3 100644\n--- a/services/comps/time/src/rtc.rs\n+++ b/services/comps/time/src/rtc.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::arch::x86::device::cmos::{get_century_register, CMOS_ADDRESS, CMOS_DATA};\n use core::sync::atomic::AtomicU8;\n use core::sync::atomic::Ordering::Relaxed;\ndiff --git a/services/comps/time/src/tsc.rs b/services/comps/time/src/tsc.rs\nindex d44fc34a8c..97a68eec5e 100644\n--- a/services/comps/time/src/tsc.rs\n+++ b/services/comps/time/src/tsc.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module provide a instance of `ClockSource` based on TSC.\n //!\n //! Use `init` to initialize this module.\ndiff --git a/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\nindex 6ff7cf7d6e..5e0613087f 100644\n--- a/services/comps/virtio/src/device/block/device.rs\n+++ b/services/comps/virtio/src/device/block/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{\n     fmt::Debug,\n     hint::spin_loop,\ndiff --git a/services/comps/virtio/src/device/block/mod.rs b/services/comps/virtio/src/device/block/mod.rs\nindex 8473d1cce0..5e508c3ac1 100644\n--- a/services/comps/virtio/src/device/block/mod.rs\n+++ b/services/comps/virtio/src/device/block/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod device;\n \n use aster_frame::io_mem::IoMem;\ndiff --git a/services/comps/virtio/src/device/console/config.rs b/services/comps/virtio/src/device/console/config.rs\nindex f4e2373195..411bcb9f8a 100644\n--- a/services/comps/virtio/src/device/console/config.rs\n+++ b/services/comps/virtio/src/device/console/config.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::io_mem::IoMem;\n use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\ndiff --git a/services/comps/virtio/src/device/console/device.rs b/services/comps/virtio/src/device/console/device.rs\nindex d791f7e33c..85276b0114 100644\n--- a/services/comps/virtio/src/device/console/device.rs\n+++ b/services/comps/virtio/src/device/console/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::hint::spin_loop;\n \n use alloc::{boxed::Box, fmt::Debug, string::ToString, sync::Arc, vec::Vec};\ndiff --git a/services/comps/virtio/src/device/console/mod.rs b/services/comps/virtio/src/device/console/mod.rs\nindex b322d6a33e..b5a8fce11a 100644\n--- a/services/comps/virtio/src/device/console/mod.rs\n+++ b/services/comps/virtio/src/device/console/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod config;\n pub mod device;\n \ndiff --git a/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\nindex f447d0f900..e5a345fc62 100644\n--- a/services/comps/virtio/src/device/input/device.rs\n+++ b/services/comps/virtio/src/device/input/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use crate::{device::VirtioDeviceError, queue::VirtQueue, transport::VirtioTransport};\ndiff --git a/services/comps/virtio/src/device/input/mod.rs b/services/comps/virtio/src/device/input/mod.rs\nindex eea3e13600..011acd0059 100644\n--- a/services/comps/virtio/src/device/input/mod.rs\n+++ b/services/comps/virtio/src/device/input/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n // Modified from input.rs in virtio-drivers project\n //\n // MIT License\ndiff --git a/services/comps/virtio/src/device/mod.rs b/services/comps/virtio/src/device/mod.rs\nindex a8e00cd5c2..5c2defdbc4 100644\n--- a/services/comps/virtio/src/device/mod.rs\n+++ b/services/comps/virtio/src/device/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::queue::QueueError;\n use int_to_c_enum::TryFromInt;\n \ndiff --git a/services/comps/virtio/src/device/network/config.rs b/services/comps/virtio/src/device/network/config.rs\nindex 0fb980d5b3..a819e3b042 100644\n--- a/services/comps/virtio/src/device/network/config.rs\n+++ b/services/comps/virtio/src/device/network/config.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::io_mem::IoMem;\n use aster_network::EthernetAddr;\n use aster_util::safe_ptr::SafePtr;\ndiff --git a/services/comps/virtio/src/device/network/device.rs b/services/comps/virtio/src/device/network/device.rs\nindex d8ba25912f..aa2b1da8f9 100644\n--- a/services/comps/virtio/src/device/network/device.rs\n+++ b/services/comps/virtio/src/device/network/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::{fmt::Debug, hint::spin_loop, mem::size_of};\n \n use alloc::{boxed::Box, string::ToString, sync::Arc, vec::Vec};\ndiff --git a/services/comps/virtio/src/device/network/header.rs b/services/comps/virtio/src/device/network/header.rs\nindex c1179ab369..2294fbb0ec 100644\n--- a/services/comps/virtio/src/device/network/header.rs\n+++ b/services/comps/virtio/src/device/network/header.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n use pod::Pod;\ndiff --git a/services/comps/virtio/src/device/network/mod.rs b/services/comps/virtio/src/device/network/mod.rs\nindex b88f1c3d3c..7940c44381 100644\n--- a/services/comps/virtio/src/device/network/mod.rs\n+++ b/services/comps/virtio/src/device/network/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod config;\n pub mod device;\n pub mod header;\ndiff --git a/services/comps/virtio/src/lib.rs b/services/comps/virtio/src/lib.rs\nindex 6b5e896716..34d70b56be 100644\n--- a/services/comps/virtio/src/lib.rs\n+++ b/services/comps/virtio/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The virtio of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/comps/virtio/src/queue.rs b/services/comps/virtio/src/queue.rs\nindex 50c5c3a4ca..092d139e95 100644\n--- a/services/comps/virtio/src/queue.rs\n+++ b/services/comps/virtio/src/queue.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtqueue\n \n use crate::transport::VirtioTransport;\ndiff --git a/services/comps/virtio/src/transport/mmio/device.rs b/services/comps/virtio/src/transport/mmio/device.rs\nindex 60f2dce266..eca2e0a521 100644\n--- a/services/comps/virtio/src/transport/mmio/device.rs\n+++ b/services/comps/virtio/src/transport/mmio/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{boxed::Box, sync::Arc};\n use aster_frame::{\n     bus::mmio::{\ndiff --git a/services/comps/virtio/src/transport/mmio/driver.rs b/services/comps/virtio/src/transport/mmio/driver.rs\nindex e4d21dc8bb..82c88715de 100644\n--- a/services/comps/virtio/src/transport/mmio/driver.rs\n+++ b/services/comps/virtio/src/transport/mmio/driver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{sync::Arc, vec::Vec};\n use aster_frame::{\n     bus::{\ndiff --git a/services/comps/virtio/src/transport/mmio/layout.rs b/services/comps/virtio/src/transport/mmio/layout.rs\nindex cc3a56f117..71bf7a2391 100644\n--- a/services/comps/virtio/src/transport/mmio/layout.rs\n+++ b/services/comps/virtio/src/transport/mmio/layout.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use pod::Pod;\ndiff --git a/services/comps/virtio/src/transport/mmio/mod.rs b/services/comps/virtio/src/transport/mmio/mod.rs\nindex 13bb42c18b..d26453ff33 100644\n--- a/services/comps/virtio/src/transport/mmio/mod.rs\n+++ b/services/comps/virtio/src/transport/mmio/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use aster_frame::bus::mmio::MMIO_BUS;\n use spin::Once;\ndiff --git a/services/comps/virtio/src/transport/mmio/multiplex.rs b/services/comps/virtio/src/transport/mmio/multiplex.rs\nindex 82ee9f27df..e4f90dcf1f 100644\n--- a/services/comps/virtio/src/transport/mmio/multiplex.rs\n+++ b/services/comps/virtio/src/transport/mmio/multiplex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use alloc::{boxed::Box, sync::Arc, vec::Vec};\ndiff --git a/services/comps/virtio/src/transport/mod.rs b/services/comps/virtio/src/transport/mod.rs\nindex 46e083b86f..28a1ef1e13 100644\n--- a/services/comps/virtio/src/transport/mod.rs\n+++ b/services/comps/virtio/src/transport/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::fmt::Debug;\n \n use alloc::boxed::Box;\ndiff --git a/services/comps/virtio/src/transport/pci/capability.rs b/services/comps/virtio/src/transport/pci/capability.rs\nindex f8a4c6a7a9..e360c99230 100644\n--- a/services/comps/virtio/src/transport/pci/capability.rs\n+++ b/services/comps/virtio/src/transport/pci/capability.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Arc;\n use aster_frame::bus::pci::{\n     capability::vendor::CapabilityVndrData,\ndiff --git a/services/comps/virtio/src/transport/pci/common_cfg.rs b/services/comps/virtio/src/transport/pci/common_cfg.rs\nindex 6d72489665..f3af5ebb5a 100644\n--- a/services/comps/virtio/src/transport/pci/common_cfg.rs\n+++ b/services/comps/virtio/src/transport/pci/common_cfg.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::io_mem::IoMem;\n use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\ndiff --git a/services/comps/virtio/src/transport/pci/device.rs b/services/comps/virtio/src/transport/pci/device.rs\nindex f67f1f0976..019da9d96e 100644\n--- a/services/comps/virtio/src/transport/pci/device.rs\n+++ b/services/comps/virtio/src/transport/pci/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::{\n     bus::{\n         pci::{\ndiff --git a/services/comps/virtio/src/transport/pci/driver.rs b/services/comps/virtio/src/transport/pci/driver.rs\nindex 5e37120f00..eb6dadaeba 100644\n--- a/services/comps/virtio/src/transport/pci/driver.rs\n+++ b/services/comps/virtio/src/transport/pci/driver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{sync::Arc, vec::Vec};\n use aster_frame::{\n     bus::{\ndiff --git a/services/comps/virtio/src/transport/pci/mod.rs b/services/comps/virtio/src/transport/pci/mod.rs\nindex 4fd80e8c75..a7eb1964b0 100644\n--- a/services/comps/virtio/src/transport/pci/mod.rs\n+++ b/services/comps/virtio/src/transport/pci/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod capability;\n pub mod common_cfg;\n pub mod device;\ndiff --git a/services/comps/virtio/src/transport/pci/msix.rs b/services/comps/virtio/src/transport/pci/msix.rs\nindex baeb093acb..b5dc34d405 100644\n--- a/services/comps/virtio/src/transport/pci/msix.rs\n+++ b/services/comps/virtio/src/transport/pci/msix.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n use aster_frame::{bus::pci::capability::msix::CapabilityMsixData, trap::IrqLine};\n \ndiff --git a/services/libs/aster-rights-proc/src/lib.rs b/services/libs/aster-rights-proc/src/lib.rs\nindex 3ca7d27e20..86c4ef58b7 100644\n--- a/services/libs/aster-rights-proc/src/lib.rs\n+++ b/services/libs/aster-rights-proc/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //\uff01This crate defines the require procedural macros to implement capability for Asterinas.\n //! When use this crate, typeflags and typeflags-util should also be added as dependency.\n //!\ndiff --git a/services/libs/aster-rights-proc/src/require_attr.rs b/services/libs/aster-rights-proc/src/require_attr.rs\nindex 6cf791a9f5..eb48870da8 100644\n--- a/services/libs/aster-rights-proc/src/require_attr.rs\n+++ b/services/libs/aster-rights-proc/src/require_attr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! expand the require macro\n \n use proc_macro2::{Ident, TokenStream};\ndiff --git a/services/libs/aster-rights-proc/src/require_item.rs b/services/libs/aster-rights-proc/src/require_item.rs\nindex a423539b50..3d7fcd513e 100644\n--- a/services/libs/aster-rights-proc/src/require_item.rs\n+++ b/services/libs/aster-rights-proc/src/require_item.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use syn::{parse::Parse, ItemFn, ItemImpl, Token};\n \n pub enum RequireItem {\ndiff --git a/services/libs/aster-rights/src/lib.rs b/services/libs/aster-rights/src/lib.rs\nindex e7e929bff9..9c92045516 100644\n--- a/services/libs/aster-rights/src/lib.rs\n+++ b/services/libs/aster-rights/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![no_std]\n \n use core::ops::{Deref, DerefMut};\ndiff --git a/services/libs/aster-std/src/console.rs b/services/libs/aster-std/src/console.rs\nindex d42995e2fa..9368b59327 100644\n--- a/services/libs/aster-std/src/console.rs\n+++ b/services/libs/aster-std/src/console.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! `print` and `println` macros\n //!\n //! FIXME: It will print to all `virtio-console` devices, which is not a good choice.\ndiff --git a/services/libs/aster-std/src/device/mod.rs b/services/libs/aster-std/src/device/mod.rs\nindex 79d1248d29..add0439d5f 100644\n--- a/services/libs/aster-std/src/device/mod.rs\n+++ b/services/libs/aster-std/src/device/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod null;\n mod pty;\n mod random;\ndiff --git a/services/libs/aster-std/src/device/null.rs b/services/libs/aster-std/src/device/null.rs\nindex 7137a64edf..81426c621c 100644\n--- a/services/libs/aster-std/src/device/null.rs\n+++ b/services/libs/aster-std/src/device/null.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n use crate::events::IoEvents;\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/device/pty/mod.rs b/services/libs/aster-std/src/device/pty/mod.rs\nindex 8ee323a677..45655f692e 100644\n--- a/services/libs/aster-std/src/device/pty/mod.rs\n+++ b/services/libs/aster-std/src/device/pty/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::devpts::DevPts;\n use crate::fs::fs_resolver::{FsPath, FsResolver};\n use crate::fs::utils::{Dentry, Inode, InodeMode, InodeType};\ndiff --git a/services/libs/aster-std/src/device/pty/pty.rs b/services/libs/aster-std/src/device/pty/pty.rs\nindex 748edb3ecc..e10cc948b0 100644\n--- a/services/libs/aster-std/src/device/pty/pty.rs\n+++ b/services/libs/aster-std/src/device/pty/pty.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::format;\n use ringbuf::{ring_buffer::RbBase, HeapRb, Rb};\n \ndiff --git a/services/libs/aster-std/src/device/random.rs b/services/libs/aster-std/src/device/random.rs\nindex 4ed22a5e20..74f13e32ab 100644\n--- a/services/libs/aster-std/src/device/random.rs\n+++ b/services/libs/aster-std/src/device/random.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/device/tdxguest/mod.rs b/services/libs/aster-std/src/device/tdxguest/mod.rs\nindex 6a493d8dab..ba50ebace2 100644\n--- a/services/libs/aster-std/src/device/tdxguest/mod.rs\n+++ b/services/libs/aster-std/src/device/tdxguest/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n use crate::error::Error;\n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/device/tty/device.rs b/services/libs/aster-std/src/device/tty/device.rs\nindex e5f8afb799..b0f76d7a0e 100644\n--- a/services/libs/aster-std/src/device/tty/device.rs\n+++ b/services/libs/aster-std/src/device/tty/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/device/tty/driver.rs b/services/libs/aster-std/src/device/tty/driver.rs\nindex 8801680db3..951dd1084b 100644\n--- a/services/libs/aster-std/src/device/tty/driver.rs\n+++ b/services/libs/aster-std/src/device/tty/driver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub use aster_frame::arch::console::register_console_input_callback;\n use spin::Once;\n \ndiff --git a/services/libs/aster-std/src/device/tty/line_discipline.rs b/services/libs/aster-std/src/device/tty/line_discipline.rs\nindex 29ace51903..63117009cd 100644\n--- a/services/libs/aster-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/aster-std/src/device/tty/line_discipline.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::prelude::*;\n use crate::process::signal::constants::{SIGINT, SIGQUIT};\ndiff --git a/services/libs/aster-std/src/device/tty/mod.rs b/services/libs/aster-std/src/device/tty/mod.rs\nindex 1aea18dadb..dfb1f53940 100644\n--- a/services/libs/aster-std/src/device/tty/mod.rs\n+++ b/services/libs/aster-std/src/device/tty/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use spin::Once;\n \n use self::driver::TtyDriver;\ndiff --git a/services/libs/aster-std/src/device/tty/termio.rs b/services/libs/aster-std/src/device/tty/termio.rs\nindex b7074e719c..d9f256e201 100644\n--- a/services/libs/aster-std/src/device/tty/termio.rs\n+++ b/services/libs/aster-std/src/device/tty/termio.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(non_camel_case_types)]\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/device/urandom.rs b/services/libs/aster-std/src/device/urandom.rs\nindex 687ecb762b..82828d02c7 100644\n--- a/services/libs/aster-std/src/device/urandom.rs\n+++ b/services/libs/aster-std/src/device/urandom.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/device/zero.rs b/services/libs/aster-std/src/device/zero.rs\nindex e3b695cd97..f72c8fa02a 100644\n--- a/services/libs/aster-std/src/device/zero.rs\n+++ b/services/libs/aster-std/src/device/zero.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n use crate::events::IoEvents;\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/driver/mod.rs b/services/libs/aster-std/src/driver/mod.rs\nindex 2ef474470a..750803b5e2 100644\n--- a/services/libs/aster-std/src/driver/mod.rs\n+++ b/services/libs/aster-std/src/driver/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use log::info;\n \n pub fn init() {\ndiff --git a/services/libs/aster-std/src/error.rs b/services/libs/aster-std/src/error.rs\nindex e23d819cdc..8d2b1346da 100644\n--- a/services/libs/aster-std/src/error.rs\n+++ b/services/libs/aster-std/src/error.rs\n@@ -1,4 +1,6 @@\n-/// Errno. Copied from Occlum\n+// SPDX-License-Identifier: MPL-2.0\n+\n+/// Error number.\n #[repr(i32)]\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Errno {\ndiff --git a/services/libs/aster-std/src/events/events.rs b/services/libs/aster-std/src/events/events.rs\nindex 1c4ff51abf..0ca220e335 100644\n--- a/services/libs/aster-std/src/events/events.rs\n+++ b/services/libs/aster-std/src/events/events.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// A trait to represent any events.\n ///\n /// # The unit event\ndiff --git a/services/libs/aster-std/src/events/io_events.rs b/services/libs/aster-std/src/events/io_events.rs\nindex 7f8111f344..029bddafdd 100644\n--- a/services/libs/aster-std/src/events/io_events.rs\n+++ b/services/libs/aster-std/src/events/io_events.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{Events, EventsFilter};\n \n crate::bitflags! {\ndiff --git a/services/libs/aster-std/src/events/mod.rs b/services/libs/aster-std/src/events/mod.rs\nindex b977e5f87d..51a625d351 100644\n--- a/services/libs/aster-std/src/events/mod.rs\n+++ b/services/libs/aster-std/src/events/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #[allow(clippy::module_inception)]\n mod events;\n mod io_events;\ndiff --git a/services/libs/aster-std/src/events/observer.rs b/services/libs/aster-std/src/events/observer.rs\nindex 6f2052b49a..dc5c11fa0d 100644\n--- a/services/libs/aster-std/src/events/observer.rs\n+++ b/services/libs/aster-std/src/events/observer.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Events;\n \n /// An observer for events.\ndiff --git a/services/libs/aster-std/src/events/subject.rs b/services/libs/aster-std/src/events/subject.rs\nindex f5bbd4c00c..376fe1eda4 100644\n--- a/services/libs/aster-std/src/events/subject.rs\n+++ b/services/libs/aster-std/src/events/subject.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use core::sync::atomic::{AtomicUsize, Ordering};\ndiff --git a/services/libs/aster-std/src/fs/device.rs b/services/libs/aster-std/src/fs/device.rs\nindex d93928f5dc..1f45b4370f 100644\n--- a/services/libs/aster-std/src/fs/device.rs\n+++ b/services/libs/aster-std/src/fs/device.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::fs_resolver::{FsPath, FsResolver};\n use crate::fs::utils::Dentry;\n use crate::fs::utils::{InodeMode, InodeType};\ndiff --git a/services/libs/aster-std/src/fs/devpts/mod.rs b/services/libs/aster-std/src/fs/devpts/mod.rs\nindex 99f75ff862..4af0873749 100644\n--- a/services/libs/aster-std/src/fs/devpts/mod.rs\n+++ b/services/libs/aster-std/src/fs/devpts/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::device::PtyMaster;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::utils::{\ndiff --git a/services/libs/aster-std/src/fs/devpts/ptmx.rs b/services/libs/aster-std/src/fs/devpts/ptmx.rs\nindex 398d86adc9..1d23120697 100644\n--- a/services/libs/aster-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/aster-std/src/fs/devpts/ptmx.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::device::PtyMaster;\n use crate::events::IoEvents;\n use crate::fs::inode_handle::FileIo;\ndiff --git a/services/libs/aster-std/src/fs/devpts/slave.rs b/services/libs/aster-std/src/fs/devpts/slave.rs\nindex 6bb34fbfd1..1f0b29b793 100644\n--- a/services/libs/aster-std/src/fs/devpts/slave.rs\n+++ b/services/libs/aster-std/src/fs/devpts/slave.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/epoll/epoll_file.rs b/services/libs/aster-std/src/fs/epoll/epoll_file.rs\nindex 5282766780..8fe9d06fda 100644\n--- a/services/libs/aster-std/src/fs/epoll/epoll_file.rs\n+++ b/services/libs/aster-std/src/fs/epoll/epoll_file.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{IoEvents, Observer};\n use crate::fs::file_handle::FileLike;\n use crate::fs::file_table::{FdEvents, FileDescripter};\ndiff --git a/services/libs/aster-std/src/fs/epoll/mod.rs b/services/libs/aster-std/src/fs/epoll/mod.rs\nindex 66ae3bfc90..c4fbbed750 100644\n--- a/services/libs/aster-std/src/fs/epoll/mod.rs\n+++ b/services/libs/aster-std/src/fs/epoll/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::file_table::FileDescripter;\n use crate::events::IoEvents;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/ext2/block_group.rs b/services/libs/aster-std/src/fs/ext2/block_group.rs\nindex 1941328dfa..1d85f6b64d 100644\n--- a/services/libs/aster-std/src/fs/ext2/block_group.rs\n+++ b/services/libs/aster-std/src/fs/ext2/block_group.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::fs::Ext2;\n use super::inode::{Inode, InodeDesc, RawInode};\n use super::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/ext2/blocks_hole.rs b/services/libs/aster-std/src/fs/ext2/blocks_hole.rs\nindex da924b651a..3214eced1e 100644\n--- a/services/libs/aster-std/src/fs/ext2/blocks_hole.rs\n+++ b/services/libs/aster-std/src/fs/ext2/blocks_hole.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitvec::prelude::BitVec;\n \n /// A blocks hole descriptor implemented by the `BitVec`.\ndiff --git a/services/libs/aster-std/src/fs/ext2/dir.rs b/services/libs/aster-std/src/fs/ext2/dir.rs\nindex 5f60bcdb28..5ca1faefe1 100644\n--- a/services/libs/aster-std/src/fs/ext2/dir.rs\n+++ b/services/libs/aster-std/src/fs/ext2/dir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::inode::{FileType, MAX_FNAME_LEN};\n use super::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/ext2/fs.rs b/services/libs/aster-std/src/fs/ext2/fs.rs\nindex 45b47c0a9f..4113fc7cb3 100644\n--- a/services/libs/aster-std/src/fs/ext2/fs.rs\n+++ b/services/libs/aster-std/src/fs/ext2/fs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::block_group::{BlockGroup, RawGroupDescriptor};\n use super::inode::{FilePerm, FileType, Inode, InodeDesc, RawInode};\n use super::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/fs.rs b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/fs.rs\nindex e65f431940..691314f704 100644\n--- a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/fs.rs\n+++ b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/fs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::ext2::{utils::Dirty, Ext2, SuperBlock as Ext2SuperBlock, MAGIC_NUM as EXT2_MAGIC};\n use crate::fs::utils::{FileSystem, FsFlags, Inode, SuperBlock, NAME_MAX};\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/inode.rs b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/inode.rs\nindex fd4ae92123..83d936a3b9 100644\n--- a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/inode.rs\n+++ b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/inode.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::device::Device;\n use crate::fs::ext2::{FilePerm, FileType, Inode as Ext2Inode};\n use crate::fs::utils::{\ndiff --git a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/mod.rs b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/mod.rs\nindex 249746aab0..311217dbb7 100644\n--- a/services/libs/aster-std/src/fs/ext2/impl_for_vfs/mod.rs\n+++ b/services/libs/aster-std/src/fs/ext2/impl_for_vfs/mod.rs\n@@ -1,2 +1,4 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod fs;\n mod inode;\ndiff --git a/services/libs/aster-std/src/fs/ext2/inode.rs b/services/libs/aster-std/src/fs/ext2/inode.rs\nindex 61bdf58d5e..ca79ada0e6 100644\n--- a/services/libs/aster-std/src/fs/ext2/inode.rs\n+++ b/services/libs/aster-std/src/fs/ext2/inode.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::blocks_hole::BlocksHoleDesc;\n use super::dir::{DirEntry, DirEntryReader, DirEntryWriter};\n use super::fs::Ext2;\ndiff --git a/services/libs/aster-std/src/fs/ext2/mod.rs b/services/libs/aster-std/src/fs/ext2/mod.rs\nindex ff7774871a..b1c107c249 100644\n--- a/services/libs/aster-std/src/fs/ext2/mod.rs\n+++ b/services/libs/aster-std/src/fs/ext2/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! A safe Rust Ext2 filesystem.\n //!\n //! The Second Extended File System(Ext2) is a major rewrite of the Ext filesystem.\ndiff --git a/services/libs/aster-std/src/fs/ext2/prelude.rs b/services/libs/aster-std/src/fs/ext2/prelude.rs\nindex 6fc487b7a6..716389edcd 100644\n--- a/services/libs/aster-std/src/fs/ext2/prelude.rs\n+++ b/services/libs/aster-std/src/fs/ext2/prelude.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub(super) use super::utils::{Dirty, IsPowerOf};\n \n pub(super) use crate::fs::utils::{\ndiff --git a/services/libs/aster-std/src/fs/ext2/super_block.rs b/services/libs/aster-std/src/fs/ext2/super_block.rs\nindex 631b96ee09..8b8c2cde9b 100644\n--- a/services/libs/aster-std/src/fs/ext2/super_block.rs\n+++ b/services/libs/aster-std/src/fs/ext2/super_block.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::inode::RawInode;\n use super::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/ext2/utils.rs b/services/libs/aster-std/src/fs/ext2/utils.rs\nindex 8d28703194..cd41c9d2ab 100644\n--- a/services/libs/aster-std/src/fs/ext2/utils.rs\n+++ b/services/libs/aster-std/src/fs/ext2/utils.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::prelude::*;\n \n use core::ops::MulAssign;\ndiff --git a/services/libs/aster-std/src/fs/file_handle.rs b/services/libs/aster-std/src/fs/file_handle.rs\nindex 8bc4c71bd7..23e0156fd5 100644\n--- a/services/libs/aster-std/src/fs/file_handle.rs\n+++ b/services/libs/aster-std/src/fs/file_handle.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Opend File Handle\n \n use crate::events::{IoEvents, Observer};\ndiff --git a/services/libs/aster-std/src/fs/file_table.rs b/services/libs/aster-std/src/fs/file_table.rs\nindex a3eeb0a0ce..df48d5fdec 100644\n--- a/services/libs/aster-std/src/fs/file_table.rs\n+++ b/services/libs/aster-std/src/fs/file_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{Events, Observer, Subject};\n use crate::net::socket::Socket;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/fs/fs_resolver.rs b/services/libs/aster-std/src/fs/fs_resolver.rs\nindex 776eec7dfa..b98b032ef2 100644\n--- a/services/libs/aster-std/src/fs/fs_resolver.rs\n+++ b/services/libs/aster-std/src/fs/fs_resolver.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use alloc::str;\n \ndiff --git a/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\nindex f554f46213..3e62d1b00a 100644\n--- a/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::prelude::*;\n use crate::process::signal::Poller;\ndiff --git a/services/libs/aster-std/src/fs/inode_handle/mod.rs b/services/libs/aster-std/src/fs/inode_handle/mod.rs\nindex e84dba0a22..695edfab00 100644\n--- a/services/libs/aster-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Opend Inode-backed File Handle\n \n mod dyn_cap;\ndiff --git a/services/libs/aster-std/src/fs/inode_handle/static_cap.rs b/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\nindex 1744f4815e..77e2ac0cba 100644\n--- a/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_rights::{Read, TRightSet, TRights, Write};\n use aster_rights_proc::require;\ndiff --git a/services/libs/aster-std/src/fs/mod.rs b/services/libs/aster-std/src/fs/mod.rs\nindex 644e8d170f..52bf23673b 100644\n--- a/services/libs/aster-std/src/fs/mod.rs\n+++ b/services/libs/aster-std/src/fs/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod device;\n pub mod devpts;\n pub mod epoll;\ndiff --git a/services/libs/aster-std/src/fs/pipe.rs b/services/libs/aster-std/src/fs/pipe.rs\nindex d7992ca49a..6ccf69c793 100644\n--- a/services/libs/aster-std/src/fs/pipe.rs\n+++ b/services/libs/aster-std/src/fs/pipe.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{IoEvents, Observer};\n use crate::prelude::*;\n use crate::process::signal::Poller;\ndiff --git a/services/libs/aster-std/src/fs/procfs/mod.rs b/services/libs/aster-std/src/fs/procfs/mod.rs\nindex f1fec834a4..4a9e4c17cf 100644\n--- a/services/libs/aster-std/src/fs/procfs/mod.rs\n+++ b/services/libs/aster-std/src/fs/procfs/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicUsize, Ordering};\n \n use crate::events::Observer;\ndiff --git a/services/libs/aster-std/src/fs/procfs/pid/comm.rs b/services/libs/aster-std/src/fs/procfs/pid/comm.rs\nindex 20b1e3533b..7b906a7f92 100644\n--- a/services/libs/aster-std/src/fs/procfs/pid/comm.rs\n+++ b/services/libs/aster-std/src/fs/procfs/pid/comm.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n \n /// Represents the inode at `/proc/[pid]/comm`.\ndiff --git a/services/libs/aster-std/src/fs/procfs/pid/exe.rs b/services/libs/aster-std/src/fs/procfs/pid/exe.rs\nindex 22a9f42f91..016f137465 100644\n--- a/services/libs/aster-std/src/fs/procfs/pid/exe.rs\n+++ b/services/libs/aster-std/src/fs/procfs/pid/exe.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n \n /// Represents the inode at `/proc/[pid]/exe`.\ndiff --git a/services/libs/aster-std/src/fs/procfs/pid/fd.rs b/services/libs/aster-std/src/fs/procfs/pid/fd.rs\nindex 49c9dc004b..335757b04d 100644\n--- a/services/libs/aster-std/src/fs/procfs/pid/fd.rs\n+++ b/services/libs/aster-std/src/fs/procfs/pid/fd.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n use crate::fs::file_handle::FileLike;\n use crate::fs::file_table::FileDescripter;\ndiff --git a/services/libs/aster-std/src/fs/procfs/pid/mod.rs b/services/libs/aster-std/src/fs/procfs/pid/mod.rs\nindex da4548e2ae..bb4987b53f 100644\n--- a/services/libs/aster-std/src/fs/procfs/pid/mod.rs\n+++ b/services/libs/aster-std/src/fs/procfs/pid/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::Observer;\n use crate::fs::file_table::FdEvents;\n use crate::fs::utils::{DirEntryVecExt, Inode};\ndiff --git a/services/libs/aster-std/src/fs/procfs/self_.rs b/services/libs/aster-std/src/fs/procfs/self_.rs\nindex a046a7655a..0fa34b3f79 100644\n--- a/services/libs/aster-std/src/fs/procfs/self_.rs\n+++ b/services/libs/aster-std/src/fs/procfs/self_.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::*;\n \n /// Represents the inode at `/proc/self`.\ndiff --git a/services/libs/aster-std/src/fs/procfs/template/builder.rs b/services/libs/aster-std/src/fs/procfs/template/builder.rs\nindex 60263a6acd..560db8c30b 100644\n--- a/services/libs/aster-std/src/fs/procfs/template/builder.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/builder.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::utils::{FileSystem, Inode};\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/procfs/template/dir.rs b/services/libs/aster-std/src/fs/procfs/template/dir.rs\nindex 251c623122..22076b9ad6 100644\n--- a/services/libs/aster-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/dir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_util::slot_vec::SlotVec;\n use core::time::Duration;\n \ndiff --git a/services/libs/aster-std/src/fs/procfs/template/file.rs b/services/libs/aster-std/src/fs/procfs/template/file.rs\nindex ad810575c6..5312f26009 100644\n--- a/services/libs/aster-std/src/fs/procfs/template/file.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/file.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::fs::utils::{FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata};\ndiff --git a/services/libs/aster-std/src/fs/procfs/template/mod.rs b/services/libs/aster-std/src/fs/procfs/template/mod.rs\nindex d15fa01a88..3eb4e5163a 100644\n--- a/services/libs/aster-std/src/fs/procfs/template/mod.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::fs::utils::{FileSystem, InodeMode, Metadata};\ndiff --git a/services/libs/aster-std/src/fs/procfs/template/sym.rs b/services/libs/aster-std/src/fs/procfs/template/sym.rs\nindex 289438e0a4..68e22496d7 100644\n--- a/services/libs/aster-std/src/fs/procfs/template/sym.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/sym.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::fs::utils::{FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata};\ndiff --git a/services/libs/aster-std/src/fs/ramfs/fs.rs b/services/libs/aster-std/src/fs/ramfs/fs.rs\nindex 8a2f17cadd..7a6ab7c499 100644\n--- a/services/libs/aster-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/aster-std/src/fs/ramfs/fs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::sync::RwLockWriteGuard;\n use aster_frame::vm::VmFrame;\n use aster_frame::vm::VmIo;\ndiff --git a/services/libs/aster-std/src/fs/ramfs/mod.rs b/services/libs/aster-std/src/fs/ramfs/mod.rs\nindex 9bf41b31c3..c407cf701c 100644\n--- a/services/libs/aster-std/src/fs/ramfs/mod.rs\n+++ b/services/libs/aster-std/src/fs/ramfs/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Ramfs based on PageCache\n \n pub use fs::RamFS;\ndiff --git a/services/libs/aster-std/src/fs/rootfs.rs b/services/libs/aster-std/src/fs/rootfs.rs\nindex ea61135800..b3afaca680 100644\n--- a/services/libs/aster-std/src/fs/rootfs.rs\n+++ b/services/libs/aster-std/src/fs/rootfs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::fs_resolver::{FsPath, FsResolver};\ndiff --git a/services/libs/aster-std/src/fs/utils/access_mode.rs b/services/libs/aster-std/src/fs/utils/access_mode.rs\nindex cbf76ba378..29cf2529b3 100644\n--- a/services/libs/aster-std/src/fs/utils/access_mode.rs\n+++ b/services/libs/aster-std/src/fs/utils/access_mode.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_rights::Rights;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/channel.rs b/services/libs/aster-std/src/fs/utils/channel.rs\nindex 722953cafd..164bd76a4d 100644\n--- a/services/libs/aster-std/src/fs/utils/channel.rs\n+++ b/services/libs/aster-std/src/fs/utils/channel.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_rights_proc::require;\n use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n use ringbuf::{HeapConsumer as HeapRbConsumer, HeapProducer as HeapRbProducer, HeapRb};\ndiff --git a/services/libs/aster-std/src/fs/utils/creation_flags.rs b/services/libs/aster-std/src/fs/utils/creation_flags.rs\nindex dc6bfe1d50..d6e69014a7 100644\n--- a/services/libs/aster-std/src/fs/utils/creation_flags.rs\n+++ b/services/libs/aster-std/src/fs/utils/creation_flags.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitflags::bitflags;\n \n bitflags! {\ndiff --git a/services/libs/aster-std/src/fs/utils/dentry.rs b/services/libs/aster-std/src/fs/utils/dentry.rs\nindex a4c3d8c6e6..21cf04717f 100644\n--- a/services/libs/aster-std/src/fs/utils/dentry.rs\n+++ b/services/libs/aster-std/src/fs/utils/dentry.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::device::Device;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/dirent_visitor.rs b/services/libs/aster-std/src/fs/utils/dirent_visitor.rs\nindex 2bd2642ce4..d47b215741 100644\n--- a/services/libs/aster-std/src/fs/utils/dirent_visitor.rs\n+++ b/services/libs/aster-std/src/fs/utils/dirent_visitor.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::InodeType;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/direntry_vec.rs b/services/libs/aster-std/src/fs/utils/direntry_vec.rs\nindex 45c4b6b7ab..43ac243b8a 100644\n--- a/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n+++ b/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Inode;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/file_creation_mask.rs b/services/libs/aster-std/src/fs/utils/file_creation_mask.rs\nindex 2a2e9d98f3..42e54bb903 100644\n--- a/services/libs/aster-std/src/fs/utils/file_creation_mask.rs\n+++ b/services/libs/aster-std/src/fs/utils/file_creation_mask.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// A mask for the file mode of a newly-created file or directory.\n ///\n /// This mask is always a subset of `0o777`.\ndiff --git a/services/libs/aster-std/src/fs/utils/fs.rs b/services/libs/aster-std/src/fs/utils/fs.rs\nindex f06a5d8691..033d52dabe 100644\n--- a/services/libs/aster-std/src/fs/utils/fs.rs\n+++ b/services/libs/aster-std/src/fs/utils/fs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Inode;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/fs/utils/inode.rs b/services/libs/aster-std/src/fs/utils/inode.rs\nindex 01143dc471..e611503703 100644\n--- a/services/libs/aster-std/src/fs/utils/inode.rs\n+++ b/services/libs/aster-std/src/fs/utils/inode.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_rights::Full;\n use core::time::Duration;\n use core2::io::{Error as IoError, ErrorKind as IoErrorKind, Result as IoResult, Write};\ndiff --git a/services/libs/aster-std/src/fs/utils/ioctl.rs b/services/libs/aster-std/src/fs/utils/ioctl.rs\nindex 0901c544b3..4503dcfa34 100644\n--- a/services/libs/aster-std/src/fs/utils/ioctl.rs\n+++ b/services/libs/aster-std/src/fs/utils/ioctl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n #[repr(u32)]\ndiff --git a/services/libs/aster-std/src/fs/utils/mod.rs b/services/libs/aster-std/src/fs/utils/mod.rs\nindex f5595834ca..e71fc4ffcf 100644\n--- a/services/libs/aster-std/src/fs/utils/mod.rs\n+++ b/services/libs/aster-std/src/fs/utils/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! VFS components\n \n pub use access_mode::AccessMode;\ndiff --git a/services/libs/aster-std/src/fs/utils/mount.rs b/services/libs/aster-std/src/fs/utils/mount.rs\nindex 044a6bfdf7..6cef1b12f2 100644\n--- a/services/libs/aster-std/src/fs/utils/mount.rs\n+++ b/services/libs/aster-std/src/fs/utils/mount.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{Dentry, DentryKey, FileSystem, InodeType};\ndiff --git a/services/libs/aster-std/src/fs/utils/page_cache.rs b/services/libs/aster-std/src/fs/utils/page_cache.rs\nindex e685ab1db9..2e2876b81a 100644\n--- a/services/libs/aster-std/src/fs/utils/page_cache.rs\n+++ b/services/libs/aster-std/src/fs/utils/page_cache.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use crate::vm::vmo::{get_page_idx_range, Pager, Vmo, VmoFlags, VmoOptions};\n use aster_rights::Full;\ndiff --git a/services/libs/aster-std/src/fs/utils/status_flags.rs b/services/libs/aster-std/src/fs/utils/status_flags.rs\nindex 2645c332bd..f2d124b948 100644\n--- a/services/libs/aster-std/src/fs/utils/status_flags.rs\n+++ b/services/libs/aster-std/src/fs/utils/status_flags.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitflags::bitflags;\n \n bitflags! {\ndiff --git a/services/libs/aster-std/src/lib.rs b/services/libs/aster-std/src/lib.rs\nindex a58704a868..44063f9af1 100644\n--- a/services/libs/aster-std/src/lib.rs\n+++ b/services/libs/aster-std/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The std library of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/libs/aster-std/src/net/iface/any_socket.rs b/services/libs/aster-std/src/net/iface/any_socket.rs\nindex fbd5e9eb01..21e3aac3f7 100644\n--- a/services/libs/aster-std/src/net/iface/any_socket.rs\n+++ b/services/libs/aster-std/src/net/iface/any_socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::Observer;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/net/iface/common.rs b/services/libs/aster-std/src/net/iface/common.rs\nindex 01890a4466..8bee94f164 100644\n--- a/services/libs/aster-std/src/net/iface/common.rs\n+++ b/services/libs/aster-std/src/net/iface/common.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicU64, Ordering};\n \n use super::Ipv4Address;\ndiff --git a/services/libs/aster-std/src/net/iface/loopback.rs b/services/libs/aster-std/src/net/iface/loopback.rs\nindex 0d40e18fcf..cfb66e2f8e 100644\n--- a/services/libs/aster-std/src/net/iface/loopback.rs\n+++ b/services/libs/aster-std/src/net/iface/loopback.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{IpAddress, Ipv4Address};\n use crate::prelude::*;\n use smoltcp::{\ndiff --git a/services/libs/aster-std/src/net/iface/mod.rs b/services/libs/aster-std/src/net/iface/mod.rs\nindex 92a7013cd3..bdd40c8708 100644\n--- a/services/libs/aster-std/src/net/iface/mod.rs\n+++ b/services/libs/aster-std/src/net/iface/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use self::common::IfaceCommon;\n use crate::prelude::*;\n use smoltcp::iface::SocketSet;\ndiff --git a/services/libs/aster-std/src/net/iface/time.rs b/services/libs/aster-std/src/net/iface/time.rs\nindex d7aced038e..fe6b08e167 100644\n--- a/services/libs/aster-std/src/net/iface/time.rs\n+++ b/services/libs/aster-std/src/net/iface/time.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::timer::read_monotonic_milli_seconds;\n \n pub(super) fn get_network_timestamp() -> smoltcp::time::Instant {\ndiff --git a/services/libs/aster-std/src/net/iface/util.rs b/services/libs/aster-std/src/net/iface/util.rs\nindex d4dd1acac0..b693a24e9e 100644\n--- a/services/libs/aster-std/src/net/iface/util.rs\n+++ b/services/libs/aster-std/src/net/iface/util.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::timer::read_monotonic_milli_seconds;\n \n use crate::{\ndiff --git a/services/libs/aster-std/src/net/iface/virtio.rs b/services/libs/aster-std/src/net/iface/virtio.rs\nindex aa49034ff9..252a6083fa 100644\n--- a/services/libs/aster-std/src/net/iface/virtio.rs\n+++ b/services/libs/aster-std/src/net/iface/virtio.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::sync::SpinLock;\n use aster_network::AnyNetworkDevice;\ndiff --git a/services/libs/aster-std/src/net/mod.rs b/services/libs/aster-std/src/net/mod.rs\nindex bf368dd371..52ac4d1b77 100644\n--- a/services/libs/aster-std/src/net/mod.rs\n+++ b/services/libs/aster-std/src/net/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     net::iface::{Iface, IfaceLoopback, IfaceVirtio},\n     prelude::*,\ndiff --git a/services/libs/aster-std/src/net/socket/ip/always_some.rs b/services/libs/aster-std/src/net/socket/ip/always_some.rs\nindex e1ee83a5f2..d359110d28 100644\n--- a/services/libs/aster-std/src/net/socket/ip/always_some.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/always_some.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use core::ops::{Deref, DerefMut};\n \ndiff --git a/services/libs/aster-std/src/net/socket/ip/common.rs b/services/libs/aster-std/src/net/socket/ip/common.rs\nindex 0e18ff42a0..c1261a7189 100644\n--- a/services/libs/aster-std/src/net/socket/ip/common.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/common.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::net::iface::BindPortConfig;\n use crate::net::iface::Iface;\n use crate::net::iface::{AnyBoundSocket, AnyUnboundSocket};\ndiff --git a/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs b/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs\nindex 9f8ee372c4..6ec2352fa4 100644\n--- a/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{IoEvents, Observer};\n use crate::net::iface::IpEndpoint;\n \ndiff --git a/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs b/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs\nindex 261035cf8f..6f06da6f03 100644\n--- a/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs b/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs\nindex 102a7d8180..9ea1cabf0b 100644\n--- a/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::net::iface::IpEndpoint;\n \ndiff --git a/services/libs/aster-std/src/net/socket/ip/mod.rs b/services/libs/aster-std/src/net/socket/ip/mod.rs\nindex 1f66a3f507..b6cf51ac68 100644\n--- a/services/libs/aster-std/src/net/socket/ip/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod always_some;\n mod common;\n mod datagram;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/connected.rs b/services/libs/aster-std/src/net/socket/ip/stream/connected.rs\nindex a5d5d299e2..c70a8f6173 100644\n--- a/services/libs/aster-std/src/net/socket/ip/stream/connected.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/connected.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::{IoEvents, Observer};\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs b/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs\nindex d97e3ff47f..9a1ff54f51 100644\n--- a/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use alloc::sync::Arc;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/init.rs b/services/libs/aster-std/src/net/socket/ip/stream/init.rs\nindex c2d33b4d1c..ec0f7f29eb 100644\n--- a/services/libs/aster-std/src/net/socket/ip/stream/init.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/init.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/listen.rs b/services/libs/aster-std/src/net/socket/ip/stream/listen.rs\nindex bc3d238005..8f8cfbfe4e 100644\n--- a/services/libs/aster-std/src/net/socket/ip/stream/listen.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/listen.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::{IoEvents, Observer};\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/mod.rs b/services/libs/aster-std/src/net/socket/ip/stream/mod.rs\nindex 01b6b7ff27..c78bb6e92c 100644\n--- a/services/libs/aster-std/src/net/socket/ip/stream/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::file_handle::FileLike;\n use crate::fs::utils::StatusFlags;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/options.rs b/services/libs/aster-std/src/net/socket/ip/stream/options.rs\nindex e99a9c1e37..db633feb4f 100644\n--- a/services/libs/aster-std/src/net/socket/ip/stream/options.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::impl_socket_options;\n \n use super::CongestionControl;\ndiff --git a/services/libs/aster-std/src/net/socket/ip/stream/util.rs b/services/libs/aster-std/src/net/socket/ip/stream/util.rs\nindex c37b1c0f3c..1f22ba9a96 100644\n--- a/services/libs/aster-std/src/net/socket/ip/stream/util.rs\n+++ b/services/libs/aster-std/src/net/socket/ip/stream/util.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n #[derive(Debug, Clone, Copy, CopyGetters, Setters)]\ndiff --git a/services/libs/aster-std/src/net/socket/mod.rs b/services/libs/aster-std/src/net/socket/mod.rs\nindex 2d92a02fd9..b629664ae1 100644\n--- a/services/libs/aster-std/src/net/socket/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{fs::file_handle::FileLike, prelude::*};\n \n use self::options::SocketOption;\ndiff --git a/services/libs/aster-std/src/net/socket/options/macros.rs b/services/libs/aster-std/src/net/socket/options/macros.rs\nindex c1f73a9079..c81b4a3216 100644\n--- a/services/libs/aster-std/src/net/socket/options/macros.rs\n+++ b/services/libs/aster-std/src/net/socket/options/macros.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #[macro_export]\n macro_rules! impl_socket_options {\n     ($(\ndiff --git a/services/libs/aster-std/src/net/socket/options/mod.rs b/services/libs/aster-std/src/net/socket/options/mod.rs\nindex 3cbb682459..8b8f66103e 100644\n--- a/services/libs/aster-std/src/net/socket/options/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/options/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::impl_socket_options;\n use crate::prelude::*;\n mod macros;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/addr.rs b/services/libs/aster-std/src/net/socket/unix/addr.rs\nindex d4f4b5e50f..d470e5e314 100644\n--- a/services/libs/aster-std/src/net/socket/unix/addr.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/addr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::utils::Dentry;\n use crate::net::socket::util::socket_addr::SocketAddr;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/mod.rs b/services/libs/aster-std/src/net/socket/unix/mod.rs\nindex 0d54d2de80..698dbf54ad 100644\n--- a/services/libs/aster-std/src/net/socket/unix/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod addr;\n mod stream;\n \ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/connected.rs b/services/libs/aster-std/src/net/socket/unix/stream/connected.rs\nindex f4d611b3f0..f7e2602224 100644\n--- a/services/libs/aster-std/src/net/socket/unix/stream/connected.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/connected.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::endpoint::Endpoint;\n use crate::events::IoEvents;\n use crate::net::socket::{unix::addr::UnixSocketAddrBound, SockShutdownCmd};\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs b/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs\nindex 9071fd3786..30e9c8b67f 100644\n--- a/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::process::signal::Poller;\n use crate::{\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/init.rs b/services/libs/aster-std/src/net/socket/unix/stream/init.rs\nindex cc6c341243..748c5ca559 100644\n--- a/services/libs/aster-std/src/net/socket/unix/stream/init.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/init.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/listener.rs b/services/libs/aster-std/src/net/socket/unix/stream/listener.rs\nindex c406eb52c3..4f3650a48c 100644\n--- a/services/libs/aster-std/src/net/socket/unix/stream/listener.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/listener.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{connected::Connected, endpoint::Endpoint, UnixStreamSocket};\n use crate::events::IoEvents;\n use crate::fs::file_handle::FileLike;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/mod.rs b/services/libs/aster-std/src/net/socket/unix/stream/mod.rs\nindex 52fd78f7b0..ca5d91ff0c 100644\n--- a/services/libs/aster-std/src/net/socket/unix/stream/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod connected;\n mod endpoint;\n mod init;\ndiff --git a/services/libs/aster-std/src/net/socket/unix/stream/socket.rs b/services/libs/aster-std/src/net/socket/unix/stream/socket.rs\nindex 5eb6390b0e..1ecc7a950b 100644\n--- a/services/libs/aster-std/src/net/socket/unix/stream/socket.rs\n+++ b/services/libs/aster-std/src/net/socket/unix/stream/socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::fs::file_handle::FileLike;\n use crate::fs::fs_resolver::FsPath;\ndiff --git a/services/libs/aster-std/src/net/socket/util/mod.rs b/services/libs/aster-std/src/net/socket/util/mod.rs\nindex cf76c1473d..7478fe95ed 100644\n--- a/services/libs/aster-std/src/net/socket/util/mod.rs\n+++ b/services/libs/aster-std/src/net/socket/util/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod options;\n pub mod send_recv_flags;\n pub mod shutdown_cmd;\ndiff --git a/services/libs/aster-std/src/net/socket/util/options.rs b/services/libs/aster-std/src/net/socket/util/options.rs\nindex 68afa53184..20c4d48930 100644\n--- a/services/libs/aster-std/src/net/socket/util/options.rs\n+++ b/services/libs/aster-std/src/net/socket/util/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::net::iface::{RECV_BUF_LEN, SEND_BUF_LEN};\ndiff --git a/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs b/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs\nindex a8f36077b1..e7fe906deb 100644\n--- a/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs\n+++ b/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n bitflags! {\ndiff --git a/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs b/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs\nindex 81fa84f9e8..8eecdb4f4d 100644\n--- a/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs\n+++ b/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// Shutdown types\ndiff --git a/services/libs/aster-std/src/net/socket/util/socket_addr.rs b/services/libs/aster-std/src/net/socket/util/socket_addr.rs\nindex b9b92c27d9..80fadb52a0 100644\n--- a/services/libs/aster-std/src/net/socket/util/socket_addr.rs\n+++ b/services/libs/aster-std/src/net/socket/util/socket_addr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::net::iface::{IpAddress, Ipv4Address};\n use crate::net::iface::{IpEndpoint, IpListenEndpoint};\n use crate::net::socket::unix::UnixSocketAddr;\ndiff --git a/services/libs/aster-std/src/prelude.rs b/services/libs/aster-std/src/prelude.rs\nindex 538603340e..d40e7e0169 100644\n--- a/services/libs/aster-std/src/prelude.rs\n+++ b/services/libs/aster-std/src/prelude.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(unused)]\n \n pub(crate) use alloc::boxed::Box;\ndiff --git a/services/libs/aster-std/src/process/clone.rs b/services/libs/aster-std/src/process/clone.rs\nindex 9ca391e71e..0e3b0ea774 100644\n--- a/services/libs/aster-std/src/process/clone.rs\n+++ b/services/libs/aster-std/src/process/clone.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::posix_thread::{PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName};\n use super::process_vm::ProcessVm;\n use super::signal::sig_disposition::SigDispositions;\ndiff --git a/services/libs/aster-std/src/process/credentials/credentials_.rs b/services/libs/aster-std/src/process/credentials/credentials_.rs\nindex 6edd777585..ad3251112b 100644\n--- a/services/libs/aster-std/src/process/credentials/credentials_.rs\n+++ b/services/libs/aster-std/src/process/credentials/credentials_.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::group::AtomicGid;\n use super::user::AtomicUid;\n use super::{Gid, Uid};\ndiff --git a/services/libs/aster-std/src/process/credentials/group.rs b/services/libs/aster-std/src/process/credentials/group.rs\nindex 9a0d6c5bdc..82f639dbce 100644\n--- a/services/libs/aster-std/src/process/credentials/group.rs\n+++ b/services/libs/aster-std/src/process/credentials/group.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicU32, Ordering};\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/credentials/mod.rs b/services/libs/aster-std/src/process/credentials/mod.rs\nindex f5e162a356..158182d398 100644\n--- a/services/libs/aster-std/src/process/credentials/mod.rs\n+++ b/services/libs/aster-std/src/process/credentials/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod credentials_;\n mod group;\n mod static_cap;\ndiff --git a/services/libs/aster-std/src/process/credentials/static_cap.rs b/services/libs/aster-std/src/process/credentials/static_cap.rs\nindex 07e9848a33..37945db687 100644\n--- a/services/libs/aster-std/src/process/credentials/static_cap.rs\n+++ b/services/libs/aster-std/src/process/credentials/static_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::credentials_::Credentials_;\n use super::{Credentials, Gid, Uid};\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/credentials/user.rs b/services/libs/aster-std/src/process/credentials/user.rs\nindex a10e8db706..34f81cda50 100644\n--- a/services/libs/aster-std/src/process/credentials/user.rs\n+++ b/services/libs/aster-std/src/process/credentials/user.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicU32, Ordering};\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/exit.rs b/services/libs/aster-std/src/process/exit.rs\nindex 20da64981b..cb45df21d9 100644\n--- a/services/libs/aster-std/src/process/exit.rs\n+++ b/services/libs/aster-std/src/process/exit.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::posix_thread::PosixThreadExt;\n use crate::process::signal::signals::kernel::KernelSignal;\n use crate::{prelude::*, process::signal::constants::SIGCHLD};\ndiff --git a/services/libs/aster-std/src/process/kill.rs b/services/libs/aster-std/src/process/kill.rs\nindex 4bd5658954..9c3e23cc34 100644\n--- a/services/libs/aster-std/src/process/kill.rs\n+++ b/services/libs/aster-std/src/process/kill.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::posix_thread::PosixThreadExt;\n use super::signal::signals::user::UserSignal;\n use super::signal::signals::Signal;\ndiff --git a/services/libs/aster-std/src/process/mod.rs b/services/libs/aster-std/src/process/mod.rs\nindex ef96eb1017..ddadb36778 100644\n--- a/services/libs/aster-std/src/process/mod.rs\n+++ b/services/libs/aster-std/src/process/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod clone;\n mod credentials;\n mod exit;\ndiff --git a/services/libs/aster-std/src/process/posix_thread/builder.rs b/services/libs/aster-std/src/process/posix_thread/builder.rs\nindex 5507dace7b..6cb075ce13 100644\n--- a/services/libs/aster-std/src/process/posix_thread/builder.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/builder.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::user::UserSpace;\n \n use crate::{\ndiff --git a/services/libs/aster-std/src/process/posix_thread/futex.rs b/services/libs/aster-std/src/process/posix_thread/futex.rs\nindex 1259f3f3f0..7f7e4094da 100644\n--- a/services/libs/aster-std/src/process/posix_thread/futex.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/futex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use aster_frame::cpu::num_cpus;\ndiff --git a/services/libs/aster-std/src/process/posix_thread/mod.rs b/services/libs/aster-std/src/process/posix_thread/mod.rs\nindex 4679efe926..fa18fef202 100644\n--- a/services/libs/aster-std/src/process/posix_thread/mod.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::kill::SignalSenderIds;\n use super::signal::sig_mask::SigMask;\n use super::signal::sig_num::SigNum;\ndiff --git a/services/libs/aster-std/src/process/posix_thread/name.rs b/services/libs/aster-std/src/process/posix_thread/name.rs\nindex b8a945ed85..6cc4347e61 100644\n--- a/services/libs/aster-std/src/process/posix_thread/name.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/name.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n pub const MAX_THREAD_NAME_LEN: usize = 16;\ndiff --git a/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs b/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\nindex 8003bfbf42..035ceb4f1d 100644\n--- a/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::{cpu::UserContext, user::UserSpace};\n \n use crate::{\ndiff --git a/services/libs/aster-std/src/process/posix_thread/robust_list.rs b/services/libs/aster-std/src/process/posix_thread/robust_list.rs\nindex f4b5057e2a..5116d26cc7 100644\n--- a/services/libs/aster-std/src/process/posix_thread/robust_list.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/robust_list.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The implementation of robust list is from occlum.\n \n use crate::{\ndiff --git a/services/libs/aster-std/src/process/process/builder.rs b/services/libs/aster-std/src/process/process/builder.rs\nindex 7bbe124485..01caa00db9 100644\n--- a/services/libs/aster-std/src/process/process/builder.rs\n+++ b/services/libs/aster-std/src/process/process/builder.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileTable;\n use crate::fs::fs_resolver::FsResolver;\n use crate::fs::utils::FileCreationMask;\ndiff --git a/services/libs/aster-std/src/process/process/job_control.rs b/services/libs/aster-std/src/process/process/job_control.rs\nindex d5af056c65..5fda59fa6d 100644\n--- a/services/libs/aster-std/src/process/process/job_control.rs\n+++ b/services/libs/aster-std/src/process/process/job_control.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use crate::process::signal::constants::{SIGCONT, SIGHUP};\n use crate::process::signal::signals::kernel::KernelSignal;\ndiff --git a/services/libs/aster-std/src/process/process/mod.rs b/services/libs/aster-std/src/process/process/mod.rs\nindex 6ec2981788..6cde240486 100644\n--- a/services/libs/aster-std/src/process/process/mod.rs\n+++ b/services/libs/aster-std/src/process/process/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::posix_thread::PosixThreadExt;\n use super::process_vm::user_heap::UserHeap;\n use super::process_vm::ProcessVm;\ndiff --git a/services/libs/aster-std/src/process/process/process_group.rs b/services/libs/aster-std/src/process/process/process_group.rs\nindex 9a69d5752b..3c656bec44 100644\n--- a/services/libs/aster-std/src/process/process/process_group.rs\n+++ b/services/libs/aster-std/src/process/process/process_group.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{Pgid, Pid, Process, Session};\n use crate::prelude::*;\n use crate::process::signal::signals::Signal;\ndiff --git a/services/libs/aster-std/src/process/process/session.rs b/services/libs/aster-std/src/process/process/session.rs\nindex 66ce097d16..bb3ce62448 100644\n--- a/services/libs/aster-std/src/process/process/session.rs\n+++ b/services/libs/aster-std/src/process/process/session.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{Pgid, Process, ProcessGroup, Sid, Terminal};\ndiff --git a/services/libs/aster-std/src/process/process/terminal.rs b/services/libs/aster-std/src/process/process/terminal.rs\nindex 94d66b319a..bcca5dc5ad 100644\n--- a/services/libs/aster-std/src/process/process/terminal.rs\n+++ b/services/libs/aster-std/src/process/process/terminal.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n use crate::process::{process_table, Pgid, ProcessGroup};\ndiff --git a/services/libs/aster-std/src/process/process_filter.rs b/services/libs/aster-std/src/process/process_filter.rs\nindex a3f4c494ba..d558d9bf5e 100644\n--- a/services/libs/aster-std/src/process/process_filter.rs\n+++ b/services/libs/aster-std/src/process/process_filter.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{Pgid, Pid};\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/process/process_table.rs b/services/libs/aster-std/src/process/process_table.rs\nindex d5d216c34e..84b1782f62 100644\n--- a/services/libs/aster-std/src/process/process_table.rs\n+++ b/services/libs/aster-std/src/process/process_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! A global table stores the pid to process mapping.\n //! This table can be used to get process with pid.\n //! TODO: progress group, thread all need similar mapping\ndiff --git a/services/libs/aster-std/src/process/process_vm/mod.rs b/services/libs/aster-std/src/process/process_vm/mod.rs\nindex 468b7aa7e0..d38634caab 100644\n--- a/services/libs/aster-std/src/process/process_vm/mod.rs\n+++ b/services/libs/aster-std/src/process/process_vm/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module defines the UserVm of a process.\n //! The UserSpace of a process only contains the virtual-physical memory mapping.\n //! But we cannot know which vaddr is user heap, which vaddr is mmap areas.\ndiff --git a/services/libs/aster-std/src/process/process_vm/user_heap.rs b/services/libs/aster-std/src/process/process_vm/user_heap.rs\nindex 7dff106e40..ba27374e12 100644\n--- a/services/libs/aster-std/src/process/process_vm/user_heap.rs\n+++ b/services/libs/aster-std/src/process/process_vm/user_heap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicUsize, Ordering};\n \n use crate::vm::perms::VmPerms;\ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs b/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs\nindex 228c8f1f4f..e125cbd90a 100644\n--- a/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// This implementation is from occlum.\ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs b/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs\nindex 499f93d038..af1e43e63f 100644\n--- a/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// A wrapper of xmas_elf's elf parsing\n use xmas_elf::{\n     header::{self, Header, HeaderPt1, HeaderPt2, HeaderPt2_, Machine_, Type_},\ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs b/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\nindex 3dce8da1d5..3605525686 100644\n--- a/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module defines the process initial stack.\n //! The process initial stack, contains arguments, environmental variables and auxiliary vectors\n //! The data layout of init stack can be seen in Figure 3.9 in https://uclibc.org/docs/psABI-x86_64.pdf\ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs b/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\nindex f1cc047cbb..6be5b846f7 100644\n--- a/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module is used to parse elf file content to get elf_load_info.\n //! When create a process from elf file, we will use the elf_load_info to construct the VmSpace\n \ndiff --git a/services/libs/aster-std/src/process/program_loader/elf/mod.rs b/services/libs/aster-std/src/process/program_loader/elf/mod.rs\nindex 20ebdd39f4..35dbc0e758 100644\n--- a/services/libs/aster-std/src/process/program_loader/elf/mod.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod aux_vec;\n mod elf_file;\n mod init_stack;\ndiff --git a/services/libs/aster-std/src/process/program_loader/mod.rs b/services/libs/aster-std/src/process/program_loader/mod.rs\nindex c1456e1f5b..e779e48372 100644\n--- a/services/libs/aster-std/src/process/program_loader/mod.rs\n+++ b/services/libs/aster-std/src/process/program_loader/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod elf;\n mod shebang;\n \ndiff --git a/services/libs/aster-std/src/process/program_loader/shebang.rs b/services/libs/aster-std/src/process/program_loader/shebang.rs\nindex 784525ac20..3aa7cb8200 100644\n--- a/services/libs/aster-std/src/process/program_loader/shebang.rs\n+++ b/services/libs/aster-std/src/process/program_loader/shebang.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// Try to parse a buffer as a shebang line.\ndiff --git a/services/libs/aster-std/src/process/rlimit.rs b/services/libs/aster-std/src/process/rlimit.rs\nindex 3c8b0f7d72..cbf95a0299 100644\n--- a/services/libs/aster-std/src/process/rlimit.rs\n+++ b/services/libs/aster-std/src/process/rlimit.rs\n@@ -1,4 +1,4 @@\n-//! This implementation is from occlum\n+// SPDX-License-Identifier: MPL-2.0\n \n #![allow(non_camel_case_types)]\n \ndiff --git a/services/libs/aster-std/src/process/signal/c_types.rs b/services/libs/aster-std/src/process/signal/c_types.rs\nindex 15f4a94afc..47d39dda7b 100644\n--- a/services/libs/aster-std/src/process/signal/c_types.rs\n+++ b/services/libs/aster-std/src/process/signal/c_types.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(non_camel_case_types)]\n use core::mem;\n \ndiff --git a/services/libs/aster-std/src/process/signal/constants.rs b/services/libs/aster-std/src/process/signal/constants.rs\nindex 9c4593e1a0..240ac2a6f9 100644\n--- a/services/libs/aster-std/src/process/signal/constants.rs\n+++ b/services/libs/aster-std/src/process/signal/constants.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// Standard signals\n pub(super) const MIN_STD_SIG_NUM: u8 = 1;\n pub(super) const MAX_STD_SIG_NUM: u8 = 31; // inclusive\ndiff --git a/services/libs/aster-std/src/process/signal/events.rs b/services/libs/aster-std/src/process/signal/events.rs\nindex 37b472609f..a741825ad5 100644\n--- a/services/libs/aster-std/src/process/signal/events.rs\n+++ b/services/libs/aster-std/src/process/signal/events.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::{Events, EventsFilter};\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/process/signal/mod.rs b/services/libs/aster-std/src/process/signal/mod.rs\nindex 950479d582..cd73cda955 100644\n--- a/services/libs/aster-std/src/process/signal/mod.rs\n+++ b/services/libs/aster-std/src/process/signal/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod c_types;\n pub mod constants;\n mod events;\ndiff --git a/services/libs/aster-std/src/process/signal/pauser.rs b/services/libs/aster-std/src/process/signal/pauser.rs\nindex c277c895af..3c2e03ab1e 100644\n--- a/services/libs/aster-std/src/process/signal/pauser.rs\n+++ b/services/libs/aster-std/src/process/signal/pauser.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n use core::time::Duration;\n \ndiff --git a/services/libs/aster-std/src/process/signal/poll.rs b/services/libs/aster-std/src/process/signal/poll.rs\nindex 6cb0f075b6..118c9c83f0 100644\n--- a/services/libs/aster-std/src/process/signal/poll.rs\n+++ b/services/libs/aster-std/src/process/signal/poll.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::events::IoEvents;\n use crate::events::{Observer, Subject};\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/signal/sig_action.rs b/services/libs/aster-std/src/process/signal/sig_action.rs\nindex 937f2e75a5..3203e3102f 100644\n--- a/services/libs/aster-std/src/process/signal/sig_action.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_action.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{c_types::sigaction_t, constants::*, sig_mask::SigMask, sig_num::SigNum};\n use crate::prelude::*;\n use bitflags::bitflags;\ndiff --git a/services/libs/aster-std/src/process/signal/sig_disposition.rs b/services/libs/aster-std/src/process/signal/sig_disposition.rs\nindex f644eb2ca4..26510b6618 100644\n--- a/services/libs/aster-std/src/process/signal/sig_disposition.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_disposition.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{constants::*, sig_action::SigAction, sig_num::SigNum};\n \n #[derive(Copy, Clone)]\ndiff --git a/services/libs/aster-std/src/process/signal/sig_mask.rs b/services/libs/aster-std/src/process/signal/sig_mask.rs\nindex 4758832ee2..d0565f13fa 100644\n--- a/services/libs/aster-std/src/process/signal/sig_mask.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_mask.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{constants::MIN_STD_SIG_NUM, sig_num::SigNum};\n \n #[derive(Debug, Copy, Clone, Default, PartialEq, Eq)]\ndiff --git a/services/libs/aster-std/src/process/signal/sig_num.rs b/services/libs/aster-std/src/process/signal/sig_num.rs\nindex 76a48accbf..f93c764d74 100644\n--- a/services/libs/aster-std/src/process/signal/sig_num.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_num.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::constants::*;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/process/signal/sig_queues.rs b/services/libs/aster-std/src/process/signal/sig_queues.rs\nindex 9b687ea8a1..544fa82ce2 100644\n--- a/services/libs/aster-std/src/process/signal/sig_queues.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_queues.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{constants::*, SigEvents, SigEventsFilter};\n use crate::events::{Observer, Subject};\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/process/signal/sig_stack.rs b/services/libs/aster-std/src/process/signal/sig_stack.rs\nindex b7ce816798..374080df97 100644\n--- a/services/libs/aster-std/src/process/signal/sig_stack.rs\n+++ b/services/libs/aster-std/src/process/signal/sig_stack.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// User-provided signal stack. `SigStack` is per-thread, and each thread can have\ndiff --git a/services/libs/aster-std/src/process/signal/signals/fault.rs b/services/libs/aster-std/src/process/signal/signals/fault.rs\nindex 799af8113c..586c8080a4 100644\n--- a/services/libs/aster-std/src/process/signal/signals/fault.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/fault.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::{CpuException, CpuExceptionInfo};\n use aster_frame::cpu::{\n     ALIGNMENT_CHECK, BOUND_RANGE_EXCEEDED, DIVIDE_BY_ZERO, GENERAL_PROTECTION_FAULT,\ndiff --git a/services/libs/aster-std/src/process/signal/signals/kernel.rs b/services/libs/aster-std/src/process/signal/signals/kernel.rs\nindex cdd17f7540..abe7ad9d17 100644\n--- a/services/libs/aster-std/src/process/signal/signals/kernel.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/kernel.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Signal;\n use crate::process::signal::c_types::siginfo_t;\n use crate::process::signal::constants::SI_KERNEL;\ndiff --git a/services/libs/aster-std/src/process/signal/signals/mod.rs b/services/libs/aster-std/src/process/signal/signals/mod.rs\nindex 15f77042a1..07f2094c3c 100644\n--- a/services/libs/aster-std/src/process/signal/signals/mod.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub mod fault;\n pub mod kernel;\n pub mod user;\ndiff --git a/services/libs/aster-std/src/process/signal/signals/user.rs b/services/libs/aster-std/src/process/signal/signals/user.rs\nindex 40d56e149e..423080be32 100644\n--- a/services/libs/aster-std/src/process/signal/signals/user.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/user.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::Signal;\n use crate::process::signal::c_types::siginfo_t;\n use crate::process::signal::constants::{SI_QUEUE, SI_TKILL, SI_USER};\ndiff --git a/services/libs/aster-std/src/process/status.rs b/services/libs/aster-std/src/process/status.rs\nindex 6b172d0616..4c2b96d9ee 100644\n--- a/services/libs/aster-std/src/process/status.rs\n+++ b/services/libs/aster-std/src/process/status.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The process status\n \n use super::TermStatus;\ndiff --git a/services/libs/aster-std/src/process/term_status.rs b/services/libs/aster-std/src/process/term_status.rs\nindex 5e0e512618..05bb10f224 100644\n--- a/services/libs/aster-std/src/process/term_status.rs\n+++ b/services/libs/aster-std/src/process/term_status.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::signal::sig_num::SigNum;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\ndiff --git a/services/libs/aster-std/src/process/wait.rs b/services/libs/aster-std/src/process/wait.rs\nindex 99e4d45724..f57eba0ce2 100644\n--- a/services/libs/aster-std/src/process/wait.rs\n+++ b/services/libs/aster-std/src/process/wait.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{prelude::*, process::process_table, thread::thread_table};\n \n use super::{process_filter::ProcessFilter, ExitCode, Pid, Process};\ndiff --git a/services/libs/aster-std/src/sched/mod.rs b/services/libs/aster-std/src/sched/mod.rs\nindex b6cf2d58ea..bfa1437c37 100644\n--- a/services/libs/aster-std/src/sched/mod.rs\n+++ b/services/libs/aster-std/src/sched/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod priority_scheduler;\n \n // There may be multiple scheduling policies in the system,\ndiff --git a/services/libs/aster-std/src/sched/priority_scheduler.rs b/services/libs/aster-std/src/sched/priority_scheduler.rs\nindex 4523c1d98f..235ad706cb 100644\n--- a/services/libs/aster-std/src/sched/priority_scheduler.rs\n+++ b/services/libs/aster-std/src/sched/priority_scheduler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::task::{set_scheduler, Scheduler, Task, TaskAdapter};\n use intrusive_collections::LinkedList;\ndiff --git a/services/libs/aster-std/src/syscall/accept.rs b/services/libs/aster-std/src/syscall/accept.rs\nindex 5977afcf9f..b0756329b5 100644\n--- a/services/libs/aster-std/src/syscall/accept.rs\n+++ b/services/libs/aster-std/src/syscall/accept.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/access.rs b/services/libs/aster-std/src/syscall/access.rs\nindex 17cc3b505c..203691769a 100644\n--- a/services/libs/aster-std/src/syscall/access.rs\n+++ b/services/libs/aster-std/src/syscall/access.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{constants::*, SyscallReturn};\n use crate::{log_syscall_entry, prelude::*, syscall::SYS_ACCESS, util::read_cstring_from_user};\n \ndiff --git a/services/libs/aster-std/src/syscall/arch_prctl.rs b/services/libs/aster-std/src/syscall/arch_prctl.rs\nindex c94a4a7e06..5a0ce97a3c 100644\n--- a/services/libs/aster-std/src/syscall/arch_prctl.rs\n+++ b/services/libs/aster-std/src/syscall/arch_prctl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::UserContext;\n \n use crate::syscall::SYS_ARCH_PRCTL;\ndiff --git a/services/libs/aster-std/src/syscall/bind.rs b/services/libs/aster-std/src/syscall/bind.rs\nindex ec49a746d2..93630a2191 100644\n--- a/services/libs/aster-std/src/syscall/bind.rs\n+++ b/services/libs/aster-std/src/syscall/bind.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/brk.rs b/services/libs/aster-std/src/syscall/brk.rs\nindex 528033a251..f32b3298aa 100644\n--- a/services/libs/aster-std/src/syscall/brk.rs\n+++ b/services/libs/aster-std/src/syscall/brk.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/syscall/chdir.rs b/services/libs/aster-std/src/syscall/chdir.rs\nindex fffaa12ad0..8bf5025e6c 100644\n--- a/services/libs/aster-std/src/syscall/chdir.rs\n+++ b/services/libs/aster-std/src/syscall/chdir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter, fs_resolver::FsPath, inode_handle::InodeHandle, utils::InodeType,\n };\ndiff --git a/services/libs/aster-std/src/syscall/chmod.rs b/services/libs/aster-std/src/syscall/chmod.rs\nindex a78992ea0b..e26f398183 100644\n--- a/services/libs/aster-std/src/syscall/chmod.rs\n+++ b/services/libs/aster-std/src/syscall/chmod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/clock_gettime.rs b/services/libs/aster-std/src/syscall/clock_gettime.rs\nindex b1ca852959..4994c50918 100644\n--- a/services/libs/aster-std/src/syscall/clock_gettime.rs\n+++ b/services/libs/aster-std/src/syscall/clock_gettime.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_CLOCK_GETTIME;\n use crate::time::now_as_duration;\ndiff --git a/services/libs/aster-std/src/syscall/clock_nanosleep.rs b/services/libs/aster-std/src/syscall/clock_nanosleep.rs\nindex c94f0336d1..d7254a2fb5 100644\n--- a/services/libs/aster-std/src/syscall/clock_nanosleep.rs\n+++ b/services/libs/aster-std/src/syscall/clock_nanosleep.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use super::SyscallReturn;\ndiff --git a/services/libs/aster-std/src/syscall/clone.rs b/services/libs/aster-std/src/syscall/clone.rs\nindex fc9d9f2402..c13c18f062 100644\n--- a/services/libs/aster-std/src/syscall/clone.rs\n+++ b/services/libs/aster-std/src/syscall/clone.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::UserContext;\n \n use crate::log_syscall_entry;\ndiff --git a/services/libs/aster-std/src/syscall/close.rs b/services/libs/aster-std/src/syscall/close.rs\nindex 3061664ad1..d7c5bc076d 100644\n--- a/services/libs/aster-std/src/syscall/close.rs\n+++ b/services/libs/aster-std/src/syscall/close.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_CLOSE;\n use crate::log_syscall_entry;\ndiff --git a/services/libs/aster-std/src/syscall/connect.rs b/services/libs/aster-std/src/syscall/connect.rs\nindex 5523af8eb7..a7ad69e008 100644\n--- a/services/libs/aster-std/src/syscall/connect.rs\n+++ b/services/libs/aster-std/src/syscall/connect.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/constants.rs b/services/libs/aster-std/src/syscall/constants.rs\nindex e919774e85..80d600ab6f 100644\n--- a/services/libs/aster-std/src/syscall/constants.rs\n+++ b/services/libs/aster-std/src/syscall/constants.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! constants used in syscall\n \n /// LONGEST ALLOWED FILENAME\ndiff --git a/services/libs/aster-std/src/syscall/dup.rs b/services/libs/aster-std/src/syscall/dup.rs\nindex b4e36b47e7..a936243ae2 100644\n--- a/services/libs/aster-std/src/syscall/dup.rs\n+++ b/services/libs/aster-std/src/syscall/dup.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/epoll.rs b/services/libs/aster-std/src/syscall/epoll.rs\nindex fac3921353..8be2f326a4 100644\n--- a/services/libs/aster-std/src/syscall/epoll.rs\n+++ b/services/libs/aster-std/src/syscall/epoll.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/syscall/execve.rs b/services/libs/aster-std/src/syscall/execve.rs\nindex b15e8579d8..b60968dcb2 100644\n--- a/services/libs/aster-std/src/syscall/execve.rs\n+++ b/services/libs/aster-std/src/syscall/execve.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::UserContext;\n use aster_rights::WriteOp;\n \ndiff --git a/services/libs/aster-std/src/syscall/exit.rs b/services/libs/aster-std/src/syscall/exit.rs\nindex b1eb00a160..2a14eb0d10 100644\n--- a/services/libs/aster-std/src/syscall/exit.rs\n+++ b/services/libs/aster-std/src/syscall/exit.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::posix_thread::PosixThreadExt;\n use crate::process::TermStatus;\n use crate::{log_syscall_entry, prelude::*};\ndiff --git a/services/libs/aster-std/src/syscall/exit_group.rs b/services/libs/aster-std/src/syscall/exit_group.rs\nindex aca5c09395..b5d3039937 100644\n--- a/services/libs/aster-std/src/syscall/exit_group.rs\n+++ b/services/libs/aster-std/src/syscall/exit_group.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::{do_exit_group, TermStatus};\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/fcntl.rs b/services/libs/aster-std/src/syscall/fcntl.rs\nindex bbd1fe402c..fbd21fe1a1 100644\n--- a/services/libs/aster-std/src/syscall/fcntl.rs\n+++ b/services/libs/aster-std/src/syscall/fcntl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_FCNTL};\n use crate::log_syscall_entry;\n use crate::{\ndiff --git a/services/libs/aster-std/src/syscall/fork.rs b/services/libs/aster-std/src/syscall/fork.rs\nindex 3fcbaf0478..30729377e0 100644\n--- a/services/libs/aster-std/src/syscall/fork.rs\n+++ b/services/libs/aster-std/src/syscall/fork.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     log_syscall_entry,\n     prelude::*,\ndiff --git a/services/libs/aster-std/src/syscall/fsync.rs b/services/libs/aster-std/src/syscall/fsync.rs\nindex 1e31934e7e..4038e945b8 100644\n--- a/services/libs/aster-std/src/syscall/fsync.rs\n+++ b/services/libs/aster-std/src/syscall/fsync.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::{\n     fs::{file_table::FileDescripter, inode_handle::InodeHandle},\ndiff --git a/services/libs/aster-std/src/syscall/futex.rs b/services/libs/aster-std/src/syscall/futex.rs\nindex 31d491ea86..28dfda1ca8 100644\n--- a/services/libs/aster-std/src/syscall/futex.rs\n+++ b/services/libs/aster-std/src/syscall/futex.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::posix_thread::futex::{\n     futex_op_and_flags_from_u32, futex_requeue, futex_wait, futex_wait_bitset, futex_wake,\n     futex_wake_bitset, FutexOp, FutexTimeout,\ndiff --git a/services/libs/aster-std/src/syscall/getcwd.rs b/services/libs/aster-std/src/syscall/getcwd.rs\nindex 58d04434e5..f464f9965c 100644\n--- a/services/libs/aster-std/src/syscall/getcwd.rs\n+++ b/services/libs/aster-std/src/syscall/getcwd.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::util::write_bytes_to_user;\ndiff --git a/services/libs/aster-std/src/syscall/getdents64.rs b/services/libs/aster-std/src/syscall/getdents64.rs\nindex c959e33e6c..e8842b8c96 100644\n--- a/services/libs/aster-std/src/syscall/getdents64.rs\n+++ b/services/libs/aster-std/src/syscall/getdents64.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     inode_handle::InodeHandle,\ndiff --git a/services/libs/aster-std/src/syscall/getegid.rs b/services/libs/aster-std/src/syscall/getegid.rs\nindex ee29e73c0d..bbf0b24c8d 100644\n--- a/services/libs/aster-std/src/syscall/getegid.rs\n+++ b/services/libs/aster-std/src/syscall/getegid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::credentials;\ndiff --git a/services/libs/aster-std/src/syscall/geteuid.rs b/services/libs/aster-std/src/syscall/geteuid.rs\nindex 8a85b28613..0f980491f6 100644\n--- a/services/libs/aster-std/src/syscall/geteuid.rs\n+++ b/services/libs/aster-std/src/syscall/geteuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETEUID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getgid.rs b/services/libs/aster-std/src/syscall/getgid.rs\nindex 7b718a60ae..1d7ba72388 100644\n--- a/services/libs/aster-std/src/syscall/getgid.rs\n+++ b/services/libs/aster-std/src/syscall/getgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETGID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getgroups.rs b/services/libs/aster-std/src/syscall/getgroups.rs\nindex 319de710b0..56985461a3 100644\n--- a/services/libs/aster-std/src/syscall/getgroups.rs\n+++ b/services/libs/aster-std/src/syscall/getgroups.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETGROUPS};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getpeername.rs b/services/libs/aster-std/src/syscall/getpeername.rs\nindex 3ee51eeb69..01b419e0fd 100644\n--- a/services/libs/aster-std/src/syscall/getpeername.rs\n+++ b/services/libs/aster-std/src/syscall/getpeername.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getpgrp.rs b/services/libs/aster-std/src/syscall/getpgrp.rs\nindex 2ea24c37a7..7df17147d1 100644\n--- a/services/libs/aster-std/src/syscall/getpgrp.rs\n+++ b/services/libs/aster-std/src/syscall/getpgrp.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETPGRP};\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/getpid.rs b/services/libs/aster-std/src/syscall/getpid.rs\nindex 56178967cc..47835f26f2 100644\n--- a/services/libs/aster-std/src/syscall/getpid.rs\n+++ b/services/libs/aster-std/src/syscall/getpid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{log_syscall_entry, prelude::*};\n \n use crate::syscall::SYS_GETPID;\ndiff --git a/services/libs/aster-std/src/syscall/getppid.rs b/services/libs/aster-std/src/syscall/getppid.rs\nindex 610d24186a..6b5d424613 100644\n--- a/services/libs/aster-std/src/syscall/getppid.rs\n+++ b/services/libs/aster-std/src/syscall/getppid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/syscall/getrandom.rs b/services/libs/aster-std/src/syscall/getrandom.rs\nindex 6c2f8d7020..e2d142c9f8 100644\n--- a/services/libs/aster-std/src/syscall/getrandom.rs\n+++ b/services/libs/aster-std/src/syscall/getrandom.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::device;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getresgid.rs b/services/libs/aster-std/src/syscall/getresgid.rs\nindex c2ae6b6f50..0a62b9ec71 100644\n--- a/services/libs/aster-std/src/syscall/getresgid.rs\n+++ b/services/libs/aster-std/src/syscall/getresgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETRESGID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getresuid.rs b/services/libs/aster-std/src/syscall/getresuid.rs\nindex f93b4e653b..b91ea082d0 100644\n--- a/services/libs/aster-std/src/syscall/getresuid.rs\n+++ b/services/libs/aster-std/src/syscall/getresuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETRESUID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getsid.rs b/services/libs/aster-std/src/syscall/getsid.rs\nindex 721644c3de..d527425b41 100644\n--- a/services/libs/aster-std/src/syscall/getsid.rs\n+++ b/services/libs/aster-std/src/syscall/getsid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{process_table, Pid};\ndiff --git a/services/libs/aster-std/src/syscall/getsockname.rs b/services/libs/aster-std/src/syscall/getsockname.rs\nindex 13990c609b..f9f0d4fc02 100644\n--- a/services/libs/aster-std/src/syscall/getsockname.rs\n+++ b/services/libs/aster-std/src/syscall/getsockname.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/getsockopt.rs b/services/libs/aster-std/src/syscall/getsockopt.rs\nindex f0689af7ee..1f37d459c8 100644\n--- a/services/libs/aster-std/src/syscall/getsockopt.rs\n+++ b/services/libs/aster-std/src/syscall/getsockopt.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/gettid.rs b/services/libs/aster-std/src/syscall/gettid.rs\nindex 180e22fa0f..1b56ffdcc8 100644\n--- a/services/libs/aster-std/src/syscall/gettid.rs\n+++ b/services/libs/aster-std/src/syscall/gettid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{log_syscall_entry, prelude::*};\n \n use crate::syscall::SYS_GETTID;\ndiff --git a/services/libs/aster-std/src/syscall/gettimeofday.rs b/services/libs/aster-std/src/syscall/gettimeofday.rs\nindex 76d6f5bb84..a47109bbb6 100644\n--- a/services/libs/aster-std/src/syscall/gettimeofday.rs\n+++ b/services/libs/aster-std/src/syscall/gettimeofday.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_GETTIMEOFDAY;\n use crate::{\ndiff --git a/services/libs/aster-std/src/syscall/getuid.rs b/services/libs/aster-std/src/syscall/getuid.rs\nindex 7bd70a11ad..49fb4a7786 100644\n--- a/services/libs/aster-std/src/syscall/getuid.rs\n+++ b/services/libs/aster-std/src/syscall/getuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_GETUID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/ioctl.rs b/services/libs/aster-std/src/syscall/ioctl.rs\nindex 6d478a4c54..dd56e419fd 100644\n--- a/services/libs/aster-std/src/syscall/ioctl.rs\n+++ b/services/libs/aster-std/src/syscall/ioctl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::fs::utils::IoctlCmd;\n use crate::log_syscall_entry;\ndiff --git a/services/libs/aster-std/src/syscall/kill.rs b/services/libs/aster-std/src/syscall/kill.rs\nindex 6f8e04ef59..3b9223a431 100644\n--- a/services/libs/aster-std/src/syscall/kill.rs\n+++ b/services/libs/aster-std/src/syscall/kill.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_KILL};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/link.rs b/services/libs/aster-std/src/syscall/link.rs\nindex 36c1be8576..128d232d18 100644\n--- a/services/libs/aster-std/src/syscall/link.rs\n+++ b/services/libs/aster-std/src/syscall/link.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/listen.rs b/services/libs/aster-std/src/syscall/listen.rs\nindex 954b473d78..66af78772b 100644\n--- a/services/libs/aster-std/src/syscall/listen.rs\n+++ b/services/libs/aster-std/src/syscall/listen.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/lseek.rs b/services/libs/aster-std/src/syscall/lseek.rs\nindex d37e284602..10003807fc 100644\n--- a/services/libs/aster-std/src/syscall/lseek.rs\n+++ b/services/libs/aster-std/src/syscall/lseek.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{file_table::FileDescripter, utils::SeekFrom};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/madvise.rs b/services/libs/aster-std/src/syscall/madvise.rs\nindex 491b7fc6a7..575c59952b 100644\n--- a/services/libs/aster-std/src/syscall/madvise.rs\n+++ b/services/libs/aster-std/src/syscall/madvise.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::util::read_bytes_from_user;\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/mkdir.rs b/services/libs/aster-std/src/syscall/mkdir.rs\nindex f8f2193eda..b98ea48dab 100644\n--- a/services/libs/aster-std/src/syscall/mkdir.rs\n+++ b/services/libs/aster-std/src/syscall/mkdir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/mmap.rs b/services/libs/aster-std/src/syscall/mmap.rs\nindex e739bae54d..e309239c11 100644\n--- a/services/libs/aster-std/src/syscall/mmap.rs\n+++ b/services/libs/aster-std/src/syscall/mmap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This mod defines mmap flags and the handler to syscall mmap\n \n use crate::fs::file_table::FileDescripter;\ndiff --git a/services/libs/aster-std/src/syscall/mod.rs b/services/libs/aster-std/src/syscall/mod.rs\nindex fad21485b9..54ef4b542d 100644\n--- a/services/libs/aster-std/src/syscall/mod.rs\n+++ b/services/libs/aster-std/src/syscall/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Read the Cpu context content then dispatch syscall to corrsponding handler\n //! The each sub module contains functions that handle real syscall logic.\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/mprotect.rs b/services/libs/aster-std/src/syscall/mprotect.rs\nindex 27c438b4d4..7bcbe03e03 100644\n--- a/services/libs/aster-std/src/syscall/mprotect.rs\n+++ b/services/libs/aster-std/src/syscall/mprotect.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use align_ext::AlignExt;\n \n use crate::{log_syscall_entry, prelude::*};\ndiff --git a/services/libs/aster-std/src/syscall/munmap.rs b/services/libs/aster-std/src/syscall/munmap.rs\nindex 786bfb022b..4f1759500d 100644\n--- a/services/libs/aster-std/src/syscall/munmap.rs\n+++ b/services/libs/aster-std/src/syscall/munmap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use align_ext::AlignExt;\n \n use crate::log_syscall_entry;\ndiff --git a/services/libs/aster-std/src/syscall/open.rs b/services/libs/aster-std/src/syscall/open.rs\nindex df3d96f3ce..dd522eb321 100644\n--- a/services/libs/aster-std/src/syscall/open.rs\n+++ b/services/libs/aster-std/src/syscall/open.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_handle::FileLike,\n     file_table::FileDescripter,\ndiff --git a/services/libs/aster-std/src/syscall/pause.rs b/services/libs/aster-std/src/syscall/pause.rs\nindex 8f57012213..5478ac1004 100644\n--- a/services/libs/aster-std/src/syscall/pause.rs\n+++ b/services/libs/aster-std/src/syscall/pause.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::signal::Pauser;\ndiff --git a/services/libs/aster-std/src/syscall/pipe.rs b/services/libs/aster-std/src/syscall/pipe.rs\nindex 973163d72e..93d90dc710 100644\n--- a/services/libs/aster-std/src/syscall/pipe.rs\n+++ b/services/libs/aster-std/src/syscall/pipe.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::fs::pipe::{PipeReader, PipeWriter};\n use crate::fs::utils::{Channel, StatusFlags};\ndiff --git a/services/libs/aster-std/src/syscall/poll.rs b/services/libs/aster-std/src/syscall/poll.rs\nindex 4833cc042f..2c89df5c48 100644\n--- a/services/libs/aster-std/src/syscall/poll.rs\n+++ b/services/libs/aster-std/src/syscall/poll.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::cell::Cell;\n use core::time::Duration;\n \ndiff --git a/services/libs/aster-std/src/syscall/prctl.rs b/services/libs/aster-std/src/syscall/prctl.rs\nindex 5ab582f6ed..25b5568279 100644\n--- a/services/libs/aster-std/src/syscall/prctl.rs\n+++ b/services/libs/aster-std/src/syscall/prctl.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::posix_thread::PosixThreadExt;\ndiff --git a/services/libs/aster-std/src/syscall/pread64.rs b/services/libs/aster-std/src/syscall/pread64.rs\nindex ac0d1b8827..32bef2c92d 100644\n--- a/services/libs/aster-std/src/syscall/pread64.rs\n+++ b/services/libs/aster-std/src/syscall/pread64.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::fs::utils::SeekFrom;\n use crate::util::write_bytes_to_user;\ndiff --git a/services/libs/aster-std/src/syscall/prlimit64.rs b/services/libs/aster-std/src/syscall/prlimit64.rs\nindex 6ec5da219b..1a56f13c49 100644\n--- a/services/libs/aster-std/src/syscall/prlimit64.rs\n+++ b/services/libs/aster-std/src/syscall/prlimit64.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::ResourceType;\n use crate::util::{read_val_from_user, write_val_to_user};\n use crate::{log_syscall_entry, prelude::*, process::Pid};\ndiff --git a/services/libs/aster-std/src/syscall/read.rs b/services/libs/aster-std/src/syscall/read.rs\nindex f12ba29e38..55ba051124 100644\n--- a/services/libs/aster-std/src/syscall/read.rs\n+++ b/services/libs/aster-std/src/syscall/read.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::util::write_bytes_to_user;\n use crate::{fs::file_table::FileDescripter, prelude::*};\ndiff --git a/services/libs/aster-std/src/syscall/readlink.rs b/services/libs/aster-std/src/syscall/readlink.rs\nindex dbba1dad88..59bf2a924d 100644\n--- a/services/libs/aster-std/src/syscall/readlink.rs\n+++ b/services/libs/aster-std/src/syscall/readlink.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/recvfrom.rs b/services/libs/aster-std/src/syscall/recvfrom.rs\nindex 2dd766d145..008de71926 100644\n--- a/services/libs/aster-std/src/syscall/recvfrom.rs\n+++ b/services/libs/aster-std/src/syscall/recvfrom.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::net::socket::SendRecvFlags;\ndiff --git a/services/libs/aster-std/src/syscall/rename.rs b/services/libs/aster-std/src/syscall/rename.rs\nindex 2441d55675..c3398a3ab6 100644\n--- a/services/libs/aster-std/src/syscall/rename.rs\n+++ b/services/libs/aster-std/src/syscall/rename.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/rmdir.rs b/services/libs/aster-std/src/syscall/rmdir.rs\nindex cda168e79e..8008c4c79b 100644\n--- a/services/libs/aster-std/src/syscall/rmdir.rs\n+++ b/services/libs/aster-std/src/syscall/rmdir.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/rt_sigaction.rs b/services/libs/aster-std/src/syscall/rt_sigaction.rs\nindex ef7346faae..2f28362403 100644\n--- a/services/libs/aster-std/src/syscall/rt_sigaction.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigaction.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     log_syscall_entry,\n     prelude::*,\ndiff --git a/services/libs/aster-std/src/syscall/rt_sigprocmask.rs b/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\nindex c39356707c..e1b9ad181f 100644\n--- a/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_RT_SIGPROCMASK};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/rt_sigreturn.rs b/services/libs/aster-std/src/syscall/rt_sigreturn.rs\nindex c74e6f6e31..567632e494 100644\n--- a/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     log_syscall_entry,\n     prelude::*,\ndiff --git a/services/libs/aster-std/src/syscall/sched_yield.rs b/services/libs/aster-std/src/syscall/sched_yield.rs\nindex d448b97a7b..f566555292 100644\n--- a/services/libs/aster-std/src/syscall/sched_yield.rs\n+++ b/services/libs/aster-std/src/syscall/sched_yield.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::thread::Thread;\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/select.rs b/services/libs/aster-std/src/syscall/select.rs\nindex ddeb243f48..8a81c2ecae 100644\n--- a/services/libs/aster-std/src/syscall/select.rs\n+++ b/services/libs/aster-std/src/syscall/select.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::time::Duration;\n \n use crate::events::IoEvents;\ndiff --git a/services/libs/aster-std/src/syscall/sendto.rs b/services/libs/aster-std/src/syscall/sendto.rs\nindex 3bae9a713d..534bd52d8c 100644\n--- a/services/libs/aster-std/src/syscall/sendto.rs\n+++ b/services/libs/aster-std/src/syscall/sendto.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::net::socket::SendRecvFlags;\ndiff --git a/services/libs/aster-std/src/syscall/set_robust_list.rs b/services/libs/aster-std/src/syscall/set_robust_list.rs\nindex 277fa78a5b..ca0bc9b87f 100644\n--- a/services/libs/aster-std/src/syscall/set_robust_list.rs\n+++ b/services/libs/aster-std/src/syscall/set_robust_list.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_SET_ROBUST_LIST};\n use crate::{\n     log_syscall_entry,\ndiff --git a/services/libs/aster-std/src/syscall/set_tid_address.rs b/services/libs/aster-std/src/syscall/set_tid_address.rs\nindex b98e07461a..16129fa85f 100644\n--- a/services/libs/aster-std/src/syscall/set_tid_address.rs\n+++ b/services/libs/aster-std/src/syscall/set_tid_address.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_SET_TID_ADDRESS;\n use crate::process::posix_thread::PosixThreadExt;\ndiff --git a/services/libs/aster-std/src/syscall/setfsgid.rs b/services/libs/aster-std/src/syscall/setfsgid.rs\nindex e8f9f28626..cac1244942 100644\n--- a/services/libs/aster-std/src/syscall/setfsgid.rs\n+++ b/services/libs/aster-std/src/syscall/setfsgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Gid};\ndiff --git a/services/libs/aster-std/src/syscall/setfsuid.rs b/services/libs/aster-std/src/syscall/setfsuid.rs\nindex 8bfc763836..5cd77a70bb 100644\n--- a/services/libs/aster-std/src/syscall/setfsuid.rs\n+++ b/services/libs/aster-std/src/syscall/setfsuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Uid};\ndiff --git a/services/libs/aster-std/src/syscall/setgid.rs b/services/libs/aster-std/src/syscall/setgid.rs\nindex eeb946bbb8..847303a3bb 100644\n--- a/services/libs/aster-std/src/syscall/setgid.rs\n+++ b/services/libs/aster-std/src/syscall/setgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Gid};\ndiff --git a/services/libs/aster-std/src/syscall/setgroups.rs b/services/libs/aster-std/src/syscall/setgroups.rs\nindex 9acf79c01c..77e028b63b 100644\n--- a/services/libs/aster-std/src/syscall/setgroups.rs\n+++ b/services/libs/aster-std/src/syscall/setgroups.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_SETGROUPS};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/setpgid.rs b/services/libs/aster-std/src/syscall/setpgid.rs\nindex 36e8636c34..758820e051 100644\n--- a/services/libs/aster-std/src/syscall/setpgid.rs\n+++ b/services/libs/aster-std/src/syscall/setpgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{process_table, Pgid, Pid};\ndiff --git a/services/libs/aster-std/src/syscall/setregid.rs b/services/libs/aster-std/src/syscall/setregid.rs\nindex a8b730cdaf..eb215e431f 100644\n--- a/services/libs/aster-std/src/syscall/setregid.rs\n+++ b/services/libs/aster-std/src/syscall/setregid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Gid};\ndiff --git a/services/libs/aster-std/src/syscall/setresgid.rs b/services/libs/aster-std/src/syscall/setresgid.rs\nindex 8c35b4cdea..b95b1a3a9e 100644\n--- a/services/libs/aster-std/src/syscall/setresgid.rs\n+++ b/services/libs/aster-std/src/syscall/setresgid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Gid};\ndiff --git a/services/libs/aster-std/src/syscall/setresuid.rs b/services/libs/aster-std/src/syscall/setresuid.rs\nindex 0eccd29df2..23e0b6e486 100644\n--- a/services/libs/aster-std/src/syscall/setresuid.rs\n+++ b/services/libs/aster-std/src/syscall/setresuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Uid};\ndiff --git a/services/libs/aster-std/src/syscall/setreuid.rs b/services/libs/aster-std/src/syscall/setreuid.rs\nindex 90612db888..a662eee8de 100644\n--- a/services/libs/aster-std/src/syscall/setreuid.rs\n+++ b/services/libs/aster-std/src/syscall/setreuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::{credentials_mut, Uid};\ndiff --git a/services/libs/aster-std/src/syscall/setsid.rs b/services/libs/aster-std/src/syscall/setsid.rs\nindex 40a315f2c1..d9aa56f734 100644\n--- a/services/libs/aster-std/src/syscall/setsid.rs\n+++ b/services/libs/aster-std/src/syscall/setsid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/syscall/setsockopt.rs b/services/libs/aster-std/src/syscall/setsockopt.rs\nindex bf7b23f45d..85a930ac22 100644\n--- a/services/libs/aster-std/src/syscall/setsockopt.rs\n+++ b/services/libs/aster-std/src/syscall/setsockopt.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/setuid.rs b/services/libs/aster-std/src/syscall/setuid.rs\nindex d1c0a609b9..137e599c84 100644\n--- a/services/libs/aster-std/src/syscall/setuid.rs\n+++ b/services/libs/aster-std/src/syscall/setuid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::{SyscallReturn, SYS_SETUID};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/shutdown.rs b/services/libs/aster-std/src/syscall/shutdown.rs\nindex aa300819fe..3fbb0ec3e7 100644\n--- a/services/libs/aster-std/src/syscall/shutdown.rs\n+++ b/services/libs/aster-std/src/syscall/shutdown.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::log_syscall_entry;\n use crate::net::socket::SockShutdownCmd;\ndiff --git a/services/libs/aster-std/src/syscall/sigaltstack.rs b/services/libs/aster-std/src/syscall/sigaltstack.rs\nindex e64679937c..c8259af478 100644\n--- a/services/libs/aster-std/src/syscall/sigaltstack.rs\n+++ b/services/libs/aster-std/src/syscall/sigaltstack.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::process::posix_thread::PosixThreadExt;\ndiff --git a/services/libs/aster-std/src/syscall/socket.rs b/services/libs/aster-std/src/syscall/socket.rs\nindex c9bfd09e7f..dcad0b29e1 100644\n--- a/services/libs/aster-std/src/syscall/socket.rs\n+++ b/services/libs/aster-std/src/syscall/socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_handle::FileLike;\n use crate::net::socket::ip::{DatagramSocket, StreamSocket};\n use crate::net::socket::unix::UnixStreamSocket;\ndiff --git a/services/libs/aster-std/src/syscall/socketpair.rs b/services/libs/aster-std/src/syscall/socketpair.rs\nindex f009294332..6ab14fcfba 100644\n--- a/services/libs/aster-std/src/syscall/socketpair.rs\n+++ b/services/libs/aster-std/src/syscall/socketpair.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::net::socket::unix::UnixStreamSocket;\n use crate::util::net::{CSocketAddrFamily, Protocol, SockFlags, SockType, SOCK_TYPE_MASK};\ndiff --git a/services/libs/aster-std/src/syscall/stat.rs b/services/libs/aster-std/src/syscall/stat.rs\nindex 7dc19d9903..e2fc86fef3 100644\n--- a/services/libs/aster-std/src/syscall/stat.rs\n+++ b/services/libs/aster-std/src/syscall/stat.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/statfs.rs b/services/libs/aster-std/src/syscall/statfs.rs\nindex dbaa13240b..f5cbf39168 100644\n--- a/services/libs/aster-std/src/syscall/statfs.rs\n+++ b/services/libs/aster-std/src/syscall/statfs.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::FsPath,\ndiff --git a/services/libs/aster-std/src/syscall/symlink.rs b/services/libs/aster-std/src/syscall/symlink.rs\nindex c63a701bfb..7d5a184425 100644\n--- a/services/libs/aster-std/src/syscall/symlink.rs\n+++ b/services/libs/aster-std/src/syscall/symlink.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/sync.rs b/services/libs/aster-std/src/syscall/sync.rs\nindex 643020113f..54cf034a2b 100644\n--- a/services/libs/aster-std/src/syscall/sync.rs\n+++ b/services/libs/aster-std/src/syscall/sync.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n \ndiff --git a/services/libs/aster-std/src/syscall/tgkill.rs b/services/libs/aster-std/src/syscall/tgkill.rs\nindex 1941370c4e..6715246475 100644\n--- a/services/libs/aster-std/src/syscall/tgkill.rs\n+++ b/services/libs/aster-std/src/syscall/tgkill.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/time.rs b/services/libs/aster-std/src/syscall/time.rs\nindex 28366239f1..1e9d0c1f03 100644\n--- a/services/libs/aster-std/src/syscall/time.rs\n+++ b/services/libs/aster-std/src/syscall/time.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::log_syscall_entry;\n use crate::prelude::*;\n use crate::time::SystemTime;\ndiff --git a/services/libs/aster-std/src/syscall/umask.rs b/services/libs/aster-std/src/syscall/umask.rs\nindex 1b46d11974..06a1325907 100644\n--- a/services/libs/aster-std/src/syscall/umask.rs\n+++ b/services/libs/aster-std/src/syscall/umask.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::SyscallReturn;\n use super::SYS_UMASK;\n use crate::{log_syscall_entry, prelude::*};\ndiff --git a/services/libs/aster-std/src/syscall/uname.rs b/services/libs/aster-std/src/syscall/uname.rs\nindex f1dd60c14d..82a9c9b6a3 100644\n--- a/services/libs/aster-std/src/syscall/uname.rs\n+++ b/services/libs/aster-std/src/syscall/uname.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{log_syscall_entry, prelude::*};\n \n use crate::syscall::SYS_UNAME;\ndiff --git a/services/libs/aster-std/src/syscall/unlink.rs b/services/libs/aster-std/src/syscall/unlink.rs\nindex 07cd6b6879..65b970e92e 100644\n--- a/services/libs/aster-std/src/syscall/unlink.rs\n+++ b/services/libs/aster-std/src/syscall/unlink.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{\n     file_table::FileDescripter,\n     fs_resolver::{FsPath, AT_FDCWD},\ndiff --git a/services/libs/aster-std/src/syscall/utimens.rs b/services/libs/aster-std/src/syscall/utimens.rs\nindex a96d1d391f..20feeb8e35 100644\n--- a/services/libs/aster-std/src/syscall/utimens.rs\n+++ b/services/libs/aster-std/src/syscall/utimens.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::{file_table::FileDescripter, fs_resolver::FsPath};\n use crate::log_syscall_entry;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/syscall/wait4.rs b/services/libs/aster-std/src/syscall/wait4.rs\nindex 6cfaba6c60..f26762bd47 100644\n--- a/services/libs/aster-std/src/syscall/wait4.rs\n+++ b/services/libs/aster-std/src/syscall/wait4.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{\n     log_syscall_entry,\n     process::{wait_child_exit, ProcessFilter},\ndiff --git a/services/libs/aster-std/src/syscall/waitid.rs b/services/libs/aster-std/src/syscall/waitid.rs\nindex b3d612cc43..4358e692ba 100644\n--- a/services/libs/aster-std/src/syscall/waitid.rs\n+++ b/services/libs/aster-std/src/syscall/waitid.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::process::{wait_child_exit, ProcessFilter};\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/write.rs b/services/libs/aster-std/src/syscall/write.rs\nindex 60df03be06..eec44d3386 100644\n--- a/services/libs/aster-std/src/syscall/write.rs\n+++ b/services/libs/aster-std/src/syscall/write.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/syscall/writev.rs b/services/libs/aster-std/src/syscall/writev.rs\nindex b927988c99..d5d9bb9b91 100644\n--- a/services/libs/aster-std/src/syscall/writev.rs\n+++ b/services/libs/aster-std/src/syscall/writev.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::fs::file_table::FileDescripter;\n use crate::{log_syscall_entry, prelude::*};\n \ndiff --git a/services/libs/aster-std/src/thread/exception.rs b/services/libs/aster-std/src/thread/exception.rs\nindex 6a690c54af..bab26771d7 100644\n--- a/services/libs/aster-std/src/thread/exception.rs\n+++ b/services/libs/aster-std/src/thread/exception.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use crate::process::signal::signals::fault::FaultSignal;\n use crate::vm::page_fault_handler::PageFaultHandler;\ndiff --git a/services/libs/aster-std/src/thread/kernel_thread.rs b/services/libs/aster-std/src/thread/kernel_thread.rs\nindex be39fb5b3d..aaa0fe91af 100644\n--- a/services/libs/aster-std/src/thread/kernel_thread.rs\n+++ b/services/libs/aster-std/src/thread/kernel_thread.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::cpu::CpuSet;\n use aster_frame::task::{Priority, TaskOptions};\n \ndiff --git a/services/libs/aster-std/src/thread/mod.rs b/services/libs/aster-std/src/thread/mod.rs\nindex c321170c74..5a73f2fc14 100644\n--- a/services/libs/aster-std/src/thread/mod.rs\n+++ b/services/libs/aster-std/src/thread/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Posix thread implementation\n \n use core::{\ndiff --git a/services/libs/aster-std/src/thread/status.rs b/services/libs/aster-std/src/thread/status.rs\nindex c715b3d4b9..8a438e3ef8 100644\n--- a/services/libs/aster-std/src/thread/status.rs\n+++ b/services/libs/aster-std/src/thread/status.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #[derive(Debug, PartialEq, Clone, Copy)]\n pub enum ThreadStatus {\n     Init,\ndiff --git a/services/libs/aster-std/src/thread/task.rs b/services/libs/aster-std/src/thread/task.rs\nindex 856161045a..ceefd0974c 100644\n--- a/services/libs/aster-std/src/thread/task.rs\n+++ b/services/libs/aster-std/src/thread/task.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::{\n     cpu::UserContext,\n     task::{preempt, Task, TaskOptions},\ndiff --git a/services/libs/aster-std/src/thread/thread_table.rs b/services/libs/aster-std/src/thread/thread_table.rs\nindex 59e5facf81..6135e4342c 100644\n--- a/services/libs/aster-std/src/thread/thread_table.rs\n+++ b/services/libs/aster-std/src/thread/thread_table.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n use super::{Thread, Tid};\ndiff --git a/services/libs/aster-std/src/thread/work_queue/mod.rs b/services/libs/aster-std/src/thread/work_queue/mod.rs\nindex 4e55e7b69a..390578cb77 100644\n--- a/services/libs/aster-std/src/thread/work_queue/mod.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::cpu::CpuSet;\n use spin::Once;\ndiff --git a/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs b/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs\nindex d8470f75b3..963b44dd9f 100644\n--- a/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::sync::Weak;\n \n use super::worker_pool::{WorkerPool, WorkerScheduler};\ndiff --git a/services/libs/aster-std/src/thread/work_queue/work_item.rs b/services/libs/aster-std/src/thread/work_queue/work_item.rs\nindex 919a5318d1..ba308618e7 100644\n--- a/services/libs/aster-std/src/thread/work_queue/work_item.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/work_item.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::cpu::CpuSet;\n use core::sync::atomic::AtomicBool;\ndiff --git a/services/libs/aster-std/src/thread/work_queue/worker.rs b/services/libs/aster-std/src/thread/work_queue/worker.rs\nindex 3ba850ed88..d60ee3335f 100644\n--- a/services/libs/aster-std/src/thread/work_queue/worker.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/worker.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::worker_pool::WorkerPool;\n use crate::prelude::*;\n use crate::thread::kernel_thread::{KernelThreadExt, ThreadOptions};\ndiff --git a/services/libs/aster-std/src/thread/work_queue/worker_pool.rs b/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\nindex 462864cd12..b3040fa5de 100644\n--- a/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::sync::atomic::{AtomicBool, Ordering};\n \n use super::{simple_scheduler::SimpleScheduler, worker::Worker, WorkItem, WorkPriority, WorkQueue};\ndiff --git a/services/libs/aster-std/src/time/mod.rs b/services/libs/aster-std/src/time/mod.rs\nindex f9c8682ed3..513c9e0613 100644\n--- a/services/libs/aster-std/src/time/mod.rs\n+++ b/services/libs/aster-std/src/time/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![allow(non_camel_case_types)]\n use core::time::Duration;\n \ndiff --git a/services/libs/aster-std/src/time/system_time.rs b/services/libs/aster-std/src/time/system_time.rs\nindex bca7a387b0..21ad5b4183 100644\n--- a/services/libs/aster-std/src/time/system_time.rs\n+++ b/services/libs/aster-std/src/time/system_time.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_time::{read_monotonic_time, read_start_time};\n use core::time::Duration;\n use time::{Date, Month, PrimitiveDateTime, Time};\ndiff --git a/services/libs/aster-std/src/util/mod.rs b/services/libs/aster-std/src/util/mod.rs\nindex 210358bc8e..62f6f8a6ff 100644\n--- a/services/libs/aster-std/src/util/mod.rs\n+++ b/services/libs/aster-std/src/util/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::vm::VmIo;\n pub mod net;\ndiff --git a/services/libs/aster-std/src/util/net/addr.rs b/services/libs/aster-std/src/util/net/addr.rs\nindex db88aa74eb..0df1aea948 100644\n--- a/services/libs/aster-std/src/util/net/addr.rs\n+++ b/services/libs/aster-std/src/util/net/addr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::net::iface::Ipv4Address;\n use crate::net::socket::unix::UnixSocketAddr;\n use crate::net::socket::SocketAddr;\ndiff --git a/services/libs/aster-std/src/util/net/mod.rs b/services/libs/aster-std/src/util/net/mod.rs\nindex 15a6078c84..394d343a38 100644\n--- a/services/libs/aster-std/src/util/net/mod.rs\n+++ b/services/libs/aster-std/src/util/net/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n mod addr;\n mod options;\n mod socket;\ndiff --git a/services/libs/aster-std/src/util/net/options/mod.rs b/services/libs/aster-std/src/util/net/options/mod.rs\nindex cf66b4a63a..8dcc2f1992 100644\n--- a/services/libs/aster-std/src/util/net/options/mod.rs\n+++ b/services/libs/aster-std/src/util/net/options/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module introduces utilities to support Linux get/setsockopt syscalls.\n //!\n //! These two syscalls are used to get/set options for a socket. These options can be at different\ndiff --git a/services/libs/aster-std/src/util/net/options/socket.rs b/services/libs/aster-std/src/util/net/options/socket.rs\nindex 7e627e8cd2..aebdc8e88f 100644\n--- a/services/libs/aster-std/src/util/net/options/socket.rs\n+++ b/services/libs/aster-std/src/util/net/options/socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::RawSocketOption;\n use crate::net::socket::options::{\n     Error, Linger, RecvBuf, ReuseAddr, ReusePort, SendBuf, SocketOption,\ndiff --git a/services/libs/aster-std/src/util/net/options/tcp.rs b/services/libs/aster-std/src/util/net/options/tcp.rs\nindex 426e5c1232..ebf608714c 100644\n--- a/services/libs/aster-std/src/util/net/options/tcp.rs\n+++ b/services/libs/aster-std/src/util/net/options/tcp.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::RawSocketOption;\n use crate::impl_raw_socket_option;\n use crate::net::socket::ip::stream::options::{Congestion, MaxSegment, NoDelay, WindowClamp};\ndiff --git a/services/libs/aster-std/src/util/net/options/utils.rs b/services/libs/aster-std/src/util/net/options/utils.rs\nindex cd776f7394..6a09a1100e 100644\n--- a/services/libs/aster-std/src/util/net/options/utils.rs\n+++ b/services/libs/aster-std/src/util/net/options/utils.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::net::socket::ip::stream::CongestionControl;\n use crate::net::socket::LingerOption;\n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/util/net/socket.rs b/services/libs/aster-std/src/util/net/socket.rs\nindex 986d58794b..6464854e77 100644\n--- a/services/libs/aster-std/src/util/net/socket.rs\n+++ b/services/libs/aster-std/src/util/net/socket.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// Standard well-defined IP protocols.\ndiff --git a/services/libs/aster-std/src/vdso.rs b/services/libs/aster-std/src/vdso.rs\nindex 242b9a17fa..7b577b225c 100644\n--- a/services/libs/aster-std/src/vdso.rs\n+++ b/services/libs/aster-std/src/vdso.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The Virtual Dynamic Shared Object (VDSO) module enables user space applications to access kernel space routines\n //! without the need for context switching. This is particularly useful for frequently invoked operations such as\n //! obtaining the current time, which can be more efficiently handled within the user space.\ndiff --git a/services/libs/aster-std/src/vm/mod.rs b/services/libs/aster-std/src/vm/mod.rs\nindex 28b205c30e..b4d623ab53 100644\n--- a/services/libs/aster-std/src/vm/mod.rs\n+++ b/services/libs/aster-std/src/vm/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtual memory (VM).\n //!\n //! There are two primary VM abstractions:\ndiff --git a/services/libs/aster-std/src/vm/page_fault_handler.rs b/services/libs/aster-std/src/vm/page_fault_handler.rs\nindex 6e79c68e40..9686637d86 100644\n--- a/services/libs/aster-std/src/vm/page_fault_handler.rs\n+++ b/services/libs/aster-std/src/vm/page_fault_handler.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n \n /// This trait is implemented by structs which can handle a user space page fault.\ndiff --git a/services/libs/aster-std/src/vm/perms.rs b/services/libs/aster-std/src/vm/perms.rs\nindex 5422358834..fdb2c69c25 100644\n--- a/services/libs/aster-std/src/vm/perms.rs\n+++ b/services/libs/aster-std/src/vm/perms.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::vm::VmPerm;\n use aster_rights::Rights;\n use bitflags::bitflags;\ndiff --git a/services/libs/aster-std/src/vm/vmar/dyn_cap.rs b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\nindex 138dcbe386..59fa7cd76a 100644\n--- a/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::vm::{Vaddr, VmIo};\n use aster_rights::Rights;\n use core::ops::Range;\ndiff --git a/services/libs/aster-std/src/vm/vmar/mod.rs b/services/libs/aster-std/src/vm/vmar/mod.rs\nindex ced1b01df5..3b17738f4f 100644\n--- a/services/libs/aster-std/src/vm/vmar/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmar/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtual Memory Address Regions (VMARs).\n \n mod dyn_cap;\ndiff --git a/services/libs/aster-std/src/vm/vmar/options.rs b/services/libs/aster-std/src/vm/vmar/options.rs\nindex df0ae43cf0..18fe069016 100644\n--- a/services/libs/aster-std/src/vm/vmar/options.rs\n+++ b/services/libs/aster-std/src/vm/vmar/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Options for allocating child VMARs.\n \n use aster_frame::config::PAGE_SIZE;\ndiff --git a/services/libs/aster-std/src/vm/vmar/static_cap.rs b/services/libs/aster-std/src/vm/vmar/static_cap.rs\nindex 248ac40a7d..1b3fe9bc8b 100644\n--- a/services/libs/aster-std/src/vm/vmar/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::ops::Range;\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/vm/vmar/vm_mapping.rs b/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\nindex b1c4bd9528..22be8143a5 100644\n--- a/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::sync::Mutex;\n use aster_frame::vm::{VmFrame, VmFrameVec, VmIo, VmMapOptions, VmPerm, VmSpace};\ndiff --git a/services/libs/aster-std/src/vm/vmo/dyn_cap.rs b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\nindex 0ee957d5ea..c7ee7ce4b5 100644\n--- a/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::ops::Range;\n \n use crate::prelude::*;\ndiff --git a/services/libs/aster-std/src/vm/vmo/mod.rs b/services/libs/aster-std/src/vm/vmo/mod.rs\nindex b84b2ccd9e..67bad9b249 100644\n--- a/services/libs/aster-std/src/vm/vmo/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmo/mod.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Virtual Memory Objects (VMOs).\n \n use core::ops::Range;\ndiff --git a/services/libs/aster-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\nindex 88e559cc4b..22d84483e5 100644\n--- a/services/libs/aster-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Options for allocating root and child VMOs.\n \n use core::marker::PhantomData;\ndiff --git a/services/libs/aster-std/src/vm/vmo/pager.rs b/services/libs/aster-std/src/vm/vmo/pager.rs\nindex d3893c3509..da25e31ce0 100644\n--- a/services/libs/aster-std/src/vm/vmo/pager.rs\n+++ b/services/libs/aster-std/src/vm/vmo/pager.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::vm::VmFrame;\n \ndiff --git a/services/libs/aster-std/src/vm/vmo/static_cap.rs b/services/libs/aster-std/src/vm/vmo/static_cap.rs\nindex b728b4e185..7824a92f50 100644\n--- a/services/libs/aster-std/src/vm/vmo/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::prelude::*;\n use aster_frame::vm::VmIo;\n use aster_rights_proc::require;\ndiff --git a/services/libs/aster-util/src/coeff.rs b/services/libs/aster-util/src/coeff.rs\nindex 08e7158d9d..ab863321cd 100644\n--- a/services/libs/aster-util/src/coeff.rs\n+++ b/services/libs/aster-util/src/coeff.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This module provides an abstraction `Coeff` to server for efficient and accurate calculation\n //! of fraction multiplication.\n \ndiff --git a/services/libs/aster-util/src/dup.rs b/services/libs/aster-util/src/dup.rs\nindex 0b9b9e99e7..c3de639da3 100644\n--- a/services/libs/aster-util/src/dup.rs\n+++ b/services/libs/aster-util/src/dup.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n /// This trait is a _fallible_ version of `Clone`.\n ///\n /// If any object of a type `T` is duplicable, then `T` should implement\ndiff --git a/services/libs/aster-util/src/id_allocator.rs b/services/libs/aster-util/src/id_allocator.rs\nindex 2938b084b2..6569cf5ab2 100644\n--- a/services/libs/aster-util/src/id_allocator.rs\n+++ b/services/libs/aster-util/src/id_allocator.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use bitvec::prelude::BitVec;\n use core::fmt::Debug;\n \ndiff --git a/services/libs/aster-util/src/lib.rs b/services/libs/aster-util/src/lib.rs\nindex 783f59b225..3777fe45c1 100644\n--- a/services/libs/aster-util/src/lib.rs\n+++ b/services/libs/aster-util/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The util of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\ndiff --git a/services/libs/aster-util/src/safe_ptr.rs b/services/libs/aster-util/src/safe_ptr.rs\nindex 8d86bb25cb..93fe585a83 100644\n--- a/services/libs/aster-util/src/safe_ptr.rs\n+++ b/services/libs/aster-util/src/safe_ptr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use aster_frame::vm::Paddr;\n use aster_frame::vm::{HasPaddr, VmIo};\n use aster_frame::Result;\ndiff --git a/services/libs/aster-util/src/slot_vec.rs b/services/libs/aster-util/src/slot_vec.rs\nindex 3fc35f5060..5b38e6bbbf 100644\n--- a/services/libs/aster-util/src/slot_vec.rs\n+++ b/services/libs/aster-util/src/slot_vec.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::vec::Vec;\n \n /// SlotVec is the variant of Vector.\ndiff --git a/services/libs/aster-util/src/union_read_ptr.rs b/services/libs/aster-util/src/union_read_ptr.rs\nindex 9e902c990e..a215429db8 100644\n--- a/services/libs/aster-util/src/union_read_ptr.rs\n+++ b/services/libs/aster-util/src/union_read_ptr.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use core::marker::PhantomData;\n \n use pod::Pod;\ndiff --git a/services/libs/comp-sys/cargo-component/analysis/src/conf.rs b/services/libs/comp-sys/cargo-component/analysis/src/conf.rs\nindex 707b2ea89e..d0d1a078f7 100644\n--- a/services/libs/comp-sys/cargo-component/analysis/src/conf.rs\n+++ b/services/libs/comp-sys/cargo-component/analysis/src/conf.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n use std::collections::{BTreeMap, HashSet};\n use std::{env, fs, io, path::PathBuf};\n \ndiff --git a/services/libs/comp-sys/cargo-component/analysis/src/lib.rs b/services/libs/comp-sys/cargo-component/analysis/src/lib.rs\nindex 6382901bd3..05268a661b 100644\n--- a/services/libs/comp-sys/cargo-component/analysis/src/lib.rs\n+++ b/services/libs/comp-sys/cargo-component/analysis/src/lib.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n #![feature(rustc_private)]\n \n extern crate rustc_ast;\ndiff --git a/services/libs/comp-sys/cargo-component/build.rs b/services/libs/comp-sys/cargo-component/build.rs\nindex fab8a69a27..1890a189bb 100644\n--- a/services/libs/comp-sys/cargo-component/build.rs\n+++ b/services/libs/comp-sys/cargo-component/build.rs\n@@ -1,4 +1,7 @@\n-//! This implementation is from rust-clippy\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n+// This implementation is from rust clippy. We modified the code.\n \n fn main() {\n     // Forward the profile to the main compilation\ndiff --git a/services/libs/comp-sys/cargo-component/src/driver.rs b/services/libs/comp-sys/cargo-component/src/driver.rs\nindex 4a378237b1..43bc66f0d9 100644\n--- a/services/libs/comp-sys/cargo-component/src/driver.rs\n+++ b/services/libs/comp-sys/cargo-component/src/driver.rs\n@@ -1,7 +1,8 @@\n-//! Licensed under the Apache License, Version 2.0 or the MIT License.\n-//! Copyright (C) 2023 Ant Group.\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n+// This implementation is from rust clippy. We modified the code.\n \n-//! This implementation is from rust clippy. We modified the code.\n #![feature(rustc_private)]\n #![feature(once_cell)]\n \ndiff --git a/services/libs/comp-sys/cargo-component/src/main.rs b/services/libs/comp-sys/cargo-component/src/main.rs\nindex 9f7feace1c..96a1254d89 100644\n--- a/services/libs/comp-sys/cargo-component/src/main.rs\n+++ b/services/libs/comp-sys/cargo-component/src/main.rs\n@@ -1,7 +1,7 @@\n-//! Licensed under the Apache License, Version 2.0 or the MIT License.\n-//! Copyright (C) 2023 Ant Group.\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n \n-//! This implementation is from rust clippy. We modified the code.\n+// This implementation is from rust clippy. We modified the code.\n \n use std::env;\n use std::path::PathBuf;\ndiff --git a/services/libs/comp-sys/component-macro/src/init_comp.rs b/services/libs/comp-sys/component-macro/src/init_comp.rs\nindex 4f3f6624d2..6137428a68 100644\n--- a/services/libs/comp-sys/component-macro/src/init_comp.rs\n+++ b/services/libs/comp-sys/component-macro/src/init_comp.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use proc_macro2::{TokenStream, TokenTree};\n use quote::{ToTokens, TokenStreamExt};\n use syn::parse::Parse;\ndiff --git a/services/libs/comp-sys/component-macro/src/lib.rs b/services/libs/comp-sys/component-macro/src/lib.rs\nindex 5fb3c8f2bf..0f777958b4 100644\n--- a/services/libs/comp-sys/component-macro/src/lib.rs\n+++ b/services/libs/comp-sys/component-macro/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //\uff01This crate defines the component system related macros.\n //!\n \ndiff --git a/services/libs/comp-sys/component-macro/src/priority.rs b/services/libs/comp-sys/component-macro/src/priority.rs\nindex 931f27196d..f775271814 100644\n--- a/services/libs/comp-sys/component-macro/src/priority.rs\n+++ b/services/libs/comp-sys/component-macro/src/priority.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::{collections::HashMap, fs::File, io::Read, ops::Add, process::Command, str::FromStr};\n \n use json::JsonValue;\ndiff --git a/services/libs/comp-sys/component/src/lib.rs b/services/libs/comp-sys/component/src/lib.rs\nindex c019bde45c..1bffe3a69c 100644\n--- a/services/libs/comp-sys/component/src/lib.rs\n+++ b/services/libs/comp-sys/component/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Component system\n //!\n \ndiff --git a/services/libs/comp-sys/controlled/src/lib.rs b/services/libs/comp-sys/controlled/src/lib.rs\nindex a047e8b07e..d4f313dce6 100644\n--- a/services/libs/comp-sys/controlled/src/lib.rs\n+++ b/services/libs/comp-sys/controlled/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This crate defines two attribute macros `controlled` and `uncontrolled`.\n //! This two macros are attached to functions or static variables to enable crate level access control.\n //! To use these two macros, a crate must at first registers a tool named `component_access_control`,\ndiff --git a/services/libs/cpio-decoder/src/error.rs b/services/libs/cpio-decoder/src/error.rs\nindex 39efbae8f6..61147e2bc4 100644\n--- a/services/libs/cpio-decoder/src/error.rs\n+++ b/services/libs/cpio-decoder/src/error.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n pub type Result<T> = core::result::Result<T, self::Error>;\n \n /// Errors of CPIO decoder.\ndiff --git a/services/libs/cpio-decoder/src/lib.rs b/services/libs/cpio-decoder/src/lib.rs\nindex fa2924f3fb..9955c83afa 100644\n--- a/services/libs/cpio-decoder/src/lib.rs\n+++ b/services/libs/cpio-decoder/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! A safe Rust CPIO (the newc format) decoder.\n //!\n //! # Example\ndiff --git a/services/libs/int-to-c-enum/derive/src/lib.rs b/services/libs/int-to-c-enum/derive/src/lib.rs\nindex a9793d2ff6..4fb34c2803 100644\n--- a/services/libs/int-to-c-enum/derive/src/lib.rs\n+++ b/services/libs/int-to-c-enum/derive/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use proc_macro2::{Ident, TokenStream};\n use quote::{format_ident, quote, TokenStreamExt};\n use syn::{parse_macro_input, Attribute, Data, DataEnum, DeriveInput, Generics};\ndiff --git a/services/libs/int-to-c-enum/src/lib.rs b/services/libs/int-to-c-enum/src/lib.rs\nindex b3a58ec49f..39b9264dba 100644\n--- a/services/libs/int-to-c-enum/src/lib.rs\n+++ b/services/libs/int-to-c-enum/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! This crate provides a derive macro named TryFromInt. This macro can be used to automatically implement TryFrom trait\n //! for [C-like enums](https://doc.rust-lang.org/stable/rust-by-example/custom_types/enum/c_like.html).\n //!\ndiff --git a/services/libs/keyable-arc/src/lib.rs b/services/libs/keyable-arc/src/lib.rs\nindex c96b710930..a1761a26f1 100644\n--- a/services/libs/keyable-arc/src/lib.rs\n+++ b/services/libs/keyable-arc/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Same as the standard `Arc`, except that it can be used as the key type of a hash table.\n //!\n //! # Motivation\ndiff --git a/services/libs/typeflags-util/src/assert.rs b/services/libs/typeflags-util/src/assert.rs\nindex a9f0afe554..77c7524e15 100644\n--- a/services/libs/typeflags-util/src/assert.rs\n+++ b/services/libs/typeflags-util/src/assert.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! define macro assert_type_same\n \n use crate::same::SameAs;\ndiff --git a/services/libs/typeflags-util/src/bool.rs b/services/libs/typeflags-util/src/bool.rs\nindex dc9743bcb9..c6cf57dfcf 100644\n--- a/services/libs/typeflags-util/src/bool.rs\n+++ b/services/libs/typeflags-util/src/bool.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Type level bools\n \n pub use core::ops::BitAnd as And;\ndiff --git a/services/libs/typeflags-util/src/extend.rs b/services/libs/typeflags-util/src/extend.rs\nindex 3f579c7706..c0a5d5ffa3 100644\n--- a/services/libs/typeflags-util/src/extend.rs\n+++ b/services/libs/typeflags-util/src/extend.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use crate::{Cons, Nil};\n \n /// This trait will extend a set with another item.\ndiff --git a/services/libs/typeflags-util/src/if_.rs b/services/libs/typeflags-util/src/if_.rs\nindex 4b1445514b..5a67ae84dd 100644\n--- a/services/libs/typeflags-util/src/if_.rs\n+++ b/services/libs/typeflags-util/src/if_.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Type Level If\n \n use crate::bool::{False, True};\ndiff --git a/services/libs/typeflags-util/src/lib.rs b/services/libs/typeflags-util/src/lib.rs\nindex 07b8a7404a..f3e7ff6070 100644\n--- a/services/libs/typeflags-util/src/lib.rs\n+++ b/services/libs/typeflags-util/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The content of this crate is from another project CapComp.\n //! This crate defines common type level operations, like SameAsOp, and Bool type operations.\n //! Besides, this crate defines operations to deal with type sets, like SetContain and SetInclude.\ndiff --git a/services/libs/typeflags-util/src/same.rs b/services/libs/typeflags-util/src/same.rs\nindex 66b19330a4..aba553ae08 100644\n--- a/services/libs/typeflags-util/src/same.rs\n+++ b/services/libs/typeflags-util/src/same.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Traits used to check if two types are the same, returning a Bool.\n //! This check happens at compile time\n \ndiff --git a/services/libs/typeflags-util/src/set.rs b/services/libs/typeflags-util/src/set.rs\nindex 4e21c92cb5..062eac1ef4 100644\n--- a/services/libs/typeflags-util/src/set.rs\n+++ b/services/libs/typeflags-util/src/set.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Common types and traits to deal with type-level sets\n \n use core::marker::PhantomData;\ndiff --git a/services/libs/typeflags/src/flag_set.rs b/services/libs/typeflags/src/flag_set.rs\nindex 2b1fd4089d..d7d1c4acd9 100644\n--- a/services/libs/typeflags/src/flag_set.rs\n+++ b/services/libs/typeflags/src/flag_set.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use itertools::Itertools;\n use proc_macro2::{Ident, TokenStream};\n use quote::{quote, TokenStreamExt};\ndiff --git a/services/libs/typeflags/src/lib.rs b/services/libs/typeflags/src/lib.rs\nindex f11eb3dcb8..4037dd79f2 100644\n--- a/services/libs/typeflags/src/lib.rs\n+++ b/services/libs/typeflags/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //\uff01This crate defines the procedural macro typeflags to implement capability for Asterinas.\n //! When using this crate, typeflags-util should also be added as dependency.\n //! This is due to typeflgas is a proc-macro crate, which is only allowed to export proc-macro interfaces.\ndiff --git a/services/libs/typeflags/src/type_flag.rs b/services/libs/typeflags/src/type_flag.rs\nindex 0d4366f38e..0d42eab1a3 100644\n--- a/services/libs/typeflags/src/type_flag.rs\n+++ b/services/libs/typeflags/src/type_flag.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use proc_macro2::TokenStream;\n use quote::quote;\n use syn::{\ndiff --git a/services/libs/typeflags/src/util.rs b/services/libs/typeflags/src/util.rs\nindex fcc9d53d8f..7313b17866 100644\n--- a/services/libs/typeflags/src/util.rs\n+++ b/services/libs/typeflags/src/util.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use proc_macro2::{Ident, TokenStream};\n use quote::{quote, TokenStreamExt};\n \ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\nindex 854e16da2a..23dc6af729 100755\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -1,5 +1,7 @@\n #!/bin/bash\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n # This script is used to update Asterinas version numbers in all relevant files in the repository.\n # Usage: ./tools/bump_version.sh <new_version>\n \ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\nindex 8af048e769..efaa556ee6 100644\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n FROM ubuntu:22.04 as build-base\n \n SHELL [\"/bin/bash\", \"-c\"]\ndiff --git a/tools/docker/run_dev_container.sh b/tools/docker/run_dev_container.sh\nindex 92af52d14c..a7e3334281 100755\n--- a/tools/docker/run_dev_container.sh\n+++ b/tools/docker/run_dev_container.sh\n@@ -1,5 +1,7 @@\n #!/bin/bash\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n \n SCRIPT_DIR=$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\n", "test_patch": "diff --git a/framework/libs/ktest-proc-macro/src/lib.rs b/framework/libs/ktest-proc-macro/src/lib.rs\nindex 30fb919e99..6edbcdbbd6 100644\n--- a/framework/libs/ktest-proc-macro/src/lib.rs\n+++ b/framework/libs/ktest-proc-macro/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n #![feature(proc_macro_span)]\n \n extern crate proc_macro2;\ndiff --git a/framework/libs/ktest/src/lib.rs b/framework/libs/ktest/src/lib.rs\nindex 7ba5795027..e6a2d04d0f 100644\n--- a/framework/libs/ktest/src/lib.rs\n+++ b/framework/libs/ktest/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! # The kernel mode testing framework of Asterinas.\n //!\n //! `ktest` stands for kernel-mode testing framework. Its goal is to provide a\ndiff --git a/framework/libs/ktest/src/path.rs b/framework/libs/ktest/src/path.rs\nindex e62aa5eb0d..434acb49be 100644\n--- a/framework/libs/ktest/src/path.rs\n+++ b/framework/libs/ktest/src/path.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use alloc::{\n     collections::{vec_deque, BTreeMap, VecDeque},\n     string::{String, ToString},\ndiff --git a/framework/libs/ktest/src/runner.rs b/framework/libs/ktest/src/runner.rs\nindex 1f60ba962f..9711811f20 100644\n--- a/framework/libs/ktest/src/runner.rs\n+++ b/framework/libs/ktest/src/runner.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! Test runner enabling control over the tests.\n //!\n \ndiff --git a/framework/libs/ktest/src/tree.rs b/framework/libs/ktest/src/tree.rs\nindex 913ebe0a52..3a99e60ba4 100644\n--- a/framework/libs/ktest/src/tree.rs\n+++ b/framework/libs/ktest/src/tree.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n //! The source module tree of ktests.\n //!\n //! In the `KtestTree`, the root is abstract, and the children of the root are the\ndiff --git a/regression/apps/pthread/pthread_test.c b/regression/apps/pthread/pthread_test.c\nindex 138e59b574..1c601b456b 100644\n--- a/regression/apps/pthread/pthread_test.c\n+++ b/regression/apps/pthread/pthread_test.c\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n // This test file is from occlum pthread test.\n \n #include <sys/types.h>\ndiff --git a/regression/apps/scripts/run_regression_test.sh b/regression/apps/scripts/run_regression_test.sh\nindex 1dbba14741..57d87ae152 100755\n--- a/regression/apps/scripts/run_regression_test.sh\n+++ b/regression/apps/scripts/run_regression_test.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n set -e\n \n SCRIPT_DIR=/regression\ndiff --git a/regression/apps/signal_c/signal_test.c b/regression/apps/signal_c/signal_test.c\nindex 8d800feef3..1193173b04 100644\n--- a/regression/apps/signal_c/signal_test.c\n+++ b/regression/apps/signal_c/signal_test.c\n@@ -1,4 +1,6 @@\n-// This test file is from occlum, to test whether we implement signal correctly.\n+// SPDX-License-Identifier: MPL-2.0\n+\n+// This test file is from occlum signal test.\n \n #define _GNU_SOURCE\n #include <sys/types.h>\ndiff --git a/regression/apps/test_common.mk b/regression/apps/test_common.mk\nindex 7187429001..e31292967f 100644\n--- a/regression/apps/test_common.mk\n+++ b/regression/apps/test_common.mk\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n MAIN_MAKEFILE := $(firstword $(MAKEFILE_LIST))\n INCLUDE_MAKEFILE := $(lastword $(MAKEFILE_LIST))\n CUR_DIR := $(shell dirname $(realpath $(MAIN_MAKEFILE)))\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\nindex acca28e15d..60b047e940 100644\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -1,3 +1,5 @@\n+# SPDX-License-Identifier: MPL-2.0\n+\n TESTS ?= chmod_test fsync_test getdents_test link_test lseek_test mkdir_test \\\n \t\topen_create_test open_test pty_test read_test rename_test stat_test \\\n \t\tstatfs_test symlink_test sync_test uidgid_test unlink_test \\\ndiff --git a/regression/syscall_test/run_syscall_test.sh b/regression/syscall_test/run_syscall_test.sh\nindex d66c8562ce..3d2d75e519 100755\n--- a/regression/syscall_test/run_syscall_test.sh\n+++ b/regression/syscall_test/run_syscall_test.sh\n@@ -1,5 +1,7 @@\n #!/bin/sh\n \n+# SPDX-License-Identifier: MPL-2.0\n+\n SCRIPT_DIR=$(dirname \"$0\")\n TEST_TMP_DIR=${SYSCALL_TEST_DIR:-/tmp}\n TEST_BIN_DIR=$SCRIPT_DIR/tests\ndiff --git a/services/libs/comp-sys/cargo-component/tests/duplicate_lib_name.rs b/services/libs/comp-sys/cargo-component/tests/duplicate_lib_name.rs\nindex 985ec2b4fe..ccc3c0fc8c 100644\n--- a/services/libs/comp-sys/cargo-component/tests/duplicate_lib_name.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/duplicate_lib_name.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n //! This test checks that if two components have same name, the compiler will panic.\n \n #![feature(once_cell)]\ndiff --git a/services/libs/comp-sys/cargo-component/tests/missing_toml.rs b/services/libs/comp-sys/cargo-component/tests/missing_toml.rs\nindex e9ed461e5f..9c36b614ba 100644\n--- a/services/libs/comp-sys/cargo-component/tests/missing_toml.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/missing_toml.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n //! This test checks that if Components.toml is missed, the compiler will panic.\n \n #![feature(once_cell)]\ndiff --git a/services/libs/comp-sys/cargo-component/tests/reexport.rs b/services/libs/comp-sys/cargo-component/tests/reexport.rs\nindex 8707dedf65..c8d00d103f 100644\n--- a/services/libs/comp-sys/cargo-component/tests/reexport.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/reexport.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n //! This test checks that if cargo-component can control reexported entry points.\n \n #![feature(once_cell)]\ndiff --git a/services/libs/comp-sys/cargo-component/tests/regression.rs b/services/libs/comp-sys/cargo-component/tests/regression.rs\nindex 79504c9682..678d688dc7 100644\n--- a/services/libs/comp-sys/cargo-component/tests/regression.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/regression.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n //! This test checks that visiting controlled resources in whitelist is allowed.\n \n #![feature(once_cell)]\ndiff --git a/services/libs/comp-sys/cargo-component/tests/test_utils/mod.rs b/services/libs/comp-sys/cargo-component/tests/test_utils/mod.rs\nindex 6ef8c6ee2e..3724d455e0 100644\n--- a/services/libs/comp-sys/cargo-component/tests/test_utils/mod.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/test_utils/mod.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n #![allow(unused)]\n \n use std::path::PathBuf;\ndiff --git a/services/libs/comp-sys/cargo-component/tests/trait_method.rs b/services/libs/comp-sys/cargo-component/tests/trait_method.rs\nindex d11d9626e1..3b5e2ca3f4 100644\n--- a/services/libs/comp-sys/cargo-component/tests/trait_method.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/trait_method.rs\n@@ -1,3 +1,6 @@\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n //! This test checks that if cargo-component can control method and trait method\n \n #![feature(once_cell)]\ndiff --git a/services/libs/comp-sys/cargo-component/tests/violate_policy.rs b/services/libs/comp-sys/cargo-component/tests/violate_policy.rs\nindex 58802fe10a..4126bc6320 100644\n--- a/services/libs/comp-sys/cargo-component/tests/violate_policy.rs\n+++ b/services/libs/comp-sys/cargo-component/tests/violate_policy.rs\n@@ -1,4 +1,8 @@\n-//! This test checks that if controlled resource not in whitelist is visited, cargo-component will report warning message.\n+// Licensed under the Apache License, Version 2.0 or the MIT License.\n+// Copyright (C) 2023-2024 Ant Group.\n+\n+//! This test checks that if controlled resource not in whitelist is visited, cargo-component will \n+//! report warning message.\n \n #![feature(once_cell)]\n \ndiff --git a/services/libs/comp-sys/component/tests/init-order/first-init/src/lib.rs b/services/libs/comp-sys/component/tests/init-order/first-init/src/lib.rs\nindex 0875097625..66c9b41811 100644\n--- a/services/libs/comp-sys/component/tests/init-order/first-init/src/lib.rs\n+++ b/services/libs/comp-sys/component/tests/init-order/first-init/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::sync::atomic::AtomicBool;\n use std::sync::atomic::Ordering::Relaxed;\n \ndiff --git a/services/libs/comp-sys/component/tests/init-order/second-init/src/lib.rs b/services/libs/comp-sys/component/tests/init-order/second-init/src/lib.rs\nindex 10ff955828..03ee5d5123 100644\n--- a/services/libs/comp-sys/component/tests/init-order/second-init/src/lib.rs\n+++ b/services/libs/comp-sys/component/tests/init-order/second-init/src/lib.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::sync::atomic::{Ordering::Relaxed, AtomicBool};\n \n use component::init_component;\ndiff --git a/services/libs/comp-sys/component/tests/init-order/second-init/tests/test.rs b/services/libs/comp-sys/component/tests/init-order/second-init/tests/test.rs\nindex 2bb2e5c42f..42cdb72f91 100644\n--- a/services/libs/comp-sys/component/tests/init-order/second-init/tests/test.rs\n+++ b/services/libs/comp-sys/component/tests/init-order/second-init/tests/test.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use second_init::HAS_INIT;\n use std::sync::atomic::Ordering::Relaxed;\n \ndiff --git a/services/libs/comp-sys/component/tests/init-order/src/main.rs b/services/libs/comp-sys/component/tests/init-order/src/main.rs\nindex eb87b21754..304060cc9b 100644\n--- a/services/libs/comp-sys/component/tests/init-order/src/main.rs\n+++ b/services/libs/comp-sys/component/tests/init-order/src/main.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use std::sync::atomic::{Ordering::Relaxed, AtomicBool};\n \n use component::init_component;\ndiff --git a/services/libs/comp-sys/component/tests/init-order/tests/test.rs b/services/libs/comp-sys/component/tests/init-order/tests/test.rs\nindex 64c7c8b136..92ea589798 100644\n--- a/services/libs/comp-sys/component/tests/init-order/tests/test.rs\n+++ b/services/libs/comp-sys/component/tests/init-order/tests/test.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use first_init::HAS_INIT;\n use component::init_component;\n use std::sync::atomic::Ordering::Relaxed;\ndiff --git a/services/libs/cpio-decoder/src/test.rs b/services/libs/cpio-decoder/src/test.rs\nindex 871f73959b..805611d153 100644\n--- a/services/libs/cpio-decoder/src/test.rs\n+++ b/services/libs/cpio-decoder/src/test.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use super::error::*;\n use super::{CpioDecoder, FileType};\n use lending_iterator::LendingIterator;\ndiff --git a/services/libs/int-to-c-enum/tests/regression.rs b/services/libs/int-to-c-enum/tests/regression.rs\nindex b3ede6712d..2f6f615230 100644\n--- a/services/libs/int-to-c-enum/tests/regression.rs\n+++ b/services/libs/int-to-c-enum/tests/regression.rs\n@@ -1,3 +1,5 @@\n+// SPDX-License-Identifier: MPL-2.0\n+\n use int_to_c_enum::TryFromInt;\n \n #[derive(TryFromInt, Debug, PartialEq, Eq)]\n", "problem_statement": "Add copyright and license info to the header of every file\nNeed to insert the copyright header to every source code file.\r\n\r\nHere is the header for each Rust file.\r\n\r\n```rust\r\n// SPDX-License-Identifier: MPL-2.0\r\n```\n", "hints_text": "As a side note, the MPL license is unfortunately hard-coded to allow implicit upgrades when the Mozilla Foundation releases a new license version. Not sure if we like that or not (or at least accept it).\r\n\r\n> 10.2. Effect of New Versions\r\n> \r\n> You may distribute the Covered Software under the terms of the version\r\n> of the License under which You originally received the Covered Software,\r\n> or under the terms of any subsequent version published by the license\r\n> steward.\r\n\r\nA similar statement in GPL-2.0 instead offers two choices, i.e., `GPL-2.0-only` or `GPL-2.0-or-later`.\r\n> 9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.\r\n> Each version is given a distinguishing version number. *If the Program specifies a version number of this License which applies to it and \"any later version\",* you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of this License, you may choose any version ever published by the Free Software Foundation.\r\n\r\nLinux uses `GPL-2.0-only` because there are some problems with GPL-3.0, or at least Linus Torvalds does not like GPL-3.0.", "created_at": "2024-01-03T06:45:56Z", "version": "0.3"}, {"repo": "asterinas/asterinas", "pull_number": 561, "instance_id": "asterinas__asterinas-561", "issue_numbers": ["551"], "base_commit": "6dbf5d560deafea0dcec228e4cb2d5e53c756174", "patch": "diff --git a/.cargo/config.toml b/.cargo/config.toml\nindex c353f95051..0b4b26d967 100644\n--- a/.cargo/config.toml\n+++ b/.cargo/config.toml\n@@ -1,6 +1,6 @@\n \n [target.'cfg(target_os = \"none\")']\n-runner = \"cargo run --package jinux-runner --\"\n+runner = \"cargo run --package aster-runner --\"\n \n [alias]\n kcheck = \"check --target x86_64-custom.json -Zbuild-std=core,alloc,compiler_builtins -Zbuild-std-features=compiler-builtins-mem\"\ndiff --git a/.github/workflows/cargo_check.yml b/.github/workflows/cargo_check.yml\nindex d05eb6a071..30f72a3c84 100644\n--- a/.github/workflows/cargo_check.yml\n+++ b/.github/workflows/cargo_check.yml\n@@ -10,9 +10,9 @@ jobs:\n   test:\n     runs-on: ubuntu-latest\n     timeout-minutes: 10\n-    container: jinuxdev/jinux:0.2.2\n+    container: asterinas/asterinas:0.2.2\n     steps:\n-      - run: echo \"Running in jinuxdev/jinux:0.2.2\"\n+      - run: echo \"Running in asterinas/asterinas:0.2.2\"\n \n       - uses: actions/checkout@v3\n \ndiff --git a/.github/workflows/docker_build.yml b/.github/workflows/docker_build.yml\nindex 29a8c03c1d..745d9711f1 100644\n--- a/.github/workflows/docker_build.yml\n+++ b/.github/workflows/docker_build.yml\n@@ -26,7 +26,7 @@ jobs:\n       - name: Fetch versions in the repo\n         id: fetch-versions\n         run: |\n-          echo \"jinux_version=$( cat VERSION )\" >> \"$GITHUB_OUTPUT\"\n+          echo \"aster_version=$( cat VERSION )\" >> \"$GITHUB_OUTPUT\"\n           echo \"rust_version=$( grep -m1 -o 'nightly-[0-9]\\+-[0-9]\\+-[0-9]\\+' rust-toolchain.toml )\" >> \"$GITHUB_OUTPUT\"\n \n       - name: Build and push\n@@ -36,6 +36,6 @@ jobs:\n           file: ./tools/docker/Dockerfile.ubuntu22.04\n           platforms: linux/amd64\n           push: true\n-          tags: jinuxdev/jinux:${{ steps.fetch-versions.outputs.jinux_version }}\n+          tags: asterinas/asterinas:${{ steps.fetch-versions.outputs.aster_version }}\n           build-args: |\n-            \"JINUX_RUST_VERSION=${{ steps.fetch-versions.outputs.rust_version }}\"\n+            \"ASTER_RUST_VERSION=${{ steps.fetch-versions.outputs.rust_version }}\"\ndiff --git a/COPYRIGHT b/COPYRIGHT\nindex ec66a4219d..1bfe4d99ea 100644\n--- a/COPYRIGHT\n+++ b/COPYRIGHT\n@@ -1,9 +1,9 @@\n-The Jinux project licensed under the GNU General Public License version 2.\n+The Asterinas project licensed under the GNU General Public License version 2.\n \n-Copyrights in the Jinux project are retained by their contributors. No\n-copyright assignment is required to contribute to the Jinux project.\n+Copyrights in the Asterinas project are retained by their contributors. No\n+copyright assignment is required to contribute to the Asterinas project.\n For full authorship information, see the version control history.\n \n-Please note that certain files or directories within the Jinux project may \n+Please note that certain files or directories within the Asterinas project may \n contain explicit copyright notices and/or license notices differ\n from the project's general license terms.\ndiff --git a/Cargo.lock b/Cargo.lock\nindex 67e48cc9f9..591a040cf6 100644\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -113,6 +113,250 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d92bec98840b8f03a5ff5413de5293bfcd8bf96467cf5452609f939ec6f5de16\"\n \n+[[package]]\n+name = \"aster-block\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"aster-util\",\n+ \"bitflags 1.3.2\",\n+ \"component\",\n+ \"lazy_static\",\n+ \"log\",\n+ \"spin 0.9.8\",\n+]\n+\n+[[package]]\n+name = \"aster-console\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"aster-util\",\n+ \"bitflags 1.3.2\",\n+ \"component\",\n+ \"log\",\n+ \"spin 0.9.8\",\n+]\n+\n+[[package]]\n+name = \"aster-frame\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"acpi\",\n+ \"align_ext\",\n+ \"aml\",\n+ \"bit_field\",\n+ \"bitflags 1.3.2\",\n+ \"bitvec\",\n+ \"buddy_system_allocator\",\n+ \"cfg-if\",\n+ \"gimli\",\n+ \"inherit-methods-macro\",\n+ \"int-to-c-enum\",\n+ \"intrusive-collections\",\n+ \"ktest\",\n+ \"lazy_static\",\n+ \"log\",\n+ \"multiboot2\",\n+ \"pod\",\n+ \"rsdp\",\n+ \"spin 0.9.8\",\n+ \"static_assertions\",\n+ \"tdx-guest\",\n+ \"trapframe\",\n+ \"unwinding\",\n+ \"volatile\",\n+ \"x86\",\n+ \"x86_64\",\n+]\n+\n+[[package]]\n+name = \"aster-frame-x86-boot-linux-setup\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"uart_16550\",\n+ \"xmas-elf\",\n+]\n+\n+[[package]]\n+name = \"aster-framebuffer\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"component\",\n+ \"font8x8\",\n+ \"log\",\n+ \"spin 0.9.8\",\n+]\n+\n+[[package]]\n+name = \"aster-input\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"aster-rights\",\n+ \"aster-util\",\n+ \"bitflags 1.3.2\",\n+ \"component\",\n+ \"lazy_static\",\n+ \"log\",\n+ \"spin 0.9.8\",\n+ \"virtio-input-decoder\",\n+]\n+\n+[[package]]\n+name = \"aster-network\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"align_ext\",\n+ \"aster-frame\",\n+ \"aster-rights\",\n+ \"aster-util\",\n+ \"bitflags 1.3.2\",\n+ \"bytes\",\n+ \"component\",\n+ \"int-to-c-enum\",\n+ \"log\",\n+ \"pod\",\n+ \"ringbuf\",\n+ \"smoltcp\",\n+ \"spin 0.9.8\",\n+]\n+\n+[[package]]\n+name = \"aster-rights\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-rights-proc\",\n+ \"bitflags 1.3.2\",\n+ \"typeflags\",\n+ \"typeflags-util\",\n+]\n+\n+[[package]]\n+name = \"aster-rights-proc\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 1.0.109\",\n+]\n+\n+[[package]]\n+name = \"aster-runner\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"anyhow\",\n+ \"clap\",\n+ \"glob\",\n+ \"rand\",\n+ \"xmas-elf\",\n+]\n+\n+[[package]]\n+name = \"aster-std\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"align_ext\",\n+ \"ascii\",\n+ \"aster-block\",\n+ \"aster-console\",\n+ \"aster-frame\",\n+ \"aster-input\",\n+ \"aster-network\",\n+ \"aster-rights\",\n+ \"aster-rights-proc\",\n+ \"aster-time\",\n+ \"aster-util\",\n+ \"aster-virtio\",\n+ \"bitflags 1.3.2\",\n+ \"controlled\",\n+ \"core2\",\n+ \"cpio-decoder\",\n+ \"getrandom\",\n+ \"int-to-c-enum\",\n+ \"intrusive-collections\",\n+ \"keyable-arc\",\n+ \"ktest\",\n+ \"lazy_static\",\n+ \"lending-iterator\",\n+ \"libflate\",\n+ \"log\",\n+ \"lru\",\n+ \"pod\",\n+ \"ringbuf\",\n+ \"smoltcp\",\n+ \"spin 0.9.8\",\n+ \"tdx-guest\",\n+ \"time\",\n+ \"typeflags\",\n+ \"typeflags-util\",\n+ \"virtio-input-decoder\",\n+ \"vte\",\n+ \"xmas-elf\",\n+]\n+\n+[[package]]\n+name = \"aster-time\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"aster-util\",\n+ \"component\",\n+ \"log\",\n+ \"spin 0.9.8\",\n+]\n+\n+[[package]]\n+name = \"aster-util\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"aster-rights\",\n+ \"aster-rights-proc\",\n+ \"bitvec\",\n+ \"ktest\",\n+ \"pod\",\n+ \"typeflags-util\",\n+]\n+\n+[[package]]\n+name = \"aster-virtio\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"align_ext\",\n+ \"aster-block\",\n+ \"aster-console\",\n+ \"aster-frame\",\n+ \"aster-input\",\n+ \"aster-network\",\n+ \"aster-rights\",\n+ \"aster-util\",\n+ \"bit_field\",\n+ \"bitflags 1.3.2\",\n+ \"bytes\",\n+ \"component\",\n+ \"int-to-c-enum\",\n+ \"log\",\n+ \"pod\",\n+ \"smoltcp\",\n+ \"spin 0.9.8\",\n+ \"typeflags-util\",\n+ \"virtio-input-decoder\",\n+]\n+\n+[[package]]\n+name = \"asterinas\"\n+version = \"0.2.2\"\n+dependencies = [\n+ \"aster-frame\",\n+ \"aster-framebuffer\",\n+ \"aster-std\",\n+ \"aster-time\",\n+ \"component\",\n+ \"x86_64\",\n+]\n+\n [[package]]\n name = \"atomic-polyfill\"\n version = \"0.1.11\"\n@@ -552,7 +796,7 @@ dependencies = [\n [[package]]\n name = \"inherit-methods-macro\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jinzhao-dev/inherit-methods-macro?rev=98f7e3e#98f7e3eb9efdac98faf5a7076f154f30894b9b02\"\n+source = \"git+https://github.com/asterinas/inherit-methods-macro?rev=98f7e3e#98f7e3eb9efdac98faf5a7076f154f30894b9b02\"\n dependencies = [\n  \"darling\",\n  \"proc-macro2\",\n@@ -603,250 +847,6 @@ dependencies = [\n  \"either\",\n ]\n \n-[[package]]\n-name = \"jinux\"\n-version = \"0.2.2\"\n-dependencies = [\n- \"component\",\n- \"jinux-frame\",\n- \"jinux-framebuffer\",\n- \"jinux-std\",\n- \"jinux-time\",\n- \"x86_64\",\n-]\n-\n-[[package]]\n-name = \"jinux-block\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"bitflags 1.3.2\",\n- \"component\",\n- \"jinux-frame\",\n- \"jinux-util\",\n- \"lazy_static\",\n- \"log\",\n- \"spin 0.9.8\",\n-]\n-\n-[[package]]\n-name = \"jinux-console\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"bitflags 1.3.2\",\n- \"component\",\n- \"jinux-frame\",\n- \"jinux-util\",\n- \"log\",\n- \"spin 0.9.8\",\n-]\n-\n-[[package]]\n-name = \"jinux-frame\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"acpi\",\n- \"align_ext\",\n- \"aml\",\n- \"bit_field\",\n- \"bitflags 1.3.2\",\n- \"bitvec\",\n- \"buddy_system_allocator\",\n- \"cfg-if\",\n- \"gimli\",\n- \"inherit-methods-macro\",\n- \"int-to-c-enum\",\n- \"intrusive-collections\",\n- \"ktest\",\n- \"lazy_static\",\n- \"log\",\n- \"multiboot2\",\n- \"pod\",\n- \"rsdp\",\n- \"spin 0.9.8\",\n- \"static_assertions\",\n- \"tdx-guest\",\n- \"trapframe\",\n- \"unwinding\",\n- \"volatile\",\n- \"x86\",\n- \"x86_64\",\n-]\n-\n-[[package]]\n-name = \"jinux-frame-x86-boot-linux-setup\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"uart_16550\",\n- \"xmas-elf\",\n-]\n-\n-[[package]]\n-name = \"jinux-framebuffer\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"component\",\n- \"font8x8\",\n- \"jinux-frame\",\n- \"log\",\n- \"spin 0.9.8\",\n-]\n-\n-[[package]]\n-name = \"jinux-input\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"bitflags 1.3.2\",\n- \"component\",\n- \"jinux-frame\",\n- \"jinux-rights\",\n- \"jinux-util\",\n- \"lazy_static\",\n- \"log\",\n- \"spin 0.9.8\",\n- \"virtio-input-decoder\",\n-]\n-\n-[[package]]\n-name = \"jinux-network\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"align_ext\",\n- \"bitflags 1.3.2\",\n- \"bytes\",\n- \"component\",\n- \"int-to-c-enum\",\n- \"jinux-frame\",\n- \"jinux-rights\",\n- \"jinux-util\",\n- \"log\",\n- \"pod\",\n- \"ringbuf\",\n- \"smoltcp\",\n- \"spin 0.9.8\",\n-]\n-\n-[[package]]\n-name = \"jinux-rights\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"bitflags 1.3.2\",\n- \"jinux-rights-proc\",\n- \"typeflags\",\n- \"typeflags-util\",\n-]\n-\n-[[package]]\n-name = \"jinux-rights-proc\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn 1.0.109\",\n-]\n-\n-[[package]]\n-name = \"jinux-runner\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"anyhow\",\n- \"clap\",\n- \"glob\",\n- \"rand\",\n- \"xmas-elf\",\n-]\n-\n-[[package]]\n-name = \"jinux-std\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"align_ext\",\n- \"ascii\",\n- \"bitflags 1.3.2\",\n- \"controlled\",\n- \"core2\",\n- \"cpio-decoder\",\n- \"getrandom\",\n- \"int-to-c-enum\",\n- \"intrusive-collections\",\n- \"jinux-block\",\n- \"jinux-console\",\n- \"jinux-frame\",\n- \"jinux-input\",\n- \"jinux-network\",\n- \"jinux-rights\",\n- \"jinux-rights-proc\",\n- \"jinux-time\",\n- \"jinux-util\",\n- \"jinux-virtio\",\n- \"keyable-arc\",\n- \"ktest\",\n- \"lazy_static\",\n- \"lending-iterator\",\n- \"libflate\",\n- \"log\",\n- \"lru\",\n- \"pod\",\n- \"ringbuf\",\n- \"smoltcp\",\n- \"spin 0.9.8\",\n- \"tdx-guest\",\n- \"time\",\n- \"typeflags\",\n- \"typeflags-util\",\n- \"virtio-input-decoder\",\n- \"vte\",\n- \"xmas-elf\",\n-]\n-\n-[[package]]\n-name = \"jinux-time\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"component\",\n- \"jinux-frame\",\n- \"jinux-util\",\n- \"log\",\n- \"spin 0.9.8\",\n-]\n-\n-[[package]]\n-name = \"jinux-util\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"bitvec\",\n- \"jinux-frame\",\n- \"jinux-rights\",\n- \"jinux-rights-proc\",\n- \"ktest\",\n- \"pod\",\n- \"typeflags-util\",\n-]\n-\n-[[package]]\n-name = \"jinux-virtio\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"align_ext\",\n- \"bit_field\",\n- \"bitflags 1.3.2\",\n- \"bytes\",\n- \"component\",\n- \"int-to-c-enum\",\n- \"jinux-block\",\n- \"jinux-console\",\n- \"jinux-frame\",\n- \"jinux-input\",\n- \"jinux-network\",\n- \"jinux-rights\",\n- \"jinux-util\",\n- \"log\",\n- \"pod\",\n- \"smoltcp\",\n- \"spin 0.9.8\",\n- \"typeflags-util\",\n- \"virtio-input-decoder\",\n-]\n-\n [[package]]\n name = \"json\"\n version = \"0.12.4\"\n@@ -918,7 +918,7 @@ checksum = \"b4668fb0ea861c1df094127ac5f1da3409a82116a4ba74fca2e58ef927159bb3\"\n [[package]]\n name = \"libflate\"\n version = \"1.4.0\"\n-source = \"git+https://github.com/jinzhao-dev/libflate?rev=b781da6#b781da6b6841e380f4cfa3529d5070afad56ea32\"\n+source = \"git+https://github.com/asterinas/libflate?rev=b781da6#b781da6b6841e380f4cfa3529d5070afad56ea32\"\n dependencies = [\n  \"adler32\",\n  \"core2\",\n@@ -929,7 +929,7 @@ dependencies = [\n [[package]]\n name = \"libflate_lz77\"\n version = \"1.2.0\"\n-source = \"git+https://github.com/jinzhao-dev/libflate?rev=b781da6#b781da6b6841e380f4cfa3529d5070afad56ea32\"\n+source = \"git+https://github.com/asterinas/libflate?rev=b781da6#b781da6b6841e380f4cfa3529d5070afad56ea32\"\n dependencies = [\n  \"core2\",\n  \"hashbrown 0.13.2\",\n@@ -1059,7 +1059,7 @@ checksum = \"de3145af08024dea9fa9914f381a17b8fc6034dfb00f3a84013f7ff43f29ed4c\"\n [[package]]\n name = \"pod\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jinzhao-dev/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n+source = \"git+https://github.com/asterinas/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n dependencies = [\n  \"pod-derive\",\n ]\n@@ -1067,7 +1067,7 @@ dependencies = [\n [[package]]\n name = \"pod-derive\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/jinzhao-dev/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n+source = \"git+https://github.com/asterinas/pod?rev=d7dba56#d7dba56cc202a10d483b60aba4f734b1f49cb37b\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1428,7 +1428,7 @@ dependencies = [\n [[package]]\n name = \"trapframe\"\n version = \"0.9.0\"\n-source = \"git+https://github.com/jinzhao-dev/trapframe-rs?rev=9758a83#9758a83f769c8f4df35413c7ad28ef42c270187e\"\n+source = \"git+https://github.com/asterinas/trapframe-rs?rev=2f37590#2f375901398508edb554deb2f84749153a59bb4a\"\n dependencies = [\n  \"log\",\n  \"pod\",\ndiff --git a/Cargo.toml b/Cargo.toml\nindex 5d86a8379c..895bc690be 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -1,21 +1,21 @@\n [package]\n-name = \"jinux\"\n+name = \"asterinas\"\n version = \"0.2.2\"\n edition = \"2021\"\n \n [[bin]]\n-name = \"jinux\"\n+name = \"asterinas\"\n path = \"kernel/main.rs\"\n \n [dependencies]\n-jinux-frame = { path = \"framework/jinux-frame\" }\n-jinux-std = { path = \"services/libs/jinux-std\" }\n+aster-frame = { path = \"framework/aster-frame\" }\n+aster-std = { path = \"services/libs/aster-std\" }\n component = { path = \"services/libs/comp-sys/component\" }\n \n [dev-dependencies]\n x86_64 = \"0.14.2\"\n-jinux-time = { path = \"services/comps/time\" }\n-jinux-framebuffer = { path = \"services/comps/framebuffer\" }\n+aster-time = { path = \"services/comps/time\" }\n+aster-framebuffer = { path = \"services/comps/framebuffer\" }\n \n [profile.dev]\n opt-level = 0\n@@ -33,8 +33,8 @@ panic = \"unwind\"\n \n members = [\n     \"runner\",\n-    \"framework/jinux-frame\",\n-    \"framework/jinux-frame/src/arch/x86/boot/linux_boot/setup\",\n+    \"framework/aster-frame\",\n+    \"framework/aster-frame/src/arch/x86/boot/linux_boot/setup\",\n     \"framework/libs/align_ext\",\n     \"framework/libs/ktest\",\n     \"framework/libs/tdx-guest\",\n@@ -48,10 +48,10 @@ members = [\n     \"services/libs/cpio-decoder\",\n     \"services/libs/int-to-c-enum\",\n     \"services/libs/int-to-c-enum/derive\",\n-    \"services/libs/jinux-rights\",\n-    \"services/libs/jinux-rights-proc\",\n-    \"services/libs/jinux-std\",\n-    \"services/libs/jinux-util\",\n+    \"services/libs/aster-rights\",\n+    \"services/libs/aster-rights-proc\",\n+    \"services/libs/aster-std\",\n+    \"services/libs/aster-util\",\n     \"services/libs/keyable-arc\",\n     \"services/libs/typeflags\",\n     \"services/libs/typeflags-util\",\n@@ -65,4 +65,4 @@ exclude = [\n ]\n \n [features]\n-intel_tdx = [\"jinux-frame/intel_tdx\", \"jinux-std/intel_tdx\"]\n+intel_tdx = [\"aster-frame/intel_tdx\", \"aster-std/intel_tdx\"]\ndiff --git a/Components.toml b/Components.toml\nindex 3f5a396ad9..91183d0331 100644\n--- a/Components.toml\n+++ b/Components.toml\n@@ -1,14 +1,14 @@\n # template\n [components]\n-std = { name = \"jinux-std\" }\n-virtio = { name = \"jinux-virtio\" }\n-input = { name = \"jinux-input\" }\n-block = { name = \"jinux-block\" }\n-console = { name = \"jinux-console\" }\n-time = { name = \"jinux-time\" }\n-framebuffer = { name = \"jinux-framebuffer\" }\n-network = { name = \"jinux-network\" }\n-main = { name = \"jinux\" }\n+std = { name = \"aster-std\" }\n+virtio = { name = \"aster-virtio\" }\n+input = { name = \"aster-input\" }\n+block = { name = \"aster-block\" }\n+console = { name = \"aster-console\" }\n+time = { name = \"aster-time\" }\n+framebuffer = { name = \"aster-framebuffer\" }\n+network = { name = \"aster-network\" }\n+main = { name = \"asterinas\" }\n \n [whitelist]\n [whitelist.std.run_first_process]\ndiff --git a/Makefile b/Makefile\nindex c4e5f2cbd7..485b26467a 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -1,4 +1,4 @@\n-# Make varaiables and defaults, you should refer to jinux-runner for more details\n+# Make varaiables and defaults, you should refer to aster-runner for more details\n AUTO_TEST ?= none\n BOOT_METHOD ?= qemu-grub\n BOOT_PROTOCOL ?= multiboot2\n@@ -92,8 +92,8 @@ USERMODE_TESTABLE := \\\n     services/libs/cpio-decoder \\\n     services/libs/int-to-c-enum \\\n     services/libs/int-to-c-enum/derive \\\n-    services/libs/jinux-rights \\\n-    services/libs/jinux-rights-proc \\\n+    services/libs/aster-rights \\\n+    services/libs/aster-rights-proc \\\n     services/libs/keyable-arc \\\n     services/libs/typeflags \\\n     services/libs/typeflags-util\ndiff --git a/README.md b/README.md\nindex 1128e92a52..a0d5783ab8 100644\n--- a/README.md\n+++ b/README.md\n@@ -1,45 +1,45 @@\n-# Jinux\n+# Asterinas\n \n-Jinux is a _secure_, _fast_, and _general-purpose_ OS kernel, written in Rust and providing Linux-compatible ABI.\n+Asterinas is a _secure_, _fast_, and _general-purpose_ OS kernel, written in Rust and providing Linux-compatible ABI.\n \n-Jinux is designed and implemented with an emphasis on security, rendering it highly attractive for usage scenarios where Linux ABI is indispensable, but Linux itself is deemed insecure given its sheer size of TCB and its nature of being memory unsafe. An instance of such usage is employing Jinux as the guest OS for VM TEEs (e.g., [AMD SEV](https://www.amd.com/en/developer/sev.html) and [Intel TDX](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-trust-domain-extensions.html)).\n+Asterinas is designed and implemented with an emphasis on security, rendering it highly attractive for usage scenarios where Linux ABI is indispensable, but Linux itself is deemed insecure given its sheer size of TCB and its nature of being memory unsafe. An instance of such usage is employing Asterinas as the guest OS for VM TEEs (e.g., [AMD SEV](https://www.amd.com/en/developer/sev.html) and [Intel TDX](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-trust-domain-extensions.html)).\n \n-## What's unique about Jinux\n+## What's unique about Asterinas\n \n-Jinux is a _zero-cost_, _least-privilege_ OS kernel. A least-privilege OS is one that adheres to the principle of least privileges, which mandates that every unit (e.g., a subsystem, a module, a function, or even an object) of the OS has the minimum authority and permissions required to perform its tasks. This approach reduces the security risk associated with any single element's bugs or flaws. By \"zero-cost\", we means the same as in Rust's philosophy of zero-cost abstractions, which emphasizes that high-level abstractions (like those that enable least privilege principles) should be available to developers to use, but not come at the cost of performance. Thus, a zero-cost, least-privilege OS enhances its security without compromising its performance.\n+Asterinas is a _zero-cost_, _least-privilege_ OS kernel. A least-privilege OS is one that adheres to the principle of least privileges, which mandates that every unit (e.g., a subsystem, a module, a function, or even an object) of the OS has the minimum authority and permissions required to perform its tasks. This approach reduces the security risk associated with any single element's bugs or flaws. By \"zero-cost\", we means the same as in Rust's philosophy of zero-cost abstractions, which emphasizes that high-level abstractions (like those that enable least privilege principles) should be available to developers to use, but not come at the cost of performance. Thus, a zero-cost, least-privilege OS enhances its security without compromising its performance.\n \n Some prior OSes do abide by the [principle of least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege), but come with considerable performance costs. Take [seL4](https://sel4.systems/) as an example. A [seL4-based multi-server OS](https://docs.sel4.systems/projects/camkes/) minimizes the scope of the OS running in the privileged CPU mode to the seL4 microkernel. The bulk of OS functionalities are implemented by process-based servers, which are separated by process boundary and only allowed to communicate with each other through well-defined interfaces, usually based on RPC. Each service can only access kernel resources represented by [seL4 capabilities](), each of which is restricted with respect to its scope and permissions. All these security measures contribute to the enhanced security of the OS, but result in a considerable runtime costs due to context switching, message passing, and runtime checks.\n \n-Jinux is unique in practicing the principle of least privilege without sacrificing the performance. This is achieved by realizing the full potential of Rust, which, compared to the traditional system programming language like C/C++, offers unique features like an expressive type system, memory safety with unsafe extensions, powerful macros, and a customizable toolchain. By leveraging these unique features, Jinux is able to construct zero-cost abstractions that enable least privileges at the following three levels.\n+Asterinas is unique in practicing the principle of least privilege without sacrificing the performance. This is achieved by realizing the full potential of Rust, which, compared to the traditional system programming language like C/C++, offers unique features like an expressive type system, memory safety with unsafe extensions, powerful macros, and a customizable toolchain. By leveraging these unique features, Asterinas is able to construct zero-cost abstractions that enable least privileges at the following three levels.\n \n-1. The architectural level. Jinux is architected as a _framekernel_, where the entire OS resides in a single address space and unsafe Rust code is restricted to a tiny portion of the OS called Jinux Framework. The Framework exposes safe APIs to the rest of Jinux, which implements the most of OS functionalities in safe Rust code completely. Thanks to the framekernel architecture, Jinux's TCB for memory safety is minimized.\n+1. The architectural level. Asterinas is architected as a _framekernel_, where the entire OS resides in a single address space and unsafe Rust code is restricted to a tiny portion of the OS called Asterinas Framework. The Framework exposes safe APIs to the rest of Asterinas, which implements the most of OS functionalities in safe Rust code completely. Thanks to the framekernel architecture, Asterinas's TCB for memory safety is minimized.\n \n ![Architecture](docs/src/images/arch_comparison.png)\n \n-2. The component level. Upon Jinux Framework is a set of OS components, each of which is responsible for a particular OS functionality, feature, or device. These OS components are Rust crates with two traits: (1) containing safe Rust code, as demanded by the framekernel architecture, and (2) being governed by Jinux Component System, which can enforce a fine-grained access control to their public APIs. The access control policy is specified in a configuration file and enforced at compile time, using a static analysis tool.\n+2. The component level. Upon Asterinas Framework is a set of OS components, each of which is responsible for a particular OS functionality, feature, or device. These OS components are Rust crates with two traits: (1) containing safe Rust code, as demanded by the framekernel architecture, and (2) being governed by Asterinas Component System, which can enforce a fine-grained access control to their public APIs. The access control policy is specified in a configuration file and enforced at compile time, using a static analysis tool.\n \n-3. The object level. Jinux promotes the philosophy of _everything-is-a-capability_, which means all kernel resources, from files to threads, from virtual memory to physical pages, should be accessed through [capabilities](https://en.wikipedia.org/wiki/Capability-based_security). In Jinux, capabilities are implemented as Rust objects that are constrained in their creation, acquisition, and usage. One common form of capabilities is those with access rights. Wherever possible, access rights are encoded in types (rather than values) so that they can be checked at compile time, eliminating any runtime costs.\n+3. The object level. Asterinas promotes the philosophy of _everything-is-a-capability_, which means all kernel resources, from files to threads, from virtual memory to physical pages, should be accessed through [capabilities](https://en.wikipedia.org/wiki/Capability-based_security). In Asterinas, capabilities are implemented as Rust objects that are constrained in their creation, acquisition, and usage. One common form of capabilities is those with access rights. Wherever possible, access rights are encoded in types (rather than values) so that they can be checked at compile time, eliminating any runtime costs.\n \n-As a zero-cost, least-privilege OS, Jinux provides the best of both worlds: the performance of a monolithic kernel and the security of a microkernel. Like a monolithic kernel, the different parts of Jinux can communicate with the most efficient means, e.g., function calls and memory sharing. In the same spirit as a microkernel, the fundamental security properties of the OS depend on a minimum amount of code (i.e., Jinux Framework).\n+As a zero-cost, least-privilege OS, Asterinas provides the best of both worlds: the performance of a monolithic kernel and the security of a microkernel. Like a monolithic kernel, the different parts of Asterinas can communicate with the most efficient means, e.g., function calls and memory sharing. In the same spirit as a microkernel, the fundamental security properties of the OS depend on a minimum amount of code (i.e., Asterinas Framework).\n \n-## Build, test and debug Jinux\n+## Build, test and debug Asterinas\n \n While most of the code is written in Rust, the project-scope build process is governed by Makefile. The development environment is managed with Docker. Please ensure Docker is installed and can be run without sudo privilege.\n \n ### Preparation\n-1. Download the latest source code of jinux.\n+1. Download the latest source code of asterinas.\n ```bash\n git clone [repository url]\n ```\n \n 2. After downloading the source code, run the following command to pull the development image.\n ```bash\n-docker pull jinuxdev/jinux:0.2.2\n+docker pull asterinas/asterinas:0.2.2\n ```\n \n 3. Start the development container.\n ```bash\n-docker run -it --privileged --network=host --device=/dev/kvm -v `pwd`:/root/jinux jinuxdev/jinux:0.2.2\n+docker run -it --privileged --network=host --device=/dev/kvm -v `pwd`:/root/asterinas asterinas/asterinas:0.2.2\n ```\n \n **All build and test commands should be run inside the development container.**\n@@ -70,14 +70,14 @@ Nevertheless, you could enter the directory of a specific crate and invoke `carg\n \n #### Kernel mode unit tests\n \n-We can run unit tests in kernel mode for crates like `jinux-frame` or `jinux-std`. This is powered by our [ktest](framework/libs/ktest) framework.\n+We can run unit tests in kernel mode for crates like `aster-frame` or `aster-std`. This is powered by our [ktest](framework/libs/ktest) framework.\n ```bash\n make run KTEST=1\n ```\n \n You could also specify tests in a crate or a subset of tests to run.\n ```bash\n-make run KTEST=1 KTEST_WHITELIST=failing_assertion,jinux_frame::test::expect_panic KTEST_CRATES=jinux-frame\n+make run KTEST=1 KTEST_WHITELIST=failing_assertion,aster_frame::test::expect_panic KTEST_CRATES=aster-frame\n ```\n \n #### Component check\n@@ -96,33 +96,33 @@ cargo component-check\n \n #### Regression Test\n \n-This command will automatically run Jinux with the test binaries in `regression/apps` directory.\n+This command will automatically run Asterinas with the test binaries in `regression/apps` directory.\n ```bash\n make run AUTO_TEST=regression\n ```\n \n #### Syscall Test\n \n-This command will build the syscall test binary and automatically run Jinux with the tests using QEMU.\n+This command will build the syscall test binary and automatically run Asterinas with the tests using QEMU.\n ```bash\n make run AUTO_TEST=syscall\n ```\n \n-Alternatively, if you wish to test it interactively inside a shell in Jinux.\n+Alternatively, if you wish to test it interactively inside a shell in Asterinas.\n ```bash\n make run BUILD_SYSCALL_TEST=1\n ```\n \n-Then, we can run the following script using the Jinux shell to run all syscall test cases.\n+Then, we can run the following script using the Asterinas shell to run all syscall test cases.\n ```bash\n /opt/syscall_test/run_syscall_test.sh\n ```\n \n ### Debug\n \n-To debug Jinux using [QEMU GDB remote debugging](https://qemu-project.gitlab.io/qemu/system/gdb.html), you could compile Jinux in debug mode, start a Jinux instance and run the GDB interactive shell in another terminal.\n+To debug Asterinas using [QEMU GDB remote debugging](https://qemu-project.gitlab.io/qemu/system/gdb.html), you could compile Asterinas in debug mode, start a Asterinas instance and run the GDB interactive shell in another terminal.\n \n-To start a QEMU Jinux VM and wait for debugging connection:\n+To start a QEMU Asterinas VM and wait for debugging connection:\n ```bash\n make run GDB_SERVER=1 ENABLE_KVM=0\n ```\n@@ -132,33 +132,33 @@ To get the GDB interactive shell:\n make run GDB_CLIENT=1\n ```\n \n-Currently, the Jinux runner's debugging interface is exposed by unix socket. Thus there shouldn't be multiple debugging instances in the same container. To add debug symbols for the underlying infrastructures such as UEFI firmware or bootloader, please check the runner's source code for details.\n+Currently, the Asterinas runner's debugging interface is exposed by unix socket. Thus there shouldn't be multiple debugging instances in the same container. To add debug symbols for the underlying infrastructures such as UEFI firmware or bootloader, please check the runner's source code for details.\n \n ## Code organization\n \n-The codebase of Jinux is organized as below.\n+The codebase of Asterinas is organized as below.\n \n-* `runner/`: creating a bootable Jinux kernel image along with an initramfs image. It also supports `cargo run` since it is the only package with `main()`.\n-* `kernel/`: defining the entry point of the Jinux kernel.\n-* `framework/`: the privileged half of Jinux (allowed to use `unsafe` keyword)\n-    * `jinux-frame`: providing the safe Rust abstractions for low-level resources like CPU, memory, interrupts, etc;\n+* `runner/`: creating a bootable Asterinas kernel image along with an initramfs image. It also supports `cargo run` since it is the only package with `main()`.\n+* `kernel/`: defining the entry point of the Asterinas kernel.\n+* `framework/`: the privileged half of Asterinas (allowed to use `unsafe` keyword)\n+    * `aster-frame`: providing the safe Rust abstractions for low-level resources like CPU, memory, interrupts, etc;\n     * `libs`: Privileged libraries.\n-* `services/`: the unprivileged half of Jinux (not allowed to use `unsafe` directly), implementing most of the OS functionalities.\n-    * `comps/`: Jinux OS components;\n-    * `libs/`: Jinux OS libraries;\n-        * `jinux-std`: this is where system calls are implemented. Currently, this crate is too big. It will eventually be decomposed into smaller crates.\n+* `services/`: the unprivileged half of Asterinas (not allowed to use `unsafe` directly), implementing most of the OS functionalities.\n+    * `comps/`: Asterinas OS components;\n+    * `libs/`: Asterinas OS libraries;\n+        * `aster-std`: this is where system calls are implemented. Currently, this crate is too big. It will eventually be decomposed into smaller crates.\n * `tests/`: providing integration tests written in Rust.\n * `regression/`: providing user-space tests written in C.\n-* `docs/`: The Jinux book (needs a major update).\n+* `docs/`: The Asterinas book (needs a major update).\n \n ## Development status\n \n-Jinux is under active development. The list below summarizes the progress of important planned features.\n+Asterinas is under active development. The list below summarizes the progress of important planned features.\n \n * Technical novelty\n-    - [X] Jinux Framework\n-    - [X] Jinux Component System\n-    - [X] Jinux Capabilities\n+    - [X] Asterinas Framework\n+    - [X] Asterinas Component System\n+    - [X] Asterinas Capabilities\n * High-level stuff\n     * Process management\n         - [X] Essential system calls (fork, execve, etc.)\n@@ -231,6 +231,6 @@ Jinux is under active development. The list below summarizes the progress of imp\n \n ## License\n \n-The Jinux project is proudly released as a free software\n+The Asterinas project is proudly released as a free software\n under the license of [GNU General Public License version 2](LICENSE-GPL).\n See [COPYRIGHT](COPYRIGHT) for details.\ndiff --git a/build.rs b/build.rs\nindex df176c1db6..0c2017fb8b 100644\n--- a/build.rs\n+++ b/build.rs\n@@ -5,7 +5,7 @@ fn main() -> Result<(), Box<dyn Error + Send + Sync>> {\n     let linker_script_path = if target == \"x86_64\" {\n         PathBuf::from(std::env::var(\"CARGO_MANIFEST_DIR\").unwrap())\n             .join(\"framework\")\n-            .join(\"jinux-frame\")\n+            .join(\"aster-frame\")\n             .join(\"src\")\n             .join(\"arch\")\n             .join(\"x86\")\ndiff --git a/docs/README.md b/docs/README.md\nindex 501530b428..bbba0f9432 100644\n--- a/docs/README.md\n+++ b/docs/README.md\n@@ -1,4 +1,4 @@\n-# Jinux Documentation\n+# Asterinas Documentation\n \n The documentation is rendered as a book with [mdBook](https://rust-lang.github.io/mdBook/),\n which can be installed with `cargo`.\ndiff --git a/docs/book.toml b/docs/book.toml\nindex 99f5875342..feb3db7264 100644\n--- a/docs/book.toml\n+++ b/docs/book.toml\n@@ -3,7 +3,7 @@ authors = [\"Tate, Hongliang Tian\"]\n language = \"en\"\n multilingual = false\n src = \"src\"\n-title = \"Jinux: A Secure, Fast, and Modern OS in Rust\"\n+title = \"Asterinas: A Secure, Fast, and Modern OS in Rust\"\n \n [rust]\n edition = \"2021\"\ndiff --git a/docs/src/README.md b/docs/src/README.md\nindex 5f3ab2fa99..d370fb5433 100644\n--- a/docs/src/README.md\n+++ b/docs/src/README.md\n@@ -14,7 +14,7 @@\n \n # Introduction\n \n-This document describes Jinux, a secure, fast, and modern OS written in Rust.\n+This document describes Asterinas, a secure, fast, and modern OS written in Rust.\n \n As the project is a work in progress, this document is by no means complete.\n Despite the incompleteness, this evolving document serves several important purposes:\n@@ -50,7 +50,7 @@ OSes, e.g., [Kerla](https://github.com/nuta/kerla),\n and [zCore](https://github.com/rcore-os/zCore). Despite their varying degrees of\n success, none of them are general-purpose, industrial-strength OSes that are or\n will ever be competitive with Linux. Eventually, a winner will emerge out of this\n-market of Rust OSes, and Jinux is our bet for this competition.\n+market of Rust OSes, and Asterinas is our bet for this competition.\n \n Second, Rust OSes are a perfect fit for\n [Trusted Execution Environments (TEEs)](https://en.wikipedia.org/wiki/Trusted_execution_environment).\n@@ -79,24 +79,24 @@ relational databases:\n [Oracle and IBM are losing ground as Chinese vendors catch up with their US counterparts](https://www.theregister.com/2022/07/06/international_database_vendors_are_losing/).\n Can such success stories be repeated in the field of OSes? I think so.\n There are some China's home-grown OSes like [openKylin](https://www.openkylin.top/index.php?lang=en), but all of them are based on Linux and lack a self-developed\n-OS _kernel_. The long-term goal of Jinux is to fill this key missing core of the home-grown OSes.\n+OS _kernel_. The long-term goal of Asterinas is to fill this key missing core of the home-grown OSes.\n \n ## Architecture Overview\n \n-Here is an overview of the architecture of Jinux.\n+Here is an overview of the architecture of Asterinas.\n \n ![architecture overview](images/arch_overview.png)\n \n ## Features\n \n-**1. Security by design.** Security is our top priority in the design of Jinux. As such, we adopt the widely acknowledged security best practice of [least privilege principle](https://en.wikipedia.org/wiki/Principle_of_least_privilege) and enforce it in a fashion that leverages the full strengths of Rust. To do so, we partition Jinux into two halves: a _privileged_ OS core and _unprivileged_ OS components. All OS components are written entirely in _safe_ Rust and only the privileged OS core\n+**1. Security by design.** Security is our top priority in the design of Asterinas. As such, we adopt the widely acknowledged security best practice of [least privilege principle](https://en.wikipedia.org/wiki/Principle_of_least_privilege) and enforce it in a fashion that leverages the full strengths of Rust. To do so, we partition Asterinas into two halves: a _privileged_ OS core and _unprivileged_ OS components. All OS components are written entirely in _safe_ Rust and only the privileged OS core\n is allowed to have _unsafe_ Rust code. Furthermore, we propose the idea of _everything-is-a-capability_, which elevates the status of [capabilities](https://en.wikipedia.org/wiki/Capability-based_security) to the level of a ubiquitous security primitive used throughout the OS. We make novel use of Rust's advanced features (e.g., [type-level programming](https://willcrichton.net/notes/type-level-programming/)) to make capabilities more accessible and efficient. The net result is improved security and uncompromised performance.\n \n-**2. Trustworthy OS-level virtualization.** OS-level virtualization mechanisms (like Linux's cgroups and namespaces) enable containers, a more lightweight and arguably more popular alternative to virtual machines (VMs). But there is one problem with containers: they are not as secure as VMs (see [StackExchange](https://security.stackexchange.com/questions/169642/what-makes-docker-more-secure-than-vms-or-bare-metal), [LWN](https://lwn.net/Articles/796700/), and [AWS](https://docs.aws.amazon.com/AmazonECS/latest/bestpracticesguide/security-tasks-containers.html)). There is a real risk that malicious containers may exploit privilege escalation bugs in the OS kernel to attack the host. [A study](https://dl.acm.org/doi/10.1145/3274694.3274720) found that 11 out of 88 kernel exploits are effective in breaking the container sandbox. The seemingly inherent insecurity of OS kernels leads to a new breed of container implementations (e.g., [Kata](https://katacontainers.io/) and [gVisor](https://gvisor.dev/)) that are based on VMs, instead of kernels, for isolation and sandboxing. We argue that this unfortunate retreat from OS-level virtualization to VM-based one is unwarranted---if the OS kernels are secure enough. And this is exactly what we plan to achieve with Jinux. We aim to provide a trustworthy OS-level virtualization mechanism on Jinux.\n+**2. Trustworthy OS-level virtualization.** OS-level virtualization mechanisms (like Linux's cgroups and namespaces) enable containers, a more lightweight and arguably more popular alternative to virtual machines (VMs). But there is one problem with containers: they are not as secure as VMs (see [StackExchange](https://security.stackexchange.com/questions/169642/what-makes-docker-more-secure-than-vms-or-bare-metal), [LWN](https://lwn.net/Articles/796700/), and [AWS](https://docs.aws.amazon.com/AmazonECS/latest/bestpracticesguide/security-tasks-containers.html)). There is a real risk that malicious containers may exploit privilege escalation bugs in the OS kernel to attack the host. [A study](https://dl.acm.org/doi/10.1145/3274694.3274720) found that 11 out of 88 kernel exploits are effective in breaking the container sandbox. The seemingly inherent insecurity of OS kernels leads to a new breed of container implementations (e.g., [Kata](https://katacontainers.io/) and [gVisor](https://gvisor.dev/)) that are based on VMs, instead of kernels, for isolation and sandboxing. We argue that this unfortunate retreat from OS-level virtualization to VM-based one is unwarranted---if the OS kernels are secure enough. And this is exactly what we plan to achieve with Asterinas. We aim to provide a trustworthy OS-level virtualization mechanism on Asterinas.\n \n-**3. Fast user-mode development.** Traditional OS kernels like Linux are hard to develop, test, and debug. Kernel development involves countless rounds of programming, failing, and rebooting on bare-metal or virtual machines. This way of life is unproductive and painful. Such a pain point is also recognized and partially addressed by [research work](https://www.usenix.org/conference/fast21/presentation/miller), but we think we can do more. In this spirit, we design the OS core to provide high-level APIs that are largely independent of the underlying hardware and implement it with two targets: one target is as part of a regular OS in kernel space and the other is as a library OS in user space. This way, all the OS components of Jinux, which are stacked above the OS core, can be developed, tested, and debugged in user space, which is more friendly to developers than kernel space.\n+**3. Fast user-mode development.** Traditional OS kernels like Linux are hard to develop, test, and debug. Kernel development involves countless rounds of programming, failing, and rebooting on bare-metal or virtual machines. This way of life is unproductive and painful. Such a pain point is also recognized and partially addressed by [research work](https://www.usenix.org/conference/fast21/presentation/miller), but we think we can do more. In this spirit, we design the OS core to provide high-level APIs that are largely independent of the underlying hardware and implement it with two targets: one target is as part of a regular OS in kernel space and the other is as a library OS in user space. This way, all the OS components of Asterinas, which are stacked above the OS core, can be developed, tested, and debugged in user space, which is more friendly to developers than kernel space.\n \n-**4. High-fidelity Linux ABI.** An OS without usable applications is useless. So we believe it is important for Jinux to fit in an established and thriving ecosystem of software, such as the one around Linux. This is why we conclude that Jinux should aim at implementing high-fidelity Linux ABI, including the system calls, the proc file system, etc.\n+**4. High-fidelity Linux ABI.** An OS without usable applications is useless. So we believe it is important for Asterinas to fit in an established and thriving ecosystem of software, such as the one around Linux. This is why we conclude that Asterinas should aim at implementing high-fidelity Linux ABI, including the system calls, the proc file system, etc.\n \n **5. TEEs as top-tier targets.** (Todo)\n \ndiff --git a/docs/src/capabilities/README.md b/docs/src/capabilities/README.md\nindex e5fd82c6ae..b6797dcf42 100644\n--- a/docs/src/capabilities/README.md\n+++ b/docs/src/capabilities/README.md\n@@ -20,12 +20,12 @@ capabilities in a limited fashion, mostly as a means to limit the access from\n external users (e.g., via syscall), rather than a mechanism to enforce advanced\n security policies internally (e.g., module-level isolation).\n \n-So we ask this question: is it possible to use capabilities as a _ubitiquous_ security primitive throughout Jinux to enhance the security and robustness of the\n+So we ask this question: is it possible to use capabilities as a _ubitiquous_ security primitive throughout Asterinas to enhance the security and robustness of the\n OS? Specifically, we propose a new principle called \"_everything is a capability_\".\n Here, \"everything\" refers to any type of OS resource, internal or external alike.\n In traditional OSes, treating everything as a capability is unrewarding \n because (1) capabilities themselves are unreliable due to memory safety problems\n-, and (2) capabilities are no free lunch as they incur memory and CPU overheads. But these arguments may no longer stand in a well-designed Rust OS like Jinux.\n+, and (2) capabilities are no free lunch as they incur memory and CPU overheads. But these arguments may no longer stand in a well-designed Rust OS like Asterinas.\n Because the odds of memory safety bugs are minimized and \n advanced Rust features like type-level programming allow us to implement\n capabilities as a zero-cost abstraction.\ndiff --git a/docs/src/capabilities/zero_cost_capabilities.md b/docs/src/capabilities/zero_cost_capabilities.md\nindex b07173c8cc..476b053a8a 100644\n--- a/docs/src/capabilities/zero_cost_capabilities.md\n+++ b/docs/src/capabilities/zero_cost_capabilities.md\n@@ -1,6 +1,6 @@\n # Zero-Cost Capabilities\n \n-To strengthen the security of Jinux, we aim to implement all kinds of OS resources\n+To strengthen the security of Asterinas, we aim to implement all kinds of OS resources\n as capabilities. As the capabilities are going to be used throughout the OS,\n it is highly desirable to minimize their costs. For this purpose,\n we want to implement capabilities as a _zero-cost abstraction_.\n@@ -351,7 +351,7 @@ mod test {\n \n ### Implement access rights with typeflags\n \n-The `Jinux-rights/lib.rs` file implements access rights.\n+The `aster-rights/lib.rs` file implements access rights.\n \n ```rust\n //! Access rights.\n@@ -376,7 +376,7 @@ typeflags! {\n }\n ```\n \n-The `Jinux-rights-proc/lib.rs` file implements the `require` procedural macro.\n+The `aster-rights-proc/lib.rs` file implements the `require` procedural macro.\n See the channel capability example later for how `require` is used.\n \n ```rust\ndiff --git a/docs/src/privilege_separation/README.md b/docs/src/privilege_separation/README.md\nindex fd341d04dc..06150ae840 100644\n--- a/docs/src/privilege_separation/README.md\n+++ b/docs/src/privilege_separation/README.md\n@@ -1,15 +1,15 @@\n # Privilege Separation\n \n-One fundamental design goal of Jinux is to support _privilege separation_, i.e., the separation between the privileged OS core and the unprivileged OS components. The privileged portion is allowed to use `unsafe` keyword to carry out dangerous tasks like accessing CPU registers, manipulating stack frames, and doing MMIO or PIO. In contrast, the unprivileged portion, which forms the majority of the OS, must be free from `unsafe` code. With privilege separation, the memory safety of Jinux can be boiled down to the correctness of the privileged OS core, regardless of the correctness of the unprivileged OS components, thus reducing the size of TCB  significantly.\n+One fundamental design goal of Asterinas is to support _privilege separation_, i.e., the separation between the privileged OS core and the unprivileged OS components. The privileged portion is allowed to use `unsafe` keyword to carry out dangerous tasks like accessing CPU registers, manipulating stack frames, and doing MMIO or PIO. In contrast, the unprivileged portion, which forms the majority of the OS, must be free from `unsafe` code. With privilege separation, the memory safety of Asterinas can be boiled down to the correctness of the privileged OS core, regardless of the correctness of the unprivileged OS components, thus reducing the size of TCB  significantly.\n \n To put privilege separation into perspective, let's compare the architectures\n-of the monolithic kernels, microkernels, and Jinux.\n+of the monolithic kernels, microkernels, and Asterinas.\n \n ![Arch comparison](../images/arch_comparison.png)\n \n The diagram above highlights the characteristics of different OS architectures \n in terms of communication overheads and the TCB for memory safety.\n-Thanks to privilege separation, Jinux promises the benefit of being _as safe as a microkernel and as fast as a monolithic kernel_.\n+Thanks to privilege separation, Asterinas promises the benefit of being _as safe as a microkernel and as fast as a monolithic kernel_.\n \n Privilege separation is an interesting research problem, prompting us to \n answer a series of technical questions.\ndiff --git a/docs/src/privilege_separation/pci_virtio_drivers.md b/docs/src/privilege_separation/pci_virtio_drivers.md\nindex b85e420922..d69aa19e8d 100644\n--- a/docs/src/privilege_separation/pci_virtio_drivers.md\n+++ b/docs/src/privilege_separation/pci_virtio_drivers.md\n@@ -22,7 +22,7 @@ Here are some of the elements in PCI-based Virtio devices that may involve `unsa\n ### Privileged part\n \n ```rust\n-// file: jinux-core-libs/pci-io-port/lib.rs\n+// file: aster-core-libs/pci-io-port/lib.rs\n use x86::IoPort;\n \n /// The I/O port to write an address in the PCI \n@@ -49,7 +49,7 @@ pub const PCI_DATA_PORT: IoPort<u32> = {\n ### Unprivileged part\n \n ```rust\n-// file: jinux-comps/pci/lib.rs\n+// file: aster-comps/pci/lib.rs\n use pci_io_port::{PCI_ADDR_PORT, PCI_DATA_PORT};\n \n /// The PCI configuration space, which enables the discovery,\n@@ -128,7 +128,7 @@ pub struct PciCapabilities {\n Most code of Virtio drivers can be unprivileged thanks to the abstractions of `VmPager` and `VmCell` provided by the OS core.\n \n ```rust\n-// file: jinux-comp-libs/virtio/transport.rs\n+// file: aster-comp-libs/virtio/transport.rs\n \n /// The transport layer for configuring a Virtio device.\n pub struct VirtioTransport {\ndiff --git a/docs/src/privilege_separation/syscall_workflow.md b/docs/src/privilege_separation/syscall_workflow.md\nindex 3873c81619..e3e856b9b3 100644\n--- a/docs/src/privilege_separation/syscall_workflow.md\n+++ b/docs/src/privilege_separation/syscall_workflow.md\n@@ -138,7 +138,7 @@ impl<T, P: Write> UserPtr<T, P> {\n }\n ```\n \n-The examples reveal two important considerations in designing Jinux:\n+The examples reveal two important considerations in designing Asterinas:\n 1. Exposing _truly_ safe APIs. The privileged OS core must expose _truly safe_ APIs: however buggy or silly the unprivileged OS components may be written, they must _not_ cause undefined behaviors.\n 2. Handling _arbitrary_ pointers safely. The safe API of the OS core must provide a safe way to deal with arbitrary pointers.\n \n@@ -146,15 +146,15 @@ With the two points in mind, let's get back to our main goal of privilege separa\n \n ## Code organization with privilege separation\n \n-Our first step is to separate privileged and unprivileged code in the codebase of Jinux. For our purpose of demonstrating a syscall handling framework, a minimal codebase may look like the following.\n+Our first step is to separate privileged and unprivileged code in the codebase of Asterinas. For our purpose of demonstrating a syscall handling framework, a minimal codebase may look like the following.\n \n ```text\n .\n-\u251c\u2500\u2500 jinux\n+\u251c\u2500\u2500 asterinas\n \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n \u2502   \u2502\u00a0\u00a0 \u2514\u2500\u2500 main.rs\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 Cargo.toml\n-\u251c\u2500\u2500 jinux-core\n+\u251c\u2500\u2500 aster-core\n \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 lib.rs\n \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 syscall_handler.rs\n@@ -162,7 +162,7 @@ Our first step is to separate privileged and unprivileged code in the codebase o\n \u2502   \u2502       \u251c\u2500\u2500 vmo.rs\n \u2502   \u2502       \u2514\u2500\u2500 vmar.rs\n \u2502\u00a0\u00a0 \u2514\u2500\u2500 Cargo.toml\n-\u251c\u2500\u2500 jinux-core-libs\n+\u251c\u2500\u2500 aster-core-libs\n \u2502   \u251c\u2500\u2500 linux-abi-types\n \u2502   \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n \u2502   \u2502\u00a0\u00a0 \u2502   \u2514\u2500\u2500 lib.rs\n@@ -171,34 +171,34 @@ Our first step is to separate privileged and unprivileged code in the codebase o\n \u2502       \u251c\u2500\u2500 src\n \u2502     \u00a0\u00a0\u2502   \u2514\u2500\u2500 lib.rs\n \u2502      \u00a0\u2514\u2500\u2500 Cargo.toml\n-\u251c\u2500\u2500 jinux-comps\n+\u251c\u2500\u2500 aster-comps\n \u2502 \u00a0 \u2514\u2500\u2500 linux-syscall\n \u2502       \u251c\u2500\u2500 src\n \u2502     \u00a0\u00a0\u2502   \u2514\u2500\u2500 lib.rs\n \u2502     \u00a0\u00a0\u2514\u2500\u2500 Cargo.toml\n-\u2514\u2500\u2500 jinux-comp-libs\n+\u2514\u2500\u2500 aster-comp-libs\n  \u00a0\u00a0 \u2514\u2500\u2500 linux-abi\n         \u251c\u2500\u2500 src\n       \u00a0\u00a0\u2502   \u2514\u2500\u2500 lib.rs\n      \u00a0\u00a0 \u2514\u2500\u2500 Cargo.toml \n ```\n \n-The ultimate build target of the codebase is the `jinux` crate, which is an OS kernel that consists of a privileged OS core (crate `jinux-core`) and multiple OS components (the crates under `jinux-comps/`).\n+The ultimate build target of the codebase is the `asterinas` crate, which is an OS kernel that consists of a privileged OS core (crate `aster-core`) and multiple OS components (the crates under `aster-comps/`).\n \n-For the sake of privilege separation, only crate `jinux` and `jinux-core` along with the crates under `jinux-core-libs` are allowed to use the `unsafe` keyword. To the contrary, the crates under `jinux-comps/` along with their dependent crates under `jinux-comp-libs/` are not allowed to use `unsafe` directly; they may only borrow the superpower of `unsafe` by using the safe API exposed by `jinux-core` or the crates under `jinux-core-libs`. To summarize, the memory safety of the OS only relies on a small and well-defined TCB that constitutes the `jinux` and `jinux-core` crate plus the crates under `jinux-core-libs/`.\n+For the sake of privilege separation, only crate `asterinas` and `aster-core` along with the crates under `aster-core-libs` are allowed to use the `unsafe` keyword. To the contrary, the crates under `aster-comps/` along with their dependent crates under `aster-comp-libs/` are not allowed to use `unsafe` directly; they may only borrow the superpower of `unsafe` by using the safe API exposed by `aster-core` or the crates under `aster-core-libs`. To summarize, the memory safety of the OS only relies on a small and well-defined TCB that constitutes the `asterinas` and `aster-core` crate plus the crates under `aster-core-libs/`.\n \n-Under this setting, all implementation of system calls goes to the `linux-syscall` crate. We are about to show that the _safe_ API provided by `jinux-core` is powerful enough to enable the _safe_ implementation of `linux-syscall`.\n+Under this setting, all implementation of system calls goes to the `linux-syscall` crate. We are about to show that the _safe_ API provided by `aster-core` is powerful enough to enable the _safe_ implementation of `linux-syscall`.\n \n-## Crate `jinux-core`\n+## Crate `aster-core`\n \n-For our purposes here, the two most relevant APIs provided by `jinux-core` is the abstraction for syscall handlers and virtual memory (VM).\n+For our purposes here, the two most relevant APIs provided by `aster-core` is the abstraction for syscall handlers and virtual memory (VM).\n \n ### Syscall handlers\n \n The `SyscallHandler` abstraction enables the OS core to hide the low-level, architectural-dependent aspects of syscall handling workflow (e.g., user-kernel switching and CPU register manipulation) and allow the unprivileged OS components to implement system calls.\n \n ```rust\n-// file: jinux-core/src/syscall_handler.rs\n+// file: aster-core/src/syscall_handler.rs\n \n pub trait SyscallHandler {\n     fn handle_syscall(&self, ctx: &mut SyscallContext);\n@@ -243,8 +243,8 @@ an important concept that we will elaborate on later. Basically, they are capabi\n Here we demonstrate how to leverage the APIs of `ksos-core` to implement system calls with safe Rust code in crate `linux-syscall`.\n \n ```rust\n-// file: jinux-comps/linux-syscall/src/lib.rs\n-use jinux_core::{SyscallContext, SyscallHandler, Vmar};\n+// file: aster-comps/linux-syscall/src/lib.rs\n+use aster_core::{SyscallContext, SyscallHandler, Vmar};\n use linux_abi::{SyscallNum::*, UserPtr, RawFd, RawTimeVal, RawTimeZone};\n \n pub struct SampleHandler;\n@@ -315,7 +315,7 @@ impl SampleHandler {\n This crate defines a marker trait `Pod`, which represents plain-old data.\n \n ```rust\n-/// file: jinux-core-libs/pod/src/lib.rs\n+/// file: aster-core-libs/pod/src/lib.rs\n \n /// A marker trait for plain old data (POD).\n ///\n@@ -388,7 +388,7 @@ unsafe impl<T: Pod, const N> [T; N] for Pod {}\n ## Crate `linux-abi-type`\n \n ```rust\n-// file: jinux-core-libs/linux-abi-types\n+// file: aster-core-libs/linux-abi-types\n use pod::Pod;\n \n pub type RawFd = i32;\n@@ -404,7 +404,7 @@ unsafe impl Pod for RawTimeVal {}\n ## Crate `linux-abi`\n \n ```rust\n-// file: jinux-comp-libs/linux-abi\n+// file: aster-comp-libs/linux-abi\n pub use linux_abi_types::*;\n \n pub enum SyscallNum {\ndiff --git a/framework/README.md b/framework/README.md\nindex 31ee67d5e4..604a9ee7e1 100644\n--- a/framework/README.md\n+++ b/framework/README.md\n@@ -1,20 +1,20 @@\n-# Jinux Framework\n+# Asterinas Framework\n \n-Jinux Framework is a Rust OS framework that facilitates the development of and innovation in OS kernels written in Rust.\n+Asterinas Framework is a Rust OS framework that facilitates the development of and innovation in OS kernels written in Rust.\n \n ## An overview\n \n-Jinux Framework provides a solid foundation for Rust developers to build their own OS kernels. While Jinux Framework origins from Jinux, the first ever framekernel, Jinux Framework is well suited for building OS kernels of any architecture, be it a framekernel, a monolithic kernel, or a microkernel.\n+Asterinas Framework provides a solid foundation for Rust developers to build their own OS kernels. While Asterinas Framework origins from Asterinas, the first ever framekernel, Asterinas Framework is well suited for building OS kernels of any architecture, be it a framekernel, a monolithic kernel, or a microkernel.\n \n-Jinux Framework offers the following key values.\n+Asterinas Framework offers the following key values.\n \n-1. **Lowering the entry bar for OS innovation.** Building an OS from scratch is not easy. Not to mention a novel one. Before adding any novel or interesting feature, an OS developer must first have something runnable, which must include basic functionalities for managing CPU, memory, and interrupts. Jinux Framework has laid this groundwork so that OS developers do not have to deal with the most low-level, error-prone, architecture-specific aspects of OS development themselves.\n+1. **Lowering the entry bar for OS innovation.** Building an OS from scratch is not easy. Not to mention a novel one. Before adding any novel or interesting feature, an OS developer must first have something runnable, which must include basic functionalities for managing CPU, memory, and interrupts. Asterinas Framework has laid this groundwork so that OS developers do not have to deal with the most low-level, error-prone, architecture-specific aspects of OS development themselves.\n \n-2. **Enhancing the memory safety of Rust OSes.** Jinux Framework encapsulates low-level, machine-oriented unsafe Rust code into high-level, machine-agnostic safe APIs. These APIs are carefully designed and implemented to be sound and minimal, ensuring the memory safety of any safe Rust callers. Our experience in building Jinux has shown that Jinux Framework is powerful enough to allow a feature-rich, Linux-compatible kernel to be completely written in safe Rust, including its device drivers.\n+2. **Enhancing the memory safety of Rust OSes.** Asterinas Framework encapsulates low-level, machine-oriented unsafe Rust code into high-level, machine-agnostic safe APIs. These APIs are carefully designed and implemented to be sound and minimal, ensuring the memory safety of any safe Rust callers. Our experience in building Asterinas has shown that Asterinas Framework is powerful enough to allow a feature-rich, Linux-compatible kernel to be completely written in safe Rust, including its device drivers.\n \n-3. **Promoting code reuse across Rust OS projects.** Shipped as crates, Rust code can be reused across projects---except when they are OSes. A crate that implements a feature or driver for OS A can hardly be reused by OS B because the crate must be [`no_std`](https://docs.rust-embedded.org/book/intro/no-std.html#summary) and depend on the infrastructure APIs provided by OS A, which are obviously different from that provided by OS B. This incompatibility problem can be resolved by Jinux Framework as it can serve as a common ground across different Rust OS projects, as long as they are built upon Jinux Framework.\n+3. **Promoting code reuse across Rust OS projects.** Shipped as crates, Rust code can be reused across projects---except when they are OSes. A crate that implements a feature or driver for OS A can hardly be reused by OS B because the crate must be [`no_std`](https://docs.rust-embedded.org/book/intro/no-std.html#summary) and depend on the infrastructure APIs provided by OS A, which are obviously different from that provided by OS B. This incompatibility problem can be resolved by Asterinas Framework as it can serve as a common ground across different Rust OS projects, as long as they are built upon Asterinas Framework.\n \n-4. **Boost productivity with user-mode development.** Traditionally, developing a kernel feature involves countless rounds of coding, failing, and rebooting on bare-metal or virtual machines, which is a painfully slow process. Jinux Framework accelerates the process by allowing high-level OS features like file systems and network stacks to be quickly tested in user mode, making the experience of OS development as smooth as that of application development. To support user-mode development, Jinux Framework is implemented for the Linux platform, in addition to bare-mental or virtual machine environments.\n+4. **Boost productivity with user-mode development.** Traditionally, developing a kernel feature involves countless rounds of coding, failing, and rebooting on bare-metal or virtual machines, which is a painfully slow process. Asterinas Framework accelerates the process by allowing high-level OS features like file systems and network stacks to be quickly tested in user mode, making the experience of OS development as smooth as that of application development. To support user-mode development, Asterinas Framework is implemented for the Linux platform, in addition to bare-mental or virtual machine environments.\n \n ## Framework APIs\n \ndiff --git a/framework/jinux-frame/Cargo.toml b/framework/aster-frame/Cargo.toml\nsimilarity index 79%\nrename from framework/jinux-frame/Cargo.toml\nrename to framework/aster-frame/Cargo.toml\nindex ad99cea1b3..827dfcef25 100644\n--- a/framework/jinux-frame/Cargo.toml\n+++ b/framework/aster-frame/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-frame\"\n+name = \"aster-frame\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n@@ -13,17 +13,17 @@ bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n buddy_system_allocator = \"0.9.0\"\n cfg-if = \"1.0\"\n gimli = { version = \"0.28\", default-features = false, features = [\"read-core\"] }\n-inherit-methods-macro = { git = \"https://github.com/jinzhao-dev/inherit-methods-macro\", rev = \"98f7e3e\" }\n+inherit-methods-macro = { git = \"https://github.com/asterinas/inherit-methods-macro\", rev = \"98f7e3e\" }\n int-to-c-enum = { path = \"../../services/libs/int-to-c-enum\" }\n intrusive-collections = \"0.9.5\"\n ktest = { path = \"../libs/ktest\" }\n lazy_static = { version = \"1.0\", features = [\"spin_no_std\"] }\n log = \"0.4\"\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n spin = \"0.9.4\"\n static_assertions = \"1.1.0\"\n tdx-guest = { path = \"../libs/tdx-guest\", optional = true }\n-trapframe = { git = \"https://github.com/jinzhao-dev/trapframe-rs\", rev = \"9758a83\" }\n+trapframe = { git = \"https://github.com/asterinas/trapframe-rs\", rev = \"2f37590\" }\n unwinding = { version = \"0.2.1\", default-features = false, features = [\"fde-static\", \"hide-trace\", \"panic\", \"personality\", \"unwinder\"] }\n volatile = { version = \"0.4.5\", features = [\"unstable\"] }\n \ndiff --git a/framework/jinux-frame/build.rs b/framework/aster-frame/build.rs\nsimilarity index 96%\nrename from framework/jinux-frame/build.rs\nrename to framework/aster-frame/build.rs\nindex c8d65f3dc7..6bd57bc3bc 100644\n--- a/framework/jinux-frame/build.rs\n+++ b/framework/aster-frame/build.rs\n@@ -32,7 +32,7 @@ fn build_linux_setup_header(\n \n     let cargo = std::env::var(\"CARGO\").unwrap();\n     let mut cmd = std::process::Command::new(cargo);\n-    cmd.arg(\"install\").arg(\"jinux-frame-x86-boot-linux-setup\");\n+    cmd.arg(\"install\").arg(\"aster-frame-x86-boot-linux-setup\");\n     cmd.arg(\"--debug\");\n     cmd.arg(\"--locked\");\n     cmd.arg(\"--path\").arg(setup_crate_dir.to_str().unwrap());\ndiff --git a/framework/jinux-frame/src/arch/mod.rs b/framework/aster-frame/src/arch/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/mod.rs\nrename to framework/aster-frame/src/arch/mod.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/boot.S b/framework/aster-frame/src/arch/x86/boot/boot.S\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/boot/boot.S\nrename to framework/aster-frame/src/arch/x86/boot/boot.S\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/boot_params.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/boot_params.rs\nsimilarity index 99%\nrename from framework/jinux-frame/src/arch/x86/boot/linux_boot/boot_params.rs\nrename to framework/aster-frame/src/arch/x86/boot/linux_boot/boot_params.rs\nindex 5150a19afc..b4a07971c8 100644\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/boot_params.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/boot_params.rs\n@@ -3,7 +3,7 @@\n //! The bootloader will deliver the address of the `BootParams` struct\n //! as the argument of the kernel entrypoint. So we must define a Linux\n //! ABI compatible struct in Rust, despite that most of the fields are\n-//! currently not needed by Jinux.\n+//! currently not needed by Asterinas.\n //!\n \n #[derive(Copy, Clone, Debug)]\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\nsimilarity index 99%\nrename from framework/jinux-frame/src/arch/x86/boot/linux_boot/mod.rs\nrename to framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\nindex fb932305d9..1967faa996 100644\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/mod.rs\n@@ -152,5 +152,5 @@ unsafe extern \"sysv64\" fn __linux64_boot(params_ptr: *const boot_params::BootPar\n         init_framebuffer_info,\n         init_memory_regions,\n     );\n-    crate::boot::call_jinux_main();\n+    crate::boot::call_aster_main();\n }\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml\nsimilarity index 82%\nrename from framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml\nrename to framework/aster-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml\nindex 019b0c64cc..41ba76b240 100644\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-frame-x86-boot-linux-setup\"\n+name = \"aster-frame-x86-boot-linux-setup\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/build.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/build.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/build.rs\nrename to framework/aster-frame/src/arch/x86/boot/linux_boot/setup/build.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/linker.ld b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/linker.ld\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/linker.ld\nrename to framework/aster-frame/src/arch/x86/boot/linux_boot/setup/linker.ld\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/boot_params.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/boot_params.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/boot_params.rs\nrename to framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/boot_params.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/console.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/console.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/console.rs\nrename to framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/console.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/header.S b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/header.S\nsimilarity index 95%\nrename from framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/header.S\nrename to framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/header.S\nindex ab47ecbcb2..563a15e508 100644\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/header.S\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/header.S\n@@ -9,8 +9,8 @@\n // Some of the fields filled with a 0xab* values should be filled\n // by the runner, which is the only tool after building and can\n // access the info of the payload.\n-// Jinux will use only a few of these fields, and some of them\n-// are filled by the loader and will be read by Jinux.\n+// Asterinas will use only a few of these fields, and some of them\n+// are filled by the loader and will be read by Asterinas.\n \n CODE32_START = 0x100000\n \ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs\nsimilarity index 98%\nrename from framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs\nrename to framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs\nindex d22eec0986..2f515c2025 100644\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/loader.rs\n@@ -24,6 +24,6 @@ pub fn load_elf(file: &[u8]) -> u32 {\n         }\n     }\n \n-    // Return the Linux 32-bit Boot Protocol entry point defined by Jinux.\n+    // Return the Linux 32-bit Boot Protocol entry point defined by Asterinas.\n     0x8001000\n }\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\nsimilarity index 90%\nrename from framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\nrename to framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\nindex 22b98a187d..aa621aa655 100644\n--- a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/main.rs\n@@ -9,7 +9,7 @@ use core::arch::{asm, global_asm};\n \n global_asm!(include_str!(\"header.S\"));\n \n-unsafe fn call_jinux_entrypoint(entrypoint: u32, boot_params_ptr: u32) -> ! {\n+unsafe fn call_aster_entrypoint(entrypoint: u32, boot_params_ptr: u32) -> ! {\n     asm!(\"mov esi, {}\", in(reg) boot_params_ptr);\n     asm!(\"mov eax, {}\", in(reg) entrypoint);\n     asm!(\"jmp eax\");\n@@ -34,7 +34,7 @@ pub extern \"cdecl\" fn _rust_setup_entry(boot_params_ptr: u32) -> ! {\n     println!(\"[setup] entrypoint: {:#x}\", entrypoint);\n \n     // Safety: the entrypoint and the ptr is valid.\n-    unsafe { call_jinux_entrypoint(entrypoint, boot_params_ptr) };\n+    unsafe { call_aster_entrypoint(entrypoint, boot_params_ptr) };\n }\n \n #[panic_handler]\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/x86_64-i386_protected_mode.json b/framework/aster-frame/src/arch/x86/boot/linux_boot/setup/x86_64-i386_protected_mode.json\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/x86_64-i386_protected_mode.json\nrename to framework/aster-frame/src/arch/x86/boot/linux_boot/setup/x86_64-i386_protected_mode.json\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/mod.rs b/framework/aster-frame/src/arch/x86/boot/mod.rs\nsimilarity index 81%\nrename from framework/jinux-frame/src/arch/x86/boot/mod.rs\nrename to framework/aster-frame/src/arch/x86/boot/mod.rs\nindex 584e07d5fd..ee4347c673 100644\n--- a/framework/jinux-frame/src/arch/x86/boot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/mod.rs\n@@ -1,4 +1,4 @@\n-//! The x86 boot module defines the entrypoints of Jinux and\n+//! The x86 boot module defines the entrypoints of Asterinas and\n //! the corresponding headers for different x86 boot protocols.\n //!\n //! We directly support\n@@ -9,7 +9,7 @@\n //!\n //! without any additional configurations.\n //!\n-//! Jinux diffrentiates the boot protocol by the entry point\n+//! Asterinas diffrentiates the boot protocol by the entry point\n //! chosen by the boot loader. In each entry point function,\n //! the universal callback registeration method from\n //! `crate::boot` will be called. Thus the initialization of\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/multiboot/header.S b/framework/aster-frame/src/arch/x86/boot/multiboot/header.S\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/boot/multiboot/header.S\nrename to framework/aster-frame/src/arch/x86/boot/multiboot/header.S\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/multiboot/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\nsimilarity index 99%\nrename from framework/jinux-frame/src/arch/x86/boot/multiboot/mod.rs\nrename to framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\nindex 45a1582b45..3a27a515fb 100644\n--- a/framework/jinux-frame/src/arch/x86/boot/multiboot/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot/mod.rs\n@@ -339,5 +339,5 @@ unsafe extern \"sysv64\" fn __multiboot_entry(boot_magic: u32, boot_params: u64) -\n         init_framebuffer_info,\n         init_memory_regions,\n     );\n-    crate::boot::call_jinux_main();\n+    crate::boot::call_aster_main();\n }\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/multiboot2/header.S b/framework/aster-frame/src/arch/x86/boot/multiboot2/header.S\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/boot/multiboot2/header.S\nrename to framework/aster-frame/src/arch/x86/boot/multiboot2/header.S\ndiff --git a/framework/jinux-frame/src/arch/x86/boot/multiboot2/mod.rs b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\nsimilarity index 99%\nrename from framework/jinux-frame/src/arch/x86/boot/multiboot2/mod.rs\nrename to framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\nindex dda8fa31e3..ff8f9b191f 100644\n--- a/framework/jinux-frame/src/arch/x86/boot/multiboot2/mod.rs\n+++ b/framework/aster-frame/src/arch/x86/boot/multiboot2/mod.rs\n@@ -172,5 +172,5 @@ unsafe extern \"sysv64\" fn __multiboot2_entry(boot_magic: u32, boot_params: u64)\n         init_framebuffer_info,\n         init_memory_regions,\n     );\n-    crate::boot::call_jinux_main();\n+    crate::boot::call_aster_main();\n }\ndiff --git a/framework/jinux-frame/src/arch/x86/console.rs b/framework/aster-frame/src/arch/x86/console.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/console.rs\nrename to framework/aster-frame/src/arch/x86/console.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/cpu.rs b/framework/aster-frame/src/arch/x86/cpu.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/cpu.rs\nrename to framework/aster-frame/src/arch/x86/cpu.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/device/cmos.rs b/framework/aster-frame/src/arch/x86/device/cmos.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/device/cmos.rs\nrename to framework/aster-frame/src/arch/x86/device/cmos.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/device/io_port.rs b/framework/aster-frame/src/arch/x86/device/io_port.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/device/io_port.rs\nrename to framework/aster-frame/src/arch/x86/device/io_port.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/device/mod.rs b/framework/aster-frame/src/arch/x86/device/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/device/mod.rs\nrename to framework/aster-frame/src/arch/x86/device/mod.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/device/serial.rs b/framework/aster-frame/src/arch/x86/device/serial.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/device/serial.rs\nrename to framework/aster-frame/src/arch/x86/device/serial.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/iommu/context_table.rs b/framework/aster-frame/src/arch/x86/iommu/context_table.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/iommu/context_table.rs\nrename to framework/aster-frame/src/arch/x86/iommu/context_table.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/iommu/fault.rs b/framework/aster-frame/src/arch/x86/iommu/fault.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/iommu/fault.rs\nrename to framework/aster-frame/src/arch/x86/iommu/fault.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/iommu/mod.rs b/framework/aster-frame/src/arch/x86/iommu/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/iommu/mod.rs\nrename to framework/aster-frame/src/arch/x86/iommu/mod.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/iommu/remapping.rs b/framework/aster-frame/src/arch/x86/iommu/remapping.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/iommu/remapping.rs\nrename to framework/aster-frame/src/arch/x86/iommu/remapping.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/iommu/second_stage.rs b/framework/aster-frame/src/arch/x86/iommu/second_stage.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/iommu/second_stage.rs\nrename to framework/aster-frame/src/arch/x86/iommu/second_stage.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/irq.rs b/framework/aster-frame/src/arch/x86/irq.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/irq.rs\nrename to framework/aster-frame/src/arch/x86/irq.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/kernel/acpi/dmar.rs b/framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/kernel/acpi/dmar.rs\nrename to framework/aster-frame/src/arch/x86/kernel/acpi/dmar.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/kernel/acpi/mod.rs b/framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/kernel/acpi/mod.rs\nrename to framework/aster-frame/src/arch/x86/kernel/acpi/mod.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/kernel/acpi/remapping.rs b/framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/kernel/acpi/remapping.rs\nrename to framework/aster-frame/src/arch/x86/kernel/acpi/remapping.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/kernel/apic/ioapic.rs b/framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/kernel/apic/ioapic.rs\nrename to framework/aster-frame/src/arch/x86/kernel/apic/ioapic.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/kernel/apic/mod.rs b/framework/aster-frame/src/arch/x86/kernel/apic/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/kernel/apic/mod.rs\nrename to framework/aster-frame/src/arch/x86/kernel/apic/mod.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/kernel/apic/x2apic.rs b/framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/kernel/apic/x2apic.rs\nrename to framework/aster-frame/src/arch/x86/kernel/apic/x2apic.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/kernel/apic/xapic.rs b/framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/kernel/apic/xapic.rs\nrename to framework/aster-frame/src/arch/x86/kernel/apic/xapic.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/kernel/mod.rs b/framework/aster-frame/src/arch/x86/kernel/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/kernel/mod.rs\nrename to framework/aster-frame/src/arch/x86/kernel/mod.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/kernel/pic.rs b/framework/aster-frame/src/arch/x86/kernel/pic.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/kernel/pic.rs\nrename to framework/aster-frame/src/arch/x86/kernel/pic.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/kernel/tsc.rs b/framework/aster-frame/src/arch/x86/kernel/tsc.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/kernel/tsc.rs\nrename to framework/aster-frame/src/arch/x86/kernel/tsc.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/linker.ld b/framework/aster-frame/src/arch/x86/linker.ld\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/linker.ld\nrename to framework/aster-frame/src/arch/x86/linker.ld\ndiff --git a/framework/jinux-frame/src/arch/x86/mm/mod.rs b/framework/aster-frame/src/arch/x86/mm/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/mm/mod.rs\nrename to framework/aster-frame/src/arch/x86/mm/mod.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/mod.rs b/framework/aster-frame/src/arch/x86/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/mod.rs\nrename to framework/aster-frame/src/arch/x86/mod.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/pci.rs b/framework/aster-frame/src/arch/x86/pci.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/pci.rs\nrename to framework/aster-frame/src/arch/x86/pci.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/qemu.rs b/framework/aster-frame/src/arch/x86/qemu.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/qemu.rs\nrename to framework/aster-frame/src/arch/x86/qemu.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/tdx_guest.rs b/framework/aster-frame/src/arch/x86/tdx_guest.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/tdx_guest.rs\nrename to framework/aster-frame/src/arch/x86/tdx_guest.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/timer/apic.rs b/framework/aster-frame/src/arch/x86/timer/apic.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/timer/apic.rs\nrename to framework/aster-frame/src/arch/x86/timer/apic.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/timer/hpet.rs b/framework/aster-frame/src/arch/x86/timer/hpet.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/timer/hpet.rs\nrename to framework/aster-frame/src/arch/x86/timer/hpet.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/timer/mod.rs b/framework/aster-frame/src/arch/x86/timer/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/timer/mod.rs\nrename to framework/aster-frame/src/arch/x86/timer/mod.rs\ndiff --git a/framework/jinux-frame/src/arch/x86/timer/pit.rs b/framework/aster-frame/src/arch/x86/timer/pit.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/arch/x86/timer/pit.rs\nrename to framework/aster-frame/src/arch/x86/timer/pit.rs\ndiff --git a/framework/jinux-frame/src/boot/kcmdline.rs b/framework/aster-frame/src/boot/kcmdline.rs\nsimilarity index 99%\nrename from framework/jinux-frame/src/boot/kcmdline.rs\nrename to framework/aster-frame/src/boot/kcmdline.rs\nindex c81d05b191..f68dff1b09 100644\n--- a/framework/jinux-frame/src/boot/kcmdline.rs\n+++ b/framework/aster-frame/src/boot/kcmdline.rs\n@@ -1,6 +1,6 @@\n //! The module to parse kernel command-line arguments.\n //!\n-//! The format of the Jinux command line string conforms\n+//! The format of the Asterinas command line string conforms\n //! to the Linux kernel command line rules:\n //!\n //! https://www.kernel.org/doc/html/v6.4/admin-guide/kernel-parameters.html\ndiff --git a/framework/jinux-frame/src/boot/memory_region.rs b/framework/aster-frame/src/boot/memory_region.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/boot/memory_region.rs\nrename to framework/aster-frame/src/boot/memory_region.rs\ndiff --git a/framework/jinux-frame/src/boot/mod.rs b/framework/aster-frame/src/boot/mod.rs\nsimilarity index 95%\nrename from framework/jinux-frame/src/boot/mod.rs\nrename to framework/aster-frame/src/boot/mod.rs\nindex b0a0ab4e74..6afdc118ab 100644\n--- a/framework/jinux-frame/src/boot/mod.rs\n+++ b/framework/aster-frame/src/boot/mod.rs\n@@ -60,7 +60,7 @@ macro_rules! define_global_static_boot_arguments {\n         ///\n         /// For the introduction of a new boot protocol, the entry point could be a novel\n         /// one. The entry point function should register all the boot initialization\n-        /// methods before `jinux_main` is called. A boot initialization method takes a\n+        /// methods before `aster_main` is called. A boot initialization method takes a\n         /// reference of the global static boot information variable and initialize it,\n         /// so that the boot information it represents could be accessed in the kernel\n         /// anywhere.\n@@ -103,17 +103,17 @@ pub fn init() {\n \n /// Call the framework-user defined entrypoint of the actual kernel.\n ///\n-/// Any kernel that uses the jinux-frame crate should define a function named\n-/// `jinux_main` as the entrypoint.\n-pub fn call_jinux_main() -> ! {\n+/// Any kernel that uses the aster-frame crate should define a function named\n+/// `aster_main` as the entrypoint.\n+pub fn call_aster_main() -> ! {\n     #[cfg(not(ktest))]\n     unsafe {\n         // The entry point of kernel code, which should be defined by the package that\n-        // uses jinux-frame.\n+        // uses aster-frame.\n         extern \"Rust\" {\n-            fn jinux_main() -> !;\n+            fn aster_main() -> !;\n         }\n-        jinux_main();\n+        aster_main();\n     }\n     #[cfg(ktest)]\n     {\ndiff --git a/framework/jinux-frame/src/bus/mmio/bus.rs b/framework/aster-frame/src/bus/mmio/bus.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/bus/mmio/bus.rs\nrename to framework/aster-frame/src/bus/mmio/bus.rs\ndiff --git a/framework/jinux-frame/src/bus/mmio/device.rs b/framework/aster-frame/src/bus/mmio/device.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/bus/mmio/device.rs\nrename to framework/aster-frame/src/bus/mmio/device.rs\ndiff --git a/framework/jinux-frame/src/bus/mmio/mod.rs b/framework/aster-frame/src/bus/mmio/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/bus/mmio/mod.rs\nrename to framework/aster-frame/src/bus/mmio/mod.rs\ndiff --git a/framework/jinux-frame/src/bus/mod.rs b/framework/aster-frame/src/bus/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/bus/mod.rs\nrename to framework/aster-frame/src/bus/mod.rs\ndiff --git a/framework/jinux-frame/src/bus/pci/bus.rs b/framework/aster-frame/src/bus/pci/bus.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/bus/pci/bus.rs\nrename to framework/aster-frame/src/bus/pci/bus.rs\ndiff --git a/framework/jinux-frame/src/bus/pci/capability/mod.rs b/framework/aster-frame/src/bus/pci/capability/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/bus/pci/capability/mod.rs\nrename to framework/aster-frame/src/bus/pci/capability/mod.rs\ndiff --git a/framework/jinux-frame/src/bus/pci/capability/msix.rs b/framework/aster-frame/src/bus/pci/capability/msix.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/bus/pci/capability/msix.rs\nrename to framework/aster-frame/src/bus/pci/capability/msix.rs\ndiff --git a/framework/jinux-frame/src/bus/pci/capability/vendor.rs b/framework/aster-frame/src/bus/pci/capability/vendor.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/bus/pci/capability/vendor.rs\nrename to framework/aster-frame/src/bus/pci/capability/vendor.rs\ndiff --git a/framework/jinux-frame/src/bus/pci/cfg_space.rs b/framework/aster-frame/src/bus/pci/cfg_space.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/bus/pci/cfg_space.rs\nrename to framework/aster-frame/src/bus/pci/cfg_space.rs\ndiff --git a/framework/jinux-frame/src/bus/pci/common_device.rs b/framework/aster-frame/src/bus/pci/common_device.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/bus/pci/common_device.rs\nrename to framework/aster-frame/src/bus/pci/common_device.rs\ndiff --git a/framework/jinux-frame/src/bus/pci/device_info.rs b/framework/aster-frame/src/bus/pci/device_info.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/bus/pci/device_info.rs\nrename to framework/aster-frame/src/bus/pci/device_info.rs\ndiff --git a/framework/jinux-frame/src/bus/pci/mod.rs b/framework/aster-frame/src/bus/pci/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/bus/pci/mod.rs\nrename to framework/aster-frame/src/bus/pci/mod.rs\ndiff --git a/framework/jinux-frame/src/config.rs b/framework/aster-frame/src/config.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/config.rs\nrename to framework/aster-frame/src/config.rs\ndiff --git a/framework/jinux-frame/src/console.rs b/framework/aster-frame/src/console.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/console.rs\nrename to framework/aster-frame/src/console.rs\ndiff --git a/framework/jinux-frame/src/cpu.rs b/framework/aster-frame/src/cpu.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/cpu.rs\nrename to framework/aster-frame/src/cpu.rs\ndiff --git a/framework/jinux-frame/src/error.rs b/framework/aster-frame/src/error.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/error.rs\nrename to framework/aster-frame/src/error.rs\ndiff --git a/framework/jinux-frame/src/io_mem.rs b/framework/aster-frame/src/io_mem.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/io_mem.rs\nrename to framework/aster-frame/src/io_mem.rs\ndiff --git a/framework/jinux-frame/src/lib.rs b/framework/aster-frame/src/lib.rs\nsimilarity index 98%\nrename from framework/jinux-frame/src/lib.rs\nrename to framework/aster-frame/src/lib.rs\nindex 0c6854125e..c20f38bdea 100644\n--- a/framework/jinux-frame/src/lib.rs\n+++ b/framework/aster-frame/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The framework part of Jinux.\n+//! The framework part of Asterinas.\n #![feature(alloc_error_handler)]\n #![feature(const_maybe_uninit_zeroed)]\n #![feature(const_mut_refs)]\ndiff --git a/framework/jinux-frame/src/logger.rs b/framework/aster-frame/src/logger.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/logger.rs\nrename to framework/aster-frame/src/logger.rs\ndiff --git a/framework/jinux-frame/src/panicking.rs b/framework/aster-frame/src/panicking.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/panicking.rs\nrename to framework/aster-frame/src/panicking.rs\ndiff --git a/framework/jinux-frame/src/prelude.rs b/framework/aster-frame/src/prelude.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/prelude.rs\nrename to framework/aster-frame/src/prelude.rs\ndiff --git a/framework/jinux-frame/src/sync/atomic_bits.rs b/framework/aster-frame/src/sync/atomic_bits.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/sync/atomic_bits.rs\nrename to framework/aster-frame/src/sync/atomic_bits.rs\ndiff --git a/framework/jinux-frame/src/sync/mod.rs b/framework/aster-frame/src/sync/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/sync/mod.rs\nrename to framework/aster-frame/src/sync/mod.rs\ndiff --git a/framework/jinux-frame/src/sync/mutex.rs b/framework/aster-frame/src/sync/mutex.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/sync/mutex.rs\nrename to framework/aster-frame/src/sync/mutex.rs\ndiff --git a/framework/jinux-frame/src/sync/rcu/mod.rs b/framework/aster-frame/src/sync/rcu/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/sync/rcu/mod.rs\nrename to framework/aster-frame/src/sync/rcu/mod.rs\ndiff --git a/framework/jinux-frame/src/sync/rcu/monitor.rs b/framework/aster-frame/src/sync/rcu/monitor.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/sync/rcu/monitor.rs\nrename to framework/aster-frame/src/sync/rcu/monitor.rs\ndiff --git a/framework/jinux-frame/src/sync/rcu/owner_ptr.rs b/framework/aster-frame/src/sync/rcu/owner_ptr.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/sync/rcu/owner_ptr.rs\nrename to framework/aster-frame/src/sync/rcu/owner_ptr.rs\ndiff --git a/framework/jinux-frame/src/sync/rwlock.rs b/framework/aster-frame/src/sync/rwlock.rs\nsimilarity index 99%\nrename from framework/jinux-frame/src/sync/rwlock.rs\nrename to framework/aster-frame/src/sync/rwlock.rs\nindex ce4ce64dfb..7e8cbe46ba 100644\n--- a/framework/jinux-frame/src/sync/rwlock.rs\n+++ b/framework/aster-frame/src/sync/rwlock.rs\n@@ -57,7 +57,7 @@ use crate::trap::DisabledLocalIrqGuard;\n /// # Examples\n ///\n /// ```\n-/// use jinux_frame::sync::RwLock;\n+/// use aster_frame::sync::RwLock;\n ///\n /// let lock = RwLock::new(5)\n ///\ndiff --git a/framework/jinux-frame/src/sync/rwmutex.rs b/framework/aster-frame/src/sync/rwmutex.rs\nsimilarity index 99%\nrename from framework/jinux-frame/src/sync/rwmutex.rs\nrename to framework/aster-frame/src/sync/rwmutex.rs\nindex 573e5e7911..46078ac42f 100644\n--- a/framework/jinux-frame/src/sync/rwmutex.rs\n+++ b/framework/aster-frame/src/sync/rwmutex.rs\n@@ -46,7 +46,7 @@ use super::WaitQueue;\n /// # Examples\n ///\n /// ```\n-/// use jinux_frame::sync::RwMutex;\n+/// use aster_frame::sync::RwMutex;\n ///\n /// let mutex = RwMutex::new(5)\n ///\ndiff --git a/framework/jinux-frame/src/sync/spin.rs b/framework/aster-frame/src/sync/spin.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/sync/spin.rs\nrename to framework/aster-frame/src/sync/spin.rs\ndiff --git a/framework/jinux-frame/src/sync/wait.rs b/framework/aster-frame/src/sync/wait.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/sync/wait.rs\nrename to framework/aster-frame/src/sync/wait.rs\ndiff --git a/framework/jinux-frame/src/task/mod.rs b/framework/aster-frame/src/task/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/task/mod.rs\nrename to framework/aster-frame/src/task/mod.rs\ndiff --git a/framework/jinux-frame/src/task/priority.rs b/framework/aster-frame/src/task/priority.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/task/priority.rs\nrename to framework/aster-frame/src/task/priority.rs\ndiff --git a/framework/jinux-frame/src/task/processor.rs b/framework/aster-frame/src/task/processor.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/task/processor.rs\nrename to framework/aster-frame/src/task/processor.rs\ndiff --git a/framework/jinux-frame/src/task/scheduler.rs b/framework/aster-frame/src/task/scheduler.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/task/scheduler.rs\nrename to framework/aster-frame/src/task/scheduler.rs\ndiff --git a/framework/jinux-frame/src/task/switch.S b/framework/aster-frame/src/task/switch.S\nsimilarity index 100%\nrename from framework/jinux-frame/src/task/switch.S\nrename to framework/aster-frame/src/task/switch.S\ndiff --git a/framework/jinux-frame/src/task/task.rs b/framework/aster-frame/src/task/task.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/task/task.rs\nrename to framework/aster-frame/src/task/task.rs\ndiff --git a/framework/jinux-frame/src/timer.rs b/framework/aster-frame/src/timer.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/timer.rs\nrename to framework/aster-frame/src/timer.rs\ndiff --git a/framework/jinux-frame/src/trap/handler.rs b/framework/aster-frame/src/trap/handler.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/trap/handler.rs\nrename to framework/aster-frame/src/trap/handler.rs\ndiff --git a/framework/jinux-frame/src/trap/irq.rs b/framework/aster-frame/src/trap/irq.rs\nsimilarity index 99%\nrename from framework/jinux-frame/src/trap/irq.rs\nrename to framework/aster-frame/src/trap/irq.rs\nindex 25c1020880..0f23b5b061 100644\n--- a/framework/jinux-frame/src/trap/irq.rs\n+++ b/framework/aster-frame/src/trap/irq.rs\n@@ -98,7 +98,7 @@ impl Drop for IrqLine {\n /// # Example\n ///\n /// ``rust\n-/// use jinux_frame::irq;\n+/// use aster_frame::irq;\n ///\n /// {\n ///     let _ = irq::disable_local();\ndiff --git a/framework/jinux-frame/src/trap/mod.rs b/framework/aster-frame/src/trap/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/trap/mod.rs\nrename to framework/aster-frame/src/trap/mod.rs\ndiff --git a/framework/jinux-frame/src/user.rs b/framework/aster-frame/src/user.rs\nsimilarity index 98%\nrename from framework/jinux-frame/src/user.rs\nrename to framework/aster-frame/src/user.rs\nindex 97b9503900..9b89bc6c4f 100644\n--- a/framework/jinux-frame/src/user.rs\n+++ b/framework/aster-frame/src/user.rs\n@@ -48,7 +48,7 @@ impl UserSpace {\n \n /// Specific architectures need to implement this trait. This should only used in `UserMode`\n ///\n-/// Only visible in jinux-frame\n+/// Only visible in aster-frame\n pub(crate) trait UserContextApiInternal {\n     /// Starts executing in the user mode.\n     fn execute(&mut self) -> UserEvent;\n@@ -98,7 +98,7 @@ pub trait UserContextApi {\n /// Here is a sample code on how to use `UserMode`.\n ///  \n /// ```no_run\n-/// use jinux_frame::task::Task;\n+/// use aster_frame::task::Task;\n ///\n /// let current = Task::current();\n /// let user_space = current.user_space()\ndiff --git a/framework/jinux-frame/src/util/mod.rs b/framework/aster-frame/src/util/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/util/mod.rs\nrename to framework/aster-frame/src/util/mod.rs\ndiff --git a/framework/jinux-frame/src/util/recycle_allocator.rs b/framework/aster-frame/src/util/recycle_allocator.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/util/recycle_allocator.rs\nrename to framework/aster-frame/src/util/recycle_allocator.rs\ndiff --git a/framework/jinux-frame/src/util/type_map.rs b/framework/aster-frame/src/util/type_map.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/util/type_map.rs\nrename to framework/aster-frame/src/util/type_map.rs\ndiff --git a/framework/jinux-frame/src/vm/dma/dma_coherent.rs b/framework/aster-frame/src/vm/dma/dma_coherent.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/vm/dma/dma_coherent.rs\nrename to framework/aster-frame/src/vm/dma/dma_coherent.rs\ndiff --git a/framework/jinux-frame/src/vm/dma/dma_stream.rs b/framework/aster-frame/src/vm/dma/dma_stream.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/vm/dma/dma_stream.rs\nrename to framework/aster-frame/src/vm/dma/dma_stream.rs\ndiff --git a/framework/jinux-frame/src/vm/dma/mod.rs b/framework/aster-frame/src/vm/dma/mod.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/vm/dma/mod.rs\nrename to framework/aster-frame/src/vm/dma/mod.rs\ndiff --git a/framework/jinux-frame/src/vm/frame.rs b/framework/aster-frame/src/vm/frame.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/vm/frame.rs\nrename to framework/aster-frame/src/vm/frame.rs\ndiff --git a/framework/jinux-frame/src/vm/frame_allocator.rs b/framework/aster-frame/src/vm/frame_allocator.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/vm/frame_allocator.rs\nrename to framework/aster-frame/src/vm/frame_allocator.rs\ndiff --git a/framework/jinux-frame/src/vm/heap_allocator.rs b/framework/aster-frame/src/vm/heap_allocator.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/vm/heap_allocator.rs\nrename to framework/aster-frame/src/vm/heap_allocator.rs\ndiff --git a/framework/jinux-frame/src/vm/io.rs b/framework/aster-frame/src/vm/io.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/vm/io.rs\nrename to framework/aster-frame/src/vm/io.rs\ndiff --git a/framework/jinux-frame/src/vm/memory_set.rs b/framework/aster-frame/src/vm/memory_set.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/vm/memory_set.rs\nrename to framework/aster-frame/src/vm/memory_set.rs\ndiff --git a/framework/jinux-frame/src/vm/mod.rs b/framework/aster-frame/src/vm/mod.rs\nsimilarity index 96%\nrename from framework/jinux-frame/src/vm/mod.rs\nrename to framework/aster-frame/src/vm/mod.rs\nindex 4a86befa22..bdd36c1797 100644\n--- a/framework/jinux-frame/src/vm/mod.rs\n+++ b/framework/aster-frame/src/vm/mod.rs\n@@ -54,12 +54,12 @@ pub const fn is_page_aligned(p: usize) -> bool {\n     (p & (PAGE_SIZE - 1)) == 0\n }\n \n-/// Convert physical address to virtual address using offset, only available inside jinux-frame\n+/// Convert physical address to virtual address using offset, only available inside aster-frame\n pub(crate) fn paddr_to_vaddr(pa: usize) -> usize {\n     pa + PHYS_OFFSET\n }\n \n-/// Only available inside jinux-frame\n+/// Only available inside aster-frame\n pub(crate) static MEMORY_REGIONS: Once<Vec<MemoryRegion>> = Once::new();\n \n pub static FRAMEBUFFER_REGIONS: Once<Vec<MemoryRegion>> = Once::new();\ndiff --git a/framework/jinux-frame/src/vm/offset.rs b/framework/aster-frame/src/vm/offset.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/vm/offset.rs\nrename to framework/aster-frame/src/vm/offset.rs\ndiff --git a/framework/jinux-frame/src/vm/options.rs b/framework/aster-frame/src/vm/options.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/vm/options.rs\nrename to framework/aster-frame/src/vm/options.rs\ndiff --git a/framework/jinux-frame/src/vm/page_table.rs b/framework/aster-frame/src/vm/page_table.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/vm/page_table.rs\nrename to framework/aster-frame/src/vm/page_table.rs\ndiff --git a/framework/jinux-frame/src/vm/space.rs b/framework/aster-frame/src/vm/space.rs\nsimilarity index 100%\nrename from framework/jinux-frame/src/vm/space.rs\nrename to framework/aster-frame/src/vm/space.rs\ndiff --git a/kernel/main.rs b/kernel/main.rs\nindex 340891903e..bbb7737d2a 100644\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -1,17 +1,17 @@\n #![no_std]\n #![no_main]\n-// The `export_name` attribute for the `jinux_main` entrypoint requires the removal of safety check.\n+// The `export_name` attribute for the `aster_main` entrypoint requires the removal of safety check.\n // Please be aware that the kernel is not allowed to introduce any other unsafe operations.\n // #![forbid(unsafe_code)]\n-extern crate jinux_frame;\n+extern crate aster_frame;\n \n-use jinux_frame::early_println;\n+use aster_frame::early_println;\n \n-#[export_name = \"jinux_main\"]\n+#[export_name = \"aster_main\"]\n pub fn main() -> ! {\n-    jinux_frame::init();\n-    early_println!(\"[kernel] finish init jinux_frame\");\n+    aster_frame::init();\n+    early_println!(\"[kernel] finish init aster_frame\");\n     component::init_all(component::parse_metadata!()).unwrap();\n-    jinux_std::init();\n-    jinux_std::run_first_process();\n+    aster_std::init();\n+    aster_std::run_first_process();\n }\ndiff --git a/regression/Makefile b/regression/Makefile\nindex 87da25cd1f..dc21bb1af0 100644\n--- a/regression/Makefile\n+++ b/regression/Makefile\n@@ -39,7 +39,7 @@ $(INITRAMFS)/lib/x86_64-linux-gnu:\n \t@cp -L /lib/x86_64-linux-gnu/libz.so.1 $@\n \t@cp -L /usr/local/benchmark/iperf/lib/libiperf.so.0 $@\n \t@# TODO: use a custom compiled vdso.so file in the future.\n-\t@git clone https://github.com/jinzhao-dev/linux_vdso.git\n+\t@git clone https://github.com/asterinas/linux_vdso.git\n \t@cd ./linux_vdso && git checkout 2a6d2db 2>/dev/null\n \t@cp -L ./linux_vdso/vdso64.so $@\n \t@rm -rf ./linux_vdso \ndiff --git a/regression/apps/scripts/shell_cmd.sh b/regression/apps/scripts/shell_cmd.sh\nindex 36afa6c5d0..7136d793ac 100755\n--- a/regression/apps/scripts/shell_cmd.sh\n+++ b/regression/apps/scripts/shell_cmd.sh\n@@ -31,7 +31,7 @@ find . -name \"*shell_cmd*\"\n mkdir foo\n rmdir foo \n \n-echo \"Hello world from jinux\" > hello.txt\n+echo \"Hello world from asterinas\" > hello.txt\n rm hello.txt\n \n cd ..\ndiff --git a/runner/Cargo.toml b/runner/Cargo.toml\nindex 69d11f0e91..778bddfb3d 100644\n--- a/runner/Cargo.toml\n+++ b/runner/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-runner\"\n+name = \"aster-runner\"\n version = \"0.1.0\"\n edition = \"2021\"\n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\ndiff --git a/runner/grub/grub.cfg.template b/runner/grub/grub.cfg.template\nindex fec85025cc..c7db16aba0 100644\n--- a/runner/grub/grub.cfg.template\n+++ b/runner/grub/grub.cfg.template\n@@ -7,7 +7,7 @@\n set timeout_style=#GRUB_TIMEOUT_STYLE#\n set timeout=#GRUB_TIMEOUT#\n \n-menuentry 'jinux' {\n+menuentry 'asterinas' {\n     #GRUB_CMD_KERNEL# #KERNEL# #KERNEL_COMMAND_LINE#\n     #GRUB_CMD_INITRAMFS# /boot/initramfs.cpio.gz\n     boot\ndiff --git a/runner/src/gdb.rs b/runner/src/gdb.rs\nindex a976b1caf0..f5a13b69e6 100644\n--- a/runner/src/gdb.rs\n+++ b/runner/src/gdb.rs\n@@ -21,7 +21,7 @@ pub fn run_gdb_client(path: &PathBuf, gdb_grub: bool) {\n     let mut gdb_cmd = Command::new(\"gdb\");\n     // Set the architecture, otherwise GDB will complain about.\n     gdb_cmd.arg(\"-ex\").arg(\"set arch i386:x86-64:intel\");\n-    let grub_script = \"/tmp/jinux-gdb-grub-script\";\n+    let grub_script = \"/tmp/aster-gdb-grub-script\";\n     if gdb_grub {\n         let grub_dir = PathBuf::from(qemu_grub_efi::GRUB_PREFIX)\n             .join(\"lib\")\n@@ -41,7 +41,7 @@ pub fn run_gdb_client(path: &PathBuf, gdb_grub: bool) {\n         for line in lines {\n             if line.contains(\"target remote :1234\") {\n                 // Connect to the GDB server.\n-                writeln!(f, \"target remote /tmp/jinux-gdb-socket\").unwrap();\n+                writeln!(f, \"target remote /tmp/aster-gdb-socket\").unwrap();\n             } else {\n                 writeln!(f, \"{}\", line).unwrap();\n             }\n@@ -53,7 +53,7 @@ pub fn run_gdb_client(path: &PathBuf, gdb_grub: bool) {\n         // Connect to the GDB server.\n         gdb_cmd\n             .arg(\"-ex\")\n-            .arg(\"target remote /tmp/jinux-gdb-socket\");\n+            .arg(\"target remote /tmp/aster-gdb-socket\");\n     }\n     // Connect to the GDB server and run.\n     println!(\"running:{:#?}\", gdb_cmd);\ndiff --git a/runner/src/machine/qemu_grub_efi/linux_boot.rs b/runner/src/machine/qemu_grub_efi/linux_boot.rs\nindex 1f7ab83e97..3a1ea0b2f4 100644\n--- a/runner/src/machine/qemu_grub_efi/linux_boot.rs\n+++ b/runner/src/machine/qemu_grub_efi/linux_boot.rs\n@@ -47,7 +47,7 @@ fn header_to_raw_binary(elf_file: &[u8]) -> Vec<u8> {\n /// This function sould be used when generating the Linux x86 Boot setup header.\n /// Some fields in the Linux x86 Boot setup header should be filled after assembled.\n /// And the filled fields must have the bytes with values of 0xAB. See\n-/// `framework/jinux-frame/src/arch/x86/boot/linux_boot/setup/src/header.S` for more\n+/// `framework/aster-frame/src/arch/x86/boot/linux_boot/setup/src/header.S` for more\n /// info on this mechanism.\n fn fill_header_field(header: &mut [u8], offset: usize, value: &[u8]) {\n     let size = value.len();\ndiff --git a/runner/src/machine/qemu_grub_efi/mod.rs b/runner/src/machine/qemu_grub_efi/mod.rs\nindex 8cb1454cc3..d88bd06948 100644\n--- a/runner/src/machine/qemu_grub_efi/mod.rs\n+++ b/runner/src/machine/qemu_grub_efi/mod.rs\n@@ -70,13 +70,13 @@ pub const GRUB_PREFIX: &str = \"/usr/local/grub\";\n pub const GRUB_VERSION: &str = \"x86_64-efi\";\n \n pub fn create_bootdev_image(\n-    jinux_path: PathBuf,\n+    atser_path: PathBuf,\n     initramfs_path: PathBuf,\n     grub_cfg: String,\n     protocol: BootProtocol,\n     release_mode: bool,\n ) -> PathBuf {\n-    let target_dir = jinux_path.parent().unwrap();\n+    let target_dir = atser_path.parent().unwrap();\n     let iso_root = target_dir.join(\"iso_root\");\n \n     // Clear or make the iso dir.\n@@ -96,24 +96,24 @@ pub fn create_bootdev_image(\n         BootProtocol::Linux => {\n             // Find the setup header in the build script output directory.\n             let bs_out_dir = if release_mode {\n-                glob(\"target/x86_64-custom/release/build/jinux-frame-*\").unwrap()\n+                glob(\"target/x86_64-custom/release/build/aster-frame-*\").unwrap()\n             } else {\n-                glob(\"target/x86_64-custom/debug/build/jinux-frame-*\").unwrap()\n+                glob(\"target/x86_64-custom/debug/build/aster-frame-*\").unwrap()\n             };\n             let header_path = Path::new(bs_out_dir.into_iter().next().unwrap().unwrap().as_path())\n                 .join(\"out\")\n                 .join(\"bin\")\n-                .join(\"jinux-frame-x86-boot-linux-setup\");\n+                .join(\"aster-frame-x86-boot-linux-setup\");\n             // Make the `bzImage`-compatible kernel image and place it in the boot directory.\n-            let target_path = iso_root.join(\"boot\").join(\"jinuz\");\n-            linux_boot::make_bzimage(&target_path, &jinux_path.as_path(), &header_path.as_path())\n+            let target_path = iso_root.join(\"boot\").join(\"asterinaz\");\n+            linux_boot::make_bzimage(&target_path, &atser_path.as_path(), &header_path.as_path())\n                 .unwrap();\n             target_path\n         }\n         BootProtocol::Multiboot | BootProtocol::Multiboot2 => {\n             // Copy the kernel image to the boot directory.\n-            let target_path = iso_root.join(\"boot\").join(\"jinux\");\n-            fs::copy(&jinux_path, &target_path).unwrap();\n+            let target_path = iso_root.join(\"boot\").join(\"atserinas\");\n+            fs::copy(&atser_path, &target_path).unwrap();\n             target_path\n         }\n     };\n@@ -164,15 +164,15 @@ pub fn generate_grub_cfg(\n     let buffer = match protocol {\n         BootProtocol::Multiboot => buffer\n             .replace(\"#GRUB_CMD_KERNEL#\", \"multiboot\")\n-            .replace(\"#KERNEL#\", \"/boot/jinux\")\n+            .replace(\"#KERNEL#\", \"/boot/atserinas\")\n             .replace(\"#GRUB_CMD_INITRAMFS#\", \"module --nounzip\"),\n         BootProtocol::Multiboot2 => buffer\n             .replace(\"#GRUB_CMD_KERNEL#\", \"multiboot2\")\n-            .replace(\"#KERNEL#\", \"/boot/jinux\")\n+            .replace(\"#KERNEL#\", \"/boot/atserinas\")\n             .replace(\"#GRUB_CMD_INITRAMFS#\", \"module2 --nounzip\"),\n         BootProtocol::Linux => buffer\n             .replace(\"#GRUB_CMD_KERNEL#\", \"linux\")\n-            .replace(\"#KERNEL#\", \"/boot/jinuz\")\n+            .replace(\"#KERNEL#\", \"/boot/asterinaz\")\n             .replace(\"#GRUB_CMD_INITRAMFS#\", \"initrd\"),\n     };\n \ndiff --git a/runner/src/main.rs b/runner/src/main.rs\nindex 7602012378..5cf11734b0 100644\n--- a/runner/src/main.rs\n+++ b/runner/src/main.rs\n@@ -1,8 +1,8 @@\n-//! jinux-runner is the Jinux runner script to ease the pain of running\n-//! and testing Jinux inside a QEMU VM. It should be built and run as the\n+//! aster-runner is the Asterinas runner script to ease the pain of running\n+//! and testing Asterinas inside a QEMU VM. It should be built and run as the\n //! cargo runner: https://doc.rust-lang.org/cargo/reference/config.html\n //!\n-//! The runner will generate the filesystem image for starting Jinux. If\n+//! The runner will generate the filesystem image for starting Asterinas. If\n //! we should use the runner in the default mode, which invokes QEMU with\n //! a GRUB boot device image, the runner would be responsible for generating\n //! the appropriate kernel image and the boot device image. It also supports\n@@ -40,7 +40,7 @@ pub enum BootProtocol {\n #[command(author, version, about, long_about = None)]\n struct Args {\n     // Positional arguments.\n-    /// The Jinux binary path.\n+    /// The Asterinas binary path.\n     path: PathBuf,\n \n     /// Provide the kernel commandline, which specifies\n@@ -117,7 +117,7 @@ pub fn random_hostfwd_ports() -> (u16, u16) {\n \n pub const GDB_ARGS: &[&str] = &[\n     \"-chardev\",\n-    \"socket,path=/tmp/jinux-gdb-socket,server=on,wait=off,id=gdb0\",\n+    \"socket,path=/tmp/aster-gdb-socket,server=on,wait=off,id=gdb0\",\n     \"-gdb\",\n     \"chardev:gdb0\",\n     \"-S\",\n@@ -145,13 +145,13 @@ fn main() {\n         port1, port2\n     ));\n     println!(\n-        \"[jinux-runner] Binding host ports to guest ports: ({} -> {}); ({} -> {}).\",\n+        \"[aster-runner] Binding host ports to guest ports: ({} -> {}); ({} -> {}).\",\n         port1, 22, port2, 8080\n     );\n \n     if args.halt_for_gdb {\n         if args.enable_kvm {\n-            println!(\"[jinux-runner] Can't enable KVM when running QEMU as a GDB server. Abort.\");\n+            println!(\"[aster-runner] Can't enable KVM when running QEMU as a GDB server. Abort.\");\n             return;\n         }\n         qemu_cmd.args(GDB_ARGS);\n@@ -206,17 +206,18 @@ fn main() {\n         qemu_cmd.arg(bootdev_image.as_os_str());\n     }\n \n-    println!(\"[jinux-runner] Running: {:#?}\", qemu_cmd);\n+    println!(\"[aster-runner] Running: {:#?}\", qemu_cmd);\n \n     let exit_status = qemu_cmd.status().unwrap();\n-\n-    // FIXME: Exit code manipulation is not needed when using non-x86 QEMU\n-    let qemu_exit_code = exit_status.code().unwrap();\n-    let kernel_exit_code = qemu_exit_code >> 1;\n-    match kernel_exit_code {\n-        0x10 /* jinux_frame::QemuExitCode::Success */ => { std::process::exit(0); },\n-        0x20 /* jinux_frame::QemuExitCode::Failed */ => { std::process::exit(1); },\n-        _ /* unknown, e.g., a triple fault */ => { std::process::exit(2) },\n+    if !exit_status.success() {\n+        // FIXME: Exit code manipulation is not needed when using non-x86 QEMU\n+        let qemu_exit_code = exit_status.code().unwrap();\n+        let kernel_exit_code = qemu_exit_code >> 1;\n+        match kernel_exit_code {\n+            0x10 /*aster_frame::QemuExitCode::Success*/ => { std::process::exit(0); },\n+            0x20 /*aster_frame::QemuExitCode::Failed*/ => { std::process::exit(1); },\n+            _ /* unknown, e.g., a triple fault */ => { std::process::exit(2) },\n+        }\n     }\n }\n \ndiff --git a/services/comps/block/Cargo.toml b/services/comps/block/Cargo.toml\nindex 99e0d23034..a3393222ee 100644\n--- a/services/comps/block/Cargo.toml\n+++ b/services/comps/block/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-block\"\n+name = \"aster-block\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n@@ -8,8 +8,8 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \ndiff --git a/services/comps/block/src/lib.rs b/services/comps/block/src/lib.rs\nindex c1410e17be..40bc59f3bb 100644\n--- a/services/comps/block/src/lib.rs\n+++ b/services/comps/block/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The block devices of jinux\n+//! The block devices of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(fn_traits)]\n@@ -12,9 +12,9 @@ use alloc::collections::BTreeMap;\n use alloc::string::String;\n use alloc::sync::Arc;\n use alloc::vec::Vec;\n+use aster_frame::sync::SpinLock;\n use component::init_component;\n use component::ComponentInitError;\n-use jinux_frame::sync::SpinLock;\n use spin::Once;\n \n pub const BLK_SIZE: usize = 512;\ndiff --git a/services/comps/console/Cargo.toml b/services/comps/console/Cargo.toml\nindex 6e022aaa56..82ec867677 100644\n--- a/services/comps/console/Cargo.toml\n+++ b/services/comps/console/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-console\"\n+name = \"aster-console\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n@@ -8,8 +8,8 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \ndiff --git a/services/comps/console/src/lib.rs b/services/comps/console/src/lib.rs\nindex 169f93ce6a..431856d1f7 100644\n--- a/services/comps/console/src/lib.rs\n+++ b/services/comps/console/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The console device of jinux\n+//! The console device of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(fn_traits)]\n@@ -8,8 +8,8 @@ extern crate alloc;\n use alloc::{collections::BTreeMap, fmt::Debug, string::String, sync::Arc, vec::Vec};\n use core::any::Any;\n \n+use aster_frame::sync::SpinLock;\n use component::{init_component, ComponentInitError};\n-use jinux_frame::sync::SpinLock;\n use spin::Once;\n \n pub type ConsoleCallback = dyn Fn(&[u8]) + Send + Sync;\ndiff --git a/services/comps/framebuffer/Cargo.toml b/services/comps/framebuffer/Cargo.toml\nindex 623734d41d..d8c729ed90 100644\n--- a/services/comps/framebuffer/Cargo.toml\n+++ b/services/comps/framebuffer/Cargo.toml\n@@ -1,12 +1,12 @@\n [package]\n-name = \"jinux-framebuffer\"\n+name = \"aster-framebuffer\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n spin = \"0.9.4\"\ndiff --git a/services/comps/framebuffer/src/lib.rs b/services/comps/framebuffer/src/lib.rs\nindex 383bf5e2bf..05c8820b75 100644\n--- a/services/comps/framebuffer/src/lib.rs\n+++ b/services/comps/framebuffer/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The framebuffer of jinux\n+//! The framebuffer of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(strict_provenance)]\n@@ -6,13 +6,13 @@\n extern crate alloc;\n \n use alloc::vec::Vec;\n+use aster_frame::{boot, config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, vm::VmIo};\n use component::{init_component, ComponentInitError};\n use core::{\n     fmt,\n     ops::{Index, IndexMut},\n };\n use font8x8::UnicodeFonts;\n-use jinux_frame::{boot, config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, vm::VmIo};\n use spin::Once;\n \n #[init_component]\n@@ -28,7 +28,7 @@ pub(crate) fn init() {\n         let framebuffer = boot::framebuffer_arg();\n         let mut writer = None;\n         let mut size = 0;\n-        for i in jinux_frame::vm::FRAMEBUFFER_REGIONS.get().unwrap().iter() {\n+        for i in aster_frame::vm::FRAMEBUFFER_REGIONS.get().unwrap().iter() {\n             size = i.len() as usize;\n         }\n \ndiff --git a/services/comps/input/Cargo.toml b/services/comps/input/Cargo.toml\nindex 9726dad1ba..7db8afd7e7 100644\n--- a/services/comps/input/Cargo.toml\n+++ b/services/comps/input/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-input\"\n+name = \"aster-input\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n@@ -8,9 +8,9 @@ edition = \"2021\"\n [dependencies]\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n-jinux-rights = { path = \"../../libs/jinux-rights\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n+aster-rights = { path = \"../../libs/aster-rights\" }\n component = { path = \"../../libs/comp-sys/component\" }\n virtio-input-decoder = \"0.1.4\"\n log = \"0.4\"\ndiff --git a/services/comps/input/src/lib.rs b/services/comps/input/src/lib.rs\nindex 1644e88a0d..3edf755095 100644\n--- a/services/comps/input/src/lib.rs\n+++ b/services/comps/input/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The input devices of jinux\n+//! The input devices of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![feature(fn_traits)]\n@@ -14,7 +14,7 @@ use alloc::vec::Vec;\n use component::init_component;\n use component::ComponentInitError;\n \n-use jinux_frame::sync::SpinLock;\n+use aster_frame::sync::SpinLock;\n use spin::Once;\n use virtio_input_decoder::DecodeType;\n \ndiff --git a/services/comps/network/Cargo.toml b/services/comps/network/Cargo.toml\nindex d56d55ca1c..60562e8946 100644\n--- a/services/comps/network/Cargo.toml\n+++ b/services/comps/network/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-network\"\n+name = \"aster-network\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n@@ -7,13 +7,13 @@ edition = \"2021\"\n \n [dependencies]\n component = { path = \"../../libs/comp-sys/component\" }\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n-jinux-rights = { path = \"../../libs/jinux-rights\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n+aster-rights = { path = \"../../libs/aster-rights\" }\n align_ext = { path = \"../../../framework/libs/align_ext\" }\n int-to-c-enum = { path = \"../../libs/int-to-c-enum\" }\n bytes = { version = \"1.4.0\", default-features = false }\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n bitflags = \"1.3\"\n spin = \"0.9.4\"\n ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\ndiff --git a/services/comps/network/src/lib.rs b/services/comps/network/src/lib.rs\nindex 1614acb438..04ea774669 100644\n--- a/services/comps/network/src/lib.rs\n+++ b/services/comps/network/src/lib.rs\n@@ -13,14 +13,14 @@ use alloc::collections::BTreeMap;\n use alloc::string::String;\n use alloc::sync::Arc;\n use alloc::vec::Vec;\n+use aster_frame::sync::SpinLock;\n+use aster_util::safe_ptr::Pod;\n use buffer::RxBuffer;\n use buffer::TxBuffer;\n use component::init_component;\n use component::ComponentInitError;\n use core::any::Any;\n use core::fmt::Debug;\n-use jinux_frame::sync::SpinLock;\n-use jinux_util::safe_ptr::Pod;\n use smoltcp::phy;\n use spin::Once;\n \ndiff --git a/services/comps/time/Cargo.toml b/services/comps/time/Cargo.toml\nindex 032189fedf..aa595969ca 100644\n--- a/services/comps/time/Cargo.toml\n+++ b/services/comps/time/Cargo.toml\n@@ -1,13 +1,13 @@\n [package]\n-name = \"jinux-time\"\n+name = \"aster-time\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n spin = \"0.9.4\"\ndiff --git a/services/comps/time/src/clocksource.rs b/services/comps/time/src/clocksource.rs\nindex ef59320f72..b688d42355 100644\n--- a/services/comps/time/src/clocksource.rs\n+++ b/services/comps/time/src/clocksource.rs\n@@ -6,9 +6,9 @@\n //! It can be integrated into larger systems to provide timing capabilities, or used standalone for time tracking and elapsed time measurements.\n \n use alloc::sync::Arc;\n+use aster_frame::sync::SpinLock;\n+use aster_util::coeff::Coeff;\n use core::{cmp::max, ops::Add, time::Duration};\n-use jinux_frame::sync::SpinLock;\n-use jinux_util::coeff::Coeff;\n \n use crate::NANOS_PER_SECOND;\n \ndiff --git a/services/comps/time/src/lib.rs b/services/comps/time/src/lib.rs\nindex b6c1e33f7c..9c165d56bb 100644\n--- a/services/comps/time/src/lib.rs\n+++ b/services/comps/time/src/lib.rs\n@@ -1,13 +1,13 @@\n-//! The system time of jinux\n+//! The system time of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n \n extern crate alloc;\n \n use alloc::sync::Arc;\n+use aster_frame::sync::Mutex;\n use component::{init_component, ComponentInitError};\n use core::{sync::atomic::Ordering::Relaxed, time::Duration};\n-use jinux_frame::sync::Mutex;\n use spin::Once;\n \n use clocksource::ClockSource;\ndiff --git a/services/comps/time/src/rtc.rs b/services/comps/time/src/rtc.rs\nindex 978d160795..a6dc47b6c4 100644\n--- a/services/comps/time/src/rtc.rs\n+++ b/services/comps/time/src/rtc.rs\n@@ -1,6 +1,6 @@\n+use aster_frame::arch::x86::device::cmos::{get_century_register, CMOS_ADDRESS, CMOS_DATA};\n use core::sync::atomic::AtomicU8;\n use core::sync::atomic::Ordering::Relaxed;\n-use jinux_frame::arch::x86::device::cmos::{get_century_register, CMOS_ADDRESS, CMOS_DATA};\n \n pub(crate) static CENTURY_REGISTER: AtomicU8 = AtomicU8::new(0);\n \ndiff --git a/services/comps/time/src/tsc.rs b/services/comps/time/src/tsc.rs\nindex 3e2ddf0f38..d44fc34a8c 100644\n--- a/services/comps/time/src/tsc.rs\n+++ b/services/comps/time/src/tsc.rs\n@@ -2,9 +2,9 @@\n //!\n //! Use `init` to initialize this module.\n use alloc::sync::Arc;\n+use aster_frame::arch::{read_tsc, x86::tsc_freq};\n+use aster_frame::timer::Timer;\n use core::time::Duration;\n-use jinux_frame::arch::{read_tsc, x86::tsc_freq};\n-use jinux_frame::timer::Timer;\n use spin::Once;\n \n use crate::clocksource::{ClockSource, Instant};\ndiff --git a/services/comps/virtio/Cargo.toml b/services/comps/virtio/Cargo.toml\nindex e71cd2b262..e5570c99ca 100644\n--- a/services/comps/virtio/Cargo.toml\n+++ b/services/comps/virtio/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-virtio\"\n+name = \"aster-virtio\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n@@ -11,15 +11,15 @@ spin = \"0.9.4\"\n virtio-input-decoder = \"0.1.4\"\n bytes = { version = \"1.4.0\", default-features = false }\n align_ext = { path = \"../../../framework/libs/align_ext\" }\n-jinux-input = { path = \"../input\" }\n-jinux-block = { path = \"../block\" }\n-jinux-network = { path = \"../network\" }\n-jinux-console = { path = \"../console\" }\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-jinux-util = { path = \"../../libs/jinux-util\" }\n-jinux-rights = { path = \"../../libs/jinux-rights\" }\n+aster-input = { path = \"../input\" }\n+aster-block = { path = \"../block\" }\n+aster-network = { path = \"../network\" }\n+aster-console = { path = \"../console\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+aster-util = { path = \"../../libs/aster-util\" }\n+aster-rights = { path = \"../../libs/aster-rights\" }\n typeflags-util = { path = \"../../libs/typeflags-util\" }\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n bit_field = \"0.10.1\"\ndiff --git a/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\nindex 925a71aba6..5bb1ea47e3 100644\n--- a/services/comps/virtio/src/device/block/device.rs\n+++ b/services/comps/virtio/src/device/block/device.rs\n@@ -1,8 +1,8 @@\n use core::hint::spin_loop;\n \n use alloc::{boxed::Box, string::ToString, sync::Arc};\n-use jinux_frame::{io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::{io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n+use aster_util::safe_ptr::SafePtr;\n use log::info;\n use pod::Pod;\n \n@@ -97,7 +97,7 @@ impl BlockDevice {\n             .unwrap();\n \n         fn handle_block_device(_: &TrapFrame) {\n-            jinux_block::get_device(super::DEVICE_NAME)\n+            aster_block::get_device(super::DEVICE_NAME)\n                 .unwrap()\n                 .handle_irq();\n         }\n@@ -107,7 +107,7 @@ impl BlockDevice {\n         }\n         device.transport.finish_init();\n \n-        jinux_block::register_device(super::DEVICE_NAME.to_string(), Arc::new(device));\n+        aster_block::register_device(super::DEVICE_NAME.to_string(), Arc::new(device));\n \n         Ok(())\n     }\n@@ -120,7 +120,7 @@ impl BlockDevice {\n     }\n }\n \n-impl jinux_block::BlockDevice for BlockDevice {\n+impl aster_block::BlockDevice for BlockDevice {\n     fn read_block(&self, block_id: usize, buf: &mut [u8]) {\n         self.read(block_id, buf);\n     }\ndiff --git a/services/comps/virtio/src/device/block/mod.rs b/services/comps/virtio/src/device/block/mod.rs\nindex fd6b5cefb8..62763d723d 100644\n--- a/services/comps/virtio/src/device/block/mod.rs\n+++ b/services/comps/virtio/src/device/block/mod.rs\n@@ -1,9 +1,9 @@\n pub mod device;\n \n+use aster_frame::io_mem::IoMem;\n+use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n use int_to_c_enum::TryFromInt;\n-use jinux_frame::io_mem::IoMem;\n-use jinux_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n use crate::transport::VirtioTransport;\ndiff --git a/services/comps/virtio/src/device/console/config.rs b/services/comps/virtio/src/device/console/config.rs\nindex b4212f9614..f4e2373195 100644\n--- a/services/comps/virtio/src/device/console/config.rs\n+++ b/services/comps/virtio/src/device/console/config.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::io_mem::IoMem;\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::io_mem::IoMem;\n+use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n use crate::transport::VirtioTransport;\ndiff --git a/services/comps/virtio/src/device/console/device.rs b/services/comps/virtio/src/device/console/device.rs\nindex d37fe2151d..6993abf414 100644\n--- a/services/comps/virtio/src/device/console/device.rs\n+++ b/services/comps/virtio/src/device/console/device.rs\n@@ -1,9 +1,9 @@\n use core::hint::spin_loop;\n \n use alloc::{boxed::Box, fmt::Debug, string::ToString, sync::Arc, vec::Vec};\n-use jinux_console::{AnyConsoleDevice, ConsoleCallback};\n-use jinux_frame::{config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_console::{AnyConsoleDevice, ConsoleCallback};\n+use aster_frame::{config::PAGE_SIZE, io_mem::IoMem, sync::SpinLock, trap::TrapFrame};\n+use aster_util::safe_ptr::SafePtr;\n use log::debug;\n \n use crate::{\n@@ -130,14 +130,14 @@ impl ConsoleDevice {\n             .unwrap();\n         device.transport.finish_init();\n \n-        jinux_console::register_device(DEVICE_NAME.to_string(), Arc::new(device));\n+        aster_console::register_device(DEVICE_NAME.to_string(), Arc::new(device));\n \n         Ok(())\n     }\n }\n \n fn handle_console_input(_: &TrapFrame) {\n-    jinux_console::get_device(DEVICE_NAME).unwrap().handle_irq();\n+    aster_console::get_device(DEVICE_NAME).unwrap().handle_irq();\n }\n \n fn config_space_change(_: &TrapFrame) {\ndiff --git a/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\nindex dc5b48c16f..fcb4b5fae1 100644\n--- a/services/comps/virtio/src/device/input/device.rs\n+++ b/services/comps/virtio/src/device/input/device.rs\n@@ -7,9 +7,9 @@ use alloc::{\n     sync::Arc,\n     vec::Vec,\n };\n+use aster_frame::{io_mem::IoMem, offset_of, sync::SpinLock, trap::TrapFrame};\n+use aster_util::{field_ptr, safe_ptr::SafePtr};\n use bitflags::bitflags;\n-use jinux_frame::{io_mem::IoMem, offset_of, sync::SpinLock, trap::TrapFrame};\n-use jinux_util::{field_ptr, safe_ptr::SafePtr};\n use log::{debug, info};\n use pod::Pod;\n use virtio_input_decoder::{DecodeType, Decoder};\n@@ -112,7 +112,7 @@ impl InputDevice {\n \n         fn handle_input(_: &TrapFrame) {\n             debug!(\"Handle Virtio input interrupt\");\n-            let device = jinux_input::get_device(super::DEVICE_NAME).unwrap();\n+            let device = aster_input::get_device(super::DEVICE_NAME).unwrap();\n             device.handle_irq().unwrap();\n         }\n \n@@ -131,7 +131,7 @@ impl InputDevice {\n \n         device.transport.finish_init();\n \n-        jinux_input::register_device(super::DEVICE_NAME.to_string(), Arc::new(device));\n+        aster_input::register_device(super::DEVICE_NAME.to_string(), Arc::new(device));\n \n         Ok(())\n     }\n@@ -183,7 +183,7 @@ impl InputDevice {\n     }\n }\n \n-impl jinux_input::InputDevice for InputDevice {\n+impl aster_input::InputDevice for InputDevice {\n     fn handle_irq(&self) -> Option<()> {\n         // one interrupt may contains serval input, so it should loop\n         loop {\ndiff --git a/services/comps/virtio/src/device/input/mod.rs b/services/comps/virtio/src/device/input/mod.rs\nindex c1310718d5..eea3e13600 100644\n--- a/services/comps/virtio/src/device/input/mod.rs\n+++ b/services/comps/virtio/src/device/input/mod.rs\n@@ -26,8 +26,8 @@\n \n pub mod device;\n use crate::transport::VirtioTransport;\n-use jinux_frame::io_mem::IoMem;\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::io_mem::IoMem;\n+use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n pub static DEVICE_NAME: &str = \"Virtio-Input\";\ndiff --git a/services/comps/virtio/src/device/network/config.rs b/services/comps/virtio/src/device/network/config.rs\nindex 1971655bba..0fb980d5b3 100644\n--- a/services/comps/virtio/src/device/network/config.rs\n+++ b/services/comps/virtio/src/device/network/config.rs\n@@ -1,7 +1,7 @@\n+use aster_frame::io_mem::IoMem;\n+use aster_network::EthernetAddr;\n+use aster_util::safe_ptr::SafePtr;\n use bitflags::bitflags;\n-use jinux_frame::io_mem::IoMem;\n-use jinux_network::EthernetAddr;\n-use jinux_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n use crate::transport::VirtioTransport;\ndiff --git a/services/comps/virtio/src/device/network/device.rs b/services/comps/virtio/src/device/network/device.rs\nindex 3faecadc18..f3fc6bfc0d 100644\n--- a/services/comps/virtio/src/device/network/device.rs\n+++ b/services/comps/virtio/src/device/network/device.rs\n@@ -1,12 +1,12 @@\n use core::{fmt::Debug, hint::spin_loop, mem::size_of};\n \n use alloc::{boxed::Box, string::ToString, sync::Arc, vec::Vec};\n-use jinux_frame::{offset_of, sync::SpinLock, trap::TrapFrame};\n-use jinux_network::{\n+use aster_frame::{offset_of, sync::SpinLock, trap::TrapFrame};\n+use aster_network::{\n     buffer::{RxBuffer, TxBuffer},\n     AnyNetworkDevice, EthernetAddr, NetDeviceIrqHandler, VirtioNetError,\n };\n-use jinux_util::{field_ptr, slot_vec::SlotVec};\n+use aster_util::{field_ptr, slot_vec::SlotVec};\n use log::debug;\n use pod::Pod;\n use smoltcp::phy::{DeviceCapabilities, Medium};\n@@ -87,7 +87,7 @@ impl NetworkDevice {\n \n         /// Interrupt handler if network device receives some packet\n         fn handle_network_event(_: &TrapFrame) {\n-            jinux_network::handle_recv_irq(super::DEVICE_NAME);\n+            aster_network::handle_recv_irq(super::DEVICE_NAME);\n         }\n \n         device\n@@ -99,7 +99,7 @@ impl NetworkDevice {\n             .register_queue_callback(QUEUE_RECV, Box::new(handle_network_event), false)\n             .unwrap();\n \n-        jinux_network::register_device(\n+        aster_network::register_device(\n             super::DEVICE_NAME.to_string(),\n             Arc::new(SpinLock::new(Box::new(device))),\n         );\ndiff --git a/services/comps/virtio/src/lib.rs b/services/comps/virtio/src/lib.rs\nindex aee89fc0f1..6b5e896716 100644\n--- a/services/comps/virtio/src/lib.rs\n+++ b/services/comps/virtio/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The virtio of jinux\n+//! The virtio of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![allow(dead_code)]\ndiff --git a/services/comps/virtio/src/queue.rs b/services/comps/virtio/src/queue.rs\nindex bca7865951..b761a2aa89 100644\n--- a/services/comps/virtio/src/queue.rs\n+++ b/services/comps/virtio/src/queue.rs\n@@ -3,18 +3,18 @@\n use crate::transport::VirtioTransport;\n \n use alloc::vec::Vec;\n+use aster_frame::{\n+    io_mem::IoMem,\n+    offset_of,\n+    vm::{DmaCoherent, VmAllocOptions},\n+};\n+use aster_rights::{Dup, TRightSet, TRights, Write};\n+use aster_util::{field_ptr, safe_ptr::SafePtr};\n use bitflags::bitflags;\n use core::{\n     mem::size_of,\n     sync::atomic::{fence, Ordering},\n };\n-use jinux_frame::{\n-    io_mem::IoMem,\n-    offset_of,\n-    vm::{DmaCoherent, VmAllocOptions},\n-};\n-use jinux_rights::{Dup, TRightSet, TRights, Write};\n-use jinux_util::{field_ptr, safe_ptr::SafePtr};\n use log::debug;\n use pod::Pod;\n \n@@ -372,7 +372,7 @@ fn set_buf(ptr: &SafePtr<Descriptor, &DmaCoherent, TRightSet<TRights![Dup, Write\n     // FIXME: use `DmaSteam` for buf. Now because the upper device driver lacks the\n     // ability to safely construct DmaStream from slice, slice is still used here.\n     let va = buf.as_ptr() as usize;\n-    let pa = jinux_frame::vm::vaddr_to_paddr(va).unwrap();\n+    let pa = aster_frame::vm::vaddr_to_paddr(va).unwrap();\n     field_ptr!(ptr, Descriptor, addr)\n         .write(&(pa as u64))\n         .unwrap();\ndiff --git a/services/comps/virtio/src/transport/mmio/device.rs b/services/comps/virtio/src/transport/mmio/device.rs\nindex 85e8e3f0e8..60f2dce266 100644\n--- a/services/comps/virtio/src/transport/mmio/device.rs\n+++ b/services/comps/virtio/src/transport/mmio/device.rs\n@@ -1,6 +1,5 @@\n use alloc::{boxed::Box, sync::Arc};\n-use core::mem::size_of;\n-use jinux_frame::{\n+use aster_frame::{\n     bus::mmio::{\n         bus::MmioDevice,\n         device::{MmioCommonDevice, VirtioMmioVersion},\n@@ -12,8 +11,9 @@ use jinux_frame::{\n     trap::IrqCallbackFunction,\n     vm::DmaCoherent,\n };\n-use jinux_rights::{ReadOp, WriteOp};\n-use jinux_util::{field_ptr, safe_ptr::SafePtr};\n+use aster_rights::{ReadOp, WriteOp};\n+use aster_util::{field_ptr, safe_ptr::SafePtr};\n+use core::mem::size_of;\n use log::warn;\n \n use crate::{\n@@ -33,7 +33,7 @@ pub struct VirtioMmioDevice {\n pub struct VirtioMmioTransport {\n     layout: SafePtr<VirtioMmioLayout, IoMem>,\n     device: Arc<VirtioMmioDevice>,\n-    common_device: jinux_frame::bus::mmio::device::MmioCommonDevice,\n+    common_device: aster_frame::bus::mmio::device::MmioCommonDevice,\n     multiplex: Arc<RwLock<MultiplexIrq>>,\n }\n \ndiff --git a/services/comps/virtio/src/transport/mmio/driver.rs b/services/comps/virtio/src/transport/mmio/driver.rs\nindex 1e6c428a77..e4d21dc8bb 100644\n--- a/services/comps/virtio/src/transport/mmio/driver.rs\n+++ b/services/comps/virtio/src/transport/mmio/driver.rs\n@@ -1,5 +1,5 @@\n use alloc::{sync::Arc, vec::Vec};\n-use jinux_frame::{\n+use aster_frame::{\n     bus::{\n         mmio::{\n             bus::{MmioDevice, MmioDriver},\ndiff --git a/services/comps/virtio/src/transport/mmio/mod.rs b/services/comps/virtio/src/transport/mmio/mod.rs\nindex be15263ef7..13bb42c18b 100644\n--- a/services/comps/virtio/src/transport/mmio/mod.rs\n+++ b/services/comps/virtio/src/transport/mmio/mod.rs\n@@ -1,5 +1,5 @@\n use alloc::sync::Arc;\n-use jinux_frame::bus::mmio::MMIO_BUS;\n+use aster_frame::bus::mmio::MMIO_BUS;\n use spin::Once;\n \n use self::driver::VirtioMmioDriver;\ndiff --git a/services/comps/virtio/src/transport/mmio/multiplex.rs b/services/comps/virtio/src/transport/mmio/multiplex.rs\nindex 8456356435..82ee9f27df 100644\n--- a/services/comps/virtio/src/transport/mmio/multiplex.rs\n+++ b/services/comps/virtio/src/transport/mmio/multiplex.rs\n@@ -1,13 +1,13 @@\n use core::fmt::Debug;\n \n use alloc::{boxed::Box, sync::Arc, vec::Vec};\n-use jinux_frame::{\n+use aster_frame::{\n     io_mem::IoMem,\n     sync::RwLock,\n     trap::{IrqCallbackFunction, IrqLine, TrapFrame},\n };\n-use jinux_rights::{ReadOp, TRightSet, WriteOp};\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_rights::{ReadOp, TRightSet, WriteOp};\n+use aster_util::safe_ptr::SafePtr;\n \n /// Multiplexing Irqs. The two interrupt types (configuration space change and queue interrupt)\n /// of the virtio-mmio device share the same IRQ, so `MultiplexIrq` are used to distinguish them.\ndiff --git a/services/comps/virtio/src/transport/mod.rs b/services/comps/virtio/src/transport/mod.rs\nindex c828bc7b66..46e083b86f 100644\n--- a/services/comps/virtio/src/transport/mod.rs\n+++ b/services/comps/virtio/src/transport/mod.rs\n@@ -1,8 +1,8 @@\n use core::fmt::Debug;\n \n use alloc::boxed::Box;\n-use jinux_frame::{io_mem::IoMem, trap::IrqCallbackFunction, vm::DmaCoherent};\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::{io_mem::IoMem, trap::IrqCallbackFunction, vm::DmaCoherent};\n+use aster_util::safe_ptr::SafePtr;\n \n use crate::{\n     queue::{AvailRing, Descriptor, UsedRing},\ndiff --git a/services/comps/virtio/src/transport/pci/capability.rs b/services/comps/virtio/src/transport/pci/capability.rs\nindex 9e6c357013..f8a4c6a7a9 100644\n--- a/services/comps/virtio/src/transport/pci/capability.rs\n+++ b/services/comps/virtio/src/transport/pci/capability.rs\n@@ -1,5 +1,5 @@\n use alloc::sync::Arc;\n-use jinux_frame::bus::pci::{\n+use aster_frame::bus::pci::{\n     capability::vendor::CapabilityVndrData,\n     cfg_space::{Bar, IoBar, MemoryBar},\n     common_device::BarManager,\ndiff --git a/services/comps/virtio/src/transport/pci/common_cfg.rs b/services/comps/virtio/src/transport/pci/common_cfg.rs\nindex adaae7b1f7..6d72489665 100644\n--- a/services/comps/virtio/src/transport/pci/common_cfg.rs\n+++ b/services/comps/virtio/src/transport/pci/common_cfg.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::io_mem::IoMem;\n-use jinux_util::safe_ptr::SafePtr;\n+use aster_frame::io_mem::IoMem;\n+use aster_util::safe_ptr::SafePtr;\n use pod::Pod;\n \n use crate::transport::pci::capability::VirtioPciCpabilityType;\ndiff --git a/services/comps/virtio/src/transport/pci/device.rs b/services/comps/virtio/src/transport/pci/device.rs\nindex 4862cf201f..f67f1f0976 100644\n--- a/services/comps/virtio/src/transport/pci/device.rs\n+++ b/services/comps/virtio/src/transport/pci/device.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::{\n+use aster_frame::{\n     bus::{\n         pci::{\n             bus::PciDevice, capability::CapabilityData, common_device::PciCommonDevice, PciDeviceId,\n@@ -12,8 +12,8 @@ use jinux_frame::{\n };\n \n use alloc::{boxed::Box, sync::Arc};\n+use aster_util::{field_ptr, safe_ptr::SafePtr};\n use core::fmt::Debug;\n-use jinux_util::{field_ptr, safe_ptr::SafePtr};\n use log::{info, warn};\n \n use super::{common_cfg::VirtioPciCommonCfg, msix::VirtioMsixManager};\ndiff --git a/services/comps/virtio/src/transport/pci/driver.rs b/services/comps/virtio/src/transport/pci/driver.rs\nindex 7f6cf9baa4..5e37120f00 100644\n--- a/services/comps/virtio/src/transport/pci/driver.rs\n+++ b/services/comps/virtio/src/transport/pci/driver.rs\n@@ -1,5 +1,5 @@\n use alloc::{sync::Arc, vec::Vec};\n-use jinux_frame::{\n+use aster_frame::{\n     bus::{\n         pci::{\n             bus::{PciDevice, PciDriver},\ndiff --git a/services/comps/virtio/src/transport/pci/mod.rs b/services/comps/virtio/src/transport/pci/mod.rs\nindex 886e72736a..4fd80e8c75 100644\n--- a/services/comps/virtio/src/transport/pci/mod.rs\n+++ b/services/comps/virtio/src/transport/pci/mod.rs\n@@ -5,7 +5,7 @@ pub mod driver;\n pub(super) mod msix;\n \n use alloc::sync::Arc;\n-use jinux_frame::bus::pci::PCI_BUS;\n+use aster_frame::bus::pci::PCI_BUS;\n use spin::Once;\n \n use self::driver::VirtioPciDriver;\ndiff --git a/services/comps/virtio/src/transport/pci/msix.rs b/services/comps/virtio/src/transport/pci/msix.rs\nindex 77ceda7b94..baeb093acb 100644\n--- a/services/comps/virtio/src/transport/pci/msix.rs\n+++ b/services/comps/virtio/src/transport/pci/msix.rs\n@@ -1,5 +1,5 @@\n use alloc::vec::Vec;\n-use jinux_frame::{bus::pci::capability::msix::CapabilityMsixData, trap::IrqLine};\n+use aster_frame::{bus::pci::capability::msix::CapabilityMsixData, trap::IrqLine};\n \n pub struct VirtioMsixManager {\n     config_msix_vector: u16,\n@@ -17,7 +17,7 @@ impl VirtioMsixManager {\n     pub fn new(mut msix: CapabilityMsixData) -> Self {\n         let mut msix_vector_list: Vec<u16> = (0..msix.table_size()).collect();\n         for i in msix_vector_list.iter() {\n-            let irq = jinux_frame::trap::IrqLine::alloc().unwrap();\n+            let irq = aster_frame::trap::IrqLine::alloc().unwrap();\n             msix.set_interrupt_vector(irq, *i);\n         }\n         let config_msix_vector = msix_vector_list.pop().unwrap();\ndiff --git a/services/libs/jinux-rights-proc/Cargo.toml b/services/libs/aster-rights-proc/Cargo.toml\nsimilarity index 91%\nrename from services/libs/jinux-rights-proc/Cargo.toml\nrename to services/libs/aster-rights-proc/Cargo.toml\nindex 81c8dd1340..bcdc003fc5 100644\n--- a/services/libs/jinux-rights-proc/Cargo.toml\n+++ b/services/libs/aster-rights-proc/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-rights-proc\"\n+name = \"aster-rights-proc\"\n version = \"0.1.0\"\n edition = \"2021\"\n \ndiff --git a/services/libs/jinux-rights-proc/src/lib.rs b/services/libs/aster-rights-proc/src/lib.rs\nsimilarity index 99%\nrename from services/libs/jinux-rights-proc/src/lib.rs\nrename to services/libs/aster-rights-proc/src/lib.rs\nindex 21c7c80b19..3ca7d27e20 100644\n--- a/services/libs/jinux-rights-proc/src/lib.rs\n+++ b/services/libs/aster-rights-proc/src/lib.rs\n@@ -1,4 +1,4 @@\n-//\uff01This crate defines the require procedural macros to implement capability for jinux.\n+//\uff01This crate defines the require procedural macros to implement capability for Asterinas.\n //! When use this crate, typeflags and typeflags-util should also be added as dependency.\n //!\n //! The require macro are used to ensure that an object has the enough capability to call the function.\ndiff --git a/services/libs/jinux-rights-proc/src/require_attr.rs b/services/libs/aster-rights-proc/src/require_attr.rs\nsimilarity index 100%\nrename from services/libs/jinux-rights-proc/src/require_attr.rs\nrename to services/libs/aster-rights-proc/src/require_attr.rs\ndiff --git a/services/libs/jinux-rights-proc/src/require_item.rs b/services/libs/aster-rights-proc/src/require_item.rs\nsimilarity index 100%\nrename from services/libs/jinux-rights-proc/src/require_item.rs\nrename to services/libs/aster-rights-proc/src/require_item.rs\ndiff --git a/services/libs/jinux-rights/Cargo.toml b/services/libs/aster-rights/Cargo.toml\nsimilarity index 78%\nrename from services/libs/jinux-rights/Cargo.toml\nrename to services/libs/aster-rights/Cargo.toml\nindex 758231ac5a..c9f4f522e4 100644\n--- a/services/libs/jinux-rights/Cargo.toml\n+++ b/services/libs/aster-rights/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"jinux-rights\"\n+name = \"aster-rights\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n@@ -9,6 +9,6 @@ edition = \"2021\"\n typeflags = { path = \"../typeflags\" }\n typeflags-util = { path = \"../typeflags-util\" }\n bitflags = \"1.3\"\n-jinux-rights-proc = { path = \"../jinux-rights-proc\" }\n+aster-rights-proc = { path = \"../aster-rights-proc\" }\n \n [features]\ndiff --git a/services/libs/jinux-rights/src/lib.rs b/services/libs/aster-rights/src/lib.rs\nsimilarity index 98%\nrename from services/libs/jinux-rights/src/lib.rs\nrename to services/libs/aster-rights/src/lib.rs\nindex 8b59cd2570..e7e929bff9 100644\n--- a/services/libs/jinux-rights/src/lib.rs\n+++ b/services/libs/aster-rights/src/lib.rs\n@@ -58,7 +58,7 @@ pub type FullOp = TRights![Read, Write, Dup];\n /// Example:\n ///\n /// ```rust\n-/// use jinux_rights::{Rights, TRights, TRightSet};\n+/// use aster_rights::{Rights, TRights, TRightSet};\n ///\n /// pub struct Vmo<R=Rights>(R);\n ///\ndiff --git a/services/libs/jinux-std/Cargo.toml b/services/libs/aster-std/Cargo.toml\nsimilarity index 72%\nrename from services/libs/jinux-std/Cargo.toml\nrename to services/libs/aster-std/Cargo.toml\nindex f826e428f9..e09364dc1d 100644\n--- a/services/libs/jinux-std/Cargo.toml\n+++ b/services/libs/aster-std/Cargo.toml\n@@ -1,26 +1,26 @@\n [package]\n-name = \"jinux-std\"\n+name = \"aster-std\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n align_ext = { path = \"../../../framework/libs/align_ext\" }\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n-jinux-input = { path = \"../../comps/input\" }\n-jinux-block = { path = \"../../comps/block\" }\n-jinux-network = { path = \"../../comps/network\" }\n-jinux-console = { path = \"../../comps/console\" }\n-jinux-time = { path = \"../../comps/time\" }\n-jinux-virtio = { path = \"../../comps/virtio\" }\n-jinux-rights = { path = \"../jinux-rights\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n+aster-input = { path = \"../../comps/input\" }\n+aster-block = { path = \"../../comps/block\" }\n+aster-network = { path = \"../../comps/network\" }\n+aster-console = { path = \"../../comps/console\" }\n+aster-time = { path = \"../../comps/time\" }\n+aster-virtio = { path = \"../../comps/virtio\" }\n+aster-rights = { path = \"../aster-rights\" }\n controlled = { path = \"../../libs/comp-sys/controlled\" }\n typeflags = { path = \"../typeflags\" }\n typeflags-util = { path = \"../typeflags-util\" }\n-jinux-rights-proc = { path = \"../jinux-rights-proc\" }\n-jinux-util = { path = \"../jinux-util\" }\n+aster-rights-proc = { path = \"../aster-rights-proc\" }\n+aster-util = { path = \"../aster-util\" }\n int-to-c-enum = { path = \"../../libs/int-to-c-enum\" }\n cpio-decoder = { path = \"../cpio-decoder\" }\n virtio-input-decoder = \"0.1.4\"\n@@ -52,7 +52,7 @@ bitflags = \"1.3\"\n ringbuf = { version = \"0.3.2\", default-features = false, features = [\"alloc\"] }\n keyable-arc = { path = \"../keyable-arc\" }\n # unzip initramfs\n-libflate = { git = \"https://github.com/jinzhao-dev/libflate\", rev = \"b781da6\", features = [\n+libflate = { git = \"https://github.com/asterinas/libflate\", rev = \"b781da6\", features = [\n     \"no_std\",\n ] }\n core2 = { version = \"0.4\", default_features = false, features = [\"alloc\"] }\ndiff --git a/services/libs/jinux-std/src/console.rs b/services/libs/aster-std/src/console.rs\nsimilarity index 94%\nrename from services/libs/jinux-std/src/console.rs\nrename to services/libs/aster-std/src/console.rs\nindex b64572d160..d42995e2fa 100644\n--- a/services/libs/jinux-std/src/console.rs\n+++ b/services/libs/aster-std/src/console.rs\n@@ -9,7 +9,7 @@ struct VirtioConsolesPrinter;\n \n impl Write for VirtioConsolesPrinter {\n     fn write_str(&mut self, s: &str) -> core::fmt::Result {\n-        for (_, device) in jinux_console::all_devices() {\n+        for (_, device) in aster_console::all_devices() {\n             device.send(s.as_bytes());\n         }\n         Ok(())\ndiff --git a/services/libs/jinux-std/src/device/mod.rs b/services/libs/aster-std/src/device/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/device/mod.rs\nrename to services/libs/aster-std/src/device/mod.rs\ndiff --git a/services/libs/jinux-std/src/device/null.rs b/services/libs/aster-std/src/device/null.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/device/null.rs\nrename to services/libs/aster-std/src/device/null.rs\ndiff --git a/services/libs/jinux-std/src/device/pty/mod.rs b/services/libs/aster-std/src/device/pty/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/device/pty/mod.rs\nrename to services/libs/aster-std/src/device/pty/mod.rs\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/aster-std/src/device/pty/pty.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/device/pty/pty.rs\nrename to services/libs/aster-std/src/device/pty/pty.rs\ndiff --git a/services/libs/jinux-std/src/device/random.rs b/services/libs/aster-std/src/device/random.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/device/random.rs\nrename to services/libs/aster-std/src/device/random.rs\ndiff --git a/services/libs/jinux-std/src/device/tdxguest/mod.rs b/services/libs/aster-std/src/device/tdxguest/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/device/tdxguest/mod.rs\nrename to services/libs/aster-std/src/device/tdxguest/mod.rs\ndiff --git a/services/libs/jinux-std/src/device/tty/device.rs b/services/libs/aster-std/src/device/tty/device.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/device/tty/device.rs\nrename to services/libs/aster-std/src/device/tty/device.rs\ndiff --git a/services/libs/jinux-std/src/device/tty/driver.rs b/services/libs/aster-std/src/device/tty/driver.rs\nsimilarity index 95%\nrename from services/libs/jinux-std/src/device/tty/driver.rs\nrename to services/libs/aster-std/src/device/tty/driver.rs\nindex b78036faa9..8801680db3 100644\n--- a/services/libs/jinux-std/src/device/tty/driver.rs\n+++ b/services/libs/aster-std/src/device/tty/driver.rs\n@@ -1,4 +1,4 @@\n-pub use jinux_frame::arch::console::register_console_input_callback;\n+pub use aster_frame::arch::console::register_console_input_callback;\n use spin::Once;\n \n use crate::{\n@@ -9,7 +9,7 @@ use crate::{\n pub static TTY_DRIVER: Once<Arc<TtyDriver>> = Once::new();\n \n pub(super) fn init() {\n-    for (_, device) in jinux_console::all_devices() {\n+    for (_, device) in aster_console::all_devices() {\n         device.register_callback(&console_input_callback)\n     }\n     let tty_driver = Arc::new(TtyDriver::new());\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/aster-std/src/device/tty/line_discipline.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/device/tty/line_discipline.rs\nrename to services/libs/aster-std/src/device/tty/line_discipline.rs\nindex 7764f4eb5b..29ace51903 100644\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/aster-std/src/device/tty/line_discipline.rs\n@@ -6,7 +6,7 @@ use crate::process::signal::{Pollee, Poller};\n use crate::thread::work_queue::work_item::WorkItem;\n use crate::thread::work_queue::{submit_work_item, WorkPriority};\n use alloc::format;\n-use jinux_frame::trap::disable_local;\n+use aster_frame::trap::disable_local;\n use ringbuf::{ring_buffer::RbBase, Rb, StaticRb};\n \n use super::termio::{KernelTermios, WinSize, CC_C_CHAR};\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/aster-std/src/device/tty/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/device/tty/mod.rs\nrename to services/libs/aster-std/src/device/tty/mod.rs\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/aster-std/src/device/tty/termio.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/device/tty/termio.rs\nrename to services/libs/aster-std/src/device/tty/termio.rs\ndiff --git a/services/libs/jinux-std/src/device/urandom.rs b/services/libs/aster-std/src/device/urandom.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/device/urandom.rs\nrename to services/libs/aster-std/src/device/urandom.rs\ndiff --git a/services/libs/jinux-std/src/device/zero.rs b/services/libs/aster-std/src/device/zero.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/device/zero.rs\nrename to services/libs/aster-std/src/device/zero.rs\ndiff --git a/services/libs/jinux-std/src/driver/mod.rs b/services/libs/aster-std/src/driver/mod.rs\nsimilarity index 88%\nrename from services/libs/jinux-std/src/driver/mod.rs\nrename to services/libs/aster-std/src/driver/mod.rs\nindex 3c49bf8ec5..4a49e8285f 100644\n--- a/services/libs/jinux-std/src/driver/mod.rs\n+++ b/services/libs/aster-std/src/driver/mod.rs\n@@ -2,14 +2,14 @@ use log::info;\n \n pub fn init() {\n     // print all the input device to make sure input crate will compile\n-    for (name, _) in jinux_input::all_devices() {\n+    for (name, _) in aster_input::all_devices() {\n         info!(\"Found Input device, name:{}\", name);\n     }\n }\n \n #[allow(unused)]\n fn block_device_test() {\n-    for (_, device) in jinux_block::all_devices() {\n+    for (_, device) in aster_block::all_devices() {\n         let mut write_buffer = [0u8; 512];\n         let mut read_buffer = [0u8; 512];\n         info!(\"write_buffer address:{:x}\", write_buffer.as_ptr() as usize);\ndiff --git a/services/libs/jinux-std/src/error.rs b/services/libs/aster-std/src/error.rs\nsimilarity index 91%\nrename from services/libs/jinux-std/src/error.rs\nrename to services/libs/aster-std/src/error.rs\nindex 2827c5afa4..679bd83a46 100644\n--- a/services/libs/jinux-std/src/error.rs\n+++ b/services/libs/aster-std/src/error.rs\n@@ -178,15 +178,15 @@ impl From<Errno> for Error {\n     }\n }\n \n-impl From<jinux_frame::Error> for Error {\n-    fn from(frame_error: jinux_frame::Error) -> Self {\n+impl From<aster_frame::Error> for Error {\n+    fn from(frame_error: aster_frame::Error) -> Self {\n         match frame_error {\n-            jinux_frame::Error::AccessDenied => Error::new(Errno::EFAULT),\n-            jinux_frame::Error::NoMemory => Error::new(Errno::ENOMEM),\n-            jinux_frame::Error::InvalidArgs => Error::new(Errno::EINVAL),\n-            jinux_frame::Error::IoError => Error::new(Errno::EIO),\n-            jinux_frame::Error::NotEnoughResources => Error::new(Errno::EBUSY),\n-            jinux_frame::Error::PageFault => Error::new(Errno::EFAULT),\n+            aster_frame::Error::AccessDenied => Error::new(Errno::EFAULT),\n+            aster_frame::Error::NoMemory => Error::new(Errno::ENOMEM),\n+            aster_frame::Error::InvalidArgs => Error::new(Errno::EINVAL),\n+            aster_frame::Error::IoError => Error::new(Errno::EIO),\n+            aster_frame::Error::NotEnoughResources => Error::new(Errno::EBUSY),\n+            aster_frame::Error::PageFault => Error::new(Errno::EFAULT),\n         }\n     }\n }\n@@ -237,16 +237,16 @@ impl From<cpio_decoder::error::Error> for Error {\n     }\n }\n \n-impl From<Error> for jinux_frame::Error {\n+impl From<Error> for aster_frame::Error {\n     fn from(error: Error) -> Self {\n         match error.errno {\n-            Errno::EACCES => jinux_frame::Error::AccessDenied,\n-            Errno::EIO => jinux_frame::Error::IoError,\n-            Errno::ENOMEM => jinux_frame::Error::NoMemory,\n-            Errno::EFAULT => jinux_frame::Error::PageFault,\n-            Errno::EINVAL => jinux_frame::Error::InvalidArgs,\n-            Errno::EBUSY => jinux_frame::Error::NotEnoughResources,\n-            _ => jinux_frame::Error::InvalidArgs,\n+            Errno::EACCES => aster_frame::Error::AccessDenied,\n+            Errno::EIO => aster_frame::Error::IoError,\n+            Errno::ENOMEM => aster_frame::Error::NoMemory,\n+            Errno::EFAULT => aster_frame::Error::PageFault,\n+            Errno::EINVAL => aster_frame::Error::InvalidArgs,\n+            Errno::EBUSY => aster_frame::Error::NotEnoughResources,\n+            _ => aster_frame::Error::InvalidArgs,\n         }\n     }\n }\ndiff --git a/services/libs/jinux-std/src/events/events.rs b/services/libs/aster-std/src/events/events.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/events/events.rs\nrename to services/libs/aster-std/src/events/events.rs\ndiff --git a/services/libs/jinux-std/src/events/io_events.rs b/services/libs/aster-std/src/events/io_events.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/events/io_events.rs\nrename to services/libs/aster-std/src/events/io_events.rs\ndiff --git a/services/libs/jinux-std/src/events/mod.rs b/services/libs/aster-std/src/events/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/events/mod.rs\nrename to services/libs/aster-std/src/events/mod.rs\ndiff --git a/services/libs/jinux-std/src/events/observer.rs b/services/libs/aster-std/src/events/observer.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/events/observer.rs\nrename to services/libs/aster-std/src/events/observer.rs\ndiff --git a/services/libs/jinux-std/src/events/subject.rs b/services/libs/aster-std/src/events/subject.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/events/subject.rs\nrename to services/libs/aster-std/src/events/subject.rs\ndiff --git a/services/libs/jinux-std/src/fs/device.rs b/services/libs/aster-std/src/fs/device.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/device.rs\nrename to services/libs/aster-std/src/fs/device.rs\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/aster-std/src/fs/devpts/mod.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/fs/devpts/mod.rs\nrename to services/libs/aster-std/src/fs/devpts/mod.rs\nindex 25d115d44e..7b84d3efff 100644\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/aster-std/src/fs/devpts/mod.rs\n@@ -6,9 +6,9 @@ use crate::fs::utils::{\n };\n use crate::prelude::*;\n \n+use aster_frame::vm::VmFrame;\n+use aster_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n use core::time::Duration;\n-use jinux_frame::vm::VmFrame;\n-use jinux_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n \n use self::ptmx::Ptmx;\n use self::slave::PtySlaveInode;\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/aster-std/src/fs/devpts/ptmx.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/devpts/ptmx.rs\nrename to services/libs/aster-std/src/fs/devpts/ptmx.rs\ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/aster-std/src/fs/devpts/slave.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/devpts/slave.rs\nrename to services/libs/aster-std/src/fs/devpts/slave.rs\ndiff --git a/services/libs/jinux-std/src/fs/epoll/epoll_file.rs b/services/libs/aster-std/src/fs/epoll/epoll_file.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/epoll/epoll_file.rs\nrename to services/libs/aster-std/src/fs/epoll/epoll_file.rs\ndiff --git a/services/libs/jinux-std/src/fs/epoll/mod.rs b/services/libs/aster-std/src/fs/epoll/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/epoll/mod.rs\nrename to services/libs/aster-std/src/fs/epoll/mod.rs\ndiff --git a/services/libs/jinux-std/src/fs/file_handle.rs b/services/libs/aster-std/src/fs/file_handle.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/file_handle.rs\nrename to services/libs/aster-std/src/fs/file_handle.rs\ndiff --git a/services/libs/jinux-std/src/fs/file_table.rs b/services/libs/aster-std/src/fs/file_table.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/fs/file_table.rs\nrename to services/libs/aster-std/src/fs/file_table.rs\nindex 93e622df3d..b3b910ed4e 100644\n--- a/services/libs/jinux-std/src/fs/file_table.rs\n+++ b/services/libs/aster-std/src/fs/file_table.rs\n@@ -2,8 +2,8 @@ use crate::events::{Events, Observer, Subject};\n use crate::net::socket::Socket;\n use crate::prelude::*;\n \n+use aster_util::slot_vec::SlotVec;\n use core::cell::Cell;\n-use jinux_util::slot_vec::SlotVec;\n \n use super::file_handle::FileLike;\n use super::fs_resolver::{FsPath, FsResolver, AT_FDCWD};\ndiff --git a/services/libs/jinux-std/src/fs/fs_resolver.rs b/services/libs/aster-std/src/fs/fs_resolver.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/fs_resolver.rs\nrename to services/libs/aster-std/src/fs/fs_resolver.rs\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\nrename to services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\nindex fae4407c34..f554f46213 100644\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/dyn_cap.rs\n@@ -1,7 +1,7 @@\n use crate::events::IoEvents;\n use crate::prelude::*;\n use crate::process::signal::Poller;\n-use jinux_rights::{Rights, TRights};\n+use aster_rights::{Rights, TRights};\n \n use super::*;\n \ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/aster-std/src/fs/inode_handle/mod.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/fs/inode_handle/mod.rs\nrename to services/libs/aster-std/src/fs/inode_handle/mod.rs\nindex 665d6f4916..e84dba0a22 100644\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/mod.rs\n@@ -13,7 +13,7 @@ use crate::fs::utils::{\n };\n use crate::prelude::*;\n use crate::process::signal::Poller;\n-use jinux_rights::Rights;\n+use aster_rights::Rights;\n \n #[derive(Debug)]\n pub struct InodeHandle<R = Rights>(Arc<InodeHandle_>, R);\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/static_cap.rs b/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\nsimilarity index 87%\nrename from services/libs/jinux-std/src/fs/inode_handle/static_cap.rs\nrename to services/libs/aster-std/src/fs/inode_handle/static_cap.rs\nindex dcd525df70..1744f4815e 100644\n--- a/services/libs/jinux-std/src/fs/inode_handle/static_cap.rs\n+++ b/services/libs/aster-std/src/fs/inode_handle/static_cap.rs\n@@ -1,6 +1,6 @@\n use crate::prelude::*;\n-use jinux_rights::{Read, TRightSet, TRights, Write};\n-use jinux_rights_proc::require;\n+use aster_rights::{Read, TRightSet, TRights, Write};\n+use aster_rights_proc::require;\n \n use super::*;\n \ndiff --git a/services/libs/jinux-std/src/fs/mod.rs b/services/libs/aster-std/src/fs/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/mod.rs\nrename to services/libs/aster-std/src/fs/mod.rs\ndiff --git a/services/libs/jinux-std/src/fs/pipe.rs b/services/libs/aster-std/src/fs/pipe.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/pipe.rs\nrename to services/libs/aster-std/src/fs/pipe.rs\ndiff --git a/services/libs/jinux-std/src/fs/procfs/mod.rs b/services/libs/aster-std/src/fs/procfs/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/procfs/mod.rs\nrename to services/libs/aster-std/src/fs/procfs/mod.rs\ndiff --git a/services/libs/jinux-std/src/fs/procfs/pid/comm.rs b/services/libs/aster-std/src/fs/procfs/pid/comm.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/procfs/pid/comm.rs\nrename to services/libs/aster-std/src/fs/procfs/pid/comm.rs\ndiff --git a/services/libs/jinux-std/src/fs/procfs/pid/exe.rs b/services/libs/aster-std/src/fs/procfs/pid/exe.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/procfs/pid/exe.rs\nrename to services/libs/aster-std/src/fs/procfs/pid/exe.rs\ndiff --git a/services/libs/jinux-std/src/fs/procfs/pid/fd.rs b/services/libs/aster-std/src/fs/procfs/pid/fd.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/procfs/pid/fd.rs\nrename to services/libs/aster-std/src/fs/procfs/pid/fd.rs\ndiff --git a/services/libs/jinux-std/src/fs/procfs/pid/mod.rs b/services/libs/aster-std/src/fs/procfs/pid/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/procfs/pid/mod.rs\nrename to services/libs/aster-std/src/fs/procfs/pid/mod.rs\ndiff --git a/services/libs/jinux-std/src/fs/procfs/self_.rs b/services/libs/aster-std/src/fs/procfs/self_.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/procfs/self_.rs\nrename to services/libs/aster-std/src/fs/procfs/self_.rs\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/builder.rs b/services/libs/aster-std/src/fs/procfs/template/builder.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/procfs/template/builder.rs\nrename to services/libs/aster-std/src/fs/procfs/template/builder.rs\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/aster-std/src/fs/procfs/template/dir.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/fs/procfs/template/dir.rs\nrename to services/libs/aster-std/src/fs/procfs/template/dir.rs\nindex 2f00ee35e3..f14d38a149 100644\n--- a/services/libs/jinux-std/src/fs/procfs/template/dir.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/dir.rs\n@@ -1,5 +1,5 @@\n+use aster_util::slot_vec::SlotVec;\n use core::time::Duration;\n-use jinux_util::slot_vec::SlotVec;\n \n use crate::fs::device::Device;\n use crate::fs::utils::{DirentVisitor, FileSystem, Inode, InodeMode, InodeType, Metadata};\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/file.rs b/services/libs/aster-std/src/fs/procfs/template/file.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/fs/procfs/template/file.rs\nrename to services/libs/aster-std/src/fs/procfs/template/file.rs\nindex cb6fe1179a..f583d9d69f 100644\n--- a/services/libs/jinux-std/src/fs/procfs/template/file.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/file.rs\n@@ -1,5 +1,5 @@\n+use aster_frame::vm::VmFrame;\n use core::time::Duration;\n-use jinux_frame::vm::VmFrame;\n \n use crate::fs::utils::{FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata};\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/mod.rs b/services/libs/aster-std/src/fs/procfs/template/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/procfs/template/mod.rs\nrename to services/libs/aster-std/src/fs/procfs/template/mod.rs\ndiff --git a/services/libs/jinux-std/src/fs/procfs/template/sym.rs b/services/libs/aster-std/src/fs/procfs/template/sym.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/fs/procfs/template/sym.rs\nrename to services/libs/aster-std/src/fs/procfs/template/sym.rs\nindex 355a029046..01a9867e00 100644\n--- a/services/libs/jinux-std/src/fs/procfs/template/sym.rs\n+++ b/services/libs/aster-std/src/fs/procfs/template/sym.rs\n@@ -1,5 +1,5 @@\n+use aster_frame::vm::VmFrame;\n use core::time::Duration;\n-use jinux_frame::vm::VmFrame;\n \n use crate::fs::utils::{FileSystem, Inode, InodeMode, InodeType, IoctlCmd, Metadata};\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/aster-std/src/fs/ramfs/fs.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/fs/ramfs/fs.rs\nrename to services/libs/aster-std/src/fs/ramfs/fs.rs\nindex 9d80d7d843..93467c71de 100644\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/aster-std/src/fs/ramfs/fs.rs\n@@ -1,10 +1,10 @@\n use alloc::str;\n+use aster_frame::sync::{RwLock, RwLockWriteGuard};\n+use aster_frame::vm::{VmFrame, VmIo};\n+use aster_rights::Full;\n+use aster_util::slot_vec::SlotVec;\n use core::sync::atomic::{AtomicUsize, Ordering};\n use core::time::Duration;\n-use jinux_frame::sync::{RwLock, RwLockWriteGuard};\n-use jinux_frame::vm::{VmFrame, VmIo};\n-use jinux_rights::Full;\n-use jinux_util::slot_vec::SlotVec;\n \n use super::*;\n use crate::events::IoEvents;\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/mod.rs b/services/libs/aster-std/src/fs/ramfs/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/ramfs/mod.rs\nrename to services/libs/aster-std/src/fs/ramfs/mod.rs\ndiff --git a/services/libs/jinux-std/src/fs/rootfs.rs b/services/libs/aster-std/src/fs/rootfs.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/rootfs.rs\nrename to services/libs/aster-std/src/fs/rootfs.rs\ndiff --git a/services/libs/jinux-std/src/fs/utils/access_mode.rs b/services/libs/aster-std/src/fs/utils/access_mode.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/fs/utils/access_mode.rs\nrename to services/libs/aster-std/src/fs/utils/access_mode.rs\nindex 3929abd5f6..cbf76ba378 100644\n--- a/services/libs/jinux-std/src/fs/utils/access_mode.rs\n+++ b/services/libs/aster-std/src/fs/utils/access_mode.rs\n@@ -1,5 +1,5 @@\n use crate::prelude::*;\n-use jinux_rights::Rights;\n+use aster_rights::Rights;\n \n #[allow(non_camel_case_types)]\n #[derive(Clone, Copy, Debug)]\ndiff --git a/services/libs/jinux-std/src/fs/utils/channel.rs b/services/libs/aster-std/src/fs/utils/channel.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/fs/utils/channel.rs\nrename to services/libs/aster-std/src/fs/utils/channel.rs\nindex 605096c079..722953cafd 100644\n--- a/services/libs/jinux-std/src/fs/utils/channel.rs\n+++ b/services/libs/aster-std/src/fs/utils/channel.rs\n@@ -1,12 +1,12 @@\n+use aster_rights_proc::require;\n use core::sync::atomic::{AtomicBool, AtomicU32, Ordering};\n-use jinux_rights_proc::require;\n use ringbuf::{HeapConsumer as HeapRbConsumer, HeapProducer as HeapRbProducer, HeapRb};\n \n use crate::events::IoEvents;\n use crate::events::Observer;\n use crate::prelude::*;\n use crate::process::signal::{Pollee, Poller};\n-use jinux_rights::{Read, ReadOp, TRights, Write, WriteOp};\n+use aster_rights::{Read, ReadOp, TRights, Write, WriteOp};\n \n use super::StatusFlags;\n \ndiff --git a/services/libs/jinux-std/src/fs/utils/creation_flags.rs b/services/libs/aster-std/src/fs/utils/creation_flags.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/utils/creation_flags.rs\nrename to services/libs/aster-std/src/fs/utils/creation_flags.rs\ndiff --git a/services/libs/jinux-std/src/fs/utils/dentry.rs b/services/libs/aster-std/src/fs/utils/dentry.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/utils/dentry.rs\nrename to services/libs/aster-std/src/fs/utils/dentry.rs\ndiff --git a/services/libs/jinux-std/src/fs/utils/dirent_visitor.rs b/services/libs/aster-std/src/fs/utils/dirent_visitor.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/utils/dirent_visitor.rs\nrename to services/libs/aster-std/src/fs/utils/dirent_visitor.rs\ndiff --git a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs b/services/libs/aster-std/src/fs/utils/direntry_vec.rs\nsimilarity index 96%\nrename from services/libs/jinux-std/src/fs/utils/direntry_vec.rs\nrename to services/libs/aster-std/src/fs/utils/direntry_vec.rs\nindex 5d139caacd..45c4b6b7ab 100644\n--- a/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\n+++ b/services/libs/aster-std/src/fs/utils/direntry_vec.rs\n@@ -1,7 +1,7 @@\n use super::Inode;\n use crate::prelude::*;\n \n-use jinux_util::slot_vec::SlotVec;\n+use aster_util::slot_vec::SlotVec;\n \n pub trait DirEntryVecExt {\n     /// If the entry is not found by `name`, use `f` to get the inode, then put the entry into vec.\ndiff --git a/services/libs/jinux-std/src/fs/utils/file_creation_mask.rs b/services/libs/aster-std/src/fs/utils/file_creation_mask.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/utils/file_creation_mask.rs\nrename to services/libs/aster-std/src/fs/utils/file_creation_mask.rs\ndiff --git a/services/libs/jinux-std/src/fs/utils/fs.rs b/services/libs/aster-std/src/fs/utils/fs.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/utils/fs.rs\nrename to services/libs/aster-std/src/fs/utils/fs.rs\ndiff --git a/services/libs/jinux-std/src/fs/utils/inode.rs b/services/libs/aster-std/src/fs/utils/inode.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/fs/utils/inode.rs\nrename to services/libs/aster-std/src/fs/utils/inode.rs\nindex 5726442fab..24b06a9de9 100644\n--- a/services/libs/jinux-std/src/fs/utils/inode.rs\n+++ b/services/libs/aster-std/src/fs/utils/inode.rs\n@@ -1,7 +1,7 @@\n+use aster_frame::vm::VmFrame;\n+use aster_rights::Full;\n use core::time::Duration;\n use core2::io::{Error as IoError, ErrorKind as IoErrorKind, Result as IoResult, Write};\n-use jinux_frame::vm::VmFrame;\n-use jinux_rights::Full;\n \n use super::{DirentVisitor, FileSystem, IoctlCmd, SuperBlock};\n use crate::events::IoEvents;\ndiff --git a/services/libs/jinux-std/src/fs/utils/ioctl.rs b/services/libs/aster-std/src/fs/utils/ioctl.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/utils/ioctl.rs\nrename to services/libs/aster-std/src/fs/utils/ioctl.rs\ndiff --git a/services/libs/jinux-std/src/fs/utils/mod.rs b/services/libs/aster-std/src/fs/utils/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/utils/mod.rs\nrename to services/libs/aster-std/src/fs/utils/mod.rs\ndiff --git a/services/libs/jinux-std/src/fs/utils/mount.rs b/services/libs/aster-std/src/fs/utils/mount.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/utils/mount.rs\nrename to services/libs/aster-std/src/fs/utils/mount.rs\ndiff --git a/services/libs/jinux-std/src/fs/utils/page_cache.rs b/services/libs/aster-std/src/fs/utils/page_cache.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/fs/utils/page_cache.rs\nrename to services/libs/aster-std/src/fs/utils/page_cache.rs\nindex 0d62fc0f22..f22f9ab98d 100644\n--- a/services/libs/jinux-std/src/fs/utils/page_cache.rs\n+++ b/services/libs/aster-std/src/fs/utils/page_cache.rs\n@@ -1,10 +1,10 @@\n use super::Inode;\n use crate::prelude::*;\n use crate::vm::vmo::{get_page_idx_range, Pager, Vmo, VmoFlags, VmoOptions};\n-use jinux_rights::Full;\n+use aster_rights::Full;\n \n+use aster_frame::vm::{VmAllocOptions, VmFrame};\n use core::ops::Range;\n-use jinux_frame::vm::{VmAllocOptions, VmFrame};\n use lru::LruCache;\n \n pub struct PageCache {\ndiff --git a/services/libs/jinux-std/src/fs/utils/status_flags.rs b/services/libs/aster-std/src/fs/utils/status_flags.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/fs/utils/status_flags.rs\nrename to services/libs/aster-std/src/fs/utils/status_flags.rs\ndiff --git a/services/libs/jinux-std/src/lib.rs b/services/libs/aster-std/src/lib.rs\nsimilarity index 88%\nrename from services/libs/jinux-std/src/lib.rs\nrename to services/libs/aster-std/src/lib.rs\nindex b79b0e1b34..5a1b9c2cb3 100644\n--- a/services/libs/jinux-std/src/lib.rs\n+++ b/services/libs/aster-std/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The std library of jinux\n+//! The std library of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n #![allow(dead_code)]\n@@ -28,7 +28,7 @@ use crate::{\n         Thread,\n     },\n };\n-use jinux_frame::{\n+use aster_frame::{\n     arch::qemu::{exit_qemu, QemuExitCode},\n     boot,\n };\n@@ -82,7 +82,7 @@ fn init_thread() {\n     }));\n     thread.join();\n     info!(\n-        \"[jinux-std/lib.rs] spawn kernel thread, tid = {}\",\n+        \"[aster-std/lib.rs] spawn kernel thread, tid = {}\",\n         thread.tid()\n     );\n     thread::work_queue::init();\n@@ -125,12 +125,10 @@ fn print_banner() {\n     println!(\"\\x1B[36m\");\n     println!(\n         r\"\n-       __   __  .__   __.  __    __  ___   ___ \n-      |  | |  | |  \\ |  | |  |  |  | \\  \\ /  / \n-      |  | |  | |   \\|  | |  |  |  |  \\  V  /  \n-.--.  |  | |  | |  . `  | |  |  |  |   >   <   \n-|  `--'  | |  | |  |\\   | |  `--'  |  /  .  \\  \n- \\______/  |__| |__| \\__|  \\______/  /__/ \\__\\                                                                                            \n+   _   ___ _____ ___ ___ ___ _  _   _   ___ \n+  /_\\ / __|_   _| __| _ \\_ _| \\| | /_\\ / __|\n+ / _ \\\\__ \\ | | | _||   /| || .` |/ _ \\\\__ \\\n+/_/ \\_\\___/ |_| |___|_|_\\___|_|\\_/_/ \\_\\___/                                                                                                                                    \n \"\n     );\n     println!(\"\\x1B[0m\");\ndiff --git a/services/libs/jinux-std/src/net/iface/any_socket.rs b/services/libs/aster-std/src/net/iface/any_socket.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/iface/any_socket.rs\nrename to services/libs/aster-std/src/net/iface/any_socket.rs\ndiff --git a/services/libs/jinux-std/src/net/iface/common.rs b/services/libs/aster-std/src/net/iface/common.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/iface/common.rs\nrename to services/libs/aster-std/src/net/iface/common.rs\ndiff --git a/services/libs/jinux-std/src/net/iface/loopback.rs b/services/libs/aster-std/src/net/iface/loopback.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/iface/loopback.rs\nrename to services/libs/aster-std/src/net/iface/loopback.rs\ndiff --git a/services/libs/jinux-std/src/net/iface/mod.rs b/services/libs/aster-std/src/net/iface/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/iface/mod.rs\nrename to services/libs/aster-std/src/net/iface/mod.rs\ndiff --git a/services/libs/jinux-std/src/net/iface/time.rs b/services/libs/aster-std/src/net/iface/time.rs\nsimilarity index 76%\nrename from services/libs/jinux-std/src/net/iface/time.rs\nrename to services/libs/aster-std/src/net/iface/time.rs\nindex 4bcc1ff492..d7aced038e 100644\n--- a/services/libs/jinux-std/src/net/iface/time.rs\n+++ b/services/libs/aster-std/src/net/iface/time.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::timer::read_monotonic_milli_seconds;\n+use aster_frame::timer::read_monotonic_milli_seconds;\n \n pub(super) fn get_network_timestamp() -> smoltcp::time::Instant {\n     let millis = read_monotonic_milli_seconds();\ndiff --git a/services/libs/jinux-std/src/net/iface/util.rs b/services/libs/aster-std/src/net/iface/util.rs\nsimilarity index 97%\nrename from services/libs/jinux-std/src/net/iface/util.rs\nrename to services/libs/aster-std/src/net/iface/util.rs\nindex a122696743..d4dd1acac0 100644\n--- a/services/libs/jinux-std/src/net/iface/util.rs\n+++ b/services/libs/aster-std/src/net/iface/util.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::timer::read_monotonic_milli_seconds;\n+use aster_frame::timer::read_monotonic_milli_seconds;\n \n use crate::{\n     prelude::*,\ndiff --git a/services/libs/jinux-std/src/net/iface/virtio.rs b/services/libs/aster-std/src/net/iface/virtio.rs\nsimilarity index 95%\nrename from services/libs/jinux-std/src/net/iface/virtio.rs\nrename to services/libs/aster-std/src/net/iface/virtio.rs\nindex 9b9c82e148..aa49034ff9 100644\n--- a/services/libs/jinux-std/src/net/iface/virtio.rs\n+++ b/services/libs/aster-std/src/net/iface/virtio.rs\n@@ -1,7 +1,7 @@\n use crate::prelude::*;\n-use jinux_frame::sync::SpinLock;\n-use jinux_network::AnyNetworkDevice;\n-use jinux_virtio::device::network::DEVICE_NAME;\n+use aster_frame::sync::SpinLock;\n+use aster_network::AnyNetworkDevice;\n+use aster_virtio::device::network::DEVICE_NAME;\n use smoltcp::{\n     iface::{Config, Routes, SocketHandle, SocketSet},\n     socket::dhcpv4,\n@@ -19,7 +19,7 @@ pub struct IfaceVirtio {\n \n impl IfaceVirtio {\n     pub fn new() -> Arc<Self> {\n-        let virtio_net = jinux_network::get_device(DEVICE_NAME).unwrap();\n+        let virtio_net = aster_network::get_device(DEVICE_NAME).unwrap();\n         let interface = {\n             let mac_addr = virtio_net.lock().mac_addr();\n             let ip_addr = IpCidr::new(wire::IpAddress::Ipv4(wire::Ipv4Address::UNSPECIFIED), 0);\ndiff --git a/services/libs/jinux-std/src/net/mod.rs b/services/libs/aster-std/src/net/mod.rs\nsimilarity index 89%\nrename from services/libs/jinux-std/src/net/mod.rs\nrename to services/libs/aster-std/src/net/mod.rs\nindex dee7122c40..bf368dd371 100644\n--- a/services/libs/jinux-std/src/net/mod.rs\n+++ b/services/libs/aster-std/src/net/mod.rs\n@@ -18,8 +18,8 @@ pub fn init() {\n         vec![iface_virtio, iface_loopback]\n     });\n \n-    for (name, _) in jinux_network::all_devices() {\n-        jinux_network::register_recv_callback(&name, || {\n+    for (name, _) in aster_network::all_devices() {\n+        aster_network::register_recv_callback(&name, || {\n             // TODO: further check that the irq num is the same as iface's irq num\n             let iface_virtio = &IFACES.get().unwrap()[0];\n             iface_virtio.poll();\ndiff --git a/services/libs/jinux-std/src/net/socket/ip/always_some.rs b/services/libs/aster-std/src/net/socket/ip/always_some.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/ip/always_some.rs\nrename to services/libs/aster-std/src/net/socket/ip/always_some.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/ip/common.rs b/services/libs/aster-std/src/net/socket/ip/common.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/ip/common.rs\nrename to services/libs/aster-std/src/net/socket/ip/common.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/ip/datagram/bound.rs b/services/libs/aster-std/src/net/socket/ip/datagram/bound.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/ip/datagram/bound.rs\nrename to services/libs/aster-std/src/net/socket/ip/datagram/bound.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/ip/datagram/mod.rs b/services/libs/aster-std/src/net/socket/ip/datagram/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/ip/datagram/mod.rs\nrename to services/libs/aster-std/src/net/socket/ip/datagram/mod.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/ip/datagram/unbound.rs b/services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/ip/datagram/unbound.rs\nrename to services/libs/aster-std/src/net/socket/ip/datagram/unbound.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/ip/mod.rs b/services/libs/aster-std/src/net/socket/ip/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/ip/mod.rs\nrename to services/libs/aster-std/src/net/socket/ip/mod.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/ip/stream/connected.rs b/services/libs/aster-std/src/net/socket/ip/stream/connected.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/ip/stream/connected.rs\nrename to services/libs/aster-std/src/net/socket/ip/stream/connected.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/ip/stream/connecting.rs b/services/libs/aster-std/src/net/socket/ip/stream/connecting.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/ip/stream/connecting.rs\nrename to services/libs/aster-std/src/net/socket/ip/stream/connecting.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/ip/stream/init.rs b/services/libs/aster-std/src/net/socket/ip/stream/init.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/ip/stream/init.rs\nrename to services/libs/aster-std/src/net/socket/ip/stream/init.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/ip/stream/listen.rs b/services/libs/aster-std/src/net/socket/ip/stream/listen.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/ip/stream/listen.rs\nrename to services/libs/aster-std/src/net/socket/ip/stream/listen.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/ip/stream/mod.rs b/services/libs/aster-std/src/net/socket/ip/stream/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/ip/stream/mod.rs\nrename to services/libs/aster-std/src/net/socket/ip/stream/mod.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/mod.rs b/services/libs/aster-std/src/net/socket/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/mod.rs\nrename to services/libs/aster-std/src/net/socket/mod.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/unix/addr.rs b/services/libs/aster-std/src/net/socket/unix/addr.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/unix/addr.rs\nrename to services/libs/aster-std/src/net/socket/unix/addr.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/unix/mod.rs b/services/libs/aster-std/src/net/socket/unix/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/unix/mod.rs\nrename to services/libs/aster-std/src/net/socket/unix/mod.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/unix/stream/connected.rs b/services/libs/aster-std/src/net/socket/unix/stream/connected.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/unix/stream/connected.rs\nrename to services/libs/aster-std/src/net/socket/unix/stream/connected.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/unix/stream/endpoint.rs b/services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/unix/stream/endpoint.rs\nrename to services/libs/aster-std/src/net/socket/unix/stream/endpoint.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/unix/stream/init.rs b/services/libs/aster-std/src/net/socket/unix/stream/init.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/unix/stream/init.rs\nrename to services/libs/aster-std/src/net/socket/unix/stream/init.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/unix/stream/listener.rs b/services/libs/aster-std/src/net/socket/unix/stream/listener.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/unix/stream/listener.rs\nrename to services/libs/aster-std/src/net/socket/unix/stream/listener.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/unix/stream/mod.rs b/services/libs/aster-std/src/net/socket/unix/stream/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/unix/stream/mod.rs\nrename to services/libs/aster-std/src/net/socket/unix/stream/mod.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/unix/stream/socket.rs b/services/libs/aster-std/src/net/socket/unix/stream/socket.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/unix/stream/socket.rs\nrename to services/libs/aster-std/src/net/socket/unix/stream/socket.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/util/mod.rs b/services/libs/aster-std/src/net/socket/util/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/util/mod.rs\nrename to services/libs/aster-std/src/net/socket/util/mod.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/util/send_recv_flags.rs b/services/libs/aster-std/src/net/socket/util/send_recv_flags.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/util/send_recv_flags.rs\nrename to services/libs/aster-std/src/net/socket/util/send_recv_flags.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/util/shutdown_cmd.rs b/services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/util/shutdown_cmd.rs\nrename to services/libs/aster-std/src/net/socket/util/shutdown_cmd.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/util/sock_options.rs b/services/libs/aster-std/src/net/socket/util/sock_options.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/util/sock_options.rs\nrename to services/libs/aster-std/src/net/socket/util/sock_options.rs\ndiff --git a/services/libs/jinux-std/src/net/socket/util/sockaddr.rs b/services/libs/aster-std/src/net/socket/util/sockaddr.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/net/socket/util/sockaddr.rs\nrename to services/libs/aster-std/src/net/socket/util/sockaddr.rs\ndiff --git a/services/libs/jinux-std/src/prelude.rs b/services/libs/aster-std/src/prelude.rs\nsimilarity index 89%\nrename from services/libs/jinux-std/src/prelude.rs\nrename to services/libs/aster-std/src/prelude.rs\nindex d14de07243..13465285b0 100644\n--- a/services/libs/jinux-std/src/prelude.rs\n+++ b/services/libs/aster-std/src/prelude.rs\n@@ -12,14 +12,14 @@ pub(crate) use alloc::sync::Arc;\n pub(crate) use alloc::sync::Weak;\n pub(crate) use alloc::vec;\n pub(crate) use alloc::vec::Vec;\n+pub(crate) use aster_frame::config::PAGE_SIZE;\n+pub(crate) use aster_frame::sync::{Mutex, MutexGuard, RwLock, SpinLock, SpinLockGuard};\n+pub(crate) use aster_frame::vm::Vaddr;\n pub(crate) use bitflags::bitflags;\n pub(crate) use core::any::Any;\n pub(crate) use core::ffi::CStr;\n pub(crate) use core::fmt::Debug;\n pub(crate) use int_to_c_enum::TryFromInt;\n-pub(crate) use jinux_frame::config::PAGE_SIZE;\n-pub(crate) use jinux_frame::sync::{Mutex, MutexGuard, RwLock, SpinLock, SpinLockGuard};\n-pub(crate) use jinux_frame::vm::Vaddr;\n pub(crate) use log::{debug, error, info, trace, warn};\n pub(crate) use pod::Pod;\n \ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/aster-std/src/process/clone.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/process/clone.rs\nrename to services/libs/aster-std/src/process/clone.rs\nindex 3f6327477f..4f901de00e 100644\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/aster-std/src/process/clone.rs\n@@ -10,10 +10,10 @@ use crate::prelude::*;\n use crate::thread::{allocate_tid, thread_table, Thread, Tid};\n use crate::util::write_val_to_user;\n use crate::vm::vmar::Vmar;\n-use jinux_frame::cpu::UserContext;\n-use jinux_frame::user::UserSpace;\n-use jinux_frame::vm::VmIo;\n-use jinux_rights::Full;\n+use aster_frame::cpu::UserContext;\n+use aster_frame::user::UserSpace;\n+use aster_frame::vm::VmIo;\n+use aster_rights::Full;\n \n bitflags! {\n     pub struct CloneFlags: u32 {\ndiff --git a/services/libs/jinux-std/src/process/credentials/credentials_.rs b/services/libs/aster-std/src/process/credentials/credentials_.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/process/credentials/credentials_.rs\nrename to services/libs/aster-std/src/process/credentials/credentials_.rs\nindex b26584da50..6b4f32e288 100644\n--- a/services/libs/jinux-std/src/process/credentials/credentials_.rs\n+++ b/services/libs/aster-std/src/process/credentials/credentials_.rs\n@@ -2,7 +2,7 @@ use super::group::AtomicGid;\n use super::user::AtomicUid;\n use super::{Gid, Uid};\n use crate::prelude::*;\n-use jinux_frame::sync::{RwLockReadGuard, RwLockWriteGuard};\n+use aster_frame::sync::{RwLockReadGuard, RwLockWriteGuard};\n \n #[derive(Debug)]\n pub(super) struct Credentials_ {\ndiff --git a/services/libs/jinux-std/src/process/credentials/group.rs b/services/libs/aster-std/src/process/credentials/group.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/credentials/group.rs\nrename to services/libs/aster-std/src/process/credentials/group.rs\ndiff --git a/services/libs/jinux-std/src/process/credentials/mod.rs b/services/libs/aster-std/src/process/credentials/mod.rs\nsimilarity index 96%\nrename from services/libs/jinux-std/src/process/credentials/mod.rs\nrename to services/libs/aster-std/src/process/credentials/mod.rs\nindex e346aeb967..f5e162a356 100644\n--- a/services/libs/jinux-std/src/process/credentials/mod.rs\n+++ b/services/libs/aster-std/src/process/credentials/mod.rs\n@@ -4,8 +4,8 @@ mod static_cap;\n mod user;\n \n use crate::prelude::*;\n+use aster_rights::{FullOp, ReadOp, WriteOp};\n use credentials_::Credentials_;\n-use jinux_rights::{FullOp, ReadOp, WriteOp};\n \n pub use group::Gid;\n pub use user::Uid;\ndiff --git a/services/libs/jinux-std/src/process/credentials/static_cap.rs b/services/libs/aster-std/src/process/credentials/static_cap.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/process/credentials/static_cap.rs\nrename to services/libs/aster-std/src/process/credentials/static_cap.rs\nindex ad2162844b..07e9848a33 100644\n--- a/services/libs/jinux-std/src/process/credentials/static_cap.rs\n+++ b/services/libs/aster-std/src/process/credentials/static_cap.rs\n@@ -1,9 +1,9 @@\n use super::credentials_::Credentials_;\n use super::{Credentials, Gid, Uid};\n use crate::prelude::*;\n-use jinux_frame::sync::{RwLockReadGuard, RwLockWriteGuard};\n-use jinux_rights::{Dup, Read, TRights, Write};\n-use jinux_rights_proc::require;\n+use aster_frame::sync::{RwLockReadGuard, RwLockWriteGuard};\n+use aster_rights::{Dup, Read, TRights, Write};\n+use aster_rights_proc::require;\n \n impl<R: TRights> Credentials<R> {\n     /// Creates a root `Credentials`. This method can only be used when creating the first process\ndiff --git a/services/libs/jinux-std/src/process/credentials/user.rs b/services/libs/aster-std/src/process/credentials/user.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/credentials/user.rs\nrename to services/libs/aster-std/src/process/credentials/user.rs\ndiff --git a/services/libs/jinux-std/src/process/exit.rs b/services/libs/aster-std/src/process/exit.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/exit.rs\nrename to services/libs/aster-std/src/process/exit.rs\ndiff --git a/services/libs/jinux-std/src/process/kill.rs b/services/libs/aster-std/src/process/kill.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/kill.rs\nrename to services/libs/aster-std/src/process/kill.rs\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/aster-std/src/process/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/mod.rs\nrename to services/libs/aster-std/src/process/mod.rs\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/builder.rs b/services/libs/aster-std/src/process/posix_thread/builder.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/process/posix_thread/builder.rs\nrename to services/libs/aster-std/src/process/posix_thread/builder.rs\nindex ead10779de..5507dace7b 100644\n--- a/services/libs/jinux-std/src/process/posix_thread/builder.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/builder.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::user::UserSpace;\n+use aster_frame::user::UserSpace;\n \n use crate::{\n     prelude::*,\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/futex.rs b/services/libs/aster-std/src/process/posix_thread/futex.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/process/posix_thread/futex.rs\nrename to services/libs/aster-std/src/process/posix_thread/futex.rs\nindex 33a46b9306..1259f3f3f0 100644\n--- a/services/libs/jinux-std/src/process/posix_thread/futex.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/futex.rs\n@@ -1,6 +1,6 @@\n use core::sync::atomic::{AtomicBool, Ordering};\n \n-use jinux_frame::cpu::num_cpus;\n+use aster_frame::cpu::num_cpus;\n \n use crate::{\n     prelude::*,\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/mod.rs b/services/libs/aster-std/src/process/posix_thread/mod.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/process/posix_thread/mod.rs\nrename to services/libs/aster-std/src/process/posix_thread/mod.rs\nindex 414ab260ef..e936663f7b 100644\n--- a/services/libs/jinux-std/src/process/posix_thread/mod.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/mod.rs\n@@ -10,8 +10,8 @@ use crate::prelude::*;\n use crate::process::signal::constants::SIGCONT;\n use crate::thread::{thread_table, Tid};\n use crate::util::write_val_to_user;\n+use aster_rights::{ReadOp, WriteOp};\n use futex::futex_wake;\n-use jinux_rights::{ReadOp, WriteOp};\n use robust_list::wake_robust_futex;\n \n mod builder;\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/name.rs b/services/libs/aster-std/src/process/posix_thread/name.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/posix_thread/name.rs\nrename to services/libs/aster-std/src/process/posix_thread/name.rs\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/posix_thread_ext.rs b/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\nsimilarity index 97%\nrename from services/libs/jinux-std/src/process/posix_thread/posix_thread_ext.rs\nrename to services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\nindex b093cb2c7a..8003bfbf42 100644\n--- a/services/libs/jinux-std/src/process/posix_thread/posix_thread_ext.rs\n+++ b/services/libs/aster-std/src/process/posix_thread/posix_thread_ext.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::{cpu::UserContext, user::UserSpace};\n+use aster_frame::{cpu::UserContext, user::UserSpace};\n \n use crate::{\n     fs::fs_resolver::{FsPath, FsResolver, AT_FDCWD},\ndiff --git a/services/libs/jinux-std/src/process/posix_thread/robust_list.rs b/services/libs/aster-std/src/process/posix_thread/robust_list.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/posix_thread/robust_list.rs\nrename to services/libs/aster-std/src/process/posix_thread/robust_list.rs\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/aster-std/src/process/process/builder.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/process/builder.rs\nrename to services/libs/aster-std/src/process/process/builder.rs\ndiff --git a/services/libs/jinux-std/src/process/process/job_control.rs b/services/libs/aster-std/src/process/process/job_control.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/process/job_control.rs\nrename to services/libs/aster-std/src/process/process/job_control.rs\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/aster-std/src/process/process/mod.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/process/process/mod.rs\nrename to services/libs/aster-std/src/process/process/mod.rs\nindex b0574666be..64cdeaf2ae 100644\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/aster-std/src/process/process/mod.rs\n@@ -23,8 +23,8 @@ mod process_group;\n mod session;\n mod terminal;\n \n+use aster_rights::Full;\n pub use builder::ProcessBuilder;\n-use jinux_rights::Full;\n pub use job_control::JobControl;\n pub use process_group::ProcessGroup;\n pub use session::Session;\ndiff --git a/services/libs/jinux-std/src/process/process/process_group.rs b/services/libs/aster-std/src/process/process/process_group.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/process/process_group.rs\nrename to services/libs/aster-std/src/process/process/process_group.rs\ndiff --git a/services/libs/jinux-std/src/process/process/session.rs b/services/libs/aster-std/src/process/process/session.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/process/session.rs\nrename to services/libs/aster-std/src/process/process/session.rs\ndiff --git a/services/libs/jinux-std/src/process/process/terminal.rs b/services/libs/aster-std/src/process/process/terminal.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/process/terminal.rs\nrename to services/libs/aster-std/src/process/process/terminal.rs\ndiff --git a/services/libs/jinux-std/src/process/process_filter.rs b/services/libs/aster-std/src/process/process_filter.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/process_filter.rs\nrename to services/libs/aster-std/src/process/process_filter.rs\ndiff --git a/services/libs/jinux-std/src/process/process_table.rs b/services/libs/aster-std/src/process/process_table.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/process_table.rs\nrename to services/libs/aster-std/src/process/process_table.rs\ndiff --git a/services/libs/jinux-std/src/process/process_vm/mod.rs b/services/libs/aster-std/src/process/process_vm/mod.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/process/process_vm/mod.rs\nrename to services/libs/aster-std/src/process/process_vm/mod.rs\nindex 8a90841463..468b7aa7e0 100644\n--- a/services/libs/jinux-std/src/process/process_vm/mod.rs\n+++ b/services/libs/aster-std/src/process/process_vm/mod.rs\n@@ -6,7 +6,7 @@\n \n pub mod user_heap;\n \n-use jinux_rights::Full;\n+use aster_rights::Full;\n use user_heap::UserHeap;\n \n use crate::vm::vmar::Vmar;\ndiff --git a/services/libs/jinux-std/src/process/process_vm/user_heap.rs b/services/libs/aster-std/src/process/process_vm/user_heap.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/process/process_vm/user_heap.rs\nrename to services/libs/aster-std/src/process/process_vm/user_heap.rs\nindex df78f10ea8..7dff106e40 100644\n--- a/services/libs/jinux-std/src/process/process_vm/user_heap.rs\n+++ b/services/libs/aster-std/src/process/process_vm/user_heap.rs\n@@ -7,7 +7,7 @@ use crate::{\n     vm::vmo::{VmoFlags, VmoOptions},\n };\n use align_ext::AlignExt;\n-use jinux_rights::{Full, Rights};\n+use aster_rights::{Full, Rights};\n \n pub const USER_HEAP_BASE: Vaddr = 0x0000_0000_1000_0000;\n pub const USER_HEAP_SIZE_LIMIT: usize = PAGE_SIZE * 1000;\ndiff --git a/services/libs/jinux-std/src/process/program_loader/elf/aux_vec.rs b/services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/program_loader/elf/aux_vec.rs\nrename to services/libs/aster-std/src/process/program_loader/elf/aux_vec.rs\ndiff --git a/services/libs/jinux-std/src/process/program_loader/elf/elf_file.rs b/services/libs/aster-std/src/process/program_loader/elf/elf_file.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/program_loader/elf/elf_file.rs\nrename to services/libs/aster-std/src/process/program_loader/elf/elf_file.rs\ndiff --git a/services/libs/jinux-std/src/process/program_loader/elf/init_stack.rs b/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/process/program_loader/elf/init_stack.rs\nrename to services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\nindex 2f1ce78615..3d53b80534 100644\n--- a/services/libs/jinux-std/src/process/program_loader/elf/init_stack.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/init_stack.rs\n@@ -8,9 +8,9 @@ use crate::{\n     vm::{vmar::Vmar, vmo::VmoOptions},\n };\n use align_ext::AlignExt;\n+use aster_frame::vm::{VmIo, VmPerm};\n+use aster_rights::{Full, Rights};\n use core::mem;\n-use jinux_frame::vm::{VmIo, VmPerm};\n-use jinux_rights::{Full, Rights};\n \n use super::aux_vec::{AuxKey, AuxVec};\n use super::elf_file::Elf;\ndiff --git a/services/libs/jinux-std/src/process/program_loader/elf/load_elf.rs b/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/process/program_loader/elf/load_elf.rs\nrename to services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\nindex d669ab3bdc..af4fdbb695 100644\n--- a/services/libs/jinux-std/src/process/program_loader/elf/load_elf.rs\n+++ b/services/libs/aster-std/src/process/program_loader/elf/load_elf.rs\n@@ -13,9 +13,9 @@ use crate::{\n     vm::{vmar::Vmar, vmo::Vmo},\n };\n use align_ext::AlignExt;\n-use jinux_frame::task::Task;\n-use jinux_frame::vm::{VmIo, VmPerm};\n-use jinux_rights::{Full, Rights};\n+use aster_frame::task::Task;\n+use aster_frame::vm::{VmIo, VmPerm};\n+use aster_rights::{Full, Rights};\n use xmas_elf::program::{self, ProgramHeader64};\n \n use super::elf_file::Elf;\ndiff --git a/services/libs/jinux-std/src/process/program_loader/elf/mod.rs b/services/libs/aster-std/src/process/program_loader/elf/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/program_loader/elf/mod.rs\nrename to services/libs/aster-std/src/process/program_loader/elf/mod.rs\ndiff --git a/services/libs/jinux-std/src/process/program_loader/mod.rs b/services/libs/aster-std/src/process/program_loader/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/program_loader/mod.rs\nrename to services/libs/aster-std/src/process/program_loader/mod.rs\ndiff --git a/services/libs/jinux-std/src/process/program_loader/shebang.rs b/services/libs/aster-std/src/process/program_loader/shebang.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/program_loader/shebang.rs\nrename to services/libs/aster-std/src/process/program_loader/shebang.rs\ndiff --git a/services/libs/jinux-std/src/process/rlimit.rs b/services/libs/aster-std/src/process/rlimit.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/rlimit.rs\nrename to services/libs/aster-std/src/process/rlimit.rs\ndiff --git a/services/libs/jinux-std/src/process/signal/c_types.rs b/services/libs/aster-std/src/process/signal/c_types.rs\nsimilarity index 97%\nrename from services/libs/jinux-std/src/process/signal/c_types.rs\nrename to services/libs/aster-std/src/process/signal/c_types.rs\nindex 60ce41b7d8..15f4a94afc 100644\n--- a/services/libs/jinux-std/src/process/signal/c_types.rs\n+++ b/services/libs/aster-std/src/process/signal/c_types.rs\n@@ -1,8 +1,8 @@\n #![allow(non_camel_case_types)]\n use core::mem;\n \n-use jinux_frame::cpu::GeneralRegs;\n-use jinux_util::{read_union_fields, union_read_ptr::UnionReadPtr};\n+use aster_frame::cpu::GeneralRegs;\n+use aster_util::{read_union_fields, union_read_ptr::UnionReadPtr};\n \n use crate::{\n     prelude::*,\ndiff --git a/services/libs/jinux-std/src/process/signal/constants.rs b/services/libs/aster-std/src/process/signal/constants.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/signal/constants.rs\nrename to services/libs/aster-std/src/process/signal/constants.rs\ndiff --git a/services/libs/jinux-std/src/process/signal/events.rs b/services/libs/aster-std/src/process/signal/events.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/signal/events.rs\nrename to services/libs/aster-std/src/process/signal/events.rs\ndiff --git a/services/libs/jinux-std/src/process/signal/mod.rs b/services/libs/aster-std/src/process/signal/mod.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/process/signal/mod.rs\nrename to services/libs/aster-std/src/process/signal/mod.rs\nindex 8ba2e74da8..6415374fe4 100644\n--- a/services/libs/jinux-std/src/process/signal/mod.rs\n+++ b/services/libs/aster-std/src/process/signal/mod.rs\n@@ -17,9 +17,9 @@ pub use poll::{Pollee, Poller};\n pub use sig_stack::{SigStack, SigStackFlags, SigStackStatus};\n \n use align_ext::AlignExt;\n+use aster_frame::cpu::UserContext;\n+use aster_frame::task::Task;\n use core::mem;\n-use jinux_frame::cpu::UserContext;\n-use jinux_frame::task::Task;\n \n use super::posix_thread::{PosixThread, PosixThreadExt};\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/process/signal/pauser.rs b/services/libs/aster-std/src/process/signal/pauser.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/process/signal/pauser.rs\nrename to services/libs/aster-std/src/process/signal/pauser.rs\nindex a242f89305..c277c895af 100644\n--- a/services/libs/jinux-std/src/process/signal/pauser.rs\n+++ b/services/libs/aster-std/src/process/signal/pauser.rs\n@@ -1,7 +1,7 @@\n use core::sync::atomic::{AtomicBool, Ordering};\n use core::time::Duration;\n \n-use jinux_frame::sync::WaitQueue;\n+use aster_frame::sync::WaitQueue;\n \n use crate::events::Observer;\n use crate::prelude::*;\ndiff --git a/services/libs/jinux-std/src/process/signal/poll.rs b/services/libs/aster-std/src/process/signal/poll.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/signal/poll.rs\nrename to services/libs/aster-std/src/process/signal/poll.rs\ndiff --git a/services/libs/jinux-std/src/process/signal/sig_action.rs b/services/libs/aster-std/src/process/signal/sig_action.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/signal/sig_action.rs\nrename to services/libs/aster-std/src/process/signal/sig_action.rs\ndiff --git a/services/libs/jinux-std/src/process/signal/sig_disposition.rs b/services/libs/aster-std/src/process/signal/sig_disposition.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/signal/sig_disposition.rs\nrename to services/libs/aster-std/src/process/signal/sig_disposition.rs\ndiff --git a/services/libs/jinux-std/src/process/signal/sig_mask.rs b/services/libs/aster-std/src/process/signal/sig_mask.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/signal/sig_mask.rs\nrename to services/libs/aster-std/src/process/signal/sig_mask.rs\ndiff --git a/services/libs/jinux-std/src/process/signal/sig_num.rs b/services/libs/aster-std/src/process/signal/sig_num.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/signal/sig_num.rs\nrename to services/libs/aster-std/src/process/signal/sig_num.rs\ndiff --git a/services/libs/jinux-std/src/process/signal/sig_queues.rs b/services/libs/aster-std/src/process/signal/sig_queues.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/signal/sig_queues.rs\nrename to services/libs/aster-std/src/process/signal/sig_queues.rs\ndiff --git a/services/libs/jinux-std/src/process/signal/sig_stack.rs b/services/libs/aster-std/src/process/signal/sig_stack.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/signal/sig_stack.rs\nrename to services/libs/aster-std/src/process/signal/sig_stack.rs\ndiff --git a/services/libs/jinux-std/src/process/signal/signals/fault.rs b/services/libs/aster-std/src/process/signal/signals/fault.rs\nsimilarity index 96%\nrename from services/libs/jinux-std/src/process/signal/signals/fault.rs\nrename to services/libs/aster-std/src/process/signal/signals/fault.rs\nindex 3cf90533ac..799af8113c 100644\n--- a/services/libs/jinux-std/src/process/signal/signals/fault.rs\n+++ b/services/libs/aster-std/src/process/signal/signals/fault.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::cpu::{CpuException, CpuExceptionInfo};\n-use jinux_frame::cpu::{\n+use aster_frame::cpu::{CpuException, CpuExceptionInfo};\n+use aster_frame::cpu::{\n     ALIGNMENT_CHECK, BOUND_RANGE_EXCEEDED, DIVIDE_BY_ZERO, GENERAL_PROTECTION_FAULT,\n     INVALID_OPCODE, PAGE_FAULT, SIMD_FLOATING_POINT_EXCEPTION, X87_FLOATING_POINT_EXCEPTION,\n };\ndiff --git a/services/libs/jinux-std/src/process/signal/signals/kernel.rs b/services/libs/aster-std/src/process/signal/signals/kernel.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/signal/signals/kernel.rs\nrename to services/libs/aster-std/src/process/signal/signals/kernel.rs\ndiff --git a/services/libs/jinux-std/src/process/signal/signals/mod.rs b/services/libs/aster-std/src/process/signal/signals/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/signal/signals/mod.rs\nrename to services/libs/aster-std/src/process/signal/signals/mod.rs\ndiff --git a/services/libs/jinux-std/src/process/signal/signals/user.rs b/services/libs/aster-std/src/process/signal/signals/user.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/signal/signals/user.rs\nrename to services/libs/aster-std/src/process/signal/signals/user.rs\ndiff --git a/services/libs/jinux-std/src/process/status.rs b/services/libs/aster-std/src/process/status.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/status.rs\nrename to services/libs/aster-std/src/process/status.rs\ndiff --git a/services/libs/jinux-std/src/process/term_status.rs b/services/libs/aster-std/src/process/term_status.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/term_status.rs\nrename to services/libs/aster-std/src/process/term_status.rs\ndiff --git a/services/libs/jinux-std/src/process/wait.rs b/services/libs/aster-std/src/process/wait.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/process/wait.rs\nrename to services/libs/aster-std/src/process/wait.rs\ndiff --git a/services/libs/jinux-std/src/sched/mod.rs b/services/libs/aster-std/src/sched/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/sched/mod.rs\nrename to services/libs/aster-std/src/sched/mod.rs\ndiff --git a/services/libs/jinux-std/src/sched/priority_scheduler.rs b/services/libs/aster-std/src/sched/priority_scheduler.rs\nsimilarity index 96%\nrename from services/libs/jinux-std/src/sched/priority_scheduler.rs\nrename to services/libs/aster-std/src/sched/priority_scheduler.rs\nindex 061b406ae7..4523c1d98f 100644\n--- a/services/libs/jinux-std/src/sched/priority_scheduler.rs\n+++ b/services/libs/aster-std/src/sched/priority_scheduler.rs\n@@ -1,6 +1,6 @@\n use crate::prelude::*;\n+use aster_frame::task::{set_scheduler, Scheduler, Task, TaskAdapter};\n use intrusive_collections::LinkedList;\n-use jinux_frame::task::{set_scheduler, Scheduler, Task, TaskAdapter};\n \n pub fn init() {\n     let preempt_scheduler = Box::new(PreemptScheduler::new());\ndiff --git a/services/libs/jinux-std/src/syscall/accept.rs b/services/libs/aster-std/src/syscall/accept.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/accept.rs\nrename to services/libs/aster-std/src/syscall/accept.rs\ndiff --git a/services/libs/jinux-std/src/syscall/access.rs b/services/libs/aster-std/src/syscall/access.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/access.rs\nrename to services/libs/aster-std/src/syscall/access.rs\ndiff --git a/services/libs/jinux-std/src/syscall/arch_prctl.rs b/services/libs/aster-std/src/syscall/arch_prctl.rs\nsimilarity index 97%\nrename from services/libs/jinux-std/src/syscall/arch_prctl.rs\nrename to services/libs/aster-std/src/syscall/arch_prctl.rs\nindex 9e9f8c1195..c94a4a7e06 100644\n--- a/services/libs/jinux-std/src/syscall/arch_prctl.rs\n+++ b/services/libs/aster-std/src/syscall/arch_prctl.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use crate::syscall::SYS_ARCH_PRCTL;\n use crate::{log_syscall_entry, prelude::*};\ndiff --git a/services/libs/jinux-std/src/syscall/bind.rs b/services/libs/aster-std/src/syscall/bind.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/bind.rs\nrename to services/libs/aster-std/src/syscall/bind.rs\ndiff --git a/services/libs/jinux-std/src/syscall/brk.rs b/services/libs/aster-std/src/syscall/brk.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/brk.rs\nrename to services/libs/aster-std/src/syscall/brk.rs\ndiff --git a/services/libs/jinux-std/src/syscall/chdir.rs b/services/libs/aster-std/src/syscall/chdir.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/chdir.rs\nrename to services/libs/aster-std/src/syscall/chdir.rs\ndiff --git a/services/libs/jinux-std/src/syscall/chmod.rs b/services/libs/aster-std/src/syscall/chmod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/chmod.rs\nrename to services/libs/aster-std/src/syscall/chmod.rs\ndiff --git a/services/libs/jinux-std/src/syscall/clock_gettime.rs b/services/libs/aster-std/src/syscall/clock_gettime.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/clock_gettime.rs\nrename to services/libs/aster-std/src/syscall/clock_gettime.rs\ndiff --git a/services/libs/jinux-std/src/syscall/clock_nanosleep.rs b/services/libs/aster-std/src/syscall/clock_nanosleep.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/clock_nanosleep.rs\nrename to services/libs/aster-std/src/syscall/clock_nanosleep.rs\ndiff --git a/services/libs/jinux-std/src/syscall/clone.rs b/services/libs/aster-std/src/syscall/clone.rs\nsimilarity index 96%\nrename from services/libs/jinux-std/src/syscall/clone.rs\nrename to services/libs/aster-std/src/syscall/clone.rs\nindex 655715b64b..fc9d9f2402 100644\n--- a/services/libs/jinux-std/src/syscall/clone.rs\n+++ b/services/libs/aster-std/src/syscall/clone.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use crate::log_syscall_entry;\n use crate::process::{clone_child, CloneArgs, CloneFlags};\ndiff --git a/services/libs/jinux-std/src/syscall/close.rs b/services/libs/aster-std/src/syscall/close.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/close.rs\nrename to services/libs/aster-std/src/syscall/close.rs\ndiff --git a/services/libs/jinux-std/src/syscall/connect.rs b/services/libs/aster-std/src/syscall/connect.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/connect.rs\nrename to services/libs/aster-std/src/syscall/connect.rs\ndiff --git a/services/libs/jinux-std/src/syscall/constants.rs b/services/libs/aster-std/src/syscall/constants.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/constants.rs\nrename to services/libs/aster-std/src/syscall/constants.rs\ndiff --git a/services/libs/jinux-std/src/syscall/dup.rs b/services/libs/aster-std/src/syscall/dup.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/dup.rs\nrename to services/libs/aster-std/src/syscall/dup.rs\ndiff --git a/services/libs/jinux-std/src/syscall/epoll.rs b/services/libs/aster-std/src/syscall/epoll.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/epoll.rs\nrename to services/libs/aster-std/src/syscall/epoll.rs\ndiff --git a/services/libs/jinux-std/src/syscall/execve.rs b/services/libs/aster-std/src/syscall/execve.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/syscall/execve.rs\nrename to services/libs/aster-std/src/syscall/execve.rs\nindex a4b624572d..b15e8579d8 100644\n--- a/services/libs/jinux-std/src/syscall/execve.rs\n+++ b/services/libs/aster-std/src/syscall/execve.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::cpu::UserContext;\n-use jinux_rights::WriteOp;\n+use aster_frame::cpu::UserContext;\n+use aster_rights::WriteOp;\n \n use super::{constants::*, SyscallReturn};\n use crate::fs::file_table::FileDescripter;\ndiff --git a/services/libs/jinux-std/src/syscall/exit.rs b/services/libs/aster-std/src/syscall/exit.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/exit.rs\nrename to services/libs/aster-std/src/syscall/exit.rs\ndiff --git a/services/libs/jinux-std/src/syscall/exit_group.rs b/services/libs/aster-std/src/syscall/exit_group.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/exit_group.rs\nrename to services/libs/aster-std/src/syscall/exit_group.rs\ndiff --git a/services/libs/jinux-std/src/syscall/fcntl.rs b/services/libs/aster-std/src/syscall/fcntl.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/fcntl.rs\nrename to services/libs/aster-std/src/syscall/fcntl.rs\ndiff --git a/services/libs/jinux-std/src/syscall/fork.rs b/services/libs/aster-std/src/syscall/fork.rs\nsimilarity index 93%\nrename from services/libs/jinux-std/src/syscall/fork.rs\nrename to services/libs/aster-std/src/syscall/fork.rs\nindex 11f2a365b1..3fcbaf0478 100644\n--- a/services/libs/jinux-std/src/syscall/fork.rs\n+++ b/services/libs/aster-std/src/syscall/fork.rs\n@@ -3,7 +3,7 @@ use crate::{\n     prelude::*,\n     process::{clone_child, CloneArgs},\n };\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use crate::syscall::SYS_FORK;\n \ndiff --git a/services/libs/jinux-std/src/syscall/futex.rs b/services/libs/aster-std/src/syscall/futex.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/futex.rs\nrename to services/libs/aster-std/src/syscall/futex.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getcwd.rs b/services/libs/aster-std/src/syscall/getcwd.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getcwd.rs\nrename to services/libs/aster-std/src/syscall/getcwd.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getdents64.rs b/services/libs/aster-std/src/syscall/getdents64.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getdents64.rs\nrename to services/libs/aster-std/src/syscall/getdents64.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getegid.rs b/services/libs/aster-std/src/syscall/getegid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getegid.rs\nrename to services/libs/aster-std/src/syscall/getegid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/geteuid.rs b/services/libs/aster-std/src/syscall/geteuid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/geteuid.rs\nrename to services/libs/aster-std/src/syscall/geteuid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getgid.rs b/services/libs/aster-std/src/syscall/getgid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getgid.rs\nrename to services/libs/aster-std/src/syscall/getgid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getgroups.rs b/services/libs/aster-std/src/syscall/getgroups.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getgroups.rs\nrename to services/libs/aster-std/src/syscall/getgroups.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getpeername.rs b/services/libs/aster-std/src/syscall/getpeername.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getpeername.rs\nrename to services/libs/aster-std/src/syscall/getpeername.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getpgrp.rs b/services/libs/aster-std/src/syscall/getpgrp.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getpgrp.rs\nrename to services/libs/aster-std/src/syscall/getpgrp.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getpid.rs b/services/libs/aster-std/src/syscall/getpid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getpid.rs\nrename to services/libs/aster-std/src/syscall/getpid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getppid.rs b/services/libs/aster-std/src/syscall/getppid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getppid.rs\nrename to services/libs/aster-std/src/syscall/getppid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getrandom.rs b/services/libs/aster-std/src/syscall/getrandom.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getrandom.rs\nrename to services/libs/aster-std/src/syscall/getrandom.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getresgid.rs b/services/libs/aster-std/src/syscall/getresgid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getresgid.rs\nrename to services/libs/aster-std/src/syscall/getresgid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getresuid.rs b/services/libs/aster-std/src/syscall/getresuid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getresuid.rs\nrename to services/libs/aster-std/src/syscall/getresuid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getsid.rs b/services/libs/aster-std/src/syscall/getsid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getsid.rs\nrename to services/libs/aster-std/src/syscall/getsid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getsockname.rs b/services/libs/aster-std/src/syscall/getsockname.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getsockname.rs\nrename to services/libs/aster-std/src/syscall/getsockname.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getsockopt.rs b/services/libs/aster-std/src/syscall/getsockopt.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getsockopt.rs\nrename to services/libs/aster-std/src/syscall/getsockopt.rs\ndiff --git a/services/libs/jinux-std/src/syscall/gettid.rs b/services/libs/aster-std/src/syscall/gettid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/gettid.rs\nrename to services/libs/aster-std/src/syscall/gettid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/gettimeofday.rs b/services/libs/aster-std/src/syscall/gettimeofday.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/gettimeofday.rs\nrename to services/libs/aster-std/src/syscall/gettimeofday.rs\ndiff --git a/services/libs/jinux-std/src/syscall/getuid.rs b/services/libs/aster-std/src/syscall/getuid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/getuid.rs\nrename to services/libs/aster-std/src/syscall/getuid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/ioctl.rs b/services/libs/aster-std/src/syscall/ioctl.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/ioctl.rs\nrename to services/libs/aster-std/src/syscall/ioctl.rs\ndiff --git a/services/libs/jinux-std/src/syscall/kill.rs b/services/libs/aster-std/src/syscall/kill.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/kill.rs\nrename to services/libs/aster-std/src/syscall/kill.rs\ndiff --git a/services/libs/jinux-std/src/syscall/link.rs b/services/libs/aster-std/src/syscall/link.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/link.rs\nrename to services/libs/aster-std/src/syscall/link.rs\ndiff --git a/services/libs/jinux-std/src/syscall/listen.rs b/services/libs/aster-std/src/syscall/listen.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/listen.rs\nrename to services/libs/aster-std/src/syscall/listen.rs\ndiff --git a/services/libs/jinux-std/src/syscall/lseek.rs b/services/libs/aster-std/src/syscall/lseek.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/lseek.rs\nrename to services/libs/aster-std/src/syscall/lseek.rs\ndiff --git a/services/libs/jinux-std/src/syscall/madvise.rs b/services/libs/aster-std/src/syscall/madvise.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/madvise.rs\nrename to services/libs/aster-std/src/syscall/madvise.rs\ndiff --git a/services/libs/jinux-std/src/syscall/mkdir.rs b/services/libs/aster-std/src/syscall/mkdir.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/mkdir.rs\nrename to services/libs/aster-std/src/syscall/mkdir.rs\ndiff --git a/services/libs/jinux-std/src/syscall/mmap.rs b/services/libs/aster-std/src/syscall/mmap.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/syscall/mmap.rs\nrename to services/libs/aster-std/src/syscall/mmap.rs\nindex 5b58fe917a..e739bae54d 100644\n--- a/services/libs/jinux-std/src/syscall/mmap.rs\n+++ b/services/libs/aster-std/src/syscall/mmap.rs\n@@ -5,8 +5,8 @@ use crate::vm::perms::VmPerms;\n use crate::vm::vmo::{VmoChildOptions, VmoOptions, VmoRightsOp};\n use crate::{log_syscall_entry, prelude::*};\n use align_ext::AlignExt;\n-use jinux_frame::vm::VmPerm;\n-use jinux_rights::Rights;\n+use aster_frame::vm::VmPerm;\n+use aster_rights::Rights;\n \n use crate::syscall::SYS_MMAP;\n \ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/aster-std/src/syscall/mod.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/syscall/mod.rs\nrename to services/libs/aster-std/src/syscall/mod.rs\nindex dcd62aabbd..731b413214 100644\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/aster-std/src/syscall/mod.rs\n@@ -69,7 +69,7 @@ use crate::syscall::wait4::sys_wait4;\n use crate::syscall::waitid::sys_waitid;\n use crate::syscall::write::sys_write;\n use crate::syscall::writev::sys_writev;\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use self::accept::sys_accept;\n use self::bind::sys_bind;\ndiff --git a/services/libs/jinux-std/src/syscall/mprotect.rs b/services/libs/aster-std/src/syscall/mprotect.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/mprotect.rs\nrename to services/libs/aster-std/src/syscall/mprotect.rs\ndiff --git a/services/libs/jinux-std/src/syscall/munmap.rs b/services/libs/aster-std/src/syscall/munmap.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/munmap.rs\nrename to services/libs/aster-std/src/syscall/munmap.rs\ndiff --git a/services/libs/jinux-std/src/syscall/open.rs b/services/libs/aster-std/src/syscall/open.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/open.rs\nrename to services/libs/aster-std/src/syscall/open.rs\ndiff --git a/services/libs/jinux-std/src/syscall/pause.rs b/services/libs/aster-std/src/syscall/pause.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/pause.rs\nrename to services/libs/aster-std/src/syscall/pause.rs\ndiff --git a/services/libs/jinux-std/src/syscall/pipe.rs b/services/libs/aster-std/src/syscall/pipe.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/pipe.rs\nrename to services/libs/aster-std/src/syscall/pipe.rs\ndiff --git a/services/libs/jinux-std/src/syscall/poll.rs b/services/libs/aster-std/src/syscall/poll.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/poll.rs\nrename to services/libs/aster-std/src/syscall/poll.rs\ndiff --git a/services/libs/jinux-std/src/syscall/prctl.rs b/services/libs/aster-std/src/syscall/prctl.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/prctl.rs\nrename to services/libs/aster-std/src/syscall/prctl.rs\ndiff --git a/services/libs/jinux-std/src/syscall/pread64.rs b/services/libs/aster-std/src/syscall/pread64.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/pread64.rs\nrename to services/libs/aster-std/src/syscall/pread64.rs\ndiff --git a/services/libs/jinux-std/src/syscall/prlimit64.rs b/services/libs/aster-std/src/syscall/prlimit64.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/prlimit64.rs\nrename to services/libs/aster-std/src/syscall/prlimit64.rs\ndiff --git a/services/libs/jinux-std/src/syscall/read.rs b/services/libs/aster-std/src/syscall/read.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/read.rs\nrename to services/libs/aster-std/src/syscall/read.rs\ndiff --git a/services/libs/jinux-std/src/syscall/readlink.rs b/services/libs/aster-std/src/syscall/readlink.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/readlink.rs\nrename to services/libs/aster-std/src/syscall/readlink.rs\ndiff --git a/services/libs/jinux-std/src/syscall/recvfrom.rs b/services/libs/aster-std/src/syscall/recvfrom.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/recvfrom.rs\nrename to services/libs/aster-std/src/syscall/recvfrom.rs\ndiff --git a/services/libs/jinux-std/src/syscall/rename.rs b/services/libs/aster-std/src/syscall/rename.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/rename.rs\nrename to services/libs/aster-std/src/syscall/rename.rs\ndiff --git a/services/libs/jinux-std/src/syscall/rmdir.rs b/services/libs/aster-std/src/syscall/rmdir.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/rmdir.rs\nrename to services/libs/aster-std/src/syscall/rmdir.rs\ndiff --git a/services/libs/jinux-std/src/syscall/rt_sigaction.rs b/services/libs/aster-std/src/syscall/rt_sigaction.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/rt_sigaction.rs\nrename to services/libs/aster-std/src/syscall/rt_sigaction.rs\ndiff --git a/services/libs/jinux-std/src/syscall/rt_sigprocmask.rs b/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/syscall/rt_sigprocmask.rs\nrename to services/libs/aster-std/src/syscall/rt_sigprocmask.rs\nindex 0219d104c2..c39356707c 100644\n--- a/services/libs/jinux-std/src/syscall/rt_sigprocmask.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigprocmask.rs\n@@ -4,7 +4,7 @@ use crate::prelude::*;\n use crate::process::posix_thread::PosixThreadExt;\n use crate::process::signal::constants::{SIGKILL, SIGSTOP};\n use crate::process::signal::sig_mask::SigMask;\n-use jinux_frame::vm::VmIo;\n+use aster_frame::vm::VmIo;\n \n pub fn sys_rt_sigprocmask(\n     how: u32,\ndiff --git a/services/libs/jinux-std/src/syscall/rt_sigreturn.rs b/services/libs/aster-std/src/syscall/rt_sigreturn.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/syscall/rt_sigreturn.rs\nrename to services/libs/aster-std/src/syscall/rt_sigreturn.rs\nindex 4132b5ab7c..c74e6f6e31 100644\n--- a/services/libs/jinux-std/src/syscall/rt_sigreturn.rs\n+++ b/services/libs/aster-std/src/syscall/rt_sigreturn.rs\n@@ -4,7 +4,7 @@ use crate::{\n     process::{posix_thread::PosixThreadExt, signal::c_types::ucontext_t},\n     util::read_val_from_user,\n };\n-use jinux_frame::cpu::UserContext;\n+use aster_frame::cpu::UserContext;\n \n use super::{SyscallReturn, SYS_RT_SIGRETRUN};\n \ndiff --git a/services/libs/jinux-std/src/syscall/sched_yield.rs b/services/libs/aster-std/src/syscall/sched_yield.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/sched_yield.rs\nrename to services/libs/aster-std/src/syscall/sched_yield.rs\ndiff --git a/services/libs/jinux-std/src/syscall/select.rs b/services/libs/aster-std/src/syscall/select.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/select.rs\nrename to services/libs/aster-std/src/syscall/select.rs\ndiff --git a/services/libs/jinux-std/src/syscall/sendto.rs b/services/libs/aster-std/src/syscall/sendto.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/sendto.rs\nrename to services/libs/aster-std/src/syscall/sendto.rs\ndiff --git a/services/libs/jinux-std/src/syscall/set_robust_list.rs b/services/libs/aster-std/src/syscall/set_robust_list.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/set_robust_list.rs\nrename to services/libs/aster-std/src/syscall/set_robust_list.rs\ndiff --git a/services/libs/jinux-std/src/syscall/set_tid_address.rs b/services/libs/aster-std/src/syscall/set_tid_address.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/set_tid_address.rs\nrename to services/libs/aster-std/src/syscall/set_tid_address.rs\ndiff --git a/services/libs/jinux-std/src/syscall/setfsgid.rs b/services/libs/aster-std/src/syscall/setfsgid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/setfsgid.rs\nrename to services/libs/aster-std/src/syscall/setfsgid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/setfsuid.rs b/services/libs/aster-std/src/syscall/setfsuid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/setfsuid.rs\nrename to services/libs/aster-std/src/syscall/setfsuid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/setgid.rs b/services/libs/aster-std/src/syscall/setgid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/setgid.rs\nrename to services/libs/aster-std/src/syscall/setgid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/setgroups.rs b/services/libs/aster-std/src/syscall/setgroups.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/setgroups.rs\nrename to services/libs/aster-std/src/syscall/setgroups.rs\ndiff --git a/services/libs/jinux-std/src/syscall/setpgid.rs b/services/libs/aster-std/src/syscall/setpgid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/setpgid.rs\nrename to services/libs/aster-std/src/syscall/setpgid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/setregid.rs b/services/libs/aster-std/src/syscall/setregid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/setregid.rs\nrename to services/libs/aster-std/src/syscall/setregid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/setresgid.rs b/services/libs/aster-std/src/syscall/setresgid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/setresgid.rs\nrename to services/libs/aster-std/src/syscall/setresgid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/setresuid.rs b/services/libs/aster-std/src/syscall/setresuid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/setresuid.rs\nrename to services/libs/aster-std/src/syscall/setresuid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/setreuid.rs b/services/libs/aster-std/src/syscall/setreuid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/setreuid.rs\nrename to services/libs/aster-std/src/syscall/setreuid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/setsid.rs b/services/libs/aster-std/src/syscall/setsid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/setsid.rs\nrename to services/libs/aster-std/src/syscall/setsid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/setsockopt.rs b/services/libs/aster-std/src/syscall/setsockopt.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/setsockopt.rs\nrename to services/libs/aster-std/src/syscall/setsockopt.rs\ndiff --git a/services/libs/jinux-std/src/syscall/setuid.rs b/services/libs/aster-std/src/syscall/setuid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/setuid.rs\nrename to services/libs/aster-std/src/syscall/setuid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/shutdown.rs b/services/libs/aster-std/src/syscall/shutdown.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/shutdown.rs\nrename to services/libs/aster-std/src/syscall/shutdown.rs\ndiff --git a/services/libs/jinux-std/src/syscall/sigaltstack.rs b/services/libs/aster-std/src/syscall/sigaltstack.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/sigaltstack.rs\nrename to services/libs/aster-std/src/syscall/sigaltstack.rs\ndiff --git a/services/libs/jinux-std/src/syscall/socket.rs b/services/libs/aster-std/src/syscall/socket.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/socket.rs\nrename to services/libs/aster-std/src/syscall/socket.rs\ndiff --git a/services/libs/jinux-std/src/syscall/socketpair.rs b/services/libs/aster-std/src/syscall/socketpair.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/socketpair.rs\nrename to services/libs/aster-std/src/syscall/socketpair.rs\ndiff --git a/services/libs/jinux-std/src/syscall/stat.rs b/services/libs/aster-std/src/syscall/stat.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/stat.rs\nrename to services/libs/aster-std/src/syscall/stat.rs\ndiff --git a/services/libs/jinux-std/src/syscall/statfs.rs b/services/libs/aster-std/src/syscall/statfs.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/statfs.rs\nrename to services/libs/aster-std/src/syscall/statfs.rs\ndiff --git a/services/libs/jinux-std/src/syscall/symlink.rs b/services/libs/aster-std/src/syscall/symlink.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/symlink.rs\nrename to services/libs/aster-std/src/syscall/symlink.rs\ndiff --git a/services/libs/jinux-std/src/syscall/tgkill.rs b/services/libs/aster-std/src/syscall/tgkill.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/tgkill.rs\nrename to services/libs/aster-std/src/syscall/tgkill.rs\ndiff --git a/services/libs/jinux-std/src/syscall/time.rs b/services/libs/aster-std/src/syscall/time.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/time.rs\nrename to services/libs/aster-std/src/syscall/time.rs\ndiff --git a/services/libs/jinux-std/src/syscall/umask.rs b/services/libs/aster-std/src/syscall/umask.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/umask.rs\nrename to services/libs/aster-std/src/syscall/umask.rs\ndiff --git a/services/libs/jinux-std/src/syscall/uname.rs b/services/libs/aster-std/src/syscall/uname.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/uname.rs\nrename to services/libs/aster-std/src/syscall/uname.rs\ndiff --git a/services/libs/jinux-std/src/syscall/unlink.rs b/services/libs/aster-std/src/syscall/unlink.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/unlink.rs\nrename to services/libs/aster-std/src/syscall/unlink.rs\ndiff --git a/services/libs/jinux-std/src/syscall/utimens.rs b/services/libs/aster-std/src/syscall/utimens.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/utimens.rs\nrename to services/libs/aster-std/src/syscall/utimens.rs\ndiff --git a/services/libs/jinux-std/src/syscall/wait4.rs b/services/libs/aster-std/src/syscall/wait4.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/wait4.rs\nrename to services/libs/aster-std/src/syscall/wait4.rs\ndiff --git a/services/libs/jinux-std/src/syscall/waitid.rs b/services/libs/aster-std/src/syscall/waitid.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/waitid.rs\nrename to services/libs/aster-std/src/syscall/waitid.rs\ndiff --git a/services/libs/jinux-std/src/syscall/write.rs b/services/libs/aster-std/src/syscall/write.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/write.rs\nrename to services/libs/aster-std/src/syscall/write.rs\ndiff --git a/services/libs/jinux-std/src/syscall/writev.rs b/services/libs/aster-std/src/syscall/writev.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/syscall/writev.rs\nrename to services/libs/aster-std/src/syscall/writev.rs\ndiff --git a/services/libs/jinux-std/src/thread/exception.rs b/services/libs/aster-std/src/thread/exception.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/thread/exception.rs\nrename to services/libs/aster-std/src/thread/exception.rs\nindex 4bdd22fada..6a690c54af 100644\n--- a/services/libs/jinux-std/src/thread/exception.rs\n+++ b/services/libs/aster-std/src/thread/exception.rs\n@@ -1,8 +1,8 @@\n use crate::prelude::*;\n use crate::process::signal::signals::fault::FaultSignal;\n use crate::vm::page_fault_handler::PageFaultHandler;\n-use jinux_frame::cpu::*;\n-use jinux_frame::vm::VmIo;\n+use aster_frame::cpu::*;\n+use aster_frame::vm::VmIo;\n \n /// We can't handle most exceptions, just send self a fault signal before return to user space.\n pub fn handle_exception(context: &UserContext) {\ndiff --git a/services/libs/jinux-std/src/thread/kernel_thread.rs b/services/libs/aster-std/src/thread/kernel_thread.rs\nsimilarity index 97%\nrename from services/libs/jinux-std/src/thread/kernel_thread.rs\nrename to services/libs/aster-std/src/thread/kernel_thread.rs\nindex 1b0a5d7885..be39fb5b3d 100644\n--- a/services/libs/jinux-std/src/thread/kernel_thread.rs\n+++ b/services/libs/aster-std/src/thread/kernel_thread.rs\n@@ -1,5 +1,5 @@\n-use jinux_frame::cpu::CpuSet;\n-use jinux_frame::task::{Priority, TaskOptions};\n+use aster_frame::cpu::CpuSet;\n+use aster_frame::task::{Priority, TaskOptions};\n \n use crate::prelude::*;\n \ndiff --git a/services/libs/jinux-std/src/thread/mod.rs b/services/libs/aster-std/src/thread/mod.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/thread/mod.rs\nrename to services/libs/aster-std/src/thread/mod.rs\nindex 86dab103ab..c321170c74 100644\n--- a/services/libs/jinux-std/src/thread/mod.rs\n+++ b/services/libs/aster-std/src/thread/mod.rs\n@@ -5,7 +5,7 @@ use core::{\n     sync::atomic::{AtomicU32, Ordering},\n };\n \n-use jinux_frame::task::Task;\n+use aster_frame::task::Task;\n \n use crate::prelude::*;\n \ndiff --git a/services/libs/jinux-std/src/thread/status.rs b/services/libs/aster-std/src/thread/status.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/thread/status.rs\nrename to services/libs/aster-std/src/thread/status.rs\ndiff --git a/services/libs/jinux-std/src/thread/task.rs b/services/libs/aster-std/src/thread/task.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/thread/task.rs\nrename to services/libs/aster-std/src/thread/task.rs\nindex e5e7a567f0..856161045a 100644\n--- a/services/libs/jinux-std/src/thread/task.rs\n+++ b/services/libs/aster-std/src/thread/task.rs\n@@ -1,4 +1,4 @@\n-use jinux_frame::{\n+use aster_frame::{\n     cpu::UserContext,\n     task::{preempt, Task, TaskOptions},\n     user::{UserContextApi, UserEvent, UserMode, UserSpace},\ndiff --git a/services/libs/jinux-std/src/thread/thread_table.rs b/services/libs/aster-std/src/thread/thread_table.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/thread/thread_table.rs\nrename to services/libs/aster-std/src/thread/thread_table.rs\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/mod.rs b/services/libs/aster-std/src/thread/work_queue/mod.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/thread/work_queue/mod.rs\nrename to services/libs/aster-std/src/thread/work_queue/mod.rs\nindex 5aae0107ca..4e55e7b69a 100644\n--- a/services/libs/jinux-std/src/thread/work_queue/mod.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/mod.rs\n@@ -1,5 +1,5 @@\n use crate::prelude::*;\n-use jinux_frame::cpu::CpuSet;\n+use aster_frame::cpu::CpuSet;\n use spin::Once;\n use work_item::WorkItem;\n use worker_pool::WorkerPool;\n@@ -60,7 +60,7 @@ static WORKQUEUE_GLOBAL_HIGH_PRI: Once<Arc<WorkQueue>> = Once::new();\n /// Certainly, users can also create a dedicated WorkQueue and WorkerPool.\n ///\n /// ```rust\n-/// use jinux_frame::cpu::CpuSet;\n+/// use aster_frame::cpu::CpuSet;\n /// use crate::thread::work_queue::{WorkQueue, WorkerPool, WorkItem};\n ///\n /// fn deferred_task(){\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/simple_scheduler.rs b/services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/thread/work_queue/simple_scheduler.rs\nrename to services/libs/aster-std/src/thread/work_queue/simple_scheduler.rs\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/work_item.rs b/services/libs/aster-std/src/thread/work_queue/work_item.rs\nsimilarity index 97%\nrename from services/libs/jinux-std/src/thread/work_queue/work_item.rs\nrename to services/libs/aster-std/src/thread/work_queue/work_item.rs\nindex 3434732139..919a5318d1 100644\n--- a/services/libs/jinux-std/src/thread/work_queue/work_item.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/work_item.rs\n@@ -1,7 +1,7 @@\n use crate::prelude::*;\n+use aster_frame::cpu::CpuSet;\n use core::sync::atomic::AtomicBool;\n use core::sync::atomic::Ordering;\n-use jinux_frame::cpu::CpuSet;\n \n /// A task to be executed by a worker thread.\n pub struct WorkItem {\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/worker.rs b/services/libs/aster-std/src/thread/work_queue/worker.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/thread/work_queue/worker.rs\nrename to services/libs/aster-std/src/thread/work_queue/worker.rs\nindex d988868ce7..3ba850ed88 100644\n--- a/services/libs/jinux-std/src/thread/work_queue/worker.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/worker.rs\n@@ -2,8 +2,8 @@ use super::worker_pool::WorkerPool;\n use crate::prelude::*;\n use crate::thread::kernel_thread::{KernelThreadExt, ThreadOptions};\n use crate::Thread;\n-use jinux_frame::cpu::CpuSet;\n-use jinux_frame::task::Priority;\n+use aster_frame::cpu::CpuSet;\n+use aster_frame::task::Priority;\n \n /// A worker thread. A `Worker` will attempt to retrieve unfinished\n /// work items from its corresponding `WorkerPool`. If there are none,\ndiff --git a/services/libs/jinux-std/src/thread/work_queue/worker_pool.rs b/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/thread/work_queue/worker_pool.rs\nrename to services/libs/aster-std/src/thread/work_queue/worker_pool.rs\nindex 57fc0dfd1c..462864cd12 100644\n--- a/services/libs/jinux-std/src/thread/work_queue/worker_pool.rs\n+++ b/services/libs/aster-std/src/thread/work_queue/worker_pool.rs\n@@ -4,9 +4,9 @@ use super::{simple_scheduler::SimpleScheduler, worker::Worker, WorkItem, WorkPri\n use crate::prelude::*;\n use crate::thread::kernel_thread::{KernelThreadExt, ThreadOptions};\n use crate::Thread;\n-use jinux_frame::cpu::CpuSet;\n-use jinux_frame::sync::WaitQueue;\n-use jinux_frame::task::Priority;\n+use aster_frame::cpu::CpuSet;\n+use aster_frame::sync::WaitQueue;\n+use aster_frame::task::Priority;\n \n /// A pool of workers.\n ///\ndiff --git a/services/libs/jinux-std/src/time/mod.rs b/services/libs/aster-std/src/time/mod.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/time/mod.rs\nrename to services/libs/aster-std/src/time/mod.rs\nindex 5ffed2d136..7c9e737daa 100644\n--- a/services/libs/jinux-std/src/time/mod.rs\n+++ b/services/libs/aster-std/src/time/mod.rs\n@@ -3,7 +3,7 @@ use core::time::Duration;\n \n use crate::prelude::*;\n \n-use jinux_time::read_monotonic_time;\n+use aster_time::read_monotonic_time;\n \n mod system_time;\n \ndiff --git a/services/libs/jinux-std/src/time/system_time.rs b/services/libs/aster-std/src/time/system_time.rs\nsimilarity index 95%\nrename from services/libs/jinux-std/src/time/system_time.rs\nrename to services/libs/aster-std/src/time/system_time.rs\nindex e1584953d5..bca7a387b0 100644\n--- a/services/libs/jinux-std/src/time/system_time.rs\n+++ b/services/libs/aster-std/src/time/system_time.rs\n@@ -1,5 +1,5 @@\n+use aster_time::{read_monotonic_time, read_start_time};\n use core::time::Duration;\n-use jinux_time::{read_monotonic_time, read_start_time};\n use time::{Date, Month, PrimitiveDateTime, Time};\n \n use crate::prelude::*;\n@@ -68,8 +68,8 @@ impl SystemTime {\n     }\n }\n \n-/// convert jinux_frame::time::Time to System time\n-fn convert_system_time(system_time: jinux_time::SystemTime) -> Result<SystemTime> {\n+/// convert aster_frame::time::Time to System time\n+fn convert_system_time(system_time: aster_time::SystemTime) -> Result<SystemTime> {\n     let month = match Month::try_from(system_time.month) {\n         Ok(month) => month,\n         Err(_) => return_errno_with_message!(Errno::EINVAL, \"unknown month in system time\"),\ndiff --git a/services/libs/jinux-std/src/util/mod.rs b/services/libs/aster-std/src/util/mod.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/util/mod.rs\nrename to services/libs/aster-std/src/util/mod.rs\nindex 9441e989ba..210358bc8e 100644\n--- a/services/libs/jinux-std/src/util/mod.rs\n+++ b/services/libs/aster-std/src/util/mod.rs\n@@ -1,5 +1,5 @@\n use crate::prelude::*;\n-use jinux_frame::vm::VmIo;\n+use aster_frame::vm::VmIo;\n pub mod net;\n \n /// copy bytes from user space of current process. The bytes len is the len of dest.\ndiff --git a/services/libs/jinux-std/src/util/net/addr.rs b/services/libs/aster-std/src/util/net/addr.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/util/net/addr.rs\nrename to services/libs/aster-std/src/util/net/addr.rs\ndiff --git a/services/libs/jinux-std/src/util/net/mod.rs b/services/libs/aster-std/src/util/net/mod.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/util/net/mod.rs\nrename to services/libs/aster-std/src/util/net/mod.rs\ndiff --git a/services/libs/jinux-std/src/util/net/socket.rs b/services/libs/aster-std/src/util/net/socket.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/util/net/socket.rs\nrename to services/libs/aster-std/src/util/net/socket.rs\ndiff --git a/services/libs/jinux-std/src/vdso.rs b/services/libs/aster-std/src/vdso.rs\nsimilarity index 96%\nrename from services/libs/jinux-std/src/vdso.rs\nrename to services/libs/aster-std/src/vdso.rs\nindex 0a14325583..242b9a17fa 100644\n--- a/services/libs/jinux-std/src/vdso.rs\n+++ b/services/libs/aster-std/src/vdso.rs\n@@ -11,10 +11,10 @@\n \n use alloc::boxed::Box;\n use alloc::sync::Arc;\n-use jinux_frame::{config::PAGE_SIZE, sync::Mutex, vm::VmIo};\n-use jinux_rights::Rights;\n-use jinux_time::Instant;\n-use jinux_util::coeff::Coeff;\n+use aster_frame::{config::PAGE_SIZE, sync::Mutex, vm::VmIo};\n+use aster_rights::Rights;\n+use aster_time::Instant;\n+use aster_util::coeff::Coeff;\n use pod::Pod;\n use spin::Once;\n \n@@ -108,7 +108,7 @@ impl VdsoData {\n \n     /// Init vdso data based on the default clocksource.\n     fn init(&mut self) {\n-        let clocksource = jinux_time::default_clocksource();\n+        let clocksource = aster_time::default_clocksource();\n         let coeff = clocksource.coeff();\n         self.set_clock_mode(DEFAULT_CLOCK_MODE);\n         self.set_coeff(coeff);\n@@ -249,7 +249,7 @@ fn init_vdso() {\n pub(super) fn init() {\n     init_start_secs_count();\n     init_vdso();\n-    jinux_time::VDSO_DATA_UPDATE.call_once(|| Arc::new(update_vdso_instant));\n+    aster_time::VDSO_DATA_UPDATE.call_once(|| Arc::new(update_vdso_instant));\n }\n \n /// Return the vdso vmo.\ndiff --git a/services/libs/jinux-std/src/vm/mod.rs b/services/libs/aster-std/src/vm/mod.rs\nsimilarity index 82%\nrename from services/libs/jinux-std/src/vm/mod.rs\nrename to services/libs/aster-std/src/vm/mod.rs\nindex 1ed93e8cd9..28b205c30e 100644\n--- a/services/libs/jinux-std/src/vm/mod.rs\n+++ b/services/libs/aster-std/src/vm/mod.rs\n@@ -10,8 +10,8 @@\n //! [Zircon](https://fuchsia.dev/fuchsia-src/reference/kernel_objects/vm_object).\n //! As capabilities, the two abstractions are aligned with our goal\n //! of everything-is-a-capability, although their specifications and\n-//! implementations in C/C++ cannot apply directly to Jinux.\n-//! In Jinux, VMARs and VMOs, as well as other capabilities, are implemented\n+//! implementations in C/C++ cannot apply directly to Asterinas.\n+//! In Asterinas, VMARs and VMOs, as well as other capabilities, are implemented\n //! as zero-cost capabilities.\n \n pub mod page_fault_handler;\ndiff --git a/services/libs/jinux-std/src/vm/page_fault_handler.rs b/services/libs/aster-std/src/vm/page_fault_handler.rs\nsimilarity index 100%\nrename from services/libs/jinux-std/src/vm/page_fault_handler.rs\nrename to services/libs/aster-std/src/vm/page_fault_handler.rs\ndiff --git a/services/libs/jinux-std/src/vm/perms.rs b/services/libs/aster-std/src/vm/perms.rs\nsimilarity index 97%\nrename from services/libs/jinux-std/src/vm/perms.rs\nrename to services/libs/aster-std/src/vm/perms.rs\nindex 2e3794f6ae..5422358834 100644\n--- a/services/libs/jinux-std/src/vm/perms.rs\n+++ b/services/libs/aster-std/src/vm/perms.rs\n@@ -1,6 +1,6 @@\n+use aster_frame::vm::VmPerm;\n+use aster_rights::Rights;\n use bitflags::bitflags;\n-use jinux_frame::vm::VmPerm;\n-use jinux_rights::Rights;\n \n bitflags! {\n     /// The memory access permissions of memory mappings.\ndiff --git a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\nsimilarity index 95%\nrename from services/libs/jinux-std/src/vm/vmar/dyn_cap.rs\nrename to services/libs/aster-std/src/vm/vmar/dyn_cap.rs\nindex 9c39044594..138dcbe386 100644\n--- a/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/dyn_cap.rs\n@@ -1,6 +1,6 @@\n+use aster_frame::vm::{Vaddr, VmIo};\n+use aster_rights::Rights;\n use core::ops::Range;\n-use jinux_frame::vm::{Vaddr, VmIo};\n-use jinux_rights::Rights;\n \n use crate::prelude::*;\n \n@@ -23,8 +23,8 @@ impl Vmar<Rights> {\n     /// # Example\n     ///\n     /// ```\n-    /// use jinux_std::prelude::*;\n-    /// use jinux_std::vm::{PAGE_SIZE, Vmar, VmoOptions};\n+    /// use aster_std::prelude::*;\n+    /// use aster_std::vm::{PAGE_SIZE, Vmar, VmoOptions};\n     ///\n     /// let vmar = Vmar::new().unwrap();\n     /// let vmo = VmoOptions::new(PAGE_SIZE).alloc().unwrap();\n@@ -156,13 +156,13 @@ impl Vmar<Rights> {\n }\n \n impl VmIo for Vmar<Rights> {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> jinux_frame::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::READ)?;\n         self.0.read(offset, buf)?;\n         Ok(())\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> jinux_frame::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.write(offset, buf)?;\n         Ok(())\ndiff --git a/services/libs/jinux-std/src/vm/vmar/mod.rs b/services/libs/aster-std/src/vm/vmar/mod.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/vm/vmar/mod.rs\nrename to services/libs/aster-std/src/vm/vmar/mod.rs\nindex 4c19882a04..ced1b01df5 100644\n--- a/services/libs/jinux-std/src/vm/vmar/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmar/mod.rs\n@@ -12,9 +12,9 @@ use alloc::collections::BTreeMap;\n use alloc::sync::Arc;\n use alloc::sync::Weak;\n use alloc::vec::Vec;\n+use aster_frame::vm::VmSpace;\n+use aster_rights::Rights;\n use core::ops::Range;\n-use jinux_frame::vm::VmSpace;\n-use jinux_rights::Rights;\n \n use self::vm_mapping::VmMapping;\n \ndiff --git a/services/libs/jinux-std/src/vm/vmar/options.rs b/services/libs/aster-std/src/vm/vmar/options.rs\nsimilarity index 96%\nrename from services/libs/jinux-std/src/vm/vmar/options.rs\nrename to services/libs/aster-std/src/vm/vmar/options.rs\nindex cb43a81ca8..df0ae43cf0 100644\n--- a/services/libs/jinux-std/src/vm/vmar/options.rs\n+++ b/services/libs/aster-std/src/vm/vmar/options.rs\n@@ -1,7 +1,7 @@\n //! Options for allocating child VMARs.\n \n-use jinux_frame::config::PAGE_SIZE;\n-use jinux_frame::{Error, Result};\n+use aster_frame::config::PAGE_SIZE;\n+use aster_frame::{Error, Result};\n \n use super::Vmar;\n \n@@ -13,7 +13,7 @@ use super::Vmar;\n /// A child VMAR created from a parent VMAR of _dynamic_ capability is also a\n /// _dynamic_ capability.\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, Vmar};\n+/// use aster_std::vm::{PAGE_SIZE, Vmar};\n ///\n /// let parent_vmar = Vmar::new();\n /// let child_size = 10 * PAGE_SIZE;\n@@ -28,8 +28,8 @@ use super::Vmar;\n /// A child VMAR created from a parent VMAR of _static_ capability is also a\n /// _static_ capability.\n /// ```\n-/// use jinux_std::prelude::*;\n-/// use jinux_std::vm::{PAGE_SIZE, Vmar};\n+/// use aster_std::prelude::*;\n+/// use aster_std::vm::{PAGE_SIZE, Vmar};\n ///\n /// let parent_vmar: Vmar<Full> = Vmar::new();\n /// let child_size = 10 * PAGE_SIZE;\n@@ -139,8 +139,8 @@ mod test {\n     use crate::vm::perms::VmPerms;\n     use crate::vm::vmo::VmoRightsOp;\n     use crate::vm::{vmar::ROOT_VMAR_HIGHEST_ADDR, vmo::VmoOptions};\n-    use jinux_frame::vm::VmIo;\n-    use jinux_rights::Full;\n+    use aster_frame::vm::VmIo;\n+    use aster_rights::Full;\n \n     #[ktest]\n     fn root_vmar() {\ndiff --git a/services/libs/jinux-std/src/vm/vmar/static_cap.rs b/services/libs/aster-std/src/vm/vmar/static_cap.rs\nsimilarity index 95%\nrename from services/libs/jinux-std/src/vm/vmar/static_cap.rs\nrename to services/libs/aster-std/src/vm/vmar/static_cap.rs\nindex 76b900e1dc..248ac40a7d 100644\n--- a/services/libs/jinux-std/src/vm/vmar/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmar/static_cap.rs\n@@ -1,9 +1,9 @@\n use core::ops::Range;\n \n use crate::prelude::*;\n-use jinux_frame::vm::VmIo;\n-use jinux_rights::{Dup, Rights, TRightSet, TRights};\n-use jinux_rights_proc::require;\n+use aster_frame::vm::VmIo;\n+use aster_rights::{Dup, Rights, TRightSet, TRights};\n+use aster_rights_proc::require;\n \n use crate::vm::{page_fault_handler::PageFaultHandler, vmo::Vmo};\n \n@@ -28,8 +28,8 @@ impl<R: TRights> Vmar<TRightSet<R>> {\n     /// # Example\n     ///\n     /// ```\n-    /// use jinux_std::prelude::*;\n-    /// use jinux_std::vm::{PAGE_SIZE, Vmar, VmoOptions};\n+    /// use aster_std::prelude::*;\n+    /// use aster_std::vm::{PAGE_SIZE, Vmar, VmoOptions};\n     ///\n     /// let vmar = Vmar::<RightsWrapper<Full>>::new().unwrap();\n     /// let vmo = VmoOptions::new(PAGE_SIZE).alloc().unwrap();\n@@ -177,13 +177,13 @@ impl<R: TRights> Vmar<TRightSet<R>> {\n }\n \n impl<R: TRights> VmIo for Vmar<TRightSet<R>> {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> jinux_frame::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::READ)?;\n         self.0.read(offset, buf)?;\n         Ok(())\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> jinux_frame::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.write(offset, buf)?;\n         Ok(())\ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\nsimilarity index 99%\nrename from services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\nrename to services/libs/aster-std/src/vm/vmar/vm_mapping.rs\nindex 53b603a64b..b1c4bd9528 100644\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/aster-std/src/vm/vmar/vm_mapping.rs\n@@ -1,7 +1,7 @@\n use crate::prelude::*;\n+use aster_frame::sync::Mutex;\n+use aster_frame::vm::{VmFrame, VmFrameVec, VmIo, VmMapOptions, VmPerm, VmSpace};\n use core::ops::Range;\n-use jinux_frame::sync::Mutex;\n-use jinux_frame::vm::{VmFrame, VmFrameVec, VmIo, VmMapOptions, VmPerm, VmSpace};\n \n use crate::vm::{\n     vmo::get_page_idx_range,\ndiff --git a/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\nsimilarity index 96%\nrename from services/libs/jinux-std/src/vm/vmo/dyn_cap.rs\nrename to services/libs/aster-std/src/vm/vmo/dyn_cap.rs\nindex 9eb0c6b346..0ee957d5ea 100644\n--- a/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/dyn_cap.rs\n@@ -2,9 +2,9 @@ use core::ops::Range;\n \n use crate::prelude::*;\n \n-use jinux_frame::vm::VmIo;\n+use aster_frame::vm::VmIo;\n \n-use jinux_rights::{Rights, TRights};\n+use aster_rights::{Rights, TRights};\n \n use super::VmoRightsOp;\n use super::{\n@@ -150,13 +150,13 @@ impl Vmo<Rights> {\n }\n \n impl VmIo for Vmo<Rights> {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> jinux_frame::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::READ)?;\n         self.0.read_bytes(offset, buf)?;\n         Ok(())\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> jinux_frame::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.write_bytes(offset, buf)?;\n         Ok(())\ndiff --git a/services/libs/jinux-std/src/vm/vmo/mod.rs b/services/libs/aster-std/src/vm/vmo/mod.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/vm/vmo/mod.rs\nrename to services/libs/aster-std/src/vm/vmo/mod.rs\nindex 74d41c7014..3d37eecf7d 100644\n--- a/services/libs/jinux-std/src/vm/vmo/mod.rs\n+++ b/services/libs/aster-std/src/vm/vmo/mod.rs\n@@ -3,8 +3,8 @@\n use core::ops::Range;\n \n use align_ext::AlignExt;\n-use jinux_frame::vm::{VmAllocOptions, VmFrame, VmFrameVec, VmIo};\n-use jinux_rights::Rights;\n+use aster_frame::vm::{VmAllocOptions, VmFrame, VmFrameVec, VmIo};\n+use aster_rights::Rights;\n \n use crate::prelude::*;\n \n@@ -66,7 +66,7 @@ pub use pager::Pager;\n /// # Implementation\n ///\n /// `Vmo` provides high-level APIs for address space management by wrapping\n-/// around its low-level counterpart `jinux_frame::vm::VmFrames`.\n+/// around its low-level counterpart `aster_frame::vm::VmFrames`.\n /// Compared with `VmFrames`,\n /// `Vmo` is easier to use (by offering more powerful APIs) and\n /// harder to misuse (thanks to its nature of being capability).\ndiff --git a/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/aster-std/src/vm/vmo/options.rs\nsimilarity index 96%\nrename from services/libs/jinux-std/src/vm/vmo/options.rs\nrename to services/libs/aster-std/src/vm/vmo/options.rs\nindex a1291eb98e..88e559cc4b 100644\n--- a/services/libs/jinux-std/src/vm/vmo/options.rs\n+++ b/services/libs/aster-std/src/vm/vmo/options.rs\n@@ -4,15 +4,15 @@ use core::marker::PhantomData;\n use core::ops::Range;\n \n use align_ext::AlignExt;\n-use jinux_frame::vm::{VmAllocOptions, VmFrame};\n-use jinux_rights_proc::require;\n+use aster_frame::vm::{VmAllocOptions, VmFrame};\n+use aster_rights_proc::require;\n use typeflags_util::{SetExtend, SetExtendOp};\n \n use crate::prelude::*;\n \n use crate::vm::vmo::get_inherited_frames_from_parent;\n use crate::vm::vmo::{VmoInner, Vmo_};\n-use jinux_rights::{Dup, Rights, TRightSet, TRights, Write};\n+use aster_rights::{Dup, Rights, TRightSet, TRights, Write};\n \n use super::VmoRightsOp;\n use super::{Pager, Vmo, VmoFlags};\n@@ -23,7 +23,7 @@ use super::{Pager, Vmo, VmoFlags};\n ///\n /// Creating a VMO as a _dynamic_ capability with full access rights:\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions};\n ///\n /// let vmo = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\n@@ -32,8 +32,8 @@ use super::{Pager, Vmo, VmoFlags};\n ///\n /// Creating a VMO as a _static_ capability with all access rights:\n /// ```\n-/// use jinux_std::prelude::*;\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions};\n+/// use aster_std::prelude::*;\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions};\n ///\n /// let vmo = VmoOptions::<Full>::new(PAGE_SIZE)\n ///     .alloc()\n@@ -44,7 +44,7 @@ use super::{Pager, Vmo, VmoFlags};\n /// physically contiguous:\n ///\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions, VmoFlags};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions, VmoFlags};\n ///\n /// let vmo = VmoOptions::new(10 * PAGE_SIZE)\n ///     .flags(VmoFlags::RESIZABLE)\n@@ -164,7 +164,7 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// A child VMO created from a parent VMO of _dynamic_ capability is also a\n /// _dynamic_ capability.\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions};\n ///\n /// let parent_vmo = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\n@@ -178,8 +178,8 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// A child VMO created from a parent VMO of _static_ capability is also a\n /// _static_ capability.\n /// ```\n-/// use jinux_std::prelude::*;\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n+/// use aster_std::prelude::*;\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n ///\n /// let parent_vmo: Vmo<Full> = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\n@@ -196,7 +196,7 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// right regardless of whether the parent is writable or not.\n ///\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n ///\n /// let parent_vmo = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\n@@ -211,7 +211,7 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// The above rule for COW VMO children also applies to static capabilities.\n ///\n /// ```\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions, VmoChildOptions};\n ///\n /// let parent_vmo = VmoOptions::<TRights![Read, Dup]>::new(PAGE_SIZE)\n ///     .alloc()\n@@ -227,7 +227,7 @@ fn committed_pages_if_continuous(flags: VmoFlags, size: usize) -> Result<BTreeMa\n /// Note that a slice VMO child and its parent cannot not be resizable.\n ///\n /// ```rust\n-/// use jinux_std::vm::{PAGE_SIZE, VmoOptions};\n+/// use aster_std::vm::{PAGE_SIZE, VmoOptions};\n ///\n /// let parent_vmo = VmoOptions::new(PAGE_SIZE)\n ///     .alloc()\n@@ -519,8 +519,8 @@ impl VmoChildType for VmoCowChild {}\n #[if_cfg_ktest]\n mod test {\n     use super::*;\n-    use jinux_frame::vm::VmIo;\n-    use jinux_rights::Full;\n+    use aster_frame::vm::VmIo;\n+    use aster_rights::Full;\n \n     #[ktest]\n     fn alloc_vmo() {\ndiff --git a/services/libs/jinux-std/src/vm/vmo/pager.rs b/services/libs/aster-std/src/vm/vmo/pager.rs\nsimilarity index 98%\nrename from services/libs/jinux-std/src/vm/vmo/pager.rs\nrename to services/libs/aster-std/src/vm/vmo/pager.rs\nindex 0f0e475131..f738586892 100644\n--- a/services/libs/jinux-std/src/vm/vmo/pager.rs\n+++ b/services/libs/aster-std/src/vm/vmo/pager.rs\n@@ -1,5 +1,5 @@\n use crate::prelude::*;\n-use jinux_frame::vm::VmFrame;\n+use aster_frame::vm::VmFrame;\n \n /// Pagers provide frame to a VMO.\n ///\ndiff --git a/services/libs/jinux-std/src/vm/vmo/static_cap.rs b/services/libs/aster-std/src/vm/vmo/static_cap.rs\nsimilarity index 95%\nrename from services/libs/jinux-std/src/vm/vmo/static_cap.rs\nrename to services/libs/aster-std/src/vm/vmo/static_cap.rs\nindex 0b4a6dcc8b..b728b4e185 100644\n--- a/services/libs/jinux-std/src/vm/vmo/static_cap.rs\n+++ b/services/libs/aster-std/src/vm/vmo/static_cap.rs\n@@ -1,9 +1,9 @@\n use crate::prelude::*;\n+use aster_frame::vm::VmIo;\n+use aster_rights_proc::require;\n use core::ops::Range;\n-use jinux_frame::vm::VmIo;\n-use jinux_rights_proc::require;\n \n-use jinux_rights::{Dup, Rights, TRightSet, TRights, Write};\n+use aster_rights::{Dup, Rights, TRightSet, TRights, Write};\n \n use super::VmoRightsOp;\n use super::{\n@@ -145,13 +145,13 @@ impl<R: TRights> Vmo<TRightSet<R>> {\n }\n \n impl<R: TRights> VmIo for Vmo<TRightSet<R>> {\n-    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> jinux_frame::Result<()> {\n+    fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::READ)?;\n         self.0.read_bytes(offset, buf)?;\n         Ok(())\n     }\n \n-    fn write_bytes(&self, offset: usize, buf: &[u8]) -> jinux_frame::Result<()> {\n+    fn write_bytes(&self, offset: usize, buf: &[u8]) -> aster_frame::Result<()> {\n         self.check_rights(Rights::WRITE)?;\n         self.0.write_bytes(offset, buf)?;\n         Ok(())\ndiff --git a/services/libs/jinux-util/Cargo.toml b/services/libs/aster-util/Cargo.toml\nsimilarity index 58%\nrename from services/libs/jinux-util/Cargo.toml\nrename to services/libs/aster-util/Cargo.toml\nindex 77daec7cbe..d21d6723f5 100644\n--- a/services/libs/jinux-util/Cargo.toml\n+++ b/services/libs/aster-util/Cargo.toml\n@@ -1,16 +1,16 @@\n [package]\n-name = \"jinux-util\"\n+name = \"aster-util\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n \n [dependencies]\n-jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"d7dba56\" }\n+aster-frame = { path = \"../../../framework/aster-frame\" }\n+pod = { git = \"https://github.com/asterinas/pod\", rev = \"d7dba56\" }\n typeflags-util = { path = \"../typeflags-util\" }\n-jinux-rights-proc = { path = \"../jinux-rights-proc\" }\n-jinux-rights = { path = \"../jinux-rights\" }\n+aster-rights-proc = { path = \"../aster-rights-proc\" }\n+aster-rights = { path = \"../aster-rights\" }\n bitvec = { version = \"1.0\", default-features = false, features = [\"alloc\"] }\n ktest = { path = \"../../../framework/libs/ktest\" }\n [features]\ndiff --git a/services/libs/jinux-util/src/coeff.rs b/services/libs/aster-util/src/coeff.rs\nsimilarity index 100%\nrename from services/libs/jinux-util/src/coeff.rs\nrename to services/libs/aster-util/src/coeff.rs\ndiff --git a/services/libs/jinux-util/src/dup.rs b/services/libs/aster-util/src/dup.rs\nsimilarity index 91%\nrename from services/libs/jinux-util/src/dup.rs\nrename to services/libs/aster-util/src/dup.rs\nindex e4ece7d3c3..0b9b9e99e7 100644\n--- a/services/libs/jinux-util/src/dup.rs\n+++ b/services/libs/aster-util/src/dup.rs\n@@ -9,5 +9,5 @@\n /// _exclusively_ to one another. In other words, a type should not implement\n /// both traits.\n pub trait Dup: Sized {\n-    fn dup(&self) -> jinux_frame::Result<Self>;\n+    fn dup(&self) -> aster_frame::Result<Self>;\n }\ndiff --git a/services/libs/jinux-util/src/id_allocator.rs b/services/libs/aster-util/src/id_allocator.rs\nsimilarity index 100%\nrename from services/libs/jinux-util/src/id_allocator.rs\nrename to services/libs/aster-util/src/id_allocator.rs\ndiff --git a/services/libs/jinux-util/src/lib.rs b/services/libs/aster-util/src/lib.rs\nsimilarity index 86%\nrename from services/libs/jinux-util/src/lib.rs\nrename to services/libs/aster-util/src/lib.rs\nindex 48ffec6cc4..27f75cc710 100644\n--- a/services/libs/jinux-util/src/lib.rs\n+++ b/services/libs/aster-util/src/lib.rs\n@@ -1,4 +1,4 @@\n-//! The util of jinux\n+//! The util of Asterinas.\n #![no_std]\n #![forbid(unsafe_code)]\n \ndiff --git a/services/libs/jinux-util/src/safe_ptr.rs b/services/libs/aster-util/src/safe_ptr.rs\nsimilarity index 95%\nrename from services/libs/jinux-util/src/safe_ptr.rs\nrename to services/libs/aster-util/src/safe_ptr.rs\nindex 220f57360e..8d86bb25cb 100644\n--- a/services/libs/jinux-util/src/safe_ptr.rs\n+++ b/services/libs/aster-util/src/safe_ptr.rs\n@@ -1,10 +1,10 @@\n+use aster_frame::vm::Paddr;\n+use aster_frame::vm::{HasPaddr, VmIo};\n+use aster_frame::Result;\n+use aster_rights::{Dup, Exec, Full, Read, Signal, TRightSet, TRights, Write};\n+use aster_rights_proc::require;\n use core::fmt::Debug;\n use core::marker::PhantomData;\n-use jinux_frame::vm::Paddr;\n-use jinux_frame::vm::{HasPaddr, VmIo};\n-use jinux_frame::Result;\n-use jinux_rights::{Dup, Exec, Full, Read, Signal, TRightSet, TRights, Write};\n-use jinux_rights_proc::require;\n pub use pod::Pod;\n pub use typeflags_util::SetContain;\n \n@@ -358,14 +358,14 @@ impl<T, M: Debug, R> Debug for SafePtr<T, M, R> {\n #[macro_export]\n macro_rules! field_ptr {\n     ($ptr:expr, $type:ty, $($field:tt)+) => {{\n-        use jinux_frame::offset_of;\n-        use jinux_frame::vm::VmIo;\n-        use jinux_rights::Dup;\n-        use jinux_rights::TRightSet;\n-        use jinux_rights::TRights;\n-        use jinux_util::safe_ptr::Pod;\n-        use jinux_util::safe_ptr::SetContain;\n-        use jinux_util::safe_ptr::SafePtr;\n+        use aster_frame::offset_of;\n+        use aster_frame::vm::VmIo;\n+        use aster_rights::Dup;\n+        use aster_rights::TRightSet;\n+        use aster_rights::TRights;\n+        use aster_util::safe_ptr::Pod;\n+        use aster_util::safe_ptr::SetContain;\n+        use aster_util::safe_ptr::SafePtr;\n \n         #[inline]\n         fn new_field_ptr<T, M, R, U>(\ndiff --git a/services/libs/jinux-util/src/slot_vec.rs b/services/libs/aster-util/src/slot_vec.rs\nsimilarity index 100%\nrename from services/libs/jinux-util/src/slot_vec.rs\nrename to services/libs/aster-util/src/slot_vec.rs\ndiff --git a/services/libs/jinux-util/src/union_read_ptr.rs b/services/libs/aster-util/src/union_read_ptr.rs\nsimilarity index 95%\nrename from services/libs/jinux-util/src/union_read_ptr.rs\nrename to services/libs/aster-util/src/union_read_ptr.rs\nindex 2cf404a1bd..9e902c990e 100644\n--- a/services/libs/jinux-util/src/union_read_ptr.rs\n+++ b/services/libs/aster-util/src/union_read_ptr.rs\n@@ -35,7 +35,7 @@ macro_rules! read_union_fields {\n         union_read_ptr.read_at(offset)\n     });\n     ($container:ident.$($field:ident).*) => ({\n-        let field_offset = jinux_frame::value_offset!($container.$($field).*);\n+        let field_offset = aster_frame::value_offset!($container.$($field).*);\n         let union_read_ptr = UnionReadPtr::new(&*$container);\n         union_read_ptr.read_at(field_offset)\n     });\ndiff --git a/services/libs/comp-sys/cargo-component/README.md b/services/libs/comp-sys/cargo-component/README.md\nindex 82af27a7e3..e5871e67e4 100644\n--- a/services/libs/comp-sys/cargo-component/README.md\n+++ b/services/libs/comp-sys/cargo-component/README.md\n@@ -1,15 +1,15 @@\n ## Overview\n-The crate contains cargo-component, a cargo subcommand to enable component-level access control in Jinux. For more info about Jinux component system, see the [RFC](https://github.com/jinzhao-dev/jinux/issues/58). The implementation mainly follows [rust clippy](https://github.com/rust-lang/rust-clippy). Internally, this tool will call `cargo check` to compile the whole project and bases the analysis on MIR.\n+The crate contains cargo-component, a cargo subcommand to enable component-level access control in Asterinas. For more info about Asterinas component system, see the [RFC](https://github.com/asterinas/Asterinas/issues/58). The implementation mainly follows [rust clippy](https://github.com/rust-lang/rust-clippy). Internally, this tool will call `cargo check` to compile the whole project and bases the analysis on MIR.\n \n ## install\n-After running `make setup` for jinux, this crate can be created with cargo.\n+After running `make setup` for Asterinas, this crate can be created with cargo.\n ```shell\n cargo install --path .\n ```\n This will install two binaries `cargo-component` and `component-driver` at `$HOME/.cargo/bin`(by default, it depends on the cargo config).\n \n ## Usage\n-Use `cargo component` or `cargo component check` or `cargo component audit`. The three commands are the same now. For jinux, we shoud use another alias command `cargo component-check`, which was defined in `src/.cargo/config.toml`.\n+Use `cargo component` or `cargo component check` or `cargo component audit`. The three commands are the same now. For Asterinas, we shoud use another alias command `cargo component-check`, which was defined in `src/.cargo/config.toml`.\n \n ### Two notes:\n - The directory **where you run the command** should contains a `Components.toml` config file, where defines all components and whitelist. \ndiff --git a/services/libs/typeflags-util/src/lib.rs b/services/libs/typeflags-util/src/lib.rs\nindex df8f37a1b9..07b8a7404a 100644\n--- a/services/libs/typeflags-util/src/lib.rs\n+++ b/services/libs/typeflags-util/src/lib.rs\n@@ -1,7 +1,7 @@\n //! The content of this crate is from another project CapComp.\n //! This crate defines common type level operations, like SameAsOp, and Bool type operations.\n //! Besides, this crate defines operations to deal with type sets, like SetContain and SetInclude.\n-//! When use jinux-typeflags or jinux-rights-poc, this crate should also be added as a dependency.\n+//! When use typeflags or aster-rights-poc, this crate should also be added as a dependency.\n #![no_std]\n pub mod assert;\n pub mod bool;\ndiff --git a/services/libs/typeflags/src/lib.rs b/services/libs/typeflags/src/lib.rs\nindex 669daac229..f11eb3dcb8 100644\n--- a/services/libs/typeflags/src/lib.rs\n+++ b/services/libs/typeflags/src/lib.rs\n@@ -1,4 +1,4 @@\n-//\uff01This crate defines the procedural macro typeflags to implement capability for jinux.\n+//\uff01This crate defines the procedural macro typeflags to implement capability for Asterinas.\n //! When using this crate, typeflags-util should also be added as dependency.\n //! This is due to typeflgas is a proc-macro crate, which is only allowed to export proc-macro interfaces.\n //! So we leave the common type-level operations and structures defined in typeflags-util.\ndiff --git a/tools/bump_version.sh b/tools/bump_version.sh\nindex 402e80a4ca..854e16da2a 100755\n--- a/tools/bump_version.sh\n+++ b/tools/bump_version.sh\n@@ -1,6 +1,6 @@\n #!/bin/bash\n \n-# This script is used to update Jinux version numbers in all relevant files in the repository.\n+# This script is used to update Asterinas version numbers in all relevant files in the repository.\n # Usage: ./tools/bump_version.sh <new_version>\n \n # Update Cargo style versions (`version = \"{version}\"`) in file $1\n@@ -9,16 +9,16 @@ update_cargo_versions() {\n     sed -i \"s/^version = \\\"[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+\\\"$/version = \\\"${new_version}\\\"/g\" $1\n }\n \n-# Update Docker image versions (`jinuxdev/jinux:{version}`) in file $1\n+# Update Docker image versions (`asterinas/asterinas:{version}`) in file $1\n update_image_versions() {\n     echo \"Updating file $1\"\n-    sed -i \"s/jinuxdev\\/jinux:[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+/jinuxdev\\/jinux:${new_version}/g\" $1\n+    sed -i \"s/asterinas\\/asterinas:[[:digit:]]\\+\\.[[:digit:]]\\+\\.[[:digit:]]\\+/asterinas\\/asterinas:${new_version}/g\" $1\n }\n \n SCRIPT_DIR=$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\n-JINUX_SRC_DIR=${SCRIPT_DIR}/..\n-CARGO_TOML_PATH=${JINUX_SRC_DIR}/Cargo.toml\n-VERSION_PATH=${JINUX_SRC_DIR}/VERSION\n+ASTER_SRC_DIR=${SCRIPT_DIR}/..\n+CARGO_TOML_PATH=${ASTER_SRC_DIR}/Cargo.toml\n+VERSION_PATH=${ASTER_SRC_DIR}/VERSION\n \n # Get and check the new version number\n if [[ $1 =~ ^[0-9]+\\.[0-9]+\\.[0-9]+$ ]]; then\n@@ -32,14 +32,14 @@ fi\n update_cargo_versions ${CARGO_TOML_PATH}\n \n # Automatically bump Cargo.lock file\n-cargo update -p jinux --precise $new_version\n+cargo update -p asterinas --precise $new_version\n \n # Update Docker image versions in README files\n-update_image_versions ${JINUX_SRC_DIR}/README.md\n+update_image_versions ${ASTER_SRC_DIR}/README.md\n update_image_versions ${SCRIPT_DIR}/docker/README.md\n \n # Update Docker image versions in workflows\n-WORKFLOWS=$(find \"${JINUX_SRC_DIR}/.github/workflows/\" -type f -name \"*.yml\")\n+WORKFLOWS=$(find \"${ASTER_SRC_DIR}/.github/workflows/\" -type f -name \"*.yml\")\n for workflow in $WORKFLOWS; do\n     update_image_versions $workflow\n done\n@@ -47,4 +47,4 @@ done\n # Create or update VERSION\n echo \"${new_version}\" > ${VERSION_PATH}\n \n-echo \"Bumped Jinux version to $new_version\"\n+echo \"Bumped Asterinas version to $new_version\"\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\nindex 39d7d4bb5b..99ee9114f9 100644\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -182,15 +182,15 @@ RUN make defconfig \\\n     && sed -i \"s/# CONFIG_FEATURE_SH_STANDALONE is not set/CONFIG_FEATURE_SH_STANDALONE=y/g\" .config \\\n     && make -j\n \n-#= The final stages to produce the Jinux development image ====================\n+#= The final stages to produce the Asterinas development image ====================\n \n FROM build-base as rust\n \n # Install Rust\n ENV PATH=\"/root/.cargo/bin:${PATH}\"\n-ARG JINUX_RUST_VERSION\n+ARG ASTER_RUST_VERSION\n RUN curl https://sh.rustup.rs -sSf | \\\n-        sh -s -- --default-toolchain ${JINUX_RUST_VERSION} -y \\\n+        sh -s -- --default-toolchain ${ASTER_RUST_VERSION} -y \\\n     && rm -rf /root/.cargo/registry && rm -rf /root/.cargo/git \\\n     && cargo -V \\\n     && rustup component add rust-src rustc-dev llvm-tools-preview\n@@ -202,7 +202,7 @@ RUN cargo install \\\n \n FROM rust\n \n-# Install all Jinux dependent packages\n+# Install all Asterinas dependent packages\n RUN apt update && apt-get install -y --no-install-recommends \\\n     cpio \\\n     cpuid \\\n@@ -226,7 +226,7 @@ RUN apt clean && rm -rf /var/lib/apt/lists/*\n \n # Prepare the system call test suite\n COPY --from=syscall_test /root/syscall_test/build/syscall_test_bins /root/syscall_test_bins\n-ENV JINUX_PREBUILT_SYSCALL_TEST=/root/syscall_test_bins\n+ENV ASTER_PREBUILT_SYSCALL_TEST=/root/syscall_test_bins\n \n # Install QEMU built from the previous stages\n COPY --from=qemu /usr/local/qemu /usr/local/qemu\n@@ -249,9 +249,9 @@ COPY --from=busybox /root/busybox/busybox /bin/busybox\n # Install benchmarks built from the previous stages\n COPY --from=build-benchmarks /usr/local/benchmark /usr/local/benchmark\n \n-# Add the path of jinux tools\n-ENV PATH=\"/root/jinux/target/bin:${PATH}\"\n+# Add the path of Asterinas tools\n+ENV PATH=\"/root/asterinas/target/bin:${PATH}\"\n \n-VOLUME [ \"/root/jinux\" ]\n+VOLUME [ \"/root/asterinas\" ]\n \n-WORKDIR /root/jinux\n+WORKDIR /root/asterinas\ndiff --git a/tools/docker/README.md b/tools/docker/README.md\nindex 19b1d50edb..69149de907 100644\n--- a/tools/docker/README.md\n+++ b/tools/docker/README.md\n@@ -1,35 +1,35 @@\n-# Jinux Development Docker Images\n+# Asterinas Development Docker Images\n \n-Jinux development Docker images are provided to facilitate developing and testing Jinux project. These images can be found in the [jinuxdev/jinux](https://hub.docker.com/r/jinuxdev/jinux/) repository on DockerHub.\n+Asterinas development Docker images are provided to facilitate developing and testing Asterinas project. These images can be found in the [asterinas/asterinas](https://hub.docker.com/r/asterinas/asterinas/) repository on DockerHub.\n \n ## Building Docker Images\n \n-To build a Docker image for Jinux and test it on your local machine, navigate to the root directory of the Jinux source code tree and execute the following command:\n+To build a Docker image for Asterinas and test it on your local machine, navigate to the root directory of the Asterinas source code tree and execute the following command:\n \n ```bash\n docker buildx build \\\n     -f tools/docker/Dockerfile.ubuntu22.04 \\\n-    --build-arg JINUX_RUST_VERSION=$RUST_VERSION \\\n-    -t jinuxdev/jinux:$JINUX_VERSION \\\n+    --build-arg ASTER_RUST_VERSION=$RUST_VERSION \\\n+    -t asterinas/asterinas:$ASTER_VERSION \\\n     .\n ```\n \n The meanings of the two environment variables in the command are as follows:\n \n-- `$JINUX_VERSION`: Represents the version number of Jinux. You can find this in the `VERSION` file.\n+- `$ASTER_VERSION`: Represents the version number of Asterinas. You can find this in the `VERSION` file.\n - `$RUST_VERSION`: Denotes the required Rust toolchain version, as specified in the `rust-toolchain` file.\n \n ## Tagging Docker Images\n \n-It's essential for each Jinux Docker image to have a distinct tag. By convention, the tag is assigned with the version number of the Jinux project itself. This methodology ensures clear correspondence between a commit of the source code and its respective Docker image.\n+It's essential for each Asterinas Docker image to have a distinct tag. By convention, the tag is assigned with the version number of the Asterinas project itself. This methodology ensures clear correspondence between a commit of the source code and its respective Docker image.\n \n If a commit needs to create a new Docker image, it should\n \n 1. Update the Dockerfile as well as other materials relevant to the Docker image, and\n-2. Run [`tools/bump_version.sh`](../bump_version.sh) tool to update the Jinux project's version number.\n+2. Run [`tools/bump_version.sh`](../bump_version.sh) tool to update the Asterinas project's version number.\n  \n For bug fixes or small changes, increment the last number of a [SemVer](https://semver.org/) by one. For major features or releases, increment the second number. All changes made in the two steps should be included in the commit.\n \n ## Uploading Docker Images\n \n-New versions of Jinux's Docker images are automatically uploaded to DockerHub through Github Actions. Simply submit your PR that updates Jinux's Docker image for review. After getting the project maintainers' approval, the [Docker image building workflow](../../.github/workflows/docker_build.yml) will be started, building the new Docker image and pushing it to DockerHub.\n\\ No newline at end of file\n+New versions of Asterinas's Docker images are automatically uploaded to DockerHub through Github Actions. Simply submit your PR that updates Asterinas's Docker image for review. After getting the project maintainers' approval, the [Docker image building workflow](../../.github/workflows/docker_build.yml) will be started, building the new Docker image and pushing it to DockerHub.\n\\ No newline at end of file\ndiff --git a/tools/docker/run_dev_container.sh b/tools/docker/run_dev_container.sh\nindex 11f9c5d5ea..92af52d14c 100755\n--- a/tools/docker/run_dev_container.sh\n+++ b/tools/docker/run_dev_container.sh\n@@ -3,9 +3,9 @@\n set -e\n \n SCRIPT_DIR=$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" && pwd )\n-JINUX_SRC_DIR=${SCRIPT_DIR}/../..\n+ASTER_SRC_DIR=${SCRIPT_DIR}/../..\n CARGO_TOML_PATH=${SCRIPT_DIR}/../../Cargo.toml\n-VERSION=$( cat ${JINUX_SRC_DIR}/VERSION )\n-IMAGE_NAME=jinuxdev/jinux:${VERSION}\n+VERSION=$( cat ${ASTER_SRC_DIR}/VERSION )\n+IMAGE_NAME=asterinas/asterinas:${VERSION}\n \n-docker run -it --privileged --network=host --device=/dev/kvm -v ${JINUX_SRC_DIR}:/root/jinux ${IMAGE_NAME}\n+docker run -it --privileged --network=host --device=/dev/kvm -v ${ASTER_SRC_DIR}:/root/asterinas ${IMAGE_NAME}\n", "test_patch": "diff --git a/.github/workflows/integration_test.yml b/.github/workflows/integration_test.yml\nindex df94fbab1e..962999bfa2 100644\n--- a/.github/workflows/integration_test.yml\n+++ b/.github/workflows/integration_test.yml\n@@ -10,9 +10,9 @@ jobs:\n   test:\n     runs-on: ubuntu-latest\n     timeout-minutes: 30\n-    container: jinuxdev/jinux:0.2.2\n+    container: asterinas/asterinas:0.2.2\n     steps:\n-      - run: echo \"Running in jinuxdev/jinux:0.2.2\"\n+      - run: echo \"Running in asterinas/asterinas:0.2.2\"\n \n       - uses: actions/checkout@v3\n \ndiff --git a/.github/workflows/unit_test.yml b/.github/workflows/unit_test.yml\nindex a9b4dc572f..bfcfa9542e 100644\n--- a/.github/workflows/unit_test.yml\n+++ b/.github/workflows/unit_test.yml\n@@ -10,9 +10,9 @@ jobs:\n   test:\n     runs-on: ubuntu-latest\n     timeout-minutes: 15\n-    container: jinuxdev/jinux:0.2.2\n+    container: asterinas/asterinas:0.2.2\n     steps:\n-      - run: echo \"Running in jinuxdev/jinux:0.2.2\"\n+      - run: echo \"Running in asterinas/asterinas:0.2.2\"\n \n       - uses: actions/checkout@v3\n \ndiff --git a/framework/libs/ktest/src/lib.rs b/framework/libs/ktest/src/lib.rs\nindex 5e2f1c24e4..7ba5795027 100644\n--- a/framework/libs/ktest/src/lib.rs\n+++ b/framework/libs/ktest/src/lib.rs\n@@ -1,10 +1,10 @@\n-//! # The kernel mode testing framework of Jinux.\n+//! # The kernel mode testing framework of Asterinas.\n //!\n //! `ktest` stands for kernel-mode testing framework. Its goal is to provide a\n //! `cargo test`-like experience for any `#![no_std]` bare metal crates.\n //!\n-//! In Jinux, all the tests written in the source tree of the crates will be run\n-//! immediately after the initialization of jinux-frame. Thus you can use any\n+//! In Asterinas, all the tests written in the source tree of the crates will be run\n+//! immediately after the initialization of aster-frame. Thus you can use any\n //! feature provided by the frame including the heap allocator, etc.\n //!\n //! By all means, ktest is an individule crate that only requires:\n@@ -39,7 +39,7 @@\n //! }\n //! ```\n //!\n-//! And also, any crates using the ktest framework should be linked with jinux-frame\n+//! And also, any crates using the ktest framework should be linked with aster-frame\n //! and import the `ktest` crate:\n //!\n //! ```toml\n@@ -67,14 +67,14 @@\n //! This is achieved by a whitelist filter on the test name.\n //!\n //! ```bash\n-//! make run KTEST=1 KTEST_WHITELIST=failing_assertion,jinux_frame::test::expect_panic\n+//! make run KTEST=1 KTEST_WHITELIST=failing_assertion,aster_frame::test::expect_panic\n //! ```\n //!\n //! `KTEST_CRATES` variable is used to specify in which crates the tests to be run.\n //! This is achieved by conditionally compiling the test module using the `#[cfg]`.\n //!\n //! ```bash\n-//! make run KTEST=1 KTEST_CRATES=jinux-frame\n+//! make run KTEST=1 KTEST_CRATES=aster-frame\n //! ``\n //!\n //! We support the `#[should_panic]` attribute just in the same way as the standard\ndiff --git a/regression/apps/signal_c/signal_test.c b/regression/apps/signal_c/signal_test.c\nindex a885e13986..8d800feef3 100644\n--- a/regression/apps/signal_c/signal_test.c\n+++ b/regression/apps/signal_c/signal_test.c\n@@ -184,7 +184,7 @@ int test_handle_sigfpe() {\n     c = div_maybe_zero(a, b);\n     fxsave(y);\n \n-    // jinux does not save and restore fpregs now, so we emit this check.\n+    // Asterinas does not save and restore fpregs now, so we emit this check.\n     // if (memcmp(x, y, 512) != 0) {\n     //     THROW_ERROR(\"floating point registers are modified\");\n     // }\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\nindex 9b864904fa..d78412f11d 100644\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -3,8 +3,8 @@ TESTS ?= open_test read_test statfs_test chmod_test pty_test uidgid_test vdso_cl\n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n BUILD_DIR ?= $(CUR_DIR)/../build\n-ifdef JINUX_PREBUILT_SYSCALL_TEST\n-\tBIN_DIR := $(JINUX_PREBUILT_SYSCALL_TEST)\n+ifdef ASTER_PREBUILT_SYSCALL_TEST\n+\tBIN_DIR := $(ASTER_PREBUILT_SYSCALL_TEST)\n else\n \tBIN_DIR := $(BUILD_DIR)/syscall_test_bins\n \tSRC_DIR := $(BUILD_DIR)/gvisor_src\n@@ -21,7 +21,7 @@ all: $(TESTS)\n $(TESTS): $(BIN_DIR) $(TARGET_DIR)\n \t@cp -f $</$@ $(TARGET_DIR)/tests\n \n-ifndef JINUX_PREBUILT_SYSCALL_TEST\n+ifndef ASTER_PREBUILT_SYSCALL_TEST\n $(BIN_DIR): $(SRC_DIR)\n \t@if ! type bazel > /dev/null; then \\\n \t\techo \"bazel is not installed, please run $(CUR_DIR)/install_bazel.sh with sudo permission to install it.\"; \\\n@@ -33,7 +33,7 @@ $(BIN_DIR): $(SRC_DIR)\n \n $(SRC_DIR):\n \t@rm -rf $@ && mkdir -p $@\n-\t@cd $@ && git clone -b 20200921.0 https://github.com/jinzhao-dev/gvisor.git .\n+\t@cd $@ && git clone -b 20200921.0 https://github.com/asterinas/gvisor.git .\n endif\n \n $(TARGET_DIR): $(RUN_BASH) $(BLOCK_LIST)\n", "problem_statement": "Rename the project name from Jinux to Asterinas\nThe project's official name will be Asterinas. The renaming process consists of the following steps:\r\n1. The Github repo will be renamed to `asterinas` and moved to the `asterinas` Github org. \r\n2. The DockerHub Image will be moved to `asterinas/asterinas`.\r\n3. All occurrences of `Jinux` in the codebase should be renamed to `Asterinas`.\r\n4. All occurrences of `jinux-` (or `jinux_`) as in the codebase should be renamed to `aster-` (or `aster_`).\r\n5. The ascii-art LOGO should be replaced accordingly.\r\n\r\nWe will make the project open source as long as we are given the green light by the management. Renaming will be done the first day when the project is open sourced.\r\n\n", "hints_text": "", "created_at": "2023-12-25T03:34:33Z", "version": "0.2"}, {"repo": "asterinas/asterinas", "pull_number": 395, "instance_id": "asterinas__asterinas-395", "issue_numbers": ["254"], "base_commit": "576578baf4025686ae4c2893c2aafbc8d1e14722", "patch": "diff --git a/services/libs/jinux-std/src/device/mod.rs b/services/libs/jinux-std/src/device/mod.rs\nindex fa9e6a0d97..2fc391eeff 100644\n--- a/services/libs/jinux-std/src/device/mod.rs\n+++ b/services/libs/jinux-std/src/device/mod.rs\n@@ -12,6 +12,8 @@ pub use pty::{PtyMaster, PtySlave};\n pub use random::Random;\n pub use urandom::Urandom;\n \n+use self::tty::get_n_tty;\n+\n /// Init the device node in fs, must be called after mounting rootfs.\n pub fn init() -> Result<()> {\n     let null = Arc::new(null::Null);\n@@ -19,7 +21,9 @@ pub fn init() -> Result<()> {\n     let zero = Arc::new(zero::Zero);\n     add_node(zero, \"zero\")?;\n     tty::init();\n-    let tty = tty::get_n_tty().clone();\n+    let console = get_n_tty().clone();\n+    add_node(console, \"console\")?;\n+    let tty = Arc::new(tty::TtyDevice);\n     add_node(tty, \"tty\")?;\n     let random = Arc::new(random::Random);\n     add_node(random, \"random\")?;\ndiff --git a/services/libs/jinux-std/src/device/null.rs b/services/libs/jinux-std/src/device/null.rs\nindex dd64aa1aa6..7137a64edf 100644\n--- a/services/libs/jinux-std/src/device/null.rs\n+++ b/services/libs/jinux-std/src/device/null.rs\n@@ -1,5 +1,8 @@\n use super::*;\n+use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Null;\n \n@@ -12,7 +15,9 @@ impl Device for Null {\n         // Same value with Linux\n         DeviceId::new(1, 3)\n     }\n+}\n \n+impl FileIo for Null {\n     fn read(&self, _buf: &mut [u8]) -> Result<usize> {\n         Ok(0)\n     }\n@@ -20,4 +25,9 @@ impl Device for Null {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/device/pty/mod.rs b/services/libs/jinux-std/src/device/pty/mod.rs\nindex a6a8173728..8ee323a677 100644\n--- a/services/libs/jinux-std/src/device/pty/mod.rs\n+++ b/services/libs/jinux-std/src/device/pty/mod.rs\n@@ -33,7 +33,7 @@ pub fn init() -> Result<()> {\n \n pub fn new_pty_pair(index: u32, ptmx: Arc<dyn Inode>) -> Result<(Arc<PtyMaster>, Arc<PtySlave>)> {\n     debug!(\"pty index = {}\", index);\n-    let master = Arc::new(PtyMaster::new(ptmx, index));\n-    let slave = Arc::new(PtySlave::new(master.clone()));\n+    let master = PtyMaster::new(ptmx, index);\n+    let slave = PtySlave::new(&master);\n     Ok((master, slave))\n }\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\nindex 34ca3044af..748edb3ecc 100644\n--- a/services/libs/jinux-std/src/device/pty/pty.rs\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -2,16 +2,18 @@ use alloc::format;\n use ringbuf::{ring_buffer::RbBase, HeapRb, Rb};\n \n use crate::device::tty::line_discipline::LineDiscipline;\n+use crate::device::tty::new_job_control_and_ldisc;\n use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n-use crate::fs::file_handle::FileLike;\n+use crate::fs::devpts::DevPts;\n use crate::fs::fs_resolver::FsPath;\n+use crate::fs::inode_handle::FileIo;\n use crate::fs::utils::{AccessMode, Inode, InodeMode, IoctlCmd};\n use crate::prelude::*;\n use crate::process::signal::{Pollee, Poller};\n+use crate::process::{JobControl, Terminal};\n use crate::util::{read_val_from_user, write_val_to_user};\n \n-const PTS_DIR: &str = \"/dev/pts\";\n const BUFFER_CAPACITY: usize = 4096;\n \n /// Pesudo terminal master.\n@@ -23,19 +25,24 @@ pub struct PtyMaster {\n     index: u32,\n     output: Arc<LineDiscipline>,\n     input: SpinLock<HeapRb<u8>>,\n+    job_control: Arc<JobControl>,\n     /// The state of input buffer\n     pollee: Pollee,\n+    weak_self: Weak<Self>,\n }\n \n impl PtyMaster {\n-    pub fn new(ptmx: Arc<dyn Inode>, index: u32) -> Self {\n-        Self {\n+    pub fn new(ptmx: Arc<dyn Inode>, index: u32) -> Arc<Self> {\n+        let (job_control, ldisc) = new_job_control_and_ldisc();\n+        Arc::new_cyclic(move |weak_ref| PtyMaster {\n             ptmx,\n             index,\n-            output: LineDiscipline::new(),\n+            output: ldisc,\n             input: SpinLock::new(HeapRb::new(BUFFER_CAPACITY)),\n+            job_control,\n             pollee: Pollee::new(IoEvents::OUT),\n-        }\n+            weak_self: weak_ref.clone(),\n+        })\n     }\n \n     pub fn index(&self) -> u32 {\n@@ -46,16 +53,12 @@ impl PtyMaster {\n         &self.ptmx\n     }\n \n-    pub(super) fn slave_push_byte(&self, byte: u8) {\n+    pub(super) fn slave_push_char(&self, ch: u8) {\n         let mut input = self.input.lock_irq_disabled();\n-        input.push_overwrite(byte);\n+        input.push_overwrite(ch);\n         self.update_state(&input);\n     }\n \n-    pub(super) fn slave_read(&self, buf: &mut [u8]) -> Result<usize> {\n-        self.output.read(buf)\n-    }\n-\n     pub(super) fn slave_poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n         let mut poll_status = IoEvents::empty();\n \n@@ -87,7 +90,7 @@ impl PtyMaster {\n     }\n }\n \n-impl FileLike for PtyMaster {\n+impl FileIo for PtyMaster {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         // TODO: deal with nonblocking read\n         if buf.is_empty() {\n@@ -122,7 +125,6 @@ impl FileLike for PtyMaster {\n \n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         let mut input = self.input.lock();\n-\n         for character in buf {\n             self.output.push_char(*character, |content| {\n                 for byte in content.as_bytes() {\n@@ -193,29 +195,35 @@ impl FileLike for PtyMaster {\n                 self.output.set_window_size(winsize);\n                 Ok(0)\n             }\n-            IoctlCmd::TIOCSCTTY => {\n-                // TODO: reimplement when adding session.\n-                let foreground = {\n-                    let current = current!();\n-                    let process_group = current.process_group().unwrap();\n-                    Arc::downgrade(&process_group)\n-                };\n-                self.output.set_fg(foreground);\n-                Ok(0)\n-            }\n             IoctlCmd::TIOCGPGRP => {\n-                let Some(fg_pgid) = self.output.fg_pgid() else {\n+                let Some(foreground) = self.foreground() else {\n                     return_errno_with_message!(\n                         Errno::ESRCH,\n                         \"the foreground process group does not exist\"\n                     );\n                 };\n+                let fg_pgid = foreground.pgid();\n                 write_val_to_user(arg, &fg_pgid)?;\n                 Ok(0)\n             }\n+            IoctlCmd::TIOCSPGRP => {\n+                let pgid = {\n+                    let pgid: i32 = read_val_from_user(arg)?;\n+                    if pgid < 0 {\n+                        return_errno_with_message!(Errno::EINVAL, \"negative pgid\");\n+                    }\n+                    pgid as u32\n+                };\n+\n+                self.set_foreground(&pgid)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSCTTY => {\n+                self.set_current_session()?;\n+                Ok(0)\n+            }\n             IoctlCmd::TIOCNOTTY => {\n-                // TODO: reimplement when adding session.\n-                self.output.set_fg(Weak::new());\n+                self.release_current_session()?;\n                 Ok(0)\n             }\n             IoctlCmd::FIONREAD => {\n@@ -246,15 +254,47 @@ impl FileLike for PtyMaster {\n     }\n }\n \n-pub struct PtySlave(Arc<PtyMaster>);\n+impl Terminal for PtyMaster {\n+    fn arc_self(&self) -> Arc<dyn Terminal> {\n+        self.weak_self.upgrade().unwrap() as _\n+    }\n+\n+    fn job_control(&self) -> &JobControl {\n+        &self.job_control\n+    }\n+}\n+\n+impl Drop for PtyMaster {\n+    fn drop(&mut self) {\n+        let fs = self.ptmx.fs();\n+        let devpts = fs.downcast_ref::<DevPts>().unwrap();\n+\n+        let index = self.index;\n+        devpts.remove_slave(index);\n+    }\n+}\n+\n+pub struct PtySlave {\n+    master: Weak<PtyMaster>,\n+    job_control: JobControl,\n+    weak_self: Weak<Self>,\n+}\n \n impl PtySlave {\n-    pub fn new(master: Arc<PtyMaster>) -> Self {\n-        PtySlave(master)\n+    pub fn new(master: &Arc<PtyMaster>) -> Arc<Self> {\n+        Arc::new_cyclic(|weak_ref| PtySlave {\n+            master: Arc::downgrade(master),\n+            job_control: JobControl::new(),\n+            weak_self: weak_ref.clone(),\n+        })\n     }\n \n     pub fn index(&self) -> u32 {\n-        self.0.index()\n+        self.master().index()\n+    }\n+\n+    fn master(&self) -> Arc<PtyMaster> {\n+        self.master.upgrade().unwrap()\n     }\n }\n \n@@ -266,50 +306,91 @@ impl Device for PtySlave {\n     fn id(&self) -> crate::fs::device::DeviceId {\n         DeviceId::new(88, self.index())\n     }\n+}\n \n+impl Terminal for PtySlave {\n+    fn arc_self(&self) -> Arc<dyn Terminal> {\n+        self.weak_self.upgrade().unwrap() as _\n+    }\n+\n+    fn job_control(&self) -> &JobControl {\n+        &self.job_control\n+    }\n+}\n+\n+impl FileIo for PtySlave {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        self.0.slave_read(buf)\n+        self.job_control.wait_until_in_foreground()?;\n+        self.master().output.read(buf)\n     }\n \n     fn write(&self, buf: &[u8]) -> Result<usize> {\n+        let master = self.master();\n         for ch in buf {\n             // do we need to add '\\r' here?\n             if *ch == b'\\n' {\n-                self.0.slave_push_byte(b'\\r');\n-                self.0.slave_push_byte(b'\\n');\n+                master.slave_push_char(b'\\r');\n+                master.slave_push_char(b'\\n');\n             } else {\n-                self.0.slave_push_byte(*ch);\n+                master.slave_push_char(*ch);\n             }\n         }\n         Ok(buf.len())\n     }\n \n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.master().slave_poll(mask, poller)\n+    }\n+\n     fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n         match cmd {\n             IoctlCmd::TCGETS\n             | IoctlCmd::TCSETS\n-            | IoctlCmd::TIOCGPGRP\n             | IoctlCmd::TIOCGPTN\n             | IoctlCmd::TIOCGWINSZ\n-            | IoctlCmd::TIOCSWINSZ => self.0.ioctl(cmd, arg),\n+            | IoctlCmd::TIOCSWINSZ => self.master().ioctl(cmd, arg),\n+            IoctlCmd::TIOCGPGRP => {\n+                if !self.is_controlling_terminal() {\n+                    return_errno_with_message!(Errno::ENOTTY, \"slave is not controlling terminal\");\n+                }\n+\n+                let Some(foreground) = self.foreground() else {\n+                    return_errno_with_message!(\n+                        Errno::ESRCH,\n+                        \"the foreground process group does not exist\"\n+                    );\n+                };\n+\n+                let fg_pgid = foreground.pgid();\n+                write_val_to_user(arg, &fg_pgid)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSPGRP => {\n+                let pgid = {\n+                    let pgid: i32 = read_val_from_user(arg)?;\n+                    if pgid < 0 {\n+                        return_errno_with_message!(Errno::EINVAL, \"negative pgid\");\n+                    }\n+                    pgid as u32\n+                };\n+\n+                self.set_foreground(&pgid)?;\n+                Ok(0)\n+            }\n             IoctlCmd::TIOCSCTTY => {\n-                // TODO:\n+                self.set_current_session()?;\n                 Ok(0)\n             }\n             IoctlCmd::TIOCNOTTY => {\n-                // TODO:\n+                self.release_current_session()?;\n                 Ok(0)\n             }\n             IoctlCmd::FIONREAD => {\n-                let buffer_len = self.0.slave_buf_len() as i32;\n+                let buffer_len = self.master().slave_buf_len() as i32;\n                 write_val_to_user(arg, &buffer_len)?;\n                 Ok(0)\n             }\n             _ => Ok(0),\n         }\n     }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.0.slave_poll(mask, poller)\n-    }\n }\ndiff --git a/services/libs/jinux-std/src/device/random.rs b/services/libs/jinux-std/src/device/random.rs\nindex 91a0567c4f..4ed22a5e20 100644\n--- a/services/libs/jinux-std/src/device/random.rs\n+++ b/services/libs/jinux-std/src/device/random.rs\n@@ -1,5 +1,8 @@\n+use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Random;\n \n@@ -19,7 +22,9 @@ impl Device for Random {\n         // The same value as Linux\n         DeviceId::new(1, 8)\n     }\n+}\n \n+impl FileIo for Random {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         Self::getrandom(buf)\n     }\n@@ -27,6 +32,11 @@ impl Device for Random {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\n \n impl From<getrandom::Error> for Error {\ndiff --git a/services/libs/jinux-std/src/device/tty/device.rs b/services/libs/jinux-std/src/device/tty/device.rs\nnew file mode 100644\nindex 0000000000..e5f8afb799\n--- /dev/null\n+++ b/services/libs/jinux-std/src/device/tty/device.rs\n@@ -0,0 +1,47 @@\n+use crate::events::IoEvents;\n+use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n+use crate::prelude::*;\n+use crate::process::signal::Poller;\n+\n+/// Corresponds to `/dev/tty` in the file system. This device represents the controlling terminal\n+/// of the session of current process.\n+pub struct TtyDevice;\n+\n+impl Device for TtyDevice {\n+    fn open(&self) -> Result<Option<Arc<dyn FileIo>>> {\n+        let current = current!();\n+        let session = current.session().unwrap();\n+\n+        let Some(terminal) = session.terminal() else {\n+            return_errno_with_message!(\n+                Errno::ENOTTY,\n+                \"the session does not have controlling terminal\"\n+            );\n+        };\n+\n+        Ok(Some(terminal as Arc<dyn FileIo>))\n+    }\n+\n+    fn type_(&self) -> DeviceType {\n+        DeviceType::CharDevice\n+    }\n+\n+    fn id(&self) -> DeviceId {\n+        DeviceId::new(5, 0)\n+    }\n+}\n+\n+impl FileIo for TtyDevice {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"cannot read tty device\");\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        return_errno_with_message!(Errno::EINVAL, \"cannot write tty device\");\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        IoEvents::empty()\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\nindex c8defa6b2c..7764f4eb5b 100644\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -1,13 +1,10 @@\n use crate::events::IoEvents;\n+use crate::prelude::*;\n use crate::process::signal::constants::{SIGINT, SIGQUIT};\n+use crate::process::signal::signals::kernel::KernelSignal;\n use crate::process::signal::{Pollee, Poller};\n-use crate::process::ProcessGroup;\n use crate::thread::work_queue::work_item::WorkItem;\n use crate::thread::work_queue::{submit_work_item, WorkPriority};\n-use crate::{\n-    prelude::*,\n-    process::{signal::signals::kernel::KernelSignal, Pgid},\n-};\n use alloc::format;\n use jinux_frame::trap::disable_local;\n use ringbuf::{ring_buffer::RbBase, Rb, StaticRb};\n@@ -19,19 +16,21 @@ use super::termio::{KernelTermios, WinSize, CC_C_CHAR};\n \n const BUFFER_CAPACITY: usize = 4096;\n \n+pub type LdiscSignalSender = Arc<dyn Fn(KernelSignal) + Send + Sync + 'static>;\n+\n pub struct LineDiscipline {\n     /// current line\n     current_line: SpinLock<CurrentLine>,\n     /// The read buffer\n     read_buffer: SpinLock<StaticRb<u8, BUFFER_CAPACITY>>,\n-    /// The foreground process group\n-    foreground: SpinLock<Weak<ProcessGroup>>,\n     /// termios\n     termios: SpinLock<KernelTermios>,\n     /// Windows size,\n     winsize: SpinLock<WinSize>,\n     /// Pollee\n     pollee: Pollee,\n+    /// Used to send signal for foreground processes, when some char comes.\n+    send_signal: LdiscSignalSender,\n     /// work item\n     work_item: Arc<WorkItem>,\n     /// Parameters used by a work item.\n@@ -76,8 +75,8 @@ impl CurrentLine {\n \n impl LineDiscipline {\n     /// Create a new line discipline\n-    pub fn new() -> Arc<Self> {\n-        Arc::new_cyclic(|line_ref: &Weak<LineDiscipline>| {\n+    pub fn new(send_signal: LdiscSignalSender) -> Arc<Self> {\n+        Arc::new_cyclic(move |line_ref: &Weak<LineDiscipline>| {\n             let line_discipline = line_ref.clone();\n             let work_item = Arc::new(WorkItem::new(Box::new(move || {\n                 if let Some(line_discipline) = line_discipline.upgrade() {\n@@ -87,10 +86,10 @@ impl LineDiscipline {\n             Self {\n                 current_line: SpinLock::new(CurrentLine::new()),\n                 read_buffer: SpinLock::new(StaticRb::default()),\n-                foreground: SpinLock::new(Weak::new()),\n                 termios: SpinLock::new(KernelTermios::default()),\n                 winsize: SpinLock::new(WinSize::default()),\n                 pollee: Pollee::new(IoEvents::empty()),\n+                send_signal,\n                 work_item,\n                 work_item_para: Arc::new(SpinLock::new(LineDisciplineWorkPara::new())),\n             }\n@@ -98,7 +97,7 @@ impl LineDiscipline {\n     }\n \n     /// Push char to line discipline.\n-    pub fn push_char<F: FnMut(&str)>(&self, ch: u8, echo_callback: F) {\n+    pub fn push_char<F2: FnMut(&str)>(&self, ch: u8, echo_callback: F2) {\n         let termios = self.termios.lock_irq_disabled();\n \n         let ch = if termios.contains_icrnl() && ch == b'\\r' {\n@@ -107,7 +106,7 @@ impl LineDiscipline {\n             ch\n         };\n \n-        if self.may_send_signal_to_foreground(&termios, ch) {\n+        if self.may_send_signal(&termios, ch) {\n             // The char is already dealt with, so just return\n             return;\n         }\n@@ -158,22 +157,14 @@ impl LineDiscipline {\n         self.update_readable_state_deferred();\n     }\n \n-    fn may_send_signal_to_foreground(&self, termios: &KernelTermios, ch: u8) -> bool {\n-        if !termios.contains_isig() {\n+    fn may_send_signal(&self, termios: &KernelTermios, ch: u8) -> bool {\n+        if !termios.is_canonical_mode() || !termios.contains_isig() {\n             return false;\n         }\n \n-        let Some(foreground) = self.foreground.lock().upgrade() else {\n-            return false;\n-        };\n-\n         let signal = match ch {\n-            item if item == *termios.get_special_char(CC_C_CHAR::VINTR) => {\n-                KernelSignal::new(SIGINT)\n-            }\n-            item if item == *termios.get_special_char(CC_C_CHAR::VQUIT) => {\n-                KernelSignal::new(SIGQUIT)\n-            }\n+            ch if ch == *termios.get_special_char(CC_C_CHAR::VINTR) => KernelSignal::new(SIGINT),\n+            ch if ch == *termios.get_special_char(CC_C_CHAR::VQUIT) => KernelSignal::new(SIGQUIT),\n             _ => return false,\n         };\n         // `kernel_signal()` may cause sleep, so only construct parameters here.\n@@ -182,7 +173,7 @@ impl LineDiscipline {\n         true\n     }\n \n-    fn update_readable_state(&self) {\n+    pub fn update_readable_state(&self) {\n         let buffer = self.read_buffer.lock_irq_disabled();\n         if !buffer.is_empty() {\n             self.pollee.add_events(IoEvents::IN);\n@@ -193,7 +184,6 @@ impl LineDiscipline {\n \n     fn update_readable_state_deferred(&self) {\n         let buffer = self.read_buffer.lock_irq_disabled();\n-        let pollee = self.pollee.clone();\n         // add/del events may sleep, so only construct parameters here.\n         if !buffer.is_empty() {\n             self.work_item_para.lock_irq_disabled().pollee_type = Some(PolleeType::Add);\n@@ -206,11 +196,7 @@ impl LineDiscipline {\n     /// include all operations that may cause sleep, and processes by a work queue.\n     fn update_readable_state_after(&self) {\n         if let Some(signal) = self.work_item_para.lock_irq_disabled().kernel_signal.take() {\n-            self.foreground\n-                .lock()\n-                .upgrade()\n-                .unwrap()\n-                .kernel_signal(signal)\n+            (self.send_signal)(signal);\n         };\n         if let Some(pollee_type) = self.work_item_para.lock_irq_disabled().pollee_type.take() {\n             match pollee_type {\n@@ -243,42 +229,24 @@ impl LineDiscipline {\n         }\n     }\n \n-    /// read all bytes buffered to dst, return the actual read length.\n-    pub fn read(&self, dst: &mut [u8]) -> Result<usize> {\n-        let mut poller = None;\n+    pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         loop {\n-            let res = self.try_read(dst);\n+            let res = self.try_read(buf);\n             match res {\n-                Ok(read_len) => {\n-                    return Ok(read_len);\n-                }\n-                Err(e) => {\n-                    if e.error() != Errno::EAGAIN {\n-                        return Err(e);\n+                Ok(len) => return Ok(len),\n+                Err(e) if e.error() != Errno::EAGAIN => return Err(e),\n+                Err(_) => {\n+                    let poller = Some(Poller::new());\n+                    if self.poll(IoEvents::IN, poller.as_ref()).is_empty() {\n+                        poller.as_ref().unwrap().wait()?\n                     }\n                 }\n             }\n-\n-            // Wait for read event\n-            let need_poller = if poller.is_none() {\n-                poller = Some(Poller::new());\n-                poller.as_ref()\n-            } else {\n-                None\n-            };\n-            let revents = self.pollee.poll(IoEvents::IN, need_poller);\n-            if revents.is_empty() {\n-                // FIXME: deal with ldisc read timeout\n-                poller.as_ref().unwrap().wait()?;\n-            }\n         }\n     }\n \n-    pub fn try_read(&self, dst: &mut [u8]) -> Result<usize> {\n-        if !self.current_can_read() {\n-            return_errno!(Errno::EAGAIN);\n-        }\n-\n+    /// read all bytes buffered to dst, return the actual read length.\n+    fn try_read(&self, dst: &mut [u8]) -> Result<usize> {\n         let (vmin, vtime) = {\n             let termios = self.termios.lock_irq_disabled();\n             let vmin = *termios.get_special_char(CC_C_CHAR::VMIN);\n@@ -326,7 +294,8 @@ impl LineDiscipline {\n                 if termios.is_canonical_mode() {\n                     // canonical mode, read until meet new line\n                     if is_line_terminator(next_char, &termios) {\n-                        if !should_not_be_read(next_char, &termios) {\n+                        // The eof should not be read\n+                        if !is_eof(next_char, &termios) {\n                             *dst_i = next_char;\n                             read_len += 1;\n                         }\n@@ -368,31 +337,6 @@ impl LineDiscipline {\n         todo!()\n     }\n \n-    /// Determine whether current process can read the line discipline. If current belongs to the foreground process group.\n-    /// or the foreground process group is None, returns true.\n-    fn current_can_read(&self) -> bool {\n-        let current = current!();\n-        let Some(foreground) = self.foreground.lock_irq_disabled().upgrade() else {\n-            return true;\n-        };\n-        foreground.contains_process(current.pid())\n-    }\n-\n-    /// set foreground process group\n-    pub fn set_fg(&self, foreground: Weak<ProcessGroup>) {\n-        *self.foreground.lock_irq_disabled() = foreground;\n-        // Some background processes may be waiting on the wait queue, when set_fg, the background processes may be able to read.\n-        self.update_readable_state();\n-    }\n-\n-    /// get foreground process group id\n-    pub fn fg_pgid(&self) -> Option<Pgid> {\n-        self.foreground\n-            .lock_irq_disabled()\n-            .upgrade()\n-            .map(|foreground| foreground.pgid())\n-    }\n-\n     /// whether there is buffered data\n     pub fn is_empty(&self) -> bool {\n         self.read_buffer.lock_irq_disabled().len() == 0\n@@ -439,8 +383,7 @@ fn is_line_terminator(item: u8, termios: &KernelTermios) -> bool {\n     false\n }\n \n-/// The special char should not be read by reading process\n-fn should_not_be_read(ch: u8, termios: &KernelTermios) -> bool {\n+fn is_eof(ch: u8, termios: &KernelTermios) -> bool {\n     ch == *termios.get_special_char(CC_C_CHAR::VEOF)\n }\n \n@@ -467,6 +410,7 @@ enum PolleeType {\n }\n \n struct LineDisciplineWorkPara {\n+    #[allow(clippy::type_complexity)]\n     kernel_signal: Option<KernelSignal>,\n     pollee_type: Option<PolleeType>,\n }\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\nindex 395ca0f756..1aea18dadb 100644\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -2,23 +2,28 @@ use spin::Once;\n \n use self::driver::TtyDriver;\n use self::line_discipline::LineDiscipline;\n-use super::*;\n use crate::events::IoEvents;\n+use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n use crate::fs::utils::IoctlCmd;\n use crate::prelude::*;\n+use crate::process::signal::signals::kernel::KernelSignal;\n use crate::process::signal::Poller;\n-use crate::process::{process_table, ProcessGroup};\n+use crate::process::{JobControl, Process, Terminal};\n use crate::util::{read_val_from_user, write_val_to_user};\n \n+mod device;\n pub mod driver;\n pub mod line_discipline;\n pub mod termio;\n \n+pub use device::TtyDevice;\n+\n static N_TTY: Once<Arc<Tty>> = Once::new();\n \n pub(super) fn init() {\n     let name = CString::new(\"console\").unwrap();\n-    let tty = Arc::new(Tty::new(name));\n+    let tty = Tty::new(name);\n     N_TTY.call_once(|| tty);\n     driver::init();\n }\n@@ -28,44 +33,36 @@ pub struct Tty {\n     name: CString,\n     /// line discipline\n     ldisc: Arc<LineDiscipline>,\n+    job_control: Arc<JobControl>,\n     /// driver\n     driver: SpinLock<Weak<TtyDriver>>,\n+    weak_self: Weak<Self>,\n }\n \n impl Tty {\n-    pub fn new(name: CString) -> Self {\n-        Tty {\n+    pub fn new(name: CString) -> Arc<Self> {\n+        let (job_control, ldisc) = new_job_control_and_ldisc();\n+        Arc::new_cyclic(move |weak_ref| Tty {\n             name,\n-            ldisc: LineDiscipline::new(),\n+            ldisc,\n+            job_control,\n             driver: SpinLock::new(Weak::new()),\n-        }\n-    }\n-\n-    /// Set foreground process group\n-    pub fn set_fg(&self, process_group: Weak<ProcessGroup>) {\n-        self.ldisc.set_fg(process_group);\n+            weak_self: weak_ref.clone(),\n+        })\n     }\n \n     pub fn set_driver(&self, driver: Weak<TtyDriver>) {\n         *self.driver.lock_irq_disabled() = driver;\n     }\n \n-    pub fn receive_char(&self, item: u8) {\n-        self.ldisc.push_char(item, |content| print!(\"{}\", content));\n+    pub fn receive_char(&self, ch: u8) {\n+        self.ldisc.push_char(ch, |content| print!(\"{}\", content));\n     }\n }\n \n-impl Device for Tty {\n-    fn type_(&self) -> DeviceType {\n-        DeviceType::CharDevice\n-    }\n-\n-    fn id(&self) -> DeviceId {\n-        // Same value with Linux\n-        DeviceId::new(5, 0)\n-    }\n-\n+impl FileIo for Tty {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.job_control.wait_until_in_foreground()?;\n         self.ldisc.read(buf)\n     }\n \n@@ -92,23 +89,28 @@ impl Device for Tty {\n                 Ok(0)\n             }\n             IoctlCmd::TIOCGPGRP => {\n-                let Some(fg_pgid) = self.ldisc.fg_pgid() else {\n-                    return_errno_with_message!(Errno::ENOENT, \"No fg process group\")\n+                let Some(foreground) = self.foreground() else {\n+                    return_errno_with_message!(Errno::ESRCH, \"No fg process group\")\n                 };\n+                let fg_pgid = foreground.pgid();\n                 debug!(\"fg_pgid = {}\", fg_pgid);\n                 write_val_to_user(arg, &fg_pgid)?;\n                 Ok(0)\n             }\n             IoctlCmd::TIOCSPGRP => {\n                 // Set the process group id of fg progress group\n-                let pgid = read_val_from_user::<i32>(arg)?;\n-                if pgid < 0 {\n-                    return_errno_with_message!(Errno::EINVAL, \"invalid pgid\");\n-                }\n-                match process_table::pgid_to_process_group(pgid as u32) {\n-                    None => self.ldisc.set_fg(Weak::new()),\n-                    Some(process_group) => self.ldisc.set_fg(Arc::downgrade(&process_group)),\n-                }\n+                let pgid = {\n+                    let pgid: i32 = read_val_from_user(arg)?;\n+                    if pgid < 0 {\n+                        return_errno_with_message!(Errno::EINVAL, \"negative pgid\");\n+                    }\n+                    pgid as u32\n+                };\n+\n+                self.set_foreground(&pgid)?;\n+                // Some background processes may be waiting on the wait queue,\n+                // when set_fg, the background processes may be able to read.\n+                self.ldisc.update_readable_state();\n                 Ok(0)\n             }\n             IoctlCmd::TCSETS => {\n@@ -143,12 +145,73 @@ impl Device for Tty {\n                 self.ldisc.set_window_size(winsize);\n                 Ok(0)\n             }\n+            IoctlCmd::TIOCSCTTY => {\n+                self.set_current_session()?;\n+                Ok(0)\n+            }\n             _ => todo!(),\n         }\n     }\n }\n \n-/// FIXME: should we maintain a static console?\n+impl Terminal for Tty {\n+    fn arc_self(&self) -> Arc<dyn Terminal> {\n+        self.weak_self.upgrade().unwrap() as _\n+    }\n+\n+    fn job_control(&self) -> &JobControl {\n+        &self.job_control\n+    }\n+}\n+\n+impl Device for Tty {\n+    fn type_(&self) -> DeviceType {\n+        DeviceType::CharDevice\n+    }\n+\n+    fn id(&self) -> DeviceId {\n+        // The same value as /dev/console in linux.\n+        DeviceId::new(88, 0)\n+    }\n+}\n+\n+pub fn new_job_control_and_ldisc() -> (Arc<JobControl>, Arc<LineDiscipline>) {\n+    let job_control = Arc::new(JobControl::new());\n+\n+    let send_signal = {\n+        let cloned_job_control = job_control.clone();\n+        move |signal: KernelSignal| {\n+            let Some(foreground) = cloned_job_control.foreground() else {\n+                return;\n+            };\n+\n+            foreground.broadcast_signal(signal);\n+        }\n+    };\n+\n+    let ldisc = LineDiscipline::new(Arc::new(send_signal));\n+\n+    (job_control, ldisc)\n+}\n+\n pub fn get_n_tty() -> &'static Arc<Tty> {\n     N_TTY.get().unwrap()\n }\n+\n+/// Open `N_TTY` as the controlling terminal for the process. This method should\n+/// only be called when creating the init process.\n+pub fn open_ntty_as_controlling_terminal(process: &Process) -> Result<()> {\n+    let tty = get_n_tty();\n+\n+    let session = &process.session().unwrap();\n+    let process_group = process.process_group().unwrap();\n+\n+    session.set_terminal(|| {\n+        tty.job_control.set_session(session);\n+        Ok(tty.clone())\n+    })?;\n+\n+    tty.job_control.set_foreground(Some(&process_group))?;\n+\n+    Ok(())\n+}\ndiff --git a/services/libs/jinux-std/src/device/urandom.rs b/services/libs/jinux-std/src/device/urandom.rs\nindex 529b3c8d71..687ecb762b 100644\n--- a/services/libs/jinux-std/src/device/urandom.rs\n+++ b/services/libs/jinux-std/src/device/urandom.rs\n@@ -1,5 +1,8 @@\n+use crate::events::IoEvents;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Urandom;\n \n@@ -19,7 +22,9 @@ impl Device for Urandom {\n         // The same value as Linux\n         DeviceId::new(1, 9)\n     }\n+}\n \n+impl FileIo for Urandom {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         Self::getrandom(buf)\n     }\n@@ -27,4 +32,9 @@ impl Device for Urandom {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/device/zero.rs b/services/libs/jinux-std/src/device/zero.rs\nindex 7d5f1f22d4..e3b695cd97 100644\n--- a/services/libs/jinux-std/src/device/zero.rs\n+++ b/services/libs/jinux-std/src/device/zero.rs\n@@ -1,5 +1,8 @@\n use super::*;\n+use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n pub struct Zero;\n \n@@ -12,7 +15,9 @@ impl Device for Zero {\n         // Same value with Linux\n         DeviceId::new(1, 5)\n     }\n+}\n \n+impl FileIo for Zero {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         for byte in buf.iter_mut() {\n             *byte = 0;\n@@ -23,4 +28,9 @@ impl Device for Zero {\n     fn write(&self, buf: &[u8]) -> Result<usize> {\n         Ok(buf.len())\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let events = IoEvents::IN | IoEvents::OUT;\n+        events & mask\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/fs/device.rs b/services/libs/jinux-std/src/fs/device.rs\nindex c85c74eb81..b85c577d68 100644\n--- a/services/libs/jinux-std/src/fs/device.rs\n+++ b/services/libs/jinux-std/src/fs/device.rs\n@@ -1,33 +1,21 @@\n-use crate::events::IoEvents;\n use crate::fs::fs_resolver::{FsPath, FsResolver};\n use crate::fs::utils::Dentry;\n-use crate::fs::utils::{InodeMode, InodeType, IoctlCmd};\n+use crate::fs::utils::{InodeMode, InodeType};\n use crate::prelude::*;\n-use crate::process::signal::Poller;\n+\n+use super::inode_handle::FileIo;\n \n /// The abstract of device\n-pub trait Device: Sync + Send {\n+pub trait Device: Sync + Send + FileIo {\n     /// Return the device type.\n     fn type_(&self) -> DeviceType;\n \n     /// Return the device ID.\n     fn id(&self) -> DeviceId;\n \n-    /// Read from the device.\n-    fn read(&self, buf: &mut [u8]) -> Result<usize>;\n-\n-    /// Write to the device.\n-    fn write(&self, buf: &[u8]) -> Result<usize>;\n-\n-    /// Poll on the device.\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        let events = IoEvents::IN | IoEvents::OUT;\n-        events & mask\n-    }\n-\n-    /// Ioctl on the device.\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        return_errno_with_message!(Errno::EINVAL, \"ioctl is not supported\");\n+    /// Open a device.\n+    fn open(&self) -> Result<Option<Arc<dyn FileIo>>> {\n+        Ok(None)\n     }\n }\n \ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs b/services/libs/jinux-std/src/fs/devpts/master.rs\ndeleted file mode 100644\nindex bfddebfc65..0000000000\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ /dev/null\n@@ -1,106 +0,0 @@\n-use crate::events::IoEvents;\n-use crate::fs::file_handle::FileLike;\n-use crate::prelude::*;\n-use crate::process::signal::Poller;\n-\n-use super::*;\n-\n-use crate::device::PtyMaster;\n-\n-/// Pty master inode for the master device.\n-pub struct PtyMasterInode(Arc<PtyMaster>);\n-\n-impl PtyMasterInode {\n-    pub fn new(device: Arc<PtyMaster>) -> Arc<Self> {\n-        Arc::new(Self(device))\n-    }\n-}\n-\n-impl Drop for PtyMasterInode {\n-    fn drop(&mut self) {\n-        // Remove the slave from fs.\n-        let fs = self.0.ptmx().fs();\n-        let devpts = fs.downcast_ref::<DevPts>().unwrap();\n-\n-        let index = self.0.index();\n-        devpts.remove_slave(index);\n-    }\n-}\n-\n-impl Inode for PtyMasterInode {\n-    /// Do not cache dentry in DCACHE.\n-    ///\n-    /// Each file descriptor obtained by opening \"/dev/ptmx\" is an independent pty master\n-    /// with its own associated pty slave.\n-    fn is_dentry_cacheable(&self) -> bool {\n-        false\n-    }\n-\n-    fn len(&self) -> usize {\n-        self.0.ptmx().metadata().size\n-    }\n-\n-    fn resize(&self, new_size: usize) {}\n-\n-    fn metadata(&self) -> Metadata {\n-        self.0.ptmx().metadata()\n-    }\n-\n-    fn type_(&self) -> InodeType {\n-        self.0.ptmx().metadata().type_\n-    }\n-\n-    fn mode(&self) -> InodeMode {\n-        self.0.ptmx().metadata().mode\n-    }\n-\n-    fn set_mode(&self, mode: InodeMode) {}\n-\n-    fn atime(&self) -> Duration {\n-        self.0.ptmx().metadata().atime\n-    }\n-\n-    fn set_atime(&self, time: Duration) {}\n-\n-    fn mtime(&self) -> Duration {\n-        self.0.ptmx().metadata().mtime\n-    }\n-\n-    fn set_mtime(&self, time: Duration) {}\n-\n-    fn read_page(&self, idx: usize, frame: &VmFrame) -> Result<()> {\n-        Ok(())\n-    }\n-\n-    fn write_page(&self, idx: usize, frame: &VmFrame) -> Result<()> {\n-        Ok(())\n-    }\n-\n-    fn read_at(&self, offset: usize, buf: &mut [u8]) -> Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    fn read_direct_at(&self, offset: usize, buf: &mut [u8]) -> Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    fn write_at(&self, offset: usize, buf: &[u8]) -> Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn write_direct_at(&self, offset: usize, buf: &[u8]) -> Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        self.0.ioctl(cmd, arg)\n-    }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.0.poll(mask, poller)\n-    }\n-\n-    fn fs(&self) -> Arc<dyn FileSystem> {\n-        self.0.ptmx().fs()\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\nindex f960872e72..25d115d44e 100644\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -1,3 +1,4 @@\n+use crate::device::PtyMaster;\n use crate::fs::device::{Device, DeviceId, DeviceType};\n use crate::fs::utils::{\n     DirentVisitor, FileSystem, FsFlags, Inode, InodeMode, InodeType, IoctlCmd, Metadata,\n@@ -9,11 +10,9 @@ use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n use jinux_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n \n-use self::master::PtyMasterInode;\n use self::ptmx::Ptmx;\n use self::slave::PtySlaveInode;\n \n-mod master;\n mod ptmx;\n mod slave;\n \n@@ -52,7 +51,7 @@ impl DevPts {\n     }\n \n     /// Create the master and slave pair.\n-    fn create_master_slave_pair(&self) -> Result<(Arc<PtyMasterInode>, Arc<PtySlaveInode>)> {\n+    fn create_master_slave_pair(&self) -> Result<(Arc<PtyMaster>, Arc<PtySlaveInode>)> {\n         let index = self\n             .index_alloc\n             .lock()\n@@ -61,17 +60,16 @@ impl DevPts {\n \n         let (master, slave) = crate::device::new_pty_pair(index as u32, self.root.ptmx.clone())?;\n \n-        let master_inode = PtyMasterInode::new(master);\n         let slave_inode = PtySlaveInode::new(slave, self.this.clone());\n         self.root.add_slave(index.to_string(), slave_inode.clone());\n \n-        Ok((master_inode, slave_inode))\n+        Ok((master, slave_inode))\n     }\n \n     /// Remove the slave from fs.\n     ///\n     /// This is called when the master is being dropped.\n-    fn remove_slave(&self, index: u32) -> Option<Arc<PtySlaveInode>> {\n+    pub fn remove_slave(&self, index: u32) -> Option<Arc<PtySlaveInode>> {\n         let removed_slave = self.root.remove_slave(&index.to_string());\n         if removed_slave.is_some() {\n             self.index_alloc.lock().free(index as usize);\n@@ -241,7 +239,7 @@ impl Inode for RootInode {\n         let inode = match name {\n             \".\" | \"..\" => self.fs().root_inode(),\n             // Call the \"open\" method of ptmx to create a master and slave pair.\n-            \"ptmx\" => self.ptmx.open()?,\n+            \"ptmx\" => self.ptmx.clone(),\n             slave => self\n                 .slaves\n                 .read()\ndiff --git a/services/libs/jinux-std/src/fs/devpts/ptmx.rs b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\nindex fcba7bab2f..c8031d997a 100644\n--- a/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/ptmx.rs\n@@ -1,4 +1,8 @@\n+use crate::device::PtyMaster;\n+use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n \n use super::*;\n \n@@ -14,12 +18,14 @@ const PTMX_MINOR_NUM: u32 = 2;\n pub struct Ptmx {\n     inner: Inner,\n     metadata: Metadata,\n-    fs: Weak<DevPts>,\n }\n \n+#[derive(Clone)]\n+struct Inner(Weak<DevPts>);\n+\n impl Ptmx {\n     pub fn new(sb: &SuperBlock, fs: Weak<DevPts>) -> Arc<Self> {\n-        let inner = Inner;\n+        let inner = Inner(fs);\n         Arc::new(Self {\n             metadata: Metadata::new_device(\n                 PTMX_INO,\n@@ -28,20 +34,19 @@ impl Ptmx {\n                 &inner,\n             ),\n             inner,\n-            fs,\n         })\n     }\n \n     /// The open method for ptmx.\n     ///\n     /// Creates a master and slave pair and returns the master inode.\n-    pub fn open(&self) -> Result<Arc<PtyMasterInode>> {\n+    pub fn open(&self) -> Result<Arc<PtyMaster>> {\n         let (master, _) = self.devpts().create_master_slave_pair()?;\n         Ok(master)\n     }\n \n     pub fn devpts(&self) -> Arc<DevPts> {\n-        self.fs.upgrade().unwrap()\n+        self.inner.0.upgrade().unwrap()\n     }\n \n     pub fn device_type(&self) -> DeviceType {\n@@ -119,9 +124,11 @@ impl Inode for Ptmx {\n     fn fs(&self) -> Arc<dyn FileSystem> {\n         self.devpts()\n     }\n-}\n \n-struct Inner;\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        Some(Arc::new(self.inner.clone()))\n+    }\n+}\n \n impl Device for Inner {\n     fn type_(&self) -> DeviceType {\n@@ -132,13 +139,23 @@ impl Device for Inner {\n         DeviceId::new(PTMX_MAJOR_NUM, PTMX_MINOR_NUM)\n     }\n \n+    fn open(&self) -> Result<Option<Arc<dyn FileIo>>> {\n+        let devpts = self.0.upgrade().unwrap();\n+        let (master, _) = devpts.create_master_slave_pair()?;\n+        Ok(Some(master as _))\n+    }\n+}\n+\n+impl FileIo for Inner {\n     fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        // do nothing because it should not be used to read.\n-        Ok(0)\n+        return_errno_with_message!(Errno::EINVAL, \"cannot read ptmx\");\n     }\n \n     fn write(&self, buf: &[u8]) -> Result<usize> {\n-        // do nothing because it should not be used to write.\n-        Ok(buf.len())\n+        return_errno_with_message!(Errno::EINVAL, \"cannot write ptmx\");\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        IoEvents::empty()\n     }\n }\ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\nindex 83e7ffc991..408bdb15ea 100644\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -1,4 +1,5 @@\n use crate::events::IoEvents;\n+use crate::fs::inode_handle::FileIo;\n use crate::prelude::*;\n use crate::process::signal::Poller;\n \n@@ -107,4 +108,8 @@ impl Inode for PtySlaveInode {\n     fn fs(&self) -> Arc<dyn FileSystem> {\n         self.fs.upgrade().unwrap()\n     }\n+\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        Some(self.device.clone())\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/fs/file_handle.rs b/services/libs/jinux-std/src/fs/file_handle.rs\nindex 2036d7557b..05dbe218b7 100644\n--- a/services/libs/jinux-std/src/fs/file_handle.rs\n+++ b/services/libs/jinux-std/src/fs/file_handle.rs\n@@ -1,6 +1,7 @@\n //! Opend File Handle\n \n use crate::events::{IoEvents, Observer};\n+use crate::fs::device::Device;\n use crate::fs::utils::{AccessMode, IoctlCmd, Metadata, SeekFrom, StatusFlags};\n use crate::net::socket::Socket;\n use crate::prelude::*;\n@@ -73,6 +74,10 @@ pub trait FileLike: Send + Sync + Any {\n     fn as_socket(&self) -> Option<&dyn Socket> {\n         None\n     }\n+\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        None\n+    }\n }\n \n impl dyn FileLike {\ndiff --git a/services/libs/jinux-std/src/fs/file_table.rs b/services/libs/jinux-std/src/fs/file_table.rs\nindex 39d3ef4600..93e622df3d 100644\n--- a/services/libs/jinux-std/src/fs/file_table.rs\n+++ b/services/libs/jinux-std/src/fs/file_table.rs\n@@ -27,7 +27,7 @@ impl FileTable {\n     pub fn new_with_stdio() -> Self {\n         let mut table = SlotVec::new();\n         let fs_resolver = FsResolver::new();\n-        let tty_path = FsPath::new(AT_FDCWD, \"/dev/tty\").expect(\"cannot find tty\");\n+        let tty_path = FsPath::new(AT_FDCWD, \"/dev/console\").expect(\"cannot find tty\");\n         let stdin = {\n             let flags = AccessMode::O_RDONLY as u32;\n             let mode = InodeMode::S_IRUSR;\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\nindex b286aa5811..fae4407c34 100644\n--- a/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/dyn_cap.rs\n@@ -21,8 +21,16 @@ impl InodeHandle<Rights> {\n         if access_mode.is_writable() && inode.type_() == InodeType::Dir {\n             return_errno_with_message!(Errno::EISDIR, \"Directory cannot open to write\");\n         }\n+\n+        let file_io = if let Some(device) = inode.as_device() {\n+            device.open()?\n+        } else {\n+            None\n+        };\n+\n         let inner = Arc::new(InodeHandle_ {\n             dentry,\n+            file_io,\n             offset: Mutex::new(0),\n             access_mode,\n             status_flags: AtomicU32::new(status_flags.bits()),\n@@ -42,6 +50,7 @@ impl InodeHandle<Rights> {\n         if !self.1.contains(Rights::READ) {\n             return_errno_with_message!(Errno::EBADF, \"File is not readable\");\n         }\n+\n         self.0.read_to_end(buf)\n     }\n \n@@ -75,11 +84,11 @@ impl FileLike for InodeHandle<Rights> {\n     }\n \n     fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.dentry().inode().poll(mask, poller)\n+        self.0.poll(mask, poller)\n     }\n \n     fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        self.dentry().inode().ioctl(cmd, arg)\n+        self.0.ioctl(cmd, arg)\n     }\n \n     fn metadata(&self) -> Metadata {\n@@ -107,4 +116,8 @@ impl FileLike for InodeHandle<Rights> {\n         // Close does not guarantee that the data has been successfully saved to disk.\n         Ok(())\n     }\n+\n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        self.dentry().inode().as_device()\n+    }\n }\ndiff --git a/services/libs/jinux-std/src/fs/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\nindex aa9101f160..665d6f4916 100644\n--- a/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n+++ b/services/libs/jinux-std/src/fs/inode_handle/mod.rs\n@@ -5,11 +5,14 @@ mod static_cap;\n \n use core::sync::atomic::{AtomicU32, Ordering};\n \n+use crate::events::IoEvents;\n+use crate::fs::device::Device;\n use crate::fs::file_handle::FileLike;\n use crate::fs::utils::{\n     AccessMode, Dentry, DirentVisitor, InodeType, IoctlCmd, Metadata, SeekFrom, StatusFlags,\n };\n use crate::prelude::*;\n+use crate::process::signal::Poller;\n use jinux_rights::Rights;\n \n #[derive(Debug)]\n@@ -17,6 +20,10 @@ pub struct InodeHandle<R = Rights>(Arc<InodeHandle_>, R);\n \n struct InodeHandle_ {\n     dentry: Arc<Dentry>,\n+    /// `file_io` is Similar to `file_private` field in `file` structure in linux. If\n+    /// `file_io` is Some, typical file operations including `read`, `write`, `poll`,\n+    /// `ioctl` will be provided by `file_io`, instead of `dentry`.\n+    file_io: Option<Arc<dyn FileIo>>,\n     offset: Mutex<usize>,\n     access_mode: AccessMode,\n     status_flags: AtomicU32,\n@@ -25,6 +32,11 @@ struct InodeHandle_ {\n impl InodeHandle_ {\n     pub fn read(&self, buf: &mut [u8]) -> Result<usize> {\n         let mut offset = self.offset.lock();\n+\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.read(buf);\n+        }\n+\n         let len = if self.status_flags().contains(StatusFlags::O_DIRECT) {\n             self.dentry.inode().read_direct_at(*offset, buf)?\n         } else {\n@@ -37,6 +49,11 @@ impl InodeHandle_ {\n \n     pub fn write(&self, buf: &[u8]) -> Result<usize> {\n         let mut offset = self.offset.lock();\n+\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.write(buf);\n+        }\n+\n         if self.status_flags().contains(StatusFlags::O_APPEND) {\n             *offset = self.dentry.inode_len();\n         }\n@@ -51,6 +68,10 @@ impl InodeHandle_ {\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> Result<usize> {\n+        if self.file_io.is_some() {\n+            return_errno_with_message!(Errno::EINVAL, \"file io does not support read to end\");\n+        }\n+\n         let len = if self.status_flags().contains(StatusFlags::O_DIRECT) {\n             self.dentry.inode().read_direct_to_end(buf)?\n         } else {\n@@ -117,6 +138,22 @@ impl InodeHandle_ {\n         *offset += read_cnt;\n         Ok(read_cnt)\n     }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.poll(mask, poller);\n+        }\n+\n+        self.dentry.inode().poll(mask, poller)\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        if let Some(ref file_io) = self.file_io {\n+            return file_io.ioctl(cmd, arg);\n+        }\n+\n+        self.dentry.inode().ioctl(cmd, arg)\n+    }\n }\n \n impl Debug for InodeHandle_ {\n@@ -136,3 +173,15 @@ impl<R> InodeHandle<R> {\n         &self.0.dentry\n     }\n }\n+\n+pub trait FileIo: Send + Sync + 'static {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize>;\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize>;\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents;\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        return_errno_with_message!(Errno::EINVAL, \"ioctl is not supported\");\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/fs/procfs/mod.rs b/services/libs/jinux-std/src/fs/procfs/mod.rs\nindex 2614b307b2..f1fec834a4 100644\n--- a/services/libs/jinux-std/src/fs/procfs/mod.rs\n+++ b/services/libs/jinux-std/src/fs/procfs/mod.rs\n@@ -91,7 +91,7 @@ impl DirOps for RootDirOps {\n             SelfSymOps::new_inode(this_ptr.clone())\n         } else if let Ok(pid) = name.parse::<Pid>() {\n             let process_ref =\n-                process_table::pid_to_process(pid).ok_or_else(|| Error::new(Errno::ENOENT))?;\n+                process_table::get_process(&pid).ok_or_else(|| Error::new(Errno::ENOENT))?;\n             PidDirOps::new_inode(process_ref, this_ptr.clone())\n         } else {\n             return_errno!(Errno::ENOENT);\ndiff --git a/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\nindex 317d2834c2..d7bdc01e22 100644\n--- a/services/libs/jinux-std/src/fs/ramfs/fs.rs\n+++ b/services/libs/jinux-std/src/fs/ramfs/fs.rs\n@@ -574,6 +574,10 @@ impl Inode for RamInode {\n         Ok(device_inode)\n     }\n \n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        self.0.read().inner.as_device().cloned()\n+    }\n+\n     fn create(&self, name: &str, type_: InodeType, mode: InodeMode) -> Result<Arc<dyn Inode>> {\n         if self.0.read().metadata.type_ != InodeType::Dir {\n             return_errno_with_message!(Errno::ENOTDIR, \"self is not dir\");\ndiff --git a/services/libs/jinux-std/src/fs/rootfs.rs b/services/libs/jinux-std/src/fs/rootfs.rs\nindex 13f18d10e4..3feb36f0f6 100644\n--- a/services/libs/jinux-std/src/fs/rootfs.rs\n+++ b/services/libs/jinux-std/src/fs/rootfs.rs\n@@ -84,7 +84,7 @@ pub fn init(initramfs_buf: &[u8]) -> Result<()> {\n \n static ROOT_MOUNT: Once<Arc<MountNode>> = Once::new();\n \n-fn init_root_mount() {\n+pub fn init_root_mount() {\n     ROOT_MOUNT.call_once(|| -> Arc<MountNode> {\n         let rootfs = RamFS::new();\n         MountNode::new_root(rootfs)\ndiff --git a/services/libs/jinux-std/src/fs/utils/inode.rs b/services/libs/jinux-std/src/fs/utils/inode.rs\nindex 5a0132a4b8..2573ff1596 100644\n--- a/services/libs/jinux-std/src/fs/utils/inode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/inode.rs\n@@ -285,6 +285,10 @@ pub trait Inode: Any + Sync + Send {\n         Err(Error::new(Errno::ENOTDIR))\n     }\n \n+    fn as_device(&self) -> Option<Arc<dyn Device>> {\n+        None\n+    }\n+\n     fn readdir_at(&self, offset: usize, visitor: &mut dyn DirentVisitor) -> Result<usize> {\n         Err(Error::new(Errno::ENOTDIR))\n     }\ndiff --git a/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\nindex e0d9b4dbdf..fa38ab0c21 100644\n--- a/services/libs/jinux-std/src/process/clone.rs\n+++ b/services/libs/jinux-std/src/process/clone.rs\n@@ -1,26 +1,20 @@\n-use jinux_frame::{cpu::UserContext, user::UserSpace, vm::VmIo};\n-\n+use super::posix_thread::{PosixThread, PosixThreadBuilder, PosixThreadExt, ThreadName};\n+use super::process_vm::ProcessVm;\n+use super::signal::sig_disposition::SigDispositions;\n+use super::{process_table, Process, ProcessBuilder};\n+use crate::current_thread;\n+use crate::fs::file_table::FileTable;\n+use crate::fs::fs_resolver::FsResolver;\n+use crate::fs::utils::FileCreationMask;\n+use crate::prelude::*;\n+use crate::thread::{allocate_tid, thread_table, Thread, Tid};\n+use crate::util::write_val_to_user;\n+use crate::vm::vmar::Vmar;\n+use jinux_frame::cpu::UserContext;\n+use jinux_frame::user::UserSpace;\n+use jinux_frame::vm::VmIo;\n use jinux_rights::Full;\n \n-use crate::{\n-    current_thread,\n-    fs::file_table::FileTable,\n-    fs::{fs_resolver::FsResolver, utils::FileCreationMask},\n-    prelude::*,\n-    process::{\n-        posix_thread::{PosixThreadBuilder, PosixThreadExt, ThreadName},\n-        process_table,\n-    },\n-    thread::{allocate_tid, thread_table, Thread, Tid},\n-    util::write_val_to_user,\n-    vm::vmar::Vmar,\n-};\n-\n-use super::{\n-    posix_thread::PosixThread, process_vm::ProcessVm, signal::sig_disposition::SigDispositions,\n-    Process, ProcessBuilder,\n-};\n-\n bitflags! {\n     pub struct CloneFlags: u32 {\n         const CLONE_VM      = 0x00000100;       /* Set if VM shared between processes.  */\n@@ -275,16 +269,13 @@ fn clone_child_process(parent_context: UserContext, clone_args: CloneArgs) -> Re\n             .file_table(child_file_table)\n             .fs(child_fs)\n             .umask(child_umask)\n-            .sig_dispositions(child_sig_dispositions)\n-            .process_group(current.process_group().unwrap());\n+            .sig_dispositions(child_sig_dispositions);\n \n         process_builder.build()?\n     };\n \n-    current!().add_child(child.clone());\n-    process_table::add_process(child.clone());\n-\n-    let child_thread = thread_table::tid_to_thread(child_tid).unwrap();\n+    // Deals with clone flags\n+    let child_thread = thread_table::get_thread(child_tid).unwrap();\n     let child_posix_thread = child_thread.as_posix_thread().unwrap();\n     clone_parent_settid(child_tid, clone_args.parent_tidptr, clone_flags)?;\n     clone_child_cleartid(child_posix_thread, clone_args.child_tidptr, clone_flags)?;\n@@ -296,6 +287,10 @@ fn clone_child_process(parent_context: UserContext, clone_args: CloneArgs) -> Re\n         clone_args.child_tidptr,\n         clone_flags,\n     )?;\n+\n+    // Sets parent process and group for child process.\n+    set_parent_and_group(&current, &child);\n+\n     Ok(child)\n }\n \n@@ -414,3 +409,19 @@ fn clone_sysvsem(clone_flags: CloneFlags) -> Result<()> {\n     }\n     Ok(())\n }\n+\n+fn set_parent_and_group(parent: &Arc<Process>, child: &Arc<Process>) {\n+    let process_group = parent.process_group().unwrap();\n+\n+    let mut process_table_mut = process_table::process_table_mut();\n+    let mut group_inner = process_group.inner.lock();\n+    let mut child_group_mut = child.process_group.lock();\n+    let mut children_mut = parent.children().lock();\n+\n+    children_mut.insert(child.pid(), child.clone());\n+\n+    group_inner.processes.insert(child.pid(), child.clone());\n+    *child_group_mut = Arc::downgrade(&process_group);\n+\n+    process_table_mut.insert(child.pid(), child.clone());\n+}\ndiff --git a/services/libs/jinux-std/src/process/exit.rs b/services/libs/jinux-std/src/process/exit.rs\nindex 8857923f94..2bd217f71c 100644\n--- a/services/libs/jinux-std/src/process/exit.rs\n+++ b/services/libs/jinux-std/src/process/exit.rs\n@@ -37,9 +37,11 @@ pub fn do_exit_group(term_status: TermStatus) {\n     // Move children to the init process\n     if !is_init_process(&current) {\n         if let Some(init_process) = get_init_process() {\n+            let mut init_children = init_process.children().lock();\n             for (_, child_process) in current.children().lock().extract_if(|_, _| true) {\n-                child_process.set_parent(Arc::downgrade(&init_process));\n-                init_process.add_child(child_process);\n+                let mut parent = child_process.parent.lock();\n+                init_children.insert(child_process.pid(), child_process.clone());\n+                *parent = Arc::downgrade(&init_process);\n             }\n         }\n     }\n@@ -56,7 +58,7 @@ const INIT_PROCESS_PID: Pid = 1;\n \n /// Get the init process\n fn get_init_process() -> Option<Arc<Process>> {\n-    process_table::pid_to_process(INIT_PROCESS_PID)\n+    process_table::get_process(&INIT_PROCESS_PID)\n }\n \n fn is_init_process(process: &Process) -> bool {\ndiff --git a/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\nindex b467a525a8..5aa8884a81 100644\n--- a/services/libs/jinux-std/src/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/mod.rs\n@@ -4,7 +4,6 @@ pub mod posix_thread;\n #[allow(clippy::module_inception)]\n mod process;\n mod process_filter;\n-mod process_group;\n pub mod process_table;\n mod process_vm;\n mod program_loader;\n@@ -17,9 +16,10 @@ mod wait;\n pub use clone::{clone_child, CloneArgs, CloneFlags};\n pub use exit::do_exit_group;\n pub use process::ProcessBuilder;\n-pub use process::{current, ExitCode, Pgid, Pid, Process};\n+pub use process::{\n+    current, ExitCode, JobControl, Pgid, Pid, Process, ProcessGroup, Session, Sid, Terminal,\n+};\n pub use process_filter::ProcessFilter;\n-pub use process_group::ProcessGroup;\n pub use program_loader::{check_executable_file, load_program_to_vm};\n pub use rlimit::ResourceType;\n pub use term_status::TermStatus;\ndiff --git a/services/libs/jinux-std/src/process/process/builder.rs b/services/libs/jinux-std/src/process/process/builder.rs\nindex def036130c..dd49dcc399 100644\n--- a/services/libs/jinux-std/src/process/process/builder.rs\n+++ b/services/libs/jinux-std/src/process/process/builder.rs\n@@ -1,12 +1,10 @@\n use crate::fs::file_table::FileTable;\n use crate::fs::fs_resolver::FsResolver;\n use crate::fs::utils::FileCreationMask;\n-use crate::process::posix_thread::PosixThreadBuilder;\n-use crate::process::process_group::ProcessGroup;\n-use crate::process::process_table;\n+use crate::process::posix_thread::{PosixThreadBuilder, PosixThreadExt};\n use crate::process::process_vm::ProcessVm;\n use crate::process::rlimit::ResourceLimits;\n-use crate::process::{posix_thread::PosixThreadExt, signal::sig_disposition::SigDispositions};\n+use crate::process::signal::sig_disposition::SigDispositions;\n use crate::thread::Thread;\n \n use super::{Pid, Process};\n@@ -23,7 +21,6 @@ pub struct ProcessBuilder<'a> {\n     argv: Option<Vec<CString>>,\n     envp: Option<Vec<CString>>,\n     process_vm: Option<ProcessVm>,\n-    process_group: Option<Arc<ProcessGroup>>,\n     file_table: Option<Arc<Mutex<FileTable>>>,\n     fs: Option<Arc<RwLock<FsResolver>>>,\n     umask: Option<Arc<RwLock<FileCreationMask>>>,\n@@ -41,7 +38,6 @@ impl<'a> ProcessBuilder<'a> {\n             argv: None,\n             envp: None,\n             process_vm: None,\n-            process_group: None,\n             file_table: None,\n             fs: None,\n             umask: None,\n@@ -60,11 +56,6 @@ impl<'a> ProcessBuilder<'a> {\n         self\n     }\n \n-    pub fn process_group(&mut self, process_group: Arc<ProcessGroup>) -> &mut Self {\n-        self.process_group = Some(process_group);\n-        self\n-    }\n-\n     pub fn file_table(&mut self, file_table: Arc<Mutex<FileTable>>) -> &mut Self {\n         self.file_table = Some(file_table);\n         self\n@@ -126,7 +117,6 @@ impl<'a> ProcessBuilder<'a> {\n             argv,\n             envp,\n             process_vm,\n-            process_group,\n             file_table,\n             fs,\n             umask,\n@@ -136,10 +126,6 @@ impl<'a> ProcessBuilder<'a> {\n \n         let process_vm = process_vm.or_else(|| Some(ProcessVm::alloc())).unwrap();\n \n-        let process_group_ref = process_group\n-            .as_ref()\n-            .map_or_else(Weak::new, Arc::downgrade);\n-\n         let file_table = file_table\n             .or_else(|| Some(Arc::new(Mutex::new(FileTable::new_with_stdio()))))\n             .unwrap();\n@@ -168,7 +154,6 @@ impl<'a> ProcessBuilder<'a> {\n                 threads,\n                 executable_path.to_string(),\n                 process_vm,\n-                process_group_ref,\n                 file_table,\n                 fs,\n                 umask,\n@@ -194,15 +179,6 @@ impl<'a> ProcessBuilder<'a> {\n \n         process.threads().lock().push(thread);\n \n-        if let Some(process_group) = process_group {\n-            process_group.add_process(process.clone());\n-        } else {\n-            let new_process_group = Arc::new(ProcessGroup::new(process.clone()));\n-            let pgid = new_process_group.pgid();\n-            process.set_process_group(Arc::downgrade(&new_process_group));\n-            process_table::add_process_group(new_process_group);\n-        }\n-\n         process.set_runnable();\n \n         Ok(process)\ndiff --git a/services/libs/jinux-std/src/process/process/job_control.rs b/services/libs/jinux-std/src/process/process/job_control.rs\nnew file mode 100644\nindex 0000000000..d5af056c65\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/job_control.rs\n@@ -0,0 +1,161 @@\n+use crate::prelude::*;\n+use crate::process::signal::constants::{SIGCONT, SIGHUP};\n+use crate::process::signal::signals::kernel::KernelSignal;\n+use crate::process::signal::Pauser;\n+use crate::process::{ProcessGroup, Session};\n+\n+/// The job control for terminals like tty and pty.\n+///\n+/// This struct is used to support shell job control, which allows users to\n+/// run commands in the foreground or in the background. This struct manages\n+/// the session and foreground process group for a terminal.\n+pub struct JobControl {\n+    foreground: SpinLock<Weak<ProcessGroup>>,\n+    session: SpinLock<Weak<Session>>,\n+    pauser: Arc<Pauser>,\n+}\n+\n+impl JobControl {\n+    /// Creates a new `TtyJobControl`\n+    pub fn new() -> Self {\n+        Self {\n+            foreground: SpinLock::new(Weak::new()),\n+            session: SpinLock::new(Weak::new()),\n+            pauser: Pauser::new(),\n+        }\n+    }\n+\n+    // *************** Session ***************\n+\n+    /// Returns the session whose controlling terminal is the terminal.\n+    fn session(&self) -> Option<Arc<Session>> {\n+        self.session.lock().upgrade()\n+    }\n+\n+    /// Sets the terminal as the controlling terminal of the `session`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This terminal should not belong to any session.\n+    pub fn set_session(&self, session: &Arc<Session>) {\n+        debug_assert!(self.session().is_none());\n+        *self.session.lock() = Arc::downgrade(session);\n+    }\n+\n+    /// Sets the terminal as the controlling terminal of the session of current process.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This function should only be called in process context.\n+    pub fn set_current_session(&self) -> Result<()> {\n+        if self.session().is_some() {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"the terminal is already controlling terminal of another session\"\n+            );\n+        }\n+\n+        let current = current!();\n+\n+        let process_group = current.process_group().unwrap();\n+        *self.foreground.lock() = Arc::downgrade(&process_group);\n+\n+        let session = current.session().unwrap();\n+        *self.session.lock() = Arc::downgrade(&session);\n+\n+        self.pauser.resume_all();\n+        Ok(())\n+    }\n+\n+    /// Releases the current session from this terminal.\n+    pub fn release_current_session(&self) -> Result<()> {\n+        let Some(session) = self.session() else {\n+            return_errno_with_message!(\n+                Errno::ENOTTY,\n+                \"the terminal is not controlling terminal now\"\n+            );\n+        };\n+\n+        if let Some(foreground) = self.foreground() {\n+            foreground.broadcast_signal(KernelSignal::new(SIGHUP));\n+            foreground.broadcast_signal(KernelSignal::new(SIGCONT));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    // *************** Foreground process group ***************\n+\n+    /// Returns the foreground process group\n+    pub fn foreground(&self) -> Option<Arc<ProcessGroup>> {\n+        self.foreground.lock().upgrade()\n+    }\n+\n+    /// Sets the foreground process group.\n+    ///\n+    /// # Panic\n+    ///\n+    /// The process group should belong to one session.\n+    pub fn set_foreground(&self, process_group: Option<&Arc<ProcessGroup>>) -> Result<()> {\n+        let Some(process_group) = process_group else {\n+            // FIXME: should we allow this branch?\n+            *self.foreground.lock() = Weak::new();\n+            return Ok(());\n+        };\n+\n+        let session = process_group.session().unwrap();\n+        let Some(terminal_session) = self.session() else {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"the terminal does not become controlling terminal of one session.\"\n+            );\n+        };\n+\n+        if !Arc::ptr_eq(&terminal_session, &session) {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"the process proup belongs to different session\"\n+            );\n+        }\n+\n+        *self.foreground.lock() = Arc::downgrade(process_group);\n+        self.pauser.resume_all();\n+        Ok(())\n+    }\n+\n+    /// Wait until the current process is the foreground process group. If\n+    /// the foreground process group is None, returns true.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This function should only be called in process context.\n+    pub fn wait_until_in_foreground(&self) -> Result<()> {\n+        // Fast path\n+        if self.current_belongs_to_foreground() {\n+            return Ok(());\n+        }\n+\n+        // Slow path\n+        self.pauser.pause_until(|| {\n+            if self.current_belongs_to_foreground() {\n+                Some(())\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    fn current_belongs_to_foreground(&self) -> bool {\n+        let Some(foreground) = self.foreground() else {\n+            return true;\n+        };\n+\n+        foreground.contains_process(current!().pid())\n+    }\n+}\n+\n+impl Default for JobControl {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/process/process/mod.rs b/services/libs/jinux-std/src/process/process/mod.rs\nindex 4767861249..ee12e34839 100644\n--- a/services/libs/jinux-std/src/process/process/mod.rs\n+++ b/services/libs/jinux-std/src/process/process/mod.rs\n@@ -1,7 +1,4 @@\n-mod builder;\n-\n use super::posix_thread::PosixThreadExt;\n-use super::process_group::ProcessGroup;\n use super::process_vm::user_heap::UserHeap;\n use super::process_vm::ProcessVm;\n use super::rlimit::ResourceLimits;\n@@ -13,7 +10,7 @@ use super::signal::signals::Signal;\n use super::signal::{Pauser, SigEvents, SigEventsFilter};\n use super::status::ProcessStatus;\n use super::{process_table, TermStatus};\n-use crate::device::tty::get_n_tty;\n+use crate::device::tty::open_ntty_as_controlling_terminal;\n use crate::events::Observer;\n use crate::fs::file_table::FileTable;\n use crate::fs::fs_resolver::FsResolver;\n@@ -23,10 +20,25 @@ use crate::thread::{allocate_tid, Thread};\n use crate::vm::vmar::Vmar;\n use jinux_rights::Full;\n \n+mod builder;\n+mod job_control;\n+mod process_group;\n+mod session;\n+mod terminal;\n+\n pub use builder::ProcessBuilder;\n+pub use job_control::JobControl;\n+pub use process_group::ProcessGroup;\n+pub use session::Session;\n+pub use terminal::Terminal;\n \n+/// Process id.\n pub type Pid = u32;\n+/// Process group id.\n pub type Pgid = u32;\n+/// Session Id.\n+pub type Sid = u32;\n+\n pub type ExitCode = i32;\n \n /// Process stands for a set of threads that shares the same userspace.\n@@ -46,11 +58,11 @@ pub struct Process {\n     /// Process status\n     status: Mutex<ProcessStatus>,\n     /// Parent process\n-    parent: Mutex<Weak<Process>>,\n+    pub(super) parent: Mutex<Weak<Process>>,\n     /// Children processes\n     children: Mutex<BTreeMap<Pid, Arc<Process>>>,\n     /// Process group\n-    process_group: Mutex<Weak<ProcessGroup>>,\n+    pub(super) process_group: Mutex<Weak<ProcessGroup>>,\n     /// File table\n     file_table: Arc<Mutex<FileTable>>,\n     /// FsResolver\n@@ -75,7 +87,6 @@ impl Process {\n         threads: Vec<Arc<Thread>>,\n         executable_path: String,\n         process_vm: ProcessVm,\n-        process_group: Weak<ProcessGroup>,\n         file_table: Arc<Mutex<FileTable>>,\n         fs: Arc<RwLock<FsResolver>>,\n         umask: Arc<RwLock<FileCreationMask>>,\n@@ -99,7 +110,7 @@ impl Process {\n             status: Mutex::new(ProcessStatus::Uninit),\n             parent: Mutex::new(parent),\n             children: Mutex::new(BTreeMap::new()),\n-            process_group: Mutex::new(process_group),\n+            process_group: Mutex::new(Weak::new()),\n             file_table,\n             fs,\n             umask,\n@@ -118,11 +129,9 @@ impl Process {\n         // spawn user process should give an absolute path\n         debug_assert!(executable_path.starts_with('/'));\n         let process = Process::create_user_process(executable_path, argv, envp)?;\n-        // FIXME: How to determine the fg process group?\n-        let process_group = Weak::clone(&process.process_group.lock());\n-        // FIXME: tty should be a parameter?\n-        let tty = get_n_tty();\n-        tty.set_fg(process_group);\n+\n+        open_ntty_as_controlling_terminal(&process)?;\n+\n         process.run();\n         Ok(process)\n     }\n@@ -141,7 +150,25 @@ impl Process {\n         };\n \n         let process = process_builder.build()?;\n-        process_table::add_process(process.clone());\n+\n+        // Lock order: session table -> group table -> process table -> group of process\n+        // -> group inner -> session inner\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut process_table_mut = process_table::process_table_mut();\n+\n+        // Creates new group\n+        let group = ProcessGroup::new(process.clone());\n+        *process.process_group.lock() = Arc::downgrade(&group);\n+        group_table_mut.insert(group.pgid(), group.clone());\n+\n+        // Creates new session\n+        let session = Session::new(group.clone());\n+        group.inner.lock().session = Arc::downgrade(&session);\n+        session.inner.lock().leader = Some(process.clone());\n+        session_table_mut.insert(session.sid(), session);\n+\n+        process_table_mut.insert(process.pid(), process.clone());\n         Ok(process)\n     }\n \n@@ -180,30 +207,25 @@ impl Process {\n     }\n \n     // *********** Parent and child ***********\n-\n-    pub fn add_child(&self, child: Arc<Process>) {\n-        let child_pid = child.pid();\n-        self.children.lock().insert(child_pid, child);\n-    }\n-\n-    pub fn set_parent(&self, parent: Weak<Process>) {\n-        *self.parent.lock() = parent;\n-    }\n-\n     pub fn parent(&self) -> Option<Arc<Process>> {\n         self.parent.lock().upgrade()\n     }\n \n-    pub fn children(&self) -> &Mutex<BTreeMap<Pid, Arc<Process>>> {\n+    pub(super) fn children(&self) -> &Mutex<BTreeMap<Pid, Arc<Process>>> {\n         &self.children\n     }\n \n+    pub fn has_child(&self, pid: &Pid) -> bool {\n+        self.children.lock().contains_key(pid)\n+    }\n+\n     pub fn children_pauser(&self) -> &Arc<Pauser> {\n         &self.children_pauser\n     }\n \n-    // *********** Process group ***********\n+    // *********** Process group & Session***********\n \n+    /// Returns the process group id of the process.\n     pub fn pgid(&self) -> Pgid {\n         if let Some(process_group) = self.process_group.lock().upgrade() {\n             process_group.pgid()\n@@ -212,17 +234,237 @@ impl Process {\n         }\n     }\n \n-    /// Set process group for current process. If old process group exists,\n-    /// remove current process from old process group.\n-    pub fn set_process_group(&self, process_group: Weak<ProcessGroup>) {\n-        if let Some(old_process_group) = self.process_group() {\n-            old_process_group.remove_process(self.pid());\n+    /// Returns the process group which the process belongs to.\n+    pub fn process_group(&self) -> Option<Arc<ProcessGroup>> {\n+        self.process_group.lock().upgrade()\n+    }\n+\n+    /// Returns whether `self` is the leader of process group.\n+    fn is_group_leader(self: &Arc<Self>) -> bool {\n+        let Some(process_group) = self.process_group() else {\n+            return false;\n+        };\n+\n+        let Some(leader) = process_group.leader() else {\n+            return false;\n+        };\n+\n+        Arc::ptr_eq(self, &leader)\n+    }\n+\n+    /// Returns the session which the process belongs to.\n+    pub fn session(&self) -> Option<Arc<Session>> {\n+        let process_group = self.process_group()?;\n+        process_group.session()\n+    }\n+\n+    /// Returns whether the process is session leader.\n+    pub fn is_session_leader(self: &Arc<Self>) -> bool {\n+        let session = self.session().unwrap();\n+\n+        let Some(leading_process) = session.leader() else {\n+            return false;\n+        };\n+\n+        Arc::ptr_eq(self, &leading_process)\n+    }\n+\n+    /// Moves the process to the new session.\n+    ///\n+    /// If the process is already session leader, this method does nothing.\n+    ///\n+    /// Otherwise, this method creates a new process group in a new session\n+    /// and moves the process to the session, returning the new session.\n+    ///\n+    /// This method may return the following errors:\n+    /// * `EPERM`, if the process is a process group leader, or some existing session\n+    /// or process group has the same id as the process.\n+    pub fn to_new_session(self: &Arc<Self>) -> Result<Arc<Session>> {\n+        if self.is_session_leader() {\n+            return Ok(self.session().unwrap());\n+        }\n+\n+        if self.is_group_leader() {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"process group leader cannot be moved to new session.\"\n+            );\n+        }\n+\n+        let session = self.session().unwrap();\n+\n+        // Lock order: session table -> group table -> group of process -> group inner -> session inner\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut self_group_mut = self.process_group.lock();\n+\n+        if session_table_mut.contains_key(&self.pid) {\n+            return_errno_with_message!(Errno::EPERM, \"cannot create new session\");\n+        }\n+\n+        if group_table_mut.contains_key(&self.pid) {\n+            return_errno_with_message!(Errno::EPERM, \"cannot create process group\");\n+        }\n+\n+        // Removes the process from old group\n+        if let Some(old_group) = self_group_mut.upgrade() {\n+            let mut group_inner = old_group.inner.lock();\n+            let mut session_inner = session.inner.lock();\n+            group_inner.remove_process(&self.pid);\n+            *self_group_mut = Weak::new();\n+\n+            if group_inner.is_empty() {\n+                group_table_mut.remove(&old_group.pgid());\n+                debug_assert!(session_inner.process_groups.contains_key(&old_group.pgid()));\n+                session_inner.process_groups.remove(&old_group.pgid());\n+\n+                if session_inner.is_empty() {\n+                    session_table_mut.remove(&session.sid());\n+                }\n+            }\n         }\n-        *self.process_group.lock() = process_group;\n+\n+        // Creates a new process group\n+        let new_group = ProcessGroup::new(self.clone());\n+        *self_group_mut = Arc::downgrade(&new_group);\n+        group_table_mut.insert(new_group.pgid(), new_group.clone());\n+\n+        // Creates a new session\n+        let new_session = Session::new(new_group.clone());\n+        let mut new_group_inner = new_group.inner.lock();\n+        new_group_inner.session = Arc::downgrade(&new_session);\n+        new_session.inner.lock().leader = Some(self.clone());\n+        session_table_mut.insert(new_session.sid(), new_session.clone());\n+\n+        // Removes the process from session.\n+        let mut session_inner = session.inner.lock();\n+        session_inner.remove_process(self);\n+\n+        Ok(new_session)\n+    }\n+\n+    /// Moves the process to other process group.\n+    ///\n+    /// * If the group already exists, the process and the group should belong to the same session.\n+    /// * If the group does not exist, this method creates a new group for the process and move the\n+    /// process to the group. The group is added to the session of the process.\n+    ///\n+    /// This method may return `EPERM` in following cases:\n+    /// * The process is session leader;\n+    /// * The group already exists, but the group does not belong to the same session as the process;\n+    /// * The group does not exist, but `pgid` is not equal to `pid` of the process.\n+    pub fn to_other_group(self: &Arc<Self>, pgid: Pgid) -> Result<()> {\n+        // if the process already belongs to the process group\n+        if self.pgid() == pgid {\n+            return Ok(());\n+        }\n+\n+        if self.is_session_leader() {\n+            return_errno_with_message!(Errno::EPERM, \"the process cannot be a session leader\");\n+        }\n+\n+        if let Some(process_group) = process_table::get_process_group(&pgid) {\n+            let session = self.session().unwrap();\n+            if !session.contains_process_group(&process_group) {\n+                return_errno_with_message!(\n+                    Errno::EPERM,\n+                    \"the group and process does not belong to same session\"\n+                );\n+            }\n+            self.to_specified_group(&process_group)?;\n+        } else {\n+            if pgid != self.pid() {\n+                return_errno_with_message!(\n+                    Errno::EPERM,\n+                    \"the new process group should have the same id as the process.\"\n+                );\n+            }\n+\n+            self.to_new_group()?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Creates a new process group and moves the process to the group.\n+    ///\n+    /// The new group will be added to the same session as the process.\n+    fn to_new_group(self: &Arc<Self>) -> Result<()> {\n+        let session = self.session().unwrap();\n+        // Lock order: group table -> group of process -> group inner -> session inner\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut self_group_mut = self.process_group.lock();\n+\n+        // Removes the process from old group\n+        if let Some(old_group) = self_group_mut.upgrade() {\n+            let mut group_inner = old_group.inner.lock();\n+            let mut session_inner = session.inner.lock();\n+            group_inner.remove_process(&self.pid);\n+            *self_group_mut = Weak::new();\n+\n+            if group_inner.is_empty() {\n+                group_table_mut.remove(&old_group.pgid());\n+                debug_assert!(session_inner.process_groups.contains_key(&old_group.pgid()));\n+                // The old session won't be empty, since we will add a new group to the session.\n+                session_inner.process_groups.remove(&old_group.pgid());\n+            }\n+        }\n+\n+        // Creates a new process group. Adds the new group to group table and session.\n+        let new_group = ProcessGroup::new(self.clone());\n+\n+        let mut new_group_inner = new_group.inner.lock();\n+        let mut session_inner = session.inner.lock();\n+\n+        *self_group_mut = Arc::downgrade(&new_group);\n+\n+        group_table_mut.insert(new_group.pgid(), new_group.clone());\n+\n+        new_group_inner.session = Arc::downgrade(&session);\n+        session_inner\n+            .process_groups\n+            .insert(new_group.pgid(), new_group.clone());\n+\n+        Ok(())\n     }\n \n-    pub fn process_group(&self) -> Option<Arc<ProcessGroup>> {\n-        self.process_group.lock().upgrade()\n+    /// Moves the process to a specified group.\n+    ///\n+    /// The caller needs to ensure that the process and the group belongs to the same session.\n+    fn to_specified_group(self: &Arc<Process>, group: &Arc<ProcessGroup>) -> Result<()> {\n+        // Lock order: group table -> group of process -> group inner (small pgid -> big pgid)\n+        let mut group_table_mut = process_table::group_table_mut();\n+        let mut self_group_mut = self.process_group.lock();\n+\n+        // Removes the process from old group\n+        let mut group_inner = if let Some(old_group) = self_group_mut.upgrade() {\n+            // Lock order: group with smaller pgid first\n+            let (mut old_group_inner, group_inner) = match old_group.pgid().cmp(&group.pgid()) {\n+                core::cmp::Ordering::Equal => return Ok(()),\n+                core::cmp::Ordering::Less => (old_group.inner.lock(), group.inner.lock()),\n+                core::cmp::Ordering::Greater => {\n+                    let group_inner = group.inner.lock();\n+                    let old_group_inner = old_group.inner.lock();\n+                    (old_group_inner, group_inner)\n+                }\n+            };\n+            old_group_inner.remove_process(&self.pid);\n+            *self_group_mut = Weak::new();\n+\n+            if old_group_inner.is_empty() {\n+                group_table_mut.remove(&old_group.pgid());\n+            }\n+\n+            group_inner\n+        } else {\n+            group.inner.lock()\n+        };\n+\n+        // Adds the process to the specified group\n+        group_inner.processes.insert(self.pid, self.clone());\n+        *self_group_mut = Arc::downgrade(group);\n+\n+        Ok(())\n     }\n \n     // ************** Virtual Memory *************\n@@ -319,3 +561,100 @@ pub fn current() -> Arc<Process> {\n         panic!(\"[Internal error]The current thread does not belong to a process\");\n     }\n }\n+\n+#[if_cfg_ktest]\n+mod test {\n+    use super::*;\n+\n+    fn new_process(parent: Option<Arc<Process>>) -> Arc<Process> {\n+        crate::fs::rootfs::init_root_mount();\n+        let pid = allocate_tid();\n+        let parent = if let Some(parent) = parent {\n+            Arc::downgrade(&parent)\n+        } else {\n+            Weak::new()\n+        };\n+        Arc::new(Process::new(\n+            pid,\n+            parent,\n+            vec![],\n+            String::new(),\n+            ProcessVm::alloc(),\n+            Arc::new(Mutex::new(FileTable::new())),\n+            Arc::new(RwLock::new(FsResolver::new())),\n+            Arc::new(RwLock::new(FileCreationMask::default())),\n+            Arc::new(Mutex::new(SigDispositions::default())),\n+            ResourceLimits::default(),\n+        ))\n+    }\n+\n+    fn new_process_in_session(parent: Option<Arc<Process>>) -> Arc<Process> {\n+        // Lock order: session table -> group table -> group of process -> group inner\n+        // -> session inner\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+\n+        let process = new_process(parent);\n+        // Creates new group\n+        let group = ProcessGroup::new(process.clone());\n+        *process.process_group.lock() = Arc::downgrade(&group);\n+\n+        // Creates new session\n+        let sess = Session::new(group.clone());\n+        group.inner.lock().session = Arc::downgrade(&sess);\n+        sess.inner.lock().leader = Some(process.clone());\n+\n+        group_table_mut.insert(group.pgid(), group);\n+        session_table_mut.insert(sess.sid(), sess);\n+\n+        process\n+    }\n+\n+    fn remove_session_and_group(process: Arc<Process>) {\n+        // Lock order: session table -> group table\n+        let mut session_table_mut = process_table::session_table_mut();\n+        let mut group_table_mut = process_table::group_table_mut();\n+        if let Some(sess) = process.session() {\n+            session_table_mut.remove(&sess.sid());\n+        }\n+\n+        if let Some(group) = process.process_group() {\n+            group_table_mut.remove(&group.pgid());\n+        }\n+    }\n+\n+    #[ktest]\n+    fn init_process() {\n+        let process = new_process(None);\n+        assert!(process.process_group().is_none());\n+        assert!(process.session().is_none());\n+    }\n+\n+    #[ktest]\n+    fn init_process_in_session() {\n+        let process = new_process_in_session(None);\n+        assert!(process.is_group_leader());\n+        assert!(process.is_session_leader());\n+        remove_session_and_group(process);\n+    }\n+\n+    #[ktest]\n+    fn to_new_session() {\n+        let process = new_process_in_session(None);\n+        let sess = process.session().unwrap();\n+        sess.inner.lock().leader = None;\n+\n+        assert!(!process.is_session_leader());\n+        assert!(process\n+            .to_new_session()\n+            .is_err_and(|e| e.error() == Errno::EPERM));\n+\n+        let group = process.process_group().unwrap();\n+        group.inner.lock().leader = None;\n+        assert!(!process.is_group_leader());\n+\n+        assert!(process\n+            .to_new_session()\n+            .is_err_and(|e| e.error() == Errno::EPERM));\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/process/process/process_group.rs b/services/libs/jinux-std/src/process/process/process_group.rs\nnew file mode 100644\nindex 0000000000..3cc8190502\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/process_group.rs\n@@ -0,0 +1,84 @@\n+use super::{Pgid, Pid, Process, Session};\n+use crate::prelude::*;\n+use crate::process::signal::signals::Signal;\n+\n+/// `ProcessGroup` represents a set of processes. Each `ProcessGroup` has a unique\n+/// identifier `pgid`.\n+pub struct ProcessGroup {\n+    pgid: Pgid,\n+    pub(in crate::process) inner: Mutex<Inner>,\n+}\n+\n+pub(in crate::process) struct Inner {\n+    pub(in crate::process) processes: BTreeMap<Pid, Arc<Process>>,\n+    pub(in crate::process) leader: Option<Arc<Process>>,\n+    pub(in crate::process) session: Weak<Session>,\n+}\n+\n+impl Inner {\n+    pub(in crate::process) fn remove_process(&mut self, pid: &Pid) {\n+        let Some(process) = self.processes.remove(pid) else {\n+            return;\n+        };\n+\n+        if let Some(leader) = &self.leader && Arc::ptr_eq(leader, &process) {\n+            self.leader = None;\n+        }\n+    }\n+\n+    pub(in crate::process) fn is_empty(&self) -> bool {\n+        self.processes.is_empty()\n+    }\n+}\n+\n+impl ProcessGroup {\n+    /// Creates a new process group with one process. The pgid is the same as the process\n+    /// id. The process will become the leading process of the new process group.\n+    ///\n+    /// The caller needs to ensure that the process does not belong to any group.\n+    pub(in crate::process) fn new(process: Arc<Process>) -> Arc<Self> {\n+        let pid = process.pid();\n+\n+        let inner = {\n+            let mut processes = BTreeMap::new();\n+            processes.insert(pid, process.clone());\n+            Inner {\n+                processes,\n+                leader: Some(process.clone()),\n+                session: Weak::new(),\n+            }\n+        };\n+\n+        Arc::new(ProcessGroup {\n+            pgid: pid,\n+            inner: Mutex::new(inner),\n+        })\n+    }\n+\n+    /// Returns whether self contains a process with `pid`.\n+    pub(in crate::process) fn contains_process(&self, pid: Pid) -> bool {\n+        self.inner.lock().processes.contains_key(&pid)\n+    }\n+\n+    /// Returns the process group identifier\n+    pub fn pgid(&self) -> Pgid {\n+        self.pgid\n+    }\n+\n+    /// Broadcasts signal to all processes in the group.\n+    pub fn broadcast_signal(&self, signal: impl Signal + Clone + 'static) {\n+        for process in self.inner.lock().processes.values() {\n+            process.enqueue_signal(Box::new(signal.clone()));\n+        }\n+    }\n+\n+    /// Returns the leader process.\n+    pub fn leader(&self) -> Option<Arc<Process>> {\n+        self.inner.lock().leader.clone()\n+    }\n+\n+    /// Returns the session which the group belongs to\n+    pub fn session(&self) -> Option<Arc<Session>> {\n+        self.inner.lock().session.upgrade()\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/process/process/session.rs b/services/libs/jinux-std/src/process/process/session.rs\nnew file mode 100644\nindex 0000000000..18ff44c4f5\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/session.rs\n@@ -0,0 +1,133 @@\n+use crate::prelude::*;\n+\n+use super::{Pgid, Process, ProcessGroup, Sid, Terminal};\n+\n+/// A `Session` is a collection of related process groups. Each session has a\n+/// unique identifier `sid`. Process groups and sessions form a two-level\n+/// hierarchical relationship between processes.\n+///\n+/// **Leader**: A *session leader* is the process that creates a new session and whose process\n+/// ID becomes the session ID.\n+///\n+/// **Controlling terminal**: The terminal can be used to manage all processes in the session. The\n+/// controlling terminal is established when the session leader first opens a terminal.\n+pub struct Session {\n+    sid: Sid,\n+    pub(in crate::process) inner: Mutex<Inner>,\n+}\n+\n+pub(in crate::process) struct Inner {\n+    pub(in crate::process) process_groups: BTreeMap<Pgid, Arc<ProcessGroup>>,\n+    pub(in crate::process) leader: Option<Arc<Process>>,\n+    pub(in crate::process) terminal: Option<Arc<dyn Terminal>>,\n+}\n+\n+impl Inner {\n+    pub(in crate::process) fn is_empty(&self) -> bool {\n+        self.process_groups.is_empty()\n+    }\n+\n+    pub(in crate::process) fn remove_process(&mut self, process: &Arc<Process>) {\n+        if let Some(leader) = &self.leader && Arc::ptr_eq(leader, process) {\n+            self.leader = None;\n+        }\n+    }\n+\n+    pub(in crate::process) fn remove_process_group(&mut self, pgid: &Pgid) {\n+        self.process_groups.remove(pgid);\n+    }\n+}\n+\n+impl Session {\n+    /// Creates a new session for the process group. The process group becomes the member of\n+    /// the new session.\n+    ///\n+    /// The caller needs to ensure that the group does not belong to any session, and the caller\n+    /// should set the leader process after creating the session.\n+    pub(in crate::process) fn new(group: Arc<ProcessGroup>) -> Arc<Self> {\n+        let sid = group.pgid();\n+        let inner = {\n+            let mut process_groups = BTreeMap::new();\n+            process_groups.insert(group.pgid(), group);\n+\n+            Inner {\n+                process_groups,\n+                leader: None,\n+                terminal: None,\n+            }\n+        };\n+        Arc::new(Self {\n+            sid,\n+            inner: Mutex::new(inner),\n+        })\n+    }\n+\n+    /// Returns the session id\n+    pub fn sid(&self) -> Sid {\n+        self.sid\n+    }\n+\n+    /// Returns the leader process.\n+    pub fn leader(&self) -> Option<Arc<Process>> {\n+        self.inner.lock().leader.clone()\n+    }\n+\n+    /// Returns whether `self` contains the `process_group`\n+    pub(in crate::process) fn contains_process_group(\n+        self: &Arc<Self>,\n+        process_group: &Arc<ProcessGroup>,\n+    ) -> bool {\n+        self.inner\n+            .lock()\n+            .process_groups\n+            .contains_key(&process_group.pgid())\n+    }\n+\n+    /// Sets terminal as the controlling terminal of the session. The `get_terminal` method\n+    /// should set the session for the terminal and returns the session.\n+    ///\n+    /// If the session already has controlling terminal, this method will return `Err(EPERM)`.\n+    pub fn set_terminal<F>(&self, get_terminal: F) -> Result<()>\n+    where\n+        F: Fn() -> Result<Arc<dyn Terminal>>,\n+    {\n+        let mut inner = self.inner.lock();\n+\n+        if inner.terminal.is_some() {\n+            return_errno_with_message!(\n+                Errno::EPERM,\n+                \"current session already has controlling terminal\"\n+            );\n+        }\n+\n+        let terminal = get_terminal()?;\n+        inner.terminal = Some(terminal);\n+        Ok(())\n+    }\n+\n+    /// Releases the controlling terminal of the session.\n+    ///\n+    /// If the session does not have controlling terminal, this method will return `ENOTTY`.\n+    pub fn release_terminal<F>(&self, release_session: F) -> Result<()>\n+    where\n+        F: Fn(&Arc<dyn Terminal>) -> Result<()>,\n+    {\n+        let mut inner = self.inner.lock();\n+        if inner.terminal.is_none() {\n+            return_errno_with_message!(\n+                Errno::ENOTTY,\n+                \"current session does not has controlling terminal\"\n+            );\n+        }\n+\n+        let terminal = inner.terminal.as_ref().unwrap();\n+        release_session(terminal)?;\n+        inner.terminal = None;\n+        Ok(())\n+    }\n+\n+    /// Returns the controlling terminal of `self`.\n+    pub fn terminal(&self) -> Option<Arc<dyn Terminal>> {\n+        self.inner.lock().terminal.clone()\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/process/process/terminal.rs b/services/libs/jinux-std/src/process/process/terminal.rs\nnew file mode 100644\nindex 0000000000..94d66b319a\n--- /dev/null\n+++ b/services/libs/jinux-std/src/process/process/terminal.rs\n@@ -0,0 +1,104 @@\n+use crate::fs::inode_handle::FileIo;\n+use crate::prelude::*;\n+use crate::process::{process_table, Pgid, ProcessGroup};\n+\n+use super::JobControl;\n+\n+/// A termial is used to interact with system. A terminal can support the shell\n+/// job control.\n+///\n+/// We currently support two kinds of terminal, the tty and pty.\n+pub trait Terminal: Send + Sync + FileIo {\n+    // *************** Foreground ***************\n+\n+    /// Returns the foreground process group\n+    fn foreground(&self) -> Option<Arc<ProcessGroup>> {\n+        self.job_control().foreground()\n+    }\n+\n+    /// Sets the foreground process group of this terminal.\n+    ///\n+    /// If the terminal is not controlling terminal, this method returns `ENOTTY`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should be called in process context.\n+    fn set_foreground(&self, pgid: &Pgid) -> Result<()> {\n+        if !self.is_controlling_terminal() {\n+            return_errno_with_message!(Errno::ENOTTY, \"self is not controlling terminal\");\n+        }\n+\n+        let foreground = process_table::get_process_group(pgid);\n+\n+        self.job_control().set_foreground(foreground.as_ref())\n+    }\n+\n+    // *************** Session and controlling terminal ***************\n+\n+    /// Returns whether the terminal is the controlling terminal of current process.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should be called in process context.\n+    fn is_controlling_terminal(&self) -> bool {\n+        let session = current!().session().unwrap();\n+        let Some(terminal) = session.terminal() else {\n+            return false;\n+        };\n+\n+        let arc_self = self.arc_self();\n+        Arc::ptr_eq(&terminal, &arc_self)\n+    }\n+\n+    /// Sets the terminal as the controlling terminal of the session of current process.\n+    ///\n+    /// If self is not session leader, or the terminal is controlling terminal of other session,\n+    /// or the session already has controlling terminal, this method returns `EPERM`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should only be called in process context.\n+    fn set_current_session(&self) -> Result<()> {\n+        if !current!().is_session_leader() {\n+            return_errno_with_message!(Errno::EPERM, \"current process is not session leader\");\n+        }\n+\n+        let get_terminal = || {\n+            self.job_control().set_current_session()?;\n+            Ok(self.arc_self())\n+        };\n+\n+        let session = current!().session().unwrap();\n+        session.set_terminal(get_terminal)\n+    }\n+\n+    /// Releases the terminal from the session of current process if the terminal is the controlling\n+    /// terminal of the session.\n+    ///\n+    /// If the terminal is not the controlling terminal of the session, this method will return `ENOTTY`.\n+    ///\n+    /// # Panic\n+    ///\n+    /// This method should only be called in process context.\n+    fn release_current_session(&self) -> Result<()> {\n+        if !self.is_controlling_terminal() {\n+            return_errno_with_message!(Errno::ENOTTY, \"release wrong tty\");\n+        }\n+\n+        let current = current!();\n+        if !current.is_session_leader() {\n+            warn!(\"TODO: release tty for process that is not session leader\");\n+            return Ok(());\n+        }\n+\n+        let release_session = |_: &Arc<dyn Terminal>| self.job_control().release_current_session();\n+\n+        let session = current.session().unwrap();\n+        session.release_terminal(release_session)\n+    }\n+\n+    /// Returns the job control of the terminal.\n+    fn job_control(&self) -> &JobControl;\n+\n+    fn arc_self(&self) -> Arc<dyn Terminal>;\n+}\ndiff --git a/services/libs/jinux-std/src/process/process_group.rs b/services/libs/jinux-std/src/process/process_group.rs\ndeleted file mode 100644\nindex 1a18ea0cd3..0000000000\n--- a/services/libs/jinux-std/src/process/process_group.rs\n+++ /dev/null\n@@ -1,85 +0,0 @@\n-use super::{\n-    process_table,\n-    signal::signals::{kernel::KernelSignal, user::UserSignal},\n-    Pgid, Pid, Process,\n-};\n-use crate::prelude::*;\n-\n-pub struct ProcessGroup {\n-    inner: Mutex<ProcessGroupInner>,\n-}\n-\n-struct ProcessGroupInner {\n-    pgid: Pgid,\n-    processes: BTreeMap<Pid, Arc<Process>>,\n-    leader_process: Option<Arc<Process>>,\n-}\n-\n-impl ProcessGroup {\n-    fn default() -> Self {\n-        ProcessGroup {\n-            inner: Mutex::new(ProcessGroupInner {\n-                pgid: 0,\n-                processes: BTreeMap::new(),\n-                leader_process: None,\n-            }),\n-        }\n-    }\n-\n-    pub fn new(process: Arc<Process>) -> Self {\n-        let process_group = ProcessGroup::default();\n-        let pid = process.pid();\n-        process_group.set_pgid(pid);\n-        process_group.add_process(process.clone());\n-        process_group.set_leader_process(process);\n-        process_group\n-    }\n-\n-    pub fn set_pgid(&self, pgid: Pgid) {\n-        self.inner.lock().pgid = pgid;\n-    }\n-\n-    pub fn set_leader_process(&self, leader_process: Arc<Process>) {\n-        self.inner.lock().leader_process = Some(leader_process);\n-    }\n-\n-    pub fn add_process(&self, process: Arc<Process>) {\n-        self.inner.lock().processes.insert(process.pid(), process);\n-    }\n-\n-    pub fn contains_process(&self, pid: Pid) -> bool {\n-        self.inner.lock().processes.contains_key(&pid)\n-    }\n-\n-    /// remove a process from this process group.\n-    /// If this group contains no processes now, the group itself will be deleted from global table.\n-    pub fn remove_process(&self, pid: Pid) {\n-        let mut inner_lock = self.inner.lock();\n-        inner_lock.processes.remove(&pid);\n-        let len = inner_lock.processes.len();\n-        let pgid = inner_lock.pgid;\n-        // if self contains no process, remove self from table\n-        if len == 0 {\n-            // this must be the last statement\n-            process_table::remove_process_group(pgid);\n-        }\n-    }\n-\n-    pub fn pgid(&self) -> Pgid {\n-        self.inner.lock().pgid\n-    }\n-\n-    /// send kernel signal to all processes in the group\n-    pub fn kernel_signal(&self, signal: KernelSignal) {\n-        for process in self.inner.lock().processes.values() {\n-            process.enqueue_signal(Box::new(signal));\n-        }\n-    }\n-\n-    /// send user signal to all processes in the group\n-    pub fn user_signal(&self, signal: UserSignal) {\n-        for process in self.inner.lock().processes.values() {\n-            process.enqueue_signal(Box::new(signal));\n-        }\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/process/process_table.rs b/services/libs/jinux-std/src/process/process_table.rs\nindex 428659843f..d5d216c34e 100644\n--- a/services/libs/jinux-std/src/process/process_table.rs\n+++ b/services/libs/jinux-std/src/process/process_table.rs\n@@ -5,35 +5,25 @@\n use crate::events::{Events, Observer, Subject};\n use crate::prelude::*;\n \n-use super::{process_group::ProcessGroup, Pgid, Pid, Process};\n+use super::{Pgid, Pid, Process, ProcessGroup, Session, Sid};\n \n-lazy_static! {\n-    static ref PROCESS_TABLE: Mutex<BTreeMap<Pid, Arc<Process>>> = Mutex::new(BTreeMap::new());\n-    static ref PROCESS_GROUP_TABLE: Mutex<BTreeMap<Pgid, Arc<ProcessGroup>>> =\n-        Mutex::new(BTreeMap::new());\n-    static ref PROCESS_TABLE_SUBJECT: Subject<PidEvent> = Subject::new();\n-}\n-\n-/// add a process to global table\n-pub fn add_process(process: Arc<Process>) {\n-    let pid = process.pid();\n-    PROCESS_TABLE.lock().insert(pid, process);\n-}\n+static PROCESS_TABLE: Mutex<BTreeMap<Pid, Arc<Process>>> = Mutex::new(BTreeMap::new());\n+static PROCESS_GROUP_TABLE: Mutex<BTreeMap<Pgid, Arc<ProcessGroup>>> = Mutex::new(BTreeMap::new());\n+static PROCESS_TABLE_SUBJECT: Subject<PidEvent> = Subject::new();\n+static SESSION_TABLE: Mutex<BTreeMap<Sid, Arc<Session>>> = Mutex::new(BTreeMap::new());\n \n-/// remove a process from global table\n-pub fn remove_process(pid: Pid) {\n-    PROCESS_TABLE.lock().remove(&pid);\n+// ************ Process *************\n \n-    let events = PidEvent::Exit(pid);\n-    PROCESS_TABLE_SUBJECT.notify_observers(&events);\n+/// Gets a process with pid\n+pub fn get_process(pid: &Pid) -> Option<Arc<Process>> {\n+    PROCESS_TABLE.lock().get(pid).cloned()\n }\n \n-/// get a process with pid\n-pub fn pid_to_process(pid: Pid) -> Option<Arc<Process>> {\n-    PROCESS_TABLE.lock().get(&pid).cloned()\n+pub(super) fn process_table_mut() -> MutexGuard<'static, BTreeMap<Pid, Arc<Process>>> {\n+    PROCESS_TABLE.lock()\n }\n \n-/// get all processes\n+/// Gets all processes\n pub fn get_all_processes() -> Vec<Arc<Process>> {\n     PROCESS_TABLE\n         .lock()\n@@ -42,26 +32,41 @@ pub fn get_all_processes() -> Vec<Arc<Process>> {\n         .collect()\n }\n \n-/// add process group to global table\n-pub fn add_process_group(process_group: Arc<ProcessGroup>) {\n-    let pgid = process_group.pgid();\n-    PROCESS_GROUP_TABLE.lock().insert(pgid, process_group);\n+// ************ Process Group *************\n+\n+/// Gets a process group with `pgid`\n+pub fn get_process_group(pgid: &Pgid) -> Option<Arc<ProcessGroup>> {\n+    PROCESS_GROUP_TABLE.lock().get(pgid).cloned()\n+}\n+\n+/// Returns whether process table contains process group with pgid\n+pub fn contain_process_group(pgid: &Pgid) -> bool {\n+    PROCESS_GROUP_TABLE.lock().contains_key(pgid)\n }\n \n-/// remove process group from global table\n-pub fn remove_process_group(pgid: Pgid) {\n-    PROCESS_GROUP_TABLE.lock().remove(&pgid);\n+pub(super) fn group_table_mut() -> MutexGuard<'static, BTreeMap<Pgid, Arc<ProcessGroup>>> {\n+    PROCESS_GROUP_TABLE.lock()\n }\n \n-/// get a process group with pgid\n-pub fn pgid_to_process_group(pgid: Pgid) -> Option<Arc<ProcessGroup>> {\n-    PROCESS_GROUP_TABLE.lock().get(&pgid).cloned()\n+// ************ Session *************\n+\n+/// Gets a session with `sid`.\n+pub fn get_session(sid: &Sid) -> Option<Arc<Session>> {\n+    SESSION_TABLE.lock().get(sid).map(Arc::clone)\n }\n \n+pub(super) fn session_table_mut() -> MutexGuard<'static, BTreeMap<Sid, Arc<Session>>> {\n+    SESSION_TABLE.lock()\n+}\n+\n+// ************ Observer *************\n+\n+/// Registers an observer which watches `PidEvent`.\n pub fn register_observer(observer: Weak<dyn Observer<PidEvent>>) {\n     PROCESS_TABLE_SUBJECT.register_observer(observer, ());\n }\n \n+/// Unregisters an observer which watches `PidEvent`.\n pub fn unregister_observer(observer: &Weak<dyn Observer<PidEvent>>) {\n     PROCESS_TABLE_SUBJECT.unregister_observer(observer);\n }\ndiff --git a/services/libs/jinux-std/src/process/signal/sig_queues.rs b/services/libs/jinux-std/src/process/signal/sig_queues.rs\nindex 4272c9bf86..9b687ea8a1 100644\n--- a/services/libs/jinux-std/src/process/signal/sig_queues.rs\n+++ b/services/libs/jinux-std/src/process/signal/sig_queues.rs\n@@ -81,8 +81,11 @@ impl SigQueues {\n         // POSIX leaves unspecified which to deliver first if there are multiple\n         // pending standard signals. So we are free to define our own. The\n         // principle is to give more urgent signals higher priority (like SIGKILL).\n+\n+        // FIXME: the gvisor pty_test JobControlTest::ReleaseTTY requires that\n+        // the SIGHUP signal should be handled before SIGCONT.\n         const ORDERED_STD_SIGS: [SigNum; COUNT_STD_SIGS] = [\n-            SIGKILL, SIGTERM, SIGSTOP, SIGCONT, SIGSEGV, SIGILL, SIGHUP, SIGINT, SIGQUIT, SIGTRAP,\n+            SIGKILL, SIGTERM, SIGSTOP, SIGSEGV, SIGILL, SIGHUP, SIGCONT, SIGINT, SIGQUIT, SIGTRAP,\n             SIGABRT, SIGBUS, SIGFPE, SIGUSR1, SIGUSR2, SIGPIPE, SIGALRM, SIGSTKFLT, SIGCHLD,\n             SIGTSTP, SIGTTIN, SIGTTOU, SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF, SIGWINCH,\n             SIGIO, SIGPWR, SIGSYS,\ndiff --git a/services/libs/jinux-std/src/process/wait.rs b/services/libs/jinux-std/src/process/wait.rs\nindex 4732be6211..99e4d45724 100644\n--- a/services/libs/jinux-std/src/process/wait.rs\n+++ b/services/libs/jinux-std/src/process/wait.rs\n@@ -80,9 +80,33 @@ fn reap_zombie_child(process: &Process, pid: Pid) -> u32 {\n     for thread in &*child_process.threads().lock() {\n         thread_table::remove_thread(thread.tid());\n     }\n-    process_table::remove_process(child_process.pid());\n-    if let Some(process_group) = child_process.process_group() {\n-        process_group.remove_process(child_process.pid());\n+\n+    // Lock order: session table -> group table -> process table -> group of process\n+    // -> group inner -> session inner\n+    let mut session_table_mut = process_table::session_table_mut();\n+    let mut group_table_mut = process_table::group_table_mut();\n+    let mut process_table_mut = process_table::process_table_mut();\n+\n+    let mut child_group_mut = child_process.process_group.lock();\n+\n+    let process_group = child_group_mut.upgrade().unwrap();\n+    let mut group_inner = process_group.inner.lock();\n+    let session = group_inner.session.upgrade().unwrap();\n+    let mut session_inner = session.inner.lock();\n+\n+    group_inner.remove_process(&child_process.pid());\n+    session_inner.remove_process(&child_process);\n+    *child_group_mut = Weak::new();\n+\n+    if group_inner.is_empty() {\n+        group_table_mut.remove(&process_group.pgid());\n+        session_inner.remove_process_group(&process_group.pgid());\n+\n+        if session_inner.is_empty() {\n+            session_table_mut.remove(&session.sid());\n+        }\n     }\n+\n+    process_table_mut.remove(&child_process.pid());\n     child_process.exit_code().unwrap()\n }\ndiff --git a/services/libs/jinux-std/src/syscall/getsid.rs b/services/libs/jinux-std/src/syscall/getsid.rs\nnew file mode 100644\nindex 0000000000..721644c3de\n--- /dev/null\n+++ b/services/libs/jinux-std/src/syscall/getsid.rs\n@@ -0,0 +1,30 @@\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+use crate::process::{process_table, Pid};\n+\n+use super::{SyscallReturn, SYS_GETSID};\n+\n+pub fn sys_getsid(pid: Pid) -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_GETSID);\n+    debug!(\"pid = {}\", pid);\n+\n+    let session = current!().session().unwrap();\n+    let sid = session.sid();\n+\n+    if pid == 0 {\n+        return Ok(SyscallReturn::Return(sid as _));\n+    }\n+\n+    let Some(process) = process_table::get_process(&pid) else {\n+        return_errno_with_message!(Errno::ESRCH, \"the process does not exist\")\n+    };\n+\n+    if !Arc::ptr_eq(&session, &process.session().unwrap()) {\n+        return_errno_with_message!(\n+            Errno::EPERM,\n+            \"the process and current process does not belong to the same session\"\n+        );\n+    }\n+\n+    Ok(SyscallReturn::Return(sid as _))\n+}\ndiff --git a/services/libs/jinux-std/src/syscall/kill.rs b/services/libs/jinux-std/src/syscall/kill.rs\nindex d9a4070e8f..e0c82be0b5 100644\n--- a/services/libs/jinux-std/src/syscall/kill.rs\n+++ b/services/libs/jinux-std/src/syscall/kill.rs\n@@ -34,15 +34,15 @@ pub fn do_sys_kill(filter: ProcessFilter, sig_num: SigNum) -> Result<()> {\n             }\n         }\n         ProcessFilter::WithPid(pid) => {\n-            if let Some(process) = process_table::pid_to_process(pid) {\n+            if let Some(process) = process_table::get_process(&pid) {\n                 process.enqueue_signal(Box::new(signal));\n             } else {\n                 return_errno_with_message!(Errno::ESRCH, \"No such process in process table\");\n             }\n         }\n         ProcessFilter::WithPgid(pgid) => {\n-            if let Some(process_group) = process_table::pgid_to_process_group(pgid) {\n-                process_group.user_signal(signal);\n+            if let Some(process_group) = process_table::get_process_group(&pgid) {\n+                process_group.broadcast_signal(signal);\n             } else {\n                 return_errno_with_message!(Errno::ESRCH, \"No such process group in process table\");\n             }\ndiff --git a/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\nindex d245667aaa..d3b95f5030 100644\n--- a/services/libs/jinux-std/src/syscall/mod.rs\n+++ b/services/libs/jinux-std/src/syscall/mod.rs\n@@ -77,12 +77,14 @@ use self::connect::sys_connect;\n use self::execve::sys_execveat;\n use self::getpeername::sys_getpeername;\n use self::getrandom::sys_getrandom;\n+use self::getsid::sys_getsid;\n use self::getsockname::sys_getsockname;\n use self::getsockopt::sys_getsockopt;\n use self::listen::sys_listen;\n use self::pread64::sys_pread64;\n use self::recvfrom::sys_recvfrom;\n use self::sendto::sys_sendto;\n+use self::setsid::sys_setsid;\n use self::setsockopt::sys_setsockopt;\n use self::shutdown::sys_shutdown;\n use self::socket::sys_socket;\n@@ -119,6 +121,7 @@ mod getpgrp;\n mod getpid;\n mod getppid;\n mod getrandom;\n+mod getsid;\n mod getsockname;\n mod getsockopt;\n mod gettid;\n@@ -155,6 +158,7 @@ mod sendto;\n mod set_robust_list;\n mod set_tid_address;\n mod setpgid;\n+mod setsid;\n mod setsockopt;\n mod shutdown;\n mod socket;\n@@ -274,6 +278,8 @@ define_syscall_nums!(\n     SYS_SETPGID = 109,\n     SYS_GETPPID = 110,\n     SYS_GETPGRP = 111,\n+    SYS_SETSID = 112,\n+    SYS_GETSID = 124,\n     SYS_STATFS = 137,\n     SYS_FSTATFS = 138,\n     SYS_PRCTL = 157,\n@@ -435,6 +441,8 @@ pub fn syscall_dispatch(\n         SYS_SETPGID => syscall_handler!(2, sys_setpgid, args),\n         SYS_GETPPID => syscall_handler!(0, sys_getppid),\n         SYS_GETPGRP => syscall_handler!(0, sys_getpgrp),\n+        SYS_SETSID => syscall_handler!(0, sys_setsid),\n+        SYS_GETSID => syscall_handler!(1, sys_getsid, args),\n         SYS_STATFS => syscall_handler!(2, sys_statfs, args),\n         SYS_FSTATFS => syscall_handler!(2, sys_fstatfs, args),\n         SYS_PRCTL => syscall_handler!(5, sys_prctl, args),\ndiff --git a/services/libs/jinux-std/src/syscall/setpgid.rs b/services/libs/jinux-std/src/syscall/setpgid.rs\nindex 86244b93d7..36e8636c34 100644\n--- a/services/libs/jinux-std/src/syscall/setpgid.rs\n+++ b/services/libs/jinux-std/src/syscall/setpgid.rs\n@@ -1,8 +1,6 @@\n-use crate::{\n-    log_syscall_entry,\n-    prelude::*,\n-    process::{process_table, Pgid, Pid, ProcessGroup},\n-};\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+use crate::process::{process_table, Pgid, Pid};\n \n use super::{SyscallReturn, SYS_SETPGID};\n \n@@ -15,7 +13,7 @@ pub fn sys_setpgid(pid: Pid, pgid: Pgid) -> Result<SyscallReturn> {\n     let pgid = if pgid == 0 { pid } else { pgid };\n     debug!(\"pid = {}, pgid = {}\", pid, pgid);\n \n-    if pid != current.pid() && !current.children().lock().contains_key(&pid) {\n+    if pid != current.pid() && !current.has_child(&pid) {\n         return_errno_with_message!(\n             Errno::ESRCH,\n             \"cannot set pgid for process other than current or children of current\"\n@@ -25,27 +23,14 @@ pub fn sys_setpgid(pid: Pid, pgid: Pgid) -> Result<SyscallReturn> {\n     // How can we determine a child process has called execve?\n \n     // only can move process to an existing group or self\n-    if pgid != pid && process_table::pgid_to_process_group(pgid).is_none() {\n+    if pgid != pid && !process_table::contain_process_group(&pgid) {\n         return_errno_with_message!(Errno::EPERM, \"process group must exist\");\n     }\n \n-    let process = process_table::pid_to_process(pid)\n+    let process = process_table::get_process(&pid)\n         .ok_or(Error::with_message(Errno::ESRCH, \"process does not exist\"))?;\n \n-    // if the process already belongs to the process group\n-    if process.pgid() == pgid {\n-        return Ok(SyscallReturn::Return(0));\n-    }\n-\n-    if let Some(process_group) = process_table::pgid_to_process_group(pgid) {\n-        process_group.add_process(process.clone());\n-        process.set_process_group(Arc::downgrade(&process_group));\n-    } else {\n-        let new_process_group = Arc::new(ProcessGroup::new(process.clone()));\n-        // new_process_group.add_process(process.clone());\n-        process.set_process_group(Arc::downgrade(&new_process_group));\n-        process_table::add_process_group(new_process_group);\n-    }\n+    process.to_other_group(pgid)?;\n \n     Ok(SyscallReturn::Return(0))\n }\ndiff --git a/services/libs/jinux-std/src/syscall/setsid.rs b/services/libs/jinux-std/src/syscall/setsid.rs\nnew file mode 100644\nindex 0000000000..40a315f2c1\n--- /dev/null\n+++ b/services/libs/jinux-std/src/syscall/setsid.rs\n@@ -0,0 +1,13 @@\n+use crate::log_syscall_entry;\n+use crate::prelude::*;\n+\n+use super::{SyscallReturn, SYS_SETSID};\n+\n+pub fn sys_setsid() -> Result<SyscallReturn> {\n+    log_syscall_entry!(SYS_SETSID);\n+\n+    let current = current!();\n+    let session = current.to_new_session()?;\n+\n+    Ok(SyscallReturn::Return(session.sid() as _))\n+}\ndiff --git a/services/libs/jinux-std/src/syscall/tgkill.rs b/services/libs/jinux-std/src/syscall/tgkill.rs\nindex c02236dd8f..014fa0d64e 100644\n--- a/services/libs/jinux-std/src/syscall/tgkill.rs\n+++ b/services/libs/jinux-std/src/syscall/tgkill.rs\n@@ -16,8 +16,8 @@ pub fn sys_tgkill(tgid: Pid, tid: Tid, sig_num: u8) -> Result<SyscallReturn> {\n     log_syscall_entry!(SYS_TGKILL);\n     let sig_num = SigNum::from_u8(sig_num);\n     info!(\"tgid = {}, pid = {}, sig_num = {:?}\", tgid, tid, sig_num);\n-    let target_thread = thread_table::tid_to_thread(tid)\n-        .ok_or(Error::with_message(Errno::EINVAL, \"Invalid pid\"))?;\n+    let target_thread =\n+        thread_table::get_thread(tid).ok_or(Error::with_message(Errno::EINVAL, \"Invalid pid\"))?;\n     let posix_thread = target_thread.as_posix_thread().unwrap();\n     let pid = posix_thread.process().pid();\n     if pid != tgid {\ndiff --git a/services/libs/jinux-std/src/thread/thread_table.rs b/services/libs/jinux-std/src/thread/thread_table.rs\nindex b1ae4463fc..59e5facf81 100644\n--- a/services/libs/jinux-std/src/thread/thread_table.rs\n+++ b/services/libs/jinux-std/src/thread/thread_table.rs\n@@ -15,6 +15,6 @@ pub fn remove_thread(tid: Tid) {\n     THREAD_TABLE.lock().remove(&tid);\n }\n \n-pub fn tid_to_thread(tid: Tid) -> Option<Arc<Thread>> {\n+pub fn get_thread(tid: Tid) -> Option<Arc<Thread>> {\n     THREAD_TABLE.lock().get(&tid).cloned()\n }\n", "test_patch": "diff --git a/regression/syscall_test/blocklists/pty_test b/regression/syscall_test/blocklists/pty_test\nindex 3d712cd4fd..88a3265eee 100644\n--- a/regression/syscall_test/blocklists/pty_test\n+++ b/regression/syscall_test/blocklists/pty_test\n@@ -21,22 +21,8 @@ PtyTest.SwitchNoncanonToCanonNoNewlineBig\n PtyTest.NoncanonBigWrite\n PtyTest.SwitchNoncanonToCanonMultiline\n PtyTest.SwitchTwiceMultiline\n-JobControlTest.SetTTYMaster\n-JobControlTest.SetTTY\n-JobControlTest.SetTTYNonLeader\n JobControlTest.SetTTYBadArg\n JobControlTest.SetTTYDifferentSession\n-JobControlTest.ReleaseTTY\n-JobControlTest.ReleaseUnsetTTY\n-JobControlTest.ReleaseWrongTTY\n-JobControlTest.ReleaseTTYNonLeader\n-JobControlTest.ReleaseTTYDifferentSession\n JobControlTest.ReleaseTTYSignals\n-JobControlTest.GetForegroundProcessGroup\n-JobControlTest.GetForegroundProcessGroupNonControlling\n JobControlTest.SetForegroundProcessGroup\n-JobControlTest.SetForegroundProcessGroupWrongTTY\n-JobControlTest.SetForegroundProcessGroupNegPgid\n-JobControlTest.SetForegroundProcessGroupEmptyProcessGroup\n-JobControlTest.SetForegroundProcessGroupDifferentSession\n-JobControlTest.OrphanRegression\n\\ No newline at end of file\n+JobControlTest.SetForegroundProcessGroupEmptyProcessGroup\n\\ No newline at end of file\n", "problem_statement": "Implement session for shell job control\nProcess groups and sessions form a two-level hierarchical relationship between processes. A session is a collection of process groups. A process\u2019s session membership is determined by its session identifier (SID). All of the processes in a session share a single controlling terminal. \r\n\r\nThe related syscalls are getsid and setsid\n", "hints_text": "", "created_at": "2023-08-30T11:25:32Z", "version": "0.2"}, {"repo": "asterinas/asterinas", "pull_number": 334, "instance_id": "asterinas__asterinas-334", "issue_numbers": ["214"], "base_commit": "25c4f0f2bcaa0bc8c650b0f4ee7b0d78e2a836b2", "patch": "diff --git a/regression/apps/Makefile b/regression/apps/Makefile\nindex 09db3e9c42..5f70f66350 100644\n--- a/regression/apps/Makefile\n+++ b/regression/apps/Makefile\n@@ -3,7 +3,7 @@ MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n INITRAMFS ?= $(CUR_DIR)/../build/initramfs\n REGRESSION_BUILD_DIR ?= $(INITRAMFS)/regression\n-TEST_APPS := signal_c pthread network hello_world hello_pie hello_c fork_c fork execve \n+TEST_APPS := signal_c pthread network hello_world hello_pie hello_c fork_c fork execve pty\n \n .PHONY: all\n \ndiff --git a/regression/apps/pty/Makefile b/regression/apps/pty/Makefile\nnew file mode 100644\nindex 0000000000..05ff449d2d\n--- /dev/null\n+++ b/regression/apps/pty/Makefile\n@@ -0,0 +1,3 @@\n+include ../test_common.mk\n+\n+EXTRA_C_FLAGS :=\ndiff --git a/regression/apps/pty/open_pty.c b/regression/apps/pty/open_pty.c\nnew file mode 100644\nindex 0000000000..220d2f3eb3\n--- /dev/null\n+++ b/regression/apps/pty/open_pty.c\n@@ -0,0 +1,51 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <termios.h>\n+#include <pty.h>\n+\n+int main() {\n+    int master, slave;\n+    char name[256];\n+    struct termios term;\n+\n+    if (openpty(&master, &slave, name, NULL, NULL) == -1) {\n+        perror(\"openpty\");\n+        exit(EXIT_FAILURE);\n+    }\n+\n+    printf(\"slave name: %s\\n\", name);\n+\n+    // Set pty slave terminal attributes\n+    tcgetattr(slave, &term);\n+    term.c_lflag &= ~(ICANON | ECHO);\n+    term.c_cc[VMIN] = 1;\n+    term.c_cc[VTIME] = 0;\n+    tcsetattr(slave, TCSANOW, &term);\n+\n+    // Print to pty slave\n+    dprintf(slave, \"Hello world!\\n\");\n+\n+    // Read from pty slave\n+    char buf[256];\n+    ssize_t n = read(master, buf, sizeof(buf));\n+    if (n > 0) {\n+        printf(\"read %ld bytes from slave: %.*s\", n, (int)n, buf);\n+    }\n+\n+    // Write to pty master\n+    dprintf(master, \"hello world from master\\n\");\n+\n+    // Read from pty master\n+    char nbuf[256];\n+    ssize_t nn = read(slave, nbuf, sizeof(nbuf));\n+    if (nn > 0) {\n+        printf(\"read %ld bytes from master: %.*s\", nn, (int)nn, nbuf);\n+    }\n+\n+    close(master);\n+    close(slave);\n+\n+    return 0;\n+}\ndiff --git a/services/libs/jinux-std/src/device/mod.rs b/services/libs/jinux-std/src/device/mod.rs\nindex 899206d626..fa9e6a0d97 100644\n--- a/services/libs/jinux-std/src/device/mod.rs\n+++ b/services/libs/jinux-std/src/device/mod.rs\n@@ -7,6 +7,8 @@ mod zero;\n \n use crate::fs::device::{add_node, Device, DeviceId, DeviceType};\n use crate::prelude::*;\n+pub use pty::new_pty_pair;\n+pub use pty::{PtyMaster, PtySlave};\n pub use random::Random;\n pub use urandom::Urandom;\n \ndiff --git a/services/libs/jinux-std/src/device/pty.rs b/services/libs/jinux-std/src/device/pty.rs\ndeleted file mode 100644\nindex 5aba6e7b72..0000000000\n--- a/services/libs/jinux-std/src/device/pty.rs\n+++ /dev/null\n@@ -1,24 +0,0 @@\n-use crate::fs::{\n-    devpts::DevPts,\n-    fs_resolver::{FsPath, FsResolver},\n-    utils::{InodeMode, InodeType},\n-};\n-use crate::prelude::*;\n-\n-pub fn init() -> Result<()> {\n-    let fs = FsResolver::new();\n-\n-    let dev = fs.lookup(&FsPath::try_from(\"/dev\")?)?;\n-    // Create the \"pts\" directory and mount devpts on it.\n-    let devpts = dev.create(\"pts\", InodeType::Dir, InodeMode::from_bits_truncate(0o755))?;\n-    devpts.mount(DevPts::new())?;\n-\n-    // Create the \"ptmx\" symlink.\n-    let ptmx = dev.create(\n-        \"ptmx\",\n-        InodeType::SymLink,\n-        InodeMode::from_bits_truncate(0o777),\n-    )?;\n-    ptmx.write_link(\"pts/ptmx\")?;\n-    Ok(())\n-}\ndiff --git a/services/libs/jinux-std/src/device/pty/mod.rs b/services/libs/jinux-std/src/device/pty/mod.rs\nnew file mode 100644\nindex 0000000000..998b594762\n--- /dev/null\n+++ b/services/libs/jinux-std/src/device/pty/mod.rs\n@@ -0,0 +1,38 @@\n+use crate::fs::devpts::DevPts;\n+use crate::fs::fs_resolver::{FsPath, FsResolver};\n+use crate::fs::utils::{Dentry, Inode, InodeMode, InodeType};\n+use crate::prelude::*;\n+\n+mod pty;\n+\n+pub use pty::{PtyMaster, PtySlave};\n+use spin::Once;\n+\n+static DEV_PTS: Once<Arc<Dentry>> = Once::new();\n+\n+pub fn init() -> Result<()> {\n+    let fs = FsResolver::new();\n+\n+    let dev = fs.lookup(&FsPath::try_from(\"/dev\")?)?;\n+    // Create the \"pts\" directory and mount devpts on it.\n+    let devpts = dev.create(\"pts\", InodeType::Dir, InodeMode::from_bits_truncate(0o755))?;\n+    devpts.mount(DevPts::new())?;\n+\n+    DEV_PTS.call_once(|| devpts);\n+\n+    // Create the \"ptmx\" symlink.\n+    let ptmx = dev.create(\n+        \"ptmx\",\n+        InodeType::SymLink,\n+        InodeMode::from_bits_truncate(0o777),\n+    )?;\n+    ptmx.write_link(\"pts/ptmx\")?;\n+    Ok(())\n+}\n+\n+pub fn new_pty_pair(index: u32, ptmx: Arc<dyn Inode>) -> Result<(Arc<PtyMaster>, Arc<PtySlave>)> {\n+    debug!(\"pty index = {}\", index);\n+    let master = Arc::new(PtyMaster::new(ptmx, index));\n+    let slave = Arc::new(PtySlave::new(master.clone()));\n+    Ok((master, slave))\n+}\ndiff --git a/services/libs/jinux-std/src/device/pty/pty.rs b/services/libs/jinux-std/src/device/pty/pty.rs\nnew file mode 100644\nindex 0000000000..e8d1cc1f85\n--- /dev/null\n+++ b/services/libs/jinux-std/src/device/pty/pty.rs\n@@ -0,0 +1,312 @@\n+use alloc::format;\n+use ringbuf::{ring_buffer::RbBase, HeapRb, Rb};\n+\n+use crate::device::tty::line_discipline::LineDiscipline;\n+use crate::fs::device::{Device, DeviceId, DeviceType};\n+use crate::fs::file_handle::FileLike;\n+use crate::fs::fs_resolver::FsPath;\n+use crate::fs::utils::{AccessMode, Inode, InodeMode, IoEvents, IoctlCmd, Pollee, Poller};\n+use crate::prelude::*;\n+use crate::util::{read_val_from_user, write_val_to_user};\n+\n+const PTS_DIR: &str = \"/dev/pts\";\n+const BUFFER_CAPACITY: usize = 4096;\n+\n+/// Pesudo terminal master.\n+/// Internally, it has two buffers.\n+/// One is inside ldisc, which is written by master and read by slave,\n+/// the other is a ring buffer, which is written by slave and read by master.\n+pub struct PtyMaster {\n+    ptmx: Arc<dyn Inode>,\n+    index: u32,\n+    output: LineDiscipline,\n+    input: SpinLock<HeapRb<u8>>,\n+    /// The state of input buffer\n+    pollee: Pollee,\n+}\n+\n+impl PtyMaster {\n+    pub fn new(ptmx: Arc<dyn Inode>, index: u32) -> Self {\n+        Self {\n+            ptmx,\n+            index,\n+            output: LineDiscipline::new(),\n+            input: SpinLock::new(HeapRb::new(BUFFER_CAPACITY)),\n+            pollee: Pollee::new(IoEvents::OUT),\n+        }\n+    }\n+\n+    pub fn index(&self) -> u32 {\n+        self.index\n+    }\n+\n+    pub fn ptmx(&self) -> &Arc<dyn Inode> {\n+        &self.ptmx\n+    }\n+\n+    pub(super) fn slave_push_byte(&self, byte: u8) {\n+        let mut input = self.input.lock_irq_disabled();\n+        input.push_overwrite(byte);\n+        self.update_state(&input);\n+    }\n+\n+    pub(super) fn slave_read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.output.read(buf)\n+    }\n+\n+    pub(super) fn slave_poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let mut poll_status = IoEvents::empty();\n+\n+        let poll_in_mask = mask & IoEvents::IN;\n+        if !poll_in_mask.is_empty() {\n+            let poll_in_status = self.output.poll(poll_in_mask, poller);\n+            poll_status |= poll_in_status;\n+        }\n+\n+        let poll_out_mask = mask & IoEvents::OUT;\n+        if !poll_out_mask.is_empty() {\n+            let poll_out_status = self.pollee.poll(poll_out_mask, poller);\n+            poll_status |= poll_out_status;\n+        }\n+\n+        poll_status\n+    }\n+\n+    pub(super) fn slave_buf_len(&self) -> usize {\n+        self.output.buffer_len()\n+    }\n+\n+    fn update_state(&self, buf: &HeapRb<u8>) {\n+        if buf.is_empty() {\n+            self.pollee.del_events(IoEvents::IN)\n+        } else {\n+            self.pollee.add_events(IoEvents::IN);\n+        }\n+    }\n+}\n+\n+impl FileLike for PtyMaster {\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        // TODO: deal with nonblocking read\n+        if buf.len() == 0 {\n+            return Ok(0);\n+        }\n+\n+        let poller = Poller::new();\n+        loop {\n+            let mut input = self.input.lock_irq_disabled();\n+\n+            if input.is_empty() {\n+                let events = self.pollee.poll(IoEvents::IN, Some(&poller));\n+\n+                if events.contains(IoEvents::ERR) {\n+                    return_errno_with_message!(Errno::EACCES, \"unexpected err\");\n+                }\n+\n+                if events.is_empty() {\n+                    drop(input);\n+                    poller.wait();\n+                }\n+                continue;\n+            }\n+\n+            let read_len = input.len().min(buf.len());\n+            input.pop_slice(&mut buf[..read_len]);\n+            self.update_state(&input);\n+            return Ok(read_len);\n+        }\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        let mut input = self.input.lock();\n+\n+        for character in buf {\n+            self.output.push_char(*character, |content| {\n+                for byte in content.as_bytes() {\n+                    input.push_overwrite(*byte);\n+                }\n+            });\n+        }\n+\n+        self.update_state(&input);\n+        Ok(buf.len())\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        match cmd {\n+            IoctlCmd::TCGETS => {\n+                let termios = self.output.termios();\n+                write_val_to_user(arg, &termios)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TCSETS => {\n+                let termios = read_val_from_user(arg)?;\n+                self.output.set_termios(termios);\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSPTLCK => {\n+                // TODO: lock/unlock pty\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCGPTN => {\n+                let idx = self.index();\n+                write_val_to_user(arg, &idx)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCGPTPEER => {\n+                let current = current!();\n+\n+                // TODO: deal with open options\n+                let slave = {\n+                    let slave_name = {\n+                        let devpts_path = super::DEV_PTS.get().unwrap().abs_path();\n+                        format!(\"{}/{}\", devpts_path, self.index())\n+                    };\n+\n+                    let fs_path = FsPath::try_from(slave_name.as_str())?;\n+\n+                    let inode_handle = {\n+                        let fs = current.fs().read();\n+                        let flags = AccessMode::O_RDWR as u32;\n+                        let mode = (InodeMode::S_IRUSR | InodeMode::S_IWUSR).bits();\n+                        fs.open(&fs_path, flags, mode)?\n+                    };\n+                    Arc::new(inode_handle)\n+                };\n+\n+                let fd = {\n+                    let mut file_table = current.file_table().lock();\n+                    file_table.insert(slave)\n+                };\n+                Ok(fd)\n+            }\n+            IoctlCmd::TIOCGWINSZ => {\n+                let winsize = self.output.window_size();\n+                write_val_to_user(arg, &winsize)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSWINSZ => {\n+                let winsize = read_val_from_user(arg)?;\n+                self.output.set_window_size(winsize);\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSCTTY => {\n+                // TODO: reimplement when adding session.\n+                let foreground = {\n+                    let current = current!();\n+                    let process_group = current.process_group().lock();\n+                    process_group.clone()\n+                };\n+                self.output.set_fg(foreground);\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCGPGRP => {\n+                let Some(fg_pgid) = self.output.fg_pgid() else {\n+                    return_errno_with_message!(\n+                        Errno::ESRCH,\n+                        \"the foreground process group does not exist\"\n+                    );\n+                };\n+                write_val_to_user(arg, &fg_pgid)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCNOTTY => {\n+                // TODO: reimplement when adding session.\n+                self.output.set_fg(Weak::new());\n+                Ok(0)\n+            }\n+            IoctlCmd::FIONREAD => {\n+                let len = self.input.lock().len() as i32;\n+                write_val_to_user(arg, &len)?;\n+                Ok(0)\n+            }\n+            _ => Ok(0),\n+        }\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        let mut poll_status = IoEvents::empty();\n+\n+        let poll_in_mask = mask & IoEvents::IN;\n+        if !poll_in_mask.is_empty() {\n+            let poll_in_status = self.pollee.poll(poll_in_mask, poller);\n+            poll_status |= poll_in_status;\n+        }\n+\n+        let poll_out_mask = mask & IoEvents::OUT;\n+        if !poll_out_mask.is_empty() {\n+            let poll_out_status = self.output.poll(poll_out_mask, poller);\n+            poll_status |= poll_out_status;\n+        }\n+\n+        poll_status\n+    }\n+}\n+\n+pub struct PtySlave(Arc<PtyMaster>);\n+\n+impl PtySlave {\n+    pub fn new(master: Arc<PtyMaster>) -> Self {\n+        PtySlave(master)\n+    }\n+\n+    pub fn index(&self) -> u32 {\n+        self.0.index()\n+    }\n+}\n+\n+impl Device for PtySlave {\n+    fn type_(&self) -> DeviceType {\n+        DeviceType::CharDevice\n+    }\n+\n+    fn id(&self) -> crate::fs::device::DeviceId {\n+        DeviceId::new(88, self.index() as u32)\n+    }\n+\n+    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n+        self.0.slave_read(buf)\n+    }\n+\n+    fn write(&self, buf: &[u8]) -> Result<usize> {\n+        for ch in buf {\n+            // do we need to add '\\r' here?\n+            if *ch == b'\\n' {\n+                self.0.slave_push_byte(b'\\r');\n+                self.0.slave_push_byte(b'\\n');\n+            } else {\n+                self.0.slave_push_byte(*ch);\n+            }\n+        }\n+        Ok(buf.len())\n+    }\n+\n+    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n+        match cmd {\n+            IoctlCmd::TCGETS\n+            | IoctlCmd::TCSETS\n+            | IoctlCmd::TIOCGPGRP\n+            | IoctlCmd::TIOCGPTN\n+            | IoctlCmd::TIOCGWINSZ\n+            | IoctlCmd::TIOCSWINSZ => self.0.ioctl(cmd, arg),\n+            IoctlCmd::TIOCSCTTY => {\n+                // TODO:\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCNOTTY => {\n+                // TODO:\n+                Ok(0)\n+            }\n+            IoctlCmd::FIONREAD => {\n+                let buffer_len = self.0.slave_buf_len() as i32;\n+                write_val_to_user(arg, &buffer_len)?;\n+                Ok(0)\n+            }\n+            _ => Ok(0),\n+        }\n+    }\n+\n+    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n+        self.0.slave_poll(mask, poller)\n+    }\n+}\ndiff --git a/services/libs/jinux-std/src/device/tty/line_discipline.rs b/services/libs/jinux-std/src/device/tty/line_discipline.rs\nindex 2a55f8a965..2d52c318e4 100644\n--- a/services/libs/jinux-std/src/device/tty/line_discipline.rs\n+++ b/services/libs/jinux-std/src/device/tty/line_discipline.rs\n@@ -3,13 +3,13 @@ use crate::process::process_group::ProcessGroup;\n use crate::process::signal::constants::{SIGINT, SIGQUIT};\n use crate::{\n     prelude::*,\n-    process::{process_table, signal::signals::kernel::KernelSignal, Pgid},\n+    process::{signal::signals::kernel::KernelSignal, Pgid},\n };\n use alloc::format;\n use jinux_frame::trap::disable_local;\n use ringbuf::{ring_buffer::RbBase, Rb, StaticRb};\n \n-use super::termio::{KernelTermios, CC_C_CHAR};\n+use super::termio::{KernelTermios, WinSize, CC_C_CHAR};\n \n // This implementation refers the implementation of linux\n // https://elixir.bootlin.com/linux/latest/source/include/linux/tty_ldisc.h\n@@ -25,6 +25,8 @@ pub struct LineDiscipline {\n     foreground: SpinLock<Weak<ProcessGroup>>,\n     /// termios\n     termios: SpinLock<KernelTermios>,\n+    /// Windows size,\n+    winsize: SpinLock<WinSize>,\n     /// Pollee\n     pollee: Pollee,\n }\n@@ -72,12 +74,13 @@ impl LineDiscipline {\n             read_buffer: SpinLock::new(StaticRb::default()),\n             foreground: SpinLock::new(Weak::new()),\n             termios: SpinLock::new(KernelTermios::default()),\n+            winsize: SpinLock::new(WinSize::default()),\n             pollee: Pollee::new(IoEvents::empty()),\n         }\n     }\n \n     /// Push char to line discipline.\n-    pub fn push_char(&self, mut item: u8, echo_callback: fn(&str)) {\n+    pub fn push_char<F: FnMut(&str)>(&self, mut item: u8, echo_callback: F) {\n         let termios = self.termios.lock_irq_disabled();\n         if termios.contains_icrnl() && item == b'\\r' {\n             item = b'\\n'\n@@ -162,7 +165,7 @@ impl LineDiscipline {\n     }\n \n     // TODO: respect output flags\n-    fn output_char(&self, item: u8, termios: &KernelTermios, echo_callback: fn(&str)) {\n+    fn output_char<F: FnMut(&str)>(&self, item: u8, termios: &KernelTermios, mut echo_callback: F) {\n         match item {\n             b'\\n' => echo_callback(\"\\n\"),\n             b'\\r' => echo_callback(\"\\r\\n\"),\n@@ -350,6 +353,18 @@ impl LineDiscipline {\n         self.current_line.lock().drain();\n         let _: Vec<_> = self.read_buffer.lock().pop_iter().collect();\n     }\n+\n+    pub fn buffer_len(&self) -> usize {\n+        self.read_buffer.lock().len()\n+    }\n+\n+    pub fn window_size(&self) -> WinSize {\n+        self.winsize.lock().clone()\n+    }\n+\n+    pub fn set_window_size(&self, winsize: WinSize) {\n+        *self.winsize.lock() = winsize;\n+    }\n }\n \n fn meet_new_line(item: u8, termios: &KernelTermios) -> bool {\ndiff --git a/services/libs/jinux-std/src/device/tty/mod.rs b/services/libs/jinux-std/src/device/tty/mod.rs\nindex 5d5aff5ee3..1564266bf9 100644\n--- a/services/libs/jinux-std/src/device/tty/mod.rs\n+++ b/services/libs/jinux-std/src/device/tty/mod.rs\n@@ -6,7 +6,7 @@ use super::*;\n use crate::fs::utils::{IoEvents, IoctlCmd, Poller};\n use crate::prelude::*;\n use crate::process::process_group::ProcessGroup;\n-use crate::process::{process_table, Pgid};\n+use crate::process::process_table;\n use crate::util::{read_val_from_user, write_val_to_user};\n \n pub mod driver;\n@@ -130,7 +130,13 @@ impl Device for Tty {\n                 Ok(0)\n             }\n             IoctlCmd::TIOCGWINSZ => {\n-                // TODO:get window size\n+                let winsize = self.ldisc.window_size();\n+                write_val_to_user(arg, &winsize)?;\n+                Ok(0)\n+            }\n+            IoctlCmd::TIOCSWINSZ => {\n+                let winsize = read_val_from_user(arg)?;\n+                self.ldisc.set_window_size(winsize);\n                 Ok(0)\n             }\n             _ => todo!(),\ndiff --git a/services/libs/jinux-std/src/device/tty/termio.rs b/services/libs/jinux-std/src/device/tty/termio.rs\nindex 60d3e54494..00615ec16a 100644\n--- a/services/libs/jinux-std/src/device/tty/termio.rs\n+++ b/services/libs/jinux-std/src/device/tty/termio.rs\n@@ -14,22 +14,28 @@ bitflags! {\n     #[repr(C)]\n     pub struct C_IFLAGS: u32 {\n         // https://elixir.bootlin.com/linux/v6.0.9/source/include/uapi/asm-generic/termbits-common.h\n-        const IGNBRK\t= 0x001;\t\t\t/* Ignore break condition */\n-        const BRKINT\t= 0x002;\t\t\t/* Signal interrupt on break */\n-        const IGNPAR\t= 0x004;\t\t\t/* Ignore characters with parity errors */\n-        const PARMRK\t= 0x008;\t\t\t/* Mark parity and framing errors */\n-        const INPCK\t    = 0x010;\t\t\t/* Enable input parity check */\n-        const ISTRIP\t= 0x020;\t\t\t/* Strip 8th bit off characters */\n-        const INLCR\t    = 0x040;\t\t\t/* Map NL to CR on input */\n-        const IGNCR\t    = 0x080;\t\t\t/* Ignore CR */\n-        const ICRNL\t    = 0x100;\t\t\t/* Map CR to NL on input */\n-        const IXANY\t    = 0x800;\t\t\t/* Any character will restart after stop */\n+        const IGNBRK  = 0x001;\t\t\t/* Ignore break condition */\n+        const BRKINT  = 0x002;\t\t\t/* Signal interrupt on break */\n+        const IGNPAR  = 0x004;\t\t\t/* Ignore characters with parity errors */\n+        const PARMRK  = 0x008;\t\t\t/* Mark parity and framing errors */\n+        const INPCK   = 0x010;\t\t\t/* Enable input parity check */\n+        const ISTRIP  = 0x020;\t\t\t/* Strip 8th bit off characters */\n+        const INLCR   = 0x040;\t\t\t/* Map NL to CR on input */\n+        const IGNCR   = 0x080;\t\t\t/* Ignore CR */\n+        const ICRNL   = 0x100;\t\t\t/* Map CR to NL on input */\n+        const IXANY   = 0x800;\t\t\t/* Any character will restart after stop */\n         // https://elixir.bootlin.com/linux/v6.0.9/source/include/uapi/asm-generic/termbits.h\n-        const IUCLC\t    = 0x0200;\n-        const IXON\t    = 0x0400;\n-        const IXOFF\t    = 0x1000;\n-        const IMAXBEL\t= 0x2000;\n-        const IUTF8\t    = 0x4000;\n+        const IUCLC   = 0x0200;\n+        const IXON    = 0x0400;\n+        const IXOFF   = 0x1000;\n+        const IMAXBEL = 0x2000;\n+        const IUTF8   = 0x4000;\n+    }\n+}\n+\n+impl Default for C_IFLAGS {\n+    fn default() -> Self {\n+        C_IFLAGS::ICRNL | C_IFLAGS::IXON\n     }\n }\n \n@@ -37,18 +43,68 @@ bitflags! {\n     #[repr(C)]\n     #[derive(Pod)]\n     pub struct C_OFLAGS: u32 {\n-        const OPOST\t= 0x01;\t\t\t/* Perform output processing */\n-        const OCRNL\t= 0x08;\n-        const ONOCR\t= 0x10;\n-        const ONLRET= 0x20;\n-        const OFILL\t= 0x40;\n-        const OFDEL\t= 0x80;\n+        const OPOST  = 1 << 0;\t\t\t/* Perform output processing */\n+        const OLCUC  = 1 << 1;\n+        const ONLCR  = 1 << 2;\n+        const OCRNL  = 1 << 3;\n+        const ONOCR  = 1 << 4;\n+        const ONLRET = 1 << 5;\n+        const OFILL  = 1 << 6;\n+        const OFDEL  = 1 << 7;\n     }\n }\n \n-#[repr(u32)]\n+impl Default for C_OFLAGS {\n+    fn default() -> Self {\n+        C_OFLAGS::OPOST | C_OFLAGS::ONLCR\n+    }\n+}\n+\n+#[repr(C)]\n #[derive(Debug, Clone, Copy, Pod)]\n-pub enum C_CFLAGS {\n+pub struct C_CFLAGS(u32);\n+\n+impl Default for C_CFLAGS {\n+    fn default() -> Self {\n+        let cbaud = C_CFLAGS_BAUD::B38400 as u32;\n+        let csize = C_CFLAGS_CSIZE::CS8 as u32;\n+        let c_cflags = cbaud | csize | CREAD;\n+        Self(c_cflags)\n+    }\n+}\n+\n+impl C_CFLAGS {\n+    pub fn cbaud(&self) -> Result<C_CFLAGS_BAUD> {\n+        let cbaud = self.0 & CBAUD_MASK;\n+        Ok(C_CFLAGS_BAUD::try_from(cbaud)?)\n+    }\n+\n+    pub fn csize(&self) -> Result<C_CFLAGS_CSIZE> {\n+        let csize = self.0 & CSIZE_MASK;\n+        Ok(C_CFLAGS_CSIZE::try_from(csize)?)\n+    }\n+\n+    pub fn cread(&self) -> bool {\n+        self.0 & CREAD != 0\n+    }\n+}\n+\n+const CREAD: u32 = 0x00000080;\n+const CBAUD_MASK: u32 = 0x0000100f;\n+const CSIZE_MASK: u32 = 0x00000030;\n+\n+#[repr(u32)]\n+#[derive(Clone, Copy, TryFromInt)]\n+pub enum C_CFLAGS_CSIZE {\n+    CS5 = 0x00000000,\n+    CS6 = 0x00000010,\n+    CS7 = 0x00000020,\n+    CS8 = 0x00000030,\n+}\n+\n+#[repr(u32)]\n+#[derive(Debug, Clone, Copy, TryFromInt)]\n+pub enum C_CFLAGS_BAUD {\n     B0 = 0x00000000, /* hang up */\n     B50 = 0x00000001,\n     B75 = 0x00000002,\n@@ -71,28 +127,41 @@ bitflags! {\n     #[repr(C)]\n     #[derive(Pod)]\n     pub struct C_LFLAGS: u32 {\n-        const ISIG\t=   0x00001;\n-        const ICANON=   0x00002;\n-        const XCASE\t=   0x00004;\n-        const ECHO\t=   0x00008;\n-        const ECHOE\t=   0x00010;\n-        const ECHOK\t=   0x00020;\n-        const ECHONL=\t0x00040;\n-        const NOFLSH=\t0x00080;\n-        const TOSTOP=\t0x00100;\n-        const ECHOCTL=\t0x00200;\n-        const ECHOPRT=\t0x00400;\n-        const ECHOKE=   0x00800;\n-        const FLUSHO=\t0x01000;\n-        const PENDIN=\t0x04000;\n-        const IEXTEN=\t0x08000;\n-        const EXTPROC=\t0x10000;\n+        const ISIG    = 0x00001;\n+        const ICANON  = 0x00002;\n+        const XCASE   = 0x00004;\n+        const ECHO    = 0x00008;\n+        const ECHOE   = 0x00010;\n+        const ECHOK   = 0x00020;\n+        const ECHONL  = 0x00040;\n+        const NOFLSH  = 0x00080;\n+        const TOSTOP  = 0x00100;\n+        const ECHOCTL = 0x00200;\n+        const ECHOPRT = 0x00400;\n+        const ECHOKE  = 0x00800;\n+        const FLUSHO  = 0x01000;\n+        const PENDIN  = 0x04000;\n+        const IEXTEN  = 0x08000;\n+        const EXTPROC = 0x10000;\n+    }\n+}\n+\n+impl Default for C_LFLAGS {\n+    fn default() -> Self {\n+        C_LFLAGS::ICANON\n+            | C_LFLAGS::ECHO\n+            | C_LFLAGS::ISIG\n+            | C_LFLAGS::ECHOE\n+            | C_LFLAGS::ECHOK\n+            | C_LFLAGS::ECHOCTL\n+            | C_LFLAGS::ECHOKE\n+            | C_LFLAGS::IEXTEN\n     }\n }\n \n /* c_cc characters index*/\n #[repr(u32)]\n-#[derive(Debug, Clone, Copy, Pod)]\n+#[derive(Debug, Clone, Copy, TryFromInt)]\n pub enum CC_C_CHAR {\n     VINTR = 0,\n     VQUIT = 1,\n@@ -114,61 +183,28 @@ pub enum CC_C_CHAR {\n }\n \n impl CC_C_CHAR {\n-    // The special char is the same as ubuntu\n-    pub fn char(&self) -> u8 {\n+    // The special char is from gvisor\n+    pub fn default_char(&self) -> u8 {\n         match self {\n-            CC_C_CHAR::VINTR => 3,\n-            CC_C_CHAR::VQUIT => 28,\n-            CC_C_CHAR::VERASE => 127,\n-            CC_C_CHAR::VKILL => 21,\n-            CC_C_CHAR::VEOF => 4,\n-            CC_C_CHAR::VTIME => 0,\n+            CC_C_CHAR::VINTR => control_character('C'),\n+            CC_C_CHAR::VQUIT => control_character('\\\\'),\n+            CC_C_CHAR::VERASE => '\\x7f' as u8,\n+            CC_C_CHAR::VKILL => control_character('U'),\n+            CC_C_CHAR::VEOF => control_character('D'),\n+            CC_C_CHAR::VTIME => '\\0' as u8,\n             CC_C_CHAR::VMIN => 1,\n-            CC_C_CHAR::VSWTC => 0,\n-            CC_C_CHAR::VSTART => 17,\n-            CC_C_CHAR::VSTOP => 19,\n-            CC_C_CHAR::VSUSP => 26,\n-            CC_C_CHAR::VEOL => 255,\n-            CC_C_CHAR::VREPRINT => 18,\n-            CC_C_CHAR::VDISCARD => 15,\n-            CC_C_CHAR::VWERASE => 23,\n-            CC_C_CHAR::VLNEXT => 22,\n-            CC_C_CHAR::VEOL2 => 255,\n+            CC_C_CHAR::VSWTC => '\\0' as u8,\n+            CC_C_CHAR::VSTART => control_character('Q'),\n+            CC_C_CHAR::VSTOP => control_character('S'),\n+            CC_C_CHAR::VSUSP => control_character('Z'),\n+            CC_C_CHAR::VEOL => '\\0' as u8,\n+            CC_C_CHAR::VREPRINT => control_character('R'),\n+            CC_C_CHAR::VDISCARD => control_character('O'),\n+            CC_C_CHAR::VWERASE => control_character('W'),\n+            CC_C_CHAR::VLNEXT => control_character('V'),\n+            CC_C_CHAR::VEOL2 => '\\0' as u8,\n         }\n     }\n-\n-    pub fn as_usize(&self) -> usize {\n-        *self as usize\n-    }\n-\n-    pub fn from_char(item: u8) -> Result<Self> {\n-        if item == Self::VINTR.char() {\n-            return Ok(Self::VINTR);\n-        }\n-        if item == Self::VQUIT.char() {\n-            return Ok(Self::VQUIT);\n-        }\n-        if item == Self::VINTR.char() {\n-            return Ok(Self::VINTR);\n-        }\n-        if item == Self::VERASE.char() {\n-            return Ok(Self::VERASE);\n-        }\n-        if item == Self::VEOF.char() {\n-            return Ok(Self::VEOF);\n-        }\n-        if item == Self::VSTART.char() {\n-            return Ok(Self::VSTART);\n-        }\n-        if item == Self::VSTOP.char() {\n-            return Ok(Self::VSTOP);\n-        }\n-        if item == Self::VSUSP.char() {\n-            return Ok(Self::VSUSP);\n-        }\n-\n-        return_errno_with_message!(Errno::EINVAL, \"Not a valid cc_char\");\n-    }\n }\n \n #[derive(Debug, Clone, Copy, Pod)]\n@@ -185,50 +221,39 @@ pub struct KernelTermios {\n impl KernelTermios {\n     pub fn default() -> Self {\n         let mut termios = Self {\n-            c_iflags: C_IFLAGS::ICRNL,\n-            c_oflags: C_OFLAGS::empty(),\n-            c_cflags: C_CFLAGS::B0,\n-            c_lflags: C_LFLAGS::ICANON | C_LFLAGS::ECHO,\n+            c_iflags: C_IFLAGS::default(),\n+            c_oflags: C_OFLAGS::default(),\n+            c_cflags: C_CFLAGS::default(),\n+            c_lflags: C_LFLAGS::default(),\n             c_line: 0,\n-            c_cc: [0; KERNEL_NCCS],\n+            c_cc: [CcT::default(); KERNEL_NCCS],\n         };\n-        *termios.get_special_char_mut(CC_C_CHAR::VINTR) = CC_C_CHAR::VINTR.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VQUIT) = CC_C_CHAR::VQUIT.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VERASE) = CC_C_CHAR::VERASE.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VKILL) = CC_C_CHAR::VKILL.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VEOF) = CC_C_CHAR::VEOF.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VTIME) = CC_C_CHAR::VTIME.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VMIN) = CC_C_CHAR::VMIN.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSWTC) = CC_C_CHAR::VSWTC.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSTART) = CC_C_CHAR::VSTART.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSTOP) = CC_C_CHAR::VSTOP.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VSUSP) = CC_C_CHAR::VSUSP.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VEOL) = CC_C_CHAR::VEOL.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VREPRINT) = CC_C_CHAR::VREPRINT.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VDISCARD) = CC_C_CHAR::VDISCARD.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VWERASE) = CC_C_CHAR::VWERASE.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VLNEXT) = CC_C_CHAR::VLNEXT.char();\n-        *termios.get_special_char_mut(CC_C_CHAR::VEOL2) = CC_C_CHAR::VEOL2.char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VINTR) = CC_C_CHAR::VINTR.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VQUIT) = CC_C_CHAR::VQUIT.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VERASE) = CC_C_CHAR::VERASE.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VKILL) = CC_C_CHAR::VKILL.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VEOF) = CC_C_CHAR::VEOF.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VTIME) = CC_C_CHAR::VTIME.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VMIN) = CC_C_CHAR::VMIN.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSWTC) = CC_C_CHAR::VSWTC.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSTART) = CC_C_CHAR::VSTART.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSTOP) = CC_C_CHAR::VSTOP.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VSUSP) = CC_C_CHAR::VSUSP.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VEOL) = CC_C_CHAR::VEOL.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VREPRINT) = CC_C_CHAR::VREPRINT.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VDISCARD) = CC_C_CHAR::VDISCARD.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VWERASE) = CC_C_CHAR::VWERASE.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VLNEXT) = CC_C_CHAR::VLNEXT.default_char();\n+        *termios.get_special_char_mut(CC_C_CHAR::VEOL2) = CC_C_CHAR::VEOL2.default_char();\n         termios\n     }\n \n-    fn new() -> Self {\n-        KernelTermios {\n-            c_iflags: C_IFLAGS::empty(),\n-            c_oflags: C_OFLAGS::empty(),\n-            c_cflags: C_CFLAGS::B0,\n-            c_lflags: C_LFLAGS::empty(),\n-            c_line: 0,\n-            c_cc: [0; KERNEL_NCCS],\n-        }\n-    }\n-\n     pub fn get_special_char(&self, cc_c_char: CC_C_CHAR) -> &CcT {\n-        &self.c_cc[cc_c_char.as_usize()]\n+        &self.c_cc[cc_c_char as usize]\n     }\n \n     pub fn get_special_char_mut(&mut self, cc_c_char: CC_C_CHAR) -> &mut CcT {\n-        &mut self.c_cc[cc_c_char.as_usize()]\n+        &mut self.c_cc[cc_c_char as usize]\n     }\n \n     /// Canonical mode means we will handle input by lines, not by single character\n@@ -265,3 +290,17 @@ impl KernelTermios {\n         self.c_lflags.contains(C_LFLAGS::IEXTEN)\n     }\n }\n+\n+const fn control_character(c: char) -> u8 {\n+    debug_assert!(c as u8 >= 'A' as u8);\n+    c as u8 - 'A' as u8 + 1u8\n+}\n+\n+#[derive(Debug, Clone, Copy, Default, Pod)]\n+#[repr(C)]\n+pub struct WinSize {\n+    ws_row: u16,\n+    ws_col: u16,\n+    ws_xpixel: u16,\n+    ws_ypixel: u16,\n+}\ndiff --git a/services/libs/jinux-std/src/fs/devpts/master.rs b/services/libs/jinux-std/src/fs/devpts/master.rs\nindex 911f074c0b..88a97cd0ec 100644\n--- a/services/libs/jinux-std/src/fs/devpts/master.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/master.rs\n@@ -1,7 +1,9 @@\n-use crate::prelude::*;\n+use crate::{fs::file_handle::FileLike, prelude::*};\n \n use super::*;\n \n+use crate::device::PtyMaster;\n+\n /// Pty master inode for the master device.\n pub struct PtyMasterInode(Arc<PtyMaster>);\n \n@@ -14,8 +16,11 @@ impl PtyMasterInode {\n impl Drop for PtyMasterInode {\n     fn drop(&mut self) {\n         // Remove the slave from fs.\n-        let index = self.0.slave_index();\n-        let _ = self.0.ptmx().devpts().remove_slave(index);\n+        let fs = self.0.ptmx().fs();\n+        let devpts = fs.downcast_ref::<DevPts>().unwrap();\n+\n+        let index = self.0.index();\n+        devpts.remove_slave(index);\n     }\n }\n \n@@ -77,52 +82,6 @@ impl Inode for PtyMasterInode {\n     }\n \n     fn fs(&self) -> Arc<dyn FileSystem> {\n-        self.0.ptmx().devpts()\n-    }\n-}\n-\n-// TODO: implement real pty master.\n-pub struct PtyMaster {\n-    slave_index: u32,\n-    ptmx: Arc<Ptmx>,\n-}\n-\n-impl PtyMaster {\n-    pub fn new(slave_index: u32, ptmx: Arc<Ptmx>) -> Arc<Self> {\n-        Arc::new(Self { slave_index, ptmx })\n-    }\n-\n-    pub fn slave_index(&self) -> u32 {\n-        self.slave_index\n-    }\n-\n-    fn ptmx(&self) -> &Ptmx {\n-        &self.ptmx\n-    }\n-}\n-\n-impl Device for PtyMaster {\n-    fn type_(&self) -> DeviceType {\n-        self.ptmx.device_type()\n-    }\n-\n-    fn id(&self) -> DeviceId {\n-        self.ptmx.device_id()\n-    }\n-\n-    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn write(&self, buf: &[u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        todo!();\n-    }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        todo!();\n+        self.0.ptmx().fs()\n     }\n }\ndiff --git a/services/libs/jinux-std/src/fs/devpts/mod.rs b/services/libs/jinux-std/src/fs/devpts/mod.rs\nindex a661274b83..ac2a0ddd7b 100644\n--- a/services/libs/jinux-std/src/fs/devpts/mod.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/mod.rs\n@@ -9,9 +9,9 @@ use core::time::Duration;\n use jinux_frame::vm::VmFrame;\n use jinux_util::{id_allocator::IdAlloc, slot_vec::SlotVec};\n \n-use self::master::{PtyMaster, PtyMasterInode};\n+use self::master::PtyMasterInode;\n use self::ptmx::Ptmx;\n-use self::slave::{PtySlave, PtySlaveInode};\n+use self::slave::PtySlaveInode;\n \n mod master;\n mod ptmx;\n@@ -60,8 +60,7 @@ impl DevPts {\n             .alloc()\n             .ok_or_else(|| Error::with_message(Errno::EIO, \"cannot alloc index\"))?;\n \n-        let master = PtyMaster::new(index as u32, self.root.ptmx.clone());\n-        let slave = PtySlave::new(master.clone());\n+        let (master, slave) = crate::device::new_pty_pair(index as u32, self.root.ptmx.clone())?;\n \n         let master_inode = PtyMasterInode::new(master);\n         let slave_inode = PtySlaveInode::new(slave, self.this.clone());\ndiff --git a/services/libs/jinux-std/src/fs/devpts/slave.rs b/services/libs/jinux-std/src/fs/devpts/slave.rs\nindex 2297c33649..027e243eba 100644\n--- a/services/libs/jinux-std/src/fs/devpts/slave.rs\n+++ b/services/libs/jinux-std/src/fs/devpts/slave.rs\n@@ -2,6 +2,8 @@ use crate::prelude::*;\n \n use super::*;\n \n+use crate::device::PtySlave;\n+\n /// Same major number with Linux, the minor number is the index of slave.\n const SLAVE_MAJOR_NUM: u32 = 3;\n \n@@ -88,44 +90,3 @@ impl Inode for PtySlaveInode {\n         self.fs.upgrade().unwrap()\n     }\n }\n-\n-// TODO: implement real pty slave.\n-pub struct PtySlave {\n-    master: Arc<PtyMaster>,\n-}\n-\n-impl PtySlave {\n-    pub fn new(master: Arc<PtyMaster>) -> Arc<Self> {\n-        Arc::new(Self { master })\n-    }\n-\n-    pub fn index(&self) -> u32 {\n-        self.master.slave_index()\n-    }\n-}\n-\n-impl Device for PtySlave {\n-    fn type_(&self) -> DeviceType {\n-        DeviceType::CharDevice\n-    }\n-\n-    fn id(&self) -> DeviceId {\n-        DeviceId::new(SLAVE_MAJOR_NUM, self.index())\n-    }\n-\n-    fn read(&self, buf: &mut [u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn write(&self, buf: &[u8]) -> Result<usize> {\n-        todo!();\n-    }\n-\n-    fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        todo!();\n-    }\n-\n-    fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        todo!();\n-    }\n-}\ndiff --git a/services/libs/jinux-std/src/fs/utils/ioctl.rs b/services/libs/jinux-std/src/fs/utils/ioctl.rs\nindex 58c0c4d81a..9a57cb0206 100644\n--- a/services/libs/jinux-std/src/fs/utils/ioctl.rs\n+++ b/services/libs/jinux-std/src/fs/utils/ioctl.rs\n@@ -3,18 +3,30 @@ use crate::prelude::*;\n #[repr(u32)]\n #[derive(Debug, Clone, Copy, TryFromInt)]\n pub enum IoctlCmd {\n-    // Get terminal attributes\n+    /// Get terminal attributes\n     TCGETS = 0x5401,\n     TCSETS = 0x5402,\n-    // Drain the output buffer and set attributes\n+    /// Drain the output buffer and set attributes\n     TCSETSW = 0x5403,\n-    // Drain the output buffer, and discard pending input, and set attributes\n+    /// Drain the output buffer, and discard pending input, and set attributes\n     TCSETSF = 0x5404,\n-    // Get the process group ID of the foreground process group on this terminal\n+    /// Make the given terminal the controlling terminal of the calling process.\n+    TIOCSCTTY = 0x540e,\n+    /// Get the process group ID of the foreground process group on this terminal\n     TIOCGPGRP = 0x540f,\n-    // Set the foreground process group ID of this terminal.\n+    /// Set the foreground process group ID of this terminal.\n     TIOCSPGRP = 0x5410,\n-    // Set window size\n+    /// Get the number of bytes in the input buffer.\n+    FIONREAD = 0x541B,\n+    /// Set window size\n     TIOCGWINSZ = 0x5413,\n     TIOCSWINSZ = 0x5414,\n+    /// the calling process gives up this controlling terminal\n+    TIOCNOTTY = 0x5422,\n+    /// Get Pty Number\n+    TIOCGPTN = 0x80045430,\n+    /// Lock/unlock Pty\n+    TIOCSPTLCK = 0x40045431,\n+    /// Safely open the slave\n+    TIOCGPTPEER = 0x40045441,\n }\ndiff --git a/services/libs/jinux-std/src/fs/utils/vnode.rs b/services/libs/jinux-std/src/fs/utils/vnode.rs\nindex e8b944f985..617f6c36b0 100644\n--- a/services/libs/jinux-std/src/fs/utils/vnode.rs\n+++ b/services/libs/jinux-std/src/fs/utils/vnode.rs\n@@ -146,6 +146,7 @@ impl Vnode {\n         if let Some(page_cache) = &inner.page_cache {\n             page_cache.evict_range(0..file_len);\n         }\n+\n         inner.inode.read_at(0, &mut buf[..file_len])\n     }\n \n@@ -196,11 +197,13 @@ impl Vnode {\n     }\n \n     pub fn poll(&self, mask: IoEvents, poller: Option<&Poller>) -> IoEvents {\n-        self.inner.read().inode.poll(mask, poller)\n+        let inode = self.inner.read().inode.clone();\n+        inode.poll(mask, poller)\n     }\n \n     pub fn ioctl(&self, cmd: IoctlCmd, arg: usize) -> Result<i32> {\n-        self.inner.read().inode.ioctl(cmd, arg)\n+        let inode = self.inner.read().inode.clone();\n+        inode.ioctl(cmd, arg)\n     }\n \n     pub fn fs(&self) -> Arc<dyn FileSystem> {\ndiff --git a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\nindex 3e2d47c0ab..994c948804 100644\n--- a/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n+++ b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\n@@ -150,12 +150,27 @@ impl VmMapping {\n     }\n     pub fn read_bytes(&self, offset: usize, buf: &mut [u8]) -> Result<()> {\n         let vmo_read_offset = self.vmo_offset() + offset;\n+\n+        // TODO: the current logic is vulnerable to TOCTTOU attack, since the permission may change after check.\n+        let page_idx_range = get_page_idx_range(&(vmo_read_offset..vmo_read_offset + buf.len()));\n+        let read_perm = VmPerm::R;\n+        for page_idx in page_idx_range {\n+            self.check_perm(&page_idx, &read_perm)?;\n+        }\n+\n         self.vmo.read_bytes(vmo_read_offset, buf)?;\n         Ok(())\n     }\n \n     pub fn write_bytes(&self, offset: usize, buf: &[u8]) -> Result<()> {\n         let vmo_write_offset = self.vmo_offset() + offset;\n+\n+        let page_idx_range = get_page_idx_range(&(vmo_write_offset..vmo_write_offset + buf.len()));\n+        let write_perm = VmPerm::W;\n+        for page_idx in page_idx_range {\n+            self.check_perm(&page_idx, &write_perm)?;\n+        }\n+\n         self.vmo.write_bytes(vmo_write_offset, buf)?;\n         Ok(())\n     }\n@@ -198,7 +213,9 @@ impl VmMapping {\n         } else {\n             self.vmo.check_rights(Rights::READ)?;\n         }\n-        self.check_perm(&page_idx, write)?;\n+\n+        let required_perm = if write { VmPerm::W } else { VmPerm::R };\n+        self.check_perm(&page_idx, &required_perm)?;\n \n         let frame = self.vmo.get_committed_frame(page_idx, write)?;\n \n@@ -300,8 +317,8 @@ impl VmMapping {\n         self.inner.lock().trim_right(vm_space, vaddr)\n     }\n \n-    fn check_perm(&self, page_idx: &usize, write: bool) -> Result<()> {\n-        self.inner.lock().check_perm(page_idx, write)\n+    fn check_perm(&self, page_idx: &usize, perm: &VmPerm) -> Result<()> {\n+        self.inner.lock().check_perm(page_idx, perm)\n     }\n }\n \n@@ -457,16 +474,14 @@ impl VmMappingInner {\n         self.map_to_addr..self.map_to_addr + self.map_size\n     }\n \n-    fn check_perm(&self, page_idx: &usize, write: bool) -> Result<()> {\n+    fn check_perm(&self, page_idx: &usize, perm: &VmPerm) -> Result<()> {\n         let page_perm = self\n             .page_perms\n             .get(&page_idx)\n             .ok_or(Error::with_message(Errno::EINVAL, \"invalid page idx\"))?;\n-        if !page_perm.contains(VmPerm::R) {\n-            return_errno_with_message!(Errno::EINVAL, \"perm should at least contain read\");\n-        }\n-        if write && !page_perm.contains(VmPerm::W) {\n-            return_errno_with_message!(Errno::EINVAL, \"perm should contain write for write access\");\n+\n+        if !page_perm.contains(*perm) {\n+            return_errno_with_message!(Errno::EACCES, \"perm check fails\");\n         }\n \n         Ok(())\n", "test_patch": "diff --git a/regression/apps/scripts/run_tests.sh b/regression/apps/scripts/run_tests.sh\nindex 7556dde7f5..d39bc54428 100755\n--- a/regression/apps/scripts/run_tests.sh\n+++ b/regression/apps/scripts/run_tests.sh\n@@ -6,7 +6,7 @@ SCRIPT_DIR=/regression\n cd ${SCRIPT_DIR}/..\n \n echo \"Running tests......\"\n-tests=\"hello_world/hello_world fork/fork execve/execve fork_c/fork signal_c/signal_test pthread/pthread_test hello_pie/hello\"\n+tests=\"hello_world/hello_world fork/fork execve/execve fork_c/fork signal_c/signal_test pthread/pthread_test hello_pie/hello pty/open_pty\"\n for testcase in ${tests}\n do \n     echo \"Running test ${testcase}......\"\ndiff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\nindex a8198e8dee..8789dc56f7 100644\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -1,4 +1,4 @@\n-TESTS ?= open_test read_test statfs_test chmod_test\n+TESTS ?= open_test read_test statfs_test chmod_test pty_test\n \n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\ndiff --git a/regression/syscall_test/blocklists/pty_test b/regression/syscall_test/blocklists/pty_test\nnew file mode 100644\nindex 0000000000..3d712cd4fd\n--- /dev/null\n+++ b/regression/syscall_test/blocklists/pty_test\n@@ -0,0 +1,42 @@\n+PtyTrunc.Truncate\n+PtyTest.MasterTermiosUnchangable\n+PtyTest.TermiosICRNL\n+PtyTest.TermiosONLCR\n+PtyTest.TermiosINLCR\n+PtyTest.TermiosOCRNL\n+PtyTest.SwitchCanonToNonCanonNewline\n+PtyTest.TermiosICANONNewline\n+PtyTest.TermiosICANONEOF\n+PtyTest.CanonDiscard\n+PtyTest.CanonMultiline\n+PtyTest.SimpleEcho\n+PtyTest.TermiosIGNCR\n+PtyTest.TermiosONOCR\n+PtyTest.VEOLTermination\n+PtyTest.CanonBigWrite\n+PtyTest.SwitchCanonToNoncanon\n+PtyTest.SwitchNoncanonToCanonNewlineBig\n+PtyTest.SwitchNoncanonToCanonNoNewline\n+PtyTest.SwitchNoncanonToCanonNoNewlineBig\n+PtyTest.NoncanonBigWrite\n+PtyTest.SwitchNoncanonToCanonMultiline\n+PtyTest.SwitchTwiceMultiline\n+JobControlTest.SetTTYMaster\n+JobControlTest.SetTTY\n+JobControlTest.SetTTYNonLeader\n+JobControlTest.SetTTYBadArg\n+JobControlTest.SetTTYDifferentSession\n+JobControlTest.ReleaseTTY\n+JobControlTest.ReleaseUnsetTTY\n+JobControlTest.ReleaseWrongTTY\n+JobControlTest.ReleaseTTYNonLeader\n+JobControlTest.ReleaseTTYDifferentSession\n+JobControlTest.ReleaseTTYSignals\n+JobControlTest.GetForegroundProcessGroup\n+JobControlTest.GetForegroundProcessGroupNonControlling\n+JobControlTest.SetForegroundProcessGroup\n+JobControlTest.SetForegroundProcessGroupWrongTTY\n+JobControlTest.SetForegroundProcessGroupNegPgid\n+JobControlTest.SetForegroundProcessGroupEmptyProcessGroup\n+JobControlTest.SetForegroundProcessGroupDifferentSession\n+JobControlTest.OrphanRegression\n\\ No newline at end of file\n", "problem_statement": "Implement pseudo terminals\nMaybe we need #209 for pty, since each pty will be a device under devfs.\n", "hints_text": "", "created_at": "2023-08-01T06:37:18Z", "version": "0.1"}, {"repo": "asterinas/asterinas", "pull_number": 327, "instance_id": "asterinas__asterinas-327", "issue_numbers": ["340"], "base_commit": "dbfb2e1a62a9981a67cc01ff7310981744ec2ac5", "patch": "diff --git a/tools/docker/.gitignore b/tools/docker/.gitignore\nnew file mode 100644\nindex 0000000000..c4d86dc34f\n--- /dev/null\n+++ b/tools/docker/.gitignore\n@@ -0,0 +1,1 @@\n+bom/\ndiff --git a/tools/docker/Dockerfile.ubuntu22.04 b/tools/docker/Dockerfile.ubuntu22.04\nindex ab0f054034..c2f7486893 100644\n--- a/tools/docker/Dockerfile.ubuntu22.04\n+++ b/tools/docker/Dockerfile.ubuntu22.04\n@@ -1,27 +1,47 @@\n-FROM ubuntu:22.04\n+FROM ubuntu:22.04 as ubuntu-22.04-with-bazel\n \n SHELL [\"/bin/bash\", \"-c\"]\n \n ARG DEBIAN_FRONTEND=noninteractive\n+\n+# Install all Bazel dependent packages\n RUN apt update && apt-get install -y --no-install-recommends \\\n     build-essential \\\n     ca-certificates \\\n+    curl \\\n+    git-core \\\n+    gnupg \\\n+    python-is-python3 \\\n+    python3-pip\n+\n+# Install bazel, which is required by the system call test suite from Gvisor project\n+COPY bom/syscall_test/install_bazel.sh /tmp/\n+WORKDIR /tmp\n+RUN ./install_bazel.sh && rm -f /tmp/install_bazel.sh\n+\n+FROM ubuntu-22.04-with-bazel as syscall_test\n+\n+# Build the syscall test binaries\n+COPY bom/syscall_test /root/syscall_test\n+WORKDIR /root/syscall_test\n+RUN export BUILD_DIR=build && \\\n+    make ${BUILD_DIR}/syscall_test_bins\n+\n+FROM ubuntu-22.04-with-bazel\n+\n+# Install all Jinux dependent packages\n+RUN apt update && apt-get install -y --no-install-recommends \\\n     cpio \\\n     cpuid \\\n-    curl \\\n     file \\\n     g++ \\\n     gdb \\\n-    git-core \\\n-    gnupg \\\n     grub-common \\\n     grub-pc \\\n     libssl-dev \\\n     net-tools \\\n     openssh-server \\\n     pkg-config \\\n-    python-is-python3 \\\n-    python3-pip \\\n     qemu-system-x86 \\\n     strace \\\n     sudo \\\n@@ -31,17 +51,14 @@ RUN apt update && apt-get install -y --no-install-recommends \\\n     xorriso \\\n     zip\n \n-# Install bazel, , which is required by the system call test suite from Gvisor project\n-RUN curl -fsSL https://bazel.build/bazel-release.pub.gpg | gpg --dearmor > bazel.gpg \\ \n-    && mv bazel.gpg /etc/apt/trusted.gpg.d/ \\\n-    && echo 'deb [arch=amd64] https://storage.googleapis.com/bazel-apt stable jdk1.8' | tee /etc/apt/sources.list.d/bazel.list \\\n-    && apt update \\ \n-    && apt install bazel=5.4.0 -y\n-\n # Clean apt cache\n RUN apt clean \\\n     && rm -rf /var/lib/apt/lists/*\n \n+# Prepare the system call test suite\n+COPY --from=syscall_test /root/syscall_test/build/syscall_test_bins /root/syscall_test_bins\n+ENV JINUX_PREBUILT_SYSCALL_TEST=/root/syscall_test_bins\n+\n # Install Rust\n ENV PATH=\"/root/.cargo/bin:${PATH}\"\n ARG JINUX_RUST_VERSION\ndiff --git a/tools/docker/build_image.sh b/tools/docker/build_image.sh\nindex 1cc10a5b21..8a871aa568 100755\n--- a/tools/docker/build_image.sh\n+++ b/tools/docker/build_image.sh\n@@ -7,10 +7,19 @@ CARGO_TOML_PATH=${SCRIPT_DIR}/../../Cargo.toml\n VERSION=$( grep -m1 -o '[0-9]\\+\\.[0-9]\\+\\.[0-9]\\+' ${CARGO_TOML_PATH} | sed 's/[^0-9\\.]//g'  )\n IMAGE_NAME=jinuxdev/jinux:${VERSION}\n DOCKER_FILE=${SCRIPT_DIR}/Dockerfile.ubuntu22.04\n+BOM_DIR=${SCRIPT_DIR}/bom\n+TOP_DIR=${SCRIPT_DIR}/../../\n ARCH=linux/amd64\n RUST_TOOLCHAIN_PATH=${SCRIPT_DIR}/../../rust-toolchain.toml\n JINUX_RUST_VERSION=$( grep -m1 -o 'nightly-[0-9]\\+-[0-9]\\+-[0-9]\\+' ${RUST_TOOLCHAIN_PATH} )\n \n+# Prpare the BOM (bill of materials) directory to copy files or dirs into the docker image.\n+# This is because the `docker build` can not access the parent directory of the context.\n+if [ ! -d ${BOM_DIR} ]; then\n+    mkdir -p ${BOM_DIR}\n+    cp -rf ${TOP_DIR}/regression/syscall_test ${BOM_DIR}/\n+fi\n+\n # Build docker\n cd ${SCRIPT_DIR}\n docker buildx build -f ${DOCKER_FILE} \\\n", "test_patch": "diff --git a/regression/syscall_test/Makefile b/regression/syscall_test/Makefile\nindex d91d80822b..a8198e8dee 100644\n--- a/regression/syscall_test/Makefile\n+++ b/regression/syscall_test/Makefile\n@@ -2,9 +2,13 @@ TESTS ?= open_test read_test statfs_test chmod_test\n \n MKFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))\n CUR_DIR := $(patsubst %/,%,$(dir $(MKFILE_PATH)))\n-BUILD_DIR := $(CUR_DIR)/../build\n-SRC_DIR := $(BUILD_DIR)/gvisor_src\n-BIN_DIR := $(BUILD_DIR)/syscall_test_bins\n+BUILD_DIR ?= $(CUR_DIR)/../build\n+ifdef JINUX_PREBUILT_SYSCALL_TEST\n+\tBIN_DIR := $(JINUX_PREBUILT_SYSCALL_TEST)\n+else\n+\tBIN_DIR := $(BUILD_DIR)/syscall_test_bins\n+\tSRC_DIR := $(BUILD_DIR)/gvisor_src\n+endif\n INITRAMFS ?= $(CUR_DIR)/../build/initramfs\n TARGET_DIR := $(INITRAMFS)/opt/syscall_test\n RUN_BASH := $(CUR_DIR)/run_syscall_test.sh\n@@ -14,20 +18,25 @@ BLOCK_LIST := $(CUR_DIR)/blocklists\n \n all: $(TESTS)\n \n-$(SRC_DIR):\n+$(TESTS): $(BIN_DIR) $(TARGET_DIR)\n+\t@cp -f $</$@ $(TARGET_DIR)/tests\n+\n+ifndef JINUX_PREBUILT_SYSCALL_TEST\n+$(BIN_DIR): $(SRC_DIR)\n \t@if ! type bazel > /dev/null; then \\\n \t\techo \"bazel is not installed, please run $(CUR_DIR)/install_bazel.sh with sudo permission to install it.\"; \\\n-\t\texit 1 ; \\\n+\t\texit 1; \\\n \tfi\n-\t@rm -rf $@ && mkdir -p $@\n-\t@cd $@ && git clone -b 20200921.0 https://github.com/jinzhao-dev/gvisor.git .\n-\n-$(BIN_DIR): $(SRC_DIR)\n \t@rm -rf $@ && mkdir -p $@\n \t@cd $(SRC_DIR) && bazel build --test_tag_filters=native //test/syscalls/...\n \t@cp $(SRC_DIR)/bazel-bin/test/syscalls/linux/*_test $@\n \n-$(TARGET_DIR): $(RUN_BASH) $(BLOCK_LIST) $(BIN_DIR)\n+$(SRC_DIR):\n+\t@rm -rf $@ && mkdir -p $@\n+\t@cd $@ && git clone -b 20200921.0 https://github.com/jinzhao-dev/gvisor.git .\n+endif\n+\n+$(TARGET_DIR): $(RUN_BASH) $(BLOCK_LIST)\n \t@rm -rf $@ && mkdir -p $@\n \t@# Prepare tests dir for test binaries\n \t@mkdir $@/tests\n@@ -36,8 +45,5 @@ $(TARGET_DIR): $(RUN_BASH) $(BLOCK_LIST) $(BIN_DIR)\n \t@# Copy bash script\n \t@cp -f $(RUN_BASH) $@\n \n-$(TESTS): $(TARGET_DIR)\n-\t@cp -f $(BIN_DIR)/$@ $(TARGET_DIR)/tests\n-\n clean:\n-\t@rm -rf $(BIN_DIR) $(TARGET_DIR)\n+\t@rm -rf $(TARGET_DIR)\n\\ No newline at end of file\n", "problem_statement": "Precompile syscall tests in the dev docker image to accelerate CI\nCurrently the syscall tests are compiled every-time when CI triggers, which is at a cost of around 12 minutes on Github runners.\n", "hints_text": "", "created_at": "2023-07-27T07:11:21Z", "version": "0.1"}, {"repo": "asterinas/asterinas", "pull_number": 183, "instance_id": "asterinas__asterinas-183", "issue_numbers": ["115"], "base_commit": "888853a6de752e97c6f94fff83c00594be42929f", "patch": "diff --git a/src/.cargo/config.toml b/.cargo/config.toml\nsimilarity index 100%\nrename from src/.cargo/config.toml\nrename to .cargo/config.toml\ndiff --git a/.gitattributes b/.gitattributes\nindex 5da8683478..112cce3c07 100644\n--- a/.gitattributes\n+++ b/.gitattributes\n@@ -1,10 +1,10 @@\n-src/apps/hello_world/hello_world filter=lfs diff=lfs merge=lfs -text\n-src/apps/fork/fork filter=lfs diff=lfs merge=lfs -text\n-src/apps/hello_c/hello filter=lfs diff=lfs merge=lfs -text\n-src/apps/execve/execve filter=lfs diff=lfs merge=lfs -text\n-src/apps/execve/hello filter=lfs diff=lfs merge=lfs -text\n-src/apps/fork_c/fork filter=lfs diff=lfs merge=lfs -text\n-src/apps/signal_c/signal_test filter=lfs diff=lfs merge=lfs -text\n-src/apps/busybox/busybox filter=lfs diff=lfs merge=lfs -text\n-src/apps/pthread/pthread_test filter=lfs diff=lfs merge=lfs -text\n-src/apps/hello_pie/hello filter=lfs diff=lfs merge=lfs -text\n+regression/apps/hello_world/hello_world filter=lfs diff=lfs merge=lfs -text\n+regression/apps/fork/fork filter=lfs diff=lfs merge=lfs -text\n+regression/apps/hello_c/hello filter=lfs diff=lfs merge=lfs -text\n+regression/apps/execve/execve filter=lfs diff=lfs merge=lfs -text\n+regression/apps/execve/hello filter=lfs diff=lfs merge=lfs -text\n+regression/apps/fork_c/fork filter=lfs diff=lfs merge=lfs -text\n+regression/apps/signal_c/signal_test filter=lfs diff=lfs merge=lfs -text\n+regression/apps/busybox/busybox filter=lfs diff=lfs merge=lfs -text\n+regression/apps/pthread/pthread_test filter=lfs diff=lfs merge=lfs -text\n+regression/apps/hello_pie/hello filter=lfs diff=lfs merge=lfs -text\ndiff --git a/.gitignore b/.gitignore\nindex 9981fa9924..19881b377b 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -13,8 +13,8 @@ target/\n **/.DS_Store\n \n # Ramdisk file\n-src/ramdisk/initramfs/\n-src/ramdisk/build/\n+regression/ramdisk/initramfs/\n+regression/ramdisk/build/\n \n # qemu log file\n qemu.log\ndiff --git a/src/Cargo.lock b/Cargo.lock\nsimilarity index 100%\nrename from src/Cargo.lock\nrename to Cargo.lock\ndiff --git a/src/Cargo.toml b/Cargo.toml\nsimilarity index 79%\nrename from src/Cargo.toml\nrename to Cargo.toml\nindex ef60250eb6..143ce953ac 100644\n--- a/src/Cargo.toml\n+++ b/Cargo.toml\n@@ -3,11 +3,15 @@ name = \"jinux\"\n version = \"0.1.0\"\n edition = \"2021\"\n \n+[[bin]]\n+name = \"jinux\"\n+path = \"kernel/main.rs\"\n+\n [dependencies]\n limine = \"0.1.10\"\n jinux-frame = { path = \"framework/jinux-frame\" }\n jinux-std = { path = \"services/libs/jinux-std\" }\n-component = { path = \"services/comp-sys/component\" }\n+component = { path = \"services/libs/comp-sys/component\" }\n \n [dev-dependencies]\n x86_64 = \"0.14.2\"\n@@ -33,4 +37,4 @@ members = [\n     \"services/libs/cpio-decoder\",\n ]\n \n-exclude = [\"services/comp-sys/controlled\", \"services/comp-sys/cargo-component\"]\n+exclude = [\"services/libs/comp-sys/controlled\", \"services/libs/comp-sys/cargo-component\"]\ndiff --git a/src/Components.toml b/Components.toml\nsimilarity index 100%\nrename from src/Components.toml\nrename to Components.toml\ndiff --git a/Makefile b/Makefile\nindex ee191869de..b8cf032494 100644\n--- a/Makefile\n+++ b/Makefile\n@@ -1,6 +1,6 @@\n .PHONY: all build clean docs fmt run setup test tools\n \n-all: build test\n+all: build\n \n setup:\n \t@rustup component add rust-src\n@@ -9,28 +9,28 @@ setup:\n \t@cargo install mdbook\n \n build:\n-\t@make --no-print-directory -C src/ramdisk\n-\t@cd src && cargo kbuild\n+\t@make --no-print-directory -C regression/ramdisk\n+\t@cargo kbuild\n \n tools:\n-\t@cd src/services/comp-sys && cargo install --path cargo-component\n+\t@cd services/libs/comp-sys && cargo install --path cargo-component\n \n run: build\n-\t@cd src && cargo krun\n+\t@cargo krun\n \n test: build\n-\t@cd src && cargo ktest\n+\t@cargo ktest\n \n docs:\n-\t@cd src && cargo doc \t\t\t\t\t# Build Rust docs\n+\t@cargo doc \t\t\t\t\t\t\t\t# Build Rust docs\n \t@echo \"\" \t\t\t\t\t\t\t\t# Add a blank line\n \t@cd docs && mdbook build \t\t\t\t# Build mdBook\n \n check:\n-\t@cd src && cargo fmt --check \t\t\t# Check Rust format issues\n-\t@cd src && cargo clippy\t\t\t\t\t# Check common programming mistakes\n+\t@cargo fmt --check \t\t\t\t# Check Rust format issues\n+\t@cargo clippy\t\t\t\t\t# Check common programming mistakes\n \n clean:\n-\t@cd src && cargo clean\n+\t@cargo clean\n \t@cd docs && mdbook clean\n-\t@make --no-print-directory -C src/ramdisk clean\n+\t@make --no-print-directory -C regression/ramdisk clean\ndiff --git a/README.md b/README.md\nindex 0fdd7f844e..d2ef2e41a0 100644\n--- a/README.md\n+++ b/README.md\n@@ -23,16 +23,16 @@ As a zero-cost, least-privilege OS, Jinux provides the best of both worlds: the\n ## How to build and test\n \n While most code is written in Rust, the project-scope build process is governed \n-by Makefile.\n+by Makefile. The following commands are intended for use on an Ubuntu server that has installed qemu-system-x86_64.\n \n-Before downloading source code, install and init Git LFS since the project manage binaries with Git LFS.\n+### Preparation\n+Before downloading source code, install and init Git LFS since the project manages binaries with Git LFS. \n ```bash\n # 1. install git-lfs\n-brew install git-lfs            # for mac\n-apt install git-lfs             # for ubuntu\n+apt install git-lfs             \n \n # 2. init git-lfs for current user\n-git lfs install --skip-repo     # for mac & ubuntu\n+git lfs install --skip-repo     \n ```\n \n Then, download source codes as normal.\n@@ -46,22 +46,29 @@ all developmennt tools are installed.\n make setup\n ```\n \n-Then, install some standalone tools (e.g., `cargo-component`) under the project directory.\n-``` bash\n-make tools\n+### build\n+Then, we can build the project.\n+```bash\n+make build\n ```\n \n-Set environmental variables to enable `cargo` find installed tools.\n+If everything goes well, then we can run the OS.\n ```bash\n-export PATH=`pwd`/src/target/bin:${PATH}\n+make run\n ```\n \n-Then, we can build and test the project.\n+### Test  \n+We can run unit tests and integration tests if building succeeds.\n ```bash\n-make\n+make test\n ```\n \n-If everything goes well, then we can run the OS.\n+If we want to check access control policy among components, install some standalone tools (e.g., `cargo-component`), and set environmental variables to enable `cargo` find installed tools under the project directory. \n+``` bash\n+make tools\n+export PATH=`pwd`/target/bin:${PATH}\n+```\n+Then we can use the tool to check access control policy.\n ```bash\n-make run\n+cargo component-check\n ```\ndiff --git a/src/boot/Cargo.toml b/boot/Cargo.toml\nsimilarity index 100%\nrename from src/boot/Cargo.toml\nrename to boot/Cargo.toml\ndiff --git a/src/boot/limine/conf/limine.cfg b/boot/limine/conf/limine.cfg\nsimilarity index 100%\nrename from src/boot/limine/conf/limine.cfg\nrename to boot/limine/conf/limine.cfg\ndiff --git a/src/boot/limine/conf/linker.ld b/boot/limine/conf/linker.ld\nsimilarity index 100%\nrename from src/boot/limine/conf/linker.ld\nrename to boot/limine/conf/linker.ld\ndiff --git a/src/boot/limine/scripts/limine-build.sh b/boot/limine/scripts/limine-build.sh\nsimilarity index 95%\nrename from src/boot/limine/scripts/limine-build.sh\nrename to boot/limine/scripts/limine-build.sh\nindex 7267124098..69188a64f0 100755\n--- a/src/boot/limine/scripts/limine-build.sh\n+++ b/boot/limine/scripts/limine-build.sh\n@@ -25,7 +25,7 @@ cp target/limine/limine-cd.bin target/iso_root\n cp target/limine/limine-cd-efi.bin target/iso_root\n \n # Copy ramdisk\n-cp ramdisk/build/ramdisk.cpio target/iso_root\n+cp regression/ramdisk/build/ramdisk.cpio target/iso_root\n \n xorriso -as mkisofs                                             \\\n     -b limine-cd.bin                                            \\\ndiff --git a/src/boot/src/main.rs b/boot/src/main.rs\nsimilarity index 100%\nrename from src/boot/src/main.rs\nrename to boot/src/main.rs\ndiff --git a/src/build.rs b/build.rs\nsimilarity index 100%\nrename from src/build.rs\nrename to build.rs\ndiff --git a/src/framework/README.md b/framework/README.md\nsimilarity index 100%\nrename from src/framework/README.md\nrename to framework/README.md\ndiff --git a/src/framework/jinux-frame/Cargo.toml b/framework/jinux-frame/Cargo.toml\nsimilarity index 94%\nrename from src/framework/jinux-frame/Cargo.toml\nrename to framework/jinux-frame/Cargo.toml\nindex 6645f749bb..025c188339 100644\n--- a/src/framework/jinux-frame/Cargo.toml\n+++ b/framework/jinux-frame/Cargo.toml\n@@ -12,7 +12,7 @@ spin = \"0.9.4\"\n volatile = { version = \"0.4.5\", features = [\"unstable\"] }\n buddy_system_allocator = \"0.9.0\"\n pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"7fa2ed2\" }\n-align_ext = { path = \"../align_ext\" }\n+align_ext = { path = \"../libs/align_ext\" }\n intrusive-collections = \"0.9.5\"\n log = \"0.4\"\n lazy_static = { version = \"1.0\", features = [\"spin_no_std\"] }\ndiff --git a/src/framework/jinux-frame/src/arch/mod.rs b/framework/jinux-frame/src/arch/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/mod.rs\nrename to framework/jinux-frame/src/arch/mod.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/boot/limine.rs b/framework/jinux-frame/src/arch/x86/boot/limine.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/boot/limine.rs\nrename to framework/jinux-frame/src/arch/x86/boot/limine.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/boot/mod.rs b/framework/jinux-frame/src/arch/x86/boot/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/boot/mod.rs\nrename to framework/jinux-frame/src/arch/x86/boot/mod.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/cpu.rs b/framework/jinux-frame/src/arch/x86/cpu.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/cpu.rs\nrename to framework/jinux-frame/src/arch/x86/cpu.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/device/cmos.rs b/framework/jinux-frame/src/arch/x86/device/cmos.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/device/cmos.rs\nrename to framework/jinux-frame/src/arch/x86/device/cmos.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/device/io_port.rs b/framework/jinux-frame/src/arch/x86/device/io_port.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/device/io_port.rs\nrename to framework/jinux-frame/src/arch/x86/device/io_port.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/device/mod.rs b/framework/jinux-frame/src/arch/x86/device/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/device/mod.rs\nrename to framework/jinux-frame/src/arch/x86/device/mod.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/device/pci.rs b/framework/jinux-frame/src/arch/x86/device/pci.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/device/pci.rs\nrename to framework/jinux-frame/src/arch/x86/device/pci.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/device/serial.rs b/framework/jinux-frame/src/arch/x86/device/serial.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/device/serial.rs\nrename to framework/jinux-frame/src/arch/x86/device/serial.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/irq.rs b/framework/jinux-frame/src/arch/x86/irq.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/irq.rs\nrename to framework/jinux-frame/src/arch/x86/irq.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/kernel/acpi.rs b/framework/jinux-frame/src/arch/x86/kernel/acpi.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/kernel/acpi.rs\nrename to framework/jinux-frame/src/arch/x86/kernel/acpi.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/kernel/ioapic.rs b/framework/jinux-frame/src/arch/x86/kernel/ioapic.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/kernel/ioapic.rs\nrename to framework/jinux-frame/src/arch/x86/kernel/ioapic.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/kernel/mod.rs b/framework/jinux-frame/src/arch/x86/kernel/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/kernel/mod.rs\nrename to framework/jinux-frame/src/arch/x86/kernel/mod.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/kernel/pic.rs b/framework/jinux-frame/src/arch/x86/kernel/pic.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/kernel/pic.rs\nrename to framework/jinux-frame/src/arch/x86/kernel/pic.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/kernel/xapic.rs b/framework/jinux-frame/src/arch/x86/kernel/xapic.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/kernel/xapic.rs\nrename to framework/jinux-frame/src/arch/x86/kernel/xapic.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/mm/mod.rs b/framework/jinux-frame/src/arch/x86/mm/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/mm/mod.rs\nrename to framework/jinux-frame/src/arch/x86/mm/mod.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/mod.rs b/framework/jinux-frame/src/arch/x86/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/mod.rs\nrename to framework/jinux-frame/src/arch/x86/mod.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/timer/apic.rs b/framework/jinux-frame/src/arch/x86/timer/apic.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/timer/apic.rs\nrename to framework/jinux-frame/src/arch/x86/timer/apic.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/timer/hpet.rs b/framework/jinux-frame/src/arch/x86/timer/hpet.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/timer/hpet.rs\nrename to framework/jinux-frame/src/arch/x86/timer/hpet.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/timer/mod.rs b/framework/jinux-frame/src/arch/x86/timer/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/timer/mod.rs\nrename to framework/jinux-frame/src/arch/x86/timer/mod.rs\ndiff --git a/src/framework/jinux-frame/src/arch/x86/timer/pit.rs b/framework/jinux-frame/src/arch/x86/timer/pit.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/arch/x86/timer/pit.rs\nrename to framework/jinux-frame/src/arch/x86/timer/pit.rs\ndiff --git a/src/framework/jinux-frame/src/config.rs b/framework/jinux-frame/src/config.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/config.rs\nrename to framework/jinux-frame/src/config.rs\ndiff --git a/src/framework/jinux-frame/src/cpu.rs b/framework/jinux-frame/src/cpu.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/cpu.rs\nrename to framework/jinux-frame/src/cpu.rs\ndiff --git a/src/framework/jinux-frame/src/error.rs b/framework/jinux-frame/src/error.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/error.rs\nrename to framework/jinux-frame/src/error.rs\ndiff --git a/src/framework/jinux-frame/src/lib.rs b/framework/jinux-frame/src/lib.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/lib.rs\nrename to framework/jinux-frame/src/lib.rs\ndiff --git a/src/framework/jinux-frame/src/logger.rs b/framework/jinux-frame/src/logger.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/logger.rs\nrename to framework/jinux-frame/src/logger.rs\ndiff --git a/src/framework/jinux-frame/src/prelude.rs b/framework/jinux-frame/src/prelude.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/prelude.rs\nrename to framework/jinux-frame/src/prelude.rs\ndiff --git a/src/framework/jinux-frame/src/sync/atomic_bits.rs b/framework/jinux-frame/src/sync/atomic_bits.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/sync/atomic_bits.rs\nrename to framework/jinux-frame/src/sync/atomic_bits.rs\ndiff --git a/src/framework/jinux-frame/src/sync/mod.rs b/framework/jinux-frame/src/sync/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/sync/mod.rs\nrename to framework/jinux-frame/src/sync/mod.rs\ndiff --git a/src/framework/jinux-frame/src/sync/mutex.rs b/framework/jinux-frame/src/sync/mutex.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/sync/mutex.rs\nrename to framework/jinux-frame/src/sync/mutex.rs\ndiff --git a/src/framework/jinux-frame/src/sync/rcu/mod.rs b/framework/jinux-frame/src/sync/rcu/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/sync/rcu/mod.rs\nrename to framework/jinux-frame/src/sync/rcu/mod.rs\ndiff --git a/src/framework/jinux-frame/src/sync/rcu/monitor.rs b/framework/jinux-frame/src/sync/rcu/monitor.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/sync/rcu/monitor.rs\nrename to framework/jinux-frame/src/sync/rcu/monitor.rs\ndiff --git a/src/framework/jinux-frame/src/sync/rcu/owner_ptr.rs b/framework/jinux-frame/src/sync/rcu/owner_ptr.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/sync/rcu/owner_ptr.rs\nrename to framework/jinux-frame/src/sync/rcu/owner_ptr.rs\ndiff --git a/src/framework/jinux-frame/src/sync/spin.rs b/framework/jinux-frame/src/sync/spin.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/sync/spin.rs\nrename to framework/jinux-frame/src/sync/spin.rs\ndiff --git a/src/framework/jinux-frame/src/sync/wait.rs b/framework/jinux-frame/src/sync/wait.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/sync/wait.rs\nrename to framework/jinux-frame/src/sync/wait.rs\ndiff --git a/src/framework/jinux-frame/src/task/mod.rs b/framework/jinux-frame/src/task/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/task/mod.rs\nrename to framework/jinux-frame/src/task/mod.rs\ndiff --git a/src/framework/jinux-frame/src/task/processor.rs b/framework/jinux-frame/src/task/processor.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/task/processor.rs\nrename to framework/jinux-frame/src/task/processor.rs\ndiff --git a/src/framework/jinux-frame/src/task/scheduler.rs b/framework/jinux-frame/src/task/scheduler.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/task/scheduler.rs\nrename to framework/jinux-frame/src/task/scheduler.rs\ndiff --git a/src/framework/jinux-frame/src/task/switch.S b/framework/jinux-frame/src/task/switch.S\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/task/switch.S\nrename to framework/jinux-frame/src/task/switch.S\ndiff --git a/src/framework/jinux-frame/src/task/task.rs b/framework/jinux-frame/src/task/task.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/task/task.rs\nrename to framework/jinux-frame/src/task/task.rs\ndiff --git a/src/framework/jinux-frame/src/timer.rs b/framework/jinux-frame/src/timer.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/timer.rs\nrename to framework/jinux-frame/src/timer.rs\ndiff --git a/src/framework/jinux-frame/src/trap/handler.rs b/framework/jinux-frame/src/trap/handler.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/trap/handler.rs\nrename to framework/jinux-frame/src/trap/handler.rs\ndiff --git a/src/framework/jinux-frame/src/trap/irq.rs b/framework/jinux-frame/src/trap/irq.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/trap/irq.rs\nrename to framework/jinux-frame/src/trap/irq.rs\ndiff --git a/src/framework/jinux-frame/src/trap/mod.rs b/framework/jinux-frame/src/trap/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/trap/mod.rs\nrename to framework/jinux-frame/src/trap/mod.rs\ndiff --git a/src/framework/jinux-frame/src/user.rs b/framework/jinux-frame/src/user.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/user.rs\nrename to framework/jinux-frame/src/user.rs\ndiff --git a/src/framework/jinux-frame/src/util/mod.rs b/framework/jinux-frame/src/util/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/util/mod.rs\nrename to framework/jinux-frame/src/util/mod.rs\ndiff --git a/src/framework/jinux-frame/src/util/recycle_allocator.rs b/framework/jinux-frame/src/util/recycle_allocator.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/util/recycle_allocator.rs\nrename to framework/jinux-frame/src/util/recycle_allocator.rs\ndiff --git a/src/framework/jinux-frame/src/util/type_map.rs b/framework/jinux-frame/src/util/type_map.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/util/type_map.rs\nrename to framework/jinux-frame/src/util/type_map.rs\ndiff --git a/src/framework/jinux-frame/src/vm/frame.rs b/framework/jinux-frame/src/vm/frame.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/vm/frame.rs\nrename to framework/jinux-frame/src/vm/frame.rs\ndiff --git a/src/framework/jinux-frame/src/vm/frame_allocator.rs b/framework/jinux-frame/src/vm/frame_allocator.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/vm/frame_allocator.rs\nrename to framework/jinux-frame/src/vm/frame_allocator.rs\ndiff --git a/src/framework/jinux-frame/src/vm/heap_allocator.rs b/framework/jinux-frame/src/vm/heap_allocator.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/vm/heap_allocator.rs\nrename to framework/jinux-frame/src/vm/heap_allocator.rs\ndiff --git a/src/framework/jinux-frame/src/vm/io.rs b/framework/jinux-frame/src/vm/io.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/vm/io.rs\nrename to framework/jinux-frame/src/vm/io.rs\ndiff --git a/src/framework/jinux-frame/src/vm/memory_set.rs b/framework/jinux-frame/src/vm/memory_set.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/vm/memory_set.rs\nrename to framework/jinux-frame/src/vm/memory_set.rs\ndiff --git a/src/framework/jinux-frame/src/vm/mod.rs b/framework/jinux-frame/src/vm/mod.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/vm/mod.rs\nrename to framework/jinux-frame/src/vm/mod.rs\ndiff --git a/src/framework/jinux-frame/src/vm/offset.rs b/framework/jinux-frame/src/vm/offset.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/vm/offset.rs\nrename to framework/jinux-frame/src/vm/offset.rs\ndiff --git a/src/framework/jinux-frame/src/vm/page_table.rs b/framework/jinux-frame/src/vm/page_table.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/vm/page_table.rs\nrename to framework/jinux-frame/src/vm/page_table.rs\ndiff --git a/src/framework/jinux-frame/src/vm/space.rs b/framework/jinux-frame/src/vm/space.rs\nsimilarity index 100%\nrename from src/framework/jinux-frame/src/vm/space.rs\nrename to framework/jinux-frame/src/vm/space.rs\ndiff --git a/src/framework/align_ext/Cargo.toml b/framework/libs/align_ext/Cargo.toml\nsimilarity index 100%\nrename from src/framework/align_ext/Cargo.toml\nrename to framework/libs/align_ext/Cargo.toml\ndiff --git a/src/framework/align_ext/src/lib.rs b/framework/libs/align_ext/src/lib.rs\nsimilarity index 100%\nrename from src/framework/align_ext/src/lib.rs\nrename to framework/libs/align_ext/src/lib.rs\ndiff --git a/src/README.md b/kernel/README.md\nsimilarity index 100%\nrename from src/README.md\nrename to kernel/README.md\ndiff --git a/src/src/main.rs b/kernel/main.rs\nsimilarity index 100%\nrename from src/src/main.rs\nrename to kernel/main.rs\ndiff --git a/src/apps/bin/Makefile b/regression/apps/bin/Makefile\nsimilarity index 100%\nrename from src/apps/bin/Makefile\nrename to regression/apps/bin/Makefile\ndiff --git a/src/apps/bin/sh b/regression/apps/bin/sh\nsimilarity index 100%\nrename from src/apps/bin/sh\nrename to regression/apps/bin/sh\ndiff --git a/src/apps/busybox/README.md b/regression/apps/busybox/README.md\nsimilarity index 100%\nrename from src/apps/busybox/README.md\nrename to regression/apps/busybox/README.md\ndiff --git a/src/apps/busybox/busybox b/regression/apps/busybox/busybox\nsimilarity index 100%\nrename from src/apps/busybox/busybox\nrename to regression/apps/busybox/busybox\ndiff --git a/src/apps/execve/Makefile b/regression/apps/execve/Makefile\nsimilarity index 100%\nrename from src/apps/execve/Makefile\nrename to regression/apps/execve/Makefile\ndiff --git a/src/apps/execve/execve b/regression/apps/execve/execve\nsimilarity index 100%\nrename from src/apps/execve/execve\nrename to regression/apps/execve/execve\ndiff --git a/src/apps/execve/execve.c b/regression/apps/execve/execve.c\nsimilarity index 100%\nrename from src/apps/execve/execve.c\nrename to regression/apps/execve/execve.c\ndiff --git a/src/apps/execve/hello b/regression/apps/execve/hello\nsimilarity index 100%\nrename from src/apps/execve/hello\nrename to regression/apps/execve/hello\ndiff --git a/src/apps/execve/hello.c b/regression/apps/execve/hello.c\nsimilarity index 100%\nrename from src/apps/execve/hello.c\nrename to regression/apps/execve/hello.c\ndiff --git a/src/apps/fork/Makefile b/regression/apps/fork/Makefile\nsimilarity index 100%\nrename from src/apps/fork/Makefile\nrename to regression/apps/fork/Makefile\ndiff --git a/src/apps/fork/fork b/regression/apps/fork/fork\nsimilarity index 100%\nrename from src/apps/fork/fork\nrename to regression/apps/fork/fork\ndiff --git a/src/apps/fork/fork.s b/regression/apps/fork/fork.s\nsimilarity index 100%\nrename from src/apps/fork/fork.s\nrename to regression/apps/fork/fork.s\ndiff --git a/src/apps/fork_c/Makefile b/regression/apps/fork_c/Makefile\nsimilarity index 100%\nrename from src/apps/fork_c/Makefile\nrename to regression/apps/fork_c/Makefile\ndiff --git a/src/apps/fork_c/fork b/regression/apps/fork_c/fork\nsimilarity index 100%\nrename from src/apps/fork_c/fork\nrename to regression/apps/fork_c/fork\ndiff --git a/src/apps/fork_c/fork.c b/regression/apps/fork_c/fork.c\nsimilarity index 100%\nrename from src/apps/fork_c/fork.c\nrename to regression/apps/fork_c/fork.c\ndiff --git a/src/apps/hello_c/Makefile b/regression/apps/hello_c/Makefile\nsimilarity index 100%\nrename from src/apps/hello_c/Makefile\nrename to regression/apps/hello_c/Makefile\ndiff --git a/regression/apps/hello_c/hello b/regression/apps/hello_c/hello\nnew file mode 100755\nindex 0000000000..4db2c3de77\n--- /dev/null\n+++ b/regression/apps/hello_c/hello\n@@ -0,0 +1,3 @@\n+version https://git-lfs.github.com/spec/v1\n+oid sha256:dda5a7d6081cc2252056375d0550731ef2fd24789aa5f17da189a36bf78c588d\n+size 871896\ndiff --git a/src/apps/hello_c/hello.c b/regression/apps/hello_c/hello.c\nsimilarity index 100%\nrename from src/apps/hello_c/hello.c\nrename to regression/apps/hello_c/hello.c\ndiff --git a/src/apps/hello_pie/Makefile b/regression/apps/hello_pie/Makefile\nsimilarity index 100%\nrename from src/apps/hello_pie/Makefile\nrename to regression/apps/hello_pie/Makefile\ndiff --git a/src/apps/hello_pie/hello b/regression/apps/hello_pie/hello\nsimilarity index 100%\nrename from src/apps/hello_pie/hello\nrename to regression/apps/hello_pie/hello\ndiff --git a/src/apps/hello_pie/hello.c b/regression/apps/hello_pie/hello.c\nsimilarity index 100%\nrename from src/apps/hello_pie/hello.c\nrename to regression/apps/hello_pie/hello.c\ndiff --git a/src/apps/hello_world/Makefile b/regression/apps/hello_world/Makefile\nsimilarity index 100%\nrename from src/apps/hello_world/Makefile\nrename to regression/apps/hello_world/Makefile\ndiff --git a/src/apps/hello_world/hello_world b/regression/apps/hello_world/hello_world\nsimilarity index 100%\nrename from src/apps/hello_world/hello_world\nrename to regression/apps/hello_world/hello_world\ndiff --git a/src/apps/hello_world/hello_world.s b/regression/apps/hello_world/hello_world.s\nsimilarity index 100%\nrename from src/apps/hello_world/hello_world.s\nrename to regression/apps/hello_world/hello_world.s\ndiff --git a/src/apps/pthread/Makefile b/regression/apps/pthread/Makefile\nsimilarity index 100%\nrename from src/apps/pthread/Makefile\nrename to regression/apps/pthread/Makefile\ndiff --git a/src/apps/signal_c/Makefile b/regression/apps/signal_c/Makefile\nsimilarity index 100%\nrename from src/apps/signal_c/Makefile\nrename to regression/apps/signal_c/Makefile\ndiff --git a/src/ramdisk/Makefile b/regression/ramdisk/Makefile\nsimilarity index 100%\nrename from src/ramdisk/Makefile\nrename to regression/ramdisk/Makefile\ndiff --git a/src/ramdisk/mkinitramfs b/regression/ramdisk/mkinitramfs\nsimilarity index 100%\nrename from src/ramdisk/mkinitramfs\nrename to regression/ramdisk/mkinitramfs\ndiff --git a/src/services/comps/block/Cargo.toml b/services/comps/block/Cargo.toml\nsimilarity index 89%\nrename from src/services/comps/block/Cargo.toml\nrename to services/comps/block/Cargo.toml\nindex 41b617a920..d500b8c51e 100644\n--- a/src/services/comps/block/Cargo.toml\n+++ b/services/comps/block/Cargo.toml\n@@ -12,7 +12,7 @@ jinux-frame = { path = \"../../../framework/jinux-frame\" }\n jinux-pci = { path = \"../pci\" }\n jinux-virtio = { path = \"../virtio\" }\n jinux-util = { path = \"../../libs/jinux-util\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \n [features]\ndiff --git a/src/services/comps/block/src/lib.rs b/services/comps/block/src/lib.rs\nsimilarity index 100%\nrename from src/services/comps/block/src/lib.rs\nrename to services/comps/block/src/lib.rs\ndiff --git a/src/services/comps/block/src/virtio.rs b/services/comps/block/src/virtio.rs\nsimilarity index 100%\nrename from src/services/comps/block/src/virtio.rs\nrename to services/comps/block/src/virtio.rs\ndiff --git a/src/services/comps/framebuffer/Cargo.toml b/services/comps/framebuffer/Cargo.toml\nsimilarity index 87%\nrename from src/services/comps/framebuffer/Cargo.toml\nrename to services/comps/framebuffer/Cargo.toml\nindex c352813d79..623734d41d 100644\n--- a/src/services/comps/framebuffer/Cargo.toml\n+++ b/services/comps/framebuffer/Cargo.toml\n@@ -7,7 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n spin = \"0.9.4\"\n font8x8 = { version = \"0.2.5\", default-features = false, features = [\ndiff --git a/src/services/comps/framebuffer/src/lib.rs b/services/comps/framebuffer/src/lib.rs\nsimilarity index 100%\nrename from src/services/comps/framebuffer/src/lib.rs\nrename to services/comps/framebuffer/src/lib.rs\ndiff --git a/src/services/comps/input/Cargo.toml b/services/comps/input/Cargo.toml\nsimilarity index 90%\nrename from src/services/comps/input/Cargo.toml\nrename to services/comps/input/Cargo.toml\nindex 1753c6de02..0f0c378163 100644\n--- a/src/services/comps/input/Cargo.toml\n+++ b/services/comps/input/Cargo.toml\n@@ -12,7 +12,7 @@ jinux-frame = { path = \"../../../framework/jinux-frame\" }\n jinux-pci = { path = \"../pci\" }\n jinux-virtio = { path = \"../virtio\" }\n jinux-util = { path = \"../../libs/jinux-util\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n virtio-input-decoder = \"0.1.4\"\n log = \"0.4\"\n \ndiff --git a/src/services/comps/input/src/lib.rs b/services/comps/input/src/lib.rs\nsimilarity index 100%\nrename from src/services/comps/input/src/lib.rs\nrename to services/comps/input/src/lib.rs\ndiff --git a/src/services/comps/input/src/virtio.rs b/services/comps/input/src/virtio.rs\nsimilarity index 100%\nrename from src/services/comps/input/src/virtio.rs\nrename to services/comps/input/src/virtio.rs\ndiff --git a/src/services/comps/pci/Cargo.toml b/services/comps/pci/Cargo.toml\nsimilarity index 89%\nrename from src/services/comps/pci/Cargo.toml\nrename to services/comps/pci/Cargo.toml\nindex 15ff93b695..70bb4672b9 100644\n--- a/src/services/comps/pci/Cargo.toml\n+++ b/services/comps/pci/Cargo.toml\n@@ -11,7 +11,7 @@ spin = \"0.9.4\"\n jinux-frame = { path = \"../../../framework/jinux-frame\" }\n jinux-util = { path = \"../../libs/jinux-util\" }\n pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"7fa2ed2\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \n [dependencies.lazy_static]\ndiff --git a/src/services/comps/pci/src/capability/exp.rs b/services/comps/pci/src/capability/exp.rs\nsimilarity index 100%\nrename from src/services/comps/pci/src/capability/exp.rs\nrename to services/comps/pci/src/capability/exp.rs\ndiff --git a/src/services/comps/pci/src/capability/mod.rs b/services/comps/pci/src/capability/mod.rs\nsimilarity index 100%\nrename from src/services/comps/pci/src/capability/mod.rs\nrename to services/comps/pci/src/capability/mod.rs\ndiff --git a/src/services/comps/pci/src/capability/msi.rs b/services/comps/pci/src/capability/msi.rs\nsimilarity index 100%\nrename from src/services/comps/pci/src/capability/msi.rs\nrename to services/comps/pci/src/capability/msi.rs\ndiff --git a/src/services/comps/pci/src/capability/msix.rs b/services/comps/pci/src/capability/msix.rs\nsimilarity index 100%\nrename from src/services/comps/pci/src/capability/msix.rs\nrename to services/comps/pci/src/capability/msix.rs\ndiff --git a/src/services/comps/pci/src/capability/pm.rs b/services/comps/pci/src/capability/pm.rs\nsimilarity index 100%\nrename from src/services/comps/pci/src/capability/pm.rs\nrename to services/comps/pci/src/capability/pm.rs\ndiff --git a/src/services/comps/pci/src/capability/sata.rs b/services/comps/pci/src/capability/sata.rs\nsimilarity index 100%\nrename from src/services/comps/pci/src/capability/sata.rs\nrename to services/comps/pci/src/capability/sata.rs\ndiff --git a/src/services/comps/pci/src/capability/vendor/mod.rs b/services/comps/pci/src/capability/vendor/mod.rs\nsimilarity index 100%\nrename from src/services/comps/pci/src/capability/vendor/mod.rs\nrename to services/comps/pci/src/capability/vendor/mod.rs\ndiff --git a/src/services/comps/pci/src/capability/vendor/virtio.rs b/services/comps/pci/src/capability/vendor/virtio.rs\nsimilarity index 100%\nrename from src/services/comps/pci/src/capability/vendor/virtio.rs\nrename to services/comps/pci/src/capability/vendor/virtio.rs\ndiff --git a/src/services/comps/pci/src/lib.rs b/services/comps/pci/src/lib.rs\nsimilarity index 100%\nrename from src/services/comps/pci/src/lib.rs\nrename to services/comps/pci/src/lib.rs\ndiff --git a/src/services/comps/pci/src/msix.rs b/services/comps/pci/src/msix.rs\nsimilarity index 100%\nrename from src/services/comps/pci/src/msix.rs\nrename to services/comps/pci/src/msix.rs\ndiff --git a/src/services/comps/pci/src/util.rs b/services/comps/pci/src/util.rs\nsimilarity index 100%\nrename from src/services/comps/pci/src/util.rs\nrename to services/comps/pci/src/util.rs\ndiff --git a/src/services/comps/time/Cargo.toml b/services/comps/time/Cargo.toml\nsimilarity index 83%\nrename from src/services/comps/time/Cargo.toml\nrename to services/comps/time/Cargo.toml\nindex 24cc2b9d03..9bd5822a62 100644\n--- a/src/services/comps/time/Cargo.toml\n+++ b/services/comps/time/Cargo.toml\n@@ -7,7 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n spin = \"0.9.4\"\n \ndiff --git a/src/services/comps/time/src/lib.rs b/services/comps/time/src/lib.rs\nsimilarity index 100%\nrename from src/services/comps/time/src/lib.rs\nrename to services/comps/time/src/lib.rs\ndiff --git a/src/services/comps/time/src/rtc.rs b/services/comps/time/src/rtc.rs\nsimilarity index 100%\nrename from src/services/comps/time/src/rtc.rs\nrename to services/comps/time/src/rtc.rs\ndiff --git a/src/services/comps/virtio/Cargo.toml b/services/comps/virtio/Cargo.toml\nsimilarity index 89%\nrename from src/services/comps/virtio/Cargo.toml\nrename to services/comps/virtio/Cargo.toml\nindex e694302688..11546d5014 100644\n--- a/src/services/comps/virtio/Cargo.toml\n+++ b/services/comps/virtio/Cargo.toml\n@@ -12,7 +12,7 @@ jinux-frame = { path = \"../../../framework/jinux-frame\" }\n jinux-pci = { path = \"../pci\" }\n jinux-util = { path = \"../../libs/jinux-util\" }\n pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"7fa2ed2\" }\n-component = { path = \"../../comp-sys/component\" }\n+component = { path = \"../../libs/comp-sys/component\" }\n log = \"0.4\"\n \n [features]\ndiff --git a/src/services/comps/virtio/src/device/block/device.rs b/services/comps/virtio/src/device/block/device.rs\nsimilarity index 100%\nrename from src/services/comps/virtio/src/device/block/device.rs\nrename to services/comps/virtio/src/device/block/device.rs\ndiff --git a/src/services/comps/virtio/src/device/block/mod.rs b/services/comps/virtio/src/device/block/mod.rs\nsimilarity index 100%\nrename from src/services/comps/virtio/src/device/block/mod.rs\nrename to services/comps/virtio/src/device/block/mod.rs\ndiff --git a/src/services/comps/virtio/src/device/input/device.rs b/services/comps/virtio/src/device/input/device.rs\nsimilarity index 100%\nrename from src/services/comps/virtio/src/device/input/device.rs\nrename to services/comps/virtio/src/device/input/device.rs\ndiff --git a/src/services/comps/virtio/src/device/input/mod.rs b/services/comps/virtio/src/device/input/mod.rs\nsimilarity index 100%\nrename from src/services/comps/virtio/src/device/input/mod.rs\nrename to services/comps/virtio/src/device/input/mod.rs\ndiff --git a/src/services/comps/virtio/src/device/mod.rs b/services/comps/virtio/src/device/mod.rs\nsimilarity index 100%\nrename from src/services/comps/virtio/src/device/mod.rs\nrename to services/comps/virtio/src/device/mod.rs\ndiff --git a/src/services/comps/virtio/src/lib.rs b/services/comps/virtio/src/lib.rs\nsimilarity index 100%\nrename from src/services/comps/virtio/src/lib.rs\nrename to services/comps/virtio/src/lib.rs\ndiff --git a/src/services/comps/virtio/src/queue.rs b/services/comps/virtio/src/queue.rs\nsimilarity index 100%\nrename from src/services/comps/virtio/src/queue.rs\nrename to services/comps/virtio/src/queue.rs\ndiff --git a/src/services/comp-sys/cargo-component/.gitignore b/services/libs/comp-sys/cargo-component/.gitignore\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/.gitignore\nrename to services/libs/comp-sys/cargo-component/.gitignore\ndiff --git a/src/services/comp-sys/cargo-component/Cargo.lock b/services/libs/comp-sys/cargo-component/Cargo.lock\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/Cargo.lock\nrename to services/libs/comp-sys/cargo-component/Cargo.lock\ndiff --git a/src/services/comp-sys/cargo-component/Cargo.toml b/services/libs/comp-sys/cargo-component/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/README.md b/services/libs/comp-sys/cargo-component/README.md\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/README.md\nrename to services/libs/comp-sys/cargo-component/README.md\ndiff --git a/src/services/comp-sys/cargo-component/analysis/Cargo.toml b/services/libs/comp-sys/cargo-component/analysis/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/analysis/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/analysis/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/analysis/src/conf.rs b/services/libs/comp-sys/cargo-component/analysis/src/conf.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/analysis/src/conf.rs\nrename to services/libs/comp-sys/cargo-component/analysis/src/conf.rs\ndiff --git a/src/services/comp-sys/cargo-component/analysis/src/lib.rs b/services/libs/comp-sys/cargo-component/analysis/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/analysis/src/lib.rs\nrename to services/libs/comp-sys/cargo-component/analysis/src/lib.rs\ndiff --git a/src/services/comp-sys/cargo-component/build.rs b/services/libs/comp-sys/cargo-component/build.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/build.rs\nrename to services/libs/comp-sys/cargo-component/build.rs\ndiff --git a/src/services/comp-sys/cargo-component/rust-toolchain.toml b/services/libs/comp-sys/cargo-component/rust-toolchain.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/rust-toolchain.toml\nrename to services/libs/comp-sys/cargo-component/rust-toolchain.toml\ndiff --git a/src/services/comp-sys/cargo-component/src/driver.rs b/services/libs/comp-sys/cargo-component/src/driver.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/src/driver.rs\nrename to services/libs/comp-sys/cargo-component/src/driver.rs\ndiff --git a/src/services/comp-sys/cargo-component/src/main.rs b/services/libs/comp-sys/cargo-component/src/main.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/src/main.rs\nrename to services/libs/comp-sys/cargo-component/src/main.rs\ndiff --git a/src/services/comp-sys/component-macro/Cargo.toml b/services/libs/comp-sys/component-macro/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/component-macro/Cargo.toml\nrename to services/libs/comp-sys/component-macro/Cargo.toml\ndiff --git a/src/services/comp-sys/component-macro/src/init_comp.rs b/services/libs/comp-sys/component-macro/src/init_comp.rs\nsimilarity index 100%\nrename from src/services/comp-sys/component-macro/src/init_comp.rs\nrename to services/libs/comp-sys/component-macro/src/init_comp.rs\ndiff --git a/src/services/comp-sys/component-macro/src/lib.rs b/services/libs/comp-sys/component-macro/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/component-macro/src/lib.rs\nrename to services/libs/comp-sys/component-macro/src/lib.rs\ndiff --git a/src/services/comp-sys/component-macro/src/priority.rs b/services/libs/comp-sys/component-macro/src/priority.rs\nsimilarity index 100%\nrename from src/services/comp-sys/component-macro/src/priority.rs\nrename to services/libs/comp-sys/component-macro/src/priority.rs\ndiff --git a/src/services/comp-sys/component/Cargo.toml b/services/libs/comp-sys/component/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/component/Cargo.toml\nrename to services/libs/comp-sys/component/Cargo.toml\ndiff --git a/src/services/comp-sys/component/README.md b/services/libs/comp-sys/component/README.md\nsimilarity index 100%\nrename from src/services/comp-sys/component/README.md\nrename to services/libs/comp-sys/component/README.md\ndiff --git a/src/services/comp-sys/component/src/lib.rs b/services/libs/comp-sys/component/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/component/src/lib.rs\nrename to services/libs/comp-sys/component/src/lib.rs\ndiff --git a/src/services/comp-sys/controlled/Cargo.toml b/services/libs/comp-sys/controlled/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/controlled/Cargo.toml\nrename to services/libs/comp-sys/controlled/Cargo.toml\ndiff --git a/src/services/comp-sys/controlled/src/lib.rs b/services/libs/comp-sys/controlled/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/controlled/src/lib.rs\nrename to services/libs/comp-sys/controlled/src/lib.rs\ndiff --git a/src/services/libs/cpio-decoder/Cargo.toml b/services/libs/cpio-decoder/Cargo.toml\nsimilarity index 100%\nrename from src/services/libs/cpio-decoder/Cargo.toml\nrename to services/libs/cpio-decoder/Cargo.toml\ndiff --git a/src/services/libs/cpio-decoder/src/error.rs b/services/libs/cpio-decoder/src/error.rs\nsimilarity index 100%\nrename from src/services/libs/cpio-decoder/src/error.rs\nrename to services/libs/cpio-decoder/src/error.rs\ndiff --git a/src/services/libs/cpio-decoder/src/lib.rs b/services/libs/cpio-decoder/src/lib.rs\nsimilarity index 100%\nrename from src/services/libs/cpio-decoder/src/lib.rs\nrename to services/libs/cpio-decoder/src/lib.rs\ndiff --git a/src/services/libs/jinux-rights-proc/Cargo.toml b/services/libs/jinux-rights-proc/Cargo.toml\nsimilarity index 100%\nrename from src/services/libs/jinux-rights-proc/Cargo.toml\nrename to services/libs/jinux-rights-proc/Cargo.toml\ndiff --git a/src/services/libs/jinux-rights-proc/src/lib.rs b/services/libs/jinux-rights-proc/src/lib.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-rights-proc/src/lib.rs\nrename to services/libs/jinux-rights-proc/src/lib.rs\ndiff --git a/src/services/libs/jinux-rights-proc/src/require_attr.rs b/services/libs/jinux-rights-proc/src/require_attr.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-rights-proc/src/require_attr.rs\nrename to services/libs/jinux-rights-proc/src/require_attr.rs\ndiff --git a/src/services/libs/jinux-std/Cargo.toml b/services/libs/jinux-std/Cargo.toml\nsimilarity index 91%\nrename from src/services/libs/jinux-std/Cargo.toml\nrename to services/libs/jinux-std/Cargo.toml\nindex 52b2861569..06d3a2fa54 100644\n--- a/src/services/libs/jinux-std/Cargo.toml\n+++ b/services/libs/jinux-std/Cargo.toml\n@@ -7,12 +7,12 @@ edition = \"2021\"\n \n [dependencies]\n jinux-frame = { path = \"../../../framework/jinux-frame\" }\n-align_ext = { path = \"../../../framework/align_ext\" }\n+align_ext = { path = \"../../../framework/libs/align_ext\" }\n pod = { git = \"https://github.com/jinzhao-dev/pod\", rev = \"7fa2ed2\" }\n jinux-input = { path = \"../../comps/input\" }\n jinux-block = { path = \"../../comps/block\" }\n jinux-time = { path = \"../../comps/time\" }\n-controlled = { path = \"../../comp-sys/controlled\" }\n+controlled = { path = \"../../libs/comp-sys/controlled\" }\n typeflags = { path = \"../typeflags\" }\n typeflags-util = { path = \"../typeflags-util\" }\n jinux-rights-proc = { path = \"../jinux-rights-proc\" }\ndiff --git a/src/services/libs/jinux-std/src/driver/mod.rs b/services/libs/jinux-std/src/driver/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/driver/mod.rs\nrename to services/libs/jinux-std/src/driver/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/driver/tty.rs b/services/libs/jinux-std/src/driver/tty.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/driver/tty.rs\nrename to services/libs/jinux-std/src/driver/tty.rs\ndiff --git a/src/services/libs/jinux-std/src/error.rs b/services/libs/jinux-std/src/error.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/error.rs\nrename to services/libs/jinux-std/src/error.rs\ndiff --git a/src/services/libs/jinux-std/src/events/events.rs b/services/libs/jinux-std/src/events/events.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/events/events.rs\nrename to services/libs/jinux-std/src/events/events.rs\ndiff --git a/src/services/libs/jinux-std/src/events/mod.rs b/services/libs/jinux-std/src/events/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/events/mod.rs\nrename to services/libs/jinux-std/src/events/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/events/observer.rs b/services/libs/jinux-std/src/events/observer.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/events/observer.rs\nrename to services/libs/jinux-std/src/events/observer.rs\ndiff --git a/src/services/libs/jinux-std/src/events/subject.rs b/services/libs/jinux-std/src/events/subject.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/events/subject.rs\nrename to services/libs/jinux-std/src/events/subject.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/file_handle/file.rs b/services/libs/jinux-std/src/fs/file_handle/file.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/file_handle/file.rs\nrename to services/libs/jinux-std/src/fs/file_handle/file.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs b/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs\nrename to services/libs/jinux-std/src/fs/file_handle/inode_handle/dyn_cap.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/file_handle/inode_handle/mod.rs b/services/libs/jinux-std/src/fs/file_handle/inode_handle/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/file_handle/inode_handle/mod.rs\nrename to services/libs/jinux-std/src/fs/file_handle/inode_handle/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/file_handle/inode_handle/static_cap.rs b/services/libs/jinux-std/src/fs/file_handle/inode_handle/static_cap.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/file_handle/inode_handle/static_cap.rs\nrename to services/libs/jinux-std/src/fs/file_handle/inode_handle/static_cap.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/file_handle/mod.rs b/services/libs/jinux-std/src/fs/file_handle/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/file_handle/mod.rs\nrename to services/libs/jinux-std/src/fs/file_handle/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/file_table.rs b/services/libs/jinux-std/src/fs/file_table.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/file_table.rs\nrename to services/libs/jinux-std/src/fs/file_table.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/fs_resolver.rs b/services/libs/jinux-std/src/fs/fs_resolver.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/fs_resolver.rs\nrename to services/libs/jinux-std/src/fs/fs_resolver.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/initramfs.rs b/services/libs/jinux-std/src/fs/initramfs.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/initramfs.rs\nrename to services/libs/jinux-std/src/fs/initramfs.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/mod.rs b/services/libs/jinux-std/src/fs/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/mod.rs\nrename to services/libs/jinux-std/src/fs/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/procfs/mod.rs b/services/libs/jinux-std/src/fs/procfs/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/procfs/mod.rs\nrename to services/libs/jinux-std/src/fs/procfs/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/procfs/pid/comm.rs b/services/libs/jinux-std/src/fs/procfs/pid/comm.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/procfs/pid/comm.rs\nrename to services/libs/jinux-std/src/fs/procfs/pid/comm.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/procfs/pid/exe.rs b/services/libs/jinux-std/src/fs/procfs/pid/exe.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/procfs/pid/exe.rs\nrename to services/libs/jinux-std/src/fs/procfs/pid/exe.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/procfs/pid/fd.rs b/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/procfs/pid/fd.rs\nrename to services/libs/jinux-std/src/fs/procfs/pid/fd.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/procfs/pid/mod.rs b/services/libs/jinux-std/src/fs/procfs/pid/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/procfs/pid/mod.rs\nrename to services/libs/jinux-std/src/fs/procfs/pid/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/procfs/self_.rs b/services/libs/jinux-std/src/fs/procfs/self_.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/procfs/self_.rs\nrename to services/libs/jinux-std/src/fs/procfs/self_.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/procfs/template/builder.rs b/services/libs/jinux-std/src/fs/procfs/template/builder.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/procfs/template/builder.rs\nrename to services/libs/jinux-std/src/fs/procfs/template/builder.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/procfs/template/dir.rs b/services/libs/jinux-std/src/fs/procfs/template/dir.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/procfs/template/dir.rs\nrename to services/libs/jinux-std/src/fs/procfs/template/dir.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/procfs/template/file.rs b/services/libs/jinux-std/src/fs/procfs/template/file.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/procfs/template/file.rs\nrename to services/libs/jinux-std/src/fs/procfs/template/file.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/procfs/template/mod.rs b/services/libs/jinux-std/src/fs/procfs/template/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/procfs/template/mod.rs\nrename to services/libs/jinux-std/src/fs/procfs/template/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/procfs/template/sym.rs b/services/libs/jinux-std/src/fs/procfs/template/sym.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/procfs/template/sym.rs\nrename to services/libs/jinux-std/src/fs/procfs/template/sym.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/ramfs/fs.rs b/services/libs/jinux-std/src/fs/ramfs/fs.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/ramfs/fs.rs\nrename to services/libs/jinux-std/src/fs/ramfs/fs.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/ramfs/mod.rs b/services/libs/jinux-std/src/fs/ramfs/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/ramfs/mod.rs\nrename to services/libs/jinux-std/src/fs/ramfs/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/stdio.rs b/services/libs/jinux-std/src/fs/stdio.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/stdio.rs\nrename to services/libs/jinux-std/src/fs/stdio.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/access_mode.rs b/services/libs/jinux-std/src/fs/utils/access_mode.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/access_mode.rs\nrename to services/libs/jinux-std/src/fs/utils/access_mode.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/creation_flags.rs b/services/libs/jinux-std/src/fs/utils/creation_flags.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/creation_flags.rs\nrename to services/libs/jinux-std/src/fs/utils/creation_flags.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/dentry_cache.rs b/services/libs/jinux-std/src/fs/utils/dentry_cache.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/dentry_cache.rs\nrename to services/libs/jinux-std/src/fs/utils/dentry_cache.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/dirent_visitor.rs b/services/libs/jinux-std/src/fs/utils/dirent_visitor.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/dirent_visitor.rs\nrename to services/libs/jinux-std/src/fs/utils/dirent_visitor.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/direntry_vec.rs b/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/direntry_vec.rs\nrename to services/libs/jinux-std/src/fs/utils/direntry_vec.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/fcntl.rs b/services/libs/jinux-std/src/fs/utils/fcntl.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/fcntl.rs\nrename to services/libs/jinux-std/src/fs/utils/fcntl.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/file_creation_mask.rs b/services/libs/jinux-std/src/fs/utils/file_creation_mask.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/file_creation_mask.rs\nrename to services/libs/jinux-std/src/fs/utils/file_creation_mask.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/fs.rs b/services/libs/jinux-std/src/fs/utils/fs.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/fs.rs\nrename to services/libs/jinux-std/src/fs/utils/fs.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/inode.rs b/services/libs/jinux-std/src/fs/utils/inode.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/inode.rs\nrename to services/libs/jinux-std/src/fs/utils/inode.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/io_events.rs b/services/libs/jinux-std/src/fs/utils/io_events.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/io_events.rs\nrename to services/libs/jinux-std/src/fs/utils/io_events.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/ioctl.rs b/services/libs/jinux-std/src/fs/utils/ioctl.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/ioctl.rs\nrename to services/libs/jinux-std/src/fs/utils/ioctl.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/mod.rs b/services/libs/jinux-std/src/fs/utils/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/mod.rs\nrename to services/libs/jinux-std/src/fs/utils/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/page_cache.rs b/services/libs/jinux-std/src/fs/utils/page_cache.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/page_cache.rs\nrename to services/libs/jinux-std/src/fs/utils/page_cache.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/poll.rs b/services/libs/jinux-std/src/fs/utils/poll.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/poll.rs\nrename to services/libs/jinux-std/src/fs/utils/poll.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/status_flags.rs b/services/libs/jinux-std/src/fs/utils/status_flags.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/status_flags.rs\nrename to services/libs/jinux-std/src/fs/utils/status_flags.rs\ndiff --git a/src/services/libs/jinux-std/src/fs/utils/vnode.rs b/services/libs/jinux-std/src/fs/utils/vnode.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/fs/utils/vnode.rs\nrename to services/libs/jinux-std/src/fs/utils/vnode.rs\ndiff --git a/src/services/libs/jinux-std/src/lib.rs b/services/libs/jinux-std/src/lib.rs\nsimilarity index 97%\nrename from src/services/libs/jinux-std/src/lib.rs\nrename to services/libs/jinux-std/src/lib.rs\nindex 8338214ef7..905cdd18e8 100644\n--- a/src/services/libs/jinux-std/src/lib.rs\n+++ b/services/libs/jinux-std/src/lib.rs\n@@ -79,7 +79,7 @@ fn init_thread() {\n }\n \n fn read_ramdisk_content() -> &'static [u8] {\n-    include_bytes!(\"../../../../ramdisk/build/ramdisk.cpio\")\n+    include_bytes!(\"../../../../regression/ramdisk/build/ramdisk.cpio\")\n }\n \n /// first process never return\ndiff --git a/src/services/libs/jinux-std/src/prelude.rs b/services/libs/jinux-std/src/prelude.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/prelude.rs\nrename to services/libs/jinux-std/src/prelude.rs\ndiff --git a/src/services/libs/jinux-std/src/process/clone.rs b/services/libs/jinux-std/src/process/clone.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/clone.rs\nrename to services/libs/jinux-std/src/process/clone.rs\ndiff --git a/src/services/libs/jinux-std/src/process/fifo_scheduler.rs b/services/libs/jinux-std/src/process/fifo_scheduler.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/fifo_scheduler.rs\nrename to services/libs/jinux-std/src/process/fifo_scheduler.rs\ndiff --git a/src/services/libs/jinux-std/src/process/mod.rs b/services/libs/jinux-std/src/process/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/mod.rs\nrename to services/libs/jinux-std/src/process/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/process/posix_thread/builder.rs b/services/libs/jinux-std/src/process/posix_thread/builder.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/posix_thread/builder.rs\nrename to services/libs/jinux-std/src/process/posix_thread/builder.rs\ndiff --git a/src/services/libs/jinux-std/src/process/posix_thread/futex.rs b/services/libs/jinux-std/src/process/posix_thread/futex.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/posix_thread/futex.rs\nrename to services/libs/jinux-std/src/process/posix_thread/futex.rs\ndiff --git a/src/services/libs/jinux-std/src/process/posix_thread/mod.rs b/services/libs/jinux-std/src/process/posix_thread/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/posix_thread/mod.rs\nrename to services/libs/jinux-std/src/process/posix_thread/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/process/posix_thread/name.rs b/services/libs/jinux-std/src/process/posix_thread/name.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/posix_thread/name.rs\nrename to services/libs/jinux-std/src/process/posix_thread/name.rs\ndiff --git a/src/services/libs/jinux-std/src/process/posix_thread/posix_thread_ext.rs b/services/libs/jinux-std/src/process/posix_thread/posix_thread_ext.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/posix_thread/posix_thread_ext.rs\nrename to services/libs/jinux-std/src/process/posix_thread/posix_thread_ext.rs\ndiff --git a/src/services/libs/jinux-std/src/process/posix_thread/robust_list.rs b/services/libs/jinux-std/src/process/posix_thread/robust_list.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/posix_thread/robust_list.rs\nrename to services/libs/jinux-std/src/process/posix_thread/robust_list.rs\ndiff --git a/src/services/libs/jinux-std/src/process/process_filter.rs b/services/libs/jinux-std/src/process/process_filter.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/process_filter.rs\nrename to services/libs/jinux-std/src/process/process_filter.rs\ndiff --git a/src/services/libs/jinux-std/src/process/process_group.rs b/services/libs/jinux-std/src/process/process_group.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/process_group.rs\nrename to services/libs/jinux-std/src/process/process_group.rs\ndiff --git a/src/services/libs/jinux-std/src/process/process_table.rs b/services/libs/jinux-std/src/process/process_table.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/process_table.rs\nrename to services/libs/jinux-std/src/process/process_table.rs\ndiff --git a/src/services/libs/jinux-std/src/process/process_vm/mmap_flags.rs b/services/libs/jinux-std/src/process/process_vm/mmap_flags.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/process_vm/mmap_flags.rs\nrename to services/libs/jinux-std/src/process/process_vm/mmap_flags.rs\ndiff --git a/src/services/libs/jinux-std/src/process/process_vm/mod.rs b/services/libs/jinux-std/src/process/process_vm/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/process_vm/mod.rs\nrename to services/libs/jinux-std/src/process/process_vm/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/process/process_vm/user_heap.rs b/services/libs/jinux-std/src/process/process_vm/user_heap.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/process_vm/user_heap.rs\nrename to services/libs/jinux-std/src/process/process_vm/user_heap.rs\ndiff --git a/src/services/libs/jinux-std/src/process/program_loader/elf/aux_vec.rs b/services/libs/jinux-std/src/process/program_loader/elf/aux_vec.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/program_loader/elf/aux_vec.rs\nrename to services/libs/jinux-std/src/process/program_loader/elf/aux_vec.rs\ndiff --git a/src/services/libs/jinux-std/src/process/program_loader/elf/elf_file.rs b/services/libs/jinux-std/src/process/program_loader/elf/elf_file.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/program_loader/elf/elf_file.rs\nrename to services/libs/jinux-std/src/process/program_loader/elf/elf_file.rs\ndiff --git a/src/services/libs/jinux-std/src/process/program_loader/elf/init_stack.rs b/services/libs/jinux-std/src/process/program_loader/elf/init_stack.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/program_loader/elf/init_stack.rs\nrename to services/libs/jinux-std/src/process/program_loader/elf/init_stack.rs\ndiff --git a/src/services/libs/jinux-std/src/process/program_loader/elf/load_elf.rs b/services/libs/jinux-std/src/process/program_loader/elf/load_elf.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/program_loader/elf/load_elf.rs\nrename to services/libs/jinux-std/src/process/program_loader/elf/load_elf.rs\ndiff --git a/src/services/libs/jinux-std/src/process/program_loader/elf/mod.rs b/services/libs/jinux-std/src/process/program_loader/elf/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/program_loader/elf/mod.rs\nrename to services/libs/jinux-std/src/process/program_loader/elf/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/process/program_loader/mod.rs b/services/libs/jinux-std/src/process/program_loader/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/program_loader/mod.rs\nrename to services/libs/jinux-std/src/process/program_loader/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/process/program_loader/shebang.rs b/services/libs/jinux-std/src/process/program_loader/shebang.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/program_loader/shebang.rs\nrename to services/libs/jinux-std/src/process/program_loader/shebang.rs\ndiff --git a/src/services/libs/jinux-std/src/process/rlimit.rs b/services/libs/jinux-std/src/process/rlimit.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/rlimit.rs\nrename to services/libs/jinux-std/src/process/rlimit.rs\ndiff --git a/src/services/libs/jinux-std/src/process/signal/c_types.rs b/services/libs/jinux-std/src/process/signal/c_types.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/signal/c_types.rs\nrename to services/libs/jinux-std/src/process/signal/c_types.rs\ndiff --git a/src/services/libs/jinux-std/src/process/signal/constants.rs b/services/libs/jinux-std/src/process/signal/constants.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/signal/constants.rs\nrename to services/libs/jinux-std/src/process/signal/constants.rs\ndiff --git a/src/services/libs/jinux-std/src/process/signal/mod.rs b/services/libs/jinux-std/src/process/signal/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/signal/mod.rs\nrename to services/libs/jinux-std/src/process/signal/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/process/signal/sig_action.rs b/services/libs/jinux-std/src/process/signal/sig_action.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/signal/sig_action.rs\nrename to services/libs/jinux-std/src/process/signal/sig_action.rs\ndiff --git a/src/services/libs/jinux-std/src/process/signal/sig_disposition.rs b/services/libs/jinux-std/src/process/signal/sig_disposition.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/signal/sig_disposition.rs\nrename to services/libs/jinux-std/src/process/signal/sig_disposition.rs\ndiff --git a/src/services/libs/jinux-std/src/process/signal/sig_mask.rs b/services/libs/jinux-std/src/process/signal/sig_mask.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/signal/sig_mask.rs\nrename to services/libs/jinux-std/src/process/signal/sig_mask.rs\ndiff --git a/src/services/libs/jinux-std/src/process/signal/sig_num.rs b/services/libs/jinux-std/src/process/signal/sig_num.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/signal/sig_num.rs\nrename to services/libs/jinux-std/src/process/signal/sig_num.rs\ndiff --git a/src/services/libs/jinux-std/src/process/signal/sig_queues.rs b/services/libs/jinux-std/src/process/signal/sig_queues.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/signal/sig_queues.rs\nrename to services/libs/jinux-std/src/process/signal/sig_queues.rs\ndiff --git a/src/services/libs/jinux-std/src/process/signal/signals/fault.rs b/services/libs/jinux-std/src/process/signal/signals/fault.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/signal/signals/fault.rs\nrename to services/libs/jinux-std/src/process/signal/signals/fault.rs\ndiff --git a/src/services/libs/jinux-std/src/process/signal/signals/kernel.rs b/services/libs/jinux-std/src/process/signal/signals/kernel.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/signal/signals/kernel.rs\nrename to services/libs/jinux-std/src/process/signal/signals/kernel.rs\ndiff --git a/src/services/libs/jinux-std/src/process/signal/signals/mod.rs b/services/libs/jinux-std/src/process/signal/signals/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/signal/signals/mod.rs\nrename to services/libs/jinux-std/src/process/signal/signals/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/process/signal/signals/user.rs b/services/libs/jinux-std/src/process/signal/signals/user.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/signal/signals/user.rs\nrename to services/libs/jinux-std/src/process/signal/signals/user.rs\ndiff --git a/src/services/libs/jinux-std/src/process/status.rs b/services/libs/jinux-std/src/process/status.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/status.rs\nrename to services/libs/jinux-std/src/process/status.rs\ndiff --git a/src/services/libs/jinux-std/src/process/wait.rs b/services/libs/jinux-std/src/process/wait.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/process/wait.rs\nrename to services/libs/jinux-std/src/process/wait.rs\ndiff --git a/src/services/libs/jinux-std/src/rights.rs b/services/libs/jinux-std/src/rights.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/rights.rs\nrename to services/libs/jinux-std/src/rights.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/access.rs b/services/libs/jinux-std/src/syscall/access.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/access.rs\nrename to services/libs/jinux-std/src/syscall/access.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/arch_prctl.rs b/services/libs/jinux-std/src/syscall/arch_prctl.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/arch_prctl.rs\nrename to services/libs/jinux-std/src/syscall/arch_prctl.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/brk.rs b/services/libs/jinux-std/src/syscall/brk.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/brk.rs\nrename to services/libs/jinux-std/src/syscall/brk.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/chdir.rs b/services/libs/jinux-std/src/syscall/chdir.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/chdir.rs\nrename to services/libs/jinux-std/src/syscall/chdir.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/clock_nanosleep.rs b/services/libs/jinux-std/src/syscall/clock_nanosleep.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/clock_nanosleep.rs\nrename to services/libs/jinux-std/src/syscall/clock_nanosleep.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/clone.rs b/services/libs/jinux-std/src/syscall/clone.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/clone.rs\nrename to services/libs/jinux-std/src/syscall/clone.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/close.rs b/services/libs/jinux-std/src/syscall/close.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/close.rs\nrename to services/libs/jinux-std/src/syscall/close.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/constants.rs b/services/libs/jinux-std/src/syscall/constants.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/constants.rs\nrename to services/libs/jinux-std/src/syscall/constants.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/dup.rs b/services/libs/jinux-std/src/syscall/dup.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/dup.rs\nrename to services/libs/jinux-std/src/syscall/dup.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/execve.rs b/services/libs/jinux-std/src/syscall/execve.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/execve.rs\nrename to services/libs/jinux-std/src/syscall/execve.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/exit.rs b/services/libs/jinux-std/src/syscall/exit.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/exit.rs\nrename to services/libs/jinux-std/src/syscall/exit.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/exit_group.rs b/services/libs/jinux-std/src/syscall/exit_group.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/exit_group.rs\nrename to services/libs/jinux-std/src/syscall/exit_group.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/fcntl.rs b/services/libs/jinux-std/src/syscall/fcntl.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/fcntl.rs\nrename to services/libs/jinux-std/src/syscall/fcntl.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/fork.rs b/services/libs/jinux-std/src/syscall/fork.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/fork.rs\nrename to services/libs/jinux-std/src/syscall/fork.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/futex.rs b/services/libs/jinux-std/src/syscall/futex.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/futex.rs\nrename to services/libs/jinux-std/src/syscall/futex.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/getcwd.rs b/services/libs/jinux-std/src/syscall/getcwd.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/getcwd.rs\nrename to services/libs/jinux-std/src/syscall/getcwd.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/getdents64.rs b/services/libs/jinux-std/src/syscall/getdents64.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/getdents64.rs\nrename to services/libs/jinux-std/src/syscall/getdents64.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/getegid.rs b/services/libs/jinux-std/src/syscall/getegid.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/getegid.rs\nrename to services/libs/jinux-std/src/syscall/getegid.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/geteuid.rs b/services/libs/jinux-std/src/syscall/geteuid.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/geteuid.rs\nrename to services/libs/jinux-std/src/syscall/geteuid.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/getgid.rs b/services/libs/jinux-std/src/syscall/getgid.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/getgid.rs\nrename to services/libs/jinux-std/src/syscall/getgid.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/getpgrp.rs b/services/libs/jinux-std/src/syscall/getpgrp.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/getpgrp.rs\nrename to services/libs/jinux-std/src/syscall/getpgrp.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/getpid.rs b/services/libs/jinux-std/src/syscall/getpid.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/getpid.rs\nrename to services/libs/jinux-std/src/syscall/getpid.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/getppid.rs b/services/libs/jinux-std/src/syscall/getppid.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/getppid.rs\nrename to services/libs/jinux-std/src/syscall/getppid.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/gettid.rs b/services/libs/jinux-std/src/syscall/gettid.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/gettid.rs\nrename to services/libs/jinux-std/src/syscall/gettid.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/getuid.rs b/services/libs/jinux-std/src/syscall/getuid.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/getuid.rs\nrename to services/libs/jinux-std/src/syscall/getuid.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/ioctl.rs b/services/libs/jinux-std/src/syscall/ioctl.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/ioctl.rs\nrename to services/libs/jinux-std/src/syscall/ioctl.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/kill.rs b/services/libs/jinux-std/src/syscall/kill.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/kill.rs\nrename to services/libs/jinux-std/src/syscall/kill.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/link.rs b/services/libs/jinux-std/src/syscall/link.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/link.rs\nrename to services/libs/jinux-std/src/syscall/link.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/lseek.rs b/services/libs/jinux-std/src/syscall/lseek.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/lseek.rs\nrename to services/libs/jinux-std/src/syscall/lseek.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/madvise.rs b/services/libs/jinux-std/src/syscall/madvise.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/madvise.rs\nrename to services/libs/jinux-std/src/syscall/madvise.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/mkdir.rs b/services/libs/jinux-std/src/syscall/mkdir.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/mkdir.rs\nrename to services/libs/jinux-std/src/syscall/mkdir.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/mmap.rs b/services/libs/jinux-std/src/syscall/mmap.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/mmap.rs\nrename to services/libs/jinux-std/src/syscall/mmap.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/mod.rs b/services/libs/jinux-std/src/syscall/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/mod.rs\nrename to services/libs/jinux-std/src/syscall/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/mprotect.rs b/services/libs/jinux-std/src/syscall/mprotect.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/mprotect.rs\nrename to services/libs/jinux-std/src/syscall/mprotect.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/munmap.rs b/services/libs/jinux-std/src/syscall/munmap.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/munmap.rs\nrename to services/libs/jinux-std/src/syscall/munmap.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/open.rs b/services/libs/jinux-std/src/syscall/open.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/open.rs\nrename to services/libs/jinux-std/src/syscall/open.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/pause.rs b/services/libs/jinux-std/src/syscall/pause.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/pause.rs\nrename to services/libs/jinux-std/src/syscall/pause.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/poll.rs b/services/libs/jinux-std/src/syscall/poll.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/poll.rs\nrename to services/libs/jinux-std/src/syscall/poll.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/prctl.rs b/services/libs/jinux-std/src/syscall/prctl.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/prctl.rs\nrename to services/libs/jinux-std/src/syscall/prctl.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/pread64.rs b/services/libs/jinux-std/src/syscall/pread64.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/pread64.rs\nrename to services/libs/jinux-std/src/syscall/pread64.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/prlimit64.rs b/services/libs/jinux-std/src/syscall/prlimit64.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/prlimit64.rs\nrename to services/libs/jinux-std/src/syscall/prlimit64.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/read.rs b/services/libs/jinux-std/src/syscall/read.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/read.rs\nrename to services/libs/jinux-std/src/syscall/read.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/readlink.rs b/services/libs/jinux-std/src/syscall/readlink.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/readlink.rs\nrename to services/libs/jinux-std/src/syscall/readlink.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/rename.rs b/services/libs/jinux-std/src/syscall/rename.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/rename.rs\nrename to services/libs/jinux-std/src/syscall/rename.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/rmdir.rs b/services/libs/jinux-std/src/syscall/rmdir.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/rmdir.rs\nrename to services/libs/jinux-std/src/syscall/rmdir.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/rt_sigaction.rs b/services/libs/jinux-std/src/syscall/rt_sigaction.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/rt_sigaction.rs\nrename to services/libs/jinux-std/src/syscall/rt_sigaction.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/rt_sigprocmask.rs b/services/libs/jinux-std/src/syscall/rt_sigprocmask.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/rt_sigprocmask.rs\nrename to services/libs/jinux-std/src/syscall/rt_sigprocmask.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/rt_sigreturn.rs b/services/libs/jinux-std/src/syscall/rt_sigreturn.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/rt_sigreturn.rs\nrename to services/libs/jinux-std/src/syscall/rt_sigreturn.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/sched_yield.rs b/services/libs/jinux-std/src/syscall/sched_yield.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/sched_yield.rs\nrename to services/libs/jinux-std/src/syscall/sched_yield.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/set_robust_list.rs b/services/libs/jinux-std/src/syscall/set_robust_list.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/set_robust_list.rs\nrename to services/libs/jinux-std/src/syscall/set_robust_list.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/set_tid_address.rs b/services/libs/jinux-std/src/syscall/set_tid_address.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/set_tid_address.rs\nrename to services/libs/jinux-std/src/syscall/set_tid_address.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/setpgid.rs b/services/libs/jinux-std/src/syscall/setpgid.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/setpgid.rs\nrename to services/libs/jinux-std/src/syscall/setpgid.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/stat.rs b/services/libs/jinux-std/src/syscall/stat.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/stat.rs\nrename to services/libs/jinux-std/src/syscall/stat.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/symlink.rs b/services/libs/jinux-std/src/syscall/symlink.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/symlink.rs\nrename to services/libs/jinux-std/src/syscall/symlink.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/tgkill.rs b/services/libs/jinux-std/src/syscall/tgkill.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/tgkill.rs\nrename to services/libs/jinux-std/src/syscall/tgkill.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/time.rs b/services/libs/jinux-std/src/syscall/time.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/time.rs\nrename to services/libs/jinux-std/src/syscall/time.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/umask.rs b/services/libs/jinux-std/src/syscall/umask.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/umask.rs\nrename to services/libs/jinux-std/src/syscall/umask.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/uname.rs b/services/libs/jinux-std/src/syscall/uname.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/uname.rs\nrename to services/libs/jinux-std/src/syscall/uname.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/unlink.rs b/services/libs/jinux-std/src/syscall/unlink.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/unlink.rs\nrename to services/libs/jinux-std/src/syscall/unlink.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/utimens.rs b/services/libs/jinux-std/src/syscall/utimens.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/utimens.rs\nrename to services/libs/jinux-std/src/syscall/utimens.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/wait4.rs b/services/libs/jinux-std/src/syscall/wait4.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/wait4.rs\nrename to services/libs/jinux-std/src/syscall/wait4.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/waitid.rs b/services/libs/jinux-std/src/syscall/waitid.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/waitid.rs\nrename to services/libs/jinux-std/src/syscall/waitid.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/write.rs b/services/libs/jinux-std/src/syscall/write.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/write.rs\nrename to services/libs/jinux-std/src/syscall/write.rs\ndiff --git a/src/services/libs/jinux-std/src/syscall/writev.rs b/services/libs/jinux-std/src/syscall/writev.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/syscall/writev.rs\nrename to services/libs/jinux-std/src/syscall/writev.rs\ndiff --git a/src/services/libs/jinux-std/src/thread/exception.rs b/services/libs/jinux-std/src/thread/exception.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/thread/exception.rs\nrename to services/libs/jinux-std/src/thread/exception.rs\ndiff --git a/src/services/libs/jinux-std/src/thread/kernel_thread.rs b/services/libs/jinux-std/src/thread/kernel_thread.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/thread/kernel_thread.rs\nrename to services/libs/jinux-std/src/thread/kernel_thread.rs\ndiff --git a/src/services/libs/jinux-std/src/thread/mod.rs b/services/libs/jinux-std/src/thread/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/thread/mod.rs\nrename to services/libs/jinux-std/src/thread/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/thread/status.rs b/services/libs/jinux-std/src/thread/status.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/thread/status.rs\nrename to services/libs/jinux-std/src/thread/status.rs\ndiff --git a/src/services/libs/jinux-std/src/thread/task.rs b/services/libs/jinux-std/src/thread/task.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/thread/task.rs\nrename to services/libs/jinux-std/src/thread/task.rs\ndiff --git a/src/services/libs/jinux-std/src/thread/thread_table.rs b/services/libs/jinux-std/src/thread/thread_table.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/thread/thread_table.rs\nrename to services/libs/jinux-std/src/thread/thread_table.rs\ndiff --git a/src/services/libs/jinux-std/src/time/mod.rs b/services/libs/jinux-std/src/time/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/time/mod.rs\nrename to services/libs/jinux-std/src/time/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/time/system_time.rs b/services/libs/jinux-std/src/time/system_time.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/time/system_time.rs\nrename to services/libs/jinux-std/src/time/system_time.rs\ndiff --git a/src/services/libs/jinux-std/src/tty/line_discipline.rs b/services/libs/jinux-std/src/tty/line_discipline.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/tty/line_discipline.rs\nrename to services/libs/jinux-std/src/tty/line_discipline.rs\ndiff --git a/src/services/libs/jinux-std/src/tty/mod.rs b/services/libs/jinux-std/src/tty/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/tty/mod.rs\nrename to services/libs/jinux-std/src/tty/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/tty/termio.rs b/services/libs/jinux-std/src/tty/termio.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/tty/termio.rs\nrename to services/libs/jinux-std/src/tty/termio.rs\ndiff --git a/src/services/libs/jinux-std/src/util/mod.rs b/services/libs/jinux-std/src/util/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/util/mod.rs\nrename to services/libs/jinux-std/src/util/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/mod.rs b/services/libs/jinux-std/src/vm/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/mod.rs\nrename to services/libs/jinux-std/src/vm/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/page_fault_handler.rs b/services/libs/jinux-std/src/vm/page_fault_handler.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/page_fault_handler.rs\nrename to services/libs/jinux-std/src/vm/page_fault_handler.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/perms.rs b/services/libs/jinux-std/src/vm/perms.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/perms.rs\nrename to services/libs/jinux-std/src/vm/perms.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs b/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/vmar/dyn_cap.rs\nrename to services/libs/jinux-std/src/vm/vmar/dyn_cap.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/vmar/mod.rs b/services/libs/jinux-std/src/vm/vmar/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/vmar/mod.rs\nrename to services/libs/jinux-std/src/vm/vmar/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/vmar/options.rs b/services/libs/jinux-std/src/vm/vmar/options.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/vmar/options.rs\nrename to services/libs/jinux-std/src/vm/vmar/options.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/vmar/static_cap.rs b/services/libs/jinux-std/src/vm/vmar/static_cap.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/vmar/static_cap.rs\nrename to services/libs/jinux-std/src/vm/vmar/static_cap.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs b/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\nrename to services/libs/jinux-std/src/vm/vmar/vm_mapping.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs b/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/vmo/dyn_cap.rs\nrename to services/libs/jinux-std/src/vm/vmo/dyn_cap.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/vmo/mod.rs b/services/libs/jinux-std/src/vm/vmo/mod.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/vmo/mod.rs\nrename to services/libs/jinux-std/src/vm/vmo/mod.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/vmo/options.rs b/services/libs/jinux-std/src/vm/vmo/options.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/vmo/options.rs\nrename to services/libs/jinux-std/src/vm/vmo/options.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/vmo/pager.rs b/services/libs/jinux-std/src/vm/vmo/pager.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/vmo/pager.rs\nrename to services/libs/jinux-std/src/vm/vmo/pager.rs\ndiff --git a/src/services/libs/jinux-std/src/vm/vmo/static_cap.rs b/services/libs/jinux-std/src/vm/vmo/static_cap.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-std/src/vm/vmo/static_cap.rs\nrename to services/libs/jinux-std/src/vm/vmo/static_cap.rs\ndiff --git a/src/services/libs/jinux-util/Cargo.toml b/services/libs/jinux-util/Cargo.toml\nsimilarity index 100%\nrename from src/services/libs/jinux-util/Cargo.toml\nrename to services/libs/jinux-util/Cargo.toml\ndiff --git a/src/services/libs/jinux-util/src/frame_ptr.rs b/services/libs/jinux-util/src/frame_ptr.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-util/src/frame_ptr.rs\nrename to services/libs/jinux-util/src/frame_ptr.rs\ndiff --git a/src/services/libs/jinux-util/src/lib.rs b/services/libs/jinux-util/src/lib.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-util/src/lib.rs\nrename to services/libs/jinux-util/src/lib.rs\ndiff --git a/src/services/libs/jinux-util/src/union_read_ptr.rs b/services/libs/jinux-util/src/union_read_ptr.rs\nsimilarity index 100%\nrename from src/services/libs/jinux-util/src/union_read_ptr.rs\nrename to services/libs/jinux-util/src/union_read_ptr.rs\ndiff --git a/src/services/libs/typeflags-util/Cargo.toml b/services/libs/typeflags-util/Cargo.toml\nsimilarity index 100%\nrename from src/services/libs/typeflags-util/Cargo.toml\nrename to services/libs/typeflags-util/Cargo.toml\ndiff --git a/src/services/libs/typeflags-util/src/assert.rs b/services/libs/typeflags-util/src/assert.rs\nsimilarity index 100%\nrename from src/services/libs/typeflags-util/src/assert.rs\nrename to services/libs/typeflags-util/src/assert.rs\ndiff --git a/src/services/libs/typeflags-util/src/bool.rs b/services/libs/typeflags-util/src/bool.rs\nsimilarity index 100%\nrename from src/services/libs/typeflags-util/src/bool.rs\nrename to services/libs/typeflags-util/src/bool.rs\ndiff --git a/src/services/libs/typeflags-util/src/extend.rs b/services/libs/typeflags-util/src/extend.rs\nsimilarity index 100%\nrename from src/services/libs/typeflags-util/src/extend.rs\nrename to services/libs/typeflags-util/src/extend.rs\ndiff --git a/src/services/libs/typeflags-util/src/if_.rs b/services/libs/typeflags-util/src/if_.rs\nsimilarity index 100%\nrename from src/services/libs/typeflags-util/src/if_.rs\nrename to services/libs/typeflags-util/src/if_.rs\ndiff --git a/src/services/libs/typeflags-util/src/lib.rs b/services/libs/typeflags-util/src/lib.rs\nsimilarity index 100%\nrename from src/services/libs/typeflags-util/src/lib.rs\nrename to services/libs/typeflags-util/src/lib.rs\ndiff --git a/src/services/libs/typeflags-util/src/same.rs b/services/libs/typeflags-util/src/same.rs\nsimilarity index 100%\nrename from src/services/libs/typeflags-util/src/same.rs\nrename to services/libs/typeflags-util/src/same.rs\ndiff --git a/src/services/libs/typeflags-util/src/set.rs b/services/libs/typeflags-util/src/set.rs\nsimilarity index 100%\nrename from src/services/libs/typeflags-util/src/set.rs\nrename to services/libs/typeflags-util/src/set.rs\ndiff --git a/src/services/libs/typeflags/Cargo.toml b/services/libs/typeflags/Cargo.toml\nsimilarity index 100%\nrename from src/services/libs/typeflags/Cargo.toml\nrename to services/libs/typeflags/Cargo.toml\ndiff --git a/src/services/libs/typeflags/src/flag_set.rs b/services/libs/typeflags/src/flag_set.rs\nsimilarity index 100%\nrename from src/services/libs/typeflags/src/flag_set.rs\nrename to services/libs/typeflags/src/flag_set.rs\ndiff --git a/src/services/libs/typeflags/src/lib.rs b/services/libs/typeflags/src/lib.rs\nsimilarity index 100%\nrename from src/services/libs/typeflags/src/lib.rs\nrename to services/libs/typeflags/src/lib.rs\ndiff --git a/src/services/libs/typeflags/src/type_flag.rs b/services/libs/typeflags/src/type_flag.rs\nsimilarity index 100%\nrename from src/services/libs/typeflags/src/type_flag.rs\nrename to services/libs/typeflags/src/type_flag.rs\ndiff --git a/src/services/libs/typeflags/src/util.rs b/services/libs/typeflags/src/util.rs\nsimilarity index 100%\nrename from src/services/libs/typeflags/src/util.rs\nrename to services/libs/typeflags/src/util.rs\ndiff --git a/src/apps/hello_c/hello b/src/apps/hello_c/hello\ndeleted file mode 100755\nindex aff26147fd..0000000000\nBinary files a/src/apps/hello_c/hello and /dev/null differ\ndiff --git a/src/x86_64-custom.json b/x86_64-custom.json\nsimilarity index 100%\nrename from src/x86_64-custom.json\nrename to x86_64-custom.json\n", "test_patch": "diff --git a/src/apps/pthread/pthread_test b/regression/apps/pthread/pthread_test\nsimilarity index 100%\nrename from src/apps/pthread/pthread_test\nrename to regression/apps/pthread/pthread_test\ndiff --git a/src/apps/pthread/pthread_test.c b/regression/apps/pthread/pthread_test.c\nsimilarity index 100%\nrename from src/apps/pthread/pthread_test.c\nrename to regression/apps/pthread/pthread_test.c\ndiff --git a/src/apps/scripts/run_tests.sh b/regression/apps/scripts/run_tests.sh\nsimilarity index 100%\nrename from src/apps/scripts/run_tests.sh\nrename to regression/apps/scripts/run_tests.sh\ndiff --git a/src/apps/scripts/test_cmd.sh b/regression/apps/scripts/test_cmd.sh\nsimilarity index 100%\nrename from src/apps/scripts/test_cmd.sh\nrename to regression/apps/scripts/test_cmd.sh\ndiff --git a/src/apps/signal_c/signal_test b/regression/apps/signal_c/signal_test\nsimilarity index 100%\nrename from src/apps/signal_c/signal_test\nrename to regression/apps/signal_c/signal_test\ndiff --git a/src/apps/signal_c/signal_test.c b/regression/apps/signal_c/signal_test.c\nsimilarity index 100%\nrename from src/apps/signal_c/signal_test.c\nrename to regression/apps/signal_c/signal_test.c\ndiff --git a/src/services/comp-sys/cargo-component/tests/duplicate_lib_name.rs b/services/libs/comp-sys/cargo-component/tests/duplicate_lib_name.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/duplicate_lib_name.rs\nrename to services/libs/comp-sys/cargo-component/tests/duplicate_lib_name.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/duplicate_lib_name_test/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/duplicate_lib_name_test/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/duplicate_lib_name_test/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/duplicate_lib_name_test/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/duplicate_lib_name_test/Components.toml b/services/libs/comp-sys/cargo-component/tests/duplicate_lib_name_test/Components.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/duplicate_lib_name_test/Components.toml\nrename to services/libs/comp-sys/cargo-component/tests/duplicate_lib_name_test/Components.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/duplicate_lib_name_test/src/lib.rs b/services/libs/comp-sys/cargo-component/tests/duplicate_lib_name_test/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/duplicate_lib_name_test/src/lib.rs\nrename to services/libs/comp-sys/cargo-component/tests/duplicate_lib_name_test/src/lib.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/missing_toml.rs b/services/libs/comp-sys/cargo-component/tests/missing_toml.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/missing_toml.rs\nrename to services/libs/comp-sys/cargo-component/tests/missing_toml.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/missing_toml_test/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/missing_toml_test/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/missing_toml_test/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/missing_toml_test/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/missing_toml_test/src/lib.rs b/services/libs/comp-sys/cargo-component/tests/missing_toml_test/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/missing_toml_test/src/lib.rs\nrename to services/libs/comp-sys/cargo-component/tests/missing_toml_test/src/lib.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/reexport.rs b/services/libs/comp-sys/cargo-component/tests/reexport.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/reexport.rs\nrename to services/libs/comp-sys/cargo-component/tests/reexport.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/reexport_test/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/reexport_test/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/reexport_test/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/reexport_test/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/reexport_test/Components.toml b/services/libs/comp-sys/cargo-component/tests/reexport_test/Components.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/reexport_test/Components.toml\nrename to services/libs/comp-sys/cargo-component/tests/reexport_test/Components.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/reexport_test/bar/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/reexport_test/bar/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/reexport_test/bar/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/reexport_test/bar/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/reexport_test/bar/src/lib.rs b/services/libs/comp-sys/cargo-component/tests/reexport_test/bar/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/reexport_test/bar/src/lib.rs\nrename to services/libs/comp-sys/cargo-component/tests/reexport_test/bar/src/lib.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/reexport_test/baz/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/reexport_test/baz/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/reexport_test/baz/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/reexport_test/baz/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/reexport_test/baz/src/lib.rs b/services/libs/comp-sys/cargo-component/tests/reexport_test/baz/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/reexport_test/baz/src/lib.rs\nrename to services/libs/comp-sys/cargo-component/tests/reexport_test/baz/src/lib.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/reexport_test/foo/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/reexport_test/foo/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/reexport_test/foo/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/reexport_test/foo/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/reexport_test/foo/src/lib.rs b/services/libs/comp-sys/cargo-component/tests/reexport_test/foo/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/reexport_test/foo/src/lib.rs\nrename to services/libs/comp-sys/cargo-component/tests/reexport_test/foo/src/lib.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/regression.rs b/services/libs/comp-sys/cargo-component/tests/regression.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/regression.rs\nrename to services/libs/comp-sys/cargo-component/tests/regression.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/regression_test/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/regression_test/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/regression_test/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/regression_test/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/regression_test/Components.toml b/services/libs/comp-sys/cargo-component/tests/regression_test/Components.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/regression_test/Components.toml\nrename to services/libs/comp-sys/cargo-component/tests/regression_test/Components.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/regression_test/bar/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/regression_test/bar/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/regression_test/bar/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/regression_test/bar/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/regression_test/bar/src/lib.rs b/services/libs/comp-sys/cargo-component/tests/regression_test/bar/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/regression_test/bar/src/lib.rs\nrename to services/libs/comp-sys/cargo-component/tests/regression_test/bar/src/lib.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/regression_test/foo/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/regression_test/foo/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/regression_test/foo/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/regression_test/foo/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/regression_test/foo/src/lib.rs b/services/libs/comp-sys/cargo-component/tests/regression_test/foo/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/regression_test/foo/src/lib.rs\nrename to services/libs/comp-sys/cargo-component/tests/regression_test/foo/src/lib.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/test_utils/mod.rs b/services/libs/comp-sys/cargo-component/tests/test_utils/mod.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/test_utils/mod.rs\nrename to services/libs/comp-sys/cargo-component/tests/test_utils/mod.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/trait_method.rs b/services/libs/comp-sys/cargo-component/tests/trait_method.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/trait_method.rs\nrename to services/libs/comp-sys/cargo-component/tests/trait_method.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/trait_method_test/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/trait_method_test/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/trait_method_test/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/trait_method_test/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/trait_method_test/Components.toml b/services/libs/comp-sys/cargo-component/tests/trait_method_test/Components.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/trait_method_test/Components.toml\nrename to services/libs/comp-sys/cargo-component/tests/trait_method_test/Components.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/trait_method_test/bar/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/trait_method_test/bar/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/trait_method_test/bar/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/trait_method_test/bar/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/trait_method_test/bar/src/lib.rs b/services/libs/comp-sys/cargo-component/tests/trait_method_test/bar/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/trait_method_test/bar/src/lib.rs\nrename to services/libs/comp-sys/cargo-component/tests/trait_method_test/bar/src/lib.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/trait_method_test/foo/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/trait_method_test/foo/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/trait_method_test/foo/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/trait_method_test/foo/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/trait_method_test/foo/src/lib.rs b/services/libs/comp-sys/cargo-component/tests/trait_method_test/foo/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/trait_method_test/foo/src/lib.rs\nrename to services/libs/comp-sys/cargo-component/tests/trait_method_test/foo/src/lib.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/violate_policy.rs b/services/libs/comp-sys/cargo-component/tests/violate_policy.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/violate_policy.rs\nrename to services/libs/comp-sys/cargo-component/tests/violate_policy.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/violate_policy_test/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/violate_policy_test/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/violate_policy_test/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/violate_policy_test/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/violate_policy_test/Components.toml b/services/libs/comp-sys/cargo-component/tests/violate_policy_test/Components.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/violate_policy_test/Components.toml\nrename to services/libs/comp-sys/cargo-component/tests/violate_policy_test/Components.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/violate_policy_test/bar/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/violate_policy_test/bar/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/violate_policy_test/bar/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/violate_policy_test/bar/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/violate_policy_test/bar/src/lib.rs b/services/libs/comp-sys/cargo-component/tests/violate_policy_test/bar/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/violate_policy_test/bar/src/lib.rs\nrename to services/libs/comp-sys/cargo-component/tests/violate_policy_test/bar/src/lib.rs\ndiff --git a/src/services/comp-sys/cargo-component/tests/violate_policy_test/foo/Cargo.toml b/services/libs/comp-sys/cargo-component/tests/violate_policy_test/foo/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/violate_policy_test/foo/Cargo.toml\nrename to services/libs/comp-sys/cargo-component/tests/violate_policy_test/foo/Cargo.toml\ndiff --git a/src/services/comp-sys/cargo-component/tests/violate_policy_test/foo/src/lib.rs b/services/libs/comp-sys/cargo-component/tests/violate_policy_test/foo/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/cargo-component/tests/violate_policy_test/foo/src/lib.rs\nrename to services/libs/comp-sys/cargo-component/tests/violate_policy_test/foo/src/lib.rs\ndiff --git a/src/services/comp-sys/component/tests/init-order/Cargo.toml b/services/libs/comp-sys/component/tests/init-order/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/component/tests/init-order/Cargo.toml\nrename to services/libs/comp-sys/component/tests/init-order/Cargo.toml\ndiff --git a/src/services/comp-sys/component/tests/init-order/Components.toml b/services/libs/comp-sys/component/tests/init-order/Components.toml\nsimilarity index 100%\nrename from src/services/comp-sys/component/tests/init-order/Components.toml\nrename to services/libs/comp-sys/component/tests/init-order/Components.toml\ndiff --git a/src/services/comp-sys/component/tests/init-order/first-init/Cargo.toml b/services/libs/comp-sys/component/tests/init-order/first-init/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/component/tests/init-order/first-init/Cargo.toml\nrename to services/libs/comp-sys/component/tests/init-order/first-init/Cargo.toml\ndiff --git a/src/services/comp-sys/component/tests/init-order/first-init/src/lib.rs b/services/libs/comp-sys/component/tests/init-order/first-init/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/component/tests/init-order/first-init/src/lib.rs\nrename to services/libs/comp-sys/component/tests/init-order/first-init/src/lib.rs\ndiff --git a/src/services/comp-sys/component/tests/init-order/second-init/Cargo.toml b/services/libs/comp-sys/component/tests/init-order/second-init/Cargo.toml\nsimilarity index 100%\nrename from src/services/comp-sys/component/tests/init-order/second-init/Cargo.toml\nrename to services/libs/comp-sys/component/tests/init-order/second-init/Cargo.toml\ndiff --git a/src/services/comp-sys/component/tests/init-order/second-init/src/lib.rs b/services/libs/comp-sys/component/tests/init-order/second-init/src/lib.rs\nsimilarity index 100%\nrename from src/services/comp-sys/component/tests/init-order/second-init/src/lib.rs\nrename to services/libs/comp-sys/component/tests/init-order/second-init/src/lib.rs\ndiff --git a/src/services/comp-sys/component/tests/init-order/second-init/tests/test.rs b/services/libs/comp-sys/component/tests/init-order/second-init/tests/test.rs\nsimilarity index 100%\nrename from src/services/comp-sys/component/tests/init-order/second-init/tests/test.rs\nrename to services/libs/comp-sys/component/tests/init-order/second-init/tests/test.rs\ndiff --git a/src/services/comp-sys/component/tests/init-order/src/main.rs b/services/libs/comp-sys/component/tests/init-order/src/main.rs\nsimilarity index 100%\nrename from src/services/comp-sys/component/tests/init-order/src/main.rs\nrename to services/libs/comp-sys/component/tests/init-order/src/main.rs\ndiff --git a/src/services/comp-sys/component/tests/init-order/tests/test.rs b/services/libs/comp-sys/component/tests/init-order/tests/test.rs\nsimilarity index 100%\nrename from src/services/comp-sys/component/tests/init-order/tests/test.rs\nrename to services/libs/comp-sys/component/tests/init-order/tests/test.rs\ndiff --git a/src/services/libs/cpio-decoder/src/test.rs b/services/libs/cpio-decoder/src/test.rs\nsimilarity index 100%\nrename from src/services/libs/cpio-decoder/src/test.rs\nrename to services/libs/cpio-decoder/src/test.rs\ndiff --git a/src/tests/console_input.rs b/tests/console_input.rs\nsimilarity index 100%\nrename from src/tests/console_input.rs\nrename to tests/console_input.rs\ndiff --git a/src/tests/framebuffer.rs b/tests/framebuffer.rs\nsimilarity index 100%\nrename from src/tests/framebuffer.rs\nrename to tests/framebuffer.rs\ndiff --git a/src/tests/rtc.rs b/tests/rtc.rs\nsimilarity index 100%\nrename from src/tests/rtc.rs\nrename to tests/rtc.rs\ndiff --git a/src/tests/test_example.rs b/tests/test_example.rs\nsimilarity index 100%\nrename from src/tests/test_example.rs\nrename to tests/test_example.rs\ndiff --git a/src/tests/timer_test.rs b/tests/timer_test.rs\nsimilarity index 100%\nrename from src/tests/timer_test.rs\nrename to tests/timer_test.rs\n", "problem_statement": "Reorganize the codebase for cleanness\nTo make the codebase more clean and understandable, I propose to do the following changes:\r\n\r\n* Rename `tests` to `test`, which indicates that the directory contains various types of testing code, including unit tests, user programs, and possibly LTP tests\r\n  * Rename `apps` to `test/apps`\r\n  * In the future, add LTP tests to `test`\r\n  * Put `ramdisk` under `test` because its content is only intended for testing\r\n* Create a `framework/libs` and move every dir (except `jinux-frame`) to the new dir\r\n* Rename `jinux-boot` to `boot` to make the name consistent with other dirs like `services` and `framework`\r\n* Move `services/comp-sys` to `services/libs/comp-sys`\r\n* Move `src/*` to the project root dir\r\n* [Optional] Rename `src/src` to `src/kernel`\n", "hints_text": "", "created_at": "2023-04-10T03:22:03Z"}]