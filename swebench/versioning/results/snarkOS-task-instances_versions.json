[{"repo": "AleoNet/snarkOS", "pull_number": 3015, "instance_id": "AleoNet__snarkOS-3015", "issue_numbers": ["2983"], "base_commit": "bd165ecfcb81e72a167b2a984ba28531d543ab44", "patch": "diff --git a/node/bft/events/src/challenge_response.rs b/node/bft/events/src/challenge_response.rs\nindex 0fc678a86d..aad59f760f 100644\n--- a/node/bft/events/src/challenge_response.rs\n+++ b/node/bft/events/src/challenge_response.rs\n@@ -17,6 +17,7 @@ use super::*;\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct ChallengeResponse<N: Network> {\n     pub signature: Data<Signature<N>>,\n+    pub nonce: u64,\n }\n \n impl<N: Network> EventTrait for ChallengeResponse<N> {\n@@ -30,6 +31,7 @@ impl<N: Network> EventTrait for ChallengeResponse<N> {\n impl<N: Network> ToBytes for ChallengeResponse<N> {\n     fn write_le<W: Write>(&self, mut writer: W) -> IoResult<()> {\n         self.signature.write_le(&mut writer)?;\n+        self.nonce.write_le(&mut writer)?;\n         Ok(())\n     }\n }\n@@ -37,8 +39,9 @@ impl<N: Network> ToBytes for ChallengeResponse<N> {\n impl<N: Network> FromBytes for ChallengeResponse<N> {\n     fn read_le<R: Read>(mut reader: R) -> IoResult<Self> {\n         let signature = Data::read_le(&mut reader)?;\n+        let nonce = u64::read_le(&mut reader)?;\n \n-        Ok(Self { signature })\n+        Ok(Self { signature, nonce })\n     }\n }\n \n@@ -53,7 +56,7 @@ pub mod prop_tests {\n     };\n \n     use bytes::{Buf, BufMut, BytesMut};\n-    use proptest::prelude::{BoxedStrategy, Strategy};\n+    use proptest::prelude::{any, BoxedStrategy, Strategy};\n     use test_strategy::proptest;\n \n     type CurrentNetwork = snarkvm::prelude::Testnet3;\n@@ -70,7 +73,9 @@ pub mod prop_tests {\n     }\n \n     pub fn any_challenge_response() -> BoxedStrategy<ChallengeResponse<CurrentNetwork>> {\n-        any_signature().prop_map(|sig| ChallengeResponse { signature: Data::Object(sig) }).boxed()\n+        (any_signature(), any::<u64>())\n+            .prop_map(|(sig, nonce)| ChallengeResponse { signature: Data::Object(sig), nonce })\n+            .boxed()\n     }\n \n     #[proptest]\ndiff --git a/node/bft/events/src/lib.rs b/node/bft/events/src/lib.rs\nindex d49073b1c5..7a3c6d30ef 100644\n--- a/node/bft/events/src/lib.rs\n+++ b/node/bft/events/src/lib.rs\n@@ -118,7 +118,7 @@ impl<N: Network> From<DisconnectReason> for Event<N> {\n \n impl<N: Network> Event<N> {\n     /// The version of the event protocol; it can be incremented in order to force users to update.\n-    pub const VERSION: u32 = 5;\n+    pub const VERSION: u32 = 6;\n \n     /// Returns the event name.\n     #[inline]\ndiff --git a/node/bft/src/gateway.rs b/node/bft/src/gateway.rs\nindex d6b8c000d4..ecbfdb110a 100644\n--- a/node/bft/src/gateway.rs\n+++ b/node/bft/src/gateway.rs\n@@ -1176,11 +1176,13 @@ impl<N: Network> Gateway<N> {\n         /* Step 3: Send the challenge response. */\n \n         // Sign the counterparty nonce.\n-        let Ok(our_signature) = self.account.sign_bytes(&peer_request.nonce.to_le_bytes(), rng) else {\n+        let response_nonce: u64 = rng.gen();\n+        let data = [peer_request.nonce.to_le_bytes(), response_nonce.to_le_bytes()].concat();\n+        let Ok(our_signature) = self.account.sign_bytes(&data, rng) else {\n             return Err(error(format!(\"Failed to sign the challenge request nonce from '{peer_addr}'\")));\n         };\n         // Send the challenge response.\n-        let our_response = ChallengeResponse { signature: Data::Object(our_signature) };\n+        let our_response = ChallengeResponse { signature: Data::Object(our_signature), nonce: response_nonce };\n         send_event(&mut framed, peer_addr, Event::ChallengeResponse(our_response)).await?;\n \n         // Add the peer to the gateway.\n@@ -1229,11 +1231,13 @@ impl<N: Network> Gateway<N> {\n         let rng = &mut rand::rngs::OsRng;\n \n         // Sign the counterparty nonce.\n-        let Ok(our_signature) = self.account.sign_bytes(&peer_request.nonce.to_le_bytes(), rng) else {\n+        let response_nonce: u64 = rng.gen();\n+        let data = [peer_request.nonce.to_le_bytes(), response_nonce.to_le_bytes()].concat();\n+        let Ok(our_signature) = self.account.sign_bytes(&data, rng) else {\n             return Err(error(format!(\"Failed to sign the challenge request nonce from '{peer_addr}'\")));\n         };\n         // Send the challenge response.\n-        let our_response = ChallengeResponse { signature: Data::Object(our_signature) };\n+        let our_response = ChallengeResponse { signature: Data::Object(our_signature), nonce: response_nonce };\n         send_event(&mut framed, peer_addr, Event::ChallengeResponse(our_response)).await?;\n \n         // Sample a random nonce.\n@@ -1290,14 +1294,14 @@ impl<N: Network> Gateway<N> {\n         expected_nonce: u64,\n     ) -> Option<DisconnectReason> {\n         // Retrieve the components of the challenge response.\n-        let ChallengeResponse { signature } = response;\n+        let ChallengeResponse { signature, nonce } = response;\n         // Perform the deferred non-blocking deserialization of the signature.\n         let Ok(signature) = spawn_blocking!(signature.deserialize_blocking()) else {\n             warn!(\"{CONTEXT} Gateway handshake with '{peer_addr}' failed (cannot deserialize the signature)\");\n             return Some(DisconnectReason::InvalidChallengeResponse);\n         };\n         // Verify the signature.\n-        if !signature.verify_bytes(&peer_address, &expected_nonce.to_le_bytes()) {\n+        if !signature.verify_bytes(&peer_address, &[expected_nonce.to_le_bytes(), nonce.to_le_bytes()].concat()) {\n             warn!(\"{CONTEXT} Gateway handshake with '{peer_addr}' failed (invalid signature)\");\n             return Some(DisconnectReason::InvalidChallengeResponse);\n         }\ndiff --git a/node/router/messages/src/challenge_response.rs b/node/router/messages/src/challenge_response.rs\nindex 3c75d4db19..d51c5bb717 100644\n--- a/node/router/messages/src/challenge_response.rs\n+++ b/node/router/messages/src/challenge_response.rs\n@@ -25,6 +25,7 @@ use std::borrow::Cow;\n pub struct ChallengeResponse<N: Network> {\n     pub genesis_header: Header<N>,\n     pub signature: Data<Signature<N>>,\n+    pub nonce: u64,\n }\n \n impl<N: Network> MessageTrait for ChallengeResponse<N> {\n@@ -38,13 +39,18 @@ impl<N: Network> MessageTrait for ChallengeResponse<N> {\n impl<N: Network> ToBytes for ChallengeResponse<N> {\n     fn write_le<W: io::Write>(&self, mut writer: W) -> io::Result<()> {\n         self.genesis_header.write_le(&mut writer)?;\n-        self.signature.write_le(&mut writer)\n+        self.signature.write_le(&mut writer)?;\n+        self.nonce.write_le(&mut writer)\n     }\n }\n \n impl<N: Network> FromBytes for ChallengeResponse<N> {\n     fn read_le<R: io::Read>(mut reader: R) -> io::Result<Self> {\n-        Ok(Self { genesis_header: Header::read_le(&mut reader)?, signature: Data::read_le(reader)? })\n+        Ok(Self {\n+            genesis_header: Header::read_le(&mut reader)?,\n+            signature: Data::read_le(&mut reader)?,\n+            nonce: u64::read_le(reader)?,\n+        })\n     }\n }\n \n@@ -80,8 +86,12 @@ pub mod prop_tests {\n     }\n \n     pub fn any_challenge_response() -> BoxedStrategy<ChallengeResponse<CurrentNetwork>> {\n-        (any_signature(), any_genesis_header())\n-            .prop_map(|(sig, genesis_header)| ChallengeResponse { signature: Data::Object(sig), genesis_header })\n+        (any_signature(), any_genesis_header(), any::<u64>())\n+            .prop_map(|(sig, genesis_header, nonce)| ChallengeResponse {\n+                signature: Data::Object(sig),\n+                genesis_header,\n+                nonce,\n+            })\n             .boxed()\n     }\n \ndiff --git a/node/router/messages/src/lib.rs b/node/router/messages/src/lib.rs\nindex baa512b5b4..09b065a49d 100644\n--- a/node/router/messages/src/lib.rs\n+++ b/node/router/messages/src/lib.rs\n@@ -111,7 +111,7 @@ impl<N: Network> From<DisconnectReason> for Message<N> {\n \n impl<N: Network> Message<N> {\n     /// The version of the network protocol; it can be incremented in order to force users to update.\n-    pub const VERSION: u32 = 13;\n+    pub const VERSION: u32 = 14;\n \n     /// Returns the message name.\n     #[inline]\ndiff --git a/node/router/src/handshake.rs b/node/router/src/handshake.rs\nindex 7ccb67fa89..195298eaea 100644\n--- a/node/router/src/handshake.rs\n+++ b/node/router/src/handshake.rs\n@@ -164,12 +164,15 @@ impl<N: Network> Router<N> {\n         }\n         /* Step 3: Send the challenge response. */\n \n+        let response_nonce: u64 = rng.gen();\n+        let data = [peer_request.nonce.to_le_bytes(), response_nonce.to_le_bytes()].concat();\n         // Sign the counterparty nonce.\n-        let Ok(our_signature) = self.account.sign_bytes(&peer_request.nonce.to_le_bytes(), rng) else {\n+        let Ok(our_signature) = self.account.sign_bytes(&data, rng) else {\n             return Err(error(format!(\"Failed to sign the challenge request nonce from '{peer_addr}'\")));\n         };\n         // Send the challenge response.\n-        let our_response = ChallengeResponse { genesis_header, signature: Data::Object(our_signature) };\n+        let our_response =\n+            ChallengeResponse { genesis_header, signature: Data::Object(our_signature), nonce: response_nonce };\n         send(&mut framed, peer_addr, Message::ChallengeResponse(our_response)).await?;\n \n         // Add the peer to the router.\n@@ -213,11 +216,14 @@ impl<N: Network> Router<N> {\n         let rng = &mut OsRng;\n \n         // Sign the counterparty nonce.\n-        let Ok(our_signature) = self.account.sign_bytes(&peer_request.nonce.to_le_bytes(), rng) else {\n+        let response_nonce: u64 = rng.gen();\n+        let data = [peer_request.nonce.to_le_bytes(), response_nonce.to_le_bytes()].concat();\n+        let Ok(our_signature) = self.account.sign_bytes(&data, rng) else {\n             return Err(error(format!(\"Failed to sign the challenge request nonce from '{peer_addr}'\")));\n         };\n         // Send the challenge response.\n-        let our_response = ChallengeResponse { genesis_header, signature: Data::Object(our_signature) };\n+        let our_response =\n+            ChallengeResponse { genesis_header, signature: Data::Object(our_signature), nonce: response_nonce };\n         send(&mut framed, peer_addr, Message::ChallengeResponse(our_response)).await?;\n \n         // Sample a random nonce.\n@@ -303,7 +309,7 @@ impl<N: Network> Router<N> {\n         expected_nonce: u64,\n     ) -> Option<DisconnectReason> {\n         // Retrieve the components of the challenge response.\n-        let ChallengeResponse { genesis_header, signature } = response;\n+        let ChallengeResponse { genesis_header, signature, nonce } = response;\n \n         // Verify the challenge response, by checking that the block header matches.\n         if genesis_header != expected_genesis_header {\n@@ -316,7 +322,7 @@ impl<N: Network> Router<N> {\n             return Some(DisconnectReason::InvalidChallengeResponse);\n         };\n         // Verify the signature.\n-        if !signature.verify_bytes(&peer_address, &expected_nonce.to_le_bytes()) {\n+        if !signature.verify_bytes(&peer_address, &[expected_nonce.to_le_bytes(), nonce.to_le_bytes()].concat()) {\n             warn!(\"Handshake with '{peer_addr}' failed (invalid signature)\");\n             return Some(DisconnectReason::InvalidChallengeResponse);\n         }\n", "test_patch": "diff --git a/node/tests/common/test_peer.rs b/node/tests/common/test_peer.rs\nindex d480c6a3e1..8d9d5e39bb 100644\n--- a/node/tests/common/test_peer.rs\n+++ b/node/tests/common/test_peer.rs\n@@ -140,10 +140,13 @@ impl Handshake for TestPeer {\n                 let peer_request = expect_message!(Message::ChallengeRequest, framed, peer_addr);\n \n                 // Sign the nonce.\n-                let signature = self.account().sign_bytes(&peer_request.nonce.to_le_bytes(), rng).unwrap();\n+                let response_nonce: u64 = rng.gen();\n+                let data = [peer_request.nonce.to_le_bytes(), response_nonce.to_le_bytes()].concat();\n+                let signature = self.account().sign_bytes(&data, rng).unwrap();\n \n                 // Send the challenge response.\n-                let our_response = ChallengeResponse { genesis_header, signature: Data::Object(signature) };\n+                let our_response =\n+                    ChallengeResponse { genesis_header, signature: Data::Object(signature), nonce: response_nonce };\n                 framed.send(Message::ChallengeResponse(our_response)).await?;\n             }\n             ConnectionSide::Responder => {\n@@ -151,10 +154,13 @@ impl Handshake for TestPeer {\n                 let peer_request = expect_message!(Message::ChallengeRequest, framed, peer_addr);\n \n                 // Sign the nonce.\n-                let signature = self.account().sign_bytes(&peer_request.nonce.to_le_bytes(), rng).unwrap();\n+                let response_nonce: u64 = rng.gen();\n+                let data = [peer_request.nonce.to_le_bytes(), response_nonce.to_le_bytes()].concat();\n+                let signature = self.account().sign_bytes(&data, rng).unwrap();\n \n                 // Send our challenge bundle.\n-                let our_response = ChallengeResponse { genesis_header, signature: Data::Object(signature) };\n+                let our_response =\n+                    ChallengeResponse { genesis_header, signature: Data::Object(signature), nonce: response_nonce };\n                 framed.send(Message::ChallengeResponse(our_response)).await?;\n                 let our_request = ChallengeRequest::new(local_ip.port(), self.node_type(), self.address(), rng.gen());\n                 framed.send(Message::ChallengeRequest(our_request)).await?;\n", "problem_statement": "[Bug] Validator sign arbitrary nonce can lead to downgraded length of secure bit.\n# https://hackerone.com/reports/2279770\r\n\r\n## Summary:\r\n\r\nDuring handshake, validator directly sign nonce (u64) sent from counterparty:\r\n\r\n```\r\nlet Ok(our_signature) = self.account.sign_bytes(&peer_request.nonce.to_le_bytes(), rng)\r\n```\r\n\r\nThe attacker can exploit this to let validator to sign the message they want.\r\n\r\nFor example, the attacker can brute force and try to find some transaction `hash` that satify `hash < u64.max`. Then let the validator sign this hash as `peer_request.nonce`. In this case the length of secure bit is downgraded from `252/2 = 126` bits to `(252-64)/2 = 94` bits. \r\n\r\n## Proof-of-Concept (PoC)\r\n\r\nAs described above.\r\n\r\n## Fix Suggestions:\r\n\r\nInstead of directly sign the nonce, the validator can sign something like `hash('validator_handshake_nonce', nonce)`. Also, consider adding prefix string when generating `batch_id` and `block_hash` to avoid future schema conflict.\n", "hints_text": "", "created_at": "2024-01-17T23:29:29Z", "version": "2.2"}, {"repo": "AleoNet/snarkOS", "pull_number": 2902, "instance_id": "AleoNet__snarkOS-2902", "issue_numbers": ["2894"], "base_commit": "4896a1200a4605d1de6fe6cb53e1efa9ccdb6152", "patch": "diff --git a/Cargo.lock b/Cargo.lock\nindex e98d384892..b9f871cccb 100644\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -3096,6 +3096,7 @@ dependencies = [\n  \"num_cpus\",\n  \"once_cell\",\n  \"parking_lot\",\n+ \"paste\",\n  \"pea2pea\",\n  \"rand\",\n  \"rand_chacha\",\ndiff --git a/node/Cargo.toml b/node/Cargo.toml\nindex c76dac9006..664bf96a06 100644\n--- a/node/Cargo.toml\n+++ b/node/Cargo.toml\n@@ -113,6 +113,9 @@ version = \"0.1\"\n [dev-dependencies.deadline]\n version = \"0.2\"\n \n+[dev-dependencies.paste]\n+version = \"1\"\n+\n [dev-dependencies.pea2pea]\n version = \"0.46\"\n \ndiff --git a/node/router/src/helpers/cache.rs b/node/router/src/helpers/cache.rs\nindex befd5e9a90..87a0d8831e 100644\n--- a/node/router/src/helpers/cache.rs\n+++ b/node/router/src/helpers/cache.rs\n@@ -53,6 +53,8 @@ pub struct Cache<N: Network> {\n     seen_outbound_solutions: RwLock<LinkedHashMap<SolutionKey<N>, OffsetDateTime>>,\n     /// The map of transaction IDs to their last seen timestamp.\n     seen_outbound_transactions: RwLock<LinkedHashMap<TransactionKey<N>, OffsetDateTime>>,\n+    /// The map of peer IPs to the number of sent peer requests.\n+    seen_outbound_peer_requests: RwLock<IndexMap<SocketAddr, u32>>,\n }\n \n impl<N: Network> Default for Cache<N> {\n@@ -75,6 +77,7 @@ impl<N: Network> Cache<N> {\n             seen_outbound_puzzle_requests: Default::default(),\n             seen_outbound_solutions: RwLock::new(LinkedHashMap::with_capacity(MAX_CACHE_SIZE)),\n             seen_outbound_transactions: RwLock::new(LinkedHashMap::with_capacity(MAX_CACHE_SIZE)),\n+            seen_outbound_peer_requests: Default::default(),\n         }\n     }\n }\n@@ -166,6 +169,21 @@ impl<N: Network> Cache<N> {\n     ) -> Option<OffsetDateTime> {\n         Self::refresh_and_insert(&self.seen_outbound_transactions, (peer_ip, transaction))\n     }\n+\n+    /// Returns `true` if the cache contains a peer request from the given peer.\n+    pub fn contains_outbound_peer_request(&self, peer_ip: SocketAddr) -> bool {\n+        self.seen_outbound_peer_requests.read().get(&peer_ip).map(|r| *r > 0).unwrap_or(false)\n+    }\n+\n+    /// Increment the peer IP's number of peer requests, returning the updated number of peer requests.\n+    pub fn increment_outbound_peer_requests(&self, peer_ip: SocketAddr) -> u32 {\n+        Self::increment_counter(&self.seen_outbound_peer_requests, peer_ip)\n+    }\n+\n+    /// Decrement the peer IP's number of peer requests, returning the updated number of peer requests.\n+    pub fn decrement_outbound_peer_requests(&self, peer_ip: SocketAddr) -> u32 {\n+        Self::decrement_counter(&self.seen_outbound_peer_requests, peer_ip)\n+    }\n }\n \n impl<N: Network> Cache<N> {\n@@ -336,4 +354,35 @@ mod tests {\n         // Check that the cache still contains the transaction.\n         assert_eq!(cache.seen_outbound_transactions.read().len(), 1);\n     }\n+\n+    #[test]\n+    fn test_outbound_peer_request() {\n+        let cache = Cache::<CurrentNetwork>::default();\n+        let peer_ip = SocketAddr::new(Ipv4Addr::LOCALHOST.into(), 1234);\n+\n+        // Check the cache is empty.\n+        assert!(cache.seen_outbound_peer_requests.read().is_empty());\n+        assert!(!cache.contains_outbound_peer_request(peer_ip));\n+\n+        // Increment the peer requests.\n+        assert_eq!(cache.increment_outbound_peer_requests(peer_ip), 1);\n+\n+        // Check the cache contains the peer request.\n+        assert!(cache.contains_outbound_peer_request(peer_ip));\n+\n+        // Increment the peer requests again for the same peer IP.\n+        assert_eq!(cache.increment_outbound_peer_requests(peer_ip), 2);\n+\n+        // Check the cache still contains the peer request.\n+        assert!(cache.contains_outbound_peer_request(peer_ip));\n+\n+        // Decrement the peer requests.\n+        assert_eq!(cache.decrement_outbound_peer_requests(peer_ip), 1);\n+\n+        // Decrement the peer requests again.\n+        assert_eq!(cache.decrement_outbound_peer_requests(peer_ip), 0);\n+\n+        // Check the cache is empty.\n+        assert!(!cache.contains_outbound_peer_request(peer_ip));\n+    }\n }\ndiff --git a/node/router/src/inbound.rs b/node/router/src/inbound.rs\nindex ac1790f211..0b68800f9a 100644\n--- a/node/router/src/inbound.rs\n+++ b/node/router/src/inbound.rs\n@@ -117,10 +117,16 @@ pub trait Inbound<N: Network>: Reading + Outbound<N> {\n                 true => Ok(()),\n                 false => bail!(\"Peer '{peer_ip}' sent an invalid peer request\"),\n             },\n-            Message::PeerResponse(message) => match self.peer_response(peer_ip, &message.peers) {\n-                true => Ok(()),\n-                false => bail!(\"Peer '{peer_ip}' sent an invalid peer response\"),\n-            },\n+            Message::PeerResponse(message) => {\n+                if !self.router().cache.contains_outbound_peer_request(peer_ip) {\n+                    bail!(\"Peer '{peer_ip}' is not following the protocol (unexpected peer response)\")\n+                }\n+\n+                match self.peer_response(peer_ip, &message.peers) {\n+                    true => Ok(()),\n+                    false => bail!(\"Peer '{peer_ip}' sent an invalid peer response\"),\n+                }\n+            }\n             Message::Ping(message) => {\n                 // Ensure the message protocol version is not outdated.\n                 if message.version < Message::<N>::VERSION {\ndiff --git a/node/router/src/lib.rs b/node/router/src/lib.rs\nindex b51284190b..332cf07075 100644\n--- a/node/router/src/lib.rs\n+++ b/node/router/src/lib.rs\n@@ -25,7 +25,6 @@ mod helpers;\n pub use helpers::*;\n \n mod handshake;\n-pub use handshake::*;\n \n mod heartbeat;\n pub use heartbeat::*;\ndiff --git a/node/router/src/outbound.rs b/node/router/src/outbound.rs\nindex ab1a4d037a..20713962c9 100644\n--- a/node/router/src/outbound.rs\n+++ b/node/router/src/outbound.rs\n@@ -59,6 +59,10 @@ pub trait Outbound<N: Network>: Writing<Message = Message<N>> {\n         if matches!(message, Message::PuzzleRequest(_)) {\n             self.router().cache.increment_outbound_puzzle_requests(peer_ip);\n         }\n+        // If the message type is a peer request, increment the cache.\n+        if matches!(message, Message::PeerRequest(_)) {\n+            self.router().cache.increment_outbound_peer_requests(peer_ip);\n+        }\n         // Retrieve the message name.\n         let name = message.name();\n         // Send the message to the peer.\n", "test_patch": "diff --git a/node/tests/disconnect.rs b/node/tests/disconnect.rs\nnew file mode 100644\nindex 0000000000..5b6ec3b925\n--- /dev/null\n+++ b/node/tests/disconnect.rs\n@@ -0,0 +1,191 @@\n+// Copyright (C) 2019-2023 Aleo Systems Inc.\n+// This file is part of the snarkOS library.\n+\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at:\n+// http://www.apache.org/licenses/LICENSE-2.0\n+\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+#![recursion_limit = \"256\"]\n+\n+#[allow(dead_code)]\n+mod common;\n+use common::{node::*, test_peer::TestPeer};\n+\n+use snarkos_node_router::Outbound;\n+use snarkos_node_tcp::P2P;\n+\n+use deadline::deadline;\n+use std::time::Duration;\n+\n+// Macro to simply construct disconnect cases.\n+// Syntax:\n+// - (full_node |> test_peer): full node disconnects from the synthetic test peer.\n+// - (full_node <| test_peer): synthetic test peer disconnects from the full node.\n+//\n+// Test naming: full_node::handshake_<node or peer>_side::test_peer.\n+macro_rules! test_disconnect {\n+    ($node_type:ident, $peer_type:ident, $node_disconnects:expr, $($attr:meta)?) => {\n+        #[tokio::test]\n+        $(#[$attr])?\n+        async fn $peer_type() {\n+            use deadline::deadline;\n+            use pea2pea::Pea2Pea;\n+            use snarkos_node_router::Outbound;\n+            use snarkos_node_tcp::P2P;\n+            use std::time::Duration;\n+\n+            // $crate::common::initialise_logger(2);\n+\n+            // Spin up a full node.\n+            let node = $crate::$node_type().await;\n+\n+            // Spin up a test peer (synthetic node).\n+            let peer = $crate::TestPeer::$peer_type().await;\n+            let peer_addr = peer.node().listening_addr().unwrap();\n+\n+            // Connect the node to the test peer.\n+            node.router().connect(peer_addr).unwrap().await.unwrap();\n+\n+            // Check the peer counts.\n+            let node_clone = node.clone();\n+            deadline!(Duration::from_secs(5), move || node_clone.router().number_of_connected_peers() == 1);\n+            let node_clone = node.clone();\n+            deadline!(Duration::from_secs(5), move || node_clone.tcp().num_connected() == 1);\n+            let peer_clone = peer.clone();\n+            deadline!(Duration::from_secs(5), move || peer_clone.node().num_connected() == 1);\n+\n+            // Disconnect.\n+            if $node_disconnects {\n+                node.router().disconnect(node.tcp().connected_addrs()[0]).await.unwrap();\n+            } else {\n+                peer.node().disconnect(peer.node().connected_addrs()[0]).await;\n+            }\n+\n+            // Check the peer counts have been updated.\n+            let node_clone = node.clone();\n+            deadline!(Duration::from_secs(5), move || node_clone.router().number_of_connected_peers() == 0);\n+            deadline!(Duration::from_secs(5), move || node.tcp().num_connected() == 0);\n+            deadline!(Duration::from_secs(5), move || peer.node().num_connected() == 0);\n+\n+        }\n+    };\n+\n+    // Node side disconnect.\n+    ($($node_type:ident |> $peer_type:ident $(= $attr:meta)?),*) => {\n+        mod disconnect_node_side {\n+            $(\n+                test_disconnect!($node_type, $peer_type, true, $($attr)?);\n+            )*\n+        }\n+    };\n+\n+    // Peer side disconnect.\n+    ($($node_type:ident <| $peer_type:ident $(= $attr:meta)?),*) => {\n+        mod disconnect_peer_side {\n+            $(\n+                test_disconnect!($node_type, $peer_type, false, $($attr)?);\n+            )*\n+        }\n+    };\n+}\n+\n+mod client {\n+    // Full node disconnects from synthetic peer.\n+    test_disconnect! {\n+        client |> client,\n+        client |> validator,\n+        client |> prover\n+    }\n+\n+    // Synthetic peer disconnects from the full node.\n+    test_disconnect! {\n+        client <| client,\n+        client <| validator,\n+        client <| prover\n+    }\n+}\n+\n+mod prover {\n+    // Full node disconnects from synthetic peer.\n+    test_disconnect! {\n+        prover |> client,\n+        prover |> validator,\n+        prover |> prover\n+    }\n+\n+    // Synthetic peer disconnects from the full node.\n+    test_disconnect! {\n+        prover <| client,\n+        prover <| validator,\n+        prover <| prover\n+    }\n+}\n+\n+mod validator {\n+    // Full node disconnects from synthetic peer.\n+    test_disconnect! {\n+        validator |> client,\n+        validator |> validator,\n+        validator |> prover\n+    }\n+\n+    // Synthetic peer disconnects from the full node.\n+    test_disconnect! {\n+        validator <| client,\n+        validator <| validator,\n+        validator <| prover\n+    }\n+}\n+\n+#[tokio::test(flavor = \"multi_thread\")]\n+async fn duplicate_disconnect_attempts() {\n+    // common::initialise_logger(3);\n+\n+    // Spin up 2 full nodes.\n+    let node1 = validator().await;\n+    let node2 = validator().await;\n+    let addr2 = node2.tcp().listening_addr().unwrap();\n+\n+    // Connect node1 to node2.\n+    assert!(node1.router().connect(addr2).unwrap().await.unwrap());\n+\n+    // Prepare disconnect attempts.\n+    let node1_clone = node1.clone();\n+    let disconn1 = tokio::spawn(async move { node1_clone.router().disconnect(addr2).await.unwrap() });\n+    let node1_clone = node1.clone();\n+    let disconn2 = tokio::spawn(async move { node1_clone.router().disconnect(addr2).await.unwrap() });\n+    let node1_clone = node1.clone();\n+    let disconn3 = tokio::spawn(async move { node1_clone.router().disconnect(addr2).await.unwrap() });\n+\n+    // Attempt to disconnect the 1st node from the other one several times at once.\n+    let (result1, result2, result3) = tokio::join!(disconn1, disconn2, disconn3);\n+    // A small anti-flakiness buffer.\n+\n+    // Count the successes.\n+    let mut successes = 0;\n+    if result1.unwrap() {\n+        successes += 1;\n+    }\n+    if result2.unwrap() {\n+        successes += 1;\n+    }\n+    if result3.unwrap() {\n+        successes += 1;\n+    }\n+\n+    // There may only be a single success.\n+    assert_eq!(successes, 1);\n+\n+    // Connection checks.\n+    let node1_clone = node1.clone();\n+    deadline!(Duration::from_secs(5), move || node1_clone.router().number_of_connected_peers() == 0);\n+    let node2_clone = node2.clone();\n+    deadline!(Duration::from_secs(5), move || node2_clone.router().number_of_connected_peers() == 0);\n+}\ndiff --git a/node/tests/peering.rs b/node/tests/peering.rs\nindex 5b6ec3b925..1bae7f6ddc 100644\n--- a/node/tests/peering.rs\n+++ b/node/tests/peering.rs\n@@ -12,180 +12,71 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-#![recursion_limit = \"256\"]\n-\n #[allow(dead_code)]\n mod common;\n-use common::{node::*, test_peer::TestPeer};\n+use common::test_peer::TestPeer;\n \n-use snarkos_node_router::Outbound;\n+use snarkos_node_router::{\n+    messages::{Message, PeerResponse},\n+    Outbound,\n+};\n use snarkos_node_tcp::P2P;\n \n use deadline::deadline;\n+use paste::paste;\n+use pea2pea::{protocols::Writing, Pea2Pea};\n use std::time::Duration;\n \n-// Macro to simply construct disconnect cases.\n-// Syntax:\n-// - (full_node |> test_peer): full node disconnects from the synthetic test peer.\n-// - (full_node <| test_peer): synthetic test peer disconnects from the full node.\n-//\n-// Test naming: full_node::handshake_<node or peer>_side::test_peer.\n-macro_rules! test_disconnect {\n-    ($node_type:ident, $peer_type:ident, $node_disconnects:expr, $($attr:meta)?) => {\n-        #[tokio::test]\n-        $(#[$attr])?\n-        async fn $peer_type() {\n-            use deadline::deadline;\n-            use pea2pea::Pea2Pea;\n-            use snarkos_node_router::Outbound;\n-            use snarkos_node_tcp::P2P;\n-            use std::time::Duration;\n-\n-            // $crate::common::initialise_logger(2);\n-\n-            // Spin up a full node.\n-            let node = $crate::$node_type().await;\n-\n-            // Spin up a test peer (synthetic node).\n-            let peer = $crate::TestPeer::$peer_type().await;\n-            let peer_addr = peer.node().listening_addr().unwrap();\n-\n-            // Connect the node to the test peer.\n-            node.router().connect(peer_addr).unwrap().await.unwrap();\n-\n-            // Check the peer counts.\n-            let node_clone = node.clone();\n-            deadline!(Duration::from_secs(5), move || node_clone.router().number_of_connected_peers() == 1);\n-            let node_clone = node.clone();\n-            deadline!(Duration::from_secs(5), move || node_clone.tcp().num_connected() == 1);\n-            let peer_clone = peer.clone();\n-            deadline!(Duration::from_secs(5), move || peer_clone.node().num_connected() == 1);\n-\n-            // Disconnect.\n-            if $node_disconnects {\n-                node.router().disconnect(node.tcp().connected_addrs()[0]).await.unwrap();\n-            } else {\n-                peer.node().disconnect(peer.node().connected_addrs()[0]).await;\n+macro_rules! test_reject_unsolicited_peer_response {\n+    ($($node_type:ident),*) => {\n+        $(\n+            paste! {\n+                #[tokio::test]\n+                async fn [<$node_type _rejects_unsolicited_peer_response>]() {\n+                    // Spin up a full node.\n+                    let node = $crate::common::node::$node_type().await;\n+\n+                    // Spin up a test peer (synthetic node), it doesn't really matter what type it is.\n+                    let peer = TestPeer::validator().await;\n+                    let peer_addr = peer.node().listening_addr().unwrap();\n+\n+                    // Connect the node to the test peer.\n+                    node.router().connect(peer_addr).unwrap().await.unwrap();\n+\n+                    // Check the peer counts.\n+                    let node_clone = node.clone();\n+                    deadline!(Duration::from_secs(5), move || node_clone.router().number_of_connected_peers() == 1);\n+                    let node_clone = node.clone();\n+                    deadline!(Duration::from_secs(5), move || node_clone.tcp().num_connected() == 1);\n+                    let peer_clone = peer.clone();\n+                    deadline!(Duration::from_secs(5), move || peer_clone.node().num_connected() == 1);\n+\n+                    // Check the candidate peers.\n+                    assert_eq!(node.router().number_of_candidate_peers(), 0);\n+\n+                    let peers = vec![\"1.1.1.1:1111\".parse().unwrap(), \"2.2.2.2:2222\".parse().unwrap()];\n+\n+                    // Send a `PeerResponse` to the node.\n+                    assert!(\n+                        peer.unicast(\n+                            *peer.node().connected_addrs().first().unwrap(),\n+                            Message::PeerResponse(PeerResponse { peers: peers.clone() })\n+                        )\n+                        .is_ok()\n+                    );\n+\n+                    // Wait for the peer to be disconnected for a protocol violation.\n+                    let node_clone = node.clone();\n+                    deadline!(Duration::from_secs(5), move || node_clone.router().number_of_connected_peers() == 0);\n+\n+                    // Make sure the sent addresses weren't inserted in the candidate peers.\n+                    for peer in peers {\n+                        assert!(!node.router().candidate_peers().contains(&peer));\n+                    }\n+                }\n             }\n-\n-            // Check the peer counts have been updated.\n-            let node_clone = node.clone();\n-            deadline!(Duration::from_secs(5), move || node_clone.router().number_of_connected_peers() == 0);\n-            deadline!(Duration::from_secs(5), move || node.tcp().num_connected() == 0);\n-            deadline!(Duration::from_secs(5), move || peer.node().num_connected() == 0);\n-\n-        }\n-    };\n-\n-    // Node side disconnect.\n-    ($($node_type:ident |> $peer_type:ident $(= $attr:meta)?),*) => {\n-        mod disconnect_node_side {\n-            $(\n-                test_disconnect!($node_type, $peer_type, true, $($attr)?);\n-            )*\n-        }\n+        )*\n     };\n-\n-    // Peer side disconnect.\n-    ($($node_type:ident <| $peer_type:ident $(= $attr:meta)?),*) => {\n-        mod disconnect_peer_side {\n-            $(\n-                test_disconnect!($node_type, $peer_type, false, $($attr)?);\n-            )*\n-        }\n-    };\n-}\n-\n-mod client {\n-    // Full node disconnects from synthetic peer.\n-    test_disconnect! {\n-        client |> client,\n-        client |> validator,\n-        client |> prover\n-    }\n-\n-    // Synthetic peer disconnects from the full node.\n-    test_disconnect! {\n-        client <| client,\n-        client <| validator,\n-        client <| prover\n-    }\n-}\n-\n-mod prover {\n-    // Full node disconnects from synthetic peer.\n-    test_disconnect! {\n-        prover |> client,\n-        prover |> validator,\n-        prover |> prover\n-    }\n-\n-    // Synthetic peer disconnects from the full node.\n-    test_disconnect! {\n-        prover <| client,\n-        prover <| validator,\n-        prover <| prover\n-    }\n }\n \n-mod validator {\n-    // Full node disconnects from synthetic peer.\n-    test_disconnect! {\n-        validator |> client,\n-        validator |> validator,\n-        validator |> prover\n-    }\n-\n-    // Synthetic peer disconnects from the full node.\n-    test_disconnect! {\n-        validator <| client,\n-        validator <| validator,\n-        validator <| prover\n-    }\n-}\n-\n-#[tokio::test(flavor = \"multi_thread\")]\n-async fn duplicate_disconnect_attempts() {\n-    // common::initialise_logger(3);\n-\n-    // Spin up 2 full nodes.\n-    let node1 = validator().await;\n-    let node2 = validator().await;\n-    let addr2 = node2.tcp().listening_addr().unwrap();\n-\n-    // Connect node1 to node2.\n-    assert!(node1.router().connect(addr2).unwrap().await.unwrap());\n-\n-    // Prepare disconnect attempts.\n-    let node1_clone = node1.clone();\n-    let disconn1 = tokio::spawn(async move { node1_clone.router().disconnect(addr2).await.unwrap() });\n-    let node1_clone = node1.clone();\n-    let disconn2 = tokio::spawn(async move { node1_clone.router().disconnect(addr2).await.unwrap() });\n-    let node1_clone = node1.clone();\n-    let disconn3 = tokio::spawn(async move { node1_clone.router().disconnect(addr2).await.unwrap() });\n-\n-    // Attempt to disconnect the 1st node from the other one several times at once.\n-    let (result1, result2, result3) = tokio::join!(disconn1, disconn2, disconn3);\n-    // A small anti-flakiness buffer.\n-\n-    // Count the successes.\n-    let mut successes = 0;\n-    if result1.unwrap() {\n-        successes += 1;\n-    }\n-    if result2.unwrap() {\n-        successes += 1;\n-    }\n-    if result3.unwrap() {\n-        successes += 1;\n-    }\n-\n-    // There may only be a single success.\n-    assert_eq!(successes, 1);\n-\n-    // Connection checks.\n-    let node1_clone = node1.clone();\n-    deadline!(Duration::from_secs(5), move || node1_clone.router().number_of_connected_peers() == 0);\n-    let node2_clone = node2.clone();\n-    deadline!(Duration::from_secs(5), move || node2_clone.router().number_of_connected_peers() == 0);\n-}\n+test_reject_unsolicited_peer_response!(client, prover, validator);\n", "problem_statement": "[Bug] A malicious peer can directly send PeerResponse to other peers with high frequency and flood network with fake peer info\n# https://hackerone.com/reports/2272999\r\n\r\n## Summary:\r\nThe  router does not check if the PeerResponse is a direct response of a previous PeerRequest  https://github.com/AleoHQ/snarkOS/blob/testnet3/node/router/src/inbound.rs#L120\r\n\r\nA malicious peer can directly send `PeerResponse` to other peers with high frequency. In this way, the other peers' `candidate_peers` will be full of malicious peer. Gradually, the good peer's connected peers are all malicious. Finally the good peers are disjoint with each oher and whole network is controlled by the malicious peers.\r\n\r\n## Steps To Reproduce:\r\n1. Clone https://github.com/AleoHQ/snarkOS and checkout `testnet3`\r\n2. Add the following code at: node/router/src/heartbeat.rs `heartbeat` function\r\n\r\n```\r\n    /// Handles the heartbeat request.\r\n    fn heartbeat(&self) {\r\n        self.safety_check_minimum_number_of_peers();\r\n        self.log_connected_peers();\r\n\r\n        //////////////////// ADD CODE HERE ////////////////////\r\n        // We can directly send PeerResponse to other peers (without previous PeerRequest). We can send PeerResponse with high frequency. Attacker can leverage this to attck the whole network.\r\n        for peer_ip in self.router().connected_peers().into_iter() {\r\n            let ip = \"1.1.1.1:111\";\r\n            let malicious_addr: SocketAddr = ip\r\n                .parse()\r\n                .expect(\"Unable to parse socket address\");\r\n            self.send(peer_ip, Message::PeerResponse( PeerResponse { peers: vec![malicious_addr; 100] }));\r\n        }\r\n        /////////////////// ADD CODE HERE ////////////////////\r\n\r\n        // Remove any stale connected peers.\r\n        self.remove_stale_connected_peers();\r\n        // Remove the oldest connected peer.\r\n       ....\r\n```\r\n3. add log at node/router/src/inbound.rs `peer_response` function\r\n\r\n```\r\n    /// Handles a `PeerResponse` message.\r\n    fn peer_response(&self, _peer_ip: SocketAddr, peers: &[SocketAddr]) -> bool {\r\n        // Filter out invalid addresses.\r\n        //////////////////// ADD LOG HERE ////////////////////\r\n        warn!(\"received peer_response {:?}\", peers);\r\n        //////////////////// ADD LOG HERE ////////////////////\r\n        let peers = peers.iter().copied().filter(|ip| self.router().is_valid_peer_ip(ip)).collect::<Vec<_>>();\r\n        // Adds the given peer IPs to the list of candidate peers.\r\n        self.router().insert_candidate_peers(&peers);\r\n        true\r\n    }\r\n```\r\n\r\n4. run ./devnet.sh\r\n5. check log, we will find something like\r\n```\r\nWARN received peer_response [1.1.1.1:111, 1.1.1.1:111, 1.1.1.1:111, 1.1.1.1:111\r\n```\r\n\r\n6. Attack success: Though the good peer haven't made `PeerRequest`, it received malicious `PeerResponse`.\r\n\r\n## Proof-of-Concept (PoC)\r\n\r\nHow this bug can be exploited:\r\n\r\n1. The malicious peer starts sending a high frequency of PeerResponse messages directly to other peers. The PeerResponse messages contain information about the other peers which are all controlled by the hacker.\r\n\r\n2. The other peers receive these PeerResponse messages and update their candidate_peers list with the information provided by the malicious peer.\r\n\r\n3. Due to the high frequency of messages and the continuous updates, the candidate_peers list of the other peers becomes populated mainly or entirely with malicious peer entries.\r\n\r\n4. As the good peers' candidate_peers list becomes filled with malicious peers, the chances of connecting to other good peers decrease significantly.\r\n\r\n5. Over time, the good peers' connections are predominated by malicious peers, reducing the opportunities for good peers to communicate with each other.\r\n\r\n6. Eventually, the good peers become disjointed from each other, as their connections are primarily with malicious peers.\r\n\r\n7. With the network effectively controlled by malicious peers, they can manipulate communication, block transactions, tamper with data, or perform other malicious activities without detection or intervention from the good peers.\r\n\r\n## Supporting Material/References:\r\n![screenshot-20231205-014632](https://github.com/AleoHQ/snarkOS/assets/136848162/7d8779a0-1f1d-450f-abd4-c3892a7733e3)\r\n\r\n## Impact\r\n\r\nThis bug have signigicant impact on all kinds of node: Prover, Validator and Client. The bug allows a malicious peer to flood the network with fake peer information, causing good peers to connect primarily with malicious peers. This gives the malicious peer control over the network and disrupts communication among the good peers. The malicious peers can tamper with transactions, manipulate data, and potentially launch further attacks. This undermines trust in the network and compromises its security and reliability.\r\n\r\n## Fix Suggestions:\r\n\r\nIn the short term, verify every `PeerResponse ` is a real response of `PeerRequest`. In the middle or long term, consider formulating specification about the network layer. Also, consider using battle tested framework like `devp2p` and `libp2p`.\n", "hints_text": "", "created_at": "2023-12-07T20:12:09Z", "version": "2.2"}, {"repo": "AleoNet/snarkOS", "pull_number": 2221, "instance_id": "AleoNet__snarkOS-2221", "issue_numbers": ["2149"], "base_commit": "05e50dd0de11d06b93a31e979c78fb1d9942e181", "patch": "diff --git a/node/messages/src/challenge_request.rs b/node/messages/src/challenge_request.rs\nindex eaf86a7b3f..35fa4497aa 100644\n--- a/node/messages/src/challenge_request.rs\n+++ b/node/messages/src/challenge_request.rs\n@@ -48,3 +48,9 @@ impl<N: Network> MessageTrait for ChallengeRequest<N> {\n         Ok(Self { version, listener_port, node_type, address, nonce })\n     }\n }\n+\n+impl<N: Network> ChallengeRequest<N> {\n+    pub fn new(listener_port: u16, node_type: NodeType, address: Address<N>, nonce: u64) -> Self {\n+        Self { version: Message::<N>::VERSION, listener_port, node_type, address, nonce }\n+    }\n+}\ndiff --git a/node/messages/src/helpers/codec.rs b/node/messages/src/helpers/codec.rs\nindex 83a6a9bd22..eedf3e26e5 100644\n--- a/node/messages/src/helpers/codec.rs\n+++ b/node/messages/src/helpers/codec.rs\n@@ -21,6 +21,9 @@ use ::bytes::{BufMut, BytesMut};\n use core::marker::PhantomData;\n use tokio_util::codec::{Decoder, Encoder, LengthDelimitedCodec};\n \n+/// The maximum size of a message that can be transmitted during the handshake.\n+const MAXIMUM_HANDSHAKE_MESSAGE_SIZE: usize = 1024 * 1024; // 1 MiB\n+\n /// The maximum size of a message that can be transmitted in the network.\n const MAXIMUM_MESSAGE_SIZE: usize = 128 * 1024 * 1024; // 128 MiB\n \n@@ -30,10 +33,20 @@ pub struct MessageCodec<N: Network> {\n     _phantom: PhantomData<N>,\n }\n \n+impl<N: Network> MessageCodec<N> {\n+    /// Increases the maximum permitted message size post-handshake.\n+    pub fn update_max_message_len(&mut self) {\n+        self.codec = LengthDelimitedCodec::builder().max_frame_length(MAXIMUM_MESSAGE_SIZE).little_endian().new_codec();\n+    }\n+}\n+\n impl<N: Network> Default for MessageCodec<N> {\n     fn default() -> Self {\n         Self {\n-            codec: LengthDelimitedCodec::builder().max_frame_length(MAXIMUM_MESSAGE_SIZE).little_endian().new_codec(),\n+            codec: LengthDelimitedCodec::builder()\n+                .max_frame_length(MAXIMUM_HANDSHAKE_MESSAGE_SIZE)\n+                .little_endian()\n+                .new_codec(),\n             _phantom: Default::default(),\n         }\n     }\ndiff --git a/node/router/src/handshake.rs b/node/router/src/handshake.rs\nindex fc473495b4..773fbb783a 100644\n--- a/node/router/src/handshake.rs\n+++ b/node/router/src/handshake.rs\n@@ -43,8 +43,40 @@ impl<N: Network> P2P for Router<N> {\n     }\n }\n \n+/// A macro unwrapping the expected handshake message or returning an error for unexpected messages.\n+#[macro_export]\n+macro_rules! expect_message {\n+    ($msg_ty:path, $framed:expr, $peer_addr:expr) => {\n+        match $framed.try_next().await? {\n+            // Received the expected message, proceed.\n+            Some($msg_ty(data)) => {\n+                trace!(\"Received '{}' from '{}'\", data.name(), $peer_addr);\n+                data\n+            }\n+            // Received a disconnect message, abort.\n+            Some(Message::Disconnect(reason)) => {\n+                return Err(error(format!(\"'{}' disconnected: {reason:?}\", $peer_addr)))\n+            }\n+            // Received an unexpected message, abort.\n+            _ => return Err(error(format!(\"'{}' did not follow the handshake protocol\", $peer_addr))),\n+        }\n+    };\n+}\n+\n+/// A macro for cutting a handshake short if message verification fails.\n+#[macro_export]\n+macro_rules! handle_verification {\n+    ($result:expr, $framed:expr, $peer_addr:expr) => {\n+        if let Some(reason) = $result {\n+            trace!(\"Sending 'Disconnect' to '{}'\", $peer_addr);\n+            $framed.send(Message::Disconnect(Disconnect { reason: reason.clone() })).await?;\n+            return Err(error(format!(\"Dropped '{}' for reason: {reason:?}\", $peer_addr)));\n+        }\n+    };\n+}\n+\n impl<N: Network> Router<N> {\n-    /// Performs the handshake protocol.\n+    /// Executes the handshake protocol.\n     pub async fn handshake<'a>(\n         &'a self,\n         peer_addr: SocketAddr,\n@@ -58,133 +90,162 @@ impl<N: Network> Router<N> {\n             debug!(\"Received a connection request from '{peer_addr}'\");\n             None\n         } else {\n+            debug!(\"Connecting to {peer_addr}...\");\n             Some(peer_addr)\n         };\n \n         // Perform the handshake; we pass on a mutable reference to peer_ip in case the process is broken at any point in time.\n-        let handshake_result = self.handshake_inner(peer_addr, &mut peer_ip, stream, peer_side, genesis_header).await;\n+        let mut handshake_result = if peer_side == ConnectionSide::Responder {\n+            self.handshake_inner_initiator(peer_addr, &mut peer_ip, stream, genesis_header).await\n+        } else {\n+            self.handshake_inner_responder(peer_addr, &mut peer_ip, stream, genesis_header).await\n+        };\n \n         // Remove the address from the collection of connecting peers (if the handshake got to the point where it's known).\n         if let Some(ip) = peer_ip {\n             self.connecting_peers.lock().remove(&ip);\n         }\n \n+        // If the handshake succeeded, announce it and increase the message size limit.\n+        if let Ok((ref peer_ip, ref mut framed)) = handshake_result {\n+            info!(\"Connected to '{peer_ip}'\");\n+            framed.codec_mut().update_max_message_len();\n+        }\n+\n         handshake_result\n     }\n \n-    /// A helper that facilitates some extra error handling in `Router::handshake`.\n-    async fn handshake_inner<'a>(\n+    /// The connection initiator side of the handshake.\n+    async fn handshake_inner_initiator<'a>(\n         &'a self,\n         peer_addr: SocketAddr,\n         peer_ip: &mut Option<SocketAddr>,\n         stream: &'a mut TcpStream,\n-        peer_side: ConnectionSide,\n         genesis_header: Header<N>,\n     ) -> io::Result<(SocketAddr, Framed<&mut TcpStream, MessageCodec<N>>)> {\n         // Construct the stream.\n         let mut framed = Framed::new(stream, MessageCodec::<N>::default());\n \n+        // This value is immediately guaranteed to be present, so it can be unwrapped.\n+        let peer_ip = peer_ip.unwrap();\n+\n         /* Step 1: Send the challenge request. */\n \n         // Initialize an RNG.\n         let rng = &mut OsRng;\n         // Sample a random nonce.\n-        let nonce_a = rng.gen();\n+        let our_nonce = rng.gen();\n \n         // Send a challenge request to the peer.\n-        let message_a = Message::<N>::ChallengeRequest(ChallengeRequest {\n-            version: Message::<N>::VERSION,\n-            listener_port: self.local_ip().port(),\n-            node_type: self.node_type,\n-            address: self.address(),\n-            nonce: nonce_a,\n-        });\n-        trace!(\"Sending '{}-A' to '{peer_addr}'\", message_a.name());\n-        framed.send(message_a).await?;\n-\n-        /* Step 2: Receive the challenge request. */\n+        let our_request = ChallengeRequest::new(self.local_ip().port(), self.node_type, self.address(), our_nonce);\n+        trace!(\"Sending '{}' to '{peer_addr}'\", our_request.name());\n+        framed.send(Message::ChallengeRequest(our_request)).await?;\n+\n+        /* Step 2: Receive the peer's challenge response followed by the challenge request. */\n+\n+        // Listen for the challenge response message.\n+        let peer_response = expect_message!(Message::ChallengeResponse, framed, peer_addr);\n \n         // Listen for the challenge request message.\n-        let request_b = match framed.try_next().await? {\n-            // Received the challenge request message, proceed.\n-            Some(Message::ChallengeRequest(data)) => data,\n-            // Received a disconnect message, abort.\n-            Some(Message::Disconnect(reason)) => return Err(error(format!(\"'{peer_addr}' disconnected: {reason:?}\"))),\n-            // Received an unexpected message, abort.\n-            _ => return Err(error(format!(\"'{peer_addr}' did not send a challenge request\"))),\n-        };\n-        trace!(\"Received '{}-B' from '{peer_addr}'\", request_b.name());\n+        let peer_request = expect_message!(Message::ChallengeRequest, framed, peer_addr);\n \n-        // Obtain the peer's listening address if it's an inbound connection.\n-        if peer_ip.is_none() {\n-            *peer_ip = Some(SocketAddr::new(peer_addr.ip(), request_b.listener_port));\n-        }\n+        // Verify the challenge response. If a disconnect reason was returned, send the disconnect message and abort.\n+        handle_verification!(\n+            self.verify_challenge_response(peer_addr, peer_request.address, peer_response, genesis_header, our_nonce)\n+                .await,\n+            framed,\n+            peer_addr\n+        );\n+\n+        // Verify the challenge request. If a disconnect reason was returned, send the disconnect message and abort.\n+        handle_verification!(self.verify_challenge_request(peer_addr, &peer_request), framed, peer_addr);\n+\n+        /* Step 3: Send the challenge response. */\n+\n+        // Sign the counterparty nonce.\n+        let our_signature = self\n+            .account\n+            .sign_bytes(&peer_request.nonce.to_le_bytes(), rng)\n+            .map_err(|_| error(format!(\"Failed to sign the challenge request nonce from '{peer_addr}'\")))?;\n+\n+        // Send the challenge response.\n+        let our_response = ChallengeResponse { genesis_header, signature: Data::Object(our_signature) };\n+        trace!(\"Sending '{}' to '{peer_addr}'\", our_response.name());\n+        framed.send(Message::ChallengeResponse(our_response)).await?;\n+\n+        // Add the peer to the router.\n+        self.insert_connected_peer(Peer::new(peer_ip, &peer_request), peer_addr);\n+\n+        Ok((peer_ip, framed))\n+    }\n+\n+    /// The connection responder side of the handshake.\n+    async fn handshake_inner_responder<'a>(\n+        &'a self,\n+        peer_addr: SocketAddr,\n+        peer_ip: &mut Option<SocketAddr>,\n+        stream: &'a mut TcpStream,\n+        genesis_header: Header<N>,\n+    ) -> io::Result<(SocketAddr, Framed<&mut TcpStream, MessageCodec<N>>)> {\n+        // Construct the stream.\n+        let mut framed = Framed::new(stream, MessageCodec::<N>::default());\n+\n+        /* Step 1: Receive the challenge request. */\n+\n+        // Listen for the challenge request message.\n+        let peer_request = expect_message!(Message::ChallengeRequest, framed, peer_addr);\n \n-        // This value is now guaranteed to be present, so it can be unwrapped.\n+        // Obtain the peer's listening address.\n+        *peer_ip = Some(SocketAddr::new(peer_addr.ip(), peer_request.listener_port));\n         let peer_ip = peer_ip.unwrap();\n \n         // Knowing the peer's listening address, ensure it is allowed to connect.\n-        if peer_side == ConnectionSide::Initiator {\n-            if let Err(forbidden_message) = self.ensure_peer_is_allowed(peer_ip) {\n-                return Err(error(format!(\"{forbidden_message}\")));\n-            }\n+        if let Err(forbidden_message) = self.ensure_peer_is_allowed(peer_ip) {\n+            return Err(error(format!(\"{forbidden_message}\")));\n         }\n \n         // Verify the challenge request. If a disconnect reason was returned, send the disconnect message and abort.\n-        if let Some(reason) = self.verify_challenge_request(peer_addr, &request_b) {\n-            trace!(\"Sending 'Disconnect' to '{peer_addr}'\");\n-            framed.send(Message::Disconnect(Disconnect { reason: reason.clone() })).await?;\n-            return Err(error(format!(\"Dropped '{peer_addr}' for reason: {reason:?}\")));\n-        }\n+        handle_verification!(self.verify_challenge_request(peer_addr, &peer_request), framed, peer_addr);\n \n-        /* Step 3: Send the challenge response. */\n+        /* Step 2: Send the challenge response followed by own challenge request. */\n+\n+        // Initialize an RNG.\n+        let rng = &mut OsRng;\n \n         // Sign the counterparty nonce.\n-        let signature_b = self\n+        let our_signature = self\n             .account\n-            .sign_bytes(&request_b.nonce.to_le_bytes(), rng)\n+            .sign_bytes(&peer_request.nonce.to_le_bytes(), rng)\n             .map_err(|_| error(format!(\"Failed to sign the challenge request nonce from '{peer_addr}'\")))?;\n \n+        // Sample a random nonce.\n+        let our_nonce = rng.gen();\n+\n         // Send the challenge response.\n-        let message_b =\n-            Message::ChallengeResponse(ChallengeResponse { genesis_header, signature: Data::Object(signature_b) });\n-        trace!(\"Sending '{}-B' to '{peer_addr}'\", message_b.name());\n-        framed.send(message_b).await?;\n+        let our_response = ChallengeResponse { genesis_header, signature: Data::Object(our_signature) };\n+        trace!(\"Sending '{}' to '{peer_addr}'\", our_response.name());\n+        framed.send(Message::ChallengeResponse(our_response)).await?;\n+\n+        // Send the challenge request.\n+        let our_request = ChallengeRequest::new(self.local_ip().port(), self.node_type, self.address(), our_nonce);\n+        trace!(\"Sending '{}' to '{peer_addr}'\", our_request.name());\n+        framed.send(Message::ChallengeRequest(our_request)).await?;\n \n-        /* Step 4: Receive the challenge response. */\n+        /* Step 3: Receive the challenge response. */\n \n         // Listen for the challenge response message.\n-        let response_a = match framed.try_next().await? {\n-            // Received the challenge response message, proceed.\n-            Some(Message::ChallengeResponse(data)) => data,\n-            // Received a disconnect message, abort.\n-            Some(Message::Disconnect(reason)) => return Err(error(format!(\"'{peer_addr}' disconnected: {reason:?}\"))),\n-            // Received an unexpected message, abort.\n-            _ => return Err(error(format!(\"'{peer_addr}' did not send a challenge response\"))),\n-        };\n-        trace!(\"Received '{}-A' from '{peer_addr}'\", response_a.name());\n+        let peer_response = expect_message!(Message::ChallengeResponse, framed, peer_addr);\n \n         // Verify the challenge response. If a disconnect reason was returned, send the disconnect message and abort.\n-        if let Some(reason) =\n-            self.verify_challenge_response(peer_addr, request_b.address, response_a, genesis_header, nonce_a).await\n-        {\n-            trace!(\"Sending 'Disconnect' to '{peer_addr}'\");\n-            framed.send(Message::Disconnect(Disconnect { reason: reason.clone() })).await?;\n-            return Err(error(format!(\"Dropped '{peer_addr}' for reason: {reason:?}\")));\n-        }\n-\n-        /* Step 5: Add the peer to the router. */\n-\n-        // Prepare the peer.\n-        let peer_address = request_b.address;\n-        let peer_type = request_b.node_type;\n-        let peer_version = request_b.version;\n-\n-        // Construct the peer.\n-        let peer = Peer::new(peer_ip, peer_address, peer_type, peer_version);\n-        // Insert the connected peer in the router.\n-        self.insert_connected_peer(peer, peer_addr);\n-        info!(\"Connected to '{peer_ip}'\");\n+        handle_verification!(\n+            self.verify_challenge_response(peer_addr, peer_request.address, peer_response, genesis_header, our_nonce)\n+                .await,\n+            framed,\n+            peer_addr\n+        );\n+\n+        // Add the peer to the router.\n+        self.insert_connected_peer(Peer::new(peer_ip, &peer_request), peer_addr);\n \n         Ok((peer_ip, framed))\n     }\ndiff --git a/node/router/src/helpers/peer.rs b/node/router/src/helpers/peer.rs\nindex f0d1d8e496..29016539cc 100644\n--- a/node/router/src/helpers/peer.rs\n+++ b/node/router/src/helpers/peer.rs\n@@ -14,7 +14,7 @@\n // You should have received a copy of the GNU General Public License\n // along with the snarkOS library. If not, see <https://www.gnu.org/licenses/>.\n \n-use snarkos_node_messages::NodeType;\n+use snarkos_node_messages::{ChallengeRequest, NodeType};\n use snarkvm::prelude::{Address, Network};\n \n use parking_lot::RwLock;\n@@ -39,12 +39,12 @@ pub struct Peer<N: Network> {\n \n impl<N: Network> Peer<N> {\n     /// Initializes a new instance of `Peer`.\n-    pub fn new(listening_ip: SocketAddr, address: Address<N>, node_type: NodeType, version: u32) -> Self {\n+    pub fn new(listening_ip: SocketAddr, challenge_request: &ChallengeRequest<N>) -> Self {\n         Self {\n             peer_ip: listening_ip,\n-            address,\n-            node_type,\n-            version,\n+            address: challenge_request.address,\n+            node_type: challenge_request.node_type,\n+            version: challenge_request.version,\n             first_seen: Instant::now(),\n             last_seen: Arc::new(RwLock::new(Instant::now())),\n         }\ndiff --git a/node/router/src/lib.rs b/node/router/src/lib.rs\nindex fe657336db..9473e0646c 100644\n--- a/node/router/src/lib.rs\n+++ b/node/router/src/lib.rs\n@@ -145,7 +145,6 @@ impl<N: Network> Router<N> {\n         let router = self.clone();\n         tokio::spawn(async move {\n             // Attempt to connect to the candidate peer.\n-            debug!(\"Connecting to {peer_ip}...\");\n             match router.tcp.connect(peer_ip).await {\n                 // Remove the peer from the candidate peers.\n                 Ok(()) => router.remove_candidate_peer(peer_ip),\n", "test_patch": "diff --git a/node/router/tests/connect.rs b/node/router/tests/connect.rs\nindex f5db28463a..f3793dca0b 100644\n--- a/node/router/tests/connect.rs\n+++ b/node/router/tests/connect.rs\n@@ -23,8 +23,6 @@ use core::time::Duration;\n \n #[tokio::test]\n async fn test_connect_without_handshake() {\n-    initialize_logger(3);\n-\n     // Create 2 routers.\n     let node0 = validator(0, 2).await;\n     let node1 = client(0, 2).await;\n@@ -81,8 +79,6 @@ async fn test_connect_without_handshake() {\n \n #[tokio::test]\n async fn test_connect_with_handshake() {\n-    initialize_logger(3);\n-\n     // Create 2 routers.\n     let node0 = validator(0, 2).await;\n     let node1 = client(0, 2).await;\n@@ -159,8 +155,6 @@ async fn test_connect_with_handshake() {\n #[ignore]\n #[tokio::test]\n async fn test_connect_simultaneously_with_handshake() {\n-    initialize_logger(3);\n-\n     // Create 2 routers.\n     let node0 = validator(0, 2).await;\n     let node1 = client(0, 2).await;\ndiff --git a/node/router/tests/disconnect.rs b/node/router/tests/disconnect.rs\nindex efc612c0e4..b7d07a6293 100644\n--- a/node/router/tests/disconnect.rs\n+++ b/node/router/tests/disconnect.rs\n@@ -23,8 +23,6 @@ use core::time::Duration;\n \n #[tokio::test]\n async fn test_disconnect_without_handshake() {\n-    initialize_logger(3);\n-\n     // Create 2 routers.\n     let node0 = validator(0, 1).await;\n     let node1 = client(0, 1).await;\n@@ -67,8 +65,6 @@ async fn test_disconnect_without_handshake() {\n \n #[tokio::test]\n async fn test_disconnect_with_handshake() {\n-    initialize_logger(3);\n-\n     // Create 2 routers.\n     let node0 = validator(0, 1).await;\n     let node1 = client(0, 1).await;\ndiff --git a/node/tests/common/test_peer.rs b/node/tests/common/test_peer.rs\nindex a7a24e56c5..183786b12b 100644\n--- a/node/tests/common/test_peer.rs\n+++ b/node/tests/common/test_peer.rs\n@@ -15,7 +15,8 @@\n // along with the snarkOS library. If not, see <https://www.gnu.org/licenses/>.\n \n use snarkos_account::Account;\n-use snarkos_node_messages::{ChallengeRequest, ChallengeResponse, Data, Message, MessageCodec, NodeType};\n+use snarkos_node_messages::{ChallengeRequest, ChallengeResponse, Data, Message, MessageCodec, MessageTrait, NodeType};\n+use snarkos_node_router::expect_message;\n use snarkvm::prelude::{error, Address, Block, FromBytes, Network, TestRng, Testnet3 as CurrentNetwork};\n \n use std::{\n@@ -35,6 +36,7 @@ use pea2pea::{\n };\n use rand::Rng;\n use tokio_util::codec::Framed;\n+use tracing::*;\n \n const ALEO_MAXIMUM_FORK_DEPTH: u32 = 4096;\n \n@@ -119,47 +121,49 @@ impl Handshake for TestPeer {\n \n         let local_ip = self.node().listening_addr().expect(\"listening address should be present\");\n \n+        let peer_addr = conn.addr();\n+        let node_side = !conn.side();\n         let stream = self.borrow_stream(&mut conn);\n         let mut framed = Framed::new(stream, MessageCodec::<CurrentNetwork>::default());\n \n-        // Send a challenge request to the peer.\n-        let message = Message::<CurrentNetwork>::ChallengeRequest(ChallengeRequest {\n-            version: Message::<CurrentNetwork>::VERSION,\n-            listener_port: local_ip.port(),\n-            node_type: self.node_type(),\n-            address: self.address(),\n-            nonce: rng.gen(),\n-        });\n-        framed.send(message).await?;\n-\n-        // Listen for the challenge request.\n-        let request_b = match framed.try_next().await? {\n-            // Received the challenge request message, proceed.\n-            Some(Message::ChallengeRequest(data)) => data,\n-            // Received a disconnect message, abort.\n-            Some(Message::Disconnect(reason)) => return Err(error(format!(\"disconnected: {reason:?}\"))),\n-            // Received an unexpected message, abort.\n-            _ => return Err(error(\"didn't send a challenge request\")),\n-        };\n-\n-        // TODO(nkls): add assertions on the contents.\n-\n-        // Sign the nonce.\n-        let signature = self.account().sign_bytes(&request_b.nonce.to_le_bytes(), rng).unwrap();\n-\n         // Retrieve the genesis block header.\n         let genesis_header = *sample_genesis_block().header();\n-        // Send the challenge response.\n-        let message =\n-            Message::ChallengeResponse(ChallengeResponse { genesis_header, signature: Data::Object(signature) });\n-        framed.send(message).await?;\n-\n-        // Receive the challenge response.\n-        let Message::ChallengeResponse(challenge_response) = framed.try_next().await.unwrap().unwrap() else {\n-            panic!(\"didn't get challenge response\")\n-        };\n \n-        assert_eq!(challenge_response.genesis_header, genesis_header);\n+        // TODO(nkls): add assertions on the contents of messages.\n+        match node_side {\n+            ConnectionSide::Initiator => {\n+                // Send a challenge request to the peer.\n+                let our_request = ChallengeRequest::new(local_ip.port(), self.node_type(), self.address(), rng.gen());\n+                framed.send(Message::ChallengeRequest(our_request)).await?;\n+\n+                // Receive the peer's challenge bundle.\n+                let _peer_response = expect_message!(Message::ChallengeResponse, framed, peer_addr);\n+                let peer_request = expect_message!(Message::ChallengeRequest, framed, peer_addr);\n+\n+                // Sign the nonce.\n+                let signature = self.account().sign_bytes(&peer_request.nonce.to_le_bytes(), rng).unwrap();\n+\n+                // Send the challenge response.\n+                let our_response = ChallengeResponse { genesis_header, signature: Data::Object(signature) };\n+                framed.send(Message::ChallengeResponse(our_response)).await?;\n+            }\n+            ConnectionSide::Responder => {\n+                // Listen for the challenge request.\n+                let peer_request = expect_message!(Message::ChallengeRequest, framed, peer_addr);\n+\n+                // Sign the nonce.\n+                let signature = self.account().sign_bytes(&peer_request.nonce.to_le_bytes(), rng).unwrap();\n+\n+                // Send our challenge bundle.\n+                let our_response = ChallengeResponse { genesis_header, signature: Data::Object(signature) };\n+                framed.send(Message::ChallengeResponse(our_response)).await?;\n+                let our_request = ChallengeRequest::new(local_ip.port(), self.node_type(), self.address(), rng.gen());\n+                framed.send(Message::ChallengeRequest(our_request)).await?;\n+\n+                // Listen for the challenge response.\n+                let _peer_response = expect_message!(Message::ChallengeResponse, framed, peer_addr);\n+            }\n+        }\n \n         Ok(conn)\n     }\n", "problem_statement": "Unify the `Connecting to '{peer_ip}'...` message in `Router::handshake`\nUnify the `Connecting to '{peer_ip}'...` message in `Router::handshake`.\r\n\r\n_Originally posted by @howardwu in https://github.com/AleoHQ/snarkOS/pull/2108#pullrequestreview-1203846755_\r\n      \n", "hints_text": "", "created_at": "2023-01-24T15:07:38Z", "version": "2.0"}, {"repo": "AleoNet/snarkOS", "pull_number": 1527, "instance_id": "AleoNet__snarkOS-1527", "issue_numbers": ["1522"], "base_commit": "9f0b304cb8407eec27077f212a86a79308528919", "patch": "diff --git a/Cargo.lock b/Cargo.lock\nindex beb2ebf665..e6269726b3 100644\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -220,9 +220,9 @@ dependencies = [\n \n [[package]]\n name = \"bumpalo\"\n-version = \"3.8.0\"\n+version = \"3.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8f1e260c3a9040a7c19a12468758f4c16f31a81a1fe087482be9570ec864bb6c\"\n+checksum = \"fe438c9d2f2b0fb88a112154ed81e30b0a491c29322afe1db3b6eec5811f5ba0\"\n \n [[package]]\n name = \"byteorder\"\n@@ -783,9 +783,9 @@ dependencies = [\n \n [[package]]\n name = \"generic-array\"\n-version = \"0.14.4\"\n+version = \"0.14.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"501466ecc8a30d1d3b7fc9229b122b2ce8ed6e9d9223f1138d4babb253e51817\"\n+checksum = \"fd48d33ec7f05fbfa152300fdad764757cbded343c1aa1cff2fbaf4134851803\"\n dependencies = [\n  \"typenum\",\n  \"version_check\",\n@@ -1983,7 +1983,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n dependencies = [\n  \"snarkvm-dpc\",\n  \"snarkvm-utilities\",\n@@ -1992,7 +1992,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-algorithms\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n dependencies = [\n  \"anyhow\",\n  \"blake2\",\n@@ -2021,7 +2021,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-curves\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n dependencies = [\n  \"derivative\",\n  \"rand\",\n@@ -2035,7 +2035,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-derives\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n dependencies = [\n  \"proc-macro-crate\",\n  \"proc-macro-error\",\n@@ -2047,7 +2047,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-dpc\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n dependencies = [\n  \"anyhow\",\n  \"base58\",\n@@ -2079,7 +2079,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-fields\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n dependencies = [\n  \"anyhow\",\n  \"derivative\",\n@@ -2092,7 +2092,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-gadgets\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n dependencies = [\n  \"anyhow\",\n  \"derivative\",\n@@ -2112,7 +2112,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-marlin\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n dependencies = [\n  \"bincode\",\n  \"blake2\",\n@@ -2138,7 +2138,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-parameters\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n dependencies = [\n  \"aleo-std\",\n  \"anyhow\",\n@@ -2155,7 +2155,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-polycommit\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n dependencies = [\n  \"derivative\",\n  \"digest 0.9.0\",\n@@ -2173,12 +2173,12 @@ dependencies = [\n [[package]]\n name = \"snarkvm-profiler\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n \n [[package]]\n name = \"snarkvm-r1cs\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n dependencies = [\n  \"anyhow\",\n  \"cfg-if\",\n@@ -2194,7 +2194,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-utilities\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=ff10c20#ff10c20512bb7f7853bf8c3f308d951e78a02290\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=459ea96#459ea966476e73b3c5296bf34ef508e0e7bcf547\"\n dependencies = [\n  \"anyhow\",\n  \"bincode\",\ndiff --git a/Cargo.toml b/Cargo.toml\nindex e78e12b054..02387aacab 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -24,7 +24,7 @@ default = []\n test = []\n \n [dependencies]\n-snarkvm = { git = \"https://github.com/AleoHQ/snarkVM.git\", rev = \"ff10c20\" }\n+snarkvm = { git = \"https://github.com/AleoHQ/snarkVM.git\", rev = \"459ea96\" }\n #snarkvm = { path = \"../snarkVM\" }\n \n bytes = \"1.0.0\"\ndiff --git a/src/environment/mod.rs b/src/environment/mod.rs\nindex 621b350a7f..093ea7841e 100644\n--- a/src/environment/mod.rs\n+++ b/src/environment/mod.rs\n@@ -19,8 +19,10 @@ use snarkvm::dpc::Network;\n \n use once_cell::sync::OnceCell;\n use std::{\n+    collections::HashSet,\n     fmt::Debug,\n     marker::PhantomData,\n+    net::SocketAddr,\n     sync::{atomic::AtomicBool, Arc},\n };\n \n@@ -40,9 +42,9 @@ pub trait Environment: 'static + Clone + Debug + Default + Send + Sync {\n     const DEFAULT_RPC_PORT: u16 = 3030 + Self::Network::NETWORK_ID;\n \n     /// The list of beacon nodes to bootstrap the node server with.\n-    const BEACON_NODES: [&'static str; 0] = [];\n+    const BEACON_NODES: &'static [&'static str] = &[];\n     /// The list of sync nodes to bootstrap the node server with.\n-    const SYNC_NODES: [&'static str; 13] = [\"127.0.0.1:4131\", \"127.0.0.1:4133\", \"127.0.0.1:4134\", \"127.0.0.1:4135\", \"127.0.0.1:4136\", \"127.0.0.1:4137\", \"127.0.0.1:4138\", \"127.0.0.1:4139\", \"127.0.0.1:4140\", \"127.0.0.1:4141\", \"127.0.0.1:4142\", \"127.0.0.1:4143\", \"127.0.0.1:4144\"];\n+    const SYNC_NODES: &'static [&'static str] = &[\"127.0.0.1:4135\"];\n \n     /// The duration in seconds to sleep in between heartbeat executions.\n     const HEARTBEAT_IN_SECS: u64 = 9;\n@@ -73,6 +75,18 @@ pub trait Environment: 'static + Clone + Debug + Default + Send + Sync {\n     /// The maximum number of failures tolerated before disconnecting from a peer.\n     const MAXIMUM_NUMBER_OF_FAILURES: usize = 1024;\n \n+    /// Returns the list of beacon nodes to bootstrap the node server with.\n+    fn beacon_nodes() -> &'static HashSet<SocketAddr> {\n+        static NODES: OnceCell<HashSet<SocketAddr>> = OnceCell::new();\n+        NODES.get_or_init(|| Self::BEACON_NODES.iter().map(|ip| ip.parse().unwrap()).collect())\n+    }\n+\n+    /// Returns the list of sync nodes to bootstrap the node server with.\n+    fn sync_nodes() -> &'static HashSet<SocketAddr> {\n+        static NODES: OnceCell<HashSet<SocketAddr>> = OnceCell::new();\n+        NODES.get_or_init(|| Self::SYNC_NODES.iter().map(|ip| ip.parse().unwrap()).collect())\n+    }\n+    \n     /// Returns the tasks handler for the node.\n     fn tasks() -> &'static Tasks<tokio::task::JoinHandle<()>> {\n         static TASKS: OnceCell<Tasks<tokio::task::JoinHandle<()>>> = OnceCell::new();\n@@ -135,7 +149,7 @@ impl<N: Network> Environment for Prover<N> {\n     type Network = N;\n     const NODE_TYPE: NodeType = NodeType::Prover;\n     const COINBASE_IS_PUBLIC: bool = true;\n-    const MINIMUM_NUMBER_OF_PEERS: usize = 1;\n+    const MINIMUM_NUMBER_OF_PEERS: usize = 2;\n     const MAXIMUM_NUMBER_OF_PEERS: usize = 21;\n }\n \n@@ -158,7 +172,7 @@ pub struct ClientTrial<N: Network>(PhantomData<N>);\n impl<N: Network> Environment for ClientTrial<N> {\n     type Network = N;\n     const NODE_TYPE: NodeType = NodeType::Client;\n-    const SYNC_NODES: [&'static str; 13] = [\n+    const SYNC_NODES: &'static [&'static str] = &[\n         \"144.126.219.193:4132\", \"165.232.145.194:4132\", \"143.198.164.241:4132\", \"188.166.7.13:4132\", \"167.99.40.226:4132\",\n         \"159.223.124.150:4132\", \"137.184.192.155:4132\", \"147.182.213.228:4132\", \"137.184.202.162:4132\", \"159.223.118.35:4132\",\n         \"161.35.106.91:4132\", \"157.245.133.62:4132\", \"143.198.166.150:4132\",\n@@ -174,7 +188,7 @@ pub struct MinerTrial<N: Network>(PhantomData<N>);\n impl<N: Network> Environment for MinerTrial<N> {\n     type Network = N;\n     const NODE_TYPE: NodeType = NodeType::Miner;\n-    const SYNC_NODES: [&'static str; 13] = [\n+    const SYNC_NODES: &'static [&'static str] = &[\n         \"144.126.219.193:4132\", \"165.232.145.194:4132\", \"143.198.164.241:4132\", \"188.166.7.13:4132\", \"167.99.40.226:4132\",\n         \"159.223.124.150:4132\", \"137.184.192.155:4132\", \"147.182.213.228:4132\", \"137.184.202.162:4132\", \"159.223.118.35:4132\",\n         \"161.35.106.91:4132\", \"157.245.133.62:4132\", \"143.198.166.150:4132\",\n@@ -191,7 +205,7 @@ pub struct OperatorTrial<N: Network>(PhantomData<N>);\n impl<N: Network> Environment for OperatorTrial<N> {\n     type Network = N;\n     const NODE_TYPE: NodeType = NodeType::Operator;\n-    const SYNC_NODES: [&'static str; 13] = [\n+    const SYNC_NODES: &'static [&'static str] = &[\n         \"144.126.219.193:4132\", \"165.232.145.194:4132\", \"143.198.164.241:4132\", \"188.166.7.13:4132\", \"167.99.40.226:4132\",\n         \"159.223.124.150:4132\", \"137.184.192.155:4132\", \"147.182.213.228:4132\", \"137.184.202.162:4132\", \"159.223.118.35:4132\",\n         \"161.35.106.91:4132\", \"157.245.133.62:4132\", \"143.198.166.150:4132\",\n@@ -208,7 +222,7 @@ pub struct ProverTrial<N: Network>(PhantomData<N>);\n impl<N: Network> Environment for ProverTrial<N> {\n     type Network = N;\n     const NODE_TYPE: NodeType = NodeType::Prover;\n-    const SYNC_NODES: [&'static str; 13] = [\n+    const SYNC_NODES: &'static [&'static str] = &[\n         \"144.126.219.193:4132\", \"165.232.145.194:4132\", \"143.198.164.241:4132\", \"188.166.7.13:4132\", \"167.99.40.226:4132\",\n         \"159.223.124.150:4132\", \"137.184.192.155:4132\", \"147.182.213.228:4132\", \"137.184.202.162:4132\", \"159.223.118.35:4132\",\n         \"161.35.106.91:4132\", \"157.245.133.62:4132\", \"143.198.166.150:4132\",\ndiff --git a/src/helpers/block_requests.rs b/src/helpers/block_requests.rs\nindex b9d3297b4a..4e1a954eb7 100644\n--- a/src/helpers/block_requests.rs\n+++ b/src/helpers/block_requests.rs\n@@ -18,7 +18,7 @@ use crate::{network::ledger::PeersState, Environment};\n use snarkos_storage::{BlockLocators, LedgerState};\n use snarkvm::dpc::prelude::*;\n \n-use std::{collections::HashSet, net::SocketAddr};\n+use std::net::SocketAddr;\n \n /// Checks if any of the peers are ahead and have a larger block height, if they are on a fork, and their block locators.\n /// The maximum known block height and cumulative weight are tracked for the purposes of further operations.\n@@ -27,8 +27,6 @@ pub fn find_maximal_peer<N: Network, E: Environment>(\n     maximum_block_height: &mut u32,\n     maximum_cumulative_weight: &mut u128,\n ) -> Option<(SocketAddr, bool, BlockLocators<N>)> {\n-    let sync_nodes: HashSet<SocketAddr> = E::SYNC_NODES.iter().map(|ip| ip.parse().unwrap()).collect();\n-\n     // Determine if the peers state has any sync nodes.\n     // TODO: have nodes sync up to tip - 4096 with only sync nodes, then switch to syncing with the longest chain.\n     let peers_contains_sync_node = false;\n@@ -40,7 +38,7 @@ pub fn find_maximal_peer<N: Network, E: Environment>(\n \n     for (peer_ip, peer_state) in peers_state.iter() {\n         // Only update the maximal peer if there are no sync nodes or the peer is a sync node.\n-        if !peers_contains_sync_node || sync_nodes.contains(peer_ip) {\n+        if !peers_contains_sync_node || E::sync_nodes().contains(peer_ip) {\n             // Update the maximal peer state if the peer is ahead and the peer knows if you are a fork or not.\n             // This accounts for (Case 1 and Case 2(a))\n             if let Some((_, _, is_on_fork, block_height, block_locators)) = peer_state {\ndiff --git a/src/network/message.rs b/src/network/message.rs\nindex be4c8c801a..a1837cb96e 100644\n--- a/src/network/message.rs\n+++ b/src/network/message.rs\n@@ -19,7 +19,7 @@ use crate::{\n     Environment,\n };\n use snarkos_storage::BlockLocators;\n-use snarkvm::prelude::*;\n+use snarkvm::{dpc::posw::PoSWProof, prelude::*};\n \n use ::bytes::{Buf, BytesMut};\n use anyhow::{anyhow, Result};\n@@ -106,8 +106,8 @@ pub enum Message<N: Network, E: Environment> {\n     PoolRegister(Address<N>),\n     /// PoolRequest := (share_difficulty, block_template)\n     PoolRequest(u64, Data<BlockTemplate<N>>),\n-    /// PoolResponse := (address, block_header)\n-    PoolResponse(Address<N>, Data<BlockHeader<N>>),\n+    /// PoolResponse := (address, nonce, proof)\n+    PoolResponse(Address<N>, N::PoSWNonce, Data<PoSWProof<N>>),\n     /// Unused\n     #[allow(unused)]\n     Unused(PhantomData<E>),\n@@ -197,7 +197,12 @@ impl<N: Network, E: Environment> Message<N, E> {\n             Self::PoolRequest(share_difficulty, block_template) => {\n                 Ok([bincode::serialize(share_difficulty)?, block_template.serialize_blocking()?].concat())\n             }\n-            Self::PoolResponse(address, block) => Ok([bincode::serialize(address)?, block.serialize_blocking()?].concat()),\n+            Self::PoolResponse(address, nonce, proof) => Ok([\n+                bincode::serialize(address)?,\n+                bincode::serialize(nonce)?,\n+                proof.serialize_blocking()?,\n+            ]\n+            .concat()),\n             Self::Unused(_) => Ok(vec![]),\n         }\n     }\n@@ -261,7 +266,11 @@ impl<N: Network, E: Environment> Message<N, E> {\n             10 => Self::UnconfirmedTransaction(bincode::deserialize(data)?),\n             11 => Self::PoolRegister(bincode::deserialize(data)?),\n             12 => Self::PoolRequest(bincode::deserialize(&data[0..8])?, Data::Buffer(data[8..].to_vec())),\n-            13 => Self::PoolResponse(bincode::deserialize(&data[0..32])?, Data::Buffer(data[32..].to_vec())),\n+            13 => Self::PoolResponse(\n+                bincode::deserialize(&data[0..32])?,\n+                bincode::deserialize(&data[32..64])?,\n+                Data::Buffer(data[64..].to_vec()),\n+            ),\n             _ => return Err(anyhow!(\"Invalid message ID {}\", id)),\n         };\n \ndiff --git a/src/network/operator.rs b/src/network/operator.rs\nindex 0a4f7d4444..568081c362 100644\n--- a/src/network/operator.rs\n+++ b/src/network/operator.rs\n@@ -27,7 +27,7 @@ use crate::{\n     ProverRouter,\n };\n use snarkos_storage::{storage::Storage, OperatorState};\n-use snarkvm::dpc::prelude::*;\n+use snarkvm::dpc::{prelude::*, PoSWProof};\n \n use anyhow::Result;\n use rand::thread_rng;\n@@ -55,10 +55,10 @@ type OperatorHandler<N> = mpsc::Receiver<OperatorRequest<N>>;\n ///\n #[derive(Debug)]\n pub enum OperatorRequest<N: Network> {\n-    /// PoolRegister := (peer_ip, worker_address)\n+    /// PoolRegister := (peer_ip, prover_address)\n     PoolRegister(SocketAddr, Address<N>),\n-    /// PoolResponse := (peer_ip, proposed_block_header, worker_address)\n-    PoolResponse(SocketAddr, BlockHeader<N>, Address<N>),\n+    /// PoolResponse := (peer_ip, prover_address, nonce, proof)\n+    PoolResponse(SocketAddr, Address<N>, N::PoSWNonce, PoSWProof<N>),\n }\n \n /// The predefined base share difficulty.\n@@ -263,42 +263,17 @@ impl<N: Network, E: Environment> Operator<N, E> {\n                     warn!(\"[PoolRegister] No current block template exists\");\n                 }\n             }\n-            OperatorRequest::PoolResponse(peer_ip, block_header, prover) => {\n+            OperatorRequest::PoolResponse(peer_ip, prover, nonce, proof) => {\n                 if let Some(block_template) = self.block_template.read().await.clone() {\n-                    // Ensure the given block header corresponds to the correct block height.\n-                    if block_template.block_height() != block_header.height() {\n-                        warn!(\"[PoolResponse] Peer {} sent a stale block.\", peer_ip);\n-                        return;\n-                    }\n-                    // Ensure the timestamp in the block template matches in the block header.\n-                    if block_template.block_timestamp() != block_header.timestamp() {\n-                        warn!(\"[PoolResponse] Peer {} sent a block with an incorrect timestamp.\", peer_ip);\n-                        return;\n-                    }\n-                    // Ensure the difficulty target in the block template matches in the block header.\n-                    if block_template.difficulty_target() != block_header.difficulty_target() {\n-                        warn!(\"[PoolResponse] Peer {} sent a block with an incorrect difficulty target.\", peer_ip);\n-                        return;\n-                    }\n-                    // Ensure the previous ledger root in the block template matches in the block header.\n-                    if block_template.previous_ledger_root() != block_header.previous_ledger_root() {\n-                        warn!(\"[PoolResponse] Peer {} sent a block with an incorrect ledger root.\", peer_ip);\n-                        return;\n-                    }\n-                    // Ensure the transactions root in the block header matches the one from the block template.\n-                    if block_template.transactions().transactions_root() != block_header.transactions_root() {\n-                        warn!(\"[PoolResponse] Peer {} has changed the list of block transactions.\", peer_ip);\n-                        return;\n-                    }\n                     // Ensure the given nonce from the prover is new.\n-                    if self.known_nonces.read().await.contains(&block_header.nonce()) {\n+                    if self.known_nonces.read().await.contains(&nonce) {\n                         warn!(\"[PoolResponse] Peer {} sent a duplicate share\", peer_ip);\n                         // TODO (julesdesmit): punish?\n                         return;\n                     }\n \n                     // Update known nonces.\n-                    self.known_nonces.write().await.insert(block_header.nonce());\n+                    self.known_nonces.write().await.insert(nonce);\n \n                     // Retrieve the share difficulty for the given prover.\n                     let share_difficulty = {\n@@ -313,12 +288,12 @@ impl<N: Network, E: Environment> Operator<N, E> {\n                     };\n \n                     // Ensure the share difficulty target is met, and the PoSW proof is valid.\n-                    let block_height = block_header.height();\n+                    let block_height = block_template.block_height();\n                     if !N::posw().verify(\n                         block_height,\n                         share_difficulty,\n-                        &[*block_header.to_header_root().unwrap(), *block_header.nonce()],\n-                        block_header.proof(),\n+                        &[*block_template.to_header_root().unwrap(), *nonce],\n+                        &proof,\n                     ) {\n                         warn!(\"[PoolResponse] PoSW proof verification failed\");\n                         return;\n@@ -336,8 +311,8 @@ impl<N: Network, E: Environment> Operator<N, E> {\n                     let coinbase_record = block_template.coinbase_record().clone();\n                     match self.state.increment_share(block_height, coinbase_record, &prover) {\n                         Ok(..) => info!(\n-                            \"Operator received a valid share from {} ({}) for block {}\",\n-                            peer_ip, prover, block_height,\n+                            \"Operator has received a valid share from {} ({}) for block {}\",\n+                            prover, peer_ip, block_height,\n                         ),\n                         Err(error) => error!(\"{}\", error),\n                     }\n@@ -345,11 +320,19 @@ impl<N: Network, E: Environment> Operator<N, E> {\n                     // If the block has satisfactory difficulty and is valid, proceed to broadcast it.\n                     let previous_block_hash = block_template.previous_block_hash();\n                     let transactions = block_template.transactions().clone();\n-                    if let Ok(block) = Block::from(previous_block_hash, block_header, transactions) {\n-                        info!(\"Operator has found unconfirmed block {} ({})\", block.height(), block.hash());\n-                        let request = LedgerRequest::UnconfirmedBlock(self.local_ip, block, self.prover_router.clone());\n-                        if let Err(error) = self.ledger_router.send(request).await {\n-                            warn!(\"Failed to broadcast mined block - {}\", error);\n+                    if let Ok(block_header) = BlockHeader::<N>::from(\n+                        block_template.previous_ledger_root(),\n+                        block_template.transactions().transactions_root(),\n+                        BlockHeaderMetadata::new(&block_template),\n+                        nonce,\n+                        proof,\n+                    ) {\n+                        if let Ok(block) = Block::from(previous_block_hash, block_header, transactions) {\n+                            info!(\"Operator has found unconfirmed block {} ({})\", block.height(), block.hash());\n+                            let request = LedgerRequest::UnconfirmedBlock(self.local_ip, block, self.prover_router.clone());\n+                            if let Err(error) = self.ledger_router.send(request).await {\n+                                warn!(\"Failed to broadcast mined block - {}\", error);\n+                            }\n                         }\n                     }\n                 } else {\ndiff --git a/src/network/peer.rs b/src/network/peer.rs\nindex 140496c278..86f0c645ad 100644\n--- a/src/network/peer.rs\n+++ b/src/network/peer.rs\n@@ -706,15 +706,15 @@ impl<N: Network, E: Environment> Peer<N, E> {\n                                         warn!(\"[PoolRequest] could not deserialize block template\");\n                                     }\n                                 }\n-                                Message::PoolResponse(address, block_header) => {\n+                                Message::PoolResponse(address, nonce, proof) => {\n                                     if E::NODE_TYPE != NodeType::Operator {\n                                         trace!(\"Skipping 'PoolResponse' from {}\", peer_ip);\n-                                    } else if let Ok(block_header) = block_header.deserialize().await {\n-                                        if let Err(error) = operator_router.send(OperatorRequest::PoolResponse(peer_ip, block_header, address)).await {\n+                                    } else if let Ok(proof) = proof.deserialize().await {\n+                                        if let Err(error) = operator_router.send(OperatorRequest::PoolResponse(peer_ip, address, nonce, proof)).await {\n                                             warn!(\"[PoolResponse] {}\", error);\n                                         }\n                                     } else {\n-                                        warn!(\"[PoolResponse] could not deserialize block\");\n+                                        warn!(\"[PoolResponse] could not deserialize proof\");\n                                     }\n                                 }\n                                 Message::Unused(_) => break, // Peer is not following the protocol.\ndiff --git a/src/network/peers.rs b/src/network/peers.rs\nindex c4cc57c05a..f4beb24f46 100644\n--- a/src/network/peers.rs\n+++ b/src/network/peers.rs\n@@ -196,8 +196,7 @@ impl<N: Network, E: Environment> Peers<N, E> {\n     ///\n     pub async fn connected_sync_nodes(&self) -> HashSet<SocketAddr> {\n         let connected_peers: HashSet<SocketAddr> = self.connected_peers.read().await.keys().into_iter().copied().collect();\n-        let sync_nodes: HashSet<SocketAddr> = E::SYNC_NODES.iter().map(|ip| ip.parse().unwrap()).collect();\n-        connected_peers.intersection(&sync_nodes).copied().collect()\n+        connected_peers.intersection(E::sync_nodes()).copied().collect()\n     }\n \n     ///\n@@ -206,8 +205,7 @@ impl<N: Network, E: Environment> Peers<N, E> {\n     ///\n     pub async fn number_of_connected_sync_nodes(&self) -> usize {\n         let connected_peers: HashSet<SocketAddr> = self.connected_peers.read().await.keys().into_iter().copied().collect();\n-        let sync_nodes: HashSet<SocketAddr> = E::SYNC_NODES.iter().map(|ip| ip.parse().unwrap()).collect();\n-        connected_peers.intersection(&sync_nodes).count()\n+        connected_peers.intersection(E::sync_nodes()).count()\n     }\n \n     ///\n@@ -324,10 +322,7 @@ impl<N: Network, E: Environment> Peers<N, E> {\n                         .read()\n                         .await\n                         .iter()\n-                        .filter(|(&peer_ip, _)| {\n-                            let peer_str = peer_ip.to_string();\n-                            !E::SYNC_NODES.contains(&peer_str.as_str()) && !E::BEACON_NODES.contains(&peer_str.as_str())\n-                        })\n+                        .filter(|(peer_ip, _)| !E::sync_nodes().contains(peer_ip) && !E::beacon_nodes().contains(peer_ip))\n                         .take(num_excess_peers)\n                         .map(|(&peer_ip, _)| peer_ip)\n                         .collect::<Vec<SocketAddr>>();\n@@ -347,6 +342,8 @@ impl<N: Network, E: Environment> Peers<N, E> {\n                 let number_of_connected_sync_nodes = connected_sync_nodes.len();\n                 let num_excess_sync_nodes = number_of_connected_sync_nodes.saturating_sub(1);\n                 if num_excess_sync_nodes > 0 {\n+                    debug!(\"Exceeded maximum number of sync nodes\");\n+\n                     // Proceed to send disconnect requests to these peers.\n                     for peer_ip in connected_sync_nodes\n                         .iter()\n@@ -373,14 +370,12 @@ impl<N: Network, E: Environment> Peers<N, E> {\n                 };\n \n                 // Add the sync nodes to the list of candidate peers.\n-                let sync_nodes: Vec<SocketAddr> = E::SYNC_NODES.iter().map(|ip| ip.parse().unwrap()).collect();\n                 if number_of_connected_sync_nodes == 0 {\n-                    self.add_candidate_peers(&sync_nodes).await;\n+                    self.add_candidate_peers(E::sync_nodes().iter()).await;\n                 }\n \n                 // Add the beacon nodes to the list of candidate peers.\n-                let beacon_nodes: Vec<SocketAddr> = E::BEACON_NODES.iter().map(|ip| ip.parse().unwrap()).collect();\n-                self.add_candidate_peers(&beacon_nodes).await;\n+                self.add_candidate_peers(E::beacon_nodes().iter()).await;\n \n                 // Attempt to connect to more peers if the number of connected peers is below the minimum threshold.\n                 // Select the peers randomly from the list of candidate peers.\n@@ -393,7 +388,7 @@ impl<N: Network, E: Environment> Peers<N, E> {\n                     .choose_multiple(&mut OsRng::default(), midpoint_number_of_peers)\n                 {\n                     // Ensure this node is not connected to more than the permitted number of sync nodes.\n-                    if sync_nodes.contains(&peer_ip) && number_of_connected_sync_nodes >= 1 {\n+                    if E::sync_nodes().contains(&peer_ip) && number_of_connected_sync_nodes >= 1 {\n                         continue;\n                     }\n \n@@ -528,7 +523,7 @@ impl<N: Network, E: Environment> Peers<N, E> {\n                 self.send(recipient, Message::PeerResponse(connected_peers)).await;\n             }\n             PeersRequest::ReceivePeerResponse(peer_ips) => {\n-                self.add_candidate_peers(&peer_ips).await;\n+                self.add_candidate_peers(peer_ips.iter()).await;\n             }\n         }\n     }\n@@ -539,19 +534,17 @@ impl<N: Network, E: Environment> Peers<N, E> {\n     /// This method skips adding any given peers if the combined size exceeds the threshold,\n     /// as the peer providing this list could be subverting the protocol.\n     ///\n-    async fn add_candidate_peers(&self, peers: &[SocketAddr]) {\n+    async fn add_candidate_peers<'a, T: ExactSizeIterator<Item = &'a SocketAddr> + IntoIterator>(&self, peers: T) {\n         // Acquire the candidate peers write lock.\n         let mut candidate_peers = self.candidate_peers.write().await;\n         // Ensure the combined number of peers does not surpass the threshold.\n-        if candidate_peers.len() + peers.len() < E::MAXIMUM_CANDIDATE_PEERS {\n-            // Proceed to insert each new candidate peer IP.\n-            for peer_ip in peers.iter().take(E::MAXIMUM_CANDIDATE_PEERS) {\n-                // Ensure the peer is not self and is a new candidate peer.\n-                let is_self = *peer_ip == self.local_ip\n-                    || (peer_ip.ip().is_unspecified() || peer_ip.ip().is_loopback()) && peer_ip.port() == self.local_ip.port();\n-                if !is_self && !self.is_connected_to(*peer_ip).await {\n-                    candidate_peers.insert(*peer_ip);\n-                }\n+        for peer_ip in peers.take(E::MAXIMUM_CANDIDATE_PEERS.saturating_sub(candidate_peers.len())) {\n+            // Ensure the peer is not self and is a new candidate peer.\n+            let is_self = *peer_ip == self.local_ip\n+                || (peer_ip.ip().is_unspecified() || peer_ip.ip().is_loopback()) && peer_ip.port() == self.local_ip.port();\n+            if !is_self && !self.is_connected_to(*peer_ip).await {\n+                // Proceed to insert each new candidate peer IP.\n+                candidate_peers.insert(*peer_ip);\n             }\n         }\n     }\n@@ -587,10 +580,7 @@ impl<N: Network, E: Environment> Peers<N, E> {\n             .connected_peers()\n             .await\n             .iter()\n-            .filter(|peer_ip| {\n-                let peer_str = peer_ip.to_string();\n-                *peer_ip != &sender && !E::SYNC_NODES.contains(&peer_str.as_str()) && !E::BEACON_NODES.contains(&peer_str.as_str())\n-            })\n+            .filter(|peer_ip| *peer_ip != &sender && !E::sync_nodes().contains(peer_ip) && !E::beacon_nodes().contains(peer_ip))\n             .copied()\n             .collect::<Vec<_>>()\n         {\ndiff --git a/src/network/prover.rs b/src/network/prover.rs\nindex 24e746f957..b0dc51994b 100644\n--- a/src/network/prover.rs\n+++ b/src/network/prover.rs\n@@ -26,7 +26,7 @@ use crate::{\n     PeersRouter,\n };\n use snarkos_storage::{storage::Storage, ProverState};\n-use snarkvm::dpc::prelude::*;\n+use snarkvm::dpc::{posw::PoSWProof, prelude::*};\n \n use anyhow::{anyhow, Result};\n use rand::thread_rng;\n@@ -245,6 +245,7 @@ impl<N: Network, E: Environment> Prover<N, E> {\n                             E::status().update(State::Mining);\n \n                             let thread_pool = self.thread_pool.clone();\n+                            let block_height = block_template.block_height();\n                             let block_template = block_template.clone();\n \n                             let result = task::spawn_blocking(move || {\n@@ -260,8 +261,11 @@ impl<N: Network, E: Environment> Prover<N, E> {\n                                             &[*block_header.to_header_root().unwrap(), *block_header.nonce()],\n                                             block_header.proof(),\n                                         ) {\n-                                            let proof_difficulty = block_header.proof().to_proof_difficulty()?;\n-                                            return Ok::<(BlockHeader<N>, u64), anyhow::Error>((block_header, proof_difficulty));\n+                                            return Ok::<(N::PoSWNonce, PoSWProof<N>, u64), anyhow::Error>((\n+                                                block_header.nonce(),\n+                                                block_header.proof().clone(),\n+                                                block_header.proof().to_proof_difficulty()?,\n+                                            ));\n                                         }\n                                     }\n                                 })\n@@ -271,21 +275,20 @@ impl<N: Network, E: Environment> Prover<N, E> {\n                             E::status().update(State::Ready);\n \n                             match result {\n-                                Ok(Ok((block_header, proof_difficulty))) => {\n+                                Ok(Ok((nonce, proof, proof_difficulty))) => {\n                                     info!(\n                                         \"Prover successfully mined a share for unconfirmed block {} with proof difficulty of {}\",\n-                                        block_header.height(),\n-                                        proof_difficulty\n+                                        block_height, proof_difficulty\n                                     );\n \n                                     // Send a `PoolResponse` to the operator.\n-                                    let message = Message::PoolResponse(recipient, Data::Object(block_header));\n+                                    let message = Message::PoolResponse(recipient, nonce, Data::Object(proof));\n                                     if let Err(error) = self.peers_router.send(PeersRequest::MessageSend(operator_ip, message)).await {\n                                         warn!(\"[PoolResponse] {}\", error);\n                                     }\n                                 }\n                                 Ok(Err(error)) => trace!(\"{}\", error),\n-                                Err(error) => trace!(\"{}\", anyhow!(\"Could not mine next block {}\", error)),\n+                                Err(error) => trace!(\"{}\", anyhow!(\"Failed to mine the next block {}\", error)),\n                             }\n                         }\n                     }\ndiff --git a/storage/Cargo.toml b/storage/Cargo.toml\nindex 1859c378e2..06fc6f2ad9 100644\n--- a/storage/Cargo.toml\n+++ b/storage/Cargo.toml\n@@ -17,7 +17,7 @@ license = \"GPL-3.0\"\n edition = \"2018\"\n \n [dependencies]\n-snarkvm = { git = \"https://github.com/AleoHQ/snarkVM.git\", rev = \"ff10c20\" }\n+snarkvm = { git = \"https://github.com/AleoHQ/snarkVM.git\", rev = \"459ea96\" }\n #snarkvm = { path = \"../../snarkVM\" }\n \n [dependencies.anyhow]\n", "test_patch": "diff --git a/testing/Cargo.toml b/testing/Cargo.toml\nindex 300bb826b9..313469f9d5 100644\n--- a/testing/Cargo.toml\n+++ b/testing/Cargo.toml\n@@ -25,7 +25,7 @@ path = \"../storage\"\n \n [dependencies.snarkvm]\n git = \"https://github.com/AleoHQ/snarkVM.git\"\n-rev = \"ff10c20\"\n+rev = \"459ea96\"\n #path = \"../../snarkVM\"\n \n [dependencies.anyhow]\n", "problem_statement": "[Bug] Pool operator reports \"could not deserialize block\"\nThere are still issues:\r\n\r\nThe operator reports `could not deserialize block` on `PoolResponse`.\r\n\r\nIt looks like when deserializing `BlockHeader`, there is another `is_valid` check (`snarkVM/dpc/src/block/header.rs`, line 375 -> 143 -> 230) so the operator will be unable to deserialize the header. We might need a `from_unchecked` for `BlockHeader` as well.\r\n\r\n_Originally posted by @HarukaMa in https://github.com/AleoHQ/snarkOS/issues/1492#issuecomment-1000500810_\r\n\r\nI guess this comment was ignored and I was using a modified snarkVM so I didn't think about this again.\r\n\r\nThe line numbers might be out of date but it should still be the deserialization from bytes process.\n", "hints_text": "network/peers.rs\r\n\r\nI find this code much improved, so one has actually an idea what's going on if de-serialization fails.\r\n\r\n\r\n                                Message::PoolRequest(share_difficulty, block_template) => {\r\n                                    if E::NODE_TYPE != NodeType::Prover {\r\n                                        trace!(\"Skipping 'PoolRequest' from {}\", peer_ip);\r\n                                    } else {\r\n                                        match block_template.deserialize().await {\r\n                                            Ok(block_template) => {\r\n                                                if let Err(error) = prover_router.send(ProverRequest::PoolRequest(peer_ip, share_difficulty, block_template)).await {\r\n                                                    warn!(\"[PoolRequest] {}\", error);\r\n                                                }\r\n                                            }\r\n                                            Err(error) => {\r\n                                                warn!(\"[PoolRequest] could not deserialize block template from {}: {}\", peer_ip, error);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                Message::PoolResponse(address, block_header) => {\r\n                                    if E::NODE_TYPE != NodeType::Operator {\r\n                                        trace!(\"Skipping 'PoolResponse' from {}\", peer_ip);\r\n                                    } else {\r\n                                        match block_header.deserialize().await {\r\n                                            Ok(block_header) => {\r\n                                                if let Err(error) = operator_router.send(OperatorRequest::PoolResponse(peer_ip, block_header, address)).await {\r\n                                                    warn!(\"[PoolResponse] {}\", error);\r\n                                                }\r\n                                            }\r\n                                            Err(error) => {\r\n                                                warn!(\"[PoolResponse] could not deserialize block from {}: {}\", peer_ip, error);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\nThat said, the code now reports as the issue\r\n\r\n`2022-01-04T16:06:38.772476Z  WARN [PoolResponse] could not deserialize block from 192.168.1.114:4006: Invalid block header`\r\n\r\nI find it odd, to report an issue on de-serialization, when in fact the de-serialization worked, but a downstream check is_valid(), returned false.\nCan confirm that we have same warning.", "created_at": "2022-01-06T02:55:34Z", "version": "2.0"}, {"repo": "AleoNet/snarkOS", "pull_number": 1427, "instance_id": "AleoNet__snarkOS-1427", "issue_numbers": ["1492"], "base_commit": "11679d4e08efa53660eca852a8e7de3275f5f73f", "patch": "diff --git a/Cargo.lock b/Cargo.lock\nindex 3148b2de22..0e6d9d84ab 100644\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1983,7 +1983,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n dependencies = [\n  \"snarkvm-dpc\",\n  \"snarkvm-utilities\",\n@@ -1992,7 +1992,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-algorithms\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n dependencies = [\n  \"anyhow\",\n  \"blake2\",\n@@ -2021,7 +2021,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-curves\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n dependencies = [\n  \"derivative\",\n  \"rand\",\n@@ -2035,7 +2035,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-derives\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n dependencies = [\n  \"proc-macro-crate\",\n  \"proc-macro-error\",\n@@ -2047,7 +2047,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-dpc\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n dependencies = [\n  \"anyhow\",\n  \"base58\",\n@@ -2079,7 +2079,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-fields\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n dependencies = [\n  \"anyhow\",\n  \"derivative\",\n@@ -2092,7 +2092,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-gadgets\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n dependencies = [\n  \"anyhow\",\n  \"derivative\",\n@@ -2112,7 +2112,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-marlin\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n dependencies = [\n  \"bincode\",\n  \"blake2\",\n@@ -2138,7 +2138,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-parameters\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n dependencies = [\n  \"aleo-std\",\n  \"anyhow\",\n@@ -2155,7 +2155,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-polycommit\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n dependencies = [\n  \"derivative\",\n  \"digest 0.9.0\",\n@@ -2173,12 +2173,12 @@ dependencies = [\n [[package]]\n name = \"snarkvm-profiler\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n \n [[package]]\n name = \"snarkvm-r1cs\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n dependencies = [\n  \"anyhow\",\n  \"cfg-if\",\n@@ -2194,7 +2194,7 @@ dependencies = [\n [[package]]\n name = \"snarkvm-utilities\"\n version = \"0.7.5\"\n-source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=02c814c#02c814c34c8f9f8b46401e447b6799e01b19ede1\"\n+source = \"git+https://github.com/AleoHQ/snarkVM.git?rev=6bafa31#6bafa3134279ee2239a1755c4d328abe69e640dd\"\n dependencies = [\n  \"anyhow\",\n  \"bincode\",\ndiff --git a/Cargo.toml b/Cargo.toml\nindex b8d2dad65d..feff73a552 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -24,11 +24,11 @@ default = []\n test = []\n \n [dependencies]\n-snarkvm = { git = \"https://github.com/AleoHQ/snarkVM.git\", rev = \"02c814c\" }\n+snarkvm = { git = \"https://github.com/AleoHQ/snarkVM.git\", rev = \"b70bf72\" }\n #snarkvm = { path = \"../snarkVM\" }\n \n bytes = \"1.0.0\"\n-futures = { version = \"0.3.19\", features = [\"thread-pool\"]}\n+futures = { version = \"0.3.19\", features = [\"thread-pool\"] }\n \n crossterm = { version = \"0.22\" }\n tui = { version = \"0.16.0\", default-features = false, features = [\"crossterm\"] }\ndiff --git a/README.md b/README.md\nindex 72cb206c25..275f103bf2 100644\n--- a/README.md\n+++ b/README.md\n@@ -160,6 +160,9 @@ OPTIONS:\n         --miner <miner>              Specify this as a mining node, with the given miner address\n         --network <network>          Specify the network of this node [default: 2]\n         --node <node>                Specify the IP address and port for the node server [default: 0.0.0.0:4132]\n+        --operator <operator>        Specify this as an operating node, with the given operator address\n+        --pool <pool>                Specify the pool that a prover node is contributing to\n+        --prover <prover>            Specify this as a prover node, with the given prover address\n         --rpc <rpc>                  Specify the IP address and port for the RPC server [default: 0.0.0.0:3032]\n         --password <rpc-password>    Specify the password for the RPC server [default: pass]\n         --username <rpc-username>    Specify the username for the RPC server [default: root]\ndiff --git a/src/environment/mod.rs b/src/environment/mod.rs\nindex 925dbba9a2..8c092b786e 100644\n--- a/src/environment/mod.rs\n+++ b/src/environment/mod.rs\n@@ -33,6 +33,23 @@ pub enum NodeType {\n     Beacon,\n     /// A sync node is a discovery node, capable of syncing nodes for the network.\n     Sync,\n+    /// An operating node is a full node, capable of coordinating provers in a pool.\n+    Operator,\n+    /// A proving node is a full node, capable of producing proofs for a pool.\n+    Prover,\n+}\n+\n+impl NodeType {\n+    pub fn description(&self) -> &str {\n+        match self {\n+            Self::Client => \"a client node\",\n+            Self::Miner => \"a mining node\",\n+            Self::Beacon => \"a beacon node\",\n+            Self::Sync => \"a sync node\",\n+            Self::Operator => \"an operating node\",\n+            Self::Prover => \"a proving node\",\n+        }\n+    }\n }\n \n impl fmt::Display for NodeType {\n@@ -114,6 +131,30 @@ impl<N: Network> Environment for Miner<N> {\n     const MAXIMUM_NUMBER_OF_PEERS: usize = 21;\n }\n \n+#[derive(Clone, Debug, Default)]\n+pub struct Operator<N: Network>(PhantomData<N>);\n+\n+#[rustfmt::skip]\n+impl<N: Network> Environment for Operator<N> {\n+    type Network = N;\n+    const NODE_TYPE: NodeType = NodeType::Operator;\n+    const COINBASE_IS_PUBLIC: bool = true;\n+    const MINIMUM_NUMBER_OF_PEERS: usize = 1;\n+    const MAXIMUM_NUMBER_OF_PEERS: usize = 1000;\n+}\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct Prover<N: Network>(PhantomData<N>);\n+\n+#[rustfmt::skip]\n+impl<N: Network> Environment for Prover<N> {\n+    type Network = N;\n+    const NODE_TYPE: NodeType = NodeType::Prover;\n+    const COINBASE_IS_PUBLIC: bool = true;\n+    const MINIMUM_NUMBER_OF_PEERS: usize = 1;\n+    const MAXIMUM_NUMBER_OF_PEERS: usize = 21;\n+}\n+\n #[derive(Clone, Debug, Default)]\n pub struct SyncNode<N: Network>(PhantomData<N>);\n \n@@ -158,3 +199,37 @@ impl<N: Network> Environment for MinerTrial<N> {\n     const MAXIMUM_NUMBER_OF_PEERS: usize = 21;\n     const COINBASE_IS_PUBLIC: bool = true;\n }\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct OperatorTrial<N: Network>(PhantomData<N>);\n+\n+#[rustfmt::skip]\n+impl<N: Network> Environment for OperatorTrial<N> {\n+    type Network = N;\n+    const NODE_TYPE: NodeType = NodeType::Operator;\n+    const SYNC_NODES: [&'static str; 13] = [\n+        \"144.126.219.193:4132\", \"165.232.145.194:4132\", \"143.198.164.241:4132\", \"188.166.7.13:4132\", \"167.99.40.226:4132\",\n+        \"159.223.124.150:4132\", \"137.184.192.155:4132\", \"147.182.213.228:4132\", \"137.184.202.162:4132\", \"159.223.118.35:4132\",\n+        \"161.35.106.91:4132\", \"157.245.133.62:4132\", \"143.198.166.150:4132\",\n+    ];\n+    const MINIMUM_NUMBER_OF_PEERS: usize = 11;\n+    const MAXIMUM_NUMBER_OF_PEERS: usize = 1000;\n+    const COINBASE_IS_PUBLIC: bool = true;\n+}\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct ProverTrial<N: Network>(PhantomData<N>);\n+\n+#[rustfmt::skip]\n+impl<N: Network> Environment for ProverTrial<N> {\n+    type Network = N;\n+    const NODE_TYPE: NodeType = NodeType::Prover;\n+    const SYNC_NODES: [&'static str; 13] = [\n+        \"144.126.219.193:4132\", \"165.232.145.194:4132\", \"143.198.164.241:4132\", \"188.166.7.13:4132\", \"167.99.40.226:4132\",\n+        \"159.223.124.150:4132\", \"137.184.192.155:4132\", \"147.182.213.228:4132\", \"137.184.202.162:4132\", \"159.223.118.35:4132\",\n+        \"161.35.106.91:4132\", \"157.245.133.62:4132\", \"143.198.166.150:4132\",\n+    ];\n+    const MINIMUM_NUMBER_OF_PEERS: usize = 11;\n+    const MAXIMUM_NUMBER_OF_PEERS: usize = 21;\n+    const COINBASE_IS_PUBLIC: bool = true;\n+}\ndiff --git a/src/network/ledger.rs b/src/network/ledger.rs\nindex 2b1926bd17..35c4daf557 100644\n--- a/src/network/ledger.rs\n+++ b/src/network/ledger.rs\n@@ -896,40 +896,6 @@ impl<N: Network, E: Environment> Ledger<N, E> {\n                     }\n                 }\n             }\n-\n-            // TODO (howardwu): TEMPORARY - Evaluate the merits of this experiment after seeing the results.\n-            // If the node is a sync node and the node is currently syncing,\n-            // reduce the number of connections down to the minimum threshold,\n-            // to improve the speed with which the node syncs back to tip.\n-            // FIXME: causes sync nodes to hang when at maximum peers\n-            /*\n-            if E::NODE_TYPE == NodeType::Sync && self.status.is_syncing() {\n-                debug!(\"Temporarily reducing the number of connected peers to sync\");\n-\n-                // Lock peers_state for further processing.\n-                let peers_state = self.peers_state.read().await;\n-\n-                // Determine the peers to disconnect from.\n-                // Attention - We are reducing this to the `MINIMUM_NUMBER_OF_PEERS`, *not* `MAXIMUM_NUMBER_OF_PEERS`.\n-                let num_excess_peers = peers_state.len().saturating_sub(E::MINIMUM_NUMBER_OF_PEERS);\n-                let peer_ips_to_disconnect = peers_state\n-                    .iter()\n-                    .filter(|(&ip, _)| ip != peer_ip)\n-                    .take(num_excess_peers)\n-                    .map(|(&ip, _)| ip)\n-                    .collect::<Vec<SocketAddr>>();\n-\n-                // Release the lock over peers_state.\n-                drop(peers_state);\n-\n-                trace!(\"Found {} peers to temporarily disconnect\", peer_ips_to_disconnect.len());\n-\n-                // Proceed to disconnect and restrict these peers.\n-                for peer_ip in peer_ips_to_disconnect {\n-                    self.disconnect_and_restrict(peer_ip, \"disconnecting to sync\").await;\n-                }\n-            }\n-            */\n         }\n     }\n \ndiff --git a/src/network/message.rs b/src/network/message.rs\nindex ccf86ca49c..680cbb7b70 100644\n--- a/src/network/message.rs\n+++ b/src/network/message.rs\n@@ -99,6 +99,12 @@ pub enum Message<N: Network, E: Environment> {\n     UnconfirmedBlock(u32, N::BlockHash, Data<Block<N>>),\n     /// UnconfirmedTransaction := (transaction)\n     UnconfirmedTransaction(Transaction<N>),\n+    /// PoolRegister := (address)\n+    PoolRegister(Address<N>),\n+    /// PoolRequest := (share_difficulty, block_template)\n+    PoolRequest(u64, Data<BlockTemplate<N>>),\n+    /// PoolResponse := (address, block_header)\n+    PoolResponse(Address<N>, Data<BlockHeader<N>>),\n     /// Unused\n     #[allow(unused)]\n     Unused(PhantomData<E>),\n@@ -120,6 +126,9 @@ impl<N: Network, E: Environment> Message<N, E> {\n             Self::Pong(..) => \"Pong\",\n             Self::UnconfirmedBlock(..) => \"UnconfirmedBlock\",\n             Self::UnconfirmedTransaction(..) => \"UnconfirmedTransaction\",\n+            Self::PoolRegister(..) => \"PoolRegister\",\n+            Self::PoolRequest(..) => \"PoolRequest\",\n+            Self::PoolResponse(..) => \"PoolResponse\",\n             Self::Unused(..) => \"Unused\",\n         }\n     }\n@@ -139,7 +148,10 @@ impl<N: Network, E: Environment> Message<N, E> {\n             Self::Pong(..) => 8,\n             Self::UnconfirmedBlock(..) => 9,\n             Self::UnconfirmedTransaction(..) => 10,\n-            Self::Unused(..) => 11,\n+            Self::PoolRegister(..) => 11,\n+            Self::PoolRequest(..) => 12,\n+            Self::PoolResponse(..) => 13,\n+            Self::Unused(..) => 14,\n         }\n     }\n \n@@ -178,6 +190,11 @@ impl<N: Network, E: Environment> Message<N, E> {\n             ]\n             .concat()),\n             Self::UnconfirmedTransaction(transaction) => Ok(bincode::serialize(transaction)?),\n+            Self::PoolRegister(address) => Ok(bincode::serialize(address)?),\n+            Self::PoolRequest(share_difficulty, block_template) => {\n+                Ok([bincode::serialize(share_difficulty)?, block_template.serialize_blocking()?].concat())\n+            }\n+            Self::PoolResponse(address, block) => Ok([bincode::serialize(address)?, block.serialize_blocking()?].concat()),\n             Self::Unused(_) => Ok(vec![]),\n         }\n     }\n@@ -239,6 +256,9 @@ impl<N: Network, E: Environment> Message<N, E> {\n                 Data::Buffer(data[36..].to_vec()),\n             ),\n             10 => Self::UnconfirmedTransaction(bincode::deserialize(data)?),\n+            11 => Self::PoolRegister(bincode::deserialize(data)?),\n+            12 => Self::PoolRequest(bincode::deserialize(&data[0..8])?, Data::Buffer(data[8..].to_vec())),\n+            13 => Self::PoolResponse(bincode::deserialize(&data[0..32])?, Data::Buffer(data[32..].to_vec())),\n             _ => return Err(anyhow!(\"Invalid message ID {}\", id)),\n         };\n \ndiff --git a/src/network/mod.rs b/src/network/mod.rs\nindex da993204b3..0a2549d9f0 100644\n--- a/src/network/mod.rs\n+++ b/src/network/mod.rs\n@@ -20,6 +20,9 @@ pub(crate) use ledger::{LedgerRequest, LedgerRouter};\n pub mod message;\n pub use message::*;\n \n+pub mod operator;\n+pub use operator::*;\n+\n pub(crate) mod peers;\n pub(crate) use peers::*;\n \ndiff --git a/src/network/operator.rs b/src/network/operator.rs\nnew file mode 100644\nindex 0000000000..13b63bc7dc\n--- /dev/null\n+++ b/src/network/operator.rs\n@@ -0,0 +1,363 @@\n+// Copyright (C) 2019-2021 Aleo Systems Inc.\n+// This file is part of the snarkOS library.\n+\n+// The snarkOS library is free software: you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation, either version 3 of the License, or\n+// (at your option) any later version.\n+\n+// The snarkOS library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with the snarkOS library. If not, see <https://www.gnu.org/licenses/>.\n+\n+use crate::{\n+    helpers::Tasks,\n+    Data,\n+    Environment,\n+    LedgerReader,\n+    LedgerRequest,\n+    LedgerRouter,\n+    Message,\n+    NodeType,\n+    PeersRequest,\n+    PeersRouter,\n+    ProverRouter,\n+};\n+use snarkos_storage::{storage::Storage, OperatorState};\n+use snarkvm::dpc::prelude::*;\n+\n+use anyhow::Result;\n+use rand::thread_rng;\n+use rayon::{ThreadPool, ThreadPoolBuilder};\n+use std::{\n+    collections::{HashMap, HashSet},\n+    net::SocketAddr,\n+    path::Path,\n+    sync::Arc,\n+    time::{Duration, Instant},\n+};\n+use tokio::{\n+    sync::{mpsc, oneshot, RwLock},\n+    task,\n+    task::JoinHandle,\n+};\n+\n+/// Shorthand for the parent half of the `Operator` message channel.\n+pub(crate) type OperatorRouter<N> = mpsc::Sender<OperatorRequest<N>>;\n+#[allow(unused)]\n+/// Shorthand for the child half of the `Operator` message channel.\n+type OperatorHandler<N> = mpsc::Receiver<OperatorRequest<N>>;\n+\n+///\n+/// An enum of requests that the `Operator` struct processes.\n+///\n+#[derive(Debug)]\n+pub enum OperatorRequest<N: Network> {\n+    /// PoolRegister := (peer_ip, worker_address)\n+    PoolRegister(SocketAddr, Address<N>),\n+    /// PoolResponse := (peer_ip, proposed_block_header, worker_address)\n+    PoolResponse(SocketAddr, BlockHeader<N>, Address<N>),\n+}\n+\n+/// The predefined base share difficulty.\n+const BASE_SHARE_DIFFICULTY: u64 = u64::MAX;\n+/// The operator heartbeat in seconds.\n+const HEARTBEAT_IN_SECONDS: Duration = Duration::from_secs(1);\n+\n+///\n+/// An operator for a program on a specific network in the node server.\n+///\n+#[derive(Debug)]\n+pub struct Operator<N: Network, E: Environment> {\n+    /// The address of the operator.\n+    address: Option<Address<N>>,\n+    /// The local address of this node.\n+    local_ip: SocketAddr,\n+    /// The thread pool of the operator.\n+    thread_pool: Arc<ThreadPool>,\n+    /// The state storage of the operator.\n+    state: Arc<OperatorState<N>>,\n+    /// The current block template that is being mined on by the operator.\n+    block_template: RwLock<Option<BlockTemplate<N>>>,\n+    /// A list of provers and their associated state := (last_submitted, share_difficulty)\n+    provers: RwLock<HashMap<Address<N>, (Instant, u64)>>,\n+    /// A list of the known nonces for the current round.\n+    known_nonces: RwLock<HashSet<N::PoSWNonce>>,\n+    /// The operator router of the node.\n+    operator_router: OperatorRouter<N>,\n+    /// The pool of unconfirmed transactions.\n+    memory_pool: Arc<RwLock<MemoryPool<N>>>,\n+    /// The peers router of the node.\n+    peers_router: PeersRouter<N, E>,\n+    /// The ledger state of the node.\n+    ledger_reader: LedgerReader<N>,\n+    /// The ledger router of the node.\n+    ledger_router: LedgerRouter<N>,\n+    /// The prover router of the node.\n+    prover_router: ProverRouter<N>,\n+}\n+\n+impl<N: Network, E: Environment> Operator<N, E> {\n+    /// Initializes a new instance of the operator.\n+    pub async fn open<S: Storage, P: AsRef<Path> + Copy>(\n+        tasks: &Tasks<JoinHandle<()>>,\n+        path: P,\n+        address: Option<Address<N>>,\n+        local_ip: SocketAddr,\n+        memory_pool: Arc<RwLock<MemoryPool<N>>>,\n+        peers_router: PeersRouter<N, E>,\n+        ledger_reader: LedgerReader<N>,\n+        ledger_router: LedgerRouter<N>,\n+        prover_router: ProverRouter<N>,\n+    ) -> Result<Arc<Self>> {\n+        // Initialize an mpsc channel for sending requests to the `Operator` struct.\n+        let (operator_router, mut operator_handler) = mpsc::channel(1024);\n+        // Initialize the operator thread pool.\n+        let thread_pool = ThreadPoolBuilder::new()\n+            .stack_size(8 * 1024 * 1024)\n+            .num_threads((num_cpus::get() / 8 * 7).max(1))\n+            .build()?;\n+\n+        // Initialize the operator.\n+        let operator = Arc::new(Self {\n+            address,\n+            local_ip,\n+            state: Arc::new(OperatorState::open_writer::<S, P>(path)?),\n+            thread_pool: Arc::new(thread_pool),\n+            block_template: RwLock::new(None),\n+            provers: Default::default(),\n+            known_nonces: Default::default(),\n+            operator_router,\n+            memory_pool,\n+            peers_router,\n+            ledger_reader,\n+            ledger_router,\n+            prover_router,\n+        });\n+\n+        if E::NODE_TYPE == NodeType::Operator {\n+            // Initialize the handler for the operator.\n+            let operator_clone = operator.clone();\n+            let (router, handler) = oneshot::channel();\n+            tasks.append(task::spawn(async move {\n+                // Notify the outer function that the task is ready.\n+                let _ = router.send(());\n+                // Asynchronously wait for a operator request.\n+                while let Some(request) = operator_handler.recv().await {\n+                    operator_clone.update(request).await;\n+                }\n+            }));\n+            // Wait until the operator handler is ready.\n+            let _ = handler.await;\n+        }\n+\n+        if E::NODE_TYPE == NodeType::Operator {\n+            if let Some(recipient) = operator.address {\n+                // Initialize an update loop for the block template.\n+                let operator = operator.clone();\n+                let (router, handler) = oneshot::channel();\n+                tasks.append(task::spawn(async move {\n+                    // Notify the outer function that the task is ready.\n+                    let _ = router.send(());\n+                    // TODO (julesdesmit): Add logic to the loop to retarget share difficulty.\n+                    loop {\n+                        // Determine if the current block template is stale.\n+                        let is_block_template_stale = match &*operator.block_template.read().await {\n+                            Some(template) => operator.ledger_reader.latest_block_height().saturating_add(1) != template.block_height(),\n+                            None => true,\n+                        };\n+\n+                        // Update the block template if it is stale.\n+                        if is_block_template_stale {\n+                            // Construct a new block template.\n+                            let transactions = operator.memory_pool.read().await.transactions();\n+                            let ledger_reader = operator.ledger_reader.clone();\n+                            let thread_pool = operator.thread_pool.clone();\n+                            let result = task::spawn_blocking(move || {\n+                                thread_pool.install(move || {\n+                                    match ledger_reader.get_block_template(\n+                                        recipient,\n+                                        E::COINBASE_IS_PUBLIC,\n+                                        &transactions,\n+                                        &mut thread_rng(),\n+                                    ) {\n+                                        Ok(block_template) => Ok(block_template),\n+                                        Err(error) => Err(format!(\"Failed to produce a new block template: {}\", error)),\n+                                    }\n+                                })\n+                            })\n+                            .await;\n+\n+                            // Update the block template.\n+                            match result {\n+                                Ok(Ok(block_template)) => {\n+                                    // Acquire the write lock to update the block template.\n+                                    *operator.block_template.write().await = Some(block_template);\n+                                    // Clear the set of known nonces.\n+                                    operator.known_nonces.write().await.clear();\n+                                }\n+                                Ok(Err(error_message)) => error!(\"{}\", error_message),\n+                                Err(error) => error!(\"{}\", error),\n+                            };\n+                        }\n+\n+                        // Proceed to sleep for a preset amount of time.\n+                        tokio::time::sleep(HEARTBEAT_IN_SECONDS).await;\n+                    }\n+                }));\n+                // Wait until the operator handler is ready.\n+                let _ = handler.await;\n+            } else {\n+                error!(\"Missing operator address. Please specify an Aleo address in order to operate a pool\");\n+            }\n+        }\n+\n+        Ok(operator)\n+    }\n+\n+    /// Returns an instance of the operator router.\n+    pub fn router(&self) -> OperatorRouter<N> {\n+        self.operator_router.clone()\n+    }\n+\n+    /// Returns all the shares in storage.\n+    pub fn to_shares(&self) -> Vec<((u32, Record<N>), HashMap<Address<N>, u64>)> {\n+        self.state.to_shares()\n+    }\n+\n+    /// Returns the shares for a specific block, given the block height and coinbase record commitment.\n+    pub fn get_shares_for_block(&self, block_height: u32, coinbase_record: Record<N>) -> Result<HashMap<Address<N>, u64>> {\n+        self.state.get_shares_for_block(block_height, coinbase_record)\n+    }\n+\n+    /// Returns the shares for a specific prover, given a ledger and the prover address.\n+    pub fn get_shares_for_prover(&self, prover: &Address<N>) -> u64 {\n+        self.state.get_shares_for_prover(&self.ledger_reader, prover)\n+    }\n+\n+    ///\n+    /// Performs the given `request` to the operator.\n+    /// All requests must go through this `update`, so that a unified view is preserved.\n+    ///\n+    pub(super) async fn update(&self, request: OperatorRequest<N>) {\n+        match request {\n+            OperatorRequest::PoolRegister(peer_ip, address) => {\n+                if let Some(block_template) = self.block_template.read().await.clone() {\n+                    // Ensure this prover exists in the list first, and retrieve their share difficulty.\n+                    let share_difficulty = self\n+                        .provers\n+                        .write()\n+                        .await\n+                        .entry(address)\n+                        .or_insert((Instant::now(), BASE_SHARE_DIFFICULTY))\n+                        .1;\n+\n+                    // Route a `PoolRequest` to the peer.\n+                    let message = Message::PoolRequest(share_difficulty, Data::Object(block_template));\n+                    if let Err(error) = self.peers_router.send(PeersRequest::MessageSend(peer_ip, message)).await {\n+                        warn!(\"[PoolRequest] {}\", error);\n+                    }\n+                } else {\n+                    warn!(\"[PoolRegister] No current block template exists\");\n+                }\n+            }\n+            OperatorRequest::PoolResponse(peer_ip, block_header, prover) => {\n+                if let Some(block_template) = self.block_template.read().await.clone() {\n+                    // Ensure the given block header corresponds to the correct block height.\n+                    if block_template.block_height() != block_header.height() {\n+                        warn!(\"[PoolResponse] Peer {} sent a stale block.\", peer_ip);\n+                        return;\n+                    }\n+                    // Ensure the timestamp in the block template matches in the block header.\n+                    if block_template.block_timestamp() != block_header.timestamp() {\n+                        warn!(\"[PoolResponse] Peer {} sent a block with an incorrect timestamp.\", peer_ip);\n+                        return;\n+                    }\n+                    // Ensure the difficulty target in the block template matches in the block header.\n+                    if block_template.difficulty_target() != block_header.difficulty_target() {\n+                        warn!(\"[PoolResponse] Peer {} sent a block with an incorrect difficulty target.\", peer_ip);\n+                        return;\n+                    }\n+                    // Ensure the previous ledger root in the block template matches in the block header.\n+                    if block_template.previous_ledger_root() != block_header.previous_ledger_root() {\n+                        warn!(\"[PoolResponse] Peer {} sent a block with an incorrect ledger root.\", peer_ip);\n+                        return;\n+                    }\n+                    // Ensure the transactions root in the block header matches the one from the block template.\n+                    if block_template.transactions().transactions_root() != block_header.transactions_root() {\n+                        warn!(\"[PoolResponse] Peer {} has changed the list of block transactions.\", peer_ip);\n+                        return;\n+                    }\n+                    // Ensure the given nonce from the prover is new.\n+                    if self.known_nonces.read().await.contains(&block_header.nonce()) {\n+                        warn!(\"[PoolResponse] Peer {} sent a duplicate share\", peer_ip);\n+                        // TODO (julesdesmit): punish?\n+                        return;\n+                    }\n+\n+                    // Update known nonces.\n+                    self.known_nonces.write().await.insert(block_header.nonce());\n+\n+                    // Retrieve the share difficulty for the given prover.\n+                    let share_difficulty = {\n+                        let provers = self.provers.read().await.clone();\n+                        match provers.get(&prover) {\n+                            Some((_, share_difficulty)) => *share_difficulty,\n+                            None => {\n+                                self.provers.write().await.insert(prover, (Instant::now(), BASE_SHARE_DIFFICULTY));\n+                                BASE_SHARE_DIFFICULTY\n+                            }\n+                        }\n+                    };\n+\n+                    // Ensure the share difficulty target is met, and the PoSW proof is valid.\n+                    let block_height = block_header.height();\n+                    if !N::posw().verify(\n+                        block_height,\n+                        share_difficulty,\n+                        &vec![*block_header.to_header_root().unwrap(), *block_header.nonce()],\n+                        block_header.proof(),\n+                    ) {\n+                        warn!(\"[PoolResponse] PoSW proof verification failed\");\n+                        return;\n+                    }\n+\n+                    // Update the internal state for this prover.\n+                    if let Some(ref mut prover) = self.provers.write().await.get_mut(&prover) {\n+                        prover.0 = Instant::now();\n+                    } else {\n+                        error!(\"Prover should have existing info\");\n+                        return;\n+                    }\n+\n+                    // Increment the share count for the prover.\n+                    let coinbase_record = block_template.coinbase_record().clone();\n+                    match self.state.increment_share(block_height, coinbase_record, &prover) {\n+                        Ok(..) => info!(\n+                            \"Operator received a valid share from {} ({}) for block {}\",\n+                            peer_ip, prover, block_height,\n+                        ),\n+                        Err(error) => error!(\"{}\", error),\n+                    }\n+\n+                    // If the block has satisfactory difficulty and is valid, proceed to broadcast it.\n+                    let previous_block_hash = block_template.previous_block_hash();\n+                    let transactions = block_template.transactions().clone();\n+                    if let Ok(block) = Block::from(previous_block_hash, block_header, transactions) {\n+                        info!(\"Operator has found unconfirmed block {} ({})\", block.height(), block.hash());\n+                        let request = LedgerRequest::UnconfirmedBlock(self.local_ip, block, self.prover_router.clone());\n+                        if let Err(error) = self.ledger_router.send(request).await {\n+                            warn!(\"Failed to broadcast mined block - {}\", error);\n+                        }\n+                    }\n+                } else {\n+                    warn!(\"[PoolResponse] No current block template exists\");\n+                }\n+            }\n+        }\n+    }\n+}\ndiff --git a/src/network/peers.rs b/src/network/peers.rs\nindex 10c1b375a7..e1e494f276 100644\n--- a/src/network/peers.rs\n+++ b/src/network/peers.rs\n@@ -23,6 +23,8 @@ use crate::{\n     LedgerRouter,\n     Message,\n     NodeType,\n+    OperatorRequest,\n+    OperatorRouter,\n     ProverRequest,\n     ProverRouter,\n };\n@@ -66,16 +68,30 @@ type ConnectionResult = oneshot::Sender<Result<()>>;\n ///\n #[derive(Debug)]\n pub enum PeersRequest<N: Network, E: Environment> {\n-    /// Connect := (peer_ip, ledger_reader, ledger_router, prover_router, connection_result)\n-    Connect(SocketAddr, LedgerReader<N>, LedgerRouter<N>, ProverRouter<N>, ConnectionResult),\n-    /// Heartbeat := (ledger_reader, ledger_router, prover_router)\n-    Heartbeat(LedgerReader<N>, LedgerRouter<N>, ProverRouter<N>),\n+    /// Connect := (peer_ip, ledger_reader, ledger_router, operator_router, prover_router, connection_result)\n+    Connect(\n+        SocketAddr,\n+        LedgerReader<N>,\n+        LedgerRouter<N>,\n+        OperatorRouter<N>,\n+        ProverRouter<N>,\n+        ConnectionResult,\n+    ),\n+    /// Heartbeat := (ledger_reader, ledger_router, operator_router, prover_router)\n+    Heartbeat(LedgerReader<N>, LedgerRouter<N>, OperatorRouter<N>, ProverRouter<N>),\n     /// MessagePropagate := (peer_ip, message)\n     MessagePropagate(SocketAddr, Message<N, E>),\n     /// MessageSend := (peer_ip, message)\n     MessageSend(SocketAddr, Message<N, E>),\n-    /// PeerConnecting := (stream, peer_ip, ledger_reader, ledger_router, prover_router)\n-    PeerConnecting(TcpStream, SocketAddr, LedgerReader<N>, LedgerRouter<N>, ProverRouter<N>),\n+    /// PeerConnecting := (stream, peer_ip, ledger_reader, ledger_router, operator_router, prover_router)\n+    PeerConnecting(\n+        TcpStream,\n+        SocketAddr,\n+        LedgerReader<N>,\n+        LedgerRouter<N>,\n+        OperatorRouter<N>,\n+        ProverRouter<N>,\n+    ),\n     /// PeerConnected := (peer_ip, peer_nonce, outbound_router)\n     PeerConnected(SocketAddr, u64, OutboundRouter<N, E>),\n     /// PeerDisconnected := (peer_ip)\n@@ -258,7 +274,7 @@ impl<N: Network, E: Environment> Peers<N, E> {\n     ///\n     pub(super) async fn update(&self, request: PeersRequest<N, E>, tasks: &Tasks<JoinHandle<()>>) {\n         match request {\n-            PeersRequest::Connect(peer_ip, ledger_reader, ledger_router, prover_router, connection_result) => {\n+            PeersRequest::Connect(peer_ip, ledger_reader, ledger_router, operator_router, prover_router, connection_result) => {\n                 // Ensure the peer IP is not this node.\n                 if peer_ip == self.local_ip\n                     || (peer_ip.ip().is_unspecified() || peer_ip.ip().is_loopback()) && peer_ip.port() == self.local_ip.port()\n@@ -308,6 +324,7 @@ impl<N: Network, E: Environment> Peers<N, E> {\n                                         ledger_reader,\n                                         ledger_router,\n                                         prover_router,\n+                                        operator_router,\n                                         self.connected_nonces().await,\n                                         Some(connection_result),\n                                         tasks.clone(),\n@@ -327,10 +344,9 @@ impl<N: Network, E: Environment> Peers<N, E> {\n                     }\n                 }\n             }\n-            PeersRequest::Heartbeat(ledger_reader, ledger_router, prover_router) => {\n+            PeersRequest::Heartbeat(ledger_reader, ledger_router, operator_router, prover_router) => {\n                 // Obtain the number of connected peers.\n                 let number_of_connected_peers = self.number_of_connected_peers().await;\n-\n                 // Ensure the number of connected peers is below the maximum threshold.\n                 if number_of_connected_peers > E::MAXIMUM_NUMBER_OF_PEERS {\n                     debug!(\"Exceeded maximum number of connected peers\");\n@@ -420,8 +436,14 @@ impl<N: Network, E: Environment> Peers<N, E> {\n \n                         // Initialize the connection process.\n                         let (router, handler) = oneshot::channel();\n-                        let request =\n-                            PeersRequest::Connect(peer_ip, ledger_reader.clone(), ledger_router.clone(), prover_router.clone(), router);\n+                        let request = PeersRequest::Connect(\n+                            peer_ip,\n+                            ledger_reader.clone(),\n+                            ledger_router.clone(),\n+                            operator_router.clone(),\n+                            prover_router.clone(),\n+                            router,\n+                        );\n                         if let Err(error) = self.peers_router.send(request).await {\n                             warn!(\"Failed to transmit the request: '{}'\", error);\n                         }\n@@ -438,7 +460,7 @@ impl<N: Network, E: Environment> Peers<N, E> {\n             PeersRequest::MessageSend(sender, message) => {\n                 self.send(sender, message).await;\n             }\n-            PeersRequest::PeerConnecting(stream, peer_ip, ledger_reader, ledger_router, prover_router) => {\n+            PeersRequest::PeerConnecting(stream, peer_ip, ledger_reader, ledger_router, operator_router, prover_router) => {\n                 // Ensure the peer IP is not this node.\n                 if peer_ip == self.local_ip\n                     || (peer_ip.ip().is_unspecified() || peer_ip.ip().is_loopback()) && peer_ip.port() == self.local_ip.port()\n@@ -509,6 +531,7 @@ impl<N: Network, E: Environment> Peers<N, E> {\n                             ledger_reader,\n                             ledger_router,\n                             prover_router,\n+                            operator_router,\n                             self.connected_nonces().await,\n                             None,\n                             tasks.clone(),\n@@ -887,6 +910,7 @@ impl<N: Network, E: Environment> Peer<N, E> {\n         ledger_reader: LedgerReader<N>,\n         ledger_router: LedgerRouter<N>,\n         prover_router: ProverRouter<N>,\n+        operator_router: OperatorRouter<N>,\n         connected_nonces: Vec<u64>,\n         connection_result: Option<ConnectionResult>,\n         tasks: Tasks<task::JoinHandle<()>>,\n@@ -1056,11 +1080,12 @@ impl<N: Network, E: Environment> Peer<N, E> {\n                                         Ok(block) => {\n                                             // TODO (howardwu): TEMPORARY - Remove this after testnet2.\n                                             // Sanity check for a V12 ledger.\n-                                            if N::NETWORK_ID == 2 && block.height() > snarkvm::dpc::testnet2::V12_UPGRADE_BLOCK_HEIGHT {\n-                                                if block.header().proof().as_ref().unwrap_or(N::genesis_block().header().proof().as_ref().unwrap()).is_hiding() {\n-                                                    warn!(\"Peer {} is not V12-compliant, proceeding to disconnect\", peer_ip);\n-                                                    break;\n-                                                }\n+                                            if N::NETWORK_ID == 2\n+                                                && block.height() > snarkvm::dpc::testnet2::V12_UPGRADE_BLOCK_HEIGHT\n+                                                && block.header().proof().is_hiding()\n+                                            {\n+                                                warn!(\"Peer {} is not V12-compliant, proceeding to disconnect\", peer_ip);\n+                                                break;\n                                             }\n \n                                             // Route the `BlockResponse` to the ledger.\n@@ -1118,11 +1143,12 @@ impl<N: Network, E: Environment> Peer<N, E> {\n \n                                             // TODO (howardwu): TEMPORARY - Remove this after testnet2.\n                                             // Sanity check for a V12 ledger.\n-                                            if N::NETWORK_ID == 2 && block_header.height() > snarkvm::dpc::testnet2::V12_UPGRADE_BLOCK_HEIGHT {\n-                                                if block_header.proof().as_ref().unwrap_or(N::genesis_block().header().proof().as_ref().unwrap()).is_hiding() {\n-                                                    warn!(\"Peer {} is not V12-compliant, proceeding to disconnect\", peer_ip);\n-                                                    break;\n-                                                }\n+                                            if N::NETWORK_ID == 2\n+                                                && block_header.height() > snarkvm::dpc::testnet2::V12_UPGRADE_BLOCK_HEIGHT\n+                                                && block_header.proof().is_hiding()\n+                                            {\n+                                                warn!(\"Peer {} is not V12-compliant, proceeding to disconnect\", peer_ip);\n+                                                break;\n                                             }\n \n                                             // Update the block header of the peer.\n@@ -1266,6 +1292,35 @@ impl<N: Network, E: Environment> Peer<N, E> {\n                                         }\n                                     }\n                                 }\n+                                Message::PoolRegister(address) => {\n+                                    if E::NODE_TYPE != NodeType::Operator {\n+                                        trace!(\"Skipping 'PoolRegister' from {}\", peer_ip);\n+                                    } else if let Err(error) = operator_router.send(OperatorRequest::PoolRegister(peer_ip, address)).await {\n+                                        warn!(\"[PoolRegister] {}\", error);\n+                                    }\n+                                }\n+                                Message::PoolRequest(share_difficulty, block_template) => {\n+                                    if E::NODE_TYPE != NodeType::Prover {\n+                                        trace!(\"Skipping 'PoolRequest' from {}\", peer_ip);\n+                                    } else if let Ok(block_template) = block_template.deserialize().await {\n+                                        if let Err(error) = prover_router.send(ProverRequest::PoolRequest(peer_ip, share_difficulty, block_template)).await {\n+                                            warn!(\"[PoolRequest] {}\", error);\n+                                        }\n+                                    } else {\n+                                        warn!(\"[PoolRequest] could not deserialize block template\");\n+                                    }\n+                                }\n+                                Message::PoolResponse(address, block_header) => {\n+                                    if E::NODE_TYPE != NodeType::Operator {\n+                                        trace!(\"Skipping 'PoolResponse' from {}\", peer_ip);\n+                                    } else if let Ok(block_header) = block_header.deserialize().await {\n+                                        if let Err(error) = operator_router.send(OperatorRequest::PoolResponse(peer_ip, block_header, address)).await {\n+                                            warn!(\"[PoolResponse] {}\", error);\n+                                        }\n+                                    } else {\n+                                        warn!(\"[PoolResponse] could not deserialize block\");\n+                                    }\n+                                }\n                                 Message::Unused(_) => break, // Peer is not following the protocol.\n                             }\n                         }\ndiff --git a/src/network/prover.rs b/src/network/prover.rs\nindex a1b2896768..526af07f86 100644\n--- a/src/network/prover.rs\n+++ b/src/network/prover.rs\n@@ -16,6 +16,7 @@\n \n use crate::{\n     helpers::{State, Status, Tasks},\n+    Data,\n     Environment,\n     LedgerReader,\n     LedgerRequest,\n@@ -28,7 +29,7 @@ use crate::{\n use snarkos_storage::{storage::Storage, ProverState};\n use snarkvm::dpc::prelude::*;\n \n-use anyhow::Result;\n+use anyhow::{anyhow, Result};\n use rand::thread_rng;\n use rayon::{ThreadPool, ThreadPoolBuilder};\n use std::{\n@@ -38,6 +39,7 @@ use std::{\n         atomic::{AtomicBool, Ordering},\n         Arc,\n     },\n+    time::Duration,\n };\n use tokio::{\n     sync::{mpsc, oneshot, RwLock},\n@@ -51,11 +53,16 @@ pub(crate) type ProverRouter<N> = mpsc::Sender<ProverRequest<N>>;\n /// Shorthand for the child half of the `Prover` message channel.\n type ProverHandler<N> = mpsc::Receiver<ProverRequest<N>>;\n \n+/// The miner heartbeat in seconds.\n+const MINER_HEARTBEAT_IN_SECONDS: Duration = Duration::from_secs(2);\n+\n ///\n /// An enum of requests that the `Prover` struct processes.\n ///\n #[derive(Debug)]\n pub enum ProverRequest<N: Network> {\n+    /// PoolRequest := (peer_ip, share_difficulty, block_template)\n+    PoolRequest(SocketAddr, u64, BlockTemplate<N>),\n     /// MemoryPoolClear := (block)\n     MemoryPoolClear(Option<Block<N>>),\n     /// UnconfirmedTransaction := (peer_ip, transaction)\n@@ -69,8 +76,12 @@ pub enum ProverRequest<N: Network> {\n pub struct Prover<N: Network, E: Environment> {\n     /// The state storage of the prover.\n     state: Arc<ProverState<N>>,\n-    /// The thread pool for the miner.\n-    miner: Arc<ThreadPool>,\n+    /// The Aleo address of the prover.\n+    address: Option<Address<N>>,\n+    /// The IP address of the connected pool.\n+    pool: Option<SocketAddr>,\n+    /// The thread pool for the prover.\n+    thread_pool: Arc<ThreadPool>,\n     /// The prover router of the node.\n     prover_router: ProverRouter<N>,\n     /// The pool of unconfirmed transactions.\n@@ -92,8 +103,9 @@ impl<N: Network, E: Environment> Prover<N, E> {\n     pub async fn open<S: Storage, P: AsRef<Path> + Copy>(\n         tasks: &mut Tasks<JoinHandle<()>>,\n         path: P,\n-        miner: Option<Address<N>>,\n+        address: Option<Address<N>>,\n         local_ip: SocketAddr,\n+        pool_ip: Option<SocketAddr>,\n         status: &Status,\n         terminator: &Arc<AtomicBool>,\n         peers_router: PeersRouter<N, E>,\n@@ -102,8 +114,8 @@ impl<N: Network, E: Environment> Prover<N, E> {\n     ) -> Result<Arc<Self>> {\n         // Initialize an mpsc channel for sending requests to the `Prover` struct.\n         let (prover_router, mut prover_handler) = mpsc::channel(1024);\n-        // Initialize the prover pool.\n-        let pool = ThreadPoolBuilder::new()\n+        // Initialize the prover thread pool.\n+        let thread_pool = ThreadPoolBuilder::new()\n             .stack_size(8 * 1024 * 1024)\n             .num_threads((num_cpus::get() / 8 * 7).max(1))\n             .build()?;\n@@ -111,7 +123,9 @@ impl<N: Network, E: Environment> Prover<N, E> {\n         // Initialize the prover.\n         let prover = Arc::new(Self {\n             state: Arc::new(ProverState::open_writer::<S, P>(path)?),\n-            miner: Arc::new(pool),\n+            address,\n+            pool: pool_ip,\n+            thread_pool: Arc::new(thread_pool),\n             prover_router,\n             memory_pool: Arc::new(RwLock::new(MemoryPool::new())),\n             status: status.clone(),\n@@ -138,78 +152,32 @@ impl<N: Network, E: Environment> Prover<N, E> {\n             let _ = handler.await;\n         }\n \n-        // Initialize a new instance of the miner.\n-        if E::NODE_TYPE == NodeType::Miner {\n-            if let Some(recipient) = miner {\n-                // Initialize the prover process.\n-                let prover = prover.clone();\n-                let tasks_clone = tasks.clone();\n-                let (router, handler) = oneshot::channel();\n-                tasks.append(task::spawn(async move {\n-                    // Notify the outer function that the task is ready.\n-                    let _ = router.send(());\n-                    loop {\n-                        // If `terminator` is `false` and the status is not `Peering` or `Mining` already, mine the next block.\n-                        if !prover.terminator.load(Ordering::SeqCst) && !prover.status.is_peering() && !prover.status.is_mining() {\n-                            // Set the status to `Mining`.\n-                            prover.status.update(State::Mining);\n-\n-                            // Prepare the unconfirmed transactions, terminator, and status.\n-                            let state = prover.state.clone();\n-                            let miner = prover.miner.clone();\n-                            let canon = prover.ledger_reader.clone(); // This is *safe* as the ledger only reads.\n-                            let unconfirmed_transactions = prover.memory_pool.read().await.transactions();\n-                            let terminator = prover.terminator.clone();\n-                            let status = prover.status.clone();\n-                            let ledger_router = prover.ledger_router.clone();\n-                            let prover_router = prover.prover_router.clone();\n-\n-                            tasks_clone.append(task::spawn(async move {\n-                                // Mine the next block.\n-                                let result = task::spawn_blocking(move || {\n-                                    miner.install(move || {\n-                                        canon.mine_next_block(\n-                                            recipient,\n-                                            E::COINBASE_IS_PUBLIC,\n-                                            &unconfirmed_transactions,\n-                                            &terminator,\n-                                            &mut thread_rng(),\n-                                        )\n-                                    })\n-                                })\n-                                .await\n-                                .map_err(|e| e.into());\n-\n-                                // Set the status to `Ready`.\n-                                status.update(State::Ready);\n+        // Initialize the miner, if the node type is a miner.\n+        if E::NODE_TYPE == NodeType::Miner && prover.pool.is_none() {\n+            Self::start_miner(tasks, prover.clone(), local_ip).await;\n+        }\n \n-                                match result {\n-                                    Ok(Ok((block, coinbase_record))) => {\n-                                        debug!(\"Miner has found unconfirmed block {} ({})\", block.height(), block.hash());\n-                                        // Store the coinbase record.\n-                                        if let Err(error) = state.add_coinbase_record(block.height(), coinbase_record) {\n-                                            warn!(\"[Miner] Failed to store coinbase record - {}\", error);\n-                                        }\n+        // Initialize the prover, if the node type is a prover.\n+        if E::NODE_TYPE == NodeType::Prover && prover.pool.is_some() {\n+            let prover = prover.clone();\n+            let (router, handler) = oneshot::channel();\n+            task::spawn(async move {\n+                // Notify the outer function that the task is ready.\n+                let _ = router.send(());\n+                loop {\n+                    // Sleep for `1` second.\n+                    tokio::time::sleep(std::time::Duration::from_secs(1)).await;\n \n-                                        // Broadcast the next block.\n-                                        let request = LedgerRequest::UnconfirmedBlock(local_ip, block, prover_router.clone());\n-                                        if let Err(error) = ledger_router.send(request).await {\n-                                            warn!(\"Failed to broadcast mined block - {}\", error);\n-                                        }\n-                                    }\n-                                    Ok(Err(error)) | Err(error) => trace!(\"{}\", error),\n-                                }\n-                            }));\n-                        }\n-                        // Sleep for 2 seconds.\n-                        tokio::time::sleep(std::time::Duration::from_secs(2)).await;\n+                    // TODO (howardwu): Check that the prover is connected to the pool before proceeding.\n+                    //  Currently we use a sleep function to probabilistically ensure the peer is connected.\n+                    if !prover.terminator.load(Ordering::SeqCst) && !prover.status.is_peering() && !prover.status.is_mining() {\n+                        prover.send_pool_register().await;\n                     }\n-                }));\n-                // Wait until the miner task is ready.\n-                let _ = handler.await;\n-            } else {\n-                error!(\"Missing miner address. Please specify an Aleo address in order to mine\");\n-            }\n+                }\n+            });\n+\n+            // Wait until the operator handler is ready.\n+            let _ = handler.await;\n         }\n \n         Ok(prover)\n@@ -236,6 +204,10 @@ impl<N: Network, E: Environment> Prover<N, E> {\n     ///\n     pub(super) async fn update(&self, request: ProverRequest<N>) {\n         match request {\n+            ProverRequest::PoolRequest(operator_ip, share_difficulty, block_template) => {\n+                // Process the pool request message.\n+                self.process_pool_request(operator_ip, share_difficulty, block_template).await;\n+            }\n             ProverRequest::MemoryPoolClear(block) => match block {\n                 Some(block) => self.memory_pool.write().await.remove_transactions(block.transactions()),\n                 None => *self.memory_pool.write().await = MemoryPool::new(),\n@@ -250,6 +222,97 @@ impl<N: Network, E: Environment> Prover<N, E> {\n         }\n     }\n \n+    ///\n+    /// Sends a `PoolRegister` message to the pool IP address.\n+    ///\n+    async fn send_pool_register(&self) {\n+        if E::NODE_TYPE == NodeType::Prover {\n+            if let Some(recipient) = self.address {\n+                if let Some(pool_ip) = self.pool {\n+                    // Proceed to register the prover to receive a block template.\n+                    let request = PeersRequest::MessageSend(pool_ip, Message::PoolRegister(recipient));\n+                    if let Err(error) = self.peers_router.send(request).await {\n+                        warn!(\"[PoolRegister] {}\", error);\n+                    }\n+                } else {\n+                    error!(\"Missing pool IP address. Please specify a pool IP address in order to run the prover\");\n+                }\n+            } else {\n+                error!(\"Missing prover address. Please specify an Aleo address in order to prove\");\n+            }\n+        }\n+    }\n+\n+    ///\n+    /// Processes a `PoolRequest` message from a pool operator.\n+    ///\n+    async fn process_pool_request(&self, operator_ip: SocketAddr, share_difficulty: u64, block_template: BlockTemplate<N>) {\n+        if E::NODE_TYPE == NodeType::Prover {\n+            if let Some(recipient) = self.address {\n+                if let Some(pool_ip) = self.pool {\n+                    // Refuse work from any pool other than the registered one.\n+                    if pool_ip == operator_ip {\n+                        // If `terminator` is `false` and the status is not `Peering` or `Mining`\n+                        // already, mine the next block.\n+                        if !self.terminator.load(Ordering::SeqCst) && !self.status.is_peering() && !self.status.is_mining() {\n+                            // Set the status to `Mining`.\n+                            self.status.update(State::Mining);\n+\n+                            let thread_pool = self.thread_pool.clone();\n+                            let block_template = block_template.clone();\n+                            let terminator = self.terminator.clone();\n+\n+                            let result = task::spawn_blocking(move || {\n+                                thread_pool.install(move || {\n+                                    loop {\n+                                        let block_header =\n+                                            BlockHeader::mine_once_unchecked(&block_template, &terminator, &mut thread_rng())?;\n+\n+                                        // Ensure the share difficulty target is met.\n+                                        if N::posw().verify(\n+                                            block_header.height(),\n+                                            share_difficulty,\n+                                            &vec![*block_header.to_header_root().unwrap(), *block_header.nonce()],\n+                                            block_header.proof(),\n+                                        ) {\n+                                            let proof_difficulty = block_header.proof().to_proof_difficulty()?;\n+                                            return Ok::<(BlockHeader<N>, u64), anyhow::Error>((block_header, proof_difficulty));\n+                                        }\n+                                    }\n+                                })\n+                            })\n+                            .await;\n+\n+                            self.status.update(State::Ready);\n+\n+                            match result {\n+                                Ok(Ok((block_header, proof_difficulty))) => {\n+                                    info!(\n+                                        \"Prover successfully mined a share for unconfirmed block {} with proof difficulty of {}\",\n+                                        block_header.height(),\n+                                        proof_difficulty\n+                                    );\n+\n+                                    // Send a `PoolResponse` to the operator.\n+                                    let message = Message::PoolResponse(recipient, Data::Object(block_header));\n+                                    if let Err(error) = self.peers_router.send(PeersRequest::MessageSend(operator_ip, message)).await {\n+                                        warn!(\"[PoolResponse] {}\", error);\n+                                    }\n+                                }\n+                                Ok(Err(error)) => trace!(\"{}\", error),\n+                                Err(error) => trace!(\"{}\", anyhow!(\"Could not mine next block {}\", error)),\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    error!(\"Missing pool IP address. Please specify a pool IP address in order to run the prover\");\n+                }\n+            } else {\n+                error!(\"Missing prover address. Please specify an Aleo address in order to prove\");\n+            }\n+        }\n+    }\n+\n     ///\n     /// Adds the given unconfirmed transaction to the memory pool.\n     ///\n@@ -272,4 +335,85 @@ impl<N: Network, E: Environment> Prover<N, E> {\n             }\n         }\n     }\n+\n+    ///\n+    /// Initialize the miner, if the node type is a miner.\n+    ///\n+    async fn start_miner(tasks: &mut Tasks<JoinHandle<()>>, prover: Arc<Self>, local_ip: SocketAddr) {\n+        // Initialize a new instance of the miner.\n+        if E::NODE_TYPE == NodeType::Miner && prover.pool.is_none() {\n+            if let Some(recipient) = prover.address {\n+                // Initialize the prover process.\n+                let prover = prover.clone();\n+                let tasks_clone = tasks.clone();\n+                let (router, handler) = oneshot::channel();\n+                tasks.append(task::spawn(async move {\n+                    // Notify the outer function that the task is ready.\n+                    let _ = router.send(());\n+                    loop {\n+                        // Prepare the status and terminator.\n+                        let status = prover.status.clone();\n+                        let terminator = prover.terminator.clone();\n+\n+                        // If `terminator` is `false` and the status is not `Peering` or `Mining` already, mine the next block.\n+                        if !terminator.load(Ordering::SeqCst) && !status.is_peering() && !status.is_mining() {\n+                            // Set the status to `Mining`.\n+                            status.update(State::Mining);\n+\n+                            // Prepare the unconfirmed transactions and dependent objects.\n+                            let state = prover.state.clone();\n+                            let thread_pool = prover.thread_pool.clone();\n+                            let canon = prover.ledger_reader.clone(); // This is *safe* as the ledger only reads.\n+                            let unconfirmed_transactions = prover.memory_pool.read().await.transactions();\n+                            let ledger_router = prover.ledger_router.clone();\n+                            let prover_router = prover.prover_router.clone();\n+\n+                            tasks_clone.append(task::spawn(async move {\n+                                // Mine the next block.\n+                                let result = task::spawn_blocking(move || {\n+                                    thread_pool.install(move || {\n+                                        canon.mine_next_block(\n+                                            recipient,\n+                                            E::COINBASE_IS_PUBLIC,\n+                                            &unconfirmed_transactions,\n+                                            &terminator,\n+                                            &mut thread_rng(),\n+                                        )\n+                                    })\n+                                })\n+                                .await\n+                                .map_err(|e| e.into());\n+\n+                                // Set the status to `Ready`.\n+                                status.update(State::Ready);\n+\n+                                match result {\n+                                    Ok(Ok((block, coinbase_record))) => {\n+                                        debug!(\"Miner has found unconfirmed block {} ({})\", block.height(), block.hash());\n+                                        // Store the coinbase record.\n+                                        if let Err(error) = state.add_coinbase_record(block.height(), coinbase_record) {\n+                                            warn!(\"[Miner] Failed to store coinbase record - {}\", error);\n+                                        }\n+\n+                                        // Broadcast the next block.\n+                                        let request = LedgerRequest::UnconfirmedBlock(local_ip, block, prover_router.clone());\n+                                        if let Err(error) = ledger_router.send(request).await {\n+                                            warn!(\"Failed to broadcast mined block - {}\", error);\n+                                        }\n+                                    }\n+                                    Ok(Err(error)) | Err(error) => trace!(\"{}\", error),\n+                                }\n+                            }));\n+                        }\n+                        // Proceed to sleep for a preset amount of time.\n+                        tokio::time::sleep(MINER_HEARTBEAT_IN_SECONDS).await;\n+                    }\n+                }));\n+                // Wait until the miner task is ready.\n+                let _ = handler.await;\n+            } else {\n+                error!(\"Missing miner address. Please specify an Aleo address in order to mine\");\n+            }\n+        }\n+    }\n }\ndiff --git a/src/network/server.rs b/src/network/server.rs\nindex 10c369ec8c..400dc18fc0 100644\n--- a/src/network/server.rs\n+++ b/src/network/server.rs\n@@ -16,14 +16,14 @@\n \n use crate::{\n     display::notification_message,\n+    environment::{Environment, NodeType},\n     helpers::{State, Status, Tasks},\n     ledger::{Ledger, LedgerRequest, LedgerRouter},\n+    operator::{Operator, OperatorRouter},\n     peers::{Peers, PeersRequest, PeersRouter},\n     prover::{Prover, ProverRouter},\n     rpc::initialize_rpc_server,\n-    Environment,\n     Node,\n-    NodeType,\n };\n use snarkos_storage::{storage::rocksdb::RocksDB, LedgerState};\n use snarkvm::prelude::*;\n@@ -55,6 +55,8 @@ pub struct Server<N: Network, E: Environment> {\n     peers: Arc<Peers<N, E>>,\n     /// The ledger of the node.\n     ledger: Arc<Ledger<N, E>>,\n+    /// The operator of the node.\n+    operator: Arc<Operator<N, E>>,\n     /// The prover of the node.\n     prover: Arc<Prover<N, E>>,\n     /// The list of tasks spawned by the node.\n@@ -66,7 +68,12 @@ impl<N: Network, E: Environment> Server<N, E> {\n     /// Starts the connection listener for peers.\n     ///\n     #[inline]\n-    pub async fn initialize(node: &Node, miner: Option<Address<N>>, mut tasks: Tasks<task::JoinHandle<()>>) -> Result<Self> {\n+    pub async fn initialize(\n+        node: &Node,\n+        address: Option<Address<N>>,\n+        pool_ip: Option<SocketAddr>,\n+        mut tasks: Tasks<task::JoinHandle<()>>,\n+    ) -> Result<Self> {\n         // Initialize a new TCP listener at the given IP.\n         let (local_ip, listener) = match TcpListener::bind(node.node).await {\n             Ok(listener) => (listener.local_addr().expect(\"Failed to fetch the local IP\"), listener),\n@@ -75,8 +82,11 @@ impl<N: Network, E: Environment> Server<N, E> {\n \n         // Initialize the ledger storage path.\n         let ledger_storage_path = node.ledger_storage_path(local_ip);\n+        // Initialize the operator storage path.\n+        let operator_storage_path = node.operator_storage_path(local_ip);\n         // Initialize the prover storage path.\n         let prover_storage_path = node.prover_storage_path(local_ip);\n+\n         // Initialize the status indicator.\n         let status = Status::new();\n         // Initialize the terminator bit.\n@@ -90,8 +100,9 @@ impl<N: Network, E: Environment> Server<N, E> {\n         let prover = Prover::open::<RocksDB, _>(\n             &mut tasks,\n             &prover_storage_path,\n-            miner,\n+            address,\n             local_ip,\n+            pool_ip,\n             &status,\n             &terminator,\n             peers.router(),\n@@ -99,6 +110,40 @@ impl<N: Network, E: Environment> Server<N, E> {\n             ledger.router(),\n         )\n         .await?;\n+        // Initialize a new instance for managing the operator.\n+        let operator = Operator::open::<RocksDB, _>(\n+            &mut tasks,\n+            &operator_storage_path,\n+            address,\n+            local_ip,\n+            prover.memory_pool(),\n+            peers.router(),\n+            ledger.reader(),\n+            ledger.router(),\n+            prover.router(),\n+        )\n+        .await?;\n+\n+        // TODO (howardwu): This is a hack for the prover.\n+        //  Check that the prover is connected to the pool before sending a PoolRegister message.\n+        if let Some(pool_ip) = pool_ip {\n+            // Initialize the connection process.\n+            let (router, handler) = oneshot::channel();\n+            // Route a `Connect` request to the pool.\n+            peers\n+                .router()\n+                .send(PeersRequest::Connect(\n+                    pool_ip,\n+                    ledger.reader(),\n+                    ledger.router(),\n+                    operator.router(),\n+                    prover.router(),\n+                    router,\n+                ))\n+                .await?;\n+            // Wait until the connection task is initialized.\n+            let _ = handler.await;\n+        }\n \n         // Initialize the connection listener for new peers.\n         Self::initialize_listener(\n@@ -109,11 +154,20 @@ impl<N: Network, E: Environment> Server<N, E> {\n             peers.clone(),\n             ledger.reader(),\n             ledger.router(),\n+            operator.router(),\n             prover.router(),\n         )\n         .await;\n         // Initialize a new instance of the heartbeat.\n-        Self::initialize_heartbeat(&mut tasks, peers.router(), ledger.reader(), ledger.router(), prover.router()).await;\n+        Self::initialize_heartbeat(\n+            &mut tasks,\n+            peers.router(),\n+            ledger.reader(),\n+            ledger.router(),\n+            operator.router(),\n+            prover.router(),\n+        )\n+        .await;\n         // Initialize a new instance of the RPC server.\n         Self::initialize_rpc(\n             &mut tasks,\n@@ -126,13 +180,14 @@ impl<N: Network, E: Environment> Server<N, E> {\n         )\n         .await;\n         // Initialize a new instance of the notification.\n-        Self::initialize_notification(&mut tasks, ledger.reader(), prover.clone(), miner).await;\n+        Self::initialize_notification(&mut tasks, ledger.reader(), prover.clone(), address).await;\n \n         Ok(Self {\n             local_ip,\n             status,\n             peers,\n             ledger,\n+            operator,\n             prover,\n             tasks,\n         })\n@@ -168,6 +223,7 @@ impl<N: Network, E: Environment> Server<N, E> {\n                 peer_ip,\n                 self.ledger.reader(),\n                 self.ledger.router(),\n+                self.operator.router(),\n                 self.prover.router(),\n                 router,\n             ))\n@@ -214,6 +270,7 @@ impl<N: Network, E: Environment> Server<N, E> {\n         peers: Arc<Peers<N, E>>,\n         ledger_reader: LedgerReader<N>,\n         ledger_router: LedgerRouter<N>,\n+        operator_router: OperatorRouter<N>,\n         prover_router: ProverRouter<N>,\n     ) {\n         // Initialize the listener process.\n@@ -234,6 +291,7 @@ impl<N: Network, E: Environment> Server<N, E> {\n                                 peer_ip,\n                                 ledger_reader.clone(),\n                                 ledger_router.clone(),\n+                                operator_router.clone(),\n                                 prover_router.clone(),\n                             );\n                             if let Err(error) = peers_router.send(request).await {\n@@ -263,6 +321,7 @@ impl<N: Network, E: Environment> Server<N, E> {\n         peers_router: PeersRouter<N, E>,\n         ledger_reader: LedgerReader<N>,\n         ledger_router: LedgerRouter<N>,\n+        operator_router: OperatorRouter<N>,\n         prover_router: ProverRouter<N>,\n     ) {\n         // Initialize the heartbeat process.\n@@ -276,7 +335,12 @@ impl<N: Network, E: Environment> Server<N, E> {\n                     error!(\"Failed to send heartbeat to ledger: {}\", error)\n                 }\n                 // Transmit a heartbeat request to the peers.\n-                let request = PeersRequest::Heartbeat(ledger_reader.clone(), ledger_router.clone(), prover_router.clone());\n+                let request = PeersRequest::Heartbeat(\n+                    ledger_reader.clone(),\n+                    ledger_router.clone(),\n+                    operator_router.clone(),\n+                    prover_router.clone(),\n+                );\n                 if let Err(error) = peers_router.send(request).await {\n                     error!(\"Failed to send heartbeat to peers: {}\", error)\n                 }\n@@ -327,7 +391,7 @@ impl<N: Network, E: Environment> Server<N, E> {\n         tasks: &mut Tasks<task::JoinHandle<()>>,\n         ledger: LedgerReader<N>,\n         prover: Arc<Prover<N, E>>,\n-        miner: Option<Address<N>>,\n+        address: Option<Address<N>>,\n     ) {\n         // Initialize the heartbeat process.\n         let (router, handler) = oneshot::channel();\n@@ -335,10 +399,10 @@ impl<N: Network, E: Environment> Server<N, E> {\n             // Notify the outer function that the task is ready.\n             let _ = router.send(());\n             loop {\n-                info!(\"{}\", notification_message(miner));\n+                info!(\"{}\", notification_message(address));\n \n                 if E::NODE_TYPE == NodeType::Miner {\n-                    if let Some(miner) = miner {\n+                    if let Some(miner_address) = address {\n                         // Retrieve the latest block height.\n                         let latest_block_height = ledger.latest_block_height();\n \n@@ -351,7 +415,7 @@ impl<N: Network, E: Environment> Server<N, E> {\n                             // Filter the coinbase records by determining if they exist on the canonical chain.\n                             if let Ok(true) = ledger.contains_commitment(&record.commitment()) {\n                                 // Ensure the record owner matches.\n-                                if record.owner() == miner {\n+                                if record.owner() == miner_address {\n                                     // Add the block to the appropriate list.\n                                     match block_height + 2048 < latest_block_height {\n                                         true => confirmed.push((block_height, record)),\n@@ -365,7 +429,7 @@ impl<N: Network, E: Environment> Server<N, E> {\n                             \"Mining Report (confirmed_blocks = {}, pending_blocks = {}, miner_address = {})\",\n                             confirmed.len(),\n                             pending.len(),\n-                            miner\n+                            miner_address\n                         );\n                     }\n                 }\ndiff --git a/src/node.rs b/src/node.rs\nindex 43c2c3f2a4..e360d014a2 100644\n--- a/src/node.rs\n+++ b/src/node.rs\n@@ -15,16 +15,10 @@\n // along with the snarkOS library. If not, see <https://www.gnu.org/licenses/>.\n \n use crate::{\n+    environment::{Client, ClientTrial, Environment, Miner, MinerTrial, NodeType, Operator, OperatorTrial, Prover, ProverTrial, SyncNode},\n     helpers::{Tasks, Updater},\n     network::Server,\n-    Client,\n-    ClientTrial,\n     Display,\n-    Environment,\n-    Miner,\n-    MinerTrial,\n-    NodeType,\n-    SyncNode,\n };\n use snarkos_storage::storage::rocksdb::RocksDB;\n use snarkvm::dpc::{prelude::*, testnet2::Testnet2};\n@@ -46,6 +40,15 @@ pub struct Node {\n     /// Specify this as a mining node, with the given miner address.\n     #[structopt(long = \"miner\")]\n     pub miner: Option<String>,\n+    /// Specify this as an operating node, with the given operator address.\n+    #[structopt(long = \"operator\")]\n+    pub operator: Option<String>,\n+    /// Specify this as a prover node, with the given prover address.\n+    #[structopt(long = \"prover\")]\n+    pub prover: Option<String>,\n+    /// Specify the pool that a prover node is contributing to.\n+    #[structopt(long = \"pool\")]\n+    pub pool: Option<SocketAddr>,\n     /// Specify the network of this node.\n     #[structopt(default_value = \"2\", long = \"network\")]\n     pub network: u16,\n@@ -91,12 +94,16 @@ impl Node {\n                 println!(\"{}\", command.parse()?);\n                 Ok(())\n             }\n-            None => match (self.network, self.miner.is_some(), self.trial, self.sync) {\n-                (2, _, _, true) => self.start_server::<Testnet2, SyncNode<Testnet2>>().await,\n-                (2, true, false, false) => self.start_server::<Testnet2, Miner<Testnet2>>().await,\n-                (2, false, false, false) => self.start_server::<Testnet2, Client<Testnet2>>().await,\n-                (2, true, true, false) => self.start_server::<Testnet2, MinerTrial<Testnet2>>().await,\n-                (2, false, true, false) => self.start_server::<Testnet2, ClientTrial<Testnet2>>().await,\n+            None => match (self.network, &self.miner, &self.operator, &self.prover, self.trial, self.sync) {\n+                (2, None, None, None, false, false) => self.start_server::<Testnet2, Client<Testnet2>>(&None).await,\n+                (2, Some(_), None, None, false, false) => self.start_server::<Testnet2, Miner<Testnet2>>(&self.miner).await,\n+                (2, None, Some(_), None, false, false) => self.start_server::<Testnet2, Operator<Testnet2>>(&self.operator).await,\n+                (2, None, None, Some(_), false, false) => self.start_server::<Testnet2, Prover<Testnet2>>(&self.prover).await,\n+                (2, None, None, None, true, false) => self.start_server::<Testnet2, ClientTrial<Testnet2>>(&None).await,\n+                (2, Some(_), None, None, true, false) => self.start_server::<Testnet2, MinerTrial<Testnet2>>(&self.miner).await,\n+                (2, None, Some(_), None, true, false) => self.start_server::<Testnet2, OperatorTrial<Testnet2>>(&self.operator).await,\n+                (2, None, None, Some(_), true, false) => self.start_server::<Testnet2, ProverTrial<Testnet2>>(&self.prover).await,\n+                (2, None, None, None, _, true) => self.start_server::<Testnet2, SyncNode<Testnet2>>(&None).await,\n                 _ => panic!(\"Unsupported node configuration\"),\n             },\n         }\n@@ -115,6 +122,19 @@ impl Node {\n         }\n     }\n \n+    /// Returns the storage path of the operator.\n+    pub(crate) fn operator_storage_path(&self, _local_ip: SocketAddr) -> PathBuf {\n+        cfg_if::cfg_if! {\n+            if #[cfg(feature = \"test\")] {\n+                // Tests may use any available ports, and removes the storage artifacts afterwards,\n+                // so that there is no need to adhere to a specific number assignment logic.\n+                PathBuf::from(format!(\"/tmp/snarkos-test-operator-{}\", _local_ip.port()))\n+            } else {\n+                aleo_std::aleo_operator_dir(self.network, self.dev)\n+            }\n+        }\n+    }\n+\n     /// Returns the storage path of the prover.\n     pub(crate) fn prover_storage_path(&self, _local_ip: SocketAddr) -> PathBuf {\n         cfg_if::cfg_if! {\n@@ -128,29 +148,26 @@ impl Node {\n         }\n     }\n \n-    async fn start_server<N: Network, E: Environment>(&self) -> Result<()> {\n-        let miner = match (E::NODE_TYPE, &self.miner) {\n-            (NodeType::Miner, Some(address)) => {\n-                let miner_address = Address::<N>::from_str(address)?;\n-                println!(\"{}\", crate::display::welcome_message());\n-                println!(\"Your Aleo address is {}.\\n\", miner_address);\n-                println!(\"Starting a mining node on {}.\", N::NETWORK_NAME);\n-                println!(\"{}\", crate::display::notification_message::<N>(Some(miner_address)));\n-                Some(miner_address)\n-            }\n-            _ => {\n-                println!(\"{}\", crate::display::welcome_message());\n-                println!(\"Starting a {} node on {}.\", E::NODE_TYPE, N::NETWORK_NAME);\n-                println!(\"{}\", crate::display::notification_message::<N>(None));\n-                None\n+    async fn start_server<N: Network, E: Environment>(&self, address: &Option<String>) -> Result<()> {\n+        println!(\"{}\", crate::display::welcome_message());\n+\n+        let address = match (E::NODE_TYPE, address) {\n+            (NodeType::Miner, Some(address)) | (NodeType::Operator, Some(address)) | (NodeType::Prover, Some(address)) => {\n+                let address = Address::<N>::from_str(address)?;\n+                println!(\"Your Aleo address is {}.\\n\", address);\n+                Some(address)\n             }\n+            _ => None,\n         };\n \n+        println!(\"Starting {} on {}.\", E::NODE_TYPE.description(), N::NETWORK_NAME);\n+        println!(\"{}\", crate::display::notification_message::<N>(address));\n+\n         // Initialize the tasks handler.\n         let tasks = Tasks::new();\n \n         // Initialize the node's server.\n-        let server = Server::<N, E>::initialize(self, miner, tasks.clone()).await?;\n+        let server = Server::<N, E>::initialize(self, address, self.pool, tasks.clone()).await?;\n \n         // Initialize signal handling; it also maintains ownership of the Server\n         // in order for it to not go out of scope.\n@@ -353,7 +370,7 @@ impl Experimental {\n \n #[derive(StructOpt, Debug)]\n pub enum ExperimentalCommands {\n-    #[structopt(name = \"new_account\", about = \"Generate a new Aleo Account.\")]\n+    #[structopt(name = \"new_account\", about = \"Generate a new Aleo account.\")]\n     NewAccount(NewAccount),\n }\n \ndiff --git a/src/rpc/rpc.rs b/src/rpc/rpc.rs\nindex 436500fd3f..df87e967a0 100644\n--- a/src/rpc/rpc.rs\n+++ b/src/rpc/rpc.rs\n@@ -424,7 +424,7 @@ fn result_to_response<T: Serialize>(\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::{helpers::State, ledger::Ledger, Client, Prover};\n+    use crate::{environment::Client, helpers::State, ledger::Ledger, network::Prover};\n \n     use crate::helpers::Tasks;\n     use snarkos_storage::{\n@@ -501,6 +501,7 @@ mod tests {\n             &prover_path,\n             None,\n             local_ip,\n+            Some(local_ip),\n             &status,\n             &terminator,\n             peers.router(),\n@@ -547,6 +548,7 @@ mod tests {\n             &prover_path,\n             None,\n             local_ip,\n+            Some(local_ip),\n             &status,\n             &terminator,\n             peers.router(),\ndiff --git a/storage/Cargo.toml b/storage/Cargo.toml\nindex b50105575f..71dbb0c14e 100644\n--- a/storage/Cargo.toml\n+++ b/storage/Cargo.toml\n@@ -17,7 +17,7 @@ license = \"GPL-3.0\"\n edition = \"2018\"\n \n [dependencies]\n-snarkvm = { git = \"https://github.com/AleoHQ/snarkVM.git\", rev = \"02c814c\" }\n+snarkvm = { git = \"https://github.com/AleoHQ/snarkVM.git\", rev = \"b70bf72\" }\n #snarkvm = { path = \"../../snarkVM\" }\n \n [dependencies.anyhow]\ndiff --git a/storage/src/helpers/block_locators.rs b/storage/src/helpers/block_locators.rs\nindex 80530843c9..fe8206b261 100644\n--- a/storage/src/helpers/block_locators.rs\n+++ b/storage/src/helpers/block_locators.rs\n@@ -193,7 +193,7 @@ mod tests {\n         // Serialize\n         let expected_string = expected_block_locators.to_string();\n         let candidate_string = serde_json::to_string(&expected_block_locators).unwrap();\n-        assert_eq!(1692, candidate_string.len(), \"Update me if serialization has changed\");\n+        assert_eq!(1703, candidate_string.len(), \"Update me if serialization has changed\");\n         assert_eq!(expected_string, candidate_string);\n \n         // Deserialize\ndiff --git a/storage/src/lib.rs b/storage/src/lib.rs\nindex 41e5e800ba..ee6cecbdba 100644\n--- a/storage/src/lib.rs\n+++ b/storage/src/lib.rs\n@@ -24,6 +24,7 @@ pub(crate) mod state;\n pub use state::{\n     LedgerState,\n     Metadata,\n+    OperatorState,\n     ProverState,\n     MAXIMUM_BLOCK_LOCATORS,\n     MAXIMUM_LINEAR_BLOCK_LOCATORS,\ndiff --git a/storage/src/state/ledger.rs b/storage/src/state/ledger.rs\nindex 50f5c61654..eb12ba837f 100644\n--- a/storage/src/state/ledger.rs\n+++ b/storage/src/state/ledger.rs\n@@ -155,6 +155,7 @@ impl<N: Network> LedgerState<N> {\n         {\n             let revert_block_height = snarkvm::dpc::testnet2::V12_UPGRADE_BLOCK_HEIGHT.saturating_sub(1);\n             warn!(\"Ledger is not V12-compliant, reverting to block {}\", revert_block_height);\n+            warn!(\"{:?}\", ledger.get_block(latest_block_height));\n             latest_block_height = ledger.clear_incompatible_blocks(latest_block_height, revert_block_height)?;\n             info!(\"Ledger successfully transitioned and is now V12-compliant\");\n         }\n@@ -600,17 +601,20 @@ impl<N: Network> LedgerState<N> {\n         is_public: bool,\n         transactions: &[Transaction<N>],\n         rng: &mut R,\n-    ) -> Result<(BlockTemplate<N>, Record<N>)> {\n-        // Prepare the new block.\n-        let previous_block_hash = self.latest_block_hash();\n-        let block_height = self.latest_block_height().saturating_add(1);\n+    ) -> Result<BlockTemplate<N>> {\n+        // Fetch the latest state of the ledger.\n+        let latest_block = self.latest_block();\n+        let previous_ledger_root = self.latest_ledger_root();\n \n+        // Prepare the new block.\n+        let previous_block_hash = latest_block.hash();\n+        let block_height = latest_block.height().saturating_add(1);\n         // Ensure that the new timestamp is ahead of the previous timestamp.\n-        let block_timestamp = std::cmp::max(chrono::Utc::now().timestamp(), self.latest_block_timestamp().saturating_add(1));\n+        let block_timestamp = std::cmp::max(chrono::Utc::now().timestamp(), latest_block.timestamp().saturating_add(1));\n \n         // Compute the block difficulty target.\n         let difficulty_target = if N::NETWORK_ID == 2 && block_height <= snarkvm::dpc::testnet2::V12_UPGRADE_BLOCK_HEIGHT {\n-            Blocks::<N>::compute_difficulty_target(self.latest_block().header(), block_timestamp, block_height)\n+            Blocks::<N>::compute_difficulty_target(latest_block.header(), block_timestamp, block_height)\n         } else if N::NETWORK_ID == 2 {\n             let anchor_block_header = self.get_block_header(snarkvm::dpc::testnet2::V12_UPGRADE_BLOCK_HEIGHT)?;\n             Blocks::<N>::compute_difficulty_target(&anchor_block_header, block_timestamp, block_height)\n@@ -619,24 +623,22 @@ impl<N: Network> LedgerState<N> {\n         };\n \n         // Compute the cumulative weight.\n-        let cumulative_weight = self\n-            .latest_cumulative_weight()\n+        let cumulative_weight = latest_block\n+            .cumulative_weight()\n             .saturating_add((u64::MAX / difficulty_target) as u128);\n \n-        // Construct the ledger root.\n-        let ledger_root = self.latest_ledger_root();\n-        // Craft a coinbase transaction.\n-        let amount = Block::<N>::block_reward(block_height);\n-        let (coinbase_transaction, coinbase_record) = Transaction::<N>::new_coinbase(recipient, amount, is_public, rng)?;\n+        // Compute the coinbase reward (not including the transaction fees).\n+        let mut coinbase_reward = Block::<N>::block_reward(block_height);\n+        let mut transaction_fees = AleoAmount::ZERO;\n+\n         // Filter the transactions to ensure they are new, and append the coinbase transaction.\n-        // TODO (howardwu): Improve the performance and design of this.\n         let mut transactions: Vec<Transaction<N>> = transactions\n             .iter()\n             .filter(|transaction| {\n                 for serial_number in transaction.serial_numbers() {\n                     if let Ok(true) = self.contains_serial_number(serial_number) {\n                         trace!(\n-                            \"Miner is filtering out transaction {} (serial_number {})\",\n+                            \"Ledger is filtering out transaction {} (serial_number {})\",\n                             transaction.transaction_id(),\n                             serial_number\n                         );\n@@ -646,34 +648,41 @@ impl<N: Network> LedgerState<N> {\n                 for commitment in transaction.commitments() {\n                     if let Ok(true) = self.contains_commitment(commitment) {\n                         trace!(\n-                            \"Miner is filtering out transaction {} (commitment {})\",\n+                            \"Ledger is filtering out transaction {} (commitment {})\",\n                             transaction.transaction_id(),\n                             commitment\n                         );\n                         return false;\n                     }\n                 }\n-                trace!(\"Miner is adding transaction {}\", transaction.transaction_id());\n+                trace!(\"Adding transaction {} to block template\", transaction.transaction_id());\n+                transaction_fees = transaction_fees.add(transaction.value_balance());\n                 true\n             })\n             .cloned()\n             .collect();\n+\n+        // Calculate the final coinbase reward (including the transaction fees).\n+        coinbase_reward = coinbase_reward.add(transaction_fees);\n+\n+        // Craft a coinbase transaction, and append it to the list of transactions.\n+        let (coinbase_transaction, coinbase_record) = Transaction::<N>::new_coinbase(recipient, coinbase_reward, is_public, rng)?;\n         transactions.push(coinbase_transaction);\n+\n         // Construct the new block transactions.\n         let transactions = Transactions::from(&transactions)?;\n \n         // Construct the block template.\n-        let template = BlockTemplate::new(\n+        Ok(BlockTemplate::new(\n             previous_block_hash,\n             block_height,\n             block_timestamp,\n             difficulty_target,\n             cumulative_weight,\n-            ledger_root,\n+            previous_ledger_root,\n             transactions,\n-        );\n-\n-        Ok((template, coinbase_record))\n+            coinbase_record,\n+        ))\n     }\n \n     /// Mines a new block using the latest state of the given ledger.\n@@ -685,10 +694,11 @@ impl<N: Network> LedgerState<N> {\n         terminator: &AtomicBool,\n         rng: &mut R,\n     ) -> Result<(Block<N>, Record<N>)> {\n-        let (template, coinbase_record) = self.get_block_template(recipient, is_public, transactions, rng)?;\n+        let template = self.get_block_template(recipient, is_public, transactions, rng)?;\n+        let coinbase_record = template.coinbase_record().clone();\n \n         // Mine the next block.\n-        match Block::mine(template, terminator, rng) {\n+        match Block::mine(&template, terminator, rng) {\n             Ok(block) => Ok((block, coinbase_record)),\n             Err(error) => Err(anyhow!(\"Unable to mine the next block: {}\", error)),\n         }\n@@ -1189,6 +1199,8 @@ impl<N: Network> LedgerState<N> {\n \n             // Decrement the current block height, and update the current block.\n             current_block_height = current_block_height.saturating_sub(1);\n+\n+            trace!(\"Ledger successfully reverted to block {}\", current_block_height);\n         }\n         Ok(current_block_height)\n     }\ndiff --git a/storage/src/state/mod.rs b/storage/src/state/mod.rs\nindex 177bfa10ea..5bbc304b9d 100644\n--- a/storage/src/state/mod.rs\n+++ b/storage/src/state/mod.rs\n@@ -17,6 +17,9 @@\n pub(crate) mod ledger;\n pub use ledger::{LedgerState, Metadata, MAXIMUM_BLOCK_LOCATORS, MAXIMUM_LINEAR_BLOCK_LOCATORS, MAXIMUM_QUADRATIC_BLOCK_LOCATORS};\n \n+pub(crate) mod operator;\n+pub use operator::OperatorState;\n+\n pub(crate) mod prover;\n pub use prover::ProverState;\n \ndiff --git a/storage/src/state/operator.rs b/storage/src/state/operator.rs\nnew file mode 100644\nindex 0000000000..c1ba0478c3\n--- /dev/null\n+++ b/storage/src/state/operator.rs\n@@ -0,0 +1,151 @@\n+// Copyright (C) 2019-2021 Aleo Systems Inc.\n+// This file is part of the snarkOS library.\n+\n+// The snarkOS library is free software: you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation, either version 3 of the License, or\n+// (at your option) any later version.\n+\n+// The snarkOS library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with the snarkOS library. If not, see <https://www.gnu.org/licenses/>.\n+\n+use crate::{\n+    state::LedgerState,\n+    storage::{DataMap, Map, MapId, Storage},\n+};\n+use snarkvm::dpc::prelude::*;\n+\n+use anyhow::{anyhow, Result};\n+use std::{collections::HashMap, path::Path, sync::Arc};\n+\n+#[derive(Debug)]\n+pub struct OperatorState<N: Network> {\n+    shares: SharesState<N>,\n+}\n+\n+impl<N: Network> OperatorState<N> {\n+    ///\n+    /// Opens a new writable instance of `OperatorState` from the given storage path.\n+    ///\n+    pub fn open_writer<S: Storage, P: AsRef<Path>>(path: P) -> Result<Self> {\n+        // Open storage.\n+        let context = N::NETWORK_ID;\n+        let is_read_only = false;\n+        let storage = S::open(path, context, is_read_only)?;\n+\n+        // Initialize the operator.\n+        let operator = Self {\n+            shares: SharesState::open(storage)?,\n+        };\n+\n+        info!(\"Operator successfully initialized\");\n+        Ok(operator)\n+    }\n+\n+    /// Returns all the shares in storage.\n+    pub fn to_shares(&self) -> Vec<((u32, Record<N>), HashMap<Address<N>, u64>)> {\n+        self.shares.to_shares()\n+    }\n+\n+    /// Returns all coinbase records in storage.\n+    pub fn to_coinbase_records(&self) -> Vec<(u32, Record<N>)> {\n+        self.shares.to_records()\n+    }\n+\n+    /// Returns the shares for a specific block, given the block height and coinbase record.\n+    pub fn get_shares_for_block(&self, block_height: u32, coinbase_record: Record<N>) -> Result<HashMap<Address<N>, u64>> {\n+        self.shares.get_shares_for_block(block_height, coinbase_record)\n+    }\n+\n+    /// Returns the shares for a specific prover, given a ledger and the prover address.\n+    pub fn get_shares_for_prover(&self, ledger: &Arc<LedgerState<N>>, prover: &Address<N>) -> u64 {\n+        self.shares.get_shares_for_prover(ledger, prover)\n+    }\n+\n+    /// Increments the share count by one for a given block height, coinbase record and prover address.\n+    pub fn increment_share(&self, block_height: u32, coinbase_record: Record<N>, prover: &Address<N>) -> Result<()> {\n+        self.shares.increment_share(block_height, coinbase_record, prover)\n+    }\n+\n+    /// Removes the shares for a given block height and coinbase record in storage.\n+    pub fn remove_shares(&self, block_height: u32, coinbase_record: Record<N>) -> Result<()> {\n+        self.shares.remove_shares(block_height, coinbase_record)\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+#[allow(clippy::type_complexity)]\n+struct SharesState<N: Network> {\n+    /// The miner shares for each block.\n+    shares: DataMap<(u32, Record<N>), HashMap<Address<N>, u64>>,\n+}\n+\n+impl<N: Network> SharesState<N> {\n+    /// Initializes a new instance of `SharesState`.\n+    fn open<S: Storage>(storage: S) -> Result<Self> {\n+        Ok(Self {\n+            shares: storage.open_map(MapId::Shares)?,\n+        })\n+    }\n+\n+    /// Returns all shares in storage.\n+    fn to_shares(&self) -> Vec<((u32, Record<N>), HashMap<Address<N>, u64>)> {\n+        self.shares.iter().collect()\n+    }\n+\n+    /// Returns all records in storage.\n+    fn to_records(&self) -> Vec<(u32, Record<N>)> {\n+        self.shares.keys().collect()\n+    }\n+\n+    /// Returns the shares for a specific block, given the block height and coinbase record.\n+    fn get_shares_for_block(&self, block_height: u32, coinbase_record: Record<N>) -> Result<HashMap<Address<N>, u64>> {\n+        match self.shares.get(&(block_height, coinbase_record))? {\n+            Some(shares) => Ok(shares),\n+            None => return Err(anyhow!(\"Block {} does not exist in shares storage\", block_height)),\n+        }\n+    }\n+\n+    /// Returns the shares for a specific prover, given a ledger and the prover address.\n+    fn get_shares_for_prover(&self, ledger: &Arc<LedgerState<N>>, prover: &Address<N>) -> u64 {\n+        self.shares\n+            .iter()\n+            .filter_map(|((_, coinbase_record), shares)| {\n+                if !shares.contains_key(prover) {\n+                    None\n+                } else {\n+                    match ledger.contains_commitment(&coinbase_record.commitment()) {\n+                        Ok(true) => shares.get(prover).copied(),\n+                        Ok(false) | Err(_) => None,\n+                    }\n+                }\n+            })\n+            .sum()\n+    }\n+\n+    /// Increments the share count by one for a given block height, coinbase record, and prover address.\n+    fn increment_share(&self, block_height: u32, coinbase_record: Record<N>, prover: &Address<N>) -> Result<()> {\n+        // Retrieve the current shares for a given block height.\n+        let mut shares = match self.shares.get(&(block_height, coinbase_record.clone()))? {\n+            Some(shares) => shares,\n+            None => HashMap::new(),\n+        };\n+\n+        // Increment the share count for the given address.\n+        let entry = shares.entry(*prover).or_insert(0);\n+        *entry = entry.saturating_add(1);\n+\n+        // Insert the updated shares for the given block height.\n+        self.shares.insert(&(block_height, coinbase_record), &shares)\n+    }\n+\n+    /// Removes all of the shares for a given block height and coinbase record.\n+    fn remove_shares(&self, block_height: u32, coinbase_record: Record<N>) -> Result<()> {\n+        self.shares.remove(&(block_height, coinbase_record))\n+    }\n+}\ndiff --git a/storage/src/storage/rocksdb/map.rs b/storage/src/storage/rocksdb/map.rs\nindex e05ea63240..1480bf1679 100644\n--- a/storage/src/storage/rocksdb/map.rs\n+++ b/storage/src/storage/rocksdb/map.rs\n@@ -27,6 +27,7 @@ pub enum MapId {\n     SerialNumbers,\n     Transactions,\n     Transitions,\n+    Shares,\n     #[cfg(test)]\n     Test,\n }\n@@ -43,6 +44,7 @@ impl MapId {\n             Self::SerialNumbers => b\"serial_numbers\",\n             Self::Transactions => b\"transactions\",\n             Self::Transitions => b\"transitions\",\n+            Self::Shares => b\"shares\",\n             #[cfg(test)]\n             Self::Test => b\"hello world\",\n         }\n", "test_patch": "diff --git a/testing/Cargo.toml b/testing/Cargo.toml\nindex 67b09a297a..3440cd3652 100644\n--- a/testing/Cargo.toml\n+++ b/testing/Cargo.toml\n@@ -25,7 +25,7 @@ path = \"../storage\"\n \n [dependencies.snarkvm]\n git = \"https://github.com/AleoHQ/snarkVM.git\"\n-rev = \"02c814c\"\n+rev = \"b70bf72\"\n #path = \"../../snarkVM\"\n \n [dependencies.anyhow]\ndiff --git a/testing/src/client_node.rs b/testing/src/client_node.rs\nindex 2af3608f29..b467932537 100644\n--- a/testing/src/client_node.rs\n+++ b/testing/src/client_node.rs\n@@ -58,7 +58,7 @@ impl ClientNode {\n         let permanent_args = &[\"snarkos\", \"--norpc\"];\n         let combined_args = permanent_args.iter().chain(extra_args.iter());\n         let config = snarkos::Node::from_iter(combined_args);\n-        let server = Server::<Testnet2, Client<Testnet2>>::initialize(&config, None, Tasks::new())\n+        let server = Server::<Testnet2, Client<Testnet2>>::initialize(&config, None, None, Tasks::new())\n             .await\n             .unwrap();\n \n", "problem_statement": "[Bug][Pool S/W] Failed to initialize a block from given inputs due to Invalid block header\n## \ud83d\udc1b Bug Report\r\n\r\n<!--\r\n    What's the bug in snarkOS that you found?\r\n    How serious is this bug and what is affected?\r\n    \r\n    To report a security issue in snarkOS, please email security@aleo.org.\r\n-->\r\n\r\nI was testing the pool s/w in feat/mining-pool branch. [mining-pool latest codebase](https://github.com/AleoHQ/snarkOS/commit/eb4fd9133b63323ba90efd1be78f32452f8714cc)\r\nIt seems that Prover cannot found the block due to Invalid block header.\r\nI'm not sure it was caused by lack of hash power on prover, but I cannot found to send a PoolResponse to the operator at all.\r\n(FYI, I added some log to tracking block height, difficulty and nonce.)\r\n\r\n```\r\n2021-12-22T07:10:18.269644Z TRACE Received 'PoolRequest' from 95.214.55.117:4132\r\n2021-12-22T07:10:18.341725Z DEBUG prover.process_pool_request()\r\n2021-12-22 07:10:18.341817883 UTC --> header.mine_once_unchecked() height 71200, target 660876088681118, nonce hn1qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq5dj2mk\r\n2021-12-22 07:10:20.887372256 UTC posw.mine_once_unchecked(), height 71200, block_header.difficulty_target 660876088681118, nonce hn1xsnrwyqmc5l976maevuhlv4ae0tjtyd39q8d5af8kyg4rdptn5zqg7p4mf\r\n2021-12-22 07:10:20.887610660 UTC <-- header.mine_once_unchecked() height 71200, target 660876088681118, nonce hn1xsnrwyqmc5l976maevuhlv4ae0tjtyd39q8d5af8kyg4rdptn5zqg7p4mf\r\n2021-12-22T07:10:20.925679Z DEBUG start new block, share_difficulty 9223372036854775807\r\n2021-12-22T07:10:20.925693Z DEBUG block_header.difficulty_target : 660876088681118\r\n2021-12-22T07:10:20.925695Z DEBUG block_header.nonce : hn1xsnrwyqmc5l976maevuhlv4ae0tjtyd39q8d5af8kyg4rdptn5zqg7p4mf\r\n2021-12-22 07:10:20.925699932 UTC block.new(), Initialize a new block\r\n2021-12-22 07:10:20.926271 UTC block.from() Construct the block. header.difficulty_target 660876088681118, height 71200\r\n2021-12-22 07:10:20.938687287 UTC PoSW difficulty target is not met. Expected 660876088681118, found 730151207245470603\r\n2021-12-22 07:10:20.938721456 UTC Invalid block header\r\n2021-12-22T07:10:20.938821Z TRACE cannot found block Failed to initialize a block from given inputs\r\n```\r\n\r\n## Steps to Reproduce\r\n\r\n<!--\r\n    How do I reproduce this issue in snarkOS?\r\n    Is there a code snippet I can use to reproduce the issue?\r\n    Are there error messages or stack traces that would help debug this issue?\r\n-->\r\n\r\n1. Step 1\r\n  pull snarkOS testnet2 branch\r\n  checkout to feat/mining-pool\r\n  build snarkOS\r\n2. Step 2\r\n  run pool operator and 2 prover nodes.\r\n3. Step 3\r\n  check the log\r\n\r\n## Expected Behavior\r\n\r\n<!--\r\n    What was supposed to happen in snarkOS?\r\n    What happened instead?\r\n-->\r\n  Prover find unconfirmed block and send a PoolResponse to the operator.\r\n\r\n## Your Environment\r\n\r\n- snarkOS : [mining-pool latest codebase](https://github.com/AleoHQ/snarkOS/commit/eb4fd9133b63323ba90efd1be78f32452f8714cc) <!-- snarkOS Version -->\r\n- Rust version : rustc 1.57.0 (f1edd0429 2021-11-29) <!-- Rust Version -->\r\n- OS : Ubuntu 20.04 <!-- Computer OS -->\r\n\n", "hints_text": "", "created_at": "2021-12-15T07:31:01Z", "version": "2.0"}, {"repo": "AleoNet/snarkOS", "pull_number": 1284, "instance_id": "AleoNet__snarkOS-1284", "issue_numbers": ["1266"], "base_commit": "90d33030e0f6913bada2ee1577ada43194d2986c", "patch": "diff --git a/ledger/src/helpers/block_locators.rs b/ledger/src/helpers/block_locators.rs\nindex 6e6c8fd5ff..c551aa8ca2 100644\n--- a/ledger/src/helpers/block_locators.rs\n+++ b/ledger/src/helpers/block_locators.rs\n@@ -29,7 +29,7 @@ use snarkvm::{\n \n use rayon::iter::{IntoParallelRefIterator, ParallelIterator};\n use serde::{de, ser, ser::SerializeStruct, Deserialize, Deserializer, Serialize, Serializer};\n-use std::ops::Deref;\n+use std::{collections::BTreeMap, ops::Deref};\n \n ///\n /// A helper struct to represent block locators from the ledger.\n@@ -38,12 +38,12 @@ use std::ops::Deref;\n ///\n #[derive(Clone, Debug, Eq, PartialEq)]\n pub struct BlockLocators<N: Network> {\n-    block_locators: Vec<(u32, N::BlockHash, Option<BlockHeader<N>>)>,\n+    block_locators: BTreeMap<u32, (N::BlockHash, Option<BlockHeader<N>>)>,\n }\n \n impl<N: Network> BlockLocators<N> {\n     #[inline]\n-    pub fn from(block_locators: Vec<(u32, N::BlockHash, Option<BlockHeader<N>>)>) -> Self {\n+    pub fn from(block_locators: BTreeMap<u32, (N::BlockHash, Option<BlockHeader<N>>)>) -> Self {\n         Self { block_locators }\n     }\n \n@@ -56,6 +56,11 @@ impl<N: Network> BlockLocators<N> {\n     pub fn len(&self) -> usize {\n         self.block_locators.len()\n     }\n+\n+    #[inline]\n+    pub fn get_block_hash(&self, block_height: u32) -> Option<N::BlockHash> {\n+        self.block_locators.get(&block_height).map(|(block_hash, _)| *block_hash)\n+    }\n }\n \n impl<N: Network> FromBytes for BlockLocators<N> {\n@@ -63,10 +68,10 @@ impl<N: Network> FromBytes for BlockLocators<N> {\n     fn read_le<R: Read>(mut reader: R) -> IoResult<Self> {\n         let num_locators: u32 = FromBytes::read_le(&mut reader)?;\n \n-        let mut block_locators = Vec::with_capacity(num_locators as usize);\n+        let mut block_locators = BTreeMap::new();\n         let mut block_headers_bytes = Vec::with_capacity(num_locators as usize);\n \n-        for index in 0..(num_locators as usize) {\n+        for index in 0..num_locators {\n             let height: u32 = FromBytes::read_le(&mut reader)?;\n             let hash: N::BlockHash = FromBytes::read_le(&mut reader)?;\n             let header_exists: bool = FromBytes::read_le(&mut reader)?;\n@@ -77,7 +82,7 @@ impl<N: Network> FromBytes for BlockLocators<N> {\n                 block_headers_bytes.push((index, buffer));\n             };\n \n-            block_locators.push((height, hash, None));\n+            block_locators.insert(height, (hash, None));\n         }\n \n         let block_headers = block_headers_bytes\n@@ -89,7 +94,7 @@ impl<N: Network> FromBytes for BlockLocators<N> {\n             .collect::<Vec<_>>();\n \n         for (index, block_header) in block_headers.into_iter() {\n-            if let Some((_, _, header)) = block_locators.get_mut(*index) {\n+            if let Some((_, header)) = block_locators.get_mut(index) {\n                 *header = Some(block_header);\n             }\n         }\n@@ -103,7 +108,7 @@ impl<N: Network> ToBytes for BlockLocators<N> {\n     fn write_le<W: Write>(&self, mut writer: W) -> IoResult<()> {\n         (self.block_locators.len() as u32).write_le(&mut writer)?;\n \n-        for (height, hash, header) in &self.block_locators {\n+        for (height, (hash, header)) in &self.block_locators {\n             height.write_le(&mut writer)?;\n             hash.write_le(&mut writer)?;\n             match header {\n@@ -150,7 +155,8 @@ impl<'de, N: Network> Deserialize<'de> for BlockLocators<N> {\n         match deserializer.is_human_readable() {\n             true => {\n                 let block_locators = serde_json::Value::deserialize(deserializer)?;\n-                let block_locators: Vec<_> = serde_json::from_value(block_locators[\"block_locators\"].clone()).map_err(de::Error::custom)?;\n+                let block_locators: BTreeMap<u32, (N::BlockHash, Option<BlockHeader<N>>)> =\n+                    serde_json::from_value(block_locators[\"block_locators\"].clone()).map_err(de::Error::custom)?;\n                 Ok(Self::from(block_locators))\n             }\n             false => FromBytesDeserializer::<Self>::deserialize_with_size_encoding(deserializer, \"block locators\"),\n@@ -161,12 +167,12 @@ impl<'de, N: Network> Deserialize<'de> for BlockLocators<N> {\n impl<N: Network> Default for BlockLocators<N> {\n     #[inline]\n     fn default() -> Self {\n-        Self::from(vec![])\n+        Self::from(Default::default())\n     }\n }\n \n impl<N: Network> Deref for BlockLocators<N> {\n-    type Target = Vec<(u32, N::BlockHash, Option<BlockHeader<N>>)>;\n+    type Target = BTreeMap<u32, (N::BlockHash, Option<BlockHeader<N>>)>;\n \n     fn deref(&self) -> &Self::Target {\n         &self.block_locators\n@@ -184,12 +190,12 @@ mod tests {\n         let expected_block_hash = Testnet2::genesis_block().hash();\n         let expected_block_header = Testnet2::genesis_block().header().clone();\n         let expected_block_locators =\n-            BlockLocators::<Testnet2>::from(vec![(expected_block_height, expected_block_hash, Some(expected_block_header))]);\n+            BlockLocators::<Testnet2>::from([(expected_block_height, (expected_block_hash, Some(expected_block_header)))].into());\n \n         // Serialize\n         let expected_string = expected_block_locators.to_string();\n         let candidate_string = serde_json::to_string(&expected_block_locators).unwrap();\n-        assert_eq!(1682, candidate_string.len(), \"Update me if serialization has changed\");\n+        assert_eq!(1684, candidate_string.len(), \"Update me if serialization has changed\");\n         assert_eq!(expected_string, candidate_string);\n \n         // Deserialize\n@@ -203,7 +209,7 @@ mod tests {\n         let expected_block_hash = Testnet2::genesis_block().hash();\n         let expected_block_header = Testnet2::genesis_block().header().clone();\n         let expected_block_locators =\n-            BlockLocators::<Testnet2>::from(vec![(expected_block_height, expected_block_hash, Some(expected_block_header))]);\n+            BlockLocators::<Testnet2>::from([(expected_block_height, (expected_block_hash, Some(expected_block_header)))].into());\n \n         // Serialize\n         let expected_bytes = expected_block_locators.to_bytes_le().unwrap();\ndiff --git a/ledger/src/state/ledger.rs b/ledger/src/state/ledger.rs\nindex 53b4702720..2a1d494276 100644\n--- a/ledger/src/state/ledger.rs\n+++ b/ledger/src/state/ledger.rs\n@@ -27,6 +27,7 @@ use parking_lot::RwLock;\n use rand::{CryptoRng, Rng};\n use serde::{Deserialize, Serialize};\n use std::{\n+    collections::BTreeMap,\n     path::Path,\n     sync::{\n         atomic::{AtomicBool, AtomicU32, Ordering},\n@@ -390,7 +391,7 @@ impl<N: Network> LedgerState<N> {\n         let block_locator_headers = block_hashes\n             .zip_eq(block_headers)\n             .take(num_block_headers as usize)\n-            .map(|(hash, header)| (header.height(), hash, Some(header)));\n+            .map(|(hash, header)| (header.height(), (hash, Some(header))));\n \n         // Decrement the block locator height by the number of block headers.\n         block_locator_height -= num_block_headers;\n@@ -398,11 +399,9 @@ impl<N: Network> LedgerState<N> {\n         // Return the block locators if the locator has run out of blocks.\n         if block_locator_height == 0 {\n             // Initialize the list of block locators.\n-            let mut block_locators = Vec::with_capacity((num_block_headers + 1) as usize);\n-            // Add the list of block locator headers.\n-            block_locators.extend(block_locator_headers);\n+            let mut block_locators: BTreeMap<u32, (N::BlockHash, Option<BlockHeader<N>>)> = block_locator_headers.collect();\n             // Add the genesis locator.\n-            block_locators.push((0, self.get_block_hash(0)?, None));\n+            block_locators.insert(0, (self.get_block_hash(0)?, None));\n \n             return Ok(BlockLocators::<N>::from(block_locators));\n         }\n@@ -414,23 +413,17 @@ impl<N: Network> LedgerState<N> {\n         let mut block_locator_hashes = Vec::with_capacity(num_block_hashes as usize);\n         // Add the block locator hashes.\n         while block_locator_height > 0 && block_locator_hashes.len() < num_block_hashes as usize {\n-            block_locator_hashes.push((block_locator_height, self.get_block_hash(block_locator_height)?, None));\n+            block_locator_hashes.push((block_locator_height, (self.get_block_hash(block_locator_height)?, None)));\n \n             // Decrement the block locator height by a power of two.\n             block_locator_height /= 2;\n         }\n \n-        // Determine the number of latest block headers and block hashes to include as block locators.\n-        let num_block_locators = num_block_headers + num_block_hashes + 1;\n-\n         // Initialize the list of block locators.\n-        let mut block_locators = Vec::with_capacity(num_block_locators as usize);\n-        // Add the list of block locator headers.\n-        block_locators.extend(block_locator_headers);\n-        // Add the list of block locator hashes.\n-        block_locators.extend(block_locator_hashes);\n+        let mut block_locators: BTreeMap<u32, (N::BlockHash, Option<BlockHeader<N>>)> =\n+            block_locator_headers.chain(block_locator_hashes).collect();\n         // Add the genesis locator.\n-        block_locators.push((0, self.get_block_hash(0)?, None));\n+        block_locators.insert(0, (self.get_block_hash(0)?, None));\n \n         Ok(BlockLocators::<N>::from(block_locators))\n     }\n@@ -444,71 +437,74 @@ impl<N: Network> LedgerState<N> {\n \n         let block_locators = &**block_locators;\n \n-        // Check that the last block locator is the genesis locator.\n-        let (expected_height, expected_genesis_block_hash, expected_genesis_header) = &block_locators[block_locators.len() - 1];\n-        if *expected_height != 0 || expected_genesis_block_hash != &self.get_block_hash(0)? || expected_genesis_header.is_some() {\n+        // Ensure the genesis block locator exists and is well-formed.\n+        let (expected_genesis_block_hash, expected_genesis_header) = match block_locators.get(&0) {\n+            Some((expected_genesis_block_hash, expected_genesis_header)) => (expected_genesis_block_hash, expected_genesis_header),\n+            None => return Ok(false),\n+        };\n+        if expected_genesis_block_hash != &N::genesis_block().hash() || expected_genesis_header.is_some() {\n             return Ok(false);\n         }\n \n-        // Get the remaining block locators (excluding the genesis block).\n-        let remaining_block_locators = &block_locators[..block_locators.len() - 1];\n-        let num_block_headers = std::cmp::min(MAXIMUM_LINEAR_BLOCK_LOCATORS as usize, remaining_block_locators.len());\n-\n-        // Check that the block headers are formed correctly (linear).\n-        // let mut last_block_height = remaining_block_locators[0].0 + 1;\n-        for (_block_height, _block_hash, block_header) in &remaining_block_locators[..num_block_headers] {\n-            // // Check that the block height is decrementing.\n-            // match last_block_height == *block_height + 1 {\n-            //     true => last_block_height = *block_height,\n-            //     false => return Ok(false)\n-            // }\n-\n-            // Check that the block header is present.\n-            let _block_header = match block_header {\n-                Some(header) => header,\n-                None => return Ok(false),\n-            };\n-\n-            // // Check that the expected block hash is correct.\n-            // if let Ok(expected_block_hash) = self.get_block_hash(*block_height) {\n-            //     if &expected_block_hash != block_hash {\n-            //         return Ok(false);\n-            //     }\n-            // }\n-            //\n-            // // Check that the expected block headers is correct.\n-            // if let Ok(expected_block_header) = self.get_block_header(*block_height) {\n-            //     if &expected_block_header != block_header {\n-            //         return Ok(false);\n-            //     }\n-            // }\n-        }\n-\n-        // Check that the block hashes are formed correctly (power of two).\n-        if block_locators.len() > MAXIMUM_LINEAR_BLOCK_LOCATORS as usize {\n-            let mut previous_block_height = u32::MAX;\n-\n-            for (block_height, _block_hash, block_header) in &block_locators[num_block_headers..] {\n-                // Check that the block heights increment by a power of two.\n-                if previous_block_height != u32::MAX && previous_block_height / 2 != *block_height {\n-                    return Ok(false);\n-                }\n-\n-                // Check that there is no block header.\n-                if block_header.is_some() {\n-                    return Ok(false);\n-                }\n-\n-                // // Check that the expected block hash is correct.\n-                // if let Ok(expected_block_hash) = self.get_block_hash(*block_height) {\n-                //     if &expected_block_hash != block_hash {\n-                //         return Ok(false);\n-                //     }\n-                // }\n-\n-                previous_block_height = *block_height;\n-            }\n-        }\n+        // // Get the remaining block locators (excluding the genesis block).\n+        // let remaining_block_locators = &block_locators[..block_locators.len() - 1];\n+        // let num_block_headers = std::cmp::min(MAXIMUM_LINEAR_BLOCK_LOCATORS as usize, remaining_block_locators.len());\n+        //\n+        // // Check that the block headers are formed correctly (linear).\n+        // // let mut last_block_height = remaining_block_locators[0].0 + 1;\n+        // for (_block_height, _block_hash, block_header) in &remaining_block_locators[..num_block_headers] {\n+        //     // // Check that the block height is decrementing.\n+        //     // match last_block_height == *block_height + 1 {\n+        //     //     true => last_block_height = *block_height,\n+        //     //     false => return Ok(false)\n+        //     // }\n+        //\n+        //     // Check that the block header is present.\n+        //     let _block_header = match block_header {\n+        //         Some(header) => header,\n+        //         None => return Ok(false),\n+        //     };\n+        //\n+        //     // // Check that the expected block hash is correct.\n+        //     // if let Ok(expected_block_hash) = self.get_block_hash(*block_height) {\n+        //     //     if &expected_block_hash != block_hash {\n+        //     //         return Ok(false);\n+        //     //     }\n+        //     // }\n+        //     //\n+        //     // // Check that the expected block headers is correct.\n+        //     // if let Ok(expected_block_header) = self.get_block_header(*block_height) {\n+        //     //     if &expected_block_header != block_header {\n+        //     //         return Ok(false);\n+        //     //     }\n+        //     // }\n+        // }\n+\n+        // // Check that the block hashes are formed correctly (power of two).\n+        // if block_locators.len() > MAXIMUM_LINEAR_BLOCK_LOCATORS as usize {\n+        //     let mut previous_block_height = u32::MAX;\n+        //\n+        //     for (block_height, _block_hash, block_header) in &block_locators[num_block_headers..] {\n+        //         // Check that the block heights increment by a power of two.\n+        //         if previous_block_height != u32::MAX && previous_block_height / 2 != *block_height {\n+        //             return Ok(false);\n+        //         }\n+        //\n+        //         // Check that there is no block header.\n+        //         if block_header.is_some() {\n+        //             return Ok(false);\n+        //         }\n+        //\n+        //         // // Check that the expected block hash is correct.\n+        //         // if let Ok(expected_block_hash) = self.get_block_hash(*block_height) {\n+        //         //     if &expected_block_hash != block_hash {\n+        //         //         return Ok(false);\n+        //         //     }\n+        //         // }\n+        //\n+        //         previous_block_height = *block_height;\n+        //     }\n+        // }\n \n         Ok(true)\n     }\ndiff --git a/src/network/ledger.rs b/src/network/ledger.rs\nindex 40d4af09be..96e786fb4a 100644\n--- a/src/network/ledger.rs\n+++ b/src/network/ledger.rs\n@@ -318,11 +318,31 @@ impl<N: Network, E: Environment> Ledger<N, E> {\n         while let Some(unconfirmed_block) = unconfirmed_blocks.get(&block.hash()) {\n             // Update the block iterator.\n             block = unconfirmed_block;\n+\n+            // Ensure the block height is not part of a block request in a fork.\n+            let mut is_forked_block = false;\n+            for requests in self.block_requests.values() {\n+                for (block_height, block_hash) in requests.keys() {\n+                    // If the block is part of a fork, then don't attempt to add it again.\n+                    if block_height == &block.height() && block_hash.is_some() {\n+                        is_forked_block = true;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            // If the block is on a fork, remove the unconfirmed block, and break the loop.\n+            if is_forked_block {\n+                self.unconfirmed_blocks.remove(&block.hash());\n+                break;\n+            }\n             // Attempt to add the unconfirmed block.\n-            match self.add_block(block.clone()) {\n-                // Upon success, remove the unconfirmed block, as it is now confirmed.\n-                true => self.unconfirmed_blocks.remove(&block.hash()),\n-                false => break,\n+            else {\n+                match self.add_block(block.clone()) {\n+                    // Upon success, remove the unconfirmed block, as it is now confirmed.\n+                    true => self.unconfirmed_blocks.remove(&block.hash()),\n+                    false => break,\n+                }\n             }\n         }\n \n@@ -485,8 +505,6 @@ impl<N: Network, E: Environment> Ledger<N, E> {\n                         true => {\n                             trace!(\"Adding unconfirmed block {} to memory pool\", block.height());\n \n-                            // Set the terminator bit to `true` to ensure the miner updates state.\n-                            self.terminator.store(true, Ordering::SeqCst);\n                             // Add the block to the unconfirmed blocks.\n                             self.unconfirmed_blocks.insert(block.previous_block_hash(), block);\n                         }\n@@ -606,7 +624,7 @@ impl<N: Network, E: Environment> Ledger<N, E> {\n             let mut latest_block_height_of_peer = 0;\n \n             // Verify the integrity of the block hashes sent by the peer.\n-            for (block_height, block_hash, _) in block_locators.iter() {\n+            for (block_height, (block_hash, _)) in block_locators.iter() {\n                 // Ensure the block hash corresponds with the block height, if the block hash exists in this ledger.\n                 if let Ok(expected_block_height) = self.canon.get_block_height(block_hash) {\n                     if expected_block_height != *block_height {\n@@ -715,7 +733,7 @@ impl<N: Network, E: Environment> Ledger<N, E> {\n             let mut first_deviating_locator = None;\n \n             // Verify the integrity of the block hashes sent by the peer.\n-            for (block_height, block_hash, _) in &*maximum_block_locators {\n+            for (block_height, (block_hash, _)) in maximum_block_locators.iter() {\n                 // Ensure the block hash corresponds with the block height, if the block hash exists in this ledger.\n                 if let Ok(expected_block_height) = self.canon.get_block_height(block_hash) {\n                     if expected_block_height != *block_height {\n@@ -746,20 +764,20 @@ impl<N: Network, E: Environment> Ledger<N, E> {\n             let latest_block_height = self.latest_block_height();\n             if latest_block_height < maximum_common_ancestor {\n                 warn!(\n-                    \"The maximum common ancestor {} can't be greater than the latest block {}\",\n+                    \"The common ancestor {} cannot be greater than the latest block {}\",\n                     maximum_common_ancestor, latest_block_height\n                 );\n                 return;\n             }\n \n             // Determine the latest common ancestor.\n-            let latest_common_ancestor =\n+            let (latest_common_ancestor, ledger_reverted) =\n                 // Case 2(b) - This ledger is not a fork of the peer, it is on the same canon chain.\n                 if !is_fork {\n                     // Continue to sync from the latest block height of this ledger, if the peer is honest.\n                     match first_deviating_locator.is_none() {\n-                        true => maximum_common_ancestor,\n-                        false => latest_block_height,\n+                        true => (maximum_common_ancestor, false),\n+                        false => (latest_block_height, false),\n                     }\n                 }\n                 // Case 2(c) - This ledger is on a fork of the peer.\n@@ -773,7 +791,7 @@ impl<N: Network, E: Environment> Ledger<N, E> {\n                         if latest_block_height != maximum_common_ancestor && !self.revert_to_block_height(maximum_common_ancestor) {\n                             return;\n                         }\n-                        maximum_common_ancestor\n+                        (maximum_common_ancestor, true)\n                     }\n                     // Case 2(c)(b) - If the common ancestor is NOT within `ALEO_MAXIMUM_FORK_DEPTH`.\n                     else\n@@ -800,7 +818,7 @@ impl<N: Network, E: Environment> Ledger<N, E> {\n                         else {\n                             info!(\"Found a potentially longer chain from {} starting at block {}\", peer_ip, maximum_common_ancestor);\n                             match self.revert_to_block_height(maximum_common_ancestor) {\n-                                true => maximum_common_ancestor,\n+                                true => (maximum_common_ancestor, true),\n                                 false => return\n                             }\n                         }\n@@ -823,8 +841,11 @@ impl<N: Network, E: Environment> Ledger<N, E> {\n \n             // Log each block request to ensure the peer responds with all requested blocks.\n             for block_height in start_block_height..=end_block_height {\n-                // Add the block request to the ledger.\n-                self.add_block_request(peer_ip, block_height, None);\n+                // If the ledger was reverted, include the expected new block hash for the fork.\n+                match ledger_reverted {\n+                    true => self.add_block_request(peer_ip, block_height, maximum_block_locators.get_block_hash(block_height)),\n+                    false => self.add_block_request(peer_ip, block_height, None),\n+                };\n             }\n         }\n     }\n", "test_patch": "diff --git a/ledger/src/state/tests.rs b/ledger/src/state/tests.rs\nindex db7c7275eb..5176d1983a 100644\n--- a/ledger/src/state/tests.rs\n+++ b/ledger/src/state/tests.rs\n@@ -51,7 +51,7 @@ fn test_genesis() {\n     assert_eq!(genesis.timestamp(), ledger.latest_block_timestamp());\n     assert_eq!(genesis.difficulty_target(), ledger.latest_block_difficulty_target());\n     assert_eq!(genesis, &ledger.latest_block());\n-    assert_eq!(vec![(genesis.height(), genesis.hash(), None)], *ledger.latest_block_locators());\n+    assert_eq!(Some(&(genesis.hash(), None)), ledger.latest_block_locators().get(&genesis.height()));\n     assert_eq!(ledger_tree.root(), ledger.latest_ledger_root());\n }\n \n@@ -94,8 +94,11 @@ fn test_add_next_block() {\n     // Ensure the block locators are correct.\n     let block_locators = ledger.latest_block_locators();\n     assert_eq!(2, block_locators.len());\n-    assert_eq!((block.height(), block.hash(), Some(block.header().clone())), block_locators[0]);\n-    assert_eq!((genesis.height(), genesis.hash(), None), block_locators[1]);\n+    assert_eq!(\n+        Some(&(block.hash(), Some(block.header().clone()))),\n+        block_locators.get(&block.height())\n+    );\n+    assert_eq!(Some(&(genesis.hash(), None)), block_locators.get(&genesis.height()));\n }\n \n #[test]\n@@ -138,7 +141,7 @@ fn test_remove_last_block() {\n     assert_eq!(genesis.timestamp(), ledger.latest_block_timestamp());\n     assert_eq!(genesis.difficulty_target(), ledger.latest_block_difficulty_target());\n     assert_eq!(genesis, &ledger.latest_block());\n-    assert_eq!(vec![(genesis.height(), genesis.hash(), None)], *ledger.latest_block_locators());\n+    assert_eq!(Some(&(genesis.hash(), None)), ledger.latest_block_locators().get(&genesis.height()));\n     assert_eq!(ledger_tree.root(), ledger.latest_ledger_root());\n }\n \n@@ -187,7 +190,7 @@ fn test_remove_last_2_blocks() {\n     assert_eq!(genesis.timestamp(), ledger.latest_block_timestamp());\n     assert_eq!(genesis.difficulty_target(), ledger.latest_block_difficulty_target());\n     assert_eq!(genesis, &ledger.latest_block());\n-    assert_eq!(vec![(genesis.height(), genesis.hash(), None)], *ledger.latest_block_locators());\n+    assert_eq!(Some(&(genesis.hash(), None)), ledger.latest_block_locators().get(&genesis.height()));\n     assert_eq!(ledger_tree.root(), ledger.latest_ledger_root());\n }\n \n", "problem_statement": "Track rolled back blocks\n<!-- Thank you for filing a PR! Help us understand by explaining your changes. Happy contributing! -->\r\n\r\n## Motivation\r\n\r\nThis PR adds the block hash of rolled back blocks to the `block_requests` to prevent the `update_ledger` from re-canonizing blocks that were already rolled back.\r\n\n", "hints_text": "", "created_at": "2021-11-15T09:40:38Z", "version": "2.0"}, {"repo": "AleoNet/snarkOS", "pull_number": 1026, "instance_id": "AleoNet__snarkOS-1026", "issue_numbers": ["979"], "base_commit": "64586b2d15ec6b75dd048d4df87534287ebb87d3", "patch": "diff --git a/consensus/src/consensus/inner/agent.rs b/consensus/src/consensus/inner/agent.rs\nindex c95dfcee8f..d2eaac69a8 100644\n--- a/consensus/src/consensus/inner/agent.rs\n+++ b/consensus/src/consensus/inner/agent.rs\n@@ -34,10 +34,25 @@ impl ConsensusInner {\n \n             self.commit_block(&hash, &block).await?;\n         }\n-        // info!(\"rebuilding canon\");\n-        // self.diff_canon().await?;\n-        // self.recommit_canon().await?; // TODO: DEFINITELY REMOVE\n-        // info!(\"rebuilt canon\");\n+\n+        // scan for forks\n+        let forks = self.scan_forks().await?;\n+        for (canon, fork_child) in forks {\n+            let canon_height = match self.storage.get_block_state(&canon).await? {\n+                BlockStatus::Committed(n) => n,\n+                _ => continue,\n+            };\n+            let fork_blocks = self.storage.longest_child_path(&fork_child).await?;\n+            debug!(\n+                \"fork detected @ {}/{} -- starts at {}, goes for {} blocks, ending at {}\",\n+                canon_height,\n+                canon,\n+                fork_child,\n+                fork_blocks.len(),\n+                fork_blocks.last().unwrap()\n+            );\n+        }\n+\n         if let Err(e) = self.try_to_fast_forward().await {\n             match e {\n                 ConsensusError::InvalidBlock(e) => debug!(\"invalid block in initial fast-forward: {}\", e),\ndiff --git a/consensus/src/consensus/inner/mod.rs b/consensus/src/consensus/inner/mod.rs\nindex 578d935991..877b59324f 100644\n--- a/consensus/src/consensus/inner/mod.rs\n+++ b/consensus/src/consensus/inner/mod.rs\n@@ -26,6 +26,8 @@ use crate::{\n };\n use anyhow::*;\n use snarkos_storage::{\n+    BlockFilter,\n+    BlockOrder,\n     BlockStatus,\n     Digest,\n     DynStorage,\n@@ -67,29 +69,39 @@ struct LedgerData {\n }\n \n impl ConsensusInner {\n-    /// scans uncommitted blocks for forks\n-    async fn scan_forks(&mut self) -> Result<()> {\n-        let blocks = self\n+    /// scans uncommitted blocks with a known path to the canon chain for forks\n+    async fn scan_forks(&mut self) -> Result<Vec<(Digest, Digest)>> {\n+        let canon_hashes = self\n             .storage\n-            .get_block_hashes(None, snarkos_storage::BlockFilter::NonCanonOnly)\n+            .get_block_hashes(\n+                Some(crate::OLDEST_FORK_THRESHOLD as u32 + 1),\n+                BlockFilter::CanonOnly(BlockOrder::Descending),\n+            )\n             .await?;\n-        info!(\"scanning {} blocks for forks\", blocks.len());\n-        for hash in blocks {\n-            let header = self.storage.get_block_header(&hash).await?;\n-            let parent_state = self.storage.get_block_state(&header.previous_block_hash).await?;\n-            match parent_state {\n-                BlockStatus::Unknown => continue, // orphan\n-                BlockStatus::Committed(_) => (),  // uncomitted child of canon, could be a fork or a hanging block\n-                BlockStatus::Uncommitted => {\n-                    // mid-fork or orphan chain, wait for head of fork\n-                    continue;\n-                }\n-            };\n-            let block = self.storage.get_block(&hash).await?;\n \n-            self.try_commit_block(&hash, &block).await?;\n+        if canon_hashes.len() < 2 {\n+            // windows will panic if len < 2\n+            return Ok(vec![]);\n         }\n-        Ok(())\n+\n+        let mut known_forks = vec![];\n+\n+        for canon_hashes in canon_hashes.windows(2) {\n+            // windows will ignore last block (furthest down), so we pull one extra above\n+            let target_hash = &canon_hashes[1];\n+            let ignore_child_hash = &canon_hashes[0];\n+            let children = self.storage.get_block_children(target_hash).await?;\n+            if children.len() == 1 && &children[0] == ignore_child_hash {\n+                continue;\n+            }\n+            for child in children {\n+                if &child != ignore_child_hash {\n+                    known_forks.push((target_hash.clone(), child));\n+                }\n+            }\n+        }\n+\n+        Ok(known_forks)\n     }\n \n     fn fresh_ledger(&self, blocks: Vec<SerialBlock>) -> Result<LedgerData> {\ndiff --git a/consensus/src/consensus/mod.rs b/consensus/src/consensus/mod.rs\nindex 83e5995f1b..7636f35183 100644\n--- a/consensus/src/consensus/mod.rs\n+++ b/consensus/src/consensus/mod.rs\n@@ -151,7 +151,7 @@ impl Consensus {\n     }\n \n     /// Diagnostic function to scan for valid forks\n-    pub async fn scan_forks(&self) -> Result<()> {\n+    pub async fn scan_forks(&self) -> Result<Vec<(Digest, Digest)>> {\n         self.send(ConsensusMessage::ScanForks()).await\n     }\n \ndiff --git a/network/src/lib.rs b/network/src/lib.rs\nindex 1a21623dc2..8c8a3161ef 100644\n--- a/network/src/lib.rs\n+++ b/network/src/lib.rs\n@@ -49,7 +49,7 @@ pub mod topology;\n pub use topology::*;\n \n /// The maximum number of block hashes that can be requested or provided in a single batch.\n-pub const MAX_BLOCK_SYNC_COUNT: u32 = snarkos_storage::NUM_LOCATOR_HASHES;\n+pub const MAX_BLOCK_SYNC_COUNT: u32 = snarkos_storage::NUM_LOCATOR_HASHES * 2;\n /// The maximum amount of time allowed to process a single batch of sync blocks. It should be aligned\n /// with `MAX_BLOCK_SYNC_COUNT`.\n pub const BLOCK_SYNC_EXPIRATION_SECS: u8 = 30;\ndiff --git a/network/src/sync/master.rs b/network/src/sync/master.rs\nindex 2949fb8a6a..f24fdf547c 100644\n--- a/network/src/sync/master.rs\n+++ b/network/src/sync/master.rs\n@@ -80,7 +80,27 @@ impl SyncMaster {\n     }\n \n     async fn block_locator_hashes(&mut self) -> Result<Vec<Digest>> {\n-        match self.node.storage.get_block_locator_hashes().await {\n+        let forks_of_interest = self.node.expect_sync().consensus.scan_forks().await?;\n+        let blocks_of_interest: Vec<Digest> = forks_of_interest.into_iter().map(|(_canon, fork)| fork).collect();\n+        let mut tips_of_blocks_of_interest: Vec<Digest> = Vec::with_capacity(blocks_of_interest.len());\n+        for block in blocks_of_interest {\n+            if tips_of_blocks_of_interest.len() > crate::MAX_BLOCK_SYNC_COUNT as usize {\n+                debug!(\"reached limit of blocks of interest in sync block locator hashes\");\n+                break;\n+            }\n+            let mut fork_path = self.node.storage.longest_child_path(&block).await?;\n+            if fork_path.len() < 2 {\n+                // a minor fork, we probably don't care\n+                continue;\n+            }\n+            tips_of_blocks_of_interest.push(fork_path.pop().unwrap());\n+        }\n+        match self\n+            .node\n+            .storage\n+            .get_block_locator_hashes(tips_of_blocks_of_interest, snarkos_consensus::OLDEST_FORK_THRESHOLD)\n+            .await\n+        {\n             Ok(block_locator_hashes) => Ok(block_locator_hashes),\n             Err(e) => {\n                 error!(\"Unable to get block locator hashes from storage: {:?}\", e);\ndiff --git a/storage/src/key_value/agent/block.rs b/storage/src/key_value/agent/block.rs\nindex d3a0ee9e81..9ca6e00ce9 100644\n--- a/storage/src/key_value/agent/block.rs\n+++ b/storage/src/key_value/agent/block.rs\n@@ -14,7 +14,11 @@\n // You should have received a copy of the GNU General Public License\n // along with the snarkOS library. If not, see <https://www.gnu.org/licenses/>.\n \n-use std::collections::HashSet;\n+use std::{collections::HashSet, convert::TryInto};\n+\n+use tracing::trace;\n+\n+use crate::BlockOrder;\n \n use super::*;\n \n@@ -224,34 +228,49 @@ impl<S: KeyValueStorage + Validator + 'static> Agent<S> {\n         })\n     }\n \n-    pub(super) fn get_block_locator_hashes(&mut self) -> Result<Vec<Digest>> {\n+    pub(super) fn get_block_locator_hashes(\n+        &mut self,\n+        points_of_interest: Vec<Digest>,\n+        oldest_fork_threshold: usize,\n+    ) -> Result<Vec<Digest>> {\n         let canon = self.canon()?;\n+        let target_height = canon.block_height as u32;\n \n         // The number of locator hashes left to obtain; accounts for the genesis block.\n-        let mut num_locator_hashes = std::cmp::min(crate::NUM_LOCATOR_HASHES - 1, canon.block_height as u32);\n+        let mut num_locator_hashes = std::cmp::min(crate::NUM_LOCATOR_HASHES - 1, target_height);\n \n         // The output list of block locator hashes.\n-        let mut block_locator_hashes = Vec::with_capacity(num_locator_hashes as usize);\n+        let mut block_locator_hashes = Vec::with_capacity(num_locator_hashes as usize + points_of_interest.len());\n+\n+        for hash in points_of_interest {\n+            trace!(\"block locator hash -- interesting: block# none: {}\", hash);\n+            block_locator_hashes.push(hash);\n+        }\n \n         // The index of the current block for which a locator hash is obtained.\n-        let mut hash_index = canon.block_height as u32;\n+        let mut hash_index = target_height;\n \n         // The number of top blocks to provide locator hashes for.\n         let num_top_blocks = std::cmp::min(10, num_locator_hashes);\n \n         for _ in 0..num_top_blocks {\n-            block_locator_hashes.push(self.get_block_hash_guarded(hash_index)?);\n+            let hash = self.get_block_hash_guarded(hash_index)?;\n+            trace!(\"block locator hash -- top: block# {}: {}\", hash_index, hash);\n+            block_locator_hashes.push(hash);\n             hash_index -= 1; // safe; num_top_blocks is never higher than the height\n         }\n \n         num_locator_hashes -= num_top_blocks;\n         if num_locator_hashes == 0 {\n-            block_locator_hashes.push(self.get_block_hash_guarded(0)?);\n+            let hash = self.get_block_hash_guarded(0)?;\n+            trace!(\"block locator hash -- genesis: block# {}: {}\", 0, hash);\n+            block_locator_hashes.push(hash);\n             return Ok(block_locator_hashes);\n         }\n \n         // Calculate the average distance between block hashes based on the desired number of locator hashes.\n-        let mut proportional_step = hash_index / num_locator_hashes;\n+        let mut proportional_step =\n+            (hash_index.min(oldest_fork_threshold as u32) / num_locator_hashes).min(crate::NUM_LOCATOR_HASHES - 1);\n \n         // Provide hashes of blocks with indices descending quadratically while the quadratic step distance is\n         // lower or close to the proportional step distance.\n@@ -263,14 +282,17 @@ impl<S: KeyValueStorage + Validator + 'static> Agent<S> {\n         // Obtain a few hashes increasing the distance quadratically.\n         let mut quadratic_step = 2; // the size of the first quadratic step\n         for _ in 0..num_quadratic_steps {\n-            block_locator_hashes.push(self.get_block_hash_guarded(hash_index)?);\n+            let hash = self.get_block_hash_guarded(hash_index)?;\n+            trace!(\"block locator hash -- quadratic: block# {}: {}\", hash_index, hash);\n+            block_locator_hashes.push(hash);\n             hash_index = hash_index.saturating_sub(quadratic_step);\n             quadratic_step *= 2;\n         }\n \n         // Update the size of the proportional step so that the hashes of the remaining blocks have the same distance\n         // between one another.\n-        proportional_step = hash_index / num_proportional_steps;\n+        proportional_step =\n+            (hash_index.min(oldest_fork_threshold as u32) / num_locator_hashes).min(crate::NUM_LOCATOR_HASHES - 1);\n \n         // Tweak: in order to avoid \"jumping\" by too many indices with the last step,\n         // increase the value of each step by 1 if the last step is too large. This\n@@ -282,14 +304,18 @@ impl<S: KeyValueStorage + Validator + 'static> Agent<S> {\n \n         // Obtain the rest of hashes with a proportional distance between them.\n         for _ in 0..num_proportional_steps {\n-            block_locator_hashes.push(self.get_block_hash_guarded(hash_index)?);\n+            let hash = self.get_block_hash_guarded(hash_index)?;\n+            trace!(\"block locator hash -- proportional: block# {}: {}\", hash_index, hash);\n+            block_locator_hashes.push(hash);\n             if hash_index == 0 {\n                 return Ok(block_locator_hashes);\n             }\n             hash_index = hash_index.saturating_sub(proportional_step);\n         }\n \n-        block_locator_hashes.push(self.get_block_hash_guarded(0)?);\n+        let hash = self.get_block_hash_guarded(0)?;\n+        trace!(\"block locator hash -- genesis: block# {}: {}\", 0, hash);\n+        block_locator_hashes.push(hash);\n \n         Ok(block_locator_hashes)\n     }\n@@ -370,17 +396,30 @@ impl<S: KeyValueStorage + Validator + 'static> Agent<S> {\n \n     pub(super) fn get_block_hashes(&mut self, limit: Option<u32>, filter: BlockFilter) -> Result<Vec<Digest>> {\n         let mut hashes = match filter {\n-            BlockFilter::CanonOnly => {\n+            BlockFilter::CanonOnly(BlockOrder::Unordered) => {\n                 self.inner().get_column_keys(KeyValueColumn::BlockIndex)?\n                     .into_iter()\n                     .filter(|key| key.len() != 4) // only interested in block hash keys\n                     .map(|key| key[..].into())\n                     .collect::<Vec<Digest>>()\n             }\n+            BlockFilter::CanonOnly(order) => {\n+                let mut values = self.inner().get_column(KeyValueColumn::BlockIndex)?\n+                    .into_iter()\n+                    .filter(|(key, value)| key.len() != 4 && value.len() == 4) // only interested in block hash keys\n+                    .map(|(key, value)| (key[..].into(), u32::from_le_bytes((&value[..]).try_into().unwrap())))\n+                    .collect::<Vec<(Digest, u32)>>();\n+                values.sort_by(|a, b| a.1.cmp(&b.1));\n+                match order {\n+                    BlockOrder::Ascending => values.into_iter().map(|x| x.0).collect(),\n+                    BlockOrder::Descending => values.into_iter().rev().map(|x| x.0).collect(),\n+                    BlockOrder::Unordered => unreachable!(),\n+                }\n+            }\n             BlockFilter::NonCanonOnly => {\n                 let all = self.get_block_hashes(None, BlockFilter::All)?;\n                 let canon = self\n-                    .get_block_hashes(None, BlockFilter::CanonOnly)?\n+                    .get_block_hashes(None, BlockFilter::CanonOnly(BlockOrder::Unordered))?\n                     .into_iter()\n                     .collect::<HashSet<Digest>>();\n                 all.into_iter().filter(|hash| !canon.contains(hash)).collect()\ndiff --git a/storage/src/key_value/agent/block_commit.rs b/storage/src/key_value/agent/block_commit.rs\nindex c985d5aff4..9b724c32c6 100644\n--- a/storage/src/key_value/agent/block_commit.rs\n+++ b/storage/src/key_value/agent/block_commit.rs\n@@ -24,19 +24,19 @@ impl<S: KeyValueStorage + Validator + 'static> Agent<S> {\n         let header = self.get_block_header(hash)?;\n         let canon_height = self.canon_height()?;\n         let mut parent_hash = header.previous_block_hash;\n-        for i in 0..=oldest_fork_threshold {\n+        for _ in 0..=oldest_fork_threshold {\n             // check if the part is part of the canon chain\n             match self.get_block_state(&parent_hash)? {\n                 // This is a canon parent\n                 BlockStatus::Committed(block_num) => {\n                     // Add the children from the latest block\n-                    if block_num + oldest_fork_threshold - i < canon_height as usize {\n+                    if canon_height as usize - block_num > oldest_fork_threshold {\n                         debug!(\"exceeded maximum fork length in extended path\");\n                         return Ok(ForkDescription::TooLong);\n                     }\n                     let longest_path = self.longest_child_path(hash)?;\n+                    debug!(\"longest child path terminating in {:?}\", longest_path.last());\n                     side_chain_path.extend(longest_path);\n-\n                     return Ok(ForkDescription::Path(ForkPath {\n                         base_index: block_num as u32,\n                         path: side_chain_path.into(),\ndiff --git a/storage/src/key_value/agent/mod.rs b/storage/src/key_value/agent/mod.rs\nindex 95ab3a6a49..d8308b9d87 100644\n--- a/storage/src/key_value/agent/mod.rs\n+++ b/storage/src/key_value/agent/mod.rs\n@@ -197,8 +197,11 @@ impl<S: KeyValueStorage + Validator + 'static> Agent<S> {\n             }\n             Message::DecommitBlocks(hash) => Box::new(self.wrap(move |f| f.decommit_blocks(&hash))),\n             Message::Canon() => Box::new(self.canon()),\n+            Message::GetBlockChildren(hash) => Box::new(self.get_child_block_hashes(&hash)),\n             Message::LongestChildPath(hash) => Box::new(self.longest_child_path(&hash)),\n-            Message::GetBlockLocatorHashes() => Box::new(self.get_block_locator_hashes()),\n+            Message::GetBlockLocatorHashes(points_of_interest, oldest_fork_threshold) => {\n+                Box::new(self.get_block_locator_hashes(points_of_interest, oldest_fork_threshold))\n+            }\n             Message::FindSyncBlocks(hashes, block_count) => Box::new(self.find_sync_blocks(hashes, block_count)),\n             Message::GetTransactionLocation(transaction_id) => Box::new(self.get_transaction_location(&transaction_id)),\n             Message::GetRecordCommitments(limit) => Box::new(self.get_record_commitments(limit)),\ndiff --git a/storage/src/key_value/mod.rs b/storage/src/key_value/mod.rs\nindex abd3963536..cfeb4172f8 100644\n--- a/storage/src/key_value/mod.rs\n+++ b/storage/src/key_value/mod.rs\n@@ -79,7 +79,8 @@ enum Message {\n     DecommitBlocks(Digest),\n     Canon(),\n     LongestChildPath(Digest),\n-    GetBlockLocatorHashes(),\n+    GetBlockChildren(Digest),\n+    GetBlockLocatorHashes(Vec<Digest>, usize), // points of interest, oldest_fork_threshold\n     FindSyncBlocks(Vec<Digest>, usize),\n     GetTransactionLocation(Digest),\n     GetRecordCommitments(Option<usize>),\n@@ -117,7 +118,12 @@ impl fmt::Display for Message {\n             Message::DecommitBlocks(hash) => write!(f, \"DecommitBlocks({})\", hash),\n             Message::Canon() => write!(f, \"Canon()\"),\n             Message::LongestChildPath(hash) => write!(f, \"LongestChildPath({})\", hash),\n-            Message::GetBlockLocatorHashes() => write!(f, \"GetBlockLocatorHashes()\"),\n+            Message::GetBlockChildren(hash) => write!(f, \"GetBlockChildren({})\", hash),\n+            Message::GetBlockLocatorHashes(canon_depth_limit, oldest_fork_threshold) => write!(\n+                f,\n+                \"GetBlockLocatorHashes({:?}, {})\",\n+                canon_depth_limit, oldest_fork_threshold\n+            ),\n             Message::FindSyncBlocks(hashes, max_block_count) => {\n                 write!(f, \"FindSyncBlocks(\")?;\n                 for hash in hashes {\ndiff --git a/storage/src/key_value/storage.rs b/storage/src/key_value/storage.rs\nindex cffa7c0fe4..9205a21590 100644\n--- a/storage/src/key_value/storage.rs\n+++ b/storage/src/key_value/storage.rs\n@@ -82,8 +82,20 @@ impl Storage for KeyValueStore {\n         self.send(Message::LongestChildPath(block_hash.clone())).await\n     }\n \n-    async fn get_block_locator_hashes(&self) -> Result<Vec<Digest>> {\n-        self.send(Message::GetBlockLocatorHashes()).await\n+    async fn get_block_children(&self, block_hash: &Digest) -> Result<Vec<Digest>> {\n+        self.send(Message::GetBlockChildren(block_hash.clone())).await\n+    }\n+\n+    async fn get_block_locator_hashes(\n+        &self,\n+        points_of_interest: Vec<Digest>,\n+        oldest_fork_threshold: usize,\n+    ) -> Result<Vec<Digest>> {\n+        self.send(Message::GetBlockLocatorHashes(\n+            points_of_interest,\n+            oldest_fork_threshold,\n+        ))\n+        .await\n     }\n \n     async fn find_sync_blocks(&self, block_locator_hashes: &[Digest], block_count: usize) -> Result<Vec<Digest>> {\ndiff --git a/storage/src/storage.rs b/storage/src/storage.rs\nindex caa544eec3..a77ed052d5 100644\n--- a/storage/src/storage.rs\n+++ b/storage/src/storage.rs\n@@ -53,13 +53,20 @@ pub struct CanonData {\n     pub hash: Digest,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone, Copy)]\n pub enum BlockFilter {\n-    CanonOnly,\n+    CanonOnly(BlockOrder),\n     NonCanonOnly,\n     All,\n }\n \n+#[derive(Debug, Clone, Copy)]\n+pub enum BlockOrder {\n+    Ascending,\n+    Descending,\n+    Unordered,\n+}\n+\n /// An application level storage interface\n /// Requires atomicity within each method implementation, but doesn't require any kind of consistency between invocations other than call-order enforcement.\n #[async_trait::async_trait]\n@@ -100,8 +107,15 @@ pub trait Storage: Send + Sync {\n     /// Gets the longest, committed or uncommitted, chain of blocks originating from `block_hash`, including `block_hash`.\n     async fn longest_child_path(&self, block_hash: &Digest) -> Result<Vec<Digest>>;\n \n+    /// Gets the immediate children of `block_hash`.\n+    async fn get_block_children(&self, block_hash: &Digest) -> Result<Vec<Digest>>;\n+\n     /// Gets a series of hashes used for relaying current block sync state.\n-    async fn get_block_locator_hashes(&self) -> Result<Vec<Digest>>;\n+    async fn get_block_locator_hashes(\n+        &self,\n+        points_of_interest: Vec<Digest>,\n+        oldest_fork_threshold: usize,\n+    ) -> Result<Vec<Digest>>;\n \n     /// Find hashes to provide for a syncing node given `block_locator_hashes`.\n     async fn find_sync_blocks(&self, block_locator_hashes: &[Digest], block_count: usize) -> Result<Vec<Digest>>;\n@@ -161,7 +175,7 @@ pub trait Storage: Send + Sync {\n     /// Gets a dump of all stored canon blocks, in block-number ascending order. A maintenance function, not intended for general use.\n     async fn get_canon_blocks(&self, limit: Option<u32>) -> Result<Vec<SerialBlock>>;\n \n-    /// Similar to `Storage::get_canon_blocks`, gets hashes of all blocks subject to `filter` and `limit` in block-number ascending order. A maintenance function, not intended for general use.\n+    /// Similar to `Storage::get_canon_blocks`, gets hashes of all blocks subject to `filter` and `limit` in filter-defined order. A maintenance function, not intended for general use.\n     async fn get_block_hashes(&self, limit: Option<u32>, filter: BlockFilter) -> Result<Vec<Digest>>;\n \n     /// Performs low-level storage validation; it's mostly intended for test purposes, as there is a lower level `KeyValueStorage` interface available outside of them.\n", "test_patch": "diff --git a/consensus/tests/consensus_sidechain.rs b/consensus/tests/consensus_sidechain.rs\nindex bb7eca7900..ce75b2fd2b 100644\n--- a/consensus/tests/consensus_sidechain.rs\n+++ b/consensus/tests/consensus_sidechain.rs\n@@ -15,6 +15,7 @@\n // along with the snarkOS library. If not, see <https://www.gnu.org/licenses/>.\n \n mod consensus_sidechain {\n+    use snarkos_consensus::OLDEST_FORK_THRESHOLD;\n     use snarkos_storage::validator::FixMode;\n     use snarkos_testing::sync::*;\n \n@@ -183,7 +184,13 @@ mod consensus_sidechain {\n         assert_eq!(best_block_number, block_height);\n \n         // Check if the locator hashes can be found.\n-        assert!(consensus.storage.get_block_locator_hashes().await.is_ok());\n+        assert!(\n+            consensus\n+                .storage\n+                .get_block_locator_hashes(vec![], snarkos_consensus::OLDEST_FORK_THRESHOLD)\n+                .await\n+                .is_ok()\n+        );\n \n         // Decommit a block.\n         let canon_hash = consensus.storage.canon().await.unwrap().hash;\n@@ -195,7 +202,13 @@ mod consensus_sidechain {\n         assert_eq!(best_block_number, block_height);\n \n         // Check if the locator hashes can still be found.\n-        assert!(consensus.storage.get_block_locator_hashes().await.is_ok());\n+        assert!(\n+            consensus\n+                .storage\n+                .get_block_locator_hashes(vec![], snarkos_consensus::OLDEST_FORK_THRESHOLD)\n+                .await\n+                .is_ok()\n+        );\n     }\n \n     #[tokio::test]\n@@ -219,7 +232,11 @@ mod consensus_sidechain {\n         }\n \n         // There is no overlap between the 2 instances.\n-        let consensus1_locator_hashes = consensus1.storage.get_block_locator_hashes().await.unwrap();\n+        let consensus1_locator_hashes = consensus1\n+            .storage\n+            .get_block_locator_hashes(vec![], OLDEST_FORK_THRESHOLD)\n+            .await\n+            .unwrap();\n         let consensus2_sync_blocks = consensus2\n             .storage\n             .find_sync_blocks(&consensus1_locator_hashes, 64)\n@@ -242,7 +259,11 @@ mod consensus_sidechain {\n         }\n \n         // The blocks should fully overlap between the 2 instances now.\n-        let consensus1_locator_hashes = consensus1.storage.get_block_locator_hashes().await.unwrap();\n+        let consensus1_locator_hashes = consensus1\n+            .storage\n+            .get_block_locator_hashes(vec![], OLDEST_FORK_THRESHOLD)\n+            .await\n+            .unwrap();\n         let consensus2_sync_blocks = consensus2\n             .storage\n             .find_sync_blocks(&consensus1_locator_hashes, 64)\n@@ -277,7 +298,11 @@ mod consensus_sidechain {\n         let overlap_height = consensus1.storage.canon().await.unwrap().block_height;\n \n         // There is some initial overlap between the 2 instances.\n-        let consensus1_locator_hashes = consensus1.storage.get_block_locator_hashes().await.unwrap();\n+        let consensus1_locator_hashes = consensus1\n+            .storage\n+            .get_block_locator_hashes(vec![], OLDEST_FORK_THRESHOLD)\n+            .await\n+            .unwrap();\n         let consensus2_sync_blocks = consensus2\n             .storage\n             .find_sync_blocks(&consensus1_locator_hashes, 64)\n@@ -310,7 +335,11 @@ mod consensus_sidechain {\n         }\n \n         // The blocks should fully overlap between the 2 instances now.\n-        let consensus1_locator_hashes = consensus1.storage.get_block_locator_hashes().await.unwrap();\n+        let consensus1_locator_hashes = consensus1\n+            .storage\n+            .get_block_locator_hashes(vec![], OLDEST_FORK_THRESHOLD)\n+            .await\n+            .unwrap();\n         let consensus2_sync_blocks = consensus2\n             .storage\n             .find_sync_blocks(&consensus1_locator_hashes, 64)\n@@ -354,7 +383,11 @@ mod consensus_sidechain {\n         }\n \n         // The blocks should fully overlap between the 2 instances now.\n-        let consensus1_locator_hashes = consensus1.storage.get_block_locator_hashes().await.unwrap();\n+        let consensus1_locator_hashes = consensus1\n+            .storage\n+            .get_block_locator_hashes(vec![], OLDEST_FORK_THRESHOLD)\n+            .await\n+            .unwrap();\n         let sync_blocks = consensus2\n             .storage\n             .find_sync_blocks(&consensus1_locator_hashes, 64)\ndiff --git a/testing/examples/test_blocks.rs b/testing/examples/test_blocks.rs\nindex 630be7cf58..badc142246 100644\n--- a/testing/examples/test_blocks.rs\n+++ b/testing/examples/test_blocks.rs\n@@ -17,91 +17,15 @@\n #[macro_use]\n extern crate tracing;\n \n-use snarkos_consensus::{error::ConsensusError, Consensus, CreateTransactionRequest, MineContext, TransactionResponse};\n-use snarkos_storage::{PrivateKey, SerialBlock, SerialBlockHeader, SerialRecord, SerialTransaction};\n-use snarkos_testing::sync::*;\n-use snarkvm_dpc::{\n-    testnet1::{instantiated::*, record::payload::Payload as RecordPayload},\n-    Account,\n-    Address,\n-    AleoAmount,\n-    DPCComponents,\n+use snarkos_consensus::{error::ConsensusError, MineContext, TransactionResponse};\n+use snarkos_testing::{\n+    mining::{mine_block, send},\n+    sync::*,\n };\n use tracing_subscriber::EnvFilter;\n \n use std::{fs::File, path::PathBuf};\n \n-async fn mine_block(\n-    miner: &MineContext,\n-    transactions: Vec<SerialTransaction>,\n-    parent_block_header: &SerialBlockHeader,\n-) -> Result<(SerialBlock, Vec<SerialRecord>), ConsensusError> {\n-    info!(\"Mining block!\");\n-\n-    let (transactions, coinbase_records) = miner.establish_block(transactions).await?;\n-\n-    let header = miner.find_block(&transactions, parent_block_header)?;\n-\n-    let block = SerialBlock { header, transactions };\n-\n-    let old_block_height = miner.consensus.storage.canon().await?.block_height;\n-\n-    // Duplicate blocks dont do anything\n-    miner.consensus.receive_block(block.clone()).await; // throws a duplicate error -- seemingly intentional\n-\n-    let new_block_height = miner.consensus.storage.canon().await?.block_height;\n-    assert_eq!(old_block_height + 1, new_block_height);\n-\n-    Ok((block, coinbase_records))\n-}\n-\n-/// Spends some value from inputs owned by the sender, to the receiver,\n-/// and pays back whatever we are left with.\n-#[allow(clippy::too_many_arguments)]\n-async fn send(\n-    consensus: &Consensus,\n-    from: &Account<Components>,\n-    inputs: Vec<SerialRecord>,\n-    receiver: &Address<Components>,\n-    amount: i64,\n-    memo: [u8; 32],\n-) -> Result<TransactionResponse, ConsensusError> {\n-    let mut sum = 0;\n-    for inp in &inputs {\n-        sum += inp.value.0;\n-    }\n-    assert!(sum >= amount, \"not enough balance in inputs\");\n-    let change = sum - amount;\n-\n-    let to = vec![receiver.clone(), from.address.clone()];\n-    let values = vec![amount, change];\n-\n-    let from: Vec<PrivateKey> = vec![from.private_key.clone(); Components::NUM_INPUT_RECORDS]\n-        .into_iter()\n-        .map(Into::into)\n-        .collect();\n-\n-    let joint_serial_numbers = consensus.calculate_joint_serial_numbers(&inputs[..], &from[..])?;\n-    let mut new_records = vec![];\n-    for j in 0..Components::NUM_OUTPUT_RECORDS as u8 {\n-        new_records.push(consensus.make_dummy_record(\n-            &joint_serial_numbers[..],\n-            j,\n-            to[j as usize].clone().into(),\n-            AleoAmount(values[j as usize]),\n-            RecordPayload::default(),\n-        )?);\n-    }\n-    consensus\n-        .create_transaction(CreateTransactionRequest {\n-            old_records: inputs,\n-            old_account_private_keys: from,\n-            new_records,\n-            memo,\n-        })\n-        .await\n-}\n-\n async fn mine_blocks(n: u32) -> Result<TestBlocks, ConsensusError> {\n     info!(\"Creating test account\");\n     let [miner_acc, acc_1, _] = FIXTURE.test_accounts.clone();\ndiff --git a/testing/examples/test_data.rs b/testing/examples/test_data.rs\nindex 4e801487d8..ba9d2e8c78 100644\n--- a/testing/examples/test_data.rs\n+++ b/testing/examples/test_data.rs\n@@ -14,20 +14,14 @@\n // You should have received a copy of the GNU General Public License\n // along with the snarkOS library. If not, see <https://www.gnu.org/licenses/>.\n \n-use snarkos_consensus::{error::ConsensusError, Consensus, CreateTransactionRequest, MineContext, TransactionResponse};\n-use snarkos_storage::{PrivateKey, SerialBlock, SerialBlockHeader, SerialRecord, SerialTransaction};\n-use snarkos_testing::sync::*;\n-use snarkvm_dpc::{\n-    testnet1::{instantiated::*, payload::Payload as RecordPayload},\n-    Account,\n-    Address,\n-    AleoAmount,\n-    DPCComponents,\n+use snarkos_consensus::{MineContext, TransactionResponse};\n+use snarkos_testing::{\n+    mining::{mine_block, send},\n+    sync::*,\n };\n \n use snarkvm_utilities::ToBytes;\n use std::{fs::File, path::PathBuf};\n-use tracing::info;\n \n async fn setup_test_data() -> TestData {\n     let [miner_acc, acc_1, _] = FIXTURE.test_accounts.clone();\n@@ -89,77 +83,6 @@ async fn setup_test_data() -> TestData {\n     }\n }\n \n-async fn mine_block(\n-    miner: &MineContext,\n-    transactions: Vec<SerialTransaction>,\n-    parent_block_header: &SerialBlockHeader,\n-) -> Result<(SerialBlock, Vec<SerialRecord>), ConsensusError> {\n-    info!(\"Mining block!\");\n-\n-    let (transactions, coinbase_records) = miner.establish_block(transactions).await?;\n-\n-    let header = miner.find_block(&transactions, parent_block_header)?;\n-\n-    let block = SerialBlock { header, transactions };\n-\n-    let old_block_height = miner.consensus.storage.canon().await?.block_height;\n-\n-    // Duplicate blocks dont do anything\n-    miner.consensus.receive_block(block.clone()).await; // throws a duplicate error -- seemingly intentional\n-\n-    let new_block_height = miner.consensus.storage.canon().await?.block_height;\n-    assert_eq!(old_block_height + 1, new_block_height);\n-\n-    Ok((block, coinbase_records))\n-}\n-\n-/// Spends some value from inputs owned by the sender, to the receiver,\n-/// and pays back whatever we are left with.\n-#[allow(clippy::too_many_arguments)]\n-async fn send(\n-    consensus: &Consensus,\n-    from: &Account<Components>,\n-    inputs: Vec<SerialRecord>,\n-    receiver: &Address<Components>,\n-    amount: i64,\n-    memo: [u8; 32],\n-) -> Result<TransactionResponse, ConsensusError> {\n-    let mut sum = 0;\n-    for inp in &inputs {\n-        sum += inp.value.0;\n-    }\n-    assert!(sum >= amount, \"not enough balance in inputs\");\n-    let change = sum - amount;\n-\n-    let to = vec![receiver.clone(), from.address.clone()];\n-    let values = vec![amount, change];\n-\n-    let from: Vec<PrivateKey> = vec![from.private_key.clone(); Components::NUM_INPUT_RECORDS]\n-        .into_iter()\n-        .map(Into::into)\n-        .collect();\n-\n-    let joint_serial_numbers = consensus.calculate_joint_serial_numbers(&inputs[..], &from[..])?;\n-    let mut new_records = vec![];\n-    for j in 0..Components::NUM_OUTPUT_RECORDS as u8 {\n-        new_records.push(consensus.make_dummy_record(\n-            &joint_serial_numbers[..],\n-            j,\n-            to[j as usize].clone().into(),\n-            AleoAmount(values[j as usize]),\n-            RecordPayload::default(),\n-        )?);\n-    }\n-    consensus\n-        .create_transaction(CreateTransactionRequest {\n-            old_records: inputs,\n-            old_account_private_keys: from,\n-            new_records,\n-            memo,\n-        })\n-        .await\n-}\n-\n #[tokio::main]\n pub async fn main() {\n     let test_data = setup_test_data().await;\ndiff --git a/testing/src/lib.rs b/testing/src/lib.rs\nindex aed057472c..66874650ed 100644\n--- a/testing/src/lib.rs\n+++ b/testing/src/lib.rs\n@@ -18,6 +18,7 @@\n #![forbid(unsafe_code)]\n \n pub mod dpc;\n+pub mod mining;\n #[cfg(feature = \"network\")]\n pub mod network;\n pub mod storage;\ndiff --git a/testing/src/mining/mod.rs b/testing/src/mining/mod.rs\nnew file mode 100644\nindex 0000000000..10a501c6af\n--- /dev/null\n+++ b/testing/src/mining/mod.rs\n@@ -0,0 +1,94 @@\n+// Copyright (C) 2019-2021 Aleo Systems Inc.\n+// This file is part of the snarkOS library.\n+\n+// The snarkOS library is free software: you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation, either version 3 of the License, or\n+// (at your option) any later version.\n+\n+// The snarkOS library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with the snarkOS library. If not, see <https://www.gnu.org/licenses/>.\n+\n+use snarkos_consensus::{error::ConsensusError, Consensus, CreateTransactionRequest, MineContext, TransactionResponse};\n+use snarkos_storage::{PrivateKey, SerialBlock, SerialBlockHeader, SerialRecord, SerialTransaction};\n+use snarkvm_dpc::{\n+    testnet1::{instantiated::*, record::payload::Payload as RecordPayload},\n+    Account,\n+    Address,\n+    AleoAmount,\n+    DPCComponents,\n+};\n+\n+pub async fn mine_block(\n+    miner: &MineContext,\n+    transactions: Vec<SerialTransaction>,\n+    parent_block_header: &SerialBlockHeader,\n+) -> Result<(SerialBlock, Vec<SerialRecord>), ConsensusError> {\n+    let (transactions, coinbase_records) = miner.establish_block(transactions).await?;\n+\n+    let header = miner.find_block(&transactions, parent_block_header)?;\n+\n+    let block = SerialBlock { header, transactions };\n+\n+    let old_block_height = miner.consensus.storage.canon().await?.block_height;\n+\n+    // Duplicate blocks dont do anything\n+    miner.consensus.receive_block(block.clone()).await; // throws a duplicate error -- seemingly intentional\n+\n+    let new_block_height = miner.consensus.storage.canon().await?.block_height;\n+    assert_eq!(old_block_height + 1, new_block_height);\n+\n+    Ok((block, coinbase_records))\n+}\n+\n+/// Spends some value from inputs owned by the sender, to the receiver,\n+/// and pays back whatever we are left with.\n+#[allow(clippy::too_many_arguments)]\n+pub async fn send(\n+    consensus: &Consensus,\n+    from: &Account<Components>,\n+    inputs: Vec<SerialRecord>,\n+    receiver: &Address<Components>,\n+    amount: i64,\n+    memo: [u8; 32],\n+) -> Result<TransactionResponse, ConsensusError> {\n+    let mut sum = 0;\n+    for inp in &inputs {\n+        sum += inp.value.0;\n+    }\n+    assert!(sum >= amount, \"not enough balance in inputs\");\n+    let change = sum - amount;\n+\n+    let to = vec![receiver.clone(), from.address.clone()];\n+    let values = vec![amount, change];\n+\n+    let from: Vec<PrivateKey> = vec![from.private_key.clone(); Components::NUM_INPUT_RECORDS]\n+        .into_iter()\n+        .map(Into::into)\n+        .collect();\n+\n+    let joint_serial_numbers = consensus.calculate_joint_serial_numbers(&inputs[..], &from[..])?;\n+    let mut new_records = vec![];\n+    for j in 0..Components::NUM_OUTPUT_RECORDS as u8 {\n+        new_records.push(consensus.make_dummy_record(\n+            &joint_serial_numbers[..],\n+            j,\n+            to[j as usize].clone().into(),\n+            AleoAmount(values[j as usize]),\n+            RecordPayload::default(),\n+        )?);\n+    }\n+    consensus\n+        .create_transaction(CreateTransactionRequest {\n+            old_records: inputs,\n+            old_account_private_keys: from,\n+            new_records,\n+            memo,\n+        })\n+        .await\n+}\n", "problem_statement": "[Feature] Send fork points in block locator hashes\nTo alleviate issues with syncing with forks around, we could see places we have forked > 64 blocks, and include those critical points as hashes in block locator hashes.\n", "hints_text": "While this could be a good ad-hoc measure, we could improve the general situation if we just decided to send more locator hashes and improve the distances between the provided block hashes; I've updated https://github.com/AleoHQ/snarkOS/pull/809 which does that, and improves the index-picking algorithm.\nI ran into an issue and independently came to this conclusion again.\r\nConsider the following cases:\r\n\r\n1.\r\n\r\nWe have a fork that is 90 blocks long locally, 120 blocks back from local canon. In reality, the 90-block chain is canon, so we are marching down a fork. Even if we include every block we have in canon as block locator hashes, we will not include base of real canon + 90-64 block, the minimum block to continue advancing down canon, in any received sync blocks from peers due to peers sending back only 64 sync block hashes.\r\n\r\nThis has been observed.\r\n\r\n2.\r\n\r\nWe have a fork that is 30 blocks long (notably less than 64 blocks), but its based 600 blocks behind local canon. In reality, the 30-block-long fork is actually canon.\r\n\r\nThe chances of a block locator hash entering a sufficient range, such that a peer sends back some hash we don't already have is relatively low. We halt syncing since our local canon is at tip of some fork, and we don't try to get any more blocks on the real canon chain,\r\n\r\nThis has been observed.\r\n\r\nA proposed (and tested to work) fix is proposed:\r\n1. Limit scope of block locator hashes to only include the range of the last 1024 blocks (equal to our max fork depth) -- we won't fork any further back then that regardless.\r\n2. Limit proportional step of block locator hashes to 63 or less. This prevents us missing a range of block locator hashes, and is actually more strict than the 1024 limit generally.\r\n3. Add the tip of all forks greater than 1 block deep (there are a lot of trivial 1 block forks we can ignore) to block locator hashes, exceeding the default capacity.\r\n\r\nThe combination of these items provides us 100% coverage of our 1024 block range and hedges against long forks with #3. There is a slight performance cost to calculating forks and such, but it's minimal in testing and is worth it.", "created_at": "2021-08-10T00:29:33Z", "version": "1.3"}, {"repo": "AleoNet/snarkOS", "pull_number": 927, "instance_id": "AleoNet__snarkOS-927", "issue_numbers": ["817"], "base_commit": "16235c8d8968357be41fb03c729dfa4e87536362", "patch": "diff --git a/network/src/errors/network.rs b/network/src/errors/network.rs\nindex 4b1a86dab7..c6f7934a6f 100644\n--- a/network/src/errors/network.rs\n+++ b/network/src/errors/network.rs\n@@ -50,6 +50,7 @@ pub enum NetworkError {\n }\n \n impl NetworkError {\n+    // FIXME (nkls): is unused and overlaps with `is_trivial`?\n     pub fn is_fatal(&self) -> bool {\n         match self {\n             Self::Io(err) => [\n@@ -66,7 +67,7 @@ impl NetworkError {\n \n     pub fn is_trivial(&self) -> bool {\n         match self {\n-            NetworkError::Io(e) => {\n+            Self::Io(e) => {\n                 matches!(\n                     e.kind(),\n                     ErrorKind::BrokenPipe\ndiff --git a/network/src/peers/peer/connector.rs b/network/src/peers/peer/connector.rs\nindex 25e15f9beb..f0c105705b 100644\n--- a/network/src/peers/peer/connector.rs\n+++ b/network/src/peers/peer/connector.rs\n@@ -50,9 +50,23 @@ impl Peer {\n                             self.address, e\n                         );\n                     }\n+\n+                    // Marks the peer as unroutable if the connection fails. Currently matches\n+                    // against all io errors which exclude a potential max peers limit breach.\n+                    //\n+                    // FIXME (nkls): refine this to be set for specific errors?\n+                    //\n+                    // TCP/IP error codes are different on Unix and on Windows and can't be\n+                    // reliably matched with the current error kinds. Nightly recently saw the\n+                    // addition of new error kinds that could be useful once stabilised:\n+                    // https://github.com/rust-lang/rust/issues/86442.\n+                    if let NetworkError::Io(_e) = e {\n+                        self.set_routable(false);\n+                    }\n                 }\n                 Ok(network) => {\n                     self.set_connected();\n+                    self.set_routable(true);\n                     metrics::increment_gauge!(CONNECTED, 1.0);\n                     event_target\n                         .send(PeerEvent {\ndiff --git a/network/src/peers/peer/peer.rs b/network/src/peers/peer/peer.rs\nindex 6f79382205..76a445d949 100644\n--- a/network/src/peers/peer/peer.rs\n+++ b/network/src/peers/peer/peer.rs\n@@ -57,6 +57,10 @@ pub struct Peer {\n     pub is_bootnode: bool,\n     #[serde(skip)]\n     pub queued_outbound_message_count: Arc<AtomicUsize>,\n+    /// Whether this peer is routable or not.\n+    ///\n+    /// `None` indicates the node has never attempted a connection with this peer.\n+    pub is_routable: Option<bool>,\n }\n \n const FAILURE_EXPIRY_TIME: Duration = Duration::from_secs(15 * 60);\n@@ -70,6 +74,10 @@ impl Peer {\n             quality: Default::default(),\n             is_bootnode,\n             queued_outbound_message_count: Default::default(),\n+\n+            // Set to `None` since peer creation only ever happens before a connection to the peer,\n+            // therefore we don't know if its listener is routable or not.\n+            is_routable: None,\n         }\n     }\n \n@@ -182,4 +190,8 @@ impl Peer {\n         self.quality.disconnected();\n         self.status = PeerStatus::Disconnected;\n     }\n+\n+    pub(super) fn set_routable(&mut self, is_routable: bool) {\n+        self.is_routable = Some(is_routable)\n+    }\n }\ndiff --git a/network/src/peers/peer_book.rs b/network/src/peers/peer_book.rs\nindex 4bac74cb8e..f1cc5a6bfa 100644\n--- a/network/src/peers/peer_book.rs\n+++ b/network/src/peers/peer_book.rs\n@@ -233,7 +233,7 @@ impl PeerBook {\n         self.map_each_peer(|peer| async move { peer.load().await }).await\n     }\n \n-    pub async fn disconnected_peers_snapshot(&self) -> Vec<Peer> {\n+    pub fn disconnected_peers_snapshot(&self) -> Vec<Peer> {\n         self.disconnected_peers\n             .inner()\n             .iter()\ndiff --git a/network/src/peers/peers.rs b/network/src/peers/peers.rs\nindex 3050d98ab8..56792685e6 100644\n--- a/network/src/peers/peers.rs\n+++ b/network/src/peers/peers.rs\n@@ -202,7 +202,7 @@ impl<S: Storage + Send + Sync + 'static> Node<S> {\n             let bootnodes = self.config.bootnodes();\n \n             // Iterate through a selection of random peers and attempt to connect.\n-            let mut candidates = self.peer_book.disconnected_peers_snapshot().await;\n+            let mut candidates = self.peer_book.disconnected_peers_snapshot();\n \n             candidates.retain(|peer| peer.address != own_address && !bootnodes.contains(&peer.address));\n \n@@ -290,12 +290,52 @@ impl<S: Storage + Send + Sync + 'static> Node<S> {\n \n     pub(crate) async fn send_peers(&self, remote_address: SocketAddr) {\n         // Broadcast the sanitized list of connected peers back to the requesting peer.\n-        let peers = self\n-            .peer_book\n-            .connected_peers()\n-            .into_iter()\n-            .filter(|&addr| addr != remote_address)\n-            .choose_multiple(&mut rand::thread_rng(), crate::SHARED_PEER_COUNT);\n+\n+        use crate::Peer;\n+        use rand::prelude::SliceRandom;\n+\n+        let connected_peers = self.peer_book.connected_peers_snapshot().await;\n+\n+        let basic_filter =\n+            |peer: &Peer| peer.address != remote_address && !self.config.bootnodes().contains(&peer.address);\n+        let strict_filter = |peer: &Peer| basic_filter(peer) && peer.is_routable.unwrap_or(false);\n+\n+        // Strictly filter the connected peers by only including the routable addresses.\n+        let strictly_filtered_peers: Vec<SocketAddr> = connected_peers\n+            .iter()\n+            .filter(|peer| strict_filter(peer))\n+            .map(|peer| peer.address)\n+            .collect();\n+\n+        // Bootnodes apply less strict filtering rules if the set is empty by falling back on\n+        // connected peers that may or may not be routable...\n+        let peers = if self.config.is_bootnode() && strictly_filtered_peers.is_empty() {\n+            let filtered_peers: Vec<SocketAddr> = connected_peers\n+                .iter()\n+                .filter(|peer| basic_filter(peer))\n+                .map(|peer| peer.address)\n+                .collect();\n+\n+            // ...and if need be on disconnected peers.\n+            if filtered_peers.is_empty() {\n+                self.peer_book\n+                    .disconnected_peers_snapshot()\n+                    .iter()\n+                    .filter(|peer| basic_filter(peer))\n+                    .map(|peer| peer.address)\n+                    .collect()\n+            } else {\n+                filtered_peers\n+            }\n+        } else {\n+            strictly_filtered_peers\n+        };\n+\n+        // Limit set size.\n+        let peers = peers\n+            .choose_multiple(&mut rand::thread_rng(), crate::SHARED_PEER_COUNT)\n+            .copied()\n+            .collect();\n \n         self.peer_book.send_to(remote_address, Payload::Peers(peers)).await;\n     }\ndiff --git a/rpc/src/rpc_impl.rs b/rpc/src/rpc_impl.rs\nindex 22104ca0d2..8517715e54 100644\n--- a/rpc/src/rpc_impl.rs\n+++ b/rpc/src/rpc_impl.rs\n@@ -408,7 +408,7 @@ impl<S: Storage + Send + core::marker::Sync + 'static> RpcFunctions for RpcImpl<\n             .iter()\n             .map(|(addr, node_centrality)| Vertice {\n                 addr: *addr,\n-                is_bootnode: self.node.config.bootnodes().contains(&addr),\n+                is_bootnode: self.node.config.bootnodes().contains(addr),\n                 degree_centrality: node_centrality.degree_centrality,\n                 eigenvector_centrality: node_centrality.eigenvector_centrality,\n                 fiedler_value: node_centrality.fiedler_value,\n", "test_patch": "diff --git a/network/tests/peers.rs b/network/tests/peers.rs\nindex 8792a988e7..86fa8fb474 100644\n--- a/network/tests/peers.rs\n+++ b/network/tests/peers.rs\n@@ -70,29 +70,28 @@ async fn peer_responder_side() {\n }\n \n #[tokio::test(flavor = \"multi_thread\")]\n-async fn triangle() {\n-    let setup = |bootnodes| TestSetup {\n+async fn bootnode_peer_propagation() {\n+    let setup = |is_bootnode, bootnodes| TestSetup {\n         consensus_setup: None,\n         min_peers: 2,\n         peer_sync_interval: 1,\n+        is_bootnode,\n         bootnodes,\n         ..Default::default()\n     };\n \n     // Spin up and connect nodes A and B.\n-    let node_alice = test_node(setup(vec![])).await;\n+    let node_alice = test_node(setup(true, vec![])).await;\n     let addr_alice = node_alice.local_address().unwrap();\n \n-    // wait a few ms so that nodes don't try to connect into one another simultaneously\n-    sleep(Duration::from_millis(10)).await;\n+    // Connect B to A.\n+    let node_bob = test_node(setup(false, vec![addr_alice.to_string()])).await;\n \n-    let node_bob = test_node(setup(vec![addr_alice.to_string()])).await;\n-    let addr_bob = node_bob.local_address().unwrap();\n+    // Sleep to avoid C and B trying to simultaneously connect to each other.\n+    sleep(Duration::from_millis(100)).await;\n \n-    sleep(Duration::from_millis(10)).await;\n-\n-    //  Spin up node C and connect to B.\n-    let node_charlie = test_node(setup(vec![addr_bob.to_string()])).await;\n+    // Connect C to A.\n+    let node_charlie = test_node(setup(false, vec![addr_alice.to_string()])).await;\n \n     let triangle_is_formed = || {\n         node_charlie.peer_book.is_connected(addr_alice)\n@@ -101,6 +100,7 @@ async fn triangle() {\n             && node_charlie.peer_book.get_active_peer_count() == 2\n     };\n \n-    // Make sure C connects to A => peer propagation works.\n+    // Make sure B and C connect => bootnode propagates peers (without `is_routable` check in this\n+    // case).\n     wait_until!(5, triangle_is_formed());\n }\ndiff --git a/network/tests/topology.rs b/network/tests/topology.rs\nindex ee6cfdf358..13f4f16a5d 100644\n--- a/network/tests/topology.rs\n+++ b/network/tests/topology.rs\n@@ -135,6 +135,8 @@ async fn spawn_nodes_in_a_mesh() {\n     );\n }\n \n+// FIXME: adjust to new peering mechanics.\n+#[ignore]\n #[tokio::test(flavor = \"multi_thread\")]\n async fn line_converges_to_mesh() {\n     let setup = TestSetup {\n@@ -156,6 +158,7 @@ async fn line_converges_to_mesh() {\n     );\n }\n \n+#[ignore]\n #[tokio::test(flavor = \"multi_thread\")]\n async fn ring_converges_to_mesh() {\n     let setup = TestSetup {\n@@ -177,6 +180,7 @@ async fn ring_converges_to_mesh() {\n     );\n }\n \n+#[ignore]\n #[tokio::test(flavor = \"multi_thread\")]\n async fn star_converges_to_mesh() {\n     let setup = TestSetup {\n", "problem_statement": "[Feature] Don't provide unroutable addresses in peer lists\nThe current peer-sharing mechanism only checks that we don't provide a peer with its own address among the addresses we're connected to; we can do better than this, though, including:\r\n- excluding bootnodes (peers are generally going to know the same ones)\r\n- excluding addresses that connected to us (as opposed to us being the initiator; potentially unroutable)\r\n- filtering for addresses that we would verify to be routable\r\n\r\nThis could be related to https://github.com/AleoHQ/snarkOS/issues/802, as the network crawler would know a lot of peers and be able to produce great peer lists.\n", "hints_text": "", "created_at": "2021-07-07T13:45:46Z", "version": "1.3"}, {"repo": "AleoNet/snarkOS", "pull_number": 878, "instance_id": "AleoNet__snarkOS-878", "issue_numbers": ["802", "818"], "base_commit": "fee2c04ff43bea30047da19b21ab69fe3fec42e2", "patch": "diff --git a/Cargo.lock b/Cargo.lock\nindex ca14eb4226..f312fd086c 100644\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -61,9 +61,9 @@ checksum = \"28b2cd92db5cbd74e8e5028f7e27dd7aa3090e89e4f2a197cc7c8dfb69c7063b\"\n \n [[package]]\n name = \"approx\"\n-version = \"0.5.0\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"072df7202e63b127ab55acfe16ce97013d5b97bf160489336d3f1840fd78e99e\"\n+checksum = \"3f2a05fd1bd10b2527e20a2cd32d8873d115b8b39fe219ee25f42a8aca6ba278\"\n dependencies = [\n  \"num-traits\",\n ]\n@@ -1655,13 +1655,12 @@ dependencies = [\n \n [[package]]\n name = \"nalgebra\"\n-version = \"0.27.1\"\n+version = \"0.26.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"462fffe4002f4f2e1f6a9dcf12cc1a6fc0e15989014efc02a941d3e0f5dc2120\"\n+checksum = \"476d1d59fe02fe54c86356e91650cd892f392782a1cb9fc524ec84f7aa9e1d06\"\n dependencies = [\n  \"approx\",\n  \"matrixmultiply\",\n- \"nalgebra-macros\",\n  \"num-complex\",\n  \"num-rational\",\n  \"num-traits\",\n@@ -1669,17 +1668,6 @@ dependencies = [\n  \"typenum\",\n ]\n \n-[[package]]\n-name = \"nalgebra-macros\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"01fcc0b8149b4632adc89ac3b7b31a12fb6099a0317a4eb2ebff574ef7de7218\"\n-dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n [[package]]\n name = \"native-tls\"\n version = \"0.2.7\"\n@@ -1745,9 +1733,9 @@ dependencies = [\n \n [[package]]\n name = \"num-complex\"\n-version = \"0.4.0\"\n+version = \"0.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"26873667bbbb7c5182d4a37c1add32cdf09f841af72da53318fdb81543c15085\"\n+checksum = \"747d632c0c558b87dbabbe6a82f3b4ae03720d0646ac5b7b4dae89394be5f2c5\"\n dependencies = [\n  \"num-traits\",\n ]\n@@ -1764,9 +1752,9 @@ dependencies = [\n \n [[package]]\n name = \"num-rational\"\n-version = \"0.4.0\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d41702bd167c2df5520b384281bc111a4b5efcf7fbc4c9c222c815b07e0a6a6a\"\n+checksum = \"12ac428b1cb17fce6f731001d307d351ec70a6d202fc2e60f7d4c5e42d8f4f07\"\n dependencies = [\n  \"autocfg\",\n  \"num-integer\",\n@@ -2577,9 +2565,9 @@ checksum = \"7fdf1b9db47230893d76faad238fd6097fd6d6a9245cd7a4d90dbd639536bbd2\"\n \n [[package]]\n name = \"simba\"\n-version = \"0.5.1\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8e82063457853d00243beda9952e910b82593e4b07ae9f721b9278a99a0d3d5c\"\n+checksum = \"5132a955559188f3d13c9ba831e77c802ddc8782783f050ed0c52f5988b95f4c\"\n dependencies = [\n  \"approx\",\n  \"num-complex\",\n@@ -2729,6 +2717,7 @@ dependencies = [\n  \"mpmc-map\",\n  \"nalgebra\",\n  \"once_cell\",\n+ \"parking_lot\",\n  \"peak_alloc\",\n  \"rand 0.8.3\",\n  \"serde\",\ndiff --git a/network/Cargo.toml b/network/Cargo.toml\nindex 21e18c5781..c200c8fd03 100644\n--- a/network/Cargo.toml\n+++ b/network/Cargo.toml\n@@ -84,9 +84,15 @@ version = \"0.1\"\n [dependencies.async-trait]\n version = \"0.1\"\n \n+[dependencies.nalgebra]\n+version = \"0.26\"\n+\n [dependencies.once_cell]\n version = \"1.5.2\"\n \n+[dependencies.parking_lot]\n+version = \"0.11.1\"\n+\n [dependencies.rand]\n version = \"0.8\"\n \n@@ -144,8 +150,6 @@ version = \"0.1\"\n [dev-dependencies.snarkos-testing]\n path = \"../testing\"\n \n-[dev-dependencies.nalgebra]\n-version = \"0.27\"\n \n [dev-dependencies.peak_alloc]\n version = \"0.1.0\"\ndiff --git a/network/src/inbound/inbound.rs b/network/src/inbound/inbound.rs\nindex 5893c5653e..b6ac7d1694 100644\n--- a/network/src/inbound/inbound.rs\n+++ b/network/src/inbound/inbound.rs\n@@ -207,7 +207,7 @@ impl<S: Storage + Send + Sync + 'static> Node<S> {\n             Payload::Peers(peers) => {\n                 metrics::increment_counter!(inbound::PEERS);\n \n-                self.process_inbound_peers(peers).await;\n+                self.process_inbound_peers(source, peers).await;\n             }\n             Payload::Ping(_) | Payload::Pong => {\n                 // Skip as this case is already handled with priority in inbound_handler\ndiff --git a/network/src/lib.rs b/network/src/lib.rs\nindex d183f17f6e..55f5fc74e0 100644\n--- a/network/src/lib.rs\n+++ b/network/src/lib.rs\n@@ -46,6 +46,9 @@ pub mod node;\n pub mod peers;\n pub mod sync;\n \n+pub mod topology;\n+pub use topology::*;\n+\n /// The maximum number of block hashes that can be requested or provided in a single batch.\n pub const MAX_BLOCK_SYNC_COUNT: u32 = 64;\n /// The maximum amount of time allowed to process a single batch of sync blocks. It should be aligned\ndiff --git a/network/src/node.rs b/network/src/node.rs\nindex c422c61013..fb60f770d7 100644\n--- a/network/src/node.rs\n+++ b/network/src/node.rs\n@@ -63,6 +63,8 @@ pub struct InnerNode<S: Storage + core::marker::Sync + Send + 'static> {\n     pub peer_book: PeerBook,\n     /// The sync handler of this node.\n     pub sync: OnceCell<Arc<Sync<S>>>,\n+    /// Tracks the known network crawled by this node.\n+    pub known_network: OnceCell<KnownNetwork>,\n     /// The node's start-up timestamp.\n     pub launched: DateTime<Utc>,\n     /// The tasks spawned by the node.\n@@ -111,7 +113,7 @@ impl<S: Storage + core::marker::Sync + Send + 'static> Node<S> {\n impl<S: Storage + Send + core::marker::Sync + 'static> Node<S> {\n     /// Creates a new instance of `Node`.\n     pub async fn new(config: Config) -> Result<Self, NetworkError> {\n-        Ok(Self(Arc::new(InnerNode {\n+        let node = Self(Arc::new(InnerNode {\n             id: thread_rng().gen(),\n             state: Default::default(),\n             local_address: Default::default(),\n@@ -119,12 +121,20 @@ impl<S: Storage + Send + core::marker::Sync + 'static> Node<S> {\n             inbound: Default::default(),\n             peer_book: PeerBook::spawn(),\n             sync: Default::default(),\n+            known_network: Default::default(),\n             launched: Utc::now(),\n             tasks: Default::default(),\n             threads: Default::default(),\n             shutting_down: Default::default(),\n             master_dispatch: RwLock::new(None),\n-        })))\n+        }));\n+\n+        if node.config.is_bootnode() {\n+            // Safe since this can only ever be set here.\n+            node.known_network.set(KnownNetwork::default()).unwrap();\n+        }\n+\n+        Ok(node)\n     }\n \n     pub fn set_sync(&mut self, sync: Sync<S>) {\n@@ -151,6 +161,10 @@ impl<S: Storage + Send + core::marker::Sync + 'static> Node<S> {\n         self.sync().is_some()\n     }\n \n+    pub fn known_network(&self) -> Option<&KnownNetwork> {\n+        self.known_network.get()\n+    }\n+\n     pub async fn start_services(&self) {\n         let node_clone = self.clone();\n         let mut receiver = self.inbound.take_receiver().await;\n@@ -181,6 +195,20 @@ impl<S: Storage + Send + core::marker::Sync + 'static> Node<S> {\n         });\n         self.register_task(peering_task);\n \n+        if self.known_network().is_some() {\n+            let node_clone = self.clone();\n+\n+            let known_network_task = task::spawn(async move {\n+                loop {\n+                    // Should always be present since we check for it before this block.\n+                    if let Some(known_network) = node_clone.known_network() {\n+                        known_network.update().await\n+                    }\n+                }\n+            });\n+            self.register_task(known_network_task);\n+        }\n+\n         let node_clone = self.clone();\n         let state_tracking_task = task::spawn(async move {\n             loop {\ndiff --git a/network/src/peers/peer_book.rs b/network/src/peers/peer_book.rs\nindex b849b6bc58..2a9eb0fb5c 100644\n--- a/network/src/peers/peer_book.rs\n+++ b/network/src/peers/peer_book.rs\n@@ -113,8 +113,16 @@ impl PeerBook {\n         self.connected_peers.inner().keys().copied().collect()\n     }\n \n+    pub fn disconnected_peers(&self) -> Vec<SocketAddr> {\n+        self.disconnected_peers.inner().keys().copied().collect()\n+    }\n+\n+    pub fn get_connected_peer_count(&self) -> u32 {\n+        self.connected_peers.len() as u32\n+    }\n+\n     pub fn get_active_peer_count(&self) -> u32 {\n-        self.connected_peers.len() as u32 + self.pending_connections()\n+        self.get_connected_peer_count() + self.pending_connections()\n     }\n \n     pub fn get_disconnected_peer_count(&self) -> u32 {\n@@ -133,10 +141,6 @@ impl PeerBook {\n         self.disconnected_peers.get(&address)\n     }\n \n-    pub fn disconnected_peers(&self) -> Vec<SocketAddr> {\n-        self.disconnected_peers.inner().keys().copied().collect()\n-    }\n-\n     async fn take_disconnected_peer(&self, address: SocketAddr) -> Option<Peer> {\n         metrics::decrement_gauge!(DISCONNECTED, 1.0);\n         self.disconnected_peers.remove(address).await\n@@ -229,6 +233,14 @@ impl PeerBook {\n         self.map_each_peer(|peer| async move { peer.load().await }).await\n     }\n \n+    pub async fn disconnected_peers_snapshot(&self) -> Vec<Peer> {\n+        self.disconnected_peers\n+            .inner()\n+            .iter()\n+            .map(|(_, peer)| peer.clone())\n+            .collect()\n+    }\n+\n     ///\n     /// Adds the given address to the disconnected peers in this `PeerBook`.\n     ///\ndiff --git a/network/src/peers/peers.rs b/network/src/peers/peers.rs\nindex 452a0460a7..a73e49d417 100644\n--- a/network/src/peers/peers.rs\n+++ b/network/src/peers/peers.rs\n@@ -37,8 +37,7 @@ impl<S: Storage + Send + Sync + 'static> Node<S> {\n     ///\n     pub(crate) async fn update_peers(&self) {\n         // Fetch the number of connected and connecting peers.\n-        let active_peer_count = self.peer_book.get_active_peer_count() as usize;\n-\n+        let active_peer_count = self.peer_book.get_active_peer_count();\n         info!(\n             \"Connected to {} peer{}\",\n             active_peer_count,\n@@ -50,27 +49,35 @@ impl<S: Storage + Send + Sync + 'static> Node<S> {\n         // give us 100ms to close some negatively judge_badd connections (probably less needed, but we have time)\n         tokio::time::sleep(Duration::from_millis(100)).await;\n \n-        // Attempt to connect to the default bootnodes of the network.\n-        self.connect_to_bootnodes().await;\n-\n-        // Attempt to connect to each disconnected peer saved in the peer book.\n-        if !self.config.is_bootnode() {\n-            self.connect_to_disconnected_peers().await;\n-        }\n-\n-        // Broadcast a `GetPeers` message to request for more peers.\n-        self.broadcast_getpeers_requests().await;\n-\n-        let new_active_peer_count = self.peer_book.get_active_peer_count() as usize;\n-        // Check if this node server is above the permitted number of connected peers.\n-        let max_peers = self.config.maximum_number_of_connected_peers() as usize;\n-        if new_active_peer_count > max_peers {\n-            let number_to_disconnect = new_active_peer_count - max_peers;\n-            trace!(\n-                \"Disconnecting from {} peers to maintain their permitted number\",\n-                number_to_disconnect\n-            );\n+        // Fetch active peer count after high RTTs disconnects.\n+        let active_peer_count = self.peer_book.get_active_peer_count();\n+        let min_peers = self.config.minimum_number_of_connected_peers() as u32;\n+        let max_peers = self.config.maximum_number_of_connected_peers() as u32;\n+\n+        // Calculate the peer counts to disconnect and connect based on the node type and current\n+        // peer counts.\n+        let (number_to_disconnect, number_to_connect) = match self.config.is_bootnode() {\n+            true => {\n+                // Bootnodes disconnect down to the min peer count, this to free up room for\n+                // the next crawled peers...\n+                let number_to_disconnect = active_peer_count.saturating_sub(min_peers);\n+                // ...then they connect to disconnected peers leaving 20% of their capacity open\n+                // incoming connections.\n+                const CRAWLING_CAPACITY_PERCENTAGE: f64 = 0.8;\n+                let crawling_capacity = (CRAWLING_CAPACITY_PERCENTAGE * max_peers as f64).floor() as u32;\n+                let number_to_connect = crawling_capacity.saturating_sub(active_peer_count - number_to_disconnect);\n+\n+                (number_to_disconnect, number_to_connect)\n+            }\n+            false => (\n+                // Non-bootnodes disconnect if above the max peer count...\n+                active_peer_count.saturating_sub(max_peers),\n+                // ...and connect if below the min peer count.\n+                min_peers.saturating_sub(active_peer_count),\n+            ),\n+        };\n \n+        if number_to_disconnect != 0 {\n             let mut current_peers = self.peer_book.connected_peers_snapshot().await;\n \n             // Bootnodes will disconnect from random peers...\n@@ -86,7 +93,21 @@ impl<S: Storage + Send + Sync + 'static> Node<S> {\n             }\n         }\n \n-        if new_active_peer_count != 0 {\n+        // Attempt to connect to the default bootnodes of the network if the node has no active\n+        // connections.\n+        if self.peer_book.get_active_peer_count() == 0 {\n+            self.connect_to_bootnodes().await;\n+        }\n+\n+        if number_to_connect != 0 {\n+            self.connect_to_disconnected_peers(number_to_connect as usize).await;\n+        }\n+\n+        // Only broadcast requests if any peers are connected.\n+        if self.peer_book.get_connected_peer_count() != 0 {\n+            // Broadcast a `GetPeers` message to request for more peers.\n+            self.broadcast_getpeers_requests().await;\n+\n             // Send a `Ping` to every connected peer.\n             self.broadcast_pings().await;\n         }\n@@ -167,44 +188,37 @@ impl<S: Storage + Send + Sync + 'static> Node<S> {\n     ///\n     /// Broadcasts a connection request to all disconnected peers.\n     ///\n-    async fn connect_to_disconnected_peers(&self) {\n+    async fn connect_to_disconnected_peers(&self, count: usize) {\n         // Local address must be known by now.\n         let own_address = self.local_address().unwrap();\n \n-        // If this node is a bootnode, attempt to connect to all disconnected peers.\n         // If this node is not a bootnode, attempt to satisfy the minimum number of peer connections.\n         let random_peers = {\n-            // Fetch the number of connected and connecting peers.\n-            let number_of_peers = self.peer_book.get_active_peer_count() as usize;\n-\n-            // Check if this node server is below the permitted number of connected peers.\n-            let min_peers = self.config.minimum_number_of_connected_peers() as usize;\n-            if number_of_peers >= min_peers {\n-                return;\n-            }\n-\n-            // Set the number of peers to attempt a connection to.\n-            let count = min_peers - number_of_peers;\n-\n-            if count == 0 {\n-                return;\n-            }\n-\n-            let disconnected_peers = self.peer_book.disconnected_peers();\n-\n             trace!(\n                 \"Connecting to {} disconnected peers\",\n-                cmp::min(count, disconnected_peers.len())\n+                cmp::min(count, self.peer_book.disconnected_peers().len())\n             );\n \n             let bootnodes = self.config.bootnodes();\n \n             // Iterate through a selection of random peers and attempt to connect.\n-            disconnected_peers\n-                .iter()\n-                .filter(|peer| **peer != own_address && !bootnodes.contains(peer))\n-                .copied()\n-                .choose_multiple(&mut rand::thread_rng(), count)\n+            let mut candidates = self.peer_book.disconnected_peers_snapshot().await;\n+\n+            candidates.retain(|peer| peer.address != own_address && !bootnodes.contains(&peer.address));\n+\n+            if self.config.is_bootnode() {\n+                // Bootnodes choose peers they haven't dialed in a while.\n+                candidates.sort_unstable_by_key(|peer| peer.quality.last_connected);\n+            }\n+\n+            // Only keep the addresses.\n+            let addr_iter = candidates.iter().map(|peer| peer.address);\n+\n+            if self.config.is_bootnode() {\n+                addr_iter.take(count).collect()\n+            } else {\n+                addr_iter.choose_multiple(&mut rand::thread_rng(), count)\n+            }\n         };\n \n         for remote_address in random_peers {\n@@ -289,17 +303,24 @@ impl<S: Storage + Send + Sync + 'static> Node<S> {\n     /// A node has sent their list of peer addresses.\n     /// Add all new/updated addresses to our disconnected.\n     /// The connection handler will be responsible for sending out handshake requests to them.\n-    pub(crate) async fn process_inbound_peers(&self, peers: Vec<SocketAddr>) {\n+    pub(crate) async fn process_inbound_peers(&self, source: SocketAddr, peers: Vec<SocketAddr>) {\n         let local_address = self.local_address().unwrap(); // the address must be known by now\n \n-        for peer_address in peers.into_iter().filter(|&peer_addr| peer_addr != local_address) {\n+        for peer_address in peers.iter().filter(|&peer_addr| *peer_addr != local_address) {\n             // Inform the peer book that we found a peer.\n             // The peer book will determine if we have seen the peer before,\n             // and include the peer if it is new.\n             self.peer_book\n-                .add_peer(peer_address, self.config.bootnodes().contains(&peer_address))\n+                .add_peer(*peer_address, self.config.bootnodes().contains(&peer_address))\n                 .await;\n         }\n+\n+        if let Some(known_network) = self.known_network() {\n+            // If this node is tracking the network, record the connections. This can\n+            // then be used to construct the graph and query peer info from the peerbook.\n+\n+            let _ = known_network.sender.try_send((source, peers));\n+        }\n     }\n \n     pub fn can_connect(&self) -> bool {\ndiff --git a/network/src/topology.rs b/network/src/topology.rs\nnew file mode 100644\nindex 0000000000..078765bfe8\n--- /dev/null\n+++ b/network/src/topology.rs\n@@ -0,0 +1,542 @@\n+// Copyright (C) 2019-2021 Aleo Systems Inc.\n+// This file is part of the snarkOS library.\n+\n+// The snarkOS library is free software: you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation, either version 3 of the License, or\n+// (at your option) any later version.\n+\n+// The snarkOS library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with the snarkOS library. If not, see <https://www.gnu.org/licenses/>.\n+\n+// Network crawler:\n+// Start a crawler task (similar to the peers task) which updates state. Only one peer would be\n+// connected at a time to start and would be queried for peers. It would then select on peer at\n+// random to continue the crawl.\n+//\n+// Q: extend the network protocol to include statistics or node metadata?\n+// Q: when to perform centrality computation?\n+\n+use std::{\n+    cmp::Ordering,\n+    collections::{BTreeMap, HashSet},\n+    hash::{Hash, Hasher},\n+    net::SocketAddr,\n+    ops::Sub,\n+};\n+\n+use chrono::{DateTime, Utc};\n+use nalgebra::{DMatrix, DVector, SymmetricEigen};\n+use parking_lot::RwLock;\n+use tokio::sync::{\n+    mpsc,\n+    mpsc::{Receiver, Sender},\n+    Mutex,\n+};\n+\n+// Purges connections that haven't been seen within this time (in hours).\n+const STALE_CONNECTION_CUTOFF_TIME_HRS: i64 = 4;\n+\n+/// A connection between two peers.\n+///\n+/// Implements `partialEq` and `Hash` manually so that the `source`-`target` order has no impact on equality\n+/// (since connections are directionless). The timestamp is also not included in the comparison.\n+#[derive(Debug, Eq, Copy, Clone)]\n+pub struct Connection {\n+    /// One side of the connection.\n+    pub source: SocketAddr,\n+    /// The other side of the connection.\n+    pub target: SocketAddr,\n+    /// The last time this peer was seen by the crawler (used determine which connections are\n+    /// likely stale).\n+    last_seen: DateTime<Utc>,\n+}\n+\n+impl PartialEq for Connection {\n+    fn eq(&self, other: &Self) -> bool {\n+        let (a, b) = (self.source, self.target);\n+        let (c, d) = (other.source, other.target);\n+\n+        a == d && b == c || a == c && b == d\n+    }\n+}\n+\n+impl Hash for Connection {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let (a, b) = (self.source, self.target);\n+\n+        // This ensures the hash is the same for (a, b) as it is for (b, a).\n+        match a.cmp(&b) {\n+            Ordering::Greater => {\n+                b.hash(state);\n+                a.hash(state);\n+            }\n+            _ => {\n+                a.hash(state);\n+                b.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+impl Connection {\n+    fn new(source: SocketAddr, target: SocketAddr) -> Self {\n+        Connection {\n+            source,\n+            target,\n+            last_seen: Utc::now(),\n+        }\n+    }\n+}\n+\n+/// Keeps track of crawled peers and their connections.\n+#[derive(Debug)]\n+pub struct KnownNetwork {\n+    pub sender: Sender<(SocketAddr, Vec<SocketAddr>)>,\n+    receiver: Mutex<Receiver<(SocketAddr, Vec<SocketAddr>)>>,\n+    connections: RwLock<HashSet<Connection>>,\n+}\n+\n+impl Default for KnownNetwork {\n+    fn default() -> Self {\n+        // Buffer size of 1000 messages seems reasonable to begin with.\n+        let (tx, rx) = mpsc::channel(1000);\n+\n+        Self {\n+            sender: tx,\n+            receiver: Mutex::new(rx),\n+            connections: Default::default(),\n+        }\n+    }\n+}\n+\n+impl KnownNetwork {\n+    /// Updates the crawled connection set.\n+    pub async fn update(&self) {\n+        if let Some((source, peers)) = self.receiver.lock().await.recv().await {\n+            self.update_inner(source, peers);\n+        }\n+    }\n+\n+    // More convenient for testing.\n+    fn update_inner(&self, source: SocketAddr, peers: Vec<SocketAddr>) {\n+        // Rules:\n+        //  - if a connecton exists already, do nothing.\n+        //  - if a connection is new, add it.\n+        //  - if an exisitng connection involving the source isn't in the peerlist, remove it if\n+        //  it's stale.\n+\n+        let new_connections: HashSet<Connection> =\n+            peers.into_iter().map(|peer| Connection::new(source, peer)).collect();\n+\n+        // Find which connections need to be removed.\n+        //\n+        // With sets: a - b = removed connections (if and only if one of the two addrs is the\n+        // source), otherwise it's a connection which doesn't include the source and shouldn't be\n+        // removed. We also keep connections seen within the last few hours as peerlists are capped\n+        // in size and omitted connections don't necessarily mean they don't exist anymore.\n+        let connections_to_remove: HashSet<Connection> = self\n+            .connections\n+            .read()\n+            .difference(&new_connections)\n+            .filter(|conn| {\n+                (conn.source == source || conn.target == source)\n+                    && (Utc::now() - conn.last_seen).num_hours() > STALE_CONNECTION_CUTOFF_TIME_HRS\n+            })\n+            .copied()\n+            .collect();\n+\n+        // Only retain connections that aren't removed.\n+        self.connections\n+            .write()\n+            .retain(|connection| !connections_to_remove.contains(&connection));\n+\n+        // Scope the write lock.\n+        {\n+            let mut connections_g = self.connections.write();\n+\n+            // Insert new connections, we use replace so the last seen timestamp is overwritten.\n+            for new_connection in new_connections.into_iter() {\n+                connections_g.replace(new_connection);\n+            }\n+        }\n+    }\n+\n+    /// Returns a connection.\n+    pub fn get_connection(&self, source: SocketAddr, target: SocketAddr) -> Option<Connection> {\n+        self.connections.read().get(&Connection::new(source, target)).copied()\n+    }\n+\n+    /// Returns a snapshot of all the connections.\n+    pub fn connections(&self) -> HashSet<Connection> {\n+        self.connections.read().clone()\n+    }\n+\n+    /// Returns `true` if the known network contains any connections, `false` otherwise.\n+    pub fn has_connections(&self) -> bool {\n+        !self.connections.read().is_empty()\n+    }\n+}\n+\n+/// Network topology measurements.\n+#[derive(Debug)]\n+pub struct NetworkMetrics {\n+    /// The total node count of the network.\n+    node_count: usize,\n+    /// The total connection count for the network.\n+    connection_count: usize,\n+    /// The network density.\n+    ///\n+    /// This is defined as actual connections divided by the total number of possible connections.\n+    density: f64,\n+    /// The algebraic connectivity of the network.\n+    ///\n+    /// This is the value of the Fiedler eigenvalue, the second-smallest eigenvalue of the network's\n+    /// Laplacian matrix.\n+    algebraic_connectivity: f64,\n+    /// The difference between the node with the largest connection count and the node with the\n+    /// lowest.\n+    degree_centrality_delta: f64,\n+    /// Node centrality measurements mapped to each node's address.\n+    ///\n+    /// Includes degree centrality, eigenvector centrality (the relative importance of a node in\n+    /// the network) and Fiedler vector (describes a possible partitioning of the network).\n+    centrality: BTreeMap<SocketAddr, NodeCentrality>,\n+}\n+\n+impl NetworkMetrics {\n+    /// Returns the network metrics for the state described by the connections list.\n+    pub fn new(known_network: &KnownNetwork) -> Self {\n+        // Copy the connections as the data must not change throughout the metrics computation.\n+        let connections: HashSet<Connection> = known_network.connections();\n+\n+        // Construct the list of nodes from the connections.\n+        let mut nodes: HashSet<SocketAddr> = HashSet::new();\n+        for connection in connections.iter() {\n+            // Using a hashset guarantees uniqueness.\n+            nodes.insert(connection.source);\n+            nodes.insert(connection.target);\n+        }\n+\n+        let node_count = nodes.len();\n+        let connection_count = connections.len();\n+        let density = calculate_density(node_count as f64, connection_count as f64);\n+\n+        // Create an index of nodes to introduce some notion of order the rows and columns all matrices will follow.\n+        let index: BTreeMap<SocketAddr, usize> = nodes.iter().enumerate().map(|(i, &addr)| (addr, i)).collect();\n+\n+        // Not stored on the struct but can be pretty inspected with `println!`.\n+        // The adjacency matrix can be built from the node index and the connections list.\n+        let adjacency_matrix = adjacency_matrix(&index, connections);\n+        // The degree matrix can be built from the adjacency matrix (row sum is connection count).\n+        let degree_matrix = degree_matrix(&index, &adjacency_matrix);\n+        // The laplacian matrix is degree matrix minus the adjacence matrix.\n+        let laplacian_matrix = degree_matrix.clone().sub(&adjacency_matrix);\n+\n+        let degree_centrality = degree_centrality(&index, &degree_matrix);\n+        let degree_centrality_delta = degree_centrality_delta(&degree_matrix);\n+        let eigenvector_centrality = eigenvector_centrality(&index, adjacency_matrix);\n+        let (algebraic_connectivity, fiedler_vector_indexed) = fiedler(&index, laplacian_matrix);\n+\n+        // Create the `NodeCentrality` instances for each node.\n+        let centrality: BTreeMap<SocketAddr, NodeCentrality> = nodes\n+            .iter()\n+            .map(|&addr| {\n+                // Must contain values for this node since it was constructed using same set of\n+                // nodes.\n+                let dc = degree_centrality.get(&addr).unwrap();\n+                let ec = eigenvector_centrality.get(&addr).unwrap();\n+                let fv = fiedler_vector_indexed.get(&addr).unwrap();\n+                let nc = NodeCentrality::new(*dc, *ec, *fv);\n+\n+                (addr, nc)\n+            })\n+            .collect();\n+\n+        Self {\n+            node_count,\n+            connection_count,\n+            density,\n+            algebraic_connectivity,\n+            degree_centrality_delta,\n+            centrality,\n+        }\n+    }\n+}\n+\n+/// Centrality measurements of a node.\n+#[derive(Debug)]\n+struct NodeCentrality {\n+    /// Connection count of the node.\n+    degree_centrality: u16,\n+    /// A measure of the relative importance of the node in the network.\n+    ///\n+    /// Summing the values of each node adds up to the number of nodes in the network. This was\n+    /// done to allow comparison between different network topologies irrespective of node count.\n+    eigenvector_centrality: f64,\n+    /// This value is extracted from the Fiedler eigenvector corresponding to the second smallest\n+    /// eigenvalue of the Laplacian matrix of the network.\n+    ///\n+    /// The network can be partitioned on the basis of these values (positive, negative and when\n+    /// relevant close to zero).\n+    fiedler_value: f64,\n+}\n+\n+impl NodeCentrality {\n+    fn new(degree_centrality: u16, eigenvector_centrality: f64, fiedler_value: f64) -> Self {\n+        Self {\n+            degree_centrality,\n+            eigenvector_centrality,\n+            fiedler_value,\n+        }\n+    }\n+}\n+\n+pub fn calculate_density(n: f64, ac: f64) -> f64 {\n+    // Calculate the total number of possible connections given a node count.\n+    let pc = n * (n - 1.0) / 2.0;\n+    // Actual connections divided by the possbile connections gives the density.\n+    ac / pc\n+}\n+\n+/// Returns the degree matrix for the network with values ordered by the index.\n+fn degree_matrix(index: &BTreeMap<SocketAddr, usize>, adjacency_matrix: &DMatrix<f64>) -> DMatrix<f64> {\n+    let n = index.len();\n+    let mut matrix = DMatrix::<f64>::zeros(n, n);\n+\n+    for (i, row) in adjacency_matrix.row_iter().enumerate() {\n+        // Set the diagonal to be the sum of connections in that row. The index isn't necessary\n+        // here since the rows are visited in order and the adjacency matrix is ordered after the\n+        // index.\n+        matrix[(i, i)] = row.sum()\n+    }\n+\n+    matrix\n+}\n+\n+/// Returns the adjacency matrix for the network with values ordered by the index.\n+fn adjacency_matrix(index: &BTreeMap<SocketAddr, usize>, connections: HashSet<Connection>) -> DMatrix<f64> {\n+    let n = index.len();\n+    let mut matrix = DMatrix::<f64>::zeros(n, n);\n+\n+    // Compute the adjacency matrix. As our network is an undirected graph, the adjacency matrix is\n+    // symmetric.\n+    for connection in connections {\n+        // Addresses must be present.\n+        // Get the indices for each address in the connection.\n+        let i = index.get(&connection.source).unwrap();\n+        let j = index.get(&connection.target).unwrap();\n+\n+        // Since connections are unique both the upper and lower triangles must be writted (as the\n+        // graph is unidrected) for each connection.\n+        matrix[(*i, *j)] = 1.0;\n+        matrix[(*j, *i)] = 1.0;\n+    }\n+\n+    matrix\n+}\n+\n+/// Returns the difference between the highest and lowest degree centrality in the network.\n+///\n+/// Returns an `f64`, though the value should be a natural number.\n+fn degree_centrality_delta(degree_matrix: &DMatrix<f64>) -> f64 {\n+    let max = degree_matrix.max();\n+    let min = degree_matrix.min();\n+\n+    max - min\n+}\n+\n+/// Returns the degree centrality of a node.\n+///\n+/// This is defined as the connection count of the node.\n+fn degree_centrality(index: &BTreeMap<SocketAddr, usize>, degree_matrix: &DMatrix<f64>) -> BTreeMap<SocketAddr, u16> {\n+    let diag = degree_matrix.diagonal();\n+    index\n+        .keys()\n+        .zip(diag.iter())\n+        .map(|(addr, dc)| (*addr, *dc as u16))\n+        .collect()\n+}\n+\n+/// Returns the eigenvalue centrality of each node in the network.\n+fn eigenvector_centrality(\n+    index: &BTreeMap<SocketAddr, usize>,\n+    adjacency_matrix: DMatrix<f64>,\n+) -> BTreeMap<SocketAddr, f64> {\n+    // Compute the eigenvectors and corresponding eigenvalues and sort in descending order.\n+    let ascending = false;\n+    let eigenvalue_vector_pairs = sorted_eigenvalue_vector_pairs(adjacency_matrix, ascending);\n+    let (_highest_eigenvalue, highest_eigenvector) = &eigenvalue_vector_pairs[0];\n+\n+    // The eigenvector is a relative score of node importance (normalised by the norm), to obtain an absolute score for each\n+    // node, we normalise so that the sum of the components are equal to 1.\n+    let sum = highest_eigenvector.sum() / index.len() as f64;\n+    let normalised = highest_eigenvector.unscale(sum);\n+\n+    // Map addresses to their eigenvalue centrality.\n+    index\n+        .keys()\n+        .zip(normalised.column(0).iter())\n+        .map(|(addr, ec)| (*addr, *ec))\n+        .collect()\n+}\n+\n+/// Returns the Fiedler values for each node in the network.\n+fn fiedler(index: &BTreeMap<SocketAddr, usize>, laplacian_matrix: DMatrix<f64>) -> (f64, BTreeMap<SocketAddr, f64>) {\n+    // Compute the eigenvectors and corresponding eigenvalues and sort in ascending order.\n+    let ascending = true;\n+    let pairs = sorted_eigenvalue_vector_pairs(laplacian_matrix, ascending);\n+\n+    // Second-smallest eigenvalue is the Fiedler value (algebraic connectivity), the associated\n+    // eigenvector is the Fiedler vector.\n+    let (algebraic_connectivity, fiedler_vector) = &pairs[1];\n+\n+    // Map addresses to their Fiedler values.\n+    let fiedler_values_indexed = index\n+        .keys()\n+        .zip(fiedler_vector.column(0).iter())\n+        .map(|(addr, fiedler_value)| (*addr, *fiedler_value))\n+        .collect();\n+\n+    (*algebraic_connectivity, fiedler_values_indexed)\n+}\n+\n+/// Computes the eigenvalues and corresponding eigenvalues from the supplied symmetric matrix.\n+fn sorted_eigenvalue_vector_pairs(matrix: DMatrix<f64>, ascending: bool) -> Vec<(f64, DVector<f64>)> {\n+    // Compute eigenvalues and eigenvectors.\n+    let eigen = SymmetricEigen::new(matrix);\n+\n+    // Map eigenvalues to their eigenvectors.\n+    let mut pairs: Vec<(f64, DVector<f64>)> = eigen\n+        .eigenvalues\n+        .iter()\n+        .zip(eigen.eigenvectors.column_iter())\n+        .map(|(value, vector)| (*value, vector.clone_owned()))\n+        .collect();\n+\n+    // Sort eigenvalue-vector pairs in descending order.\n+    pairs.sort_unstable_by(|(a, _), (b, _)| {\n+        if ascending {\n+            a.partial_cmp(b).unwrap()\n+        } else {\n+            b.partial_cmp(a).unwrap()\n+        }\n+    });\n+\n+    pairs\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use chrono::Duration;\n+\n+    #[test]\n+    fn connections_partial_eq() {\n+        let a = \"12.34.56.78:9000\".parse().unwrap();\n+        let b = \"98.76.54.32:1000\".parse().unwrap();\n+\n+        assert_eq!(Connection::new(a, b), Connection::new(b, a));\n+        assert_eq!(Connection::new(a, b), Connection::new(a, b));\n+    }\n+\n+    #[test]\n+    fn connections_update() {\n+        let addr_a = \"11.11.11.11:1000\".parse().unwrap();\n+        let addr_b = \"22.22.22.22:2000\".parse().unwrap();\n+        let addr_c = \"33.33.33.33:3000\".parse().unwrap();\n+        let addr_d = \"44.44.44.44:4000\".parse().unwrap();\n+        let addr_e = \"55.55.55.55:5000\".parse().unwrap();\n+\n+        let old_but_valid_timestamp = Utc::now() - Duration::hours(STALE_CONNECTION_CUTOFF_TIME_HRS - 1);\n+        let stale_timestamp = Utc::now() - Duration::hours(STALE_CONNECTION_CUTOFF_TIME_HRS + 1);\n+\n+        // Seed the known network with the older connections.\n+        let old_but_valid_connection = Connection {\n+            source: addr_a,\n+            target: addr_d,\n+            last_seen: old_but_valid_timestamp,\n+        };\n+\n+        let stale_connection = Connection {\n+            source: addr_a,\n+            target: addr_e,\n+            last_seen: stale_timestamp,\n+        };\n+\n+        let mut seeded_connections = HashSet::new();\n+        seeded_connections.insert(old_but_valid_connection);\n+        seeded_connections.insert(stale_connection);\n+\n+        let (tx, rx) = mpsc::channel(100);\n+        let known_network = KnownNetwork {\n+            sender: tx,\n+            receiver: Mutex::new(rx),\n+            connections: RwLock::new(seeded_connections),\n+        };\n+\n+        // Insert two connections.\n+        known_network.update_inner(addr_a, vec![addr_b, addr_c]);\n+        assert!(\n+            known_network\n+                .connections\n+                .read()\n+                .contains(&Connection::new(addr_a, addr_b))\n+        );\n+        assert!(\n+            known_network\n+                .connections\n+                .read()\n+                .contains(&Connection::new(addr_a, addr_c))\n+        );\n+        assert!(\n+            known_network\n+                .connections\n+                .read()\n+                .contains(&Connection::new(addr_a, addr_d))\n+        );\n+        // Assert the stale connection was purged.\n+        assert!(\n+            !known_network\n+                .connections\n+                .read()\n+                .contains(&Connection::new(addr_a, addr_e))\n+        );\n+\n+        // Insert (a, b) connection reversed, make sure it doesn't change the list.\n+        known_network.update_inner(addr_b, vec![addr_a]);\n+        assert_eq!(known_network.connections.read().len(), 3);\n+\n+        // Insert (a, d) again and make sure the timestamp was updated.\n+        known_network.update_inner(addr_a, vec![addr_d]);\n+        assert_ne!(\n+            old_but_valid_timestamp,\n+            known_network.get_connection(addr_a, addr_d).unwrap().last_seen\n+        );\n+    }\n+\n+    #[test]\n+    fn connections_hash() {\n+        use std::collections::hash_map::DefaultHasher;\n+\n+        let a = \"11.11.11.11:1000\".parse().unwrap();\n+        let b = \"22.22.22.22:2000\".parse().unwrap();\n+\n+        let mut h1 = DefaultHasher::new();\n+        let mut h2 = DefaultHasher::new();\n+\n+        let k1 = Connection::new(a, b);\n+        let k2 = Connection::new(b, a);\n+\n+        k1.hash(&mut h1);\n+        k2.hash(&mut h2);\n+\n+        // verify k1 == k2 => hash(k1) == hash(k2)\n+        assert_eq!(h1.finish(), h2.finish());\n+    }\n+}\ndiff --git a/rpc/documentation/public_endpoints/getnetworkgraph.md b/rpc/documentation/public_endpoints/getnetworkgraph.md\nnew file mode 100644\nindex 0000000000..1b3545c5fe\n--- /dev/null\n+++ b/rpc/documentation/public_endpoints/getnetworkgraph.md\n@@ -0,0 +1,22 @@\n+Returns the network graph crawled by this node (if it is a bootnode).\n+\n+### Arguments\n+\n+None\n+\n+### Response\n+\n+| Parameter                 | Type       | Description                               |\n+| :-----------------------: | :--------: | :---------------------------------------: |\n+| `edges`                   | array      | The list of connections known by the node |\n+| `vertices`                | array      | The list of nodes known by the node       |\n+| `edges[i].source`         | SocketAddr | One side of the crawled connection        |\n+| `edges[i].target`         | SocketAddr | The other side of the crawled connection  |\n+| `vertices[i].addr`        | SocketAddr | The recorded address of the crawled node  |\n+| `vertices[i].is_bootnode` | bool       | Indicates whether the node is a bootnode  |\n+\n+### Example\n+```ignore\n+curl --data-binary '{\"jsonrpc\": \"2.0\", \"id\":\"documentation\", \"method\": \"getnetworkgraph\", \"params\": [] }' -H 'content-type: application/json' http://127.0.0.1:3030/\n+```\n+\ndiff --git a/rpc/src/custom_rpc_server.rs b/rpc/src/custom_rpc_server.rs\nindex afbd12d7bb..58c6c3c77b 100644\n--- a/rpc/src/custom_rpc_server.rs\n+++ b/rpc/src/custom_rpc_server.rs\n@@ -219,6 +219,10 @@ async fn handle_rpc<S: Storage + Send + Sync + 'static>(\n             let result = rpc.get_block_template().map_err(convert_crate_err);\n             result_to_response(&req, result)\n         }\n+        \"getnetworkgraph\" => {\n+            let result = rpc.get_network_graph().map_err(convert_crate_err);\n+            result_to_response(&req, result)\n+        }\n         // private\n         \"createaccount\" => {\n             let result = rpc\ndiff --git a/rpc/src/error.rs b/rpc/src/error.rs\nindex 7818866d37..56a1dd6fd9 100644\n--- a/rpc/src/error.rs\n+++ b/rpc/src/error.rs\n@@ -52,6 +52,9 @@ pub enum RpcError {\n     #[error(\"The node doesn't have the sync layer running\")]\n     NoConsensus,\n \n+    #[error(\"The node isn't tracking the network\")]\n+    NoKnownNetwork,\n+\n     #[error(\"{}\", _0)]\n     StorageError(StorageError),\n \ndiff --git a/rpc/src/rpc_impl.rs b/rpc/src/rpc_impl.rs\nindex 2fc93d905e..3c78d9e75e 100644\n--- a/rpc/src/rpc_impl.rs\n+++ b/rpc/src/rpc_impl.rs\n@@ -21,7 +21,7 @@\n use crate::{error::RpcError, rpc_trait::RpcFunctions, rpc_types::*};\n use snarkos_consensus::{get_block_reward, memory_pool::Entry, ConsensusParameters, MemoryPool, MerkleTreeLedger};\n use snarkos_metrics::{snapshots::NodeStats, stats::NODE_STATS};\n-use snarkos_network::{Node, Sync};\n+use snarkos_network::{KnownNetwork, Node, Sync};\n use snarkvm_dpc::{\n     testnet1::{\n         instantiated::{Components, Tx},\n@@ -40,6 +40,7 @@ use snarkvm_utilities::{\n use chrono::Utc;\n \n use std::{\n+    collections::HashSet,\n     ops::Deref,\n     sync::{atomic::Ordering, Arc},\n };\n@@ -94,6 +95,10 @@ impl<S: Storage + Send + core::marker::Sync + 'static> RpcImpl<S> {\n     pub fn memory_pool(&self) -> Result<&MemoryPool<Tx>, RpcError> {\n         Ok(self.sync_handler()?.memory_pool())\n     }\n+\n+    pub fn known_network(&self) -> Result<&KnownNetwork, RpcError> {\n+        self.node.known_network().ok_or(RpcError::NoKnownNetwork)\n+    }\n }\n \n impl<S: Storage + Send + core::marker::Sync + 'static> RpcFunctions for RpcImpl<S> {\n@@ -377,4 +382,29 @@ impl<S: Storage + Send + core::marker::Sync + 'static> RpcFunctions for RpcImpl<\n             coinbase_value: coinbase_value.0 as u64,\n         })\n     }\n+\n+    fn get_network_graph(&self) -> Result<NetworkGraph, RpcError> {\n+        let mut vertices = HashSet::new();\n+        let edges: HashSet<Edge> = self\n+            .known_network()?\n+            .connections()\n+            .iter()\n+            .map(|connection| {\n+                let (source, target) = (connection.source, connection.target);\n+\n+                vertices.insert(Vertice {\n+                    addr: source,\n+                    is_bootnode: self.node.config.bootnodes().contains(&source),\n+                });\n+                vertices.insert(Vertice {\n+                    addr: target,\n+                    is_bootnode: self.node.config.bootnodes().contains(&target),\n+                });\n+\n+                Edge { source, target }\n+            })\n+            .collect();\n+\n+        Ok(NetworkGraph { vertices, edges })\n+    }\n }\ndiff --git a/rpc/src/rpc_trait.rs b/rpc/src/rpc_trait.rs\nindex f203ee32db..9497a7344b 100644\n--- a/rpc/src/rpc_trait.rs\n+++ b/rpc/src/rpc_trait.rs\n@@ -98,6 +98,11 @@ pub trait RpcFunctions {\n     // #[cfg_attr(nightly, doc(include = \"../documentation/public_endpoints/getblocktemplate.md\"))]\n     #[rpc(name = \"getblocktemplate\")]\n     fn get_block_template(&self) -> Result<BlockTemplate, RpcError>;\n+\n+    // todo: readd in Rust 1.54\n+    // #[cfg_attr(nightly, doc(include =\"../documentation/public_endpoints/getnetworkgraph.md\"))]\n+    #[rpc(name = \"getnetworkgraph\")]\n+    fn get_network_graph(&self) -> Result<NetworkGraph, RpcError>;\n }\n \n /// Definition of private RPC endpoints that require authentication.\ndiff --git a/rpc/src/rpc_types.rs b/rpc/src/rpc_types.rs\nindex 2014e118a6..710227eccf 100644\n--- a/rpc/src/rpc_types.rs\n+++ b/rpc/src/rpc_types.rs\n@@ -19,7 +19,7 @@\n use chrono::{DateTime, Utc};\n use jsonrpc_core::Metadata;\n use serde::{Deserialize, Serialize};\n-use std::net::SocketAddr;\n+use std::{collections::HashSet, net::SocketAddr};\n \n /// Defines the authentication format for accessing private endpoints on the RPC server\n #[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]\n@@ -282,3 +282,21 @@ pub struct TransactionRecipient {\n     /// The amount being sent\n     pub amount: u64,\n }\n+\n+#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]\n+pub struct NetworkGraph {\n+    pub vertices: HashSet<Vertice>,\n+    pub edges: HashSet<Edge>,\n+}\n+\n+#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, Hash)]\n+pub struct Vertice {\n+    pub addr: SocketAddr,\n+    pub is_bootnode: bool,\n+}\n+\n+#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, Hash)]\n+pub struct Edge {\n+    pub source: SocketAddr,\n+    pub target: SocketAddr,\n+}\n", "test_patch": "diff --git a/network/tests/topology.rs b/network/tests/topology.rs\nindex 78311941f4..ee6cfdf358 100644\n--- a/network/tests/topology.rs\n+++ b/network/tests/topology.rs\n@@ -14,7 +14,7 @@\n // You should have received a copy of the GNU General Public License\n // along with the snarkOS library. If not, see <https://www.gnu.org/licenses/>.\n \n-use snarkos_network::Node;\n+use snarkos_network::{topology::calculate_density, Node};\n use snarkos_storage::LedgerStorage;\n use snarkos_testing::{\n     network::{\n@@ -26,10 +26,6 @@ use snarkos_testing::{\n     wait_until,\n };\n \n-use std::{collections::BTreeMap, net::SocketAddr, ops::Sub};\n-\n-use nalgebra::{DMatrix, DVector, SymmetricEigen};\n-\n const N: usize = 25;\n const MIN_PEERS: u16 = 5;\n const MAX_PEERS: u16 = 30;\n@@ -132,7 +128,11 @@ async fn spawn_nodes_in_a_mesh() {\n     // Make sure the node with the largest degree centrality and smallest degree centrality don't\n     // have a delta greater than the max-min peer interval allows for. This check also provides\n     // some insight into whether the network is meshed in a homogeneous manner.\n-    wait_until!(15, degree_centrality_delta(&nodes) <= MAX_PEERS - MIN_PEERS, 200);\n+    wait_until!(\n+        15,\n+        degree_centrality_delta(&nodes) <= (MAX_PEERS - MIN_PEERS).into(),\n+        200\n+    );\n }\n \n #[tokio::test(flavor = \"multi_thread\")]\n@@ -149,7 +149,11 @@ async fn line_converges_to_mesh() {\n     start_nodes(&nodes).await;\n \n     wait_until!(10, network_density(&nodes) >= 0.1, 200);\n-    wait_until!(10, degree_centrality_delta(&nodes) <= MAX_PEERS - MIN_PEERS, 200);\n+    wait_until!(\n+        10,\n+        degree_centrality_delta(&nodes) <= (MAX_PEERS - MIN_PEERS).into(),\n+        200\n+    );\n }\n \n #[tokio::test(flavor = \"multi_thread\")]\n@@ -166,7 +170,11 @@ async fn ring_converges_to_mesh() {\n     start_nodes(&nodes).await;\n \n     wait_until!(10, network_density(&nodes) >= 0.1, 200);\n-    wait_until!(10, degree_centrality_delta(&nodes) <= MAX_PEERS - MIN_PEERS, 200);\n+    wait_until!(\n+        10,\n+        degree_centrality_delta(&nodes) <= (MAX_PEERS - MIN_PEERS).into(),\n+        200\n+    );\n }\n \n #[tokio::test(flavor = \"multi_thread\")]\n@@ -183,7 +191,11 @@ async fn star_converges_to_mesh() {\n     start_nodes(&nodes).await;\n \n     wait_until!(15, network_density(&nodes) >= 0.1, 200);\n-    wait_until!(15, degree_centrality_delta(&nodes) <= MAX_PEERS - MIN_PEERS, 200);\n+    wait_until!(\n+        15,\n+        degree_centrality_delta(&nodes) <= (MAX_PEERS - MIN_PEERS).into(),\n+        200\n+    );\n }\n \n #[tokio::test(flavor = \"multi_thread\")]\n@@ -253,268 +265,32 @@ async fn binary_star_contact() {\n     nodes.push(solo);\n \n     wait_until!(10, network_density(&nodes) >= 0.05);\n-\n-    // Computing the metrics for this ignored case, interesting to inspect, especially Fiedler\n-    // partitioning as we have a graph with two clusters both centered around the bootnodes.\n-    let metrics = NetworkMetrics::new(&nodes);\n-    assert_eq!(metrics.node_count, 51);\n-}\n-\n-/// Network topology measurements.\n-#[derive(Debug)]\n-struct NetworkMetrics {\n-    /// The total node count of the network.\n-    node_count: usize,\n-    /// The total connection count for the network.\n-    connection_count: usize,\n-    /// The network density.\n-    ///\n-    /// This is defined as actual connections divided by the total number of possible connections.\n-    density: f64,\n-    /// The algebraic connectivity of the network.\n-    ///\n-    /// This is the value of the Fiedler eigenvalue, the second-smallest eigenvalue of the network's\n-    /// Laplacian matrix.\n-    algebraic_connectivity: f64,\n-    /// The difference between the node with the largest connection count and the node with the\n-    /// lowest.\n-    degree_centrality_delta: u16,\n-    /// Node centrality measurements mapped to each node's address.\n-    ///\n-    /// Includes degree centrality, eigenvector centrality (the relative importance of a node in\n-    /// the network) and Fiedler vector (describes a possible partitioning of the network).\n-    centrality: BTreeMap<SocketAddr, NodeCentrality>,\n-}\n-\n-impl NetworkMetrics {\n-    /// Returns the network metrics for the state described by the node list.\n-    fn new(nodes: &[Node<LedgerStorage>]) -> Self {\n-        let node_count = nodes.len();\n-        let connection_count = total_connection_count(nodes);\n-        let density = network_density(&nodes);\n-\n-        // Create an index of nodes to introduce some notion of order the rows and columns all matrices will follow.\n-        let index: BTreeMap<SocketAddr, usize> = nodes\n-            .iter()\n-            .map(|node| node.local_address().unwrap())\n-            .enumerate()\n-            .map(|(i, addr)| (addr, i))\n-            .collect();\n-\n-        // Not stored on the struct but can be pretty inspected with `println!`.\n-        let degree_matrix = degree_matrix(&index, &nodes);\n-        let adjacency_matrix = adjacency_matrix(&index, &nodes);\n-        let laplacian_matrix = degree_matrix.clone().sub(adjacency_matrix.clone());\n-\n-        let degree_centrality = degree_centrality(&index, degree_matrix);\n-        let degree_centrality_delta = degree_centrality_delta(&nodes);\n-        let eigenvector_centrality = eigenvector_centrality(&index, adjacency_matrix);\n-        let (algebraic_connectivity, fiedler_vector_indexed) = fiedler(&index, laplacian_matrix);\n-\n-        // Create the `NodeCentrality` instances for each node.\n-        let centrality: BTreeMap<SocketAddr, NodeCentrality> = nodes\n-            .iter()\n-            .map(|node| {\n-                let addr = node.local_address().unwrap();\n-                // Must contain values for this node since it was constructed using same set of\n-                // nodes.\n-                let dc = degree_centrality.get(&addr).unwrap();\n-                let ec = eigenvector_centrality.get(&addr).unwrap();\n-                let fv = fiedler_vector_indexed.get(&addr).unwrap();\n-                let nc = NodeCentrality::new(*dc, *ec, *fv);\n-\n-                (addr, nc)\n-            })\n-            .collect();\n-\n-        Self {\n-            node_count,\n-            connection_count,\n-            density,\n-            algebraic_connectivity,\n-            degree_centrality_delta,\n-            centrality,\n-        }\n-    }\n-}\n-\n-/// Centrality measurements of a node.\n-#[derive(Debug)]\n-struct NodeCentrality {\n-    /// Connection count of the node.\n-    degree_centrality: u16,\n-    /// A measure of the relative importance of the node in the network.\n-    ///\n-    /// Summing the values of each node adds up to the number of nodes in the network. This was\n-    /// done to allow comparison between different network topologies irrespective of node count.\n-    eigenvector_centrality: f64,\n-    /// This value is extracted from the Fiedler eigenvector corresponding to the second smallest\n-    /// eigenvalue of the Laplacian matrix of the network.\n-    ///\n-    /// The network can be partitioned on the basis of these values (positive, negative and when\n-    /// relevant close to zero).\n-    fiedler_value: f64,\n-}\n-\n-impl NodeCentrality {\n-    fn new(degree_centrality: u16, eigenvector_centrality: f64, fiedler_value: f64) -> Self {\n-        Self {\n-            degree_centrality,\n-            eigenvector_centrality,\n-            fiedler_value,\n-        }\n-    }\n }\n \n /// Returns the total connection count of the network.\n-fn total_connection_count(nodes: &[Node<LedgerStorage>]) -> usize {\n+fn total_connection_count(nodes: &[Node<LedgerStorage>]) -> u32 {\n     let mut count = 0;\n \n     for node in nodes {\n-        count += node.peer_book.get_active_peer_count()\n-    }\n-\n-    (count / 2) as usize\n-}\n-\n-/// Returns the network density.\n-fn network_density(nodes: &[Node<LedgerStorage>]) -> f64 {\n-    let connections = total_connection_count(nodes);\n-    calculate_density(nodes.len() as f64, connections as f64)\n-}\n-\n-fn calculate_density(n: f64, ac: f64) -> f64 {\n-    // Calculate the total number of possible connections given a node count.\n-    let pc = n * (n - 1.0) / 2.0;\n-    // Actual connections divided by the possbile connections gives the density.\n-    ac / pc\n-}\n-\n-/// Returns the degree matrix for the network with values ordered by the index.\n-fn degree_matrix(index: &BTreeMap<SocketAddr, usize>, nodes: &[Node<LedgerStorage>]) -> DMatrix<f64> {\n-    let n = nodes.len();\n-    let mut matrix = DMatrix::<f64>::zeros(n, n);\n-\n-    for node in nodes {\n-        let n = node.peer_book.get_active_peer_count();\n-        // Address must be present.\n-        // Get the index for the and set the number of connected peers. The degree matrix is\n-        // diagonal.\n-        let node_n = index.get(&node.local_address().unwrap()).unwrap();\n-        matrix[(*node_n, *node_n)] = n as f64;\n-    }\n-\n-    matrix\n-}\n-\n-/// Returns the adjacency matrix for the network with values ordered by the index.\n-fn adjacency_matrix(index: &BTreeMap<SocketAddr, usize>, nodes: &[Node<LedgerStorage>]) -> DMatrix<f64> {\n-    let n = nodes.len();\n-    let mut matrix = DMatrix::<f64>::zeros(n, n);\n-\n-    // Compute the adjacency matrix. As our network is an undirected graph, the adjacency matrix is\n-    // symmetric.\n-    for node in nodes {\n-        node.peer_book.connected_peers().into_iter().for_each(|addr| {\n-            // Addresses must be present.\n-            // Get the indices for each node, progressing row by row to construct the matrix.\n-            let node_m = index.get(&node.local_address().unwrap()).unwrap();\n-            let peer_n = index.get(&addr).unwrap();\n-            matrix[(*node_m, *peer_n)] = 1.0;\n-        });\n+        count += node.peer_book.get_connected_peer_count()\n     }\n \n-    matrix\n+    count / 2\n }\n \n-/// Returns the difference between the highest and lowest degree centrality in the network.\n // This could use the degree matrix, though as this is used extensively in tests and checked\n // repeatedly until it reaches a certain value, we want to keep its calculation decoupled from the\n // `NetworkMetrics`.\n-fn degree_centrality_delta(nodes: &[Node<LedgerStorage>]) -> u16 {\n-    let dc = nodes.iter().map(|node| node.peer_book.get_active_peer_count());\n+fn degree_centrality_delta(nodes: &[Node<LedgerStorage>]) -> u32 {\n+    let dc = nodes.iter().map(|node| node.peer_book.get_connected_peer_count());\n     let min = dc.clone().min().unwrap();\n     let max = dc.max().unwrap();\n \n-    (max - min) as u16\n-}\n-\n-/// Returns the degree centrality of a node.\n-///\n-/// This is defined as the connection count of the node.\n-fn degree_centrality(index: &BTreeMap<SocketAddr, usize>, degree_matrix: DMatrix<f64>) -> BTreeMap<SocketAddr, u16> {\n-    let diag = degree_matrix.diagonal();\n-    index\n-        .keys()\n-        .zip(diag.iter())\n-        .map(|(addr, dc)| (*addr, *dc as u16))\n-        .collect()\n+    max - min\n }\n \n-/// Returns the eigenvalue centrality of each node in the network.\n-fn eigenvector_centrality(\n-    index: &BTreeMap<SocketAddr, usize>,\n-    adjacency_matrix: DMatrix<f64>,\n-) -> BTreeMap<SocketAddr, f64> {\n-    // Compute the eigenvectors and corresponding eigenvalues and sort in descending order.\n-    let ascending = false;\n-    let eigenvalue_vector_pairs = sorted_eigenvalue_vector_pairs(adjacency_matrix, ascending);\n-    let (_highest_eigenvalue, highest_eigenvector) = &eigenvalue_vector_pairs[0];\n-\n-    // The eigenvector is a relative score of node importance (normalised by the norm), to obtain an absolute score for each\n-    // node, we normalise so that the sum of the components are equal to 1.\n-    let sum = highest_eigenvector.sum() / index.len() as f64;\n-    let normalised = highest_eigenvector.unscale(sum);\n-\n-    // Map addresses to their eigenvalue centrality.\n-    index\n-        .keys()\n-        .zip(normalised.column(0).iter())\n-        .map(|(addr, ec)| (*addr, *ec))\n-        .collect()\n-}\n-\n-/// Returns the Fiedler values for each node in the network.\n-fn fiedler(index: &BTreeMap<SocketAddr, usize>, laplacian_matrix: DMatrix<f64>) -> (f64, BTreeMap<SocketAddr, f64>) {\n-    // Compute the eigenvectors and corresponding eigenvalues and sort in ascending order.\n-    let ascending = true;\n-    let pairs = sorted_eigenvalue_vector_pairs(laplacian_matrix, ascending);\n-\n-    // Second-smallest eigenvalue is the Fiedler value (algebraic connectivity), the associated\n-    // eigenvector is the Fiedler vector.\n-    let (algebraic_connectivity, fiedler_vector) = &pairs[1];\n-\n-    // Map addresses to their Fiedler values.\n-    let fiedler_values_indexed = index\n-        .keys()\n-        .zip(fiedler_vector.column(0).iter())\n-        .map(|(addr, fiedler_value)| (*addr, *fiedler_value))\n-        .collect();\n-\n-    (*algebraic_connectivity, fiedler_values_indexed)\n-}\n-\n-/// Computes the eigenvalues and corresponding eigenvalues from the supplied symmetric matrix.\n-fn sorted_eigenvalue_vector_pairs(matrix: DMatrix<f64>, ascending: bool) -> Vec<(f64, DVector<f64>)> {\n-    // Compute eigenvalues and eigenvectors.\n-    let eigen = SymmetricEigen::new(matrix);\n-\n-    // Map eigenvalues to their eigenvectors.\n-    let mut pairs: Vec<(f64, DVector<f64>)> = eigen\n-        .eigenvalues\n-        .iter()\n-        .zip(eigen.eigenvectors.column_iter())\n-        .map(|(value, vector)| (*value, vector.clone_owned()))\n-        .collect();\n-\n-    // Sort eigenvalue-vector pairs in descending order.\n-    pairs.sort_unstable_by(|(a, _), (b, _)| {\n-        if ascending {\n-            a.partial_cmp(b).unwrap()\n-        } else {\n-            b.partial_cmp(a).unwrap()\n-        }\n-    });\n-\n-    pairs\n+/// Returns the network density.\n+fn network_density(nodes: &[Node<LedgerStorage>]) -> f64 {\n+    let connections = total_connection_count(nodes);\n+    calculate_density(nodes.len() as f64, connections as f64)\n }\n", "problem_statement": "[Feature] Protocol (as opposed to rpc) based network crawler\n## \ud83d\ude80 Feature\r\n\r\nA network based crawler would be more reliable than RPC (which relies on nodes running on the default port). It could also  be used for in-depth network analysis (graph exposed through RPC and behind a feature flag) and network shaping when coupled with the already implemented centrality measurements.\r\n\n[Feature] Improve the availability of bootnodes\nDue to all the nodes maintaining persistent connections, the default list of bootnodes that all the nodes attempt to connect to at first can quickly exhaust their connection limits, regardless of how generous they are. There are several ways in which we can improve this situation:\r\n- making the bootnodes \"thin\" and their connections short-lived, i.e. removing their sync capabilities and instead making them laser-focused on just providing lists of peers; that would make them capable of handling huge numbers of connections, making us able to have fewer bootnodes in total; such bootnodes could also serve as network crawlers (see https://github.com/AleoHQ/snarkOS/issues/802) and actively improve the \"shape\" of the network by providing \"smart\" peer lists\r\n- making the connections of bootnodes short-lived (though not as short as in the first point), e.g. disconnecting from peers after e.g. 5 minutes; that time should allow the new peers to learn about other potential peers and possibly form long-lived connections with them instead of the bootnodes\r\n- reduce the number of bootnodes that the nodes attempt to connect to in a single attempt; this could make the initial wait time a bit longer, but would be likely to reduce the strain on all the bootnodes by giving nodes the chance to learn about other peers and connect to them instead of all the bootnodes; this would work best if paired with https://github.com/AleoHQ/snarkOS/issues/817\n", "hints_text": "\n", "created_at": "2021-06-17T14:59:02Z", "version": "1.3"}]