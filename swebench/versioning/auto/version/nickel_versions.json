[
    {
        "repo": "nickel-org/nickel.rs",
        "pull_number": 210,
        "instance_id": "nickel-org__nickel.rs-210",
        "issue_numbers": [
            "208"
        ],
        "base_commit": "db6b5294d6f209daefcb41b1c10dd4a9ee46aa7d",
        "patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -23,7 +23,7 @@ plugin = \"*\"\n regex = \"*\"\n rustc-serialize = \"*\"\n log = \"*\"\n-hyper = \"*\"\n+hyper = \"=0.3\"\n groupable = \"*\"\n mustache = \"*\"\n lazy_static = \"*\"\ndiff --git a/src/nickel.rs b/src/nickel.rs\n--- a/src/nickel.rs\n+++ b/src/nickel.rs\n@@ -1,4 +1,3 @@\n-use std::fmt::Display;\n use std::net::ToSocketAddrs;\n use router::{Router, HttpRouter, Matcher};\n use middleware::{MiddlewareStack, Middleware, ErrorHandler};\ndiff --git a/src/server.rs b/src/server.rs\n--- a/src/server.rs\n+++ b/src/server.rs\n@@ -1,7 +1,8 @@\n use std::net::ToSocketAddrs;\n use std::sync::{Arc, RwLock};\n use std::collections::HashMap;\n-use hyper::server::{Request, Response, Handler};\n+use hyper::HttpResult;\n+use hyper::server::{Request, Response, Handler, Listening};\n use hyper::server::Server as HyperServer;\n \n use middleware::MiddlewareStack;\n",
        "test_patch": "diff --git a/src/nickel.rs b/src/nickel.rs\n--- a/src/nickel.rs\n+++ b/src/nickel.rs\n@@ -135,14 +134,21 @@ impl Nickel {\n     /// let mut server = Nickel::new();\n     /// server.listen(\"127.0.0.1:6767\");\n     /// ```\n-    pub fn listen<T: ToSocketAddrs + Display>(mut self, addr: T) {\n+    pub fn listen<T: ToSocketAddrs>(mut self, addr: T) {\n         self.middleware_stack.add_middleware(middleware! {\n             (StatusCode::NotFound, \"File Not Found\")\n         });\n \n-        println!(\"Listening on http://{}\", addr);\n-        println!(\"Ctrl-C to shutdown server\");\n+        let server = Server::new(self.middleware_stack);\n+        let listener = server.serve(addr).unwrap();\n \n-        Server::new(self.middleware_stack).serve(addr);\n+        println!(\"Listening on http://{}\", listener.socket);\n+        println!(\"Ctrl-C to shutdown server\");\n     }\n }\n+\n+#[test]\n+#[should_panic]\n+fn invalid_listen_addr() {\n+    Nickel::new().listen(\"127.0.0.1.6667\");\n+}\ndiff --git a/src/server.rs b/src/server.rs\n--- a/src/server.rs\n+++ b/src/server.rs\n@@ -33,15 +34,9 @@ impl Server {\n         }\n     }\n \n-    pub fn serve<T: ToSocketAddrs>(self, addr: T) {\n+    pub fn serve<T: ToSocketAddrs>(self, addr: T) -> HttpResult<Listening> {\n         let arc = ArcServer(Arc::new(self));\n         let server = HyperServer::http(arc);\n-        let _ = server.listen(addr).unwrap();\n+        server.listen(addr)\n     }\n }\n-\n-#[test]\n-#[should_panic]\n-fn invalid_listen_addr() {\n-    Server::new(MiddlewareStack::new()).serve(\"127.0.0.1.6667\");\n-}\n",
        "problem_statement": "Display trait in Nickel::listen prevents using (addr, port) tuple\nNickel::listen expects a ToSocketAddrs, which is conveniently implemented by (&str, u16). This allows to do something like server.listen((\"localhost\", port))\n\nHowever, requiring Display prevents this tuple from being used there.\n\nIs it possible to drop the Display requirement? As the compiler suggests, \"try using `:?` instead if you are using a format string\".\n\n(I tried implementing Display for the tuple, but apparently I can't do that from my crate.)\n\nAs a workaround, I am currently using\n\n```\nserver.listen(net::SocketAddrV4::new(net::Ipv4Addr::from_str(\"localhost\").unwrap(), port));\n```\n\nBut it's not quite as nice...\n\n",
        "hints_text": "",
        "created_at": "2015-05-06T22:34:49Z",
        "version": "0.3"
    },
    {
        "repo": "nickel-org/nickel.rs",
        "pull_number": 192,
        "instance_id": "nickel-org__nickel.rs-192",
        "issue_numbers": [
            "191"
        ],
        "base_commit": "a4391002f0437f9cc1b3f2cfe43598554f4a7bca",
        "patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -12,6 +12,8 @@ repository = \"https://github.com/nickel-org/nickel.rs\"\n readme = \"README.md\"\n keywords = [\"nickel\", \"server\", \"web\", \"express\"]\n \n+[features]\n+\"nightly\" = [\"hyper/nightly\"]\n \n [dependencies]\n url = \"*\"\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -50,6 +50,15 @@ cargo run --example example\n \n Then try `localhost:6767/user/4711` and `localhost:6767/bar`\n \n+### Note about nightly\n+\n+To build on nightly, you will need to add `--features nightly` to the end of the above commands. Alternatively, if depending on the library you will need to add the following to your `Cargo.toml`.\n+\n+```\n+[dependencies.nickel]\n+version = \"*\"\n+features = [\"nightly\"]\n+```\n \n ##Take a look at the example code\n Here is how sample server in `example.rs` looks like:\ndiff --git a/src/middleware_handler.rs b/src/middleware_handler.rs\n--- a/src/middleware_handler.rs\n+++ b/src/middleware_handler.rs\n@@ -12,7 +12,7 @@\n \n use request::Request;\n use response::Response;\n-use hyper::status::StatusCode;\n+use hyper::status::{StatusCode, StatusClass};\n use std::fmt::Display;\n use hyper::header;\n use hyper::net;\ndiff --git a/src/middleware_handler.rs b/src/middleware_handler.rs\n--- a/src/middleware_handler.rs\n+++ b/src/middleware_handler.rs\n@@ -61,7 +61,13 @@ impl ResponseFinalizer for () {\n impl ResponseFinalizer for json::Json {\n     fn respond<'a>(self, mut res: Response<'a>) -> MiddlewareResult<'a> {\n         maybe_set_type(&mut res, MediaType::Json);\n-        res.send(json::encode(&self).unwrap())\n+        let result = match json::encode(&self) {\n+            Ok(data) => (StatusCode::Ok, data),\n+            Err(e) => (StatusCode::InternalServerError,\n+                       format!(\"Failed to parse JSON: {}\", e))\n+        };\n+\n+        result.respond(res)\n     }\n }\n \ndiff --git a/src/middleware_handler.rs b/src/middleware_handler.rs\n--- a/src/middleware_handler.rs\n+++ b/src/middleware_handler.rs\n@@ -84,41 +90,46 @@ impl<'a, S: Display> ResponseFinalizer for &'a [S] {\n macro_rules! dual_impl {\n     ($view:ty, $alloc:ty, |$s:ident, $res:ident| $b:block) => (\n         impl<'a> ResponseFinalizer for $view {\n+            #[allow(unused_mut)]\n             fn respond<'c>($s, mut $res: Response<'c>) -> MiddlewareResult<'c> $b\n         }\n \n         impl ResponseFinalizer for $alloc {\n+            #[allow(unused_mut)]\n             fn respond<'c>($s, mut $res: Response<'c>) -> MiddlewareResult<'c> $b\n         }\n     )\n }\n \n-dual_impl!(&'a str,\n+dual_impl!(&'static str,\n            String,\n             |self, res| {\n-                maybe_set_type(&mut res, MediaType::Html);\n-\n-                res.set_status(StatusCode::Ok);\n-                res.send(self)\n+                (StatusCode::Ok, self).respond(res)\n             });\n \n-dual_impl!((StatusCode, &'a str),\n+dual_impl!((StatusCode, &'static str),\n            (StatusCode, String),\n             |self, res| {\n                 maybe_set_type(&mut res, MediaType::Html);\n-                let (status, data) = self;\n-\n-                res.set_status(status);\n-                res.send(data)\n+                let (status, message) = self;\n+\n+                match status.class() {\n+                    StatusClass::ClientError\n+                    | StatusClass::ServerError => {\n+                        res.error(status, message)\n+                    },\n+                    _ => {\n+                        res.set_status(status);\n+                        res.send(message)\n+                    }\n+                }\n             });\n \n-dual_impl!((u16, &'a str),\n+dual_impl!((u16, &'static str),\n            (u16, String),\n            |self, res| {\n-                maybe_set_type(&mut res, MediaType::Html);\n-                let (status, data) = self;\n-                res.set_status(StatusCode::from_u16(status));\n-                res.send(data)\n+                let (status, message) = self;\n+                (StatusCode::from_u16(status), message).respond(res)\n             });\n \n // FIXME: Hyper uses traits for headers, so this needs to be a Vec of\n",
        "test_patch": "diff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -4,3 +4,7 @@ sudo: false\n cache:\n   directories:\n       - target\n+\n+script:\n+    - cargo build --features nightly\n+    - cargo test --features nightly\n",
        "problem_statement": "Custom error handler is never called\nI have debugged to discover that a custom error handler is never called!\nI was wondering why my custom 404 handler wasn't return the correct response and digged further to find it's not even be called.\n\n",
        "hints_text": "",
        "created_at": "2015-04-16T14:32:00Z",
        "version": "0.2"
    },
    {
        "repo": "nickel-org/nickel.rs",
        "pull_number": 145,
        "instance_id": "nickel-org__nickel.rs-145",
        "issue_numbers": [
            "144"
        ],
        "base_commit": "7f86e5809af585cc22e6d191375e139df60307ee",
        "patch": "diff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -5,7 +5,7 @@ nickel is supposed to be a simple and lightweight foundation for web application\n \n Some of the features are:\n \n-* Easy handlers: A handler is just a function that takes a `Request` and `ResponseWriter`\n+* Easy handlers: A handler is just a function that takes a `&Request` and `&mut Response`\n * Variables in routes. Just write `my/route/:someid`\n * Easy parameter access: `request.param(\"someid\")`\n * simple wildcard routes: `/some/*/route`\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -47,24 +53,37 @@ Then try `localhost:6767/user/4711` and `localhost:6767/bar`\n Here is how sample server in `example.rs` looks like:\n \n ```rust\n-extern crate serialize;\n+#![feature(core, io)]\n+\n+extern crate \"rustc-serialize\" as rustc_serialize;\n extern crate nickel;\n extern crate http;\n \n-use http::status::NotFound;\n+use http::status::{NotFound, BadRequest};\n use nickel::{\n     Nickel, NickelError, ErrorWithStatusCode, Continue, Halt, Request, Response,\n     QueryString, JsonBody, StaticFilesHandler, MiddlewareResult, HttpRouter\n };\n-use nickel::mimes;\n-use std::io::net::ip::Ipv4Addr;\n+use nickel::mimes::MediaType;\n+use std::old_io::net::ip::Ipv4Addr;\n+use std::collections::BTreeMap;\n+use rustc_serialize::json::{Json, ToJson};\n \n-#[derive(Decodable, Encodable)]\n+#[derive(RustcDecodable, RustcEncodable)]\n struct Person {\n     firstname: String,\n     lastname:  String,\n }\n \n+impl ToJson for Person {\n+    fn to_json(&self) -> Json {\n+        let mut map = BTreeMap::new();\n+        map.insert(\"first_name\".to_string(), self.firstname.to_json());\n+        map.insert(\"last_name\".to_string(), self.lastname.to_json());\n+        Json::Object(map)\n+    }\n+}\n+\n fn main() {\n     let mut server = Nickel::new();\n \ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -81,64 +100,104 @@ fn main() {\n     }\n \n     // middleware is optional and can be registered with `utilize`\n-    server.utilize(logger);\n-\n-    // this will cause json bodies automatically being parsed\n-    server.utilize(Nickel::json_body_parser());\n-\n-    // this will cause the query string to be parsed on each request\n-    server.utilize(Nickel::query_string());\n+    // issue #20178\n+    let logger_handler: fn(&Request, &mut Response) -> MiddlewareResult = logger;\n+    server.utilize(logger_handler);\n \n     let mut router = Nickel::router();\n \n-    fn user_handler(request: &Request, response: &mut Response) {\n-        let text = format!(\"This is user: {}\", request.param(\"userid\"));\n-        response.send(text.as_slice());\n+    fn user_handler(request: &Request, _response: &mut Response) -> String {\n+        format!(\"This is user: {}\", request.param(\"userid\"))\n     }\n \n+    // issue #20178\n+    let uhandler: fn(&Request, &mut Response) -> String = user_handler;\n+\n     // go to http://localhost:6767/user/4711 to see this route in action\n-    router.get(\"/user/:userid\", user_handler);\n+    router.get(\"/user/:userid\", uhandler);\n \n     fn bar_handler(_request: &Request, response: &mut Response) {\n         response.send(\"This is the /bar handler\");\n     }\n \n+    // issue #20178\n+    let bhandler: fn(&Request, &mut Response) = bar_handler;\n+\n     // go to http://localhost:6767/bar to see this route in action\n-    router.get(\"/bar\", bar_handler);\n+    router.get(\"/bar\", bhandler);\n \n     fn simple_wildcard(_request: &Request, response: &mut Response) {\n         response.send(\"This matches /some/crazy/route but not /some/super/crazy/route\");\n     }\n \n+    // issue #20178\n+    let shandler: fn(&Request, &mut Response) = simple_wildcard;\n+\n     // go to http://localhost:6767/some/crazy/route to see this route in action\n-    router.get(\"/some/*/route\", simple_wildcard);\n+    router.get(\"/some/*/route\", shandler);\n \n-    fn double_wildcard(_request: &Request, response: &mut Response) {\n-        response.send(\"This matches /a/crazy/route and also /a/super/crazy/route\");\n+    fn double_wildcard(_request: &Request, _response: &mut Response) -> &'static str {\n+        \"This matches /a/crazy/route and also /a/super/crazy/route\"\n     }\n \n+    // issue #20178\n+    let dhandler: fn(&Request, &mut Response) -> &'static str = double_wildcard;\n+\n     // go to http://localhost:6767/a/nice/route or http://localhost:6767/a/super/nice/route to see this route in action\n-    router.get(\"/a/**/route\", double_wildcard);\n+    router.get(\"/a/**/route\", dhandler);\n \n     // try it with curl\n     // curl 'http://localhost:6767/a/post/request' -H 'Content-Type: application/json;charset=UTF-8'  --data-binary $'{ \"firstname\": \"John\",\"lastname\": \"Connor\" }'\n-    fn post_handler(request: &Request, response: &mut Response) {\n-\n+    fn post_handler(request: &mut Request, _response: &mut Response) -> String {\n         let person = request.json_as::<Person>().unwrap();\n-        let text = format!(\"Hello {} {}\", person.firstname, person.lastname);\n-        response.send(text.as_slice());\n+        format!(\"Hello {} {}\", person.firstname, person.lastname)\n     }\n \n+    // issue #20178\n+    let phandler: fn(&mut Request, &mut Response) -> String = post_handler;\n+\n     // go to http://localhost:6767/a/post/request to see this route in action\n-    router.post(\"/a/post/request\", post_handler);\n+    router.post(\"/a/post/request\", phandler);\n+\n+    fn json_response(_request: &Request, _response: &mut Response) -> Json {\n+        let person = Person {\n+            firstname: \"Pea\".to_string(),\n+            lastname: \"Nut\".to_string()\n+        };\n+        person.to_json()\n+    }\n+\n+    // issue #20178\n+    let jresponse: fn(&Request, &mut Response) -> Json = json_response;\n+\n+    // go to http://localhost:6767/api/person/1 to see this route in action\n+    router.get(\"/api/person/1\", jresponse);\n \n     // try calling http://localhost:6767/query?foo=bar\n-    fn query_handler(request: &Request, response: &mut Response) {\n-        let text = format!(\"Your foo values in the query string are: {}\", request.query(\"foo\", \"This is only a default value!\"));\n-        response.send(text.as_slice());\n+    fn query_handler(request: &mut Request, _response: &mut Response) -> String {\n+        format!(\"Your foo values in the query string are: {:?}\", *request.query(\"foo\", \"This is only a default value!\"))\n     }\n \n-    router.get(\"/query\", query_handler);\n+    // issue #20178\n+    let qhandler: fn(&mut Request, &mut Response) -> String = query_handler;\n+\n+    router.get(\"/query\", qhandler);\n+\n+    // try calling http://localhost:6767/strict?state=valid\n+    // then try calling http://localhost:6767/strict?state=invalid\n+    fn strict_handler(request: &mut Request, response: &mut Response) -> MiddlewareResult {\n+        if request.query(\"state\", \"invalid\")[0].as_slice() != \"valid\" {\n+            Err(NickelError::new(\"Error Parsing JSON\", ErrorWithStatusCode(BadRequest)))\n+        } else {\n+            response.send(\"Congratulations on conforming!\");\n+            Ok(Halt)\n+        }\n+    }\n+\n+    // issue #20178\n+    let sthandler: fn(&mut Request, &mut Response) -> MiddlewareResult = strict_handler;\n+\n+    router.get(\"/strict\", sthandler);\n \n     server.utilize(router);\n \ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -149,7 +208,7 @@ fn main() {\n     fn custom_404(err: &NickelError, _req: &Request, response: &mut Response) -> MiddlewareResult {\n         match err.kind {\n             ErrorWithStatusCode(NotFound) => {\n-                response.content_type(mimes::Html)\n+                response.content_type(MediaType::Html)\n                         .status_code(NotFound)\n                         .send(\"<h1>Call the police!<h1>\");\n                 Ok(Halt)\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -158,7 +217,10 @@ fn main() {\n         }\n     }\n \n-    server.handle_error(custom_404);\n+    // issue #20178\n+    let custom_handler: fn(&NickelError, &Request, &mut Response) -> MiddlewareResult = custom_404;\n+\n+    server.handle_error(custom_handler);\n \n     server.listen(Ipv4Addr(127, 0, 0, 1), 6767);\n }\n",
        "test_patch": "diff --git a/Makefile /dev/null\n--- a/Makefile\n+++ /dev/null\n@@ -1,23 +0,0 @@\n-LIBS=-L target/deps\n-\n-.PHONY: deps examples\n-\n-all: deps examples\n-\n-deps:\n-\tcargo build -v\n-\n-examples: deps\n-\tcargo test\n-\n-doc: deps\n-\trustdoc $(LIBS) src/lib.rs\n-\n-clean:\n-\tcargo clean\n-\n-run: \n-\t./target/examples/example\n-\n-buildrun: examples run\n-\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -31,13 +31,19 @@ git clone --recursive https://github.com/nickel-org/nickel.git\n ##Build nickel\n \n ```shell\n-make all\n+cargo build --release\n+```\n+\n+##Run the tests\n+\n+```shell\n+cargo test\n ```\n \n ##Run the example\n \n ```shell\n-make run\n+cargo run --example example\n ```\n \n Then try `localhost:6767/user/4711` and `localhost:6767/bar`\n",
        "problem_statement": "make doc fails\nWith nightly:\n\n``` shell\n$ make doc\n...\nrustdoc -L target/deps src/lib.rs\nsrc/lib.rs:27:1: 27:18 error: multiple matching crates for `log`\nsrc/lib.rs:27 extern crate log;\n              ^~~~~~~~~~~~~~~~~\nnote: candidates:\nnote: path: /usr/local/lib/rustlib/x86_64-unknown-linux-gnu/lib/liblog-4e7c5e5c.so\nnote: path: /usr/local/lib/rustlib/x86_64-unknown-linux-gnu/lib/liblog-4e7c5e5c.rlib\nnote: crate name: log\nnote: path: /home/rgs/src/rust/nickel.rs/target/deps/liblog-6ccd07f1f8244a62.rlib\nnote: crate name: log\nsrc/lib.rs:27:1: 27:18 error: can't find crate for `log`\nsrc/lib.rs:27 extern crate log;\n              ^~~~~~~~~~~~~~~~~\nerror: aborting due to 2 previous errors\nthread '<unnamed>' panicked at 'Box<Any>', /home/rustbuild/src/rust-buildbot/slave/nightly-dist-rustc-linux/build/src/libsyntax/diagnostic.rs:151\nthread '<unnamed>' panicked at 'called `Result::unwrap()` on an `Err` value: \"rustc failed\"', /home/rustbuild/src/rust-buildbot/slave/nightly-dist-rustc-linux/build/src/libcore/result.rs:743\nthread '<main>' panicked at 'called `Option::unwrap()` on a `None` value', /home/rustbuild/src/rust-buildbot/slave/nightly-dist-rustc-linux/build/src/libcore/option.rs:362\nMakefile:14: recipe for target 'doc' failed\nmake: *** [doc] Error 101\n```\n\nIdeas?\n\n",
        "hints_text": "`cargo clean`?\n\nStill fails for me - works for you?\n",
        "created_at": "2015-02-08T18:15:39Z",
        "version": "0.1"
    },
    {
        "repo": "nickel-org/nickel.rs",
        "pull_number": 377,
        "instance_id": "nickel-org__nickel.rs-377",
        "issue_numbers": [
            "376"
        ],
        "base_commit": "b77e4ca9a5544a742ec2fb894b85b6b736239656",
        "patch": "diff --git a/src/urlencoded.rs b/src/urlencoded.rs\n--- a/src/urlencoded.rs\n+++ b/src/urlencoded.rs\n@@ -27,6 +27,11 @@ impl Params {\n     pub fn all(&self, key: &str) -> Option<&[String]> {\n         self.0.get(key).map(|v| &**v)\n     }\n+\n+    /// Retrieve the entire query map.\n+    pub fn map(&self) -> &HashMap<String, Vec<String>> {\n+        &self.0\n+    }\n }\n \n pub fn parse(encoded_string : &str) -> Params {\n",
        "test_patch": "diff --git a/src/urlencoded.rs b/src/urlencoded.rs\n--- a/src/urlencoded.rs\n+++ b/src/urlencoded.rs\n@@ -58,12 +63,24 @@ fn parses_encoded_string_with_duplicate_keys() {\n         store.all(\"message\"),\n         Some(&[\"hello\".to_string(), \"world\".to_string()][..])\n     );\n+\n+    let map = store.map();\n+    assert_eq!(map.len(), 2);\n+    assert_eq!(map.get(\"foo\"), Some(&vec![\"bar\".to_string()]));\n+    assert_eq!(\n+        map.get(\"message\"),\n+        Some(&vec![\"hello\".to_string(), \"world\".to_string()])\n+    );\n }\n \n #[test]\n fn parses_urlencoded_characters() {\n     let store = parse(\"message=hello%20world\");\n     assert_eq!(store.get(\"message\"), Some(\"hello world\"));\n+\n+    let map = store.map();\n+    assert_eq!(map.len(), 1);\n+    assert_eq!(map.get(\"message\"), Some(&vec![\"hello world\".to_string()]));\n }\n \n #[test]\n",
        "problem_statement": "Expose a way to iterate over query params\nI don't know what query parameters my endpoint has but I want to package them up and forward them to something that does. I don't want to pass nickel-specific types (`Request` or `Query`) to that thing.\n\n",
        "hints_text": "",
        "created_at": "2016-08-12T21:31:35Z",
        "version": "0.8"
    },
    {
        "repo": "nickel-org/nickel.rs",
        "pull_number": 171,
        "instance_id": "nickel-org__nickel.rs-171",
        "issue_numbers": [
            "101"
        ],
        "base_commit": "2c098b0403c17de507d3bd40779c1cad452da38b",
        "patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -18,12 +18,12 @@ time = \"*\"\n typemap = \"*\"\n plugin = \"*\"\n regex = \"*\"\n-regex_macros = \"*\"\n rustc-serialize = \"*\"\n log = \"*\"\n hyper = \"*\"\n groupable = \"*\"\n mustache = \"*\"\n+lazy_static = \"*\"\n \n [[example]]\n \ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -55,16 +55,17 @@ Here is how sample server in `example.rs` looks like:\n ```rust\n extern crate rustc_serialize;\n extern crate nickel;\n+extern crate regex;\n #[macro_use] extern crate nickel_macros;\n \n+use std::collections::BTreeMap;\n+use std::io::Write;\n use nickel::status::StatusCode::{self, NotFound, BadRequest};\n use nickel::{\n     Nickel, NickelError, Continue, Halt, Request,\n     QueryString, JsonBody, StaticFilesHandler, HttpRouter, Action\n };\n-\n-use std::collections::BTreeMap;\n-use std::io::Write;\n+use regex::Regex;\n use rustc_serialize::json::{Json, ToJson};\n \n #[derive(RustcDecodable, RustcEncodable)]\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -104,6 +105,13 @@ fn main() {\n     // go to http://localhost:6767/bar to see this route in action\n     router.get(\"/bar\", middleware!(\"This is the /bar handler\"));\n \n+    let hello_regex = Regex::new(\"/hello/(?P<name>[a-zA-Z]+)\").unwrap();\n+\n+    // go to http://localhost:6767/hello/moomah to see this route in action\n+    router.get(hello_regex, middleware! { |request|\n+        format!(\"Hello {}\", request.param(\"name\"))\n+    });\n+\n     // go to http://localhost:6767/some/crazy/route to see this route in action\n     router.get(\"/some/*/route\", middleware! {\n         \"This matches /some/crazy/route but not /some/super/crazy/route\"\ndiff --git a/examples/example.rs b/examples/example.rs\n--- a/examples/example.rs\n+++ b/examples/example.rs\n@@ -1,15 +1,16 @@\n extern crate rustc_serialize;\n extern crate nickel;\n+extern crate regex;\n #[macro_use] extern crate nickel_macros;\n \n+use std::collections::BTreeMap;\n+use std::io::Write;\n use nickel::status::StatusCode::{self, NotFound, BadRequest};\n use nickel::{\n     Nickel, NickelError, Continue, Halt, Request,\n     QueryString, JsonBody, StaticFilesHandler, HttpRouter, Action\n };\n-\n-use std::collections::BTreeMap;\n-use std::io::Write;\n+use regex::Regex;\n use rustc_serialize::json::{Json, ToJson};\n \n #[derive(RustcDecodable, RustcEncodable)]\ndiff --git a/examples/example.rs b/examples/example.rs\n--- a/examples/example.rs\n+++ b/examples/example.rs\n@@ -49,6 +50,13 @@ fn main() {\n     // go to http://localhost:6767/bar to see this route in action\n     router.get(\"/bar\", middleware!(\"This is the /bar handler\"));\n \n+    let hello_regex = Regex::new(\"/hello/(?P<name>[a-zA-Z]+)\").unwrap();\n+\n+    // go to http://localhost:6767/hello/moomah to see this route in action\n+    router.get(hello_regex, middleware! { |request|\n+        format!(\"Hello {}\", request.param(\"name\"))\n+    });\n+\n     // go to http://localhost:6767/some/crazy/route to see this route in action\n     router.get(\"/some/*/route\", middleware! {\n         \"This matches /some/crazy/route but not /some/super/crazy/route\"\ndiff --git a/examples/macro_example.rs b/examples/macro_example.rs\n--- a/examples/macro_example.rs\n+++ b/examples/macro_example.rs\n@@ -1,14 +1,16 @@\n extern crate url;\n extern crate nickel;\n+extern crate regex;\n extern crate rustc_serialize;\n #[macro_use] extern crate nickel_macros;\n \n+use std::io::Write;\n use nickel::status::StatusCode::{self, NotFound};\n use nickel::{\n     Nickel, NickelError, Continue, Halt, Request, Response,\n     QueryString, JsonBody, StaticFilesHandler, MiddlewareResult, HttpRouter, Action\n };\n-use std::io::Write;\n+use regex::Regex;\n \n #[derive(RustcDecodable, RustcEncodable)]\n struct Person {\ndiff --git a/examples/macro_example.rs b/examples/macro_example.rs\n--- a/examples/macro_example.rs\n+++ b/examples/macro_example.rs\n@@ -43,6 +45,8 @@ fn main() {\n     // go to http://localhost:6767/thoughtram_logo_brain.png to see static file serving in action\n     server.utilize(StaticFilesHandler::new(\"examples/assets/\"));\n \n+    let hello_regex = Regex::new(\"/hello/(?P<name>[a-zA-Z]+)\").unwrap();\n+\n     // The return type for a route can be anything that implements `ResponseFinalizer`\n     server.utilize(router!(\n         // go to http://localhost:6767/user/4711 to see this route in action\ndiff --git a/examples/macro_example.rs b/examples/macro_example.rs\n--- a/examples/macro_example.rs\n+++ b/examples/macro_example.rs\n@@ -63,6 +67,11 @@ fn main() {\n             (200u16, \"This is the /bar handler\")\n         }\n \n+        // go to http://localhost:6767/hello/moomah to see this route in action\n+        get hello_regex => |request, response| {\n+            format!(\"Hello {}\", request.param(\"name\"))\n+        }\n+\n         // FIXME\n         // // go to http://localhost:6767/redirect to see this route in action\n         // get \"/redirect\" => |request, response| {\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1,7 +1,5 @@\n #![crate_name = \"nickel\"]\n #![crate_type = \"rlib\"]\n-#![feature(plugin)]\n-#![plugin(regex_macros)]\n \n //!Nickel is supposed to be a simple and lightweight foundation for web applications written in Rust. Its API is inspired by the popular express framework for JavaScript.\n //!\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -25,6 +23,7 @@ extern crate mustache;\n extern crate groupable;\n \n #[macro_use] extern crate log;\n+#[macro_use] extern crate lazy_static;\n #[macro_use] extern crate nickel_macros;\n \n pub use nickel::Nickel;\ndiff --git a/src/nickel.rs b/src/nickel.rs\n--- a/src/nickel.rs\n+++ b/src/nickel.rs\n@@ -1,6 +1,6 @@\n use std::fmt::Display;\n use std::net::ToSocketAddrs;\n-use router::{Router, HttpRouter};\n+use router::{Router, HttpRouter, IntoMatcher};\n use middleware::{MiddlewareStack, Middleware, ErrorHandler};\n use server::Server;\n use hyper::method::Method;\ndiff --git a/src/nickel.rs b/src/nickel.rs\n--- a/src/nickel.rs\n+++ b/src/nickel.rs\n@@ -21,10 +21,9 @@ pub struct Nickel{\n }\n \n impl HttpRouter for Nickel {\n-    fn add_route<H: Middleware>(&mut self, method: Method, uri: &str, handler: H) {\n+    fn add_route<M: IntoMatcher, H: Middleware>(&mut self, method: Method, matcher: M, handler: H) {\n         let mut router = Router::new();\n-        // FIXME: Inference failure in nightly 22/10/2014\n-        router.add_route::<H>(method, uri, handler);\n+        router.add_route(method, matcher, handler);\n         self.utilize(router);\n     }\n }\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -1,5 +1,6 @@\n use hyper::method::Method;\n use middleware::Middleware;\n+use router::IntoMatcher;\n \n pub trait HttpRouter {\n     /// Registers a handler to be used for a specified method.\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -10,10 +11,12 @@ pub trait HttpRouter {\n     /// ```{rust}\n     /// extern crate hyper;\n     /// extern crate nickel;\n+    /// extern crate regex;\n     /// #[macro_use] extern crate nickel_macros;\n     ///\n     /// use nickel::{Nickel, HttpRouter};\n     /// use hyper::method::Method::{Get, Post, Put, Delete};\n+    /// use regex::Regex;\n     ///\n     /// fn main() {\n     ///     let read_handler = middleware! { \"Get request! \"};\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -27,9 +30,13 @@ pub trait HttpRouter {\n     ///     server.add_route(Post, \"/foo\", modify_handler);\n     ///     server.add_route(Put, \"/foo\", modify_handler);\n     ///     server.add_route(Delete, \"/foo\", modify_handler);\n+    ///\n+    ///     // Regex path\n+    ///     let regex = Regex::new(\"/(foo|bar)\").unwrap();\n+    ///     server.add_route(Get, regex, read_handler);\n     /// }\n     /// ```\n-    fn add_route<H: Middleware>(&mut self, Method, &str, H);\n+    fn add_route<M: IntoMatcher, H: Middleware>(&mut self, Method, M, H);\n \n     /// Registers a handler to be used for a specific GET request.\n     /// Handlers are assigned to paths and paths are allowed to contain\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -71,7 +78,6 @@ pub trait HttpRouter {\n     /// # router! macro example\n     ///\n     /// ```{rust}\n-    /// #![feature(plugin)]\n     /// #[macro_use] extern crate nickel_macros;\n     /// extern crate nickel;\n     /// use nickel::Nickel;\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -102,8 +108,8 @@ pub trait HttpRouter {\n     ///     server.utilize(router);\n     /// }\n     /// ```\n-    fn get<H: Middleware>(&mut self, uri: &str, handler: H) {\n-        self.add_route(Method::Get, uri, handler);\n+    fn get<M: IntoMatcher, H: Middleware>(&mut self, matcher: M, handler: H) {\n+        self.add_route(Method::Get, matcher, handler);\n     }\n \n     /// Registers a handler to be used for a specific POST request.\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -125,8 +131,8 @@ pub trait HttpRouter {\n     /// });\n     /// # }\n     /// ```\n-    fn post<H: Middleware>(&mut self, uri: &str, handler: H) {\n-        self.add_route(Method::Post, uri, handler);\n+    fn post<M: IntoMatcher, H: Middleware>(&mut self, matcher: M, handler: H) {\n+        self.add_route(Method::Post, matcher, handler);\n     }\n \n     /// Registers a handler to be used for a specific PUT request.\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -148,8 +154,8 @@ pub trait HttpRouter {\n     /// });\n     /// # }\n     /// ```\n-    fn put<H: Middleware>(&mut self, uri: &str, handler: H) {\n-        self.add_route(Method::Put, uri, handler);\n+    fn put<M: IntoMatcher, H: Middleware>(&mut self, matcher: M, handler: H) {\n+        self.add_route(Method::Put, matcher, handler);\n     }\n \n     /// Registers a handler to be used for a specific DELETE request.\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -170,7 +176,7 @@ pub trait HttpRouter {\n     /// });\n     /// # }\n     /// ```\n-    fn delete<H: Middleware>(&mut self, uri: &str, handler: H) {\n-        self.add_route(Method::Delete, uri, handler);\n+    fn delete<M: IntoMatcher, H: Middleware>(&mut self, matcher: M, handler: H) {\n+        self.add_route(Method::Delete, matcher, handler);\n     }\n }\ndiff --git /dev/null b/src/router/into_matcher.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/router/into_matcher.rs\n@@ -0,0 +1,63 @@\n+use super::Matcher;\n+use regex::{Regex, Captures};\n+\n+pub trait IntoMatcher {\n+    fn into_matcher(self) -> Matcher;\n+}\n+\n+impl IntoMatcher for Regex {\n+    fn into_matcher(self) -> Matcher {\n+        let path = self.as_str().to_string();\n+        Matcher::new(path, self)\n+    }\n+}\n+\n+impl<'a> IntoMatcher for &'a str {\n+    fn into_matcher(self) -> Matcher {\n+        self.to_string().into_matcher()\n+    }\n+}\n+\n+lazy_static! {\n+    static ref REGEX_VAR_SEQ: Regex = Regex::new(r\":([,a-zA-Z0-9_-]*)\").unwrap();\n+}\n+\n+pub static FORMAT_PARAM:      &'static str = \"format\";\n+// FIXME: Once const fn lands this could be defined in terms of the above\n+static FORMAT_VAR:            &'static str = \":format\";\n+static VAR_SEQ:               &'static str = \"[,a-zA-Z0-9_-]*\";\n+static VAR_SEQ_WITH_SLASH:    &'static str = \"[,/a-zA-Z0-9_-]*\";\n+// matches request params (e.g. ?foo=true&bar=false)\n+static REGEX_PARAM_SEQ:       &'static str = \"(\\\\?[a-zA-Z0-9%_=&-]*)?\";\n+\n+impl IntoMatcher for String {\n+    fn into_matcher(self) -> Matcher {\n+        let with_format = if self.contains(FORMAT_VAR) {\n+            self\n+        } else {\n+            format!(\"{}(\\\\.{})?\", self, FORMAT_VAR)\n+        };\n+\n+        // First mark all double wildcards for replacement. We can't directly\n+        // replace them since the replacement does contain the * symbol as well,\n+        // which would get overwritten with the next replace call\n+        let with_placeholder = with_format.replace(\"**\", \"___DOUBLE_WILDCARD___\");\n+\n+        // Then replace the regular wildcard symbols (*) with the appropriate regex\n+        let star_replaced = with_placeholder.replace(\"*\", VAR_SEQ);\n+\n+        // Now replace the previously marked double wild cards (**)\n+        let wildcarded = star_replaced.replace(\"___DOUBLE_WILDCARD___\", VAR_SEQ_WITH_SLASH);\n+\n+        // Add a named capture for each :(variable) symbol\n+        let named_captures = REGEX_VAR_SEQ.replace_all(&wildcarded, |captures: &Captures| {\n+            // There should only ever be one match (after subgroup 0)\n+            let c = captures.iter().skip(1).next().unwrap();\n+            format!(\"(?P<{}>[,a-zA-Z0-9%_-]*)\", c.unwrap())\n+        });\n+\n+        let line_regex = format!(\"^{}{}$\", named_captures, REGEX_PARAM_SEQ);\n+        let regex = Regex::new(&line_regex).unwrap();\n+        Matcher::new(with_format, regex)\n+    }\n+}\ndiff --git /dev/null b/src/router/matcher.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/router/matcher.rs\n@@ -0,0 +1,29 @@\n+use std::borrow::Cow;\n+use std::ops::Deref;\n+use regex::Regex;\n+\n+pub struct Matcher {\n+    pub path: Cow<'static, str>,\n+    pub regex: Regex\n+}\n+\n+impl Matcher {\n+    pub fn new<P: Into<Cow<'static, str>>>(path: P, regex: Regex) -> Matcher {\n+        Matcher {\n+            path: path.into(),\n+            regex: regex\n+        }\n+    }\n+\n+    pub fn path(&self) -> &str {\n+        &self.path\n+    }\n+}\n+\n+impl Deref for Matcher {\n+    type Target = Regex;\n+\n+    fn deref(&self) -> &Regex {\n+        &self.regex\n+    }\n+}\ndiff --git a/src/router/mod.rs b/src/router/mod.rs\n--- a/src/router/mod.rs\n+++ b/src/router/mod.rs\n@@ -1,53 +1,10 @@\n //!Router asigns handlers to paths and resolves them per request\n pub use self::http_router::HttpRouter;\n pub use self::router::{Router, Route, RouteResult};\n-pub mod http_router;\n+pub use self::matcher::Matcher;\n+pub use self::into_matcher::{IntoMatcher, FORMAT_PARAM};\n \n+pub mod http_router;\n pub mod router;\n-\n-/// The path_utils collects some small helper methods that operate on the path\n-mod path_utils {\n-    use regex::Regex;\n-    use std::collections::HashMap;\n-\n-    // matches named variables (e.g. :userid)\n-    static REGEX_VAR_SEQ: Regex                 = regex!(r\":([,a-zA-Z0-9_-]*)\");\n-    static VAR_SEQ:&'static str                 = \"[,a-zA-Z0-9_-]*\";\n-    static VAR_SEQ_WITH_SLASH:&'static str      = \"[,/a-zA-Z0-9_-]*\";\n-    static VAR_SEQ_WITH_CAPTURE:&'static str    = \"([,a-zA-Z0-9%_-]*)\";\n-    // matches request params (e.g. ?foo=true&bar=false)\n-    static REGEX_PARAM_SEQ:&'static str         = \"(\\\\?[a-zA-Z0-9%_=&-]*)?\";\n-    static REGEX_START:&'static str             = \"^\";\n-    static REGEX_END:&'static str               = \"$\";\n-    pub fn create_regex (route_path: &str) -> Regex {\n-        let updated_path =\n-            route_path.to_string()\n-                      // first mark all double wildcards for replacement.\n-                      // We can't directly replace them since the replacement\n-                      // does contain the * symbol as well, which would get\n-                      // overwritten with the next replace call\n-                      .replace(\"**\", \"___DOUBLE_WILDCARD___\")\n-                      // then replace the regular wildcard symbols (*) with the\n-                      // appropriate regex\n-                      .replace(\"*\", VAR_SEQ)\n-                      // now replace the previously marked double wild cards (**)\n-                      .replace(\"___DOUBLE_WILDCARD___\", VAR_SEQ_WITH_SLASH);\n-\n-        // then replace the variable symbols (:variable) with the appropriate regex\n-        let r2 = REGEX_VAR_SEQ.replace_all(&*updated_path, VAR_SEQ_WITH_CAPTURE);\n-        let resultv = vec![REGEX_START,\n-                           &*r2,\n-                           REGEX_PARAM_SEQ,\n-                           REGEX_END];\n-\n-        let result: String = resultv.into_iter().collect();\n-        Regex::new(&*result).ok().unwrap()\n-    }\n-\n-    pub fn get_variable_info (route_path: &str) -> HashMap<String, usize> {\n-        REGEX_VAR_SEQ.captures_iter(route_path)\n-                     .enumerate()\n-                     .filter_map(|(i, matched)| matched.at(1).map(|m| (m.to_string(), i)))\n-                     .collect()\n-    }\n-}\n+mod matcher;\n+mod into_matcher;\ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -1,23 +1,19 @@\n use middleware::{Middleware, Continue, MiddlewareResult};\n-use super::path_utils;\n use hyper::uri::RequestUri::AbsolutePath;\n use request::Request;\n use response::Response;\n use router::HttpRouter;\n use hyper::method::Method;\n use hyper::status::StatusCode;\n-use regex::Regex;\n-use std::collections::HashMap;\n+use router::{IntoMatcher, Matcher, FORMAT_PARAM};\n \n /// A Route is the basic data structure that stores both the path\n /// and the handler that gets executed for the route.\n /// The path can contain variable pattern such as `user/:userid/invoices`\n pub struct Route {\n-    pub path: String,\n     pub method: Method,\n     pub handler: Box<Middleware + Send + Sync + 'static>,\n-    pub variables: HashMap<String, usize>,\n-    matcher: Regex\n+    matcher: Matcher\n }\n \n /// A RouteResult is what the router returns when `match_route` is called.\ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -26,13 +22,20 @@ pub struct Route {\n /// evaluated string\n pub struct RouteResult<'a> {\n     pub route: &'a Route,\n-    params: Vec<String>\n+    params: Vec<(String, String)>\n }\n \n impl<'a> RouteResult<'a> {\n     pub fn param(&self, key: &str) -> &str {\n-        let idx = self.route.variables.get(key).unwrap();\n-        &*self.params[*idx]\n+        for &(ref k, ref v) in &self.params {\n+            if k == &key {\n+                return &v[..]\n+            }\n+        }\n+\n+        // FIXME: should have a default format\n+        if key == FORMAT_PARAM { return \"\" }\n+        panic!(\"unknown param: {}\", key)\n     }\n }\n \ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -43,56 +46,50 @@ pub struct Router {\n     routes: Vec<Route>,\n }\n \n-impl<'a> Router {\n+impl Router {\n     pub fn new () -> Router {\n         Router {\n             routes: Vec::new()\n         }\n     }\n \n-    pub fn match_route(&'a self, method: &Method, path: &str) -> Option<RouteResult<'a>> {\n+    pub fn match_route<'a>(&'a self, method: &Method, path: &str) -> Option<RouteResult<'a>> {\n+        // Strip off the querystring when matching a route\n+        let path = path.splitn(1, '?').next().unwrap();\n+\n         self.routes\n             .iter()\n             .find(|item| item.method == *method && item.matcher.is_match(path))\n-            .map(|route| {\n-                let vec = match route.matcher.captures(path) {\n-                    Some(captures) => {\n-                        (0..route.variables.len())\n-                            .filter_map(|pos| {\n-                                captures.at(pos + 1).map(|c| c.to_string())\n-                            })\n-                            .collect()\n-                    },\n-                    None => vec![],\n-                };\n+            .map(|route|\n                 RouteResult {\n-                    route: route,\n-                    params: vec\n+                    params: extract_params(route, path),\n+                    route: route\n                 }\n-            })\n+            )\n     }\n }\n \n-impl HttpRouter for Router {\n-    fn add_route<H: Middleware>(&mut self, method: Method, path: &str, handler: H) {\n-        static FORMAT_VAR: &'static str = \":format\";\n-\n-        let with_format = if path.contains(FORMAT_VAR) {\n-            path.to_string()\n-        } else {\n-            format!(\"{}(\\\\.{})?\", path, FORMAT_VAR)\n-        };\n-\n-        let matcher = path_utils::create_regex(&with_format);\n-        let variable_infos = path_utils::get_variable_info(&with_format);\n+fn extract_params(route: &Route, path: &str) -> Vec<(String, String)> {\n+    match route.matcher.captures(path) {\n+        Some(captures) => {\n+            captures.iter_named()\n+                    .filter_map(|(name, subcap)| {\n+                        subcap.map(|cap| (name.to_string(), cap.to_string()))\n+                    })\n+                    .collect()\n+        }\n+        None => vec![]\n+    }\n+}\n \n+impl HttpRouter for Router {\n+    fn add_route<M: IntoMatcher, H: Middleware>(&mut self, method: Method, matcher: M, handler: H) {\n         let route = Route {\n-            path: with_format,\n+            matcher: matcher.into_matcher(),\n             method: method,\n-            matcher: matcher,\n             handler: Box::new(handler),\n-            variables: variable_infos\n         };\n+\n         self.routes.push(route);\n     }\n }\ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -105,7 +102,7 @@ impl Middleware for Router {\n             AbsolutePath(ref url) => self.match_route(&req.origin.method, &**url),\n             _ => None\n         };\n-        debug!(\"route_result.route.path: {:?}\", route_result.as_ref().map(|r| &*r.route.path));\n+        debug!(\"route_result.route.path: {:?}\", route_result.as_ref().map(|r| r.route.matcher.path()));\n \n         match route_result {\n             Some(route_result) => {\ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -192,16 +188,8 @@ fn can_match_var_routes () {\n     route_store.add_route(Method::Get, \"/file/:format/:file\", handler);\n \n     let route_result = route_store.match_route(&Method::Get, \"/foo/4711\").unwrap();\n-    let route = route_result.route;\n-\n     assert_eq!(route_result.param(\"userid\"), \"4711\");\n \n-    // assert the route has identified the variable\n-    assert_eq!(route.variables.len(), 2);\n-    assert_eq!(route.variables[\"userid\"], 0);\n-    // routes have an implicit format variable\n-    assert_eq!(route.variables[\"format\"], 1);\n-\n     let route_result = route_store.match_route(&Method::Get, \"/bar/4711\");\n     assert!(route_result.is_none());\n \ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -228,7 +216,7 @@ fn can_match_var_routes () {\n \n     let route_result = route_result.unwrap();\n     assert_eq!(route_result.param(\"userid\"), \"John%20Doe\");\n-    assert_eq!(route_result.param(\"format\"), \".json\");\n+    assert_eq!(route_result.param(\"format\"), \"json\");\n \n     // ensure format works with queries\n     let route_result = route_store.match_route(&Method::Get,\ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -238,7 +226,13 @@ fn can_match_var_routes () {\n     let route_result = route_result.unwrap();\n     // NOTE: `.param` doesn't cover query params currently\n     assert_eq!(route_result.param(\"userid\"), \"5490,1234\");\n-    assert_eq!(route_result.param(\"format\"), \".csv\");\n+    assert_eq!(route_result.param(\"format\"), \"csv\");\n+\n+    // ensure format works with no format\n+    let route_result = route_store.match_route(&Method::Get,\n+                                               \"/foo/5490,1234?foo=true&bar=false\").unwrap();\n+\n+    assert_eq!(route_result.param(\"format\"), \"\");\n \n     // ensure format works if defined by user\n     let route_result = route_store.match_route(&Method::Get, \"/file/markdown/something?foo=true\");\n",
        "test_patch": "diff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -119,41 +116,42 @@ impl Middleware for Router {\n     }\n }\n \n-#[test]\n-fn creates_map_with_var_variable_infos () {\n-    let map = path_utils::get_variable_info(\"foo/:uid/bar/:groupid\");\n-\n-    assert_eq!(map.len(), 2);\n-    assert_eq!(map[\"uid\"], 0);\n-    assert_eq!(map[\"groupid\"], 1);\n-}\n-\n #[test]\n fn creates_regex_with_captures () {\n-    let regex = path_utils::create_regex(\"foo/:uid/bar/:groupid\");\n-    let caps = regex.captures(\"foo/4711/bar/5490\").unwrap();\n+    let matcher = \"foo/:uid/bar/:groupid\".into_matcher();\n+    let caps = matcher.captures(\"foo/4711/bar/5490\").unwrap();\n \n+    assert_eq!(matcher.path(), \"foo/:uid/bar/:groupid(\\\\.:format)?\");\n     assert_eq!(caps.at(1).unwrap(), \"4711\");\n     assert_eq!(caps.at(2).unwrap(), \"5490\");\n \n-    let regex = path_utils::create_regex(\"foo/*/:uid/bar/:groupid\");\n-    let caps = regex.captures(\"foo/test/4711/bar/5490\").unwrap();\n+    let matcher = \"foo/*/:uid/bar/:groupid\".into_matcher();\n+    let caps = matcher.captures(\"foo/test/4711/bar/5490\").unwrap();\n \n+    assert_eq!(matcher.path(), \"foo/*/:uid/bar/:groupid(\\\\.:format)?\");\n     assert_eq!(caps.at(1).unwrap(), \"4711\");\n     assert_eq!(caps.at(2).unwrap(), \"5490\");\n \n-    let regex = path_utils::create_regex(\"foo/**/:uid/bar/:groupid\");\n-    let caps = regex.captures(\"foo/test/another/4711/bar/5490\").unwrap();\n+    let matcher = \"foo/**/:uid/bar/:groupid\".into_matcher();\n+    let caps = matcher.captures(\"foo/test/another/4711/bar/5490\").unwrap();\n \n+    assert_eq!(matcher.path(), \"foo/**/:uid/bar/:groupid(\\\\.:format)?\");\n     assert_eq!(caps.at(1).unwrap(), \"4711\");\n     assert_eq!(caps.at(2).unwrap(), \"5490\");\n+\n+    let matcher = \"foo/**/:format/bar/:groupid\".into_matcher();\n+    let caps = matcher.captures(\"foo/test/another/4711/bar/5490\").unwrap();\n+\n+    assert_eq!(matcher.path(), \"foo/**/:format/bar/:groupid\");\n+    assert_eq!(caps.name(\"format\").unwrap(), \"4711\");\n+    assert_eq!(caps.name(\"groupid\").unwrap(), \"5490\");\n }\n \n #[test]\n fn creates_valid_regex_for_routes () {\n-    let regex1 = path_utils::create_regex(\"foo/:uid/bar/:groupid\");\n-    let regex2 = path_utils::create_regex(\"foo/*/bar\");\n-    let regex3 = path_utils::create_regex(\"foo/**/bar\");\n+    let regex1 = \"foo/:uid/bar/:groupid\".into_matcher();\n+    let regex2 = \"foo/*/bar\".into_matcher();\n+    let regex3 = \"foo/**/bar\".into_matcher();\n \n     assert_eq!(regex1.is_match(\"foo/4711/bar/5490\"), true);\n     assert_eq!(regex1.is_match(\"foo/4711/bar/5490?foo=true&bar=false\"), true);\ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -182,8 +180,6 @@ fn creates_valid_regex_for_routes () {\n \n #[test]\n fn can_match_var_routes () {\n-    use hyper::method::Method;\n-\n     let route_store = &mut Router::new();\n     let handler = middleware! { \"hello from foo\" };\n \ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -250,3 +244,76 @@ fn can_match_var_routes () {\n     assert_eq!(route_result.param(\"format\"), \"markdown\");\n }\n \n+#[test]\n+fn regex_path() {\n+    use regex::Regex;\n+\n+    let route_store = &mut Router::new();\n+    let handler = middleware! { \"hello from foo\" };\n+\n+    let regex = Regex::new(\"/(foo|bar)\").unwrap();\n+    route_store.add_route(Method::Get, regex, handler);\n+\n+    let route_result = route_store.match_route(&Method::Get, \"/foo\");\n+    assert!(route_result.is_some());\n+\n+    let route_result = route_store.match_route(&Method::Get, \"/bar\");\n+    assert!(route_result.is_some());\n+\n+    let route_result = route_store.match_route(&Method::Get, \"/bar?foo\");\n+    assert!(route_result.is_some());\n+\n+    let route_result = route_store.match_route(&Method::Get, \"/baz\");\n+    assert!(route_result.is_none());\n+}\n+\n+#[test]\n+fn regex_path_named() {\n+    use regex::Regex;\n+\n+    let route_store = &mut Router::new();\n+    let handler = middleware! { \"hello from foo\" };\n+\n+    let regex = Regex::new(\"/(?P<a>foo|bar)/b\").unwrap();\n+    route_store.add_route(Method::Get, regex, handler);\n+\n+    let route_result = route_store.match_route(&Method::Get, \"/foo/b\");\n+    assert!(route_result.is_some());\n+\n+    let route_result = route_result.unwrap();\n+    assert_eq!(route_result.param(\"a\"), \"foo\");\n+\n+    let route_result = route_store.match_route(&Method::Get, \"/bar/b\");\n+    assert!(route_result.is_some());\n+\n+    let route_result = route_result.unwrap();\n+    assert_eq!(route_result.param(\"a\"), \"bar\");\n+\n+    let route_result = route_store.match_route(&Method::Get, \"/baz/b\");\n+    assert!(route_result.is_none());\n+}\n+\n+#[test]\n+fn ignores_querystring() {\n+    use regex::Regex;\n+\n+    let route_store = &mut Router::new();\n+    let handler = middleware! { \"hello from foo\" };\n+\n+    let regex = Regex::new(\"/(?P<a>foo|bar)/b\").unwrap();\n+    route_store.add_route(Method::Get, regex, handler);\n+    route_store.add_route(Method::Get, \"/:foo\", handler);\n+\n+    // Should ignore the querystring\n+    let route_result = route_store.match_route(&Method::Get, \"/moo?foo\");\n+    assert!(route_result.is_some());\n+\n+    let route_result = route_result.unwrap();\n+    assert_eq!(route_result.param(\"foo\"), \"moo\");\n+\n+    let route_result = route_store.match_route(&Method::Get, \"/bar/b?foo\");\n+    assert!(route_result.is_some());\n+\n+    let route_result = route_result.unwrap();\n+    assert_eq!(route_result.param(\"a\"), \"bar\");\n+}\n",
        "problem_statement": "Regex Routing\nWhat was the motivation for choosing a wildstar / custom routing language over matching paths with regex?  Is there any interest in adding support of regex path matching?  I know that personally I prefer using Regex to do my routing.  It provides more control than wildstar/blobs, and named capture groups match up with url parameters really well.\n\nOr maybe Nickel.rs can already do this and I'm just not reading close enough.\n\nIf people are interested in using regex for routing, I'd be happy to patch it in.\n\n",
        "hints_text": "Well express.js has the same wildstar route feature and I wanted something quite comparable to express.js when I wrote the router. But as far as I see expressjs also supports regex routes and I agree that it would be a neat addition to the router. I just think it should be done in a way that still supports the basic pattern routes that we have today. Would be great if you like to work on that.\n\n//cc @Ryman @SimonPersson \n\nI like this! It means that bugs are less likely to occur than with our own implementation, more power to the programmer (match \"/a/\" but not \"/1/\" and similar) and also we can check that the regex is valid at compile time with the macro. Sounds great to me.\n\nIt'd be nice to support the basic patterns we have now too, for users who just want to match basic routes without having to learn regex.\n\nIt should be fairly simple to support both since we already stores a regex internally. It'd be nice to make a macro out of `create_regex` while we're at it!\n\n:+1: I'm for this, it should be easy enough to use a `ToRouteMatcher` trait to allow the flexibility to do `x.get(regex!(..), handler)` or `x.get(\"..\", handler)`.\n\nIn the long run, I'd hope we could provide compile time validation of variables in the route being used within a handler. I wouldn't consider that a requirement at the moment, but it's something to think about if you go ahead with this :)\n\n> I'm for this, it should be easy enough to use a ToRouteMatcher trait to allow the flexibility to do x.get(regex!(..), handler) or x.get(\"..\", handler).\n\nYep, I was thinking in that direction, too.\n\n@axelmagn do you like to work on that?\n\nHappily!  I'll jump on in.\n",
        "created_at": "2015-03-18T04:30:00Z",
        "version": "0.2"
    },
    {
        "repo": "nickel-org/nickel.rs",
        "pull_number": 157,
        "instance_id": "nickel-org__nickel.rs-157",
        "issue_numbers": [
            "99"
        ],
        "base_commit": "220acdc2b2e6d0ca0e9cbe68fda2c77e670603ee",
        "patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -11,10 +11,6 @@ license = \"MIT\"\n name = \"nickel\"\n path = \"src/lib.rs\"\n \n-[dependencies.http]\n-\n-git = \"https://github.com/nickel-org/rust-http.git\"\n-\n [dependencies.rust-mustache]\n \n git = \"https://github.com/nickel-org/rust-mustache.git\"\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -36,6 +32,7 @@ regex = \"*\"\n regex_macros = \"*\"\n rustc-serialize = \"*\"\n log = \"*\"\n+hyper = \"*\"\n \n [[example]]\n \ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -53,19 +53,19 @@ Then try `localhost:6767/user/4711` and `localhost:6767/bar`\n Here is how sample server in `example.rs` looks like:\n \n ```rust\n-#![feature(core, io)]\n+#![feature(core, io, net)]\n \n extern crate \"rustc-serialize\" as rustc_serialize;\n extern crate nickel;\n-extern crate http;\n+#[macro_use] extern crate nickel_macros;\n \n-use http::status::{NotFound, BadRequest};\n+use nickel::status::StatusCode::{self, NotFound, BadRequest};\n use nickel::{\n-    Nickel, NickelError, ErrorWithStatusCode, Continue, Halt, Request, Response,\n-    QueryString, JsonBody, StaticFilesHandler, MiddlewareResult, HttpRouter\n+    Nickel, NickelError, ErrorWithStatusCode, Continue, Halt, Request,\n+    QueryString, JsonBody, StaticFilesHandler, HttpRouter, Action\n };\n-use nickel::mimes::MediaType;\n-use std::old_io::net::ip::Ipv4Addr;\n+use std::net::IpAddr;\n+use std::io::Write;\n use std::collections::BTreeMap;\n use rustc_serialize::json::{Json, ToJson};\n \ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -91,113 +91,62 @@ fn main() {\n     // to achieve with the current version of rust.\n \n     //this is an example middleware function that just logs each request\n-    fn logger(request: &Request, _response: &mut Response) -> MiddlewareResult {\n-        println!(\"logging request: {}\", request.origin.request_uri);\n-\n-        // a request is supposed to return a `bool` to indicate whether additional\n-        // middleware should continue executing or should be stopped.\n-        Ok(Continue)\n-    }\n-\n     // middleware is optional and can be registered with `utilize`\n-    // issue #20178\n-    let logger_handler: fn(&Request, &mut Response) -> MiddlewareResult = logger;\n-    server.utilize(logger_handler);\n+    server.utilize(middleware! { |request|\n+        println!(\"logging request: {:?}\", request.origin.uri);\n+    });\n \n     let mut router = Nickel::router();\n \n-    fn user_handler(request: &Request, _response: &mut Response) -> String {\n-        format!(\"This is user: {}\", request.param(\"userid\"))\n-    }\n-\n-    // issue #20178\n-    let uhandler: fn(&Request, &mut Response) -> String = user_handler;\n-\n     // go to http://localhost:6767/user/4711 to see this route in action\n-    router.get(\"/user/:userid\", uhandler);\n-\n-    fn bar_handler(_request: &Request, response: &mut Response) {\n-        response.send(\"This is the /bar handler\");\n-    }\n-\n-    // issue #20178\n-    let bhandler: fn(&Request, &mut Response) = bar_handler;\n+    router.get(\"/user/:userid\", middleware! { |request|\n+        format!(\"This is user: {}\", request.param(\"userid\"))\n+    });\n \n     // go to http://localhost:6767/bar to see this route in action\n-    router.get(\"/bar\", bhandler);\n-\n-    fn simple_wildcard(_request: &Request, response: &mut Response) {\n-        response.send(\"This matches /some/crazy/route but not /some/super/crazy/route\");\n-    }\n-\n-    // issue #20178\n-    let shandler: fn(&Request, &mut Response) = simple_wildcard;\n+    router.get(\"/bar\", middleware!(\"This is the /bar handler\"));\n \n     // go to http://localhost:6767/some/crazy/route to see this route in action\n-    router.get(\"/some/*/route\", shandler);\n-\n-    fn double_wildcard(_request: &Request, _response: &mut Response) -> &'static str {\n-        \"This matches /a/crazy/route and also /a/super/crazy/route\"\n-    }\n-\n-    // issue #20178\n-    let dhandler: fn(&Request, &mut Response) -> &'static str = double_wildcard;\n+    router.get(\"/some/*/route\", middleware! {\n+        \"This matches /some/crazy/route but not /some/super/crazy/route\"\n+    });\n \n     // go to http://localhost:6767/a/nice/route or http://localhost:6767/a/super/nice/route to see this route in action\n-    router.get(\"/a/**/route\", dhandler);\n+    router.get(\"/a/**/route\", middleware! {\n+        \"This matches /a/crazy/route and also /a/super/crazy/route\"\n+    });\n \n     // try it with curl\n     // curl 'http://localhost:6767/a/post/request' -H 'Content-Type: application/json;charset=UTF-8'  --data-binary $'{ \"firstname\": \"John\",\"lastname\": \"Connor\" }'\n-    fn post_handler(request: &mut Request, _response: &mut Response) -> String {\n+    router.post(\"/a/post/request\", middleware! { |request, response|\n         let person = request.json_as::<Person>().unwrap();\n         format!(\"Hello {} {}\", person.firstname, person.lastname)\n-    }\n-\n-    // issue #20178\n-    let phandler: fn(&mut Request, &mut Response) -> String = post_handler;\n+    });\n \n-    // go to http://localhost:6767/a/post/request to see this route in action\n-    router.post(\"/a/post/request\", phandler);\n-\n-    fn json_response(_request: &Request, _response: &mut Response) -> Json {\n+    // go to http://localhost:6767/api/person/1 to see this route in action\n+    router.get(\"/api/person/1\", middleware! {\n         let person = Person {\n             firstname: \"Pea\".to_string(),\n             lastname: \"Nut\".to_string()\n         };\n         person.to_json()\n-    }\n-\n-    // issue #20178\n-    let jresponse: fn(&Request, &mut Response) -> Json = json_response;\n-\n-    // go to http://localhost:6767/api/person/1 to see this route in action\n-    router.get(\"/api/person/1\", jresponse);\n+    });\n \n     // try calling http://localhost:6767/query?foo=bar\n-    fn query_handler(request: &mut Request, _response: &mut Response) -> String {\n-        format!(\"Your foo values in the query string are: {:?}\", *request.query(\"foo\", \"This is only a default value!\"))\n-    }\n-\n-    // issue #20178\n-    let qhandler: fn(&mut Request, &mut Response) -> String = query_handler;\n-\n-    router.get(\"/query\", qhandler);\n+    router.get(\"/query\", middleware! { |request|\n+        format!(\"Your foo values in the query string are: {:?}\",\n+                request.query(\"foo\", \"This is only a default value!\"))\n+    });\n \n     // try calling http://localhost:6767/strict?state=valid\n     // then try calling http://localhost:6767/strict?state=invalid\n-    fn strict_handler(request: &mut Request, response: &mut Response) -> MiddlewareResult {\n+    router.get(\"/strict\", middleware! { |request|\n         if request.query(\"state\", \"invalid\")[0].as_slice() != \"valid\" {\n-            Err(NickelError::new(\"Error Parsing JSON\", ErrorWithStatusCode(BadRequest)))\n+            (BadRequest, \"Error Parsing JSON\")\n         } else {\n-            response.send(\"Congratulations on conforming!\");\n-            Ok(Halt)\n+            (StatusCode::Ok, \"Congratulations on conforming!\")\n         }\n-    }\n-\n-    // issue #20178\n-    let sthandler: fn(&mut Request, &mut Response) -> MiddlewareResult = strict_handler;\n-\n-    router.get(\"/strict\", sthandler);\n+    });\n \n     server.utilize(router);\n \ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -205,24 +154,28 @@ fn main() {\n     server.utilize(StaticFilesHandler::new(\"examples/assets/\"));\n \n     //this is how to overwrite the default error handler to handle 404 cases with a custom view\n-    fn custom_404(err: &NickelError, _req: &Request, response: &mut Response) -> MiddlewareResult {\n+    fn custom_404<'a>(err: &mut NickelError, _req: &mut Request) -> Action {\n         match err.kind {\n             ErrorWithStatusCode(NotFound) => {\n-                response.content_type(MediaType::Html)\n-                        .status_code(NotFound)\n-                        .send(\"<h1>Call the police!<h1>\");\n-                Ok(Halt)\n+                // FIXME: Supportable?\n+                // response.content_type(MediaType::Html)\n+                //         .status_code(NotFound)\n+                //         .send(\"<h1>Call the police!<h1>\");\n+                if let Some(ref mut res) = err.stream {\n+                    let _ = res.write_all(b\"<h1>Call the police!</h1>\");\n+                }\n+                Halt(())\n             },\n-            _ => Ok(Continue)\n+            _ => Continue(())\n         }\n     }\n \n     // issue #20178\n-    let custom_handler: fn(&NickelError, &Request, &mut Response) -> MiddlewareResult = custom_404;\n+    let custom_handler: fn(&mut NickelError, &mut Request) -> Action = custom_404;\n \n     server.handle_error(custom_handler);\n \n-    server.listen(Ipv4Addr(127, 0, 0, 1), 6767);\n+    server.listen(IpAddr::new_v4(127, 0, 0, 1), 6767);\n }\n ```\n \ndiff --git a/examples/example.rs b/examples/example.rs\n--- a/examples/example.rs\n+++ b/examples/example.rs\n@@ -1,17 +1,17 @@\n-#![feature(core, old_io)]\n+#![feature(core, io, net)]\n \n extern crate \"rustc-serialize\" as rustc_serialize;\n extern crate nickel;\n-extern crate http;\n+#[macro_use] extern crate nickel_macros;\n \n-use http::status::{NotFound, BadRequest};\n+use nickel::status::StatusCode::{self, NotFound, BadRequest};\n use nickel::{\n-    Nickel, NickelError, ErrorWithStatusCode, Continue, Halt, Request, Response,\n-    QueryString, JsonBody, StaticFilesHandler, MiddlewareResult, HttpRouter\n+    Nickel, NickelError, ErrorWithStatusCode, Continue, Halt, Request,\n+    QueryString, JsonBody, StaticFilesHandler, HttpRouter, Action\n };\n-use nickel::mimes::MediaType;\n-use std::old_io::net::ip::Ipv4Addr;\n+use std::net::IpAddr;\n use std::collections::BTreeMap;\n+use std::io::Write;\n use rustc_serialize::json::{Json, ToJson};\n \n #[derive(RustcDecodable, RustcEncodable)]\ndiff --git a/examples/example.rs b/examples/example.rs\n--- a/examples/example.rs\n+++ b/examples/example.rs\n@@ -36,113 +36,62 @@ fn main() {\n     // to achieve with the current version of rust.\n \n     //this is an example middleware function that just logs each request\n-    fn logger(request: &Request, _response: &mut Response) -> MiddlewareResult {\n-        println!(\"logging request: {}\", request.origin.request_uri);\n-\n-        // a request is supposed to return a `bool` to indicate whether additional\n-        // middleware should continue executing or should be stopped.\n-        Ok(Continue)\n-    }\n-\n     // middleware is optional and can be registered with `utilize`\n-    // issue #20178\n-    let logger_handler: fn(&Request, &mut Response) -> MiddlewareResult = logger;\n-    server.utilize(logger_handler);\n+    server.utilize(middleware! { |request|\n+        println!(\"logging request: {:?}\", request.origin.uri);\n+    });\n \n     let mut router = Nickel::router();\n \n-    fn user_handler(request: &Request, _response: &mut Response) -> String {\n-        format!(\"This is user: {}\", request.param(\"userid\"))\n-    }\n-\n-    // issue #20178\n-    let uhandler: fn(&Request, &mut Response) -> String = user_handler;\n-\n     // go to http://localhost:6767/user/4711 to see this route in action\n-    router.get(\"/user/:userid\", uhandler);\n-\n-    fn bar_handler(_request: &Request, response: &mut Response) {\n-        response.send(\"This is the /bar handler\");\n-    }\n-\n-    // issue #20178\n-    let bhandler: fn(&Request, &mut Response) = bar_handler;\n+    router.get(\"/user/:userid\", middleware! { |request|\n+        format!(\"This is user: {}\", request.param(\"userid\"))\n+    });\n \n     // go to http://localhost:6767/bar to see this route in action\n-    router.get(\"/bar\", bhandler);\n-\n-    fn simple_wildcard(_request: &Request, response: &mut Response) {\n-        response.send(\"This matches /some/crazy/route but not /some/super/crazy/route\");\n-    }\n-\n-    // issue #20178\n-    let shandler: fn(&Request, &mut Response) = simple_wildcard;\n+    router.get(\"/bar\", middleware!(\"This is the /bar handler\"));\n \n     // go to http://localhost:6767/some/crazy/route to see this route in action\n-    router.get(\"/some/*/route\", shandler);\n-\n-    fn double_wildcard(_request: &Request, _response: &mut Response) -> &'static str {\n-        \"This matches /a/crazy/route and also /a/super/crazy/route\"\n-    }\n-\n-    // issue #20178\n-    let dhandler: fn(&Request, &mut Response) -> &'static str = double_wildcard;\n+    router.get(\"/some/*/route\", middleware! {\n+        \"This matches /some/crazy/route but not /some/super/crazy/route\"\n+    });\n \n     // go to http://localhost:6767/a/nice/route or http://localhost:6767/a/super/nice/route to see this route in action\n-    router.get(\"/a/**/route\", dhandler);\n+    router.get(\"/a/**/route\", middleware! {\n+        \"This matches /a/crazy/route and also /a/super/crazy/route\"\n+    });\n \n     // try it with curl\n     // curl 'http://localhost:6767/a/post/request' -H 'Content-Type: application/json;charset=UTF-8'  --data-binary $'{ \"firstname\": \"John\",\"lastname\": \"Connor\" }'\n-    fn post_handler(request: &mut Request, _response: &mut Response) -> String {\n+    router.post(\"/a/post/request\", middleware! { |request, response|\n         let person = request.json_as::<Person>().unwrap();\n         format!(\"Hello {} {}\", person.firstname, person.lastname)\n-    }\n-\n-    // issue #20178\n-    let phandler: fn(&mut Request, &mut Response) -> String = post_handler;\n+    });\n \n-    // go to http://localhost:6767/a/post/request to see this route in action\n-    router.post(\"/a/post/request\", phandler);\n-\n-    fn json_response(_request: &Request, _response: &mut Response) -> Json {\n+    // go to http://localhost:6767/api/person/1 to see this route in action\n+    router.get(\"/api/person/1\", middleware! {\n         let person = Person {\n             firstname: \"Pea\".to_string(),\n             lastname: \"Nut\".to_string()\n         };\n         person.to_json()\n-    }\n-\n-    // issue #20178\n-    let jresponse: fn(&Request, &mut Response) -> Json = json_response;\n-\n-    // go to http://localhost:6767/api/person/1 to see this route in action\n-    router.get(\"/api/person/1\", jresponse);\n+    });\n \n     // try calling http://localhost:6767/query?foo=bar\n-    fn query_handler(request: &mut Request, _response: &mut Response) -> String {\n-        format!(\"Your foo values in the query string are: {:?}\", request.query(\"foo\", \"This is only a default value!\"))\n-    }\n-\n-    // issue #20178\n-    let qhandler: fn(&mut Request, &mut Response) -> String = query_handler;\n-\n-    router.get(\"/query\", qhandler);\n+    router.get(\"/query\", middleware! { |request|\n+        format!(\"Your foo values in the query string are: {:?}\",\n+                request.query(\"foo\", \"This is only a default value!\"))\n+    });\n \n     // try calling http://localhost:6767/strict?state=valid\n     // then try calling http://localhost:6767/strict?state=invalid\n-    fn strict_handler(request: &mut Request, response: &mut Response) -> MiddlewareResult {\n+    router.get(\"/strict\", middleware! { |request|\n         if request.query(\"state\", \"invalid\")[0].as_slice() != \"valid\" {\n-            Err(NickelError::new(\"Error Parsing JSON\", ErrorWithStatusCode(BadRequest)))\n+            (BadRequest, \"Error Parsing JSON\")\n         } else {\n-            response.send(\"Congratulations on conforming!\");\n-            Ok(Halt)\n+            (StatusCode::Ok, \"Congratulations on conforming!\")\n         }\n-    }\n-\n-    // issue #20178\n-    let sthandler: fn(&mut Request, &mut Response) -> MiddlewareResult = strict_handler;\n-\n-    router.get(\"/strict\", sthandler);\n+    });\n \n     server.utilize(router);\n \ndiff --git a/examples/example.rs b/examples/example.rs\n--- a/examples/example.rs\n+++ b/examples/example.rs\n@@ -150,22 +99,26 @@ fn main() {\n     server.utilize(StaticFilesHandler::new(\"examples/assets/\"));\n \n     //this is how to overwrite the default error handler to handle 404 cases with a custom view\n-    fn custom_404(err: &NickelError, _req: &Request, response: &mut Response) -> MiddlewareResult {\n+    fn custom_404<'a>(err: &mut NickelError, _req: &mut Request) -> Action {\n         match err.kind {\n             ErrorWithStatusCode(NotFound) => {\n-                response.content_type(MediaType::Html)\n-                        .status_code(NotFound)\n-                        .send(\"<h1>Call the police!<h1>\");\n-                Ok(Halt)\n+                // FIXME: Supportable?\n+                // response.content_type(MediaType::Html)\n+                //         .status_code(NotFound)\n+                //         .send(\"<h1>Call the police!<h1>\");\n+                if let Some(ref mut res) = err.stream {\n+                    let _ = res.write_all(b\"<h1>Call the police!</h1>\");\n+                }\n+                Halt(())\n             },\n-            _ => Ok(Continue)\n+            _ => Continue(())\n         }\n     }\n \n     // issue #20178\n-    let custom_handler: fn(&NickelError, &Request, &mut Response) -> MiddlewareResult = custom_404;\n+    let custom_handler: fn(&mut NickelError, &mut Request) -> Action = custom_404;\n \n     server.handle_error(custom_handler);\n \n-    server.listen(Ipv4Addr(127, 0, 0, 1), 6767);\n+    server.listen(IpAddr::new_v4(127, 0, 0, 1), 6767);\n }\ndiff --git a/examples/example_route_data.rs b/examples/example_route_data.rs\n--- a/examples/example_route_data.rs\n+++ b/examples/example_route_data.rs\n@@ -1,12 +1,9 @@\n-#![feature(old_io)]\n+#![feature(net)]\n \n extern crate nickel;\n-extern crate http;\n \n-use nickel::{\n-    Nickel, Request, Response, HttpRouter\n-};\n-use std::old_io::net::ip::Ipv4Addr;\n+use nickel::{Nickel, Request, Response, HttpRouter, MiddlewareResult, Halt};\n+use std::net::IpAddr;\n use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering::Relaxed;\n \ndiff --git a/examples/example_route_data.rs b/examples/example_route_data.rs\n--- a/examples/example_route_data.rs\n+++ b/examples/example_route_data.rs\n@@ -17,13 +14,16 @@ struct Logger {\n fn main() {\n     let mut server = Nickel::new();\n \n-    fn root_handler(_request: &Request, response: &mut Response, logger: &Logger) {\n-        response.send(format!(\"{}\", logger.visits.fetch_add(1, Relaxed)));\n+    fn root_handler<'a>(_: &mut Request, response: Response<'a>, logger: &Logger)\n+            -> MiddlewareResult<'a> {\n+        let text = format!(\"{}\", logger.visits.fetch_add(1, Relaxed));\n+        let response = try!(response.send(text));\n+        Ok(Halt(response))\n     }\n \n     // issue #20178\n-    let rhandler: fn(&Request, &mut Response, &Logger) = root_handler;\n+    let rhandler: for <'a> fn(&mut Request, Response<'a>, &Logger) -> MiddlewareResult<'a> = root_handler;\n \n     server.get(\"/\", (rhandler, Logger{visits: AtomicUsize::new(0)}));\n-    server.listen(Ipv4Addr(127, 0, 0, 1), 6767);\n+    server.listen(IpAddr::new_v4(127, 0, 0, 1), 6767);\n }\ndiff --git a/examples/example_template.rs b/examples/example_template.rs\n--- a/examples/example_template.rs\n+++ b/examples/example_template.rs\n@@ -1,25 +1,21 @@\n-#![feature(old_io)]\n-\n+#![feature(net)]\n extern crate nickel;\n-extern crate http;\n+#[macro_use] extern crate nickel_macros;\n \n-use nickel::{Nickel, Request, Response, HttpRouter};\n-use std::old_io::net::ip::Ipv4Addr;\n+use nickel::{Nickel, Request, Response, HttpRouter, MiddlewareResult, Halt};\n+use std::net::IpAddr;\n use std::collections::HashMap;\n \n fn main() {\n     let mut server = Nickel::new();\n \n-    fn root_handler (_request: &Request, response: &mut Response) {\n+    fn handler<'a>(_: &mut Request, res: Response<'a>) -> MiddlewareResult<'a> {\n         let mut data = HashMap::<&str, &str>::new();\n         data.insert(\"name\", \"user\");\n-        response.render(\"examples/assets/template.tpl\", &data);\n+        Ok(Halt(try!(res.render(\"examples/assets/template.tpl\", &data))))\n     }\n \n-    // issue #20178\n-    let handler: fn(&Request, &mut Response) = root_handler;\n-\n-    server.get(\"/\", handler);\n+    server.get(\"/\", middleware!(@handler));\n \n-    server.listen(Ipv4Addr(127, 0, 0, 1), 6767);\n+    server.listen(IpAddr::new_v4(127, 0, 0, 1), 6767);\n }\ndiff --git a/examples/example_with_default_router.rs b/examples/example_with_default_router.rs\n--- a/examples/example_with_default_router.rs\n+++ b/examples/example_with_default_router.rs\n@@ -1,32 +1,20 @@\n-#![feature(old_io)]\n-\n+#![feature(net)]\n extern crate nickel;\n-extern crate http;\n+#[macro_use] extern crate nickel_macros;\n \n-use nickel::{Nickel, Request, Response, HttpRouter};\n-use std::old_io::net::ip::Ipv4Addr;\n+use nickel::{Nickel, HttpRouter};\n+use std::net::IpAddr;\n \n fn main() {\n     let mut server = Nickel::new();\n \n-    fn bar_handler (_request: &Request, response: &mut Response) {\n-        response.send(\"This is the /bar handler\");\n-    }\n-\n-    // issue #20178\n-    let bhandler: fn(&Request, &mut Response) = bar_handler;\n-\n     // go to http://localhost:6767/bar to see this route in action\n-    server.get(\"/bar\", bhandler);\n-\n-    fn foo_handler (request: &mut Request, _response: &mut Response) -> String {\n-        format!(\"Foo is '{}'\", request.param(\"foo\"))\n-    }\n-\n-    let fhandler: fn(&mut Request, &mut Response) -> String = foo_handler;\n+    server.get(\"/bar\", middleware! { \"This is the /bar handler\" });\n \n     // go to http://localhost:6767/foo to see this route in action\n-    server.get(\"/:foo\", fhandler);\n+    server.get(\"/:foo\", middleware! { |request|\n+        format!(\"Foo is '{}'\", request.param(\"foo\"))\n+    });\n \n-    server.listen(Ipv4Addr(127, 0, 0, 1), 6767);\n+    server.listen(IpAddr::new_v4(127, 0, 0, 1), 6767);\n }\ndiff --git a/examples/hello_world.rs b/examples/hello_world.rs\n--- a/examples/hello_world.rs\n+++ b/examples/hello_world.rs\n@@ -1,9 +1,9 @@\n-#![feature(plugin, old_io)]\n+#![feature(plugin, net)]\n #[macro_use] extern crate nickel_macros;\n extern crate nickel;\n \n use nickel::Nickel;\n-use std::old_io::net::ip::Ipv4Addr;\n+use std::net::IpAddr;\n \n fn main() {\n     let mut server = Nickel::new();\ndiff --git a/examples/hello_world.rs b/examples/hello_world.rs\n--- a/examples/hello_world.rs\n+++ b/examples/hello_world.rs\n@@ -14,5 +14,5 @@ fn main() {\n         }\n     });\n \n-    server.listen(Ipv4Addr(127, 0, 0, 1), 6767);\n+    server.listen(IpAddr::new_v4(127, 0, 0, 1), 6767);\n }\ndiff --git a/examples/macro_example.rs b/examples/macro_example.rs\n--- a/examples/macro_example.rs\n+++ b/examples/macro_example.rs\n@@ -1,18 +1,17 @@\n-#![feature(plugin, core, old_io)]\n+#![feature(plugin, core, io, net)]\n \n extern crate url;\n-extern crate http;\n extern crate nickel;\n extern crate \"rustc-serialize\" as rustc_serialize;\n #[macro_use] extern crate nickel_macros;\n \n-use http::status;\n+use nickel::status::StatusCode::{self, NotFound};\n use nickel::{\n     Nickel, NickelError, ErrorWithStatusCode, Continue, Halt, Request, Response,\n-    QueryString, JsonBody, StaticFilesHandler, MiddlewareResult, HttpRouter\n+    QueryString, JsonBody, StaticFilesHandler, MiddlewareResult, HttpRouter, Action\n };\n-use nickel::mimes::MediaType;\n-use std::old_io::net::ip::Ipv4Addr;\n+use std::io::Write;\n+use std::net::IpAddr;\n \n #[derive(RustcDecodable, RustcEncodable)]\n struct Person {\ndiff --git a/examples/macro_example.rs b/examples/macro_example.rs\n--- a/examples/macro_example.rs\n+++ b/examples/macro_example.rs\n@@ -21,24 +20,25 @@ struct Person {\n }\n \n //this is an example middleware function that just logs each request\n-fn logger(request: &Request, _response: &mut Response) -> MiddlewareResult {\n-    println!(\"logging request: {}\", request.origin.request_uri);\n-\n-    // a request is supposed to return a `bool` to indicate whether additional\n-    // middleware should continue executing or should be stopped.\n-    Ok(Continue)\n+fn logger<'a>(request: &mut Request, response: Response<'a>) -> MiddlewareResult<'a> {\n+    println!(\"logging request: {:?}\", request.origin.uri);\n+    Ok(Continue(response))\n }\n \n //this is how to overwrite the default error handler to handle 404 cases with a custom view\n-fn custom_404(err: &NickelError, _req: &Request, response: &mut Response) -> MiddlewareResult {\n+fn custom_404<'a>(err: &mut NickelError, _req: &mut Request) -> Action {\n     match err.kind {\n-        ErrorWithStatusCode(status::NotFound) => {\n-            response.content_type(MediaType::Html)\n-                    .status_code(status::NotFound)\n-                    .send(\"<h1>Call the police!<h1>\");\n-            Ok(Halt)\n+        ErrorWithStatusCode(NotFound) => {\n+            // FIXME: Supportable?\n+            // response.content_type(MediaType::Html)\n+            //         .status_code(NotFound)\n+            //         .send(\"<h1>Call the police!<h1>\");\n+            if let Some(ref mut res) = err.stream {\n+                let _ = res.write_all(b\"<h1>Call the police!</h1>\");\n+            }\n+            Halt(())\n         },\n-        _ => Ok(Continue)\n+        _ => Continue(())\n     }\n }\n \ndiff --git a/examples/macro_example.rs b/examples/macro_example.rs\n--- a/examples/macro_example.rs\n+++ b/examples/macro_example.rs\n@@ -46,9 +46,7 @@ fn main() {\n     let mut server = Nickel::new();\n \n     // middleware is optional and can be registered with `utilize`\n-    // issue #20178\n-    let logger_handler: fn(&Request, &mut Response) -> MiddlewareResult = logger;\n-    server.utilize(logger_handler);\n+    server.utilize(middleware!(@logger));\n \n     // go to http://localhost:6767/thoughtram_logo_brain.png to see static file serving in action\n     server.utilize(StaticFilesHandler::new(\"examples/assets/\"));\ndiff --git a/examples/macro_example.rs b/examples/macro_example.rs\n--- a/examples/macro_example.rs\n+++ b/examples/macro_example.rs\n@@ -73,18 +71,19 @@ fn main() {\n             (200usize, \"This is the /bar handler\")\n         }\n \n-        // go to http://localhost:6767/redirect to see this route in action\n-        get \"/redirect\" => |request, response| {\n-            use http::headers::response::Header::Location;\n-            let root = url::Url::parse(\"http://www.rust-lang.org/\").unwrap();\n-            // returning a typed http status, a response body and some additional headers\n-            (status::TemporaryRedirect, \"Redirecting you to 'rust-lang.org'\", vec![Location(root)])\n-        }\n+        // FIXME\n+        // // go to http://localhost:6767/redirect to see this route in action\n+        // get \"/redirect\" => |request, response| {\n+        //     use http::headers::response::Header::Location;\n+        //     let root = url::Url::parse(\"http://www.rust-lang.org/\").unwrap();\n+        //     // returning a typed http status, a response body and some additional headers\n+        //     (StatusCode::TemporaryRedirect, \"Redirecting you to 'rust-lang.org'\", vec![Location(root)])\n+        // }\n \n         // go to http://localhost:6767/private to see this route in action\n         get \"/private\" => |request, response| {\n             // returning a typed http status and a response body\n-            (status::Unauthorized, \"This is a private place\")\n+            (StatusCode::Unauthorized, \"This is a private place\")\n         }\n \n         // go to http://localhost:6767/some/crazy/route to see this route in action\ndiff --git a/examples/macro_example.rs b/examples/macro_example.rs\n--- a/examples/macro_example.rs\n+++ b/examples/macro_example.rs\n@@ -102,25 +101,22 @@ fn main() {\n         // curl 'http://localhost:6767/a/post/request' -H 'Content-Type: application/json;charset=UTF-8'  --data-binary $'{ \"firstname\": \"John\",\"lastname\": \"Connor\" }'\n         post \"/a/post/request\" => |request, response| {\n             let person = request.json_as::<Person>().unwrap();\n-            let text = format!(\"Hello {} {}\", person.firstname, person.lastname);\n-            response.send(text.as_slice());\n-            // a 'regular' handler with no return, handling everything via the response object\n+            format!(\"Hello {} {}\", person.firstname, person.lastname)\n         }\n \n         // try calling http://localhost:6767/query?foo=bar\n         get \"/query\" => |request, response| {\n             let text = format!(\"Your foo values in the query string are: {:?}\",\n                                request.query(\"foo\", \"This is only a default value!\"));\n-            response.send(text.as_slice());\n-            // a 'regular' handler with no return, handling everything via the response object\n+            text\n         }\n     ));\n \n     // issue #20178\n-    let custom_handler: fn(&NickelError, &Request, &mut Response) -> MiddlewareResult = custom_404;\n+    let custom_handler: fn(&mut NickelError, &mut Request) -> Action = custom_404;\n \n     server.handle_error(custom_handler);\n \n     println!(\"Running server!\");\n-    server.listen(Ipv4Addr(127, 0, 0, 1), 6767);\n+    server.listen(IpAddr::new_v4(127, 0, 0, 1), 6767);\n }\ndiff --git a/nickel_macros/src/macro.rs b/nickel_macros/src/macro.rs\n--- a/nickel_macros/src/macro.rs\n+++ b/nickel_macros/src/macro.rs\n@@ -3,30 +3,41 @@\n macro_rules! router {\n     ($($method:ident $path:expr => |$req:ident, $res:ident| $b:block)+) => (\n         {\n-            use nickel::{HttpRouter, MiddlewareResult};\n-            use nickel::ResponseFinalizer;\n+            use nickel::HttpRouter;\n             let mut router = nickel::Router::new();\n \n-            #[inline(always)]\n-            fn restrict<R: ResponseFinalizer>(r: R, res: &mut nickel::Response) -> MiddlewareResult {\n-                r.respond(res)\n-            }\n+            $( router.$method($path, middleware!(|$req, $res| $b)); )+\n \n-            $(\n-                {\n-                    #[allow(unused_variables)]\n-                    fn f($req: &mut nickel::Request, $res: &mut nickel::Response) -> MiddlewareResult {\n-                        restrict($b, $res)\n-                    }\n+            router\n+        }\n+    )\n+}\n \n-                    // issue #20178\n-                    let fhandler: fn(&mut nickel::Request, &mut nickel::Response) -> MiddlewareResult = f;\n+#[macro_export]\n+macro_rules! middleware {\n+    (@$f:ident) => {\n+        $f as for<'a> fn(&mut Request, Response<'a>) -> MiddlewareResult<'a>\n+    };\n+    (|$req:ident, $res:ident| $($b:tt)+) => {{\n+        use nickel::{MiddlewareResult,ResponseFinalizer, Response, Request};\n \n-                    router.$method($path, fhandler);\n-                }\n-            )+\n+        #[inline(always)]\n+        fn restrict<'a, R: ResponseFinalizer>(r: R, res: Response<'a>)\n+                -> MiddlewareResult<'a> {\n+            r.respond(res)\n+        }\n \n-            router\n+        #[allow(unused_variables)]\n+        fn f<'a>($req: &mut Request, $res: Response<'a>)\n+                -> MiddlewareResult<'a> {\n+            restrict(as_block!({$($b)+}), $res)\n         }\n-    )\n+\n+        // issue #20178\n+        f as for<'a> fn(&mut Request, Response<'a>) -> MiddlewareResult<'a>\n+    }};\n+    (|$req:ident| $($b:tt)+) => { middleware!(|$req, res| $($b)+) };\n+    ($($b:tt)+) => { middleware!(|req, res| $($b)+) };\n }\n+\n+#[macro_export] macro_rules! as_block { ($b:block) => ( $b ) }\ndiff --git a/src/default_error_handler.rs b/src/default_error_handler.rs\n--- a/src/default_error_handler.rs\n+++ b/src/default_error_handler.rs\n@@ -1,21 +1,24 @@\n-use http::status::{NotFound, BadRequest, InternalServerError};\n+use hyper::status::StatusCode::{NotFound, BadRequest};\n use request::Request;\n-use response::Response;\n-use ResponseFinalizer;\n-use middleware::{ErrorHandler, MiddlewareResult};\n+use middleware::{ErrorHandler, Action, Halt};\n use nickel_error::{NickelError, ErrorWithStatusCode};\n+use std::io::Write;\n \n #[derive(Clone, Copy)]\n pub struct DefaultErrorHandler;\n \n impl ErrorHandler for DefaultErrorHandler {\n-    fn invoke(&self, err: &NickelError, _req: &mut Request, res: &mut Response) -> MiddlewareResult {\n-        let r = match err.kind {\n-            ErrorWithStatusCode(NotFound) => (NotFound, \"Not Found\"),\n-            ErrorWithStatusCode(BadRequest) => (BadRequest, \"Bad Request\"),\n-            _ => (InternalServerError, \"Internal Server Error\")\n-        };\n+    fn handle_error(&self, err: &mut NickelError, _req: &mut Request) -> Action {\n+        if let Some(ref mut res) = err.stream {\n+            let msg = match err.kind {\n+                ErrorWithStatusCode(NotFound) => b\"Not Found\",\n+                ErrorWithStatusCode(BadRequest) => b\"Bad Request\",\n+                _ => b\"Internal Server Error\"\n+            };\n \n-        r.respond(res)\n+            let _ = res.write_all(msg);\n+        }\n+\n+        Halt(())\n     }\n }\ndiff --git a/src/favicon_handler.rs b/src/favicon_handler.rs\n--- a/src/favicon_handler.rs\n+++ b/src/favicon_handler.rs\n@@ -1,27 +1,30 @@\n-use std::old_io::File;\n+use std::fs::File;\n+use std::path::{PathBuf, AsPath};\n+use std::io::Read;\n \n-use http::server::request::RequestUri::AbsolutePath;\n-use http::method::{Get, Head, Options};\n-use http::status;\n+use hyper::uri::RequestUri::AbsolutePath;\n+use hyper::method::Method::{Get, Head, Options};\n+use hyper::status::StatusCode;\n+use hyper::header;\n+use hyper::net;\n \n-use request;\n-use response;\n-use middleware::{Action, Halt, Continue, Middleware};\n-use nickel_error::NickelError;\n+use request::Request;\n+use response::Response;\n+use middleware::{Halt, Continue, Middleware, MiddlewareResult};\n use mimes::MediaType;\n \n pub struct FaviconHandler {\n     icon: Vec<u8>,\n-    icon_path: Path, // Is it useful to log where in-memory favicon came from every request?\n+    icon_path: PathBuf, // Is it useful to log where in-memory favicon came from every request?\n }\n \n impl Middleware for FaviconHandler {\n-    fn invoke (&self, req: &mut request::Request, res: &mut response::Response)\n-               -> Result<Action, NickelError> {\n+    fn invoke<'a, 'b>(&'a self, req: &mut Request<'b, 'a>, res: Response<'a, net::Fresh>)\n+            -> MiddlewareResult<'a> {\n         if FaviconHandler::is_favicon_request(req) {\n             self.handle_request(req, res)\n         } else {\n-            Ok(Continue)\n+            Ok(Continue(res))\n         }\n     }\n }\ndiff --git a/src/favicon_handler.rs b/src/favicon_handler.rs\n--- a/src/favicon_handler.rs\n+++ b/src/favicon_handler.rs\n@@ -30,52 +33,57 @@ impl FaviconHandler {\n     /// Create a new middleware to serve an /favicon.ico file from an in-memory cache.\n     /// The file is only read from disk once when the server starts.\n     ///\n-    ///\n-    /// # Example\n-    /// ```{rust,ignore}\n+    /// # Examples\n+    /// ```{rust,no_run}\n     /// use nickel::{Nickel, FaviconHandler};\n     /// let mut server = Nickel::new();\n     ///\n     /// server.utilize(FaviconHandler::new(\"/path/to/ico/file\"));\n     /// ```\n-    pub fn new (icon_path: &str) -> FaviconHandler {\n-        let _icon_path = Path::new(icon_path);\n+    pub fn new<P: AsPath>(icon_path: P) -> FaviconHandler {\n+        let icon_path = icon_path.as_path().to_path_buf();\n+        let mut icon = vec![];\n+        File::open(&icon_path).unwrap().read_to_end(&mut icon).unwrap();\n+\n         FaviconHandler {\n             // Fail when favicon cannot be read. Better error message though?\n-            icon: File::open(&Path::new(icon_path)).unwrap().read_to_end().unwrap(),\n-            icon_path: _icon_path,\n+            icon: icon,\n+            icon_path: icon_path,\n         }\n     }\n \n     #[inline]\n-    pub fn is_favicon_request (req: &request::Request) -> bool {\n-        match req.origin.request_uri {\n+    pub fn is_favicon_request(req: &Request) -> bool {\n+        match req.origin.uri {\n             AbsolutePath(ref path) => &**path == \"/favicon.ico\",\n             _                      => false\n         }\n     }\n \n-    pub fn handle_request (&self, req: &request::Request, res: &mut response::Response)\n-               -> Result<Action, NickelError> {\n+    pub fn handle_request<'a>(&self, req: &Request, mut res: Response<'a>) -> MiddlewareResult<'a> {\n         match req.origin.method {\n             Get | Head => {\n-                self.send_favicon(req, res);\n+                self.send_favicon(req, res)\n             },\n             Options => {\n-                res.status_code(status::Ok);\n-                res.origin.headers.allow = Some(vec!(Get, Head, Options));\n+                res.status_code(StatusCode::Ok);\n+                res.origin.headers_mut().set(header::Allow(vec!(Get, Head, Options)));\n+                let stream = try!(res.send(\"\"));\n+                Ok(Halt(stream))\n             },\n             _ => {\n-                res.status_code(status::MethodNotAllowed);\n-                res.origin.headers.allow = Some(vec!(Get, Head, Options));\n+                res.status_code(StatusCode::MethodNotAllowed);\n+                res.origin.headers_mut().set(header::Allow(vec!(Get, Head, Options)));\n+                let stream = try!(res.send(\"\"));\n+                Ok(Halt(stream))\n             }\n         }\n-        Ok(Halt)\n     }\n \n-    pub fn send_favicon (&self, req: &request::Request, res: &mut response::Response) {\n+    pub fn send_favicon<'a, 'b>(&self, req: &Request, mut res: Response<'a>) -> MiddlewareResult<'a> {\n         debug!(\"{:?} {:?}\", req.origin.method, self.icon_path.display());\n         res.content_type(MediaType::Ico);\n-        res.send(&*self.icon);\n+        let stream = try!(res.send(&*self.icon));\n+        Ok(Halt(stream))\n     }\n }\ndiff --git a/src/json_body_parser.rs b/src/json_body_parser.rs\n--- a/src/json_body_parser.rs\n+++ b/src/json_body_parser.rs\n@@ -1,39 +1,35 @@\n-use std::str;\n use serialize::{Decodable, json};\n use request::Request;\n use typemap::Key;\n use plugin::{Plugin, Pluggable};\n+use std::io;\n+use std::io::{Read, ErrorKind};\n \n // Plugin boilerplate\n struct JsonBodyParser;\n impl Key for JsonBodyParser { type Value = String; }\n impl<'a, 'b> Plugin<Request<'a, 'b>> for JsonBodyParser {\n-    type Error = &'static str;\n+    type Error = io::Error;\n \n-    fn eval(req: &mut Request) -> Result<String, &'static str> {\n-        if !req.origin.body.is_empty() {\n-            str::from_utf8(&*req.origin.body)\n-                .map(|s| s.to_string())\n-                .map_err(|_| \"Request body is not utf-8.\")\n-        }\n-        else {\n-            Err(\"Request body is empty.\")\n-        }\n+    fn eval(req: &mut Request) -> io::Result<String> {\n+        let mut s = String::new();\n+        try!(req.origin.read_to_string(&mut s));\n+        Ok(s)\n     }\n }\n \n pub trait JsonBody {\n-    fn json_as<T: Decodable>(&mut self) -> Option<T>;\n+    fn json_as<T: Decodable>(&mut self) -> io::Result<T>;\n }\n \n impl<'a, 'b> JsonBody for Request<'a, 'b> {\n-    fn json_as<T: Decodable>(&mut self) -> Option<T> {\n-        // FIXME:\n-        // I think it would be smarter to not return Option<T> but rather\n-        // DecodeResult<T> to not swallow valuable debugging information.\n-        // I couldn't figure out how to properly do that\n-        self.get::<JsonBodyParser>().and_then(|parsed| {\n-            json::decode::<T>(&*parsed).map_err(|_| \"Couldn't parse JSON.\")\n-        }).ok()\n+    fn json_as<T: Decodable>(&mut self) -> io::Result<T> {\n+        self.get::<JsonBodyParser>().and_then(|parsed|\n+            json::decode::<T>(&*parsed).map_err(|err|\n+                io::Error::new(ErrorKind::Other,\n+                               \"Failed to parse JSON\",\n+                               Some(format!(\"{}\", err)))\n+            )\n+        )\n     }\n }\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -1,6 +1,6 @@\n #![crate_name = \"nickel\"]\n #![crate_type = \"rlib\"]\n-#![feature(plugin, core, collections, old_io, old_path, std_misc)]\n+#![feature(plugin, core, collections, io, net, os, path, fs, std_misc, old_path)]\n #![plugin(regex_macros)]\n \n //!Nickel is supposed to be a simple and lightweight foundation for web applications written in Rust. Its API is inspired by the popular express framework for JavaScript.\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -15,16 +15,17 @@\n //!* middleware\n \n extern crate time;\n-extern crate http;\n extern crate \"rustc-serialize\" as serialize;\n+extern crate hyper;\n extern crate regex;\n extern crate typemap;\n extern crate plugin;\n extern crate url;\n extern crate mustache;\n extern crate groupable;\n-#[macro_use]\n-extern crate log;\n+\n+#[macro_use] extern crate log;\n+#[macro_use] extern crate nickel_macros;\n \n pub use nickel::Nickel;\n pub use request::Request;\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -55,3 +56,7 @@ mod query_string;\n mod urlencoded;\n mod nickel_error;\n mod default_error_handler;\n+\n+pub mod status {\n+    pub use hyper::status::StatusCode;\n+}\ndiff --git a/src/middleware.rs b/src/middleware.rs\n--- a/src/middleware.rs\n+++ b/src/middleware.rs\n@@ -1,36 +1,34 @@\n use request::Request;\n use response::Response;\n use nickel_error::NickelError;\n-use middleware_handler::ResponseFinalizer;\n+use hyper::net;\n+\n pub use self::Action::{Continue, Halt};\n \n-pub type MiddlewareResult = Result<Action, NickelError>;\n+pub type MiddlewareResult<'a> = Result<Action<Response<'a, net::Fresh>,\n+                                              Response<'a, net::Streaming>>,\n+                                        NickelError<'a>>;\n \n-#[derive(PartialEq, Copy)]\n-pub enum Action {\n-  Continue,\n-  Halt\n+pub enum Action<T=(), U=()> {\n+    Continue(T),\n+    Halt(U)\n }\n \n // the usage of + Send is weird here because what we really want is + Static\n // but that's not possible as of today. We have to use + Send for now.\n pub trait Middleware: Send + 'static + Sync {\n-    fn invoke<'a, 'b>(&'a self, _req: &mut Request<'b, 'a>, _res: &mut Response) -> MiddlewareResult {\n-        Ok(Continue)\n+    fn invoke<'a, 'b>(&'a self, _req: &mut Request<'b, 'a>, res: Response<'a, net::Fresh>) -> MiddlewareResult<'a> {\n+        Ok(Continue(res))\n     }\n }\n \n pub trait ErrorHandler: Send + 'static + Sync {\n-    fn invoke(&self, _err: &NickelError, _req: &mut Request, _res: &mut Response) -> MiddlewareResult {\n-        Ok(Continue)\n-    }\n+    fn handle_error(&self, &mut NickelError, &mut Request) -> Action;\n }\n \n-impl<R> ErrorHandler for fn(&NickelError, &Request, &mut Response) -> R\n-        where R: ResponseFinalizer {\n-    fn invoke(&self, err: &NickelError, req: &mut Request, res: &mut Response) -> MiddlewareResult {\n-        let r = (*self)(err, req, res);\n-        r.respond(res)\n+impl ErrorHandler for fn(&mut NickelError, &mut Request) -> Action {\n+    fn handle_error(&self, err: &mut NickelError, req: &mut Request) -> Action {\n+        (*self)(err, req)\n     }\n }\n \ndiff --git a/src/middleware.rs b/src/middleware.rs\n--- a/src/middleware.rs\n+++ b/src/middleware.rs\n@@ -48,33 +46,43 @@ impl MiddlewareStack {\n         self.error_handlers.push(Box::new(handler));\n     }\n \n-    pub fn invoke<'a, 'b>(&'a self, req: &mut Request<'b, 'a>, res: &mut Response) {\n+    pub fn invoke<'a>(&'a self, mut req: Request<'a, 'a>, mut res: Response<'a>) {\n         for handler in self.handlers.iter() {\n-            match handler.invoke(req, res) {\n-                Ok(Halt) => {\n-                    debug!(\"{:?} {:?} {:?} {:?}\",\n+            match handler.invoke(&mut req, res) {\n+                Ok(Halt(res)) => {\n+                    debug!(\"Halted {:?} {:?} {:?} {:?}\",\n                            req.origin.method,\n                            req.origin.remote_addr,\n-                           req.origin.request_uri,\n-                           res.origin.status);\n+                           req.origin.uri,\n+                           res.origin.status());\n+                    let _ = res.end();\n                     return\n                 }\n-                Ok(Continue) => {},\n+                Ok(Continue(fresh)) => res = fresh,\n                 Err(mut err) => {\n-                    warn!(\"{:?} {:?} {:?} {:?}\",\n+                    warn!(\"{:?} {:?} {:?} {:?} {:?} {:?}\",\n                           req.origin.method,\n                           req.origin.remote_addr,\n-                          req.origin.request_uri,\n-                          err.kind);\n+                          req.origin.uri,\n+                          err.kind,\n+                          err.message,\n+                          err.stream.as_ref().map(|s| s.origin.status()));\n+\n                     for error_handler in self.error_handlers.iter().rev() {\n-                        match error_handler.invoke(&err, req, res) {\n-                            Ok(Continue) => {},\n-                            Ok(Halt) => return,\n-                            // change the error so that other ErrorHandler\n-                            // down the stack receive the new error.\n-                            Err(new_err) => err = new_err,\n+                        if let Halt(()) = error_handler.handle_error(&mut err, &mut req) {\n+                            err.end();\n+                            return\n                         }\n                     }\n+\n+                    warn!(\"Unhandled error: {:?} {:?} {:?} {:?} {:?} {:?}\",\n+                          req.origin.method,\n+                          req.origin.remote_addr,\n+                          req.origin.uri,\n+                          err.kind,\n+                          err.message,\n+                          err.stream.map(|s| s.origin.status()));\n+                    return\n                 }\n             }\n         }\ndiff --git a/src/middleware_handler.rs b/src/middleware_handler.rs\n--- a/src/middleware_handler.rs\n+++ b/src/middleware_handler.rs\n@@ -12,45 +12,27 @@\n \n use request::Request;\n use response::Response;\n-use http::status;\n-use http::headers;\n+use hyper::status::StatusCode;\n use std::fmt::Display;\n use std::num::FromPrimitive;\n-use middleware::{Middleware, MiddlewareResult, Halt};\n+use hyper::header;\n+use hyper::net;\n+use middleware::{Middleware, MiddlewareResult, Halt, Continue};\n use serialize::json;\n use mimes::MediaType;\n+use std::io::Write;\n \n-impl<R> Middleware for fn(&Request, &mut Response) -> R\n-        where R: ResponseFinalizer {\n-    fn invoke<'a, 'b>(&self, req: &mut Request<'a, 'b>, res: &mut Response) -> MiddlewareResult {\n-        let r = (*self)(req, res);\n-        r.respond(res)\n+impl Middleware for for<'a> fn(&mut Request, Response<'a>) -> MiddlewareResult<'a> {\n+    fn invoke<'a, 'b>(&'a self, req: &mut Request<'b, 'a>, res: Response<'a>) -> MiddlewareResult<'a> {\n+        (*self)(req, res)\n     }\n }\n \n-impl<T, R> Middleware for (fn(&Request, &mut Response, &T) -> R, T)\n-        where T: Send + Sync + 'static, R: ResponseFinalizer + 'static {\n-    fn invoke<'a, 'b>(&self, req: &mut Request<'a, 'b>, res: &mut Response) -> MiddlewareResult {\n+impl<T> Middleware for (for <'a> fn(&mut Request, Response<'a>, &T) -> MiddlewareResult<'a>, T)\n+        where T: Send + Sync + 'static {\n+    fn invoke<'a, 'b>(&'a self, req: &mut Request<'b, 'a>, res: Response<'a>) -> MiddlewareResult<'a> {\n         let (f, ref data) = *self;\n-        let r = f(req, res, data);\n-        r.respond(res)\n-    }\n-}\n-\n-impl<R> Middleware for fn(&mut Request, &mut Response) -> R\n-        where R: ResponseFinalizer {\n-    fn invoke<'a, 'b>(&self, req: &mut Request<'a, 'b>, res: &mut Response) -> MiddlewareResult {\n-        let r = (*self)(req, res);\n-        r.respond(res)\n-    }\n-}\n-\n-impl<T, R> Middleware for (fn(&mut Request, &mut Response, &T) -> R, T)\n-        where T: Send + Sync + 'static, R: ResponseFinalizer + 'static {\n-    fn invoke<'a, 'b>(&self, req: &mut Request<'a, 'b>, res: &mut Response) -> MiddlewareResult {\n-        let (f, ref data) = *self;\n-        let r = f(req, res, data);\n-        r.respond(res)\n+        f(req, res, data)\n     }\n }\n \ndiff --git a/src/middleware_handler.rs b/src/middleware_handler.rs\n--- a/src/middleware_handler.rs\n+++ b/src/middleware_handler.rs\n@@ -59,53 +41,53 @@ impl<T, R> Middleware for (fn(&mut Request, &mut Response, &T) -> R, T)\n /// also modifying the `Response` as required.\n ///\n /// Please see the examples for some uses.\n-pub trait ResponseFinalizer {\n-    fn respond(self, &mut Response) -> MiddlewareResult;\n+pub trait ResponseFinalizer<T=net::Fresh> {\n+    fn respond<'a>(self, Response<'a, T>) -> MiddlewareResult<'a>;\n }\n \n impl ResponseFinalizer for () {\n-    fn respond(self, res: &mut Response) -> MiddlewareResult {\n-        maybe_set_type(res, MediaType::Html);\n-        Ok(Halt)\n+    fn respond<'a>(self, res: Response<'a>) -> MiddlewareResult<'a> {\n+        Ok(Continue(res))\n     }\n }\n \n-impl ResponseFinalizer for MiddlewareResult {\n-    fn respond(self, res: &mut Response) -> MiddlewareResult {\n-        maybe_set_type(res, MediaType::Html);\n-        self\n-    }\n-}\n+// This is impossible?\n+// impl<'a> ResponseFinalizer for MiddlewareResult<'a> {\n+//     fn respond<'a>(self, res: Response<'a>) -> MiddlewareResult<'a> {\n+//         maybe_set_type(&mut res, MediaType::Html);\n+//         self\n+//     }\n+// }\n \n impl ResponseFinalizer for json::Json {\n-    fn respond(self, res: &mut Response) -> MiddlewareResult {\n-        maybe_set_type(res, MediaType::Json);\n-        // FIXME: remove unwrap\n-        res.send(json::encode(&self).unwrap());\n-        Ok(Halt)\n+    fn respond<'a>(self, mut res: Response<'a>) -> MiddlewareResult<'a> {\n+        maybe_set_type(&mut res, MediaType::Json);\n+        let stream = try!(res.send(json::encode(&self).unwrap()));\n+        Ok(Halt(stream))\n     }\n }\n \n impl<'a, S: Display> ResponseFinalizer for &'a [S] {\n-    fn respond(self, res: &mut Response) -> MiddlewareResult {\n-        maybe_set_type(res, MediaType::Html);\n-        res.origin.status = status::Ok;\n+    fn respond<'c>(self, mut res: Response<'c>) -> MiddlewareResult<'c> {\n+        maybe_set_type(&mut res, MediaType::Html);\n+        res.status_code(StatusCode::Ok);\n+        let mut res = try!(res.start());\n         for ref s in self.iter() {\n-            // FIXME : failure unhandled\n-            let _ = write!(res.origin, \"{}\", s);\n+            // FIXME : This error handling is poor\n+            try!(res.write_fmt(format_args!(\"{}\", s)))\n         }\n-        Ok(Halt)\n+        Ok(Halt(res))\n     }\n }\n \n macro_rules! dual_impl {\n     ($view:ty, $alloc:ty, |$s:ident, $res:ident| $b:block) => (\n         impl<'a> ResponseFinalizer for $view {\n-            fn respond($s, $res: &mut Response) -> MiddlewareResult $b\n+            fn respond<'c>($s, mut $res: Response<'c>) -> MiddlewareResult<'c> $b\n         }\n \n         impl ResponseFinalizer for $alloc {\n-            fn respond($s, $res: &mut Response) -> MiddlewareResult $b\n+            fn respond<'c>($s, mut $res: Response<'c>) -> MiddlewareResult<'c> $b\n         }\n     )\n }\ndiff --git a/src/middleware_handler.rs b/src/middleware_handler.rs\n--- a/src/middleware_handler.rs\n+++ b/src/middleware_handler.rs\n@@ -113,54 +95,62 @@ macro_rules! dual_impl {\n dual_impl!(&'a str,\n            String,\n             |self, res| {\n-                maybe_set_type(res, MediaType::Html);\n-                res.origin.status = status::Ok;\n-                res.send(self);\n-                Ok(Halt)\n+                maybe_set_type(&mut res, MediaType::Html);\n+\n+                res.status_code(StatusCode::Ok);\n+                let stream = try!(res.send(self));\n+                Ok(Halt(stream))\n             });\n \n-dual_impl!((status::Status, &'a str),\n-           (status::Status, String),\n+dual_impl!((StatusCode, &'a str),\n+           (StatusCode, String),\n             |self, res| {\n-                maybe_set_type(res, MediaType::Html);\n+                maybe_set_type(&mut res, MediaType::Html);\n                 let (status, data) = self;\n-                res.origin.status = status;\n-                res.send(data);\n-                Ok(Halt)\n+\n+                res.status_code(status);\n+                let stream = try!(res.send(data));\n+                Ok(Halt(stream))\n             });\n \n dual_impl!((usize, &'a str),\n            (usize, String),\n            |self, res| {\n-                maybe_set_type(res, MediaType::Html);\n+                maybe_set_type(&mut res, MediaType::Html);\n                 let (status, data) = self;\n                 match FromPrimitive::from_uint(status) {\n                     Some(status) => {\n-                        res.origin.status = status;\n-                        res.send(data);\n-                        Ok(Halt)\n+                        res.status_code(status);\n+                        let stream = try!(res.send(data));\n+                        Ok(Halt(stream))\n                     }\n                     // This is a logic error\n                     None => panic!(\"Bad status code\")\n                 }\n             });\n \n-dual_impl!((status::Status, &'a str, Vec<headers::response::Header>),\n-           (status::Status, String, Vec<headers::response::Header>),\n-           |self, res| {\n-                let (status, data, headers) = self;\n-\n-                res.origin.status = status;\n-                for header in headers.into_iter() {\n-                    res.origin.headers.insert(header);\n-                }\n-                maybe_set_type(res, MediaType::Html);\n-                res.send(data);\n-                Ok(Halt)\n-            });\n+// FIXME: Hyper uses traits for headers, so this needs to be a Vec of\n+// trait objects. But, a trait object is unable to have Foo + Bar as a bound.\n+//\n+// A better/faster solution would be to impl this for tuples,\n+// where each tuple element implements the Header trait, which would give a\n+// static dispatch.\n+// dual_impl!((StatusCode, &'a str, Vec<Box<ResponseHeader>>),\n+//            (StatusCode, String, Vec<Box<ResponseHeader>>)\n+//            |self, res| {\n+//                 let (status, data, headers) = self;\n+\n+//                 res.origin.status = status;\n+//                 for header in headers.into_iter() {\n+//                     res.origin.headers_mut().set(header);\n+//                 }\n+//                 maybe_set_type(&mut res, MediaType::Html);\n+//                 res.send(data);\n+//                 Ok(Halt)\n+//             })\n \n fn maybe_set_type(res: &mut Response, ty: MediaType) {\n-    if res.origin.headers.content_type.is_none() {\n+    if res.origin.headers().has::<header::ContentType>() {\n         res.content_type(ty);\n     }\n }\ndiff --git a/src/mimes.rs b/src/mimes.rs\n--- a/src/mimes.rs\n+++ b/src/mimes.rs\n@@ -1,4 +1,4 @@\n-use http::headers::content_type;\n+use hyper::mime::Mime;\n use std::str::FromStr;\n \n macro_rules! mimes {\ndiff --git a/src/mimes.rs b/src/mimes.rs\n--- a/src/mimes.rs\n+++ b/src/mimes.rs\n@@ -13,19 +13,16 @@ macro_rules! mimes {\n             ),*\n         }\n \n-        pub fn get_media_type(ty: MediaType) -> content_type::MediaType {\n-            let (ty, subty) = match ty {\n+        // FIXME: Should be less runtime cost to this, hyper's Mime type looks\n+        // slightly more robust than old-http, so could probably just re-export\n+        // that and depreciate this.\n+        pub fn get_media_type(ty: MediaType) -> Mime {\n+            match ty {\n                 $(\n                     $(\n-                        MediaType::$name => ($t, $subt)\n+                        MediaType::$name => (concat!($t, \"/\", $subt)).parse().unwrap()\n                     ),*\n                 ),*\n-            };\n-\n-            content_type::MediaType {\n-                type_: ty.to_string(),\n-                subtype: subty.to_string(),\n-                parameters: vec![]\n             }\n         }\n \ndiff --git a/src/nickel.rs b/src/nickel.rs\n--- a/src/nickel.rs\n+++ b/src/nickel.rs\n@@ -1,14 +1,14 @@\n-use std::old_io::net::ip::{Port, IpAddr};\n-\n-use request::Request;\n-use response::Response;\n+use std::net::IpAddr;\n use router::{Router, HttpRouter};\n-use middleware::{MiddlewareResult, MiddlewareStack, Middleware, ErrorHandler};\n-use nickel_error::{ErrorWithStatusCode, NickelError};\n+use middleware::{MiddlewareStack, Middleware, ErrorHandler};\n use server::Server;\n+use hyper::method::Method;\n+use hyper::status::StatusCode;\n \n-use http::method::Method;\n-use http::status::NotFound;\n+// Re-exports so that we can use nickel_macros within nickel\n+// as they use the path `nickel::foo` which resolves to this module\n+// rather than an external crate.\n+pub use {MiddlewareResult, ResponseFinalizer, Request, Response};\n \n //pre defined middleware\n use default_error_handler::DefaultErrorHandler;\ndiff --git a/src/nickel.rs b/src/nickel.rs\n--- a/src/nickel.rs\n+++ b/src/nickel.rs\n@@ -51,18 +51,17 @@ impl Nickel {\n     /// down the stack should continue or if the middleware invocation should\n     /// be stopped after the current handler.\n     ///\n-    /// # Example\n-    ///\n+    /// # Examples\n     /// ```{rust}\n-    /// use nickel::{Nickel, Request, Response, Continue, MiddlewareResult};\n-    /// fn logger(req: &Request, res: &mut Response) -> MiddlewareResult {\n-    ///     println!(\"logging request: {}\", req.origin.request_uri);\n-    ///     Ok(Continue)\n-    /// }\n-    ///\n+    /// # extern crate nickel;\n+    /// # #[macro_use] extern crate nickel_macros;\n+    /// # fn main() {\n+    /// use nickel::Nickel;\n     /// let mut server = Nickel::new();\n-    /// let l: fn(&Request, &mut Response) -> MiddlewareResult = logger;\n-    /// server.utilize(l);\n+    /// server.utilize(middleware! { |req|\n+    ///     println!(\"logging request: {:?}\", req.origin.uri);\n+    /// });\n+    /// # }\n     /// ```\n     pub fn utilize<T: Middleware>(&mut self, handler: T){\n         self.middleware_stack.add_middleware(handler);\ndiff --git a/src/nickel.rs b/src/nickel.rs\n--- a/src/nickel.rs\n+++ b/src/nickel.rs\n@@ -74,33 +73,32 @@ impl Nickel {\n     /// A error handler is nearly identical to a regular middleware handler with the only\n     /// difference that it takes an additional error parameter or type `NickelError.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```{rust}\n-    /// # extern crate http;\n     /// # extern crate nickel;\n     /// # fn main() {\n-    /// use nickel::{Nickel, Request, Response, Continue, Halt, MiddlewareResult};\n-    /// use nickel::{NickelError, ErrorWithStatusCode};\n-    /// use http::status::NotFound;\n-    /// use nickel::mimes::MediaType::Html;\n+    /// use std::io::Write;\n+    /// use nickel::{Nickel, Request, Response, Continue, Halt};\n+    /// use nickel::{NickelError, ErrorWithStatusCode, Action};\n+    /// use nickel::status::StatusCode::NotFound;\n     ///\n-    /// fn error_handler(err: &NickelError, req: &Request, response: &mut Response)\n-    ///                  -> MiddlewareResult {\n+    /// fn error_handler(err: &mut NickelError, req: &mut Request) -> Action {\n     ///    match err.kind {\n     ///        ErrorWithStatusCode(NotFound) => {\n-    ///            response.content_type(Html);\n-    ///            response.origin.status = NotFound;\n-    ///            response.send(\"<h1>Call the police!<h1>\");\n-    ///            Ok(Halt)\n+    ///            if let Some(ref mut res) = err.stream {\n+    ///                let _ = res.write_all(b\"<h1>Call the police!</h1>\");\n+    ///            }\n+    ///            Halt(())\n+    ///\n     ///        },\n-    ///        _ => Ok(Continue)\n+    ///        _ => Continue(())\n     ///    }\n     /// }\n     ///\n     /// let mut server = Nickel::new();\n     ///\n-    /// let ehandler: fn(&NickelError, &Request, &mut Response) -> MiddlewareResult = error_handler;\n+    /// let ehandler: fn(&mut NickelError, &mut Request) -> Action = error_handler;\n     ///\n     /// server.handle_error(ehandler)\n     /// # }\ndiff --git a/src/nickel.rs b/src/nickel.rs\n--- a/src/nickel.rs\n+++ b/src/nickel.rs\n@@ -112,22 +110,22 @@ impl Nickel {\n     /// Create a new middleware to serve as a router.\n     ///\n     ///\n-    /// # Example\n+    /// # Examples\n     /// ```{rust}\n-    /// use nickel::{Nickel, Request, Response, HttpRouter};\n-    ///\n-    /// let mut server = Nickel::new();\n-    /// let mut router = Nickel::router();\n-    ///\n-    /// fn foo_handler(request: &Request, response: &mut Response) {\n-    ///     response.send(\"Hi from /foo\");\n-    /// };\n+    /// extern crate nickel;\n+    /// #[macro_use] extern crate nickel_macros;\n+    /// use nickel::{Nickel, HttpRouter};\n     ///\n-    /// let fhandler: fn(&Request, &mut Response) = foo_handler;\n+    /// fn main() {\n+    ///     let mut server = Nickel::new();\n+    ///     let mut router = Nickel::router();\n     ///\n-    /// router.get(\"/foo\", fhandler);\n+    ///     router.get(\"/foo\", middleware! {\n+    ///         \"Hi from /foo\"\n+    ///     });\n     ///\n-    /// server.utilize(router);\n+    ///     server.utilize(router);\n+    /// }\n     /// ```\n     pub fn router() -> Router {\n         Router::new()\ndiff --git a/src/nickel.rs b/src/nickel.rs\n--- a/src/nickel.rs\n+++ b/src/nickel.rs\n@@ -135,21 +133,18 @@ impl Nickel {\n \n     /// Bind and listen for connections on the given host and port\n     ///\n-    /// # Example\n+    /// # Examples\n     /// ```{rust,no_run}\n     /// use nickel::Nickel;\n-    /// use std::old_io::net::ip::IpAddr::Ipv4Addr;\n+    /// use std::net::IpAddr;\n     ///\n     /// let mut server = Nickel::new();\n-    /// server.listen(Ipv4Addr(127, 0, 0, 1), 6767);\n+    /// server.listen(IpAddr::new_v4(127, 0, 0, 1), 6767);\n     /// ```\n-    pub fn listen(mut self, ip: IpAddr, port: Port) {\n-        fn not_found_handler(_: &Request, _: &mut Response) -> MiddlewareResult {\n-            Err(NickelError::new(\"File Not Found\", ErrorWithStatusCode(NotFound)))\n-        }\n-\n-        let nfhandler: fn(&Request, &mut Response) -> MiddlewareResult = not_found_handler;\n-        self.middleware_stack.add_middleware(nfhandler);\n+    pub fn listen(mut self, ip: IpAddr, port: u16) {\n+        self.middleware_stack.add_middleware(middleware! {\n+            (StatusCode::NotFound, \"File Not Found\")\n+        });\n \n         match port {\n             80u16 =>  println!(\"Listening on http://{}\", ip),\ndiff --git a/src/nickel.rs b/src/nickel.rs\n--- a/src/nickel.rs\n+++ b/src/nickel.rs\n@@ -157,6 +152,6 @@ impl Nickel {\n         }\n         println!(\"Ctrl-C to shutdown server\");\n \n-        Server::new(self.middleware_stack, ip, port).serve();\n+        Server::new(self.middleware_stack).serve(ip, port);\n     }\n }\ndiff --git a/src/nickel_error.rs b/src/nickel_error.rs\n--- a/src/nickel_error.rs\n+++ b/src/nickel_error.rs\n@@ -1,36 +1,58 @@\n use std::borrow::{IntoCow, Cow};\n-use http::status::Status;\n+use hyper::status::StatusCode;\n+use std::error::FromError;\n+use std::io;\n+use response::Response;\n+use hyper::net::Streaming;\n \n pub use self::NickelErrorKind::{ErrorWithStatusCode, UserDefinedError, Other};\n \n /// NickelError is the basic error type for HTTP errors as well as user defined errors.\n /// One can pattern match against the `kind` property to handle the different cases.\n-\n-#[derive(Debug)]\n-pub struct NickelError {\n+pub struct NickelError<'a> {\n+    pub stream: Option<Response<'a, Streaming>>,\n     pub kind: NickelErrorKind,\n     pub message: Cow<'static, str>\n }\n \n-impl NickelError {\n+impl<'a> NickelError<'a> {\n     /// Creates a new `NickelError` instance\n     ///\n-    /// # Example\n-    /// ```{rust,ignore}\n-    /// NickelError::new(\"Error Parsing JSON\", ErrorWithStatusCode(BadRequest));\n+    /// # Examples\n+    /// ```{rust}\n+    /// use nickel::{NickelError, ErrorWithStatusCode};\n+    /// use nickel::status::StatusCode;\n+    /// NickelError::new(None,\n+    ///                  \"Error Parsing JSON\",\n+    ///                  ErrorWithStatusCode(StatusCode::BadRequest));\n     /// ```\n-    pub fn new<T: IntoCow<'static, str>>(message: T, kind: NickelErrorKind) -> NickelError {\n+    pub fn new<T>(stream: Option<Response<'a, Streaming>>,\n+                  message: T,\n+                  kind: NickelErrorKind) -> NickelError<'a>\n+            where T: IntoCow<'static, str> {\n         NickelError {\n+            stream: stream,\n             message: message.into_cow(),\n             kind: kind\n         }\n     }\n+\n+    pub fn end(self) -> Option<io::Result<()>> {\n+        self.stream.map(|s| s.end())\n+    }\n+}\n+\n+impl<'a> FromError<io::Error> for NickelError<'a> {\n+    fn from_error(err: io::Error) -> NickelError<'a> {\n+        NickelError::new(None,\n+                         err.description().to_string(),\n+                         ErrorWithStatusCode(StatusCode::InternalServerError))\n+    }\n }\n \n #[derive(Debug)]\n pub enum NickelErrorKind {\n-    // FIXME: Should probably re-export http::status::Status\n-    ErrorWithStatusCode(Status),\n+    ErrorWithStatusCode(StatusCode),\n     UserDefinedError(usize, String),\n     Other\n }\ndiff --git a/src/query_string.rs b/src/query_string.rs\n--- a/src/query_string.rs\n+++ b/src/query_string.rs\n@@ -2,8 +2,8 @@ use std::borrow::Cow;\n use std::collections::HashMap;\n use request::Request;\n use urlencoded;\n-use http::server::request::RequestUri;\n-use http::server::request::RequestUri::{Star, AbsoluteUri, AbsolutePath, Authority};\n+use hyper::uri::RequestUri;\n+use hyper::uri::RequestUri::{Star, AbsoluteUri, AbsolutePath, Authority};\n use url::UrlParser;\n use plugin::{Plugin, Pluggable};\n use typemap::Key;\ndiff --git a/src/query_string.rs b/src/query_string.rs\n--- a/src/query_string.rs\n+++ b/src/query_string.rs\n@@ -18,7 +18,7 @@ impl<'a, 'b> Plugin<Request<'a, 'b>> for QueryStringParser {\n     type Error = ();\n \n     fn eval(req: &mut Request) -> Result<QueryStore, ()> {\n-        Ok(parse(&req.origin.request_uri))\n+        Ok(parse(&req.origin.uri))\n     }\n }\n \ndiff --git a/src/query_string.rs b/src/query_string.rs\n--- a/src/query_string.rs\n+++ b/src/query_string.rs\n@@ -40,7 +40,7 @@ impl<'a, 'b> QueryString for Request<'a, 'b> {\n }\n \n fn parse(origin: &RequestUri) -> QueryStore {\n-    let f = |&: query: Option<&String>| query.map(|q| urlencoded::parse(&*q));\n+    let f = |query: Option<&String>| query.map(|q| urlencoded::parse(&*q));\n \n     let result = match *origin {\n         AbsoluteUri(ref url) => f(url.query.as_ref()),\ndiff --git a/src/request.rs b/src/request.rs\n--- a/src/request.rs\n+++ b/src/request.rs\n@@ -1,12 +1,12 @@\n-use http;\n use router::RouteResult;\n use plugin::{Extensible, Pluggable};\n use typemap::TypeMap;\n+use hyper::server::Request as HyperRequest;\n \n ///A container for all the request data\n pub struct Request<'a, 'b: 'a> {\n-    ///the original `http::server::Request`\n-    pub origin: &'a http::server::Request,\n+    ///the original `hyper::server::Request`\n+    pub origin: HyperRequest<'a>,\n     ///a `HashMap<String, String>` holding all params with names and values\n     pub route_result: Option<RouteResult<'b>>,\n \ndiff --git a/src/request.rs b/src/request.rs\n--- a/src/request.rs\n+++ b/src/request.rs\n@@ -14,7 +14,7 @@ pub struct Request<'a, 'b: 'a> {\n }\n \n impl<'a, 'b> Request<'a, 'b> {\n-    pub fn from_internal(req: &http::server::Request) -> Request {\n+    pub fn from_internal(req: HyperRequest<'a>) -> Request<'a, 'b> {\n         Request {\n             origin: req,\n             route_result: None,\ndiff --git a/src/response.rs b/src/response.rs\n--- a/src/response.rs\n+++ b/src/response.rs\n@@ -1,30 +1,35 @@\n use std::sync::RwLock;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::old_io::{IoResult, File};\n-use std::old_io::util::copy;\n use std::old_path::BytesContainer;\n+use std::path::Path;\n+use std::fmt::Debug;\n use serialize::Encodable;\n-use http;\n-use http::server::ResponseWriter;\n+use hyper::status::StatusCode;\n+use hyper::server::Response as HyperResponse;\n+use hyper::header;\n+use hyper::net::{Fresh, Streaming};\n use time;\n-use mimes;\n+use mimes::{get_media_type, MediaType};\n use mustache;\n use mustache::Template;\n+use std::io;\n+use std::io::{Read, Write, ErrorKind, copy};\n+use std::fs::File;\n \n pub type TemplateCache = RwLock<HashMap<&'static str, Template>>;\n \n ///A container for the response\n-pub struct Response<'a, 'b: 'a> {\n-    ///the original `http::server::ResponseWriter`\n-    pub origin: &'a mut ResponseWriter<'b>,\n+pub struct Response<'a, T=Fresh> {\n+    ///the original `hyper::server::Response`\n+    pub origin: HyperResponse<'a, T>,\n     templates: &'a TemplateCache\n }\n \n-impl<'a, 'b> Response<'a, 'b> {\n-    pub fn from_internal<'c, 'd>(response: &'c mut ResponseWriter<'d>,\n+impl<'a> Response<'a, Fresh> {\n+    pub fn from_internal<'c, 'd>(response: HyperResponse<'c, Fresh>,\n                                  templates: &'c TemplateCache)\n-                                -> Response<'c, 'd> {\n+                                -> Response<'c, Fresh> {\n         Response {\n             origin: response,\n             templates: templates\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -1,35 +1,32 @@\n-use http::method::{Method, Get, Post, Put, Delete};\n+use hyper::method::Method;\n use middleware::Middleware;\n \n pub trait HttpRouter {\n     /// Registers a handler to be used for a specified method.\n     /// A handler can be anything implementing the `RequestHandler` trait.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```{rust}\n+    /// extern crate hyper;\n     /// extern crate nickel;\n-    /// extern crate http;\n-    /// use nickel::{Nickel, Request, Response, HttpRouter};\n-    /// use http::method::{Get, Post, Put, Delete};\n+    /// #[macro_use] extern crate nickel_macros;\n+    ///\n+    /// use nickel::{Nickel, HttpRouter};\n+    /// use hyper::method::Method::{Get, Post, Put, Delete};\n     ///\n     /// fn main() {\n-    ///     fn read_handler(request: &Request, response: &mut Response) {\n-    ///         response.send(\"Get request!\");\n-    ///     };\n-    ///     fn modify_handler(request: &Request, response: &mut Response) {\n-    ///         response.send(format!(\"Method is: {}\", request.origin.method));\n+    ///     let read_handler = middleware! { \"Get request! \"};\n+    ///     let modify_handler = middleware! { |request|\n+    ///         format!(\"Method is: {}\", request.origin.method)\n     ///     };\n     ///\n     ///     let mut server = Nickel::new();\n     ///\n-    ///     let rhandler: fn(&Request, &mut Response) = read_handler;\n-    ///     server.add_route(Get, \"/foo\", rhandler);\n-    ///\n-    ///     let mhandler: fn(&Request, &mut Response) = modify_handler;\n-    ///     server.add_route(Post, \"/foo\", mhandler);\n-    ///     server.add_route(Put, \"/foo\", mhandler);\n-    ///     server.add_route(Delete, \"/foo\", mhandler);\n+    ///     server.add_route(Get, \"/foo\", read_handler);\n+    ///     server.add_route(Post, \"/foo\", modify_handler);\n+    ///     server.add_route(Put, \"/foo\", modify_handler);\n+    ///     server.add_route(Delete, \"/foo\", modify_handler);\n     /// }\n     /// ```\n     fn add_route<H: Middleware>(&mut self, Method, &str, H);\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -38,47 +35,40 @@ pub trait HttpRouter {\n     /// Handlers are assigned to paths and paths are allowed to contain\n     /// variables and wildcards.\n     ///\n-    /// A handler added through this API will\n-    /// be attached to the default router. Consider creating the router\n-    /// middleware manually for advanced functionality.\n+    /// A handler added through this API will be attached to the default router.\n+    /// Consider creating the router middleware manually for advanced functionality.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```{rust}\n+    /// extern crate nickel;\n+    /// #[macro_use] extern crate nickel_macros;\n     /// use nickel::{Nickel, Request, Response, HttpRouter};\n-    /// let mut server = Nickel::new();\n     ///\n-    /// //  without variables or wildcards\n-    /// fn bare_handler(request: &Request, response: &mut Response) {\n-    ///     response.send(\"This matches /user\");\n-    /// };\n-    /// let bhandler: fn(&Request, &mut Response) = bare_handler;\n-    /// server.get(\"/user\", bhandler);\n-    ///\n-    /// // with variables\n-    /// fn var_handler(request: &Request, response: &mut Response) {\n-    ///     let text = format!(\"This is user: {}\", request.param(\"userid\"));\n-    ///     response.send(text.as_slice());\n-    /// };\n-    /// let vhandler: fn(&Request, &mut Response) = var_handler;\n-    /// server.get(\"/user/:userid\", vhandler);\n-    ///\n-    /// // with simple wildcard\n-    /// fn wild_handler(request: &Request, response: &mut Response) {\n-    ///     response.send(\"This matches /user/list/4711 but not /user/extended/list/4711\");\n-    /// };\n-    /// let whandler: fn(&Request, &mut Response) = wild_handler;\n-    /// server.get(\"/user/*/:userid\", whandler);\n-    ///\n-    /// // with double wildcard\n-    /// fn very_wild_handler(request: &Request, response: &mut Response) {\n-    ///     response.send(\"This matches /user/list/4711 and also /user/extended/list/4711\");\n-    /// };\n-    /// let vwhandler: fn(&Request, &mut Response) = very_wild_handler;\n-    /// server.get(\"/user/**/:userid\", vwhandler);\n+    /// fn main() {\n+    ///     let mut server = Nickel::new();\n+    ///\n+    ///     //  without variables or wildcards\n+    ///     server.get(\"/user\", middleware! { \"This matches /user\" });\n+    ///\n+    ///     // with variables\n+    ///     server.get(\"/user/:userid\", middleware! { |request|\n+    ///         format!(\"This is user: {}\", request.param(\"userid\"))\n+    ///     });\n+    ///\n+    ///     // with simple wildcard\n+    ///     server.get(\"/user/*/:userid\", middleware! {\n+    ///         \"This matches /user/list/4711 but not /user/extended/list/4711\"\n+    ///     });\n+    ///\n+    ///     // with double wildcard\n+    ///     server.get(\"/user/**/:userid\", middleware! {\n+    ///         \"This matches /user/list/4711 and also /user/extended/list/4711\"\n+    ///     });\n+    /// }\n     /// ```\n     ///\n-    /// # Macro example\n+    /// # router! macro example\n     ///\n     /// ```{rust}\n     /// #![feature(plugin)]\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -90,22 +80,21 @@ pub trait HttpRouter {\n     ///     let router = router! {\n     ///         //  without variables or wildcards\n     ///         get \"/user\" => |request, response| {\n-    ///             response.send(\"This matches /user\");\n+    ///             \"This matches /user\";\n     ///         }\n     ///         // with variables\n     ///         get \"/user/:userid\" => |request, response| {\n-    ///             let text = format!(\"This is user: {}\", request.param(\"userid\"));\n-    ///             response.send(text.as_slice());\n+    ///             format!(\"This is user: {}\", request.param(\"userid\"))\n     ///         }\n     ///         // with simple wildcard\n     ///         get \"/user/*/:userid\" => |request, response| {\n-    ///             response.send(\"This matches /user/list/4711\");\n-    ///             response.send(\"NOT /user/extended/list/4711\");\n+    ///             [\"This matches /user/list/4711\",\n+    ///              \"NOT /user/extended/list/4711\"];\n     ///         }\n     ///         // with double wildcard\n     ///         get \"/user/**/:userid\" => |request, response| {\n-    ///             response.send(\"This matches /user/list/4711\");\n-    ///             response.send(\"AND /user/extended/list/4711\");\n+    ///             [\"This matches /user/list/4711\",\n+    ///              \"AND /user/extended/list/4711\"];\n     ///         }\n     ///     };\n     ///\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -114,7 +103,7 @@ pub trait HttpRouter {\n     /// }\n     /// ```\n     fn get<H: Middleware>(&mut self, uri: &str, handler: H) {\n-        self.add_route(Get, uri, handler);\n+        self.add_route(Method::Get, uri, handler);\n     }\n \n     /// Registers a handler to be used for a specific POST request.\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -122,20 +111,22 @@ pub trait HttpRouter {\n     /// Consider creating the router middleware manually for advanced functionality.\n     ///\n     /// Take a look at `get(...)` for a more detailed description.\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```{rust}\n-    /// use nickel::{Nickel, Request, Response, HttpRouter};\n-    /// fn handler(request: &Request, response: &mut Response) {\n-    ///     response.send(\"This matches a POST request to /a/post/request\");\n-    /// };\n+    /// # extern crate nickel;\n+    /// # #[macro_use] extern crate nickel_macros;\n+    /// # fn main() {\n+    /// use nickel::{Nickel, HttpRouter};\n     ///\n     /// let mut server = Nickel::new();\n-    /// let h: fn(&Request, &mut Response) = handler;\n-    /// server.post(\"/a/post/request\", h);\n+    /// server.post(\"/a/post/request\", middleware! {\n+    ///     \"This matches a POST request to /a/post/request\"\n+    /// });\n+    /// # }\n     /// ```\n     fn post<H: Middleware>(&mut self, uri: &str, handler: H) {\n-        self.add_route(Post, uri, handler);\n+        self.add_route(Method::Post, uri, handler);\n     }\n \n     /// Registers a handler to be used for a specific PUT request.\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -143,20 +134,22 @@ pub trait HttpRouter {\n     /// Consider creating the router middleware manually for advanced functionality.\n     ///\n     /// Take a look at `get(...)` for a more detailed description.\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```{rust}\n-    /// use nickel::{Nickel, Request, Response, HttpRouter};\n-    /// fn handler(request: &Request, response: &mut Response) {\n-    ///     response.send(\"This matches a POST request to /a/put/request\");\n-    /// };\n+    /// # extern crate nickel;\n+    /// # #[macro_use] extern crate nickel_macros;\n+    /// # fn main() {\n+    /// use nickel::{Nickel, HttpRouter};\n     ///\n     /// let mut server = Nickel::new();\n-    /// let h: fn(&Request, &mut Response) = handler;\n-    /// server.put(\"/a/put/request\", h);\n+    /// server.put(\"/a/put/request\", middleware! {\n+    ///     \"This matches a PUT request to /a/put/request\"\n+    /// });\n+    /// # }\n     /// ```\n     fn put<H: Middleware>(&mut self, uri: &str, handler: H) {\n-        self.add_route(Put, uri, handler);\n+        self.add_route(Method::Put, uri, handler);\n     }\n \n     /// Registers a handler to be used for a specific DELETE request.\ndiff --git a/src/router/http_router.rs b/src/router/http_router.rs\n--- a/src/router/http_router.rs\n+++ b/src/router/http_router.rs\n@@ -164,19 +157,20 @@ pub trait HttpRouter {\n     /// Consider creating the router middleware manually for advanced functionality.\n     ///\n     /// Take a look at `get(...)` for a more detailed description.\n-    /// # Example\n-    ///\n+    /// # Examples\n     /// ```{rust}\n-    /// use nickel::{Nickel, Request, Response, HttpRouter};\n-    /// fn handler(request: &Request, response: &mut Response) {\n-    ///     response.send(\"This matches a DELETE request to /a/delete/request\");\n-    /// };\n+    /// # extern crate nickel;\n+    /// # #[macro_use] extern crate nickel_macros;\n+    /// # fn main() {\n+    /// use nickel::{Nickel, HttpRouter};\n     ///\n     /// let mut server = Nickel::new();\n-    /// let h: fn(&Request, &mut Response) = handler;\n-    /// server.delete(\"/a/delete/request\", h);\n+    /// server.delete(\"/a/delete/request\", middleware! {\n+    ///     \"This matches a DELETE request to /a/delete/request\"\n+    /// });\n+    /// # }\n     /// ```\n     fn delete<H: Middleware>(&mut self, uri: &str, handler: H) {\n-        self.add_route(Delete, uri, handler);\n+        self.add_route(Method::Delete, uri, handler);\n     }\n }\ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -1,10 +1,11 @@\n use middleware::{Middleware, Continue, MiddlewareResult};\n use super::path_utils;\n-use http::server::request::RequestUri::AbsolutePath;\n+use hyper::uri::RequestUri::AbsolutePath;\n use request::Request;\n use response::Response;\n use router::HttpRouter;\n-use http::method::Method;\n+use hyper::method::Method;\n+use hyper::status::StatusCode;\n use regex::Regex;\n use std::collections::HashMap;\n \ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -88,21 +89,23 @@ impl HttpRouter for Router {\n }\n \n impl Middleware for Router {\n-    fn invoke<'a, 'b>(&'a self, req: &mut Request<'b, 'a>, res: &mut Response)\n-                        -> MiddlewareResult {\n-        match req.origin.request_uri {\n-            AbsolutePath(ref url) => {\n-                match self.match_route(&req.origin.method, &*url) {\n-                    Some(route_result) => {\n-                        res.origin.status = ::http::status::Ok;\n-                        let handler = &route_result.route.handler;\n-                        req.route_result = Some(route_result);\n-                        handler.invoke(req, res)\n-                    },\n-                    None => Ok(Continue)\n-                }\n+    fn invoke<'a, 'b>(&'a self, req: &mut Request<'b, 'a>, mut res: Response<'a>)\n+                        -> MiddlewareResult<'a> {\n+        debug!(\"Router::invoke for '{:?}'\", req.origin.uri);\n+        let route_result = match req.origin.uri {\n+            AbsolutePath(ref url) => self.match_route(&req.origin.method, &**url),\n+            _ => None\n+        };\n+        debug!(\"route_result.route.path: {:?}\", route_result.as_ref().map(|r| &*r.route.path));\n+\n+        match route_result {\n+            Some(route_result) => {\n+                res.status_code(StatusCode::Ok);\n+                let handler = &route_result.route.handler;\n+                req.route_result = Some(route_result);\n+                handler.invoke(req, res)\n             },\n-            _ => Ok(Continue)\n+            None => Ok(Continue(res))\n         }\n     }\n }\ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -195,21 +190,21 @@ fn can_match_var_routes () {\n     assert_eq!(route.variables.len(), 1);\n     assert_eq!(route.variables[\"userid\".to_string()], 0);\n \n-    let route_result = route_store.match_route(&method::Get, \"/bar/4711\");\n+    let route_result = route_store.match_route(&Method::Get, \"/bar/4711\");\n     assert!(route_result.is_none());\n \n-    let route_result = route_store.match_route(&method::Get, \"/foo\");\n+    let route_result = route_store.match_route(&Method::Get, \"/foo\");\n     assert!(route_result.is_none());\n \n     //ensure that this will work with commas too\n-    let route_result = route_store.match_route(&method::Get, \"/foo/123,456\");\n+    let route_result = route_store.match_route(&Method::Get, \"/foo/123,456\");\n     assert!(route_result.is_some());\n \n     let route_result = route_result.unwrap();\n     assert_eq!(route_result.param(\"userid\"), \"123,456\");\n \n     //ensure that this will work with spacing too\n-    let route_result = route_store.match_route(&method::Get, \"/foo/John%20Doe\");\n+    let route_result = route_store.match_route(&Method::Get, \"/foo/John%20Doe\");\n     assert!(route_result.is_some());\n \n     let route_result = route_result.unwrap();\ndiff --git a/src/server.rs b/src/server.rs\n--- a/src/server.rs\n+++ b/src/server.rs\n@@ -1,49 +1,39 @@\n-use std::old_io::net::ip::{SocketAddr, IpAddr, Port};\n+use std::net::IpAddr;\n use std::sync::{Arc, RwLock};\n use std::collections::HashMap;\n-\n-use http::server::{Config, Request, ResponseWriter};\n-use http::server::Server as HttpServer;\n+use hyper::server::{Request, Response, Handler};\n+use hyper::server::Server as HyperServer;\n \n use middleware::MiddlewareStack;\n use request;\n use response;\n-use mustache;\n \n pub struct Server {\n     middleware_stack: MiddlewareStack,\n-    ip: IpAddr,\n-    port: Port,\n     templates: response::TemplateCache\n }\n \n-impl HttpServer for Arc<Server> {\n-    fn get_config(&self) -> Config {\n-        Config { bind_address: SocketAddr { ip: self.ip, port: self.port } }\n-    }\n-\n-    fn handle_request(&self, req: Request, res: &mut ResponseWriter) {\n-\n-        let nickel_req = &mut request::Request::from_internal(&req);\n-        let nickel_res = &mut response::Response::from_internal(res, &self.templates);\n+impl Handler for Arc<Server> {\n+    fn handle<'a>(&'a self, req: Request<'a>, res: Response<'a>) {\n+        let nickel_req = request::Request::from_internal(req);\n+        let nickel_res = response::Response::from_internal(res, &self.templates);\n \n         self.middleware_stack.invoke(nickel_req, nickel_res);\n     }\n }\n \n impl Server {\n-    pub fn new(middleware_stack: MiddlewareStack, ip: IpAddr, port: Port) -> Server {\n+    pub fn new(middleware_stack: MiddlewareStack) -> Server {\n         Server {\n             middleware_stack: middleware_stack,\n-            ip: ip,\n-            port: port,\n-            templates: RwLock::new(HashMap::<&'static str, mustache::Template>::new())\n+            templates: RwLock::new(HashMap::new())\n         }\n     }\n \n-    // why do we need this? Is the http::Server.serve_forever method protected in C# terms?\n-    pub fn serve(self) {\n+    pub fn serve(self, ip: IpAddr, port: u16) {\n         let arc = Arc::new(self);\n-        arc.serve_forever();\n+        let server = HyperServer::http(arc);\n+        let _ = server.listen(ip, port);\n     }\n }\n+\ndiff --git a/src/static_files_handler.rs b/src/static_files_handler.rs\n--- a/src/static_files_handler.rs\n+++ b/src/static_files_handler.rs\n@@ -1,39 +1,25 @@\n-use std::old_io::{IoError, IoResult, FileNotFound};\n-use std::old_path::BytesContainer;\n+use std::path::{AsPath, PathBuf};\n+use std::fs::PathExt;\n \n-use http::server::request::RequestUri::AbsolutePath;\n-use http::method::{Get, Head};\n-use http::status::{ InternalServerError };\n+use hyper::uri::RequestUri::AbsolutePath;\n+use hyper::method::Method::{Get, Head};\n \n-use request;\n-use response;\n+use request::Request;\n+use response::Response;\n use middleware::{Halt, Continue, Middleware, MiddlewareResult};\n-use nickel_error::{ NickelError, ErrorWithStatusCode };\n \n // this should be much simpler after unboxed closures land in Rust.\n \n #[derive(Clone)]\n pub struct StaticFilesHandler {\n-    root_path: Path\n+    root_path: PathBuf\n }\n \n impl Middleware for StaticFilesHandler {\n-    fn invoke (&self, req: &mut request::Request, res: &mut response::Response)\n-               -> MiddlewareResult {\n+    fn invoke<'a>(&self, req: &mut Request, res: Response<'a>) -> MiddlewareResult<'a> {\n         match req.origin.method {\n-            Get | Head => {\n-                match self.with_file(self.extract_path(req), res) {\n-                    Ok(()) => Ok(Halt),\n-                    Err(err) => match err.kind {\n-                        // We shouldn't assume the StaticFileHandler to be the last middleware in the stack.\n-                        // Therefore it's important to continue in case of FileNotFound errors.\n-                        FileNotFound => Ok(Continue),\n-                        _ => Err(NickelError::new(format!(\"Unknown Error ({})\", err),\n-                                                  ErrorWithStatusCode(InternalServerError)))\n-                    }\n-                }\n-            },\n-            _ => Ok(Continue)\n+            Get | Head => self.with_file(self.extract_path(req), res),\n+            _ => Ok(Continue(res))\n         }\n     }\n }\ndiff --git a/src/static_files_handler.rs b/src/static_files_handler.rs\n--- a/src/static_files_handler.rs\n+++ b/src/static_files_handler.rs\n@@ -44,21 +30,21 @@ impl StaticFilesHandler {\n     /// the provided root directory.\n     ///\n     ///\n-    /// # Example\n+    /// # Examples\n     /// ```{rust}\n     /// use nickel::{Nickel, StaticFilesHandler};\n     /// let mut server = Nickel::new();\n     ///\n     /// server.utilize(StaticFilesHandler::new(\"/path/to/serve/\"));\n     /// ```\n-    pub fn new (root_path: &str) -> StaticFilesHandler {\n+    pub fn new<P: AsPath>(root_path: P) -> StaticFilesHandler {\n         StaticFilesHandler {\n-            root_path: Path::new(root_path)\n+            root_path: root_path.as_path().to_path_buf()\n         }\n     }\n \n-    fn extract_path<'a>(&self, req: &'a mut request::Request) -> Option<&'a str> {\n-        match req.origin.request_uri {\n+    fn extract_path<'a>(&self, req: &'a mut Request) -> Option<&'a str> {\n+        match req.origin.uri {\n             AbsolutePath(ref path) => {\n                 debug!(\"{:?} {:?}{:?}\", req.origin.method, self.root_path.display(), path);\n \ndiff --git a/src/static_files_handler.rs b/src/static_files_handler.rs\n--- a/src/static_files_handler.rs\n+++ b/src/static_files_handler.rs\n@@ -71,11 +57,17 @@ impl StaticFilesHandler {\n         }\n     }\n \n-    fn with_file<T: BytesContainer>(&self, relative_path: Option<T>, res: &mut response::Response)\n-                                    -> IoResult<()> {\n-        match relative_path {\n-            Some(path) => res.send_file(&self.root_path.join(path)),\n-            None => Err(IoError::last_error())\n-        }\n+    fn with_file<'a, 'b, P>(&self,\n+                            relative_path: Option<P>,\n+                            res: Response<'a>)\n+            -> MiddlewareResult<'a> where P: AsPath {\n+        if let Some(path) = relative_path {\n+            let path = self.root_path.join(path.as_path());\n+            if path.exists() {\n+                return Ok(Halt(try!(res.send_file(&path))));\n+            }\n+        };\n+\n+        Ok(Continue(res))\n     }\n }\n",
        "test_patch": "diff --git a/src/query_string.rs b/src/query_string.rs\n--- a/src/query_string.rs\n+++ b/src/query_string.rs\n@@ -59,7 +59,7 @@ fn parse(origin: &RequestUri) -> QueryStore {\n #[test]\n fn splits_and_parses_an_url() {\n     use url::Url;\n-    let t = |&: url|{\n+    let t = |url| {\n         let store = parse(&url);\n         assert_eq!(store[\"foo\".to_string()], vec![\"bar\".to_string()]);\n         assert_eq!(store[\"message\".to_string()],\ndiff --git a/src/response.rs b/src/response.rs\n--- a/src/response.rs\n+++ b/src/response.rs\n@@ -34,134 +39,187 @@ impl<'a, 'b> Response<'a, 'b> {\n     /// Sets the content type by it's short form.\n     /// Returns the response for chaining.\n     ///\n-    /// # Example\n+    /// # Examples\n     /// ```{rust}\n-    /// # use nickel::{Request, Response};\n+    /// use nickel::{Request, Response, MiddlewareResult, Continue};\n     /// use nickel::mimes::MediaType;\n-    /// fn handler(request: &Request, response: &mut Response) {\n-    ///     response.content_type(MediaType::Html);\n+    ///\n+    /// fn handler<'a>(_: &mut Request, mut res: Response<'a>) -> MiddlewareResult<'a> {\n+    ///     res.content_type(MediaType::Html);\n+    ///     Ok(Continue(res))\n     /// }\n     /// ```\n-    pub fn content_type(&mut self, mt: mimes::MediaType) -> &mut Response<'a,'b> {\n-        self.origin.headers.content_type = Some(mimes::get_media_type(mt));\n+    pub fn content_type(&mut self, mt: MediaType) -> &mut Response<'a> {\n+        self.origin.headers_mut().set(header::ContentType(get_media_type(mt)));\n         self\n     }\n \n     /// Sets the status code and returns the response for chaining\n     ///\n-    /// # Example\n+    /// # Examples\n     /// ```{rust}\n-    /// # extern crate http;\n-    /// # extern crate nickel;\n-    /// # use nickel::{Request, Response};\n-    /// # fn main() {\n-    /// fn handler(request: &Request, response: &mut Response) {\n-    ///     response.status_code(http::status::NotFound);\n+    /// use nickel::{Request, Response, MiddlewareResult, Continue};\n+    /// use nickel::status::StatusCode;\n+    ///\n+    /// fn handler<'a>(_: &mut Request, mut res: Response<'a>) -> MiddlewareResult<'a> {\n+    ///     res.status_code(StatusCode::NotFound);\n+    ///     Ok(Continue(res))\n     /// }\n-    /// # }\n     /// ```\n-    pub fn status_code(&mut self, status: http::status::Status) -> &mut Response<'a,'b> {\n-        self.origin.status = status;\n+    pub fn status_code(&mut self, status: StatusCode) -> &mut Response<'a> {\n+        *self.origin.status_mut() = status;\n         self\n     }\n \n     /// Writes a response\n     ///\n-    /// # Example\n+    /// # Examples\n     /// ```{rust}\n-    /// # use nickel::{Request, Response};\n-    /// fn handler(request: &Request, response: &mut Response) {\n-    ///     response.send(\"hello world\");\n+    /// use nickel::{Request, Response, MiddlewareResult, Halt};\n+    ///\n+    /// fn handler<'a>(_: &mut Request, res: Response<'a>) -> MiddlewareResult<'a> {\n+    ///     Ok(Halt(try!(res.send(\"hello world\"))))\n     /// }\n     /// ```\n-    pub fn send<T: BytesContainer> (&mut self, text: T) {\n-        // TODO: This needs to be more sophisticated to return the correct headers\n-        // not just \"some headers\" :)\n-        Response::set_headers(self.origin);\n-        let _ = self.origin.write_all(text.container_as_bytes());\n-    }\n+    pub fn send<T: BytesContainer> (mut self, text: T) -> io::Result<Response<'a, Streaming>> {\n+        self.set_common_headers();\n \n-    fn set_headers(response_writer: &mut http::server::ResponseWriter) {\n-        let ref mut headers = response_writer.headers;\n-        headers.date = Some(time::now_utc());\n-\n-        // we don't need to set this https://github.com/Ogeon/rustful/issues/3#issuecomment-44787613\n-        headers.content_length = None;\n-\n-        headers.server = Some(String::from_str(\"Nickel\"));\n+        let mut stream = try!(self.start());\n+        try!(stream.write_all(text.container_as_bytes()));\n+        Ok(stream)\n     }\n \n     /// Writes a file to the output.\n     ///\n-    /// # Example\n+    /// # Examples\n     /// ```{rust}\n-    /// # use nickel::{Request, Response};\n-    /// fn handler(request: &Request, response: &mut Response) {\n+    /// use nickel::{Request, Response, MiddlewareResult, Halt};\n+    /// use nickel::status::StatusCode;\n+    /// use std::path::Path;\n+    ///\n+    /// fn handler<'a>(_: &mut Request, mut res: Response<'a>) -> MiddlewareResult<'a> {\n     ///     let favicon = Path::new(\"/assets/favicon.ico\");\n-    ///     response.send_file(&favicon).ok().expect(\"Failed to send favicon\");\n+    ///     Ok(Halt(try!(res.send_file(favicon))))\n     /// }\n     /// ```\n-    pub fn send_file(&mut self, path: &Path) -> IoResult<()> {\n+    pub fn send_file(mut self, path: &Path) -> io::Result<Response<'a, Streaming>> {\n+        // Chunk the response\n+        self.origin.headers_mut().remove::<header::ContentLength>();\n+        // Determine content type by file extension or default to binary\n+        self.content_type(path.extension()\n+                              .and_then(|os| os.to_str())\n+                              .and_then(|s| s.parse().ok())\n+                              .unwrap_or(MediaType::Bin));\n+\n+        let mut stream = try!(self.start());\n         let mut file = try!(File::open(path));\n-        self.origin.headers.content_length = None;\n+        try!(copy(&mut file, &mut stream));\n+        Ok(stream)\n+    }\n \n-        self.origin.headers.content_type = path.extension_str()\n-                                               .and_then(|s| s.parse().ok())\n-                                               .map(mimes::get_media_type);\n-        self.origin.headers.server = Some(String::from_str(\"Nickel\"));\n-        copy(&mut file, self.origin)\n+    // TODO: This needs to be more sophisticated to return the correct headers\n+    // not just \"some headers\" :)\n+    //\n+    // Also, it should only set them if not already set.\n+    fn set_common_headers(&mut self) {\n+        let ref mut headers = self.origin.headers_mut();\n+        headers.set(header::Date(time::now_utc()));\n+        headers.set(header::Server(String::from_str(\"Nickel\")));\n     }\n \n     /// Renders the given template bound with the given data.\n     ///\n-    /// # Example\n+    /// # Examples\n     /// ```{rust}\n-    /// # use nickel::{Request, Response};\n-    /// # use std::collections::HashMap;\n-    /// fn handler(request: &Request, response: &mut Response) {\n+    /// use std::collections::HashMap;\n+    /// use nickel::{Request, Response, MiddlewareResult, Halt};\n+    ///\n+    /// fn handler<'a>(_: &mut Request, mut res: Response<'a>) -> MiddlewareResult<'a> {\n     ///     let mut data = HashMap::new();\n     ///     data.insert(\"name\", \"user\");\n-    ///     response.render(\"examples/assets/template.tpl\", &data);\n+    ///     let stream = try!(res.render(\"examples/assets/template.tpl\", &data));\n+    ///     Ok(Halt(stream))\n     /// }\n     /// ```\n-    pub fn render<'c, T: Encodable>\n-        (&mut self, path: &'static str, data: &T) {\n-            // Fast path doesn't need writer lock\n-            {\n-                let templates = self.templates.read().unwrap();\n-                if let Some(t) = templates.get(&path) {\n-                    let _ = t.render(self.origin, data);\n-                    return\n-                }\n-            }\n-\n-            // We didn't find the template, get writers lock and\n-            let mut templates = self.templates.write().unwrap();\n-            // search again incase there was a race to compile the template\n-            let template = match templates.entry(path) {\n-                Vacant(entry) => {\n-                    let mut file = File::open(&Path::new(path));\n-                    let raw_template = file.read_to_string()\n-                                           .ok()\n-                                           .expect(&*format!(\"Couldn't open the template file: {}\",\n-                                                            path));\n-                    entry.insert(mustache::compile_str(&*raw_template))\n-                },\n-                Occupied(entry) => entry.into_mut()\n-            };\n-\n-            let _ = template.render(self.origin, data);\n+    pub fn render<T>(self, path: &'static str, data: &T)\n+            -> io::Result<Response<'a, Streaming>>\n+            where T: Encodable {\n+        fn to_ioerr<U: Debug>(r: Result<(), U>) -> io::Result<()> {\n+            r.map_err(|e| io::Error::new(ErrorKind::Other,\n+                                         \"Problem rendering template\",\n+                                         Some(format!(\"{:?}\", e))))\n+        }\n+\n+        // Fast path doesn't need writer lock\n+        if let Some(t) = self.templates.read().unwrap().get(&path) {\n+            let mut stream = try!(self.start());\n+            try!(to_ioerr(t.render(&mut stream, data)));\n+            return Ok(stream);\n+        }\n+\n+        // We didn't find the template, get writers lock\n+        let mut templates = self.templates.write().unwrap();\n+        // Search again incase there was a race to compile the template\n+        let template = match templates.entry(path) {\n+            Vacant(entry) => {\n+                let mut file = File::open(&Path::new(path))\n+                                     .ok().expect(&*format!(\"Couldn't open the template file: {}\", path));\n+                let mut raw_template = String::new();\n+\n+                file.read_to_string(&mut raw_template)\n+                    .ok().expect(&*format!(\"Couldn't open the template file: {}\", path));\n+\n+                entry.insert(mustache::compile_str(&*raw_template))\n+            },\n+            Occupied(entry) => entry.into_mut()\n+        };\n+\n+        let mut stream = try!(self.start());\n+        try!(to_ioerr(template.render(&mut stream, data)));\n+        Ok(stream)\n+    }\n+\n+    pub fn start(mut self) -> io::Result<Response<'a, Streaming>> {\n+        self.set_common_headers();\n+\n+        let Response { origin, templates } = self;\n+        let origin = try!(origin.start());\n+\n+        Ok(Response { origin: origin, templates: templates })\n+    }\n+}\n+\n+impl<'a, 'b> Write for Response<'a, Streaming> {\n+    #[inline(always)]\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.origin.write(buf)\n+    }\n+    #[inline(always)]\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.origin.flush()\n+    }\n+}\n+\n+impl<'a, 'b> Response<'a, Streaming> {\n+    /// Flushes all writing of a response to the client.\n+    pub fn end(self) -> io::Result<()> {\n+        self.origin.end()\n     }\n }\n \n #[test]\n fn matches_content_type () {\n+    use hyper::mime::{Mime, TopLevel, SubLevel};\n     let path = &Path::new(\"test.txt\");\n-    let content_type = path.extension_str().and_then(|s| s.parse().ok());\n+    let content_type = path.extension()\n+                           .and_then(|os| os.to_str())\n+                           .and_then(|s| s.parse().ok());\n \n-    assert_eq!(content_type, Some(mimes::MediaType::Txt));\n-    let content_type = content_type.map(mimes::get_media_type).unwrap();\n+    assert_eq!(content_type, Some(MediaType::Txt));\n+    let content_type = content_type.map(get_media_type).unwrap();\n \n-    assert_eq!(content_type.type_, \"text\");\n-    assert_eq!(content_type.subtype, \"plain\");\n+    match content_type {\n+        Mime(TopLevel::Text, SubLevel::Plain, _) => {}, // OK\n+        wrong => panic!(\"Wrong mime: {}\", wrong)\n+    }\n }\ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -170,23 +173,15 @@ fn creates_valid_regex_for_routes () {\n \n #[test]\n fn can_match_var_routes () {\n-    use http::method;\n-    use request::Request;\n-    use response::Response;\n+    use hyper::method::Method;\n \n     let route_store = &mut Router::new();\n+    let handler = middleware! { \"hello from foo\" };\n \n-    fn handler (_request: &Request, response: &mut Response) -> () {\n-        let _ = response.origin.write_all(\"hello from foo\".as_bytes());\n-    };\n-\n-    // issue #20178\n-    let handler_cast: fn(&Request, &mut Response) = handler;\n-\n-    route_store.add_route(method::Get, \"/foo/:userid\", handler_cast);\n-    route_store.add_route(method::Get, \"/bar\", handler_cast);\n+    route_store.add_route(Method::Get, \"/foo/:userid\", handler);\n+    route_store.add_route(Method::Get, \"/bar\", handler);\n \n-    let route_result = route_store.match_route(&method::Get, \"/foo/4711\").unwrap();\n+    let route_result = route_store.match_route(&Method::Get, \"/foo/4711\").unwrap();\n     let route = route_result.route;\n \n     assert_eq!(route_result.param(\"userid\"), \"4711\");\n",
        "problem_statement": "Response#send should handle state\nCurrently multiple calls to send are allowed, but each call will try to set headers again. We should probably give Response a state, so we know if the headers have been written or not. We can additionally use this information in the finalizers, if nothing has been written to the response then we can add some additional headers like `Content-Length` if it's simple to calculate the length.\n\nHow we handle this would also affect things like `res.content_type(..)` since we shouldn't really allow the user to modify headers after already trying to send data. For example, it is a bug for a user to `send` and then call `status_code`, we should help them catch this and not have to debug through curl.\n\nWe could achieve this through the type system via Phantom types, meaning no runtime cost, but it will make current finalizers pretty broken. _But_, I think we can probably just have it so that `RequestHandler`s don't have a response as their input for simple cases which would make it less of a problem.\n\ne.g. This would be a `200 OK` with a content length automatically set\n\n```\nfn handler(req: &Request) -> String {\n    format!(\"{}\", req.param(\"something\"))\n}\n```\n\nI think this could actually make things somewhat easier to test for users too. (change &Request to some Request trait)\n\nThe full handler form should still be available for whenever a response needs to be progressively generated and chunked to the client.\n\nIf we chose to manage state at runtime we could still do the above, the only question is what to do if a user calls something they shouldn't do after a `send`, do we fail? print a warning? just no-op?\n\nAn alternative could be to add a lint that helps find method calls (other than send) on a response after a send has been performed.\n\n",
        "hints_text": "> But, I think we can probably just have it so that RequestHandlers don't have a response as their input for simple cases which would make it less of a problem.\n\nNot a huge fan, can't exactly tell why though. I think I don't like the idea of hiding the `Response` from the user to \"help\" him. I like the idea of making the user aware of his mistake if he calls such a method after sending though.\n\n> If we chose to manage state at runtime \n\nYep, I think that would be better. It shouldn't have a huge cost, should it? I mean it's basically only a boolean to remember that we already called `send`, no?\n\n> do we fail\n\nIt's a tough thing to decide. My initial reaction was: Sure, let's just fail. It's a fixable bug so let's make the developer aware of it. But on the other hand what if the developer only calls `res.content_type(...)` wrongly when a special condition is true. Like `user_stars > 1000`. Then he might not know about it during development and runs into a `fail` in production (assuming no tests caught it either). Not sure if that feels right to me. We would let a task fail that could have ran just perfectly fine (except the `content_type(...)` call not having a real effect).\n\nSo in general, I like the idea of making him aware but a `fail` might be too strict. I guess we should just go with a warning.\n\n@cburgdorf \n\n> Not a huge fan, can't exactly tell why though. I think I don't like the idea of hiding the Response from the user to \"help\" him. I like the idea of making the user aware of his mistake if he calls such a method after sending though.\n\nFrom what I understood we wouldn't hide it though, would we? The user could still choose to use the same `RequestHandler` signature as today.\n\n> Yep, I think that would be better. It shouldn't have a huge cost, should it? I mean it's basically only a boolean to remember that we already called send, no?\n\nIt means an extra branch for every call to a method in `Response`. I wouldn't be so sure that it's an insignificant performance drop to be honest. Some compilers have this thing where you can tell it at compile time that one branch is very likely and to optimize for that branch. If rustc has an option like that the performance hit would mostly be for the wrong programs, I don't think it has though.\n\n@Ryman \n\n> The full handler form should still be available for whenever a response needs to be progressively generated and chunked to the client.\n\nAnd if I choose to use the full handler form, there's no safety? The current behaviour stays? \n\n@Ryman  and @cburgdorf \nIn general, my opinion is that we should try to catch as many errors as possible at runtime. It must be better to stop bugs at compile time then to do a whole lot of testing to find out if every edge case works.\n\nI also think that the ability to leave out a parameter in the `RequestHandler` seems pretty neat. Would it be possible to leave out `Request` too? We might be able to use that for #79 too, so that a handler signature can be one of six possible combinations, depending on what data the handler needs.\n\n> From what I understood we wouldn't hide it though, would we? The user could still choose to use the same RequestHandler signature as today.\n\nWell, yes. Strictly speaking the user could still reach for the \"traditional\" handler signature with both parameters. But this also means you can't fully protect them that way. I mean will anyone ever say _\"hey, I'll leave of `Response` here in order to prevent me from making that mistake\"_. You need to have the full power anyway in some cases so I don't know if leaving of the `Request` parameter will become really popular among users. I'm not sure is this extra flexibility/complexity is worth the effort?\n\nI'm not strongly against it. If you think it's a good idea and worth the effort/complexity I may just have to give it a try :)\n\n> It means an extra branch for every call to a method in `Response`\n\nI know but this is just a simple boolean comparison and we aren't in a loop or something. I guess you could see a difference if you sum up the times of 100.000 requests with that feature and without it but would it really make a difference for a single request? I certainly don't know it but it feels negligible to me.   \n\n> I mean will anyone ever say \"hey, I'll leave of Response here in order to prevent me from making that mistake\". You need to have the full power anyway in some cases\n\nI like the concept of an 'escape hatch' in Rust, where one provides a simple thing wrapping a more complicated thing with access to handle special cases. We can provide both, and I think people with simple requirements will often opt for a nicer signature rather than prefixing their args with `_` to remove compiler warnings.\n\nAlso I do think people care about syntax and such, we already have an issue on the use of `utilize` over `use`? So I'd imagine there'll be an issue in future about wanting to leave off Response when it's untouched and handled by finalizers. May aswell nip it in the bud while we're thinking of this? \n\n> And if I choose to use the full handler form, there's no safety? The current behaviour stays?\n\nYeah, but after thinking more about this, I think we can have safety here, but at some complexity :)\n\nIf we required `Response#send` and similar methods to `move` the response, then we can do the following:\n- `fn x(&Request) -> Finalizer` - the user can do simple/common things easily and we can do certain optimizations based on the types\n-  `fn x(&Request, &mut Response) -> Finalizer` - the user can use a lot of convenience methods but cannot initiate any sends as it would move the response.\n-  `fn x(&Request, Response) -> StreamingResponse` - the user has full control as long as they return the moved response (moved into hypothetical `StreamingResponse` type which doesnt allow touching the headers).\n\nI'm pretty sure that the above is possible, and I think it's not too complicated for a user if the documentation is nice. I just wonder about how much things like this affect compile time.\n\n> It means an extra branch for every call to a method in Response\n> \n> I know but this is just a simple boolean comparison and we aren't in a loop or something. I guess you could see a difference if you sum up the times of 100.000 requests with that feature and without it but would it really make a difference for a single request? I certainly don't know it but it feels negligible to me.\n\nI'm with @cburgdorf here, its like 5ns and outside of a loop, so I wouldn't be too worried about it although if we can get the safety in the above working then we will skip the cost I guess :)\n\n> We can provide both, and I think people with simple requirements will often opt for a nicer signature rather than prefixing their args with _ to remove compiler warnings\n\nWell, yes. It's a bit like what we do already with the return values of our handlers which can look different depending on the use case.\n\n> If we required Response#send and similar methods to move the response\n\nI had this thought, too :)\n\n> I'm pretty sure that the above is possible, and I think it's not too complicated for a user if the documentation is nice\n\nWell, we can try it out and see how it goes. I guess, I would probably just not reach for the extra complexity \"just\" for the small benefit of preventing the user from something not too dramatic. But then, that might be just me :)\n",
        "created_at": "2015-02-27T18:40:58Z",
        "version": "0.1"
    },
    {
        "repo": "nickel-org/nickel.rs",
        "pull_number": 317,
        "instance_id": "nickel-org__nickel.rs-317",
        "issue_numbers": [
            "306"
        ],
        "base_commit": "1964b16bf4b20f82f1390534228508868b94bd7c",
        "patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -51,6 +51,11 @@ path = \"examples/routing.rs\"\n \n [[example]]\n \n+name = \"enable_cors\"\n+path = \"examples/enable_cors.rs\"\n+\n+[[example]]\n+\n name = \"template\"\n path = \"examples/template.rs\"\n \ndiff --git /dev/null b/examples/enable_cors.rs\nnew file mode 100644\n--- /dev/null\n+++ b/examples/enable_cors.rs\n@@ -0,0 +1,29 @@\n+#[macro_use] extern crate nickel;\n+extern crate hyper;\n+\n+use nickel::{Nickel, HttpRouter, Request, Response, MiddlewareResult};\n+use hyper::header::{AccessControlAllowOrigin, AccessControlAllowHeaders};\n+\n+fn enable_cors<'mw>(_req: &mut Request, mut res: Response<'mw>) -> MiddlewareResult<'mw> {\n+    // Set appropriate headers\n+    res.set(AccessControlAllowOrigin::Any);\n+    res.set(AccessControlAllowHeaders(vec![\n+        // Hyper uses the `unicase::Unicase` type to ensure comparisons are done\n+        // case-insensitively. Here, we use `into()` to convert to one from a `&str`\n+        // so that we don't have to import the type ourselves.\n+        \"Origin\".into(),\n+        \"X-Requested-With\".into(),\n+        \"Content-Type\".into(),\n+        \"Accept\".into(),\n+    ]));\n+\n+    // Pass control to the next middleware\n+    res.next_middleware()\n+}\n+\n+fn main() {\n+    let mut server = Nickel::new();\n+    server.utilize(enable_cors);\n+    server.get(\"**\", middleware!(\"Hello CORS Enabled World\"));\n+    server.listen(\"127.0.0.1:6767\");\n+}\n",
        "test_patch": "diff --git a/tests/example_tests.rs b/tests/example_tests.rs\n--- a/tests/example_tests.rs\n+++ b/tests/example_tests.rs\n@@ -1,5 +1,6 @@\n extern crate rustc_serialize;\n extern crate hyper;\n+\n #[macro_use] extern crate lazy_static;\n \n mod util;\ndiff --git a/tests/example_tests.rs b/tests/example_tests.rs\n--- a/tests/example_tests.rs\n+++ b/tests/example_tests.rs\n@@ -17,6 +18,7 @@ mod examples {\n     mod regex_route;\n     mod custom_error_handler;\n     mod static_files;\n+    mod enable_cors;\n \n     #[cfg(feature = \"ssl\")]\n     mod https;\ndiff --git /dev/null b/tests/examples/enable_cors.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/examples/enable_cors.rs\n@@ -0,0 +1,35 @@\n+use hyper::method::Method;\n+use hyper::header::{AccessControlAllowOrigin, AccessControlAllowHeaders};\n+\n+use util::{run_example, response_for_method, read_body_to_string};\n+\n+#[test]\n+fn sets_headers() {\n+     run_example(\"enable_cors\", |port| {\n+        let paths = [\"\", \"foo\", \"bar.html\", \"foo-barrrr/baz\"];\n+\n+        for path in &paths {\n+            let url = format!(\"http://localhost:{}/{}\", port, path);\n+            let mut res = response_for_method(Method::Get, &url);\n+\n+            assert_eq!(\n+                res.headers.get(),\n+                Some(&AccessControlAllowOrigin::Any)\n+            );\n+\n+            assert_eq!(\n+                res.headers.get(),\n+                Some(&AccessControlAllowHeaders(vec![\n+                    \"Origin\".into(),\n+                    \"X-Requested-With\".into(),\n+                    \"Content-Type\".into(),\n+                    \"Accept\".into(),\n+                ]))\n+            );\n+\n+\n+            let body = read_body_to_string(&mut res);\n+            assert_eq!(body, \"Hello CORS Enabled World\");\n+        }\n+    })\n+}\n",
        "problem_statement": "provide cors example\nIt would be nice to have an example for CORS:\n\nhttp://enable-cors.org/server_expressjs.html\n\n",
        "hints_text": "+1\n",
        "created_at": "2016-03-17T01:19:40Z",
        "version": "0.7"
    },
    {
        "repo": "nickel-org/nickel.rs",
        "pull_number": 332,
        "instance_id": "nickel-org__nickel.rs-332",
        "issue_numbers": [
            "329"
        ],
        "base_commit": "6027326616cb0145efab96b4b90818988275a0f8",
        "patch": "diff --git a/examples/form_data/form_data.rs b/examples/form_data/form_data.rs\n--- a/examples/form_data/form_data.rs\n+++ b/examples/form_data/form_data.rs\n@@ -1,7 +1,6 @@\n #[macro_use] extern crate nickel;\n-use nickel::{Nickel, HttpRouter};\n+use nickel::{Nickel, HttpRouter, FormBody};\n use std::collections::HashMap;\n-use std::io::Read;\n \n fn main() {\n     let mut server = Nickel::new();\ndiff --git a/examples/form_data/form_data.rs b/examples/form_data/form_data.rs\n--- a/examples/form_data/form_data.rs\n+++ b/examples/form_data/form_data.rs\n@@ -14,15 +13,16 @@ fn main() {\n     });\n \n     server.post(\"/confirmation\", middleware!{ |req, res|\n-        let mut form_data = String::new();\n-        req.origin.read_to_string(&mut form_data).unwrap();\n+        let form_data = try_with!(res, req.form_body());\n \n-        println!(\"{}\", form_data);\n+        println!(\"{:?}\", form_data);\n \n         let mut data = HashMap::new();\n         data.insert(\"title\", \"Confirmation\");\n-        data.insert(\"formData\", &form_data);\n-\n+        data.insert(\"firstname\", form_data.get(\"firstname\").unwrap_or(\"First name?\"));\n+        data.insert(\"lastname\", form_data.get(\"lastname\").unwrap_or(\"Last name?\"));\n+        data.insert(\"phone\", form_data.get(\"phone\").unwrap_or(\"Phone?\"));\n+        data.insert(\"email\", form_data.get(\"email\").unwrap_or(\"Email?\"));\n         return res.render(\"examples/form_data/views/confirmation.html\", &data)\n     });\n \ndiff --git a/examples/form_data/views/confirmation.html b/examples/form_data/views/confirmation.html\n--- a/examples/form_data/views/confirmation.html\n+++ b/examples/form_data/views/confirmation.html\n@@ -1,7 +1,11 @@\n+<!DOCTYPE html>\n+<html>\n <head>\n     <meta http-equiv=\"Content-Type\" content=\"text/html\">\n     <title>{{title}}</title>\n </head>\n <body>\n-      <h1>{{formData}}</h1>\n+    <h1>{{title}}</h1>\n+    <p>{{firstname}} {{lastname}} {{phone}} {{email}}</p>\n </body>\n+</html>\ndiff --git a/examples/form_data/views/contact.html b/examples/form_data/views/contact.html\n--- a/examples/form_data/views/contact.html\n+++ b/examples/form_data/views/contact.html\n@@ -1,3 +1,5 @@\n+<!DOCTYPE html>\n+<html>\n <head>\n     <meta http-equiv=\"Content-Type\" content=\"text/html\">\n     <title>{{title}}</title>\ndiff --git a/examples/form_data/views/contact.html b/examples/form_data/views/contact.html\n--- a/examples/form_data/views/contact.html\n+++ b/examples/form_data/views/contact.html\n@@ -11,3 +13,4 @@\n             <button type=\"submit\" formenctype=\"application/x-www-form-urlencoded\" formaction=\"/confirmation\" formmethod=\"post\">SEND</button>\n       </form>\n </body>\n+</html>\ndiff --git /dev/null b/src/body_parser.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/body_parser.rs\n@@ -0,0 +1,127 @@\n+use hyper::header::ContentType;\n+use hyper::mime::{Mime, SubLevel, TopLevel};\n+use serialize::{Decodable, json};\n+use request::Request;\n+use plugin::{Plugin, Pluggable};\n+use status::StatusCode;\n+use std::error::Error as StdError;\n+use std::fmt;\n+use std::io::{self, ErrorKind, Read};\n+use typemap::Key;\n+use urlencoded::{self, Params};\n+\n+struct BodyReader;\n+\n+impl Key for BodyReader {\n+    type Value = String;\n+}\n+\n+impl<'mw, 'conn, D> Plugin<Request<'mw, 'conn, D>> for BodyReader {\n+    type Error = io::Error;\n+\n+    fn eval(req: &mut Request<D>) -> Result<String, io::Error> {\n+        let mut buf = String::new();\n+        try!(req.origin.read_to_string(&mut buf));\n+        Ok(buf)\n+    }\n+}\n+\n+struct FormBodyParser;\n+\n+impl Key for FormBodyParser {\n+    type Value = Params;\n+}\n+\n+impl<'mw, 'conn, D> Plugin<Request<'mw, 'conn, D>> for FormBodyParser {\n+    type Error = BodyError;\n+\n+    fn eval(req: &mut Request<D>) -> Result<Params, BodyError> {\n+        match req.origin.headers.get::<ContentType>() {\n+            Some(&ContentType(Mime(\n+                TopLevel::Application,\n+                SubLevel::WwwFormUrlEncoded,\n+                _\n+            ))) => {\n+                let body = try!(req.get_ref::<BodyReader>());\n+                Ok(urlencoded::parse(&*body))\n+            },\n+            _ => Err(BodyError::WrongContentType)\n+        }\n+    }\n+}\n+\n+pub trait FormBody {\n+    /// Extracts URL encoded data from the request body.\n+    /// # Examples\n+    /// ```{rust}\n+    /// #[macro_use] extern crate nickel;\n+    /// use nickel::{Nickel, HttpRouter, FormBody};\n+    ///\n+    /// fn main() {\n+    ///     let mut server = Nickel::new();\n+    ///     server.post(\"/a\", middleware! { |req, res|\n+    ///         let form_body = try_with!(res, req.form_body());\n+    ///         return res.send(format!(\"Post: {:?}\", form_body))\n+    ///     });\n+    /// }\n+    /// ```\n+    fn form_body(&mut self) -> Result<&Params, (StatusCode, BodyError)>;\n+}\n+\n+impl<'mw, 'conn, D> FormBody for Request<'mw, 'conn, D> {\n+    fn form_body(&mut self) -> Result<&Params, (StatusCode, BodyError)> {\n+        self.get_ref::<FormBodyParser>().map_err(|e| (StatusCode::BadRequest, e))\n+    }\n+}\n+\n+pub trait JsonBody {\n+    fn json_as<T: Decodable>(&mut self) -> Result<T, io::Error>;\n+}\n+\n+impl<'mw, 'conn, D> JsonBody for Request<'mw, 'conn, D> {\n+    // FIXME: Update the error type.\n+    // Would be good to capture parsing error rather than a generic io::Error.\n+    // FIXME: Do the content-type check\n+    fn json_as<T: Decodable>(&mut self) -> Result<T, io::Error> {\n+        self.get_ref::<BodyReader>().and_then(|body|\n+            json::decode::<T>(&*body).map_err(|err|\n+                io::Error::new(ErrorKind::Other, format!(\"Parse error: {}\", err))\n+            )\n+        )\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum BodyError {\n+    Io(io::Error),\n+    WrongContentType,\n+}\n+\n+impl From<io::Error> for BodyError {\n+    fn from(err: io::Error) -> BodyError {\n+        BodyError::Io(err)\n+    }\n+}\n+\n+impl StdError for BodyError {\n+    fn description(&self) -> &str {\n+        match *self {\n+            BodyError::Io(ref err) => err.description(),\n+            BodyError::WrongContentType => \"Wrong content type\"\n+        }\n+    }\n+\n+    fn cause(&self) -> Option<&StdError> {\n+        match *self {\n+            BodyError::Io(ref err) => Some(err),\n+            _ => None\n+        }\n+    }\n+}\n+\n+impl fmt::Display for BodyError {\n+    fn fmt(&self, out: &mut fmt::Formatter) -> fmt::Result {\n+        write!(out, \"{}\", self.description())\n+    }\n+}\n+\ndiff --git a/src/json_body_parser.rs /dev/null\n--- a/src/json_body_parser.rs\n+++ /dev/null\n@@ -1,34 +0,0 @@\n-use serialize::{Decodable, json};\n-use request::Request;\n-use typemap::Key;\n-use plugin::{Plugin, Pluggable};\n-use std::io;\n-use std::io::{Read, ErrorKind};\n-\n-// Plugin boilerplate\n-struct JsonBodyParser;\n-impl Key for JsonBodyParser { type Value = String; }\n-\n-impl<'mw, 'conn, D> Plugin<Request<'mw, 'conn, D>> for JsonBodyParser {\n-    type Error = io::Error;\n-\n-    fn eval(req: &mut Request<D>) -> Result<String, io::Error> {\n-        let mut s = String::new();\n-        try!(req.origin.read_to_string(&mut s));\n-        Ok(s)\n-    }\n-}\n-\n-pub trait JsonBody {\n-    fn json_as<T: Decodable>(&mut self) -> Result<T, io::Error>;\n-}\n-\n-impl<'mw, 'conn, D> JsonBody for Request<'mw, 'conn, D> {\n-    fn json_as<T: Decodable>(&mut self) -> Result<T, io::Error> {\n-        self.get_ref::<JsonBodyParser>().and_then(|parsed|\n-            json::decode::<T>(&*parsed).map_err(|err|\n-                io::Error::new(ErrorKind::Other, format!(\"Parse error: {}\", err))\n-            )\n-        )\n-    }\n-}\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -22,8 +22,9 @@ pub use static_files_handler::StaticFilesHandler;\n pub use mount::{Mount, Mountable};\n pub use favicon_handler::FaviconHandler;\n pub use default_error_handler::DefaultErrorHandler;\n-pub use json_body_parser::JsonBody;\n-pub use query_string::{QueryString, Query};\n+pub use body_parser::{BodyError, FormBody, JsonBody};\n+pub use query_string::QueryString;\n+pub use urlencoded::{Params, Query};\n pub use router::{Router, Route, RouteResult, HttpRouter};\n pub use nickel_error::NickelError;\n pub use mimes::MediaType;\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -41,9 +42,9 @@ mod responder;\n mod favicon_handler;\n mod static_files_handler;\n mod mount;\n-mod json_body_parser;\n-pub mod mimes;\n+mod body_parser;\n mod query_string;\n+pub mod mimes;\n mod urlencoded;\n mod nickel_error;\n mod default_error_handler;\ndiff --git a/src/query_string.rs b/src/query_string.rs\n--- a/src/query_string.rs\n+++ b/src/query_string.rs\n@@ -1,48 +1,37 @@\n-use std::collections::HashMap;\n-use request::Request;\n-use urlencoded;\n-use hyper::uri::RequestUri;\n-use hyper::uri::RequestUri::{Star, AbsoluteUri, AbsolutePath, Authority};\n-use url::UrlParser;\n use plugin::{Plugin, Pluggable};\n+use request::Request;\n use typemap::Key;\n+use urlencoded::{Query, parse_uri};\n \n-type QueryStore = HashMap<String, Vec<String>>;\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct Query(QueryStore);\n-\n-impl Query {\n-    /// Retrieves the first value from the query for `key`, or `None` if not present.\n-    ///\n-    /// # Notes\n-    /// There may be multiple values per key, if all of the values for a given\n-    /// `key` are required, then use `all`.\n-    //FIXME: Implement via Indexing whenever IndexGet is supported\n-    pub fn get(&self, key: &str) -> Option<&str> {\n-        self.0.get(key).and_then(|v| v.first().map(|s| &**s))\n-    }\n+struct QueryStringParser;\n \n-    /// Retrieve all values from the query for `key`, or `None` if none are present.\n-    pub fn all(&self, key: &str) -> Option<&[String]> {\n-        self.0.get(key).map(|v| &**v)\n-    }\n+impl Key for QueryStringParser {\n+    type Value = Query;\n }\n \n-// Plugin boilerplate\n-struct QueryStringParser;\n-impl Key for QueryStringParser { type Value = Query; }\n-\n impl<'mw, 'conn, D> Plugin<Request<'mw, 'conn, D>> for QueryStringParser {\n     type Error = ();\n \n     fn eval(req: &mut Request<D>) -> Result<Query, ()> {\n-        Ok(parse(&req.origin.uri))\n+        Ok(parse_uri(&req.origin.uri))\n     }\n }\n \n pub trait QueryString {\n-    /// Retrieve the query from the current `Request`.\n+    /// Extracts URL encoded data from the URL query string.\n+    /// # Examples\n+    /// ```{rust}\n+    /// #[macro_use] extern crate nickel;\n+    /// use nickel::{Nickel, HttpRouter, QueryString};\n+    ///\n+    /// fn main() {\n+    ///     let mut server = Nickel::new();\n+    ///     server.get(\"/a\", middleware! { |req, res|\n+    ///         let query = req.query();\n+    ///         return res.send(format!(\"Query: {:?}\", query))\n+    ///     });\n+    /// }\n+    /// ```\n     fn query(&mut self) -> &Query;\n }\n \n",
        "test_patch": "diff --git a/src/query_string.rs b/src/query_string.rs\n--- a/src/query_string.rs\n+++ b/src/query_string.rs\n@@ -53,44 +42,3 @@ impl<'mw, 'conn, D> QueryString for Request<'mw, 'conn, D> {\n             .expect(\"Bug: QueryStringParser returned None\")\n     }\n }\n-\n-fn parse(origin: &RequestUri) -> Query {\n-    let f = |query: Option<&String>| query.map(|q| urlencoded::parse(&*q));\n-\n-    let result = match *origin {\n-        AbsoluteUri(ref url) => f(url.query.as_ref()),\n-        AbsolutePath(ref s) => UrlParser::new().parse_path(&*s)\n-                                                // FIXME: If this fails to parse,\n-                                                // then it really shouldn't have\n-                                                // reached here.\n-                                               .ok()\n-                                               .and_then(|(_, query, _)| f(query.as_ref())),\n-        Star | Authority(..) => None\n-    };\n-\n-    Query(result.unwrap_or_else(|| HashMap::new()))\n-}\n-\n-#[test]\n-fn splits_and_parses_an_url() {\n-    use url::Url;\n-    let t = |url| {\n-        let store = parse(&url);\n-        assert_eq!(store.get(\"foo\"), Some(\"bar\"));\n-        assert_eq!(store.get(\"foo\").unwrap_or(\"other\"), \"bar\");\n-        assert_eq!(store.get(\"bar\").unwrap_or(\"other\"), \"other\");\n-        assert_eq!(store.all(\"message\"),\n-                        Some(&[\"hello\".to_string(), \"world\".to_string()][..]));\n-        assert_eq!(store.all(\"car\"), None);\n-    };\n-\n-    let raw = \"http://www.foo.bar/query/test?foo=bar&message=hello&message=world\";\n-    t(AbsoluteUri(Url::parse(raw).unwrap()));\n-\n-    t(AbsolutePath(\"/query/test?foo=bar&message=hello&message=world\".to_string()));\n-\n-    assert_eq!(parse(&Star), Query(HashMap::new()));\n-\n-    let store = parse(&Authority(\"host.com\".to_string()));\n-    assert_eq!(store, Query(HashMap::new()));\n-}\ndiff --git a/src/urlencoded.rs b/src/urlencoded.rs\n--- a/src/urlencoded.rs\n+++ b/src/urlencoded.rs\n@@ -1,25 +1,96 @@\n-use std::collections::HashMap;\n-use url::form_urlencoded;\n use groupable::Groupable;\n+use hyper::uri::RequestUri;\n+use hyper::uri::RequestUri::{Star, AbsoluteUri, AbsolutePath, Authority};\n+use std::collections::HashMap;\n+use url::{form_urlencoded, UrlParser};\n+\n+type QueryStore = HashMap<String, Vec<String>>;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct Params(QueryStore);\n+\n+// TODO: remove it in favor of Params\n+pub type Query = Params;\n+\n+impl Params {\n+    /// Retrieves the first value from the query for `key`, or `None` if not present.\n+    ///\n+    /// # Notes\n+    /// There may be multiple values per key, if all of the values for a given\n+    /// `key` are required, then use `all`.\n+    //FIXME: Implement via Indexing whenever IndexGet is supported\n+    pub fn get(&self, key: &str) -> Option<&str> {\n+        self.0.get(key).and_then(|v| v.first().map(|s| &**s))\n+    }\n+\n+    /// Retrieve all values from the query for `key`, or `None` if none are present.\n+    pub fn all(&self, key: &str) -> Option<&[String]> {\n+        self.0.get(key).map(|v| &**v)\n+    }\n+}\n+\n+pub fn parse(encoded_string : &str) -> Params {\n+    Params(form_urlencoded::parse(encoded_string.as_bytes()).into_iter().group())\n+}\n+\n+pub fn parse_uri(origin: &RequestUri) -> Params {\n+    let f = |query: Option<&String>| query.map(|q| parse(&*q));\n+\n+    let result = match *origin {\n+        AbsoluteUri(ref url) => f(url.query.as_ref()),\n+        AbsolutePath(ref s) => UrlParser::new().parse_path(&*s)\n+                                                // FIXME: If this fails to parse,\n+                                                // then it really shouldn't have\n+                                                // reached here.\n+                                               .ok()\n+                                               .and_then(|(_, query, _)| f(query.as_ref())),\n+        Star | Authority(..) => None\n+    };\n \n-pub fn parse (encoded_string : &str) -> HashMap<String, Vec<String>> {\n-    form_urlencoded::parse(encoded_string.as_bytes()).into_iter().group()\n+    result.unwrap_or_else(|| Params(HashMap::new()))\n }\n \n #[test]\n fn parses_encoded_string_with_duplicate_keys() {\n-    let map = parse(\"foo=bar&message=hello&message=world\");\n-    assert_eq!(map[\"foo\"],\n-                vec![\"bar\".to_string()]);\n+    let store = parse(\"foo=bar&message=hello&message=world\");\n+    assert_eq!(\n+        store.all(\"foo\"),\n+        Some(&[\"bar\".to_string()][..])\n+    );\n+    assert_eq!(store.get(\"message\"), Some(\"hello\"));\n     // Ensure the ordering is correct\n-    assert_eq!(map[\"message\"],\n-                vec![\"hello\".to_string(), \"world\".to_string()]);\n+    assert_eq!(\n+        store.all(\"message\"),\n+        Some(&[\"hello\".to_string(), \"world\".to_string()][..])\n+    );\n }\n \n #[test]\n fn parses_urlencoded_characters() {\n-    let map = parse(\"message=hello%20world\");\n+    let store = parse(\"message=hello%20world\");\n+    assert_eq!(store.get(\"message\"), Some(\"hello world\"));\n+}\n+\n+#[test]\n+fn splits_and_parses_an_url() {\n+    use url::Url;\n+    let t = |url| {\n+        let store = parse_uri(&url);\n+        assert_eq!(store.get(\"foo\"), Some(\"bar\"));\n+        assert_eq!(store.get(\"foo\").unwrap_or(\"other\"), \"bar\");\n+        assert_eq!(store.get(\"bar\").unwrap_or(\"other\"), \"other\");\n+        assert_eq!(store.all(\"message\"),\n+                        Some(&[\"hello\".to_string(), \"world\".to_string()][..]));\n+        assert_eq!(store.all(\"car\"), None);\n+    };\n+\n+    let raw = \"http://www.foo.bar/query/test?foo=bar&message=hello&message=world\";\n+    t(AbsoluteUri(Url::parse(raw).unwrap()));\n+\n+    t(AbsolutePath(\"/query/test?foo=bar&message=hello&message=world\".to_string()));\n+\n+    assert_eq!(parse_uri(&Star), Params(HashMap::new()));\n \n-    assert_eq!(map[\"message\"],\n-                vec![\"hello world\".to_string()]);\n+    let store = parse_uri(&Authority(\"host.com\".to_string()));\n+    assert_eq!(store, Params(HashMap::new()));\n }\ndiff --git a/tests/example_tests.rs b/tests/example_tests.rs\n--- a/tests/example_tests.rs\n+++ b/tests/example_tests.rs\n@@ -19,6 +19,7 @@ mod examples {\n     mod custom_error_handler;\n     mod static_files;\n     mod enable_cors;\n+    mod form_data;\n \n     #[cfg(feature = \"ssl\")]\n     mod https;\ndiff --git /dev/null b/tests/examples/form_data.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/examples/form_data.rs\n@@ -0,0 +1,51 @@\n+use hyper::client::Client;\n+use hyper::header::ContentType;\n+use hyper::status::StatusCode;\n+use util::{read_body_to_string, read_url, run_example};\n+\n+#[test]\n+fn display_form() {\n+    run_example(\"form_data\", |port| {\n+        let url = format!(\"http://localhost:{}/\", port);\n+        let s = read_url(&url);\n+        assert!(s.contains(r#\"<form>\"#), \"response didn't have a form\");\n+    })\n+}\n+\n+#[test]\n+fn post_with_data() {\n+    run_example(\"form_data\", |port| {\n+        let url = format!(\"http://localhost:{}/confirmation\", port);\n+        let ref mut res = Client::new()\n+            .post(&url)\n+            .header(ContentType::form_url_encoded())\n+            .body(r#\"firstname=John&lastname=Doe&phone=911&email=john@doe.com\"#)\n+            .send()\n+            .unwrap();\n+        let s = read_body_to_string(res);\n+        assert!(s.contains(r#\"John Doe 911 john@doe.com\"#), \"response didn't have an expected data\");\n+    })\n+}\n+\n+#[test]\n+fn post_without_data() {\n+    run_example(\"form_data\", |port| {\n+        let url = format!(\"http://localhost:{}/confirmation\", port);\n+        let ref mut res = Client::new()\n+            .post(&url)\n+            .header(ContentType::form_url_encoded())\n+            .send()\n+            .unwrap();\n+        let s = read_body_to_string(res);\n+        assert!(s.contains(r#\"First name? Last name? Phone? Email?\"#), \"response didn't have an expected data\");\n+    })\n+}\n+\n+#[test]\n+fn post_without_content_type() {\n+    run_example(\"form_data\", |port| {\n+        let url = format!(\"http://localhost:{}/confirmation\", port);\n+        let res = Client::new().post(&url).send().unwrap();\n+        assert_eq!(res.status, StatusCode::BadRequest);\n+    })\n+}\n",
        "problem_statement": "Get `application/x-www-form-urlencoded` POST data as a HashMap\nHello! I would like to get `application/x-www-form-urlencoded` POST data as a HashMap. \nAs I understand it's impossible at this moment, isn't it? Are there any plans to implement this?\n\n",
        "hints_text": "Hi @Kilte \n\nhave you seen the form data example here?\n\nhttps://github.com/nickel-org/nickel.rs/blob/master/examples/form_data/form_data.rs\n\n@cburgdorf, yes, of course. But `form_data` contains a raw string and I need to parse it.\nIt looks like this:\n\n``` rust\nextern crate url;\n\nuse url::form_urlencoded;\n\n// ...\n\nlet mut s = String::new();\nreq.origin.read_to_string(&mut s).unwrap();\nlet params = combine_duplicates(form_urlencoded::parse(s.as_bytes()));\nfor (k, v) in params.iter() {\n    println!(\"Param {:?} {:?}\", k, v);\n}\n```\n\n...\n\n``` rust\n// from https://github.com/iron/urlencoded/\nuse std::collections::HashMap;\nuse std::collections::hash_map::Entry::*;\n\ntype QueryMap = HashMap<String, Vec<String>>;\n\n/// Convert a list of (key, value) pairs into a hashmap with vector values.\nfn combine_duplicates(q: Vec<(String, String)>) -> QueryMap {\n    let mut deduplicated: QueryMap = HashMap::new();\n\n    for (k, v) in q.into_iter() {\n        match deduplicated.entry(k) {\n            // Already a Vec here, push onto it\n            Occupied(entry) => { entry.into_mut().push(v); },\n\n            // No value, create a one-element Vec.\n            Vacant(entry) => { entry.insert(vec![v]); },\n        };\n    }\n\n    deduplicated\n}\n\n```\n\nA complete implementation:\n\n``` rust\n// form_urlencoded.rs\nuse std::collections::hash_map::{HashMap, Entry};\nuse std::io::{Error, Read};\n\nuse nickel::Request;\nuse nickel::status::StatusCode;\nuse plugin::{Plugin, Pluggable};\nuse typemap::Key;\nuse url::form_urlencoded::parse;\n\npub type Params = HashMap<String, Vec<String>>;\n\npub struct FormUrlencoded;\n\nimpl Key for FormUrlencoded {\n    type Value = Params;\n}\n\nimpl<'mw, 'conn, D> Plugin<Request<'mw, 'conn, D>> for FormUrlencoded {\n    type Error = Error;\n\n    fn eval(req: &mut Request<D>) -> Result<Params, Error> {\n        let mut buf = String::new();\n        try!(req.origin.read_to_string(&mut buf));\n\n        let mut result = Params::new();\n\n        for (key, value) in parse(buf.as_bytes()).into_iter() {\n            match result.entry(key) {\n                Entry::Occupied(entry) => {\n                    entry.into_mut().push(value);\n                },\n                Entry::Vacant(entry) => {\n                    entry.insert(vec![value]);\n                },\n            };\n        }\n\n        Ok(result)\n    }\n}\n\npub trait FormUrlencodedExtension {\n    fn post(&mut self) -> Result<&Params, (StatusCode, Error)>;\n}\n\nimpl<'a, 'b, D> FormUrlencodedExtension for Request<'a, 'b, D> {\n    fn post(&mut self) -> Result<&Params, (StatusCode, Error)> {\n        self.get_ref::<FormUrlencoded>().map_err(|e| (StatusCode::BadRequest, e))\n    }\n}\n\n```\n\nUsage:\n\n``` rust\n// handlers.rs\nuse form_urlencoded::FormUrlencodedExtension;\n// ...\n\nfn handler<'mw>(req: &mut Request, mut rep: Response<'mw>) -> MiddlewareResult<'mw> {\n    let post = try_with!(rep, req.post());\n    let param = match post.get(\"s\") {\n        None => /* ... */,\n        Some(vec) => /* ... */    \n    };\n    // ...\n}\n```\n\n@Kilte Would you like to submit the above as a PR?\n\n@Ryman, why not? Just one question: which result type in `FormUrlencodedExtension::post()` I should use? `Result<&Params, (StatusCode, Error)>`, or just `Result<&Params, Error>`?\n\nAnd I think we should provide a struct for POST data like [this](https://github.com/nickel-org/nickel.rs/blob/master/src/query_string.rs#L13). What do you think?\n\n> Just one question: which result type in FormUrlencodedExtension::post() I should use? Result<&Params, (StatusCode, Error)>, or just Result<&Params, Error>?\n\nIt would be nice if it worked seamlessly with the `try_with!(..)` macro. `BadRequest` probably makes sense as a default in that case. I think it will probably be a case of having it's own error enum which the user can match on to decide the appropriate StatusCode (if there are enough different types of failure case).\n\n> And I think we should provide a struct for POST data like this.\n\nI think this is probably worth doing. Will need to see it in action to make a good decision though!\n\nThe PR should probably try updating the existing form example to allow us to see how some basic usage looks like.\n",
        "created_at": "2016-04-25T08:19:56Z",
        "version": "0.8"
    },
    {
        "repo": "nickel-org/nickel.rs",
        "pull_number": 225,
        "instance_id": "nickel-org__nickel.rs-225",
        "issue_numbers": [
            "224"
        ],
        "base_commit": "a9120c6c2018772971cfe4b117da2dea48808f51",
        "patch": "diff --git a/src/request.rs b/src/request.rs\n--- a/src/request.rs\n+++ b/src/request.rs\n@@ -2,6 +2,7 @@ use router::RouteResult;\n use plugin::{Extensible, Pluggable};\n use typemap::TypeMap;\n use hyper::server::Request as HyperRequest;\n+use hyper::uri::RequestUri::AbsolutePath;\n \n ///A container for all the request data\n pub struct Request<'a, 'b: 'k, 'k: 'a> {\ndiff --git a/src/request.rs b/src/request.rs\n--- a/src/request.rs\n+++ b/src/request.rs\n@@ -25,6 +26,13 @@ impl<'a, 'b, 'k> Request<'a, 'b, 'k> {\n     pub fn param(&self, key: &str) -> &str {\n         self.route_result.as_ref().unwrap().param(key)\n     }\n+\n+    pub fn path_without_query(&self) -> Option<&str> {\n+        match self.origin.uri {\n+            AbsolutePath(ref path) => Some(path.splitn(2, '?').next().unwrap()),\n+            _ => None\n+        }\n+    }\n }\n \n impl<'a, 'b, 'k> Extensible for Request<'a, 'b, 'k> {\ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -1,5 +1,5 @@\n use middleware::{Middleware, Continue, MiddlewareResult};\n-use hyper::uri::RequestUri::AbsolutePath;\n+\n use request::Request;\n use response::Response;\n use router::HttpRouter;\ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -54,9 +54,6 @@ impl Router {\n     }\n \n     pub fn match_route<'a>(&'a self, method: &Method, path: &str) -> Option<RouteResult<'a>> {\n-        // Strip off the querystring when matching a route\n-        let path = path.splitn(2, '?').next().unwrap();\n-\n         self.routes\n             .iter()\n             .find(|item| item.method == *method && item.matcher.is_match(path))\ndiff --git a/src/router/router.rs b/src/router/router.rs\n--- a/src/router/router.rs\n+++ b/src/router/router.rs\n@@ -98,10 +95,11 @@ impl Middleware for Router {\n     fn invoke<'a, 'b>(&'a self, req: &mut Request<'b, 'a, 'b>, mut res: Response<'a>)\n                         -> MiddlewareResult<'a> {\n         debug!(\"Router::invoke for '{:?}'\", req.origin.uri);\n-        let route_result = match req.origin.uri {\n-            AbsolutePath(ref url) => self.match_route(&req.origin.method, &**url),\n-            _ => None\n-        };\n+\n+        // Strip off the querystring when matching a route\n+        let route_result = req.path_without_query()\n+                              .and_then(|path| self.match_route(&req.origin.method, path));\n+\n         debug!(\"route_result.route.path: {:?}\", route_result.as_ref().map(|r| r.route.matcher.path()));\n \n         match route_result {\ndiff --git a/src/static_files_handler.rs b/src/static_files_handler.rs\n--- a/src/static_files_handler.rs\n+++ b/src/static_files_handler.rs\n@@ -2,7 +2,6 @@ use std::path::{Path, PathBuf};\n use std::io::ErrorKind::NotFound;\n use std::fs;\n \n-use hyper::uri::RequestUri::AbsolutePath;\n use hyper::method::Method::{Get, Head};\n \n use request::Request;\ndiff --git a/src/static_files_handler.rs b/src/static_files_handler.rs\n--- a/src/static_files_handler.rs\n+++ b/src/static_files_handler.rs\n@@ -45,17 +44,14 @@ impl StaticFilesHandler {\n     }\n \n     fn extract_path<'a>(&self, req: &'a mut Request) -> Option<&'a str> {\n-        match req.origin.uri {\n-            AbsolutePath(ref path) => {\n-                debug!(\"{:?} {:?}{:?}\", req.origin.method, self.root_path.display(), path);\n+        req.path_without_query().map(|path| {\n+            debug!(\"{:?} {:?}{:?}\", req.origin.method, self.root_path.display(), path);\n \n-                match &**path {\n-                    \"/\" => Some(\"index.html\"),\n-                    path => Some(&path[1..]),\n-                }\n+            match path {\n+                \"/\" => \"index.html\",\n+                path => &path[1..],\n             }\n-            _ => None\n-        }\n+        })\n     }\n \n     fn with_file<'a, 'b, P>(&self,\n",
        "test_patch": "diff --git a/tests/compile-fail/inference_request_hinted.rs b/tests/compile-fail/inference_request_hinted.rs\n--- a/tests/compile-fail/inference_request_hinted.rs\n+++ b/tests/compile-fail/inference_request_hinted.rs\n@@ -11,9 +11,11 @@ fn main() {\n     // Request hinted\n     server.utilize(|_: &mut Request, res| res.send(\"Hello World!\"));\n     //~^ ERROR the type of this value must be known in this context\n+    //~^^ ERROR type mismatch resolving `for<'r,'b,'a>\n \n     server.get(\"**\", |_: &mut Request, res| res.send(\"Hello World!\"));\n     //~^ ERROR the type of this value must be known in this context\n+    //~^^ ERROR type mismatch resolving `for<'r,'b,'a>\n \n     server.listen(\"127.0.0.1:6767\");\n }\n",
        "problem_statement": "Static files and url parameters\nI'm trying to use mathjax on my server. I install it locally and serve the directory using StaticFilesHandler but mathjax tries to access files such as /MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML which fails to resolve.\n\nIs that intended ? If so, how can I make this work ?\n\n",
        "hints_text": "",
        "created_at": "2015-05-21T19:02:16Z",
        "version": "0.5"
    },
    {
        "repo": "nickel-org/nickel.rs",
        "pull_number": 211,
        "instance_id": "nickel-org__nickel.rs-211",
        "issue_numbers": [
            "160"
        ],
        "base_commit": "db6b5294d6f209daefcb41b1c10dd4a9ee46aa7d",
        "patch": "diff --git /dev/null b/examples/assets/footer.tpl\nnew file mode 100644\n--- /dev/null\n+++ b/examples/assets/footer.tpl\n@@ -0,0 +1,2 @@\n+    </body>\n+</html>\ndiff --git /dev/null b/examples/assets/header.tpl\nnew file mode 100644\n--- /dev/null\n+++ b/examples/assets/header.tpl\n@@ -0,0 +1,7 @@\n+<html>\n+    <head>\n+        <title>\n+            nickel.rs - example\n+        </title>\n+    </head>\n+    <body>\ndiff --git a/src/response.rs b/src/response.rs\n--- a/src/response.rs\n+++ b/src/response.rs\n@@ -17,7 +17,7 @@ use std::io::{Read, Write, copy};\n use std::fs::File;\n use {NickelError, Halt, MiddlewareResult, AsBytes};\n \n-pub type TemplateCache = RwLock<HashMap<&'static str, Template>>;\n+pub type TemplateCache = RwLock<HashMap<String, Template>>;\n \n ///A container for the response\n pub struct Response<'a, T=Fresh> {\ndiff --git a/src/response.rs b/src/response.rs\n--- a/src/response.rs\n+++ b/src/response.rs\n@@ -186,8 +186,8 @@ impl<'a> Response<'a, Fresh> {\n     ///     res.render(\"examples/assets/template.tpl\", &data)\n     /// }\n     /// ```\n-    pub fn render<T>(self, path: &'static str, data: &T) -> MiddlewareResult<'a>\n-            where T: Encodable {\n+    pub fn render<T, P>(self, path: P, data: &T) -> MiddlewareResult<'a>\n+            where T: Encodable, P: AsRef<str> + Into<String> {\n         fn render<'a, T>(res: Response<'a>, template: &Template, data: &T)\n                 -> MiddlewareResult<'a> where T: Encodable {\n             let mut stream = try!(res.start());\ndiff --git a/src/response.rs b/src/response.rs\n--- a/src/response.rs\n+++ b/src/response.rs\n@@ -198,23 +198,26 @@ impl<'a> Response<'a, Fresh> {\n         }\n \n         // Fast path doesn't need writer lock\n-        if let Some(t) = self.templates.read().unwrap().get(&path) {\n+        if let Some(t) = self.templates.read().unwrap().get(path.as_ref()) {\n             return render(self, t, data);\n         }\n \n         // We didn't find the template, get writers lock\n         let mut templates = self.templates.write().unwrap();\n-        // Search again incase there was a race to compile the template\n-        let template = match templates.entry(path) {\n-            Vacant(entry) => {\n-                let mut file = File::open(&Path::new(path))\n-                                     .ok().expect(&*format!(\"Couldn't open the template file: {}\", path));\n-                let mut raw_template = String::new();\n \n-                file.read_to_string(&mut raw_template)\n-                    .ok().expect(&*format!(\"Couldn't open the template file: {}\", path));\n+        // Additional clone required for now as the entry api doesn't give us a key ref\n+        let path = path.into();\n \n-                entry.insert(mustache::compile_str(&*raw_template))\n+        // Search again incase there was a race to compile the template\n+        let template = match templates.entry(path.clone()) {\n+            Vacant(entry) => {\n+                match mustache::compile_path(&path) {\n+                    Ok(template) => entry.insert(template),\n+                    Err(e) => return self.error(InternalServerError,\n+                                                format!(\"Failed to compile template: \\\n+                                                        {}.\\nReason: {:?}\",\n+                                                        &path, e))\n+                }\n             },\n             Occupied(entry) => entry.into_mut()\n         };\n",
        "test_patch": "diff --git a/examples/assets/template.tpl b/examples/assets/template.tpl\n--- a/examples/assets/template.tpl\n+++ b/examples/assets/template.tpl\n@@ -1,15 +1,5 @@\n-<html>\n-    <head>\n-        <title>\n-            nickel.rs template test\n-        </title>\n-    </head>\n-    <body>\n-        <h1>\n-            Hello {{ name }}!\n-        </h1>\n-        <p>\n-            This page is hosted by nickel.rs and rendered by rust-mustache.\n-        </p>\n-    </body>\n-</html>\n\\ No newline at end of file\n+{{> header }}\n+    <h1>\n+        Hello {{ name }}!\n+    </h1>\n+{{> footer }}\n",
        "problem_statement": "Mustache partials not working\nhttps://github.com/ninjabear/nickel-bootstrap/tree/master/templates\n\nIn here I have some mustache partials set up, but I'm not entirely clear on how nickel would use them (it doesn't appear to automatically). \n\nI had a quick look at the code, not sure where or if it has been implemented.\n\n",
        "hints_text": "I tried using this https://github.com/erickt/rust-mustache directly too - not compiling at the moment. \n\nThe test for partials is here; https://github.com/erickt/rust-mustache/blob/master/src/template.rs#L474 \n\nThe upstream version haven't compiled in a long time and none of the PRs where requested.\n\nThe tests for partials is there in our branch too and passes. Maybe you can take a look and see if the test case is not good enough or if you're doing something wrong.\n\nIt likely has something to do with the changes I made for migrating to the new fs/io apis! That touched some logic for partial file loading (and if the files are not found then mustache treats them as empty strings by current design)\n\nPresumably now nickel-mustache is the \"official\" version rather than a fork we should fix this there? \n\n@ninjabear Yeah :)\n",
        "created_at": "2015-05-07T02:11:25Z",
        "version": "0.3"
    }
]