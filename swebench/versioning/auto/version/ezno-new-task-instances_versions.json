[
    {
        "repo": "kaleidawave/ezno",
        "pull_number": 95,
        "instance_id": "kaleidawave__ezno-95",
        "issue_numbers": [
            "73"
        ],
        "base_commit": "662647988138972097eb7557ef33bf63ccd67c4c",
        "patch": "diff --git /dev/null b/checker/definitions/internal-full.d.ts\nnew file mode 100644\n--- /dev/null\n+++ b/checker/definitions/internal-full.d.ts\n@@ -0,0 +1,205 @@\n+// \u2193\u2193 Ezno Functions \u2193\u2193\n+declare function debug_context(): void performs const debug_context;\n+declare function print_type(t: any): void performs const print_type;\n+declare function debug_type(t: any): void performs const debug_type;\n+declare function debug_type_rust(t: any): void performs const debug_type_rust;\n+declare function debug_effects_rust(t: () => {}): void performs const debug_effects_rust;\n+declare function debug_effects(t: () => {}): void performs const debug_effects;\n+declare function is_dependent(t: any): void performs const is_dependent;\n+\n+declare function context_id(): void performs const context_id;\n+declare function context_id_chain(): void performs const context_id_chain;\n+\n+// A function, as it should be!\n+declare function satisfies<T>(t: T): T performs const satisfies;\n+\n+declare function compile_type_to_object<T>(): any performs const compile_type_to_object;\n+// \u2191\u2191 Ezno Functions \u2191\u2191\n+\n+declare var undefined: undefined;\n+\n+interface nominal Array<T> {\n+    [index: number]: T | undefined;\n+    \n+    length: number;\n+\n+    push(item: T) performs {\n+        this[this.length] = item;\n+        return ++this.length\n+    }\n+\n+    pop(): T | undefined performs {\n+        if (this.length === 0) {\n+            return undefined\n+        } else {\n+            const value = this[--this.length];\n+            delete this[this.length];\n+            return value\n+        }\n+    }\n+\n+    map<U>(cb: (t: T) => U): Array<U> performs {\n+        const { length } = this, u: Array<U> = [];\n+        let i: number = 0;\n+        while (i < length) {\n+            const value = this[i++];\n+            u.push(cb(value))\n+        }\n+        return u;\n+    }\n+\n+    filter(cb: (t: T) => boolean): Array<T> performs {\n+        const { length } = this, filtered: Array<T> = [];\n+        let i: number = 0;\n+        while (i < length) {\n+            const value = this[i++];\n+            if (cb(value)) {\n+                filtered.push(value)\n+            }\n+        }\n+        return filtered;\n+    }\n+\n+    find(cb: (t: T) => boolean): T | undefined performs {\n+        const { length } = this;\n+        let i: number = 0;\n+        while (i < length) {\n+            const value = this[i++];\n+            if (cb(value)) {\n+                return value\n+            }\n+        }\n+    }\n+\n+    every(cb: (t: T) => boolean): boolean performs {\n+        const { length } = this;\n+        let i: number = 0;\n+        while (i < length) {\n+            const value = this[i++];\n+            if (!cb(value)) {\n+                return false\n+            }\n+        }\n+        // Vacuous truth\n+        return true\n+    }\n+\n+    some(cb: (t: T) => boolean): boolean performs {\n+        const { length } = this;\n+        let i: number = 0;\n+        while (i < length) {\n+            const value = this[i++];\n+            if (cb(value)) {\n+                return true\n+            }\n+        }\n+        return false\n+    }\n+\n+    includes(searchElement: T, fromIndex?: number): boolean performs {\n+        const { length } = this;\n+        let i: number = fromIndex ?? 0;\n+        while (i < length) {\n+            const value = this[i++];\n+            if (value === searchElement) {\n+                return true\n+            }\n+        }\n+        return false\n+    }\n+\n+    // last() performs {\n+    //     return this[this.length - 1]\n+    // }\n+}\n+\n+interface Math {\n+    @DoNotIncludeThis\n+    sin(x: number): number performs const sin;\n+    @DoNotIncludeThis\n+    cos(x: number): number performs const cos;\n+    @DoNotIncludeThis\n+    tan(x: number): number performs const tan;\n+    @DoNotIncludeThis\n+    floor(x: number): number performs const floor;\n+    @DoNotIncludeThis\n+    sqrt(x: number): number performs const sqrt;\n+    @DoNotIncludeThis\n+    cbrt(x: number): number performs const cbrt;\n+\n+    // TODO newer method\n+    trunc(x: number): number performs const trunc;\n+\n+    PI: 3.141592653589793\n+}\n+\n+interface nominal string {\n+    [index: number]: string | undefined;\n+\n+    toUpperCase(): string performs const uppercase;\n+    toLowerCase(): string performs const lowercase;\n+\n+    get length(): number performs const string_length;\n+}\n+\n+interface Console {\n+    @DoNotIncludeThis\n+    log(msg: any): void;\n+}\n+\n+interface JSON {\n+    // TODO any temp\n+    @DoNotIncludeThis\n+    parse(input: string): any;\n+\n+    // TODO any temp\n+    @DoNotIncludeThis\n+    stringify(input: any): string;\n+}\n+\n+interface Function {\n+    bind(this_ty: any): Function performs const bind;\n+}\n+\n+interface Symbols {\n+    // TODO temp\n+    iterator: 199\n+}\n+\n+declare var Symbol: Symbols;\n+\n+interface Object {\n+    @DoNotIncludeThis\n+    setPrototypeOf(on: object, to: object): object performs const set_prototype;\n+\n+    @DoNotIncludeThis\n+    getPrototypeOf(on: object): object | null performs const get_prototype;\n+\n+    // create(prototype: object): object performs {\n+    //     const n = {};\n+    //     Object.setProtoTypeOf(n, prototype);\n+    //     return n\n+    // }\n+}\n+\n+declare var JSON: JSON;\n+declare var Math: Math;\n+declare var console: Console;\n+declare var Object: Object;\n+\n+declare function JSXH(tag: string, attributes: any, children?: any) performs {\n+    return { tag, attributes, children }\n+}\n+\n+interface Document {\n+    title: string\n+}\n+\n+interface FormData {\n+}\n+\n+@client\n+declare const document: Document;\n+\n+// @server\n+// declare function createItem(a: any);\n\\ No newline at end of file\ndiff --git a/checker/definitions/internal.d.ts b/checker/definitions/internal.d.ts\n--- a/checker/definitions/internal.d.ts\n+++ b/checker/definitions/internal.d.ts\n@@ -2,6 +2,10 @@\n declare function debug_context(): void performs const debug_context;\n declare function print_type(t: any): void performs const print_type;\n declare function debug_type(t: any): void performs const debug_type;\n+declare function debug_type_independent(t: any): void performs const debug_type_independent;\n+declare function debug_type_rust(t: any): void performs const debug_type_rust;\n+declare function debug_type_rust_independent(t: any): void performs const debug_type_rust_independent;\n+declare function debug_effects_rust(t: () => {}): void performs const debug_effects_rust;\n declare function debug_effects(t: () => {}): void performs const debug_effects;\n declare function is_dependent(t: any): void performs const is_dependent;\n \ndiff --git a/checker/definitions/internal.d.ts b/checker/definitions/internal.d.ts\n--- a/checker/definitions/internal.d.ts\n+++ b/checker/definitions/internal.d.ts\n@@ -17,7 +21,7 @@ declare function compile_type_to_object<T>(): any performs const compile_type_to\n declare var undefined: undefined;\n \n interface nominal Array<T> {\n-    [index: number]: T;\n+    [index: number]: T | undefined;\n     \n     length: number;\n \ndiff --git a/checker/definitions/internal.d.ts b/checker/definitions/internal.d.ts\n--- a/checker/definitions/internal.d.ts\n+++ b/checker/definitions/internal.d.ts\n@@ -62,6 +66,8 @@ interface Math {\n }\n \n interface nominal string {\n+    [index: number]: string | undefined;\n+\n     toUpperCase(): string performs const uppercase;\n     toLowerCase(): string performs const lowercase;\n \ndiff --git a/checker/definitions/internal.d.ts b/checker/definitions/internal.d.ts\n--- a/checker/definitions/internal.d.ts\n+++ b/checker/definitions/internal.d.ts\n@@ -87,6 +93,13 @@ interface Function {\n     bind(this_ty: any): Function performs const bind;\n }\n \n+interface Symbols {\n+    // TODO temp\n+    iterator: 199\n+}\n+\n+declare var Symbol: Symbols;\n+\n interface Object {\n     @DoNotIncludeThis\n     setPrototypeOf(on: object, to: object): object performs const set_prototype;\ndiff --git a/checker/definitions/internal.d.ts b/checker/definitions/internal.d.ts\n--- a/checker/definitions/internal.d.ts\n+++ b/checker/definitions/internal.d.ts\n@@ -106,8 +119,8 @@ declare var Math: Math;\n declare var console: Console;\n declare var Object: Object;\n \n-declare function JSXH(tagname: string, attributes: any, children?: any) performs {\n-    return tagname\n+declare function JSXH(tag: string, attributes: any, children?: any) performs {\n+    return { tag, attributes, children }\n }\n \n interface Document {\ndiff --git a/checker/examples/check.rs b/checker/examples/check.rs\n--- a/checker/examples/check.rs\n+++ b/checker/examples/check.rs\n@@ -27,8 +30,8 @@ fn main() {\n \tif let Ok(mut post_check_data) = post_check_data {\n \t\tif args.iter().any(|arg| arg == \"--types\") {\n \t\t\teprintln!(\"Types:\");\n-\t\t\tfor item in post_check_data.types.into_vec_temp() {\n-\t\t\t\teprintln!(\"\\t{item:?}\");\n+\t\t\tfor (type_id, item) in post_check_data.types.into_vec_temp() {\n+\t\t\t\teprintln!(\"\\t{type_id:?}: {item:?}\");\n \t\t\t}\n \t\t}\n \t\tif args.iter().any(|arg| arg == \"--events\") {\ndiff --git a/checker/examples/check.rs b/checker/examples/check.rs\n--- a/checker/examples/check.rs\n+++ b/checker/examples/check.rs\n@@ -41,9 +44,20 @@ fn main() {\n \t\t}\n \t}\n \n-\teprintln!(\"Diagnostics:\");\n-\tfor diagnostic in diagnostics {\n-\t\teprintln!(\"\\t{}\", diagnostic.reason());\n+\tif args.iter().any(|arg| arg == \"--time\") {\n+\t\tlet end = now.elapsed();\n+\t\tlet count = diagnostics.into_iter().len();\n+\t\teprintln!(\"Found {count} diagnostics in {end:?}\");\n+\t} else {\n+\t\teprintln!(\"Diagnostics:\");\n+\t\tfor diagnostic in diagnostics {\n+\t\t\teprintln!(\"\\t{}\", diagnostic.reason());\n+\t\t\tif let Diagnostic::PositionWithAdditionalLabels { labels, .. } = diagnostic {\n+\t\t\t\tfor (label, _) in labels.iter() {\n+\t\t\t\t\teprintln!(\"\\t\\t({})\", label);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t}\n }\n \ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -94,12 +94,10 @@ const my_wrapped: Wrapper<number> = { internal: \"hi\" }\n \n ```ts\n const numbers1: Array<number> = [1, 2, \"3\"]\n-const numbers2: Array<string> = [ \"hi\", \"3\"]\n+const numbers2: Array<string> = [\"hi\", \"3\"]\n ```\n \n-> Printing is a bit wack here\n-\n-- Type [Array] { 0: 1, 1: 2, 2: \"3\", length: 3 } is not assignable to type Array\\<number>\n+- Type [1, 2, \"3\"] is not assignable to type Array\\<number>\n \n ### Function checking\n \ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -352,18 +350,6 @@ function getToUpperCase(s: string) {\n \n - Expected \"HEY\", found \"HI\"\n \n-#### This as generic argument\n-\n-```ts\n-function callToUpperCase(s: string) {\n-\treturn s.toUpperCase()\n-}\n-\n-(callToUpperCase(\"hi\") satisfies \"HEY\")\n-```\n-\n-- Expected \"HEY\", found \"HI\"\n-\n ### Closures\n \n #### Reading variable\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -436,7 +422,9 @@ value.getValue() satisfies 6\n ```ts\n let a: number = 0\n function func() {\n-\ta = 4\n+\ta = 4;\n+\t// Important that subsequent reads use the new value, not the same free variable\n+\ta satisfies 4;\n }\n \n func()\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -459,7 +447,7 @@ let b: 2 = a\n \n - Type 4 is not assignable to type 2\n \n-#### Property updates object inside function\n+#### Free variable property update object inside function\n \n ```ts\n const obj: { a: number } = { a: 2 }\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -523,6 +511,74 @@ out satisfies string\n \n - Expected string, found 3\n \n+#### TDZ from free variable (across function)\n+\n+```ts\n+function getX() {\n+    return x\n+}\n+\n+(getX satisfies () => number);\n+\n+getX();\n+\n+let x: number = 5;\n+```\n+\n+- Variable x used before declaration\n+\n+#### Assignment to union\n+\n+> Solves the common subtyping issue between read and write properties\n+\n+```ts\n+let myObject: { a: number } = { a: 4 }\n+\n+function setAtoString(someObject: { a: number | string }) {\n+    someObject.a = \"hi\";\n+}\n+\n+setAtoString({ a: 6 });\n+setAtoString(myObject);\n+```\n+\n+> Error could be better. Full one contains labels with more information\n+\n+- Assignment mismatch\n+\n+#### Mutating an object by a function\n+\n+> This is where the object loses its constant-ness\n+\n+```ts\n+function doThingWithCallback(callback: (obj: { x: number }) => any) {\n+    const obj: { x: number } = { x: 8 };\n+    callback(obj);\n+    (obj.x satisfies 8);\n+    return obj;\n+}\n+\n+const object = doThingWithCallback((obj: { x: number }) => obj.x = 2);\n+(object.x satisfies string);\n+```\n+\n+- Expected 8, found number\n+- Expected string, found 2\n+\n+#### Assigning to parameter observed via effect\n+\n+```ts\n+function add_property(obj: { prop: number }) {\n+    obj.prop += 2;\n+}\n+\n+const obj = { prop: 4 };\n+add_property(obj);\n+(obj.prop satisfies 8);\n+```\n+\n+- Expected 8, found 6\n+\n ### Constant evaluation\n \n #### Arithmetic\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -581,7 +637,7 @@ const z: false = true || 4\n - Expected number, found true\n - Expected string, found true\n \n-#### String operations\n+#### String operations (constant functions can use `this`)\n \n ```ts\n \"hi\".toUpperCase() satisfies number\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -867,6 +923,132 @@ func satisfies (a: boolean) => 5;\n \n - Expected (a: boolean) => 5, found (a: boolean) => 2 | undefined\n \n+### Iteration\n+\n+#### While loop unrolling\n+\n+```ts\n+let a = 1;\n+let i = 0;\n+while (i < 5) {\n+    a *= 2;\n+    i++;\n+}\n+\n+(a satisfies 8);\n+```\n+\n+- Expected 8, found 32\n+\n+#### While loop event in the condition\n+\n+```ts\n+let a = 1;\n+let i = 0;\n+while (i++ < 5) {\n+    a *= 2;\n+}\n+\n+(a satisfies 8);\n+```\n+\n+- Expected 8, found 32\n+\n+#### Do while loop\n+\n+```ts\n+let a = 0;\n+do {\n+    a++\n+} while (a < 3)\n+\n+(a satisfies 8);\n+```\n+\n+- Expected 8, found 3\n+\n+#### For loop with initialiser and condition\n+\n+```ts\n+let a: string = \"\";\n+for (let i: number = 0; i < 10; i++) {\n+    a = a + i;\n+}\n+\n+(a satisfies number)\n+```\n+\n+- Expected number, found \"0123456789\"\n+\n+#### While loop with unknown number of iterations\n+\n+```ts\n+declare let i: number;\n+let a: number = 0;\n+while (a < i) {\n+    a++;\n+}\n+\n+(a satisfies string)\n+```\n+\n+- Expected string, found number\n+\n+> Important that type is widened to 'number' (think it is an open poly in this case)\n+\n+#### While loop unrolling as an effect\n+\n+```ts\n+function loop(n: number, c: string) {\n+    let a: string = c;\n+    let i: number = 0;\n+    while (i++ < n) {\n+        a += c\n+    }\n+    return a\n+}\n+\n+(loop(10, \"!\") satisfies number);\n+```\n+\n+- Expected number, found \"!!!!!!!!!!\"\n+\n+#### Break in a while loop\n+\n+```ts\n+let a = 2;\n+let i = 0;\n+while (i++ < 10) {\n+    a *= 2;\n+    if (a > 5) {\n+        break;\n+    }\n+}\n+\n+(a satisfies 2);\n+```\n+\n+- Expected 2, found 8\n+\n+#### Continue in a while loop\n+\n+> With the continue the update to `a` only happens on even runs (5 times)\n+\n+```ts\n+let a = 2;\n+let i = 0;\n+while (i++ < 10) {\n+    if (i % 2) {\n+        continue;\n+    }\n+    a *= 2;\n+}\n+\n+(a satisfies 2);\n+```\n+\n+- Expected 2, found 64\n+\n ### Statements, declarations and expressions\n \n > Some of these are part of synthesis, rather than checking\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -1066,9 +1248,17 @@ type X = { a: string }\n \n - Type { b: \"NaN\" } is not assignable to type X\n \n-### Classes\n+#### TDZ in statements\n \n-> TODO privacy\n+```ts\n+let x = y;\n+\n+let y = 2;\n+```\n+\n+- Variable y used before declaration\n+\n+### Classes\n \n #### Constructor\n \ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -1106,8 +1296,6 @@ global satisfies string;\n \n #### Properties\n \n-> TODO check timing\n-\n ```ts\n let global: number = 0;\n \ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -1273,6 +1461,40 @@ function getOther<T extends { prop: string, other: string }>(t: T): T[\"other\"] {\n \n - Cannot return T[\"other\"] because the function is expected to return T[\"prop\"]\n \n+#### Index into dependent array\n+\n+```ts\n+function getFirst(array: number[]) {\n+    return array[0]\n+}\n+\n+(getFirst satisfies boolean);\n+```\n+\n+- Expected boolean, found (array: Array\\<number>) => number | undefined\n+\n+#### Index into dependent string\n+\n+```ts\n+function getSecondCharacter(s: string) {\n+    return s[1]\n+}\n+\n+(getSecondCharacter satisfies boolean);\n+(getSecondCharacter(\"string\") satisfies \"b\");\n+```\n+\n+- Expected boolean, found (s: string) => string | undefined\n+- Expected \"b\", found \"t\"\n+\n+#### Index into string\n+\n+```ts\n+(\"something\"[2] satisfies number);\n+```\n+\n+- Expected number, found \"m\"\n+\n ### Prototypes\n \n #### Set prototype\ndiff --git a/checker/specification/to_implement.md b/checker/specification/to_implement.md\n--- a/checker/specification/to_implement.md\n+++ b/checker/specification/to_implement.md\n@@ -1,19 +1,3 @@\n-### Function calling\n-\n-#### TDZ (temporary dead zone)\n-\n-> `b` is a free variable and hoisted, so `getB` can only be used once it is defined\n-\n-```ts\n-function getB() {\n-    return b\n-}\n-\n-getB();\n-const b = 2;\n-getB();\n-```\n-\n ### Types\n \n #### Resolving value by property on dependent\ndiff --git a/checker/specification/to_implement.md b/checker/specification/to_implement.md\n--- a/checker/specification/to_implement.md\n+++ b/checker/specification/to_implement.md\n@@ -30,6 +14,19 @@ getProperty(\"c\") satisfies 2\n - Expected \"a\" | \"b\" | \"c\" found \"d\"\n - Expected 2 found 3\n \n+#### Set property on dependent observed\n+\n+```ts\n+function add_property(obj: { prop: number }) {\n+    obj.prop = 2;\n+    (obj.prop satisfies 4);\n+}\n+```\n+\n+> Not number\n+\n+- Expected 4, found 2\n+\n #### Calling on or type\n \n ```ts\ndiff --git a/checker/specification/to_implement.md b/checker/specification/to_implement.md\n--- a/checker/specification/to_implement.md\n+++ b/checker/specification/to_implement.md\n@@ -44,6 +41,20 @@ print_type(callFunc)\n \n - Expected \"a\" | \"b\" | \"c\" found \"d\"\n \n+#### This as generic argument\n+\n+> Was working, now broken for some reason :(\n+\n+```ts\n+function callToUpperCase(s: string) {\n+\treturn s.toUpperCase()\n+}\n+\n+(callToUpperCase(\"hi\") satisfies \"HEY\")\n+```\n+\n+- Expected \"HEY\", found \"HI\"\n+\n #### Symmetric or\n \n ```ts\ndiff --git a/checker/specification/to_implement.md b/checker/specification/to_implement.md\n--- a/checker/specification/to_implement.md\n+++ b/checker/specification/to_implement.md\n@@ -102,6 +113,20 @@ print_type(callFunc)\n \n - Expected string, found (obj: { prop: 3 } | { prop: 2 }) => 3 | 2\n \n+#### Generics pass down\n+\n+> Too many generics here, doesn't get caught for some reason?\n+\n+```ts\n+let c: Array<number> = []\n+\n+function add() {\n+    c.push(\"hi\")\n+}\n+```\n+\n+- Type \"hi\" is not assignable to argument of type number\n+\n ### Narrowing\n \n > TODO `typeof`, `instanceof`, conditional, across a function\ndiff --git a/checker/specification/to_implement.md b/checker/specification/to_implement.md\n--- a/checker/specification/to_implement.md\n+++ b/checker/specification/to_implement.md\n@@ -306,17 +331,6 @@ a.prop3 satisfies \"prop2\"\n \n ### Collections\n \n-#### Push to array\n-\n-> Currently panics on set property diagnostic not being able to be register in apply event :(\n-\n-```ts\n-const myArray: Array<number> = [];\n-myArray.push(\"hi\")\n-```\n-\n-- Type \"hi\" is not assignable to type number\n-\n #### Simple array map\n \n ```ts\ndiff --git a/checker/specification/to_implement.md b/checker/specification/to_implement.md\n--- a/checker/specification/to_implement.md\n+++ b/checker/specification/to_implement.md\n@@ -403,14 +417,24 @@ array2[2] satisfies string;\n \n - Expected string, found 3\n \n-#### Index into array\n+### Classes\n+\n+> TODO extends\n+\n+#### Privacy\n \n ```ts\n-function getFirst(a: Array<string>) {\n-\treturn a[3]\n+class MyClass {\n+\t#a = 2;\n+\n+\tgetA(this: { #a: any }) {\n+\t\treturn this.#a\n+\t}\n }\n \n-print_type(getFirst)\n+(new MyClass).#a;\n+((new MyClass).getA() satisfies 3);\n ```\n \n-- TODO\n+- Cannot get private property \"#a\"\n+- Expected 3, found 2\ndiff --git a/checker/src/behavior/constant_functions.rs b/checker/src/behavior/constant_functions.rs\n--- a/checker/src/behavior/constant_functions.rs\n+++ b/checker/src/behavior/constant_functions.rs\n@@ -5,6 +5,7 @@ use crate::{\n \tsubtyping::check_satisfies,\n \ttypes::{\n \t\tfunctions::SynthesisedArgument, poly_types::generic_type_arguments::TypeArgumentStore,\n+\t\tprinting::debug_effects,\n \t},\n \ttypes::{poly_types::FunctionTypeArguments, printing::print_type, Type, TypeStore},\n \tConstant, Environment, TypeId,\ndiff --git a/checker/src/behavior/constant_functions.rs b/checker/src/behavior/constant_functions.rs\n--- a/checker/src/behavior/constant_functions.rs\n+++ b/checker/src/behavior/constant_functions.rs\n@@ -105,12 +106,12 @@ pub(crate) fn call_constant_function(\n \t\t\t\t});\n \t\t\t\tOk(ConstantOutput::Value(result))\n \t\t\t} else {\n+\t\t\t\t// This can occur!!\n \t\t\t\tErr(ConstantFunctionError::BadCall)\n \t\t\t}\n \t\t}\n-\t\t// TODO second argument Rust\n-\t\t\"print_type\" | \"debug_type\" => {\n-\t\t\tlet debug = id == \"debug_type\";\n+\t\t\"print_type\" | \"debug_type\" | \"debug_type_independent\" => {\n+\t\t\tlet debug = id.starts_with(\"debug\");\n \t\t\tlet ty = arguments\n \t\t\t\t.first()\n \t\t\t\t.ok_or(ConstantFunctionError::BadCall)?\ndiff --git a/checker/src/behavior/constant_functions.rs b/checker/src/behavior/constant_functions.rs\n--- a/checker/src/behavior/constant_functions.rs\n+++ b/checker/src/behavior/constant_functions.rs\n@@ -119,7 +120,16 @@ pub(crate) fn call_constant_function(\n \t\t\tlet ty_as_string = print_type(ty, types, &environment.as_general_context(), debug);\n \t\t\tOk(ConstantOutput::Diagnostic(format!(\"Type is: {ty_as_string}\")))\n \t\t}\n-\t\t\"debug_effects\" => {\n+\t\t\"debug_type_rust\" | \"debug_type_rust_independent\" => {\n+\t\t\tlet id = arguments\n+\t\t\t\t.first()\n+\t\t\t\t.ok_or(ConstantFunctionError::BadCall)?\n+\t\t\t\t.to_type()\n+\t\t\t\t.map_err(|()| ConstantFunctionError::BadCall)?;\n+\t\t\tlet ty = types.get_type_by_id(id);\n+\t\t\tOk(ConstantOutput::Diagnostic(format!(\"Type is: {id:?} = {ty:?}\")))\n+\t\t}\n+\t\t\"debug_effects_rust\" => {\n \t\t\tlet ty = arguments\n \t\t\t\t.first()\n \t\t\t\t.ok_or(ConstantFunctionError::BadCall)?\ndiff --git a/checker/src/behavior/constant_functions.rs b/checker/src/behavior/constant_functions.rs\n--- a/checker/src/behavior/constant_functions.rs\n+++ b/checker/src/behavior/constant_functions.rs\n@@ -130,12 +140,29 @@ pub(crate) fn call_constant_function(\n \t\t\t{\n \t\t\t\tlet effects =\n \t\t\t\t\t&types.functions.get(func).ok_or(ConstantFunctionError::BadCall)?.effects;\n-\t\t\t\t// TODO print using a different function\n \t\t\t\tOk(ConstantOutput::Diagnostic(format!(\"{effects:#?}\")))\n \t\t\t} else {\n \t\t\t\tOk(ConstantOutput::Diagnostic(\"not a function\".to_owned()))\n \t\t\t}\n \t\t}\n+\t\t\"debug_effects\" => {\n+\t\t\tlet ty = arguments\n+\t\t\t\t.first()\n+\t\t\t\t.ok_or(ConstantFunctionError::BadCall)?\n+\t\t\t\t.to_type()\n+\t\t\t\t.map_err(|()| ConstantFunctionError::BadCall)?;\n+\t\t\tif let Type::Function(func, _) | Type::FunctionReference(func, _) =\n+\t\t\t\ttypes.get_type_by_id(ty)\n+\t\t\t{\n+\t\t\t\tlet effects =\n+\t\t\t\t\t&types.functions.get(func).ok_or(ConstantFunctionError::BadCall)?.effects;\n+\t\t\t\tlet mut buf = String::new();\n+\t\t\t\tdebug_effects(&mut buf, effects, types, &environment.as_general_context(), true);\n+\t\t\t\tOk(ConstantOutput::Diagnostic(buf))\n+\t\t\t} else {\n+\t\t\t\tOk(ConstantOutput::Diagnostic(\"not a function\".to_owned()))\n+\t\t\t}\n+\t\t}\n \t\t// For functions\n \t\t\"bind\" => {\n \t\t\tlet on = this_argument.get_passed().map(|t| types.get_type_by_id(t));\ndiff --git a/checker/src/behavior/functions.rs b/checker/src/behavior/functions.rs\n--- a/checker/src/behavior/functions.rs\n+++ b/checker/src/behavior/functions.rs\n@@ -457,38 +457,42 @@ where\n \t\t\t\t// TODO this could be done conditionally to create less objects, but also doesn't introduce any bad side effects so\n \t\t\t\t// TODO prototype needs to be a poly based on this.prototype. This also fixes inference\n \n-\t\t\t\tlet (this_free_variable, this_constructed_object) = if let Some(this_constraint) =\n-\t\t\t\t\tthis_constraint\n-\t\t\t\t{\n-\t\t\t\t\t// TODO I don't whether NEW_TARGET_ARG should have a backer\n-\t\t\t\t\tlet prototype = checking_data.types.register_type(Type::Constructor(\n-\t\t\t\t\t\tConstructor::Property {\n-\t\t\t\t\t\t\ton: TypeId::NEW_TARGET_ARG,\n-\t\t\t\t\t\t\tunder: PropertyKey::String(Cow::Owned(\"value\".to_owned())),\n-\t\t\t\t\t\t\tresult: this_constraint,\n-\t\t\t\t\t\t},\n-\t\t\t\t\t));\n-\n-\t\t\t\t\tlet this_constructed_object = function_environment.facts.new_object(\n-\t\t\t\t\t\tSome(prototype),\n-\t\t\t\t\t\t&mut checking_data.types,\n-\t\t\t\t\t\ttrue,\n-\t\t\t\t\t);\n-\n-\t\t\t\t\tlet this_free_variable = checking_data.types.register_type(Type::RootPolyType(\n-\t\t\t\t\t\tPolyNature::FreeVariable {\n-\t\t\t\t\t\t\treference: RootReference::This,\n-\t\t\t\t\t\t\tbased_on: this_constraint,\n-\t\t\t\t\t\t},\n-\t\t\t\t\t));\n-\n-\t\t\t\t\t(this_free_variable, this_constructed_object)\n-\t\t\t\t} else {\n-\t\t\t\t\t// TODO inferred prototype\n-\t\t\t\t\tlet this_constructed_object =\n-\t\t\t\t\t\tfunction_environment.facts.new_object(None, &mut checking_data.types, true);\n-\t\t\t\t\t(TypeId::ANY_INFERRED_FREE_THIS, this_constructed_object)\n-\t\t\t\t};\n+\t\t\t\tlet (this_free_variable, this_constructed_object) =\n+\t\t\t\t\tif let Some(this_constraint) = this_constraint {\n+\t\t\t\t\t\t// TODO I don't whether NEW_TARGET_ARG should have a backer\n+\t\t\t\t\t\tlet prototype = checking_data.types.register_type(Type::Constructor(\n+\t\t\t\t\t\t\tConstructor::Property {\n+\t\t\t\t\t\t\t\ton: TypeId::NEW_TARGET_ARG,\n+\t\t\t\t\t\t\t\tunder: PropertyKey::String(Cow::Owned(\"value\".to_owned())),\n+\t\t\t\t\t\t\t\tresult: this_constraint,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t));\n+\n+\t\t\t\t\t\tlet this_constructed_object = function_environment.facts.new_object(\n+\t\t\t\t\t\t\tSome(prototype),\n+\t\t\t\t\t\t\t&mut checking_data.types,\n+\t\t\t\t\t\t\ttrue,\n+\t\t\t\t\t\t\ttrue,\n+\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\tlet this_free_variable = checking_data.types.register_type(\n+\t\t\t\t\t\t\tType::RootPolyType(PolyNature::FreeVariable {\n+\t\t\t\t\t\t\t\treference: RootReference::This,\n+\t\t\t\t\t\t\t\tbased_on: this_constraint,\n+\t\t\t\t\t\t\t}),\n+\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t(this_free_variable, this_constructed_object)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// TODO inferred prototype\n+\t\t\t\t\t\tlet this_constructed_object = function_environment.facts.new_object(\n+\t\t\t\t\t\t\tNone,\n+\t\t\t\t\t\t\t&mut checking_data.types,\n+\t\t\t\t\t\t\ttrue,\n+\t\t\t\t\t\t\ttrue,\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\t(TypeId::ANY_INFERRED_FREE_THIS, this_constructed_object)\n+\t\t\t\t\t};\n \n \t\t\t\tif let FunctionBehavior::Function { ref mut free_this_id, .. } = behavior {\n \t\t\t\t\t// TODO set object as well\ndiff --git a/checker/src/behavior/loops.rs /dev/null\n--- a/checker/src/behavior/loops.rs\n+++ /dev/null\n@@ -1,20 +0,0 @@\n-pub struct ValueWithEvents {\n-    events: Vec<Event>,\n-    value: TypeId,\n-}\n-\n-pub enum LoopBehavior {\n-    While(TypeId),\n-    For {\n-        initializer: TypeId,\n-        condition: ValueWithEvents,\n-        afterthought: ValueWithEvents\n-    }\n-}\n-\n-// TODO\n-// events -> get diff, start, end. (end - start).abs() / diff < options.loop_max\n-\n-fn evaluate() {\n-    \n-}\n\\ No newline at end of file\ndiff --git a/checker/src/behavior/mod.rs b/checker/src/behavior/mod.rs\n--- a/checker/src/behavior/mod.rs\n+++ b/checker/src/behavior/mod.rs\n@@ -8,6 +8,7 @@\n pub mod assignments;\n pub mod constant_functions;\n pub mod functions;\n+pub mod iteration;\n pub mod modules;\n pub mod objects;\n pub mod operations;\ndiff --git a/checker/src/behavior/objects.rs b/checker/src/behavior/objects.rs\n--- a/checker/src/behavior/objects.rs\n+++ b/checker/src/behavior/objects.rs\n@@ -21,7 +21,7 @@ impl ObjectBuilder {\n \tpub fn new(prototype: Option<TypeId>, types: &mut TypeStore, facts: &mut Facts) -> Self {\n \t\t// TODO is_under_dyn bad\n \t\tlet is_under_dyn = true;\n-\t\tSelf { object: facts.new_object(prototype, types, is_under_dyn) }\n+\t\tSelf { object: facts.new_object(prototype, types, is_under_dyn, false) }\n \t}\n \n \tpub fn append(\ndiff --git a/checker/src/behavior/operations.rs b/checker/src/behavior/operations.rs\n--- a/checker/src/behavior/operations.rs\n+++ b/checker/src/behavior/operations.rs\n@@ -4,15 +4,15 @@ use derive_enum_from_into::EnumFrom;\n use source_map::{Span, SpanWithSource};\n \n use crate::{\n-\tdiagnostics::TypeCheckError,\n+\tdiagnostics::{TypeCheckError, TypeStringRepresentation},\n \ttypes::{\n-\t\tcast_as_number, cast_as_string, is_type_truthy_falsy, new_logical_or_type,\n+\t\tcast_as_number, cast_as_string, is_type_truthy_falsy, new_logical_or_type, Constructor,\n \t\tStructureGenerics, TypeStore,\n \t},\n \tASTImplementation, CheckingData, Constant, Decidable, Environment, Type, TypeId,\n };\n \n-#[derive(Clone, Debug, binary_serialize_derive::BinarySerializable)]\n+#[derive(Clone, Copy, Debug, binary_serialize_derive::BinarySerializable)]\n pub enum MathematicalAndBitwise {\n \tAdd,\n \tSubtract,\ndiff --git a/checker/src/behavior/operations.rs b/checker/src/behavior/operations.rs\n--- a/checker/src/behavior/operations.rs\n+++ b/checker/src/behavior/operations.rs\n@@ -28,7 +28,7 @@ pub enum MathematicalAndBitwise {\n \tBitwiseOr,\n }\n \n-#[derive(Clone, Debug, EnumFrom)]\n+#[derive(Clone, Copy, Debug, EnumFrom)]\n pub enum PureBinaryOperation {\n \tMathematicalAndBitwise(MathematicalAndBitwise),\n \t// Some of these can be reduced\ndiff --git a/checker/src/behavior/operations.rs b/checker/src/behavior/operations.rs\n--- a/checker/src/behavior/operations.rs\n+++ b/checker/src/behavior/operations.rs\n@@ -58,7 +58,28 @@ pub fn evaluate_pure_binary_operation_handle_errors<\n \t\t\tmatch result {\n \t\t\t\tOk(result) => result,\n \t\t\t\tErr(err) => {\n-\t\t\t\t\t// checking_data.diagnostics_container.add_error(TypeCheckError::)\n+\t\t\t\t\tlet ctx = &environment.as_general_context();\n+\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n+\t\t\t\t\t\tTypeCheckError::InvalidMathematicalOrBitwiseOperation {\n+\t\t\t\t\t\t\toperator,\n+\t\t\t\t\t\t\tlhs: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\tlhs,\n+\t\t\t\t\t\t\t\tctx,\n+\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\trhs: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\trhs,\n+\t\t\t\t\t\t\t\tctx,\n+\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tposition: lhs_pos\n+\t\t\t\t\t\t\t\t.without_source()\n+\t\t\t\t\t\t\t\t.union(rhs_pos.without_source())\n+\t\t\t\t\t\t\t\t.with_source(environment.get_source()),\n+\t\t\t\t\t\t},\n+\t\t\t\t\t);\n \t\t\t\t\tTypeId::ERROR_TYPE\n \t\t\t\t}\n \t\t\t}\ndiff --git a/checker/src/behavior/operations.rs b/checker/src/behavior/operations.rs\n--- a/checker/src/behavior/operations.rs\n+++ b/checker/src/behavior/operations.rs\n@@ -85,7 +106,7 @@ pub fn evaluate_mathematical_operation(\n ) -> Result<TypeId, ()> {\n \tfn attempt_constant_math_operator(\n \t\tlhs: TypeId,\n-\t\toperator: &MathematicalAndBitwise,\n+\t\toperator: MathematicalAndBitwise,\n \t\trhs: TypeId,\n \t\ttypes: &mut TypeStore,\n \t\tstrict_casts: bool,\ndiff --git a/checker/src/behavior/operations.rs b/checker/src/behavior/operations.rs\n--- a/checker/src/behavior/operations.rs\n+++ b/checker/src/behavior/operations.rs\n@@ -156,11 +177,11 @@ pub fn evaluate_mathematical_operation(\n \t\treturn Ok(types.register_type(crate::Type::Constructor(constructor)));\n \t}\n \n-\tattempt_constant_math_operator(lhs, &operator, rhs, types, strict_casts)\n+\tattempt_constant_math_operator(lhs, operator, rhs, types, strict_casts)\n }\n \n /// Not canonical / reducible\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Copy, Debug)]\n pub enum EqualityAndInequality {\n \tStrictEqual,\n \tStrictNotEqual,\ndiff --git a/checker/src/behavior/operations.rs b/checker/src/behavior/operations.rs\n--- a/checker/src/behavior/operations.rs\n+++ b/checker/src/behavior/operations.rs\n@@ -173,16 +194,16 @@ pub enum EqualityAndInequality {\n }\n \n /// Canonical / irreducible\n-#[derive(Clone, Debug, binary_serialize_derive::BinarySerializable)]\n+#[derive(Clone, Copy, Debug, binary_serialize_derive::BinarySerializable)]\n pub enum CanonicalEqualityAndInequality {\n \tStrictEqual,\n \tLessThan,\n }\n \n pub fn evaluate_equality_inequality_operation(\n-\tlhs: TypeId,\n+\tmut lhs: TypeId,\n \toperator: &EqualityAndInequality,\n-\trhs: TypeId,\n+\tmut rhs: TypeId,\n \ttypes: &mut TypeStore,\n \tstrict_casts: bool,\n ) -> Result<TypeId, ()> {\ndiff --git a/checker/src/behavior/operations.rs b/checker/src/behavior/operations.rs\n--- a/checker/src/behavior/operations.rs\n+++ b/checker/src/behavior/operations.rs\n@@ -238,7 +259,24 @@ pub fn evaluate_equality_inequality_operation(\n \t\t\t\t|| types.get_type_by_id(rhs).is_dependent();\n \n \t\t\tif is_dependent {\n-\t\t\t\tlet constructor = crate::types::Constructor::CanonicalRelationOperator {\n+\t\t\t\tif let Type::Constructor(Constructor::BinaryOperator {\n+\t\t\t\t\tlhs: op_lhs,\n+\t\t\t\t\toperator,\n+\t\t\t\t\trhs: op_rhs,\n+\t\t\t\t}) = types.get_type_by_id(lhs)\n+\t\t\t\t{\n+\t\t\t\t\tif let (\n+\t\t\t\t\t\tType::Constant(Constant::Number(add)),\n+\t\t\t\t\t\tMathematicalAndBitwise::Add,\n+\t\t\t\t\t\tType::Constant(Constant::Number(lt)),\n+\t\t\t\t\t) = (types.get_type_by_id(*op_rhs), operator, types.get_type_by_id(rhs))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tcrate::utils::notify!(\"Shifted LT\");\n+\t\t\t\t\t\tlhs = *op_lhs;\n+\t\t\t\t\t\trhs = types.register_type(Type::Constant(Constant::Number(lt - add)));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tlet constructor = Constructor::CanonicalRelationOperator {\n \t\t\t\t\tlhs,\n \t\t\t\t\toperator: CanonicalEqualityAndInequality::LessThan,\n \t\t\t\t\trhs,\ndiff --git a/checker/src/behavior/operations.rs b/checker/src/behavior/operations.rs\n--- a/checker/src/behavior/operations.rs\n+++ b/checker/src/behavior/operations.rs\n@@ -420,7 +458,7 @@ pub fn evaluate_logical_operation_with_expression<\n \t}\n }\n \n-#[derive(Clone, Debug, binary_serialize_derive::BinarySerializable)]\n+#[derive(Clone, Copy, Debug, binary_serialize_derive::BinarySerializable)]\n pub enum PureUnary {\n \tLogicalNot,\n \tNegation,\ndiff --git a/checker/src/context/calling.rs b/checker/src/context/calling.rs\n--- a/checker/src/context/calling.rs\n+++ b/checker/src/context/calling.rs\n@@ -42,10 +42,6 @@ impl CallCheckingBehavior for CheckThings {\n }\n \n pub(crate) struct Target(Vec<TargetKind>);\n-//  {\n-// \t// facts: Facts,\n-// \t// function_id: Vec<FunctionId>,\n-// }\n \n pub(crate) enum TargetKind {\n \tConditional(Facts),\ndiff --git a/checker/src/context/calling.rs b/checker/src/context/calling.rs\n--- a/checker/src/context/calling.rs\n+++ b/checker/src/context/calling.rs\n@@ -89,8 +85,8 @@ impl Target {\n \n \tpub(crate) fn new_conditional_target(\n \t\t&mut self,\n-\t\tcb: impl for<'a> FnOnce(&'a mut Target) -> EarlyReturn,\n-\t) -> (Facts, EarlyReturn) {\n+\t\tcb: impl for<'a> FnOnce(&'a mut Target) -> Option<EventResult>,\n+\t) -> (Facts, Option<EventResult>) {\n \t\tself.0.push(TargetKind::Conditional(Facts::default()));\n \t\tlet result = cb(self);\n \t\tif let Some(TargetKind::Conditional(facts)) = self.0.pop() {\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -1,5 +1,5 @@\n use source_map::{SourceId, Span, SpanWithSource};\n-use std::collections::HashSet;\n+use std::collections::{HashMap, HashSet};\n \n use crate::{\n \tbehavior::{\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -14,7 +14,7 @@ use crate::{\n \t\t},\n \t\tvariables::{VariableMutability, VariableOrImport, VariableWithValue},\n \t},\n-\tdiagnostics::{TypeCheckError, TypeStringRepresentation},\n+\tdiagnostics::{NotInLoopOrCouldNotFindLabel, TypeCheckError, TypeStringRepresentation, TDZ},\n \tevents::{Event, RootReference},\n \tsubtyping::BasicEquality,\n \ttypes::{\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -30,8 +30,8 @@ use crate::{\n use super::{\n \tcalling::CheckThings,\n \tfacts::{Facts, Publicity},\n-\tget_value_of_variable, AssignmentError, ClosedOverReferencesInScope, Context, ContextType,\n-\tEnvironment, GeneralContext, SetPropertyError,\n+\tget_on_ctx, get_value_of_variable, AssignmentError, ClosedOverReferencesInScope, Context,\n+\tContextType, Environment, GeneralContext, SetPropertyError,\n };\n \n pub type ContextLocation = Option<String>;\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -49,7 +49,7 @@ pub struct Syntax<'a> {\n \t/// Not to be confused with `used_parent_references`\n \tpub closed_over_references: ClosedOverReferencesInScope,\n \n-\t/// TODO WIP!\n+\t/// TODO WIP! server, client, worker etc\n \tpub location: ContextLocation,\n }\n \ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -66,6 +66,10 @@ impl<'a> ContextType for Syntax<'a> {\n \t\tmatches!(self.scope, Scope::Function { .. } | Scope::Looping { .. })\n \t}\n \n+\tfn is_conditional(&self) -> bool {\n+\t\tmatches!(self.scope, Scope::Conditional { .. })\n+\t}\n+\n \tfn get_closed_over_references(&mut self) -> Option<&mut ClosedOverReferencesInScope> {\n \t\tSome(&mut self.closed_over_references)\n \t}\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -111,6 +115,8 @@ pub enum FunctionScope {\n \t},\n }\n \n+pub type Label = Option<String>;\n+\n /// TODO name of structure\n /// TODO conditionals should have conditional proofs (separate from the ones on context)\n #[derive(Debug, Clone)]\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -124,10 +130,12 @@ pub enum Scope {\n \tConditional {\n \t\t/// Something that is truthy for this to run\n \t\tantecedent: TypeId,\n+\n+\t\tis_switch: Option<Label>,\n \t},\n \t/// Variables here are dependent on the iteration,\n \tLooping {\n-\t\t// TODO on: Proofs,\n+\t\tlabel: Label, // TODO on: Proofs,\n \t},\n \tTryBlock {},\n \t// Just blocks and modules\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -224,7 +232,7 @@ impl<'a> Environment<'a> {\n \n \t\t\t\tfn set_property_error_to_type_check_error(\n \t\t\t\t\tctx: &GeneralContext,\n-\t\t\t\t\terror: &SetPropertyError,\n+\t\t\t\t\terror: SetPropertyError,\n \t\t\t\t\tassignment_span: SpanWithSource,\n \t\t\t\t\ttypes: &TypeStore,\n \t\t\t\t\tnew: TypeId,\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -233,20 +241,16 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\tSetPropertyError::NotWriteable => {\n \t\t\t\t\t\t\tTypeCheckError::PropertyNotWriteable(assignment_span)\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tSetPropertyError::DoesNotMeetConstraint(constraint, _) => {\n-\t\t\t\t\t\t\tTypeCheckError::AssignmentError(AssignmentError::PropertyConstraint {\n-\t\t\t\t\t\t\t\tproperty_type: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\t\t\t*constraint,\n-\t\t\t\t\t\t\t\t\tctx,\n-\t\t\t\t\t\t\t\t\ttypes,\n-\t\t\t\t\t\t\t\t\tfalse,\n-\t\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\t\tvalue_type: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\t\t\tnew, ctx, types, false,\n-\t\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\t\tassignment_position: assignment_span,\n-\t\t\t\t\t\t\t})\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tSetPropertyError::DoesNotMeetConstraint {\n+\t\t\t\t\t\t\tproperty_constraint,\n+\t\t\t\t\t\t\treason: _,\n+\t\t\t\t\t\t} => TypeCheckError::AssignmentError(AssignmentError::PropertyConstraint {\n+\t\t\t\t\t\t\tproperty_constraint,\n+\t\t\t\t\t\t\tvalue_type: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\tnew, ctx, types, false,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tassignment_position: assignment_span,\n+\t\t\t\t\t\t}),\n \t\t\t\t\t}\n \t\t\t\t}\n \ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -264,7 +268,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\t\tErr(error) => {\n \t\t\t\t\t\t\t\tlet error = set_property_error_to_type_check_error(\n \t\t\t\t\t\t\t\t\t&self.as_general_context(),\n-\t\t\t\t\t\t\t\t\t&error,\n+\t\t\t\t\t\t\t\t\terror,\n \t\t\t\t\t\t\t\t\tassignment_span,\n \t\t\t\t\t\t\t\t\t&checking_data.types,\n \t\t\t\t\t\t\t\t\tnew,\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -302,7 +306,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\t\tErr(error) => {\n \t\t\t\t\t\t\t\tlet error = set_property_error_to_type_check_error(\n \t\t\t\t\t\t\t\t\t&self.as_general_context(),\n-\t\t\t\t\t\t\t\t\t&error,\n+\t\t\t\t\t\t\t\t\terror,\n \t\t\t\t\t\t\t\t\tassignment_span,\n \t\t\t\t\t\t\t\t\t&checking_data.types,\n \t\t\t\t\t\t\t\t\tnew,\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -348,7 +352,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\t\tErr(error) => {\n \t\t\t\t\t\t\t\tlet error = set_property_error_to_type_check_error(\n \t\t\t\t\t\t\t\t\t&self.as_general_context(),\n-\t\t\t\t\t\t\t\t\t&error,\n+\t\t\t\t\t\t\t\t\terror,\n \t\t\t\t\t\t\t\t\tassignment_span,\n \t\t\t\t\t\t\t\t\t&checking_data.types,\n \t\t\t\t\t\t\t\t\tnew,\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -378,7 +382,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\t\tErr(error) => {\n \t\t\t\t\t\t\t\tlet error = set_property_error_to_type_check_error(\n \t\t\t\t\t\t\t\t\t&self.as_general_context(),\n-\t\t\t\t\t\t\t\t\t&error,\n+\t\t\t\t\t\t\t\t\terror,\n \t\t\t\t\t\t\t\t\tassignment_span,\n \t\t\t\t\t\t\t\t\t&checking_data.types,\n \t\t\t\t\t\t\t\t\tnew,\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -559,7 +563,6 @@ impl<'a> Environment<'a> {\n \t\t\ton,\n \t\t\tunder,\n \t\t\tnew: PropertyValue::Deleted,\n-\t\t\treflects_dependency: None,\n \t\t\tinitialization: false,\n \t\t\tpublicity: Publicity::Public,\n \t\t\tposition: None,\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -717,11 +720,13 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\t\t// TODO temp\n \t\t\t\t\t\t\tif matches!(ty, Type::Function(..)) {\n \t\t\t\t\t\t\t\treturn Ok(VariableWithValue(og_var.clone(), current_value));\n-\t\t\t\t\t\t\t} else if let Type::RootPolyType(PolyNature::Open(ot)) = ty {\n-\t\t\t\t\t\t\t\tcrate::utils::notify!(\n-\t\t\t\t\t\t\t\t\t\"Open poly type treated as immutable free variable\"\n-\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t\treturn Ok(VariableWithValue(og_var.clone(), *ot));\n+\t\t\t\t\t\t\t} else if let Type::RootPolyType(PolyNature::Open(_)) = ty {\n+\t\t\t\t\t\t\t\t// crate::utils::notify!(\n+\t\t\t\t\t\t\t\t// \t\"Open poly type treated as immutable free variable\"\n+\t\t\t\t\t\t\t\t// );\n+\t\t\t\t\t\t\t\treturn Ok(VariableWithValue(og_var.clone(), current_value));\n+\t\t\t\t\t\t\t} else if let Type::Constant(_) = ty {\n+\t\t\t\t\t\t\t\treturn Ok(VariableWithValue(og_var.clone(), current_value));\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\tcrate::utils::notify!(\"Free variable!\");\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -737,6 +742,19 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tVariableMutability::Mutable { reassignment_constraint } => {\n+\t\t\t\t\t// TODO is there a nicer way to do this\n+\t\t\t\t\t// Look for reassignments\n+\t\t\t\t\tfor p in self.parents_iter() {\n+\t\t\t\t\t\tif let Some(value) =\n+\t\t\t\t\t\t\tget_on_ctx!(p.facts.variable_current_value.get(&og_var.get_id()))\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\treturn Ok(VariableWithValue(og_var.clone(), *value));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif get_on_ctx!(p.context_type.is_dynamic_boundary()) {\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n \t\t\t\t\tif let Some(constraint) = reassignment_constraint {\n \t\t\t\t\t\tconstraint\n \t\t\t\t\t} else {\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -801,7 +819,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\tof,\n \t\t\t\t\tNone::<&crate::types::poly_types::FunctionTypeArguments>,\n \t\t\t\t)\n-\t\t\t\t.expect(\"variable not assigned yet\");\n+\t\t\t\t.expect(\"import not assigned yet\");\n \t\t\t\treturn Ok(VariableWithValue(og_var.clone(), current_value));\n \t\t\t}\n \ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -809,9 +827,16 @@ impl<'a> Environment<'a> {\n \t\t\t\tself.facts_chain(),\n \t\t\t\tog_var.get_id(),\n \t\t\t\tNone::<&crate::types::poly_types::FunctionTypeArguments>,\n-\t\t\t)\n-\t\t\t.expect(\"variable not assigned yet\");\n-\t\t\tOk(VariableWithValue(og_var.clone(), current_value))\n+\t\t\t);\n+\t\t\tif let Some(current_value) = current_value {\n+\t\t\t\tOk(VariableWithValue(og_var.clone(), current_value))\n+\t\t\t} else {\n+\t\t\t\tchecking_data.diagnostics_container.add_error(TypeCheckError::TDZ(TDZ {\n+\t\t\t\t\tvariable_name: self.get_variable_name(og_var.get_id()).to_owned(),\n+\t\t\t\t\tposition,\n+\t\t\t\t}));\n+\t\t\t\tOk(VariableWithValue(og_var.clone(), TypeId::ERROR_TYPE))\n+\t\t\t}\n \t\t}\n \t}\n \ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -839,8 +864,10 @@ impl<'a> Environment<'a> {\n \t\t}\n \n \t\tlet (truthy_result, truthy_events) = {\n-\t\t\tlet mut truthy_environment =\n-\t\t\t\tself.new_lexical_environment(Scope::Conditional { antecedent: condition });\n+\t\t\tlet mut truthy_environment = self.new_lexical_environment(Scope::Conditional {\n+\t\t\t\tantecedent: condition,\n+\t\t\t\tis_switch: None,\n+\t\t\t});\n \n \t\t\tlet result = then_evaluate(&mut truthy_environment, checking_data);\n \ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -850,6 +877,7 @@ impl<'a> Environment<'a> {\n \t\tif let Some(else_evaluate) = else_evaluate {\n \t\t\tlet mut falsy_environment = self.new_lexical_environment(Scope::Conditional {\n \t\t\t\tantecedent: checking_data.types.new_logical_negation_type(condition),\n+\t\t\t\tis_switch: None,\n \t\t\t});\n \n \t\t\tlet falsy_result = else_evaluate(&mut falsy_environment, checking_data);\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -893,6 +921,44 @@ impl<'a> Environment<'a> {\n \t\tself.facts.events.push(Event::Return { returned, returned_position });\n \t}\n \n+\tpub fn add_continue(\n+\t\t&mut self,\n+\t\tlabel: Option<&str>,\n+\t\tposition: Span,\n+\t) -> Result<(), NotInLoopOrCouldNotFindLabel> {\n+\t\tif let Some(carry) = self.find_label_or_conditional_count(label, true) {\n+\t\t\tself.facts.events.push(Event::Continue {\n+\t\t\t\tposition: Some(position.with_source(self.get_source())),\n+\t\t\t\tcarry,\n+\t\t\t});\n+\t\t\tOk(())\n+\t\t} else {\n+\t\t\tErr(NotInLoopOrCouldNotFindLabel {\n+\t\t\t\tlabel: label.map(ToOwned::to_owned),\n+\t\t\t\tposition: position.with_source(self.get_source()),\n+\t\t\t})\n+\t\t}\n+\t}\n+\n+\tpub fn add_break(\n+\t\t&mut self,\n+\t\tlabel: Option<&str>,\n+\t\tposition: Span,\n+\t) -> Result<(), NotInLoopOrCouldNotFindLabel> {\n+\t\tif let Some(carry) = self.find_label_or_conditional_count(label, false) {\n+\t\t\tself.facts.events.push(Event::Break {\n+\t\t\t\tposition: Some(position.with_source(self.get_source())),\n+\t\t\t\tcarry,\n+\t\t\t});\n+\t\t\tOk(())\n+\t\t} else {\n+\t\t\tErr(NotInLoopOrCouldNotFindLabel {\n+\t\t\t\tlabel: label.map(ToOwned::to_owned),\n+\t\t\t\tposition: position.with_source(self.get_source()),\n+\t\t\t})\n+\t\t}\n+\t}\n+\n \t/// Updates **a existing property**\n \t///\n \t/// Returns the result of the setter... TODO could return new else\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -917,6 +983,52 @@ impl<'a> Environment<'a> {\n \t\t)\n \t}\n \n+\t/// `continue` has different behavior to `break` right?\n+\tfn find_label_or_conditional_count(\n+\t\t&self,\n+\t\tlooking_for_label: Option<&str>,\n+\t\tis_continue: bool,\n+\t) -> Option<u8> {\n+\t\tlet mut falling_through_structures = 0;\n+\t\tfor ctx in self.parents_iter() {\n+\t\t\tif let GeneralContext::Syntax(ctx) = ctx {\n+\t\t\t\tlet scope = &ctx.context_type.scope;\n+\n+\t\t\t\tmatch scope {\n+\t\t\t\t\tScope::Function(_)\n+\t\t\t\t\t| Scope::InterfaceEnvironment { .. }\n+\t\t\t\t\t| Scope::FunctionAnnotation {}\n+\t\t\t\t\t| Scope::Module { .. }\n+\t\t\t\t\t| Scope::DefinitionModule { .. }\n+\t\t\t\t\t| Scope::TypeAlias\n+\t\t\t\t\t| Scope::StaticBlock {} => {\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tScope::Looping { ref label } => {\n+\t\t\t\t\t\tif looking_for_label.is_none() {\n+\t\t\t\t\t\t\treturn Some(falling_through_structures);\n+\t\t\t\t\t\t} else if let Some(label) = label {\n+\t\t\t\t\t\t\tif label == looking_for_label.unwrap() {\n+\t\t\t\t\t\t\t\treturn Some(falling_through_structures);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tfalling_through_structures += 1;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tScope::Conditional { is_switch: Some(label @ Some(_)), .. }\n+\t\t\t\t\t\tif !is_continue && looking_for_label.is_some() =>\n+\t\t\t\t\t{\n+\t\t\t\t\t\ttodo!(\"switch break\")\n+\t\t\t\t\t}\n+\t\t\t\t\tScope::PassThrough { .. }\n+\t\t\t\t\t| Scope::Conditional { .. }\n+\t\t\t\t\t| Scope::TryBlock {}\n+\t\t\t\t\t| Scope::Block {} => {}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tNone\n+\t}\n+\n \tpub(crate) fn import_items<\n \t\t'b,\n \t\tP: Iterator<Item = NamePair<'b>>,\ndiff --git a/checker/src/context/facts.rs b/checker/src/context/facts.rs\n--- a/checker/src/context/facts.rs\n+++ b/checker/src/context/facts.rs\n@@ -60,7 +60,6 @@ impl Facts {\n \t\t\t\ton,\n \t\t\t\tunder,\n \t\t\t\tnew: to,\n-\t\t\t\treflects_dependency: None,\n \t\t\t\tinitialization: true,\n \t\t\t\tpublicity,\n \t\t\t\tposition,\ndiff --git a/checker/src/context/facts.rs b/checker/src/context/facts.rs\n--- a/checker/src/context/facts.rs\n+++ b/checker/src/context/facts.rs\n@@ -81,7 +80,9 @@ impl Facts {\n \t\t&mut self,\n \t\tprototype: Option<TypeId>,\n \t\ttypes: &mut crate::types::TypeStore,\n+\t\t// TODO if this on environment instead it could be worked out?\n \t\tis_under_dyn: bool,\n+\t\tis_function_this: bool,\n \t) -> TypeId {\n \t\tlet ty = types.register_type(Type::Object(crate::types::ObjectNature::RealDeal));\n \t\t// crate::utils::notify!(\"New object created under {:?}\", ty);\ndiff --git a/checker/src/context/facts.rs b/checker/src/context/facts.rs\n--- a/checker/src/context/facts.rs\n+++ b/checker/src/context/facts.rs\n@@ -98,8 +99,12 @@ impl Facts {\n \t\t\t// TODO maybe register the environment if function ...\n \t\t\t// TODO register properties\n \t\t\t// TODO Needs a position (or not?)\n-\t\t\tlet value =\n-\t\t\t\tEvent::CreateObject { referenced_in_scope_as: ty, prototype, position: None };\n+\t\t\tlet value = Event::CreateObject {\n+\t\t\t\treferenced_in_scope_as: ty,\n+\t\t\t\tprototype,\n+\t\t\t\tposition: None,\n+\t\t\t\tis_function_this,\n+\t\t\t};\n \t\t\tself.events.push(value);\n \t\t}\n \ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -30,7 +30,7 @@ use crate::{\n \tevents::{Event, RootReference},\n \tsubtyping::{type_is_subtype, BasicEquality},\n \ttypes::{\n-\t\tself, create_this_before_function_synthesis,\n+\t\tself, create_this_before_function_synthesis, get_constraint,\n \t\tpoly_types::{generic_type_arguments::StructureGenericArguments, FunctionTypeArguments},\n \t\tproperties::{PropertyKey, PropertyValue},\n \t\tConstructor, FunctionType, PolyNature, Type, TypeId, TypeStore,\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -131,6 +131,9 @@ pub trait ContextType: Sized {\n \t/// Variables **above** this scope may change *between runs*\n \tfn is_dynamic_boundary(&self) -> bool;\n \n+\t/// Branch might not be run\n+\tfn is_conditional(&self) -> bool;\n+\n \tfn get_closed_over_references(&mut self) -> Option<&mut ClosedOverReferencesInScope>;\n \n \tfn get_exports(&mut self) -> Option<&mut Exported>;\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -179,6 +182,9 @@ pub struct Context<T: ContextType> {\n \t/// TODO replace with facts.value_of_this\n \tpub(crate) can_reference_this: CanReferenceThis,\n \n+\t/// When a objects `TypeId` is in here getting a property returns a constructor rather than\n+\tpub possibly_mutated_objects: HashSet<TypeId>,\n+\n \t// pub (crate) facts: Facts,\n \tpub facts: Facts,\n }\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -491,220 +497,6 @@ impl<T: ContextType> Context<T> {\n \t\tbuf\n \t}\n \n-\t/// Finds the constraint of poly types\n-\tpub(crate) fn get_poly_base(&self, on: TypeId, types: &TypeStore) -> Option<TypeId> {\n-\t\tmatch types.get_type_by_id(on) {\n-\t\t\tType::RootPolyType(nature) => {\n-\t\t\t\tfn does_type_have_mutable_constraint<T: ContextType>(\n-\t\t\t\t\tcontext: &Context<T>,\n-\t\t\t\t\ton: TypeId,\n-\t\t\t\t) -> bool {\n-\t\t\t\t\tcontext.parents_iter().any(|env| {\n-\t\t\t\t\t\tif let GeneralContext::Syntax(syn) = env {\n-\t\t\t\t\t\t\tsyn.bases.does_type_have_mutable_base(on)\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tfalse\n-\t\t\t\t\t\t}\n-\t\t\t\t\t})\n-\t\t\t\t}\n-\n-\t\t\t\tlet based_on = match nature {\n-\t\t\t\t\tPolyNature::Parameter { fixed_to } => fixed_to,\n-\t\t\t\t\tPolyNature::Generic { name, eager_fixed } => eager_fixed,\n-\t\t\t\t\tPolyNature::Open(ty) => ty,\n-\t\t\t\t\tPolyNature::FreeVariable { reference, based_on } => based_on,\n-\t\t\t\t\tPolyNature::RecursiveFunction(_, return_ty) => return_ty,\n-\t\t\t\t};\n-\n-\t\t\t\t// TODO not sure\n-\n-\t\t\t\tSome(*based_on)\n-\n-\t\t\t\t// // TODO into function\n-\t\t\t\t// match nature.get_poly_pointer() {\n-\t\t\t\t// \tPolyPointer::Fixed(to) => Some(PolyBase::Fixed {\n-\t\t\t\t// \t\tto,\n-\t\t\t\t// \t\tis_open_poly: matches!(nature, PolyNature::Open(..)),\n-\t\t\t\t// \t}),\n-\t\t\t\t// \tPolyPointer::Inferred(boundary) => {\n-\t\t\t\t// \t\tlet to = self\n-\t\t\t\t// \t\t\t.parents_iter()\n-\t\t\t\t// \t\t\t.find_map(|ctx| get_on_ctx!(ctx.bases.get_local_type_base(on)))\n-\t\t\t\t// \t\t\t// TODO temp\n-\t\t\t\t// \t\t\t.unwrap_or_else(|| {\n-\t\t\t\t// \t\t\t\tcrate::utils::notify!(\"No type base on inferred poly type\");\n-\t\t\t\t// \t\t\t\tTypeId::ANY_TYPE\n-\t\t\t\t// \t\t\t});\n-\n-\t\t\t\t// \t\tSome(PolyBase::Dynamic { to, boundary })\n-\t\t\t\t// \t}\n-\t\t\t\t// }\n-\n-\t\t\t\t// if let Some(to) = .m {\n-\t\t\t\t// \tSome(PolyBase::Fixed {\n-\t\t\t\t// \t\tto,\n-\t\t\t\t// \t\tis_open_poly: matches!(nature, PolyNature::Open(_)),\n-\t\t\t\t// \t})\n-\t\t\t\t// } else {\n-\t\t\t\t// \tSome(PolyBase::Dynamic { to: (), boundary: () })\n-\n-\t\t\t\t// \t// let modified_base =\n-\t\t\t\t// \t// \tself.parents_iter().find_map(|env| get_on_ctx!(env.bases.get(&on)).copied());\n-\n-\t\t\t\t// \t// let aliases = modified_base.unwrap_or(*aliases);\n-\n-\t\t\t\t// \t// Some(if constraint_is_mutable {\n-\t\t\t\t// \t// \tPolyBase::Dynamic(aliases)\n-\t\t\t\t// \t// } else {\n-\t\t\t\t// \t// })\n-\t\t\t\t// }\n-\t\t\t}\n-\t\t\tType::Constructor(constructor) => match constructor.clone() {\n-\t\t\t\tConstructor::BinaryOperator { lhs, operator, rhs } => {\n-\t\t\t\t\tif let MathematicalAndBitwise::Add = operator {\n-\t\t\t\t\t\tlet lhs = self.get_thingy(lhs, types);\n-\t\t\t\t\t\tlet rhs = self.get_thingy(rhs, types);\n-\t\t\t\t\t\t// TODO these need to be generated\n-\t\t\t\t\t\tif let (TypeId::NUMBER_TYPE, TypeId::NUMBER_TYPE) = (lhs, rhs) {\n-\t\t\t\t\t\t\tSome(TypeId::NUMBER_TYPE)\n-\t\t\t\t\t\t} else if let (TypeId::STRING_TYPE, _) | (_, TypeId::STRING_TYPE) =\n-\t\t\t\t\t\t\t(lhs, rhs)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tSome(TypeId::STRING_TYPE)\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t// TODO new conditional\n-\t\t\t\t\t\t\ttodo!(\"needs conditional {:?} {:?}\", lhs, rhs)\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tSome(TypeId::NUMBER_TYPE)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tConstructor::UnaryOperator { operand, operator } => {\n-\t\t\t\t\ttodo!()\n-\t\t\t\t\t// if *constraint == TypeId::ANY_TYPE && mutable_context {\n-\t\t\t\t\t// \tlet (operand, operator) = (operand.clone(), operator.clone());\n-\t\t\t\t\t// \tlet constraint = to(self, data);\n-\t\t\t\t\t// \tself.modify_type(\n-\t\t\t\t\t// \t\ton,\n-\t\t\t\t\t// \t\tSome(Type::Constructor(Constructor::UnaryOperator {\n-\t\t\t\t\t// \t\t\toperator,\n-\t\t\t\t\t// \t\t\toperand,\n-\t\t\t\t\t// \t\t\t\t\t\t\t\t// \t\t})),\n-\t\t\t\t\t// \t);\n-\t\t\t\t\t// \tSome(constraint)\n-\t\t\t\t\t// } else {\n-\t\t\t\t\t// \tSome(*constraint)\n-\t\t\t\t\t// }\n-\t\t\t\t}\n-\t\t\t\tConstructor::FunctionResult { on, with, result } => {\n-\t\t\t\t\tSome(result)\n-\t\t\t\t\t// TODO temp\n-\t\t\t\t\t// if let PolyPointer::Fixed(result) = result {\n-\t\t\t\t\t// \tSome(PolyBase::Fixed { to: result, is_open_poly: true })\n-\t\t\t\t\t// } else {\n-\t\t\t\t\t// \tlet on_base_function = self.get_poly_base(on, types);\n-\t\t\t\t\t// \tif let Some(base) = on_base_function {\n-\t\t\t\t\t// \t\tlet (boundary, is_open_poly, ty) = base.unravel();\n-\t\t\t\t\t// \t\tif let Type::Function(func, _) = types.get_type_by_id(ty) {\n-\t\t\t\t\t// \t\t\tSome(func.return_type)\n-\t\t\t\t\t// \t\t} else {\n-\t\t\t\t\t// \t\t\ttodo!()\n-\t\t\t\t\t// \t\t}\n-\t\t\t\t\t// \t} else {\n-\t\t\t\t\t// \t\t// TODO record ahead of time, rather than recalculating here\n-\t\t\t\t\t// \t\tlet is_open_poly = with\n-\t\t\t\t\t// \t\t\t.iter()\n-\t\t\t\t\t// \t\t\t.filter_map(|arg| {\n-\t\t\t\t\t// \t\t\t\tself.get_poly_base(arg.into_type().unwrap(), types)\n-\t\t\t\t\t// \t\t\t})\n-\t\t\t\t\t// \t\t\t.all(|base| base.is_open_poly());\n-\n-\t\t\t\t\t// \t\tlet ty = types.get_type_by_id(on);\n-\t\t\t\t\t// \t\tif let Type::Function(func, _) = ty {\n-\t\t\t\t\t// \t\t\t// TODO\n-\t\t\t\t\t// \t\t\tSome(func.return_type)\n-\t\t\t\t\t// \t\t} else {\n-\t\t\t\t\t// \t\t\tlet on = crate::types::printing::print_type(\n-\t\t\t\t\t// \t\t\t\ton,\n-\t\t\t\t\t// \t\t\t\ttypes,\n-\t\t\t\t\t// \t\t\t\t&self.into_general_context(),\n-\t\t\t\t\t// \t\t\t\ttrue,\n-\t\t\t\t\t// \t\t\t);\n-\t\t\t\t\t// \t\t\tunreachable!(\"Getting function on {}\", on);\n-\t\t\t\t\t// \t\t}\n-\t\t\t\t\t// \t}\n-\t\t\t\t\t// }\n-\t\t\t\t}\n-\t\t\t\tConstructor::Property { on, under, result } => {\n-\t\t\t\t\tSome(result)\n-\n-\t\t\t\t\t// `on` or `under` will be poly, but one of them may be a non-poly\n-\t\t\t\t\t// type and so it can be expected to be `None` here.\n-\t\t\t\t\t// TODO needs better primitives for controlling this\n-\t\t\t\t\t// let on_constraint = self.get_poly_base(on, types).unwrap_or(on);\n-\t\t\t\t\t// let property = match under {\n-\t\t\t\t\t// \tPropertyKey::Type(ty) => {\n-\t\t\t\t\t// \t\tPropertyKey::Type(self.get_poly_base(ty, types).unwrap_or(ty))\n-\t\t\t\t\t// \t}\n-\t\t\t\t\t// \tprop => prop,\n-\t\t\t\t\t// };\n-\n-\t\t\t\t\t// Bad\n-\t\t\t\t\t// let is_open_poly =\n-\t\t\t\t\t// \ton_constraint.as_ref().map(PolyBase::is_open_poly).unwrap_or(true)\n-\t\t\t\t\t// \t\t&& property_constraint\n-\t\t\t\t\t// \t\t\t.as_ref()\n-\t\t\t\t\t// \t\t\t.map(PolyBase::is_open_poly)\n-\t\t\t\t\t// \t\t\t.unwrap_or(true);\n-\n-\t\t\t\t\t// let on_base = on_constraint.unwrap_or(on);\n-\t\t\t\t\t// let property_base = property_constraint.unwrap_or(under);\n-\n-\t\t\t\t\t// TODO abstract to function\n-\t\t\t\t\t// let (on_boundary, _, on_constraint) = on_base.unravel();\n-\t\t\t\t\t// let (property_fixed, _, property_constraint) = property_base.unravel();\n-\n-\t\t\t\t\t// TODO temp\n-\t\t\t\t\t// let result = result self\n-\t\t\t\t\t// \t.get_property_unbound(on_constraint, PublicityKind::Public, property, types)\n-\t\t\t\t\t// \t.map(|property| match property {\n-\t\t\t\t\t// \t\tLogical::Pure(PropertyValue::Value(v)) => v,\n-\t\t\t\t\t// \t\t// TODO not sure?\n-\t\t\t\t\t// \t\tLogical::Pure(PropertyValue::Getter(g)) => g.return_type,\n-\t\t\t\t\t// \t\tresult => todo!(\"{:?}\", result),\n-\t\t\t\t\t// \t})\n-\t\t\t\t\t// \t.expect(\"Inference failed\");\n-\t\t\t\t}\n-\t\t\t\tConstructor::ConditionalResult { result_union, .. } => {\n-\t\t\t\t\t// TODO dynamic and open poly\n-\t\t\t\t\tSome(result_union)\n-\t\t\t\t}\n-\t\t\t\tConstructor::TypeOperator(_) | Constructor::CanonicalRelationOperator { .. } => {\n-\t\t\t\t\t// TODO open poly\n-\t\t\t\t\tSome(TypeId::BOOLEAN_TYPE)\n-\t\t\t\t}\n-\t\t\t\tConstructor::TypeRelationOperator(op) => match op {\n-\t\t\t\t\tcrate::types::TypeRelationOperator::Extends { .. } => {\n-\t\t\t\t\t\tSome(TypeId::BOOLEAN_TYPE)\n-\t\t\t\t\t}\n-\t\t\t\t},\n-\t\t\t\t// TODO sure?\n-\t\t\t\tConstructor::StructureGenerics { .. } => None,\n-\t\t\t},\n-\t\t\t_ => None,\n-\t\t}\n-\t}\n-\n-\tfn get_thingy(&self, on: TypeId, types: &TypeStore) -> TypeId {\n-\t\tif let Some(poly_base) = self.get_poly_base(on, types) {\n-\t\t\tpoly_base\n-\t\t} else if let Type::Constant(cst) = types.get_type_by_id(on) {\n-\t\t\tcst.get_backing_type_id()\n-\t\t} else {\n-\t\t\ton\n-\t\t}\n-\t}\n-\n \t/// Only on current environment, doesn't walk\n \tfn get_this_constraint(&self) -> Option<TypeId> {\n \t\tmatch self.as_general_context() {\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -775,7 +567,9 @@ impl<T: ContextType> Context<T> {\n \t/// Get all properties on a type (for printing and other non one property uses)\n \t///\n \t/// - TODO make aware of ands and aliases\n+\t/// - TODO prototypes\n \t/// - TODO could this be an iterator\n+\t/// - TODO return whether it is fixed\n \tpub fn get_properties_on_type(\n \t\t&self,\n \t\tbase: TypeId,\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -866,9 +660,7 @@ impl<T: ContextType> Context<T> {\n \t\t\ttodo!()\n \t\t} else {\n \t\t\tlet under = match under {\n-\t\t\t\tPropertyKey::Type(t) => {\n-\t\t\t\t\tPropertyKey::Type(self.get_poly_base(t, types).unwrap_or(t))\n-\t\t\t\t}\n+\t\t\t\tPropertyKey::Type(t) => PropertyKey::Type(get_constraint(t, types).unwrap_or(t)),\n \t\t\t\tunder @ PropertyKey::String(_) => under,\n \t\t\t};\n \t\t\ttypes.get_fact_about_type(self, on, &get_property, (publicity, &under))\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -881,7 +673,10 @@ impl<T: ContextType> Context<T> {\n \t}\n \n \tpub(crate) fn get_variable_name(&self, id: VariableId) -> &str {\n-\t\tself.parents_iter().find_map(|env| get_on_ctx!(env.variable_names.get(&id))).unwrap()\n+\t\t// TODO map_or temp\n+\t\tself.parents_iter()\n+\t\t\t.find_map(|env| get_on_ctx!(env.variable_names.get(&id)))\n+\t\t\t.map_or(\"could not find\", String::as_str)\n \t}\n \n \tpub fn as_general_context(&self) -> GeneralContext {\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -935,6 +730,7 @@ impl<T: ContextType> Context<T> {\n \t\t\tfacts: Default::default(),\n \t\t\tobject_constraints: Default::default(),\n \t\t\tbases: Default::default(),\n+\t\t\tpossibly_mutated_objects: Default::default(),\n \t\t}\n \t}\n \ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -981,7 +777,7 @@ impl<T: ContextType> Context<T> {\n \t\tscope: Scope,\n \t\tchecking_data: &mut CheckingData<U, A>,\n \t\tcb: impl for<'a> FnOnce(&'a mut Environment, &'a mut CheckingData<U, A>) -> Res,\n-\t) -> (Res, Option<(Vec<Event>, ClosedOverReferencesInScope)>, ContextId) {\n+\t) -> (Res, Option<(Facts, ClosedOverReferencesInScope)>, ContextId) {\n \t\tif matches!(scope, Scope::Conditional { .. }) {\n \t\t\tunreachable!(\"Use Environment::new_conditional_context\")\n \t\t}\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1009,11 +805,13 @@ impl<T: ContextType> Context<T> {\n \t\t\tobject_constraints,\n \t\t\tdeferred_function_constraints,\n \t\t\tmut facts,\n+\t\t\tpossibly_mutated_objects,\n \t\t} = new_environment;\n \n \t\tself.bases.merge(bases, self.context_id);\n \n \t\tself.variable_names.extend(variable_names);\n+\t\tself.possibly_mutated_objects.extend(possibly_mutated_objects);\n \n \t\t// TODO\n \t\t// self.tasks_to_run.extend(tasks_to_run.into_iter());\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1031,7 +829,7 @@ impl<T: ContextType> Context<T> {\n \t\t\tScope::FunctionAnnotation {} => None,\n \t\t\t// TODO temp\n \t\t\tScope::Function(FunctionScope::Constructor { .. }) | Scope::Looping { .. } => {\n-\t\t\t\tSome((facts.events, used_parent_references))\n+\t\t\t\tSome((facts, used_parent_references))\n \t\t\t}\n \t\t\tScope::Function { .. } => {\n \t\t\t\tunreachable!(\"use new_function\")\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1052,6 +850,7 @@ impl<T: ContextType> Context<T> {\n \t\t\t\tif matches!(scope, Scope::PassThrough { .. }) {\n \t\t\t\t\tself.variables.extend(variables);\n \t\t\t\t\tself.facts.variable_current_value.extend(facts.variable_current_value);\n+\t\t\t\t\tNone\n \t\t\t\t} else {\n \t\t\t\t\t// TODO for LSP\n \t\t\t\t\t// let shell = ExistingContext {\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1061,33 +860,34 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t\t// \tscope: scope.clone(),\n \t\t\t\t\t// };\n \t\t\t\t\t// checking_data.existing_contexts.existing_environments.insert(context_id, shell);\n-\t\t\t\t}\n \n-\t\t\t\t// \t// TODO temp\n-\t\t\t\t// \tself.context_type\n-\t\t\t\t// \t\t.get_closed_over_references_mut()\n-\t\t\t\t// \t\t.extend(closed_over_references.into_iter());\n+\t\t\t\t\t// \t// TODO temp\n+\t\t\t\t\t// \tself.context_type\n+\t\t\t\t\t// \t\t.get_closed_over_references_mut()\n+\t\t\t\t\t// \t\t.extend(closed_over_references.into_iter());\n \n-\t\t\t\tself.deferred_function_constraints.extend(deferred_function_constraints);\n+\t\t\t\t\tself.deferred_function_constraints.extend(deferred_function_constraints);\n \n-\t\t\t\tself.can_reference_this = can_reference_this;\n+\t\t\t\t\tself.can_reference_this = can_reference_this;\n \n-\t\t\t\tfor (on, mut properties) in facts.current_properties {\n-\t\t\t\t\tmatch self.facts.current_properties.entry(on) {\n-\t\t\t\t\t\thash_map::Entry::Occupied(mut occupied) => {\n-\t\t\t\t\t\t\toccupied.get_mut().append(&mut properties);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\thash_map::Entry::Vacant(vacant) => {\n-\t\t\t\t\t\t\tvacant.insert(properties);\n+\t\t\t\t\t// TODO clone\n+\t\t\t\t\tfor (on, mut properties) in facts.current_properties.clone() {\n+\t\t\t\t\t\tmatch self.facts.current_properties.entry(on) {\n+\t\t\t\t\t\t\thash_map::Entry::Occupied(mut occupied) => {\n+\t\t\t\t\t\t\t\toccupied.get_mut().append(&mut properties);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\thash_map::Entry::Vacant(vacant) => {\n+\t\t\t\t\t\t\t\tvacant.insert(properties);\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t}\n \n-\t\t\t\tif self.context_type.get_parent().is_some() {\n-\t\t\t\t\tself.facts.events.append(&mut facts.events);\n-\t\t\t\t\tNone\n-\t\t\t\t} else {\n-\t\t\t\t\tSome((facts.events, Default::default()))\n+\t\t\t\t\tif self.context_type.get_parent().is_some() {\n+\t\t\t\t\t\tself.facts.events.append(&mut facts.events);\n+\t\t\t\t\t\tNone\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tSome((facts, Default::default()))\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t};\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1296,7 +1096,7 @@ impl<T: ContextType> Context<T> {\n \t}\n \n \t/// TODO speed up\n-\tpub(crate) fn get_object_constraint(&self, on: TypeId) -> Vec<TypeId> {\n+\tpub(crate) fn get_object_constraints(&self, on: TypeId) -> Vec<TypeId> {\n \t\tself.parents_iter()\n \t\t\t.flat_map(|env| {\n \t\t\t\tget_on_ctx!(env.object_constraints.get(&on))\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1335,7 +1135,7 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t\t\t_ => None,\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tcrate::utils::notify!(\"TODO get root type\");\n+\t\t\t\t\tcrate::utils::notify!(\"TODO get root this type, returning ERROR_TYPE for now\");\n \t\t\t\t\tSome(TypeId::ERROR_TYPE)\n \t\t\t\t}\n \t\t\t})\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1390,7 +1190,7 @@ pub enum AssignmentError {\n \t\tvalue_site: SpanWithSource,\n \t},\n \tPropertyConstraint {\n-\t\tproperty_type: TypeStringRepresentation,\n+\t\tproperty_constraint: TypeStringRepresentation,\n \t\tvalue_type: TypeStringRepresentation,\n \t\tassignment_position: SpanWithSource,\n \t},\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1436,28 +1236,12 @@ impl Logical<TypeId> {\n \t}\n }\n \n-// TODO temp\n-impl Logical<PropertyValue> {\n-\tpub(crate) fn prop_to_type(self) -> TypeId {\n-\t\tmatch self {\n-\t\t\tLogical::Pure(ty) => ty.as_get_type(),\n-\t\t\tLogical::Or { .. } => todo!(),\n-\t\t\tLogical::Implies { antecedent, on } => {\n-\t\t\t\tlet value = on.prop_to_type();\n-\t\t\t\tif let Some((value, a)) = antecedent.type_arguments.get(&value) {\n-\t\t\t\t\t*value\n-\t\t\t\t} else {\n-\t\t\t\t\tvalue\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-#[derive(Debug)]\n pub enum SetPropertyError {\n \tNotWriteable,\n-\tDoesNotMeetConstraint(TypeId, crate::types::subtyping::NonEqualityReason),\n+\tDoesNotMeetConstraint {\n+\t\tproperty_constraint: TypeStringRepresentation,\n+\t\treason: crate::types::subtyping::NonEqualityReason,\n+\t},\n }\n \n /// TODO mutable let imports\ndiff --git a/checker/src/context/root.rs b/checker/src/context/root.rs\n--- a/checker/src/context/root.rs\n+++ b/checker/src/context/root.rs\n@@ -25,6 +25,10 @@ impl ContextType for Root {\n \t\tfalse\n \t}\n \n+\tfn is_conditional(&self) -> bool {\n+\t\tfalse\n+\t}\n+\n \tfn get_closed_over_references(&mut self) -> Option<&mut ClosedOverReferencesInScope> {\n \t\tNone\n \t}\ndiff --git a/checker/src/context/root.rs b/checker/src/context/root.rs\n--- a/checker/src/context/root.rs\n+++ b/checker/src/context/root.rs\n@@ -75,6 +79,7 @@ impl RootContext {\n \t\t\t// TODO\n \t\t\tcan_reference_this: crate::context::CanReferenceThis::Yeah,\n \t\t\tfacts: Default::default(),\n+\t\t\tpossibly_mutated_objects: Default::default(),\n \t\t}\n \t}\n \ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -1,6 +1,15 @@\n //! Contains type checking errors, warnings and related structures\n \n-use crate::diagnostics;\n+#![allow(clippy::upper_case_acronyms)]\n+\n+use crate::{\n+\tcontext::environment::Label,\n+\tdiagnostics,\n+\ttypes::{\n+\t\tpoly_types::generic_type_arguments::StructureGenericArguments,\n+\t\tprinting::print_type_with_generics, StructureGenerics,\n+\t},\n+};\n use serde::Serialize;\n use source_map::{SourceId, Span, SpanWithSource};\n use std::{\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -30,7 +39,7 @@ pub enum Diagnostic {\n \t\tposition: SpanWithSource,\n \t\tkind: DiagnosticKind,\n \t},\n-\tPositionWithAdditionLabels {\n+\tPositionWithAdditionalLabels {\n \t\treason: String,\n \t\tposition: SpanWithSource,\n \t\tlabels: Vec<(String, Option<SpanWithSource>)>,\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -38,13 +47,24 @@ pub enum Diagnostic {\n \t},\n }\n \n+/// Temporary dead zone. Between the variable identifier being hoisted and the value being assigned\n+pub struct TDZ {\n+\tpub variable_name: String,\n+\tpub position: SpanWithSource,\n+}\n+\n+pub struct NotInLoopOrCouldNotFindLabel {\n+\tpub label: Label,\n+\tpub position: SpanWithSource,\n+}\n+\n impl Diagnostic {\n \tpub fn sources(&self) -> impl Iterator<Item = SourceId> + '_ {\n \t\tuse either::{Left, Right};\n \t\tmatch self {\n \t\t\tDiagnostic::Global { .. } => Left(Left(iter::empty())),\n \t\t\tDiagnostic::Position { position: span, .. } => Left(Right(iter::once(span.source))),\n-\t\t\tDiagnostic::PositionWithAdditionLabels { position: pos, labels, .. } => {\n+\t\t\tDiagnostic::PositionWithAdditionalLabels { position: pos, labels, .. } => {\n \t\t\t\tRight(iter::once(pos.source).chain(\n \t\t\t\t\tlabels.iter().filter_map(|(_, span)| span.as_ref().map(|span| span.source)),\n \t\t\t\t))\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -57,7 +77,7 @@ impl Diagnostic {\n \t\tmatch self {\n \t\t\tDiagnostic::Global { reason, .. }\n \t\t\t| Diagnostic::Position { reason, .. }\n-\t\t\t| Diagnostic::PositionWithAdditionLabels { reason, .. } => reason,\n+\t\t\t| Diagnostic::PositionWithAdditionalLabels { reason, .. } => reason,\n \t\t}\n \t}\n \ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -66,7 +86,7 @@ impl Diagnostic {\n \t\tmatch self {\n \t\t\tDiagnostic::Global { reason, .. } => (reason, None),\n \t\t\tDiagnostic::Position { reason, position, .. }\n-\t\t\t| Diagnostic::PositionWithAdditionLabels { reason, position, .. } => (reason, Some(position)),\n+\t\t\t| Diagnostic::PositionWithAdditionalLabels { reason, position, .. } => (reason, Some(position)),\n \t\t}\n \t}\n }\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -163,6 +183,53 @@ impl TypeStringRepresentation {\n \t\tlet value = print_type(id, types, ctx, debug_mode);\n \t\tSelf::Type(value)\n \t}\n+\n+\t/// TODO working it out\n+\tpub(crate) fn from_property_constraint(\n+\t\tproperty_constraint: crate::context::Logical<crate::PropertyValue>,\n+\t\t// TODO chain\n+\t\tgenerics: Option<&StructureGenericArguments>,\n+\t\tctx: &GeneralContext,\n+\t\ttypes: &TypeStore,\n+\t\tdebug_mode: bool,\n+\t) -> TypeStringRepresentation {\n+\t\tmatch property_constraint {\n+\t\t\tcrate::context::Logical::Pure(p) => match p {\n+\t\t\t\tcrate::PropertyValue::Value(v) => {\n+\t\t\t\t\t// TODO pass down generics!!!\n+\t\t\t\t\tlet value = print_type_with_generics(\n+\t\t\t\t\t\tv,\n+\t\t\t\t\t\tgenerics.map(|g| &g.type_arguments),\n+\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\tctx,\n+\t\t\t\t\t\tdebug_mode,\n+\t\t\t\t\t);\n+\t\t\t\t\tSelf::Type(value)\n+\t\t\t\t}\n+\t\t\t\tcrate::PropertyValue::Getter(_) => todo!(),\n+\t\t\t\tcrate::PropertyValue::Setter(_) => todo!(),\n+\t\t\t\tcrate::PropertyValue::Deleted => todo!(),\n+\t\t\t},\n+\t\t\tcrate::context::Logical::Or { left, right } => {\n+\t\t\t\tlet left = Self::from_property_constraint(*left, None, ctx, types, debug_mode);\n+\t\t\t\tlet right = Self::from_property_constraint(*right, None, ctx, types, debug_mode);\n+\t\t\t\tif let (TypeStringRepresentation::Type(mut l), TypeStringRepresentation::Type(r)) =\n+\t\t\t\t\t(left, right)\n+\t\t\t\t{\n+\t\t\t\t\tl.push_str(&r);\n+\t\t\t\t\tTypeStringRepresentation::Type(l)\n+\t\t\t\t} else {\n+\t\t\t\t\tunreachable!()\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcrate::context::Logical::Implies { on, antecedent } => {\n+\t\t\t\tif generics.is_some() {\n+\t\t\t\t\ttodo!(\"chaining\")\n+\t\t\t\t}\n+\t\t\t\tSelf::from_property_constraint(*on, Some(&antecedent), ctx, types, debug_mode)\n+\t\t\t}\n+\t\t}\n+\t}\n }\n \n impl Display for TypeStringRepresentation {\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -184,13 +251,19 @@ impl From<NoEnvironmentSpecified> for Diagnostic {\n // Contains known internal errors and warnings\n // Contained here in a module to separate user facing\n mod defined_errors_and_warnings {\n-\tuse crate::{behavior, context::AssignmentError, types::calling::FunctionCallingError};\n+\tuse crate::{\n+\t\tbehavior::{self, operations::MathematicalAndBitwise},\n+\t\tcontext::AssignmentError,\n+\t\ttypes::calling::FunctionCallingError,\n+\t};\n \tuse source_map::{Span, SpanWithSource};\n \n \tuse crate::Diagnostic;\n \tuse std::path;\n \n-\tuse super::{PropertyRepresentation, TypeStringRepresentation};\n+\tuse super::{\n+\t\tNotInLoopOrCouldNotFindLabel, PropertyRepresentation, TypeStringRepresentation, TDZ,\n+\t};\n \n \t/// Reasons for errors, intermediate type for generating [Diagnostic]s\n \t/// e.g. cannot Call, cannot equate, duplicate key etc\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -201,6 +274,7 @@ mod defined_errors_and_warnings {\n \t\t\tproperty: PropertyRepresentation,\n \t\t\tsite: SpanWithSource,\n \t\t},\n+\t\tNotInLoopOrCouldNotFindLabel(NotInLoopOrCouldNotFindLabel),\n \t\tRestParameterAnnotationShouldBeArrayType(SpanWithSource),\n \t\tCouldNotFindVariable {\n \t\t\tvariable: &'a str,\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -295,6 +369,13 @@ mod defined_errors_and_warnings {\n \t\t\tname: String,\n \t\t\tposition: SpanWithSource,\n \t\t},\n+\t\tTDZ(TDZ),\n+\t\tInvalidMathematicalOrBitwiseOperation {\n+\t\t\toperator: MathematicalAndBitwise,\n+\t\t\tlhs: TypeStringRepresentation,\n+\t\t\trhs: TypeStringRepresentation,\n+\t\t\tposition: SpanWithSource,\n+\t\t},\n \t}\n \n \timpl From<TypeCheckError<'_>> for Diagnostic {\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -335,7 +416,7 @@ mod defined_errors_and_warnings {\n \t\t\t\t\t\trestriction,\n \t\t\t\t\t} => {\n \t\t\t\t\t\tif let Some((restriction_pos, restriction)) = restriction {\n-\t\t\t\t\t\t\tDiagnostic::PositionWithAdditionLabels {\n+\t\t\t\t\t\t\tDiagnostic::PositionWithAdditionalLabels {\n \t\t\t\t\t\t\t\treason: format!(\n \t\t\t\t\t\t\t\t\t\"Argument of type {argument_type} is not assignable to parameter of type {restriction}\" \n \t\t\t\t\t\t\t\t),\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -349,7 +430,7 @@ mod defined_errors_and_warnings {\n \t\t\t\t\t\t\t\tkind,\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tDiagnostic::PositionWithAdditionLabels {\n+\t\t\t\t\t\t\tDiagnostic::PositionWithAdditionalLabels {\n \t\t\t\t\t\t\t\treason: format!(\n \t\t\t\t\t\t\t\t\t\"Argument of type {argument_type} is not assignable to parameter of type {parameter_type}\",\n \t\t\t\t\t\t\t\t),\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -363,7 +444,7 @@ mod defined_errors_and_warnings {\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tFunctionCallingError::MissingArgument { parameter_position, call_site } => {\n-\t\t\t\t\t\tDiagnostic::PositionWithAdditionLabels {\n+\t\t\t\t\t\tDiagnostic::PositionWithAdditionalLabels {\n \t\t\t\t\t\t\treason: \"Missing argument\".into(),\n \t\t\t\t\t\t\tposition: call_site,\n \t\t\t\t\t\t\tkind,\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -407,15 +488,34 @@ mod defined_errors_and_warnings {\n \t\t\t\t\t},\n \t\t\t\t\tFunctionCallingError::NoLogicForIdentifier(name, position) => Diagnostic::Position { reason: format!(\"no logic for constant function {name}\"), kind, position },\n \t\t\t\t\tFunctionCallingError::NeedsToBeCalledWithNewKeyword(position) => Diagnostic::Position { reason: \"class constructor must be called with new\".to_owned(), kind, position },\n+\t\t\t\t\tFunctionCallingError::TDZ { error: TDZ { position, variable_name }, call_site } => Diagnostic::PositionWithAdditionalLabels {\n+\t\t\t\t\t\treason: format!(\"Variable {variable_name} used before declaration\"),\n+\t\t\t\t\t\tposition: call_site.unwrap(),\n+\t\t\t\t\t\tkind,\n+\t\t\t\t\t\tlabels: vec![(\n+\t\t\t\t\t\t\t\"Variable referenced here\".to_owned(),\n+\t\t\t\t\t\t\tSome(position),\n+\t\t\t\t\t\t)],\n+\t\t\t\t\t},\n+\t\t\t\t\tFunctionCallingError::SetPropertyConstraint { property_type, value_type, assignment_position, call_site } => Diagnostic::PositionWithAdditionalLabels {\n+\t\t\t\t\t\treason: \"Assignment mismatch\".to_owned(),\n+\t\t\t\t\t\tposition: call_site.unwrap(),\n+\t\t\t\t\t\tkind,\n+\t\t\t\t\t\tlabels: vec![(\n+\t\t\t\t\t\t\tformat!(\n+\t\t\t\t\t\t\t\t\"Type {value_type} does not meet property constraint {property_type}\"\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tSome(assignment_position),\n+\t\t\t\t\t\t)],\n+\t\t\t\t\t}\n \t\t\t\t},\n-\t\t\t\t//  => ,\n \t\t\t\tTypeCheckError::AssignmentError(error) => match error {\n \t\t\t\t\tAssignmentError::DoesNotMeetConstraint {\n \t\t\t\t\t\tvariable_type,\n \t\t\t\t\t\tvariable_site,\n \t\t\t\t\t\tvalue_type,\n \t\t\t\t\t\tvalue_site,\n-\t\t\t\t\t} => Diagnostic::PositionWithAdditionLabels {\n+\t\t\t\t\t} => Diagnostic::PositionWithAdditionalLabels {\n \t\t\t\t\t\treason: format!(\n \t\t\t\t\t\t\t\"Type {value_type} is not assignable to type {variable_type}\",\n \t\t\t\t\t\t),\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -427,7 +527,7 @@ mod defined_errors_and_warnings {\n \t\t\t\t\t\tkind,\n \t\t\t\t\t},\n \t\t\t\t\tAssignmentError::PropertyConstraint {\n-\t\t\t\t\t\tproperty_type,\n+\t\t\t\t\t\tproperty_constraint: property_type,\n \t\t\t\t\t\tvalue_type,\n \t\t\t\t\t\tassignment_position,\n \t\t\t\t\t} => Diagnostic::Position {\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -468,7 +568,7 @@ mod defined_errors_and_warnings {\n \t\t\t\t\treturned_position,\n \t\t\t\t\texpected_return_type,\n \t\t\t\t\treturned_type,\n-\t\t\t\t} => Diagnostic::PositionWithAdditionLabels {\n+\t\t\t\t} => Diagnostic::PositionWithAdditionalLabels {\n \t\t\t\t\treason: format!(\n \t\t\t\t\t\t\"Cannot return {returned_type} because the function is expected to return {expected_return_type}\",\n \t\t\t\t\t),\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -610,6 +710,18 @@ mod defined_errors_and_warnings {\n \t\t\t\t\tposition,\n \t\t\t\t\tkind,\n \t\t\t\t},\n+\t\t\t\tTypeCheckError::TDZ(TDZ { position, variable_name }) => Diagnostic::Position {\n+\t\t\t\t\treason: format!(\"Variable {variable_name} used before declaration\"),\n+\t\t\t\t\tposition,\n+\t\t\t\t\tkind,\n+\t\t\t\t},\n+\t\t\t\tTypeCheckError::InvalidMathematicalOrBitwiseOperation { operator, lhs, rhs, position } => Diagnostic::Position {\n+\t\t\t\t\t// TODO temp\n+\t\t\t\t\treason: format!(\"Cannot {lhs} {operator:?} {rhs}\"),\n+\t\t\t\t\tposition,\n+\t\t\t\t\tkind,\n+\t\t\t\t},\n+\t\t\t\tTypeCheckError::NotInLoopOrCouldNotFindLabel(_) => todo!(),\n \t\t\t}\n \t\t}\n \t}\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -1,19 +1,30 @@\n-use super::{CallingTiming, EarlyReturn, Event, PrototypeArgument, RootReference};\n+use super::{CallingTiming, Event, EventResult, PrototypeArgument, RootReference};\n \n use crate::{\n-\tbehavior::functions::ThisValue,\n-\tcontext::{calling::Target, get_value_of_variable, CallCheckingBehavior},\n+\tbehavior::{\n+\t\tfunctions::ThisValue,\n+\t\titeration::{self, IterationKind},\n+\t},\n+\tcontext::{calling::Target, get_value_of_variable, CallCheckingBehavior, SetPropertyError},\n+\tdiagnostics::{TypeStringRepresentation, TDZ},\n \ttypes::{\n \t\tcurry_arguments,\n \t\tfunctions::SynthesisedArgument,\n-\t\tis_type_truthy_falsy,\n-\t\tpoly_types::FunctionTypeArguments,\n+\t\tget_constraint, is_type_truthy_falsy,\n+\t\tpoly_types::{generic_type_arguments::TypeArgumentStore, FunctionTypeArguments},\n \t\tproperties::{get_property, set_property, PropertyValue},\n \t\tsubstitute, Constructor, StructureGenerics, TypeId, TypeStore,\n \t},\n \tDecidable, Environment, Type,\n };\n \n+#[derive(Default)]\n+pub struct ErrorsAndInfo {\n+\tpub errors: Vec<crate::types::calling::FunctionCallingError>,\n+\tpub warnings: Vec<crate::types::calling::InfoDiagnostic>,\n+}\n+\n+#[must_use]\n pub(crate) fn apply_event(\n \tevent: Event,\n \tthis_value: ThisValue,\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -21,7 +32,8 @@ pub(crate) fn apply_event(\n \tenvironment: &mut Environment,\n \ttarget: &mut Target,\n \ttypes: &mut TypeStore,\n-) -> EarlyReturn {\n+\terrors: &mut ErrorsAndInfo,\n+) -> Option<EventResult> {\n \tmatch event {\n \t\tEvent::ReadsReference { reference, reflects_dependency, position } => {\n \t\t\tif let Some(id) = reflects_dependency {\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -35,13 +47,19 @@ pub(crate) fn apply_event(\n \t\t\t\t\t\tif let Some(ty) = value {\n \t\t\t\t\t\t\tty\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tcrate::utils::notify!(\"emit a tdz error\");\n+\t\t\t\t\t\t\terrors.errors.push(crate::types::calling::FunctionCallingError::TDZ {\n+\t\t\t\t\t\t\t\terror: TDZ {\n+\t\t\t\t\t\t\t\t\tvariable_name: environment.get_variable_name(id).to_owned(),\n+\t\t\t\t\t\t\t\t\tposition,\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\tcall_site: None,\n+\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\tTypeId::ERROR_TYPE\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tRootReference::This => this_value.get(environment, types, &position),\n \t\t\t\t};\n-\t\t\t\ttype_arguments.set_id_from_reference(id, value, types);\n+\t\t\t\ttype_arguments.set_id_from_reference(id, value);\n \t\t\t}\n \t\t}\n \t\tEvent::SetsVariable(variable, value, position) => {\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -80,19 +98,15 @@ pub(crate) fn apply_event(\n \t\t\t\t\t);\n \n \t\t\tif let Some(id) = reflects_dependency {\n-\t\t\t\ttype_arguments.set_id_from_reference(id, value, types);\n+\t\t\t\ttype_arguments.set_id_from_reference(id, value);\n \t\t\t}\n \t\t}\n-\t\tEvent::Setter {\n-\t\t\ton,\n-\t\t\tunder,\n-\t\t\tnew,\n-\t\t\treflects_dependency,\n-\t\t\tinitialization,\n-\t\t\tpublicity,\n-\t\t\tposition,\n-\t\t} => {\n+\t\tEvent::Setter { on, under, new, initialization, publicity, position } => {\n+\t\t\tlet was = on;\n \t\t\tlet on = substitute(on, type_arguments, environment, types);\n+\n+\t\t\tcrate::utils::notify!(\"was {:?} now {:?}\", was, on);\n+\n \t\t\tlet under = match under {\n \t\t\t\tcrate::types::properties::PropertyKey::Type(under) => {\n \t\t\t\t\tlet ty = substitute(under, type_arguments, environment, types);\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -187,16 +220,19 @@ pub(crate) fn apply_event(\n \t\t\t\t\t\ttypes,\n \t\t\t\t\t);\n \t\t\t\t\tmatch result {\n-\t\t\t\t\t\tOk(result) => {\n+\t\t\t\t\t\tOk(mut result) => {\n+\t\t\t\t\t\t\terrors.warnings.append(&mut result.warnings);\n \t\t\t\t\t\t\tif let Some(reflects_dependency) = reflects_dependency {\n \t\t\t\t\t\t\t\ttype_arguments.set_id_from_reference(\n \t\t\t\t\t\t\t\t\treflects_dependency,\n \t\t\t\t\t\t\t\t\tresult.returned_type,\n-\t\t\t\t\t\t\t\t\ttypes,\n \t\t\t\t\t\t\t\t);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tErr(_) => todo!(\"inference and or checking failed at function\"),\n+\t\t\t\t\t\tErr(mut calling_errors) => {\n+\t\t\t\t\t\t\tcrate::utils::notify!(\"inference and or checking failed at function\");\n+\t\t\t\t\t\t\terrors.errors.append(&mut calling_errors);\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\t// TODO different\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -257,6 +301,7 @@ pub(crate) fn apply_event(\n \t\t\t\t\t\t\t\tenvironment,\n \t\t\t\t\t\t\t\ttarget,\n \t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\terrors,\n \t\t\t\t\t\t\t) {\n \t\t\t\t\t\t\t\treturn Some(early);\n \t\t\t\t\t\t\t}\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -274,6 +319,7 @@ pub(crate) fn apply_event(\n \t\t\t\t\t\t\t\tenvironment,\n \t\t\t\t\t\t\t\ttarget,\n \t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\terrors,\n \t\t\t\t\t\t\t) {\n \t\t\t\t\t\t\t\treturn Some(early);\n \t\t\t\t\t\t\t}\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -3,11 +3,12 @@\n //! Events is the general name for the IR. Effect = Events of a function\n \n use crate::{\n-\tbehavior::functions::ThisValue,\n+\tbehavior::{functions::ThisValue, iteration::IterationKind},\n \tcontext::{calling::Target, facts::Publicity, get_on_ctx, CallCheckingBehavior},\n \ttypes::{\n \t\tcalling::CalledWithNew,\n \t\tproperties::{PropertyKey, PropertyValue},\n+\t\tTypeArguments,\n \t},\n \tFunctionId, GeneralContext, SpanWithSource, VariableId,\n };\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -38,6 +39,24 @@ impl RootReference {\n \t}\n }\n \n+/// If `carry == 0` then break\n+#[derive(Debug)]\n+pub enum EventResult {\n+\tReturn(TypeId, SpanWithSource),\n+\tBreak {\n+\t\tcarry: u8,\n+\t},\n+\t/// from `continue` statements, which should be called `skip`.\n+\t/// TODO maybe this can be abstracted\n+\tContinue {\n+\t\tcarry: u8,\n+\t},\n+\tThrow,\n+}\n+\n+/// For iterations. TODO up for debate\n+pub type InitialVariables = map_vec::Map<VariableId, TypeId>;\n+\n /// Events which happen\n ///\n /// Used for getting values and states\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -48,7 +67,7 @@ impl RootReference {\n /// TODO store positions?\n #[derive(Debug, Clone, binary_serialize_derive::BinarySerializable)]\n pub enum Event {\n-\t/// Reads variable\n+\t/// Reads a reference (as a free variable or `this`)\n \t///\n \t/// Can be used for DCE reasons, or finding variables in context\n \tReadsReference {\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -72,7 +91,6 @@ pub enum Event {\n \t\tunder: PropertyKey<'static>,\n \t\t// Can be a getter through define property\n \t\tnew: PropertyValue,\n-\t\treflects_dependency: Option<TypeId>,\n \t\t/// THIS DOES NOT CALL SETTERS, JUST SETS VALUE!\n \t\t/// TODO this is [define] property\n \t\t/// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -80,7 +98,6 @@ pub enum Event {\n \t\tpublicity: Publicity,\n \t\tposition: Option<SpanWithSource>,\n \t},\n-\n \t/// This includes closed over variables, anything dependent\n \tCallsType {\n \t\ton: TypeId,\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -99,8 +116,20 @@ pub enum Event {\n \t\telse_events: Box<[Event]>,\n \t\tposition: Option<SpanWithSource>,\n \t},\n+\t/// Run events multiple times\n+\tIterate {\n+\t\tkind: IterationKind,\n+\t\t/// TODO for of and in variants here:\n+\t\t// condition: TypeId,\n+\t\titerate_over: Box<[Event]>,\n+\t\t/// Contains initial values that the iteration runs over. Without, initial iterations can't access anything...?\n+\t\tinitial: InitialVariables,\n+\t},\n \t/// TODO not sure but whatever\n-\tReturn { returned: TypeId, returned_position: SpanWithSource },\n+\tReturn {\n+\t\treturned: TypeId,\n+\t\treturned_position: SpanWithSource,\n+\t},\n \t/// *lil bit magic*, handles:\n \t/// - Creating objects `{}`\n \t/// - Creating objects with prototypes:\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -123,11 +152,18 @@ pub enum Event {\n \t\t/// This is also for the specialisation (somehow)\n \t\treferenced_in_scope_as: TypeId,\n \t\tposition: Option<SpanWithSource>,\n+\t\t/// Debug only\n+\t\tis_function_this: bool,\n+\t},\n+\tBreak {\n+\t\tposition: Option<SpanWithSource>,\n+\t\tcarry: u8,\n+\t},\n+\t/// TODO explain why this can't be done with just (or at least label makes it more difficult)\n+\tContinue {\n+\t\tposition: Option<SpanWithSource>,\n+\t\tcarry: u8,\n \t},\n-\t/// TODO label\n-\tBreak { position: Option<SpanWithSource> },\n-\t/// TODO label\n-\tContinue { position: Option<SpanWithSource> },\n }\n \n #[derive(Debug, Clone, binary_serialize_derive::BinarySerializable)]\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -144,5 +180,3 @@ pub enum CallingTiming {\n \t/// TODO could use above mechanism at some point\n \tAtSomePointManyTimes,\n }\n-\n-pub(crate) type EarlyReturn = Option<TypeId>;\ndiff --git a/checker/src/lib.rs b/checker/src/lib.rs\n--- a/checker/src/lib.rs\n+++ b/checker/src/lib.rs\n@@ -96,6 +96,11 @@ pub trait ASTImplementation: Sized {\n \ttype TypeAnnotation<'a>;\n \ttype TypeParameter<'a>;\n \ttype Expression<'a>;\n+\ttype MultipleExpression<'a>;\n+\ttype ForStatementInitiliser<'a>;\n+\n+\t/// Used in `for of`, `for in` and function parameters\n+\ttype VariableField<'a>;\n \n \ttype ClassMethod<'a>: SynthesisableFunction<Self>;\n \ndiff --git a/checker/src/lib.rs b/checker/src/lib.rs\n--- a/checker/src/lib.rs\n+++ b/checker/src/lib.rs\n@@ -137,12 +142,27 @@ pub trait ASTImplementation: Sized {\n \t\tchecking_data: &mut crate::CheckingData<T, Self>,\n \t) -> TypeId;\n \n+\t/// Expected is used for eagerly setting function parameters\n+\tfn synthesise_multiple_expression<'a, T: crate::ReadFromFS>(\n+\t\texpression: &'a Self::MultipleExpression<'a>,\n+\t\texpected_type: TypeId,\n+\t\tenvironment: &mut Environment,\n+\t\tchecking_data: &mut crate::CheckingData<T, Self>,\n+\t) -> TypeId;\n+\n \tfn synthesise_type_annotation<'a, T: crate::ReadFromFS>(\n \t\tannotation: &'a Self::TypeAnnotation<'a>,\n \t\tenvironment: &mut Environment,\n \t\tchecking_data: &mut crate::CheckingData<T, Self>,\n \t) -> TypeId;\n \n+\t/// Don't need to return anything. All information recorded via changed to `environment`\n+\tfn synthesise_for_loop_initialiser<'a, T: crate::ReadFromFS>(\n+\t\tfor_loop_initialiser: &'a Self::ForStatementInitiliser<'a>,\n+\t\tenvironment: &mut Environment,\n+\t\tchecking_data: &mut crate::CheckingData<T, Self>,\n+\t);\n+\n \tfn expression_position<'a>(expression: &'a Self::Expression<'a>) -> Span;\n \n \tfn type_parameter_name<'a>(parameter: &'a Self::TypeParameter<'a>) -> &'a str;\ndiff --git a/checker/src/lib.rs b/checker/src/lib.rs\n--- a/checker/src/lib.rs\n+++ b/checker/src/lib.rs\n@@ -191,6 +211,7 @@ impl FunctionId {\n \tpub const AUTO_CONSTRUCTOR: Self = FunctionId(SourceId::NULL, 0);\n }\n \n+#[derive(Debug)]\n pub enum Decidable<T> {\n \tKnown(T),\n \t/// Points to poly type\ndiff --git a/checker/src/lib.rs b/checker/src/lib.rs\n--- a/checker/src/lib.rs\n+++ b/checker/src/lib.rs\n@@ -544,3 +565,10 @@ impl TypeCombinable for TypeId {\n \t\tTypeId::UNDEFINED_TYPE\n \t}\n }\n+\n+impl<A: crate::ASTImplementation> PostCheckData<A> {\n+\t#[must_use]\n+\tpub fn is_function_called(&self, function_id: FunctionId) -> bool {\n+\t\tself.types.called_functions.contains(&function_id)\n+\t}\n+}\ndiff --git a/checker/src/options.rs b/checker/src/options.rs\n--- a/checker/src/options.rs\n+++ b/checker/src/options.rs\n@@ -1,7 +1,7 @@\n use std::any::Any;\n \n /// Options for type checking\n-/// TODO reach compat with tsc\n+/// TODO figure out compat with tsc\n #[derive(serde::Deserialize)]\n // TODO: Can be refactored with bit to reduce memory\n #[allow(clippy::struct_excessive_bools)]\ndiff --git a/checker/src/serialization.rs b/checker/src/serialization.rs\n--- a/checker/src/serialization.rs\n+++ b/checker/src/serialization.rs\n@@ -36,6 +36,16 @@ impl BinarySerializable for () {\n \tfn deserialize<I: Iterator<Item = u8>>(iter: &mut I, source: SourceId) -> Self {}\n }\n \n+impl BinarySerializable for u8 {\n+\tfn serialize(self, buf: &mut Vec<u8>) {\n+\t\tbuf.push(self);\n+\t}\n+\n+\tfn deserialize<I: Iterator<Item = u8>>(iter: &mut I, source: SourceId) -> Self {\n+\t\titer.next().unwrap()\n+\t}\n+}\n+\n impl<T: BinarySerializable> BinarySerializable for Option<T> {\n \tfn serialize(self, buf: &mut Vec<u8>) {\n \t\tif let Some(item) = self {\ndiff --git a/checker/src/synthesis/block.rs b/checker/src/synthesis/block.rs\n--- a/checker/src/synthesis/block.rs\n+++ b/checker/src/synthesis/block.rs\n@@ -28,7 +28,7 @@ pub(super) fn synthesise_block<T: crate::ReadFromFS>(\n \tfor (idx, statement) in statements.iter().enumerate() {\n \t\tmatch statement {\n \t\t\tStatementOrDeclaration::Statement(statement) => {\n-\t\t\t\tsynthesise_statement(statement, environment, checking_data);\n+\t\t\t\tsynthesise_statement(statement, None, environment, checking_data);\n \n \t\t\t\t// TODO Statement::is_control_flow ...?\n \t\t\t\tif let Statement::Return(..) | Statement::Break(..) | Statement::Continue(..) =\ndiff --git a/checker/src/synthesis/hoisting.rs b/checker/src/synthesis/hoisting.rs\n--- a/checker/src/synthesis/hoisting.rs\n+++ b/checker/src/synthesis/hoisting.rs\n@@ -465,7 +465,7 @@ pub(super) fn export_part_to_name_pair(\n \t}\n }\n \n-fn hoist_variable_declaration<T: ReadFromFS>(\n+pub(super) fn hoist_variable_declaration<T: ReadFromFS>(\n \tdeclaration: &parser::declarations::VariableDeclaration,\n \tenvironment: &mut crate::context::Context<crate::context::environment::Syntax<'_>>,\n \tchecking_data: &mut CheckingData<T, super::EznoParser>,\ndiff --git a/checker/src/synthesis/mod.rs b/checker/src/synthesis/mod.rs\n--- a/checker/src/synthesis/mod.rs\n+++ b/checker/src/synthesis/mod.rs\n@@ -28,7 +28,13 @@ use crate::{\n \tCheckingData, Constant, Diagnostic, Environment, Facts, RootContext, TypeId,\n };\n \n-use self::{expressions::synthesise_expression, type_annotations::synthesise_type_annotation};\n+use self::{\n+\tdeclarations::synthesise_variable_declaration,\n+\texpressions::{synthesise_expression, synthesise_multiple_expression},\n+\thoisting::hoist_variable_declaration,\n+\ttype_annotations::synthesise_type_annotation,\n+\tvariables::register_variable,\n+};\n \n pub(super) fn parser_property_key_to_checker_property_key<\n \tP: parser::property_key::PropertyKeyKind,\ndiff --git a/checker/src/synthesis/mod.rs b/checker/src/synthesis/mod.rs\n--- a/checker/src/synthesis/mod.rs\n+++ b/checker/src/synthesis/mod.rs\n@@ -119,8 +125,13 @@ impl crate::ASTImplementation for EznoParser {\n \ttype TypeAnnotation<'a> = parser::TypeAnnotation;\n \ttype TypeParameter<'a> = parser::GenericTypeConstraint;\n \ttype Expression<'a> = parser::Expression;\n+\ttype MultipleExpression<'a> = parser::expressions::MultipleExpression;\n \ttype ClassMethod<'a> = parser::FunctionBase<parser::ast::ClassFunctionBase>;\n \n+\ttype VariableField<'a> = parser::VariableField<parser::VariableFieldInSourceCode>;\n+\n+\ttype ForStatementInitiliser<'a> = parser::statements::ForLoopStatementInitializer;\n+\n \tfn module_from_string(\n \t\tsource_id: SourceId,\n \t\tstring: String,\ndiff --git a/checker/src/synthesis/mod.rs b/checker/src/synthesis/mod.rs\n--- a/checker/src/synthesis/mod.rs\n+++ b/checker/src/synthesis/mod.rs\n@@ -191,6 +202,31 @@ impl crate::ASTImplementation for EznoParser {\n \tfn owned_module_from_module(m: Self::Module<'static>) -> Self::OwnedModule {\n \t\tm\n \t}\n+\n+\tfn synthesise_multiple_expression<'a, T: crate::ReadFromFS>(\n+\t\texpression: &'a Self::MultipleExpression<'a>,\n+\t\texpected_type: TypeId,\n+\t\tenvironment: &mut Environment,\n+\t\tchecking_data: &mut crate::CheckingData<T, Self>,\n+\t) -> TypeId {\n+\t\tsynthesise_multiple_expression(expression, environment, checking_data, expected_type)\n+\t}\n+\n+\tfn synthesise_for_loop_initialiser<'a, T: crate::ReadFromFS>(\n+\t\tfor_loop_initialiser: &'a Self::ForStatementInitiliser<'a>,\n+\t\tenvironment: &mut Environment,\n+\t\tchecking_data: &mut crate::CheckingData<T, Self>,\n+\t) {\n+\t\tmatch for_loop_initialiser {\n+\t\t\tparser::statements::ForLoopStatementInitializer::VariableDeclaration(declaration) => {\n+\t\t\t\t// TODO is this correct & the best\n+\t\t\t\thoist_variable_declaration(declaration, environment, checking_data);\n+\t\t\t\tsynthesise_variable_declaration(declaration, environment, checking_data, false);\n+\t\t\t}\n+\t\t\tparser::statements::ForLoopStatementInitializer::VarStatement(_) => todo!(),\n+\t\t\tparser::statements::ForLoopStatementInitializer::Expression(_) => todo!(),\n+\t\t}\n+\t}\n }\n \n pub mod interactive {\ndiff --git a/checker/src/synthesis/statements.rs b/checker/src/synthesis/statements.rs\n--- a/checker/src/synthesis/statements.rs\n+++ b/checker/src/synthesis/statements.rs\n@@ -2,8 +2,12 @@ use super::{\n \texpressions::synthesise_multiple_expression, synthesise_block, variables::register_variable,\n };\n use crate::{\n-\tbehavior::{assignments::Reference, operations::CanonicalEqualityAndInequality},\n-\tcontext::{calling::Target, ClosedOverReferencesInScope, ContextId, Scope},\n+\tbehavior::{\n+\t\tassignments::Reference,\n+\t\titeration::{synthesise_iteration, IterationBehavior},\n+\t\toperations::CanonicalEqualityAndInequality,\n+\t},\n+\tcontext::{calling::Target, environment, ClosedOverReferencesInScope, ContextId, Scope},\n \tdiagnostics::TypeCheckError,\n \tevents::{apply_event, Event, RootReference},\n \tsynthesis::EznoParser,\ndiff --git a/checker/src/synthesis/statements.rs b/checker/src/synthesis/statements.rs\n--- a/checker/src/synthesis/statements.rs\n+++ b/checker/src/synthesis/statements.rs\n@@ -21,8 +25,13 @@ use std::collections::HashMap;\n pub type ExportedItems = HashMap<String, crate::behavior::variables::VariableOrImport>;\n pub type ReturnResult = Option<TypeId>;\n \n+pub struct StatementInformation {\n+\tlabel: Option<String>,\n+}\n+\n pub(super) fn synthesise_statement<T: crate::ReadFromFS>(\n \tstatement: &Statement,\n+\tinformation: Option<StatementInformation>,\n \tenvironment: &mut Environment,\n \tchecking_data: &mut CheckingData<T, super::EznoParser>,\n ) {\ndiff --git a/checker/src/synthesis/statements.rs b/checker/src/synthesis/statements.rs\n--- a/checker/src/synthesis/statements.rs\n+++ b/checker/src/synthesis/statements.rs\n@@ -52,7 +61,7 @@ pub(super) fn synthesise_statement<T: crate::ReadFromFS>(\n \n \t\t\tenvironment.return_value(returned, position);\n \t\t}\n-\t\tStatement::IfStatement(if_statement) => {\n+\t\tStatement::If(if_statement) => {\n \t\t\tfn run_condition<T: crate::ReadFromFS>(\n \t\t\t\tcurrent: (&MultipleExpression, &BlockOrSingleStatement),\n \t\t\t\tothers: &[(&MultipleExpression, &BlockOrSingleStatement)],\ndiff --git a/checker/src/synthesis/statements.rs b/checker/src/synthesis/statements.rs\n--- a/checker/src/synthesis/statements.rs\n+++ b/checker/src/synthesis/statements.rs\n@@ -103,79 +112,76 @@ pub(super) fn synthesise_statement<T: crate::ReadFromFS>(\n \t\t\t\tchecking_data,\n \t\t\t);\n \t\t}\n-\t\tStatement::SwitchStatement(stmt) => {\n+\t\tStatement::Switch(stmt) => {\n \t\t\tchecking_data.diagnostics_container.add_error(TypeCheckError::Unsupported {\n \t\t\t\tthing: \"Switch statement\",\n \t\t\t\tat: stmt.get_position().with_source(environment.get_source()),\n \t\t\t});\n \t\t}\n-\t\tStatement::WhileStatement(stmt) => {\n-\t\t\tchecking_data.diagnostics_container.add_error(TypeCheckError::Unsupported {\n-\t\t\t\tthing: \"While statement\",\n-\t\t\t\tat: stmt.get_position().with_source(environment.get_source()),\n-\t\t\t});\n-\t\t}\n-\t\tStatement::DoWhileStatement(stmt) => {\n-\t\t\tchecking_data.diagnostics_container.add_error(TypeCheckError::Unsupported {\n-\t\t\t\tthing: \"Do while statement\",\n-\t\t\t\tat: stmt.get_position().with_source(environment.get_source()),\n-\t\t\t});\n-\t\t}\n-\t\tStatement::ForLoopStatement(stmt) => {\n-\t\t\tchecking_data.diagnostics_container.add_error(TypeCheckError::Unsupported {\n-\t\t\t\tthing: \"For statement\",\n-\t\t\t\tat: stmt.get_position().with_source(environment.get_source()),\n-\t\t\t});\n-\t\t\t// let mut environment = environment.new_lexical_environment(ScopeType::Conditional {});\n-\t\t\t// match &for_statement.condition {\n-\t\t\t// \tForLoopCondition::ForOf { keyword, variable, of } => {\n-\t\t\t// \t\ttodo!()\n-\t\t\t// \t\t// let of_expression_instance =\n-\t\t\t// \t\t//     synthesise_expression(of, &mut environment, checking_data);\n-\t\t\t// \t\t// let iterator_result = get_type_iterator_with_error_handler(\n-\t\t\t// \t\t//     of_expression_instance.get_type(),\n-\t\t\t// \t\t//     &mut checking_data.diagnostics_container,\n-\t\t\t// \t\t//     Some(&mut checking_data.type_mappings.implementors_of_generic),\n-\t\t\t// \t\t//     of.get_position(),\n-\t\t\t// \t\t// )\n-\t\t\t// \t\t// .get_iterator_type();\n-\t\t\t// \t\t// synthesise_variable_field(\n-\t\t\t// \t\t//     variable.get_ast_mut(),\n-\t\t\t// \t\t//     &iterator_result,\n-\t\t\t// \t\t//     matches!(keyword, parser::statements::VariableKeyword::Const(_)),\n-\t\t\t// \t\t//     &mut environment,\n-\t\t\t// \t\t//     checking_data,\n-\t\t\t// \t\t//\n-\t\t\t// \t\t//\n-\t\t\t// \t\t// );\n-\t\t\t// \t}\n-\t\t\t// \tForLoopCondition::ForIn { keyword, variable: _, in_condition: _ } => todo!(),\n-\t\t\t// \tForLoopCondition::Statements { initializer, condition, final_expression } => {\n-\t\t\t// \t\tmatch initializer {\n-\t\t\t// \t\t\tparser::statements::ForLoopStatementInitializer::Statement(statement) => {\n-\t\t\t// \t\t\t\tsynthesise_variable_declaration_statement(\n-\t\t\t// \t\t\t\t\tstatement,\n-\t\t\t// \t\t\t\t\t&mut environment,\n-\t\t\t// \t\t\t\t\tchecking_data,\n-\t\t\t//\n-\t\t\t// \t\t\t\t);\n-\t\t\t// \t\t\t}\n-\t\t\t// \t\t\tparser::statements::ForLoopStatementInitializer::Expression(_) => todo!(),\n-\t\t\t// \t\t}\n-\t\t\t// \t\t// synthesise_variable_declaration(\n-\t\t\t// \t\t//     initializer,\n-\t\t\t// \t\t//     *constant,\n-\t\t\t// \t\t//     &mut environment,\n-\t\t\t// \t\t//     checking_data,\n-\t\t\t// \t\t//\n-\t\t\t// \t\t//\n-\t\t\t// \t\t// );\n-\t\t\t// \t\tsynthesise_expression(condition, &mut environment, checking_data);\n-\t\t\t// \t\tsynthesise_expression(final_expression, &mut environment, checking_data);\n-\t\t\t// \t}\n-\t\t\t// };\n-\t\t\t// synthesise_block(&for_statement.statements, &mut environment, checking_data);\n-\t\t}\n+\t\tStatement::WhileLoop(stmt) => synthesise_iteration(\n+\t\t\tIterationBehavior::While(&stmt.condition),\n+\t\t\tinformation.and_then(|info| info.label),\n+\t\t\tenvironment,\n+\t\t\tchecking_data,\n+\t\t\t|environment, checking_data| {\n+\t\t\t\tsynthesise_block_or_single_statement(&stmt.inner, environment, checking_data);\n+\t\t\t},\n+\t\t),\n+\t\tStatement::DoWhileLoop(stmt) => synthesise_iteration(\n+\t\t\tIterationBehavior::DoWhile(&stmt.condition),\n+\t\t\tinformation.and_then(|info| info.label),\n+\t\t\tenvironment,\n+\t\t\tchecking_data,\n+\t\t\t|environment, checking_data| {\n+\t\t\t\tsynthesise_block_or_single_statement(&stmt.inner, environment, checking_data);\n+\t\t\t},\n+\t\t),\n+\t\tStatement::ForLoop(stmt) => match &stmt.condition {\n+\t\t\tparser::statements::ForLoopCondition::ForOf { keyword, variable, of, position } => {\n+\t\t\t\tsynthesise_iteration(\n+\t\t\t\t\tIterationBehavior::ForOf { lhs: variable.get_ast_ref(), rhs: of },\n+\t\t\t\t\tinformation.and_then(|info| info.label),\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\tchecking_data,\n+\t\t\t\t\t|environment, checking_data| {\n+\t\t\t\t\t\tsynthesise_block_or_single_statement(\n+\t\t\t\t\t\t\t&stmt.inner,\n+\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t);\n+\t\t\t\t\t},\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\tparser::statements::ForLoopCondition::ForIn { keyword, variable, r#in, position } => {\n+\t\t\t\tsynthesise_iteration(\n+\t\t\t\t\tIterationBehavior::ForIn { lhs: variable.get_ast_ref(), rhs: r#in },\n+\t\t\t\t\tinformation.and_then(|info| info.label),\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\tchecking_data,\n+\t\t\t\t\t|environment, checking_data| {\n+\t\t\t\t\t\tsynthesise_block_or_single_statement(\n+\t\t\t\t\t\t\t&stmt.inner,\n+\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t);\n+\t\t\t\t\t},\n+\t\t\t\t);\n+\t\t\t}\n+\t\t\tparser::statements::ForLoopCondition::Statements {\n+\t\t\t\tinitialiser,\n+\t\t\t\tcondition,\n+\t\t\t\tafterthought,\n+\t\t\t\tposition,\n+\t\t\t} => synthesise_iteration(\n+\t\t\t\tIterationBehavior::For { initialiser, condition, afterthought },\n+\t\t\t\tinformation.and_then(|info| info.label),\n+\t\t\t\tenvironment,\n+\t\t\t\tchecking_data,\n+\t\t\t\t|environment, checking_data| {\n+\t\t\t\t\tsynthesise_block_or_single_statement(&stmt.inner, environment, checking_data);\n+\t\t\t\t},\n+\t\t\t),\n+\t\t},\n \t\tStatement::Block(ref block) => {\n \t\t\tlet (result, _, _) = environment.new_lexical_environment_fold_into_parent(\n \t\t\t\tScope::Block {},\ndiff --git a/checker/src/synthesis/statements.rs b/checker/src/synthesis/statements.rs\n--- a/checker/src/synthesis/statements.rs\n+++ b/checker/src/synthesis/statements.rs\n@@ -183,18 +189,22 @@ pub(super) fn synthesise_statement<T: crate::ReadFromFS>(\n \t\t\t\t|environment, checking_data| synthesise_block(&block.0, environment, checking_data),\n \t\t\t);\n \t\t}\n-\t\tStatement::Debugger(_pos) => {\n-\t\t\t// yay!\n-\t\t}\n-\t\t// TODO acknowledge '@ts-ignore' statements but error\n \t\tStatement::Cursor(cursor_id, _) => {\n \t\t\ttodo!(\"Dump environment data somewhere\")\n \t\t}\n-\t\tStatement::Continue(..) | Statement::Break(..) => {\n-\t\t\tchecking_data.raise_unimplemented_error(\n-\t\t\t\t\"continue and break statements\",\n-\t\t\t\tstatement.get_position().with_source(environment.get_source()),\n-\t\t\t);\n+\t\tStatement::Continue(label, position) => {\n+\t\t\tif let Err(err) = environment.add_continue(label.as_deref(), *position) {\n+\t\t\t\tchecking_data\n+\t\t\t\t\t.diagnostics_container\n+\t\t\t\t\t.add_error(TypeCheckError::NotInLoopOrCouldNotFindLabel(err));\n+\t\t\t}\n+\t\t}\n+\t\tStatement::Break(label, position) => {\n+\t\t\tif let Err(err) = environment.add_break(label.as_deref(), *position) {\n+\t\t\t\tchecking_data\n+\t\t\t\t\t.diagnostics_container\n+\t\t\t\t\t.add_error(TypeCheckError::NotInLoopOrCouldNotFindLabel(err));\n+\t\t\t}\n \t\t}\n \t\tStatement::Throw(stmt) => {\n \t\t\tlet thrown_value = synthesise_multiple_expression(\ndiff --git a/checker/src/synthesis/statements.rs b/checker/src/synthesis/statements.rs\n--- a/checker/src/synthesis/statements.rs\n+++ b/checker/src/synthesis/statements.rs\n@@ -207,11 +217,14 @@ pub(super) fn synthesise_statement<T: crate::ReadFromFS>(\n \t\t\tenvironment.throw_value(thrown_value, thrown_position);\n \t\t}\n \t\tStatement::Labelled { position, name, statement } => {\n-\t\t\tchecking_data.raise_unimplemented_error(\n-\t\t\t\t\"labelled statements\",\n-\t\t\t\tstatement.get_position().with_source(environment.get_source()),\n+\t\t\t// Labels on invalid statements is caught at parse time\n+\n+\t\t\tsynthesise_statement(\n+\t\t\t\tstatement,\n+\t\t\t\tSome(StatementInformation { label: Some(name.clone()) }),\n+\t\t\t\tenvironment,\n+\t\t\t\tchecking_data,\n \t\t\t);\n-\t\t\tsynthesise_statement(statement, environment, checking_data);\n \t\t}\n \t\tStatement::VarVariable(_) => {\n \t\t\tchecking_data.raise_unimplemented_error(\ndiff --git a/checker/src/synthesis/statements.rs b/checker/src/synthesis/statements.rs\n--- a/checker/src/synthesis/statements.rs\n+++ b/checker/src/synthesis/statements.rs\n@@ -219,7 +232,7 @@ pub(super) fn synthesise_statement<T: crate::ReadFromFS>(\n \t\t\t\tstatement.get_position().with_source(environment.get_source()),\n \t\t\t);\n \t\t}\n-\t\tStatement::TryCatchStatement(stmt) => {\n+\t\tStatement::TryCatch(stmt) => {\n \t\t\tlet throw_type: TypeId =\n \t\t\t\tenvironment.new_try_context(checking_data, |environment, checking_data| {\n \t\t\t\t\tsynthesise_block(&stmt.try_inner.0, environment, checking_data);\ndiff --git a/checker/src/synthesis/statements.rs b/checker/src/synthesis/statements.rs\n--- a/checker/src/synthesis/statements.rs\n+++ b/checker/src/synthesis/statements.rs\n@@ -249,10 +262,21 @@ pub(super) fn synthesise_statement<T: crate::ReadFromFS>(\n \t\t\t\t);\n \t\t\t}\n \t\t}\n-\t\tStatement::Empty(_) | Statement::Comment(..) | Statement::MultiLineComment(..) => {}\n+\t\t// TODO do these higher up in the block. To set relevant information\n+\t\tStatement::Comment(s, _) if s.starts_with(\"@ts\") => {\n+\t\t\tcrate::utils::notify!(\"acknowledge '@ts-ignore' and other comments\");\n+\t\t}\n+\t\tStatement::MultiLineComment(s, _) if s.starts_with('*') => {\n+\t\t\tcrate::utils::notify!(\"acknowledge '@ts-ignore' and other comments\");\n+\t\t}\n+\t\tStatement::Comment(..)\n+\t\t| Statement::MultiLineComment(..)\n+\t\t| Statement::Debugger(_)\n+\t\t| Statement::Empty(_) => {}\n \t}\n }\n \n+/// Expects that this caller has already create a context for this to run in\n fn synthesise_block_or_single_statement<T: crate::ReadFromFS>(\n \tblock_or_single_statement: &BlockOrSingleStatement,\n \tenvironment: &mut Environment,\ndiff --git a/checker/src/synthesis/statements.rs b/checker/src/synthesis/statements.rs\n--- a/checker/src/synthesis/statements.rs\n+++ b/checker/src/synthesis/statements.rs\n@@ -263,12 +287,7 @@ fn synthesise_block_or_single_statement<T: crate::ReadFromFS>(\n \t\t\tsynthesise_block(&block.0, environment, checking_data);\n \t\t}\n \t\tBlockOrSingleStatement::SingleStatement(statement) => {\n-\t\t\tsynthesise_statement(statement, environment, checking_data);\n+\t\t\tsynthesise_statement(statement, None, environment, checking_data);\n \t\t}\n \t}\n-\t// environment.new_lexical_environment_fold_into_parent(\n-\t// \tscope,\n-\t// \tchecking_data,\n-\t// \t|environment, checking_data|\n-\t// )\n }\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -36,6 +36,7 @@ use crate::{\n \tsubtyping::{self, type_is_subtype, BasicEquality, SubTypeResult},\n \tsynthesis::functions::synthesise_function_annotation,\n \ttypes::{\n+\t\tget_constraint,\n \t\tpoly_types::generic_type_arguments::StructureGenericArguments,\n \t\tproperties::{PropertyKey, PropertyValue},\n \t\tsubstitute, Constant, PolyNature, StructureGenerics, Type,\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -386,7 +387,7 @@ pub(super) fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\tlet under =\n \t\t\t\tcrate::types::properties::PropertyKey::from_type(indexer, &checking_data.types);\n \n-\t\t\tif let Some(base) = environment.get_poly_base(being_indexed, &checking_data.types) {\n+\t\t\tif let Some(base) = get_constraint(being_indexed, &checking_data.types) {\n \t\t\t\tchecking_data.types.new_property_constructor(being_indexed, indexer, base)\n \t\t\t} else if let Some(prop) = environment.get_property_unbound(\n \t\t\t\tbeing_indexed,\ndiff --git a/checker/src/synthesis/variables.rs b/checker/src/synthesis/variables.rs\n--- a/checker/src/synthesis/variables.rs\n+++ b/checker/src/synthesis/variables.rs\n@@ -13,7 +13,7 @@ use crate::{\n \tdiagnostics::{TypeCheckError, TypeStringRepresentation},\n \tsynthesis::parser_property_key_to_checker_property_key,\n \ttypes::{printing::print_type, properties::PropertyKey, Constant},\n-\tCheckingData, Environment, TypeId,\n+\tCheckingData, Environment, PropertyValue, TypeId,\n };\n \n /// For eagerly registering variables, before the statement and its RHS is actually evaluate\ndiff --git a/checker/src/synthesis/variables.rs b/checker/src/synthesis/variables.rs\n--- a/checker/src/synthesis/variables.rs\n+++ b/checker/src/synthesis/variables.rs\n@@ -89,7 +89,14 @@ pub(crate) fn register_variable<T: crate::ReadFromFS, U: parser::VariableFieldKi\n \t\t\t\t\t\t\t\t&checking_data.types,\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\t\tif let Some(value) = property_constraint {\n-\t\t\t\t\t\t\t\tvalue.prop_to_type()\n+\t\t\t\t\t\t\t\tmatch value {\n+\t\t\t\t\t\t\t\t\tcrate::context::Logical::Pure(PropertyValue::Value(value)) => {\n+\t\t\t\t\t\t\t\t\t\tvalue\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tcrate::context::Logical::Pure(_) => todo!(),\n+\t\t\t\t\t\t\t\t\tcrate::context::Logical::Or { left, right } => todo!(),\n+\t\t\t\t\t\t\t\t\tcrate::context::Logical::Implies { on, antecedent } => todo!(),\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tchecking_data\n \t\t\t\t\t\t\t\t\t.diagnostics_container\ndiff --git a/checker/src/synthesis/variables.rs b/checker/src/synthesis/variables.rs\n--- a/checker/src/synthesis/variables.rs\n+++ b/checker/src/synthesis/variables.rs\n@@ -171,7 +178,14 @@ pub(crate) fn register_variable<T: crate::ReadFromFS, U: parser::VariableFieldKi\n \t\t\t\t\t\t\t\t&checking_data.types,\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\t\tif let Some(value) = property_constraint {\n-\t\t\t\t\t\t\t\tvalue.prop_to_type()\n+\t\t\t\t\t\t\t\tmatch value {\n+\t\t\t\t\t\t\t\t\tcrate::context::Logical::Pure(PropertyValue::Value(value)) => {\n+\t\t\t\t\t\t\t\t\t\tvalue\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tcrate::context::Logical::Pure(_) => todo!(),\n+\t\t\t\t\t\t\t\t\tcrate::context::Logical::Or { left, right } => todo!(),\n+\t\t\t\t\t\t\t\t\tcrate::context::Logical::Implies { on, antecedent } => todo!(),\n+\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\tchecking_data\n \t\t\t\t\t\t\t\t\t.diagnostics_container\ndiff --git a/checker/src/type_mappings.rs b/checker/src/type_mappings.rs\n--- a/checker/src/type_mappings.rs\n+++ b/checker/src/type_mappings.rs\n@@ -27,8 +27,6 @@ pub struct TypeMappings {\n \t/// Data to a AST mapping. For classes this points to the shape\n \tpub types_to_types: RangeMap<TypeId>,\n \tpub import_statements_to_pointing_path: RangeMap<PathBuf>,\n-\t/// can be used for tree shaking\n-\tpub called_functions: HashSet<FunctionId>,\n \n \t/// Variable restriction. Cached after hoisting pass. TODO temp needs tidy\n \tpub variable_restrictions: HashMap<(SourceId, u32), (TypeId, SpanWithSource)>,\ndiff --git a/checker/src/type_mappings.rs b/checker/src/type_mappings.rs\n--- a/checker/src/type_mappings.rs\n+++ b/checker/src/type_mappings.rs\n@@ -47,18 +45,6 @@ pub struct VariablesToTypes(pub(crate) HashMap<VariableId, TypeId>);\n \n // TODO these are temp\n impl TypeMappings {\n-\t#[must_use]\n-\tpub fn print_called_functions(&self, source: &str) -> String {\n-\t\tlet mut buf = \"Called functions:\\n\".to_owned();\n-\t\tfor func_id in &self.called_functions {\n-\t\t\tbuf.push_str(\n-\t\t\t\tsource.get((func_id.1 as usize)..(func_id.1 as usize + 10)).unwrap_or_default(),\n-\t\t\t);\n-\t\t\tbuf.push('\\n');\n-\t\t}\n-\t\tbuf\n-\t}\n-\n \t#[must_use]\n \tpub fn print_type_mappings(\n \t\t&self,\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -7,20 +7,22 @@ use crate::{\n \t\tfunctions::{FunctionBehavior, ThisValue},\n \t},\n \tcontext::{\n-\t\tcalling::CheckThings, get_value_of_variable, CallCheckingBehavior, Environment, Logical,\n+\t\tcalling::CheckThings, get_value_of_variable, CallCheckingBehavior, ContextType,\n+\t\tEnvironment, Logical, SetPropertyError,\n \t},\n-\tdiagnostics::{TypeCheckError, TypeStringRepresentation},\n-\tevents::{apply_event, Event, RootReference},\n+\tdiagnostics::{TypeCheckError, TypeStringRepresentation, TDZ},\n+\tevents::{application::ErrorsAndInfo, apply_event, Event, EventResult, RootReference},\n \tsubtyping::{type_is_subtype, BasicEquality, NonEqualityReason, SubTypeResult},\n \ttypes::{\n \t\tfunctions::SynthesisedArgument, poly_types::generic_type_arguments::TypeArgumentStore,\n-\t\tprinting::print_type, substitute,\n+\t\tprinting::print_type, substitute, ObjectNature,\n \t},\n \ttypes::{FunctionType, Type},\n \tFunctionId, SpecialExpressions, TypeId,\n };\n \n use super::{\n+\tget_constraint, is_type_constant,\n \tpoly_types::{\n \t\tgeneric_type_arguments::StructureGenericArguments, FunctionTypeArguments, SeedingContext,\n \t},\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -56,7 +58,13 @@ pub fn call_type_handle_errors<T: crate::ReadFromFS, M: crate::ASTImplementation\n \t\t&mut checking_data.types,\n \t);\n \tmatch result {\n-\t\tOk(FunctionCallResult { returned_type, warnings, called, special }) => {\n+\t\tOk(FunctionCallResult {\n+\t\t\treturned_type,\n+\t\t\twarnings,\n+\t\t\tcalled,\n+\t\t\tspecial,\n+\t\t\tfound_dependent_argument: _,\n+\t\t}) => {\n \t\t\tfor warning in warnings {\n \t\t\t\tchecking_data.diagnostics_container.add_info(\n \t\t\t\t\tcrate::diagnostics::Diagnostic::Position {\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -67,9 +75,6 @@ pub fn call_type_handle_errors<T: crate::ReadFromFS, M: crate::ASTImplementation\n \t\t\t\t);\n \t\t\t}\n \n-\t\t\tif let Some(called) = called {\n-\t\t\t\tchecking_data.type_mappings.called_functions.insert(called);\n-\t\t\t}\n \t\t\t(returned_type, special)\n \t\t}\n \t\tErr(errors) => {\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -88,7 +93,7 @@ pub(crate) fn call_type<E: CallCheckingBehavior>(\n \ton: TypeId,\n \tCallingInput { called_with_new, this_value, call_site_type_arguments, call_site }: CallingInput,\n \targuments: Vec<SynthesisedArgument>,\n-\tenvironment: &mut Environment,\n+\ttop_environment: &mut Environment,\n \tbehavior: &mut E,\n \ttypes: &mut TypeStore,\n ) -> Result<FunctionCallResult, Vec<FunctionCallingError>> {\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -96,30 +101,27 @@ pub(crate) fn call_type<E: CallCheckingBehavior>(\n \t\t|| arguments.iter().any(|arg| match arg {\n \t\t\tSynthesisedArgument::NonSpread { ty, .. } => *ty == TypeId::ERROR_TYPE,\n \t\t}) {\n+\t\tcrate::utils::notify!(\"Exiting earlier because of ERROR_TYPE fail\");\n \t\treturn Ok(FunctionCallResult {\n \t\t\tcalled: None,\n \t\t\treturned_type: TypeId::ERROR_TYPE,\n \t\t\twarnings: Vec::new(),\n \t\t\tspecial: None,\n+\t\t\tfound_dependent_argument: false,\n \t\t});\n \t}\n \n-\tif let Some(constraint) = environment.get_poly_base(on, types) {\n-\t\tcrate::utils::notify!(\"Evaluating generic call\");\n+\tif let Some(constraint) = get_constraint(on, types) {\n \t\tcreate_generic_function_call(\n \t\t\tconstraint,\n \t\t\tCallingInput { called_with_new, this_value, call_site_type_arguments, call_site },\n \t\t\targuments,\n \t\t\ton,\n-\t\t\tenvironment,\n+\t\t\ttop_environment,\n \t\t\tbehavior,\n \t\t\ttypes,\n \t\t)\n \t} else {\n-\t\t// pub enum Callable {\n-\t\t// \tFunction()\n-\t\t// }\n-\n \t\tlet callable = get_logical_callable_from_type(on, types);\n \n \t\tif let Some(logical) = callable {\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -130,14 +132,14 @@ pub(crate) fn call_type<E: CallCheckingBehavior>(\n \t\t\t\tCallingInputWithoutThis { called_with_new, call_site_type_arguments, call_site },\n \t\t\t\tstructure_generics,\n \t\t\t\targuments,\n-\t\t\t\tenvironment,\n+\t\t\t\ttop_environment,\n \t\t\t\tbehavior,\n \t\t\t)\n \t\t} else {\n \t\t\tErr(vec![FunctionCallingError::NotCallable {\n \t\t\t\tcalling: crate::diagnostics::TypeStringRepresentation::from_type_id(\n \t\t\t\t\ton,\n-\t\t\t\t\t&environment.as_general_context(),\n+\t\t\t\t\t&top_environment.as_general_context(),\n \t\t\t\t\ttypes,\n \t\t\t\t\tfalse,\n \t\t\t\t),\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -156,7 +158,6 @@ fn call_logical<E: CallCheckingBehavior>(\n \tenvironment: &mut Environment,\n \tbehavior: &mut E,\n ) -> Result<FunctionCallResult, Vec<FunctionCallingError>> {\n-\tcrate::utils::notify!(\"Calling logical\");\n \tmatch logical {\n \t\tLogical::Pure((func, this_value)) => {\n \t\t\tif let Some(function_type) = types.functions.get(&func) {\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -336,6 +375,18 @@ pub enum FunctionCallingError {\n \tCyclicRecursion(FunctionId, SpanWithSource),\n \tNoLogicForIdentifier(String, SpanWithSource),\n \tNeedsToBeCalledWithNewKeyword(SpanWithSource),\n+\tTDZ {\n+\t\terror: TDZ,\n+\t\t/// Should be set\n+\t\tcall_site: Option<SpanWithSource>,\n+\t},\n+\tSetPropertyConstraint {\n+\t\tproperty_type: TypeStringRepresentation,\n+\t\tvalue_type: TypeStringRepresentation,\n+\t\tassignment_position: SpanWithSource,\n+\t\t/// Should be set\n+\t\tcall_site: Option<SpanWithSource>,\n+\t},\n }\n \n pub struct InfoDiagnostic(pub String);\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -347,6 +398,7 @@ pub struct FunctionCallResult {\n \t// TODO\n \tpub warnings: Vec<InfoDiagnostic>,\n \tpub special: Option<SpecialExpressions>,\n+\tpub found_dependent_argument: bool,\n }\n \n #[derive(Debug, Default, Clone, Copy, binary_serialize_derive::BinarySerializable)]\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -388,21 +440,28 @@ impl FunctionType {\n \t\t\t\twarnings: Vec::new(),\n \t\t\t\t// TODO ?\n \t\t\t\tspecial: None,\n+\t\t\t\tfound_dependent_argument: false,\n \t\t\t});\n \t\t\t// let reason = FunctionCallingError::Recursed(self.id, call_site);\n \t\t\t// return Err(vec![reason])\n \t\t}\n \n+\t\tif !(environment.context_type.is_conditional()\n+\t\t\t|| environment.context_type.is_dynamic_boundary())\n+\t\t{\n+\t\t\ttypes.called_functions.insert(self.id);\n+\t\t}\n+\n \t\tif let (Some(const_fn_ident), true) = (self.constant_function.as_deref(), call_constant) {\n \t\t\tlet has_dependent_argument = arguments.iter().any(|arg| {\n \t\t\t\ttypes.get_type_by_id(arg.to_type().expect(\"dependent spread types\")).is_dependent()\n \t\t\t}) || matches!(this_value, ThisValue::Passed(ty) if types.get_type_by_id(ty).is_dependent());\n \n-\t\t\t// TODO temp, need a better solution\n \t\t\tlet call_anyway = matches!(\n \t\t\t\tconst_fn_ident,\n \t\t\t\t\"debug_type\"\n-\t\t\t\t\t| \"print_type\" | \"debug_effects\"\n+\t\t\t\t\t| \"debug_type_rust\" | \"print_type\"\n+\t\t\t\t\t| \"debug_effects\" | \"debug_effects_rust\"\n \t\t\t\t\t| \"satisfies\" | \"is_dependent\"\n \t\t\t\t\t| \"bind\" | \"create_proxy\"\n \t\t\t);\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -432,14 +491,17 @@ impl FunctionType {\n \t\t\t\t\t\t\treturned_type: value,\n \t\t\t\t\t\t\twarnings: Default::default(),\n \t\t\t\t\t\t\tcalled: None,\n+\t\t\t\t\t\t\tfound_dependent_argument: false,\n \t\t\t\t\t\t\tspecial,\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t\tOk(ConstantOutput::Diagnostic(diagnostic)) => {\n+\t\t\t\t\t\tcrate::utils::notify!(\"Here, constant output\");\n \t\t\t\t\t\treturn Ok(FunctionCallResult {\n \t\t\t\t\t\t\treturned_type: TypeId::UNDEFINED_TYPE,\n \t\t\t\t\t\t\twarnings: vec![InfoDiagnostic(diagnostic)],\n \t\t\t\t\t\t\tcalled: None,\n+\t\t\t\t\t\t\tfound_dependent_argument: false,\n \t\t\t\t\t\t\t// TODO!!\n \t\t\t\t\t\t\tspecial: Some(SpecialExpressions::Marker),\n \t\t\t\t\t\t});\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -499,11 +565,12 @@ impl FunctionType {\n \t\t\t\t\twarnings: Default::default(),\n \t\t\t\t\tcalled: None,\n \t\t\t\t\tspecial: None,\n+\t\t\t\t\tfound_dependent_argument: true,\n \t\t\t\t});\n \t\t\t}\n \t\t}\n \n-\t\tlet (mut errors, mut warnings) = (Vec::new(), Vec::<()>::new());\n+\t\tlet mut errors = ErrorsAndInfo::default();\n \n \t\t// Type arguments of the function\n \t\tlet local_type_argument_as_restrictions: map_vec::Map<\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -527,8 +594,12 @@ impl FunctionType {\n \t\tmatch self.behavior {\n \t\t\tFunctionBehavior::ArrowFunction { is_async } => {}\n \t\t\tFunctionBehavior::Method { free_this_id, .. } => {\n-\t\t\t\tlet value_of_this =\n-\t\t\t\t\tthis_value.get_passed().expect(\"method has no 'this' passed :?\");\n+\t\t\t\tlet value_of_this = if let Some(value) = this_value.get_passed() {\n+\t\t\t\t\tvalue\n+\t\t\t\t} else {\n+\t\t\t\t\tcrate::utils::notify!(\"method has no 'this' passed :?\");\n+\t\t\t\t\tTypeId::UNDEFINED_TYPE\n+\t\t\t\t};\n \n \t\t\t\tcrate::utils::notify!(\"ft id {:?} & vot {:?}\", free_this_id, value_of_this);\n \ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -566,7 +637,9 @@ impl FunctionType {\n \t\t\t}\n \t\t\tFunctionBehavior::Constructor { non_super_prototype, this_object_type } => {\n \t\t\t\tif let CalledWithNew::None = called_with_new {\n-\t\t\t\t\terrors.push(FunctionCallingError::NeedsToBeCalledWithNewKeyword(call_site));\n+\t\t\t\t\terrors\n+\t\t\t\t\t\t.errors\n+\t\t\t\t\t\t.push(FunctionCallingError::NeedsToBeCalledWithNewKeyword(call_site));\n \t\t\t\t}\n \t\t\t}\n \t\t}\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -614,13 +687,12 @@ impl FunctionType {\n \t\t// take the found and inject back into what it resolved\n \t\tlet mut result_type_arguments = map_vec::Map::new();\n \n-\t\tfound.into_iter().for_each(|(item, values)| {\n-\t\t\tlet mut into_iter = values.into_iter();\n+\t\tfor (item, values) in found {\n+\t\t\t// TODO only first ??\n \t\t\tlet (mut value, argument_position, param) =\n-\t\t\t\tinto_iter.next().expect(\"no type argument ...?\");\n+\t\t\t\tvalues.into_iter().next().expect(\"no type argument ...?\");\n \n-\t\t\tlet restrictions_for_item = type_restrictions.get(&item);\n-\t\t\tif let Some(restrictions_for_item) = restrictions_for_item {\n+\t\t\tif let Some(restrictions_for_item) = type_restrictions.get(&item) {\n \t\t\t\tfor (restriction, restriction_position) in restrictions_for_item {\n \t\t\t\t\tlet mut behavior = BasicEquality {\n \t\t\t\t\t\tadd_property_restrictions: false,\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -653,7 +725,7 @@ impl FunctionType {\n \t\t\t\t\t\t\tfalse,\n \t\t\t\t\t\t);\n \n-\t\t\t\t\t\terrors.push(FunctionCallingError::InvalidArgumentType {\n+\t\t\t\t\t\terrors.errors.push(FunctionCallingError::InvalidArgumentType {\n \t\t\t\t\t\t\targument_type,\n \t\t\t\t\t\t\targument_position,\n \t\t\t\t\t\t\tparameter_type,\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -666,12 +738,7 @@ impl FunctionType {\n \n \t\t\t// TODO position is just the first\n \t\t\tresult_type_arguments.insert(item, (value, argument_position));\n-\t\t});\n-\t\t// for (item, restrictions) in type_restrictions.iter() {\n-\t\t// \tfor (restriction, pos) in restrictions {\n-\t\t// \t\t// TODO\n-\t\t// \t}\n-\t\t// }\n+\t\t}\n \n \t\tlet mut type_arguments = FunctionTypeArguments {\n \t\t\tstructure_arguments: parent_type_arguments,\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -683,8 +750,8 @@ impl FunctionType {\n \t\t\t// TODO check free variables from inference\n \t\t}\n \n-\t\tif !errors.is_empty() {\n-\t\t\treturn Err(errors);\n+\t\tif !errors.errors.is_empty() {\n+\t\t\treturn Err(errors.errors);\n \t\t}\n \n \t\t// Evaluate effects directly into environment\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -698,9 +765,31 @@ impl FunctionType {\n \n \t\t\tlet mut return_result = None;\n \n+\t\t\t// Apply events here\n \t\t\tfor event in self.effects.clone() {\n-\t\t\t\tlet result =\n-\t\t\t\t\tapply_event(event, this_value, &mut type_arguments, environment, target, types);\n+\t\t\t\tlet current_errors = errors.errors.len();\n+\t\t\t\tlet result = apply_event(\n+\t\t\t\t\tevent,\n+\t\t\t\t\tthis_value,\n+\t\t\t\t\t&mut type_arguments,\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\ttarget,\n+\t\t\t\t\ttypes,\n+\t\t\t\t\t&mut errors,\n+\t\t\t\t);\n+\n+\t\t\t\t// Adjust call sites. (because they aren't currently passed down)\n+\t\t\t\tfor d in &mut errors.errors[current_errors..] {\n+\t\t\t\t\tif let FunctionCallingError::TDZ { call_site: ref mut c, .. } = d {\n+\t\t\t\t\t\t*c = Some(call_site);\n+\t\t\t\t\t} else if let FunctionCallingError::SetPropertyConstraint {\n+\t\t\t\t\t\tcall_site: ref mut c,\n+\t\t\t\t\t\t..\n+\t\t\t\t\t} = d\n+\t\t\t\t\t{\n+\t\t\t\t\t\t*c = Some(call_site);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \n \t\t\t\tif let value @ Some(_) = result {\n \t\t\t\t\treturn_result = value;\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -709,6 +798,8 @@ impl FunctionType {\n \t\t\t}\n \n \t\t\tif let Some(closure_id) = type_arguments.closure_id {\n+\t\t\t\tcrate::utils::notify!(\"Setting closure variables\");\n+\n \t\t\t\t// Set closed over values\n \t\t\t\tself.closed_over_variables.iter().for_each(|(reference, value)| {\n \t\t\t\t\tlet value = substitute(*value, &mut type_arguments, environment, types);\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -724,6 +815,11 @@ impl FunctionType {\n \t\t\treturn_result\n \t\t});\n \n+\t\tif !errors.errors.is_empty() {\n+\t\t\tcrate::utils::notify!(\"Got {} application errors\", errors.errors.len());\n+\t\t\treturn Err(errors.errors);\n+\t\t}\n+\n \t\tif let CalledWithNew::New { .. } = called_with_new {\n \t\t\t// TODO ridiculous early return primitive rule\n \t\t\tmatch self.behavior {\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -738,9 +834,10 @@ impl FunctionType {\n \n \t\t\t\t\treturn Ok(FunctionCallResult {\n \t\t\t\t\t\treturned_type: new_instance_type,\n-\t\t\t\t\t\twarnings: Default::default(),\n+\t\t\t\t\t\twarnings: errors.warnings,\n \t\t\t\t\t\tcalled: Some(self.id),\n \t\t\t\t\t\tspecial: None,\n+\t\t\t\t\t\tfound_dependent_argument: false,\n \t\t\t\t\t});\n \t\t\t\t}\n \t\t\t\tFunctionBehavior::Constructor { non_super_prototype, this_object_type } => {\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -753,26 +850,29 @@ impl FunctionType {\n \n \t\t\t\t\treturn Ok(FunctionCallResult {\n \t\t\t\t\t\treturned_type: new_instance_type,\n-\t\t\t\t\t\twarnings: Default::default(),\n+\t\t\t\t\t\twarnings: errors.warnings,\n \t\t\t\t\t\tcalled: Some(self.id),\n \t\t\t\t\t\tspecial: None,\n+\t\t\t\t\t\tfound_dependent_argument: false,\n \t\t\t\t\t});\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// set events should cover property specialisation here:\n-\t\tlet returned_type = if let Some(returned_type) = early_return {\n+\t\tlet returned_type = if let Some(EventResult::Return(returned_type, _)) = early_return {\n \t\t\treturned_type\n \t\t} else {\n+\t\t\tcrate::utils::notify!(\"Substituting return type (no return)\");\n \t\t\tsubstitute(self.return_type, &mut type_arguments, environment, types)\n \t\t};\n \n \t\tOk(FunctionCallResult {\n \t\t\treturned_type,\n-\t\t\twarnings: Default::default(),\n+\t\t\twarnings: errors.warnings,\n \t\t\tcalled: Some(self.id),\n \t\t\tspecial: None,\n+\t\t\tfound_dependent_argument: false,\n \t\t})\n \t}\n \ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -782,7 +882,7 @@ impl FunctionType {\n \t\tmut seeding_context: SeedingContext,\n \t\tenvironment: &mut Environment,\n \t\ttypes: &TypeStore,\n-\t\terrors: &mut Vec<FunctionCallingError>,\n+\t\terrors: &mut ErrorsAndInfo,\n \t\tcall_site: &source_map::BaseSpan<SourceId>,\n \t) -> SeedingContext {\n \t\tfor (parameter_idx, parameter) in self.parameters.parameters.iter().enumerate() {\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -827,7 +927,7 @@ impl FunctionType {\n \t\t\t\t\t);\n \n \t\t\t\t\tif let SubTypeResult::IsNotSubType(reasons) = result {\n-\t\t\t\t\t\terrors.push(FunctionCallingError::InvalidArgumentType {\n+\t\t\t\t\t\terrors.errors.push(FunctionCallingError::InvalidArgumentType {\n \t\t\t\t\t\t\tparameter_type: TypeStringRepresentation::from_type_id(\n \t\t\t\t\t\t\t\tparameter.ty,\n \t\t\t\t\t\t\t\t&environment.as_general_context(),\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -862,7 +962,7 @@ impl FunctionType {\n \t\t\t\t);\n \t\t\t} else {\n \t\t\t\t// TODO group\n-\t\t\t\terrors.push(FunctionCallingError::MissingArgument {\n+\t\t\t\terrors.errors.push(FunctionCallingError::MissingArgument {\n \t\t\t\t\tparameter_position: parameter.position,\n \t\t\t\t\tcall_site: *call_site,\n \t\t\t\t});\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -872,7 +972,7 @@ impl FunctionType {\n \t\t\t// \tif auto_inserted_arg {\n \t\t\t// \t\ttodo!(\"different error\");\n \t\t\t// \t} else {\n-\t\t\t// \t\terrors.push(FunctionCallingError::InvalidArgumentType {\n+\t\t\t// \t\terrors.errors.push(FunctionCallingError::InvalidArgumentType {\n \t\t\t// \t\t\tparameter_index: idx,\n \t\t\t// \t\t\targument_type: argument_type.into_owned(),\n \t\t\t// \t\t\tparameter_type: parameter_type.clone(),\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -881,7 +981,7 @@ impl FunctionType {\n \t\t\t// \t}\n \t\t\t// }\n \t\t\t// } else {\n-\t\t\t// \terrors.push(FunctionCallingError::MissingArgument {\n+\t\t\t// \terrors.errors.push(FunctionCallingError::MissingArgument {\n \t\t\t// \t\tparameter_pos: parameter.2.clone().unwrap(),\n \t\t\t// \t});\n \t\t\t// }\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -923,7 +1023,7 @@ impl FunctionType {\n \t\t\t\t\t\t);\n \n \t\t\t\t\t\tif let SubTypeResult::IsNotSubType(reasons) = result {\n-\t\t\t\t\t\t\terrors.push(FunctionCallingError::InvalidArgumentType {\n+\t\t\t\t\t\t\terrors.errors.push(FunctionCallingError::InvalidArgumentType {\n \t\t\t\t\t\t\t\tparameter_type: TypeStringRepresentation::from_type_id(\n \t\t\t\t\t\t\t\t\trest_parameter.item_type,\n \t\t\t\t\t\t\t\t\t&environment.as_general_context(),\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -964,7 +1064,7 @@ impl FunctionType {\n \t\t\t\t} else {\n \t\t\t\t\tfirst.get_position()\n \t\t\t\t};\n-\t\t\t\terrors.push(FunctionCallingError::ExcessArguments { count, position });\n+\t\t\t\terrors.errors.push(FunctionCallingError::ExcessArguments { count, position });\n \t\t\t}\n \t\t}\n \t\tseeding_context\ndiff --git a/checker/src/types/functions.rs b/checker/src/types/functions.rs\n--- a/checker/src/types/functions.rs\n+++ b/checker/src/types/functions.rs\n@@ -90,7 +90,7 @@ impl FunctionType {\n \t\tlet behavior =\n \t\t\tFunctionBehavior::Constructor { non_super_prototype: None, this_object_type: on };\n \n-\t\tlet (events, free_variables) = env_data.unwrap();\n+\t\tlet (facts, free_variables) = env_data.unwrap();\n \t\tSelf {\n \t\t\tid: crate::FunctionId::AUTO_CONSTRUCTOR,\n \t\t\tconstant_function: None,\ndiff --git a/checker/src/types/functions.rs b/checker/src/types/functions.rs\n--- a/checker/src/types/functions.rs\n+++ b/checker/src/types/functions.rs\n@@ -98,7 +98,7 @@ impl FunctionType {\n \t\t\tparameters: SynthesisedParameters::default(),\n \t\t\t// Only needed for printing\n \t\t\treturn_type: on,\n-\t\t\teffects: events,\n+\t\t\teffects: facts.events,\n \t\t\tbehavior,\n \t\t\t// TODO ???\n \t\t\tfree_variables: Default::default(),\ndiff --git a/checker/src/types/functions.rs b/checker/src/types/functions.rs\n--- a/checker/src/types/functions.rs\n+++ b/checker/src/types/functions.rs\n@@ -120,6 +120,8 @@ pub(crate) fn create_this_before_function_synthesis(\n \t\treferenced_in_scope_as: ty,\n \t\tprototype: crate::events::PrototypeArgument::Yeah(prototype),\n \t\tposition: None,\n+\t\t// TODO right?\n+\t\tis_function_this: true,\n \t};\n \tfacts.events.push(value);\n \ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -37,6 +37,8 @@ use self::{\n };\n use crate::FunctionId;\n \n+pub type TypeArguments = map_vec::Map<TypeId, (TypeId, SpanWithSource)>;\n+\n /// References [Type]\n ///\n /// TODO maybe u32 or u64\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -128,6 +130,8 @@ pub enum Type {\n }\n \n /// TODO difference between untyped and typed parameters and what about parameter based for any\n+///\n+/// Most of the difference here is just for debugging, printing etc\n #[derive(Clone, Debug, binary_serialize_derive::BinarySerializable)]\n pub enum PolyNature {\n \tParameter {\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -138,14 +142,13 @@ pub enum PolyNature {\n \t\teager_fixed: TypeId,\n \t},\n \tOpen(TypeId),\n-\t/// For functions and for loops where something in the scope can mutate (so not constant)\n-\t/// between runs.\n+\t/// For functions and for loops where something in the scope can mutate\n+\t/// (so not constant) between runs.\n \tFreeVariable {\n \t\treference: RootReference,\n \t\tbased_on: TypeId,\n \t},\n \tRecursiveFunction(FunctionId, TypeId),\n-\t// Object\n }\n \n // TODO\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -157,6 +160,17 @@ pub fn is_primitive(ty: TypeId, types: &TypeStore) -> bool {\n \tfalse\n }\n \n+/// not full constant but\n+#[must_use]\n+pub fn is_type_constant(ty: TypeId, types: &TypeStore) -> bool {\n+\tmatches!(ty, TypeId::UNDEFINED_TYPE | TypeId::NULL_TYPE)\n+\t\t|| matches!(\n+\t\t\ttypes.get_type_by_id(ty),\n+\t\t\tType::Constant(..) | Type::Object(ObjectNature::RealDeal) | Type::SpecialObject(..)\n+\t\t)\n+}\n+\n+/// TODO split\n #[derive(Copy, Clone, Debug, binary_serialize_derive::BinarySerializable)]\n pub enum ObjectNature {\n \t/// Actual allocated object\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -226,8 +240,8 @@ pub enum Constructor {\n \t\telse_result: TypeId,\n \t\tresult_union: TypeId,\n \t},\n-\t///\n-\tFunctionResult {\n+\t/// output of a function where on is dependent (or sometimes for const functions one of `with` is dependent)\n+\tImage {\n \t\ton: TypeId,\n \t\t// TODO I don't think this is necessary, maybe for debugging. In such case should be an Rc to share with events\n \t\twith: Box<[SynthesisedArgument]>,\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -246,7 +260,7 @@ impl Constructor {\n \tfn get_base(&self) -> Option<TypeId> {\n \t\tmatch self {\n \t\t\tConstructor::ConditionalResult { result_union: result, .. }\n-\t\t\t| Constructor::FunctionResult { result, .. } => Some(*result),\n+\t\t\t| Constructor::Image { result, .. } => Some(*result),\n \t\t\tConstructor::BinaryOperator { .. }\n \t\t\t| Constructor::CanonicalRelationOperator { .. }\n \t\t\t| Constructor::UnaryOperator { .. }\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -451,3 +465,208 @@ pub(crate) fn is_explicit_generic(on: TypeId, types: &TypeStore) -> bool {\n \t\tfalse\n \t}\n }\n+\n+/// Finds the constraint of poly types\n+///\n+/// **Also looks at possibly mutated things\n+pub(crate) fn get_constraint(on: TypeId, types: &TypeStore) -> Option<TypeId> {\n+\tmatch types.get_type_by_id(on) {\n+\t\tType::RootPolyType(nature) => {\n+\t\t\tlet based_on = match nature {\n+\t\t\t\tPolyNature::Parameter { fixed_to } => fixed_to,\n+\t\t\t\tPolyNature::Generic { name, eager_fixed } => eager_fixed,\n+\t\t\t\tPolyNature::Open(ty) => ty,\n+\t\t\t\tPolyNature::FreeVariable { reference, based_on } => based_on,\n+\t\t\t\tPolyNature::RecursiveFunction(_, return_ty) => return_ty,\n+\t\t\t};\n+\n+\t\t\t// TODO not sure\n+\n+\t\t\tSome(*based_on)\n+\n+\t\t\t// // TODO into function\n+\t\t\t// match nature.get_poly_pointer() {\n+\t\t\t// \tPolyPointer::Fixed(to) => Some(PolyBase::Fixed {\n+\t\t\t// \t\tto,\n+\t\t\t// \t\tis_open_poly: matches!(nature, PolyNature::Open(..)),\n+\t\t\t// \t}),\n+\t\t\t// \tPolyPointer::Inferred(boundary) => {\n+\t\t\t// \t\tlet to = self\n+\t\t\t// \t\t\t.parents_iter()\n+\t\t\t// \t\t\t.find_map(|ctx| get_on_ctx!(ctx.bases.get_local_type_base(on)))\n+\t\t\t// \t\t\t// TODO temp\n+\t\t\t// \t\t\t.unwrap_or_else(|| {\n+\t\t\t// \t\t\t\tcrate::utils::notify!(\"No type base on inferred poly type\");\n+\t\t\t// \t\t\t\tTypeId::ANY_TYPE\n+\t\t\t// \t\t\t});\n+\n+\t\t\t// \t\tSome(PolyBase::Dynamic { to, boundary })\n+\t\t\t// \t}\n+\t\t\t// }\n+\n+\t\t\t// if let Some(to) = .m {\n+\t\t\t// \tSome(PolyBase::Fixed {\n+\t\t\t// \t\tto,\n+\t\t\t// \t\tis_open_poly: matches!(nature, PolyNature::Open(_)),\n+\t\t\t// \t})\n+\t\t\t// } else {\n+\t\t\t// \tSome(PolyBase::Dynamic { to: (), boundary: () })\n+\n+\t\t\t// \t// let modified_base =\n+\t\t\t// \t// \tself.parents_iter().find_map(|env| get_on_ctx!(env.bases.get(&on)).copied());\n+\n+\t\t\t// \t// let aliases = modified_base.unwrap_or(*aliases);\n+\n+\t\t\t// \t// Some(if constraint_is_mutable {\n+\t\t\t// \t// \tPolyBase::Dynamic(aliases)\n+\t\t\t// \t// } else {\n+\t\t\t// \t// })\n+\t\t\t// }\n+\t\t}\n+\t\tType::Constructor(constructor) => match constructor.clone() {\n+\t\t\tConstructor::BinaryOperator { lhs, operator, rhs } => {\n+\t\t\t\tif let MathematicalAndBitwise::Add = operator {\n+\t\t\t\t\tlet lhs = get_larger_type(lhs, types);\n+\t\t\t\t\tlet rhs = get_larger_type(rhs, types);\n+\t\t\t\t\t// TODO these need to be generated\n+\t\t\t\t\tif let (TypeId::NUMBER_TYPE, TypeId::NUMBER_TYPE) = (lhs, rhs) {\n+\t\t\t\t\t\tSome(TypeId::NUMBER_TYPE)\n+\t\t\t\t\t} else if let (TypeId::STRING_TYPE, _) | (_, TypeId::STRING_TYPE) = (lhs, rhs) {\n+\t\t\t\t\t\tSome(TypeId::STRING_TYPE)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tcrate::utils::notify!(\"lhs = {:?}\", types.get_type_by_id(lhs));\n+\t\t\t\t\t\t// TODO new conditional\n+\t\t\t\t\t\ttodo!(\"Based on conditional {:?} + {:?}\", lhs, rhs)\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tSome(TypeId::NUMBER_TYPE)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tConstructor::UnaryOperator { operand, operator } => {\n+\t\t\t\ttodo!()\n+\t\t\t\t// if *constraint == TypeId::ANY_TYPE && mutable_context {\n+\t\t\t\t// \tlet (operand, operator) = (operand.clone(), operator.clone());\n+\t\t\t\t// \tlet constraint = to(self, data);\n+\t\t\t\t// \tself.modify_type(\n+\t\t\t\t// \t\ton,\n+\t\t\t\t// \t\tSome(Type::Constructor(Constructor::UnaryOperator {\n+\t\t\t\t// \t\t\toperator,\n+\t\t\t\t// \t\t\toperand,\n+\t\t\t\t// \t\t\t\t\t\t\t\t// \t\t})),\n+\t\t\t\t// \t);\n+\t\t\t\t// \tSome(constraint)\n+\t\t\t\t// } else {\n+\t\t\t\t// \tSome(*constraint)\n+\t\t\t\t// }\n+\t\t\t}\n+\t\t\tConstructor::Image { on, with, result } => {\n+\t\t\t\tSome(result)\n+\t\t\t\t// TODO temp\n+\t\t\t\t// if let PolyPointer::Fixed(result) = result {\n+\t\t\t\t// \tSome(PolyBase::Fixed { to: result, is_open_poly: true })\n+\t\t\t\t// } else {\n+\t\t\t\t// \tlet on_base_function = self.get_poly_base(on, types);\n+\t\t\t\t// \tif let Some(base) = on_base_function {\n+\t\t\t\t// \t\tlet (boundary, is_open_poly, ty) = base.unravel();\n+\t\t\t\t// \t\tif let Type::Function(func, _) = types.get_type_by_id(ty) {\n+\t\t\t\t// \t\t\tSome(func.return_type)\n+\t\t\t\t// \t\t} else {\n+\t\t\t\t// \t\t\ttodo!()\n+\t\t\t\t// \t\t}\n+\t\t\t\t// \t} else {\n+\t\t\t\t// \t\t// TODO record ahead of time, rather than recalculating here\n+\t\t\t\t// \t\tlet is_open_poly = with\n+\t\t\t\t// \t\t\t.iter()\n+\t\t\t\t// \t\t\t.filter_map(|arg| {\n+\t\t\t\t// \t\t\t\tself.get_poly_base(arg.into_type().unwrap(), types)\n+\t\t\t\t// \t\t\t})\n+\t\t\t\t// \t\t\t.all(|base| base.is_open_poly());\n+\n+\t\t\t\t// \t\tlet ty = types.get_type_by_id(on);\n+\t\t\t\t// \t\tif let Type::Function(func, _) = ty {\n+\t\t\t\t// \t\t\t// TODO\n+\t\t\t\t// \t\t\tSome(func.return_type)\n+\t\t\t\t// \t\t} else {\n+\t\t\t\t// \t\t\tlet on = crate::types::printing::print_type(\n+\t\t\t\t// \t\t\t\ton,\n+\t\t\t\t// \t\t\t\ttypes,\n+\t\t\t\t// \t\t\t\t&self.into_general_context(),\n+\t\t\t\t// \t\t\t\ttrue,\n+\t\t\t\t// \t\t\t);\n+\t\t\t\t// \t\t\tunreachable!(\"Getting function on {}\", on);\n+\t\t\t\t// \t\t}\n+\t\t\t\t// \t}\n+\t\t\t\t// }\n+\t\t\t}\n+\t\t\tConstructor::Property { on, under, result } => {\n+\t\t\t\tcrate::utils::notify!(\"Here, result of a property get\");\n+\t\t\t\tSome(result)\n+\n+\t\t\t\t// `on` or `under` will be poly, but one of them may be a non-poly\n+\t\t\t\t// type and so it can be expected to be `None` here.\n+\t\t\t\t// TODO needs better primitives for controlling this\n+\t\t\t\t// let on_constraint = self.get_poly_base(on, types).unwrap_or(on);\n+\t\t\t\t// let property = match under {\n+\t\t\t\t// \tPropertyKey::Type(ty) => {\n+\t\t\t\t// \t\tPropertyKey::Type(self.get_poly_base(ty, types).unwrap_or(ty))\n+\t\t\t\t// \t}\n+\t\t\t\t// \tprop => prop,\n+\t\t\t\t// };\n+\n+\t\t\t\t// Bad\n+\t\t\t\t// let is_open_poly =\n+\t\t\t\t// \ton_constraint.as_ref().map(PolyBase::is_open_poly).unwrap_or(true)\n+\t\t\t\t// \t\t&& property_constraint\n+\t\t\t\t// \t\t\t.as_ref()\n+\t\t\t\t// \t\t\t.map(PolyBase::is_open_poly)\n+\t\t\t\t// \t\t\t.unwrap_or(true);\n+\n+\t\t\t\t// let on_base = on_constraint.unwrap_or(on);\n+\t\t\t\t// let property_base = property_constraint.unwrap_or(under);\n+\n+\t\t\t\t// TODO abstract to function\n+\t\t\t\t// let (on_boundary, _, on_constraint) = on_base.unravel();\n+\t\t\t\t// let (property_fixed, _, property_constraint) = property_base.unravel();\n+\n+\t\t\t\t// TODO temp\n+\t\t\t\t// let result = result self\n+\t\t\t\t// \t.get_property_unbound(on_constraint, PublicityKind::Public, property, types)\n+\t\t\t\t// \t.map(|property| match property {\n+\t\t\t\t// \t\tLogical::Pure(PropertyValue::Value(v)) => v,\n+\t\t\t\t// \t\t// TODO not sure?\n+\t\t\t\t// \t\tLogical::Pure(PropertyValue::Getter(g)) => g.return_type,\n+\t\t\t\t// \t\tresult => todo!(\"{:?}\", result),\n+\t\t\t\t// \t})\n+\t\t\t\t// \t.expect(\"Inference failed\");\n+\t\t\t}\n+\t\t\tConstructor::ConditionalResult { result_union, .. } => {\n+\t\t\t\t// TODO dynamic and open poly\n+\t\t\t\tSome(result_union)\n+\t\t\t}\n+\t\t\tConstructor::TypeOperator(_) | Constructor::CanonicalRelationOperator { .. } => {\n+\t\t\t\t// TODO open poly\n+\t\t\t\tSome(TypeId::BOOLEAN_TYPE)\n+\t\t\t}\n+\t\t\tConstructor::TypeRelationOperator(op) => match op {\n+\t\t\t\tcrate::types::TypeRelationOperator::Extends { .. } => Some(TypeId::BOOLEAN_TYPE),\n+\t\t\t},\n+\t\t\t// TODO sure?\n+\t\t\tConstructor::StructureGenerics { .. } => None,\n+\t\t},\n+\t\tType::Object(ObjectNature::RealDeal) => {\n+\t\t\tcrate::utils::notify!(\"Might be missing some obj here\");\n+\t\t\tNone\n+\t\t}\n+\t\t_ => None,\n+\t}\n+}\n+\n+fn get_larger_type(on: TypeId, types: &TypeStore) -> TypeId {\n+\tif let Some(poly_base) = get_constraint(on, types) {\n+\t\tpoly_base\n+\t} else if let Type::Constant(cst) = types.get_type_by_id(on) {\n+\t\tcst.get_backing_type_id()\n+\t} else {\n+\t\ton\n+\t}\n+}\ndiff --git a/checker/src/types/poly_types/generics/generic_type_arguments.rs b/checker/src/types/poly_types/generics/generic_type_arguments.rs\n--- a/checker/src/types/poly_types/generics/generic_type_arguments.rs\n+++ b/checker/src/types/poly_types/generics/generic_type_arguments.rs\n@@ -67,9 +67,17 @@ pub(crate) struct FunctionTypeArguments {\n }\n \n impl FunctionTypeArguments {\n-\tpub(crate) fn set_id_from_reference(&mut self, id: TypeId, value: TypeId, types: &TypeStore) {\n+\tpub(crate) fn set_id_from_reference(&mut self, id: TypeId, value: TypeId) {\n \t\tself.local_arguments.insert(id, (value, SpanWithSource::NULL_SPAN));\n \t}\n+\n+\tpub(crate) fn new() -> Self {\n+\t\tSelf {\n+\t\t\tstructure_arguments: Default::default(),\n+\t\t\tlocal_arguments: SmallMap::new(),\n+\t\t\tclosure_id: Default::default(),\n+\t\t}\n+\t}\n }\n \n pub(crate) trait TypeArgumentStore {\ndiff --git a/checker/src/types/poly_types/generics/generic_type_arguments.rs b/checker/src/types/poly_types/generics/generic_type_arguments.rs\n--- a/checker/src/types/poly_types/generics/generic_type_arguments.rs\n+++ b/checker/src/types/poly_types/generics/generic_type_arguments.rs\n@@ -166,7 +174,8 @@ impl TypeArgumentStore for SmallMap<TypeId, (TypeId, SpanWithSource)> {\n \t}\n \n \tfn to_structural_generic_arguments(&self) -> StructureGenericArguments {\n-\t\ttodo!(\"This shouldn't be needed\");\n+\t\tcrate::utils::notify!(\"to_structural_generic_arguments shouldn't be needed\");\n+\t\tStructureGenericArguments { type_arguments: self.clone(), closures: Vec::new() }\n \t}\n \n \tfn is_empty(&self) -> bool {\ndiff --git a/checker/src/types/poly_types/substitution.rs b/checker/src/types/poly_types/substitution.rs\n--- a/checker/src/types/poly_types/substitution.rs\n+++ b/checker/src/types/poly_types/substitution.rs\n@@ -3,9 +3,15 @@\n use crate::{\n \tbehavior::{\n \t\tfunctions::{ClosureId, ThisValue},\n-\t\toperations::{evaluate_equality_inequality_operation, evaluate_mathematical_operation},\n+\t\toperations::{\n+\t\t\tevaluate_equality_inequality_operation, evaluate_mathematical_operation,\n+\t\t\tevaluate_pure_unary_operator,\n+\t\t},\n+\t},\n+\ttypes::{\n+\t\tget_constraint, is_type_truthy_falsy, Constructor, PolyNature, StructureGenerics, Type,\n+\t\tTypeStore,\n \t},\n-\ttypes::{is_type_truthy_falsy, Constructor, PolyNature, StructureGenerics, Type, TypeStore},\n \tDecidable, Environment, TypeId,\n };\n \ndiff --git a/checker/src/types/poly_types/substitution.rs b/checker/src/types/poly_types/substitution.rs\n--- a/checker/src/types/poly_types/substitution.rs\n+++ b/checker/src/types/poly_types/substitution.rs\n@@ -41,14 +47,25 @@ pub(crate) fn substitute(\n \t\t\tcurry_arguments(arguments, types, id)\n \t\t}\n \t\tType::FunctionReference(f, t) => curry_arguments(arguments, types, id),\n-\t\tType::Constant(_)\n-\t\t| Type::AliasTo { .. }\n-\t\t| Type::And(_, _)\n-\t\t| Type::Or(_, _)\n-\t\t| Type::Interface { .. } => id,\n+\t\tType::And(lhs, rhs) => {\n+\t\t\tlet rhs = *rhs;\n+\t\t\tlet lhs = substitute(*lhs, arguments, environment, types);\n+\t\t\tlet rhs = substitute(rhs, arguments, environment, types);\n+\t\t\ttypes.register_type(Type::And(lhs, rhs))\n+\t\t}\n+\t\tType::Or(lhs, rhs) => {\n+\t\t\tlet rhs = *rhs;\n+\t\t\tlet lhs = substitute(*lhs, arguments, environment, types);\n+\t\t\tlet rhs = substitute(rhs, arguments, environment, types);\n+\t\t\ttypes.register_type(Type::Or(lhs, rhs))\n+\t\t}\n+\t\tType::Constant(_) | Type::AliasTo { .. } | Type::Interface { .. } => id,\n \t\tType::RootPolyType(nature) => {\n \t\t\tif let PolyNature::Open(_) = nature {\n \t\t\t\tid\n+\t\t\t} else if let PolyNature::Generic { .. } = nature {\n+\t\t\t\tcrate::utils::notify!(\"Could not find argument generic\");\n+\t\t\t\tid\n \t\t\t} else {\n \t\t\t\t// Other root poly types cases handled by the early return\n \t\t\t\tlet on = crate::types::printing::print_type(\ndiff --git a/checker/src/types/poly_types/substitution.rs b/checker/src/types/poly_types/substitution.rs\n--- a/checker/src/types/poly_types/substitution.rs\n+++ b/checker/src/types/poly_types/substitution.rs\n@@ -58,7 +75,7 @@ pub(crate) fn substitute(\n \t\t\t\t\ttrue,\n \t\t\t\t);\n \t\t\t\tcrate::utils::notify!(\"Could not find argument for {}\", on);\n-\t\t\t\tid\n+\t\t\t\tTypeId::ERROR_TYPE\n \t\t\t}\n \t\t}\n \ndiff --git a/checker/src/types/poly_types/substitution.rs b/checker/src/types/poly_types/substitution.rs\n--- a/checker/src/types/poly_types/substitution.rs\n+++ b/checker/src/types/poly_types/substitution.rs\n@@ -68,20 +85,28 @@ pub(crate) fn substitute(\n \t\t\t\tlet lhs = substitute(lhs, arguments, environment, types);\n \t\t\t\tlet rhs = substitute(rhs, arguments, environment, types);\n \n-\t\t\t\tevaluate_mathematical_operation(lhs, operator, rhs, types, false)\n-\t\t\t\t\t.expect(\"restriction about binary operator failed\")\n+\t\t\t\tmatch evaluate_mathematical_operation(lhs, operator, rhs, types, false) {\n+\t\t\t\t\tOk(result) => result,\n+\t\t\t\t\tErr(()) => {\n+\t\t\t\t\t\tunreachable!(\n+\t\t\t\t\t\t\t\"Cannot {lhs:?} {operator:?} {rhs:?} (restriction or something failed)\"\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t\tConstructor::UnaryOperator { operand, operator, .. } => {\n-\t\t\t\ttodo!()\n-\t\t\t\t// evaluate_unary_operator(\n-\t\t\t\t// \toperator,\n-\t\t\t\t// \toperand,\n-\t\t\t\t// \tenvironment,\n-\t\t\t\t// \t// Restrictions should have been made ahead of time\n-\t\t\t\t// \tfalse,\n-\t\t\t\t// \ttypes,\n-\t\t\t\t// )\n-\t\t\t\t// .unwrap()\n+\t\t\t\tmatch evaluate_pure_unary_operator(\n+\t\t\t\t\toperator, operand, types,\n+\t\t\t\t\t// Restrictions should have been made ahead of time\n+\t\t\t\t\tfalse,\n+\t\t\t\t) {\n+\t\t\t\t\tOk(result) => result,\n+\t\t\t\t\tErr(()) => {\n+\t\t\t\t\t\tunreachable!(\n+\t\t\t\t\t\t\t\"Cannot {operand:?} {operator:?} (restriction or something failed)\"\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t\tConstructor::ConditionalResult {\n \t\t\t\tcondition,\ndiff --git a/checker/src/types/poly_types/substitution.rs b/checker/src/types/poly_types/substitution.rs\n--- a/checker/src/types/poly_types/substitution.rs\n+++ b/checker/src/types/poly_types/substitution.rs\n@@ -134,8 +159,51 @@ pub(crate) fn substitute(\n \t\t\t\t\ttypes.register_type(Type::Constructor(ty))\n \t\t\t\t}\n \t\t\t}\n-\t\t\tConstructor::Property { .. } | Constructor::FunctionResult { .. } => {\n-\t\t\t\tunreachable!(\"this should have covered by event specialisation\");\n+\t\t\tConstructor::Property { on, under, result } => {\n+\t\t\t\tlet id = get_constraint(on, types).unwrap_or(on);\n+\n+\t\t\t\tif let Type::Constructor(Constructor::StructureGenerics(StructureGenerics {\n+\t\t\t\t\ton: TypeId::ARRAY_TYPE,\n+\t\t\t\t\targuments,\n+\t\t\t\t})) = types.get_type_by_id(id)\n+\t\t\t\t{\n+\t\t\t\t\t// Try get the constant\n+\t\t\t\t\tif under.as_number().is_some() {\n+\t\t\t\t\t\tcrate::utils::notify!(\"Temp array index property get\");\n+\t\t\t\t\t\tlet value = arguments.get_argument(TypeId::T_TYPE).unwrap();\n+\t\t\t\t\t\ttypes.new_or_type(value, TypeId::UNDEFINED_TYPE)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tlet mut structure_generic_arguments = arguments.clone();\n+\t\t\t\t\t\tlet new_result = substitute(\n+\t\t\t\t\t\t\tresult,\n+\t\t\t\t\t\t\t// TODO\n+\t\t\t\t\t\t\t&mut structure_generic_arguments,\n+\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\tcrate::utils::notify!(\n+\t\t\t\t\t\t\t\"Specialising the constraint {:?} to {:?} using {:?} (which is strange)\",\n+\t\t\t\t\t\t\tresult,\n+\t\t\t\t\t\t\tnew_result,\n+\t\t\t\t\t\t\tstructure_generic_arguments\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\ttypes.register_type(Type::Constructor(Constructor::Property {\n+\t\t\t\t\t\t\ton,\n+\t\t\t\t\t\t\tunder,\n+\t\t\t\t\t\t\tresult: new_result,\n+\t\t\t\t\t\t}))\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\ttodo!(\n+\t\t\t\t\t\t\"Constructor::Property ({:?}[{:?}]) should be covered by events\",\n+\t\t\t\t\t\ton,\n+\t\t\t\t\t\tunder\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tConstructor::Image { .. } => {\n+\t\t\t\ttodo!(\"Constructor::Image should be covered by events\");\n+\t\t\t\t// id\n \n \t\t\t\t// let on = substitute(on, arguments, environment);\n \ndiff --git a/checker/src/types/poly_types/substitution.rs b/checker/src/types/poly_types/substitution.rs\n--- a/checker/src/types/poly_types/substitution.rs\n+++ b/checker/src/types/poly_types/substitution.rs\n@@ -210,8 +278,14 @@ pub(crate) fn substitute(\n \t\t\t\tlet lhs = substitute(lhs, arguments, environment, types);\n \t\t\t\tlet rhs = substitute(rhs, arguments, environment, types);\n \n-\t\t\t\tevaluate_equality_inequality_operation(lhs, &operator, rhs, types, false)\n-\t\t\t\t\t.expect(\"restriction about binary operator failed\")\n+\t\t\t\tmatch evaluate_equality_inequality_operation(lhs, &operator, rhs, types, false) {\n+\t\t\t\t\tOk(result) => result,\n+\t\t\t\t\tErr(()) => {\n+\t\t\t\t\t\tunreachable!(\n+\t\t\t\t\t\t\t\"Cannot {lhs:?} {operator:?} {rhs:?} (restriction or something failed)\"\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t}\n \t\t\tConstructor::TypeOperator(..) => todo!(),\n \t\t\tConstructor::TypeRelationOperator(op) => match op {\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -1,27 +1,43 @@\n use iterator_endiate::EndiateIteratorExt;\n-use std::collections::HashSet;\n+use std::{\n+\tcollections::{HashMap, HashSet},\n+\tfmt::Write,\n+};\n \n-use super::{properties::PropertyKey, PolyNature, Type, TypeId, TypeStore};\n+use super::{properties::PropertyKey, PolyNature, Type, TypeArguments, TypeId, TypeStore};\n use crate::{\n-\tcontext::{facts::Publicity, get_on_ctx},\n-\ttypes::{Constructor, StructureGenerics},\n-\tConstant, GeneralContext,\n+\tcontext::{facts::Publicity, get_on_ctx, Logical},\n+\tevents::Event,\n+\ttypes::{get_constraint, Constructor, StructureGenerics},\n+\tConstant, GeneralContext, PropertyValue,\n };\n \n-/// TODO temp, needs recursion safe, reuse buffer\n-\n #[must_use]\n pub fn print_type(id: TypeId, types: &TypeStore, ctx: &GeneralContext, debug: bool) -> String {\n \tlet mut buf = String::new();\n-\tprint_type_into_buf(id, &mut buf, &mut HashSet::new(), types, ctx, debug);\n+\tprint_type_into_buf(id, &mut buf, &mut HashSet::new(), None, types, ctx, debug);\n+\tbuf\n+}\n \n+#[must_use]\n+pub fn print_type_with_generics(\n+\tid: TypeId,\n+\ttype_arguments: Option<&TypeArguments>,\n+\ttypes: &TypeStore,\n+\tctx: &GeneralContext,\n+\tdebug: bool,\n+) -> String {\n+\tlet mut buf = String::new();\n+\tprint_type_into_buf(id, &mut buf, &mut HashSet::new(), type_arguments, types, ctx, debug);\n \tbuf\n }\n \n+/// Recursion safe + reuses buffer\n fn print_type_into_buf(\n \tid: TypeId,\n \tbuf: &mut String,\n \tcycles: &mut HashSet<TypeId>,\n+\targs: Option<&TypeArguments>,\n \ttypes: &TypeStore,\n \tctx: &GeneralContext,\n \tdebug: bool,\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -30,7 +46,7 @@ fn print_type_into_buf(\n \n \tlet not_in_cycle = cycles.insert(id);\n \tif !not_in_cycle {\n-\t\tbuf.push_str(\"cyclic\");\n+\t\tbuf.push_str(\"*cycle*\");\n \t\treturn;\n \t}\n \ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -40,21 +56,23 @@ fn print_type_into_buf(\n \t\t\tbuf.push_str(name);\n \t\t}\n \t\tType::And(a, b) => {\n-\t\t\tprint_type_into_buf(*a, buf, cycles, types, ctx, debug);\n+\t\t\tprint_type_into_buf(*a, buf, cycles, args, types, ctx, debug);\n \t\t\tbuf.push_str(\" & \");\n-\t\t\tprint_type_into_buf(*b, buf, cycles, types, ctx, debug);\n+\t\t\tprint_type_into_buf(*b, buf, cycles, args, types, ctx, debug);\n \t\t}\n \t\tType::Or(a, b) => {\n-\t\t\tprint_type_into_buf(*a, buf, cycles, types, ctx, debug);\n+\t\t\tprint_type_into_buf(*a, buf, cycles, args, types, ctx, debug);\n \t\t\tbuf.push_str(\" | \");\n-\t\t\tprint_type_into_buf(*b, buf, cycles, types, ctx, debug);\n+\t\t\tprint_type_into_buf(*b, buf, cycles, args, types, ctx, debug);\n \t\t}\n \t\tType::RootPolyType(nature) => match nature {\n \t\t\tPolyNature::Generic { name, eager_fixed } => {\n-\t\t\t\tif debug {\n+\t\t\t\tif let Some(value) = args.and_then(|a| a.get(&id).map(|(t, _)| *t)) {\n+\t\t\t\t\tprint_type_into_buf(value, buf, cycles, args, types, ctx, debug);\n+\t\t\t\t} else if debug {\n \t\t\t\t\t// TODO restriction\n \t\t\t\t\twrite!(buf, \"[generic {} {}, fixed to \", name, id.0).unwrap();\n-\t\t\t\t\tprint_type_into_buf(*eager_fixed, buf, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_type_into_buf(*eager_fixed, buf, cycles, args, types, ctx, debug);\n \t\t\t\t\tbuf.push(']');\n \t\t\t\t} else {\n \t\t\t\t\tbuf.push_str(name);\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -64,21 +82,21 @@ fn print_type_into_buf(\n \t\t\t\tif debug {\n \t\t\t\t\tlet name = reference.get_name(ctx);\n \t\t\t\t\t// FV = free variable\n-\t\t\t\t\twrite!(buf, \"[FV {} {}]\", name, id.0).unwrap();\n+\t\t\t\t\twrite!(buf, \"[FV '{}' {}] fixed to \", name, id.0).unwrap();\n \t\t\t\t}\n-\t\t\t\tprint_type_into_buf(*to, buf, cycles, types, ctx, debug);\n+\t\t\t\tprint_type_into_buf(*to, buf, cycles, args, types, ctx, debug);\n \t\t\t}\n \t\t\tPolyNature::Parameter { fixed_to: to } => {\n \t\t\t\tif debug {\n-\t\t\t\t\twrite!(buf, \"[param {}]\", id.0).unwrap();\n+\t\t\t\t\twrite!(buf, \"[param {}] fixed to \", id.0).unwrap();\n \t\t\t\t}\n-\t\t\t\tprint_type_into_buf(*to, buf, cycles, types, ctx, debug);\n+\t\t\t\tprint_type_into_buf(*to, buf, cycles, args, types, ctx, debug);\n \t\t\t}\n \t\t\tPolyNature::Open(to) => {\n \t\t\t\tif debug {\n-\t\t\t\t\twrite!(buf, \"[open {}]\", id.0).unwrap();\n+\t\t\t\t\twrite!(buf, \"[open {}] \", id.0).unwrap();\n \t\t\t\t}\n-\t\t\t\tprint_type_into_buf(*to, buf, cycles, types, ctx, debug);\n+\t\t\t\tprint_type_into_buf(*to, buf, cycles, args, types, ctx, debug);\n \t\t\t}\n \t\t\tPolyNature::RecursiveFunction(_, _) => {\n \t\t\t\ttodo!()\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -100,20 +118,20 @@ fn print_type_into_buf(\n \t\t\t} => {\n \t\t\t\tif debug {\n \t\t\t\t\twrite!(buf, \"[? {id:? }\").unwrap();\n-\t\t\t\t\tprint_type_into_buf(*condition, buf, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_type_into_buf(*condition, buf, cycles, args, types, ctx, debug);\n \t\t\t\t\tbuf.push(']');\n \t\t\t\t}\n-\t\t\t\tprint_type_into_buf(*truthy_result, buf, cycles, types, ctx, debug);\n+\t\t\t\tprint_type_into_buf(*truthy_result, buf, cycles, args, types, ctx, debug);\n \t\t\t\tbuf.push_str(if debug { \" : \" } else { \" | \" });\n-\t\t\t\tprint_type_into_buf(*else_result, buf, cycles, types, ctx, debug);\n+\t\t\t\tprint_type_into_buf(*else_result, buf, cycles, args, types, ctx, debug);\n \t\t\t}\n \t\t\tConstructor::StructureGenerics(StructureGenerics { on, arguments }) => {\n \t\t\t\tif debug {\n \t\t\t\t\tbuf.push_str(\"SG (\");\n-\t\t\t\t\tprint_type_into_buf(*on, buf, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_type_into_buf(*on, buf, cycles, args, types, ctx, debug);\n \t\t\t\t\tbuf.push(')');\n \t\t\t\t} else {\n-\t\t\t\t\tprint_type_into_buf(*on, buf, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_type_into_buf(*on, buf, cycles, args, types, ctx, debug);\n \t\t\t\t}\n \t\t\t\tif debug && !arguments.closures.is_empty() {\n \t\t\t\t\twrite!(buf, \" [closures {:?}]\", arguments.closures).unwrap();\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -126,7 +144,7 @@ fn print_type_into_buf(\n \t\t\t\t\t// TODO might be out of order ...\n \t\t\t\t\tbuf.push('<');\n \t\t\t\t\tfor (not_at_end, (arg, _)) in arguments.type_arguments.values().nendiate() {\n-\t\t\t\t\t\tprint_type_into_buf(*arg, buf, cycles, types, ctx, debug);\n+\t\t\t\t\t\tprint_type_into_buf(*arg, buf, cycles, args, types, ctx, debug);\n \t\t\t\t\t\tif not_at_end {\n \t\t\t\t\t\t\tbuf.push_str(\", \");\n \t\t\t\t\t\t}\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -136,34 +154,34 @@ fn print_type_into_buf(\n \t\t\t}\n \t\t\tconstructor if debug => match constructor {\n \t\t\t\tConstructor::BinaryOperator { lhs, operator, rhs } => {\n-\t\t\t\t\tprint_type_into_buf(*lhs, buf, cycles, types, ctx, debug);\n-\t\t\t\t\tbuf.push_str(\" + \");\n-\t\t\t\t\tprint_type_into_buf(*rhs, buf, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_type_into_buf(*lhs, buf, cycles, args, types, ctx, debug);\n+\t\t\t\t\tbuf.write_fmt(format_args!(\" {operator:?} \")).unwrap();\n+\t\t\t\t\tprint_type_into_buf(*rhs, buf, cycles, args, types, ctx, debug);\n \t\t\t\t}\n \t\t\t\tConstructor::CanonicalRelationOperator { lhs, operator, rhs } => {\n-\t\t\t\t\tprint_type_into_buf(*lhs, buf, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_type_into_buf(*lhs, buf, cycles, args, types, ctx, debug);\n \t\t\t\t\tmatch operator {\n \t\t\t\t\t\t\tcrate::behavior::operations::CanonicalEqualityAndInequality::StrictEqual => {\n \t\t\t\t\t\t\t\tbuf.push_str(\" === \");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcrate::behavior::operations::CanonicalEqualityAndInequality::LessThan => {\n-\t\t\t\t\t\t\t\tbuf.push_str(\" > \");\n+\t\t\t\t\t\t\t\tbuf.push_str(\" < \");\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n-\t\t\t\t\tprint_type_into_buf(*rhs, buf, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_type_into_buf(*rhs, buf, cycles, args, types, ctx, debug);\n \t\t\t\t}\n \t\t\t\tConstructor::UnaryOperator { operator, operand } => todo!(),\n \t\t\t\tConstructor::TypeOperator(_) => todo!(),\n \t\t\t\tConstructor::TypeRelationOperator(_) => todo!(),\n-\t\t\t\tConstructor::FunctionResult { on, with, result } => {\n+\t\t\t\tConstructor::Image { on, with, result } => {\n \t\t\t\t\t// TODO arguments and stuff\n \t\t\t\t\tbuf.push_str(\"[func result] \");\n-\t\t\t\t\tprint_type_into_buf(*result, buf, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_type_into_buf(*result, buf, cycles, args, types, ctx, debug);\n \t\t\t\t}\n \t\t\t\tConstructor::Property { on, under, result: _ } => {\n-\t\t\t\t\tprint_type_into_buf(*on, buf, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_type_into_buf(*on, buf, cycles, args, types, ctx, debug);\n \t\t\t\t\tbuf.push('[');\n-\t\t\t\t\tprint_property_key_into_buf(buf, under, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_property_key_into_buf(buf, under, cycles, args, types, ctx, debug);\n \t\t\t\t\tbuf.push(']');\n \t\t\t\t}\n \t\t\t\tConstructor::StructureGenerics { .. } | Constructor::ConditionalResult { .. } => {\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -172,7 +190,7 @@ fn print_type_into_buf(\n \t\t\t},\n \t\t\tConstructor::Property { on, under, result } => {\n \t\t\t\tif crate::types::is_explicit_generic(*on, types) {\n-\t\t\t\t\tprint_type_into_buf(*on, buf, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_type_into_buf(*on, buf, cycles, args, types, ctx, debug);\n \t\t\t\t\tbuf.push('[');\n \t\t\t\t\tmatch under {\n \t\t\t\t\t\tPropertyKey::String(s) => {\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -181,43 +199,29 @@ fn print_type_into_buf(\n \t\t\t\t\t\t\tbuf.push('\"');\n \t\t\t\t\t\t}\n \t\t\t\t\t\tPropertyKey::Type(t) => {\n-\t\t\t\t\t\t\tprint_type_into_buf(*t, buf, cycles, types, ctx, debug);\n+\t\t\t\t\t\t\tprint_type_into_buf(*t, buf, cycles, args, types, ctx, debug);\n \t\t\t\t\t\t}\n \t\t\t\t\t};\n \t\t\t\t\tbuf.push(']');\n \t\t\t\t} else {\n-\t\t\t\t\tprint_type_into_buf(*result, buf, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_type_into_buf(*result, buf, cycles, args, types, ctx, debug);\n \t\t\t\t}\n \t\t\t}\n \t\t\tconstructor => {\n-\t\t\t\tlet base = get_on_ctx!(ctx.get_poly_base(id, types)).unwrap();\n-\t\t\t\tprint_type_into_buf(base, buf, cycles, types, ctx, debug);\n+\t\t\t\tlet base = get_constraint(id, types).unwrap();\n+\t\t\t\tprint_type_into_buf(base, buf, cycles, args, types, ctx, debug);\n \t\t\t}\n \t\t},\n \t\tType::Interface { name, parameters, nominal } => {\n-\t\t\tif debug {\n+\t\t\tif debug && id.0 as usize > TypeId::INTERNAL_TYPE_COUNT {\n \t\t\t\twrite!(buf, \"(r{} nom={:?}) {name}\", id.0, nominal).unwrap();\n-\t\t\t// buf.push_str(\"{ \");\n-\t\t\t// let properties = get_on_ctx!(ctx.get_properties_on_type(id));\n-\t\t\t// for (not_at_end, (publicity, key, value)) in properties.into_iter().nendiate() {\n-\t\t\t// \tif let PublicityKind::Private = publicity {\n-\t\t\t// \t\tbuf.push('#');\n-\t\t\t// \t}\n-\t\t\t// \tprint_property_key_into_buf(buf, &key, cycles, types, ctx, debug);\n-\t\t\t// \tbuf.push_str(\": \");\n-\t\t\t// \tprint_type_into_buf(value, buf, cycles, types, ctx, debug);\n-\t\t\t// \tif not_at_end {\n-\t\t\t// \t\tbuf.push_str(\", \");\n-\t\t\t// \t}\n-\t\t\t// }\n-\t\t\t// buf.push_str(\" }\")\n \t\t\t} else {\n \t\t\t\tbuf.push_str(name);\n \t\t\t}\n \t\t\tif let (true, Some(parameters)) = (debug, parameters) {\n \t\t\t\tbuf.push('<');\n \t\t\t\tfor param in parameters {\n-\t\t\t\t\tprint_type_into_buf(*param, buf, cycles, types, ctx, debug);\n+\t\t\t\t\tprint_type_into_buf(*param, buf, cycles, args, types, ctx, debug);\n \t\t\t\t\tbuf.push_str(\", \");\n \t\t\t\t}\n \t\t\t\tbuf.push('>');\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -235,7 +239,7 @@ fn print_type_into_buf(\n \t\t\tif debug {\n \t\t\t\twrite!(\n \t\t\t\t\tbuf,\n-\t\t\t\t\t\"[t{} func, fvs {:?}, co {:?}, this {:?}, const {:?}] \",\n+\t\t\t\t\t\"[FR #{} func, fvs {:?}, co {:?}, this {:?}, const {:?}] \",\n \t\t\t\t\tid.0,\n \t\t\t\t\tfunc.free_variables,\n \t\t\t\t\tfunc.closed_over_variables,\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -267,21 +271,41 @@ fn print_type_into_buf(\n \t\t\tfor (not_at_end, param) in func.parameters.parameters.iter().nendiate() {\n \t\t\t\tbuf.push_str(&param.name);\n \t\t\t\tbuf.push_str(\": \");\n-\t\t\t\tprint_type_into_buf(param.ty, buf, cycles, types, ctx, debug);\n+\t\t\t\tprint_type_into_buf(param.ty, buf, cycles, args, types, ctx, debug);\n \t\t\t\tif not_at_end {\n \t\t\t\t\tbuf.push_str(\", \");\n \t\t\t\t}\n \t\t\t}\n \t\t\tbuf.push_str(\") => \");\n-\t\t\tprint_type_into_buf(func.return_type, buf, cycles, types, ctx, debug);\n+\t\t\tprint_type_into_buf(func.return_type, buf, cycles, args, types, ctx, debug);\n \t\t}\n \t\tType::Object(..) => {\n \t\t\tif debug {\n \t\t\t\twrite!(buf, \"[obj {}]\", id.0).unwrap();\n \t\t\t}\n \t\t\tif let Some(prototype) = get_on_ctx!(ctx.facts.prototypes.get(&id)) {\n+\t\t\t\tif *prototype == TypeId::ARRAY_TYPE && !debug {\n+\t\t\t\t\tif let Some(n) = get_array_length(ctx, id, types) {\n+\t\t\t\t\t\tbuf.push('[');\n+\t\t\t\t\t\tfor i in 0..(n.into_inner() as usize) {\n+\t\t\t\t\t\t\tif i != 0 {\n+\t\t\t\t\t\t\t\tbuf.push_str(\", \");\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tlet value =\n+\t\t\t\t\t\t\t\tget_simple_value(ctx, id, PropertyKey::from_usize(i), types)\n+\t\t\t\t\t\t\t\t\t.expect(\"Trying to print complex array type\");\n+\t\t\t\t\t\t\tprint_type_into_buf(value, buf, cycles, args, types, ctx, debug);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbuf.push(']');\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// TODO get property\n+\t\t\t\t\t\twrite!(buf, \"Array\").unwrap();\n+\t\t\t\t\t}\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\n \t\t\t\tbuf.push('[');\n-\t\t\t\tprint_type_into_buf(*prototype, buf, cycles, types, ctx, debug);\n+\t\t\t\tprint_type_into_buf(*prototype, buf, cycles, args, types, ctx, debug);\n \t\t\t\tbuf.push_str(\"] \");\n \t\t\t}\n \t\t\tbuf.push_str(\"{ \");\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -290,9 +314,9 @@ fn print_type_into_buf(\n \t\t\t\tif let Publicity::Private = publicity {\n \t\t\t\t\tbuf.push('#');\n \t\t\t\t}\n-\t\t\t\tprint_property_key_into_buf(buf, &key, cycles, types, ctx, debug);\n+\t\t\t\tprint_property_key_into_buf(buf, &key, cycles, args, types, ctx, debug);\n \t\t\t\tbuf.push_str(\": \");\n-\t\t\t\tprint_type_into_buf(value, buf, cycles, types, ctx, debug);\n+\t\t\t\tprint_type_into_buf(value, buf, cycles, args, types, ctx, debug);\n \t\t\t\tif not_at_end {\n \t\t\t\t\tbuf.push_str(\", \");\n \t\t\t\t}\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -305,9 +329,9 @@ fn print_type_into_buf(\n \t\t\tcrate::behavior::objects::SpecialObjects::Proxy { handler, over } => {\n \t\t\t\t// Copies from node behavior\n \t\t\t\tbuf.push_str(\"Proxy [ \");\n-\t\t\t\tprint_type_into_buf(*over, buf, cycles, types, ctx, debug);\n+\t\t\t\tprint_type_into_buf(*over, buf, cycles, args, types, ctx, debug);\n \t\t\t\tbuf.push_str(\", \");\n-\t\t\t\tprint_type_into_buf(*handler, buf, cycles, types, ctx, debug);\n+\t\t\t\tprint_type_into_buf(*handler, buf, cycles, args, types, ctx, debug);\n \t\t\t\tbuf.push_str(\" ]\");\n \t\t\t}\n \t\t\tcrate::behavior::objects::SpecialObjects::Import(exports) => {\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -319,7 +343,7 @@ fn print_type_into_buf(\n \t\t\t\t\t\tcrate::behavior::variables::VariableMutability::Constant => {\n \t\t\t\t\t\t\tlet value =\n \t\t\t\t\t\t\t\tget_on_ctx!(ctx.get_value_of_constant_import_variable(*variable));\n-\t\t\t\t\t\t\tprint_type_into_buf(value, buf, cycles, types, ctx, debug);\n+\t\t\t\t\t\t\tprint_type_into_buf(value, buf, cycles, args, types, ctx, debug);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tcrate::behavior::variables::VariableMutability::Mutable {\n \t\t\t\t\t\t\treassignment_constraint,\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -337,6 +361,39 @@ fn print_type_into_buf(\n \tcycles.remove(&id);\n }\n \n+fn get_simple_value(\n+\tctx: &GeneralContext,\n+\ton: TypeId,\n+\tproperty: PropertyKey,\n+\ttypes: &TypeStore,\n+) -> Option<TypeId> {\n+\tget_on_ctx!(ctx.get_property_unbound(on, Publicity::Public, property, types)).and_then(|v| {\n+\t\tif let Logical::Pure(PropertyValue::Value(t)) = v {\n+\t\t\tSome(t)\n+\t\t} else {\n+\t\t\tNone\n+\t\t}\n+\t})\n+}\n+\n+fn get_array_length(\n+\tctx: &GeneralContext,\n+\ton: TypeId,\n+\ttypes: &TypeStore,\n+) -> Option<ordered_float::NotNan<f64>> {\n+\tlet id = get_simple_value(\n+\t\tctx,\n+\t\ton,\n+\t\tPropertyKey::String(std::borrow::Cow::Borrowed(\"length\")),\n+\t\ttypes,\n+\t)?;\n+\tif let Type::Constant(Constant::Number(n)) = types.get_type_by_id(id) {\n+\t\tSome(*n)\n+\t} else {\n+\t\tNone\n+\t}\n+}\n+\n #[must_use]\n pub fn print_property_key(\n \tkey: &PropertyKey,\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -345,7 +402,7 @@ pub fn print_property_key(\n \tdebug: bool,\n ) -> String {\n \tlet mut string = String::new();\n-\tprint_property_key_into_buf(&mut string, key, &mut HashSet::new(), types, ctx, debug);\n+\tprint_property_key_into_buf(&mut string, key, &mut HashSet::new(), None, types, ctx, debug);\n \tstring\n }\n \ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -353,12 +410,157 @@ pub(crate) fn print_property_key_into_buf(\n \tbuf: &mut String,\n \tkey: &PropertyKey,\n \tcycles: &mut HashSet<TypeId>,\n+\targs: Option<&TypeArguments>,\n \ttypes: &TypeStore,\n \tctx: &GeneralContext,\n \tdebug: bool,\n ) {\n \tmatch key {\n \t\tPropertyKey::String(s) => buf.push_str(s),\n-\t\tPropertyKey::Type(t) => print_type_into_buf(*t, buf, cycles, types, ctx, debug),\n+\t\tPropertyKey::Type(t) => {\n+\t\t\tbuf.push('[');\n+\t\t\tprint_type_into_buf(*t, buf, cycles, args, types, ctx, debug);\n+\t\t\tbuf.push(']');\n+\t\t}\n+\t}\n+}\n+\n+pub fn debug_effects(\n+\tmut buf: &mut String,\n+\tevents: &[Event],\n+\ttypes: &TypeStore,\n+\tctx: &GeneralContext,\n+\tdebug: bool,\n+) {\n+\tfor event in events {\n+\t\tmatch event {\n+\t\t\tEvent::ReadsReference { reference, reflects_dependency, position } => {\n+\t\t\t\tlet name = reference.get_name(ctx);\n+\t\t\t\tbuf.write_fmt(format_args!(\"read '{name}' into {reflects_dependency:?}\")).unwrap();\n+\t\t\t}\n+\t\t\tEvent::SetsVariable(variable, value, _) => {\n+\t\t\t\tlet on = get_on_ctx!(ctx.get_variable_name(*variable));\n+\t\t\t\tbuf.push_str(on);\n+\t\t\t\tbuf.push_str(\" = \");\n+\t\t\t\tprint_type_into_buf(*value, buf, &mut HashSet::new(), None, types, ctx, debug);\n+\t\t\t}\n+\t\t\tEvent::Getter { on, under, reflects_dependency, publicity, position } => {\n+\t\t\t\tbuf.push_str(\"read \");\n+\t\t\t\tprint_type_into_buf(*on, buf, &mut HashSet::new(), None, types, ctx, debug);\n+\t\t\t\tif let PropertyKey::String(_) = under {\n+\t\t\t\t\tbuf.push('.');\n+\t\t\t\t}\n+\t\t\t\tprint_property_key_into_buf(\n+\t\t\t\t\tbuf,\n+\t\t\t\t\tunder,\n+\t\t\t\t\t&mut HashSet::new(),\n+\t\t\t\t\tNone,\n+\t\t\t\t\ttypes,\n+\t\t\t\t\tctx,\n+\t\t\t\t\tdebug,\n+\t\t\t\t);\n+\t\t\t\tbuf.write_fmt(format_args!(\" into {reflects_dependency:?}\")).unwrap();\n+\t\t\t}\n+\t\t\tEvent::Setter { on, under, new, initialization, publicity, position } => {\n+\t\t\t\tif *initialization {\n+\t\t\t\t\tbuf.write_fmt(format_args!(\"initialise {:?} with \", *on)).unwrap();\n+\t\t\t\t\tif let PropertyValue::Value(new) = new {\n+\t\t\t\t\t\tprint_type_into_buf(\n+\t\t\t\t\t\t\t*new,\n+\t\t\t\t\t\t\tbuf,\n+\t\t\t\t\t\t\t&mut HashSet::new(),\n+\t\t\t\t\t\t\tNone,\n+\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\tctx,\n+\t\t\t\t\t\t\tdebug,\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tprint_type_into_buf(*on, buf, &mut HashSet::new(), None, types, ctx, debug);\n+\t\t\t\t\tbuf.push('[');\n+\t\t\t\t\tprint_property_key_into_buf(\n+\t\t\t\t\t\tbuf,\n+\t\t\t\t\t\tunder,\n+\t\t\t\t\t\t&mut HashSet::default(),\n+\t\t\t\t\t\tNone,\n+\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\tctx,\n+\t\t\t\t\t\tdebug,\n+\t\t\t\t\t);\n+\t\t\t\t\tbuf.push_str(\"] = \");\n+\t\t\t\t\tif let PropertyValue::Value(new) = new {\n+\t\t\t\t\t\tprint_type_into_buf(\n+\t\t\t\t\t\t\t*new,\n+\t\t\t\t\t\t\tbuf,\n+\t\t\t\t\t\t\t&mut HashSet::new(),\n+\t\t\t\t\t\t\tNone,\n+\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\tctx,\n+\t\t\t\t\t\t\tdebug,\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tEvent::CallsType {\n+\t\t\t\ton,\n+\t\t\t\twith,\n+\t\t\t\treflects_dependency,\n+\t\t\t\ttiming,\n+\t\t\t\tcalled_with_new,\n+\t\t\t\tposition,\n+\t\t\t} => {\n+\t\t\t\tbuf.push_str(\"call \");\n+\t\t\t\tprint_type_into_buf(*on, buf, &mut HashSet::new(), None, types, ctx, debug);\n+\t\t\t\tbuf.push_str(match timing {\n+\t\t\t\t\tcrate::events::CallingTiming::Synchronous => \"now\",\n+\t\t\t\t\tcrate::events::CallingTiming::QueueTask => \"queue\",\n+\t\t\t\t\tcrate::events::CallingTiming::AtSomePointManyTimes => \"sometime\",\n+\t\t\t\t});\n+\t\t\t\t// TODO args\n+\t\t\t}\n+\t\t\tEvent::Throw(value, _) => {\n+\t\t\t\tbuf.push_str(\"throw \");\n+\t\t\t\tprint_type_into_buf(*value, buf, &mut HashSet::new(), None, types, ctx, debug);\n+\t\t\t}\n+\t\t\tEvent::Conditionally { condition, events_if_truthy, else_events, position } => {\n+\t\t\t\tbuf.push_str(\"if \");\n+\t\t\t\tprint_type_into_buf(*condition, buf, &mut HashSet::new(), None, types, ctx, debug);\n+\t\t\t\tbuf.push_str(\" then \");\n+\t\t\t\tdebug_effects(buf, events_if_truthy, types, ctx, debug);\n+\t\t\t\tif !else_events.is_empty() {\n+\t\t\t\t\tbuf.push_str(\" else \");\n+\t\t\t\t\tdebug_effects(buf, else_events, types, ctx, debug);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tEvent::Return { returned, returned_position } => {\n+\t\t\t\tbuf.push_str(\"return \");\n+\t\t\t\tprint_type_into_buf(*returned, buf, &mut HashSet::new(), None, types, ctx, debug);\n+\t\t\t}\n+\t\t\tEvent::CreateObject {\n+\t\t\t\tprototype,\n+\t\t\t\treferenced_in_scope_as,\n+\t\t\t\tposition,\n+\t\t\t\tis_function_this,\n+\t\t\t} => {\n+\t\t\t\tif *is_function_this {\n+\t\t\t\t\tbuf.write_fmt(format_args!(\"create this function object\")).unwrap();\n+\t\t\t\t} else {\n+\t\t\t\t\tbuf.write_fmt(format_args!(\"create object as {referenced_in_scope_as:?}\"))\n+\t\t\t\t\t\t.unwrap();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tEvent::Break { .. } => {\n+\t\t\t\tbuf.push_str(\"break\");\n+\t\t\t}\n+\t\t\tEvent::Continue { .. } => {\n+\t\t\t\tbuf.push_str(\"continue\");\n+\t\t\t}\n+\t\t\tEvent::Iterate { iterate_over, initial: _, kind } => {\n+\t\t\t\tbuf.push_str(\"iterate\\n\");\n+\t\t\t\tdebug_effects(buf, iterate_over, types, ctx, debug);\n+\t\t\t\tbuf.push_str(\"end\");\n+\t\t\t}\n+\t\t}\n+\t\tbuf.push('\\n');\n \t}\n }\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -2,11 +2,14 @@ use std::borrow::Cow;\n \n use crate::{\n \tbehavior::functions::ThisValue,\n-\tcontext::{facts::Publicity, CallCheckingBehavior, Logical, SetPropertyError},\n+\tcontext::{environment, facts::Publicity, CallCheckingBehavior, Logical, SetPropertyError},\n+\tdiagnostics::TypeStringRepresentation,\n \tevents::Event,\n-\tsubtyping::{type_is_subtype, SubTypeResult},\n+\tsubtyping::{type_is_subtype, type_is_subtype_of_property, SubTypeResult},\n \ttypes::{\n-\t\tcalling::CallingInput, printing::print_type, substitute, FunctionType, StructureGenerics,\n+\t\tcalling::CallingInput, get_constraint,\n+\t\tpoly_types::generic_type_arguments::StructureGenericArguments, printing::print_type,\n+\t\tsubstitute, FunctionType, ObjectNature, StructureGenerics,\n \t},\n \tConstant, Environment, TypeId,\n };\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -60,6 +63,14 @@ impl<'a> PropertyKey<'a> {\n \t\t\tPropertyKey::Type(ty)\n \t\t}\n \t}\n+\n+\tpub(crate) fn as_number(&self) -> Option<usize> {\n+\t\tmatch self {\n+\t\t\tPropertyKey::String(s) => s.parse::<usize>().ok(),\n+\t\t\t// TODO\n+\t\t\tPropertyKey::Type(_) => None,\n+\t\t}\n+\t}\n }\n \n impl crate::serialization::BinarySerializable for PropertyKey<'static> {\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -133,7 +144,7 @@ pub(crate) fn get_property<E: CallCheckingBehavior>(\n \tpublicity: Publicity,\n \tunder: PropertyKey,\n \twith: Option<TypeId>,\n-\tenvironment: &mut Environment,\n+\ttop_environment: &mut Environment,\n \tbehavior: &mut E,\n \ttypes: &mut TypeStore,\n \tposition: SpanWithSource,\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -144,19 +155,41 @@ pub(crate) fn get_property<E: CallCheckingBehavior>(\n \t\tFromAObject(TypeId),\n \t}\n \n-\t// || under == TypeId::ERROR_TYPE\n-\tif on == TypeId::ERROR_TYPE {\n+\tif on == TypeId::ERROR_TYPE\n+\t\t|| matches!(under, PropertyKey::Type(under) if under == TypeId::ERROR_TYPE)\n+\t{\n \t\treturn Some((PropertyKind::Direct, TypeId::ERROR_TYPE));\n \t}\n \n-\tlet value: GetResult = if let Some(constraint) = environment.get_poly_base(on, types) {\n+\t// TODO rearrange here\n+\n+\tlet value: GetResult = if let Some(constraint) = get_constraint(on, types) {\n+\t\tGetResult::AccessIntroducesDependence(evaluate_get_on_poly(\n+\t\t\tconstraint,\n+\t\t\ton,\n+\t\t\tpublicity,\n+\t\t\tunder.clone(),\n+\t\t\twith,\n+\t\t\ttop_environment,\n+\t\t\tbehavior,\n+\t\t\ttypes,\n+\t\t)?)\n+\t} else if top_environment.possibly_mutated_objects.contains(&on) {\n+\t\tlet items = top_environment.get_object_constraints(on);\n+\t\tlet constraint = if items.len() == 1 {\n+\t\t\titems.into_iter().next().unwrap()\n+\t\t} else if items.is_empty() {\n+\t\t\ttodo!(\"inference\")\n+\t\t} else {\n+\t\t\ttodo!(\"build and type\")\n+\t\t};\n \t\tGetResult::AccessIntroducesDependence(evaluate_get_on_poly(\n \t\t\tconstraint,\n \t\t\ton,\n \t\t\tpublicity,\n \t\t\tunder.clone(),\n \t\t\twith,\n-\t\t\tenvironment,\n+\t\t\ttop_environment,\n \t\t\tbehavior,\n \t\t\ttypes,\n \t\t)?)\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -165,7 +198,7 @@ pub(crate) fn get_property<E: CallCheckingBehavior>(\n \t\t// \ttodo!()\n \t\t// }\n \t\t// TODO\n-\t\treturn get_from_an_object(on, publicity, under, environment, behavior, types);\n+\t\treturn get_from_an_object(on, publicity, under, top_environment, behavior, types);\n \t};\n \n \tlet reflects_dependency = match value {\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -304,12 +337,23 @@ fn get_from_an_object<E: CallCheckingBehavior>(\n \t\t\tLogical::Implies { on: log_on, mut antecedent } => {\n \t\t\t\tlet (kind, ty) =\n \t\t\t\t\tresolve_property_on_logical(*log_on, types, on, environment, behavior)?;\n+\n+\t\t\t\tcrate::utils::notify!(\"Specialising implies\");\n \t\t\t\tlet ty = substitute(ty, &mut antecedent, environment, types);\n \t\t\t\tSome((kind, ty))\n \t\t\t}\n \t\t}\n \t}\n \n+\t// TODO explain what happens around non constant strings\n+\tif let Type::Constant(Constant::String(s)) = types.get_type_by_id(on) {\n+\t\tif let Some(n) = under.as_number() {\n+\t\t\treturn s.chars().nth(n).map(|s| {\n+\t\t\t\t(PropertyKind::Direct, types.new_constant_type(Constant::String(s.to_string())))\n+\t\t\t});\n+\t\t}\n+\t}\n+\n \tlet result = environment.get_property_unbound(on, publicity, under, types)?;\n \n \tresolve_property_on_logical(result, types, on, environment, behavior)\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -327,60 +371,85 @@ fn evaluate_get_on_poly<E: CallCheckingBehavior>(\n \tbehavior: &E,\n \ttypes: &mut TypeStore,\n ) -> Option<TypeId> {\n-\t// match constraint {\n-\t// \tPolyBase::Fixed { to, is_open_poly } => {\n-\t// crate::utils::notify!(\n-\t// \t\"Get property found fixed constraint {}, is_open_poly={:?}\",\n-\t// \tenvironment.debug_type(on, types),\n-\t// \tis_open_poly\n-\t// );\n-\n-\tfn get_property_from_logical(\n+\tfn resolve_logical_with_poly(\n \t\tfact: Logical<PropertyValue>,\n-\t\ttypes: &mut TypeStore,\n \t\ton: TypeId,\n \t\tunder: PropertyKey,\n+\t\t// TODO generic chain\n+\t\targuments: Option<&StructureGenericArguments>,\n+\t\tenvironment: &mut Environment,\n+\t\ttypes: &mut TypeStore,\n \t) -> Option<TypeId> {\n \t\tmatch fact {\n \t\t\tLogical::Pure(og) => {\n \t\t\t\tmatch og {\n-\t\t\t\t\tPropertyValue::Value(og) => {\n-\t\t\t\t\t\tmatch types.get_type_by_id(og) {\n+\t\t\t\t\tPropertyValue::Value(value) => {\n+\t\t\t\t\t\tmatch types.get_type_by_id(value) {\n \t\t\t\t\t\t\tType::FunctionReference(func, _) => {\n \t\t\t\t\t\t\t\t// TODO only want to do sometimes, or even never as it can be pulled using the poly chain\n \t\t\t\t\t\t\t\tlet depends_on_this =\n \t\t\t\t\t\t\t\t\ttypes.get_function_from_id(*func).behavior.can_be_bound();\n \n-\t\t\t\t\t\t\t\tif depends_on_this {\n-\t\t\t\t\t\t\t\t\tlet with_this = types.register_type(Type::Function(\n-\t\t\t\t\t\t\t\t\t\t*func,\n-\t\t\t\t\t\t\t\t\t\tThisValue::Passed(on),\n-\t\t\t\t\t\t\t\t\t));\n-\t\t\t\t\t\t\t\t\tSome(with_this)\n+\t\t\t\t\t\t\t\tlet result = if depends_on_this {\n+\t\t\t\t\t\t\t\t\ttypes\n+\t\t\t\t\t\t\t\t\t\t.register_type(Type::Function(*func, ThisValue::Passed(on)))\n \t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\tSome(og)\n+\t\t\t\t\t\t\t\t\tvalue\n+\t\t\t\t\t\t\t\t};\n+\n+\t\t\t\t\t\t\t\t// TODO wrap in constructor property\n+\t\t\t\t\t\t\t\tif let Some(arguments) = arguments {\n+\t\t\t\t\t\t\t\t\t// TODO not always..., func.inherits_generics maybe?\n+\t\t\t\t\t\t\t\t\tSome(types.register_type(Type::Constructor(\n+\t\t\t\t\t\t\t\t\t\tConstructor::StructureGenerics(StructureGenerics {\n+\t\t\t\t\t\t\t\t\t\t\ton: result,\n+\t\t\t\t\t\t\t\t\t\t\targuments: arguments.clone(),\n+\t\t\t\t\t\t\t\t\t\t}),\n+\t\t\t\t\t\t\t\t\t)))\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tSome(value)\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tType::Function(..) => todo!(),\n-\t\t\t\t\t\t\tType::And(_, _)\n-\t\t\t\t\t\t\t| Type::RootPolyType(_)\n-\t\t\t\t\t\t\t| Type::Constructor(_)\n+\t\t\t\t\t\t\tt @ (Type::And(_, _)\n \t\t\t\t\t\t\t| Type::Or(_, _)\n-\t\t\t\t\t\t\t| Type::AliasTo { .. }\n-\t\t\t\t\t\t\t| Type::Interface { .. } => {\n-\t\t\t\t\t\t\t\t// TODO this isn't necessary sometimes\n+\t\t\t\t\t\t\t| Type::RootPolyType(_)\n+\t\t\t\t\t\t\t| Type::Constructor(_)) => {\n+\t\t\t\t\t\t\t\tlet result = if let Some(arguments) = arguments {\n+\t\t\t\t\t\t\t\t\tsubstitute(\n+\t\t\t\t\t\t\t\t\t\tvalue,\n+\t\t\t\t\t\t\t\t\t\t&mut arguments.type_arguments.clone(),\n+\t\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tcrate::utils::notify!(\"Here, getting property on {:?}\", t);\n+\t\t\t\t\t\t\t\t\tvalue\n+\t\t\t\t\t\t\t\t};\n \t\t\t\t\t\t\t\tlet constructor_result =\n \t\t\t\t\t\t\t\t\ttypes.register_type(Type::Constructor(Constructor::Property {\n \t\t\t\t\t\t\t\t\t\ton,\n \t\t\t\t\t\t\t\t\t\tunder: under.into_owned(),\n-\t\t\t\t\t\t\t\t\t\tresult: og,\n+\t\t\t\t\t\t\t\t\t\tresult,\n \t\t\t\t\t\t\t\t\t}));\n \n \t\t\t\t\t\t\t\tSome(constructor_result)\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tType::Constant(_) | Type::Object(..) | Type::SpecialObject(..) => {\n-\t\t\t\t\t\t\t\tSome(og)\n+\t\t\t\t\t\t\tType::Function(..) => todo!(),\n+\t\t\t\t\t\t\tType::AliasTo { .. }\n+\t\t\t\t\t\t\t| Type::Object(ObjectNature::AnonymousTypeAnnotation)\n+\t\t\t\t\t\t\t| Type::Interface { .. } => {\n+\t\t\t\t\t\t\t\tlet constructor_result =\n+\t\t\t\t\t\t\t\t\ttypes.register_type(Type::Constructor(Constructor::Property {\n+\t\t\t\t\t\t\t\t\t\ton,\n+\t\t\t\t\t\t\t\t\t\tunder: under.into_owned(),\n+\t\t\t\t\t\t\t\t\t\tresult: value,\n+\t\t\t\t\t\t\t\t\t}));\n+\n+\t\t\t\t\t\t\t\tSome(constructor_result)\n \t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tType::Constant(_)\n+\t\t\t\t\t\t\t| Type::Object(ObjectNature::RealDeal)\n+\t\t\t\t\t\t\t| Type::SpecialObject(..) => Some(value),\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tPropertyValue::Getter(getter) => {\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -402,8 +471,16 @@ fn evaluate_get_on_poly<E: CallCheckingBehavior>(\n \t\t\t\t}\n \t\t\t}\n \t\t\tLogical::Or { left, right } => {\n-\t\t\t\tlet left = get_property_from_logical(*left, types, on, under.clone());\n-\t\t\t\tlet right = get_property_from_logical(*right, types, on, under);\n+\t\t\t\tlet left = resolve_logical_with_poly(\n+\t\t\t\t\t*left,\n+\t\t\t\t\ton,\n+\t\t\t\t\tunder.clone(),\n+\t\t\t\t\targuments,\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\ttypes,\n+\t\t\t\t);\n+\t\t\t\tlet right =\n+\t\t\t\t\tresolve_logical_with_poly(*right, on, under, arguments, environment, types);\n \n \t\t\t\tif let (Some(lhs), Some(rhs)) = (left, right) {\n \t\t\t\t\tcrate::utils::notify!(\"TODO how does conditionality work\");\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -413,18 +490,28 @@ fn evaluate_get_on_poly<E: CallCheckingBehavior>(\n \t\t\t\t\tNone\n \t\t\t\t}\n \t\t\t}\n-\t\t\tLogical::Implies { on: a, antecedent } => {\n-\t\t\t\ttodo!()\n-\t\t\t\t// TODO pass down argument instead ...\n-\t\t\t\t// let a = get_property_from_logical(*a, types, on, under.clone())?;\n-\t\t\t\t// Some(substitute(*a, &mut antecedent.type_arguments, environment, types))\n+\t\t\tLogical::Implies { on: implies_on, antecedent } => {\n+\t\t\t\tif arguments.is_some() {\n+\t\t\t\t\ttodo!(\"generics chain\")\n+\t\t\t\t}\n+\n+\t\t\t\tresolve_logical_with_poly(\n+\t\t\t\t\t*implies_on,\n+\t\t\t\t\ton,\n+\t\t\t\t\tunder.clone(),\n+\t\t\t\t\tSome(&antecedent),\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\ttypes,\n+\t\t\t\t)\n \t\t\t}\n \t\t}\n \t}\n \n \tlet fact = environment.get_property_unbound(constraint, publicity, under.clone(), types)?;\n \n-\tget_property_from_logical(fact, types, on, under)\n+\t// crate::utils::notify!(\"unbound is is {:?}\", fact);\n+\n+\tresolve_logical_with_poly(fact, on, under, None, environment, types)\n }\n \n /// Aka a assignment to a property, **INCLUDING initialization of a new one**\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -449,12 +536,14 @@ pub(crate) fn set_property<E: CallCheckingBehavior>(\n \t// }\n \n \t// if E::CHECK_PARAMETERS {\n-\tlet object_constraint = environment.get_object_constraint(on);\n+\tlet object_constraint = environment.get_object_constraints(on);\n \n \tfor constraint in object_constraint {\n \t\tlet property_constraint =\n \t\t\tenvironment.get_property_unbound(constraint, publicity, under.clone(), types);\n \n+\t\t// crate::utils::notify!(\"Property constraint .is_some() {:?}\", property_constraint.is_some());\n+\n \t\t// crate::utils::notify!(\n \t\t// \t\"Re-assignment constraint {}, prop={} {:?}\",\n \t\t// \tprint_type(constraint, types, &environment.as_general_context(), true),\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -462,27 +551,40 @@ pub(crate) fn set_property<E: CallCheckingBehavior>(\n \t\t// \tproperty_constraint\n \t\t// );\n \n-\t\tif let Some(property) = property_constraint {\n+\t\tif let Some(property_constraint) = property_constraint {\n \t\t\tlet mut basic_subtyping = crate::types::subtyping::BasicEquality {\n \t\t\t\t// This is important for free variables, sometimes ?\n \t\t\t\tadd_property_restrictions: true,\n \t\t\t\t// TODO position here\n \t\t\t\tposition: source_map::SpanWithSource::NULL_SPAN,\n \t\t\t};\n-\t\t\tlet property = property.prop_to_type();\n-\t\t\tcrate::utils::notify!(\n-\t\t\t\t\"{}\",\n-\t\t\t\tprint_type(property, types, &environment.as_general_context(), true)\n-\t\t\t);\n-\t\t\tif let SubTypeResult::IsNotSubType(sub_type_error) = type_is_subtype(\n-\t\t\t\tproperty,\n-\t\t\t\tnew.as_get_type(),\n-\t\t\t\t&mut basic_subtyping,\n-\t\t\t\tenvironment,\n-\t\t\t\ttypes,\n-\t\t\t) {\n-\t\t\t\t// TODO don't short circuit\n-\t\t\t\treturn Err(SetPropertyError::DoesNotMeetConstraint(property, sub_type_error));\n+\n+\t\t\tmatch new {\n+\t\t\t\tPropertyValue::Value(value) => {\n+\t\t\t\t\tlet result = type_is_subtype_of_property(\n+\t\t\t\t\t\t&property_constraint,\n+\t\t\t\t\t\tNone,\n+\t\t\t\t\t\t*value,\n+\t\t\t\t\t\t&mut basic_subtyping,\n+\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\ttypes,\n+\t\t\t\t\t);\n+\t\t\t\t\tif let SubTypeResult::IsNotSubType(reason) = result {\n+\t\t\t\t\t\treturn Err(SetPropertyError::DoesNotMeetConstraint {\n+\t\t\t\t\t\t\tproperty_constraint: TypeStringRepresentation::from_property_constraint(\n+\t\t\t\t\t\t\t\tproperty_constraint,\n+\t\t\t\t\t\t\t\tNone,\n+\t\t\t\t\t\t\t\t&environment.as_general_context(),\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\treason,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tPropertyValue::Getter(_) => todo!(),\n+\t\t\t\tPropertyValue::Setter(_) => todo!(),\n+\t\t\t\tPropertyValue::Deleted => todo!(),\n \t\t\t}\n \t\t} else {\n \t\t\t// TODO does not exist warning\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -492,7 +594,6 @@ pub(crate) fn set_property<E: CallCheckingBehavior>(\n \t\t\t// ));\n \t\t}\n \t}\n-\t// }\n \n \t// crate::utils::notify!(\n \t// \t\"setting {:?} {:?} {:?}\",\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -525,8 +626,6 @@ pub(crate) fn set_property<E: CallCheckingBehavior>(\n \t\t\t\t\t\tnew,\n \t\t\t\t\t\tunder: under.into_owned(),\n \t\t\t\t\t\tpublicity,\n-\t\t\t\t\t\t// TODO\n-\t\t\t\t\t\treflects_dependency: None,\n \t\t\t\t\t\tinitialization: false,\n \t\t\t\t\t\tposition: setter_position,\n \t\t\t\t\t});\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -1,14 +1,19 @@\n use std::collections::{HashMap, HashSet};\n \n use crate::{\n-\tbehavior::functions::{ClosureId, FunctionBehavior},\n+\tbehavior::{\n+\t\tfunctions::{ClosureId, FunctionBehavior},\n+\t\toperations::{CanonicalEqualityAndInequality, MathematicalAndBitwise},\n+\t},\n \tcontext::{get_on_ctx, Context, ContextType, Logical},\n \ttypes::FunctionType,\n \ttypes::{PolyNature, Type},\n-\tFunctionId, GeneralContext, TypeId,\n+\tConstant, FunctionId, GeneralContext, TypeId,\n };\n \n-use super::{properties::PropertyKey, Constructor, StructureGenerics, TypeRelationOperator};\n+use super::{\n+\tget_constraint, properties::PropertyKey, Constructor, StructureGenerics, TypeRelationOperator,\n+};\n \n /// Holds all the types. Eventually may be split across modules\n #[derive(Debug)]\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -19,11 +24,11 @@ pub struct TypeStore {\n \n \tpub(crate) dependent_dependencies: HashMap<TypeId, HashSet<TypeId>>,\n \n-\t// TODO merge into type\n-\t// pub(crate) functions_on_type: HashMap<TypeId, FunctionType>,\n-\t// pub(crate) proxies: HashMap<TypeId, Proxy>,\n \tpub(crate) specialisations: HashMap<TypeId, Vec<TypeId>>,\n \n+\t/// can be used for tree shaking\n+\tpub called_functions: HashSet<FunctionId>,\n+\n \t/// TODO not best place but is passed through everything so\n \tpub(crate) closure_counter: u32,\n }\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -90,6 +95,7 @@ impl Default for TypeStore {\n \t\t\tfunctions: HashMap::new(),\n \t\t\tdependent_dependencies: Default::default(),\n \t\t\tspecialisations: Default::default(),\n+\t\t\tcalled_functions: Default::default(),\n \t\t\tclosure_counter: 0,\n \t\t}\n \t}\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -247,6 +253,17 @@ impl TypeStore {\n \t\t\t\t\tself.get_fact_about_type(ctx, TypeId::FUNCTION_TYPE, resolver, data)\n \t\t\t\t})\n \t\t\t}\n+\t\t\tType::FunctionReference(_, _) => {\n+\t\t\t\tlet on_function = ctx\n+\t\t\t\t\t.parents_iter()\n+\t\t\t\t\t.find_map(|env| resolver(&env, self, on, data))\n+\t\t\t\t\t.map(Logical::Pure);\n+\n+\t\t\t\t// TODO undecided on this\n+\t\t\t\ton_function.or_else(|| {\n+\t\t\t\t\tself.get_fact_about_type(ctx, TypeId::FUNCTION_TYPE, resolver, data)\n+\t\t\t\t})\n+\t\t\t}\n \t\t\tType::AliasTo { to, .. } => {\n \t\t\t\tlet property_on_self = ctx\n \t\t\t\t\t.parents_iter()\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -272,7 +289,8 @@ impl TypeStore {\n \t\t\t\t}\n \t\t\t}\n \t\t\tType::RootPolyType(_nature) => {\n-\t\t\t\tlet aliases = ctx.get_poly_base(on, self).unwrap();\n+\t\t\t\t// TODO None here\n+\t\t\t\tlet aliases = get_constraint(on, self).unwrap();\n \t\t\t\t// Don't think any properties exist on this poly type\n \t\t\t\tself.get_fact_about_type(ctx, aliases, resolver, data)\n \t\t\t}\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -280,7 +298,6 @@ impl TypeStore {\n \t\t\t\ton,\n \t\t\t\targuments,\n \t\t\t})) => {\n-\t\t\t\tcrate::utils::notify!(\"Here StructureGenerics\");\n \t\t\t\t// TODO could drop some of with here\n \t\t\t\tlet fact_opt = self.get_fact_about_type(ctx, *on, resolver, data);\n \t\t\t\tfact_opt.map(|fact| Logical::Implies {\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -290,7 +307,8 @@ impl TypeStore {\n \t\t\t}\n \t\t\tType::Constructor(constructor) => {\n \t\t\t\t// Don't think any properties exist on this poly type\n-\t\t\t\tlet constraint = ctx.get_poly_base(on, self).unwrap();\n+\t\t\t\t// TODO None here\n+\t\t\t\tlet constraint = get_constraint(on, self).unwrap();\n \t\t\t\t// TODO might need to send more information here, rather than forgetting via .get_type\n \t\t\t\tself.get_fact_about_type(ctx, on, resolver, data)\n \t\t\t}\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -315,7 +333,6 @@ impl TypeStore {\n \t\t\t\t.or_else(|| {\n \t\t\t\t\tself.get_fact_about_type(ctx, cst.get_backing_type_id(), resolver, data)\n \t\t\t\t}),\n-\t\t\tType::FunctionReference(_, _) => todo!(),\n \t\t\tType::SpecialObject(_) => todo!(),\n \t\t}\n \t}\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -12,15 +12,14 @@ use crate::{\n };\n \n use super::{\n+\tget_constraint,\n \tpoly_types::{generic_type_arguments::StructureGenericArguments, SeedingContext},\n \tproperties::PropertyKey,\n-\tConstructor, PolyNature, StructureGenerics, Type,\n+\tConstructor, PolyNature, StructureGenerics, Type, TypeArguments,\n };\n \n pub use super::{BasicEquality, NonEqualityReason, PropertyError, SubTypeResult, SubtypeBehavior};\n \n-type TypeArguments = map_vec::Map<TypeId, (TypeId, SpanWithSource)>;\n-\n /// `base_type :>= ty` (`ty <=: base_type`)\n ///\n /// TODO `TypeArguments` as a chain?\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -54,9 +53,9 @@ fn set_object_restriction(environment: &mut Environment, object: TypeId, restric\n /// TODO integrate `set_restriction`, but it can't create a type ? maybe object restriction should be logically.\n /// maybe sub function\n pub fn type_is_subtype_of_property<T: SubtypeBehavior>(\n-\tproperty: Logical<PropertyValue>,\n+\tproperty: &Logical<PropertyValue>,\n \t// TODO chain with annex\n-\tproperty_generics: Option<&StructureGenericArguments>,\n+\tproperty_generics: Option<&TypeArguments>,\n \tty: TypeId,\n \tbehavior: &mut T,\n \tenvironment: &mut Environment,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -66,7 +65,7 @@ pub fn type_is_subtype_of_property<T: SubtypeBehavior>(\n \t\tLogical::Pure(prop) => type_is_subtype2(\n \t\t\tprop.as_set_type(),\n \t\t\tty,\n-\t\t\tNone,\n+\t\t\tproperty_generics,\n \t\t\tNone,\n \t\t\tbehavior,\n \t\t\tenvironment,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -75,7 +74,7 @@ pub fn type_is_subtype_of_property<T: SubtypeBehavior>(\n \t\t),\n \t\tLogical::Or { left, right } => {\n \t\t\tlet left_result = type_is_subtype_of_property(\n-\t\t\t\t*left,\n+\t\t\t\tleft,\n \t\t\t\tproperty_generics,\n \t\t\t\tty,\n \t\t\t\tbehavior,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -86,7 +85,7 @@ pub fn type_is_subtype_of_property<T: SubtypeBehavior>(\n \t\t\t\tleft_result\n \t\t\t} else {\n \t\t\t\ttype_is_subtype_of_property(\n-\t\t\t\t\t*right,\n+\t\t\t\t\tright,\n \t\t\t\t\tproperty_generics,\n \t\t\t\t\tty,\n \t\t\t\t\tbehavior,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -99,7 +98,14 @@ pub fn type_is_subtype_of_property<T: SubtypeBehavior>(\n \t\t\tif property_generics.is_some() {\n \t\t\t\ttodo!(\"nesting of generics\");\n \t\t\t}\n-\t\t\ttype_is_subtype_of_property(*on, Some(&antecedent), ty, behavior, environment, types)\n+\t\t\ttype_is_subtype_of_property(\n+\t\t\t\ton,\n+\t\t\t\tSome(&antecedent.type_arguments),\n+\t\t\t\tty,\n+\t\t\t\tbehavior,\n+\t\t\t\tenvironment,\n+\t\t\t\ttypes,\n+\t\t\t)\n \t\t}\n \t}\n }\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -239,7 +245,8 @@ fn type_is_subtype2<T: SubtypeBehavior>(\n \t\t\t\trestriction_mode,\n \t\t\t);\n \t\t\tlet left = print_type(base_type, types, &environment.as_general_context(), true);\n-\t\t\tcrate::utils::notify!(\"Left {}\", left);\n+\n+\t\t\t// crate::utils::notify!(\"Left object {}\", left);\n \n \t\t\tif let SubTypeResult::IsNotSubType(..) = result {\n \t\t\t\tresult\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -337,7 +344,7 @@ fn type_is_subtype2<T: SubtypeBehavior>(\n \t\t\t\t\t}\n \t\t\t\t}\n \n-\t\t\t\tlet constraint = environment.get_poly_base(base_type, types).unwrap();\n+\t\t\t\tlet constraint = get_constraint(base_type, types).unwrap();\n \t\t\t\tif let SubTypeResult::IsNotSubType(reasons) = type_is_subtype2(\n \t\t\t\t\tconstraint,\n \t\t\t\t\tty,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -379,7 +386,7 @@ fn type_is_subtype2<T: SubtypeBehavior>(\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tPropertyKey::String(a) => {\n-\t\t\t\t\t\t\t\tcrate::utils::notify!(\"looking at prototype {}\", a);\n+\t\t\t\t\t\t\t\tcrate::utils::notify!(\"looking at property {}\", a);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tPropertyKey::Type(_) => (),\n \t\t\t\t\t\t}\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -413,9 +420,26 @@ fn type_is_subtype2<T: SubtypeBehavior>(\n \t\t\t\t\t}\n \n \t\t\t\t\tSubTypeResult::IsSubType\n+\t\t\t\t} else if let Type::Constructor(Constructor::StructureGenerics(\n+\t\t\t\t\tStructureGenerics { on: TypeId::ARRAY_TYPE, arguments: right_arguments },\n+\t\t\t\t)) = right_ty\n+\t\t\t\t{\n+\t\t\t\t\tlet left_arg = arguments.get_local_argument(TypeId::T_TYPE).unwrap();\n+\t\t\t\t\tlet right_arg = right_arguments.get_local_argument(TypeId::T_TYPE).unwrap();\n+\t\t\t\t\t// TODO unsure about arguments here\n+\t\t\t\t\ttype_is_subtype2(\n+\t\t\t\t\t\tleft_arg,\n+\t\t\t\t\t\tright_arg,\n+\t\t\t\t\t\tbase_type_arguments,\n+\t\t\t\t\t\tright_type_arguments,\n+\t\t\t\t\t\tbehavior,\n+\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\trestriction_mode,\n+\t\t\t\t\t)\n \t\t\t\t} else {\n-\t\t\t\t\tcrate::utils::notify!(\"Else here :?\");\n-\t\t\t\t\ttodo!(\"get right type structure generics match parameters\");\n+\t\t\t\t\tcrate::utils::notify!(\"Not array-ish\");\n+\t\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif base_type_arguments.is_some() {\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -445,7 +469,7 @@ fn type_is_subtype2<T: SubtypeBehavior>(\n \t\t\t\telse_result,\n \t\t\t\tresult_union,\n \t\t\t} => todo!(),\n-\t\t\tConstructor::FunctionResult { on, with, result } => todo!(),\n+\t\t\tConstructor::Image { on, with, result } => todo!(),\n \t\t\tConstructor::Property { on, under, result: _ } => {\n \t\t\t\t// Ezno custom behavior\n \t\t\t\t// TODO might be based of T\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -590,7 +614,7 @@ fn type_is_subtype2<T: SubtypeBehavior>(\n \t\t\t\t\t\t\trestriction_mode,\n \t\t\t\t\t\t)\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tlet to = environment.get_poly_base(ty, types).unwrap();\n+\t\t\t\t\t\tlet to = get_constraint(ty, types).unwrap();\n \n \t\t\t\t\t\tif to == TypeId::ANY_TYPE {\n \t\t\t\t\t\t\tcrate::utils::notify!(\"Modify constraint for equality\");\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -718,7 +718,7 @@ impl FromStr for NumberRepresentation {\n \t\t\t})\n \t\t} else if let Some(s) = s.strip_suffix('.') {\n \t\t\tOk(Self::Number {\n-\t\t\t\tvalue: sign.apply(s.parse().map_err(|_| s.clone())?),\n+\t\t\t\tvalue: sign.apply(s.parse().map_err(|_| s)?),\n \t\t\t\tbefore_point: s.len() as u8,\n \t\t\t\tafter_point: Some(0),\n \t\t\t})\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -131,7 +131,7 @@ pub enum ForLoopCondition {\n \t\tposition: Span,\n \t},\n \tStatements {\n-\t\tinitializer: Option<ForLoopStatementInitializer>,\n+\t\tinitialiser: Option<ForLoopStatementInitializer>,\n \t\tcondition: Option<MultipleExpression>,\n \t\tafterthought: Option<MultipleExpression>,\n \t\tposition: Span,\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -268,7 +268,7 @@ impl ASTNode for ForLoopCondition {\n \t\t\t\t\t.as_ref()\n \t\t\t\t\t.map_or(semi_colon_two, |expr| expr.get_position().get_end());\n \t\t\t\tlet position = start.union(end);\n-\t\t\t\tSelf::Statements { initializer, condition, afterthought, position }\n+\t\t\t\tSelf::Statements { initialiser: initializer, condition, afterthought, position }\n \t\t\t}\n \t\t};\n \t\treader.expect_next(TSXToken::CloseParentheses)?;\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -301,7 +301,7 @@ impl ASTNode for ForLoopCondition {\n \t\t\t\tbuf.push_str(\" in \");\n \t\t\t\tr#in.to_string_from_buffer(buf, options, depth);\n \t\t\t}\n-\t\t\tSelf::Statements { initializer, condition, afterthought, position: _ } => {\n+\t\t\tSelf::Statements { initialiser: initializer, condition, afterthought, position: _ } => {\n \t\t\t\tif let Some(initializer) = initializer {\n \t\t\t\t\tmatch initializer {\n \t\t\t\t\t\tForLoopStatementInitializer::VariableDeclaration(stmt) => {\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -40,12 +40,12 @@ pub enum Statement {\n \t// TODO as keyword\n \tDebugger(Span),\n \t// Loops and \"condition-aries\"\n-\tIfStatement(IfStatement),\n-\tForLoopStatement(ForLoopStatement),\n-\tSwitchStatement(SwitchStatement),\n-\tWhileStatement(WhileStatement),\n-\tDoWhileStatement(DoWhileStatement),\n-\tTryCatchStatement(TryCatchStatement),\n+\tIf(IfStatement),\n+\tForLoop(ForLoopStatement),\n+\tSwitch(SwitchStatement),\n+\tWhileLoop(WhileStatement),\n+\tDoWhileLoop(DoWhileStatement),\n+\tTryCatch(TryCatchStatement),\n \t// Control flow\n \tReturn(ReturnStatement),\n \t// TODO maybe an actual label struct:\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -238,12 +238,12 @@ impl ASTNode for Statement {\n \t\t\t\t\texpression.to_string_from_buffer(buf, options, depth);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tStatement::IfStatement(is) => is.to_string_from_buffer(buf, options, depth),\n-\t\t\tStatement::ForLoopStatement(fl) => fl.to_string_from_buffer(buf, options, depth),\n-\t\t\tStatement::SwitchStatement(ss) => ss.to_string_from_buffer(buf, options, depth),\n-\t\t\tStatement::WhileStatement(ws) => ws.to_string_from_buffer(buf, options, depth),\n-\t\t\tStatement::DoWhileStatement(dws) => dws.to_string_from_buffer(buf, options, depth),\n-\t\t\tStatement::TryCatchStatement(tcs) => tcs.to_string_from_buffer(buf, options, depth),\n+\t\t\tStatement::If(is) => is.to_string_from_buffer(buf, options, depth),\n+\t\t\tStatement::ForLoop(fl) => fl.to_string_from_buffer(buf, options, depth),\n+\t\t\tStatement::Switch(ss) => ss.to_string_from_buffer(buf, options, depth),\n+\t\t\tStatement::WhileLoop(ws) => ws.to_string_from_buffer(buf, options, depth),\n+\t\t\tStatement::DoWhileLoop(dws) => dws.to_string_from_buffer(buf, options, depth),\n+\t\t\tStatement::TryCatch(tcs) => tcs.to_string_from_buffer(buf, options, depth),\n \t\t\tStatement::Comment(comment, _) => {\n \t\t\t\tif options.should_add_comment(false) {\n \t\t\t\t\tbuf.push_str(\"//\");\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -304,7 +304,7 @@ impl Statement {\n \t\t\tself,\n \t\t\tStatement::VarVariable(_)\n \t\t\t\t| Statement::Expression(_)\n-\t\t\t\t| Statement::DoWhileStatement(_)\n+\t\t\t\t| Statement::DoWhileLoop(_)\n \t\t\t\t| Statement::Continue(..)\n \t\t\t\t| Statement::Break(..)\n \t\t\t\t| Statement::Return(..)\ndiff --git a/src/error_handling.rs b/src/error_handling.rs\n--- a/src/error_handling.rs\n+++ b/src/error_handling.rs\n@@ -26,7 +26,7 @@ pub(crate) fn emit_ezno_diagnostic(\n \t\t\tlabels: vec![Label::primary(position.source, position).with_message(reason)],\n \t\t\tnotes: Vec::default(),\n \t\t},\n-\t\tchecker::Diagnostic::PositionWithAdditionLabels { reason, position, labels, kind } => {\n+\t\tchecker::Diagnostic::PositionWithAdditionalLabels { reason, position, labels, kind } => {\n \t\t\tlet (labels, notes) =\n \t\t\t\tlabels.into_iter().partition::<Vec<_>, _>(|(_, value)| value.is_some());\n \ndiff --git a/src/transformers/optimisations.rs b/src/transformers/optimisations.rs\n--- a/src/transformers/optimisations.rs\n+++ b/src/transformers/optimisations.rs\n@@ -1,5 +1,3 @@\n-use std::collections::HashSet;\n-\n use checker::{synthesis::EznoParser, FunctionId, PostCheckData};\n use parser::{\n \tdeclarations::{\ndiff --git a/src/transformers/optimisations.rs b/src/transformers/optimisations.rs\n--- a/src/transformers/optimisations.rs\n+++ b/src/transformers/optimisations.rs\n@@ -30,10 +28,9 @@ impl VisitorMut<Expression, PostCheckData<EznoParser>> for ExpressionOptimiser {\n \t\t\t\tfor item in literal.members.iter_mut() {\n \t\t\t\t\tlet item = item.get_ast_mut();\n \t\t\t\t\tif let ObjectLiteralMember::Method(method) = item {\n-\t\t\t\t\t\tlet current_module = chain.get_module();\n \t\t\t\t\t\tlet position = *method.get_position();\n-\t\t\t\t\t\tlet function_id = FunctionId(current_module, position.start);\n-\t\t\t\t\t\tif !data.type_mappings.called_functions.contains(&function_id) {\n+\t\t\t\t\t\tlet function_id = FunctionId(chain.get_module(), position.start);\n+\t\t\t\t\t\tif !data.is_function_called(function_id) {\n \t\t\t\t\t\t\t// Make it null for now to not break `Object.keys`\n \t\t\t\t\t\t\tlet name = method.name.clone();\n \t\t\t\t\t\t\t*item = ObjectLiteralMember::Property(\ndiff --git a/src/transformers/optimisations.rs b/src/transformers/optimisations.rs\n--- a/src/transformers/optimisations.rs\n+++ b/src/transformers/optimisations.rs\n@@ -47,24 +44,20 @@ impl VisitorMut<Expression, PostCheckData<EznoParser>> for ExpressionOptimiser {\n \t\t\t}\n \t\t\tExpression::ArrowFunction(func) => {\n \t\t\t\tif !data\n-\t\t\t\t\t.type_mappings\n-\t\t\t\t\t.called_functions\n-\t\t\t\t\t.contains(&FunctionId(chain.get_module(), func.get_position().start))\n+\t\t\t\t\t.is_function_called(FunctionId(chain.get_module(), func.get_position().start))\n \t\t\t\t{\n \t\t\t\t\t*item = Expression::Null(*func.get_position());\n \t\t\t\t}\n \t\t\t}\n \t\t\tExpression::ExpressionFunction(func) => {\n \t\t\t\tif !data\n-\t\t\t\t\t.type_mappings\n-\t\t\t\t\t.called_functions\n-\t\t\t\t\t.contains(&FunctionId(chain.get_module(), func.get_position().start))\n+\t\t\t\t\t.is_function_called(FunctionId(chain.get_module(), func.get_position().start))\n \t\t\t\t{\n \t\t\t\t\t*item = Expression::Null(*func.get_position());\n \t\t\t\t}\n \t\t\t}\n \t\t\tExpression::ClassExpression(cls) => {\n-\t\t\t\tshake_class(cls, &data.type_mappings.called_functions, chain.get_module());\n+\t\t\t\tshake_class(cls, data, chain.get_module());\n \t\t\t}\n \t\t\t_ => {}\n \t\t}\ndiff --git a/src/transformers/optimisations.rs b/src/transformers/optimisations.rs\n--- a/src/transformers/optimisations.rs\n+++ b/src/transformers/optimisations.rs\n@@ -91,13 +84,13 @@ impl VisitorMut<BlockItemMut<'_>, PostCheckData<EznoParser>> for StatementOptimi\n \t\t\t\t\t// TODO remove if never read\n \t\t\t\t}\n \t\t\t\tparser::Declaration::Function(func) => {\n-\t\t\t\t\tif !data\n-\t\t\t\t\t\t.type_mappings\n-\t\t\t\t\t\t.called_functions\n-\t\t\t\t\t\t.contains(&FunctionId(chain.get_module(), func.get_position().start))\n-\t\t\t\t\t{\n+\t\t\t\t\tif !data.is_function_called(FunctionId(\n+\t\t\t\t\t\tchain.get_module(),\n+\t\t\t\t\t\tfunc.get_position().start,\n+\t\t\t\t\t)) {\n \t\t\t\t\t\t// Replace with property to not break Object.keys for now\n-\t\t\t\t\t\t// TODO replacing this with variable isn't great but is the unfortunate design of `StatementOrDeclarationMut`\n+\t\t\t\t\t\t// TODO replacing this with variable isn't great but\n+\t\t\t\t\t\t// is the unfortunate design of `StatementOrDeclarationMut`\n \t\t\t\t\t\t*declaration = parser::Declaration::Variable(\n \t\t\t\t\t\t\tparser::declarations::VariableDeclaration::LetDeclaration {\n \t\t\t\t\t\t\t\tkeyword: parser::Keyword::new(parser::Span::NULL_SPAN),\ndiff --git a/src/transformers/optimisations.rs b/src/transformers/optimisations.rs\n--- a/src/transformers/optimisations.rs\n+++ b/src/transformers/optimisations.rs\n@@ -108,11 +101,7 @@ impl VisitorMut<BlockItemMut<'_>, PostCheckData<EznoParser>> for StatementOptimi\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tparser::Declaration::Class(cls) => {\n-\t\t\t\t\tshake_class(\n-\t\t\t\t\t\t&mut cls.on,\n-\t\t\t\t\t\t&data.type_mappings.called_functions,\n-\t\t\t\t\t\tchain.get_module(),\n-\t\t\t\t\t);\n+\t\t\t\t\tshake_class(&mut cls.on, data, chain.get_module());\n \t\t\t\t}\n \t\t\t\tparser::Declaration::Import(_) => {\n \t\t\t\t\t// TODO imported items\ndiff --git a/src/transformers/optimisations.rs b/src/transformers/optimisations.rs\n--- a/src/transformers/optimisations.rs\n+++ b/src/transformers/optimisations.rs\n@@ -132,13 +121,13 @@ impl VisitorMut<BlockItemMut<'_>, PostCheckData<EznoParser>> for StatementOptimi\n /// TODO properties and even entire class\n fn shake_class<T: ExpressionOrStatementPosition>(\n \tclass: &mut ClassDeclaration<T>,\n-\tcalled_functions: &HashSet<FunctionId>,\n+\tdata: &PostCheckData<EznoParser>,\n \tsource: SourceId,\n ) {\n \tfor item in class.members.iter_mut() {\n \t\tif let ClassMember::Method(static_kw, func) = &item.on {\n \t\t\tlet id = FunctionId(source, func.position.start);\n-\t\t\tif !called_functions.contains(&id) {\n+\t\t\tif !data.is_function_called(id) {\n \t\t\t\t// Replace with property to not break Object.keys for now\n \t\t\t\titem.on = ClassMember::Property(\n \t\t\t\t\tstatic_kw.clone(),\n",
        "test_patch": "diff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -160,9 +160,16 @@ jobs:\n         working-directory: parser\n \n       - name: Run checker specification\n-        if: steps.changes.outputs.checker == 'true'\n+        if: steps.changes.outputs.checker == 'true' && github.event_name != 'pull_request'\n         run: cargo test\n         working-directory: checker/specification\n+      \n+      - name: Run checker specification (w/ staging)\n+        if: steps.changes.outputs.checker == 'true' && github.event_name == 'pull_request'\n+        run: cargo test -F staging\n+        working-directory: checker/specification\n+        env:\n+          EZNO_DEBUG: 1\n \n       - name: Run checker tests\n         if: steps.changes.outputs.checker == 'true'\ndiff --git a/checker/examples/check.rs b/checker/examples/check.rs\n--- a/checker/examples/check.rs\n+++ b/checker/examples/check.rs\n@@ -1,14 +1,17 @@\n #[cfg(feature = \"ezno-parser\")]\n fn main() {\n-\tuse ezno_checker::{check_project, synthesis};\n+\tuse ezno_checker::{check_project, synthesis, Diagnostic};\n \tuse std::{\n \t\tenv, fs,\n \t\tpath::{Path, PathBuf},\n+\t\ttime::Instant,\n \t};\n \n \tlet name = env::args().nth(1).unwrap_or_else(|| \"examples/test.ts\".to_string());\n \tlet path = Path::new(&name);\n \n+\tlet now = Instant::now();\n+\n \tlet (diagnostics, post_check_data) = check_project::<_, synthesis::EznoParser>(\n \t\tpath.to_path_buf(),\n \t\tstd::iter::once(ezno_checker::INTERNAL_DEFINITION_FILE_PATH.into()).collect(),\ndiff --git /dev/null b/checker/src/behavior/iteration.rs\nnew file mode 100644\n--- /dev/null\n+++ b/checker/src/behavior/iteration.rs\n@@ -0,0 +1,757 @@\n+use std::collections::{HashMap, HashSet};\n+\n+use source_map::{BaseSpan, SpanWithSource};\n+\n+use crate::{\n+\tbehavior::{operations::CanonicalEqualityAndInequality, variables::VariableOrImport},\n+\tcontext::{calling::Target, environment::Label, get_value_of_variable, CallCheckingBehavior},\n+\tevents::{\n+\t\tapplication::ErrorsAndInfo, apply_event, Event, EventResult, InitialVariables,\n+\t\tRootReference,\n+\t},\n+\ttypes::{\n+\t\tpoly_types::{\n+\t\t\tgeneric_type_arguments::{StructureGenericArguments, TypeArgumentStore},\n+\t\t\tFunctionTypeArguments,\n+\t\t},\n+\t\tprinting::print_type,\n+\t\tsubstitute, Constructor, ObjectNature, PolyNature, TypeArguments, TypeStore,\n+\t},\n+\tCheckingData, Constant, Environment, Facts, Scope, Type, TypeId, VariableId,\n+};\n+\n+#[derive(Clone, Copy)]\n+pub enum IterationBehavior<'a, A: crate::ASTImplementation> {\n+\tWhile(&'a A::MultipleExpression<'a>),\n+\tDoWhile(&'a A::MultipleExpression<'a>),\n+\tFor {\n+\t\tinitialiser: &'a Option<A::ForStatementInitiliser<'a>>,\n+\t\tcondition: &'a Option<A::MultipleExpression<'a>>,\n+\t\tafterthought: &'a Option<A::MultipleExpression<'a>>,\n+\t},\n+\tForIn {\n+\t\tlhs: &'a A::VariableField<'a>,\n+\t\trhs: &'a A::MultipleExpression<'a>,\n+\t},\n+\tForOf {\n+\t\tlhs: &'a A::VariableField<'a>,\n+\t\trhs: &'a A::Expression<'a>,\n+\t},\n+}\n+\n+#[allow(clippy::needless_pass_by_value)]\n+pub fn synthesise_iteration<T: crate::ReadFromFS, A: crate::ASTImplementation>(\n+\tbehavior: IterationBehavior<A>,\n+\tlabel: Label,\n+\tenvironment: &mut Environment,\n+\tchecking_data: &mut CheckingData<T, A>,\n+\tloop_body: impl FnOnce(&mut Environment, &mut CheckingData<T, A>),\n+) {\n+\tmatch behavior {\n+\t\tIterationBehavior::While(condition) => {\n+\t\t\tlet (condition, result, ..) = environment.new_lexical_environment_fold_into_parent(\n+\t\t\t\tScope::Looping { label },\n+\t\t\t\tchecking_data,\n+\t\t\t\t|environment, checking_data| {\n+\t\t\t\t\tlet condition = A::synthesise_multiple_expression(\n+\t\t\t\t\t\tcondition,\n+\t\t\t\t\t\tTypeId::ANY_TYPE,\n+\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t);\n+\n+\t\t\t\t\t// TODO not always needed\n+\t\t\t\t\tlet break_event = Event::Conditionally {\n+\t\t\t\t\t\tcondition,\n+\t\t\t\t\t\tevents_if_truthy: Default::default(),\n+\t\t\t\t\t\telse_events: Box::new([Event::Break { position: None, carry: 0 }]),\n+\t\t\t\t\t\tposition: None,\n+\t\t\t\t\t};\n+\t\t\t\t\tenvironment.facts.events.push(break_event);\n+\n+\t\t\t\t\tloop_body(environment, checking_data);\n+\n+\t\t\t\t\tcondition\n+\t\t\t\t},\n+\t\t\t);\n+\n+\t\t\tlet (\n+\t\t\t\tFacts { variable_current_value, current_properties, mut events, .. },\n+\t\t\t\t_closes_over,\n+\t\t\t) = result.unwrap();\n+\n+\t\t\tlet loop_facts = Values {\n+\t\t\t\tvariable_values: variable_current_value,\n+\t\t\t\tproperties_values: current_properties,\n+\t\t\t};\n+\n+\t\t\tlet fixed_iterations = calculate_result_of_loop(\n+\t\t\t\tcondition,\n+\t\t\t\tNone,\n+\t\t\t\tenvironment,\n+\t\t\t\t&checking_data.types,\n+\t\t\t\t&loop_facts,\n+\t\t\t);\n+\n+\t\t\tif let Some(_value) = run_iteration_block(\n+\t\t\t\tIterationKind::Condition { under: fixed_iterations.ok(), postfix_condition: false },\n+\t\t\t\tevents,\n+\t\t\t\tInitialVariablesInput::Compute,\n+\t\t\t\t&mut FunctionTypeArguments::new(),\n+\t\t\t\tenvironment,\n+\t\t\t\t&mut crate::context::calling::Target::new_default(),\n+\t\t\t\t// TODO shouldn't be needed\n+\t\t\t\t&mut Default::default(),\n+\t\t\t\t&mut checking_data.types,\n+\t\t\t) {\n+\t\t\t\ttodo!()\n+\t\t\t}\n+\t\t}\n+\t\tIterationBehavior::DoWhile(condition) => {\n+\t\t\t// let is_do_while = matches!(behavior, IterationBehavior::DoWhile(..));\n+\n+\t\t\t// Same as above but condition is evaluated at end. Don't know whether events should be evaluated once...?\n+\t\t\tlet (condition, result, ..) = environment.new_lexical_environment_fold_into_parent(\n+\t\t\t\tScope::Looping { label },\n+\t\t\t\tchecking_data,\n+\t\t\t\t|environment, checking_data| {\n+\t\t\t\t\tloop_body(environment, checking_data);\n+\n+\t\t\t\t\tlet condition = A::synthesise_multiple_expression(\n+\t\t\t\t\t\tcondition,\n+\t\t\t\t\t\tTypeId::ANY_TYPE,\n+\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t);\n+\n+\t\t\t\t\t// TODO not always needed\n+\t\t\t\t\tlet break_event = Event::Conditionally {\n+\t\t\t\t\t\tcondition,\n+\t\t\t\t\t\tevents_if_truthy: Default::default(),\n+\t\t\t\t\t\telse_events: Box::new([Event::Break { position: None, carry: 0 }]),\n+\t\t\t\t\t\tposition: None,\n+\t\t\t\t\t};\n+\t\t\t\t\tenvironment.facts.events.push(break_event);\n+\n+\t\t\t\t\tcondition\n+\t\t\t\t},\n+\t\t\t);\n+\n+\t\t\tlet (\n+\t\t\t\tFacts { variable_current_value, current_properties, mut events, .. },\n+\t\t\t\t_closes_over,\n+\t\t\t) = result.unwrap();\n+\n+\t\t\tlet loop_facts = Values {\n+\t\t\t\tvariable_values: variable_current_value,\n+\t\t\t\tproperties_values: current_properties,\n+\t\t\t};\n+\n+\t\t\tlet fixed_iterations = calculate_result_of_loop(\n+\t\t\t\tcondition,\n+\t\t\t\tNone,\n+\t\t\t\tenvironment,\n+\t\t\t\t&checking_data.types,\n+\t\t\t\t&loop_facts,\n+\t\t\t);\n+\n+\t\t\tif let Some(_value) = run_iteration_block(\n+\t\t\t\tIterationKind::Condition { under: fixed_iterations.ok(), postfix_condition: true },\n+\t\t\t\tevents,\n+\t\t\t\tInitialVariablesInput::Compute,\n+\t\t\t\t&mut FunctionTypeArguments::new(),\n+\t\t\t\tenvironment,\n+\t\t\t\t&mut crate::context::calling::Target::new_default(),\n+\t\t\t\t// TODO shouldn't be needed\n+\t\t\t\t&mut Default::default(),\n+\t\t\t\t&mut checking_data.types,\n+\t\t\t) {\n+\t\t\t\ttodo!()\n+\t\t\t}\n+\t\t}\n+\t\tIterationBehavior::For { initialiser, condition, afterthought } => {\n+\t\t\t// 99% of the time need to do this, so doing here anyway\n+\t\t\tlet ((condition, result, dependent_variables), ..) = environment\n+\t\t\t\t.new_lexical_environment_fold_into_parent(\n+\t\t\t\t\tScope::Block {},\n+\t\t\t\t\tchecking_data,\n+\t\t\t\t\t|environment, checking_data| {\n+\t\t\t\t\t\tlet dependent_variables_initial_values: HashMap<VariableId, TypeId> =\n+\t\t\t\t\t\t\tif let Some(initialiser) = initialiser {\n+\t\t\t\t\t\t\t\tA::synthesise_for_loop_initialiser(\n+\t\t\t\t\t\t\t\t\tinitialiser,\n+\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t\t\tenvironment\n+\t\t\t\t\t\t\t\t\t.variables\n+\t\t\t\t\t\t\t\t\t.values()\n+\t\t\t\t\t\t\t\t\t.map(|v| {\n+\t\t\t\t\t\t\t\t\t\tlet id = v.get_id();\n+\t\t\t\t\t\t\t\t\t\tlet end_value = environment\n+\t\t\t\t\t\t\t\t\t\t\t.facts\n+\t\t\t\t\t\t\t\t\t\t\t.variable_current_value\n+\t\t\t\t\t\t\t\t\t\t\t.get(&id)\n+\t\t\t\t\t\t\t\t\t\t\t.expect(\"loop variable with no initial value\");\n+\t\t\t\t\t\t\t\t\t\t(id, *end_value)\n+\t\t\t\t\t\t\t\t\t})\n+\t\t\t\t\t\t\t\t\t.collect()\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tDefault::default()\n+\t\t\t\t\t\t\t};\n+\n+\t\t\t\t\t\tlet ((condition, dependent_variables), events, ..) = environment\n+\t\t\t\t\t\t\t.new_lexical_environment_fold_into_parent(\n+\t\t\t\t\t\t\t\tScope::Looping { label },\n+\t\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t\t\t|environment, checking_data| {\n+\t\t\t\t\t\t\t\t\tlet condition = if let Some(condition) = condition {\n+\t\t\t\t\t\t\t\t\t\tA::synthesise_multiple_expression(\n+\t\t\t\t\t\t\t\t\t\t\tcondition,\n+\t\t\t\t\t\t\t\t\t\t\tTypeId::ANY_TYPE,\n+\t\t\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tTypeId::TRUE\n+\t\t\t\t\t\t\t\t\t};\n+\n+\t\t\t\t\t\t\t\t\t// TODO not always needed\n+\t\t\t\t\t\t\t\t\tlet break_event = Event::Conditionally {\n+\t\t\t\t\t\t\t\t\t\tcondition,\n+\t\t\t\t\t\t\t\t\t\tevents_if_truthy: Default::default(),\n+\t\t\t\t\t\t\t\t\t\telse_events: Box::new([Event::Break {\n+\t\t\t\t\t\t\t\t\t\t\tposition: None,\n+\t\t\t\t\t\t\t\t\t\t\tcarry: 0,\n+\t\t\t\t\t\t\t\t\t\t}]),\n+\t\t\t\t\t\t\t\t\t\tposition: None,\n+\t\t\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\t\t\tenvironment.facts.events.push(break_event);\n+\n+\t\t\t\t\t\t\t\t\tloop_body(environment, checking_data);\n+\n+\t\t\t\t\t\t\t\t\t// Just want to observe events that happen here\n+\t\t\t\t\t\t\t\t\tif let Some(afterthought) = afterthought {\n+\t\t\t\t\t\t\t\t\t\tlet _ = A::synthesise_multiple_expression(\n+\t\t\t\t\t\t\t\t\t\t\tafterthought,\n+\t\t\t\t\t\t\t\t\t\t\tTypeId::ANY_TYPE,\n+\t\t\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\tlet dependent_variables: HashMap<VariableId, (TypeId, TypeId)> =\n+\t\t\t\t\t\t\t\t\t\tdependent_variables_initial_values\n+\t\t\t\t\t\t\t\t\t\t\t.into_iter()\n+\t\t\t\t\t\t\t\t\t\t\t.map(|(id, start_value)| {\n+\t\t\t\t\t\t\t\t\t\t\t\tlet end_value = environment\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.facts\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.variable_current_value\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.get(&id)\n+\t\t\t\t\t\t\t\t\t\t\t\t\t.expect(\"loop variable with no initial value\");\n+\t\t\t\t\t\t\t\t\t\t\t\t(id, (start_value, *end_value))\n+\t\t\t\t\t\t\t\t\t\t\t})\n+\t\t\t\t\t\t\t\t\t\t\t.collect();\n+\n+\t\t\t\t\t\t\t\t\t(condition, dependent_variables)\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t// TODO copy value of variables between things, or however it works\n+\n+\t\t\t\t\t\t(condition, events, dependent_variables)\n+\t\t\t\t\t},\n+\t\t\t\t);\n+\n+\t\t\tlet (\n+\t\t\t\tFacts { variable_current_value, current_properties, mut events, .. },\n+\t\t\t\t_closes_over,\n+\t\t\t) = result.unwrap();\n+\n+\t\t\tlet loop_facts = Values {\n+\t\t\t\tvariable_values: variable_current_value,\n+\t\t\t\tproperties_values: current_properties,\n+\t\t\t};\n+\n+\t\t\tlet fixed_iterations = calculate_result_of_loop(\n+\t\t\t\tcondition,\n+\t\t\t\tSome(&dependent_variables),\n+\t\t\t\tenvironment,\n+\t\t\t\t&checking_data.types,\n+\t\t\t\t&loop_facts,\n+\t\t\t);\n+\n+\t\t\tfor (var, (start, _)) in dependent_variables {\n+\t\t\t\tenvironment.facts.variable_current_value.insert(var, start);\n+\t\t\t}\n+\n+\t\t\tif let Some(_value) = run_iteration_block(\n+\t\t\t\tIterationKind::Condition { under: fixed_iterations.ok(), postfix_condition: false },\n+\t\t\t\tevents,\n+\t\t\t\tInitialVariablesInput::Compute,\n+\t\t\t\t&mut FunctionTypeArguments::new(),\n+\t\t\t\tenvironment,\n+\t\t\t\t&mut crate::context::calling::Target::new_default(),\n+\t\t\t\t// TODO shouldn't be needed\n+\t\t\t\t&mut Default::default(),\n+\t\t\t\t&mut checking_data.types,\n+\t\t\t) {\n+\t\t\t\ttodo!()\n+\t\t\t}\n+\t\t}\n+\t\tIterationBehavior::ForIn { lhs, rhs } => {\n+\t\t\t// TODO for of Object.keys ???\n+\t\t\tlet on = A::synthesise_multiple_expression(\n+\t\t\t\trhs,\n+\t\t\t\tTypeId::ANY_TYPE,\n+\t\t\t\tenvironment,\n+\t\t\t\tchecking_data,\n+\t\t\t);\n+\n+\t\t\tlet ((), result, ..) = environment.new_lexical_environment_fold_into_parent(\n+\t\t\t\tScope::Looping { label },\n+\t\t\t\tchecking_data,\n+\t\t\t\t|environment, checking_data| {\n+\t\t\t\t\tloop_body(environment, checking_data);\n+\t\t\t\t},\n+\t\t\t);\n+\n+\t\t\tlet events = result.unwrap().0.events;\n+\n+\t\t\tif let Some(_value) = run_iteration_block(\n+\t\t\t\tIterationKind::Properties(on),\n+\t\t\t\tevents,\n+\t\t\t\tInitialVariablesInput::Compute,\n+\t\t\t\t&mut FunctionTypeArguments::new(),\n+\t\t\t\tenvironment,\n+\t\t\t\t&mut crate::context::calling::Target::new_default(),\n+\t\t\t\t// TODO shouldn't be needed\n+\t\t\t\t&mut Default::default(),\n+\t\t\t\t&mut checking_data.types,\n+\t\t\t) {\n+\t\t\t\ttodo!()\n+\t\t\t}\n+\t\t}\n+\t\tIterationBehavior::ForOf { lhs, rhs } => todo!(),\n+\t}\n+}\n+\n+pub enum InitialVariablesInput {\n+\tCalculated(InitialVariables),\n+\tCompute,\n+}\n+\n+#[derive(Debug, Clone, Copy, binary_serialize_derive::BinarySerializable)]\n+pub enum IterationKind {\n+\tCondition {\n+\t\t/// `Some` if under certain conditions it can evaluate the loop\n+\t\tunder: Option<LoopStructure>,\n+\t\t/// `true` for do-while loops\n+\t\tpostfix_condition: bool,\n+\t},\n+\tProperties(TypeId),\n+\tIterator(TypeId),\n+}\n+\n+#[allow(clippy::too_many_arguments)]\n+pub(crate) fn run_iteration_block(\n+\tcondition: IterationKind,\n+\tevents: Vec<Event>,\n+\tinitial: InitialVariablesInput,\n+\ttype_arguments: &mut FunctionTypeArguments,\n+\tenvironment: &mut Environment,\n+\ttarget: &mut Target,\n+\terrors: &mut ErrorsAndInfo,\n+\ttypes: &mut TypeStore,\n+) -> Option<EventResult> {\n+\t/// TODO via config\n+\tconst MAX_ITERATIONS: usize = 1000;\n+\n+\tmatch condition {\n+\t\tIterationKind::Condition { postfix_condition, under } => {\n+\t\t\t// let mut buf = String::new();\n+\t\t\t// crate::types::printing::debug_effects(\n+\t\t\t// \t&mut buf,\n+\t\t\t// \t&events,\n+\t\t\t// \t&checking_data.types,\n+\t\t\t// \t&environment.as_general_context(),\n+\t\t\t// \ttrue,\n+\t\t\t// );\n+\t\t\t// crate::utils::notify!(\"events in iteration = {}\", buf);\n+\n+\t\t\tlet non_exorbitant_amount_of_iterations = under\n+\t\t\t\t.and_then(|under| under.calculate_iterations(types).ok())\n+\t\t\t\t.and_then(|iterations| (iterations < MAX_ITERATIONS).then_some(iterations));\n+\n+\t\t\tif let Some(mut iterations) = non_exorbitant_amount_of_iterations {\n+\t\t\t\t// These bodies always run at least once. TODO is there a better way?\n+\t\t\t\tif postfix_condition {\n+\t\t\t\t\titerations += 1;\n+\t\t\t\t}\n+\n+\t\t\t\tcrate::utils::notify!(\n+\t\t\t\t\t\"Evaluating a constant amount of iterations {:?}\",\n+\t\t\t\t\titerations\n+\t\t\t\t);\n+\n+\t\t\t\tif let InitialVariablesInput::Calculated(initial) = initial {\n+\t\t\t\t\tfor (variable_id, initial_value) in &initial {\n+\t\t\t\t\t\ttarget\n+\t\t\t\t\t\t\t.get_latest_facts(environment)\n+\t\t\t\t\t\t\t.variable_current_value\n+\t\t\t\t\t\t\t.insert(*variable_id, *initial_value);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tcrate::utils::notify!(\"Here ??\");\n+\t\t\t\t}\n+\n+\t\t\t\tevaluate_iterations(\n+\t\t\t\t\titerations,\n+\t\t\t\t\t&events,\n+\t\t\t\t\ttype_arguments,\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\ttarget,\n+\t\t\t\t\terrors,\n+\t\t\t\t\ttypes,\n+\t\t\t\t)\n+\t\t\t} else {\n+\t\t\t\tlet initial = match initial {\n+\t\t\t\t\tInitialVariablesInput::Calculated(initial) => {\n+\t\t\t\t\t\tfor (id, value) in &initial {\n+\t\t\t\t\t\t\ttarget\n+\t\t\t\t\t\t\t\t.get_latest_facts(environment)\n+\t\t\t\t\t\t\t\t.variable_current_value\n+\t\t\t\t\t\t\t\t.insert(*id, *value);\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tinitial\n+\t\t\t\t\t}\n+\t\t\t\t\tInitialVariablesInput::Compute => {\n+\t\t\t\t\t\t// TODO maybe treat the same way as closures\n+\t\t\t\t\t\tlet mut initial = map_vec::Map::new();\n+\n+\t\t\t\t\t\tfor event in &events {\n+\t\t\t\t\t\t\t// TODO also nested events right?\n+\t\t\t\t\t\t\tif let Event::ReadsReference {\n+\t\t\t\t\t\t\t\treference: RootReference::Variable(variable_id),\n+\t\t\t\t\t\t\t\treflects_dependency: Some(free_variable_id),\n+\t\t\t\t\t\t\t\tposition,\n+\t\t\t\t\t\t\t} = event\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tlet value_before_iterations = get_value_of_variable(\n+\t\t\t\t\t\t\t\t\tenvironment.facts_chain(),\n+\t\t\t\t\t\t\t\t\t*variable_id,\n+\t\t\t\t\t\t\t\t\tNone::<&crate::types::poly_types::FunctionTypeArguments>,\n+\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t\t.unwrap();\n+\n+\t\t\t\t\t\t\t\tcrate::utils::notify!(\n+\t\t\t\t\t\t\t\t\t\"setting '{}' to have initial type {}\",\n+\t\t\t\t\t\t\t\t\tenvironment.get_variable_name(*variable_id),\n+\t\t\t\t\t\t\t\t\tprint_type(\n+\t\t\t\t\t\t\t\t\t\tvalue_before_iterations,\n+\t\t\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\t\t\t&environment.as_general_context(),\n+\t\t\t\t\t\t\t\t\t\ttrue\n+\t\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t\t\tinitial.insert(*variable_id, value_before_iterations);\n+\n+\t\t\t\t\t\t\t\tenvironment\n+\t\t\t\t\t\t\t\t\t.facts\n+\t\t\t\t\t\t\t\t\t.variable_current_value\n+\t\t\t\t\t\t\t\t\t.insert(*variable_id, *free_variable_id);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tinitial\n+\t\t\t\t\t}\n+\t\t\t\t};\n+\n+\t\t\t\tcrate::utils::notify!(\"Saving events\");\n+\n+\t\t\t\ttarget.get_latest_facts(environment).events.push(Event::Iterate {\n+\t\t\t\t\tkind: IterationKind::Condition { under, postfix_condition },\n+\t\t\t\t\tinitial,\n+\t\t\t\t\titerate_over: events.into_boxed_slice(),\n+\t\t\t\t});\n+\n+\t\t\t\t// TODO can skip if at the end of a function\n+\t\t\t\t// for event in events {\n+\t\t\t\t// \tlet result = apply_event_unknown(\n+\t\t\t\t// \t\tevent,\n+\t\t\t\t// \t\tcrate::behavior::functions::ThisValue::UseParent,\n+\t\t\t\t// \t\t&mut arguments,\n+\t\t\t\t// \t\tenvironment,\n+\t\t\t\t// \t\t&mut crate::context::calling::Target::new_default(),\n+\t\t\t\t// \t\t&mut checking_data.types,\n+\t\t\t\t// \t);\n+\t\t\t\t// }\n+\t\t\t\tNone\n+\t\t\t}\n+\t\t}\n+\t\tIterationKind::Properties(on) => {\n+\t\t\tif let Type::Object(ObjectNature::RealDeal) = types.get_type_by_id(on) {\n+\t\t\t\tfor (publicity, property, _value) in environment.get_properties_on_type(on) {\n+\t\t\t\t\t// TODO enumerable\n+\t\t\t\t\tcrate::utils::notify!(\"Property: {:?}\", property);\n+\t\t\t\t}\n+\t\t\t\tNone\n+\t\t\t} else {\n+\t\t\t\ttodo!(\"dependent in\")\n+\t\t\t}\n+\t\t}\n+\t\tIterationKind::Iterator(_) => todo!(),\n+\t}\n+}\n+\n+#[must_use]\n+fn evaluate_iterations(\n+\titerations: usize,\n+\tevents: &[Event],\n+\targuments: &mut FunctionTypeArguments,\n+\tenvironment: &mut Environment,\n+\ttarget: &mut Target,\n+\terrors: &mut ErrorsAndInfo,\n+\ttypes: &mut TypeStore,\n+) -> Option<EventResult> {\n+\t// TODO temp fix\n+\tif !errors.errors.is_empty() {\n+\t\treturn None;\n+\t}\n+\n+\t'main_iterations: for _ in 0..iterations {\n+\t\t'inner_loop: for event in events {\n+\t\t\tlet result = apply_event(\n+\t\t\t\tevent.clone(),\n+\t\t\t\tcrate::behavior::functions::ThisValue::UseParent,\n+\t\t\t\targuments,\n+\t\t\t\tenvironment,\n+\t\t\t\t// TODO new nested target\n+\t\t\t\ttarget,\n+\t\t\t\ttypes,\n+\t\t\t\t// Shouldn't matter\n+\t\t\t\terrors,\n+\t\t\t);\n+\n+\t\t\tif !errors.errors.is_empty() {\n+\t\t\t\tunreachable!(\"errors when calling loop\")\n+\t\t\t}\n+\n+\t\t\tif let Some(result) = result {\n+\t\t\t\tmatch result {\n+\t\t\t\t\tEventResult::Continue { carry: 0 } => {\n+\t\t\t\t\t\tbreak 'inner_loop;\n+\t\t\t\t\t}\n+\t\t\t\t\tEventResult::Break { carry: 0 } => {\n+\t\t\t\t\t\tbreak 'main_iterations;\n+\t\t\t\t\t}\n+\t\t\t\t\tEventResult::Continue { carry } => {\n+\t\t\t\t\t\treturn Some(EventResult::Continue { carry: carry - 1 })\n+\t\t\t\t\t}\n+\t\t\t\t\tEventResult::Break { carry } => {\n+\t\t\t\t\t\treturn Some(EventResult::Break { carry: carry - 1 })\n+\t\t\t\t\t}\n+\t\t\t\t\te @ (EventResult::Return(..) | EventResult::Throw) => return Some(e),\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tNone\n+}\n+\n+/// Denotes values at the end of a loop\n+/// TODO Cow\n+struct Values {\n+\tpub variable_values: HashMap<VariableId, TypeId>,\n+\tpub properties_values: HashMap<\n+\t\tTypeId,\n+\t\tVec<(\n+\t\t\tcrate::context::facts::Publicity,\n+\t\t\tcrate::types::properties::PropertyKey<'static>,\n+\t\t\tcrate::PropertyValue,\n+\t\t)>,\n+\t>,\n+}\n+\n+/// Not quite a \"Hoare triple\"\n+#[derive(Debug, Clone, Copy, binary_serialize_derive::BinarySerializable)]\n+pub struct LoopStructure {\n+\tpub start: TypeId,\n+\tpub increment_by: TypeId,\n+\tpub roof: TypeId,\n+}\n+\n+impl LoopStructure {\n+\tpub(crate) fn specialise<T: TypeArgumentStore>(\n+\t\tself,\n+\t\targuments: &mut T,\n+\t\t// TODO temp\n+\t\tenvironment: &mut Environment,\n+\t\ttypes: &mut TypeStore,\n+\t) -> Self {\n+\t\tSelf {\n+\t\t\tstart: substitute(self.start, arguments, environment, types),\n+\t\t\tincrement_by: substitute(self.increment_by, arguments, environment, types),\n+\t\t\troof: substitute(self.roof, arguments, environment, types),\n+\t\t}\n+\t}\n+\n+\tpub fn calculate_iterations(self, types: &TypeStore) -> Result<usize, Self> {\n+\t\tlet values = (\n+\t\t\ttypes.get_type_by_id(self.start),\n+\t\t\ttypes.get_type_by_id(self.increment_by),\n+\t\t\ttypes.get_type_by_id(self.roof),\n+\t\t);\n+\n+\t\tif let (\n+\t\t\tType::Constant(Constant::Number(start)),\n+\t\t\tType::Constant(Constant::Number(increments_by)),\n+\t\t\tType::Constant(Constant::Number(roof)),\n+\t\t) = values\n+\t\t{\n+\t\t\tlet iterations = (roof - start) / increments_by;\n+\t\t\t// crate::utils::notify!(\n+\t\t\t// \t\"Evaluating iteration: start={}, end={}, increment={}, iterations={}\",\n+\t\t\t// \tstart,\n+\t\t\t// \tend,\n+\t\t\t// \tincrement,\n+\t\t\t// \titerations\n+\t\t\t// );\n+\t\t\tOk(iterations.ceil() as usize)\n+\t\t} else {\n+\t\t\tcrate::utils::notify!(\"Iterations was {:?}\", values);\n+\t\t\tErr(self)\n+\t\t}\n+\t}\n+}\n+\n+fn calculate_result_of_loop(\n+\tcondition: TypeId,\n+\tloop_variables: Option<&HashMap<VariableId, (TypeId, TypeId)>>,\n+\tparent_environment: &Environment,\n+\ttypes: &TypeStore,\n+\tinside_loop: &Values,\n+) -> Result<LoopStructure, ()> {\n+\tlet condition_ty = types.get_type_by_id(condition);\n+\n+\tcrate::utils::notify!(\"condition is {:?}\", condition_ty);\n+\n+\t// TODO some other cases\n+\t// - and for less than equal\n+\tif let Type::Constructor(Constructor::CanonicalRelationOperator {\n+\t\tlhs: less_than_reference_type_id,\n+\t\toperator: CanonicalEqualityAndInequality::LessThan,\n+\t\trhs: roof,\n+\t}) = condition_ty\n+\t{\n+\t\t// TODO sort by constant. Assumed here that dependent is on the LHS\n+\n+\t\tlet reference_ty = types.get_type_by_id(*less_than_reference_type_id);\n+\t\t// TODO what about properties etc\n+\t\tif let Type::RootPolyType(PolyNature::FreeVariable {\n+\t\t\treference: less_than_reference,\n+\t\t\tbased_on,\n+\t\t}) = reference_ty\n+\t\t{\n+\t\t\tif let RootReference::Variable(possible_changing_variable_id) = less_than_reference {\n+\t\t\t\tlet roof_ty = types.get_type_by_id(*roof);\n+\t\t\t\t// TODO temp\n+\t\t\t\tlet roof: TypeId = if let Type::RootPolyType(PolyNature::FreeVariable {\n+\t\t\t\t\treference: RootReference::Variable(roof_id),\n+\t\t\t\t\tbased_on,\n+\t\t\t\t}) = roof_ty\n+\t\t\t\t{\n+\t\t\t\t\tlet changed = if let Some((_start, end)) =\n+\t\t\t\t\t\tloop_variables.as_ref().and_then(|vs| vs.get(roof_id).copied())\n+\t\t\t\t\t{\n+\t\t\t\t\t\tcrate::utils::notify!(\"Found loop variables\");\n+\t\t\t\t\t\tfalse\n+\t\t\t\t\t} else if let Some(inside) = inside_loop.variable_values.get(roof_id) {\n+\t\t\t\t\t\tcrate::utils::notify!(\n+\t\t\t\t\t\t\t\"Found loop here {:?}\",\n+\t\t\t\t\t\t\ttypes.get_type_by_id(*inside)\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\tfalse\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tcrate::utils::notify!(\"Here, roof not changed\");\n+\t\t\t\t\t\ttrue\n+\t\t\t\t\t};\n+\n+\t\t\t\t\tif changed {\n+\t\t\t\t\t\tif let Some((_start, end)) =\n+\t\t\t\t\t\t\tloop_variables.as_ref().and_then(|vs| vs.get(roof_id).copied())\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tend\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t*parent_environment.facts.variable_current_value.get(roof_id).unwrap()\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tcrate::utils::notify!(\"Roof changed in loop\");\n+\t\t\t\t\t\treturn Err(());\n+\t\t\t\t\t}\n+\t\t\t\t} else if let Type::Constant(_) = roof_ty {\n+\t\t\t\t\t*roof\n+\t\t\t\t} else {\n+\t\t\t\t\treturn Err(());\n+\t\t\t\t};\n+\n+\t\t\t\tlet value_after_running_expressions_in_loop = types.get_type_by_id(\n+\t\t\t\t\tif let Some((_start, end)) = loop_variables\n+\t\t\t\t\t\t.as_ref()\n+\t\t\t\t\t\t.and_then(|vs| vs.get(possible_changing_variable_id).copied())\n+\t\t\t\t\t{\n+\t\t\t\t\t\tend\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t*inside_loop.variable_values.get(possible_changing_variable_id).unwrap()\n+\t\t\t\t\t},\n+\t\t\t\t);\n+\n+\t\t\t\t// crate::utils::notify!(\n+\t\t\t\t// \t\"incremented is {:?}\",\n+\t\t\t\t// \tvalue_after_running_expressions_in_loop\n+\t\t\t\t// );\n+\n+\t\t\t\t// Looking at incrementor\n+\t\t\t\tif let Type::Constructor(Constructor::BinaryOperator {\n+\t\t\t\t\tlhs: assignment,\n+\t\t\t\t\toperator,\n+\t\t\t\t\trhs: increments_by,\n+\t\t\t\t}) = value_after_running_expressions_in_loop\n+\t\t\t\t{\n+\t\t\t\t\tdebug_assert!(\n+\t\t\t\t\t\tassignment == less_than_reference_type_id,\n+\t\t\t\t\t\t\"incrementor not the same as condition?\"\n+\t\t\t\t\t);\n+\n+\t\t\t\t\tlet start = if let Some((start, _end)) = loop_variables\n+\t\t\t\t\t\t.as_ref()\n+\t\t\t\t\t\t.and_then(|vs| vs.get(possible_changing_variable_id).copied())\n+\t\t\t\t\t{\n+\t\t\t\t\t\tstart\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// let id = if let RootReference::Variable(id) = reference {\n+\t\t\t\t\t\t// \tid\n+\t\t\t\t\t\t// } else {\n+\t\t\t\t\t\t// \tunreachable!(\"this\")\n+\t\t\t\t\t\t// };\n+\t\t\t\t\t\t*parent_environment\n+\t\t\t\t\t\t\t.facts\n+\t\t\t\t\t\t\t.variable_current_value\n+\t\t\t\t\t\t\t.get(possible_changing_variable_id)\n+\t\t\t\t\t\t\t.unwrap()\n+\t\t\t\t\t};\n+\n+\t\t\t\t\treturn Ok(LoopStructure { start, roof, increment_by: *increments_by });\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tcrate::utils::notify!(\"{:?} has no max\", roof);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tcrate::utils::notify!(\"LHS {:?} is not free variable \", reference_ty);\n+\t\t}\n+\t}\n+\tErr(())\n+}\ndiff --git a/checker/src/context/calling.rs b/checker/src/context/calling.rs\n--- a/checker/src/context/calling.rs\n+++ b/checker/src/context/calling.rs\n@@ -1,12 +1,12 @@\n use super::facts::Facts;\n-use crate::{events::EarlyReturn, Environment, FunctionId};\n+use crate::{events::EventResult, Environment, FunctionId};\n \n /// For anything that might involve a call, including gets, sets and actual calls\n pub(crate) trait CallCheckingBehavior {\n \t// TODO\n \tconst CHECK_PARAMETERS: bool;\n \n-\tfn get_top_level_facts<'a>(&'a mut self, environment: &'a mut Environment) -> &'a mut Facts;\n+\tfn get_latest_facts<'a>(&'a mut self, environment: &'a mut Environment) -> &'a mut Facts;\n \n \tfn in_recursive_cycle(&self, function_id: FunctionId) -> bool;\n \ndiff --git a/checker/src/context/calling.rs b/checker/src/context/calling.rs\n--- a/checker/src/context/calling.rs\n+++ b/checker/src/context/calling.rs\n@@ -22,7 +22,7 @@ pub struct CheckThings;\n impl CallCheckingBehavior for CheckThings {\n \tconst CHECK_PARAMETERS: bool = true;\n \n-\tfn get_top_level_facts<'a>(&'a mut self, environment: &'a mut Environment) -> &'a mut Facts {\n+\tfn get_latest_facts<'a>(&'a mut self, environment: &'a mut Environment) -> &'a mut Facts {\n \t\t&mut environment.facts\n \t}\n \ndiff --git a/checker/src/context/calling.rs b/checker/src/context/calling.rs\n--- a/checker/src/context/calling.rs\n+++ b/checker/src/context/calling.rs\n@@ -55,7 +51,7 @@ pub(crate) enum TargetKind {\n impl CallCheckingBehavior for Target {\n \tconst CHECK_PARAMETERS: bool = false;\n \n-\tfn get_top_level_facts<'b>(&'b mut self, environment: &'b mut Environment) -> &'b mut Facts {\n+\tfn get_latest_facts<'b>(&'b mut self, environment: &'b mut Environment) -> &'b mut Facts {\n \t\tself.0\n \t\t\t.iter_mut()\n \t\t\t.rev()\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -49,7 +67,7 @@ pub(crate) fn apply_event(\n \n \t\t\t// if not closed over!!\n \t\t\t// TODO temp assigns to many contexts, which is bad\n-\t\t\tlet facts = target.get_top_level_facts(environment);\n+\t\t\tlet facts = target.get_latest_facts(environment);\n \t\t\tfor closure_id in type_arguments\n \t\t\t\t.closure_id\n \t\t\t\t.iter()\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -141,19 +155,38 @@ pub(crate) fn apply_event(\n \t\t\t\t\t\ton\n \t\t\t\t\t};\n \t\t\t\ttarget\n-\t\t\t\t\t.get_top_level_facts(environment)\n+\t\t\t\t\t.get_latest_facts(environment)\n \t\t\t\t\t.register_property(on, publicity, under, new, true, position);\n \t\t\t} else {\n-\t\t\t\tlet returned =\n-\t\t\t\t\tset_property(on, publicity, &under, &new, environment, target, types, position)\n-\t\t\t\t\t\t.unwrap();\n-\n-\t\t\t\tif let Some(id) = reflects_dependency {\n-\t\t\t\t\ttype_arguments.set_id_from_reference(\n-\t\t\t\t\t\tid,\n-\t\t\t\t\t\treturned.unwrap_or(TypeId::UNDEFINED_TYPE),\n-\t\t\t\t\t\ttypes,\n-\t\t\t\t\t);\n+\t\t\t\tlet result =\n+\t\t\t\t\tset_property(on, publicity, &under, &new, environment, target, types, position);\n+\n+\t\t\t\tif let Err(err) = result {\n+\t\t\t\t\tif let SetPropertyError::DoesNotMeetConstraint { property_constraint, reason } =\n+\t\t\t\t\t\terr\n+\t\t\t\t\t{\n+\t\t\t\t\t\tlet value_type = if let PropertyValue::Value(id) = new {\n+\t\t\t\t\t\t\tTypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\tid,\n+\t\t\t\t\t\t\t\t&environment.as_general_context(),\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\ttodo!()\n+\t\t\t\t\t\t};\n+\n+\t\t\t\t\t\terrors.errors.push(\n+\t\t\t\t\t\t\tcrate::types::calling::FunctionCallingError::SetPropertyConstraint {\n+\t\t\t\t\t\t\t\tproperty_type: property_constraint,\n+\t\t\t\t\t\t\t\tvalue_type,\n+\t\t\t\t\t\t\t\tassignment_position: position.unwrap(),\n+\t\t\t\t\t\t\t\tcall_site: None,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tunreachable!()\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -224,22 +260,30 @@ pub(crate) fn apply_event(\n \t\tEvent::Throw(thrown, position) => {\n \t\t\tlet substituted_thrown = substitute(thrown, type_arguments, environment, types);\n \n-\t\t\ttarget.get_top_level_facts(environment).throw_value(substituted_thrown, position);\n+\t\t\ttarget.get_latest_facts(environment).throw_value(substituted_thrown, position);\n \n-\t\t\tif substituted_thrown != TypeId::ERROR_TYPE {\n-\t\t\t\treturn None;\n-\t\t\t}\n+\t\t\t// TODO write down why result isn't added here\n+\t\t\treturn Some(EventResult::Throw);\n \t\t}\n \t\t// TODO extract\n \t\tEvent::Conditionally { condition, events_if_truthy, else_events, position } => {\n \t\t\tlet condition = substitute(condition, type_arguments, environment, types);\n \n-\t\t\tif let Decidable::Known(result) = is_type_truthy_falsy(condition, types) {\n+\t\t\tlet result = is_type_truthy_falsy(condition, types);\n+\t\t\t// crate::utils::notify!(\"Condition {:?}\", result);\n+\n+\t\t\tif let Decidable::Known(result) = result {\n \t\t\t\tlet to_evaluate = if result { events_if_truthy } else { else_events };\n \t\t\t\tfor event in to_evaluate.iter().cloned() {\n-\t\t\t\t\tif let Some(early) =\n-\t\t\t\t\t\tapply_event(event, this_value, type_arguments, environment, target, types)\n-\t\t\t\t\t{\n+\t\t\t\t\tif let Some(early) = apply_event(\n+\t\t\t\t\t\tevent,\n+\t\t\t\t\t\tthis_value,\n+\t\t\t\t\t\ttype_arguments,\n+\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\ttarget,\n+\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\terrors,\n+\t\t\t\t\t) {\n \t\t\t\t\t\treturn Some(early);\n \t\t\t\t\t}\n \t\t\t\t}\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -289,7 +335,7 @@ pub(crate) fn apply_event(\n \t\t\t\t// - variable and property values (these aren't read from events)\n \t\t\t\t// - immutable, mutable, prototypes etc\n \t\t\t\t// }\n-\t\t\t\tlet facts = target.get_top_level_facts(environment);\n+\t\t\t\tlet facts = target.get_latest_facts(environment);\n \t\t\t\tfor (var, truth) in truthy_facts.variable_current_value {\n \t\t\t\t\tlet entry = facts.variable_current_value.entry(var);\n \t\t\t\t\tentry.and_modify(|existing| {\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -301,7 +347,7 @@ pub(crate) fn apply_event(\n \t\t\t\t\t});\n \t\t\t\t}\n \n-\t\t\t\ttarget.get_top_level_facts(environment).events.push(Event::Conditionally {\n+\t\t\t\ttarget.get_latest_facts(environment).events.push(Event::Conditionally {\n \t\t\t\t\tcondition,\n \t\t\t\t\tevents_if_truthy: truthy_facts.events.into_boxed_slice(),\n \t\t\t\t\telse_events: else_facts.events.into_boxed_slice(),\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -311,47 +357,158 @@ pub(crate) fn apply_event(\n \t\t}\n \t\tEvent::Return { returned, returned_position } => {\n \t\t\tlet substituted_returned = substitute(returned, type_arguments, environment, types);\n-\t\t\tif substituted_returned != TypeId::ERROR_TYPE {\n-\t\t\t\treturn Some(substituted_returned);\n-\t\t\t}\n-\n-\t\t\tcrate::utils::notify!(\"event returned error so skipped\");\n+\t\t\treturn Some(EventResult::Return(substituted_returned, returned_position));\n \t\t}\n \t\t// TODO Needs a position (or not?)\n-\t\tEvent::CreateObject { referenced_in_scope_as, prototype, position } => {\n+\t\tEvent::CreateObject { referenced_in_scope_as, prototype, position, is_function_this } => {\n+\t\t\t// TODO\n \t\t\tlet is_under_dyn = true;\n \n \t\t\tlet new_object_id = match prototype {\n \t\t\t\tPrototypeArgument::Yeah(prototype) => {\n \t\t\t\t\tlet prototype = substitute(prototype, type_arguments, environment, types);\n-\t\t\t\t\ttarget.get_top_level_facts(environment).new_object(\n+\t\t\t\t\ttarget.get_latest_facts(environment).new_object(\n \t\t\t\t\t\tSome(prototype),\n \t\t\t\t\t\ttypes,\n \t\t\t\t\t\tis_under_dyn,\n+\t\t\t\t\t\tis_function_this,\n \t\t\t\t\t)\n \t\t\t\t}\n-\t\t\t\tPrototypeArgument::None => {\n-\t\t\t\t\ttarget.get_top_level_facts(environment).new_object(None, types, is_under_dyn)\n-\t\t\t\t}\n+\t\t\t\tPrototypeArgument::None => target.get_latest_facts(environment).new_object(\n+\t\t\t\t\tNone,\n+\t\t\t\t\ttypes,\n+\t\t\t\t\tis_under_dyn,\n+\t\t\t\t\tis_function_this,\n+\t\t\t\t),\n \t\t\t\tPrototypeArgument::Function(id) => {\n \t\t\t\t\ttypes.register_type(crate::Type::Function(id, this_value))\n \t\t\t\t}\n \t\t\t};\n \n \t\t\t// TODO conditionally if any properties are structurally generic\n-\t\t\tlet new_object_id_with_curried_arguments =\n-\t\t\t\tcurry_arguments(type_arguments, types, new_object_id);\n+\t\t\t// let new_object_id_with_curried_arguments =\n+\t\t\t// \tcurry_arguments(type_arguments, types, new_object_id);\n+\n+\t\t\t// crate::utils::notify!(\n+\t\t\t// \t\"Setting {:?} to {:?}\",\n+\t\t\t// \treferenced_in_scope_as,\n+\t\t\t// \tnew_object_id_with_curried_arguments\n+\t\t\t// );\n \n-\t\t\ttype_arguments.set_id_from_reference(\n-\t\t\t\treferenced_in_scope_as,\n-\t\t\t\tnew_object_id_with_curried_arguments,\n+\t\t\ttype_arguments.set_id_from_reference(referenced_in_scope_as, new_object_id);\n+\t\t}\n+\t\tEvent::Break { position, carry } => return Some(EventResult::Break { carry }),\n+\t\tEvent::Continue { position, carry } => return Some(EventResult::Continue { carry }),\n+\t\tEvent::Iterate { kind, iterate_over, initial } => {\n+\t\t\t// TODO this might clash\n+\t\t\tlet initial = initial\n+\t\t\t\t.into_iter()\n+\t\t\t\t.map(|(id, value)| (id, substitute(value, type_arguments, environment, types)))\n+\t\t\t\t.collect();\n+\n+\t\t\tlet kind = match kind {\n+\t\t\t\tIterationKind::Condition { under, postfix_condition } => IterationKind::Condition {\n+\t\t\t\t\tunder: under.map(|under| under.specialise(type_arguments, environment, types)),\n+\t\t\t\t\tpostfix_condition,\n+\t\t\t\t},\n+\t\t\t\tIterationKind::Properties(on) => {\n+\t\t\t\t\tIterationKind::Properties(substitute(on, type_arguments, environment, types))\n+\t\t\t\t}\n+\t\t\t\tIterationKind::Iterator(on) => {\n+\t\t\t\t\tIterationKind::Iterator(substitute(on, type_arguments, environment, types))\n+\t\t\t\t}\n+\t\t\t};\n+\n+\t\t\tlet early_result = iteration::run_iteration_block(\n+\t\t\t\tkind,\n+\t\t\t\titerate_over.to_vec(),\n+\t\t\t\titeration::InitialVariablesInput::Calculated(initial),\n+\t\t\t\ttype_arguments,\n+\t\t\t\tenvironment,\n+\t\t\t\ttarget,\n+\t\t\t\terrors,\n \t\t\t\ttypes,\n \t\t\t);\n+\n+\t\t\tif let Some(early_result) = early_result {\n+\t\t\t\t// crate::utils::notify!(\"got out {:?}\", early_result);\n+\t\t\t\treturn Some(early_result);\n+\t\t\t}\n \t\t}\n-\t\t// TODO\n-\t\tEvent::Break { position } => {}\n-\t\t// TODO\n-\t\tEvent::Continue { position } => {}\n \t}\n \tNone\n }\n+\n+// /// For loops and recursion\n+// pub(crate) fn apply_event_unknown(\n+// \tevent: Event,\n+// \tthis_value: ThisValue,\n+// \ttype_arguments: &mut FunctionTypeArguments,\n+// \tenvironment: &mut Environment,\n+// \ttarget: &mut Target,\n+// \ttypes: &mut TypeStore,\n+// ) {\n+// \tmatch event {\n+// \t\t// TODO maybe mark as read\n+// \t\tEvent::ReadsReference { .. } => {}\n+// \t\tEvent::Getter { on, under, reflects_dependency, publicity, position } => {\n+// \t\t\tcrate::utils::notify!(\"Run getters\");\n+// \t\t}\n+// \t\tEvent::SetsVariable(variable, value, _) => {\n+// \t\t\tlet new_value = get_constraint(value, types)\n+// \t\t\t\t.map(|value| {\n+// \t\t\t\t\ttypes.register_type(Type::RootPolyType(crate::types::PolyNature::Open(value)))\n+// \t\t\t\t})\n+// \t\t\t\t.unwrap_or(value);\n+// \t\t\tenvironment.facts.variable_current_value.insert(variable, new_value);\n+// \t\t}\n+// \t\tEvent::Setter { on, under, new, initialization, publicity, position } => {\n+// \t\t\tlet on = substitute(on, type_arguments, environment, types);\n+// \t\t\tlet new_value = match new {\n+// \t\t\t\tPropertyValue::Value(new) => {\n+// \t\t\t\t\tlet new = get_constraint(new, types)\n+// \t\t\t\t\t\t.map(|value| {\n+// \t\t\t\t\t\t\ttypes.register_type(Type::RootPolyType(crate::types::PolyNature::Open(\n+// \t\t\t\t\t\t\t\tvalue,\n+// \t\t\t\t\t\t\t)))\n+// \t\t\t\t\t\t})\n+// \t\t\t\t\t\t.unwrap_or(new);\n+// \t\t\t\t\tPropertyValue::Value(new)\n+// \t\t\t\t}\n+// \t\t\t\tPropertyValue::Getter(_) | PropertyValue::Setter(_) | PropertyValue::Deleted => new,\n+// \t\t\t};\n+// \t\t\tmatch under {\n+// \t\t\t\tcrate::types::properties::PropertyKey::String(_) => {\n+// \t\t\t\t\tenvironment\n+// \t\t\t\t\t\t.facts\n+// \t\t\t\t\t\t.register_property(on, publicity, under, new_value, false, position);\n+// \t\t\t\t}\n+// \t\t\t\tcrate::types::properties::PropertyKey::Type(_) => todo!(),\n+// \t\t\t}\n+// \t\t}\n+// \t\tEvent::CallsType { on, with, reflects_dependency, timing, called_with_new, position } => {\n+// \t\t\ttodo!()\n+// \t\t}\n+// \t\tEvent::Throw(_, _) => todo!(),\n+// \t\tEvent::Conditionally { condition, events_if_truthy, else_events, position } => {\n+// \t\t\t// TODO think this is correct...?\n+// \t\t\tfor event in events_if_truthy.into_vec() {\n+// \t\t\t\tapply_event_unknown(event, this_value, type_arguments, environment, target, types)\n+// \t\t\t}\n+// \t\t\tfor event in else_events.into_vec() {\n+// \t\t\t\tapply_event_unknown(event, this_value, type_arguments, environment, target, types)\n+// \t\t\t}\n+// \t\t}\n+// \t\tEvent::Return { returned, returned_position } => todo!(),\n+// \t\tEvent::CreateObject { prototype, referenced_in_scope_as, position, is_function_this } => {\n+// \t\t\ttodo!()\n+// \t\t}\n+// \t\tEvent::Break { position, carry } => {\n+// \t\t\t// TODO conditionally\n+// \t\t}\n+// \t\tEvent::Continue { position, carry } => {\n+// \t\t\t// TODO conditionally\n+// \t\t}\n+// \t\tEvent::Iterate { .. } => todo!(),\n+// \t}\n+// }\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -232,79 +233,117 @@ fn create_generic_function_call<E: CallCheckingBehavior>(\n \tCallingInput { called_with_new, this_value, call_site_type_arguments, call_site }: CallingInput,\n \targuments: Vec<SynthesisedArgument>,\n \ton: TypeId,\n-\tenvironment: &mut Environment,\n+\ttop_environment: &mut Environment,\n \tbehavior: &mut E,\n \ttypes: &mut TypeStore,\n ) -> Result<FunctionCallResult, Vec<FunctionCallingError>> {\n+\tcrate::utils::notify!(\"On {:?}\", types.get_type_by_id(constraint));\n+\n \tlet result = call_type(\n \t\tconstraint,\n \t\tCallingInput { called_with_new, this_value, call_site_type_arguments, call_site },\n \t\t// TODO clone\n \t\targuments.clone(),\n-\t\tenvironment,\n+\t\ttop_environment,\n \t\tbehavior,\n \t\ttypes,\n \t)?;\n \n+\tcrate::utils::notify!(\"Got {:?} out\", result.returned_type);\n+\n+\t// TODO can skip for pure functions (or open polys) and references that aren't used later\n+\tfor argument in &arguments {\n+\t\t// TODO need to do in a function\n+\t\t// All properties\n+\t\t// Functions free variables etc\n+\t\tmatch argument {\n+\t\t\tSynthesisedArgument::NonSpread { ty, position } => {\n+\t\t\t\tmatch types.get_type_by_id(*ty) {\n+\t\t\t\t\tType::Interface { .. }\n+\t\t\t\t\t| Type::AliasTo { .. }\n+\t\t\t\t\t| Type::And(_, _)\n+\t\t\t\t\t| Type::Object(ObjectNature::AnonymousTypeAnnotation)\n+\t\t\t\t\t| Type::FunctionReference(_, _)\n+\t\t\t\t\t| Type::Or(_, _) => {\n+\t\t\t\t\t\tcrate::utils::notify!(\"Unreachable\");\n+\t\t\t\t\t}\n+\t\t\t\t\tType::Constant(_) => {}\n+\t\t\t\t\tType::RootPolyType(_) | Type::Constructor(_) => {\n+\t\t\t\t\t\t// All dependent anyway\n+\t\t\t\t\t\tcrate::utils::notify!(\"TODO if any properties set etc\");\n+\t\t\t\t\t}\n+\t\t\t\t\tType::Function(_, _) => {\n+\t\t\t\t\t\tcrate::utils::notify!(\"TODO record that function could be called\");\n+\t\t\t\t\t}\n+\t\t\t\t\tType::Object(ObjectNature::RealDeal) => {\n+\t\t\t\t\t\ttop_environment.possibly_mutated_objects.insert(*ty);\n+\t\t\t\t\t\tcrate::utils::notify!(\"TODO record methods could be called here as well\");\n+\t\t\t\t\t}\n+\t\t\t\t\tType::SpecialObject(_) => {\n+\t\t\t\t\t\tcrate::utils::notify!(\"TODO record stuff if mutable\");\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tlet with = arguments.into_boxed_slice();\n \n-\t// TODO work this out\n-\tlet is_open_poly = false;\n+\t// Skip constant returned reflects types\n+\tif is_type_constant(result.returned_type, types) {\n+\t\tcrate::utils::notify!(\"Adding calls type here\");\n \n-\tlet reflects_dependency = if is_open_poly {\n-\t\tNone\n+\t\tbehavior.get_latest_facts(top_environment).events.push(Event::CallsType {\n+\t\t\ton,\n+\t\t\twith,\n+\t\t\ttiming: crate::events::CallingTiming::Synchronous,\n+\t\t\tcalled_with_new, // Don't care about output.\n+\t\t\treflects_dependency: None,\n+\t\t\tposition: call_site,\n+\t\t});\n+\n+\t\tOk(result)\n \t} else {\n-\t\t// Skip constant types\n-\t\tif matches!(result.returned_type, TypeId::UNDEFINED_TYPE | TypeId::NULL_TYPE)\n-\t\t\t|| matches!(\n-\t\t\t\ttypes.get_type_by_id(result.returned_type),\n-\t\t\t\tType::Constant(..)\n-\t\t\t\t\t| Type::Object(super::ObjectNature::RealDeal)\n-\t\t\t\t\t| Type::SpecialObject(..)\n-\t\t\t) {\n-\t\t\t// TODO nearest fact\n-\t\t\tenvironment.facts.events.push(Event::CallsType {\n+\t\t// TODO work this out\n+\t\tlet is_open_poly = false;\n+\n+\t\tlet reflects_dependency = if is_open_poly {\n+\t\t\tNone\n+\t\t} else {\n+\t\t\tlet constructor = Constructor::Image {\n+\t\t\t\t// TODO on or to\n+\t\t\t\ton,\n+\t\t\t\twith: with.clone(),\n+\t\t\t\t// TODO unwrap\n+\t\t\t\tresult: result.returned_type,\n+\t\t\t};\n+\n+\t\t\tlet constructor_return = types.register_type(Type::Constructor(constructor));\n+\n+\t\t\tSome(constructor_return)\n+\t\t};\n+\n+\t\t// Event already added if dependent argument\n+\t\tif !result.found_dependent_argument {\n+\t\t\tbehavior.get_latest_facts(top_environment).events.push(Event::CallsType {\n \t\t\t\ton,\n \t\t\t\twith,\n \t\t\t\ttiming: crate::events::CallingTiming::Synchronous,\n-\t\t\t\tcalled_with_new, // Don't care about output.\n-\t\t\t\treflects_dependency: None,\n+\t\t\t\tcalled_with_new,\n+\t\t\t\treflects_dependency,\n \t\t\t\tposition: call_site,\n \t\t\t});\n-\n-\t\t\treturn Ok(result);\n \t\t}\n \n-\t\tlet constructor = Constructor::FunctionResult {\n-\t\t\t// TODO on or to\n-\t\t\ton,\n-\t\t\twith: with.clone(),\n-\t\t\t// TODO unwrap\n-\t\t\tresult: result.returned_type,\n-\t\t};\n-\n-\t\tlet constructor_return = types.register_type(Type::Constructor(constructor));\n-\n-\t\tSome(constructor_return)\n-\t};\n-\n-\t// TODO nearest fact\n-\tenvironment.facts.events.push(Event::CallsType {\n-\t\ton,\n-\t\twith,\n-\t\ttiming: crate::events::CallingTiming::Synchronous,\n-\t\tcalled_with_new,\n-\t\treflects_dependency,\n-\t\tposition: call_site,\n-\t});\n-\n-\t// TODO should wrap result in open poly\n-\tOk(FunctionCallResult {\n-\t\tcalled: result.called,\n-\t\treturned_type: reflects_dependency.unwrap_or(result.returned_type),\n-\t\twarnings: result.warnings,\n-\t\tspecial: None,\n-\t})\n+\t\t// TODO should wrap result in open poly\n+\t\tOk(FunctionCallResult {\n+\t\t\tcalled: result.called,\n+\t\t\treturned_type: reflects_dependency.unwrap_or(result.returned_type),\n+\t\t\twarnings: result.warnings,\n+\t\t\tspecial: None,\n+\t\t\tfound_dependent_argument: result.found_dependent_argument,\n+\t\t})\n+\t}\n }\n \n /// Errors from trying to call a function\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -450,42 +512,46 @@ impl FunctionType {\n \t\t\t\t\t}\n \t\t\t\t\tErr(ConstantFunctionError::BadCall) => {\n \t\t\t\t\t\tcrate::utils::notify!(\n-\t\t\t\t\t\t\t\"Constant function calling failed, not constant params\"\n+\t\t\t\t\t\t\t\"Constant function calling failed, non constant params\"\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else if has_dependent_argument {\n \t\t\t\tlet with = arguments.to_vec().into_boxed_slice();\n \t\t\t\t// TODO with cloned!!\n-\t\t\t\tlet result = self\n-\t\t\t\t\t.call(\n-\t\t\t\t\t\tCallingInput {\n-\t\t\t\t\t\t\tcalled_with_new,\n-\t\t\t\t\t\t\tthis_value,\n-\t\t\t\t\t\t\tcall_site_type_arguments,\n-\t\t\t\t\t\t\tcall_site,\n-\t\t\t\t\t\t},\n-\t\t\t\t\t\tparent_type_arguments,\n-\t\t\t\t\t\targuments,\n-\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\tbehavior,\n-\t\t\t\t\t\ttypes,\n-\t\t\t\t\t\t// Very important!\n-\t\t\t\t\t\tfalse,\n-\t\t\t\t\t)?\n-\t\t\t\t\t.returned_type;\n+\t\t\t\tlet calling_input = CallingInput {\n+\t\t\t\t\tcalled_with_new,\n+\t\t\t\t\tthis_value,\n+\t\t\t\t\tcall_site_type_arguments,\n+\t\t\t\t\tcall_site,\n+\t\t\t\t};\n+\t\t\t\tlet call = self.call(\n+\t\t\t\t\tcalling_input,\n+\t\t\t\t\tparent_type_arguments,\n+\t\t\t\t\targuments,\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\tbehavior,\n+\t\t\t\t\ttypes,\n+\t\t\t\t\t// Very important!\n+\t\t\t\t\tfalse,\n+\t\t\t\t);\n+\n+\t\t\t\tif let Err(ref err) = call {\n+\t\t\t\t\tcrate::utils::notify!(\"Calling function with dependent argument failed\");\n+\t\t\t\t}\n+\n+\t\t\t\tlet result = call?.returned_type;\n \n \t\t\t\t// TODO pass down\n \t\t\t\tlet on = types.register_type(Type::Function(self.id, this_value));\n-\t\t\t\tlet new_type = Type::Constructor(Constructor::FunctionResult {\n-\t\t\t\t\ton,\n-\t\t\t\t\twith: with.clone(),\n-\t\t\t\t\tresult,\n-\t\t\t\t});\n+\t\t\t\tlet new_type =\n+\t\t\t\t\tType::Constructor(Constructor::Image { on, with: with.clone(), result });\n \n \t\t\t\tlet ty = types.register_type(new_type);\n \n-\t\t\t\tbehavior.get_top_level_facts(environment).events.push(Event::CallsType {\n+\t\t\t\tcrate::utils::notify!(\"Here\");\n+\n+\t\t\t\tbehavior.get_latest_facts(environment).events.push(Event::CallsType {\n \t\t\t\t\ton,\n \t\t\t\t\twith: arguments.to_vec().into_boxed_slice(),\n \t\t\t\t\treflects_dependency: Some(ty),\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -173,7 +206,7 @@ pub(crate) fn get_property<E: CallCheckingBehavior>(\n \t\tGetResult::FromAObject(_) => None,\n \t};\n \n-\tbehavior.get_top_level_facts(environment).events.push(Event::Getter {\n+\tbehavior.get_latest_facts(top_environment).events.push(Event::Getter {\n \t\ton,\n \t\tunder: under.into_owned(),\n \t\treflects_dependency,\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -514,7 +615,7 @@ pub(crate) fn set_property<E: CallCheckingBehavior>(\n \t\tmatch fact {\n \t\t\tLogical::Pure(og) => match og {\n \t\t\t\tPropertyValue::Deleted | PropertyValue::Value(..) => {\n-\t\t\t\t\tlet facts = behavior.get_top_level_facts(environment);\n+\t\t\t\t\tlet facts = behavior.get_latest_facts(environment);\n \t\t\t\t\tfacts.current_properties.entry(on).or_default().push((\n \t\t\t\t\t\tpublicity,\n \t\t\t\t\t\tunder.into_owned(),\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -537,13 +636,29 @@ pub(crate) fn set_property<E: CallCheckingBehavior>(\n \t\t\t\t}\n \t\t\t},\n \t\t\tLogical::Or { .. } => todo!(),\n-\t\t\tLogical::Implies { .. } => todo!(),\n+\t\t\tLogical::Implies { on: implies_on, antecedent } => {\n+\t\t\t\tcrate::utils::notify!(\"Check that `implies_on` could be a setter here\");\n+\t\t\t\tlet facts = behavior.get_latest_facts(environment);\n+\t\t\t\tfacts.current_properties.entry(on).or_default().push((\n+\t\t\t\t\tpublicity,\n+\t\t\t\t\tunder.into_owned(),\n+\t\t\t\t\tnew.clone(),\n+\t\t\t\t));\n+\t\t\t\tfacts.events.push(Event::Setter {\n+\t\t\t\t\ton,\n+\t\t\t\t\tnew,\n+\t\t\t\t\tunder: under.into_owned(),\n+\t\t\t\t\tpublicity,\n+\t\t\t\t\tinitialization: false,\n+\t\t\t\t\tposition: setter_position,\n+\t\t\t\t});\n+\t\t\t}\n \t\t}\n \t} else {\n \t\t// TODO abstract\n \t\t// TODO only if dependent?\n \t\tlet register_setter_event = true;\n-\t\tbehavior.get_top_level_facts(environment).register_property(\n+\t\tbehavior.get_latest_facts(environment).register_property(\n \t\t\ton,\n \t\t\tpublicity,\n \t\t\tunder.into_owned(),\ndiff --git a/parser/tests/visiting.rs b/parser/tests/visiting.rs\n--- a/parser/tests/visiting.rs\n+++ b/parser/tests/visiting.rs\n@@ -50,9 +50,9 @@ struct AddElseClause;\n \n impl VisitorMut<BlockItemMut<'_>, ()> for AddElseClause {\n \tfn visit_mut(&mut self, item: &mut BlockItemMut, _data: &mut (), _chain: &Chain) {\n-\t\tif let BlockItemMut::SingleStatement(Statement::IfStatement(if_statement))\n+\t\tif let BlockItemMut::SingleStatement(Statement::If(if_statement))\n \t\t| BlockItemMut::StatementOrDeclaration(StatementOrDeclaration::Statement(\n-\t\t\tStatement::IfStatement(if_statement),\n+\t\t\tStatement::If(if_statement),\n \t\t)) = item\n \t\t{\n \t\t\tif if_statement.trailing_else.is_none() {\n",
        "problem_statement": "For / while loops\n- [ ] Add iterators for array based on length etc\r\n- [ ] Add effects running with some iteration limit\n",
        "hints_text": "",
        "created_at": "2023-12-05T20:49:20Z",
        "version": "0.0"
    },
    {
        "repo": "kaleidawave/ezno",
        "pull_number": 16,
        "instance_id": "kaleidawave__ezno-16",
        "issue_numbers": [
            "7"
        ],
        "base_commit": "f64028b23b07ce17432f43438d8e3a58be990397",
        "patch": "diff --git a/.github/workflows/publish.yml b/.github/workflows/publish.yml\n--- a/.github/workflows/publish.yml\n+++ b/.github/workflows/publish.yml\n@@ -29,6 +37,10 @@ jobs:\n       new-ezno-version: ${{ steps.get-version.outputs.new-ezno-version }}\n     steps:\n       - uses: actions/checkout@v3\n+      - uses: actions/cache@v3\n+        with:\n+          path: ${{ env.CACHE_PATHS }}\n+          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n \n       - name: Set git credentials\n         run: |\ndiff --git a/.github/workflows/publish.yml b/.github/workflows/publish.yml\n--- a/.github/workflows/publish.yml\n+++ b/.github/workflows/publish.yml\n@@ -58,26 +70,14 @@ jobs:\n       - name: Get new Ezno version\n         id: get-version\n         run: |\n-          echo \"new-ezno-version=$(echo '${{ steps.release.outputs.new-versions-json-object }}' | jq \".ezno\" )\" >> $GITHUB_OUTPUT\n+          echo \"new-ezno-version=$(echo '${{ steps.release.outputs.new-versions-json-object }}' | jq -r \".ezno\" )\" >> $GITHUB_OUTPUT\n \n-      - name: Install WASM build dependencies\n-        run: |\n-          # Make sure Rust can target WASM\n-          rustup target add wasm32-unknown-unknown\n-          \n-          # Install WASM bindgen\n-          mkdir private\n-          cd private\n-          mkdir wasm-bindgen\n-          cd wasm-bindgen\n-\n-          gh release download 0.2.84 -R rustwasm/wasm-bindgen -p '*x86_64-unknown-linux-musl.tar.gz' -O wasm-bindgen.tar.gz\n-          tar -xf wasm-bindgen.tar.gz\n-          mv wasm-bindgen-0.2.84-x86_64-unknown-linux-musl/wasm-bindgen wasm-bindgen\n-          \n-          pwd >> $GITHUB_PATH\n-        env:\n-          GH_TOKEN: ${{ github.token }}\n+      - name: Add WASM to rustup\n+        run: rustup target add wasm32-unknown-unknown\n+\n+      - uses: brndnmtthws/rust-action-cargo-binstall@v1\n+        with:\n+          packages: wasm-bindgen-cli\n \n       - name: Set NPM package version & build\n         run: | \ndiff --git a/.github/workflows/publish.yml b/.github/workflows/publish.yml\n--- a/.github/workflows/publish.yml\n+++ b/.github/workflows/publish.yml\n@@ -94,8 +94,8 @@ jobs:\n         \n       - name: Update plugin version and dependencies\n         run: |\n-          # Hopefully propagated in 30 seconds\n-          sleep 30\n+          # Hopefully propagated in 20 seconds\n+          sleep 20\n           npm ci\n           npm install ezno@${{ steps.get-version.outputs.new-ezno-version }}\n           npm version ${{ steps.get-version.outputs.new-ezno-version }}\ndiff --git a/.github/workflows/publish.yml b/.github/workflows/publish.yml\n--- a/.github/workflows/publish.yml\n+++ b/.github/workflows/publish.yml\n@@ -116,6 +116,7 @@ jobs:\n           git add .\n           git commit -m \"Release: ${{ steps.release.outputs.new-versions-description }}\"\n           git push --tags origin main\n+          sleep 20\n \n       - name: Discord\n         uses: dusmartijngames/discord-webhook-notify@master\ndiff --git a/.github/workflows/publish.yml b/.github/workflows/publish.yml\n--- a/.github/workflows/publish.yml\n+++ b/.github/workflows/publish.yml\n@@ -142,6 +143,15 @@ jobs:\n \n     steps:\n       - uses: actions/checkout@v3\n+      - uses: actions/cache@v3\n+        with:\n+          path: ${{ env.CACHE_PATHS }}\n+          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n+\n+      - name: Check repo\n+        run: |\n+          git describe --tags --abbrev=0\n+          cat Cargo.toml\n \n       - name: Build binary\n         run: cargo build --release\ndiff --git a/.github/workflows/publish.yml b/.github/workflows/publish.yml\n--- a/.github/workflows/publish.yml\n+++ b/.github/workflows/publish.yml\n@@ -179,8 +190,9 @@ jobs:\n     - name: GitHub release\n       uses: softprops/action-gh-release@v1\n       with:\n-        body: \"Release ${{ needs.crates-publish.outputs.new-ezno-version }}\"\n-        tag_name: \"release/${{ needs.crates-publish.outputs.new-ezno-version }}\"\n+        name: \"Ezno ${{ needs.crates-publish.outputs.new-ezno-version }}\"\n+        tag_name: \"release/ezno-${{ needs.crates-publish.outputs.new-ezno-version }}\"\n+        body: \"For @kaleidawave to update\"\n         files: |\n           README.md\n           build-artifacts/*\n\\ No newline at end of file\ndiff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -8,6 +18,12 @@ on:\n \n env:\n   CARGO_TERM_COLOR: always\n+  CACHE_PATHS: |\n+    ~/.cargo/bin/\n+    ~/.cargo/registry/index/\n+    ~/.cargo/registry/cache/\n+    ~/.cargo/git/db/\n+    target/\n \n jobs:\n   validity:\ndiff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -16,11 +32,9 @@ jobs:\n       - uses: actions/checkout@v3\n       - uses: actions/cache@v3\n         with:\n-          path: |\n-            ~/.cargo/registry\n-            ~/.cargo/git\n-            target\n+          path: ${{ env.CACHE_PATHS }}\n           key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n+\n       - name: Check source is valid\n         run: cargo check --workspace\n \ndiff --git a/parser/Cargo.toml b/parser/Cargo.toml\n--- a/parser/Cargo.toml\n+++ b/parser/Cargo.toml\n@@ -23,7 +23,7 @@ visitable-derive = { path = \"./visitable-derive\", version = \"0.0.1\", package = \"\n \n derive-finite-automaton = \"0.1.0\"\n derive-debug-extras = { version = \"0.2.2\", features = [\n-    \"auto-debug-single-tuple-inline\",\n+  \"auto-debug-single-tuple-inline\",\n ] }\n derive-partial-eq-extras = \"0.1.2\"\n derive-enum-from-into = \"0.1.1\"\ndiff --git a/parser/Cargo.toml b/parser/Cargo.toml\n--- a/parser/Cargo.toml\n+++ b/parser/Cargo.toml\n@@ -35,20 +35,20 @@ enum_variant_type = \"0.3.1\"\n enum-variants-strings = \"0.2\"\n \n source-map = { version = \"0.12\", features = [\n-    \"span-serialize\",\n-    \"self-rust-tokenize\",\n+  \"span-serialize\",\n+  \"self-rust-tokenize\",\n ] }\n self-rust-tokenize = { version = \"0.3.3\", optional = true }\n \n # Needs buffered and not parralel for WASM\n [target.'cfg(target_family = \"wasm\")'.dependencies]\n tokenizer-lib = { version = \"1.5.0\", features = [\n-    \"buffered\",\n+  \"buffered\",\n ], default_features = false }\n \n [target.'cfg(not(target_family = \"wasm\"))'.dependencies]\n tokenizer-lib = { version = \"1.5.0\", features = [\n-    \"parallel\",\n+  \"parallel\",\n ], default_features = false }\n \n [dev-dependencies]\ndiff --git a/parser/generator/Cargo.toml b/parser/generator/Cargo.toml\n--- a/parser/generator/Cargo.toml\n+++ b/parser/generator/Cargo.toml\n@@ -17,4 +17,6 @@ proc-macro = true\n quote = \"1.0\"\n proc-macro2 = \"1.0\"\n self-rust-tokenize = \"0.3.3\"\n-parser = { path = \"..\", package = \"ezno-parser\", version = \"0.0.3\", features = [\"self-rust-tokenize\"]}\n+parser = { path = \"..\", package = \"ezno-parser\", version = \"0.0.3\", features = [\n+  \"self-rust-tokenize\",\n+] }\ndiff --git a/parser/visitable-derive/Cargo.toml b/parser/visitable-derive/Cargo.toml\n--- a/parser/visitable-derive/Cargo.toml\n+++ b/parser/visitable-derive/Cargo.toml\n@@ -15,4 +15,4 @@ proc-macro = true\n \n [dependencies]\n syn-helpers = \"0.4.2\"\n-string-cases = \"0.2\"\n\\ No newline at end of file\n+string-cases = \"0.2\"\n",
        "test_patch": "diff --git /dev/null b/.github/workflows/performance-and-size.yml\nnew file mode 100644\n--- /dev/null\n+++ b/.github/workflows/performance-and-size.yml\n@@ -0,0 +1,43 @@\n+name: Performance and size\n+\n+on:\n+  push:\n+    branches: [main]\n+  pull_request:\n+    branches: [main]\n+\n+env:\n+  CARGO_TERM_COLOR: always\n+\n+jobs:\n+  hyperfine:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: actions/checkout@v3\n+      - uses: actions/cache@v3\n+        with:\n+          path: |\n+            ~/.cargo/bin/\n+            ~/.cargo/registry/index/\n+            ~/.cargo/registry/cache/\n+            ~/.cargo/git/db/\n+            target/\n+          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n+\n+      - uses: brndnmtthws/rust-action-cargo-binstall@v1\n+        with:\n+          packages: hyperfine\n+\n+      - name: Build Ezno\n+        run: cargo build --release\n+        env:\n+          CARGO_PROFILE_RELEASE_DEBUG: true\n+\n+      - name: Run hyperfine\n+        run: |\n+          curl -O https://gist.githubusercontent.com/kaleidawave/9554eb0ec0a2efc5727a3227fe997c8d/raw/6445ec1b802b52081e6dbb9c3a99e6de3f33dcfa/example.js\n+          hyperfine './target/release/ezno build example.js'\n+\n+      - name: Print (linux) binary size\n+        run: |\n+          echo \"Binary is $(stat -c %s ./target/release/ezno) bytes\"\n\\ No newline at end of file\ndiff --git a/.github/workflows/publish.yml b/.github/workflows/publish.yml\n--- a/.github/workflows/publish.yml\n+++ b/.github/workflows/publish.yml\n@@ -22,6 +22,14 @@ on:\n \n concurrency: release-crate\n \n+env:\n+  CACHE_PATHS: |\n+    ~/.cargo/bin/\n+    ~/.cargo/registry/index/\n+    ~/.cargo/registry/cache/\n+    ~/.cargo/git/db/\n+    target/\n+\n jobs:\n   crates-publish:\n     runs-on: ubuntu-latest\ndiff --git a/.github/workflows/publish.yml b/.github/workflows/publish.yml\n--- a/.github/workflows/publish.yml\n+++ b/.github/workflows/publish.yml\n@@ -162,6 +172,7 @@ jobs:\n     if: ${{ github.event.inputs.ezno-version != 'none' }}\n     needs: [crates-publish, build]\n     runs-on: ubuntu-latest\n+\n     steps:\n     - uses: actions/checkout@v3\n \ndiff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -1,5 +1,15 @@\n name: Rust\n \n+# Contains checks:\n+# - That the code compiles\n+# - That the code complies with formatting\n+# - Lints (using clippy) to find errors\n+# - That crates that are published are publish-able\n+# - Testing \n+#   - Standard Rust integration and unit tests\n+#   - Fuzz tests\n+#   - WASM edition works tests\n+\n on:\n   push:\n     branches: [main]\ndiff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -28,32 +42,77 @@ jobs:\n     runs-on: ubuntu-latest\n     steps:\n       - uses: actions/checkout@v3\n-      - name: Check formatting with rustfmt\n+\n+      - name: Check Rust formatting with rustfmt\n         run: cargo fmt --all --check\n \n+      - uses: brndnmtthws/rust-action-cargo-binstall@v1\n+        with:\n+          packages: taplo-cli\n+\n+      - name: Check TOML formatting with taplo\n+        run: |\n+          taplo fmt --check **/*/Cargo.toml\n+\n   tests:\n     needs: validity\n     runs-on: ubuntu-latest\n     steps:\n       - uses: actions/checkout@v3\n-      - name: Run all tests\n-        run: cargo test --workspace --verbose --all-features\n+      - uses: actions/cache@v3\n+        with:\n+          path: ${{ env.CACHE_PATHS }}\n+          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n+\n+      - uses: dorny/paths-filter@v2\n+        id: changes\n+        with:\n+          filters: |\n+            parser:\n+              - 'parser/**'\n+\n+      - name: Run parser tests\n+        if: steps.changes.outputs.parser == 'true'\n+        run: cargo test\n+        working-directory: parser\n+\n+      - name: Run base tests\n+        run: cargo test\n \n   fuzzing:\n     needs: validity\n     runs-on: ubuntu-latest\n+    continue-on-error: true\n+    strategy:\n+      matrix:\n+        fuzz-target: [module_roundtrip_naive, module_roundtrip_structured]\n+\n     steps:\n       - uses: actions/checkout@v3\n+      - uses: actions/cache@v3\n+        with:\n+          path: ${{ env.CACHE_PATHS }}\n+          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n+      - uses: dorny/paths-filter@v2\n+        id: changes\n+        with:\n+          filters: |\n+            parser:\n+              - 'parser/**'\n+\n       - name: Install latest nightly and set it as default\n+        if: steps.changes.outputs.parser == 'true'\n         run: |\n           rustup install nightly\n           rustup default nightly\n-      - name: Install cargo-fuzz\n-        run: cargo install cargo-fuzz\n+      - uses: brndnmtthws/rust-action-cargo-binstall@v1\n+        if: steps.changes.outputs.parser == 'true'\n+        with:\n+          packages: cargo-fuzz\n       - name: Run fuzzing\n+        if: steps.changes.outputs.parser == 'true'\n         run: |\n-          cargo fuzz run -s none module_roundtrip_naive -- -timeout=10 -max_total_time=120 -use_value_profile=1 || true\n-          cargo fuzz run -s none module_roundtrip_structured -- -timeout=10 -max_total_time=120 -use_value_profile=1 || true\n+          cargo fuzz run -s none ${{ matrix.fuzz-target }} -- -timeout=10 -max_total_time=120 -use_value_profile=1\n         working-directory: parser/fuzz\n \n   clippy:\ndiff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -61,6 +120,10 @@ jobs:\n     runs-on: ubuntu-latest\n     steps:\n       - uses: actions/checkout@v3\n+      - uses: actions/cache@v3\n+        with:\n+          path: ${{ env.CACHE_PATHS }}\n+          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n       - name: Lint code with clippy\n         run: cargo clippy\n \ndiff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -69,6 +132,10 @@ jobs:\n     runs-on: ubuntu-latest\n     steps:\n       - uses: actions/checkout@v3\n+      - uses: actions/cache@v3\n+        with:\n+          path: ${{ env.CACHE_PATHS }}\n+          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n       - uses: brndnmtthws/rust-action-cargo-binstall@v1\n         with:\n           packages: wasm-bindgen-cli\ndiff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -99,7 +166,6 @@ jobs:\n         working-directory: src/js-cli-and-library\n         shell: bash\n \n-   \n   publish-ability:\n     runs-on: ubuntu-latest\n     steps:\ndiff --git a/parser/fuzz/Cargo.toml b/parser/fuzz/Cargo.toml\n--- a/parser/fuzz/Cargo.toml\n+++ b/parser/fuzz/Cargo.toml\n@@ -1,43 +1,43 @@\n [package]\n-\tname = \"ezno-parser-fuzz\"\n-\tversion = \"0.0.0\"\n-\tpublish = false\n-\tedition = \"2021\"\n+name = \"ezno-parser-fuzz\"\n+version = \"0.0.0\"\n+publish = false\n+edition = \"2021\"\n \n-\t[package.metadata]\n-\t\tcargo-fuzz = true\n+[package.metadata]\n+cargo-fuzz = true\n \n [build-dependencies]\n-\treqwest = { version = \"0.11.14\", features = [\"blocking\"] }\n+reqwest = { version = \"0.11.14\", features = [\"blocking\"] }\n \n [dependencies]\n-\tboa_ast = { git = \"https://github.com/boa-dev/boa.git\", features = [\n-\t\t\"arbitrary\",\n-\t] }\n-\tboa_interner = { git = \"https://github.com/boa-dev/boa.git\", features = [\n-\t\t\"arbitrary\",\n-\t] }\n-\tlibfuzzer-sys = \"0.4\"\n-\tpretty_assertions = \"1.3.0\"\n-\n-\t[dependencies.ezno-parser]\n-\t\tpath = \"..\"\n+boa_ast = { git = \"https://github.com/boa-dev/boa.git\", features = [\n+  \"arbitrary\",\n+] }\n+boa_interner = { git = \"https://github.com/boa-dev/boa.git\", features = [\n+  \"arbitrary\",\n+] }\n+libfuzzer-sys = \"0.4\"\n+pretty_assertions = \"1.3.0\"\n+\n+[dependencies.ezno-parser]\n+path = \"..\"\n \n # Prevent this from interfering with workspaces\n [workspace]\n-\tmembers = [\".\"]\n+members = [\".\"]\n \n [profile.release]\n-\tdebug = 1\n+debug = 1\n \n [[bin]]\n-\tname = \"module_roundtrip_naive\"\n-\tpath = \"fuzz_targets/module_roundtrip_naive.rs\"\n-\ttest = false\n-\tdoc = false\n+name = \"module_roundtrip_naive\"\n+path = \"fuzz_targets/module_roundtrip_naive.rs\"\n+test = false\n+doc = false\n \n [[bin]]\n-\tname = \"module_roundtrip_structured\"\n-\tpath = \"fuzz_targets/module_roundtrip_structured.rs\"\n-\ttest = false\n-\tdoc = false\n+name = \"module_roundtrip_structured\"\n+path = \"fuzz_targets/module_roundtrip_structured.rs\"\n+test = false\n+doc = false\n",
        "problem_statement": "Improve CI testing and publishing\n### Testing\r\n- **Run fuzzing tests in parallel**. Will show red light correctly and be faster\r\n- Get cargo fuzz from: https://github.com/rust-fuzz/cargo-fuzz/releases/tag/0.11.2\r\n- Split up testing step by crates (eventually this should mean that it should only run tests for crates that have changed)\r\n- Have some sort of feature matrix for testing\r\n- **Add hyperfine and flamegraph** performance tracing\r\n- Enforce Cargo.toml formats\r\n\r\n*need to check whether caching is working correctly*\r\n\r\n### Publishing\r\n- Automatically add `ezno-ast-generator` if `ezno-parser` is updated\r\n\n",
        "hints_text": "https://github.com/marketplace/actions/brndnmtthws-rust-action-cargo-binstall / https://github.com/brndnmtthws/rust-action perhaps?",
        "created_at": "2023-03-26T18:44:12Z",
        "version": "0.0"
    },
    {
        "repo": "kaleidawave/ezno",
        "pull_number": 127,
        "instance_id": "kaleidawave__ezno-127",
        "issue_numbers": [
            "106"
        ],
        "base_commit": "0fa4fa8830baa9506ad1ee2080137ca625a3cd63",
        "patch": "diff --git a/checker/definitions/overrides.d.ts b/checker/definitions/overrides.d.ts\n--- a/checker/definitions/overrides.d.ts\n+++ b/checker/definitions/overrides.d.ts\n@@ -269,4 +269,4 @@ declare function satisfies<T>(t: T): T;\n \n @Constant\n declare function compile_type_to_object<T>(): any;\n-// \u2191\u2191 Ezno Functions \u2191\u2191\n\\ No newline at end of file\n+// \u2191\u2191 Ezno Functions \u2191\u2191\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -648,6 +648,16 @@ callToUpperCase(\"hi\") satisfies \"HEY\";\n \n - Expected \"HEY\", found \"HI\"\n \n+#### String internal `this` unbinding error\n+\n+```ts\n+const { toUpperCase } = \"hi\";\n+\n+toUpperCase();\n+```\n+\n+- The 'this' context of the function is expected to be string, found undefined\n+\n #### Calling new on a function\n \n ```ts\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -739,7 +749,7 @@ doThing(6, 1) satisfies 6;\n let a: number = 0\n function func() {\n \ta = 4;\n-\t// Important that subsequent reads use the \n+\t// Important that subsequent reads use the\n \t// new value, not the same free variable\n \ta satisfies 4;\n }\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -1569,7 +1579,7 @@ interface X {\n \tinterface X {\n \t\tc: number\n \t}\n-\t\n+\n \tconst x: X = { a: \"field\", b: false, c: false }\n \tconst y: X = { a: \"field\", b: false, c: 2 }\n }\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -1658,6 +1668,27 @@ try {\n \n - Expected string, found 3\n \n+#### Object destructuring assignment\n+\n+```ts\n+const o = { a: 1, b: { c: 3 } };\n+\n+let a, b, c;\n+({\n+  c = o.a++,\n+  b: { c: b = 7 },\n+  a,\n+} = o);\n+\n+a satisfies string;\n+b satisfies boolean;\n+c satisfies 3;\n+```\n+\n+- Expected string, found 2\n+- Expected boolean, found 3\n+- Expected 3, found 1\n+\n ### Async and `Promise`s\n \n > Position of await is not checked (here is fine because top level await)\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -1692,6 +1723,21 @@ x.value satisfies string\n \n - Expected string, found 4\n \n+#### Class `this` unbinding\n+\n+```ts\n+class X {\n+    method() {\n+        return this;\n+    }\n+}\n+\n+const { method } = new X();\n+method();\n+```\n+\n+- The 'this' context of the function is expected to be X, found undefined\n+\n #### Property keys\n \n > Property keys are synthesised once and their effects run once (as opposed to their value)\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -3,12 +3,15 @@ use std::collections::HashSet;\n \n use crate::{\n \tdiagnostics::{\n-\t\tNotInLoopOrCouldNotFindLabel, TypeCheckError, TypeCheckWarning, TypeStringRepresentation,\n-\t\tTDZ,\n+\t\tNotInLoopOrCouldNotFindLabel, PropertyRepresentation, TypeCheckError, TypeCheckWarning,\n+\t\tTypeStringRepresentation, TDZ,\n \t},\n \tevents::{ApplicationResult, Event, FinalEvent, RootReference},\n \tfeatures::{\n-\t\tassignments::{Assignable, AssignmentKind, Reference},\n+\t\tassignments::{\n+\t\t\tAssignable, AssignableArrayDestructuringField, AssignableObjectDestructuringField,\n+\t\t\tAssignmentKind, Reference,\n+\t\t},\n \t\tmodules::Exported,\n \t\tobjects::SpecialObjects,\n \t\toperations::{\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -19,7 +22,7 @@ use crate::{\n \t},\n \tsubtyping::{type_is_subtype, BasicEquality, SubTypeResult},\n \ttypes::{\n-\t\tis_type_truthy_falsy,\n+\t\tis_type_truthy_falsy, printing,\n \t\tproperties::{PropertyKey, PropertyKind, PropertyValue},\n \t\tPolyNature, Type, TypeCombinable, TypeStore,\n \t},\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -242,7 +245,7 @@ impl<'a> Environment<'a> {\n \t\tA: crate::ASTImplementation,\n \t>(\n \t\t&mut self,\n-\t\tlhs: Assignable,\n+\t\tlhs: Assignable<A>,\n \t\toperator: AssignmentKind,\n \t\t// Can be `None` for increment and decrement\n \t\texpression: Option<&'b A::Expression<'b>>,\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -251,112 +254,26 @@ impl<'a> Environment<'a> {\n \t) -> TypeId {\n \t\tmatch lhs {\n \t\t\tAssignable::Reference(reference) => {\n-\t\t\t\t/// Returns\n-\t\t\t\tfn get_reference<U: crate::ReadFromFS, A: crate::ASTImplementation>(\n-\t\t\t\t\tenv: &mut Environment,\n-\t\t\t\t\treference: Reference,\n-\t\t\t\t\tchecking_data: &mut CheckingData<U, A>,\n-\t\t\t\t) -> TypeId {\n-\t\t\t\t\tmatch reference {\n-\t\t\t\t\t\tReference::Variable(name, position) => {\n-\t\t\t\t\t\t\tenv.get_variable_handle_error(&name, position, checking_data).unwrap().1\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tReference::Property { on, with, publicity, span } => {\n-\t\t\t\t\t\t\tlet get_property_handle_errors = env.get_property_handle_errors(\n-\t\t\t\t\t\t\t\ton,\n-\t\t\t\t\t\t\t\tpublicity,\n-\t\t\t\t\t\t\t\t&with,\n-\t\t\t\t\t\t\t\tchecking_data,\n-\t\t\t\t\t\t\t\tspan.without_source(),\n-\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\tmatch get_property_handle_errors {\n-\t\t\t\t\t\t\t\tOk(i) => i.get_value(),\n-\t\t\t\t\t\t\t\tErr(()) => TypeId::ERROR_TYPE,\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tfn set_reference<U: crate::ReadFromFS, A: crate::ASTImplementation>(\n-\t\t\t\t\tenv: &mut Environment,\n-\t\t\t\t\treference: Reference,\n-\t\t\t\t\tnew: TypeId,\n-\t\t\t\t\tchecking_data: &mut CheckingData<U, A>,\n-\t\t\t\t) -> Result<TypeId, SetPropertyError> {\n-\t\t\t\t\tmatch reference {\n-\t\t\t\t\t\tReference::Variable(name, position) => Ok(env\n-\t\t\t\t\t\t\t.assign_to_variable_handle_errors(\n-\t\t\t\t\t\t\t\tname.as_str(),\n-\t\t\t\t\t\t\t\tposition,\n-\t\t\t\t\t\t\t\tnew,\n-\t\t\t\t\t\t\t\tchecking_data,\n-\t\t\t\t\t\t\t)),\n-\t\t\t\t\t\tReference::Property { on, with, publicity, span } => Ok(env\n-\t\t\t\t\t\t\t.set_property(\n-\t\t\t\t\t\t\t\ton,\n-\t\t\t\t\t\t\t\tpublicity,\n-\t\t\t\t\t\t\t\t&with,\n-\t\t\t\t\t\t\t\tnew,\n-\t\t\t\t\t\t\t\t&mut checking_data.types,\n-\t\t\t\t\t\t\t\tSome(span),\n-\t\t\t\t\t\t\t\t&checking_data.options,\n-\t\t\t\t\t\t\t)?\n-\t\t\t\t\t\t\t.unwrap_or(new)),\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tfn set_property_error_to_type_check_error(\n-\t\t\t\t\tctx: &impl InformationChain,\n-\t\t\t\t\terror: SetPropertyError,\n-\t\t\t\t\tassignment_span: SpanWithSource,\n-\t\t\t\t\ttypes: &TypeStore,\n-\t\t\t\t\tnew: TypeId,\n-\t\t\t\t) -> TypeCheckError<'static> {\n-\t\t\t\t\tmatch error {\n-\t\t\t\t\t\tSetPropertyError::NotWriteable => {\n-\t\t\t\t\t\t\tTypeCheckError::PropertyNotWriteable(assignment_span)\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tSetPropertyError::DoesNotMeetConstraint {\n-\t\t\t\t\t\t\tproperty_constraint,\n-\t\t\t\t\t\t\treason: _,\n-\t\t\t\t\t\t} => TypeCheckError::AssignmentError(AssignmentError::PropertyConstraint {\n-\t\t\t\t\t\t\tproperty_constraint,\n-\t\t\t\t\t\t\tvalue_type: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\t\tnew, ctx, types, false,\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tassignment_position: assignment_span,\n-\t\t\t\t\t\t}),\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n \t\t\t\tmatch operator {\n \t\t\t\t\tAssignmentKind::Assign => {\n-\t\t\t\t\t\tlet new = A::synthesise_expression(\n+\t\t\t\t\t\tlet rhs = A::synthesise_expression(\n \t\t\t\t\t\t\texpression.unwrap(),\n \t\t\t\t\t\t\tTypeId::ANY_TYPE,\n \t\t\t\t\t\t\tself,\n \t\t\t\t\t\t\tchecking_data,\n \t\t\t\t\t\t);\n-\t\t\t\t\t\tlet result = set_reference(self, reference, new, checking_data);\n-\t\t\t\t\t\tmatch result {\n-\t\t\t\t\t\t\tOk(ty) => ty,\n-\t\t\t\t\t\t\tErr(error) => {\n-\t\t\t\t\t\t\t\tlet error = set_property_error_to_type_check_error(\n-\t\t\t\t\t\t\t\t\tself,\n-\t\t\t\t\t\t\t\t\terror,\n-\t\t\t\t\t\t\t\t\tassignment_span.with_source(self.get_source()),\n-\t\t\t\t\t\t\t\t\t&checking_data.types,\n-\t\t\t\t\t\t\t\t\tnew,\n-\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t\tchecking_data.diagnostics_container.add_error(error);\n-\t\t\t\t\t\t\t\tTypeId::ERROR_TYPE\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tself.assign_to_reference_assign_handle_errors(\n+\t\t\t\t\t\t\treference,\n+\t\t\t\t\t\t\trhs,\n+\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t\tassignment_span,\n+\t\t\t\t\t\t)\n \t\t\t\t\t}\n \t\t\t\t\tAssignmentKind::PureUpdate(operator) => {\n \t\t\t\t\t\t// Order matters here\n \t\t\t\t\t\tlet reference_position = reference.get_position();\n-\t\t\t\t\t\tlet existing = get_reference(self, reference.clone(), checking_data);\n+\t\t\t\t\t\tlet existing = self.get_reference(reference.clone(), checking_data, true);\n \n \t\t\t\t\t\tlet expression = expression.unwrap();\n \t\t\t\t\t\tlet expression_pos =\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -375,7 +292,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\t\tchecking_data,\n \t\t\t\t\t\t\tself,\n \t\t\t\t\t\t);\n-\t\t\t\t\t\tlet result = set_reference(self, reference, new, checking_data);\n+\t\t\t\t\t\tlet result = self.set_reference(reference, new, checking_data);\n \t\t\t\t\t\tmatch result {\n \t\t\t\t\t\t\tOk(ty) => ty,\n \t\t\t\t\t\t\tErr(error) => {\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -395,7 +312,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\t// let value =\n \t\t\t\t\t\t// \tself.get_variable_or_error(&name, &assignment_span, checking_data);\n \t\t\t\t\t\tlet span = reference.get_position();\n-\t\t\t\t\t\tlet existing = get_reference(self, reference.clone(), checking_data);\n+\t\t\t\t\t\tlet existing = self.get_reference(reference.clone(), checking_data, true);\n \n \t\t\t\t\t\t// TODO existing needs to be cast to number!!\n \ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -415,7 +332,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\t\tself,\n \t\t\t\t\t\t);\n \n-\t\t\t\t\t\tlet result = set_reference(self, reference, new, checking_data);\n+\t\t\t\t\t\tlet result = self.set_reference(reference, new, checking_data);\n \n \t\t\t\t\t\tmatch result {\n \t\t\t\t\t\t\tOk(new) => match return_kind {\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -438,7 +355,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tAssignmentKind::ConditionalUpdate(operator) => {\n-\t\t\t\t\t\tlet existing = get_reference(self, reference.clone(), checking_data);\n+\t\t\t\t\t\tlet existing = self.get_reference(reference.clone(), checking_data, true);\n \t\t\t\t\t\tlet expression = expression.unwrap();\n \t\t\t\t\t\tlet new = evaluate_logical_operation_with_expression(\n \t\t\t\t\t\t\t(existing, reference.get_position().without_source()),\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -449,7 +366,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\t)\n \t\t\t\t\t\t.unwrap();\n \n-\t\t\t\t\t\tlet result = set_reference(self, reference, new, checking_data);\n+\t\t\t\t\t\tlet result = self.set_reference(reference, new, checking_data);\n \n \t\t\t\t\t\tmatch result {\n \t\t\t\t\t\t\tOk(new) => new,\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -468,8 +385,248 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\tAssignable::ObjectDestructuring(_) => todo!(),\n-\t\t\tAssignable::ArrayDestructuring(_) => todo!(),\n+\t\t\tAssignable::ObjectDestructuring(assignments) => {\n+\t\t\t\tdebug_assert!(matches!(operator, AssignmentKind::Assign));\n+\n+\t\t\t\tlet rhs = A::synthesise_expression(\n+\t\t\t\t\texpression.unwrap(),\n+\t\t\t\t\tTypeId::ANY_TYPE,\n+\t\t\t\t\tself,\n+\t\t\t\t\tchecking_data,\n+\t\t\t\t);\n+\n+\t\t\t\tself.assign_to_object_destructure_handle_errors(\n+\t\t\t\t\tassignments,\n+\t\t\t\t\trhs,\n+\t\t\t\t\tassignment_span,\n+\t\t\t\t\tchecking_data,\n+\t\t\t\t)\n+\t\t\t}\n+\t\t\tAssignable::ArrayDestructuring(assignments) => {\n+\t\t\t\tdebug_assert!(matches!(operator, AssignmentKind::Assign));\n+\n+\t\t\t\tlet rhs = A::synthesise_expression(\n+\t\t\t\t\texpression.unwrap(),\n+\t\t\t\t\tTypeId::ANY_TYPE,\n+\t\t\t\t\tself,\n+\t\t\t\t\tchecking_data,\n+\t\t\t\t);\n+\n+\t\t\t\tself.assign_to_array_destructure_handle_errors(\n+\t\t\t\t\tassignments,\n+\t\t\t\t\trhs,\n+\t\t\t\t\tassignment_span,\n+\t\t\t\t\tchecking_data,\n+\t\t\t\t)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfn assign_to_reference_assign_handle_errors<\n+\t\tT: crate::ReadFromFS,\n+\t\tA: crate::ASTImplementation,\n+\t>(\n+\t\t&mut self,\n+\t\treference: Reference,\n+\t\trhs: TypeId,\n+\t\tchecking_data: &mut CheckingData<T, A>,\n+\t\tassignment_span: source_map::BaseSpan<()>,\n+\t) -> TypeId {\n+\t\tlet result = self.set_reference(reference, rhs, checking_data);\n+\n+\t\tmatch result {\n+\t\t\tOk(ty) => ty,\n+\t\t\tErr(error) => {\n+\t\t\t\tlet error = set_property_error_to_type_check_error(\n+\t\t\t\t\tself,\n+\t\t\t\t\terror,\n+\t\t\t\t\tassignment_span.with_source(self.get_source()),\n+\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\trhs,\n+\t\t\t\t);\n+\t\t\t\tchecking_data.diagnostics_container.add_error(error);\n+\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfn assign_to_assign_only_handle_errors<T: crate::ReadFromFS, A: crate::ASTImplementation>(\n+\t\t&mut self,\n+\t\tlhs: Assignable<A>,\n+\t\trhs: TypeId,\n+\t\tassignment_span: Span,\n+\t\tchecking_data: &mut CheckingData<T, A>,\n+\t) -> TypeId {\n+\t\tmatch lhs {\n+\t\t\tAssignable::Reference(reference) => self.assign_to_reference_assign_handle_errors(\n+\t\t\t\treference,\n+\t\t\t\trhs,\n+\t\t\t\tchecking_data,\n+\t\t\t\tassignment_span,\n+\t\t\t),\n+\t\t\tAssignable::ObjectDestructuring(assignments) => self\n+\t\t\t\t.assign_to_object_destructure_handle_errors(\n+\t\t\t\t\tassignments,\n+\t\t\t\t\trhs,\n+\t\t\t\t\tassignment_span,\n+\t\t\t\t\tchecking_data,\n+\t\t\t\t),\n+\t\t\tAssignable::ArrayDestructuring(assignments) => self\n+\t\t\t\t.assign_to_array_destructure_handle_errors(\n+\t\t\t\t\tassignments,\n+\t\t\t\t\trhs,\n+\t\t\t\t\tassignment_span,\n+\t\t\t\t\tchecking_data,\n+\t\t\t\t),\n+\t\t}\n+\t}\n+\n+\tfn assign_to_object_destructure_handle_errors<\n+\t\tT: crate::ReadFromFS,\n+\t\tA: crate::ASTImplementation,\n+\t>(\n+\t\t&mut self,\n+\t\tassignments: Vec<AssignableObjectDestructuringField<A>>,\n+\t\trhs: TypeId,\n+\t\tassignment_span: Span,\n+\t\tchecking_data: &mut CheckingData<T, A>,\n+\t) -> TypeId {\n+\t\tfor assignment in assignments {\n+\t\t\tmatch assignment {\n+\t\t\t\tAssignableObjectDestructuringField::Mapped {\n+\t\t\t\t\ton,\n+\t\t\t\t\tname,\n+\t\t\t\t\tdefault_value,\n+\t\t\t\t\tposition,\n+\t\t\t\t} => {\n+\t\t\t\t\tlet value = self.get_property(\n+\t\t\t\t\t\trhs,\n+\t\t\t\t\t\tPublicity::Public,\n+\t\t\t\t\t\t&on,\n+\t\t\t\t\t\t&mut checking_data.types,\n+\t\t\t\t\t\tNone,\n+\t\t\t\t\t\tposition,\n+\t\t\t\t\t\t&checking_data.options,\n+\t\t\t\t\t\tfalse,\n+\t\t\t\t\t);\n+\n+\t\t\t\t\tlet rhs_value = if let Some((_, value)) = value {\n+\t\t\t\t\t\tvalue\n+\t\t\t\t\t} else if let Some(default_value) = default_value {\n+\t\t\t\t\t\tA::synthesise_expression(\n+\t\t\t\t\t\t\tdefault_value.as_ref(),\n+\t\t\t\t\t\t\tTypeId::ANY_TYPE,\n+\t\t\t\t\t\t\tself,\n+\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n+\t\t\t\t\t\t\tTypeCheckError::PropertyDoesNotExist {\n+\t\t\t\t\t\t\t\tproperty: match on {\n+\t\t\t\t\t\t\t\t\tPropertyKey::String(s) => {\n+\t\t\t\t\t\t\t\t\t\tPropertyRepresentation::StringKey(s.to_string())\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tPropertyKey::Type(t) => PropertyRepresentation::Type(\n+\t\t\t\t\t\t\t\t\t\tprinting::print_type(t, &checking_data.types, self, false),\n+\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\ton: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\trhs,\n+\t\t\t\t\t\t\t\t\tself,\n+\t\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\tsite: position,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t};\n+\n+\t\t\t\t\tself.assign_to_assign_only_handle_errors(\n+\t\t\t\t\t\tname,\n+\t\t\t\t\t\trhs_value,\n+\t\t\t\t\t\tassignment_span,\n+\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t\tAssignableObjectDestructuringField::Spread(_, _) => todo!(),\n+\t\t\t}\n+\t\t}\n+\n+\t\trhs\n+\t}\n+\n+\t#[allow(clippy::needless_pass_by_value)]\n+\tfn assign_to_array_destructure_handle_errors<\n+\t\tT: crate::ReadFromFS,\n+\t\tA: crate::ASTImplementation,\n+\t>(\n+\t\t&mut self,\n+\t\t_assignments: Vec<AssignableArrayDestructuringField<A>>,\n+\t\t_rhs: TypeId,\n+\t\tassignment_span: Span,\n+\t\tchecking_data: &mut CheckingData<T, A>,\n+\t) -> TypeId {\n+\t\tchecking_data.raise_unimplemented_error(\n+\t\t\t\"destructuring array (needs iterator)\",\n+\t\t\tassignment_span.with_source(self.get_source()),\n+\t\t);\n+\n+\t\tTypeId::ERROR_TYPE\n+\t}\n+\n+\tfn get_reference<U: crate::ReadFromFS, A: crate::ASTImplementation>(\n+\t\t&mut self,\n+\t\treference: Reference,\n+\t\tchecking_data: &mut CheckingData<U, A>,\n+\t\tbind_this: bool,\n+\t) -> TypeId {\n+\t\tmatch reference {\n+\t\t\tReference::Variable(name, position) => {\n+\t\t\t\tself.get_variable_handle_error(&name, position, checking_data).unwrap().1\n+\t\t\t}\n+\t\t\tReference::Property { on, with, publicity, span } => {\n+\t\t\t\tlet get_property_handle_errors = self.get_property_handle_errors(\n+\t\t\t\t\ton,\n+\t\t\t\t\tpublicity,\n+\t\t\t\t\t&with,\n+\t\t\t\t\tchecking_data,\n+\t\t\t\t\tspan,\n+\t\t\t\t\tbind_this,\n+\t\t\t\t);\n+\t\t\t\tmatch get_property_handle_errors {\n+\t\t\t\t\tOk(i) => i.get_value(),\n+\t\t\t\t\tErr(()) => TypeId::ERROR_TYPE,\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfn set_reference<U: crate::ReadFromFS, A: crate::ASTImplementation>(\n+\t\t&mut self,\n+\t\treference: Reference,\n+\t\trhs: TypeId,\n+\t\tchecking_data: &mut CheckingData<U, A>,\n+\t) -> Result<TypeId, SetPropertyError> {\n+\t\tmatch reference {\n+\t\t\tReference::Variable(name, position) => Ok(self.assign_to_variable_handle_errors(\n+\t\t\t\tname.as_str(),\n+\t\t\t\tposition,\n+\t\t\t\trhs,\n+\t\t\t\tchecking_data,\n+\t\t\t)),\n+\t\t\tReference::Property { on, with, publicity, span } => Ok(self\n+\t\t\t\t.set_property(\n+\t\t\t\t\ton,\n+\t\t\t\t\tpublicity,\n+\t\t\t\t\t&with,\n+\t\t\t\t\trhs,\n+\t\t\t\t\t&mut checking_data.types,\n+\t\t\t\t\tSome(span),\n+\t\t\t\t\t&checking_data.options,\n+\t\t\t\t)?\n+\t\t\t\t.unwrap_or(rhs)),\n \t\t}\n \t}\n \ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -665,8 +822,9 @@ impl<'a> Environment<'a> {\n \t\tproperty: &PropertyKey,\n \t\ttypes: &mut TypeStore,\n \t\twith: Option<TypeId>,\n-\t\tposition: Span,\n+\t\tposition: SpanWithSource,\n \t\toptions: &TypeCheckOptions,\n+\t\tbind_this: bool,\n \t) -> Option<(PropertyKind, TypeId)> {\n \t\tcrate::types::properties::get_property(\n \t\t\ton,\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -676,7 +834,8 @@ impl<'a> Environment<'a> {\n \t\t\tself,\n \t\t\t&mut CheckThings { debug_types: options.debug_types },\n \t\t\ttypes,\n-\t\t\tposition.with_source(self.get_source()),\n+\t\t\tposition,\n+\t\t\tbind_this,\n \t\t)\n \t}\n \ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -686,7 +845,8 @@ impl<'a> Environment<'a> {\n \t\tpublicity: Publicity,\n \t\tkey: &PropertyKey,\n \t\tchecking_data: &mut CheckingData<U, A>,\n-\t\tsite: Span,\n+\t\tsite: SpanWithSource,\n+\t\tbind_this: bool,\n \t) -> Result<Instance, ()> {\n \t\tlet get_property = self.get_property(\n \t\t\ton,\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -696,6 +856,7 @@ impl<'a> Environment<'a> {\n \t\t\tNone,\n \t\t\tsite,\n \t\t\t&checking_data.options,\n+\t\t\tbind_this,\n \t\t);\n \n \t\tif let Some((kind, result)) = get_property {\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -708,12 +869,13 @@ impl<'a> Environment<'a> {\n \t\t\tchecking_data.diagnostics_container.add_error(TypeCheckError::PropertyDoesNotExist {\n \t\t\t\t// TODO printing temp\n \t\t\t\tproperty: match key {\n-\t\t\t\t\tPropertyKey::String(s) => {\n-\t\t\t\t\t\tcrate::diagnostics::PropertyRepresentation::StringKey(s.to_string())\n-\t\t\t\t\t}\n-\t\t\t\t\tPropertyKey::Type(t) => crate::diagnostics::PropertyRepresentation::Type(\n-\t\t\t\t\t\tcrate::types::printing::print_type(*t, &checking_data.types, self, false),\n-\t\t\t\t\t),\n+\t\t\t\t\tPropertyKey::String(s) => PropertyRepresentation::StringKey(s.to_string()),\n+\t\t\t\t\tPropertyKey::Type(t) => PropertyRepresentation::Type(printing::print_type(\n+\t\t\t\t\t\t*t,\n+\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\tself,\n+\t\t\t\t\t\tfalse,\n+\t\t\t\t\t)),\n \t\t\t\t},\n \t\t\t\ton: crate::diagnostics::TypeStringRepresentation::from_type_id(\n \t\t\t\t\ton,\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -721,7 +883,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t&checking_data.types,\n \t\t\t\t\tfalse,\n \t\t\t\t),\n-\t\t\t\tsite: site.with_source(self.get_source()),\n+\t\t\t\tsite,\n \t\t\t});\n \t\t\tErr(())\n \t\t}\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -1219,3 +1381,22 @@ impl<'a> Environment<'a> {\n \t\tNone\n \t}\n }\n+\n+fn set_property_error_to_type_check_error(\n+\tctx: &impl InformationChain,\n+\terror: SetPropertyError,\n+\tassignment_span: SpanWithSource,\n+\ttypes: &TypeStore,\n+\tnew: TypeId,\n+) -> TypeCheckError<'static> {\n+\tmatch error {\n+\t\tSetPropertyError::NotWriteable => TypeCheckError::PropertyNotWriteable(assignment_span),\n+\t\tSetPropertyError::DoesNotMeetConstraint { property_constraint, reason: _ } => {\n+\t\t\tTypeCheckError::AssignmentError(AssignmentError::PropertyConstraint {\n+\t\t\t\tproperty_constraint,\n+\t\t\t\tvalue_type: TypeStringRepresentation::from_type_id(new, ctx, types, false),\n+\t\t\t\tassignment_position: assignment_span,\n+\t\t\t})\n+\t\t}\n+\t}\n+}\ndiff --git a/checker/src/context/information.rs b/checker/src/context/information.rs\n--- a/checker/src/context/information.rs\n+++ b/checker/src/context/information.rs\n@@ -41,7 +41,7 @@ pub struct LocalInformation {\n \n \t/// Object type (LHS), must always be RHS\n \t///\n-\t/// *not quite the best place, but used in InformationChain*\n+\t/// *not quite the best place, but used in [`InformationChain`]*\n \tpub(crate) object_constraints: HashMap<TypeId, TypeId>,\n \n \t/// For super calls etc\ndiff --git a/checker/src/context/information.rs b/checker/src/context/information.rs\n--- a/checker/src/context/information.rs\n+++ b/checker/src/context/information.rs\n@@ -237,7 +237,7 @@ pub(crate) fn get_property_unbound(\n \t// \tunder @ PropertyKey::String(_) => under,\n \t// };\n \n-\ttypes.get_fact_about_type(info, on, None, &get_property, (publicity, &under))\n+\ttypes.get_fact_about_type(info, on, None, &get_property, (publicity, under))\n }\n \n fn get_property_under(\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -168,7 +168,7 @@ pub struct Context<T: ContextType> {\n \tpub(crate) deferred_function_constraints: HashMap<FunctionId, (FunctionType, SpanWithSource)>,\n \tpub(crate) bases: bases::Bases,\n \n-\t/// TODO replace with info.value_of_this\n+\t/// TODO replace with `info.value_of_this`\n \tpub(crate) can_reference_this: CanReferenceThis,\n \n \t/// When a objects `TypeId` is in here getting a property returns a constructor rather than\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -459,7 +459,7 @@ mod defined_errors_and_warnings {\n \t\t\t\t\t\tif let Some((restriction_pos, restriction)) = restriction {\n \t\t\t\t\t\t\tDiagnostic::PositionWithAdditionalLabels {\n \t\t\t\t\t\t\t\treason: format!(\n-\t\t\t\t\t\t\t\t\t\"Argument of type {argument_type} is not assignable to parameter of type {restriction}\" \n+\t\t\t\t\t\t\t\t\t\"Argument of type {argument_type} is not assignable to parameter of type {restriction}\"\n \t\t\t\t\t\t\t\t),\n \t\t\t\t\t\t\t\tposition: argument_position,\n \t\t\t\t\t\t\t\tlabels: vec![(\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -558,6 +558,13 @@ mod defined_errors_and_warnings {\n \t\t\t\t\t\t\tkind,\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\tFunctionCallingError::MismatchedThis { call_site, expected, found } => Diagnostic::Position {\n+\t\t\t\t\t\treason: format!(\n+\t\t\t\t\t\t\t\"The 'this' context of the function is expected to be {expected}, found {found}\"\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tposition: call_site,\n+\t\t\t\t\t\tkind,\n+\t\t\t\t\t},\n \t\t\t\t},\n \t\t\t\tTypeCheckError::AssignmentError(error) => match error {\n \t\t\t\t\tAssignmentError::DoesNotMeetConstraint {\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -95,9 +95,17 @@ pub(crate) fn apply_event(\n \t\t\t\tunder @ PropertyKey::String(_) => under,\n \t\t\t};\n \n-\t\t\tlet Some((_, value)) =\n-\t\t\t\tget_property(on, publicity, &under, None, environment, target, types, position)\n-\t\t\telse {\n+\t\t\tlet Some((_, value)) = get_property(\n+\t\t\t\ton,\n+\t\t\t\tpublicity,\n+\t\t\t\t&under,\n+\t\t\t\tNone,\n+\t\t\t\tenvironment,\n+\t\t\t\ttarget,\n+\t\t\t\ttypes,\n+\t\t\t\tposition,\n+\t\t\t\ttrue,\n+\t\t\t) else {\n \t\t\t\tpanic!(\n \t\t\t\t\t\"could not get property {under:?} at {position:?} on {}, (inference or some checking failed)\",\n \t\t\t\t\tprint_type(on, types, environment, true)\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -71,7 +71,7 @@ pub enum Event {\n \t\tnew: PropertyValue,\n \t\t/// THIS DOES NOT CALL SETTERS, JUST SETS VALUE!\n \t\t/// TODO this is [define] property\n-\t\t/// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields\n+\t\t/// see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields>\n \t\tinitialization: bool,\n \t\tpublicity: Publicity,\n \t\tposition: Option<SpanWithSource>,\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -107,7 +107,7 @@ pub enum Event {\n \t/// - Creating objects with prototypes:\n \t///     - Arrays\n \t///     - Map & Sets\n-\t///     - HTMLElement and derivatives\n+\t///     - `HTMLElement` and derivatives\n \t///\n \t/// ```typescript\n \t/// function x() {\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -119,7 +119,7 @@ pub enum Event {\n \t/// not in externally referenced set or something\n \tCreateObject {\n \t\tprototype: PrototypeArgument,\n-\t\t/// This is the id referencing a [Type::AliasTo] that is created\n+\t\t/// This is the id referencing a [`Type::AliasTo`] that is created\n \t\t///\n \t\t/// This is also for the specialisation (somehow)\n \t\treferenced_in_scope_as: TypeId,\ndiff --git a/checker/src/features/assignments.rs b/checker/src/features/assignments.rs\n--- a/checker/src/features/assignments.rs\n+++ b/checker/src/features/assignments.rs\n@@ -4,10 +4,10 @@ use crate::{context::information::Publicity, types::properties::PropertyKey, Typ\n \n use super::operations::{LogicalOperator, MathematicalAndBitwise};\n \n-pub enum Assignable {\n+pub enum Assignable<A: crate::ASTImplementation> {\n \tReference(Reference),\n-\tObjectDestructuring(Vec<(PropertyKey<'static>, Assignable)>),\n-\tArrayDestructuring(Vec<Option<Assignable>>),\n+\tObjectDestructuring(Vec<AssignableObjectDestructuringField<A>>),\n+\tArrayDestructuring(Vec<AssignableArrayDestructuringField<A>>),\n }\n \n // TODO derive copy, when span derives copy\ndiff --git a/checker/src/features/assignments.rs b/checker/src/features/assignments.rs\n--- a/checker/src/features/assignments.rs\n+++ b/checker/src/features/assignments.rs\n@@ -18,6 +18,25 @@ pub enum Reference {\n \tProperty { on: TypeId, with: PropertyKey<'static>, publicity: Publicity, span: SpanWithSource },\n }\n \n+pub enum AssignableObjectDestructuringField<A: crate::ASTImplementation> {\n+\t/// `{ x: y }`\n+\tMapped {\n+\t\ton: PropertyKey<'static>,\n+\t\tname: Assignable<A>,\n+\t\tdefault_value: Option<Box<A::Expression<'static>>>,\n+\t\tposition: SpanWithSource,\n+\t},\n+\t/// `{ ...x }`\n+\tSpread(Assignable<A>, SpanWithSource),\n+}\n+\n+pub enum AssignableArrayDestructuringField<A: crate::ASTImplementation> {\n+\tSpread(Assignable<A>, SpanWithSource),\n+\tName(Assignable<A>, Option<Box<A::Expression<'static>>>),\n+\tComment { content: String, is_multiline: bool, position: SpanWithSource },\n+\tNone,\n+}\n+\n /// Increment and decrement are are not binary add subtract as they cast their lhs to number\n pub enum AssignmentKind {\n \tAssign,\ndiff --git a/checker/src/features/functions.rs b/checker/src/features/functions.rs\n--- a/checker/src/features/functions.rs\n+++ b/checker/src/features/functions.rs\n@@ -371,7 +371,7 @@ pub enum FunctionRegisterBehavior<'a, A: crate::ASTImplementation> {\n \t},\n \tConstructor {\n \t\tprototype: TypeId,\n-\t\t/// Is this is_some then can use `super()`\n+\t\t/// Is this [`Option::is_some`] then can use `super()`\n \t\tsuper_type: Option<TypeId>,\n \t\tproperties: ClassPropertiesToRegister<'a, A>,\n \t},\ndiff --git a/checker/src/features/variables.rs b/checker/src/features/variables.rs\n--- a/checker/src/features/variables.rs\n+++ b/checker/src/features/variables.rs\n@@ -19,7 +19,7 @@ pub enum VariableOrImport {\n \t\t/// Whether can be reassigned and what to\n \t\tmutability: VariableMutability,\n \t\t/// Location where variable is defined **ALSO UNIQUELY IDENTIFIES THE VARIABLE** as can\n-\t\t/// be turned into a [VariableId]\n+\t\t/// be turned into a [`VariableId`]\n \t\tdeclared_at: SpanWithSource,\n \t\tcontext: ContextLocation,\n \t},\ndiff --git a/checker/src/features/variables.rs b/checker/src/features/variables.rs\n--- a/checker/src/features/variables.rs\n+++ b/checker/src/features/variables.rs\n@@ -136,6 +136,8 @@ pub fn get_new_register_argument_under<T: crate::ReadFromFS, A: crate::ASTImplem\n \tchecking_data: &mut CheckingData<T, A>,\n \tat: Span,\n ) -> VariableRegisterArguments {\n+\tlet position = at.with_source(environment.get_source());\n+\n \tlet space = on.space.map(|space| {\n \t\tlet property_constraint = get_property_unbound(\n \t\t\tspace,\ndiff --git a/checker/src/features/variables.rs b/checker/src/features/variables.rs\n--- a/checker/src/features/variables.rs\n+++ b/checker/src/features/variables.rs\n@@ -168,7 +170,7 @@ pub fn get_new_register_argument_under<T: crate::ReadFromFS, A: crate::ASTImplem\n \t\t\t\t\t&checking_data.types,\n \t\t\t\t\tfalse,\n \t\t\t\t),\n-\t\t\t\tsite: at.with_source(environment.get_source()),\n+\t\t\t\tsite: position,\n \t\t\t});\n \t\t\tTypeId::ERROR_TYPE\n \t\t}\ndiff --git a/checker/src/features/variables.rs b/checker/src/features/variables.rs\n--- a/checker/src/features/variables.rs\n+++ b/checker/src/features/variables.rs\n@@ -176,7 +178,14 @@ pub fn get_new_register_argument_under<T: crate::ReadFromFS, A: crate::ASTImplem\n \n \tlet initial_value = on.initial_value.map(|initial_value| {\n \t\tenvironment\n-\t\t\t.get_property_handle_errors(initial_value, Publicity::Public, under, checking_data, at)\n+\t\t\t.get_property_handle_errors(\n+\t\t\t\tinitial_value,\n+\t\t\t\tPublicity::Public,\n+\t\t\t\tunder,\n+\t\t\t\tchecking_data,\n+\t\t\t\tposition,\n+\t\t\t\ttrue,\n+\t\t\t)\n \t\t\t.map_or(TypeId::ERROR_TYPE, Instance::get_value)\n \t});\n \ndiff --git a/checker/src/lib.rs b/checker/src/lib.rs\n--- a/checker/src/lib.rs\n+++ b/checker/src/lib.rs\n@@ -133,8 +133,8 @@ pub trait ASTImplementation: Sized {\n \t) -> (Names, LocalInformation);\n \n \t/// Expected is used for eagerly setting function parameters\n-\tfn synthesise_expression<'a, T: crate::ReadFromFS>(\n-\t\texpression: &'a Self::Expression<'a>,\n+\tfn synthesise_expression<T: crate::ReadFromFS>(\n+\t\texpression: &Self::Expression<'_>,\n \t\texpected_type: TypeId,\n \t\tenvironment: &mut Environment,\n \t\tchecking_data: &mut crate::CheckingData<T, Self>,\ndiff --git a/checker/src/options.rs b/checker/src/options.rs\n--- a/checker/src/options.rs\n+++ b/checker/src/options.rs\n@@ -16,7 +16,7 @@ pub struct TypeCheckOptions {\n \t/// Given a `function x`, `x = 2` is not possible\n \tpub constant_function_declarations: bool,\n \n-\t/// Whether auto casts can happen. aka `{} + 2` is allowed using Object[ToPrimitiveDefault]\n+\t/// Whether auto casts can happen. aka `{} + 2` is allowed using the Object's primitive default\n \t/// TODO maybe levels\n \tpub strict_casts: bool,\n \ndiff --git a/checker/src/synthesis/assignments.rs b/checker/src/synthesis/assignments.rs\n--- a/checker/src/synthesis/assignments.rs\n+++ b/checker/src/synthesis/assignments.rs\n@@ -1,12 +1,16 @@\n use std::borrow::Cow;\n \n use parser::{\n-\tast::LHSOfAssignment, expressions::assignments::VariableOrPropertyAccess, VariableIdentifier,\n+\tast::LHSOfAssignment, expressions::assignments::VariableOrPropertyAccess, VariableField,\n+\tVariableIdentifier,\n };\n \n use crate::{\n \tcontext::{information::Publicity, Environment},\n-\tfeatures::assignments::{Assignable, Reference},\n+\tfeatures::assignments::{\n+\t\tAssignable, AssignableArrayDestructuringField, AssignableObjectDestructuringField,\n+\t\tReference,\n+\t},\n \tsynthesis::expressions::synthesise_expression,\n \ttypes::properties::PropertyKey,\n \tCheckingData, TypeId,\ndiff --git a/checker/src/synthesis/assignments.rs b/checker/src/synthesis/assignments.rs\n--- a/checker/src/synthesis/assignments.rs\n+++ b/checker/src/synthesis/assignments.rs\n@@ -20,89 +24,131 @@ pub(super) fn synthesise_lhs_of_assignment_to_reference<T: crate::ReadFromFS>(\n \tlhs: &LHSOfAssignment,\n \tenvironment: &mut Environment,\n \tchecking_data: &mut CheckingData<T, super::EznoParser>,\n-) -> Assignable {\n+) -> Assignable<super::EznoParser> {\n \tmatch lhs {\n-\t\tLHSOfAssignment::ObjectDestructuring(items, _) => Assignable::ObjectDestructuring(\n-\t\t\titems\n-\t\t\t\t.iter()\n-\t\t\t\t.map(|item| match item.get_ast_ref() {\n-\t\t\t\t\tparser::ObjectDestructuringField::Name(name, _, _) => {\n-\t\t\t\t\t\tlet on = if let VariableIdentifier::Standard(name, _) = name {\n-\t\t\t\t\t\t\tPropertyKey::String(Cow::Owned(name.clone()))\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\ttodo!()\n-\t\t\t\t\t\t};\n-\t\t\t\t\t\t(\n-\t\t\t\t\t\t\ton,\n-\t\t\t\t\t\t\tsynthesise_object_shorthand_assignable(\n-\t\t\t\t\t\t\t\tname,\n-\t\t\t\t\t\t\t\tchecking_data,\n-\t\t\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t)\n-\t\t\t\t\t}\n-\t\t\t\t\tparser::ObjectDestructuringField::Spread(_, _) => todo!(),\n-\t\t\t\t\tparser::ObjectDestructuringField::Map {\n-\t\t\t\t\t\tfrom,\n-\t\t\t\t\t\tname,\n-\t\t\t\t\t\tdefault_value: _,\n-\t\t\t\t\t\tposition: _,\n-\t\t\t\t\t} => {\n-\t\t\t\t\t\t// TODO into function\n-\t\t\t\t\t\tmatch name.get_ast_ref() {\n-\t\t\t\t\t\t\tparser::VariableField::Name(name) => {\n-\t\t\t\t\t\t\t\tlet on = parser_property_key_to_checker_property_key(\n-\t\t\t\t\t\t\t\t\tfrom,\n-\t\t\t\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\t\t\t\tchecking_data,\n-\t\t\t\t\t\t\t\t\ttrue,\n-\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t\tlet a = synthesise_object_shorthand_assignable(\n-\t\t\t\t\t\t\t\t\tname,\n-\t\t\t\t\t\t\t\t\tchecking_data,\n-\t\t\t\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t\t(on, a)\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tparser::VariableField::Array(_, _) => todo!(),\n-\t\t\t\t\t\t\tparser::VariableField::Object(_, _) => todo!(),\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t})\n-\t\t\t\t.collect(),\n-\t\t),\n-\t\tLHSOfAssignment::ArrayDestructuring(items, _) => Assignable::ArrayDestructuring(\n-\t\t\titems\n-\t\t\t\t.iter()\n-\t\t\t\t.map(|item| match item.get_ast_ref() {\n-\t\t\t\t\tparser::ArrayDestructuringField::Spread(_, _) => todo!(),\n-\t\t\t\t\tparser::ArrayDestructuringField::Name(name, _) => match name {\n-\t\t\t\t\t\tparser::VariableField::Name(name) => {\n-\t\t\t\t\t\t\tSome(synthesise_object_shorthand_assignable(\n-\t\t\t\t\t\t\t\tname,\n-\t\t\t\t\t\t\t\tchecking_data,\n-\t\t\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\t\t))\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tparser::VariableField::Array(_, _) => todo!(),\n-\t\t\t\t\t\tparser::VariableField::Object(_, _) => todo!(),\n-\t\t\t\t\t},\n-\t\t\t\t\tparser::ArrayDestructuringField::Comment { .. }\n-\t\t\t\t\t| parser::ArrayDestructuringField::None => None,\n-\t\t\t\t})\n-\t\t\t\t.collect(),\n-\t\t),\n+\t\tLHSOfAssignment::ObjectDestructuring(items, _) => {\n+\t\t\tsynthesise_object_to_reference(items, environment, checking_data)\n+\t\t}\n+\t\tLHSOfAssignment::ArrayDestructuring(items, _) => {\n+\t\t\tsynthesise_array_to_reference(items, environment, checking_data)\n+\t\t}\n \t\tLHSOfAssignment::VariableOrPropertyAccess(access) => Assignable::Reference(\n \t\t\tsynthesise_access_to_reference(access, environment, checking_data),\n \t\t),\n \t}\n }\n \n+fn synthesise_variable_field_to_reference<T: crate::ReadFromFS>(\n+\tvariable_field: &VariableField,\n+\tenvironment: &mut Environment,\n+\tchecking_data: &mut CheckingData<T, super::EznoParser>,\n+) -> Assignable<super::EznoParser> {\n+\tmatch variable_field {\n+\t\tVariableField::Object(items, _) => {\n+\t\t\tsynthesise_object_to_reference(items, environment, checking_data)\n+\t\t}\n+\t\tVariableField::Array(items, _) => {\n+\t\t\tsynthesise_array_to_reference(items, environment, checking_data)\n+\t\t}\n+\t\tVariableField::Name(ident) => Assignable::Reference(match ident {\n+\t\t\tVariableIdentifier::Standard(name, position) => {\n+\t\t\t\tReference::Variable(name.clone(), position.with_source(environment.get_source()))\n+\t\t\t}\n+\t\t\tVariableIdentifier::Marker(_, _) => todo!(),\n+\t\t}),\n+\t}\n+}\n+\n+fn synthesise_object_to_reference<T: crate::ReadFromFS>(\n+\titems: &[parser::WithComment<parser::ObjectDestructuringField>],\n+\tenvironment: &mut Environment,\n+\tchecking_data: &mut CheckingData<T, super::EznoParser>,\n+) -> Assignable<super::EznoParser> {\n+\tAssignable::ObjectDestructuring(\n+\t\titems\n+\t\t\t.iter()\n+\t\t\t.map(|item| match item.get_ast_ref() {\n+\t\t\t\tparser::ObjectDestructuringField::Name(name, default_value, position) => {\n+\t\t\t\t\tAssignableObjectDestructuringField::Mapped {\n+\t\t\t\t\t\ton: synthesise_object_property_key(name, environment),\n+\t\t\t\t\t\tname: synthesise_object_shorthand_assignable(\n+\t\t\t\t\t\t\tname,\n+\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tdefault_value: default_value.clone(),\n+\t\t\t\t\t\tposition: position.with_source(environment.get_source()),\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tparser::ObjectDestructuringField::Spread(name, position) => {\n+\t\t\t\t\tAssignableObjectDestructuringField::Spread(\n+\t\t\t\t\t\tsynthesise_object_shorthand_assignable(name, environment, checking_data),\n+\t\t\t\t\t\tposition.with_source(environment.get_source()),\n+\t\t\t\t\t)\n+\t\t\t\t}\n+\t\t\t\tparser::ObjectDestructuringField::Map { from, name, default_value, position } => {\n+\t\t\t\t\tlet on = parser_property_key_to_checker_property_key(\n+\t\t\t\t\t\tfrom,\n+\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\ttrue,\n+\t\t\t\t\t);\n+\n+\t\t\t\t\tAssignableObjectDestructuringField::Mapped {\n+\t\t\t\t\t\ton,\n+\t\t\t\t\t\tname: synthesise_variable_field_to_reference(\n+\t\t\t\t\t\t\tname.get_ast_ref(),\n+\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tdefault_value: default_value.clone(),\n+\t\t\t\t\t\tposition: position.with_source(environment.get_source()),\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\t.collect(),\n+\t)\n+}\n+\n+fn synthesise_array_to_reference<T: crate::ReadFromFS>(\n+\titems: &[parser::WithComment<parser::ArrayDestructuringField>],\n+\tenvironment: &mut Environment,\n+\tchecking_data: &mut CheckingData<T, super::EznoParser>,\n+) -> Assignable<super::EznoParser> {\n+\tAssignable::ArrayDestructuring(\n+\t\titems\n+\t\t\t.iter()\n+\t\t\t.map(|item| match item.get_ast_ref() {\n+\t\t\t\tparser::ArrayDestructuringField::Spread(name, position) => {\n+\t\t\t\t\tAssignableArrayDestructuringField::Spread(\n+\t\t\t\t\t\tsynthesise_variable_field_to_reference(name, environment, checking_data),\n+\t\t\t\t\t\tposition.with_source(environment.get_source()),\n+\t\t\t\t\t)\n+\t\t\t\t}\n+\t\t\t\tparser::ArrayDestructuringField::Name(name, default_value) => {\n+\t\t\t\t\tAssignableArrayDestructuringField::Name(\n+\t\t\t\t\t\tsynthesise_variable_field_to_reference(name, environment, checking_data),\n+\t\t\t\t\t\tdefault_value.clone(),\n+\t\t\t\t\t)\n+\t\t\t\t}\n+\t\t\t\tparser::ArrayDestructuringField::Comment { content, is_multiline, position } => {\n+\t\t\t\t\tAssignableArrayDestructuringField::Comment {\n+\t\t\t\t\t\tcontent: content.clone(),\n+\t\t\t\t\t\tis_multiline: *is_multiline,\n+\t\t\t\t\t\tposition: position.with_source(environment.get_source()),\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tparser::ArrayDestructuringField::None => AssignableArrayDestructuringField::None,\n+\t\t\t})\n+\t\t\t.collect(),\n+\t)\n+}\n+\n fn synthesise_object_shorthand_assignable<T: crate::ReadFromFS>(\n \tname: &parser::VariableIdentifier,\n-\t_checking_data: &CheckingData<T, super::EznoParser>,\n \tenvironment: &Environment,\n-) -> Assignable {\n+\t_checking_data: &CheckingData<T, super::EznoParser>,\n+) -> Assignable<super::EznoParser> {\n \tmatch name {\n \t\tparser::VariableIdentifier::Standard(name, pos) => Assignable::Reference(\n \t\t\tReference::Variable(name.clone(), pos.with_source(environment.get_source())),\ndiff --git a/checker/src/synthesis/assignments.rs b/checker/src/synthesis/assignments.rs\n--- a/checker/src/synthesis/assignments.rs\n+++ b/checker/src/synthesis/assignments.rs\n@@ -111,6 +157,18 @@ fn synthesise_object_shorthand_assignable<T: crate::ReadFromFS>(\n \t}\n }\n \n+fn synthesise_object_property_key(\n+\tname: &parser::VariableIdentifier,\n+\tenvironment: &Environment,\n+) -> PropertyKey<'static> {\n+\tmatch name {\n+\t\tparser::VariableIdentifier::Standard(name, pos) => {\n+\t\t\tPropertyKey::String(Cow::Owned(name.to_owned()))\n+\t\t}\n+\t\tparser::VariableIdentifier::Marker(..) => todo!(),\n+\t}\n+}\n+\n pub(crate) fn synthesise_access_to_reference<T: crate::ReadFromFS>(\n \tvariable_or_property_access: &VariableOrPropertyAccess,\n \tenvironment: &mut Environment,\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -429,8 +429,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t}\n \t\t}\n \t\tExpression::Assignment { lhs, rhs, position } => {\n-\t\t\tlet lhs: Assignable =\n-\t\t\t\tsynthesise_lhs_of_assignment_to_reference(lhs, environment, checking_data);\n+\t\t\tlet lhs = synthesise_lhs_of_assignment_to_reference(lhs, environment, checking_data);\n \n \t\t\treturn environment.assign_to_assignable_handle_errors(\n \t\t\t\tlhs,\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -441,7 +440,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t);\n \t\t}\n \t\tExpression::BinaryAssignmentOperation { lhs, operator, rhs, position } => {\n-\t\t\tlet lhs: Assignable = Assignable::Reference(synthesise_access_to_reference(\n+\t\t\tlet lhs = Assignable::Reference(synthesise_access_to_reference(\n \t\t\t\tlhs,\n \t\t\t\tenvironment,\n \t\t\t\tchecking_data,\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -456,7 +455,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t);\n \t\t}\n \t\tExpression::UnaryPrefixAssignmentOperation { operator, operand, position } => {\n-\t\t\tlet lhs: Assignable = Assignable::Reference(synthesise_access_to_reference(\n+\t\t\tlet lhs = Assignable::Reference(synthesise_access_to_reference(\n \t\t\t\toperand,\n \t\t\t\tenvironment,\n \t\t\t\tchecking_data,\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -486,7 +485,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t}\n \t\t}\n \t\tExpression::UnaryPostfixAssignmentOperation { operand, operator, position } => {\n-\t\t\tlet lhs: Assignable = Assignable::Reference(synthesise_access_to_reference(\n+\t\t\tlet lhs = Assignable::Reference(synthesise_access_to_reference(\n \t\t\t\toperand,\n \t\t\t\tenvironment,\n \t\t\t\tchecking_data,\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -549,7 +548,8 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\tpublicity,\n \t\t\t\t&property,\n \t\t\t\tchecking_data,\n-\t\t\t\t*position,\n+\t\t\t\tposition.with_source(environment.get_source()),\n+\t\t\t\ttrue,\n \t\t\t);\n \n \t\t\tmatch result {\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -573,7 +573,8 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\tPublicity::Public,\n \t\t\t\t&PropertyKey::from_type(indexer, &checking_data.types),\n \t\t\t\tchecking_data,\n-\t\t\t\t*position,\n+\t\t\t\tposition.with_source(environment.get_source()),\n+\t\t\t\ttrue,\n \t\t\t);\n \n \t\t\tmatch result {\ndiff --git a/checker/src/synthesis/variables.rs b/checker/src/synthesis/variables.rs\n--- a/checker/src/synthesis/variables.rs\n+++ b/checker/src/synthesis/variables.rs\n@@ -8,10 +8,10 @@ use parser::{\n use super::expressions::synthesise_expression;\n use crate::{\n \tcontext::{information::Publicity, Context, ContextType, VariableRegisterArguments},\n-\tdiagnostics::TypeCheckError,\n+\tdiagnostics::{PropertyRepresentation, TypeCheckError, TypeStringRepresentation},\n \tfeatures::variables::{get_new_register_argument_under, VariableMutability},\n \tsynthesis::parser_property_key_to_checker_property_key,\n-\ttypes::properties::PropertyKey,\n+\ttypes::{printing, properties::PropertyKey},\n \tCheckingData, Environment, TypeId,\n };\n \ndiff --git a/checker/src/synthesis/variables.rs b/checker/src/synthesis/variables.rs\n--- a/checker/src/synthesis/variables.rs\n+++ b/checker/src/synthesis/variables.rs\n@@ -268,8 +268,8 @@ fn assign_initial_to_fields<T: crate::ReadFromFS>(\n \t\t\t\tmatch item.get_ast_ref() {\n \t\t\t\t\tObjectDestructuringField::Spread(_, _) => todo!(),\n \t\t\t\t\tObjectDestructuringField::Name(name, default_value, _) => {\n-\t\t\t\t\t\tlet id =\n-\t\t\t\t\t\t\tcrate::VariableId(environment.get_source(), name.get_position().start);\n+\t\t\t\t\t\tlet position = name.get_position().with_source(environment.get_source());\n+\t\t\t\t\t\tlet id = crate::VariableId(environment.get_source(), position.start);\n \n \t\t\t\t\t\tlet key_ty = match name {\n \t\t\t\t\t\t\tVariableIdentifier::Standard(name, _) => {\ndiff --git a/checker/src/synthesis/variables.rs b/checker/src/synthesis/variables.rs\n--- a/checker/src/synthesis/variables.rs\n+++ b/checker/src/synthesis/variables.rs\n@@ -286,13 +286,13 @@ fn assign_initial_to_fields<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\t&key_ty,\n \t\t\t\t\t\t\t&mut checking_data.types,\n \t\t\t\t\t\t\tNone,\n-\t\t\t\t\t\t\tname.get_position(),\n+\t\t\t\t\t\t\tposition,\n \t\t\t\t\t\t\t&checking_data.options,\n+\t\t\t\t\t\t\tfalse,\n \t\t\t\t\t\t);\n \t\t\t\t\t\tlet value = match property {\n \t\t\t\t\t\t\tSome((_, value)) => value,\n \t\t\t\t\t\t\tNone => {\n-\t\t\t\t\t\t\t\t// TODO non decidable error\n \t\t\t\t\t\t\t\tif let Some(else_expression) = default_value {\n \t\t\t\t\t\t\t\t\tsynthesise_expression(\n \t\t\t\t\t\t\t\t\t\telse_expression,\ndiff --git a/checker/src/synthesis/variables.rs b/checker/src/synthesis/variables.rs\n--- a/checker/src/synthesis/variables.rs\n+++ b/checker/src/synthesis/variables.rs\n@@ -301,7 +301,33 @@ fn assign_initial_to_fields<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\t\t\t\tTypeId::ANY_TYPE,\n \t\t\t\t\t\t\t\t\t)\n \t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t// TODO emit error\n+\t\t\t\t\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n+\t\t\t\t\t\t\t\t\t\tTypeCheckError::PropertyDoesNotExist {\n+\t\t\t\t\t\t\t\t\t\t\tproperty: match key_ty {\n+\t\t\t\t\t\t\t\t\t\t\t\tPropertyKey::String(s) => {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tPropertyRepresentation::StringKey(s.to_string())\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tPropertyKey::Type(t) => {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tPropertyRepresentation::Type(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tprinting::print_type(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tt,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\t\t\t\ton: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\t\t\t\tvalue,\n+\t\t\t\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\t\t\t\tsite: position,\n+\t\t\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\t\t);\n+\n \t\t\t\t\t\t\t\t\tTypeId::ERROR_TYPE\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\ndiff --git a/checker/src/synthesis/variables.rs b/checker/src/synthesis/variables.rs\n--- a/checker/src/synthesis/variables.rs\n+++ b/checker/src/synthesis/variables.rs\n@@ -326,14 +352,14 @@ fn assign_initial_to_fields<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\t&key_ty,\n \t\t\t\t\t\t\t&mut checking_data.types,\n \t\t\t\t\t\t\tNone,\n-\t\t\t\t\t\t\t*position,\n+\t\t\t\t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\t\t\t\t&checking_data.options,\n+\t\t\t\t\t\t\tfalse,\n \t\t\t\t\t\t);\n \n \t\t\t\t\t\tlet value = match property_value {\n \t\t\t\t\t\t\tSome((_, value)) => value,\n \t\t\t\t\t\t\tNone => {\n-\t\t\t\t\t\t\t\t// TODO non decidable error\n \t\t\t\t\t\t\t\tif let Some(default_value) = default_value {\n \t\t\t\t\t\t\t\t\tsynthesise_expression(\n \t\t\t\t\t\t\t\t\t\tdefault_value,\ndiff --git a/checker/src/synthesis/variables.rs b/checker/src/synthesis/variables.rs\n--- a/checker/src/synthesis/variables.rs\n+++ b/checker/src/synthesis/variables.rs\n@@ -342,7 +368,33 @@ fn assign_initial_to_fields<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\t\t\t\tTypeId::ANY_TYPE,\n \t\t\t\t\t\t\t\t\t)\n \t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t// TODO emit error\n+\t\t\t\t\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n+\t\t\t\t\t\t\t\t\t\tTypeCheckError::PropertyDoesNotExist {\n+\t\t\t\t\t\t\t\t\t\t\tproperty: match key_ty {\n+\t\t\t\t\t\t\t\t\t\t\t\tPropertyKey::String(s) => {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tPropertyRepresentation::StringKey(s.to_string())\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t\tPropertyKey::Type(t) => {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tPropertyRepresentation::Type(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tprinting::print_type(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tt,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\t\t\t\ton: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\t\t\t\tvalue,\n+\t\t\t\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\t\t\t\tsite: position.with_source(environment.get_source()),\n+\t\t\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\t\t);\n+\n \t\t\t\t\t\t\t\t\tTypeId::ERROR_TYPE\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t}\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -55,7 +55,7 @@ struct FunctionLike {\n \tpub(crate) function: FunctionId,\n \t/// For generic calls\n \tpub(crate) from: Option<TypeId>,\n-\t/// From, maybe ignored if [CalledWithNew] overrides\n+\t/// From, maybe ignored if [`CalledWithNew`] overrides\n \tpub(crate) this_value: ThisValue,\n }\n \ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -270,18 +270,12 @@ fn get_logical_callable_from_type(\n \t\t\t\tLogical::Implies { on: Box::new(res), antecedent: generic.arguments.clone() }\n \t\t\t})\n \t\t}\n-\t\tType::Constructor(Constructor::Property { on, under: _, result, bind_this: true }) => {\n-\t\t\t// bind_this from #98\n-\t\t\t// Bind does not happen for theses calls, so done here *conditionally on `bind_this`*\n-\n+\t\tType::Constructor(Constructor::Property { on, under: _, result, bind_this }) => {\n \t\t\tcrate::utils::notify!(\"Passing {:?}\", on);\n \n-\t\t\tlet result = get_logical_callable_from_type(\n-\t\t\t\t*result,\n-\t\t\t\tSome(ThisValue::Passed(*on)),\n-\t\t\t\tSome(ty),\n-\t\t\t\ttypes,\n-\t\t\t)?;\n+\t\t\tlet this_value = if *bind_this { ThisValue::Passed(*on) } else { ThisValue::UseParent };\n+\t\t\tlet result =\n+\t\t\t\tget_logical_callable_from_type(*result, Some(this_value), Some(ty), types)?;\n \n \t\t\tif let Some(antecedent) = get_constraint(*on, types).and_then(|c| {\n \t\t\t\tif let Type::Constructor(Constructor::StructureGenerics(generic)) =\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -524,6 +518,11 @@ pub enum FunctionCallingError {\n \t\t/// Should be set\n \t\tcall_site: Option<SpanWithSource>,\n \t},\n+\tMismatchedThis {\n+\t\texpected: TypeStringRepresentation,\n+\t\tfound: TypeStringRepresentation,\n+\t\tcall_site: SpanWithSource,\n+\t},\n }\n \n pub struct InfoDiagnostic(pub String);\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -705,6 +704,7 @@ impl FunctionType {\n \t\t\ttypes,\n \t\t\t&mut errors,\n \t\t\tcall_site,\n+\t\t\tbehavior,\n \t\t);\n \n \t\tlet local_arguments = self.assign_arguments_to_parameters::<E>(\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -721,10 +721,10 @@ impl FunctionType {\n \n \t\tlet mut type_arguments = FunctionTypeArguments {\n \t\t\tlocal_arguments,\n-\t\t\tclosure_ids: if let Some(StructureGenericArguments::Closure(cs)) = structure_generics {\n-\t\t\t\tcs\n-\t\t\t} else {\n-\t\t\t\tDefault::default()\n+\t\t\t#[allow(clippy::manual_unwrap_or_default)]\n+\t\t\tclosure_ids: match structure_generics {\n+\t\t\t\tSome(StructureGenericArguments::Closure(cs)) => cs,\n+\t\t\t\t_ => Vec::new(),\n \t\t\t},\n \t\t\tcall_site,\n \t\t};\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -920,7 +920,7 @@ impl FunctionType {\n \t}\n \n \t#[allow(clippy::too_many_arguments)]\n-\tfn set_this_for_behavior(\n+\tfn set_this_for_behavior<E: CallCheckingBehavior>(\n \t\t&self,\n \t\tcalled_with_new: CalledWithNew,\n \t\tthis_value: ThisValue,\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -929,6 +929,7 @@ impl FunctionType {\n \t\ttypes: &mut TypeStore,\n \t\terrors: &mut ErrorsAndInfo,\n \t\tcall_site: source_map::BaseSpan<SourceId>,\n+\t\tbehavior: &E,\n \t) {\n \t\tmatch self.behavior {\n \t\t\tFunctionBehavior::ArrowFunction { .. } => {}\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -943,6 +944,44 @@ impl FunctionType {\n \t\t\t\t\tTypeId::UNDEFINED_TYPE\n \t\t\t\t};\n \n+\t\t\t\tlet base_type = get_constraint(free_this_id, types).unwrap_or(free_this_id);\n+\n+\t\t\t\tlet mut basic_subtyping = BasicEquality {\n+\t\t\t\t\tadd_property_restrictions: false,\n+\t\t\t\t\tposition: call_site,\n+\t\t\t\t\tobject_constraints: Default::default(),\n+\t\t\t\t\tallow_errors: true,\n+\t\t\t\t};\n+\n+\t\t\t\tlet type_is_subtype = type_is_subtype(\n+\t\t\t\t\tbase_type,\n+\t\t\t\t\tvalue_of_this,\n+\t\t\t\t\t&mut basic_subtyping,\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\ttypes,\n+\t\t\t\t);\n+\n+\t\t\t\tmatch type_is_subtype {\n+\t\t\t\t\tSubTypeResult::IsSubType => {}\n+\t\t\t\t\tSubTypeResult::IsNotSubType(reason) => {\n+\t\t\t\t\t\terrors.errors.push(FunctionCallingError::MismatchedThis {\n+\t\t\t\t\t\t\texpected: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\tfree_this_id,\n+\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\tbehavior.debug_types(),\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfound: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\tvalue_of_this,\n+\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\tbehavior.debug_types(),\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tcall_site,\n+\t\t\t\t\t\t});\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n \t\t\t\tcrate::utils::notify!(\n \t\t\t\t\t\"free this id {:?} & value of this {:?}\",\n \t\t\t\t\tfree_this_id,\ndiff --git a/checker/src/types/functions.rs b/checker/src/types/functions.rs\n--- a/checker/src/types/functions.rs\n+++ b/checker/src/types/functions.rs\n@@ -189,7 +189,7 @@ pub struct SynthesisedParameter {\n #[derive(Clone, Debug, binary_serialize_derive::BinarySerializable)]\n pub struct SynthesisedRestParameter {\n \tpub name: String,\n-\t/// This is the item type, aka the `T`` of `Array<T>`\n+\t/// This is the item type, aka the `T` of `Array<T>`\n \tpub item_type: TypeId,\n \t/// This is the generic type (to substitute into)\n \tpub ty: TypeId,\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -289,7 +289,6 @@ pub enum Constructor {\n \t\ton: TypeId,\n \t\tunder: PropertyKey<'static>,\n \t\tresult: TypeId,\n-\t\t/// See issue #98\n \t\tbind_this: bool,\n \t},\n \t/// For await a poly type\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -188,6 +188,7 @@ pub(crate) fn get_property<E: CallCheckingBehavior>(\n \tbehavior: &mut E,\n \ttypes: &mut TypeStore,\n \tposition: SpanWithSource,\n+\tbind_this: bool,\n ) -> Option<(PropertyKind, TypeId)> {\n \tif on == TypeId::ERROR_TYPE\n \t\t|| matches!(under, PropertyKey::Type(under) if *under == TypeId::ERROR_TYPE)\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -215,6 +216,7 @@ pub(crate) fn get_property<E: CallCheckingBehavior>(\n \t\t\tbehavior,\n \t\t\ttypes,\n \t\t\tposition,\n+\t\t\tbind_this,\n \t\t)\n \t} else if top_environment.possibly_mutated_objects.contains(&on) {\n \t\tlet Some(constraint) = top_environment.get_object_constraint(on) else {\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -231,13 +233,14 @@ pub(crate) fn get_property<E: CallCheckingBehavior>(\n \t\t\tbehavior,\n \t\t\ttypes,\n \t\t\tposition,\n+\t\t\tbind_this,\n \t\t)\n \t} else {\n \t\t// if environment.get_poly_base(under, types).is_some() {\n \t\t// \ttodo!()\n \t\t// }\n \t\t// TODO\n-\t\tget_from_an_object(on, publicity, under, top_environment, behavior, types)\n+\t\tget_from_an_object(on, publicity, under, top_environment, behavior, types, bind_this)\n \t}\n }\n \ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -248,6 +251,7 @@ fn get_from_an_object<E: CallCheckingBehavior>(\n \tenvironment: &mut Environment,\n \tbehavior: &mut E,\n \ttypes: &mut TypeStore,\n+\tbind_this: bool,\n ) -> Option<(PropertyKind, TypeId)> {\n \t/// Generates closure arguments, values of this and more. Runs getters\n \tfn resolve_property_on_logical<E: CallCheckingBehavior>(\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -257,6 +261,7 @@ fn get_from_an_object<E: CallCheckingBehavior>(\n \t\tenvironment: &mut Environment,\n \t\ttypes: &mut TypeStore,\n \t\tbehavior: &mut E,\n+\t\tbind_this: bool,\n \t) -> Option<(PropertyKind, TypeId)> {\n \t\tmatch logical {\n \t\t\tLogical::Pure(property) => {\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -264,10 +269,14 @@ fn get_from_an_object<E: CallCheckingBehavior>(\n \t\t\t\t\tPropertyValue::Value(value) => {\n \t\t\t\t\t\tlet ty = types.get_type_by_id(value);\n \t\t\t\t\t\tmatch ty {\n-\t\t\t\t\t\t\t// TODO function :: bind_this\n \t\t\t\t\t\t\tType::SpecialObject(SpecialObjects::Function(func, _state)) => {\n+\t\t\t\t\t\t\t\tlet this_value = if bind_this {\n+\t\t\t\t\t\t\t\t\tThisValue::Passed(on)\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tThisValue::UseParent\n+\t\t\t\t\t\t\t\t};\n \t\t\t\t\t\t\t\tlet func = types.register_type(Type::SpecialObject(\n-\t\t\t\t\t\t\t\t\tSpecialObjects::Function(*func, ThisValue::Passed(on)),\n+\t\t\t\t\t\t\t\t\tSpecialObjects::Function(*func, this_value),\n \t\t\t\t\t\t\t\t));\n \n \t\t\t\t\t\t\t\tSome((PropertyKind::Direct, func))\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -372,6 +381,7 @@ fn get_from_an_object<E: CallCheckingBehavior>(\n \t\t\t\tenvironment,\n \t\t\t\ttypes,\n \t\t\t\tbehavior,\n+\t\t\t\tbind_this,\n \t\t\t),\n \t\t}\n \t}\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -388,7 +398,7 @@ fn get_from_an_object<E: CallCheckingBehavior>(\n \t// ? is okay here\n \tlet result = get_property_unbound(on, publicity, under, types, environment).ok()?;\n \n-\tresolve_property_on_logical(result, on, None, environment, types, behavior)\n+\tresolve_property_on_logical(result, on, None, environment, types, behavior, bind_this)\n }\n \n #[allow(clippy::too_many_arguments)]\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -402,6 +412,7 @@ fn evaluate_get_on_poly<E: CallCheckingBehavior>(\n \tbehavior: &mut E,\n \ttypes: &mut TypeStore,\n \tposition: SpanWithSource,\n+\tbind_this: bool,\n ) -> Option<(PropertyKind, TypeId)> {\n \tfn resolve_logical_with_poly(\n \t\tfact: Logical<PropertyValue>,\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -411,6 +422,7 @@ fn evaluate_get_on_poly<E: CallCheckingBehavior>(\n \t\targuments: Option<&StructureGenericArguments>,\n \t\tenvironment: &mut Environment,\n \t\ttypes: &mut TypeStore,\n+\t\tbind_this: bool,\n \t) -> Option<TypeId> {\n \t\tmatch fact {\n \t\t\tLogical::Pure(og) => {\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -431,8 +443,7 @@ fn evaluate_get_on_poly<E: CallCheckingBehavior>(\n \t\t\t\t\t\t\t\ton,\n \t\t\t\t\t\t\t\tunder: under.into_owned(),\n \t\t\t\t\t\t\t\tresult,\n-\t\t\t\t\t\t\t\t// TODO #98\n-\t\t\t\t\t\t\t\tbind_this: true,\n+\t\t\t\t\t\t\t\tbind_this,\n \t\t\t\t\t\t\t}))\n \t\t\t\t\t\t}\n \t\t\t\t\t\t// Don't need to set this here. It is picked up from `on` during lookup\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -441,15 +452,12 @@ fn evaluate_get_on_poly<E: CallCheckingBehavior>(\n \t\t\t\t\t\t| Type::AliasTo { .. }\n \t\t\t\t\t\t| Type::Object(ObjectNature::AnonymousTypeAnnotation)\n \t\t\t\t\t\t| Type::Interface { .. }\n-\t\t\t\t\t\t| Type::Class { .. } => {\n-\t\t\t\t\t\t\ttypes.register_type(Type::Constructor(Constructor::Property {\n-\t\t\t\t\t\t\t\ton,\n-\t\t\t\t\t\t\t\tunder: under.into_owned(),\n-\t\t\t\t\t\t\t\tresult: value,\n-\t\t\t\t\t\t\t\t// TODO #98\n-\t\t\t\t\t\t\t\tbind_this: true,\n-\t\t\t\t\t\t\t}))\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\t| Type::Class { .. } => types.register_type(Type::Constructor(Constructor::Property {\n+\t\t\t\t\t\t\ton,\n+\t\t\t\t\t\t\tunder: under.into_owned(),\n+\t\t\t\t\t\t\tresult: value,\n+\t\t\t\t\t\t\tbind_this,\n+\t\t\t\t\t\t})),\n \t\t\t\t\t\tType::Constant(_)\n \t\t\t\t\t\t| Type::Object(ObjectNature::RealDeal)\n \t\t\t\t\t\t| Type::SpecialObject(..) => value,\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -497,9 +505,17 @@ fn evaluate_get_on_poly<E: CallCheckingBehavior>(\n \t\t\t\t\t\targuments,\n \t\t\t\t\t\tenvironment,\n \t\t\t\t\t\ttypes,\n+\t\t\t\t\t\tbind_this,\n+\t\t\t\t\t)?;\n+\t\t\t\t\tlet rhs = resolve_logical_with_poly(\n+\t\t\t\t\t\trhs,\n+\t\t\t\t\t\ton,\n+\t\t\t\t\t\tunder,\n+\t\t\t\t\t\targuments,\n+\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\tbind_this,\n \t\t\t\t\t)?;\n-\t\t\t\t\tlet rhs =\n-\t\t\t\t\t\tresolve_logical_with_poly(rhs, on, under, arguments, environment, types)?;\n \t\t\t\t\tSome(types.new_conditional_type(based_on, lhs, rhs))\n \t\t\t\t} else {\n \t\t\t\t\tcrate::utils::notify!(\"TODO emit some diagnostic about missing\");\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -518,6 +534,7 @@ fn evaluate_get_on_poly<E: CallCheckingBehavior>(\n \t\t\t\t\tSome(&antecedent),\n \t\t\t\t\tenvironment,\n \t\t\t\t\ttypes,\n+\t\t\t\t\tbind_this,\n \t\t\t\t)\n \t\t\t}\n \t\t}\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -28,7 +28,7 @@ use super::{\n /// Holds all the types. Eventually may be split across modules\n #[derive(Debug, binary_serialize_derive::BinarySerializable)]\n pub struct TypeStore {\n-\t/// Contains all of the types. Indexed by [TypeId]\n+\t/// Contains all of the types. Indexed by [`TypeId`]\n \ttypes: Vec<Type>,\n \n \t/// Some types are prototypes but have generic parameters but\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -626,14 +626,19 @@ impl TypeStore {\n \t\t\t\t.map(Logical::Pure)\n \t\t\t\t.or_else(|| {\n \t\t\t\t\tlet backing_type = cst.get_backing_type_id();\n-\t\t\t\t\tself.get_fact_about_type(\n-\t\t\t\t\t\tinfo_chain,\n-\t\t\t\t\t\tbacking_type,\n-\t\t\t\t\t\ton_type_arguments,\n-\t\t\t\t\t\tresolver,\n-\t\t\t\t\t\tdata,\n-\t\t\t\t\t)\n-\t\t\t\t\t.ok()\n+\n+\t\t\t\t\tif on == backing_type {\n+\t\t\t\t\t\tNone\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tself.get_fact_about_type(\n+\t\t\t\t\t\t\tinfo_chain,\n+\t\t\t\t\t\t\tbacking_type,\n+\t\t\t\t\t\t\ton_type_arguments,\n+\t\t\t\t\t\t\tresolver,\n+\t\t\t\t\t\t\tdata,\n+\t\t\t\t\t\t)\n+\t\t\t\t\t\t.ok()\n+\t\t\t\t\t}\n \t\t\t\t})\n \t\t\t\t.ok_or(crate::context::Missing::None),\n \t\t\tType::SpecialObject(_) => todo!(),\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -709,6 +709,31 @@ pub(crate) fn type_is_subtype_with_generics<'a, T: SubTypeBehavior<'a>>(\n \t\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n \t\t\t\t}\n \t\t\t}\n+\t\t\tType::Object(..) => subtype_properties(\n+\t\t\t\tbase_type,\n+\t\t\t\tbase_structure_arguments,\n+\t\t\t\tty,\n+\t\t\t\tty_structure_arguments,\n+\t\t\t\tbehavior,\n+\t\t\t\tenvironment,\n+\t\t\t\ttypes,\n+\t\t\t\tmode,\n+\t\t\t\talready_checked,\n+\t\t\t),\n+\t\t\tType::Constructor(Constructor::StructureGenerics(StructureGenerics {\n+\t\t\t\ton,\n+\t\t\t\targuments,\n+\t\t\t})) => type_is_subtype_with_generics(\n+\t\t\t\tbase_type,\n+\t\t\t\tbase_structure_arguments,\n+\t\t\t\t*on,\n+\t\t\t\tGenericChainLink::append(ty_structure_arguments.as_ref(), arguments),\n+\t\t\t\tbehavior,\n+\t\t\t\tenvironment,\n+\t\t\t\ttypes,\n+\t\t\t\tmode,\n+\t\t\t\talready_checked,\n+\t\t\t),\n \t\t\t_ => SubTypeResult::IsNotSubType(NonEqualityReason::Mismatch),\n \t\t},\n \t\tType::Interface { nominal: base_type_nominal, .. } => {\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -979,6 +1004,14 @@ fn subtype_properties<'a, T: SubTypeBehavior<'a>>(\n \tmode: SubTypingMode,\n \talready_checked: &mut AlreadyChecked,\n ) -> SubTypeResult {\n+\t// TODO (#128): This is a compromise where only boolean and number types are treated as nominal\n+\tmatch base_type {\n+\t\tTypeId::BOOLEAN_TYPE | TypeId::NUMBER_TYPE if base_type != ty => {\n+\t\t\treturn SubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n+\t\t}\n+\t\t_ => {}\n+\t}\n+\n \tlet mode = mode.one_deeper();\n \n \tlet mut property_errors = Vec::new();\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -991,10 +1024,16 @@ fn subtype_properties<'a, T: SubTypeBehavior<'a>>(\n \t\tcrate::utils::notify!(\"key {:?} with {:?}\", key, base_type_arguments);\n \n \t\tlet key = match key {\n-\t\t\tPropertyKey::Type(ty) => PropertyKey::from_type(\n-\t\t\t\tbase_type_arguments.unwrap().get_single_argument(*ty).unwrap_or(*ty),\n-\t\t\t\ttypes,\n-\t\t\t),\n+\t\t\tPropertyKey::Type(ty) => {\n+\t\t\t\tif let Some(base_type_arguments) = base_type_arguments {\n+\t\t\t\t\tPropertyKey::from_type(\n+\t\t\t\t\t\tbase_type_arguments.get_single_argument(*ty).unwrap_or(*ty),\n+\t\t\t\t\t\ttypes,\n+\t\t\t\t\t)\n+\t\t\t\t} else {\n+\t\t\t\t\tkey.clone()\n+\t\t\t\t}\n+\t\t\t}\n \t\t\tPropertyKey::String(_) => key.clone(),\n \t\t};\n \ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1088,7 +1127,36 @@ fn check_lhs_property_is_super_type_of_rhs<'a, T: SubTypeBehavior<'a>>(\n \t\t\t\tErr(..) => Err(PropertyError::Missing),\n \t\t\t}\n \t\t}\n-\t\tPropertyValue::Getter(_) => todo!(),\n+\t\tPropertyValue::Getter(getter) => {\n+\t\t\tlet rhs_property = get_property_unbound(ty, publicity, key, types, environment);\n+\t\t\tcrate::utils::notify!(\"looking for {:?} found {:?}\", key, rhs_property);\n+\n+\t\t\tmatch rhs_property {\n+\t\t\t\tOk(rhs_property) => {\n+\t\t\t\t\tlet res = check_logical_property(\n+\t\t\t\t\t\tgetter.return_type,\n+\t\t\t\t\t\tbase_type_arguments,\n+\t\t\t\t\t\trhs_property,\n+\t\t\t\t\t\tright_type_arguments,\n+\t\t\t\t\t\tbehavior,\n+\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\tmode,\n+\t\t\t\t\t\talready_checked,\n+\t\t\t\t\t);\n+\t\t\t\t\tmatch res {\n+\t\t\t\t\t\tSubTypeResult::IsSubType => Ok(()),\n+\t\t\t\t\t\tSubTypeResult::IsNotSubType(err) => Err(PropertyError::Invalid {\n+\t\t\t\t\t\t\texpected: TypeId::UNIMPLEMENTED_ERROR_TYPE,\n+\t\t\t\t\t\t\tfound: TypeId::UNIMPLEMENTED_ERROR_TYPE,\n+\t\t\t\t\t\t\tmismatch: err,\n+\t\t\t\t\t\t}),\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\t// TODO\n+\t\t\t\tErr(..) => Err(PropertyError::Missing),\n+\t\t\t}\n+\t\t}\n \t\tPropertyValue::Setter(_) => todo!(),\n \t\tPropertyValue::Deleted => {\n \t\t\t// TODO WIP\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -18,7 +18,7 @@ use derive_finite_automaton::{\n pub struct LexerOptions {\n \t/// Whether to append tokens when lexing. If false will just ignore\n \tpub comments: Comments,\n-\t/// Whether to parse JSX. TypeScripts `<number> 2` breaks the lexer so this can be disabled to allow\n+\t/// Whether to parse JSX. TypeScript's `<number> 2` breaks the lexer so this can be disabled to allow\n \t/// for that syntax\n \tpub lex_jsx: bool,\n \t/// TODO temp\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -110,7 +110,7 @@ pub struct ParseOptions {\n \tpub decorators: bool,\n \t/// Skip **all** comments from the AST\n \tpub comments: Comments,\n-\t/// See [crate::extensions::is_expression::IsExpression]\n+\t/// See [`crate::extensions::is_expression::IsExpression`]\n \tpub is_expressions: bool,\n \t/// Allows functions to be prefixed with 'server'\n \tpub custom_function_headers: bool,\ndiff --git a/parser/src/tokens.rs b/parser/src/tokens.rs\n--- a/parser/src/tokens.rs\n+++ b/parser/src/tokens.rs\n@@ -91,33 +91,33 @@ use crate::{ParseError, Quoted};\n pub enum TSXToken {\n     Identifier(String),\n     Keyword(TSXKeyword),\n-    NumberLiteral(String), \n+    NumberLiteral(String),\n     StringLiteral(String, Quoted),\n     MultiLineComment(String), Comment(String),\n     RegexLiteral(String), RegexFlagLiteral(String),\n     TemplateLiteralStart, TemplateLiteralChunk(String), TemplateLiteralEnd,\n     TemplateLiteralExpressionStart, TemplateLiteralExpressionEnd,\n-    Comma, SemiColon, Colon, Dot, \n+    Comma, SemiColon, Colon, Dot,\n     /// @\n     At,\n-    Spread, Assign, \n+    Spread, Assign,\n     /// `=>`\n     Arrow,\n-    /// `(` \n-    OpenParentheses, \n-    /// `)` \n-    CloseParentheses, \n-    /// `{` \n-    OpenBrace, \n-    /// `}` \n-    CloseBrace, \n-    /// `[` \n-    OpenBracket, \n-    /// `]` \n-    CloseBracket, \n-    /// `<` \n-    OpenChevron, \n-    /// `>` \n+    /// `(`\n+    OpenParentheses,\n+    /// `)`\n+    CloseParentheses,\n+    /// `{`\n+    OpenBrace,\n+    /// `}`\n+    CloseBrace,\n+    /// `[`\n+    OpenBracket,\n+    /// `]`\n+    CloseBracket,\n+    /// `<`\n+    OpenChevron,\n+    /// `>`\n     CloseChevron,\n     Add, Subtract, Multiply, Divide,\n     QuestionMark, Exponent, Modulo,\ndiff --git a/parser/src/tokens.rs b/parser/src/tokens.rs\n--- a/parser/src/tokens.rs\n+++ b/parser/src/tokens.rs\n@@ -132,19 +132,19 @@ pub enum TSXToken {\n     Equal, NotEqual, StrictEqual, StrictNotEqual,\n     GreaterThanEqual, LessThanEqual,\n     OptionalChain, OptionalCall, OptionalIndex, NullishCoalescing, NullishCoalescingAssign,\n-    /// `?:` \n-    OptionalMember, \n-    /// '!:` \n-    NonOptionalMember, \n+    /// `?:`\n+    OptionalMember,\n+    /// `!:`\n+    NonOptionalMember,\n     /// For scripts thing\n     HashTag,\n     // JSX Tokens. Some like JSXComment are non standard\n-    JSXOpeningTagStart, JSXTagName(String), JSXOpeningTagEnd, \n-    JSXClosingTagStart, \n-    /// This also covers the end of a token, thus no 'TSXToken::JSXClosingTagEnd'\n-    JSXClosingTagName(String), \n+    JSXOpeningTagStart, JSXTagName(String), JSXOpeningTagEnd,\n+    JSXClosingTagStart,\n+    /// This also covers the end of a token, thus no `TSXToken::JSXClosingTagEnd`\n+    JSXClosingTagName(String),\n     /// />\n-    JSXSelfClosingTag, \n+    JSXSelfClosingTag,\n     JSXAttributeKey(String), JSXAttributeAssign, JSXAttributeValue(String),\n     JSXContent(String), JSXContentLineBreak,\n     /// The start and end of expressions either as a node or a attribute\ndiff --git a/parser/src/tokens.rs b/parser/src/tokens.rs\n--- a/parser/src/tokens.rs\n+++ b/parser/src/tokens.rs\n@@ -307,8 +307,8 @@ pub enum TSXKeyword {\n     Async, Await,\n     Static,\n     Get, Set,\n-    Extends, \n-    Null, \n+    Extends,\n+    Null,\n     True, False,\n     // TS special keywords\n     Abstract, Implements,\ndiff --git a/parser/src/tokens.rs b/parser/src/tokens.rs\n--- a/parser/src/tokens.rs\n+++ b/parser/src/tokens.rs\n@@ -317,19 +317,19 @@ pub enum TSXKeyword {\n     // TS publicity attributes\n     Private, Public, Protected,\n     // TS Keywords\n-    As, Readonly, Satisfies, Declare, Namespace, \n+    As, Readonly, Satisfies, Declare, Namespace,\n \t// TS & Ezno\n-\tIs, \n+\tIs,\n \tInfer, KeyOf, Unique, Symbol,\n \t// TODO unsure\n \t#[cfg(feature = \"extras\")] Module,\n     // Extra function modifiers\n-    #[cfg(feature = \"extras\")] Server, #[cfg(feature = \"extras\")] Worker, \n+    #[cfg(feature = \"extras\")] Server, #[cfg(feature = \"extras\")] Worker,\n     // Type declaration changes\n     #[cfg(feature = \"extras\")] Nominal, #[cfg(feature = \"extras\")] Performs,\n \n     #[cfg(feature = \"extras\")]\n-    /// https://github.com/tc39/proposal-generator-arrow-functions#introduce-new-generator-keyword-for-both-function-and-arrow-function\n+    /// <https://github.com/tc39/proposal-generator-arrow-functions#introduce-new-generator-keyword-for-both-function-and-arrow-function>\n     Generator,\n \n     #[cfg(feature = \"extras\")]\n",
        "test_patch": "diff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -527,7 +544,15 @@ fn evaluate_get_on_poly<E: CallCheckingBehavior>(\n \n \t// crate::utils::notify!(\"unbound is is {:?}\", fact);\n \n-\tlet value = resolve_logical_with_poly(fact, on, under.clone(), None, top_environment, types)?;\n+\tlet value = resolve_logical_with_poly(\n+\t\tfact,\n+\t\ton,\n+\t\tunder.clone(),\n+\t\tNone,\n+\t\ttop_environment,\n+\t\ttypes,\n+\t\tbind_this,\n+\t)?;\n \n \tbehavior.get_latest_info(top_environment).events.push(Event::Getter {\n \t\ton,\n",
        "problem_statement": "Implement destructuring assignment (declaration works already)\nWhile [declaration destructuring is implemented](https://github.com/kaleidawave/ezno/blob/main/checker/specification/specification.md#array-destructuring) (aka you can declare some variables where the LHS destructors the RHS value), the assignment part is not implemented\r\n\r\nhttps://github.com/kaleidawave/ezno/blob/7eb3a31b02f7fd9a2e6055951948c250fd4e8719/checker/src/context/environment.rs#L412-L413\r\n\r\nFor \r\n```ts\r\nlet array1 = [1, 2, 3];\r\nlet a = 0, b = 0;\r\n[a, b] = array1;\r\n\r\na satisfies 1;\r\nb satisfies \"hello world\";\r\n```\r\nto work. It should be very similar (but different as it is acting on intermediate level rather than AST) to the `assign_fields` function used for the declaration kind\r\n\r\nhttps://github.com/kaleidawave/ezno/blob/7eb3a31b02f7fd9a2e6055951948c250fd4e8719/checker/src/synthesis/variables.rs#L198\r\n\r\nThe implementation should be very similar to the current behaviour for assigning to a variable, however it needs to do the recursive assignment and `get_property` things from destructuring. \n",
        "hints_text": "",
        "created_at": "2024-03-27T19:03:02Z",
        "version": "0.0"
    },
    {
        "repo": "kaleidawave/ezno",
        "pull_number": 173,
        "instance_id": "kaleidawave__ezno-173",
        "issue_numbers": [
            "176"
        ],
        "base_commit": "e6f6ffd7cb48285cdaaf7e57e4d636bbaf038b03",
        "patch": "diff --git a/.github/workflows/performance-and-size.yml b/.github/workflows/performance-and-size.yml\n--- a/.github/workflows/performance-and-size.yml\n+++ b/.github/workflows/performance-and-size.yml\n@@ -101,7 +101,8 @@ jobs:\n           echo \"::group::Running large\"\n \n           cat ./checker/specification/specification.md > main.md\n-          cargo run -p ezno-parser --example code_blocks_to_script all.md --comment-headers --out ./code.tsx\n+          cargo run -p ezno-parser --example code_blocks_to_script main.md --comment-headers --out ./code.tsx\n+\n           for i in {1..10}; do\n             cat ./code.tsx >> large.tsx\n           done\ndiff --git a/.github/workflows/performance-and-size.yml b/.github/workflows/performance-and-size.yml\n--- a/.github/workflows/performance-and-size.yml\n+++ b/.github/workflows/performance-and-size.yml\n@@ -109,7 +110,7 @@ jobs:\n           ./target/release/ezno check large.tsx --timings --max-diagnostics 0 || true\n           echo \"::endgroup::\"\n \n-      - name: Run parser, minfier/stringer performance\n+      - name: Run parsing & stringing (minfied) benchmarks\n         shell: bash\n         run: |\n           strings=(\ndiff --git a/.github/workflows/publish.yml b/.github/workflows/publish.yml\n--- a/.github/workflows/publish.yml\n+++ b/.github/workflows/publish.yml\n@@ -103,7 +103,7 @@ jobs:\n       - uses: brndnmtthws/rust-action-cargo-binstall@v1\n         if: ${{ inputs.ezno-version != 'none' }}\n         with:\n-          packages: wasm-pack@0.12.1\n+          packages: wasm-pack@0.13.0\n \n       - name: Set NPM package version & build\n         id: set-npm-version\ndiff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml\n--- a/.github/workflows/rust.yml\n+++ b/.github/workflows/rust.yml\n@@ -139,7 +139,7 @@ jobs:\n       - uses: brndnmtthws/rust-action-cargo-binstall@v1\n         if: steps.changes.outputs.src == 'true' || github.ref_name == 'main'\n         with:\n-          packages: wasm-pack@0.12.1\n+          packages: wasm-pack@0.13.0\n       - uses: denoland/setup-deno@v1\n         if: steps.changes.outputs.src == 'true' || github.ref_name == 'main'\n         with:\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -275,6 +275,7 @@ dependencies = [\n  \"multiline-term-input\",\n  \"native-tls\",\n  \"notify\",\n+ \"pretty_assertions\",\n  \"self-replace\",\n  \"serde\",\n  \"serde-wasm-bindgen\",\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -38,15 +38,17 @@ path = \"src/main.rs\"\n [dependencies]\n # ezno-web-framework = { path = \"./plugins/web\" }\n \n-console = \"0.15\"\n-codespan-reporting = \"0.11\"\n argh = \"0.1\"\n base64 = \"0.21\"\n+console = \"0.15\"\n+codespan-reporting = \"0.11\"\n enum-variants-strings = \"0.3\"\n+glob = \"0.3\"\n+# For `StrComparison` for string comparison\n+pretty_assertions = \"1.3.0\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0\"\n simple-json-parser = \"0.0.2\"\n-glob = \"0.3\"\n \n [target.'cfg(not(target_family = \"wasm\"))'.dependencies]\n # For updating binary\ndiff --git a/checker/definitions/overrides.d.ts b/checker/definitions/overrides.d.ts\n--- a/checker/definitions/overrides.d.ts\n+++ b/checker/definitions/overrides.d.ts\n@@ -293,8 +293,8 @@ declare class Proxy {\n // TODO string keys temp because parser broke\n interface PropertyDescriptor {\n     value?: any;\n-    [\"get\" ? (): any;\n-    [\"set\" ? (v: any): void;\n+    get?(): any;\n+    set?(v: any): void;\n \n     writable?: boolean;\n     configurable?: boolean;\ndiff --git a/checker/definitions/simple.d.ts b/checker/definitions/simple.d.ts\n--- a/checker/definitions/simple.d.ts\n+++ b/checker/definitions/simple.d.ts\n@@ -327,8 +327,8 @@ declare class Proxy {\n // TODO string keys temp because parser broke\n interface PropertyDescriptor {\n     value?: any;\n-    [\"get\" ? (): any;\n-    [\"set\" ? (v: any): void;\n+    get?(): any;\n+    set?(v: any): void;\n \n     writable?: boolean;\n     configurable?: boolean;\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -2678,6 +2678,19 @@ class X {}\n \n - Expected 4, found false\n \n+#### Tagged template literal\n+\n+```ts\n+function myTag(static_parts: Array<string>, other: string) {\n+\treturn { static_parts, other }\n+}\n+\n+const name = \"Ben\";\n+myTag`${name}Hello ` satisfies string;\n+```\n+\n+- Expected string, found { static_parts: [\"\", \"Hello \"], other: \"Ben\" }\n+\n ### Async and `Promise`s\n \n > Position of await is not checked (here is fine because top level await)\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -3719,11 +3733,12 @@ x.property_b\n \n > TODO constrained inference\n \n-#### Readonly parameter\n+#### Readonly property\n \n ```ts\n-function x(p: readonly { a: string }) {\n-\tp.a = \"hi\";\n+function x(p: { readonly a: string, b: string }) {\n+    p.a = \"hi\";\n+\tp.b = \"hi\";\n }\n ```\n \ndiff --git a/checker/specification/to_implement.md b/checker/specification/to_implement.md\n--- a/checker/specification/to_implement.md\n+++ b/checker/specification/to_implement.md\n@@ -830,19 +830,6 @@ func(cb => { cb satisfies boolean }, \"hi\")\n \n > Was working, now broken (or removed)\n \n-#### Readonly property\n-\n-> Should be working but parser current wraps `a` as `Readonly<string>` :(\n-\n-```ts\n-function x(p: { readonly a: string, b: string }) {\n-    p.a = \"hi\";\n-\tp.b = \"hi\";\n-}\n-```\n-\n-- Cannot write to property 'a'\n-\n #### Destructuring using iterator\n \n ```ts\ndiff --git a/checker/specification/to_implement.md b/checker/specification/to_implement.md\n--- a/checker/specification/to_implement.md\n+++ b/checker/specification/to_implement.md\n@@ -888,21 +875,6 @@ function x(a: GreaterThan<4>) {\n \n - Expected string, found boolean\n \n-#### Tagged template literal\n-\n-> Waiting for parser definition updated to make this easier\n-\n-```ts\n-function myTag(static_parts: Array<string>, other: string) {\n-\treturn { static_parts, other }\n-}\n-\n-const name = \"Ben\";\n-myTag`${name}Hello ` satisfies string\n-```\n-\n-- Expected string, found { static_parts: [\"\", \"Hello \"], other: \"Ben\" }\n-\n ### Control flow\n \n #### Conditional break\ndiff --git a/checker/src/features/template_literal.rs b/checker/src/features/template_literal.rs\n--- a/checker/src/features/template_literal.rs\n+++ b/checker/src/features/template_literal.rs\n@@ -13,16 +13,11 @@ use crate::{\n \tCheckingData, Constant, Environment, Type, TypeId,\n };\n \n-#[derive(Copy, Clone)]\n-pub enum TemplateLiteralPart<'a, T> {\n-\tStatic(&'a str),\n-\tDynamic(&'a T),\n-}\n-\n #[allow(clippy::needless_pass_by_value)]\n pub fn synthesise_template_literal_expression<'a, T, A>(\n \ttag: Option<TypeId>,\n-\tmut parts_iter: impl Iterator<Item = TemplateLiteralPart<'a, A::Expression<'a>>> + 'a,\n+\tparts_iter: impl Iterator<Item = (&'a str, &'a A::MultipleExpression<'a>)> + 'a,\n+\tfinal_part: &'a str,\n \tposition: SpanWithSource,\n \tenvironment: &mut Environment,\n \tchecking_data: &mut CheckingData<T, A>,\ndiff --git a/checker/src/features/template_literal.rs b/checker/src/features/template_literal.rs\n--- a/checker/src/features/template_literal.rs\n+++ b/checker/src/features/template_literal.rs\n@@ -30,37 +25,8 @@ pub fn synthesise_template_literal_expression<'a, T, A>(\n where\n \tT: crate::ReadFromFS,\n \tA: crate::ASTImplementation,\n-\tA::Expression<'a>: 'a,\n+\tA::MultipleExpression<'a>: 'a,\n {\n-\t#[allow(clippy::needless_pass_by_value)]\n-\tfn part_to_type<'a, T: crate::ReadFromFS, A: crate::ASTImplementation>(\n-\t\tfirst: TemplateLiteralPart<'a, A::Expression<'a>>,\n-\t\tenvironment: &mut Environment,\n-\t\tchecking_data: &mut CheckingData<T, A>,\n-\t) -> crate::TypeId {\n-\t\tmatch first {\n-\t\t\tTemplateLiteralPart::Static(static_part) => {\n-\t\t\t\tchecking_data.types.new_constant_type(Constant::String((*static_part).to_owned()))\n-\t\t\t}\n-\t\t\tTemplateLiteralPart::Dynamic(expression) => {\n-\t\t\t\t// TODO tidy\n-\t\t\t\tlet value = A::synthesise_expression(\n-\t\t\t\t\texpression,\n-\t\t\t\t\tTypeId::ANY_TYPE,\n-\t\t\t\t\tenvironment,\n-\t\t\t\t\tchecking_data,\n-\t\t\t\t);\n-\t\t\t\tif let Type::Constant(cst) = checking_data.types.get_type_by_id(value) {\n-\t\t\t\t\tlet value = cast_as_string(cst, checking_data.options.strict_casts).unwrap();\n-\t\t\t\t\tchecking_data.types.new_constant_type(Constant::String(value))\n-\t\t\t\t} else {\n-\t\t\t\t\tcrate::utilities::notify!(\"Need to cast to string...\");\n-\t\t\t\t\tvalue\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n \tif let Some(tag) = tag {\n \t\t// TODO use tuple type\n \t\tlet mut static_parts = ObjectBuilder::new(\ndiff --git a/checker/src/features/template_literal.rs b/checker/src/features/template_literal.rs\n--- a/checker/src/features/template_literal.rs\n+++ b/checker/src/features/template_literal.rs\n@@ -73,47 +39,65 @@ where\n \t\t// TODO position\n \t\tlet mut arguments = Vec::<SynthesisedArgument>::new();\n \t\tlet mut static_part_count = 0u16;\n-\t\tfor part in parts_iter {\n-\t\t\tmatch part {\n-\t\t\t\tp @ TemplateLiteralPart::Static(_) => {\n-\t\t\t\t\tlet value = part_to_type(p, environment, checking_data);\n-\t\t\t\t\tstatic_parts.append(\n-\t\t\t\t\t\tcrate::types::properties::Publicity::Public,\n-\t\t\t\t\t\tcrate::types::properties::PropertyKey::from_usize(static_part_count.into()),\n-\t\t\t\t\t\tcrate::PropertyValue::Value(value),\n-\t\t\t\t\t\t// TODO should static parts should have position?\n-\t\t\t\t\t\tposition,\n-\t\t\t\t\t\t&mut environment.info,\n-\t\t\t\t\t);\n-\t\t\t\t\tstatic_part_count += 1;\n-\t\t\t\t}\n-\t\t\t\tTemplateLiteralPart::Dynamic(expression) => {\n-\t\t\t\t\tlet position =\n-\t\t\t\t\t\tA::expression_position(expression).with_source(environment.get_source());\n-\t\t\t\t\targuments.push(SynthesisedArgument {\n-\t\t\t\t\t\tvalue: part_to_type(\n-\t\t\t\t\t\t\tTemplateLiteralPart::Dynamic(expression),\n-\t\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\t\tchecking_data,\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tposition,\n-\t\t\t\t\t\tspread: false,\n-\t\t\t\t\t});\n-\t\t\t\t}\n+\t\tfor (static_part, dynamic_part) in parts_iter {\n+\t\t\t{\n+\t\t\t\tlet value =\n+\t\t\t\t\tchecking_data.types.new_constant_type(Constant::String(static_part.to_owned()));\n+\t\t\t\tstatic_parts.append(\n+\t\t\t\t\tcrate::types::properties::Publicity::Public,\n+\t\t\t\t\tcrate::types::properties::PropertyKey::from_usize(static_part_count.into()),\n+\t\t\t\t\tcrate::PropertyValue::Value(value),\n+\t\t\t\t\t// TODO should static parts should have position?\n+\t\t\t\t\tposition,\n+\t\t\t\t\t&mut environment.info,\n+\t\t\t\t);\n+\t\t\t\tstatic_part_count += 1;\n+\t\t\t}\n+\t\t\t{\n+\t\t\t\tlet value = A::synthesise_multiple_expression(\n+\t\t\t\t\tdynamic_part,\n+\t\t\t\t\tTypeId::ANY_TYPE,\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\tchecking_data,\n+\t\t\t\t);\n+\t\t\t\tlet value = if let Type::Constant(cst) = checking_data.types.get_type_by_id(value) {\n+\t\t\t\t\tlet value = cast_as_string(cst, checking_data.options.strict_casts).unwrap();\n+\t\t\t\t\tchecking_data.types.new_constant_type(Constant::String(value))\n+\t\t\t\t} else {\n+\t\t\t\t\tcrate::utilities::notify!(\"Need to cast to string...\");\n+\t\t\t\t\tvalue\n+\t\t\t\t};\n+\t\t\t\tlet position = A::multiple_expression_position(dynamic_part)\n+\t\t\t\t\t.with_source(environment.get_source());\n+\t\t\t\targuments.push(SynthesisedArgument { value, position, spread: false });\n \t\t\t}\n \t\t}\n \n+\t\tif !final_part.is_empty() {\n+\t\t\tlet value =\n+\t\t\t\tchecking_data.types.new_constant_type(Constant::String(final_part.to_owned()));\n+\t\t\tstatic_parts.append(\n+\t\t\t\tcrate::types::properties::Publicity::Public,\n+\t\t\t\tcrate::types::properties::PropertyKey::from_usize(static_part_count.into()),\n+\t\t\t\tcrate::PropertyValue::Value(value),\n+\t\t\t\t// TODO should static parts should have position?\n+\t\t\t\tposition,\n+\t\t\t\t&mut environment.info,\n+\t\t\t);\n+\t\t\tstatic_part_count += 1;\n+\t\t}\n+\n \t\t{\n \t\t\t// TODO spread\n-\t\t\tlet length = checking_data.types.new_constant_type(Constant::Number(\n+\t\t\tlet static_part_array_length = checking_data.types.new_constant_type(Constant::Number(\n \t\t\t\tf64::from(static_part_count).try_into().unwrap(),\n \t\t\t));\n \n \t\t\t// TODO: Should there be a position here?\n \t\t\tstatic_parts.append(\n \t\t\t\tcrate::types::properties::Publicity::Public,\n-\t\t\t\tcrate::types::properties::PropertyKey::String(\"length\".into()),\n-\t\t\t\tcrate::types::properties::PropertyValue::Value(length),\n+\t\t\t\tcrate::types::properties::PropertyKey::String(std::borrow::Cow::Borrowed(\"length\")),\n+\t\t\t\tcrate::types::properties::PropertyValue::Value(static_part_array_length),\n \t\t\t\tposition,\n \t\t\t\t&mut environment.info,\n \t\t\t);\ndiff --git a/checker/src/features/template_literal.rs b/checker/src/features/template_literal.rs\n--- a/checker/src/features/template_literal.rs\n+++ b/checker/src/features/template_literal.rs\n@@ -154,27 +138,61 @@ where\n \t\t}\n \t} else {\n \t\t// Bit weird but makes Rust happy\n-\t\tif let Some(first) = parts_iter.next() {\n-\t\t\tlet mut acc = part_to_type(first, environment, checking_data);\n-\t\t\tfor rest in parts_iter {\n-\t\t\t\tlet other = part_to_type(rest, environment, checking_data);\n-\t\t\t\tlet result = super::operations::evaluate_mathematical_operation(\n-\t\t\t\t\tacc,\n-\t\t\t\t\tcrate::features::operations::MathematicalAndBitwise::Add,\n-\t\t\t\t\tother,\n-\t\t\t\t\t&mut checking_data.types,\n-\t\t\t\t\tchecking_data.options.strict_casts,\n-\t\t\t\t);\n-\t\t\t\tmatch result {\n-\t\t\t\t\tOk(result) => acc = result,\n-\t\t\t\t\tErr(()) => {\n-\t\t\t\t\t\tcrate::utilities::notify!(\"Invalid template literal concatenation\");\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\tlet mut acc = TypeId::EMPTY_STRING;\n+\t\tfor (static_part, dynamic_part) in parts_iter {\n+\t\t\tlet lhs =\n+\t\t\t\tchecking_data.types.new_constant_type(Constant::String(static_part.to_owned()));\n+\t\t\tlet result = super::operations::evaluate_mathematical_operation(\n+\t\t\t\tacc,\n+\t\t\t\tcrate::features::operations::MathematicalAndBitwise::Add,\n+\t\t\t\tlhs,\n+\t\t\t\t&mut checking_data.types,\n+\t\t\t\tchecking_data.options.strict_casts,\n+\t\t\t);\n+\t\t\tif let Ok(result) = result {\n+\t\t\t\tacc = result;\n+\t\t\t} else {\n+\t\t\t\tcrate::utilities::notify!(\"Invalid template literal concatenation\");\n+\t\t\t\treturn TypeId::ERROR_TYPE;\n \t\t\t}\n+\t\t\tlet rhs = A::synthesise_multiple_expression(\n+\t\t\t\tdynamic_part,\n+\t\t\t\tTypeId::ANY_TYPE,\n+\t\t\t\tenvironment,\n+\t\t\t\tchecking_data,\n+\t\t\t);\n+\t\t\tlet result = super::operations::evaluate_mathematical_operation(\n+\t\t\t\tacc,\n+\t\t\t\tcrate::features::operations::MathematicalAndBitwise::Add,\n+\t\t\t\trhs,\n+\t\t\t\t&mut checking_data.types,\n+\t\t\t\tchecking_data.options.strict_casts,\n+\t\t\t);\n+\t\t\tif let Ok(result) = result {\n+\t\t\t\tacc = result;\n+\t\t\t} else {\n+\t\t\t\tcrate::utilities::notify!(\"Invalid template literal concatenation\");\n+\t\t\t\treturn TypeId::ERROR_TYPE;\n+\t\t\t}\n+\t\t}\n+\t\tif final_part.is_empty() {\n \t\t\tacc\n \t\t} else {\n-\t\t\tchecking_data.types.new_constant_type(Constant::String(String::new()))\n+\t\t\tlet value =\n+\t\t\t\tchecking_data.types.new_constant_type(Constant::String(final_part.to_owned()));\n+\t\t\tlet result = super::operations::evaluate_mathematical_operation(\n+\t\t\t\tacc,\n+\t\t\t\tcrate::features::operations::MathematicalAndBitwise::Add,\n+\t\t\t\tvalue,\n+\t\t\t\t&mut checking_data.types,\n+\t\t\t\tchecking_data.options.strict_casts,\n+\t\t\t);\n+\t\t\tif let Ok(result) = result {\n+\t\t\t\tresult\n+\t\t\t} else {\n+\t\t\t\tcrate::utilities::notify!(\"Invalid template literal concatenation\");\n+\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t}\n \t\t}\n \t}\n }\ndiff --git a/checker/src/lib.rs b/checker/src/lib.rs\n--- a/checker/src/lib.rs\n+++ b/checker/src/lib.rs\n@@ -164,6 +164,8 @@ pub trait ASTImplementation: Sized {\n \n \tfn expression_position<'a>(expression: &'a Self::Expression<'a>) -> Span;\n \n+\tfn multiple_expression_position<'a>(expression: &'a Self::MultipleExpression<'a>) -> Span;\n+\n \tfn type_parameter_name<'a>(parameter: &'a Self::TypeParameter<'a>) -> &'a str;\n \n \tfn type_annotation_position<'a>(annotation: &'a Self::TypeAnnotation<'a>) -> Span;\ndiff --git a/checker/src/synthesis/classes.rs b/checker/src/synthesis/classes.rs\n--- a/checker/src/synthesis/classes.rs\n+++ b/checker/src/synthesis/classes.rs\n@@ -579,7 +579,7 @@ fn register_extends_and_member<T: crate::ReadFromFS>(\n \t\t\t\t\tif let Some(ClassMember::Method(_, method)) = upcoming {\n \t\t\t\t\t\tlet actual = synthesise_shape(method, environment, checking_data);\n \t\t\t\t\t\t(overloads, actual)\n-\t\t\t\t\t} else if class.name.declare {\n+\t\t\t\t\t} else if class.name.is_declare {\n \t\t\t\t\t\tlet actual = overloads.pop().unwrap();\n \t\t\t\t\t\t(overloads, actual)\n \t\t\t\t\t} else {\ndiff --git a/checker/src/synthesis/declarations.rs b/checker/src/synthesis/declarations.rs\n--- a/checker/src/synthesis/declarations.rs\n+++ b/checker/src/synthesis/declarations.rs\n@@ -113,7 +113,7 @@ pub(crate) fn synthesise_declaration<T: crate::ReadFromFS>(\n \t\t\t\t\t}\n \t\t\t\t\tparser::declarations::export::Exportable::Parts(parts) => {\n \t\t\t\t\t\tfor part in parts {\n-\t\t\t\t\t\t\tlet pair = super::hoisting::export_part_to_name_pair(part);\n+\t\t\t\t\t\t\tlet pair = super::hoisting::part_to_name_pair(part);\n \t\t\t\t\t\t\tif let Some(pair) = pair {\n \t\t\t\t\t\t\t\tlet position = pair.position.with_source(environment.get_source());\n \t\t\t\t\t\t\t\tlet value = environment.get_variable_handle_error(\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -208,22 +208,15 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\tobject_literal.position.with_source(environment.get_source()),\n \t\t\texpecting,\n \t\t)),\n-\t\tExpression::TemplateLiteral(TemplateLiteral { tag, parts, position }) => {\n-\t\t\tlet parts_iter = parts.iter().map(|part| match part {\n-\t\t\t\tparser::expressions::TemplateLiteralPart::Static(value) => {\n-\t\t\t\t\tcrate::features::template_literal::TemplateLiteralPart::Static(value.as_str())\n-\t\t\t\t}\n-\t\t\t\tparser::expressions::TemplateLiteralPart::Dynamic(expr) => {\n-\t\t\t\t\tcrate::features::template_literal::TemplateLiteralPart::Dynamic(&**expr)\n-\t\t\t\t}\n-\t\t\t});\n+\t\tExpression::TemplateLiteral(TemplateLiteral { tag, parts, last, position }) => {\n \t\t\tlet tag = tag.as_ref().map(|expr| {\n \t\t\t\tsynthesise_expression(expr, environment, checking_data, TypeId::ANY_TYPE)\n \t\t\t});\n \n-\t\t\tInstance::RValue(synthesise_template_literal_expression(\n+\t\t\tInstance::RValue(synthesise_template_literal_expression::<_, EznoParser>(\n \t\t\t\ttag,\n-\t\t\t\tparts_iter,\n+\t\t\t\tparts.iter().map(|(l, r)| (l.as_str(), r)),\n+\t\t\t\tlast.as_str(),\n \t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\tenvironment,\n \t\t\t\tchecking_data,\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -296,7 +289,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\t| BinaryOperator::NullCoalescing => {\n \t\t\t\t\tunreachable!()\n \t\t\t\t}\n-\t\t\t\tBinaryOperator::Divides | BinaryOperator::Pipe | BinaryOperator::Compose => {\n+\t\t\t\tBinaryOperator::Pipe | BinaryOperator::Compose => {\n \t\t\t\t\tchecking_data.raise_unimplemented_error(\n \t\t\t\t\t\t\"special operations\",\n \t\t\t\t\t\tposition.with_source(environment.get_source()),\ndiff --git a/checker/src/synthesis/hoisting.rs b/checker/src/synthesis/hoisting.rs\n--- a/checker/src/synthesis/hoisting.rs\n+++ b/checker/src/synthesis/hoisting.rs\n@@ -188,7 +188,7 @@ pub(crate) fn hoist_statements<T: crate::ReadFromFS>(\n \t\t\t\t\t\tparser::declarations::import::ImportedItems::Parts(parts) => {\n \t\t\t\t\t\t\tcrate::utilities::notify!(\"{:?}\", parts);\n \t\t\t\t\t\t\tcrate::features::modules::ImportKind::Parts(\n-\t\t\t\t\t\t\t\tparts.iter().flatten().filter_map(import_part_to_name_pair),\n+\t\t\t\t\t\t\t\tparts.iter().flatten().filter_map(part_to_name_pair),\n \t\t\t\t\t\t\t)\n \t\t\t\t\t\t}\n \t\t\t\t\t\tparser::declarations::import::ImportedItems::All { under } => match under {\ndiff --git a/checker/src/synthesis/hoisting.rs b/checker/src/synthesis/hoisting.rs\n--- a/checker/src/synthesis/hoisting.rs\n+++ b/checker/src/synthesis/hoisting.rs\n@@ -263,7 +263,7 @@ pub(crate) fn hoist_statements<T: crate::ReadFromFS>(\n \t\t\t\t\t\t},\n \t\t\t\t\t..\n \t\t\t\t}) => {\n-\t\t\t\t\tlet parts = parts.iter().filter_map(export_part_to_name_pair);\n+\t\t\t\t\tlet parts = parts.iter().filter_map(part_to_name_pair);\n \n \t\t\t\t\timport_items(\n \t\t\t\t\t\tenvironment,\ndiff --git a/checker/src/synthesis/hoisting.rs b/checker/src/synthesis/hoisting.rs\n--- a/checker/src/synthesis/hoisting.rs\n+++ b/checker/src/synthesis/hoisting.rs\n@@ -588,7 +588,7 @@ pub(crate) fn hoist_statements<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\t\t\tchecking_data,\n \t\t\t\t\t\t\t\t);\n \t\t\t\t\t\t\t\t(overloads, actual)\n-\t\t\t\t\t\t\t} else if function.name.declare {\n+\t\t\t\t\t\t\t} else if function.name.is_declare {\n \t\t\t\t\t\t\t\tlet actual = overloads.pop().unwrap();\n \t\t\t\t\t\t\t\t(overloads, actual)\n \t\t\t\t\t\t\t} else {\ndiff --git a/checker/src/synthesis/hoisting.rs b/checker/src/synthesis/hoisting.rs\n--- a/checker/src/synthesis/hoisting.rs\n+++ b/checker/src/synthesis/hoisting.rs\n@@ -740,7 +740,7 @@ pub(crate) fn hoist_statements<T: crate::ReadFromFS>(\n \t\t\t\t\tparser::functions::FunctionLocationModifier::Worker => \"worker\".to_owned(),\n \t\t\t\t});\n \n-\t\t\t\tlet value = if function.name.declare {\n+\t\t\t\tlet value = if function.name.is_declare {\n \t\t\t\t\tlet (overloaded, _last) = (false, function);\n \t\t\t\t\t//  if function.has_body() {\n \t\t\t\t\t// } else {\ndiff --git a/checker/src/synthesis/hoisting.rs b/checker/src/synthesis/hoisting.rs\n--- a/checker/src/synthesis/hoisting.rs\n+++ b/checker/src/synthesis/hoisting.rs\n@@ -842,68 +842,29 @@ pub(crate) fn hoist_statements<T: crate::ReadFromFS>(\n \t}\n }\n \n-fn import_part_to_name_pair(item: &parser::declarations::ImportPart) -> Option<NamePair<'_>> {\n-\tmatch item {\n-\t\tparser::declarations::ImportPart::Name(name) => {\n-\t\t\tif let VariableIdentifier::Standard(name, position) = name {\n-\t\t\t\tSome(NamePair { value: name, r#as: name, position: *position })\n-\t\t\t} else {\n-\t\t\t\tNone\n-\t\t\t}\n-\t\t}\n-\t\tparser::declarations::ImportPart::NameWithAlias { name, alias, position } => {\n-\t\t\tSome(NamePair {\n-\t\t\t\tvalue: match alias {\n-\t\t\t\t\tparser::declarations::ImportExportName::Reference(item)\n-\t\t\t\t\t| parser::declarations::ImportExportName::Quoted(item, _) => item,\n-\t\t\t\t\tparser::declarations::ImportExportName::Marker(_) => {\n-\t\t\t\t\t\t// TODO I think okay\n-\t\t\t\t\t\treturn None;\n-\t\t\t\t\t}\n-\t\t\t\t},\n-\t\t\t\tr#as: name,\n-\t\t\t\tposition: *position,\n-\t\t\t})\n-\t\t}\n-\t\tparser::declarations::ImportPart::PrefixComment(_, item, _) => {\n-\t\t\titem.as_deref().and_then(import_part_to_name_pair)\n-\t\t}\n-\t\tparser::declarations::ImportPart::PostfixComment(item, _, _) => {\n-\t\t\timport_part_to_name_pair(item)\n-\t\t}\n-\t}\n-}\n-\n-pub(super) fn export_part_to_name_pair(\n-\titem: &parser::declarations::export::ExportPart,\n+// TODO with `type`\n+pub(super) fn part_to_name_pair<T: parser::declarations::ImportOrExport>(\n+\titem: &parser::declarations::ImportExportPart<T>,\n ) -> Option<NamePair<'_>> {\n-\tmatch item {\n-\t\tparser::declarations::export::ExportPart::Name(name) => {\n-\t\t\tif let VariableIdentifier::Standard(name, position) = name {\n-\t\t\t\tSome(NamePair { value: name, r#as: name, position: *position })\n-\t\t\t} else {\n-\t\t\t\tNone\n+\tif let VariableIdentifier::Standard(ref name, position) = item.name {\n+\t\tlet value = match &item.alias {\n+\t\t\tSome(\n+\t\t\t\tparser::declarations::ImportExportName::Reference(item)\n+\t\t\t\t| parser::declarations::ImportExportName::Quoted(item, _),\n+\t\t\t) => item,\n+\t\t\tSome(parser::declarations::ImportExportName::Marker(_)) => {\n+\t\t\t\t// TODO I think okay\n+\t\t\t\treturn None;\n \t\t\t}\n+\t\t\tNone => name,\n+\t\t};\n+\t\tif T::PREFIX {\n+\t\t\tSome(NamePair { value, r#as: name, position })\n+\t\t} else {\n+\t\t\tSome(NamePair { value: name, r#as: value, position })\n \t\t}\n-\t\tparser::declarations::export::ExportPart::NameWithAlias { name, alias, position } => {\n-\t\t\tSome(NamePair {\n-\t\t\t\tvalue: name,\n-\t\t\t\tr#as: match alias {\n-\t\t\t\t\tparser::declarations::ImportExportName::Reference(item)\n-\t\t\t\t\t| parser::declarations::ImportExportName::Quoted(item, _) => item,\n-\t\t\t\t\tparser::declarations::ImportExportName::Marker(_) => {\n-\t\t\t\t\t\treturn None;\n-\t\t\t\t\t}\n-\t\t\t\t},\n-\t\t\t\tposition: *position,\n-\t\t\t})\n-\t\t}\n-\t\tparser::declarations::export::ExportPart::PrefixComment(_, item, _) => {\n-\t\t\titem.as_deref().and_then(export_part_to_name_pair)\n-\t\t}\n-\t\tparser::declarations::export::ExportPart::PostfixComment(item, _, _) => {\n-\t\t\texport_part_to_name_pair(item)\n-\t\t}\n+\t} else {\n+\t\tNone\n \t}\n }\n \ndiff --git a/checker/src/synthesis/mod.rs b/checker/src/synthesis/mod.rs\n--- a/checker/src/synthesis/mod.rs\n+++ b/checker/src/synthesis/mod.rs\n@@ -113,6 +113,12 @@ impl crate::ASTImplementation for EznoParser {\n \t\tASTNode::get_position(expression)\n \t}\n \n+\tfn multiple_expression_position<'_a>(\n+\t\texpression: &'_a Self::MultipleExpression<'_a>,\n+\t) -> source_map::Span {\n+\t\tASTNode::get_position(expression)\n+\t}\n+\n \tfn type_parameter_name<'_a>(parameter: &'_a Self::TypeParameter<'_a>) -> &'_a str {\n \t\t&parameter.name\n \t}\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -22,7 +22,9 @@ use crate::{\n \tCheckingData, Map,\n };\n use parser::{\n-\ttype_annotations::{AnnotationWithBinder, CommonTypes, TupleElementKind, TupleLiteralElement},\n+\ttype_annotations::{\n+\t\tAnnotationWithBinder, CommonTypes, TupleElementKind, TupleLiteralElement, TypeName,\n+\t},\n \tASTNode, TypeAnnotation,\n };\n use source_map::SpanWithSource;\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -47,6 +49,11 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\tCommonTypes::String => TypeId::STRING_TYPE,\n \t\t\tCommonTypes::Number => TypeId::NUMBER_TYPE,\n \t\t\tCommonTypes::Boolean => TypeId::BOOLEAN_TYPE,\n+\t\t\t// TODO #137\n+\t\t\tCommonTypes::Unknown | CommonTypes::Any => TypeId::ANY_TYPE,\n+\t\t\tCommonTypes::Null => TypeId::NULL_TYPE,\n+\t\t\tCommonTypes::Undefined => TypeId::UNDEFINED_TYPE,\n+\t\t\tCommonTypes::Never => TypeId::NEVER_TYPE,\n \t\t},\n \t\tTypeAnnotation::StringLiteral(value, ..) => {\n \t\t\tchecking_data.types.new_constant_type(Constant::String(value.clone()))\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -60,52 +67,50 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\tTypeAnnotation::BooleanLiteral(value, _) => {\n \t\t\tchecking_data.types.new_constant_type(Constant::Boolean(*value))\n \t\t}\n-\t\tTypeAnnotation::Name(name, pos) => match name.as_str() {\n-\t\t\t// TODO differentiate? see #137\n-\t\t\t\"any\" | \"unknown\" => TypeId::ANY_TYPE,\n-\t\t\t\"never\" => TypeId::NEVER_TYPE,\n-\t\t\t\"this\" => {\n-\t\t\t\tchecking_data.raise_unimplemented_error(\n-\t\t\t\t\t\"this annotation\",\n-\t\t\t\t\tpos.with_source(environment.get_source()),\n-\t\t\t\t);\n-\t\t\t\tTypeId::ERROR_TYPE\n-\t\t\t}\n-\t\t\t\"self\" => TypeId::ANY_INFERRED_FREE_THIS,\n-\t\t\tname => {\n-\t\t\t\tif let Some(ty) = environment.get_type_from_name(name) {\n-\t\t\t\t\t// Warn if it requires parameters. e.g. Array\n-\t\t\t\t\tif checking_data.types.get_type_by_id(ty).get_parameters().is_some() {\n-\t\t\t\t\t\t// TODO check defaults...\n+\t\tTypeAnnotation::Name(name, position) => {\n+\t\t\tmatch name {\n+\t\t\t\tTypeName::Name(name) => {\n+\t\t\t\t\tif let Some(ty) = environment.get_type_from_name(name) {\n+\t\t\t\t\t\t// Warn if it requires parameters. e.g. Array\n+\t\t\t\t\t\tif checking_data.types.get_type_by_id(ty).get_parameters().is_some() {\n+\t\t\t\t\t\t\t// TODO check defaults...\n+\t\t\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n+\t\t\t\t\t\t\t\tTypeCheckError::TypeNeedsTypeArguments(\n+\t\t\t\t\t\t\t\t\tname,\n+\t\t\t\t\t\t\t\t\tposition.with_source(environment.get_source()),\n+\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tty\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tlet possibles = {\n+\t\t\t\t\t\t\tlet mut possibles =\n+\t\t\t\t\t\t\t\tcrate::get_closest(environment.get_all_named_types(), name)\n+\t\t\t\t\t\t\t\t\t.unwrap_or(vec![]);\n+\t\t\t\t\t\t\tpossibles.sort_unstable();\n+\t\t\t\t\t\t\tpossibles\n+\t\t\t\t\t\t};\n \t\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n-\t\t\t\t\t\t\tTypeCheckError::TypeNeedsTypeArguments(\n+\t\t\t\t\t\t\tTypeCheckError::CouldNotFindType(\n \t\t\t\t\t\t\t\tname,\n-\t\t\t\t\t\t\t\tpos.with_source(environment.get_source()),\n+\t\t\t\t\t\t\t\tpossibles,\n+\t\t\t\t\t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\t\t\t\t),\n \t\t\t\t\t\t);\n \t\t\t\t\t\tTypeId::ERROR_TYPE\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tty\n \t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tlet possibles = {\n-\t\t\t\t\t\tlet mut possibles =\n-\t\t\t\t\t\t\tcrate::get_closest(environment.get_all_named_types(), name)\n-\t\t\t\t\t\t\t\t.unwrap_or(vec![]);\n-\t\t\t\t\t\tpossibles.sort_unstable();\n-\t\t\t\t\t\tpossibles\n-\t\t\t\t\t};\n-\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n-\t\t\t\t\t\tTypeCheckError::CouldNotFindType(\n-\t\t\t\t\t\t\tname,\n-\t\t\t\t\t\t\tpossibles,\n-\t\t\t\t\t\t\tpos.with_source(environment.get_source()),\n-\t\t\t\t\t\t),\n+\t\t\t\t}\n+\t\t\t\tTypeName::FromNamespace(..) => {\n+\t\t\t\t\tchecking_data.raise_unimplemented_error(\n+\t\t\t\t\t\t\"namespace item\",\n+\t\t\t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\t\t);\n \t\t\t\t\tTypeId::ERROR_TYPE\n \t\t\t\t}\n \t\t\t}\n-\t\t},\n+\t\t}\n \t\tTypeAnnotation::Union(type_annotations, _) => {\n \t\t\tlet iterator = type_annotations\n \t\t\t\t.iter()\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -157,168 +162,177 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t}\n \t\t// This will take the found type and generate a `StructureGeneric` based on the type arguments\n \t\tTypeAnnotation::NameWithGenericArguments(name, arguments, position) => {\n-\t\t\t// match name.as_str() {\n-\t\t\t// \t\"ReturnType\" => todo!(),\n-\t\t\t// \t\"Constructor\" => todo!(),\n-\t\t\t// \t_ => {}\n-\t\t\t// }\n-\n-\t\t\tif let Some(inner_type_id) = environment.get_type_from_name(name) {\n-\t\t\t\tlet inner_type = checking_data.types.get_type_by_id(inner_type_id);\n-\t\t\t\tlet inner_type_alias_id = if let Type::AliasTo { to, .. } = inner_type {\n-\t\t\t\t\t// Fix for recursion\n-\t\t\t\t\tif *to == TypeId::ANY_TO_INFER_TYPE {\n-\t\t\t\t\t\tNone\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tSome(*to)\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tNone\n-\t\t\t\t};\n-\n-\t\t\t\t// crate::utilities::notify!(\"{:?}\", inner_type);\n-\n-\t\t\t\tif let Some(parameters) = inner_type.get_parameters() {\n-\t\t\t\t\tlet mut type_arguments: crate::Map<TypeId, (TypeId, SpanWithSource)> =\n-\t\t\t\t\t\tcrate::Map::default();\n-\n-\t\t\t\t\tfor (parameter, argument_type_annotation) in\n-\t\t\t\t\t\tparameters.clone().into_iter().zip(arguments.iter())\n-\t\t\t\t\t{\n-\t\t\t\t\t\tlet argument = synthesise_type_annotation(\n-\t\t\t\t\t\t\targument_type_annotation,\n-\t\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\t\tchecking_data,\n-\t\t\t\t\t\t);\n+\t\t\tmatch name {\n+\t\t\t\tTypeName::Name(name) => {\n+\t\t\t\t\tif let Some(inner_type_id) = environment.get_type_from_name(name) {\n+\t\t\t\t\t\tlet inner_type = checking_data.types.get_type_by_id(inner_type_id);\n+\t\t\t\t\t\tlet inner_type_alias_id = if let Type::AliasTo { to, .. } = inner_type {\n+\t\t\t\t\t\t\t// Fix for recursion\n+\t\t\t\t\t\t\tif *to == TypeId::ANY_TO_INFER_TYPE {\n+\t\t\t\t\t\t\t\tNone\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tSome(*to)\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tNone\n+\t\t\t\t\t\t};\n+\n+\t\t\t\t\t\t// crate::utilities::notify!(\"{:?}\", inner_type);\n+\n+\t\t\t\t\t\tif let Some(parameters) = inner_type.get_parameters() {\n+\t\t\t\t\t\t\tlet mut type_arguments: crate::Map<TypeId, (TypeId, SpanWithSource)> =\n+\t\t\t\t\t\t\t\tcrate::Map::default();\n+\n+\t\t\t\t\t\t\tfor (parameter, argument_type_annotation) in\n+\t\t\t\t\t\t\t\tparameters.clone().into_iter().zip(arguments.iter())\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\tlet argument = synthesise_type_annotation(\n+\t\t\t\t\t\t\t\t\targument_type_annotation,\n+\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t// TODO check restriction on parameter\n+\t\t\t\t\t\t\t\t\t// let mut basic_equality = BasicEquality {\n+\t\t\t\t\t\t\t\t\t// \tadd_property_restrictions: true,\n+\t\t\t\t\t\t\t\t\t// \tposition: argument_type_annotation\n+\t\t\t\t\t\t\t\t\t// \t\t.get_position()\n+\t\t\t\t\t\t\t\t\t// \t\t.with_source(environment.get_source()),\n+\t\t\t\t\t\t\t\t\t// \t// TODO not needed\n+\t\t\t\t\t\t\t\t\t// \tobject_constraints: Default::default(),\n+\t\t\t\t\t\t\t\t\t// \tallow_errors: true,\n+\t\t\t\t\t\t\t\t\t// };\n+\n+\t\t\t\t\t\t\t\t\t// let Type::RootPolyType(PolyNature::InterfaceGeneric { name: _ }) =\n+\t\t\t\t\t\t\t\t\t// \tchecking_data.types.get_type_by_id(parameter)\n+\t\t\t\t\t\t\t\t\t// else {\n+\t\t\t\t\t\t\t\t\t// \tunreachable!()\n+\t\t\t\t\t\t\t\t\t// };\n+\n+\t\t\t\t\t\t\t\t\t// // TODO it is a bit weird with the arguments, maybe should get their restriction directly here?\n+\t\t\t\t\t\t\t\t\t// // Definition files don't necessary need to check ...\n+\t\t\t\t\t\t\t\t\t// let result = type_is_subtype(\n+\t\t\t\t\t\t\t\t\t// \t*parameter_restriction,\n+\t\t\t\t\t\t\t\t\t// \targument,\n+\t\t\t\t\t\t\t\t\t// \t&mut basic_equality,\n+\t\t\t\t\t\t\t\t\t// \tenvironment,\n+\t\t\t\t\t\t\t\t\t// \t&checking_data.types,\n+\t\t\t\t\t\t\t\t\t// );\n+\n+\t\t\t\t\t\t\t\t\t// if let SubTypeResult::IsNotSubType(_matches) = result {\n+\t\t\t\t\t\t\t\t\t// \tlet error = TypeCheckError::GenericArgumentDoesNotMeetRestriction {\n+\t\t\t\t\t\t\t\t\t// \t\tparameter_restriction: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\t// \t\t\t*parameter_restriction,\n+\t\t\t\t\t\t\t\t\t// \t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t// \t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\t\t// \t\t\tchecking_data.options.debug_types,\n+\t\t\t\t\t\t\t\t\t// \t\t),\n+\t\t\t\t\t\t\t\t\t// \t\targument: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\t// \t\t\targument,\n+\t\t\t\t\t\t\t\t\t// \t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t// \t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\t\t// \t\t\tchecking_data.options.debug_types,\n+\t\t\t\t\t\t\t\t\t// \t\t),\n+\t\t\t\t\t\t\t\t\t// \t\tposition: argument_type_annotation\n+\t\t\t\t\t\t\t\t\t// \t\t\t.get_position()\n+\t\t\t\t\t\t\t\t\t// \t\t\t.with_source(environment.get_source()),\n+\t\t\t\t\t\t\t\t\t// \t};\n+\n+\t\t\t\t\t\t\t\t\t// \tchecking_data.diagnostics_container.add_error(error);\n+\t\t\t\t\t\t\t\t\t// }\n+\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\tlet with_source = argument_type_annotation\n+\t\t\t\t\t\t\t\t\t.get_position()\n+\t\t\t\t\t\t\t\t\t.with_source(environment.get_source());\n+\n+\t\t\t\t\t\t\t\ttype_arguments.insert(parameter, (argument, with_source));\n+\t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t// TODO check restriction on parameter\n-\t\t\t\t\t\t\t// let mut basic_equality = BasicEquality {\n-\t\t\t\t\t\t\t// \tadd_property_restrictions: true,\n-\t\t\t\t\t\t\t// \tposition: argument_type_annotation\n-\t\t\t\t\t\t\t// \t\t.get_position()\n-\t\t\t\t\t\t\t// \t\t.with_source(environment.get_source()),\n-\t\t\t\t\t\t\t// \t// TODO not needed\n-\t\t\t\t\t\t\t// \tobject_constraints: Default::default(),\n-\t\t\t\t\t\t\t// \tallow_errors: true,\n-\t\t\t\t\t\t\t// };\n-\n-\t\t\t\t\t\t\t// let Type::RootPolyType(PolyNature::InterfaceGeneric { name: _ }) =\n-\t\t\t\t\t\t\t// \tchecking_data.types.get_type_by_id(parameter)\n-\t\t\t\t\t\t\t// else {\n-\t\t\t\t\t\t\t// \tunreachable!()\n-\t\t\t\t\t\t\t// };\n-\n-\t\t\t\t\t\t\t// // TODO it is a bit weird with the arguments, maybe should get their restriction directly here?\n-\t\t\t\t\t\t\t// // Definition files don't necessary need to check ...\n-\t\t\t\t\t\t\t// let result = type_is_subtype(\n-\t\t\t\t\t\t\t// \t*parameter_restriction,\n-\t\t\t\t\t\t\t// \targument,\n-\t\t\t\t\t\t\t// \t&mut basic_equality,\n-\t\t\t\t\t\t\t// \tenvironment,\n-\t\t\t\t\t\t\t// \t&checking_data.types,\n+\t\t\t\t\t\t\t// Inline alias with arguments unless intrinsic\n+\t\t\t\t\t\t\t// crate::utilities::notify!(\n+\t\t\t\t\t\t\t// \t\"{:?} and {:?}\",\n+\t\t\t\t\t\t\t// \tinner_type_alias_id,\n+\t\t\t\t\t\t\t// \tinner_type_alias_id.is_some_and(intrinsics::tsc_string_intrinsic)\n \t\t\t\t\t\t\t// );\n \n-\t\t\t\t\t\t\t// if let SubTypeResult::IsNotSubType(_matches) = result {\n-\t\t\t\t\t\t\t// \tlet error = TypeCheckError::GenericArgumentDoesNotMeetRestriction {\n-\t\t\t\t\t\t\t// \t\tparameter_restriction: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\t// \t\t\t*parameter_restriction,\n-\t\t\t\t\t\t\t// \t\t\tenvironment,\n-\t\t\t\t\t\t\t// \t\t\t&checking_data.types,\n-\t\t\t\t\t\t\t// \t\t\tchecking_data.options.debug_types,\n-\t\t\t\t\t\t\t// \t\t),\n-\t\t\t\t\t\t\t// \t\targument: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\t// \t\t\targument,\n-\t\t\t\t\t\t\t// \t\t\tenvironment,\n-\t\t\t\t\t\t\t// \t\t\t&checking_data.types,\n-\t\t\t\t\t\t\t// \t\t\tchecking_data.options.debug_types,\n-\t\t\t\t\t\t\t// \t\t),\n-\t\t\t\t\t\t\t// \t\tposition: argument_type_annotation\n-\t\t\t\t\t\t\t// \t\t\t.get_position()\n-\t\t\t\t\t\t\t// \t\t\t.with_source(environment.get_source()),\n-\t\t\t\t\t\t\t// \t};\n-\n-\t\t\t\t\t\t\t// \tchecking_data.diagnostics_container.add_error(error);\n-\t\t\t\t\t\t\t// }\n+\t\t\t\t\t\t\tif intrinsics::tsc_string_intrinsic(inner_type_id) {\n+\t\t\t\t\t\t\t\tdistribute_tsc_string_intrinsic(\n+\t\t\t\t\t\t\t\t\tinner_type_id,\n+\t\t\t\t\t\t\t\t\ttype_arguments.get(&TypeId::STRING_GENERIC).unwrap().0,\n+\t\t\t\t\t\t\t\t\t&mut checking_data.types,\n+\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t} else if let (Some(inner_type_alias_id), false) =\n+\t\t\t\t\t\t\t\t(inner_type_alias_id, intrinsics::is_intrinsic(inner_type_id))\n+\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t// Important that these wrappers are kept as there 'wrap' holds information\n+\t\t\t\t\t\t\t\t// {\n+\t\t\t\t\t\t\t\t// \tuse crate::types::printing::print_type;\n+\n+\t\t\t\t\t\t\t\t// \tlet ty = print_type(\n+\t\t\t\t\t\t\t\t// \t\tinner_type_id,\n+\t\t\t\t\t\t\t\t// \t\t&mut checking_data.types,\n+\t\t\t\t\t\t\t\t// \t\tenvironment,\n+\t\t\t\t\t\t\t\t// \t\ttrue,\n+\t\t\t\t\t\t\t\t// \t);\n+\t\t\t\t\t\t\t\t// \tcrate::utilities::notify!(\"Here substituting alias eagerly {}\", ty);\n+\t\t\t\t\t\t\t\t// }\n+\n+\t\t\t\t\t\t\t\tlet substitution_arguments = ExplicitTypeArguments(type_arguments)\n+\t\t\t\t\t\t\t\t\t.into_substitution_arguments();\n+\n+\t\t\t\t\t\t\t\tcrate::types::substitute(\n+\t\t\t\t\t\t\t\t\tinner_type_alias_id,\n+\t\t\t\t\t\t\t\t\t&substitution_arguments,\n+\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t&mut checking_data.types,\n+\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\tlet arguments =\n+\t\t\t\t\t\t\t\t\tGenericArguments::ExplicitRestrictions(type_arguments);\n+\n+\t\t\t\t\t\t\t\tlet ty = Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n+\t\t\t\t\t\t\t\t\ton: inner_type_id,\n+\t\t\t\t\t\t\t\t\targuments,\n+\t\t\t\t\t\t\t\t});\n+\n+\t\t\t\t\t\t\t\tchecking_data.types.register_type(ty)\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n+\t\t\t\t\t\t\t\tTypeCheckError::TypeHasNoGenericParameters(\n+\t\t\t\t\t\t\t\t\tname.clone(),\n+\t\t\t\t\t\t\t\t\tposition.with_source(environment.get_source()),\n+\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\tTypeId::ERROR_TYPE\n \t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tlet with_source = argument_type_annotation\n-\t\t\t\t\t\t\t.get_position()\n-\t\t\t\t\t\t\t.with_source(environment.get_source());\n-\n-\t\t\t\t\t\ttype_arguments.insert(parameter, (argument, with_source));\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// Inline alias with arguments unless intrinsic\n-\t\t\t\t\t// crate::utilities::notify!(\n-\t\t\t\t\t// \t\"{:?} and {:?}\",\n-\t\t\t\t\t// \tinner_type_alias_id,\n-\t\t\t\t\t// \tinner_type_alias_id.is_some_and(intrinsics::tsc_string_intrinsic)\n-\t\t\t\t\t// );\n-\n-\t\t\t\t\tif intrinsics::tsc_string_intrinsic(inner_type_id) {\n-\t\t\t\t\t\tdistribute_tsc_string_intrinsic(\n-\t\t\t\t\t\t\tinner_type_id,\n-\t\t\t\t\t\t\ttype_arguments.get(&TypeId::STRING_GENERIC).unwrap().0,\n-\t\t\t\t\t\t\t&mut checking_data.types,\n-\t\t\t\t\t\t)\n-\t\t\t\t\t} else if let (Some(inner_type_alias_id), false) =\n-\t\t\t\t\t\t(inner_type_alias_id, intrinsics::is_intrinsic(inner_type_id))\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// Important that these wrappers are kept as there 'wrap' holds information\n-\t\t\t\t\t\t// {\n-\t\t\t\t\t\t// \tuse crate::types::printing::print_type;\n-\n-\t\t\t\t\t\t// \tlet ty = print_type(\n-\t\t\t\t\t\t// \t\tinner_type_id,\n-\t\t\t\t\t\t// \t\t&mut checking_data.types,\n-\t\t\t\t\t\t// \t\tenvironment,\n-\t\t\t\t\t\t// \t\ttrue,\n-\t\t\t\t\t\t// \t);\n-\t\t\t\t\t\t// \tcrate::utilities::notify!(\"Here substituting alias eagerly {}\", ty);\n-\t\t\t\t\t\t// }\n-\n-\t\t\t\t\t\tlet substitution_arguments =\n-\t\t\t\t\t\t\tExplicitTypeArguments(type_arguments).into_substitution_arguments();\n-\n-\t\t\t\t\t\tcrate::types::substitute(\n-\t\t\t\t\t\t\tinner_type_alias_id,\n-\t\t\t\t\t\t\t&substitution_arguments,\n-\t\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\t\t&mut checking_data.types,\n-\t\t\t\t\t\t)\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tlet arguments = GenericArguments::ExplicitRestrictions(type_arguments);\n-\n-\t\t\t\t\t\tlet ty = Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n-\t\t\t\t\t\t\ton: inner_type_id,\n-\t\t\t\t\t\t\targuments,\n-\t\t\t\t\t\t});\n-\n-\t\t\t\t\t\tchecking_data.types.register_type(ty)\n+\t\t\t\t\t\tlet possibles = {\n+\t\t\t\t\t\t\tlet mut possibles =\n+\t\t\t\t\t\t\t\tcrate::get_closest(environment.get_all_named_types(), name)\n+\t\t\t\t\t\t\t\t\t.unwrap_or(vec![]);\n+\t\t\t\t\t\t\tpossibles.sort_unstable();\n+\t\t\t\t\t\t\tpossibles\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n+\t\t\t\t\t\t\tTypeCheckError::CouldNotFindType(\n+\t\t\t\t\t\t\t\tname,\n+\t\t\t\t\t\t\t\tpossibles,\n+\t\t\t\t\t\t\t\tposition.with_source(environment.get_source()),\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\tTypeId::ERROR_TYPE\n \t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n-\t\t\t\t\t\tTypeCheckError::TypeHasNoGenericParameters(\n-\t\t\t\t\t\t\tname.clone(),\n-\t\t\t\t\t\t\tposition.with_source(environment.get_source()),\n-\t\t\t\t\t\t),\n+\t\t\t\t}\n+\t\t\t\tTypeName::FromNamespace(..) => {\n+\t\t\t\t\tchecking_data.raise_unimplemented_error(\n+\t\t\t\t\t\t\"namespace item\",\n+\t\t\t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\t\t);\n \t\t\t\t\tTypeId::ERROR_TYPE\n \t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tlet possibles = {\n-\t\t\t\t\tlet mut possibles = crate::get_closest(environment.get_all_named_types(), name)\n-\t\t\t\t\t\t.unwrap_or(vec![]);\n-\t\t\t\t\tpossibles.sort_unstable();\n-\t\t\t\t\tpossibles\n-\t\t\t\t};\n-\t\t\t\tchecking_data.diagnostics_container.add_error(TypeCheckError::CouldNotFindType(\n-\t\t\t\t\tname,\n-\t\t\t\t\tpossibles,\n-\t\t\t\t\tposition.with_source(environment.get_source()),\n-\t\t\t\t));\n-\t\t\t\tTypeId::ERROR_TYPE\n \t\t\t}\n \t\t}\n \t\tTypeAnnotation::FunctionLiteral {\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -347,13 +361,20 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t&position,\n \t\t\t)\n \t\t}\n-\t\tTypeAnnotation::Readonly(type_annotation, pos) => {\n+\t\tTypeAnnotation::Abstract(_type_annotation, position) => {\n+\t\t\tchecking_data.raise_unimplemented_error(\n+\t\t\t\t\"abstact type annotation\",\n+\t\t\t\tposition.with_source(environment.get_source()),\n+\t\t\t);\n+\t\t\tTypeId::ERROR_TYPE\n+\t\t}\n+\t\tTypeAnnotation::Readonly(type_annotation, position) => {\n \t\t\tlet underlying_type =\n \t\t\t\tsynthesise_type_annotation(type_annotation, environment, checking_data);\n \n \t\t\tlet restrictions = Map::from_iter([(\n \t\t\t\tTypeId::T_TYPE,\n-\t\t\t\t(underlying_type, pos.with_source(environment.get_source())),\n+\t\t\t\t(underlying_type, position.with_source(environment.get_source())),\n \t\t\t)]);\n \t\t\tlet ty = Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n \t\t\t\ton: TypeId::READONLY_RESTRICTION,\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -364,7 +385,6 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \n \t\t\t// environment.frozen.insert(ty_to_be_readonly, TypeId::TRUE);\n \t\t}\n-\t\tTypeAnnotation::NamespacedName(_, _, _) => unimplemented!(),\n \t\tTypeAnnotation::ArrayLiteral(item_annotation, _) => {\n \t\t\tlet item_type = synthesise_type_annotation(item_annotation, environment, checking_data);\n \t\t\tlet position = item_annotation.get_position().with_source(environment.get_source());\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -641,32 +661,52 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\tcrate::utilities::notify!(\"Unknown decorator skipping {:#?}\", decorator.name);\n \t\t\tsynthesise_type_annotation(inner, environment, checking_data)\n \t\t}\n-\t\tTypeAnnotation::TemplateLiteral(parts, _) => {\n-\t\t\tlet mut iter = parts.iter();\n-\t\t\tlet mut acc = part_to_type(iter.next().unwrap(), checking_data, environment);\n+\t\tTypeAnnotation::TemplateLiteral { parts, last, .. } => {\n \t\t\t// Using the existing thing breaks because we try to do `\"...\" + string` and\n \t\t\t// the evaluate_mathematical_operator expects literal or poly values (not just types)\n-\t\t\t// TODO abstract to features/template_literal.rs\n-\t\t\tfor part in iter {\n-\t\t\t\tlet next = part_to_type(part, checking_data, environment);\n-\t\t\t\tlet ty = if let (\n-\t\t\t\t\tType::Constant(Constant::String(left)),\n-\t\t\t\t\tType::Constant(Constant::String(right)),\n-\t\t\t\t) = (\n-\t\t\t\t\tchecking_data.types.get_type_by_id(acc),\n-\t\t\t\t\tchecking_data.types.get_type_by_id(next),\n-\t\t\t\t) {\n-\t\t\t\t\tType::Constant(Constant::String(format!(\"{left}{right}\")))\n+\t\t\tlet mut acc = TypeId::EMPTY_STRING;\n+\t\t\tfor (static_part, dynamic_part) in parts {\n+\t\t\t\tlet lhs =\n+\t\t\t\t\tchecking_data.types.new_constant_type(Constant::String(static_part.to_owned()));\n+\t\t\t\tacc = if let TypeId::EMPTY_STRING = acc {\n+\t\t\t\t\tlhs\n \t\t\t\t} else {\n-\t\t\t\t\tType::Constructor(Constructor::BinaryOperator {\n-\t\t\t\t\t\tlhs: acc,\n-\t\t\t\t\t\toperator: crate::features::operations::MathematicalAndBitwise::Add,\n-\t\t\t\t\t\trhs: next,\n-\t\t\t\t\t})\n+\t\t\t\t\tchecking_data.types.register_type(Type::Constructor(\n+\t\t\t\t\t\tcrate::types::Constructor::BinaryOperator {\n+\t\t\t\t\t\t\tlhs: acc,\n+\t\t\t\t\t\t\toperator: crate::features::operations::MathematicalAndBitwise::Add,\n+\t\t\t\t\t\t\trhs: lhs,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t))\n \t\t\t\t};\n-\t\t\t\tacc = checking_data.types.register_type(ty);\n+\t\t\t\tlet rhs = synthesise_type_annotation(\n+\t\t\t\t\tdynamic_part.get_inner_ref(),\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\tchecking_data,\n+\t\t\t\t);\n+\t\t\t\tlet constructor = crate::types::Constructor::BinaryOperator {\n+\t\t\t\t\tlhs: acc,\n+\t\t\t\t\toperator: crate::features::operations::MathematicalAndBitwise::Add,\n+\t\t\t\t\trhs,\n+\t\t\t\t};\n+\t\t\t\tacc = checking_data.types.register_type(Type::Constructor(constructor));\n+\t\t\t}\n+\t\t\tif last.is_empty() {\n+\t\t\t\tacc\n+\t\t\t} else {\n+\t\t\t\tlet lhs = checking_data.types.new_constant_type(Constant::String(last.to_owned()));\n+\t\t\t\tif let TypeId::EMPTY_STRING = acc {\n+\t\t\t\t\tlhs\n+\t\t\t\t} else {\n+\t\t\t\t\tchecking_data.types.register_type(Type::Constructor(\n+\t\t\t\t\t\tcrate::types::Constructor::BinaryOperator {\n+\t\t\t\t\t\t\tlhs: acc,\n+\t\t\t\t\t\t\toperator: crate::features::operations::MathematicalAndBitwise::Add,\n+\t\t\t\t\t\t\trhs: lhs,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t))\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tacc\n \t\t}\n \t\tTypeAnnotation::Infer { name, extends, position: _ } => {\n \t\t\tlet extends = if let Some(ref extends) = extends {\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -700,9 +740,14 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t));\n \t\t\tchecking_data.types.register_type(ty)\n \t\t}\n-\t\tTypeAnnotation::Is { item, is, position } => {\n-\t\t\tlet _item = synthesise_type_annotation(item, environment, checking_data);\n-\t\t\tlet _is = synthesise_type_annotation(is, environment, checking_data);\n+\t\tTypeAnnotation::Is { reference: _, is: _, position } => {\n+\t\t\t// let _item = environment.get_reference_constraint(\n+\t\t\t// \tcrate::features::assignments::Reference::Variable(\n+\t\t\t// \t\treference.clone(),\n+\t\t\t// \t\tposition.with_source(environment.get_source()),\n+\t\t\t// \t),\n+\t\t\t// );\n+\t\t\t// let _is = synthesise_type_annotation(is, environment, checking_data);\n \t\t\tchecking_data.raise_unimplemented_error(\n \t\t\t\t\"is type annotation\",\n \t\t\t\tposition.with_source(environment.get_source()),\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -754,27 +799,6 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \tty\n }\n \n-fn part_to_type<T: crate::ReadFromFS>(\n-\tpart: &parser::ast::TemplateLiteralPart<AnnotationWithBinder>,\n-\tchecking_data: &mut CheckingData<T, super::EznoParser>,\n-\tenvironment: &mut Environment,\n-) -> TypeId {\n-\tmatch part {\n-\t\tparser::ast::TemplateLiteralPart::Static(s) => {\n-\t\t\tchecking_data.types.new_constant_type(Constant::String(s.clone()))\n-\t\t}\n-\t\tparser::ast::TemplateLiteralPart::Dynamic(p) => {\n-\t\t\tlet annotation = p.get_inner_ref();\n-\t\t\tlet ty = synthesise_type_annotation(annotation, environment, checking_data);\n-\t\t\tif let Type::AliasTo { to, .. } = checking_data.types.get_type_by_id(ty) {\n-\t\t\t\t*to\n-\t\t\t} else {\n-\t\t\t\tty\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n /// Comment as type annotation\n pub(crate) fn comment_as_type_annotation<T: crate::ReadFromFS>(\n \tpossible_declaration: &str,\ndiff --git a/parser/examples/code_blocks_to_script.rs b/parser/examples/code_blocks_to_script.rs\n--- a/parser/examples/code_blocks_to_script.rs\n+++ b/parser/examples/code_blocks_to_script.rs\n@@ -17,10 +17,16 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n \tlet into_files_directory_and_extension = args.windows(3).find_map(|item| {\n \t\tmatches!(item[0].as_str(), \"--into-files\").then_some((item[1].clone(), item[2].clone()))\n \t});\n+\n \tlet out_file = args\n \t\t.windows(2)\n \t\t.find_map(|item| matches!(item[0].as_str(), \"--out\").then_some(item[1].clone()));\n \n+\tlet repeat = args.windows(2).find_map(|item| {\n+\t\tmatches!(item[0].as_str(), \"--repeat\")\n+\t\t\t.then_some(item[1].parse::<u16>().expect(\"--repeat must be integer\"))\n+\t});\n+\n \tlet content = std::fs::read_to_string(&path)?;\n \n \tlet filters: Vec<&str> = vec![\"import\", \"export\", \"declare\"];\ndiff --git a/parser/examples/code_blocks_to_script.rs b/parser/examples/code_blocks_to_script.rs\n--- a/parser/examples/code_blocks_to_script.rs\n+++ b/parser/examples/code_blocks_to_script.rs\n@@ -63,8 +69,15 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n \t\t\t// Fix for FLow\n \t\t\tlet code =\n \t\t\t\tif replace_satisfies_with_as { code.replace(\" satisfies \", \" as \") } else { code };\n-\t\t\tfor line in code.lines() {\n-\t\t\t\twriteln!(file, \"{}\", line.strip_prefix('\\t').unwrap_or(line))?;\n+\n+\t\t\tif let Some(repeat) = repeat {\n+\t\t\t\tfor _ in 0..repeat {\n+\t\t\t\t\twriteln!(file, \"() => {{\\n{code}\\n}};\")?;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfor line in code.lines() {\n+\t\t\t\t\twriteln!(file, \"{}\", line.strip_prefix('\\t').unwrap_or(line))?;\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn Ok(());\ndiff --git a/parser/examples/lex.rs b/parser/examples/lex.rs\n--- a/parser/examples/lex.rs\n+++ b/parser/examples/lex.rs\n@@ -1,24 +1,25 @@\n use std::thread::spawn;\n \n-use ezno_parser::lex_script;\n+use ezno_parser::{lex_script, LexerOptions};\n use tokenizer_lib::{sized_tokens::SizedToken, ParallelTokenQueue, Token, TokenReader};\n \n fn main() -> Result<(), Box<dyn std::error::Error>> {\n \tlet mut args: std::collections::VecDeque<_> = std::env::args().skip(1).collect();\n \tlet path = args.pop_front().ok_or(\"expected argument\")?;\n \tlet print_tokens = !args.iter().any(|item| item == \"--quiet\");\n+\tlet top_level_html = args.iter().any(|item| item == \"--top-level-html\");\n \n \tlet script = std::fs::read_to_string(path)?;\n-\tlex_and_print_tokens(script, print_tokens);\n+\tlex_and_print_tokens(script, print_tokens, top_level_html);\n \tOk(())\n }\n \n-fn lex_and_print_tokens(script: String, print_tokens: bool) {\n+fn lex_and_print_tokens(script: String, print_tokens: bool, top_level_html: bool) {\n \tlet (mut sender, mut receiver) = ParallelTokenQueue::new();\n \n \tprintln!(\"{:?}\", ezno_parser::source_map::LineStarts::new(&script));\n \n-\tlet lexer_options: ezno_parser::LexerOptions = Default::default();\n+\tlet lexer_options: LexerOptions = LexerOptions { top_level_html, ..Default::default() };\n \tlet other = script.clone();\n \tlet thread = spawn(move || lex_script(&script, &mut sender, &lexer_options, None));\n \ndiff --git a/parser/examples/parse.rs b/parser/examples/parse.rs\n--- a/parser/examples/parse.rs\n+++ b/parser/examples/parse.rs\n@@ -9,6 +9,8 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n \n \tlet comments = if args.iter().any(|item| item == \"--no-comments\") {\n \t\tComments::None\n+\t} else if args.iter().any(|item| item == \"--doc-comments\") {\n+\t\tComments::JustDocumentation\n \t} else {\n \t\tComments::All\n \t};\ndiff --git a/parser/examples/parse.rs b/parser/examples/parse.rs\n--- a/parser/examples/parse.rs\n+++ b/parser/examples/parse.rs\n@@ -21,6 +23,7 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n \tlet render_timings = args.iter().any(|item| item == \"--render-timings\");\n \tlet type_definition_module = args.iter().any(|item| item == \"--type-definition-module\");\n \tlet type_annotations = !args.iter().any(|item| item == \"--no-type-annotations\");\n+\tlet top_level_html = args.iter().any(|item| item == \"--top-level-html\");\n \n \tlet print_ast = args.iter().any(|item| item == \"--ast\");\n \ndiff --git a/parser/examples/parse.rs b/parser/examples/parse.rs\n--- a/parser/examples/parse.rs\n+++ b/parser/examples/parse.rs\n@@ -45,6 +48,7 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n \t\tis_expressions: extras,\n \t\tspecial_jsx_attributes: extras,\n \t\textra_operators: extras,\n+\t\ttop_level_html,\n \t\t..ParseOptions::default()\n \t};\n \ndiff --git a/parser/examples/pretty_printing.rs b/parser/examples/pretty_printing.rs\n--- a/parser/examples/pretty_printing.rs\n+++ b/parser/examples/pretty_printing.rs\n@@ -1,7 +1,10 @@\n use ezno_parser::{ASTNode, Module, ParseOptions, ToStringOptions};\n \n fn main() {\n-\tlet input = r#\"const x = something ? \"hello world something x\" : \"another thing quite long, lolmao. another thing quite long, lolmao\";\n+\tlet input = r#\"\n+import { something, aaa, another_thing, bbb } from \"./x.js\";\n+\t\n+const x = something ? \"hello world something x\" : \"another thing quite long, lolmao. another thing quite long, lolmao\";\n const y = \"hello world something x\", z = \"another thing quite long, lolmao. another thing quite long, lolmao\";\n \n function x(a: { something: string, another: number, third: \"yes\" }, b: Array<{ everything: any }>) {\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -66,6 +66,7 @@ impl ASTNode for StatementOrDeclaration {\n \t\tstate: &mut crate::ParsingState,\n \t\toptions: &ParseOptions,\n \t) -> ParseResult<Self> {\n+\t\t// Exclusively for generator\n \t\tif options.interpolation_points\n \t\t\t&& matches!(reader.peek(), Some(Token(TSXToken::Identifier(i), _)) if i == MARKER)\n \t\t{\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -332,7 +333,7 @@ impl ASTNode for BlockOrSingleStatement {\n \t\t\t\t\t\treader,\n \t\t\t\t\t\t&state.line_starts,\n \t\t\t\t\t\tstmt.get_position().end,\n-\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\toptions,\n \t\t\t\t\t)?;\n \t\t\t\t}\n \t\t\t\tBox::new(stmt).into()\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -388,7 +389,7 @@ pub(crate) fn parse_statements_and_declarations(\n \t\tlet end = item.get_position().end;\n \n \t\tlet blank_lines_after_statement = if requires_semi_colon {\n-\t\t\texpect_semi_colon(reader, &state.line_starts, end, options.retain_blank_lines)?\n+\t\t\texpect_semi_colon(reader, &state.line_starts, end, options)?\n \t\t} else if options.retain_blank_lines {\n \t\t\tlet Token(kind, next) = reader.peek().unwrap();\n \t\t\tlet lines = state.line_starts.byte_indexes_crosses_lines(end as usize, next.0 as usize);\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -436,10 +437,10 @@ pub fn statements_and_declarations_to_string<T: source_map::ToString>(\n \t\t\t(options.include_type_annotations, item)\n \t\t{\n \t\t\tmatch dec {\n-\t\t\t\tDeclaration::Function(item) if item.on.name.declare => {\n+\t\t\t\tDeclaration::Function(item) if item.on.name.is_declare => {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n-\t\t\t\tDeclaration::Class(item) if item.on.name.declare => {\n+\t\t\t\tDeclaration::Class(item) if item.on.name.is_declare => {\n \t\t\t\t\tcontinue;\n \t\t\t\t}\n \t\t\t\t_ => {}\ndiff --git a/parser/src/comments.rs b/parser/src/comments.rs\n--- a/parser/src/comments.rs\n+++ b/parser/src/comments.rs\n@@ -137,13 +137,13 @@ impl<T: ASTNode> ASTNode for WithComment<T> {\n \t) {\n \t\tmatch self {\n \t\t\tSelf::None(ast) => ast.to_string_from_buffer(buf, options, local),\n-\t\t\tSelf::PrefixComment(comment, ast, _) => {\n-\t\t\t\tif options.should_add_comment(comment.starts_with('*')) {\n+\t\t\tSelf::PrefixComment(content, ast, _) => {\n+\t\t\t\tif options.should_add_comment(content) {\n \t\t\t\t\tbuf.push_str(\"/*\");\n \t\t\t\t\tif options.pretty {\n \t\t\t\t\t\t// Perform indent correction\n \t\t\t\t\t\t// Have to use '\\n' as `.lines` with it's handling of '\\r'\n-\t\t\t\t\t\tfor (idx, line) in comment.split('\\n').enumerate() {\n+\t\t\t\t\t\tfor (idx, line) in content.split('\\n').enumerate() {\n \t\t\t\t\t\t\tif idx > 0 {\n \t\t\t\t\t\t\t\tbuf.push_new_line();\n \t\t\t\t\t\t\t}\ndiff --git a/parser/src/comments.rs b/parser/src/comments.rs\n--- a/parser/src/comments.rs\n+++ b/parser/src/comments.rs\n@@ -152,7 +152,7 @@ impl<T: ASTNode> ASTNode for WithComment<T> {\n \t\t\t\t\t\t}\n \t\t\t\t\t// buf.push_new_line();\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tbuf.push_str_contains_new_line(comment.as_str());\n+\t\t\t\t\t\tbuf.push_str_contains_new_line(content.as_str());\n \t\t\t\t\t}\n \t\t\t\t\tbuf.push_str(\"*/\");\n \t\t\t\t}\ndiff --git a/parser/src/comments.rs b/parser/src/comments.rs\n--- a/parser/src/comments.rs\n+++ b/parser/src/comments.rs\n@@ -160,7 +160,7 @@ impl<T: ASTNode> ASTNode for WithComment<T> {\n \t\t\t}\n \t\t\tSelf::PostfixComment(ast, comment, _) => {\n \t\t\t\tast.to_string_from_buffer(buf, options, local);\n-\t\t\t\tif options.should_add_comment(comment.starts_with('*')) {\n+\t\t\t\tif options.should_add_comment(comment) {\n \t\t\t\t\tbuf.push_str(\"/*\");\n \t\t\t\t\tif options.pretty {\n \t\t\t\t\t\t// Perform indent correction\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -221,15 +221,15 @@ impl ASTNode for ClassMember {\n \t\t\t\tbuf.push_str(\"static \");\n \t\t\t\tblock.to_string_from_buffer(buf, options, local.next_level());\n \t\t\t}\n-\t\t\tSelf::Comment(c, is_multiline, _) => {\n-\t\t\t\tif options.should_add_comment(c.starts_with('.')) {\n+\t\t\tSelf::Comment(content, is_multiline, _) => {\n+\t\t\t\tif options.should_add_comment(content) {\n \t\t\t\t\tif *is_multiline {\n \t\t\t\t\t\tbuf.push_str(\"/*\");\n-\t\t\t\t\t\tbuf.push_str(c);\n+\t\t\t\t\t\tbuf.push_str(content);\n \t\t\t\t\t\tbuf.push_str(\"*/\");\n \t\t\t\t\t} else {\n \t\t\t\t\t\tbuf.push_str(\"//\");\n-\t\t\t\t\t\tbuf.push_str(c);\n+\t\t\t\t\t\tbuf.push_str(content);\n \t\t\t\t\t\tbuf.push_new_line();\n \t\t\t\t\t}\n \t\t\t\t}\ndiff --git a/parser/src/declarations/export.rs b/parser/src/declarations/export.rs\n--- a/parser/src/declarations/export.rs\n+++ b/parser/src/declarations/export.rs\n@@ -1,17 +1,16 @@\n use crate::{\n \tderive_ASTNode, errors::parse_lexing_error, throw_unexpected_token,\n-\ttype_annotations::TypeAnnotationFunctionParameters, ASTNode, Expression, ListItem, ParseError,\n+\ttype_annotations::TypeAnnotationFunctionParameters, ASTNode, Expression, ParseError,\n \tParseOptions, ParseResult, Span, StatementPosition, TSXKeyword, TSXToken, Token,\n \tTypeAnnotation, VariableIdentifier,\n };\n \n use super::{\n-\tvariable::VariableDeclaration, ClassDeclaration, ImportExportName, ImportLocation,\n+\tvariable::VariableDeclaration, ClassDeclaration, ImportExportPart, ImportLocation,\n \tInterfaceDeclaration, StatementFunction, TypeAlias,\n };\n \n use get_field_by_type::GetFieldByType;\n-use iterator_endiate::EndiateIteratorExt;\n use tokenizer_lib::TokenReader;\n use visitable_derive::Visitable;\n \ndiff --git a/parser/src/declarations/export.rs b/parser/src/declarations/export.rs\n--- a/parser/src/declarations/export.rs\n+++ b/parser/src/declarations/export.rs\n@@ -24,13 +23,11 @@ pub enum ExportDeclaration {\n \t\texported: Exportable,\n \t\tposition: Span,\n \t},\n-\n \t// `export default ...`\n \tDefault {\n \t\texpression: Box<Expression>,\n \t\tposition: Span,\n \t},\n-\n \tDefaultFunction {\n \t\t/// Technically not allowed in TypeScript\n \t\tis_async: bool,\ndiff --git a/parser/src/declarations/export.rs b/parser/src/declarations/export.rs\n--- a/parser/src/declarations/export.rs\n+++ b/parser/src/declarations/export.rs\n@@ -50,9 +47,17 @@ pub enum Exportable {\n \tVariable(VariableDeclaration),\n \tInterface(InterfaceDeclaration),\n \tTypeAlias(TypeAlias),\n-\tParts(Vec<ExportPart>),\n-\tImportAll { r#as: Option<VariableIdentifier>, from: ImportLocation },\n-\tImportParts { parts: Vec<ExportPart>, from: ImportLocation, type_definitions_only: bool },\n+\tParts(Vec<ImportExportPart<ExportDeclaration>>),\n+\tImportAll {\n+\t\tr#as: Option<VariableIdentifier>,\n+\t\tfrom: ImportLocation,\n+\t},\n+\tImportParts {\n+\t\t// yah `super::ImportDeclaration` here\n+\t\tparts: Vec<ImportExportPart<super::ImportDeclaration>>,\n+\t\tfrom: ImportLocation,\n+\t\ttype_definitions_only: bool,\n+\t},\n }\n \n impl ASTNode for ExportDeclaration {\ndiff --git a/parser/src/declarations/export.rs b/parser/src/declarations/export.rs\n--- a/parser/src/declarations/export.rs\n+++ b/parser/src/declarations/export.rs\n@@ -170,7 +175,7 @@ impl ASTNode for ExportDeclaration {\n \t\t\t\t\tstate.append_keyword_at_pos(reader.next().unwrap().1 .0, TSXKeyword::Type);\n \t\t\t\t\tlet Token(_, start) = reader.next().unwrap(); // OpenBrace\n \n-\t\t\t\t\tlet (parts, _, _end) = crate::parse_bracketed::<ExportPart>(\n+\t\t\t\t\tlet (parts, _, _end) = crate::parse_bracketed::<ImportExportPart<_>>(\n \t\t\t\t\t\treader,\n \t\t\t\t\t\tstate,\n \t\t\t\t\t\toptions,\ndiff --git a/parser/src/declarations/export.rs b/parser/src/declarations/export.rs\n--- a/parser/src/declarations/export.rs\n+++ b/parser/src/declarations/export.rs\n@@ -213,7 +218,7 @@ impl ASTNode for ExportDeclaration {\n \t\t\t\t});\n \t\t\t\tif let Some(Token(token_type, _)) = after_bracket {\n \t\t\t\t\tif let TSXToken::Keyword(TSXKeyword::From) = token_type {\n-\t\t\t\t\t\tlet (parts, _, _end) = crate::parse_bracketed::<ExportPart>(\n+\t\t\t\t\t\tlet (parts, _, _end) = crate::parse_bracketed::<ImportExportPart<_>>(\n \t\t\t\t\t\t\treader,\n \t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\toptions,\ndiff --git a/parser/src/declarations/export.rs b/parser/src/declarations/export.rs\n--- a/parser/src/declarations/export.rs\n+++ b/parser/src/declarations/export.rs\n@@ -234,7 +239,7 @@ impl ASTNode for ExportDeclaration {\n \t\t\t\t\t\t\tposition: start.union(end),\n \t\t\t\t\t\t})\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tlet (parts, _, end) = crate::parse_bracketed::<ExportPart>(\n+\t\t\t\t\t\tlet (parts, _, end) = crate::parse_bracketed::<ImportExportPart<_>>(\n \t\t\t\t\t\t\treader,\n \t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\toptions,\ndiff --git a/parser/src/declarations/export.rs b/parser/src/declarations/export.rs\n--- a/parser/src/declarations/export.rs\n+++ b/parser/src/declarations/export.rs\n@@ -302,17 +307,9 @@ impl ASTNode for ExportDeclaration {\n \t\t\t\t\t\ttype_alias.to_string_from_buffer(buf, options, local);\n \t\t\t\t\t}\n \t\t\t\t\tExportable::Parts(parts) => {\n-\t\t\t\t\t\tbuf.push('{');\n-\t\t\t\t\t\toptions.push_gap_optionally(buf);\n-\t\t\t\t\t\tfor (at_end, part) in parts.iter().endiate() {\n-\t\t\t\t\t\t\tpart.to_string_from_buffer(buf, options, local);\n-\t\t\t\t\t\t\tif !at_end {\n-\t\t\t\t\t\t\t\tbuf.push(',');\n-\t\t\t\t\t\t\t\toptions.push_gap_optionally(buf);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\toptions.push_gap_optionally(buf);\n-\t\t\t\t\t\tbuf.push('}');\n+\t\t\t\t\t\tsuper::import_export_parts_to_string_from_buffer(\n+\t\t\t\t\t\t\tparts, buf, options, local,\n+\t\t\t\t\t\t);\n \t\t\t\t\t}\n \t\t\t\t\tExportable::ImportAll { r#as, from } => {\n \t\t\t\t\t\tbuf.push_str(\"* \");\ndiff --git a/parser/src/declarations/export.rs b/parser/src/declarations/export.rs\n--- a/parser/src/declarations/export.rs\n+++ b/parser/src/declarations/export.rs\n@@ -329,18 +326,9 @@ impl ASTNode for ExportDeclaration {\n \t\t\t\t\t\tif *type_definitions_only {\n \t\t\t\t\t\t\tbuf.push_str(\"type \");\n \t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tbuf.push('{');\n-\t\t\t\t\t\toptions.push_gap_optionally(buf);\n-\t\t\t\t\t\tfor (at_end, part) in parts.iter().endiate() {\n-\t\t\t\t\t\t\tpart.to_string_from_buffer(buf, options, local);\n-\t\t\t\t\t\t\tif !at_end {\n-\t\t\t\t\t\t\t\tbuf.push(',');\n-\t\t\t\t\t\t\t\toptions.push_gap_optionally(buf);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\toptions.push_gap_optionally(buf);\n-\t\t\t\t\t\tbuf.push('}');\n+\t\t\t\t\t\tsuper::import_export_parts_to_string_from_buffer(\n+\t\t\t\t\t\t\tparts, buf, options, local,\n+\t\t\t\t\t\t);\n \t\t\t\t\t\toptions.push_gap_optionally(buf);\n \t\t\t\t\t\tbuf.push_str(\"from \\\"\");\n \t\t\t\t\t\tfrom.to_string_from_buffer(buf);\ndiff --git a/parser/src/declarations/export.rs b/parser/src/declarations/export.rs\n--- a/parser/src/declarations/export.rs\n+++ b/parser/src/declarations/export.rs\n@@ -379,124 +367,3 @@ impl ASTNode for ExportDeclaration {\n \t\t}\n \t}\n }\n-\n-/// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#syntax>\n-///\n-/// Similar to [`ImportPart`] but reversed\n-#[apply(derive_ASTNode)]\n-#[derive(Debug, Clone, PartialEq, Visitable, GetFieldByType)]\n-#[get_field_by_type_target(Span)]\n-pub enum ExportPart {\n-\tName(VariableIdentifier),\n-\tNameWithAlias {\n-\t\tname: String,\n-\t\talias: ImportExportName,\n-\t\tposition: Span,\n-\t},\n-\tPrefixComment(\n-\t\tString,\n-\t\t#[cfg_attr(target_family = \"wasm\", tsify(type = \"ExportPart | null\"))] Option<Box<Self>>,\n-\t\tSpan,\n-\t),\n-\tPostfixComment(\n-\t\t#[cfg_attr(target_family = \"wasm\", tsify(type = \"ExportPart\"))] Box<Self>,\n-\t\tString,\n-\t\tSpan,\n-\t),\n-}\n-\n-impl ListItem for ExportPart {\n-\ttype LAST = ();\n-}\n-\n-impl ASTNode for ExportPart {\n-\tfn get_position(&self) -> Span {\n-\t\t*GetFieldByType::get(self)\n-\t}\n-\n-\t// TODO also single line comments here\n-\tfn from_reader(\n-\t\treader: &mut impl TokenReader<TSXToken, crate::TokenStart>,\n-\t\tstate: &mut crate::ParsingState,\n-\t\toptions: &ParseOptions,\n-\t) -> ParseResult<Self> {\n-\t\tlet token = reader.next().ok_or_else(parse_lexing_error)?;\n-\t\tif let Token(TSXToken::MultiLineComment(comment), start) = token {\n-\t\t\tlet (position, under) =\n-\t\t\t\tif let Some(Token(TSXToken::CloseBrace | TSXToken::Comma, _)) = reader.peek() {\n-\t\t\t\t\t(start.with_length(comment.len() + 2), None)\n-\t\t\t\t} else {\n-\t\t\t\t\tlet part = Self::from_reader(reader, state, options)?;\n-\t\t\t\t\t(start.union(part.get_position()), Some(Box::new(part)))\n-\t\t\t\t};\n-\t\t\tOk(Self::PrefixComment(comment, under, position))\n-\t\t} else {\n-\t\t\tlet (name, pos) = crate::tokens::token_as_identifier(token, \"export name\")?;\n-\t\t\tlet mut value = if let Some(Token(TSXToken::Keyword(TSXKeyword::As), _)) = reader.peek()\n-\t\t\t{\n-\t\t\t\treader.next();\n-\t\t\t\tlet (alias, end) = ImportExportName::from_reader(reader, state, options)?;\n-\t\t\t\tlet position = pos.union(end);\n-\t\t\t\tSelf::NameWithAlias { name, alias, position }\n-\t\t\t} else {\n-\t\t\t\tSelf::Name(VariableIdentifier::Standard(name, pos))\n-\t\t\t};\n-\n-\t\t\twhile let Some(Token(TSXToken::MultiLineComment(_), _)) = reader.peek() {\n-\t\t\t\tlet Some(Token(TSXToken::MultiLineComment(c), start)) = reader.next() else {\n-\t\t\t\t\tunreachable!()\n-\t\t\t\t};\n-\t\t\t\tlet pos = value.get_position().union(start.get_end_after(c.len() + 2));\n-\t\t\t\tvalue = Self::PostfixComment(Box::new(value), c, pos);\n-\t\t\t}\n-\t\t\tOk(value)\n-\t\t}\n-\t}\n-\n-\tfn to_string_from_buffer<T: source_map::ToString>(\n-\t\t&self,\n-\t\tbuf: &mut T,\n-\t\toptions: &crate::ToStringOptions,\n-\t\tlocal: crate::LocalToStringInformation,\n-\t) {\n-\t\tmatch self {\n-\t\t\tExportPart::Name(name) => {\n-\t\t\t\tname.to_string_from_buffer(buf, options, local);\n-\t\t\t}\n-\t\t\tExportPart::NameWithAlias { name, alias, .. } => {\n-\t\t\t\tbuf.push_str(name);\n-\t\t\t\tbuf.push_str(\" as \");\n-\t\t\t\tmatch alias {\n-\t\t\t\t\tImportExportName::Reference(alias) => buf.push_str(alias),\n-\t\t\t\t\tImportExportName::Quoted(alias, q) => {\n-\t\t\t\t\t\tbuf.push(q.as_char());\n-\t\t\t\t\t\tbuf.push_str(alias);\n-\t\t\t\t\t\tbuf.push(q.as_char());\n-\t\t\t\t\t}\n-\t\t\t\t\tImportExportName::Marker(_) => {}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tExportPart::PrefixComment(comment, inner, _) => {\n-\t\t\t\tif options.should_add_comment(comment.starts_with('.')) {\n-\t\t\t\t\tbuf.push_str(\"/*\");\n-\t\t\t\t\tbuf.push_str(comment);\n-\t\t\t\t\tbuf.push_str(\"*/\");\n-\t\t\t\t\tif inner.is_some() {\n-\t\t\t\t\t\tbuf.push(' ');\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif let Some(inner) = inner {\n-\t\t\t\t\tinner.to_string_from_buffer(buf, options, local);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tExportPart::PostfixComment(inner, comment, _) => {\n-\t\t\t\tinner.to_string_from_buffer(buf, options, local);\n-\t\t\t\tif options.should_add_comment(comment.starts_with('.')) {\n-\t\t\t\t\tbuf.push_str(\"/*\");\n-\t\t\t\t\tbuf.push_str(comment);\n-\t\t\t\t\tbuf.push_str(\"*/ \");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-}\ndiff --git a/parser/src/declarations/import.rs b/parser/src/declarations/import.rs\n--- a/parser/src/declarations/import.rs\n+++ b/parser/src/declarations/import.rs\n@@ -1,23 +1,19 @@\n-use get_field_by_type::GetFieldByType;\n-use iterator_endiate::EndiateIteratorExt;\n use source_map::Span;\n use tokenizer_lib::{sized_tokens::TokenStart, Token, TokenReader};\n \n use crate::{\n-\tast::object_literal::ObjectLiteral, derive_ASTNode, errors::parse_lexing_error,\n-\tparse_bracketed, throw_unexpected_token, tokens::token_as_identifier, ASTNode, ListItem,\n-\tMarker, ParseOptions, ParseResult, ParsingState, Quoted, TSXKeyword, TSXToken,\n-\tVariableIdentifier,\n+\tast::object_literal::ObjectLiteral, derive_ASTNode, parse_bracketed, throw_unexpected_token,\n+\tASTNode, ParseOptions, ParseResult, ParsingState, TSXKeyword, TSXToken, VariableIdentifier,\n };\n use visitable_derive::Visitable;\n \n-use super::ImportLocation;\n+use super::{ImportExportPart, ImportLocation};\n \n /// Side effects is represented under the Parts variant where the vector is empty\n #[derive(Debug, Clone, PartialEq, Visitable)]\n #[apply(derive_ASTNode)]\n pub enum ImportedItems {\n-\tParts(Option<Vec<ImportPart>>),\n+\tParts(Option<Vec<ImportExportPart<ImportDeclaration>>>),\n \tAll { under: VariableIdentifier },\n }\n \ndiff --git a/parser/src/declarations/import.rs b/parser/src/declarations/import.rs\n--- a/parser/src/declarations/import.rs\n+++ b/parser/src/declarations/import.rs\n@@ -38,48 +34,6 @@ pub struct ImportDeclaration {\n \tpub reversed: bool,\n }\n \n-/// TODO `default` should have its own variant?\n-#[derive(Debug, Clone, PartialEq)]\n-#[apply(derive_ASTNode)]\n-pub enum ImportExportName {\n-\tReference(String),\n-\tQuoted(String, Quoted),\n-\t/// For typing here\n-\t#[cfg_attr(feature = \"self-rust-tokenize\", self_tokenize_field(0))]\n-\tMarker(\n-\t\t#[cfg_attr(target_family = \"wasm\", tsify(type = \"Marker<ImportExportName>\"))] Marker<Self>,\n-\t),\n-}\n-\n-impl ImportExportName {\n-\tpub(crate) fn from_reader(\n-\t\treader: &mut impl TokenReader<TSXToken, crate::TokenStart>,\n-\t\tstate: &mut crate::ParsingState,\n-\t\toptions: &ParseOptions,\n-\t) -> ParseResult<(Self, source_map::End)> {\n-\t\tif let Some(Token(TSXToken::Comma, pos)) = reader.peek() {\n-\t\t\tlet marker = state.new_partial_point_marker(*pos);\n-\t\t\treturn Ok((ImportExportName::Marker(marker), pos.get_end_after(0)));\n-\t\t}\n-\t\tlet token = reader.next().unwrap();\n-\t\tif let Token(TSXToken::StringLiteral(alias, quoted), start) = token {\n-\t\t\tlet with_length = start.get_end_after(alias.len() + 1);\n-\t\t\tstate.constant_imports.push(alias.clone());\n-\t\t\tOk((ImportExportName::Quoted(alias, quoted), with_length))\n-\t\t} else {\n-\t\t\tlet (ident, pos) = token_as_identifier(token, \"import alias\")?;\n-\t\t\tif options.interpolation_points && ident == crate::marker::MARKER {\n-\t\t\t\tOk((\n-\t\t\t\t\tImportExportName::Marker(state.new_partial_point_marker(pos.get_start())),\n-\t\t\t\t\tpos.get_end(),\n-\t\t\t\t))\n-\t\t\t} else {\n-\t\t\t\tOk((ImportExportName::Reference(ident), pos.get_end()))\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n impl ASTNode for ImportDeclaration {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, crate::TokenStart>,\ndiff --git a/parser/src/declarations/import.rs b/parser/src/declarations/import.rs\n--- a/parser/src/declarations/import.rs\n+++ b/parser/src/declarations/import.rs\n@@ -155,17 +109,9 @@ impl ASTNode for ImportDeclaration {\n \t\t\t\t\t\tif self.default.is_some() {\n \t\t\t\t\t\t\tbuf.push_str(\", \");\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tbuf.push('{');\n-\t\t\t\t\t\toptions.push_gap_optionally(buf);\n-\t\t\t\t\t\tfor (at_end, part) in parts.iter().endiate() {\n-\t\t\t\t\t\t\tpart.to_string_from_buffer(buf, options, local);\n-\t\t\t\t\t\t\tif !at_end {\n-\t\t\t\t\t\t\t\tbuf.push(',');\n-\t\t\t\t\t\t\t\toptions.push_gap_optionally(buf);\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\toptions.push_gap_optionally(buf);\n-\t\t\t\t\t\tbuf.push('}');\n+\t\t\t\t\t\tsuper::import_export_parts_to_string_from_buffer(\n+\t\t\t\t\t\t\tparts, buf, options, local,\n+\t\t\t\t\t\t);\n \t\t\t\t\t\toptions.push_gap_optionally(buf);\n \t\t\t\t\t}\n \t\t\t\t}\ndiff --git a/parser/src/declarations/import.rs b/parser/src/declarations/import.rs\n--- a/parser/src/declarations/import.rs\n+++ b/parser/src/declarations/import.rs\n@@ -274,7 +220,7 @@ pub(crate) fn parse_import_specifier_and_parts(\n \t\tlet end = under.get_position().get_end();\n \t\t(ImportedItems::All { under }, end)\n \t} else if let Some(Token(TSXToken::OpenBrace, _)) = peek {\n-\t\tlet (parts, _, end) = parse_bracketed::<ImportPart>(\n+\t\tlet (parts, _, end) = parse_bracketed::<ImportExportPart<_>>(\n \t\t\treader,\n \t\t\tstate,\n \t\t\toptions,\ndiff --git a/parser/src/declarations/import.rs b/parser/src/declarations/import.rs\n--- a/parser/src/declarations/import.rs\n+++ b/parser/src/declarations/import.rs\n@@ -298,151 +244,3 @@ pub(crate) fn parse_import_specifier_and_parts(\n \t\tend,\n \t})\n }\n-\n-/// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#syntax>\n-#[apply(derive_ASTNode)]\n-#[derive(Debug, Clone, PartialEq, Visitable, GetFieldByType)]\n-#[get_field_by_type_target(Span)]\n-pub enum ImportPart {\n-\tName(VariableIdentifier),\n-\tNameWithAlias {\n-\t\tname: String,\n-\t\talias: ImportExportName,\n-\t\tposition: Span,\n-\t},\n-\tPrefixComment(\n-\t\tString,\n-\t\t#[cfg_attr(target_family = \"wasm\", tsify(type = \"ImportPart | null\"))] Option<Box<Self>>,\n-\t\tSpan,\n-\t),\n-\tPostfixComment(\n-\t\t#[cfg_attr(target_family = \"wasm\", tsify(type = \"ImportPart\"))] Box<Self>,\n-\t\tString,\n-\t\tSpan,\n-\t),\n-}\n-\n-impl ListItem for ImportPart {\n-\ttype LAST = ();\n-}\n-\n-impl ASTNode for ImportPart {\n-\tfn get_position(&self) -> Span {\n-\t\t*GetFieldByType::get(self)\n-\t}\n-\n-\t// TODO also single line comments here\n-\tfn from_reader(\n-\t\treader: &mut impl TokenReader<TSXToken, crate::TokenStart>,\n-\t\tstate: &mut crate::ParsingState,\n-\t\toptions: &ParseOptions,\n-\t) -> ParseResult<Self> {\n-\t\tlet token = reader.next().ok_or_else(parse_lexing_error)?;\n-\t\tif let Token(TSXToken::MultiLineComment(comment), start) = token {\n-\t\t\tlet (position, under) =\n-\t\t\t\tif let Some(Token(TSXToken::CloseBrace | TSXToken::Comma, _)) = reader.peek() {\n-\t\t\t\t\t(start.with_length(comment.len() + 2), None)\n-\t\t\t\t} else {\n-\t\t\t\t\tlet part = Self::from_reader(reader, state, options)?;\n-\t\t\t\t\t(start.union(part.get_position()), Some(Box::new(part)))\n-\t\t\t\t};\n-\t\t\tOk(Self::PrefixComment(comment, under, position))\n-\t\t} else {\n-\t\t\tlet (alias, alias_pos) =\n-\t\t\t\tif let Token(TSXToken::StringLiteral(alias, quoted), start) = token {\n-\t\t\t\t\tlet with_length = start.with_length(alias.len() + 2);\n-\t\t\t\t\t(ImportExportName::Quoted(alias, quoted), with_length)\n-\t\t\t\t} else {\n-\t\t\t\t\tlet (ident, pos) = token_as_identifier(token, \"import alias\")?;\n-\t\t\t\t\t(ImportExportName::Reference(ident), pos)\n-\t\t\t\t};\n-\n-\t\t\tlet mut value = match alias {\n-\t\t\t\tImportExportName::Quoted(..) => {\n-\t\t\t\t\tlet _ = state.expect_keyword(reader, TSXKeyword::As)?;\n-\t\t\t\t\tlet (name, pos) = token_as_identifier(\n-\t\t\t\t\t\treader.next().ok_or_else(parse_lexing_error)?,\n-\t\t\t\t\t\t\"import name\",\n-\t\t\t\t\t)?;\n-\t\t\t\t\tlet position = alias_pos.union(pos);\n-\t\t\t\t\tSelf::NameWithAlias { name, alias, position }\n-\t\t\t\t}\n-\t\t\t\tImportExportName::Reference(reference) => {\n-\t\t\t\t\tif state.optionally_expect_keyword(reader, TSXKeyword::As).is_some() {\n-\t\t\t\t\t\tlet (name, pos) = token_as_identifier(\n-\t\t\t\t\t\t\treader.next().ok_or_else(parse_lexing_error)?,\n-\t\t\t\t\t\t\t\"import name\",\n-\t\t\t\t\t\t)?;\n-\t\t\t\t\t\tlet position = alias_pos.union(pos);\n-\t\t\t\t\t\tSelf::NameWithAlias {\n-\t\t\t\t\t\t\tname,\n-\t\t\t\t\t\t\talias: ImportExportName::Reference(reference),\n-\t\t\t\t\t\t\tposition,\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tSelf::Name(VariableIdentifier::Standard(reference, alias_pos))\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tImportExportName::Marker(id) => Self::Name(VariableIdentifier::Marker(\n-\t\t\t\t\tMarker(id.0, Default::default()),\n-\t\t\t\t\talias_pos,\n-\t\t\t\t)),\n-\t\t\t};\n-\t\t\twhile let Some(Token(TSXToken::MultiLineComment(_), _)) = reader.peek() {\n-\t\t\t\tlet Some(Token(TSXToken::MultiLineComment(c), start)) = reader.next() else {\n-\t\t\t\t\tunreachable!()\n-\t\t\t\t};\n-\t\t\t\tlet pos = value.get_position().union(start.get_end_after(c.len() + 2));\n-\t\t\t\tvalue = Self::PostfixComment(Box::new(value), c, pos);\n-\t\t\t}\n-\t\t\tOk(value)\n-\t\t}\n-\t}\n-\n-\tfn to_string_from_buffer<T: source_map::ToString>(\n-\t\t&self,\n-\t\tbuf: &mut T,\n-\t\toptions: &crate::ToStringOptions,\n-\t\tlocal: crate::LocalToStringInformation,\n-\t) {\n-\t\tmatch self {\n-\t\t\tImportPart::Name(name) => {\n-\t\t\t\tname.to_string_from_buffer(buf, options, local);\n-\t\t\t}\n-\t\t\tImportPart::NameWithAlias { name, alias, .. } => {\n-\t\t\t\tmatch alias {\n-\t\t\t\t\tImportExportName::Reference(alias) => buf.push_str(alias),\n-\t\t\t\t\tImportExportName::Quoted(alias, q) => {\n-\t\t\t\t\t\tbuf.push(q.as_char());\n-\t\t\t\t\t\tbuf.push_str(alias);\n-\t\t\t\t\t\tbuf.push(q.as_char());\n-\t\t\t\t\t}\n-\t\t\t\t\tImportExportName::Marker(_) => {}\n-\t\t\t\t}\n-\t\t\t\tbuf.push_str(\" as \");\n-\t\t\t\tbuf.push_str(name);\n-\t\t\t}\n-\t\t\tImportPart::PrefixComment(comment, inner, _) => {\n-\t\t\t\tif options.should_add_comment(comment.starts_with('.')) {\n-\t\t\t\t\tbuf.push_str(\"/*\");\n-\t\t\t\t\tbuf.push_str(comment);\n-\t\t\t\t\tbuf.push_str(\"*/\");\n-\t\t\t\t\tif inner.is_some() {\n-\t\t\t\t\t\tbuf.push(' ');\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif let Some(inner) = inner {\n-\t\t\t\t\tinner.to_string_from_buffer(buf, options, local);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tImportPart::PostfixComment(inner, comment, _) => {\n-\t\t\t\tinner.to_string_from_buffer(buf, options, local);\n-\t\t\t\tif options.should_add_comment(comment.starts_with('.')) {\n-\t\t\t\t\tbuf.push_str(\"/*\");\n-\t\t\t\t\tbuf.push_str(comment);\n-\t\t\t\t\tbuf.push_str(\"*/ \");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-}\ndiff --git a/parser/src/declarations/mod.rs b/parser/src/declarations/mod.rs\n--- a/parser/src/declarations/mod.rs\n+++ b/parser/src/declarations/mod.rs\n@@ -1,3 +1,15 @@\n+pub mod classes;\n+pub mod export;\n+pub mod import;\n+pub mod variable;\n+\n+pub use super::types::{\n+\tdeclare_variable::*,\n+\tenum_declaration::{EnumDeclaration, EnumMember},\n+\tinterface::InterfaceDeclaration,\n+\ttype_alias::TypeAlias,\n+};\n+\n use derive_enum_from_into::{EnumFrom, EnumTryInto};\n use get_field_by_type::GetFieldByType;\n use source_map::Span;\ndiff --git a/parser/src/declarations/mod.rs b/parser/src/declarations/mod.rs\n--- a/parser/src/declarations/mod.rs\n+++ b/parser/src/declarations/mod.rs\n@@ -11,7 +23,9 @@ use crate::{\n };\n \n pub use self::{\n+\tclasses::ClassDeclaration,\n \texport::ExportDeclaration,\n+\timport::ImportDeclaration,\n \tvariable::{VariableDeclaration, VariableDeclarationItem},\n };\n \ndiff --git a/parser/src/declarations/mod.rs b/parser/src/declarations/mod.rs\n--- a/parser/src/declarations/mod.rs\n+++ b/parser/src/declarations/mod.rs\n@@ -29,20 +43,6 @@ const TYPES_STATEMENT_FUNCTION: &str = r\"\n \t}\n \";\n \n-pub mod classes;\n-pub mod export;\n-pub mod import;\n-pub mod variable;\n-\n-pub use super::types::{\n-\tdeclare_variable::*,\n-\tenum_declaration::{EnumDeclaration, EnumMember},\n-\tinterface::InterfaceDeclaration,\n-\ttype_alias::TypeAlias,\n-};\n-pub use classes::ClassDeclaration;\n-pub use import::{ImportDeclaration, ImportExportName, ImportPart};\n-\n #[apply(derive_ASTNode)]\n #[derive(\n \tDebug, Clone, Visitable, EnumFrom, EnumTryInto, PartialEq, get_field_by_type::GetFieldByType,\ndiff --git a/parser/src/declarations/mod.rs b/parser/src/declarations/mod.rs\n--- a/parser/src/declarations/mod.rs\n+++ b/parser/src/declarations/mod.rs\n@@ -280,22 +280,31 @@ impl crate::ASTNode for Declaration {\n \t\t\t\t\t\tlet mut class = ClassDeclaration::<StatementPosition>::from_reader(\n \t\t\t\t\t\t\treader, state, options,\n \t\t\t\t\t\t)?;\n-\t\t\t\t\t\tclass.name.declare = true;\n+\t\t\t\t\t\tclass.name.is_declare = true;\n \t\t\t\t\t\tclass.position.start = start.0;\n \t\t\t\t\t\tOk(Declaration::Class(Decorated::new(decorators, class)))\n \t\t\t\t\t}\n \t\t\t\t\tTSXToken::Keyword(TSXKeyword::Function) => {\n \t\t\t\t\t\tlet mut function = StatementFunction::from_reader(reader, state, options)?;\n-\t\t\t\t\t\tfunction.name.declare = true;\n+\t\t\t\t\t\tfunction.name.is_declare = true;\n \t\t\t\t\t\tfunction.position.start = start.0;\n \t\t\t\t\t\tOk(Declaration::Function(Decorated::new(decorators, function)))\n \t\t\t\t\t}\n \t\t\t\t\tTSXToken::Keyword(TSXKeyword::Type) => {\n \t\t\t\t\t\tlet mut alias = TypeAlias::from_reader(reader, state, options)?;\n-\t\t\t\t\t\talias.name.declare = true;\n+\t\t\t\t\t\talias.name.is_declare = true;\n \t\t\t\t\t\talias.position.start = start.0;\n \t\t\t\t\t\tOk(Declaration::TypeAlias(alias))\n \t\t\t\t\t}\n+\t\t\t\t\t#[cfg(feature = \"full-typescript\")]\n+\t\t\t\t\tTSXToken::Keyword(TSXKeyword::Namespace) => {\n+\t\t\t\t\t\tlet mut namespace = crate::types::namespace::Namespace::from_reader(\n+\t\t\t\t\t\t\treader, state, options,\n+\t\t\t\t\t\t)?;\n+\t\t\t\t\t\tnamespace.is_declare = true;\n+\t\t\t\t\t\tnamespace.position.start = start.0;\n+\t\t\t\t\t\tOk(Declaration::Namespace(namespace))\n+\t\t\t\t\t}\n \t\t\t\t\t_ => throw_unexpected_token_with_token(\n \t\t\t\t\t\treader.next().ok_or_else(parse_lexing_error)?,\n \t\t\t\t\t\t&[\ndiff --git a/parser/src/declarations/mod.rs b/parser/src/declarations/mod.rs\n--- a/parser/src/declarations/mod.rs\n+++ b/parser/src/declarations/mod.rs\n@@ -305,6 +314,7 @@ impl crate::ASTNode for Declaration {\n \t\t\t\t\t\t\tTSXToken::Keyword(TSXKeyword::Function),\n \t\t\t\t\t\t\tTSXToken::Keyword(TSXKeyword::Class),\n \t\t\t\t\t\t\tTSXToken::Keyword(TSXKeyword::Type),\n+\t\t\t\t\t\t\tTSXToken::Keyword(TSXKeyword::Namespace),\n \t\t\t\t\t\t],\n \t\t\t\t\t),\n \t\t\t\t}\ndiff --git a/parser/src/declarations/mod.rs b/parser/src/declarations/mod.rs\n--- a/parser/src/declarations/mod.rs\n+++ b/parser/src/declarations/mod.rs\n@@ -363,3 +373,214 @@ impl crate::ASTNode for Declaration {\n \t\t*self.get()\n \t}\n }\n+\n+pub trait ImportOrExport: std::fmt::Debug + Clone + PartialEq + Sync + Send + 'static {\n+\tconst PREFIX: bool;\n+}\n+\n+impl ImportOrExport for ImportDeclaration {\n+\tconst PREFIX: bool = true;\n+}\n+\n+impl ImportOrExport for ExportDeclaration {\n+\tconst PREFIX: bool = false;\n+}\n+\n+/// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#syntax>\n+#[derive(Debug, Clone, PartialEq, Visitable, GetFieldByType)]\n+#[get_field_by_type_target(Span)]\n+#[cfg_attr(feature = \"serde-serialize\", derive(serde::Serialize))]\n+pub struct ImportExportPart<T: ImportOrExport> {\n+\tpub just_type: bool,\n+\tpub name: crate::VariableIdentifier,\n+\tpub alias: Option<ImportExportName>,\n+\tpub position: Span,\n+\t#[visit_skip_field]\n+\tpub _marker: std::marker::PhantomData<T>,\n+}\n+\n+#[cfg_attr(target_family = \"wasm\", wasm_bindgen::prelude::wasm_bindgen(typescript_custom_section))]\n+#[allow(dead_code)]\n+const IMPORT_EXPORT_PART_TYPE: &str = r\"\n+\ttype ImportExportPart<_T> = { just_type: boolean, name: VariableIdentifier, alias: ImportExportName | null, position: Span };\n+\";\n+\n+impl<T: ImportOrExport> crate::ListItem for ImportExportPart<T> {\n+\ttype LAST = ();\n+}\n+\n+impl<U: ImportOrExport> crate::ASTNode for ImportExportPart<U> {\n+\tfn get_position(&self) -> Span {\n+\t\t*GetFieldByType::get(self)\n+\t}\n+\n+\t// TODO also single line comments here\n+\tfn from_reader(\n+\t\treader: &mut impl crate::TokenReader<TSXToken, crate::TokenStart>,\n+\t\tstate: &mut crate::ParsingState,\n+\t\toptions: &ParseOptions,\n+\t) -> crate::ParseResult<Self> {\n+\t\tlet just_type =\n+\t\t\treader.conditional_next(|t| matches!(t, TSXToken::Keyword(TSXKeyword::Type))).is_some();\n+\n+\t\tif U::PREFIX {\n+\t\t\tlet (alias, position) = ImportExportName::from_reader(reader, state, options)?;\n+\t\t\tif reader.conditional_next(|t| matches!(t, TSXToken::Keyword(TSXKeyword::As))).is_some()\n+\t\t\t{\n+\t\t\t\tlet name = crate::VariableIdentifier::from_reader(reader, state, options)?;\n+\t\t\t\tlet position = position.union(name.get_position());\n+\t\t\t\tOk(Self {\n+\t\t\t\t\tjust_type,\n+\t\t\t\t\tname,\n+\t\t\t\t\talias: Some(alias),\n+\t\t\t\t\tposition,\n+\t\t\t\t\t_marker: Default::default(),\n+\t\t\t\t})\n+\t\t\t} else if let ImportExportName::Reference(name) = alias {\n+\t\t\t\tlet name = crate::VariableIdentifier::Standard(name, position);\n+\t\t\t\tOk(Self { just_type, name, alias: None, position, _marker: Default::default() })\n+\t\t\t} else {\n+\t\t\t\tcrate::throw_unexpected_token(reader, &[TSXToken::Keyword(TSXKeyword::As)])\n+\t\t\t}\n+\t\t} else {\n+\t\t\tlet name = crate::VariableIdentifier::from_reader(reader, state, options)?;\n+\t\t\tlet mut position = name.get_position();\n+\t\t\tlet alias = if reader\n+\t\t\t\t.conditional_next(|t| matches!(t, TSXToken::Keyword(TSXKeyword::As)))\n+\t\t\t\t.is_some()\n+\t\t\t{\n+\t\t\t\tlet (alias, end) = ImportExportName::from_reader(reader, state, options)?;\n+\t\t\t\tposition = position.union(end);\n+\t\t\t\tSome(alias)\n+\t\t\t} else {\n+\t\t\t\tNone\n+\t\t\t};\n+\t\t\tOk(Self { just_type, name, alias, position, _marker: Default::default() })\n+\t\t}\n+\t}\n+\n+\tfn to_string_from_buffer<T: source_map::ToString>(\n+\t\t&self,\n+\t\tbuf: &mut T,\n+\t\toptions: &crate::ToStringOptions,\n+\t\tlocal: crate::LocalToStringInformation,\n+\t) {\n+\t\tif self.just_type && options.include_type_annotations {\n+\t\t\tbuf.push_str(\"type \");\n+\t\t}\n+\t\tif let Some(ref alias) = self.alias {\n+\t\t\tif U::PREFIX {\n+\t\t\t\talias.to_string_from_buffer(buf, options, local);\n+\t\t\t\tbuf.push_str(\" as \");\n+\t\t\t\tself.name.to_string_from_buffer(buf, options, local);\n+\t\t\t} else {\n+\t\t\t\tself.name.to_string_from_buffer(buf, options, local);\n+\t\t\t\tbuf.push_str(\" as \");\n+\t\t\t\talias.to_string_from_buffer(buf, options, local);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tself.name.to_string_from_buffer(buf, options, local);\n+\t\t}\n+\t}\n+}\n+\n+// If `options.pretty` sort by name\n+fn import_export_parts_to_string_from_buffer<T: source_map::ToString, U: ImportOrExport>(\n+\tparts: &[ImportExportPart<U>],\n+\tbuf: &mut T,\n+\toptions: &crate::ToStringOptions,\n+\tlocal: crate::LocalToStringInformation,\n+) {\n+\tuse super::ASTNode;\n+\tuse iterator_endiate::EndiateIteratorExt;\n+\n+\tbuf.push('{');\n+\toptions.push_gap_optionally(buf);\n+\tif options.pretty {\n+\t\tlet mut parts: Vec<&ImportExportPart<U>> = parts.iter().collect();\n+\t\tparts.sort_unstable_by_key(|part| part.name.as_option_str().unwrap_or_default());\n+\t\tfor (at_end, part) in parts.iter().endiate() {\n+\t\t\tpart.to_string_from_buffer(buf, options, local);\n+\t\t\tif !at_end {\n+\t\t\t\tbuf.push(',');\n+\t\t\t\toptions.push_gap_optionally(buf);\n+\t\t\t}\n+\t\t}\n+\t} else {\n+\t\tfor (at_end, part) in parts.iter().endiate() {\n+\t\t\tpart.to_string_from_buffer(buf, options, local);\n+\t\t\tif !at_end {\n+\t\t\t\tbuf.push(',');\n+\t\t\t\toptions.push_gap_optionally(buf);\n+\t\t\t}\n+\t\t}\n+\t}\n+\toptions.push_gap_optionally(buf);\n+\tbuf.push('}');\n+}\n+\n+#[cfg(feature = \"self-rust-tokenize\")]\n+impl<U: ImportOrExport> self_rust_tokenize::SelfRustTokenize for ImportExportPart<U> {\n+\tfn append_to_token_stream(\n+\t\t&self,\n+\t\t_token_stream: &mut self_rust_tokenize::proc_macro2::TokenStream,\n+\t) {\n+\t\ttodo!(\"\")\n+\t}\n+}\n+\n+/// TODO `default` should have its own variant?\n+#[derive(Debug, Clone, PartialEq)]\n+#[apply(derive_ASTNode)]\n+pub enum ImportExportName {\n+\tReference(String),\n+\tQuoted(String, Quoted),\n+\t/// For typing here\n+\t#[cfg_attr(feature = \"self-rust-tokenize\", self_tokenize_field(0))]\n+\tMarker(\n+\t\t#[cfg_attr(target_family = \"wasm\", tsify(type = \"Marker<ImportExportName>\"))] Marker<Self>,\n+\t),\n+}\n+\n+impl ImportExportName {\n+\tpub(crate) fn from_reader(\n+\t\treader: &mut impl crate::TokenReader<TSXToken, crate::TokenStart>,\n+\t\tstate: &mut crate::ParsingState,\n+\t\toptions: &ParseOptions,\n+\t) -> crate::ParseResult<(Self, Span)> {\n+\t\tif let Some(Token(TSXToken::Comma, pos)) = reader.peek() {\n+\t\t\tlet marker = state.new_partial_point_marker(*pos);\n+\t\t\treturn Ok((ImportExportName::Marker(marker), pos.union(source_map::End(pos.0))));\n+\t\t}\n+\t\tlet token = reader.next().unwrap();\n+\t\tif let Token(TSXToken::StringLiteral(alias, quoted), start) = token {\n+\t\t\tlet with_length = start.with_length(alias.len() + 1);\n+\t\t\tstate.constant_imports.push(alias.clone());\n+\t\t\tOk((ImportExportName::Quoted(alias, quoted), with_length))\n+\t\t} else {\n+\t\t\tlet (ident, pos) = crate::tokens::token_as_identifier(token, \"import alias\")?;\n+\t\t\tif options.interpolation_points && ident == crate::marker::MARKER {\n+\t\t\t\tOk((ImportExportName::Marker(state.new_partial_point_marker(pos.get_start())), pos))\n+\t\t\t} else {\n+\t\t\t\tOk((ImportExportName::Reference(ident), pos))\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpub(crate) fn to_string_from_buffer<T: source_map::ToString>(\n+\t\t&self,\n+\t\tbuf: &mut T,\n+\t\t_options: &crate::ToStringOptions,\n+\t\t_local: crate::LocalToStringInformation,\n+\t) {\n+\t\tmatch self {\n+\t\t\tImportExportName::Reference(alias) => buf.push_str(alias),\n+\t\t\tImportExportName::Quoted(alias, q) => {\n+\t\t\t\tbuf.push(q.as_char());\n+\t\t\t\tbuf.push_str(alias);\n+\t\t\t\tbuf.push(q.as_char());\n+\t\t\t}\n+\t\t\tImportExportName::Marker(_) => {}\n+\t\t}\n+\t}\n+}\ndiff --git a/parser/src/errors.rs b/parser/src/errors.rs\n--- a/parser/src/errors.rs\n+++ b/parser/src/errors.rs\n@@ -34,6 +34,7 @@ pub enum ParseErrors<'a> {\n \tInvalidRegexFlag,\n \tExpectedDeclaration,\n \tCannotHaveRegularMemberAfterSpread,\n+\tInvalidLHSOfIs,\n }\n \n impl<'a> Display for ParseErrors<'a> {\ndiff --git a/parser/src/errors.rs b/parser/src/errors.rs\n--- a/parser/src/errors.rs\n+++ b/parser/src/errors.rs\n@@ -133,6 +134,9 @@ impl<'a> Display for ParseErrors<'a> {\n \t\t\tParseErrors::CannotHaveRegularMemberAfterSpread => {\n \t\t\t\twrite!(f, \"Cannot have regular member after spread\")\n \t\t\t}\n+\t\t\tParseErrors::InvalidLHSOfIs => {\n+\t\t\t\twrite!(f, \"LHS must be variable reference\")\n+\t\t\t}\n \t\t}\n \t}\n }\ndiff --git a/parser/src/errors.rs b/parser/src/errors.rs\n--- a/parser/src/errors.rs\n+++ b/parser/src/errors.rs\n@@ -145,7 +149,7 @@ pub enum LexingErrors {\n \tNumberLiteralBaseSpecifierMustPrecededWithZero,\n \tInvalidCharacterInJSXTag(char),\n \tUnbalancedJSXClosingTags,\n-\tExpectedClosingAngleAtEndOfSelfClosingTag,\n+\tExpectedClosingChevronAtEndOfSelfClosingTag,\n \tInvalidCharacterInAttributeKey(char),\n \tUnexpectedCharacter(derive_finite_automaton::InvalidCharacter),\n \tEmptyAttributeName,\ndiff --git a/parser/src/errors.rs b/parser/src/errors.rs\n--- a/parser/src/errors.rs\n+++ b/parser/src/errors.rs\n@@ -162,6 +166,7 @@ pub enum LexingErrors {\n \tInvalidUnderscore,\n \tCannotLoadLargeFile(usize),\n \tExpectedDashInComment,\n+\tExpectedOpenChevron,\n }\n \n impl Display for LexingErrors {\ndiff --git a/parser/src/errors.rs b/parser/src/errors.rs\n--- a/parser/src/errors.rs\n+++ b/parser/src/errors.rs\n@@ -179,7 +184,7 @@ impl Display for LexingErrors {\n \t\t\tLexingErrors::InvalidCharacterInJSXTag(chr) => {\n \t\t\t\twrite!(f, \"Invalid character {chr:?} in JSX tag\")\n \t\t\t}\n-\t\t\tLexingErrors::ExpectedClosingAngleAtEndOfSelfClosingTag => {\n+\t\t\tLexingErrors::ExpectedClosingChevronAtEndOfSelfClosingTag => {\n \t\t\t\tf.write_str(\"Expected closing angle at end of self closing JSX tag\")\n \t\t\t}\n \t\t\tLexingErrors::InvalidCharacterInAttributeKey(chr) => {\ndiff --git a/parser/src/errors.rs b/parser/src/errors.rs\n--- a/parser/src/errors.rs\n+++ b/parser/src/errors.rs\n@@ -211,6 +216,9 @@ impl Display for LexingErrors {\n \t\t\tLexingErrors::ExpectedDashInComment => {\n \t\t\t\tf.write_str(\"JSX comments must have two dashes after `<!` start\")\n \t\t\t}\n+\t\t\tLexingErrors::ExpectedOpenChevron => {\n+\t\t\t\tf.write_str(\"Unexpected token in HTML. Expected '<'\")\n+\t\t\t}\n \t\t}\n \t}\n }\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1,9 +1,9 @@\n use crate::{\n \tare_nodes_over_length, declarations::ClassDeclaration, derive_ASTNode,\n-\terrors::parse_lexing_error, functions, parse_bracketed, throw_unexpected_token_with_token,\n-\tto_string_bracketed, type_annotations::generic_arguments_from_reader_sub_open_angle,\n-\tExpressionPosition, FunctionHeader, ListItem, Marker, NumberRepresentation, ParseErrors,\n-\tParseResult, Quoted, TSXKeyword,\n+\terrors::parse_lexing_error, functions, number::NumberRepresentation, parse_bracketed,\n+\tthrow_unexpected_token_with_token, to_string_bracketed,\n+\ttype_annotations::generic_arguments_from_reader_sub_open_angle, ExpressionPosition,\n+\tFunctionHeader, ListItem, Marker, ParseErrors, ParseResult, Quoted, TSXKeyword,\n };\n \n use self::{\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -38,7 +38,7 @@ pub mod operators;\n pub mod template_literal;\n pub use arrow_function::{ArrowFunction, ExpressionOrBlock};\n \n-pub use template_literal::{TemplateLiteral, TemplateLiteralPart};\n+pub use template_literal::TemplateLiteral;\n \n use operators::{\n \tAssociativityDirection, BinaryAssignmentOperator, BinaryOperator, UnaryOperator,\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -243,9 +243,11 @@ impl Expression {\n \n \t\t\tif next_is_not_expression_like {\n \t\t\t\tlet point = start.unwrap_or(*at);\n+\t\t\t\t// take up the whole next part for checker suggestions\n+\t\t\t\tlet position = point.union(source_map::End(at.0));\n \t\t\t\treturn Ok(Expression::Marker {\n \t\t\t\t\tmarker_id: state.new_partial_point_marker(point),\n-\t\t\t\t\tposition: point.with_length(0),\n+\t\t\t\t\tposition,\n \t\t\t\t});\n \t\t\t}\n \t\t}\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -533,16 +535,18 @@ impl Expression {\n \t\t\t\t\tprefix: true,\n \t\t\t\t}\n \t\t\t}\n+\t\t\t// TODO not great\n+\t\t\tToken(TSXToken::DocTypeHTML, _) => {\n+\t\t\t\tJSXRoot::from_reader(reader, state, options).map(Expression::JSXRoot)?\n+\t\t\t}\n \t\t\tToken(tok @ (TSXToken::JSXOpeningTagStart | TSXToken::JSXFragmentStart), span) => {\n \t\t\t\tlet var_name = matches!(tok, TSXToken::JSXFragmentStart);\n-\t\t\t\tlet root = JSXRoot::from_reader_sub_start(reader, state, options, var_name, span)?;\n-\t\t\t\tExpression::JSXRoot(root)\n+\t\t\t\tJSXRoot::from_reader_sub_start(reader, state, options, var_name, span)\n+\t\t\t\t\t.map(Expression::JSXRoot)?\n \t\t\t}\n \t\t\tToken(TSXToken::TemplateLiteralStart, start) => {\n-\t\t\t\tlet template_literal = TemplateLiteral::from_reader_sub_start_with_tag(\n-\t\t\t\t\treader, state, options, None, start,\n-\t\t\t\t)?;\n-\t\t\t\tExpression::TemplateLiteral(template_literal)\n+\t\t\t\tTemplateLiteral::from_reader_sub_start_with_tag(reader, state, options, None, start)\n+\t\t\t\t\t.map(Expression::TemplateLiteral)?\n \t\t\t}\n \t\t\tToken(TSXToken::Keyword(kw), start) if function_header_ish(kw, reader) => {\n \t\t\t\t// TODO not great to recreate token, but that is how Rust works :)\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -565,14 +569,14 @@ impl Expression {\n \t\t\t\t\t}\n \n \t\t\t\t\tlet (name, position) = token_as_identifier(token, \"function parameter\")?;\n-\t\t\t\t\tlet function = ArrowFunction::from_reader_with_first_parameter(\n+\t\t\t\t\tArrowFunction::from_reader_with_first_parameter(\n \t\t\t\t\t\treader,\n \t\t\t\t\t\tstate,\n \t\t\t\t\t\toptions,\n \t\t\t\t\t\t(name, position),\n \t\t\t\t\t\tis_async,\n-\t\t\t\t\t)?;\n-\t\t\t\t\tExpression::ArrowFunction(function)\n+\t\t\t\t\t)\n+\t\t\t\t\t.map(Expression::ArrowFunction)?\n \t\t\t\t} else {\n \t\t\t\t\t#[cfg(feature = \"extras\")]\n \t\t\t\t\t{\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -963,7 +967,8 @@ impl Expression {\n \n \t\t\t\t\tlet (property, position) = if options.partial_syntax && is_next_not_identifier {\n \t\t\t\t\t\tlet marker = state.new_partial_point_marker(accessor_position);\n-\t\t\t\t\t\t(PropertyReference::Marker(marker), accessor_position.with_length(1))\n+\t\t\t\t\t\tlet position = accessor_position.union(source_map::End(at.0));\n+\t\t\t\t\t\t(PropertyReference::Marker(marker), position)\n \t\t\t\t\t} else {\n \t\t\t\t\t\tlet is_private =\n \t\t\t\t\t\t\treader.conditional_next(|t| matches!(t, TSXToken::HashTag)).is_some();\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1058,9 +1063,10 @@ impl Expression {\n \t\t\t\t\t\t\tvalue: top.into(),\n \t\t\t\t\t\t\trhs: match reference {\n \t\t\t\t\t\t\t\t// TODO temp :0\n-\t\t\t\t\t\t\t\tTypeAnnotation::Name(name, span) if name == \"const\" => {\n-\t\t\t\t\t\t\t\t\tTypeOrConst::Const(span)\n-\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tTypeAnnotation::Name(\n+\t\t\t\t\t\t\t\t\tcrate::type_annotations::TypeName::Name(name),\n+\t\t\t\t\t\t\t\t\tspan,\n+\t\t\t\t\t\t\t\t) if name == \"const\" => TypeOrConst::Const(span),\n \t\t\t\t\t\t\t\treference => TypeOrConst::Type(Box::new(reference)),\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t},\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1733,7 +1739,7 @@ impl Expression {\n \t\t\t\t}\n \t\t\t}\n \t\t\tSelf::Comment { content, on, is_multiline, prefix, position: _ } => {\n-\t\t\t\tif *prefix && options.should_add_comment(content.starts_with('*')) {\n+\t\t\t\tif *prefix && options.should_add_comment(content) {\n \t\t\t\t\tif *is_multiline {\n \t\t\t\t\t\tbuf.push_str(\"/*\");\n \t\t\t\t\t\tbuf.push_str_contains_new_line(content);\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1745,7 +1751,7 @@ impl Expression {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\ton.to_string_using_precedence(buf, options, local, local2);\n-\t\t\t\tif !prefix && options.should_add_comment(content.starts_with('*')) {\n+\t\t\t\tif !prefix && options.should_add_comment(content) {\n \t\t\t\t\tif *is_multiline {\n \t\t\t\t\t\tbuf.push_str(\"/*\");\n \t\t\t\t\t\tbuf.push_str_contains_new_line(content);\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1758,22 +1764,19 @@ impl Expression {\n \t\t\t\t}\n \t\t\t}\n \t\t\tSelf::TemplateLiteral(template_literal) => {\n+\t\t\t\t// Doing here because of tag precedence\n \t\t\t\tif let Some(tag) = &template_literal.tag {\n \t\t\t\t\ttag.to_string_using_precedence(buf, options, local, local2);\n \t\t\t\t}\n \t\t\t\tbuf.push('`');\n-\t\t\t\tfor part in &template_literal.parts {\n-\t\t\t\t\tmatch part {\n-\t\t\t\t\t\tTemplateLiteralPart::Static(content) => {\n-\t\t\t\t\t\t\tbuf.push_str_contains_new_line(content.as_str());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tTemplateLiteralPart::Dynamic(expression) => {\n-\t\t\t\t\t\t\tbuf.push_str(\"${\");\n-\t\t\t\t\t\t\texpression.to_string_from_buffer(buf, options, local);\n-\t\t\t\t\t\t\tbuf.push('}');\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\t\tfor (static_part, dynamic_part) in &template_literal.parts {\n+\t\t\t\t\tbuf.push_str_contains_new_line(static_part.as_str());\n+\n+\t\t\t\t\tbuf.push_str(\"${\");\n+\t\t\t\t\tdynamic_part.to_string_from_buffer(buf, options, local);\n+\t\t\t\t\tbuf.push('}');\n \t\t\t\t}\n+\t\t\t\tbuf.push_str_contains_new_line(template_literal.last.as_str());\n \t\t\t\tbuf.push('`');\n \t\t\t}\n \t\t\tSelf::ConditionalTernary { condition, truthy_result, falsy_result, .. } => {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -2216,8 +2219,8 @@ impl ASTNode for FunctionArgument {\n \t\t\tFunctionArgument::Standard(expression) => {\n \t\t\t\texpression.to_string_from_buffer(buf, options, local);\n \t\t\t}\n-\t\t\tFunctionArgument::Comment { content, is_multiline, position: _ } => {\n-\t\t\t\tif options.should_add_comment(*is_multiline && content.starts_with('*')) {\n+\t\t\tFunctionArgument::Comment { content, is_multiline: _is_multiline, position: _ } => {\n+\t\t\t\tif options.should_add_comment(content) {\n \t\t\t\t\tbuf.push_str(\"/*\");\n \t\t\t\t\tbuf.push_str(content);\n \t\t\t\t\tbuf.push_str(\"*/\");\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -293,15 +293,15 @@ impl ASTNode for ObjectLiteralMember {\n \t\t\t\tbuf.push_str(\"...\");\n \t\t\t\tspread_expr.to_string_from_buffer(buf, options, local);\n \t\t\t}\n-\t\t\tSelf::Comment(c, is_multiline, _) => {\n-\t\t\t\tif options.should_add_comment(c.starts_with('.')) {\n+\t\t\tSelf::Comment(content, is_multiline, _) => {\n+\t\t\t\tif options.should_add_comment(content) {\n \t\t\t\t\tif *is_multiline {\n \t\t\t\t\t\tbuf.push_str(\"/*\");\n-\t\t\t\t\t\tbuf.push_str(c);\n+\t\t\t\t\t\tbuf.push_str(content);\n \t\t\t\t\t\tbuf.push_str(\"*/\");\n \t\t\t\t\t} else {\n \t\t\t\t\t\tbuf.push_str(\"//\");\n-\t\t\t\t\t\tbuf.push_str(c);\n+\t\t\t\t\t\tbuf.push_str(content);\n \t\t\t\t\t\tbuf.push_new_line();\n \t\t\t\t\t}\n \t\t\t\t}\ndiff --git a/parser/src/expressions/operators.rs b/parser/src/expressions/operators.rs\n--- a/parser/src/expressions/operators.rs\n+++ b/parser/src/expressions/operators.rs\n@@ -26,7 +26,6 @@ pub enum BinaryOperator {\n     NullCoalescing, \n \n     /// Non standard\n-    Divides,\n     Pipe,\n     Compose\n }\ndiff --git a/parser/src/expressions/operators.rs b/parser/src/expressions/operators.rs\n--- a/parser/src/expressions/operators.rs\n+++ b/parser/src/expressions/operators.rs\n@@ -34,7 +33,7 @@ pub enum BinaryOperator {\n impl BinaryOperator {\n \t#[must_use]\n \tpub fn is_non_standard(&self) -> bool {\n-\t\tmatches!(self, BinaryOperator::Divides | BinaryOperator::Pipe | BinaryOperator::Compose)\n+\t\tmatches!(self, BinaryOperator::Pipe | BinaryOperator::Compose)\n \t}\n }\n \ndiff --git a/parser/src/expressions/operators.rs b/parser/src/expressions/operators.rs\n--- a/parser/src/expressions/operators.rs\n+++ b/parser/src/expressions/operators.rs\n@@ -141,7 +140,6 @@ impl Operator for BinaryOperator {\n \t\t\tBinaryOperator::BitwiseAnd => \"&\",\n \t\t\tBinaryOperator::BitwiseOr => \"|\",\n \t\t\tBinaryOperator::BitwiseXOr => \"^\",\n-\t\t\tBinaryOperator::Divides => \"/%\",  // \u2223\n \t\t\tBinaryOperator::Compose => \"<@>\", // \u2218\n \t\t\tBinaryOperator::Pipe => \"|>\",\n \t\t}\ndiff --git a/parser/src/expressions/operators.rs b/parser/src/expressions/operators.rs\n--- a/parser/src/expressions/operators.rs\n+++ b/parser/src/expressions/operators.rs\n@@ -151,10 +149,7 @@ impl Operator for BinaryOperator {\n \t\tmatch self {\n \t\t\tBinaryOperator::Pipe | BinaryOperator::Compose => 15,\n \t\t\tBinaryOperator::Exponent => 14,\n-\t\t\tBinaryOperator::Multiply\n-\t\t\t| BinaryOperator::Divide\n-\t\t\t| BinaryOperator::Modulo\n-\t\t\t| BinaryOperator::Divides => 13,\n+\t\t\tBinaryOperator::Multiply | BinaryOperator::Divide | BinaryOperator::Modulo => 13,\n \t\t\tBinaryOperator::Add | BinaryOperator::Subtract => 12,\n \t\t\tBinaryOperator::BitwiseShiftLeft\n \t\t\t| BinaryOperator::BitwiseShiftRightUnsigned\ndiff --git a/parser/src/expressions/operators.rs b/parser/src/expressions/operators.rs\n--- a/parser/src/expressions/operators.rs\n+++ b/parser/src/expressions/operators.rs\n@@ -395,8 +390,6 @@ impl TryFrom<&TSXToken> for BinaryOperator {\n \t\t\tTSXToken::BitwiseShiftRightUnsigned => Ok(BinaryOperator::BitwiseShiftRightUnsigned),\n \t\t\tTSXToken::NullishCoalescing => Ok(BinaryOperator::NullCoalescing),\n \t\t\t#[cfg(feature = \"extras\")]\n-\t\t\tTSXToken::DividesOperator => Ok(BinaryOperator::Divides),\n-\t\t\t#[cfg(feature = \"extras\")]\n \t\t\tTSXToken::ComposeOperator => Ok(BinaryOperator::Compose),\n \t\t\t#[cfg(feature = \"extras\")]\n \t\t\tTSXToken::PipeOperator => Ok(BinaryOperator::Pipe),\ndiff --git a/parser/src/expressions/template_literal.rs b/parser/src/expressions/template_literal.rs\n--- a/parser/src/expressions/template_literal.rs\n+++ b/parser/src/expressions/template_literal.rs\n@@ -1,6 +1,7 @@\n+use super::{Expression, MultipleExpression};\n use crate::{\n-\tderive_ASTNode, errors::parse_lexing_error, ASTNode, Expression, ParseOptions, ParseResult,\n-\tSpan, TSXToken, Token, TokenReader,\n+\tderive_ASTNode, errors::parse_lexing_error, ASTNode, ParseOptions, ParseResult, Span, TSXToken,\n+\tToken, TokenReader,\n };\n use tokenizer_lib::sized_tokens::TokenStart;\n use visitable_derive::Visitable;\ndiff --git a/parser/src/expressions/template_literal.rs b/parser/src/expressions/template_literal.rs\n--- a/parser/src/expressions/template_literal.rs\n+++ b/parser/src/expressions/template_literal.rs\n@@ -10,43 +11,11 @@ use visitable_derive::Visitable;\n #[get_field_by_type_target(Span)]\n pub struct TemplateLiteral {\n \tpub tag: Option<Box<Expression>>,\n-\tpub parts: Vec<TemplateLiteralPart<Expression>>,\n+\tpub parts: Vec<(String, MultipleExpression)>,\n+\tpub last: String,\n \tpub position: Span,\n }\n \n-#[apply(derive_ASTNode)]\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub enum TemplateLiteralPart<T: ASTNode> {\n-\tStatic(String),\n-\tDynamic(Box<T>),\n-}\n-\n-impl<T: ASTNode + crate::Visitable> crate::Visitable for TemplateLiteralPart<T> {\n-\tfn visit<TData>(\n-\t\t&self,\n-\t\tvisitors: &mut (impl crate::VisitorReceiver<TData> + ?Sized),\n-\t\tdata: &mut TData,\n-\t\toptions: &crate::VisitOptions,\n-\t\tchain: &mut temporary_annex::Annex<crate::Chain>,\n-\t) {\n-\t\tif let Self::Dynamic(dynamic) = self {\n-\t\t\tdynamic.visit(visitors, data, options, chain);\n-\t\t}\n-\t}\n-\n-\tfn visit_mut<TData>(\n-\t\t&mut self,\n-\t\tvisitors: &mut (impl crate::VisitorMutReceiver<TData> + ?Sized),\n-\t\tdata: &mut TData,\n-\t\toptions: &crate::VisitOptions,\n-\t\tchain: &mut temporary_annex::Annex<crate::Chain>,\n-\t) {\n-\t\tif let Self::Dynamic(dynamic) = self {\n-\t\t\tdynamic.visit_mut(visitors, data, options, chain);\n-\t\t}\n-\t}\n-}\n-\n impl ASTNode for TemplateLiteral {\n \tfn get_position(&self) -> Span {\n \t\tself.position\ndiff --git a/parser/src/expressions/template_literal.rs b/parser/src/expressions/template_literal.rs\n--- a/parser/src/expressions/template_literal.rs\n+++ b/parser/src/expressions/template_literal.rs\n@@ -71,18 +40,14 @@ impl ASTNode for TemplateLiteral {\n \t\t\ttag.to_string_from_buffer(buf, options, local);\n \t\t}\n \t\tbuf.push('`');\n-\t\tfor part in &self.parts {\n-\t\t\tmatch part {\n-\t\t\t\tTemplateLiteralPart::Static(content) => {\n-\t\t\t\t\tbuf.push_str_contains_new_line(content.as_str());\n-\t\t\t\t}\n-\t\t\t\tTemplateLiteralPart::Dynamic(expression) => {\n-\t\t\t\t\tbuf.push_str(\"${\");\n-\t\t\t\t\texpression.to_string_from_buffer(buf, options, local);\n-\t\t\t\t\tbuf.push('}');\n-\t\t\t\t}\n-\t\t\t}\n+\t\tfor (static_part, dynamic_part) in &self.parts {\n+\t\t\tbuf.push_str_contains_new_line(static_part.as_str());\n+\n+\t\t\tbuf.push_str(\"${\");\n+\t\t\tdynamic_part.to_string_from_buffer(buf, options, local);\n+\t\t\tbuf.push('}');\n \t\t}\n+\t\tbuf.push_str_contains_new_line(self.last.as_str());\n \t\tbuf.push('`');\n \t}\n }\ndiff --git a/parser/src/expressions/template_literal.rs b/parser/src/expressions/template_literal.rs\n--- a/parser/src/expressions/template_literal.rs\n+++ b/parser/src/expressions/template_literal.rs\n@@ -95,21 +60,22 @@ impl TemplateLiteral {\n \t\ttag: Option<Box<Expression>>,\n \t\tstart: TokenStart,\n \t) -> ParseResult<Self> {\n-\t\tlet mut parts = Vec::<TemplateLiteralPart<_>>::new();\n+\t\tlet mut parts = Vec::new();\n+\t\tlet mut last = String::new();\n \t\tloop {\n \t\t\tmatch reader.next().ok_or_else(parse_lexing_error)? {\n \t\t\t\tToken(TSXToken::TemplateLiteralChunk(chunk), _) => {\n-\t\t\t\t\tparts.push(TemplateLiteralPart::Static(chunk));\n+\t\t\t\t\tlast = chunk;\n \t\t\t\t}\n \t\t\t\tToken(TSXToken::TemplateLiteralExpressionStart, _) => {\n-\t\t\t\t\tlet expression = Expression::from_reader(reader, state, options)?;\n+\t\t\t\t\tlet expression = MultipleExpression::from_reader(reader, state, options)?;\n+\t\t\t\t\tparts.push((std::mem::take(&mut last), expression));\n \t\t\t\t\treader.expect_next(TSXToken::TemplateLiteralExpressionEnd)?;\n-\t\t\t\t\tparts.push(TemplateLiteralPart::Dynamic(Box::new(expression)));\n \t\t\t\t}\n-\t\t\t\tToken(TSXToken::EOS, _) => return Err(parse_lexing_error()),\n \t\t\t\tt @ Token(TSXToken::TemplateLiteralEnd, _) => {\n-\t\t\t\t\treturn Ok(Self { parts, tag, position: start.union(t.get_end()) });\n+\t\t\t\t\treturn Ok(Self { parts, last, tag, position: start.union(t.get_end()) });\n \t\t\t\t}\n+\t\t\t\tToken(TSXToken::EOS, _) => return Err(parse_lexing_error()),\n \t\t\t\tt => unreachable!(\"Token {:?}\", t),\n \t\t\t}\n \t\t}\ndiff --git a/parser/src/functions/mod.rs b/parser/src/functions/mod.rs\n--- a/parser/src/functions/mod.rs\n+++ b/parser/src/functions/mod.rs\n@@ -644,20 +644,22 @@ pub(crate) fn get_method_name<T: PropertyKeyKind + 'static>(\n \tstate: &mut crate::ParsingState,\n \toptions: &ParseOptions,\n ) -> Result<(MethodHeader, WithComment<PropertyKey<T>>), crate::ParseError> {\n-\tlet is_named_get_set_or_async = matches!(\n-\t\treader.peek(),\n-\t\tSome(Token(TSXToken::Keyword(TSXKeyword::Get | TSXKeyword::Set | TSXKeyword::Async), _))\n-\t) && matches!(\n-\t\treader.peek_n(1),\n-\t\tSome(Token(\n-\t\t\tTSXToken::OpenParentheses\n-\t\t\t\t| TSXToken::Colon\n-\t\t\t\t| TSXToken::OpenChevron\n-\t\t\t\t| TSXToken::CloseBrace\n-\t\t\t\t| TSXToken::Comma,\n-\t\t\t_\n-\t\t))\n-\t);\n+\tlet is_named_get_set_or_async =\n+\t\tmatches!(\n+\t\t\treader.peek(),\n+\t\t\tSome(Token(TSXToken::Keyword(kw), _))\n+\t\t\tif kw.is_in_method_header()\n+\t\t) && matches!(\n+\t\t\treader.peek_n(1),\n+\t\t\tSome(Token(\n+\t\t\t\tTSXToken::OpenParentheses\n+\t\t\t\t\t| TSXToken::Colon | TSXToken::OpenChevron\n+\t\t\t\t\t| TSXToken::CloseBrace\n+\t\t\t\t\t| TSXToken::Comma | TSXToken::QuestionMark\n+\t\t\t\t\t| TSXToken::OptionalMember,\n+\t\t\t\t_\n+\t\t\t))\n+\t\t);\n \n \tlet (function_header, key) = if is_named_get_set_or_async {\n \t\tlet token = reader.next().unwrap();\ndiff --git a/parser/src/functions/mod.rs b/parser/src/functions/mod.rs\n--- a/parser/src/functions/mod.rs\n+++ b/parser/src/functions/mod.rs\n@@ -666,6 +668,8 @@ pub(crate) fn get_method_name<T: PropertyKeyKind + 'static>(\n \t\t\tTSXToken::Keyword(TSXKeyword::Get) => \"get\",\n \t\t\tTSXToken::Keyword(TSXKeyword::Set) => \"set\",\n \t\t\tTSXToken::Keyword(TSXKeyword::Async) => \"async\",\n+\t\t\t#[cfg(feature = \"extras\")]\n+\t\t\tTSXToken::Keyword(TSXKeyword::Generator) => \"generator\",\n \t\t\t_ => unreachable!(),\n \t\t};\n \t\t// TODO\ndiff --git a/parser/src/generator_helpers.rs b/parser/src/generator_helpers.rs\n--- a/parser/src/generator_helpers.rs\n+++ b/parser/src/generator_helpers.rs\n@@ -13,6 +13,12 @@ impl<T: ASTNode> IntoAST<T> for T {\n \n pub struct Ident<'a>(&'a str);\n \n+impl<'a> From<&'a str> for Ident<'a> {\n+\tfn from(name: &'a str) -> Self {\n+\t\tSelf(name)\n+\t}\n+}\n+\n impl<'a> IntoAST<Expression> for Ident<'a> {\n \tfn into_ast(self) -> Expression {\n \t\tExpression::VariableReference(self.0.to_owned(), source_map::Nullable::NULL)\ndiff --git a/parser/src/generator_helpers.rs b/parser/src/generator_helpers.rs\n--- a/parser/src/generator_helpers.rs\n+++ b/parser/src/generator_helpers.rs\n@@ -45,7 +51,7 @@ impl<'a> IntoAST<VariableIdentifier> for &'a str {\n impl IntoAST<Expression> for usize {\n \tfn into_ast(self) -> Expression {\n \t\tExpression::NumberLiteral(\n-\t\t\tcrate::NumberRepresentation::from(self as f64),\n+\t\t\tcrate::number::NumberRepresentation::from(self as f64),\n \t\t\tsource_map::Nullable::NULL,\n \t\t)\n \t}\ndiff --git a/parser/src/generator_helpers.rs b/parser/src/generator_helpers.rs\n--- a/parser/src/generator_helpers.rs\n+++ b/parser/src/generator_helpers.rs\n@@ -54,7 +60,7 @@ impl IntoAST<Expression> for usize {\n impl IntoAST<Expression> for f64 {\n \tfn into_ast(self) -> Expression {\n \t\tExpression::NumberLiteral(\n-\t\t\tcrate::NumberRepresentation::from(self),\n+\t\t\tcrate::number::NumberRepresentation::from(self),\n \t\t\tsource_map::Nullable::NULL,\n \t\t)\n \t}\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -15,6 +15,9 @@ use derive_finite_automaton::{\n \tFiniteAutomata, FiniteAutomataConstructor, GetAutomataStateForValue, GetNextResult,\n };\n \n+mod html {}\n+\n+#[allow(clippy::struct_excessive_bools)]\n pub struct LexerOptions {\n \t/// Whether to append tokens when lexing. If false will just ignore\n \tpub comments: Comments,\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -23,6 +26,8 @@ pub struct LexerOptions {\n \tpub lex_jsx: bool,\n \t/// TODO temp\n \tpub allow_unsupported_characters_in_jsx_attribute_keys: bool,\n+\tpub allow_expressions_in_jsx: bool,\n+\tpub top_level_html: bool,\n }\n \n impl Default for LexerOptions {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -31,6 +36,8 @@ impl Default for LexerOptions {\n \t\t\tcomments: Comments::All,\n \t\t\tlex_jsx: true,\n \t\t\tallow_unsupported_characters_in_jsx_attribute_keys: true,\n+\t\t\tallow_expressions_in_jsx: true,\n+\t\t\ttop_level_html: false,\n \t\t}\n \t}\n }\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -80,6 +87,8 @@ pub fn lex_script(\n \n \t#[derive(PartialEq, Debug)]\n \tenum JSXLexingState {\n+\t\t/// Only for top level html\n+\t\tExpectingOpenChevron,\n \t\tTagName {\n \t\t\tdirection: JSXTagNameDirection,\n \t\t\tlexed_start: bool,\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -144,7 +153,7 @@ pub fn lex_script(\n \t\t\tno_inner_tags_or_expressions: bool,\n \t\t\tis_self_closing_tag: bool,\n \t\t},\n-\t\tComment,\n+\t\tSingleLineComment,\n \t\tMultiLineComment {\n \t\t\tlast_char_was_star: bool,\n \t\t},\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -157,11 +166,31 @@ pub fn lex_script(\n \t\t},\n \t}\n \n+\t// TODO WIP\n+\tconst DEFAULT_JSX_LEXING_STATE: LexingState = LexingState::JSXLiteral {\n+\t\tinterpolation_depth: 0,\n+\t\ttag_depth: 0,\n+\t\tstate: JSXLexingState::ExpectingOpenChevron,\n+\t\tno_inner_tags_or_expressions: false,\n+\t\tis_self_closing_tag: false,\n+\t};\n+\tconst FIRST_CHEVRON_JSX_LEXING_STATE: LexingState = LexingState::JSXLiteral {\n+\t\tinterpolation_depth: 0,\n+\t\ttag_depth: 0,\n+\t\tstate: JSXLexingState::TagName {\n+\t\t\tdirection: JSXTagNameDirection::Opening,\n+\t\t\tlexed_start: false,\n+\t\t},\n+\t\tno_inner_tags_or_expressions: false,\n+\t\tis_self_closing_tag: false,\n+\t};\n+\n \tif script.len() > u32::MAX as usize {\n \t\treturn Err((LexingErrors::CannotLoadLargeFile(script.len()), source_map::Nullable::NULL));\n \t}\n \n-\tlet mut state: LexingState = LexingState::None;\n+\tlet mut state: LexingState =\n+\t\tif options.top_level_html { DEFAULT_JSX_LEXING_STATE } else { LexingState::None };\n \n \t// Used to go back to previous state if was in template literal or JSX literal\n \tlet mut state_stack: Vec<LexingState> = Vec::new();\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -175,6 +204,7 @@ pub fn lex_script(\n \t// to discern whether it is regex or division at this point as regex literal needs to be parsed as a literal rather\n \t// than a sequence of tokens. Similarly for JSX is a < a less than comparison or the start of a tag. This variable\n \t// should be set to true if the last pushed token was `=`, `return` etc and set to else set to false.\n+\t// TODO this doesn't work see #165\n \tlet mut expect_expression = true;\n \n \tmacro_rules! return_err {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -192,7 +222,29 @@ pub fn lex_script(\n \t\t}};\n \t}\n \n-\tfor (idx, chr) in script.char_indices() {\n+\tlet mut characters = script.char_indices();\n+\tif script.starts_with(\"#!\") {\n+\t\tfor (idx, c) in characters.by_ref() {\n+\t\t\tif c == '\\n' {\n+\t\t\t\tsender.push(Token(\n+\t\t\t\t\tTSXToken::HashBangComment(script[2..idx].to_owned()),\n+\t\t\t\t\tTokenStart::new(0),\n+\t\t\t\t));\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif options.top_level_html && script.starts_with(\"<!DOCTYPE html>\") {\n+\t\tfor (_idx, c) in characters.by_ref() {\n+\t\t\tif c == '>' {\n+\t\t\t\tsender.push(Token(TSXToken::DocTypeHTML, TokenStart::new(0)));\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfor (idx, chr) in characters {\n \t\t// dbg!(chr, &state);\n \n \t\t// Sets current parser state and updates start track\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -365,7 +417,7 @@ pub fn lex_script(\n \t\t\t\t\t\t// Handle comments\n \t\t\t\t\t\tmatch result {\n \t\t\t\t\t\t\tTSXToken::Comment(_) => {\n-\t\t\t\t\t\t\t\tstate = LexingState::Comment;\n+\t\t\t\t\t\t\t\tstate = LexingState::SingleLineComment;\n \t\t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tTSXToken::MultiLineComment(_) => {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -433,12 +485,11 @@ pub fn lex_script(\n \t\t\t\t\t*escaped = false;\n \t\t\t\t}\n \t\t\t},\n-\t\t\tLexingState::Comment => {\n+\t\t\tLexingState::SingleLineComment => {\n \t\t\t\tif let '\\n' = chr {\n-\t\t\t\t\tif matches!(options.comments, Comments::All) {\n-\t\t\t\t\t\tpush_token!(TSXToken::Comment(\n-\t\t\t\t\t\t\tscript[(start + 2)..idx].trim_end().to_owned()\n-\t\t\t\t\t\t),);\n+\t\t\t\t\tlet content = &script[(start + 2)..idx];\n+\t\t\t\t\tif options.comments.should_add_comment(content) {\n+\t\t\t\t\t\tpush_token!(TSXToken::Comment(content.trim_end().to_owned()));\n \t\t\t\t\t}\n \t\t\t\t\tset_state!(LexingState::None);\n \t\t\t\t\tcontinue;\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -446,12 +497,9 @@ pub fn lex_script(\n \t\t\t}\n \t\t\tLexingState::MultiLineComment { ref mut last_char_was_star } => match chr {\n \t\t\t\t'/' if *last_char_was_star => {\n-\t\t\t\t\tlet comment = &script[(start + 2)..(idx - 1)];\n-\t\t\t\t\tlet include = matches!(options.comments, Comments::All)\n-\t\t\t\t\t\t|| (matches!(options.comments, Comments::JustDocumentation)\n-\t\t\t\t\t\t\t&& comment.starts_with('*'));\n-\t\t\t\t\tif include {\n-\t\t\t\t\t\tpush_token!(TSXToken::MultiLineComment(comment.to_owned()));\n+\t\t\t\t\tlet content = &script[(start + 2)..(idx - 1)];\n+\t\t\t\t\tif options.comments.should_add_comment(content) {\n+\t\t\t\t\t\tpush_token!(TSXToken::MultiLineComment(content.to_owned()));\n \t\t\t\t\t}\n \t\t\t\t\tset_state!(LexingState::None);\n \t\t\t\t\tcontinue;\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -475,7 +523,7 @@ pub fn lex_script(\n \t\t\t\t} else {\n \t\t\t\t\tmatch chr {\n \t\t\t\t\t\t'/' if start + 1 == idx => {\n-\t\t\t\t\t\t\tstate = LexingState::Comment;\n+\t\t\t\t\t\t\tstate = LexingState::SingleLineComment;\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n \t\t\t\t\t\t'*' if start + 1 == idx => {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -558,6 +606,14 @@ pub fn lex_script(\n \t\t\t\tstate: ref mut jsx_state,\n \t\t\t} => {\n \t\t\t\tmatch jsx_state {\n+\t\t\t\t\tJSXLexingState::ExpectingOpenChevron => {\n+\t\t\t\t\t\tif chr == '<' {\n+\t\t\t\t\t\t\tset_state!(FIRST_CHEVRON_JSX_LEXING_STATE);\n+\t\t\t\t\t\t} else if !chr.is_whitespace() {\n+\t\t\t\t\t\t\tdbg!(chr);\n+\t\t\t\t\t\t\treturn_err!(LexingErrors::ExpectedOpenChevron);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t\tJSXLexingState::TagName { ref mut direction, ref mut lexed_start } => match chr\n \t\t\t\t\t{\n \t\t\t\t\t\t// Closing tag\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -630,6 +686,8 @@ pub fn lex_script(\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tlet tag_name = script[start..idx].trim();\n \t\t\t\t\t\t\t*is_self_closing_tag = html_tag_is_self_closing(tag_name);\n+\t\t\t\t\t\t\t*no_inner_tags_or_expressions =\n+\t\t\t\t\t\t\t\thtml_tag_contains_literal_content(tag_name);\n \t\t\t\t\t\t\tpush_token!(TSXToken::JSXTagName(tag_name.to_owned()));\n \t\t\t\t\t\t\tstart = idx;\n \t\t\t\t\t\t\t*tag_depth += 1;\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -638,8 +696,6 @@ pub fn lex_script(\n \t\t\t\t\t\t\t\t\t*jsx_state = JSXLexingState::SelfClosingTagClose;\n \t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t'>' => {\n-\t\t\t\t\t\t\t\t\t*no_inner_tags_or_expressions =\n-\t\t\t\t\t\t\t\t\t\thtml_tag_contains_literal_content(&script[start..idx]);\n \t\t\t\t\t\t\t\t\tpush_token!(TSXToken::JSXOpeningTagEnd);\n \t\t\t\t\t\t\t\t\tstart = idx + 1;\n \t\t\t\t\t\t\t\t\t*jsx_state = if *no_inner_tags_or_expressions {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -679,7 +735,7 @@ pub fn lex_script(\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t}\n-\t\t\t\t\t\treturn_err!(LexingErrors::ExpectedClosingAngleAtEndOfSelfClosingTag);\n+\t\t\t\t\t\treturn_err!(LexingErrors::ExpectedClosingChevronAtEndOfSelfClosingTag);\n \t\t\t\t\t}\n \t\t\t\t\tJSXLexingState::AttributeKey => match chr {\n \t\t\t\t\t\t'=' => {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -690,6 +746,7 @@ pub fn lex_script(\n \t\t\t\t\t\t\tif !key_slice.is_empty() {\n \t\t\t\t\t\t\t\tpush_token!(TSXToken::JSXAttributeKey(key_slice.to_owned()));\n \t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tstart = idx;\n \t\t\t\t\t\t\tpush_token!(TSXToken::JSXAttributeAssign);\n \t\t\t\t\t\t\t*jsx_state = JSXLexingState::AttributeEqual;\n \t\t\t\t\t\t\tstart = idx + 1;\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -763,7 +820,7 @@ pub fn lex_script(\n \t\t\t\t\t},\n \t\t\t\t\tJSXLexingState::AttributeEqual => {\n \t\t\t\t\t\tlet delimiter = match chr {\n-\t\t\t\t\t\t\t'{' => {\n+\t\t\t\t\t\t\t'{' if options.allow_expressions_in_jsx => {\n \t\t\t\t\t\t\t\tpush_token!(TSXToken::JSXExpressionStart);\n \t\t\t\t\t\t\t\t*interpolation_depth += 1;\n \t\t\t\t\t\t\t\t*jsx_state = JSXLexingState::AttributeKey;\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -841,7 +898,7 @@ pub fn lex_script(\n \t\t\t\t\t\t\t\t};\n \t\t\t\t\t\t\t\tstart = idx;\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t'{' => {\n+\t\t\t\t\t\t\t'{' if options.allow_expressions_in_jsx => {\n \t\t\t\t\t\t\t\tlet content_slice = &script[start..idx];\n \t\t\t\t\t\t\t\tif !content_slice.trim().is_empty() {\n \t\t\t\t\t\t\t\t\tpush_token!(TSXToken::JSXContent(content_slice.to_owned()));\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -902,7 +959,11 @@ pub fn lex_script(\n \t\t\t\t\t\t\t));\n \t\t\t\t\t\t\tstart = idx + 1;\n \t\t\t\t\t\t\tif *tag_depth == 0 {\n-\t\t\t\t\t\t\t\tset_state!(LexingState::None);\n+\t\t\t\t\t\t\t\tset_state!(if options.top_level_html {\n+\t\t\t\t\t\t\t\t\tDEFAULT_JSX_LEXING_STATE\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tLexingState::None\n+\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\t*jsx_state = JSXLexingState::Content;\n \t\t\t\t\t\t\t}\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -991,16 +1052,7 @@ pub fn lex_script(\n \t\t\t\t\t\t\t};\n \t\t\t\t\t\t}\n \t\t\t\t\t\t(true, '<') if options.lex_jsx => {\n-\t\t\t\t\t\t\tset_state!(LexingState::JSXLiteral {\n-\t\t\t\t\t\t\t\tinterpolation_depth: 0,\n-\t\t\t\t\t\t\t\ttag_depth: 0,\n-\t\t\t\t\t\t\t\tstate: JSXLexingState::TagName {\n-\t\t\t\t\t\t\t\t\tdirection: JSXTagNameDirection::Opening,\n-\t\t\t\t\t\t\t\t\tlexed_start: false,\n-\t\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t\tno_inner_tags_or_expressions: false,\n-\t\t\t\t\t\t\t\tis_self_closing_tag: false,\n-\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t\tset_state!(FIRST_CHEVRON_JSX_LEXING_STATE);\n \t\t\t\t\t\t}\n \t\t\t\t\t\t(true, '/') => {\n \t\t\t\t\t\t\tstate = LexingState::RegexLiteral {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -1073,25 +1125,25 @@ pub fn lex_script(\n \t\t\t\t}\n \t\t\t\tGetNextResult::NewState(_new_state) => unreachable!(),\n \t\t\t\tGetNextResult::InvalidCharacter(err) => {\n-\t\t\t\t\tsender.push(Token(TSXToken::EOS, TokenStart::new(script.len() as u32)));\n \t\t\t\t\treturn_err!(LexingErrors::UnexpectedCharacter(err));\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tLexingState::Comment => {\n-\t\t\tsender.push(Token(\n-\t\t\t\tTSXToken::Comment(script[(start + 2)..].trim_end().to_owned()),\n-\t\t\t\tTokenStart::new(start as u32 + offset),\n-\t\t\t));\n-\t\t}\n-\t\tLexingState::String { .. } => {\n-\t\t\tsender.push(Token(TSXToken::EOS, TokenStart::new(script.len() as u32)));\n-\t\t\treturn_err!(LexingErrors::ExpectedEndToStringLiteral);\n+\t\tLexingState::SingleLineComment => {\n+\t\t\tlet content = &script[(start + 2)..];\n+\t\t\tif options.comments.should_add_comment(content) {\n+\t\t\t\tsender.push(Token(\n+\t\t\t\t\tTSXToken::Comment(content.trim_end().to_owned()),\n+\t\t\t\t\tTokenStart::new(start as u32 + offset),\n+\t\t\t\t));\n+\t\t\t}\n \t\t}\n \t\tLexingState::MultiLineComment { .. } => {\n-\t\t\tsender.push(Token(TSXToken::EOS, TokenStart::new(script.len() as u32)));\n \t\t\treturn_err!(LexingErrors::ExpectedEndToMultilineComment);\n \t\t}\n+\t\tLexingState::String { .. } => {\n+\t\t\treturn_err!(LexingErrors::ExpectedEndToStringLiteral);\n+\t\t}\n \t\t// This is okay as the state is not cleared until it finds flags.\n \t\tLexingState::RegexLiteral { after_last_slash, .. } => {\n \t\t\tif after_last_slash {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -1105,12 +1157,12 @@ pub fn lex_script(\n \t\t\t\treturn_err!(LexingErrors::ExpectedEndToRegexLiteral);\n \t\t\t}\n \t\t}\n-\t\tLexingState::JSXLiteral { .. } => {\n-\t\t\tsender.push(Token(TSXToken::EOS, TokenStart::new(script.len() as u32)));\n-\t\t\treturn_err!(LexingErrors::ExpectedEndToJSXLiteral);\n+\t\tLexingState::JSXLiteral { state, .. } => {\n+\t\t\tif !matches!(state, JSXLexingState::ExpectingOpenChevron) {\n+\t\t\t\treturn_err!(LexingErrors::ExpectedEndToJSXLiteral);\n+\t\t\t}\n \t\t}\n \t\tLexingState::TemplateLiteral { .. } => {\n-\t\t\tsender.push(Token(TSXToken::EOS, TokenStart::new(script.len() as u32)));\n \t\t\treturn_err!(LexingErrors::ExpectedEndToTemplateLiteral);\n \t\t}\n \t\tLexingState::None => {}\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -13,6 +13,8 @@ pub mod generator_helpers;\n mod lexer;\n pub mod marker;\n mod modules;\n+pub mod number;\n+pub mod options;\n pub mod property_key;\n pub mod statements;\n mod tokens;\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -38,6 +40,7 @@ pub use generator_helpers::IntoAST;\n use iterator_endiate::EndiateIteratorExt;\n pub use lexer::{lex_script, LexerOptions};\n pub use modules::Module;\n+pub use options::*;\n pub use property_key::PropertyKey;\n pub use source_map::{self, SourceId, Span};\n pub use statements::Statement;\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -58,8 +61,6 @@ use tokenizer_lib::{\n \n pub(crate) use tokenizer_lib::sized_tokens::TokenStart;\n \n-use std::{borrow::Cow, str::FromStr};\n-\n use crate::errors::parse_lexing_error;\n \n #[macro_use]\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -91,203 +92,6 @@ impl Quoted {\n \t}\n }\n \n-/// Options to customize parsing\n-#[allow(unused)]\n-#[derive(Copy, Clone)]\n-// TODO: Can be refactored with bit to reduce memory\n-#[allow(clippy::struct_excessive_bools)]\n-#[cfg_attr(feature = \"serde-serialize\", derive(serde::Deserialize), serde(default))]\n-#[cfg_attr(target_family = \"wasm\", derive(tsify::Tsify))]\n-pub struct ParseOptions {\n-\t/// Parsing of [JSX](https://facebook.github.io/jsx/) (includes some additions)\n-\tpub jsx: bool,\n-\t/// allow type annotations\n-\tpub type_annotations: bool,\n-\t/// just definition file\n-\tpub type_definition_module: bool,\n-\t/// Allow custom characters in JSX attributes\n-\tpub special_jsx_attributes: bool,\n-\t/// Parses decorators on items\n-\tpub decorators: bool,\n-\t/// Skip **all** comments from the AST\n-\tpub comments: Comments,\n-\t/// See [`crate::extensions::is_expression::IsExpression`]\n-\tpub is_expressions: bool,\n-\t/// Allows functions to be prefixed with 'server'\n-\tpub custom_function_headers: bool,\n-\t/// TODO temp for seeing how channel performs\n-\tpub buffer_size: usize,\n-\t/// Has no effect on WASM. Increase for deeply nested AST structures\n-\tpub stack_size: Option<usize>,\n-\t/// Useful for LSP information\n-\tpub record_keyword_positions: bool,\n-\t/// For the generator\n-\tpub interpolation_points: bool,\n-\t/// Extra\n-\tpub destructuring_type_annotation: bool,\n-\t/// Extra\n-\tpub extra_operators: bool,\n-\t/// For formatting\n-\tpub retain_blank_lines: bool,\n-\t/// For LSP\n-\tpub partial_syntax: bool,\n-}\n-\n-impl ParseOptions {\n-\tfn get_lex_options(&self) -> LexerOptions {\n-\t\tLexerOptions {\n-\t\t\tcomments: self.comments,\n-\t\t\tlex_jsx: self.jsx,\n-\t\t\tallow_unsupported_characters_in_jsx_attribute_keys: self.special_jsx_attributes,\n-\t\t}\n-\t}\n-\n-\t#[must_use]\n-\tpub fn all_features() -> Self {\n-\t\tSelf {\n-\t\t\tjsx: true,\n-\t\t\ttype_annotations: true,\n-\t\t\ttype_definition_module: false,\n-\t\t\tspecial_jsx_attributes: true,\n-\t\t\tcomments: Comments::All,\n-\t\t\tdecorators: true,\n-\t\t\tcustom_function_headers: true,\n-\t\t\tis_expressions: true,\n-\t\t\tbuffer_size: 100,\n-\t\t\tstack_size: None,\n-\t\t\trecord_keyword_positions: true,\n-\t\t\t// Only used in the AST-generator\n-\t\t\tinterpolation_points: false,\n-\t\t\tpartial_syntax: true,\n-\t\t\tdestructuring_type_annotation: true,\n-\t\t\textra_operators: true,\n-\t\t\tretain_blank_lines: true,\n-\t\t}\n-\t}\n-}\n-\n-// TODO unsure about some of these defaults, may change in future\n-impl Default for ParseOptions {\n-\tfn default() -> Self {\n-\t\tSelf {\n-\t\t\tjsx: true,\n-\t\t\ttype_annotations: true,\n-\t\t\ttype_definition_module: false,\n-\t\t\tspecial_jsx_attributes: false,\n-\t\t\tcomments: Comments::All,\n-\t\t\tdecorators: true,\n-\t\t\tcustom_function_headers: false,\n-\t\t\tis_expressions: false,\n-\t\t\tbuffer_size: 100,\n-\t\t\tstack_size: None,\n-\t\t\trecord_keyword_positions: false,\n-\t\t\tinterpolation_points: false,\n-\t\t\tpartial_syntax: false,\n-\t\t\tdestructuring_type_annotation: false,\n-\t\t\textra_operators: false,\n-\t\t\tretain_blank_lines: false,\n-\t\t}\n-\t}\n-}\n-\n-/// Settings for serializing `ASTNodes`\n-// TODO: Can be refactored with bit to reduce memory\n-#[allow(clippy::struct_excessive_bools)]\n-#[cfg_attr(feature = \"serde-serialize\", derive(serde::Deserialize), serde(default))]\n-#[cfg_attr(target_family = \"wasm\", derive(tsify::Tsify))]\n-pub struct ToStringOptions {\n-\t/// Does not include whitespace minification\n-\tpub pretty: bool,\n-\t/// Blocks have trailing semicolons. Has no effect if pretty == false\n-\tpub trailing_semicolon: bool,\n-\t/// Single statements get put on the same line as their parent statement\n-\tpub single_statement_on_new_line: bool,\n-\t/// Include type annotations (and additional TypeScript) syntax\n-\tpub include_type_annotations: bool,\n-\t/// TODO unsure about this\n-\tpub include_decorators: bool,\n-\tpub comments: Comments,\n-\tpub indent_with: String,\n-\t/// If false, panics if sees JSX\n-\tpub expect_jsx: bool,\n-\t/// For partial AST, marker nodes may exist. This allows pretty printing on invalid source\n-\t/// but should be `false` for builds\n-\t///\n-\t/// if `false` and a marker node is found, printing will panic\n-\tpub expect_markers: bool,\n-\t/// has no effect under !pretty\n-\tpub max_line_length: u8,\n-}\n-\n-impl Default for ToStringOptions {\n-\tfn default() -> Self {\n-\t\tToStringOptions {\n-\t\t\tpretty: true,\n-\t\t\tinclude_type_annotations: false,\n-\t\t\tsingle_statement_on_new_line: true,\n-\t\t\tinclude_decorators: false,\n-\t\t\tcomments: Comments::All,\n-\t\t\texpect_jsx: false,\n-\t\t\ttrailing_semicolon: false,\n-\t\t\texpect_markers: false,\n-\t\t\tindent_with: \"\\t\".to_owned(),\n-\t\t\tmax_line_length: u8::MAX,\n-\t\t}\n-\t}\n-}\n-\n-impl ToStringOptions {\n-\t#[must_use]\n-\tpub fn minified() -> Self {\n-\t\tToStringOptions {\n-\t\t\tpretty: false,\n-\t\t\tcomments: Comments::None,\n-\t\t\tindent_with: String::new(),\n-\t\t\t..Default::default()\n-\t\t}\n-\t}\n-\n-\t/// With TypeScript type syntax\n-\t#[must_use]\n-\tpub fn typescript() -> Self {\n-\t\tToStringOptions { include_type_annotations: true, ..Default::default() }\n-\t}\n-\n-\t/// Whether to include comment in source\n-\tpub(crate) fn should_add_comment(&self, is_document_comment: bool) -> bool {\n-\t\tmatches!(self.comments, Comments::All)\n-\t\t\t|| (matches!(self.comments, Comments::JustDocumentation) && is_document_comment)\n-\t}\n-\n-\tpub(crate) fn add_indent<T: source_map::ToString>(&self, indent: u8, buf: &mut T) {\n-\t\tif self.pretty {\n-\t\t\t(0..indent).for_each(|_| buf.push_str(&self.indent_with));\n-\t\t}\n-\t}\n-\n-\t/// Adds whitespace **conditionally** (based on pretty setting)\n-\tpub(crate) fn push_gap_optionally<T: source_map::ToString>(&self, buf: &mut T) {\n-\t\tif self.pretty {\n-\t\t\tbuf.push(' ');\n-\t\t}\n-\t}\n-\n-\tpub(crate) fn enforce_limit_length_limit(&self) -> bool {\n-\t\tself.pretty && self.max_line_length != u8::MAX\n-\t}\n-}\n-\n-#[derive(Debug, Default, Clone, Copy)]\n-#[cfg_attr(feature = \"serde-serialize\", derive(serde::Deserialize))]\n-#[cfg_attr(target_family = \"wasm\", derive(tsify::Tsify))]\n-pub enum Comments {\n-\t#[default]\n-\tAll,\n-\t/// Only multiline comments starting with `/**`\n-\tJustDocumentation,\n-\tNone,\n-}\n-\n #[derive(Debug, Clone, Copy)]\n pub struct LocalToStringInformation {\n \tunder: SourceId,\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -547,293 +351,6 @@ impl KeywordPositions {\n \t}\n }\n \n-#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]\n-#[apply(derive_ASTNode)]\n-pub enum NumberSign {\n-\t/// Also implies non negative/missing\n-\tPositive,\n-\tNegative,\n-}\n-\n-impl NumberSign {\n-\tpub fn apply<T: std::ops::Neg<Output = T>>(&self, x: T) -> T {\n-\t\tmatch self {\n-\t\t\tNumberSign::Positive => x,\n-\t\t\tNumberSign::Negative => -x,\n-\t\t}\n-\t}\n-}\n-\n-impl std::ops::Neg for NumberSign {\n-\ttype Output = Self;\n-\n-\tfn neg(self) -> Self::Output {\n-\t\tmatch self {\n-\t\t\tNumberSign::Positive => NumberSign::Negative,\n-\t\t\tNumberSign::Negative => NumberSign::Positive,\n-\t\t}\n-\t}\n-}\n-\n-impl std::fmt::Display for NumberSign {\n-\tfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-\t\tif matches!(self, Self::Negative) {\n-\t\t\tf.write_str(\"-\")\n-\t\t} else {\n-\t\t\tOk(())\n-\t\t}\n-\t}\n-}\n-\n-/// Some of these can't be parsed, but are there to make so that a number expression can be generated from a f64\n-///\n-/// <https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-literals-numeric-literals>\n-#[derive(Debug, Clone)]\n-#[apply(derive_ASTNode)]\n-pub enum NumberRepresentation {\n-\tInfinity,\n-\tNegativeInfinity,\n-\tNaN,\n-\tHex { sign: NumberSign, value: u64 },\n-\tBin { sign: NumberSign, value: u64 },\n-\tOctal { sign: NumberSign, value: u64 },\n-\tNumber(f64),\n-\tExponential { sign: NumberSign, value: f64, exponent: i32 },\n-\tBigInt(NumberSign, String),\n-}\n-\n-impl std::hash::Hash for NumberRepresentation {\n-\tfn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n-\t\tcore::mem::discriminant(self).hash(state);\n-\t}\n-}\n-\n-impl TryFrom<NumberRepresentation> for f64 {\n-\t// BigInt!!\n-\ttype Error = ();\n-\n-\tfn try_from(this: NumberRepresentation) -> Result<Self, Self::Error> {\n-\t\tmatch this {\n-\t\t\tNumberRepresentation::Infinity => Ok(f64::INFINITY),\n-\t\t\tNumberRepresentation::NegativeInfinity => Ok(f64::NEG_INFINITY),\n-\t\t\tNumberRepresentation::NaN => Ok(f64::NAN),\n-\t\t\tNumberRepresentation::Number(value) => Ok(value),\n-\t\t\tNumberRepresentation::Hex { sign, value, .. }\n-\t\t\t| NumberRepresentation::Bin { sign, value, .. }\n-\t\t\t| NumberRepresentation::Octal { sign, value, .. } => {\n-\t\t\t\t// TODO `value as f64` can lose information? If so should return f64::INFINITY\n-\t\t\t\tOk(sign.apply(value as f64))\n-\t\t\t}\n-\t\t\tNumberRepresentation::Exponential { sign, value, exponent } => {\n-\t\t\t\tOk(sign.apply(value * 10f64.powi(exponent)))\n-\t\t\t}\n-\t\t\tNumberRepresentation::BigInt(..) => Err(()),\n-\t\t}\n-\t}\n-}\n-\n-// For code generation\n-impl From<f64> for NumberRepresentation {\n-\tfn from(value: f64) -> Self {\n-\t\tif value == f64::INFINITY {\n-\t\t\tSelf::Infinity\n-\t\t} else if value == f64::NEG_INFINITY {\n-\t\t\tSelf::NegativeInfinity\n-\t\t} else if value.is_nan() {\n-\t\t\tSelf::NaN\n-\t\t} else {\n-\t\t\tSelf::Number(value)\n-\t\t}\n-\t}\n-}\n-\n-impl FromStr for NumberRepresentation {\n-\ttype Err = String;\n-\n-\tfn from_str(s: &str) -> Result<Self, Self::Err> {\n-\t\tif s == \"NaN\" {\n-\t\t\treturn Ok(Self::NaN);\n-\t\t}\n-\n-\t\tif s.contains('_') {\n-\t\t\treturn s.replace('_', \"\").parse();\n-\t\t}\n-\n-\t\tlet (sign, s) = if let Some(s) = s.strip_prefix('-') {\n-\t\t\t(NumberSign::Negative, s)\n-\t\t} else {\n-\t\t\t(NumberSign::Positive, s)\n-\t\t};\n-\n-\t\tlet s = if s.contains('_') { Cow::Owned(s.replace('_', \"\")) } else { Cow::Borrowed(s) };\n-\n-\t\tif let Some(s) = s.strip_suffix('n') {\n-\t\t\tOk(NumberRepresentation::BigInt(sign, s.to_owned()))\n-\t\t} else if let Some(s) = s.strip_prefix('0') {\n-\t\t\tlet next_char = s.chars().next();\n-\t\t\tmatch next_char {\n-\t\t\t\tSome('.') => {\n-\t\t\t\t\tif s.len() == 1 {\n-\t\t\t\t\t\tOk(Self::Number(0f64))\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tOk(Self::Number(sign.apply(s.parse().map_err(|_| s.to_owned())?)))\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tSome('X' | 'x') => {\n-\t\t\t\t\tlet mut value = 0u64;\n-\t\t\t\t\tfor c in s[1..].as_bytes() {\n-\t\t\t\t\t\tvalue <<= 4; // 16=2^4\n-\t\t\t\t\t\tmatch c {\n-\t\t\t\t\t\t\tb'0'..=b'9' => {\n-\t\t\t\t\t\t\t\tvalue += u64::from(c - b'0');\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tb'a'..=b'f' => {\n-\t\t\t\t\t\t\t\tvalue += u64::from(c - b'a') + 10;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tb'A'..=b'F' => {\n-\t\t\t\t\t\t\t\tvalue += u64::from(c - b'A') + 10;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t_ => return Err(s.to_owned()),\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tOk(Self::Hex { sign, value })\n-\t\t\t\t}\n-\t\t\t\tSome('B' | 'b') => {\n-\t\t\t\t\tlet mut value = 0u64;\n-\t\t\t\t\tfor c in s[1..].as_bytes() {\n-\t\t\t\t\t\tvalue <<= 1;\n-\t\t\t\t\t\tmatch c {\n-\t\t\t\t\t\t\tb'0' | b'1' => {\n-\t\t\t\t\t\t\t\tvalue += u64::from(c - b'0');\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t_ => return Err(s.to_owned()),\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tOk(Self::Bin { sign, value })\n-\t\t\t\t}\n-\t\t\t\tSome('e' | 'E') => {\n-\t\t\t\t\t// Lol\n-\t\t\t\t\tlet exponent: i32 = s[1..].parse().map_err(|_| s.to_owned())?;\n-\t\t\t\t\tOk(Self::Exponential { sign, value: 0f64, exponent })\n-\t\t\t\t}\n-\t\t\t\t// 'o' | 'O' but can also be missed\n-\t\t\t\tSome(c) => {\n-\t\t\t\t\tlet uses_character = matches!(c, 'o' | 'O');\n-\n-\t\t\t\t\tif !uses_character && s.contains(['8', '9', '.']) {\n-\t\t\t\t\t\treturn Ok(Self::Number(sign.apply(s.parse().map_err(|_| s.to_owned())?)));\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t// If it uses the the character then skip one, else skip zero\n-\t\t\t\t\tlet start: usize = uses_character.into();\n-\n-\t\t\t\t\tlet mut value = 0u64;\n-\t\t\t\t\tfor c in s[start..].as_bytes() {\n-\t\t\t\t\t\tvalue <<= 3; // 8=2^3\n-\t\t\t\t\t\tif matches!(c, b'0'..=b'7') {\n-\t\t\t\t\t\t\tvalue += u64::from(c - b'0');\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\treturn Err(s.to_owned());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tOk(Self::Octal { sign, value })\n-\t\t\t\t}\n-\t\t\t\tNone => Ok(Self::Number(0f64)),\n-\t\t\t}\n-\t\t} else if s.starts_with('.') {\n-\t\t\tlet value: f64 = format!(\"0{s}\").parse().map_err(|_| s.clone())?;\n-\t\t\tOk(Self::Number(sign.apply(value)))\n-\t\t} else if let Some(s) = s.strip_suffix('.') {\n-\t\t\tOk(Self::Number(sign.apply(s.parse::<f64>().map_err(|_| s)?)))\n-\t\t} else if let Some((left, right)) = s.split_once(['e', 'E']) {\n-\t\t\tlet value = left.parse::<f64>().map_err(|_| s.clone())?;\n-\t\t\tif let Ok(exponent) = right.parse::<i32>() {\n-\t\t\t\tOk(Self::Exponential { sign, value, exponent })\n-\t\t\t} else if right.starts_with('-') || value == 0f64 {\n-\t\t\t\t// lol\n-\t\t\t\tOk(Self::Number(0f64))\n-\t\t\t} else {\n-\t\t\t\tOk(Self::Infinity)\n-\t\t\t}\n-\t\t} else {\n-\t\t\tOk(Self::Number(sign.apply(s.parse::<f64>().map_err(|_| s.clone())?)))\n-\t\t}\n-\t}\n-}\n-\n-impl std::fmt::Display for NumberRepresentation {\n-\tfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-\t\twrite!(f, \"{}\", self.clone().as_js_string())\n-\t}\n-}\n-\n-// TODO not great\n-impl PartialEq for NumberRepresentation {\n-\tfn eq(&self, other: &Self) -> bool {\n-\t\tif let (Ok(a), Ok(b)) = (f64::try_from(self.clone()), f64::try_from(other.clone())) {\n-\t\t\ta == b\n-\t\t} else {\n-\t\t\t// TODO ...\n-\t\t\tfalse\n-\t\t}\n-\t}\n-}\n-\n-impl Eq for NumberRepresentation {}\n-\n-impl std::ops::Neg for NumberRepresentation {\n-\ttype Output = Self;\n-\n-\tfn neg(self) -> Self::Output {\n-\t\tmatch self {\n-\t\t\tNumberRepresentation::Infinity => NumberRepresentation::NegativeInfinity,\n-\t\t\tNumberRepresentation::NegativeInfinity => NumberRepresentation::Infinity,\n-\t\t\tNumberRepresentation::NaN => NumberRepresentation::NaN,\n-\t\t\tNumberRepresentation::Hex { sign, value } => {\n-\t\t\t\tNumberRepresentation::Hex { sign: sign.neg(), value }\n-\t\t\t}\n-\t\t\tNumberRepresentation::Bin { sign, value } => {\n-\t\t\t\tNumberRepresentation::Bin { sign: sign.neg(), value }\n-\t\t\t}\n-\t\t\tNumberRepresentation::Octal { sign, value } => {\n-\t\t\t\tNumberRepresentation::Octal { sign: sign.neg(), value }\n-\t\t\t}\n-\t\t\tNumberRepresentation::Number(n) => NumberRepresentation::Number(n.neg()),\n-\t\t\tNumberRepresentation::Exponential { sign, value, exponent } => {\n-\t\t\t\tNumberRepresentation::Exponential { sign: sign.neg(), value, exponent }\n-\t\t\t}\n-\t\t\tNumberRepresentation::BigInt(sign, value) => {\n-\t\t\t\tNumberRepresentation::BigInt(sign.neg(), value)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-impl NumberRepresentation {\n-\t#[must_use]\n-\tpub fn as_js_string(self) -> String {\n-\t\tmatch self {\n-\t\t\tNumberRepresentation::Infinity => \"Infinity\".to_owned(),\n-\t\t\tNumberRepresentation::NegativeInfinity => \"-Infinity\".to_owned(),\n-\t\t\tNumberRepresentation::NaN => \"NaN\".to_owned(),\n-\t\t\tNumberRepresentation::Hex { sign, value, .. } => {\n-\t\t\t\tformat!(\"{sign}0x{value:x}\")\n-\t\t\t}\n-\t\t\tNumberRepresentation::Bin { sign, value, .. } => {\n-\t\t\t\tformat!(\"{sign}0b{value:b}\")\n-\t\t\t}\n-\t\t\tNumberRepresentation::Octal { sign, value } => {\n-\t\t\t\tformat!(\"{sign}0o{value:o}\")\n-\t\t\t}\n-\t\t\tNumberRepresentation::Number(value) => value.to_string(),\n-\t\t\tNumberRepresentation::Exponential { sign, value, exponent } => {\n-\t\t\t\tformat!(\"{sign}{value}e{exponent}\")\n-\t\t\t}\n-\t\t\tNumberRepresentation::BigInt(s, value) => format!(\"{s}{value}n\"),\n-\t\t}\n-\t}\n-}\n-\n /// Classes and `function` functions have two variants depending whether in statement position\n /// or expression position\n pub trait ExpressionOrStatementPosition:\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -868,7 +385,7 @@ pub trait ExpressionOrStatementPosition:\n #[apply(derive_ASTNode)]\n pub struct StatementPosition {\n \tpub identifier: VariableIdentifier,\n-\tpub declare: bool,\n+\tpub is_declare: bool,\n }\n \n impl ExpressionOrStatementPosition for StatementPosition {\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -880,7 +397,7 @@ impl ExpressionOrStatementPosition for StatementPosition {\n \t\toptions: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tVariableIdentifier::from_reader(reader, state, options)\n-\t\t\t.map(|identifier| Self { identifier, declare: false })\n+\t\t\t.map(|identifier| Self { identifier, is_declare: false })\n \t}\n \n \tfn as_option_variable_identifier(&self) -> Option<&VariableIdentifier> {\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -896,7 +413,7 @@ impl ExpressionOrStatementPosition for StatementPosition {\n \t}\n \n \tfn is_declare(&self) -> bool {\n-\t\tself.declare\n+\t\tself.is_declare\n \t}\n }\n \ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -1123,7 +640,7 @@ pub(crate) fn expect_semi_colon(\n \treader: &mut impl TokenReader<TSXToken, crate::TokenStart>,\n \tline_starts: &source_map::LineStarts,\n \tstatement_end: u32,\n-\trecord_new_lines: bool,\n+\toptions: &ParseOptions,\n ) -> ParseResult<usize> {\n \tif let Some(token) = reader.peek() {\n \t\tlet Token(kind, start) = token;\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -1139,7 +656,7 @@ pub(crate) fn expect_semi_colon(\n \t\t} else if let TSXToken::SemiColon = kind {\n \t\t\tlet Token(_, semicolon_end) = reader.next().unwrap();\n \t\t\tlet Token(kind, next) = reader.peek().unwrap();\n-\t\t\tif record_new_lines {\n+\t\t\tif options.retain_blank_lines {\n \t\t\t\tlet byte_indexes_crosses_lines = line_starts\n \t\t\t\t\t.byte_indexes_crosses_lines(semicolon_end.0 as usize, next.0 as usize + 1);\n \ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -1156,7 +673,11 @@ pub(crate) fn expect_semi_colon(\n \t\t\tlet line_difference = line_starts\n \t\t\t\t.byte_indexes_crosses_lines(statement_end as usize, start.0 as usize + 1);\n \t\t\tif line_difference == 0 {\n-\t\t\t\tthrow_unexpected_token(reader, &[TSXToken::SemiColon])\n+\t\t\t\tif options.partial_syntax {\n+\t\t\t\t\tOk(0)\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow_unexpected_token(reader, &[TSXToken::SemiColon])\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tOk(line_difference - 1)\n \t\t\t}\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -1255,9 +776,10 @@ pub mod ast {\n \t\t\tFunctionBase, FunctionBody, FunctionHeader, FunctionParameters, MethodHeader,\n \t\t\tParameter, ParameterData, SpreadParameter,\n \t\t},\n+\t\tnumber::NumberRepresentation,\n \t\tstatements::*,\n-\t\tBlock, Decorated, ExpressionPosition, NumberRepresentation, PropertyKey,\n-\t\tStatementOrDeclaration, StatementPosition, VariableField, VariableIdentifier, WithComment,\n+\t\tBlock, Decorated, ExpressionPosition, PropertyKey, StatementOrDeclaration,\n+\t\tStatementPosition, VariableField, VariableIdentifier, WithComment,\n \t};\n \n \tpub use source_map::{BaseSpan, SourceId};\ndiff --git a/parser/src/marker.rs b/parser/src/marker.rs\n--- a/parser/src/marker.rs\n+++ b/parser/src/marker.rs\n@@ -1,6 +1,6 @@\n use std::marker::PhantomData;\n \n-/// Places in the AST which\n+/// Places in the AST which are either partial OR will recieve data from the generator\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub struct Marker<T>(pub u8, pub PhantomData<T>);\n \ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -9,6 +9,7 @@ use super::{ASTNode, Span, TSXToken, TokenReader};\n #[derive(Debug, Clone)]\n #[apply(derive_ASTNode)]\n pub struct Module {\n+\tpub hashbang_comment: Option<String>,\n \tpub items: Vec<StatementOrDeclaration>,\n \tpub span: Span,\n }\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -26,6 +27,11 @@ impl ASTNode for Module {\n \t\toptions: &crate::ToStringOptions,\n \t\tlocal: crate::LocalToStringInformation,\n \t) {\n+\t\tif let Some(ref hashbang_comment) = self.hashbang_comment {\n+\t\t\tbuf.push_str(\"#!\");\n+\t\t\tbuf.push_str(hashbang_comment);\n+\t\t\tbuf.push_new_line();\n+\t\t}\n \t\tstatements_and_declarations_to_string(&self.items, buf, options, local);\n \t}\n \ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -38,10 +44,22 @@ impl ASTNode for Module {\n \t\tstate: &mut crate::ParsingState,\n \t\toptions: &ParseOptions,\n \t) -> ParseResult<Self> {\n-\t\tlet end = state.length_of_source;\n-\t\tparse_statements_and_declarations(reader, state, options).map(|statements| Module {\n-\t\t\titems: statements,\n-\t\t\tspan: Span { start: 0, source: (), end },\n+\t\tlet span = Span { start: 0, source: (), end: state.length_of_source };\n+\t\tlet hashbang_comment = if let Some(crate::Token(TSXToken::HashBangComment(_), _)) =\n+\t\t\treader.peek()\n+\t\t{\n+\t\t\tlet Some(crate::Token(TSXToken::HashBangComment(hashbang_comment), _)) = reader.next()\n+\t\t\telse {\n+\t\t\t\tunreachable!()\n+\t\t\t};\n+\t\t\tSome(hashbang_comment)\n+\t\t} else {\n+\t\t\tNone\n+\t\t};\n+\t\tparse_statements_and_declarations(reader, state, options).map(|items| Module {\n+\t\t\thashbang_comment,\n+\t\t\titems,\n+\t\t\tspan,\n \t\t})\n \t}\n }\ndiff --git /dev/null b/parser/src/number.rs\nnew file mode 100644\n--- /dev/null\n+++ b/parser/src/number.rs\n@@ -0,0 +1,290 @@\n+use super::derive_ASTNode;\n+use std::{borrow::Cow, str::FromStr};\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash)]\n+#[apply(derive_ASTNode)]\n+pub enum NumberSign {\n+\t/// Also implies non negative/missing\n+\tPositive,\n+\tNegative,\n+}\n+\n+impl NumberSign {\n+\tpub fn apply<T: std::ops::Neg<Output = T>>(&self, x: T) -> T {\n+\t\tmatch self {\n+\t\t\tNumberSign::Positive => x,\n+\t\t\tNumberSign::Negative => -x,\n+\t\t}\n+\t}\n+}\n+\n+impl std::ops::Neg for NumberSign {\n+\ttype Output = Self;\n+\n+\tfn neg(self) -> Self::Output {\n+\t\tmatch self {\n+\t\t\tNumberSign::Positive => NumberSign::Negative,\n+\t\t\tNumberSign::Negative => NumberSign::Positive,\n+\t\t}\n+\t}\n+}\n+\n+impl std::fmt::Display for NumberSign {\n+\tfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+\t\tif matches!(self, Self::Negative) {\n+\t\t\tf.write_str(\"-\")\n+\t\t} else {\n+\t\t\tOk(())\n+\t\t}\n+\t}\n+}\n+\n+/// Some of these can't be parsed, but are there to make so that a number expression can be generated from a f64\n+///\n+/// <https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-literals-numeric-literals>\n+#[derive(Debug, Clone)]\n+#[apply(derive_ASTNode)]\n+pub enum NumberRepresentation {\n+\tInfinity,\n+\tNegativeInfinity,\n+\tNaN,\n+\tHex { sign: NumberSign, value: u64 },\n+\tBin { sign: NumberSign, value: u64 },\n+\tOctal { sign: NumberSign, value: u64 },\n+\tNumber(f64),\n+\tExponential { sign: NumberSign, value: f64, exponent: i32 },\n+\tBigInt(NumberSign, String),\n+}\n+\n+impl std::hash::Hash for NumberRepresentation {\n+\tfn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+\t\tcore::mem::discriminant(self).hash(state);\n+\t}\n+}\n+\n+impl TryFrom<NumberRepresentation> for f64 {\n+\t// BigInt!!\n+\ttype Error = ();\n+\n+\tfn try_from(this: NumberRepresentation) -> Result<Self, Self::Error> {\n+\t\tmatch this {\n+\t\t\tNumberRepresentation::Infinity => Ok(f64::INFINITY),\n+\t\t\tNumberRepresentation::NegativeInfinity => Ok(f64::NEG_INFINITY),\n+\t\t\tNumberRepresentation::NaN => Ok(f64::NAN),\n+\t\t\tNumberRepresentation::Number(value) => Ok(value),\n+\t\t\tNumberRepresentation::Hex { sign, value, .. }\n+\t\t\t| NumberRepresentation::Bin { sign, value, .. }\n+\t\t\t| NumberRepresentation::Octal { sign, value, .. } => {\n+\t\t\t\t// TODO `value as f64` can lose information? If so should return f64::INFINITY\n+\t\t\t\t#[allow(clippy::cast_precision_loss)]\n+\t\t\t\tOk(sign.apply(value as f64))\n+\t\t\t}\n+\t\t\tNumberRepresentation::Exponential { sign, value, exponent } => {\n+\t\t\t\tOk(sign.apply(value * 10f64.powi(exponent)))\n+\t\t\t}\n+\t\t\tNumberRepresentation::BigInt(..) => Err(()),\n+\t\t}\n+\t}\n+}\n+\n+// For code generation\n+impl From<f64> for NumberRepresentation {\n+\tfn from(value: f64) -> Self {\n+\t\tif value == f64::INFINITY {\n+\t\t\tSelf::Infinity\n+\t\t} else if value == f64::NEG_INFINITY {\n+\t\t\tSelf::NegativeInfinity\n+\t\t} else if value.is_nan() {\n+\t\t\tSelf::NaN\n+\t\t} else {\n+\t\t\tSelf::Number(value)\n+\t\t}\n+\t}\n+}\n+\n+impl FromStr for NumberRepresentation {\n+\ttype Err = String;\n+\n+\tfn from_str(s: &str) -> Result<Self, Self::Err> {\n+\t\tif s == \"NaN\" {\n+\t\t\treturn Ok(Self::NaN);\n+\t\t}\n+\n+\t\tif s.contains('_') {\n+\t\t\treturn s.replace('_', \"\").parse();\n+\t\t}\n+\n+\t\tlet (sign, s) = if let Some(s) = s.strip_prefix('-') {\n+\t\t\t(NumberSign::Negative, s)\n+\t\t} else {\n+\t\t\t(NumberSign::Positive, s)\n+\t\t};\n+\n+\t\tlet s = if s.contains('_') { Cow::Owned(s.replace('_', \"\")) } else { Cow::Borrowed(s) };\n+\n+\t\tif let Some(s) = s.strip_suffix('n') {\n+\t\t\tOk(NumberRepresentation::BigInt(sign, s.to_owned()))\n+\t\t} else if let Some(s) = s.strip_prefix('0') {\n+\t\t\tlet next_char = s.chars().next();\n+\t\t\tmatch next_char {\n+\t\t\t\tSome('.') => {\n+\t\t\t\t\tif s.len() == 1 {\n+\t\t\t\t\t\tOk(Self::Number(0f64))\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tOk(Self::Number(sign.apply(s.parse().map_err(|_| s.to_owned())?)))\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tSome('X' | 'x') => {\n+\t\t\t\t\tlet mut value = 0u64;\n+\t\t\t\t\tfor c in s[1..].as_bytes() {\n+\t\t\t\t\t\tvalue <<= 4; // 16=2^4\n+\t\t\t\t\t\tmatch c {\n+\t\t\t\t\t\t\tb'0'..=b'9' => {\n+\t\t\t\t\t\t\t\tvalue += u64::from(c - b'0');\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tb'a'..=b'f' => {\n+\t\t\t\t\t\t\t\tvalue += u64::from(c - b'a') + 10;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tb'A'..=b'F' => {\n+\t\t\t\t\t\t\t\tvalue += u64::from(c - b'A') + 10;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t_ => return Err(s.to_owned()),\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tOk(Self::Hex { sign, value })\n+\t\t\t\t}\n+\t\t\t\tSome('B' | 'b') => {\n+\t\t\t\t\tlet mut value = 0u64;\n+\t\t\t\t\tfor c in s[1..].as_bytes() {\n+\t\t\t\t\t\tvalue <<= 1;\n+\t\t\t\t\t\tmatch c {\n+\t\t\t\t\t\t\tb'0' | b'1' => {\n+\t\t\t\t\t\t\t\tvalue += u64::from(c - b'0');\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t_ => return Err(s.to_owned()),\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tOk(Self::Bin { sign, value })\n+\t\t\t\t}\n+\t\t\t\tSome('e' | 'E') => {\n+\t\t\t\t\t// Lol\n+\t\t\t\t\tlet exponent: i32 = s[1..].parse().map_err(|_| s.to_owned())?;\n+\t\t\t\t\tOk(Self::Exponential { sign, value: 0f64, exponent })\n+\t\t\t\t}\n+\t\t\t\t// 'o' | 'O' but can also be missed\n+\t\t\t\tSome(c) => {\n+\t\t\t\t\tlet uses_character = matches!(c, 'o' | 'O');\n+\n+\t\t\t\t\tif !uses_character && s.contains(['8', '9', '.']) {\n+\t\t\t\t\t\treturn Ok(Self::Number(sign.apply(s.parse().map_err(|_| s.to_owned())?)));\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// If it uses the the character then skip one, else skip zero\n+\t\t\t\t\tlet start: usize = uses_character.into();\n+\n+\t\t\t\t\tlet mut value = 0u64;\n+\t\t\t\t\tfor c in s[start..].as_bytes() {\n+\t\t\t\t\t\tvalue <<= 3; // 8=2^3\n+\t\t\t\t\t\tif matches!(c, b'0'..=b'7') {\n+\t\t\t\t\t\t\tvalue += u64::from(c - b'0');\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\treturn Err(s.to_owned());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tOk(Self::Octal { sign, value })\n+\t\t\t\t}\n+\t\t\t\tNone => Ok(Self::Number(0f64)),\n+\t\t\t}\n+\t\t} else if s.starts_with('.') {\n+\t\t\tlet value: f64 = format!(\"0{s}\").parse().map_err(|_| s.clone())?;\n+\t\t\tOk(Self::Number(sign.apply(value)))\n+\t\t} else if let Some(s) = s.strip_suffix('.') {\n+\t\t\tOk(Self::Number(sign.apply(s.parse::<f64>().map_err(|_| s)?)))\n+\t\t} else if let Some((left, right)) = s.split_once(['e', 'E']) {\n+\t\t\tlet value = left.parse::<f64>().map_err(|_| s.clone())?;\n+\t\t\tif let Ok(exponent) = right.parse::<i32>() {\n+\t\t\t\tOk(Self::Exponential { sign, value, exponent })\n+\t\t\t} else if right.starts_with('-') || value == 0f64 {\n+\t\t\t\t// lol\n+\t\t\t\tOk(Self::Number(0f64))\n+\t\t\t} else {\n+\t\t\t\tOk(Self::Infinity)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tOk(Self::Number(sign.apply(s.parse::<f64>().map_err(|_| s.clone())?)))\n+\t\t}\n+\t}\n+}\n+\n+impl std::fmt::Display for NumberRepresentation {\n+\tfn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+\t\twrite!(f, \"{}\", self.clone().as_js_string())\n+\t}\n+}\n+\n+// TODO not great\n+impl PartialEq for NumberRepresentation {\n+\tfn eq(&self, other: &Self) -> bool {\n+\t\tif let (Ok(a), Ok(b)) = (f64::try_from(self.clone()), f64::try_from(other.clone())) {\n+\t\t\ta == b\n+\t\t} else {\n+\t\t\t// TODO ...\n+\t\t\tfalse\n+\t\t}\n+\t}\n+}\n+\n+impl Eq for NumberRepresentation {}\n+\n+impl std::ops::Neg for NumberRepresentation {\n+\ttype Output = Self;\n+\n+\tfn neg(self) -> Self::Output {\n+\t\tmatch self {\n+\t\t\tNumberRepresentation::Infinity => NumberRepresentation::NegativeInfinity,\n+\t\t\tNumberRepresentation::NegativeInfinity => NumberRepresentation::Infinity,\n+\t\t\tNumberRepresentation::NaN => NumberRepresentation::NaN,\n+\t\t\tNumberRepresentation::Hex { sign, value } => {\n+\t\t\t\tNumberRepresentation::Hex { sign: sign.neg(), value }\n+\t\t\t}\n+\t\t\tNumberRepresentation::Bin { sign, value } => {\n+\t\t\t\tNumberRepresentation::Bin { sign: sign.neg(), value }\n+\t\t\t}\n+\t\t\tNumberRepresentation::Octal { sign, value } => {\n+\t\t\t\tNumberRepresentation::Octal { sign: sign.neg(), value }\n+\t\t\t}\n+\t\t\tNumberRepresentation::Number(n) => NumberRepresentation::Number(n.neg()),\n+\t\t\tNumberRepresentation::Exponential { sign, value, exponent } => {\n+\t\t\t\tNumberRepresentation::Exponential { sign: sign.neg(), value, exponent }\n+\t\t\t}\n+\t\t\tNumberRepresentation::BigInt(sign, value) => {\n+\t\t\t\tNumberRepresentation::BigInt(sign.neg(), value)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+impl NumberRepresentation {\n+\t#[must_use]\n+\tpub fn as_js_string(self) -> String {\n+\t\tmatch self {\n+\t\t\tNumberRepresentation::Infinity => \"Infinity\".to_owned(),\n+\t\t\tNumberRepresentation::NegativeInfinity => \"-Infinity\".to_owned(),\n+\t\t\tNumberRepresentation::NaN => \"NaN\".to_owned(),\n+\t\t\tNumberRepresentation::Hex { sign, value, .. } => {\n+\t\t\t\tformat!(\"{sign}0x{value:x}\")\n+\t\t\t}\n+\t\t\tNumberRepresentation::Bin { sign, value, .. } => {\n+\t\t\t\tformat!(\"{sign}0b{value:b}\")\n+\t\t\t}\n+\t\t\tNumberRepresentation::Octal { sign, value } => {\n+\t\t\t\tformat!(\"{sign}0o{value:o}\")\n+\t\t\t}\n+\t\t\tNumberRepresentation::Number(value) => value.to_string(),\n+\t\t\tNumberRepresentation::Exponential { sign, value, exponent } => {\n+\t\t\t\tformat!(\"{sign}{value}e{exponent}\")\n+\t\t\t}\n+\t\t\tNumberRepresentation::BigInt(s, value) => format!(\"{s}{value}n\"),\n+\t\t}\n+\t}\n+}\ndiff --git /dev/null b/parser/src/options.rs\nnew file mode 100644\n--- /dev/null\n+++ b/parser/src/options.rs\n@@ -0,0 +1,216 @@\n+use super::lexer::LexerOptions;\n+\n+/// Options to customize parsing\n+#[allow(unused)]\n+#[derive(Copy, Clone)]\n+// TODO: Can be refactored with bit to reduce memory\n+#[allow(clippy::struct_excessive_bools)]\n+#[cfg_attr(feature = \"serde-serialize\", derive(serde::Deserialize), serde(default))]\n+#[cfg_attr(target_family = \"wasm\", derive(tsify::Tsify))]\n+pub struct ParseOptions {\n+\t/// Parsing of [JSX](https://facebook.github.io/jsx/) (includes some additions)\n+\tpub jsx: bool,\n+\t/// allow type annotations\n+\tpub type_annotations: bool,\n+\t/// just definition file\n+\tpub type_definition_module: bool,\n+\t/// Allow custom characters in JSX attributes\n+\tpub special_jsx_attributes: bool,\n+\t/// Parses decorators on items\n+\tpub decorators: bool,\n+\t/// Skip **all** comments from the AST\n+\tpub comments: Comments,\n+\t/// See [`crate::extensions::is_expression::IsExpression`]\n+\tpub is_expressions: bool,\n+\t/// Allows functions to be prefixed with 'server'\n+\tpub custom_function_headers: bool,\n+\t/// TODO temp for seeing how channel performs\n+\tpub buffer_size: usize,\n+\t/// Has no effect on WASM. Increase for deeply nested AST structures\n+\tpub stack_size: Option<usize>,\n+\t/// Useful for LSP information\n+\tpub record_keyword_positions: bool,\n+\t/// For the generator\n+\tpub interpolation_points: bool,\n+\t/// Extra\n+\tpub destructuring_type_annotation: bool,\n+\t/// Extra\n+\tpub extra_operators: bool,\n+\t/// For formatting\n+\tpub retain_blank_lines: bool,\n+\t/// For LSP\n+\tpub partial_syntax: bool,\n+\t/// JSX with modifications equiv\n+\tpub top_level_html: bool,\n+}\n+\n+impl ParseOptions {\n+\tpub(crate) fn get_lex_options(&self) -> LexerOptions {\n+\t\tLexerOptions {\n+\t\t\tcomments: self.comments,\n+\t\t\tlex_jsx: self.jsx,\n+\t\t\tallow_unsupported_characters_in_jsx_attribute_keys: self.special_jsx_attributes,\n+\t\t\tallow_expressions_in_jsx: !self.top_level_html,\n+\t\t\ttop_level_html: self.top_level_html,\n+\t\t}\n+\t}\n+\n+\t#[must_use]\n+\tpub fn all_features() -> Self {\n+\t\tSelf {\n+\t\t\tjsx: true,\n+\t\t\ttype_annotations: true,\n+\t\t\ttype_definition_module: false,\n+\t\t\tspecial_jsx_attributes: true,\n+\t\t\tcomments: Comments::All,\n+\t\t\tdecorators: true,\n+\t\t\tcustom_function_headers: true,\n+\t\t\tis_expressions: true,\n+\t\t\tbuffer_size: 100,\n+\t\t\tstack_size: None,\n+\t\t\trecord_keyword_positions: true,\n+\t\t\t// Only used in the AST-generator\n+\t\t\tinterpolation_points: false,\n+\t\t\tpartial_syntax: true,\n+\t\t\tdestructuring_type_annotation: true,\n+\t\t\textra_operators: true,\n+\t\t\tretain_blank_lines: true,\n+\t\t\ttop_level_html: false,\n+\t\t}\n+\t}\n+}\n+\n+// TODO unsure about some of these defaults, may change in future\n+impl Default for ParseOptions {\n+\tfn default() -> Self {\n+\t\tSelf {\n+\t\t\tjsx: true,\n+\t\t\ttype_annotations: true,\n+\t\t\ttype_definition_module: false,\n+\t\t\tspecial_jsx_attributes: false,\n+\t\t\tcomments: Comments::All,\n+\t\t\tdecorators: true,\n+\t\t\tcustom_function_headers: false,\n+\t\t\tis_expressions: false,\n+\t\t\tbuffer_size: 100,\n+\t\t\tstack_size: None,\n+\t\t\trecord_keyword_positions: false,\n+\t\t\tinterpolation_points: false,\n+\t\t\tpartial_syntax: false,\n+\t\t\tdestructuring_type_annotation: false,\n+\t\t\textra_operators: false,\n+\t\t\tretain_blank_lines: false,\n+\t\t\ttop_level_html: false,\n+\t\t}\n+\t}\n+}\n+\n+/// Settings for serializing `ASTNodes`\n+// TODO: Can be refactored with bit to reduce memory\n+#[allow(clippy::struct_excessive_bools)]\n+#[cfg_attr(feature = \"serde-serialize\", derive(serde::Deserialize), serde(default))]\n+#[cfg_attr(target_family = \"wasm\", derive(tsify::Tsify))]\n+pub struct ToStringOptions {\n+\t/// Does not include whitespace minification\n+\tpub pretty: bool,\n+\t/// Blocks have trailing semicolons. Has no effect if pretty == false\n+\tpub trailing_semicolon: bool,\n+\t/// Single statements get put on the same line as their parent statement\n+\tpub single_statement_on_new_line: bool,\n+\t/// Include type annotations (and additional TypeScript) syntax\n+\tpub include_type_annotations: bool,\n+\t/// TODO unsure about this\n+\tpub include_decorators: bool,\n+\tpub comments: Comments,\n+\tpub indent_with: String,\n+\t/// If false, panics if sees JSX\n+\tpub expect_jsx: bool,\n+\t/// For partial AST, marker nodes may exist. This allows pretty printing on invalid source\n+\t/// but should be `false` for builds\n+\t///\n+\t/// if `false` and a marker node is found, printing will panic\n+\tpub expect_markers: bool,\n+\t/// has no effect under !pretty\n+\tpub max_line_length: u8,\n+}\n+\n+impl Default for ToStringOptions {\n+\tfn default() -> Self {\n+\t\tToStringOptions {\n+\t\t\tpretty: true,\n+\t\t\tinclude_type_annotations: false,\n+\t\t\tsingle_statement_on_new_line: true,\n+\t\t\tinclude_decorators: false,\n+\t\t\tcomments: Comments::All,\n+\t\t\texpect_jsx: false,\n+\t\t\ttrailing_semicolon: false,\n+\t\t\texpect_markers: false,\n+\t\t\tindent_with: \"\\t\".to_owned(),\n+\t\t\tmax_line_length: u8::MAX,\n+\t\t}\n+\t}\n+}\n+\n+impl ToStringOptions {\n+\t#[must_use]\n+\tpub fn minified() -> Self {\n+\t\tToStringOptions {\n+\t\t\tpretty: false,\n+\t\t\tcomments: Comments::None,\n+\t\t\tindent_with: String::new(),\n+\t\t\t..Default::default()\n+\t\t}\n+\t}\n+\n+\t/// With TypeScript type syntax\n+\t#[must_use]\n+\tpub fn typescript() -> Self {\n+\t\tToStringOptions { include_type_annotations: true, ..Default::default() }\n+\t}\n+\n+\t/// Whether to include comment in source\n+\tpub(crate) fn should_add_comment(&self, content: &str) -> bool {\n+\t\tself.comments.should_add_comment(content)\n+\t}\n+\n+\tpub(crate) fn add_indent<T: source_map::ToString>(&self, indent: u8, buf: &mut T) {\n+\t\tif self.pretty {\n+\t\t\t(0..indent).for_each(|_| buf.push_str(&self.indent_with));\n+\t\t}\n+\t}\n+\n+\t/// Adds whitespace **conditionally** (based on pretty setting)\n+\tpub(crate) fn push_gap_optionally<T: source_map::ToString>(&self, buf: &mut T) {\n+\t\tif self.pretty {\n+\t\t\tbuf.push(' ');\n+\t\t}\n+\t}\n+\n+\tpub(crate) fn enforce_limit_length_limit(&self) -> bool {\n+\t\tself.pretty && self.max_line_length != u8::MAX\n+\t}\n+}\n+\n+#[derive(Debug, Default, Clone, Copy)]\n+#[cfg_attr(feature = \"serde-serialize\", derive(serde::Deserialize))]\n+#[cfg_attr(target_family = \"wasm\", derive(tsify::Tsify))]\n+pub enum Comments {\n+\t#[default]\n+\tAll,\n+\t/// Only multiline comments starting with `/**`\n+\tJustDocumentation,\n+\tNone,\n+}\n+\n+impl Comments {\n+\t/// Whether to include comment in source\n+\tpub(crate) fn should_add_comment(self, content: &str) -> bool {\n+\t\tmatch self {\n+\t\t\tComments::All => true,\n+\t\t\tComments::None => false,\n+\t\t\tComments::JustDocumentation => {\n+\t\t\t\tcontent.starts_with('*') || content.trim_start().starts_with('@')\n+\t\t\t}\n+\t\t}\n+\t}\n+}\ndiff --git a/parser/src/property_key.rs b/parser/src/property_key.rs\n--- a/parser/src/property_key.rs\n+++ b/parser/src/property_key.rs\n@@ -10,8 +10,8 @@ use temporary_annex::Annex;\n use tokenizer_lib::{sized_tokens::TokenReaderWithTokenEnds, Token, TokenReader};\n \n use crate::{\n-\terrors::parse_lexing_error, tokens::token_as_identifier, ASTNode, Expression,\n-\tNumberRepresentation, ParseOptions, ParseResult,\n+\terrors::parse_lexing_error, number::NumberRepresentation, tokens::token_as_identifier, ASTNode,\n+\tExpression, ParseOptions, ParseResult,\n };\n \n pub trait PropertyKeyKind: Debug + PartialEq + Eq + Clone + Sized + Send + Sync + 'static {\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -99,8 +99,7 @@ impl ASTNode for Statement {\n \t\t\t\t\treader,\n \t\t\t\t\t&state.line_starts,\n \t\t\t\t\tstatement.get_position().start,\n-\t\t\t\t\t// TODO\n-\t\t\t\t\tfalse,\n+\t\t\t\t\toptions,\n \t\t\t\t)?;\n \t\t\t}\n \t\t\t// TODO statement.can_be_labelled()\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -237,13 +236,13 @@ impl ASTNode for Statement {\n \t\t\tStatement::DoWhileLoop(dws) => dws.to_string_from_buffer(buf, options, local),\n \t\t\tStatement::TryCatch(tcs) => tcs.to_string_from_buffer(buf, options, local),\n \t\t\tStatement::Comment(comment, _) => {\n-\t\t\t\tif options.should_add_comment(false) {\n+\t\t\t\tif options.should_add_comment(comment.as_str()) {\n \t\t\t\t\tbuf.push_str(\"//\");\n \t\t\t\t\tbuf.push_str_contains_new_line(comment.as_str().trim_end());\n \t\t\t\t}\n \t\t\t}\n \t\t\tStatement::MultiLineComment(comment, _) => {\n-\t\t\t\tif options.should_add_comment(comment.starts_with('*')) {\n+\t\t\t\tif options.should_add_comment(comment) {\n \t\t\t\t\tbuf.push_str(\"/*\");\n \t\t\t\t\tif options.pretty {\n \t\t\t\t\t\t// Perform indent correction\ndiff --git a/parser/src/statements/switch_statement.rs b/parser/src/statements/switch_statement.rs\n--- a/parser/src/statements/switch_statement.rs\n+++ b/parser/src/statements/switch_statement.rs\n@@ -92,7 +92,7 @@ impl ASTNode for SwitchStatement {\n \t\t\t\t\t\treader,\n \t\t\t\t\t\t&state.line_starts,\n \t\t\t\t\t\tvalue.get_position().end,\n-\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\toptions,\n \t\t\t\t\t)?;\n \t\t\t\t}\n \t\t\t\t// Could skip over semi colons regardless. But they are technically empty statements \ud83e\udd37\u200d\u2642\ufe0f\ndiff --git a/parser/src/tokens.rs b/parser/src/tokens.rs\n--- a/parser/src/tokens.rs\n+++ b/parser/src/tokens.rs\n@@ -83,7 +83,6 @@ use crate::{ParseError, Quoted};\n )]\n #[cfg_attr(feature = \"extras\", automaton_mappings(\n     \">!\" => TSXToken::InvertAssign,\n-    \"/%\" => TSXToken::DividesOperator,\n     \"<@>\" => TSXToken::ComposeOperator,\n     \"|>\" => TSXToken::PipeOperator,\n ))]\ndiff --git a/parser/src/tokens.rs b/parser/src/tokens.rs\n--- a/parser/src/tokens.rs\n+++ b/parser/src/tokens.rs\n@@ -94,6 +93,8 @@ pub enum TSXToken {\n     NumberLiteral(String),\n     StringLiteral(String, Quoted),\n     MultiLineComment(String), Comment(String),\n+\t/// <https://262.ecma-international.org/15.0/index.html#sec-hashbang>\n+    HashBangComment(String),\n     RegexLiteral(String), RegexFlagLiteral(String),\n     TemplateLiteralStart, TemplateLiteralChunk(String), TemplateLiteralEnd,\n     TemplateLiteralExpressionStart, TemplateLiteralExpressionEnd,\ndiff --git a/parser/src/tokens.rs b/parser/src/tokens.rs\n--- a/parser/src/tokens.rs\n+++ b/parser/src/tokens.rs\n@@ -152,12 +153,12 @@ pub enum TSXToken {\n     // <> and </>\n     JSXFragmentStart, JSXFragmentEnd,\n     /// <!-- -->\n-    JSXComment(String),\n+    JSXComment(String), \n+\t/// For top level HTML\n+\tDocTypeHTML,\n \n     // Non standard\n     #[cfg(feature = \"extras\")]\n-    DividesOperator,\n-    #[cfg(feature = \"extras\")]\n     InvertAssign,\n     #[cfg(feature = \"extras\")]\n     ComposeOperator,\ndiff --git a/parser/src/tokens.rs b/parser/src/tokens.rs\n--- a/parser/src/tokens.rs\n+++ b/parser/src/tokens.rs\n@@ -183,7 +184,6 @@ impl tokenizer_lib::sized_tokens::SizedToken for TSXToken {\n \t\t\tTSXToken::JSXClosingTagName(lit)\n \t\t\t| TSXToken::TemplateLiteralChunk(lit)\n \t\t\t| TSXToken::JSXAttributeKey(lit)\n-\t\t\t| TSXToken::JSXAttributeValue(lit)\n \t\t\t| TSXToken::JSXContent(lit)\n \t\t\t| TSXToken::JSXTagName(lit)\n \t\t\t| TSXToken::Identifier(lit)\ndiff --git a/parser/src/tokens.rs b/parser/src/tokens.rs\n--- a/parser/src/tokens.rs\n+++ b/parser/src/tokens.rs\n@@ -192,10 +192,14 @@ impl tokenizer_lib::sized_tokens::SizedToken for TSXToken {\n \n \t\t\tTSXToken::JSXComment(comment) => comment.len() as u32 + 7,\n \t\t\tTSXToken::MultiLineComment(comment) => comment.len() as u32 + 4,\n-\t\t\tTSXToken::StringLiteral(comment, _) | TSXToken::Comment(comment) => {\n-\t\t\t\tcomment.len() as u32 + 2\n+\t\t\tTSXToken::StringLiteral(comment, _)\n+\t\t\t| TSXToken::Comment(comment)\n+\t\t\t| TSXToken::HashBangComment(comment) => comment.len() as u32 + 2,\n+\t\t\tTSXToken::JSXAttributeValue(value) | TSXToken::RegexLiteral(value) => {\n+\t\t\t\tvalue.len() as u32 + 2\n \t\t\t}\n-\t\t\tTSXToken::RegexLiteral(regex) => regex.len() as u32 + 2,\n+\n+\t\t\tTSXToken::DocTypeHTML => 15,\n \n \t\t\tTSXToken::Comma\n \t\t\t| TSXToken::SemiColon\ndiff --git a/parser/src/tokens.rs b/parser/src/tokens.rs\n--- a/parser/src/tokens.rs\n+++ b/parser/src/tokens.rs\n@@ -282,7 +286,7 @@ impl tokenizer_lib::sized_tokens::SizedToken for TSXToken {\n \t\t\tTSXToken::EOS => 0,\n \n \t\t\t#[cfg(feature = \"extras\")]\n-\t\t\tTSXToken::InvertAssign | TSXToken::DividesOperator | TSXToken::PipeOperator => 2,\n+\t\t\tTSXToken::InvertAssign | TSXToken::PipeOperator => 2,\n \t\t\t#[cfg(feature = \"extras\")]\n \t\t\tTSXToken::ComposeOperator => 3,\n \t\t}\ndiff --git a/parser/src/tokens.rs b/parser/src/tokens.rs\n--- a/parser/src/tokens.rs\n+++ b/parser/src/tokens.rs\n@@ -356,6 +360,19 @@ impl TSXKeyword {\n \t\tmatches!(self, TSXKeyword::Function | TSXKeyword::Async)\n \t}\n \n+\t#[cfg(feature = \"extras\")]\n+\tpub(crate) fn is_in_method_header(self) -> bool {\n+\t\tmatches!(\n+\t\t\tself,\n+\t\t\tTSXKeyword::Generator | TSXKeyword::Get | TSXKeyword::Set | TSXKeyword::Async\n+\t\t)\n+\t}\n+\n+\t#[cfg(not(feature = \"extras\"))]\n+\tpub(crate) fn is_in_method_header(self) -> bool {\n+\t\tmatches!(self, TSXKeyword::Get | TSXKeyword::Set | TSXKeyword::Async)\n+\t}\n+\n \t#[allow(clippy::cast_possible_truncation)]\n \tpub(crate) fn length(self) -> u32 {\n \t\tself.to_str().len() as u32\ndiff --git a/parser/src/tokens.rs b/parser/src/tokens.rs\n--- a/parser/src/tokens.rs\n+++ b/parser/src/tokens.rs\n@@ -407,12 +424,13 @@ impl TSXToken {\n \tpub fn is_expression_prefix(&self) -> bool {\n \t\tmatches!(\n \t\t\tself,\n-\t\t\tTSXToken::Keyword(TSXKeyword::Return | TSXKeyword::Case | TSXKeyword::Yield | TSXKeyword::Throw | TSXKeyword::TypeOf | TSXKeyword::In | TSXKeyword::Of | TSXKeyword::Await)\n+\t\t\tTSXToken::Keyword(TSXKeyword::Return | TSXKeyword::Case | TSXKeyword::Yield | TSXKeyword::Throw | TSXKeyword::TypeOf | TSXKeyword::In | TSXKeyword::Of | TSXKeyword::Await | TSXKeyword::Do | TSXKeyword::Extends)\n \t\t\t\t| TSXToken::Arrow\n \t\t\t\t// for `const x = 2; /something/g`\n \t\t\t\t| TSXToken::SemiColon\n \t\t\t\t| TSXToken::OpenParentheses\n \t\t\t\t| TSXToken::OpenBrace\n+\t\t\t\t| TSXToken::OpenBracket\n \t\t\t\t| TSXToken::JSXExpressionStart\n \t\t\t\t| TSXToken::QuestionMark\n \t\t\t\t| TSXToken::Colon\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -2,10 +2,9 @@ use crate::{\n \tderive_ASTNode, errors::parse_lexing_error, extensions::decorators::Decorated,\n \tfunctions::MethodHeader, parse_bracketed, property_key::PublicOrPrivate,\n \tthrow_unexpected_token_with_token, to_string_bracketed, tokens::token_as_identifier,\n-\ttypes::type_annotations::TypeAnnotationFunctionParameters, ASTNode, Expression,\n-\tExpressionOrStatementPosition, NumberRepresentation, ParseErrors, ParseOptions, ParseResult,\n-\tPropertyKey, Span, StatementPosition, TSXKeyword, TSXToken, TypeAnnotation, TypeParameter,\n-\tWithComment,\n+\ttypes::type_annotations::TypeAnnotationFunctionParameters, ASTNode,\n+\tExpressionOrStatementPosition, ParseErrors, ParseOptions, ParseResult, PropertyKey, Span,\n+\tStatementPosition, TSXKeyword, TSXToken, TypeAnnotation, TypeParameter, WithComment,\n };\n \n use get_field_by_type::GetFieldByType;\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -16,7 +15,7 @@ use tokenizer_lib::{sized_tokens::TokenReaderWithTokenEnds, Token, TokenReader};\n #[derive(Debug, Clone, PartialEq, get_field_by_type::GetFieldByType)]\n #[get_field_by_type_target(Span)]\n pub struct InterfaceDeclaration {\n-\tpub is_declare: bool,\n+\tpub is_is_declare: bool,\n \tpub name: StatementPosition,\n \t#[cfg(feature = \"extras\")]\n \tpub is_nominal: bool,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -92,7 +91,7 @@ impl ASTNode for InterfaceDeclaration {\n \t\tlet position = start.union(reader.expect_next_get_end(TSXToken::CloseBrace)?);\n \t\tOk(InterfaceDeclaration {\n \t\t\tname,\n-\t\t\tis_declare: false,\n+\t\t\tis_is_declare: false,\n \t\t\t#[cfg(feature = \"extras\")]\n \t\t\tis_nominal,\n \t\t\ttype_parameters,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -256,6 +255,7 @@ impl ASTNode for InterfaceMember {\n \t\t\t}\n \t\t\t// Caller self with generic parameters\n \t\t\tTSXToken::OpenChevron => {\n+\t\t\t\tlet _ = reader.next();\n \t\t\t\tlet (type_parameters, _, _start_pos) =\n \t\t\t\t\tparse_bracketed(reader, state, options, None, TSXToken::CloseChevron)?;\n \t\t\t\tlet parameters =\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -349,27 +349,57 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t}\n \t\t\t}\n \t\t\t_ => {\n-\t\t\t\tlet header = MethodHeader::from_reader(reader);\n+\t\t\t\tlet first = reader\n+\t\t\t\t\t.conditional_next(|t| matches!(t, TSXToken::OpenBracket))\n+\t\t\t\t\t.map(|res| (None, res))\n+\t\t\t\t\t.or_else(|| {\n+\t\t\t\t\t\tlet is_get_set_async_index_type =\n+\t\t\t\t\t\t\tmatches!(\n+\t\t\t\t\t\t\t\treader.peek(),\n+\t\t\t\t\t\t\t\tSome(Token(\n+\t\t\t\t\t\t\t\t\tTSXToken::Keyword(\n+\t\t\t\t\t\t\t\t\t\tTSXKeyword::Get | TSXKeyword::Set | TSXKeyword::Async\n+\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\t\t_\n+\t\t\t\t\t\t\t\t))\n+\t\t\t\t\t\t\t) && matches!(reader.peek_n(1), Some(Token(TSXToken::OpenBracket, _)));\n+\n+\t\t\t\t\t\tif is_get_set_async_index_type {\n+\t\t\t\t\t\t\tlet token = reader.next().unwrap();\n+\t\t\t\t\t\t\tlet header = match token.0 {\n+\t\t\t\t\t\t\t\tTSXToken::Keyword(TSXKeyword::Get) => MethodHeader::Get,\n+\t\t\t\t\t\t\t\tTSXToken::Keyword(TSXKeyword::Set) => MethodHeader::Set,\n+\t\t\t\t\t\t\t\tTSXToken::Keyword(TSXKeyword::Async) => {\n+\t\t\t\t\t\t\t\t\tMethodHeader::Regular { is_async: true, generator: None }\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t_ => unreachable!(),\n+\t\t\t\t\t\t\t};\n+\t\t\t\t\t\t\tlet open_bracket_token = reader.next().unwrap();\n+\t\t\t\t\t\t\tSome((Some(header), open_bracket_token))\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tNone\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n \n-\t\t\t\t// TODO tidy\n-\t\t\t\tlet (name, type_parameters) = if let TSXToken::OpenBracket =\n-\t\t\t\t\treader.peek().unwrap().0\n+\t\t\t\t// Non literal property names and index type\n+\t\t\t\tlet (header, name, type_parameters) = if let Some((header, Token(_, start))) = first\n \t\t\t\t{\n-\t\t\t\t\t// Non literal property names and index type\n-\t\t\t\t\tlet Token(_, start) = reader.next().unwrap();\n \t\t\t\t\tlet name = match reader.next().ok_or_else(parse_lexing_error)? {\n \t\t\t\t\t\tToken(TSXToken::StringLiteral(name, quoted), start) => {\n \t\t\t\t\t\t\tlet position = start.with_length(name.len() + 2);\n+\t\t\t\t\t\t\tlet _end = reader.expect_next_get_end(TSXToken::CloseBracket)?;\n \t\t\t\t\t\t\tPropertyKey::StringLiteral(name, quoted, position)\n \t\t\t\t\t\t}\n \t\t\t\t\t\tToken(TSXToken::NumberLiteral(value), start) => {\n \t\t\t\t\t\t\tlet position = start.with_length(value.len());\n+\t\t\t\t\t\t\tlet _end = reader.expect_next_get_end(TSXToken::CloseBracket)?;\n \t\t\t\t\t\t\tPropertyKey::NumberLiteral(\n-\t\t\t\t\t\t\t\tvalue.parse::<NumberRepresentation>().unwrap(),\n+\t\t\t\t\t\t\t\tvalue.parse::<crate::number::NumberRepresentation>().unwrap(),\n \t\t\t\t\t\t\t\tposition,\n \t\t\t\t\t\t\t)\n \t\t\t\t\t\t}\n \t\t\t\t\t\ttoken => {\n+\t\t\t\t\t\t\tuse crate::Expression;\n \t\t\t\t\t\t\t// \"name\" is the name of the parameter name for indexing\n \t\t\t\t\t\t\tlet (name, name_span) =\n \t\t\t\t\t\t\t\ttoken_as_identifier(token, \"interface parameter\")?;\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -386,7 +416,7 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\t\t\t\tlet start_span = readonly_position.as_ref().unwrap_or(&name_span);\n \t\t\t\t\t\t\t\tmatch reader.next().ok_or_else(parse_lexing_error)? {\n \t\t\t\t\t\t\t\t\t// Indexed type\n-\t\t\t\t\t\t\t\t\tToken(TSXToken::Colon, _) => {\n+\t\t\t\t\t\t\t\t\tToken(TSXToken::Colon, _start) => {\n \t\t\t\t\t\t\t\t\t\tlet indexer_type =\n \t\t\t\t\t\t\t\t\t\t\tTypeAnnotation::from_reader(reader, state, options)?;\n \t\t\t\t\t\t\t\t\t\treader.expect_next(TSXToken::CloseBracket)?;\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -401,6 +431,7 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\t\t\t\t\t\t\treturn_type,\n \t\t\t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t// For mapped types\n \t\t\t\t\t\t\t\t\tToken(TSXToken::Keyword(TSXKeyword::In), _) => {\n \t\t\t\t\t\t\t\t\t\tlet matching_type =\n \t\t\t\t\t\t\t\t\t\t\tTypeAnnotation::from_reader(reader, state, options)?;\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -410,15 +441,14 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\t\t\t\t\t\t});\n \n \t\t\t\t\t\t\t\t\t\tlet as_type = if next_is_as.is_some() {\n-\t\t\t\t\t\t\t\t\t\t\tSome(Box::new(TypeAnnotation::from_reader_with_config(\n-\t\t\t\t\t\t\t\t\t\t\t\treader, state, options, None, None,\n+\t\t\t\t\t\t\t\t\t\t\tSome(Box::new(TypeAnnotation::from_reader(\n+\t\t\t\t\t\t\t\t\t\t\t\treader, state, options,\n \t\t\t\t\t\t\t\t\t\t\t)?))\n \t\t\t\t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\t\t\t\tNone\n \t\t\t\t\t\t\t\t\t\t};\n \n \t\t\t\t\t\t\t\t\t\treader.expect_next(TSXToken::CloseBracket)?;\n-\t\t\t\t\t\t\t\t\t\t// TODO the -?: ?: : stuff '-?:' should be a token\n \t\t\t\t\t\t\t\t\t\tlet token = reader.next().ok_or_else(parse_lexing_error)?;\n \t\t\t\t\t\t\t\t\t\tlet optionality = match token {\n \t\t\t\t\t\t\t\t\t\t\tToken(TSXToken::Colon, _) => Optionality::Default,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -469,18 +499,23 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t};\n-\t\t\t\t\t(name, None)\n+\t\t\t\t\t(header, name, None)\n \t\t\t\t} else {\n-\t\t\t\t\tlet property_key = PropertyKey::from_reader(reader, state, options)?;\n+\t\t\t\t\tlet (header, name) = crate::functions::get_method_name(reader, state, options)?;\n \t\t\t\t\tlet type_parameters = reader\n \t\t\t\t\t\t.conditional_next(|token| *token == TSXToken::OpenChevron)\n \t\t\t\t\t\t.is_some()\n \t\t\t\t\t\t.then(|| {\n \t\t\t\t\t\t\tparse_bracketed(reader, state, options, None, TSXToken::CloseChevron)\n \t\t\t\t\t\t})\n-\t\t\t\t\t\t.transpose()?;\n+\t\t\t\t\t\t.transpose()?\n+\t\t\t\t\t\t.map(|(tp, _, _)| tp);\n+\n+\t\t\t\t\tlet name = name.get_ast();\n+\n+\t\t\t\t\tlet header = if header.is_no_modifiers() { None } else { Some(header) };\n \n-\t\t\t\t\t(property_key, type_parameters.map(|(tp, _, _)| tp))\n+\t\t\t\t\t(header, name, type_parameters)\n \t\t\t\t};\n \n \t\t\t\tlet start = readonly_position.unwrap_or_else(|| name.get_position());\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -509,7 +544,7 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\t\t};\n \n \t\t\t\t\t\tOk(InterfaceMember::Method {\n-\t\t\t\t\t\t\theader,\n+\t\t\t\t\t\t\theader: header.unwrap_or_default(),\n \t\t\t\t\t\t\tname,\n \t\t\t\t\t\t\tparameters,\n \t\t\t\t\t\t\ttype_parameters,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -519,8 +554,7 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\t\t})\n \t\t\t\t\t}\n \t\t\t\t\tToken(TSXToken::QuestionMark, _) => {\n-\t\t\t\t\t\t// TODO this is a little weird, I don't think '?(' is a actual token and is\n-\t\t\t\t\t\t// only used here. Making '?(' a token may break ternary where first expr is a group\n+\t\t\t\t\t\t// This is a function. If it was a property it would be the `?:` token\n \t\t\t\t\t\tlet parameters =\n \t\t\t\t\t\t\tTypeAnnotationFunctionParameters::from_reader(reader, state, options)?;\n \ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -539,7 +573,7 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\t\t};\n \n \t\t\t\t\t\tOk(InterfaceMember::Method {\n-\t\t\t\t\t\t\theader,\n+\t\t\t\t\t\t\theader: header.unwrap_or_default(),\n \t\t\t\t\t\t\tname,\n \t\t\t\t\t\t\tparameters,\n \t\t\t\t\t\t\ttype_parameters,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -548,35 +582,22 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\t\t\treturn_type,\n \t\t\t\t\t\t})\n \t\t\t\t\t}\n-\t\t\t\t\tToken(TSXToken::Colon, _) => {\n-\t\t\t\t\t\tlet mut type_annotation =\n-\t\t\t\t\t\t\tTypeAnnotation::from_reader(reader, state, options)?;\n-\n-\t\t\t\t\t\tif readonly_position.is_some() {\n-\t\t\t\t\t\t\t// TODO positioning:\n+\t\t\t\t\tt @ Token(TSXToken::Colon | TSXToken::OptionalMember, _) => {\n+\t\t\t\t\t\tif header.is_none() {\n+\t\t\t\t\t\t\tlet type_annotation =\n+\t\t\t\t\t\t\t\tTypeAnnotation::from_reader(reader, state, options)?;\n \t\t\t\t\t\t\tlet position = start.union(type_annotation.get_position());\n-\t\t\t\t\t\t\ttype_annotation =\n-\t\t\t\t\t\t\t\tTypeAnnotation::Readonly(Box::new(type_annotation), position);\n+\t\t\t\t\t\t\tlet is_optional = matches!(t, Token(TSXToken::OptionalMember, _));\n+\t\t\t\t\t\t\tOk(InterfaceMember::Property {\n+\t\t\t\t\t\t\t\tposition,\n+\t\t\t\t\t\t\t\tname,\n+\t\t\t\t\t\t\t\ttype_annotation,\n+\t\t\t\t\t\t\t\tis_optional,\n+\t\t\t\t\t\t\t\tis_readonly: readonly_position.is_some(),\n+\t\t\t\t\t\t\t})\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tthrow_unexpected_token_with_token(t, &[TSXToken::OpenParentheses])\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tlet position = start.union(type_annotation.get_position());\n-\t\t\t\t\t\tOk(InterfaceMember::Property {\n-\t\t\t\t\t\t\tposition,\n-\t\t\t\t\t\t\tname,\n-\t\t\t\t\t\t\ttype_annotation,\n-\t\t\t\t\t\t\tis_optional: false,\n-\t\t\t\t\t\t\tis_readonly: readonly_position.is_some(),\n-\t\t\t\t\t\t})\n-\t\t\t\t\t}\n-\t\t\t\t\tToken(TSXToken::OptionalMember, _) => {\n-\t\t\t\t\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, options)?;\n-\t\t\t\t\t\tlet position = start.union(type_annotation.get_position());\n-\t\t\t\t\t\tOk(InterfaceMember::Property {\n-\t\t\t\t\t\t\tname,\n-\t\t\t\t\t\t\ttype_annotation,\n-\t\t\t\t\t\t\tis_optional: true,\n-\t\t\t\t\t\t\tis_readonly: readonly_position.is_some(),\n-\t\t\t\t\t\t\tposition,\n-\t\t\t\t\t\t})\n \t\t\t\t\t}\n \t\t\t\t\ttoken => throw_unexpected_token_with_token(\n \t\t\t\t\t\ttoken,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -709,14 +730,14 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t});\n \t\t\t\toutput_type.to_string_from_buffer(buf, options, local);\n \t\t\t}\n-\t\t\tInterfaceMember::Comment(c, is_multiline, _) => {\n+\t\t\tInterfaceMember::Comment(content, is_multiline, _) => {\n \t\t\t\tif *is_multiline {\n \t\t\t\t\tbuf.push_str(\"/*\");\n-\t\t\t\t\tbuf.push_str(c);\n+\t\t\t\t\tbuf.push_str(content);\n \t\t\t\t\tbuf.push_str(\"*/\");\n \t\t\t\t} else {\n \t\t\t\t\tbuf.push_str(\"//\");\n-\t\t\t\t\tbuf.push_str(c);\n+\t\t\t\t\tbuf.push_str(content);\n \t\t\t\t\tbuf.push_new_line();\n \t\t\t\t}\n \t\t\t}\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -739,11 +760,18 @@ pub(crate) fn parse_interface_members(\n \t\t\tbreak;\n \t\t}\n \t\tlet decorated_member = WithComment::from_reader(reader, state, options)?;\n-\t\tmembers.push(decorated_member);\n-\t\t// Semi colons and commas are optional here\n-\t\tif let Some(Token(TSXToken::SemiColon | TSXToken::Comma, _)) = reader.peek() {\n+\t\t// Semi colons and commas are optional here. Should expect_semi_colon\n+\t\tif let Some(Token(TSXToken::Comma, _)) = reader.peek() {\n \t\t\treader.next();\n+\t\t} else {\n+\t\t\tlet _ = crate::expect_semi_colon(\n+\t\t\t\treader,\n+\t\t\t\t&state.line_starts,\n+\t\t\t\tdecorated_member.get_position().end,\n+\t\t\t\toptions,\n+\t\t\t)?;\n \t\t}\n+\t\tmembers.push(decorated_member);\n \t}\n \tOk(members)\n }\ndiff --git a/parser/src/types/namespace.rs b/parser/src/types/namespace.rs\n--- a/parser/src/types/namespace.rs\n+++ b/parser/src/types/namespace.rs\n@@ -1,13 +1,14 @@\n use get_field_by_type::GetFieldByType;\n use source_map::Span;\n+use visitable_derive::Visitable;\n \n use crate::{derive_ASTNode, Block};\n \n-/// While `Block`, only some items are allowed\n #[apply(derive_ASTNode)]\n-#[derive(Debug, Clone, PartialEq, get_field_by_type::GetFieldByType)]\n+#[derive(Debug, Clone, PartialEq, get_field_by_type::GetFieldByType, Visitable)]\n #[get_field_by_type_target(Span)]\n pub struct Namespace {\n+\tpub is_declare: bool,\n \tpub name: String,\n \tpub inner: Block,\n \tpub position: Span,\ndiff --git a/parser/src/types/namespace.rs b/parser/src/types/namespace.rs\n--- a/parser/src/types/namespace.rs\n+++ b/parser/src/types/namespace.rs\n@@ -26,7 +27,7 @@ impl crate::ASTNode for Namespace {\n \t\t)?;\n \t\tlet inner = Block::from_reader(reader, state, options)?;\n \t\tlet position = start.union(inner.get_position());\n-\t\tOk(Self { name, inner, position })\n+\t\tOk(Self { is_declare: false, name, inner, position })\n \t}\n \n \tfn to_string_from_buffer<T: source_map::ToString>(\ndiff --git a/parser/src/types/namespace.rs b/parser/src/types/namespace.rs\n--- a/parser/src/types/namespace.rs\n+++ b/parser/src/types/namespace.rs\n@@ -36,6 +37,9 @@ impl crate::ASTNode for Namespace {\n \t\tlocal: crate::LocalToStringInformation,\n \t) {\n \t\tif options.include_type_annotations {\n+\t\t\tif self.is_declare {\n+\t\t\t\tbuf.push_str(\"declare \");\n+\t\t\t}\n \t\t\tbuf.push_str(\"namespace \");\n \t\t\tbuf.push_str(&self.name);\n \t\t\tbuf.push(' ');\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -6,8 +6,8 @@ use crate::{\n \tListItem, ParseErrors, Quoted,\n };\n use crate::{\n-\terrors::parse_lexing_error, expressions::TemplateLiteralPart,\n-\textensions::decorators::Decorated, Decorator, Marker, ParseResult, VariableField, WithComment,\n+\terrors::parse_lexing_error, extensions::decorators::Decorated, Decorator, Marker, ParseResult,\n+\tVariableField, WithComment,\n };\n use derive_partial_eq_extras::PartialEqExtras;\n use iterator_endiate::EndiateIteratorExt;\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -19,8 +19,8 @@ use super::{\n };\n \n use crate::{\n-\ttokens::token_as_identifier, ASTNode, NumberRepresentation, ParseError, ParseOptions, Span,\n-\tTSXKeyword, TSXToken, Token, TokenReader,\n+\tnumber::NumberRepresentation, tokens::token_as_identifier, ASTNode, ParseError, ParseOptions,\n+\tSpan, TSXKeyword, TSXToken, Token, TokenReader,\n };\n \n /// A reference to a type\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -29,15 +29,12 @@ use crate::{\n #[get_field_by_type_target(Span)]\n #[partial_eq_ignore_types(Span)]\n pub enum TypeAnnotation {\n-\t/// A name e.g. `IPost`\n-\tName(String, Span),\n+\t/// Common types that don't have to allocate a string for\n \tCommonName(CommonTypes, Span),\n-\t/// WIP\n-\tThis(Span),\n-\t/// A name e.g. `Intl.IPost`. TODO can there be more than 2 members\n-\tNamespacedName(String, String, Span),\n+\t/// A name e.g. `IPost`\n+\tName(TypeName, Span),\n \t/// A name with generics e.g. `Array<number>`\n-\tNameWithGenericArguments(String, Vec<TypeAnnotation>, Span),\n+\tNameWithGenericArguments(TypeName, Vec<TypeAnnotation>, Span),\n \t/// Union e.g. `number | string`\n \tUnion(Vec<TypeAnnotation>, Span),\n \t/// Intersection e.g. `c & d`\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -70,9 +67,15 @@ pub enum TypeAnnotation {\n \t/// Tuple literal e.g. `[number, x: string]`\n \tTupleLiteral(Vec<TupleLiteralElement>, Span),\n \t/// ?\n-\tTemplateLiteral(Vec<TemplateLiteralPart<AnnotationWithBinder>>, Span),\n+\tTemplateLiteral {\n+\t\tparts: Vec<(String, AnnotationWithBinder)>,\n+\t\tlast: String,\n+\t\tposition: Span,\n+\t},\n \t/// Declares type as not assignable (still has interior mutability) e.g. `readonly number`\n \tReadonly(Box<TypeAnnotation>, Span),\n+\t/// I have no idea what this is for?\n+\tAbstract(Box<TypeAnnotation>, Span),\n \t/// Declares type as being union type of all property types e.g. `T[K]`\n \tIndex(Box<TypeAnnotation>, Box<TypeAnnotation>, Span),\n \t/// KeyOf\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -91,7 +94,7 @@ pub enum TypeAnnotation {\n \t\tposition: Span,\n \t},\n \tIs {\n-\t\titem: Box<TypeAnnotation>,\n+\t\treference: IsItem,\n \t\tis: Box<TypeAnnotation>,\n \t\tposition: Span,\n \t},\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -110,11 +113,14 @@ pub enum TypeAnnotation {\n \t},\n \t/// For operation precedence reasons\n \tParenthesizedReference(Box<TypeAnnotation>, Span),\n+\t/// With decorators\n \tDecorated(\n \t\tDecorator,\n \t\t#[cfg_attr(target_family = \"wasm\", tsify(type = \"TypeAnnotation\"))] Box<Self>,\n \t\tSpan,\n \t),\n+\t/// Allowed in certain positions\n+\tThis(Span),\n \t#[cfg_attr(feature = \"self-rust-tokenize\", self_tokenize_field(0))]\n \tMarker(Marker<TypeAnnotation>, Span),\n }\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -179,7 +185,7 @@ impl AnnotationWithBinder {\n \t}\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone, PartialEq)]\n #[apply(derive_ASTNode)]\n pub enum TupleElementKind {\n \tStandard,\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -187,13 +193,48 @@ pub enum TupleElementKind {\n \tOptional,\n }\n \n-/// Reduces string allocation and type lookup overhead\n-#[derive(Debug, Clone, PartialEq, Eq)]\n+/// Reduces string allocation and type lookup overhead. This always point to the same type regardless of context (because no type is allowed to be named these)\n+#[derive(Debug, Clone, PartialEq)]\n #[apply(derive_ASTNode)]\n pub enum CommonTypes {\n \tString,\n \tNumber,\n \tBoolean,\n+\tAny,\n+\tNull,\n+\tUndefined,\n+\tUnknown,\n+\tNever,\n+}\n+\n+impl CommonTypes {\n+\tfn name(&self) -> &'static str {\n+\t\tmatch self {\n+\t\t\tCommonTypes::String => \"string\",\n+\t\t\tCommonTypes::Number => \"number\",\n+\t\t\tCommonTypes::Boolean => \"boolean\",\n+\t\t\tCommonTypes::Any => \"any\",\n+\t\t\tCommonTypes::Null => \"null\",\n+\t\t\tCommonTypes::Undefined => \"undefined\",\n+\t\t\tCommonTypes::Never => \"never\",\n+\t\t\tCommonTypes::Unknown => \"unknown\",\n+\t\t}\n+\t}\n+}\n+\n+#[apply(derive_ASTNode)]\n+#[derive(Debug, Clone, PartialEq)]\n+pub enum TypeName {\n+\tName(String),\n+\t// For `Intl.Int` or something\n+\tFromNamespace(Vec<String>),\n+}\n+\n+#[apply(derive_ASTNode)]\n+#[derive(Debug, Clone, PartialEq)]\n+pub enum IsItem {\n+\tReference(String),\n+\tThis,\n }\n \n impl ASTNode for TypeAnnotation {\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -215,19 +256,39 @@ impl ASTNode for TypeAnnotation {\n \t\t\tSelf::Marker(..) => {\n \t\t\t\tassert!(options.expect_markers,);\n \t\t\t}\n-\t\t\tSelf::CommonName(name, _) => buf.push_str(match name {\n-\t\t\t\tCommonTypes::String => \"string\",\n-\t\t\t\tCommonTypes::Number => \"number\",\n-\t\t\t\tCommonTypes::Boolean => \"boolean\",\n-\t\t\t}),\n+\t\t\tSelf::CommonName(name, _) => buf.push_str(name.name()),\n \t\t\tSelf::Decorated(decorator, on_type_annotation, _) => {\n \t\t\t\tdecorator.to_string_from_buffer(buf, options, local);\n \t\t\t\tbuf.push(' ');\n \t\t\t\ton_type_annotation.to_string_from_buffer(buf, options, local);\n \t\t\t}\n-\t\t\tSelf::Name(name, _) => buf.push_str(name),\n+\t\t\tSelf::Name(name, _) => match name {\n+\t\t\t\tTypeName::Name(name) => {\n+\t\t\t\t\tbuf.push_str(name);\n+\t\t\t\t}\n+\t\t\t\tTypeName::FromNamespace(namespace) => {\n+\t\t\t\t\tfor (not_at_end, item) in namespace.iter().nendiate() {\n+\t\t\t\t\t\tbuf.push_str(item);\n+\t\t\t\t\t\tif not_at_end {\n+\t\t\t\t\t\t\tbuf.push('.');\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t},\n \t\t\tSelf::NameWithGenericArguments(name, arguments, _) => {\n-\t\t\t\tbuf.push_str(name);\n+\t\t\t\tmatch name {\n+\t\t\t\t\tTypeName::Name(name) => {\n+\t\t\t\t\t\tbuf.push_str(name);\n+\t\t\t\t\t}\n+\t\t\t\t\tTypeName::FromNamespace(namespace) => {\n+\t\t\t\t\t\tfor (not_at_end, item) in namespace.iter().nendiate() {\n+\t\t\t\t\t\t\tbuf.push_str(item);\n+\t\t\t\t\t\t\tif not_at_end {\n+\t\t\t\t\t\t\t\tbuf.push('.');\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\tto_string_bracketed(arguments, ('<', '>'), buf, options, local);\n \t\t\t}\n \t\t\tSelf::FunctionLiteral { type_parameters, parameters, return_type, .. } => {\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -277,11 +338,6 @@ impl ASTNode for TypeAnnotation {\n \t\t\t\t\textends.to_string_from_buffer(buf, options, local);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tSelf::NamespacedName(from, to, _) => {\n-\t\t\t\tbuf.push_str(from);\n-\t\t\t\tbuf.push('.');\n-\t\t\t\tbuf.push_str(to);\n-\t\t\t}\n \t\t\tSelf::ObjectLiteral(members, _) => {\n \t\t\t\tto_string_bracketed(members, ('{', '}'), buf, options, local);\n \t\t\t}\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -294,6 +350,10 @@ impl ASTNode for TypeAnnotation {\n \t\t\t\twith.to_string_from_buffer(buf, options, local);\n \t\t\t\tbuf.push(']');\n \t\t\t}\n+\t\t\tSelf::Abstract(item, _) => {\n+\t\t\t\tbuf.push_str(\"abstract \");\n+\t\t\t\titem.to_string_from_buffer(buf, options, local);\n+\t\t\t}\n \t\t\tSelf::KeyOf(item, _) => {\n \t\t\t\tbuf.push_str(\"keyof \");\n \t\t\t\titem.to_string_from_buffer(buf, options, local);\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -350,18 +410,16 @@ impl ASTNode for TypeAnnotation {\n \t\t\t\treference.to_string_from_buffer(buf, options, local);\n \t\t\t\tbuf.push(')');\n \t\t\t}\n-\t\t\tSelf::TemplateLiteral(parts, _) => {\n+\t\t\tSelf::TemplateLiteral { parts, last, .. } => {\n \t\t\t\tbuf.push('`');\n-\t\t\t\tfor part in parts {\n-\t\t\t\t\tmatch part {\n-\t\t\t\t\t\tTemplateLiteralPart::Static(chunk) => buf.push_str(chunk),\n-\t\t\t\t\t\tTemplateLiteralPart::Dynamic(reference) => {\n-\t\t\t\t\t\t\tbuf.push_str(\"${\");\n-\t\t\t\t\t\t\treference.to_string_from_buffer(buf, options, local);\n-\t\t\t\t\t\t\tbuf.push('}');\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\t\tfor (static_part, dynamic_part) in parts {\n+\t\t\t\t\tbuf.push_str_contains_new_line(static_part.as_str());\n+\n+\t\t\t\t\tbuf.push_str(\"${\");\n+\t\t\t\t\tdynamic_part.to_string_from_buffer(buf, options, local);\n+\t\t\t\t\tbuf.push('}');\n \t\t\t\t}\n+\t\t\t\tbuf.push_str_contains_new_line(last.as_str());\n \t\t\t\tbuf.push('`');\n \t\t\t}\n \t\t\tSelf::Symbol { unique, .. } => {\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -375,8 +433,11 @@ impl ASTNode for TypeAnnotation {\n \t\t\t\tbuf.push_str(\" extends \");\n \t\t\t\textends.to_string_from_buffer(buf, options, local);\n \t\t\t}\n-\t\t\tSelf::Is { item, is, .. } => {\n-\t\t\t\titem.to_string_from_buffer(buf, options, local);\n+\t\t\tSelf::Is { reference, is, .. } => {\n+\t\t\t\tbuf.push_str(match reference {\n+\t\t\t\t\tIsItem::Reference(reference) => reference,\n+\t\t\t\t\tIsItem::This => \"this\",\n+\t\t\t\t});\n \t\t\t\tbuf.push_str(\" is \");\n \t\t\t\tis.to_string_from_buffer(buf, options, local);\n \t\t\t}\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -429,10 +490,9 @@ impl TypeAnnotation {\n \n \t\t\tif next_is_not_type_annotation_like {\n \t\t\t\tlet point = start.unwrap_or(*at);\n-\t\t\t\treturn Ok(TypeAnnotation::Marker(\n-\t\t\t\t\tstate.new_partial_point_marker(point),\n-\t\t\t\t\tpoint.with_length(0),\n-\t\t\t\t));\n+\t\t\t\t// take up the whole next part for checker suggestions\n+\t\t\t\tlet position = point.union(source_map::End(at.0));\n+\t\t\t\treturn Ok(TypeAnnotation::Marker(state.new_partial_point_marker(point), position));\n \t\t\t}\n \t\t}\n \ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -636,38 +696,65 @@ impl TypeAnnotation {\n \t\t\t}\n \t\t\tToken(TSXToken::TemplateLiteralStart, start) => {\n \t\t\t\tlet mut parts = Vec::new();\n-\t\t\t\tlet mut end = None;\n+\t\t\t\tlet mut last = String::new();\n+\t\t\t\tlet mut end: Option<TokenEnd> = None;\n \t\t\t\twhile end.is_none() {\n \t\t\t\t\tmatch reader.next().ok_or_else(parse_lexing_error)? {\n \t\t\t\t\t\tToken(TSXToken::TemplateLiteralChunk(chunk), _) => {\n-\t\t\t\t\t\t\tparts.push(TemplateLiteralPart::Static(chunk));\n+\t\t\t\t\t\t\tlast = chunk;\n \t\t\t\t\t\t}\n \t\t\t\t\t\tToken(TSXToken::TemplateLiteralExpressionStart, _) => {\n \t\t\t\t\t\t\tlet expression =\n \t\t\t\t\t\t\t\tAnnotationWithBinder::from_reader(reader, state, options)?;\n-\t\t\t\t\t\t\treader.expect_next(TSXToken::TemplateLiteralExpressionEnd)?;\n-\t\t\t\t\t\t\tparts.push(TemplateLiteralPart::Dynamic(Box::new(expression)));\n+\t\t\t\t\t\t\tparts.push((std::mem::take(&mut last), expression));\n+\t\t\t\t\t\t\tlet next = reader.next();\n+\t\t\t\t\t\t\tdebug_assert!(matches!(\n+\t\t\t\t\t\t\t\tnext,\n+\t\t\t\t\t\t\t\tSome(Token(TSXToken::TemplateLiteralExpressionEnd, _))\n+\t\t\t\t\t\t\t));\n \t\t\t\t\t\t}\n \t\t\t\t\t\tToken(TSXToken::TemplateLiteralEnd, end_position) => {\n \t\t\t\t\t\t\tend = Some(TokenEnd::new(end_position.0));\n \t\t\t\t\t\t}\n-\t\t\t\t\t\ttoken => {\n-\t\t\t\t\t\t\teprintln!(\"Found token {token:?}\");\n-\t\t\t\t\t\t\treturn Err(parse_lexing_error());\n-\t\t\t\t\t\t}\n+\t\t\t\t\t\tToken(TSXToken::EOS, _) => return Err(parse_lexing_error()),\n+\t\t\t\t\t\tt => unreachable!(\"Token {:?}\", t),\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tSelf::TemplateLiteral(parts, start.union(end.unwrap()))\n+\t\t\t\tSelf::TemplateLiteral { parts, last, position: start.union(end.unwrap()) }\n \t\t\t}\n \t\t\tToken(TSXToken::Keyword(TSXKeyword::Readonly), start) => {\n-\t\t\t\tlet readonly_type = TypeAnnotation::from_reader(reader, state, options)?;\n+\t\t\t\tlet readonly_type = TypeAnnotation::from_reader_with_config(\n+\t\t\t\t\treader,\n+\t\t\t\t\tstate,\n+\t\t\t\t\toptions,\n+\t\t\t\t\tSome(TypeOperatorKind::Query),\n+\t\t\t\t\tSome(start),\n+\t\t\t\t)?;\n \t\t\t\tlet position = start.union(readonly_type.get_position());\n-\t\t\t\treturn Ok(TypeAnnotation::Readonly(Box::new(readonly_type), position));\n+\t\t\t\tTypeAnnotation::Readonly(Box::new(readonly_type), position)\n \t\t\t}\n \t\t\tToken(TSXToken::Keyword(TSXKeyword::KeyOf), start) => {\n-\t\t\t\tlet key_of_type = TypeAnnotation::from_reader(reader, state, options)?;\n+\t\t\t\tlet key_of_type = TypeAnnotation::from_reader_with_config(\n+\t\t\t\t\treader,\n+\t\t\t\t\tstate,\n+\t\t\t\t\toptions,\n+\t\t\t\t\tSome(TypeOperatorKind::Query),\n+\t\t\t\t\tSome(start),\n+\t\t\t\t)?;\n \t\t\t\tlet position = start.union(key_of_type.get_position());\n-\t\t\t\treturn Ok(TypeAnnotation::KeyOf(Box::new(key_of_type), position));\n+\t\t\t\tTypeAnnotation::KeyOf(Box::new(key_of_type), position)\n+\t\t\t}\n+\t\t\t// PLS stop adding **** to the syntax\n+\t\t\tToken(TSXToken::Keyword(TSXKeyword::Abstract), start) => {\n+\t\t\t\tlet inner_type = TypeAnnotation::from_reader_with_config(\n+\t\t\t\t\treader,\n+\t\t\t\t\tstate,\n+\t\t\t\t\toptions,\n+\t\t\t\t\tSome(TypeOperatorKind::Query),\n+\t\t\t\t\tSome(start),\n+\t\t\t\t)?;\n+\t\t\t\tlet position = start.union(inner_type.get_position());\n+\t\t\t\tTypeAnnotation::Abstract(Box::new(inner_type), position)\n \t\t\t}\n \t\t\tToken(TSXToken::Keyword(TSXKeyword::New), start) => {\n \t\t\t\tlet type_parameters = reader\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -696,19 +783,29 @@ impl TypeAnnotation {\n \t\t\t\t\t\"string\" => Self::CommonName(CommonTypes::String, pos),\n \t\t\t\t\t\"number\" => Self::CommonName(CommonTypes::Number, pos),\n \t\t\t\t\t\"boolean\" => Self::CommonName(CommonTypes::Boolean, pos),\n-\t\t\t\t\t_ => Self::Name(name, pos),\n+\t\t\t\t\t\"any\" => Self::CommonName(CommonTypes::Any, pos),\n+\t\t\t\t\t\"null\" => Self::CommonName(CommonTypes::Null, pos),\n+\t\t\t\t\t\"undefined\" => Self::CommonName(CommonTypes::Undefined, pos),\n+\t\t\t\t\t\"unknown\" => Self::CommonName(CommonTypes::Unknown, pos),\n+\t\t\t\t\t\"never\" => Self::CommonName(CommonTypes::Never, pos),\n+\t\t\t\t\t_ => Self::Name(TypeName::Name(name), pos),\n \t\t\t\t}\n \t\t\t}\n \t\t};\n \t\t// Namespaced name\n \t\tif let Some(Token(TSXToken::Dot, _)) = reader.peek() {\n-\t\t\tlet Self::Name(name, start) = reference else { return Ok(reference) };\n-\t\t\treader.next();\n-\t\t\tlet (namespace_member, end) =\n-\t\t\t\ttoken_as_identifier(reader.next().unwrap(), \"namespace name\")?;\n-\t\t\tlet position = start.union(end);\n-\t\t\treturn Ok(TypeAnnotation::NamespacedName(name, namespace_member, position));\n+\t\t\tlet Self::Name(TypeName::Name(name), mut position) = reference else {\n+\t\t\t\treturn Ok(reference);\n+\t\t\t};\n+\t\t\tlet mut namespace = vec![name];\n+\t\t\twhile reader.conditional_next(|tok| *tok == TSXToken::Dot).is_some() {\n+\t\t\t\tlet (part, end) = token_as_identifier(reader.next().unwrap(), \"namespace name\")?;\n+\t\t\t\tnamespace.push(part);\n+\t\t\t\tposition = position.union(end);\n+\t\t\t}\n+\t\t\treference = Self::Name(TypeName::FromNamespace(namespace), position);\n \t\t}\n+\n \t\t// Generics arguments:\n \t\tif let Some(Token(TSXToken::OpenChevron, _position)) = reader.peek() {\n \t\t\t// Assert its a Self::Name\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -743,50 +840,72 @@ impl TypeAnnotation {\n \t\t\t}\n \t\t}\n \n-\t\tmatch reader.peek() {\n-\t\t\tSome(Token(TSXToken::Keyword(TSXKeyword::Extends), _)) => {\n-\t\t\t\treader.next();\n-\t\t\t\tlet extends_type = TypeAnnotation::from_reader_with_config(\n-\t\t\t\t\treader,\n-\t\t\t\t\tstate,\n-\t\t\t\t\toptions,\n-\t\t\t\t\tSome(TypeOperatorKind::Query),\n-\t\t\t\t\tstart,\n-\t\t\t\t)?;\n-\t\t\t\t// TODO local\n-\t\t\t\tlet position = reference.get_position().union(extends_type.get_position());\n-\t\t\t\treference = TypeAnnotation::Extends {\n-\t\t\t\t\titem: Box::new(reference),\n-\t\t\t\t\textends: Box::new(extends_type),\n-\t\t\t\t\tposition,\n-\t\t\t\t};\n+\t\tif let Some(Token(TSXToken::Keyword(TSXKeyword::Is), _)) = reader.peek() {\n+\t\t\tfn type_annotation_as_name(\n+\t\t\t\treference: TypeAnnotation,\n+\t\t\t) -> Result<(IsItem, Span), TypeAnnotation> {\n+\t\t\t\tmatch reference {\n+\t\t\t\t\tTypeAnnotation::CommonName(name, span) => {\n+\t\t\t\t\t\tOk((IsItem::Reference(name.name().to_owned()), span))\n+\t\t\t\t\t}\n+\t\t\t\t\tTypeAnnotation::Name(TypeName::Name(name), span) => {\n+\t\t\t\t\t\tOk((IsItem::Reference(name), span))\n+\t\t\t\t\t}\n+\t\t\t\t\tTypeAnnotation::This(span) => Ok((IsItem::This, span)),\n+\t\t\t\t\t_ => Err(reference),\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tSome(Token(TSXToken::Keyword(TSXKeyword::Is), _)) => {\n-\t\t\t\treader.next();\n-\t\t\t\tlet is_type = TypeAnnotation::from_reader_with_config(\n-\t\t\t\t\treader,\n-\t\t\t\t\tstate,\n-\t\t\t\t\toptions,\n-\t\t\t\t\tSome(TypeOperatorKind::Query),\n-\t\t\t\t\tstart,\n-\t\t\t\t)?;\n-\t\t\t\t// TODO local\n-\t\t\t\tlet position = reference.get_position().union(is_type.get_position());\n \n-\t\t\t\treference = TypeAnnotation::Is {\n-\t\t\t\t\titem: Box::new(reference),\n-\t\t\t\t\tis: Box::new(is_type),\n-\t\t\t\t\tposition,\n-\t\t\t\t};\n+\t\t\tmatch type_annotation_as_name(reference) {\n+\t\t\t\tOk((item, span)) => {\n+\t\t\t\t\treader.next();\n+\t\t\t\t\tlet is_type = TypeAnnotation::from_reader_with_config(\n+\t\t\t\t\t\treader,\n+\t\t\t\t\t\tstate,\n+\t\t\t\t\t\toptions,\n+\t\t\t\t\t\tSome(TypeOperatorKind::Query),\n+\t\t\t\t\t\tSome(span.get_start()),\n+\t\t\t\t\t)?;\n+\t\t\t\t\t// TODO local\n+\t\t\t\t\tlet position = span.union(is_type.get_position());\n+\n+\t\t\t\t\treference =\n+\t\t\t\t\t\tTypeAnnotation::Is { reference: item, is: Box::new(is_type), position };\n+\t\t\t\t}\n+\t\t\t\tErr(reference) => {\n+\t\t\t\t\treturn Err(ParseError::new(\n+\t\t\t\t\t\tcrate::ParseErrors::InvalidLHSOfIs,\n+\t\t\t\t\t\treference.get_position(),\n+\t\t\t\t\t));\n+\t\t\t\t}\n \t\t\t}\n-\t\t\t_ => {}\n \t\t}\n \n-\t\t// Extends, Is, Intersections & Unions or implicit function literals\n+\t\tif let Some(Token(TSXToken::Keyword(TSXKeyword::Extends), _)) = reader.peek() {\n+\t\t\tif parent_kind.is_some() {\n+\t\t\t\treturn Ok(reference);\n+\t\t\t}\n+\t\t\treader.next();\n+\t\t\tlet extends_type = TypeAnnotation::from_reader_with_config(\n+\t\t\t\treader,\n+\t\t\t\tstate,\n+\t\t\t\toptions,\n+\t\t\t\tSome(TypeOperatorKind::Query),\n+\t\t\t\tstart,\n+\t\t\t)?;\n+\t\t\t// TODO local\n+\t\t\tlet position = reference.get_position().union(extends_type.get_position());\n+\t\t\treference = TypeAnnotation::Extends {\n+\t\t\t\titem: Box::new(reference),\n+\t\t\t\textends: Box::new(extends_type),\n+\t\t\t\tposition,\n+\t\t\t};\n+\t\t}\n+\n+\t\t// Extends, intersections, unions or (special)implicit function literals\n \t\tmatch reader.peek() {\n \t\t\tSome(Token(TSXToken::BitwiseOr, _)) => {\n-\t\t\t\tif matches!(parent_kind, Some(TypeOperatorKind::Query | TypeOperatorKind::Function))\n-\t\t\t\t{\n+\t\t\t\tif let Some(TypeOperatorKind::Query | TypeOperatorKind::Function) = parent_kind {\n \t\t\t\t\treturn Ok(reference);\n \t\t\t\t}\n \t\t\t\tlet mut union_members = vec![reference];\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -796,7 +915,7 @@ impl TypeAnnotation {\n \t\t\t\t\t\treader,\n \t\t\t\t\t\tstate,\n \t\t\t\t\t\toptions,\n-\t\t\t\t\t\tSome(TypeOperatorKind::Union),\n+\t\t\t\t\t\tSome(parent_kind.unwrap_or(TypeOperatorKind::Union)),\n \t\t\t\t\t\tstart,\n \t\t\t\t\t)?);\n \t\t\t\t}\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -808,13 +927,10 @@ impl TypeAnnotation {\n \t\t\t\tOk(Self::Union(union_members, position))\n \t\t\t}\n \t\t\tSome(Token(TSXToken::BitwiseAnd, _)) => {\n-\t\t\t\tif matches!(\n-\t\t\t\t\tparent_kind,\n-\t\t\t\t\tSome(\n-\t\t\t\t\t\tTypeOperatorKind::Union\n-\t\t\t\t\t\t\t| TypeOperatorKind::Query | TypeOperatorKind::Function\n-\t\t\t\t\t)\n-\t\t\t\t) {\n+\t\t\t\tif let Some(\n+\t\t\t\t\tTypeOperatorKind::Union | TypeOperatorKind::Query | TypeOperatorKind::Function,\n+\t\t\t\t) = parent_kind\n+\t\t\t\t{\n \t\t\t\t\treturn Ok(reference);\n \t\t\t\t}\n \t\t\t\tlet mut intersection_members = vec![reference];\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -824,7 +940,7 @@ impl TypeAnnotation {\n \t\t\t\t\t\treader,\n \t\t\t\t\t\tstate,\n \t\t\t\t\t\toptions,\n-\t\t\t\t\t\tSome(TypeOperatorKind::Intersection),\n+\t\t\t\t\t\tSome(parent_kind.unwrap_or(TypeOperatorKind::Intersection)),\n \t\t\t\t\t\tstart,\n \t\t\t\t\t)?);\n \t\t\t\t}\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -837,8 +953,7 @@ impl TypeAnnotation {\n \t\t\t\tOk(Self::Intersection(intersection_members, position))\n \t\t\t}\n \t\t\tSome(Token(TSXToken::Arrow, _)) => {\n-\t\t\t\tif matches!(parent_kind, Some(TypeOperatorKind::Query | TypeOperatorKind::Function))\n-\t\t\t\t{\n+\t\t\t\tif let Some(TypeOperatorKind::Query | TypeOperatorKind::Function) = parent_kind {\n \t\t\t\t\treturn Ok(reference);\n \t\t\t\t}\n \t\t\t\treader.next();\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -309,8 +309,8 @@ impl<T: DestructuringFieldInto> ASTNode for ArrayDestructuringField<T> {\n \t\t\t\t\tdefault_value.to_string_from_buffer(buf, options, local);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tSelf::Comment { content, is_multiline, position: _ } => {\n-\t\t\t\tif options.should_add_comment(*is_multiline && content.starts_with('*')) {\n+\t\t\tSelf::Comment { content, is_multiline: _is_multiline, position: _ } => {\n+\t\t\t\tif options.should_add_comment(content) {\n \t\t\t\t\tbuf.push_str(\"/*\");\n \t\t\t\t\tbuf.push_str(content);\n \t\t\t\t\tbuf.push_str(\"*/\");\ndiff --git a/parser/src/visiting.rs b/parser/src/visiting.rs\n--- a/parser/src/visiting.rs\n+++ b/parser/src/visiting.rs\n@@ -234,7 +234,7 @@ mod ast {\n \t\tsource_map::Span,\n \t\tcrate::TypeAnnotation,\n \t\tcrate::types::Visibility,\n-\t\tcrate::NumberRepresentation,\n+\t\tcrate::number::NumberRepresentation,\n \t\tcrate::expressions::operators::BinaryOperator,\n \t\tcrate::expressions::operators::BinaryAssignmentOperator,\n \t\tcrate::expressions::operators::UnaryOperator,\ndiff --git a/parser/src/visiting.rs b/parser/src/visiting.rs\n--- a/parser/src/visiting.rs\n+++ b/parser/src/visiting.rs\n@@ -242,6 +242,7 @@ mod ast {\n \t\tcrate::expressions::operators::UnaryPostfixAssignmentOperator,\n \t\tcrate::types::InterfaceDeclaration,\n \t\tcrate::types::type_alias::TypeAlias,\n+\t\tcrate::types::type_annotations::IsItem,\n \t\tcrate::types::declare_variable::DeclareVariableDeclaration,\n \t\tcrate::VariableIdentifier,\n \t\tcrate::PropertyReference,\ndiff --git a/parser/src/visiting.rs b/parser/src/visiting.rs\n--- a/parser/src/visiting.rs\n+++ b/parser/src/visiting.rs\n@@ -251,7 +252,6 @@ mod ast {\n \t\tcrate::functions::FunctionHeader,\n \t\tcrate::functions::MethodHeader,\n \t\tcrate::VariableKeyword,\n-\t\tcrate::types::namespace::Namespace,\n \t\tsource_map::SourceId\n \t];\n }\ndiff --git a/src/build.rs b/src/build.rs\n--- a/src/build.rs\n+++ b/src/build.rs\n@@ -89,8 +89,11 @@ pub fn build<T: crate::ReadFromFS>(\n \t\t// TODO For all modules\n \t\tlet keys = data.modules.keys().cloned().collect::<Vec<_>>();\n \n-\t\tlet null_module =\n-\t\t\tparser::Module { items: Default::default(), span: parser::source_map::Nullable::NULL };\n+\t\tlet null_module = parser::Module {\n+\t\t\thashbang_comment: None,\n+\t\t\titems: Default::default(),\n+\t\t\tspan: parser::source_map::Nullable::NULL,\n+\t\t};\n \n \t\tlet mut outputs = Vec::new();\n \ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -333,7 +336,7 @@ pub fn run_cli<T: crate::ReadFromFS, U: crate::WriteToFS, V: crate::CLIInputReso\n \t\t\t}\n \t\t}\n \t\tCompilerSubCommand::Experimental(ExperimentalArguments {\n-\t\t\tnested: ExperimentalSubcommand::Format(FormatArguments { path }),\n+\t\t\tnested: ExperimentalSubcommand::Format(FormatArguments { path, check }),\n \t\t}) => {\n \t\t\tuse parser::{source_map::FileSystem, ASTNode, Module, ToStringOptions};\n \ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -348,7 +351,7 @@ pub fn run_cli<T: crate::ReadFromFS, U: crate::WriteToFS, V: crate::CLIInputReso\n \t\t\t\tparser::source_map::MapFileStore::<parser::source_map::NoPathMap>::default();\n \t\t\tlet source_id = files.new_source_id(path.clone(), input.clone());\n \t\t\tlet res = Module::from_string(\n-\t\t\t\tinput,\n+\t\t\t\tinput.clone(),\n \t\t\t\tParseOptions { retain_blank_lines: true, ..Default::default() },\n \t\t\t);\n \t\t\tmatch res {\ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -358,9 +361,22 @@ pub fn run_cli<T: crate::ReadFromFS, U: crate::WriteToFS, V: crate::CLIInputReso\n \t\t\t\t\t\tinclude_type_annotations: true,\n \t\t\t\t\t\t..Default::default()\n \t\t\t\t\t};\n-\t\t\t\t\tlet _ = fs::write(path.clone(), module.to_string(&options));\n-\t\t\t\t\tprint_to_cli(format_args!(\"Formatted {} \ud83c\udf89\", path.display()));\n-\t\t\t\t\tExitCode::SUCCESS\n+\t\t\t\t\tlet output = module.to_string(&options);\n+\t\t\t\t\tif check {\n+\t\t\t\t\t\tif input == output {\n+\t\t\t\t\t\t\tExitCode::SUCCESS\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tprint_to_cli(format_args!(\n+\t\t\t\t\t\t\t\t\"{}\",\n+\t\t\t\t\t\t\t\tpretty_assertions::StrComparison::new(&input, &output)\n+\t\t\t\t\t\t\t));\n+\t\t\t\t\t\t\tExitCode::FAILURE\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tlet _ = fs::write(path.clone(), output);\n+\t\t\t\t\t\tprint_to_cli(format_args!(\"Formatted {} \ud83c\udf89\", path.display()));\n+\t\t\t\t\t\tExitCode::SUCCESS\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tErr(err) => {\n \t\t\t\t\treport_diagnostics_to_cli(\ndiff --git a/src/repl.rs b/src/repl.rs\n--- a/src/repl.rs\n+++ b/src/repl.rs\n@@ -84,6 +84,7 @@ pub(crate) fn run_repl<U: crate::CLIInputResolver>(\n \t\tlet result = if input.trim_start().starts_with('{') {\n \t\t\tExpression::from_string_with_options(input, options, offset).map(|(expression, _)| {\n \t\t\t\tModule {\n+\t\t\t\t\thashbang_comment: None,\n \t\t\t\t\tspan: expression.get_position(),\n \t\t\t\t\titems: vec![Statement::Expression(expression.into()).into()],\n \t\t\t\t}\n",
        "test_patch": "diff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -3305,14 +3318,15 @@ box(someNumber) satisfies boolean;\n \n #### Template literal type restriction\n \n-> TODO dynamic restriction\n-\n ```ts\n type Name = \"Ben\"\n \"test\" satisfies `Hello ${Name}`;\n+\"Hello Ben\" satisfies `Hello ${Name}`;\n ```\n \n-- Expected \"Hello Ben\", found \"test\"\n+> Should be `Expected \"Hello Ben\", found \"test\"`. See #188\n+\n+- Expected string, found \"test\"\n \n #### Template literal type specialisation\n \ndiff --git a/parser/generator/tests/structures.rs b/parser/generator/tests/structures.rs\n--- a/parser/generator/tests/structures.rs\n+++ b/parser/generator/tests/structures.rs\n@@ -17,7 +17,7 @@ fn expr() {\n \t\t\t\t\t)\n \t\t\t\t),\n \t\t\t\trhs: Expression::NumberLiteral(\n-\t\t\t\t\tezno_parser::NumberRepresentation::from(4f64),\n+\t\t\t\t\tezno_parser::number::NumberRepresentation::from(4f64),\n \t\t\t\t\tsource_map::Nullable::NULL\n \t\t\t\t)\n \t\t\t\t.into(),\ndiff --git a/parser/generator/tests/structures.rs b/parser/generator/tests/structures.rs\n--- a/parser/generator/tests/structures.rs\n+++ b/parser/generator/tests/structures.rs\n@@ -44,7 +44,7 @@ fn stmt_with_expr_interpolation() {\n \t\t\t\t),\n \t\t\t)),\n \t\t\texpression: Some(Expression::NumberLiteral(\n-\t\t\t\tezno_parser::NumberRepresentation::from(-0.8715757724135882),\n+\t\t\t\tezno_parser::number::NumberRepresentation::from(-0.8715757724135882),\n \t\t\t\tsource_map::Nullable::NULL,\n \t\t\t)),\n \t\t\ttype_annotation: None,\ndiff --git a/parser/generator/tests/structures.rs b/parser/generator/tests/structures.rs\n--- a/parser/generator/tests/structures.rs\n+++ b/parser/generator/tests/structures.rs\n@@ -78,7 +78,7 @@ fn stmt_with_var_name_interpolation() {\n \t\t\t\t),\n \t\t\t)),\n \t\t\texpression: Some(Expression::NumberLiteral(\n-\t\t\t\tezno_parser::NumberRepresentation::from(4f64),\n+\t\t\t\tezno_parser::number::NumberRepresentation::from(4f64),\n \t\t\t\tsource_map::Nullable::NULL,\n \t\t\t)),\n \t\t\ttype_annotation: None,\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -2491,7 +2494,9 @@ pub(crate) fn chain_to_string_from_buffer<T: source_map::ToString>(\n #[cfg(test)]\n mod tests {\n \tuse super::{ASTNode, BinaryOperator, Expression, Expression::*, MultipleExpression};\n-\tuse crate::{assert_matches_ast, ast::FunctionArgument, span, NumberRepresentation, Quoted};\n+\tuse crate::{\n+\t\tassert_matches_ast, ast::FunctionArgument, number::NumberRepresentation, span, Quoted,\n+\t};\n \n \t#[test]\n \tfn literal() {\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1160,11 +1275,14 @@ impl ListItem for TupleLiteralElement {\n #[cfg(test)]\n mod tests {\n \tuse super::*;\n-\tuse crate::{assert_matches_ast, span, NumberRepresentation};\n+\tuse crate::{assert_matches_ast, number::NumberRepresentation, span};\n \n \t#[test]\n \tfn name() {\n-\t\tassert_matches_ast!(\"something\", TypeAnnotation::Name(Deref @ \"something\", span!(0, 9)));\n+\t\tassert_matches_ast!(\n+\t\t\t\"something\",\n+\t\t\tTypeAnnotation::Name(TypeName::Name(Deref @ \"something\"), span!(0, 9))\n+\t\t);\n \t\tassert_matches_ast!(\"string\", TypeAnnotation::CommonName(CommonTypes::String, span!(0, 6)));\n \t}\n \ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1186,7 +1304,7 @@ mod tests {\n \t\tassert_matches_ast!(\n \t\t\t\"Array<string>\",\n \t\t\tTypeAnnotation::NameWithGenericArguments(\n-\t\t\t\tDeref @ \"Array\",\n+\t\t\t\tTypeName::Name(Deref @ \"Array\"),\n \t\t\t\tDeref @ [TypeAnnotation::CommonName(CommonTypes::String, span!(6, 12))],\n \t\t\t\tspan!(0, 13),\n \t\t\t)\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1195,7 +1313,7 @@ mod tests {\n \t\tassert_matches_ast!(\n \t\t\t\"Map<string, number>\",\n \t\t\tTypeAnnotation::NameWithGenericArguments(\n-\t\t\t\tDeref @ \"Map\",\n+\t\t\t\tTypeName::Name(Deref @ \"Map\"),\n \t\t\t\tDeref @\n \t\t\t\t[TypeAnnotation::CommonName(CommonTypes::String, span!(4, 10)), TypeAnnotation::CommonName(CommonTypes::Number, span!(12, 18))],\n \t\t\t\tspan!(0, 19),\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1205,9 +1323,9 @@ mod tests {\n \t\tassert_matches_ast!(\n \t\t\t\"Array<Array<string>>\",\n \t\t\tTypeAnnotation::NameWithGenericArguments(\n-\t\t\t\tDeref @ \"Array\",\n+\t\t\t\tTypeName::Name(Deref @ \"Array\"),\n \t\t\t\tDeref @ [TypeAnnotation::NameWithGenericArguments(\n-\t\t\t\t\tDeref @ \"Array\",\n+\t\t\t\t\tTypeName::Name(Deref @ \"Array\"),\n \t\t\t\t\tDeref @ [TypeAnnotation::CommonName(CommonTypes::String, span!(12, 18))],\n \t\t\t\t\tspan!(6, 19),\n \t\t\t\t)],\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1286,7 +1404,7 @@ mod tests {\n \t\t\t\t\tparameters: Deref @ [ TypeAnnotationFunctionParameter { .. } ],\n \t\t\t\t\t..\n \t\t\t\t},\n-\t\t\t\treturn_type: Deref @ TypeAnnotation::Name(Deref @ \"T\", span!(5, 6)),\n+\t\t\t\treturn_type: Deref @ TypeAnnotation::Name(TypeName::Name(Deref @ \"T\"), span!(5, 6)),\n \t\t\t\t..\n \t\t\t}\n \t\t);\ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1297,16 +1415,15 @@ mod tests {\n \tfn template_literal() {\n \t\tassert_matches_ast!(\n \t\t\t\"`test-${X}`\",\n-\t\t\tTypeAnnotation::TemplateLiteral(\n-\t\t\t\tDeref\n-\t\t\t\t@ [TemplateLiteralPart::Static(Deref @ \"test-\"), TemplateLiteralPart::Dynamic(\n-\t\t\t\t\tDeref @ AnnotationWithBinder::NoAnnotation(TypeAnnotation::Name(\n-\t\t\t\t\t\tDeref @ \"X\",\n-\t\t\t\t\t\tspan!(8, 9),\n-\t\t\t\t\t)),\n-\t\t\t\t)],\n-\t\t\t\t_,\n-\t\t\t)\n+\t\t\tTypeAnnotation::TemplateLiteral {\n+\t\t\t\tparts: Deref @ [\n+\t\t\t\t\t(\n+\t\t\t\t\t\tDeref @ \"test-\",\n+\t\t\t\t\t\tAnnotationWithBinder::NoAnnotation(TypeAnnotation::Name(TypeName::Name(Deref @ \"X\"), span!(8, 9)))\n+\t\t\t\t\t)\n+\t\t\t\t],\n+\t\t\t\t..\n+\t\t\t}\n \t\t);\n \t}\n \ndiff --git a/parser/src/types/type_annotations.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_annotations.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1325,7 +1442,7 @@ mod tests {\n \t\t\t\tDeref @ TypeAnnotation::ParenthesizedReference(\n \t\t\t\t\tDeref @ TypeAnnotation::Union(\n \t\t\t\t\t\tDeref @\n-\t\t\t\t\t\t[TypeAnnotation::CommonName(CommonTypes::Number, span!(1, 7)), TypeAnnotation::Name(Deref @ \"null\", span!(10, 14))],\n+\t\t\t\t\t\t[TypeAnnotation::CommonName(CommonTypes::Number, span!(1, 7)), TypeAnnotation::CommonName(CommonTypes::Null, span!(10, 14))],\n \t\t\t\t\t\t_,\n \t\t\t\t\t),\n \t\t\t\t\tspan!(0, 15),\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -755,7 +755,7 @@ mod tests {\n \t\t\t\t\tNone,\n \t\t\t\t\tSome(\n \t\t\t\t\t\tDeref @ Expression::NumberLiteral(\n-\t\t\t\t\t\t\tcrate::NumberRepresentation::Number { .. },\n+\t\t\t\t\t\t\tcrate::number::NumberRepresentation::Number { .. },\n \t\t\t\t\t\t\tspan!(6, 7),\n \t\t\t\t\t\t),\n \t\t\t\t\t),\ndiff --git a/parser/tests/expressions.rs b/parser/tests/expressions.rs\n--- a/parser/tests/expressions.rs\n+++ b/parser/tests/expressions.rs\n@@ -152,3 +152,35 @@ function Component(item) {\n \n \tassert_eq!(output, input);\n }\n+\n+#[test]\n+fn regex_and_leading_decimal() {\n+\tlet input = r#\"\n+for (const x in 0.4) {}\n+for await (const [a] of 0.2) {}\n+for (const result of /thing/) {}\n+\"#\n+\t.trim();\n+\n+\tlet module = Module::from_string(input.to_owned(), Default::default()).unwrap();\n+\n+\teprintln!(\"Module: {module:#?}\");\n+\n+\tlet output = module.to_string(&ezno_parser::ToStringOptions::typescript());\n+\tassert_eq!(output, input);\n+}\n+\n+#[test]\n+fn class_and_object_divides() {\n+\tlet input = r#\"\n+const b = class Number {} / 2\n+\"#\n+\t.trim();\n+\n+\tlet module = Module::from_string(input.to_owned(), Default::default()).unwrap();\n+\n+\teprintln!(\"Module: {module:#?}\");\n+\n+\tlet output = module.to_string(&ezno_parser::ToStringOptions::typescript());\n+\tassert_eq!(output, input);\n+}\ndiff --git a/parser/tests/statements_and_declarations.rs b/parser/tests/statements_and_declarations.rs\n--- a/parser/tests/statements_and_declarations.rs\n+++ b/parser/tests/statements_and_declarations.rs\n@@ -109,9 +109,9 @@ import { export1 } from \"module-name\";\n import { export1 as alias1 } from \"module-name\";\n import { default as alias } from \"module-name\";\n import { export1, export2 } from \"module-name\";\n-import { export1, export2 as alias2, /* \u2026 */ } from \"module-name\";\n+import { export2 as alias2, export1 } from \"module-name\";\n import { \"string name\" as alias } from \"module-name\";\n-import defaultExport, { export1, /* \u2026 */ } from \"module-name\";\n+import defaultExport, { export1 } from \"module-name\";\n import defaultExport, * as name from \"module-name\";\n import \"module-name\"\"#\n \t\t.trim_start();\ndiff --git a/parser/tests/statements_and_declarations.rs b/parser/tests/statements_and_declarations.rs\n--- a/parser/tests/statements_and_declarations.rs\n+++ b/parser/tests/statements_and_declarations.rs\n@@ -135,45 +135,36 @@ fn exports() {\n \t// Taken from MDN\n \tlet input = r#\"\n // Exporting declarations\n-export let name1, name2 /*, \u2026 */;\n-export const name1 = 1, name2 = 2 /*, \u2026 */;\n-export function functionName() { \n-    /* \u2026 */ \n+export let name1, name2;\n+export const name1 = 1, name2 = 2;\n+export function functionName() {  \n }\n export class ClassName { \n-    /* \u2026 */\n }\n-export function* generatorFunctionName() { \n-    /* \u2026 */ \n+export function* generatorFunctionName() {  \n }\n export const { name1, name2: bar } = o;\n export const [ name1, name2 ] = array;\n \n // Export list\n-export { name1, /* \u2026, */ nameN };\n-export { variable1 as name1, variable2 as name2, /* \u2026, */ nameN };\n+export { name1, nameN };\n+export { variable1 as name1, variable2 as name2, nameN };\n export { variable1 as \"string name\" };\n-export { name1 as default /*, \u2026 */ };\n+export { name1 as default };\n \n // Default exports\n export default expression;\n export default function functionName() { \n-    /* \u2026 */\n }\n-export default class ClassName { \n-    /* \u2026 */ \n+export default class ClassName {  \n }\n-export default function* generatorFunctionName() { \n-    /* \u2026 */ \n+export default function* generatorFunctionName() {  \n }\n-export default function () { \n-    /* \u2026 */ \n+export default function () {  \n }\n-export default class { \n-    /* \u2026 */ \n+export default class {  \n }\n-export default function* () { \n-    /* \u2026 */ \n+export default function* () {  \n }\n \n export interface X { property: number }\ndiff --git a/parser/tests/statements_and_declarations.rs b/parser/tests/statements_and_declarations.rs\n--- a/parser/tests/statements_and_declarations.rs\n+++ b/parser/tests/statements_and_declarations.rs\n@@ -181,11 +172,11 @@ export interface X { property: number }\n // Aggregating modules\n export * from \"module-name\";\n export * as name1 from \"module-name\";\n-export { name1, /* \u2026, */ nameN } from \"module-name\";\n-export { import1 as name1, import2 as name2, /* \u2026, */ nameN } from \"module-name\";\n-export { default, /* \u2026, */ } from \"module-name\";\n+export { name1, nameN } from \"module-name\";\n+export { import1 as name1, import2 as name2, nameN } from \"module-name\";\n+export { default } from \"module-name\";\n export { default as name1 } from \"module-name\";\n-export type { name1, /* \u2026, */ nameN } from \"module-name\";\"#\n+export type { name1, nameN } from \"module-name\";\"#\n \t\t.trim_start();\n \n \tlet _module = Module::from_string(input.to_owned(), Default::default()).unwrap();\ndiff --git a/parser/tests/statements_and_declarations.rs b/parser/tests/statements_and_declarations.rs\n--- a/parser/tests/statements_and_declarations.rs\n+++ b/parser/tests/statements_and_declarations.rs\n@@ -215,7 +206,7 @@ from \"module-name\" import defaultExport;\n from \"module-name\" import * as name;\n from \"module-name\" import { export1 };\n from \"module-name\" import { export1, export2 };\n-from \"module-name\" import defaultExport, { export1, /* \u2026 */ };\n+from \"module-name\" import defaultExport, { export1 };\n from \"module-name\" import defaultExport, * as name;\n     \"#\n \t.trim();\ndiff --git a/parser/tests/statements_and_declarations.rs b/parser/tests/statements_and_declarations.rs\n--- a/parser/tests/statements_and_declarations.rs\n+++ b/parser/tests/statements_and_declarations.rs\n@@ -293,3 +284,18 @@ let a, b, a1, b1, c, d, rest, pop, push;\n \tlet output = module.to_string(&ezno_parser::ToStringOptions::typescript());\n \tassert_eq!(output, input);\n }\n+\n+#[test]\n+fn comments() {\n+\tlet input = r\"#!/usr/bin/env node\n+// Hi\n+\"\n+\t.trim();\n+\n+\tlet module = Module::from_string(input.to_owned(), Default::default()).unwrap();\n+\n+\teprintln!(\"Module: {module:#?}\");\n+\n+\tlet output = module.to_string(&ezno_parser::ToStringOptions::typescript());\n+\tassert_eq!(output, input);\n+}\ndiff --git a/parser/tests/type_annotations.rs b/parser/tests/type_annotations.rs\n--- a/parser/tests/type_annotations.rs\n+++ b/parser/tests/type_annotations.rs\n@@ -131,13 +131,31 @@ type Record<T extends string, V> = { [P in T]: V };\n type Something<T extends string, V> = { [P in T as `get${P}`]: V };\n type Something<T, V extends keyof T> = { [P in keyof T]: V }\n \"#\n-\t.trim()\n-\t.replace(\"    \", \"\\t\");\n+\t.trim();\n \n \tlet parse_options = ParseOptions { type_definition_module: true, ..Default::default() };\n \n-\tlet module = Module::from_string(input.clone(), parse_options).unwrap();\n+\tlet module = Module::from_string(input.to_owned(), parse_options).unwrap();\n \tlet output = module.to_string(&ToStringOptions::typescript());\n \n-\tassert_eq!(output, input.clone());\n+\tassert_eq!(output, input);\n+}\n+\n+// Currently broken #165\n+#[test]\n+#[ignore]\n+fn jsx_nuances() {\n+\tlet input = r#\"\n+function x(a: <T>(a: number, b: T) => T) {}\n+\n+type B<T extends boolean> = T ? string : <U>(a: number, b: U) => T;\n+\"#\n+\t.trim();\n+\n+\tlet parse_options = ParseOptions { jsx: true, ..Default::default() };\n+\n+\tlet module = Module::from_string(input.to_owned(), parse_options).unwrap();\n+\tlet output = module.to_string(&ToStringOptions::typescript());\n+\n+\tassert_eq!(output, input);\n }\ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -133,6 +133,9 @@ pub(crate) struct FormatArguments {\n \t/// path to input file\n \t#[argh(positional)]\n \tpub path: PathBuf,\n+\t/// check whether file is formatted\n+\t#[argh(switch)]\n+\tpub check: bool,\n }\n \n /// Upgrade/update the ezno binary to the latest version\n",
        "problem_statement": "Error on hashbang\nezno does not tolerate Hashbang Comments.\r\n```js\r\n#!/usr/bin/env node\r\n\r\nconsole.log(\"hello\")\r\n```\r\n\r\nThese are permitted at the beginning of a script as of ECMAScript 2023\r\nhttps://262.ecma-international.org/15.0/index.html#sec-hashbang\r\n\r\n```\r\nerror: \r\n  \u250c\u2500 ./my/script.js:1:2\r\n  \u2502\r\n1 \u2502 #!/usr/bin/env node\r\n  \u2502  ^^ Expected identifier at private in expression, found LogicalNot\r\n```\n",
        "hints_text": "",
        "created_at": "2024-07-10T20:07:52Z",
        "version": "0.0"
    },
    {
        "repo": "kaleidawave/ezno",
        "pull_number": 31,
        "instance_id": "kaleidawave__ezno-31",
        "issue_numbers": [
            "32"
        ],
        "base_commit": "c36380a52b100ffe3462d7a335126e14e34e7727",
        "patch": "diff --git a/checker/src/behavior/assignments.rs b/checker/src/behavior/assignments.rs\n--- a/checker/src/behavior/assignments.rs\n+++ b/checker/src/behavior/assignments.rs\n@@ -1,159 +1,52 @@\n+use source_map::Span;\n+\n use crate::{structures::operators, CheckingData, Environment, TypeId};\n \n-pub enum ResultOfAssignment {\n-\tNewValue(TypeId),\n-\tNewValueAndAReturnValue(TypeId, TypeId),\n+pub enum Assignable {\n+\tReference(Reference),\n+\tObjectDestructuring(Vec<(TypeId, Reference)>),\n+\tArrayDestructuring(Vec<Reference>),\n }\n \n-pub trait AssignmentBehavior<T> {\n-\t/// Returns two values:\n-\t/// 1) the new value of the variable and returns\n-\t/// 2) second value returned from the expression. None = first type\n-\t/// TODO use [ResultOfAssignment]\n-\tfn get_new_value<U: crate::FSResolver>(\n-\t\tself,\n-\t\tassignee_type: TypeId,\n-\t\tenvironment: &mut Environment,\n-\t\tchecking_data: &mut CheckingData<U>,\n-\t\tother: impl SynthesizeExpression<T>,\n-\t) -> ResultOfAssignment;\n-\n-\t/// Bool whether to evaluate LHS if updating expression. e.g. `x++` or `x -= 2` are true\n-\tfn based_off_existing(&self) -> bool;\n+// TODO copy, when span copy\n+#[derive(Clone)]\n+pub enum Reference {\n+\tVariable(String, Span),\n+\tProperty { on: TypeId, with: TypeId, span: Span },\n }\n \n-// TODO\n-pub trait SynthesizeExpression<T> {\n-\tfn synthesize_expression<U: crate::FSResolver>(\n-\t\titem: T,\n-\t\tenvironment: &mut Environment,\n-\t\tchecking_data: &mut CheckingData<U>,\n-\t) -> TypeId;\n-}\n-\n-pub(super) struct BinaryAssignment<'a, T> {\n-\t// None == straight assignment... TODO better way\n-\tpub operator: Option<operators::BinaryOperator>,\n-\tpub rhs: &'a mut T,\n-}\n-\n-impl<'a, U> AssignmentBehavior<U> for BinaryAssignment<'a, U> {\n-\tfn get_new_value<T: crate::FSResolver>(\n-\t\tself,\n-\t\tassignee_type: TypeId,\n-\t\tenvironment: &mut Environment,\n-\t\tchecking_data: &mut CheckingData<T>,\n-\t\tother: impl SynthesizeExpression<U>,\n-\t) -> ResultOfAssignment {\n-\t\ttodo!()\n-\t\t// let value = synthesize_expression(self.rhs, environment, checking_data, chain);\n-\t\t// let new_value = if let Some(operator) = self.operator {\n-\t\t// \tlet operator: operators::BinaryOperator = operator.into();\n-\t\t// \tlet operator = super::parser_binary_operator_to_others(operator);\n-\t\t// \tlet evaluate_binary_operator = evaluate_binary_operator(\n-\t\t// \t\toperator,\n-\t\t// \t\tassignee_type,\n-\t\t// \t\tvalue,\n-\t\t// \t\tenvironment,\n-\t\t// \t\tchecking_data.settings.strict_casts,\n-\t\t// \t\t&mut checking_data.types,\n-\t\t// \t);\n-\n-\t\t// \tif let Ok(value) = evaluate_binary_operator {\n-\t\t// \t\tvalue\n-\t\t// \t} else {\n-\t\t// \t\ttodo!(\"Add error to checking_data\")\n-\t\t// \t}\n-\t\t// } else {\n-\t\t// \tvalue\n-\t\t// };\n-\t\t// (new_value, None)\n-\t}\n-\n-\tfn based_off_existing(&self) -> bool {\n-\t\tself.operator.is_some()\n-\t}\n+/// Increment and decrement are are not binary add subtract as they cast their lhs to number\n+pub enum AssignmentKind {\n+\tAssign,\n+\tUpdate(operators::BinaryOperator),\n+\tIncrementOrDecrement(IncrementOrDecrement, AssignmentReturnStatus),\n }\n \n-pub(crate) struct PostfixUnaryAssignment {\n-\tpub operator: operators::UnaryOperator,\n+pub enum IncrementOrDecrement {\n+\tIncrement,\n+\tDecrement,\n }\n \n-pub(crate) struct PrefixUnaryAssignment {\n-\tpub operator: operators::UnaryOperator,\n+pub enum AssignmentReturnStatus {\n+\tPrevious,\n+\tNew,\n }\n \n-impl<U> AssignmentBehavior<U> for PrefixUnaryAssignment {\n-\tfn get_new_value<T: crate::FSResolver>(\n-\t\tself,\n-\t\tassignee_type: TypeId,\n-\t\tenvironment: &mut Environment,\n-\t\tchecking_data: &mut CheckingData<T>,\n-\t\tother: impl SynthesizeExpression<U>,\n-\t) -> ResultOfAssignment {\n-\t\ttodo!()\n-\n-\t\t// let new_value = match self.operator {\n-\t\t// \tUnaryPrefixAssignmentOperator::Invert => evaluate_unary_operator(\n-\t\t// \t\toperators::UnaryOperator::LogicalNegation,\n-\t\t// \t\tassignee_type,\n-\t\t// \t\tenvironment,\n-\t\t// \t\tchecking_data.settings.strict_casts,\n-\t\t// \t\t&mut checking_data.types,\n-\t\t// \t)\n-\t\t// \t.unwrap(),\n-\t\t// \tUnaryPrefixAssignmentOperator::IncrementOrDecrement(direction) => {\n-\t\t// \t\t// TODO want to down level this += or -= 1; but that function takes an expression not a type.\n-\t\t// \t\t// TODO error handling\n-\t\t// \t\tlet rhs =\n-\t\t// \t\t\tchecking_data.types.new_constant_type(Constant::Number(1.try_into().unwrap()));\n-\t\t// \t\tlet operator = match direction {\n-\t\t// \t\t\tparser::operators::IncrementOrDecrement::Increment => {\n-\t\t// \t\t\t\toperators::BinaryOperator::Add\n-\t\t// \t\t\t}\n-\t\t// \t\t\tparser::operators::IncrementOrDecrement::Decrement => todo!(),\n-\t\t// \t\t};\n-\t\t// \t\tevaluate_binary_operator(\n-\t\t// \t\t\toperator,\n-\t\t// \t\t\tassignee_type,\n-\t\t// \t\t\trhs,\n-\t\t// \t\t\tenvironment,\n-\t\t// \t\t\tchecking_data.settings.strict_casts,\n-\t\t// \t\t\t&mut checking_data.types,\n-\t\t// \t\t)\n-\t\t// \t\t.unwrap()\n-\t\t// \t}\n-\t\t// };\n-\n-\t\t// (new_value, Some(new_value))\n-\t}\n-\n-\tfn based_off_existing(&self) -> bool {\n-\t\ttrue\n+impl Reference {\n+\tpub fn get_position(&self) -> Span {\n+\t\tmatch self {\n+\t\t\tReference::Variable(_, span) | Reference::Property { span, .. } => span.clone(),\n+\t\t}\n \t}\n }\n \n-impl<U> AssignmentBehavior<U> for PostfixUnaryAssignment {\n-\tfn get_new_value<T: crate::FSResolver>(\n-\t\tself,\n-\t\tassignee_type: TypeId,\n+// TODO\n+pub trait SynthesizableExpression {\n+\tfn synthesize_expression<U: crate::FSResolver>(\n+\t\t&self,\n \t\tenvironment: &mut Environment,\n-\t\tchecking_data: &mut CheckingData<T>,\n-\t\tother: impl SynthesizeExpression<U>,\n-\t) -> ResultOfAssignment {\n-\t\ttodo!()\n-\t\t// let update = AssignmentBehavior::get_new_value(\n-\t\t// \tPrefixUnaryAssignment { operator: todo!(\"self.operator.0,\") },\n-\t\t// \tassignee_type,\n-\t\t// \tenvironment,\n-\t\t// \tchecking_data,\n-\t\t// \tchain,\n-\t\t// );\n-\n-\t\t// (update.0, Some(assignee_type))\n-\t}\n+\t\tchecking_data: &mut CheckingData<U>,\n+\t) -> TypeId;\n \n-\tfn based_off_existing(&self) -> bool {\n-\t\ttrue\n-\t}\n+\tfn get_position(&self) -> Span;\n }\ndiff --git a/checker/src/behavior/functions.rs b/checker/src/behavior/functions.rs\n--- a/checker/src/behavior/functions.rs\n+++ b/checker/src/behavior/functions.rs\n@@ -1,18 +1,120 @@\n+use source_map::Span;\n+\n use crate::{\n-\tstructures::parameters::SynthesizedParameters,\n-\ttypes::poly_types::GenericFunctionTypeParameters, CheckingData, Environment, FSResolver,\n-\tTypeId,\n+\tcontext::{Context, ContextType, FunctionId, VariableId},\n+\tstructures::{functions::FunctionType, parameters::SynthesizedParameters},\n+\ttypes::{poly_types::GenericTypeParameters, properties::Property, FunctionNature, TypeStore},\n+\tCheckingData, Environment, FSResolver, Type, TypeId,\n };\n \n+#[derive(Copy, Clone, Debug, binary_serialize_derive::BinarySerializable)]\n+pub enum GetSetGeneratorOrNone {\n+\tGet,\n+\tSet,\n+\tGenerator,\n+\tNone,\n+}\n+\n+pub trait RegisterBehavior {\n+\ttype Return;\n+\n+\t/// TODO lift T\n+\tfn func<T: SynthesizableFunction, U: ContextType>(\n+\t\t&self,\n+\t\tfunc: &T,\n+\t\tfunc_ty: FunctionType,\n+\t\tenvironment: &mut Context<U>,\n+\t\ttypes: &mut TypeStore,\n+\t) -> Self::Return;\n+}\n+\n+pub struct RegisterAsType;\n+\n+impl RegisterBehavior for RegisterAsType {\n+\ttype Return = TypeId;\n+\n+\tfn func<T: SynthesizableFunction, U: ContextType>(\n+\t\t&self,\n+\t\tfunc: &T,\n+\t\tfunc_ty: FunctionType,\n+\t\tenvironment: &mut Context<U>,\n+\t\ttypes: &mut TypeStore,\n+\t) -> Self::Return {\n+\t\ttypes.register_type(crate::Type::Function(\n+\t\t\tfunc_ty,\n+\t\t\tcrate::types::FunctionNature::Source(func.id(), None),\n+\t\t))\n+\t}\n+}\n+\n+/// Because of hoisting\n+pub struct RegisterOnExisting(pub String);\n+\n+impl RegisterBehavior for RegisterOnExisting {\n+\ttype Return = ();\n+\n+\tfn func<T: SynthesizableFunction, U: ContextType>(\n+\t\t&self,\n+\t\tfunc: &T,\n+\t\tfunc_ty: FunctionType,\n+\t\tenvironment: &mut Context<U>,\n+\t\ttypes: &mut TypeStore,\n+\t) -> Self::Return {\n+\t\tlet ty = types.register_type(crate::Type::Function(\n+\t\t\tfunc_ty,\n+\t\t\tcrate::types::FunctionNature::Source(func.id(), None),\n+\t\t));\n+\t\tlet variable_id = environment.variables.get(&self.0).unwrap().declared_at.clone();\n+\t\tenvironment.variable_current_value.insert(VariableId(variable_id), ty);\n+\t}\n+}\n+\n+pub struct RegisterOnExistingObject;\n+\n+impl RegisterBehavior for RegisterOnExistingObject {\n+\ttype Return = Property;\n+\n+\tfn func<T: SynthesizableFunction, U: ContextType>(\n+\t\t&self,\n+\t\tfunc: &T,\n+\t\tfunc_ty: FunctionType,\n+\t\tenvironment: &mut Context<U>,\n+\t\ttypes: &mut TypeStore,\n+\t) -> Self::Return {\n+\t\tmatch func.get_set_generator_or_none() {\n+\t\t\tcrate::GetSetGeneratorOrNone::Get => Property::Get(Box::new(func_ty)),\n+\t\t\tcrate::GetSetGeneratorOrNone::Set => Property::Set(Box::new(func_ty)),\n+\t\t\tcrate::GetSetGeneratorOrNone::Generator | crate::GetSetGeneratorOrNone::None => {\n+\t\t\t\tlet ty = Type::Function(func_ty, FunctionNature::Source(func.id(), None));\n+\t\t\t\tlet ty = types.register_type(ty);\n+\t\t\t\tProperty::Value(ty)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n pub trait SynthesizableFunction {\n \tfn is_declare(&self) -> bool;\n \n+\tfn is_async(&self) -> bool;\n+\n+\tfn get_set_generator_or_none(&self) -> GetSetGeneratorOrNone;\n+\n+\tfn id(&self) -> FunctionId;\n+\n \t/// **THIS FUNCTION IS EXPECTED TO PUT THE TYPE PARAMETERS INTO THE ENVIRONMENT WHILE SYNTHESIZING THEM**\n \tfn type_parameters<T: FSResolver>(\n \t\t&self,\n \t\tenvironment: &mut Environment,\n \t\tchecking_data: &mut CheckingData<T>,\n-\t) -> GenericFunctionTypeParameters;\n+\t) -> Option<GenericTypeParameters>;\n+\n+\t/// Has to be the first parameter\n+\tfn this_constraint<T: FSResolver>(\n+\t\t&self,\n+\t\tenvironment: &mut Environment,\n+\t\tchecking_data: &mut CheckingData<T>,\n+\t) -> Option<TypeId>;\n \n \t/// **THIS FUNCTION IS EXPECTED TO PUT THE PARAMETERS INTO THE ENVIRONMENT WHILE SYNTHESIZING THEM**\n \tfn parameters<T: FSResolver>(\ndiff --git a/checker/src/behavior/functions.rs b/checker/src/behavior/functions.rs\n--- a/checker/src/behavior/functions.rs\n+++ b/checker/src/behavior/functions.rs\n@@ -21,15 +123,16 @@ pub trait SynthesizableFunction {\n \t\tchecking_data: &mut CheckingData<T>,\n \t) -> SynthesizedParameters;\n \n+\t/// Returned type is extracted from events, thus doesn't expect anything in return\n \tfn body<T: FSResolver>(\n \t\t&self,\n \t\tenvironment: &mut Environment,\n \t\tchecking_data: &mut CheckingData<T>,\n \t);\n \n-\tfn return_type<T: FSResolver>(\n+\tfn return_type_annotation<T: FSResolver>(\n \t\t&self,\n \t\tenvironment: &mut Environment,\n \t\tchecking_data: &mut CheckingData<T>,\n-\t) -> Option<TypeId>;\n+\t) -> Option<(TypeId, Span)>;\n }\ndiff --git a/checker/src/behavior/variables.rs b/checker/src/behavior/variables.rs\n--- a/checker/src/behavior/variables.rs\n+++ b/checker/src/behavior/variables.rs\n@@ -1,5 +1,6 @@\n use source_map::Span;\n \n+use crate::context::AssignmentError;\n use crate::{CheckingData, TypeId};\n \n pub fn check_variable_initialization<T: crate::FSResolver>(\ndiff --git a/checker/src/behavior/variables.rs b/checker/src/behavior/variables.rs\n--- a/checker/src/behavior/variables.rs\n+++ b/checker/src/behavior/variables.rs\n@@ -23,22 +24,23 @@ pub fn check_variable_initialization<T: crate::FSResolver>(\n \t);\n \n \tif let SubTypeResult::IsNotSubType(matches) = type_is_subtype {\n-\t\tlet error = crate::errors::TypeCheckError::InvalidAssignmentOrDeclaration {\n-\t\t\tvariable_type: crate::errors::TypeStringRepresentation::from_type_id(\n-\t\t\t\tvariable_declared_type,\n-\t\t\t\t&environment.into_general_environment(),\n-\t\t\t\t&checking_data.types,\n-\t\t\t\tchecking_data.settings.debug_types,\n-\t\t\t),\n-\t\t\tvariable_site: basic_subtyping.position,\n-\t\t\tvalue_type: crate::errors::TypeStringRepresentation::from_type_id(\n-\t\t\t\texpression_type,\n-\t\t\t\t&environment.into_general_environment(),\n-\t\t\t\t&checking_data.types,\n-\t\t\t\tchecking_data.settings.debug_types,\n-\t\t\t),\n-\t\t\tvalue_site: expression_declared_pos.into_owned(),\n-\t\t};\n+\t\tlet error =\n+\t\t\tcrate::errors::TypeCheckError::AssignmentError(AssignmentError::InvalidDeclaration {\n+\t\t\t\tvariable_type: crate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\tvariable_declared_type,\n+\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\tchecking_data.settings.debug_types,\n+\t\t\t\t),\n+\t\t\t\tvariable_site: basic_subtyping.position,\n+\t\t\t\tvalue_type: crate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\texpression_type,\n+\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\tchecking_data.settings.debug_types,\n+\t\t\t\t),\n+\t\t\t\tvalue_site: expression_declared_pos.into_owned(),\n+\t\t\t});\n \n \t\tchecking_data.diagnostics_container.add_error(error);\n \t}\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -1,14 +1,18 @@\n-use std::collections::HashMap;\n-\n use source_map::Span;\n+use std::collections::HashMap;\n \n use crate::{\n-\terrors::TypeCheckError,\n-\tevents::{Event, Reference},\n-\tstructures::variables::{VariableMutability, VariableWithValue},\n+\tbehavior::assignments::{Assignable, AssignmentKind, Reference, SynthesizableExpression},\n+\terrors::{TypeCheckError, TypeStringRepresentation},\n+\tevaluate_binary_operator_handle_errors,\n+\tevents::{Event, RootReference},\n+\tstructures::{\n+\t\toperators::BinaryOperator,\n+\t\tvariables::{VariableMutability, VariableWithValue},\n+\t},\n \tsubtyping::BasicEquality,\n \ttypes::{\n-\t\tproperties::PropertyResult,\n+\t\tproperties::{Property, PropertyResult},\n \t\tsubtyping::{type_is_subtype, SubTypeResult},\n \t\tType, TypeStore,\n \t},\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -16,7 +20,7 @@ use crate::{\n };\n \n use super::{\n-\tContext, ContextType, Environment, GeneralEnvironment, ReassignmentError, SetPropertyError,\n+\tAssignmentError, Context, ContextType, Environment, GeneralEnvironment, SetPropertyError,\n };\n \n #[derive(Debug)]\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -32,7 +36,7 @@ pub struct Syntax<'a> {\n \tpub async_events: Vec<Event>,\n \n \t/// TODO rhs type is what...?\n-\tpub closed_over_variables: HashMap<Reference, TypeId>,\n+\tpub closed_over_references: HashMap<RootReference, TypeId>,\n }\n \n impl<'a> ContextType for Syntax<'a> {\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -84,102 +88,190 @@ pub enum Scope {\n }\n \n impl<'a> Environment<'a> {\n-\tpub fn assign_variable_handle_errors<T: crate::FSResolver>(\n+\t/// Handles all assignments, including updates and destructuring\n+\t///\n+\t/// Will evaluate the expression with the right timing and conditions, including never if short circuit\n+\t///\n+\t/// TODO finish operator. Unify increment and decrement. The RHS span should be fine with Span::NULL ...? Maybe RHS type could be None to accommodate\n+\tpub fn assign_to_assignable_handle_errors<U: crate::FSResolver>(\n+\t\t&mut self,\n+\t\tlhs: Assignable,\n+\t\toperator: AssignmentKind,\n+\t\t// Can be `None` for increment and decrement\n+\t\texpression: Option<&impl SynthesizableExpression>,\n+\t\tassignment_span: Span,\n+\t\tchecking_data: &mut CheckingData<U>,\n+\t) -> TypeId {\n+\t\tmatch lhs {\n+\t\t\tAssignable::Reference(reference) => {\n+\t\t\t\t/// Returns\n+\t\t\t\tfn get_reference<U: crate::FSResolver>(\n+\t\t\t\t\tenv: &mut Environment,\n+\t\t\t\t\treference: Reference,\n+\t\t\t\t\tchecking_data: &mut CheckingData<U>,\n+\t\t\t\t) -> TypeId {\n+\t\t\t\t\tmatch reference {\n+\t\t\t\t\t\tReference::Variable(name, position) => {\n+\t\t\t\t\t\t\tenv.get_variable_or_error(&name, &position, checking_data).unwrap().1\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tReference::Property { on, with, span } => {\n+\t\t\t\t\t\t\tenv.get_property_handle_errors(on, with, checking_data, span)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t/// Returns\n+\t\t\t\tfn set_reference<U: crate::FSResolver>(\n+\t\t\t\t\tenv: &mut Environment,\n+\t\t\t\t\treference: Reference,\n+\t\t\t\t\tnew: TypeId,\n+\t\t\t\t\tchecking_data: &mut CheckingData<U>,\n+\t\t\t\t) -> TypeId {\n+\t\t\t\t\tmatch reference {\n+\t\t\t\t\t\tReference::Variable(name, position) => env\n+\t\t\t\t\t\t\t.assign_to_variable_handle_errors(\n+\t\t\t\t\t\t\t\tname.as_str(),\n+\t\t\t\t\t\t\t\tposition,\n+\t\t\t\t\t\t\t\tnew,\n+\t\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\tReference::Property { on, with, span } => env\n+\t\t\t\t\t\t\t.set_property(on, with, new, &mut checking_data.types)\n+\t\t\t\t\t\t\t.unwrap()\n+\t\t\t\t\t\t\t.unwrap_or(new),\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tmatch operator {\n+\t\t\t\t\tAssignmentKind::Assign => {\n+\t\t\t\t\t\tlet new = expression.unwrap().synthesize_expression(self, checking_data);\n+\t\t\t\t\t\tset_reference(self, reference, new, checking_data)\n+\t\t\t\t\t}\n+\t\t\t\t\tAssignmentKind::Update(operator) => {\n+\t\t\t\t\t\t// Order matters here\n+\t\t\t\t\t\tlet span = reference.get_position();\n+\t\t\t\t\t\tlet existing = get_reference(self, reference.clone(), checking_data);\n+\n+\t\t\t\t\t\tlet expression = expression.unwrap();\n+\t\t\t\t\t\tlet rhs = (\n+\t\t\t\t\t\t\texpression.synthesize_expression(self, checking_data),\n+\t\t\t\t\t\t\texpression.get_position(),\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\tlet new = evaluate_binary_operator_handle_errors(\n+\t\t\t\t\t\t\toperator,\n+\t\t\t\t\t\t\t(existing, span),\n+\t\t\t\t\t\t\trhs,\n+\t\t\t\t\t\t\tself,\n+\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\tset_reference(self, reference, new, checking_data)\n+\t\t\t\t\t}\n+\t\t\t\t\tAssignmentKind::IncrementOrDecrement(direction, return_kind) => {\n+\t\t\t\t\t\t// let value =\n+\t\t\t\t\t\t// \tself.get_variable_or_error(&name, &assignment_span, checking_data);\n+\t\t\t\t\t\tlet span = reference.get_position();\n+\t\t\t\t\t\tlet existing = get_reference(self, reference.clone(), checking_data);\n+\n+\t\t\t\t\t\t// TODO existing needs to be cast to number!!\n+\n+\t\t\t\t\t\tlet new = evaluate_binary_operator_handle_errors(\n+\t\t\t\t\t\t\tmatch direction {\n+\t\t\t\t\t\t\t\tcrate::behavior::assignments::IncrementOrDecrement::Increment => {\n+\t\t\t\t\t\t\t\t\tBinaryOperator::Add\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tcrate::behavior::assignments::IncrementOrDecrement::Decrement => {\n+\t\t\t\t\t\t\t\t\tBinaryOperator::Subtract\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t(existing, span),\n+\t\t\t\t\t\t\t(TypeId::ONE, Span::NULL_SPAN),\n+\t\t\t\t\t\t\tself,\n+\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\tlet new = set_reference(self, reference, new, checking_data);\n+\n+\t\t\t\t\t\tmatch return_kind {\n+\t\t\t\t\t\t\tcrate::behavior::assignments::AssignmentReturnStatus::Previous => {\n+\t\t\t\t\t\t\t\texisting\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tcrate::behavior::assignments::AssignmentReturnStatus::New => new,\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tAssignable::ObjectDestructuring(_) => todo!(),\n+\t\t\tAssignable::ArrayDestructuring(_) => todo!(),\n+\t\t}\n+\t}\n+\n+\tpub fn assign_to_variable_handle_errors<T: crate::FSResolver>(\n \t\t&mut self,\n \t\tvariable_name: &str,\n \t\tassignment_span: Span,\n \t\tnew_type: TypeId,\n \t\tchecking_data: &mut CheckingData<T>,\n \t) -> TypeId {\n-\t\tlet result = self.assign_variable(variable_name, new_type, &checking_data.types);\n+\t\tlet result = self.assign_to_variable(variable_name, new_type, &checking_data.types);\n \t\tmatch result {\n \t\t\tOk(ok) => ok,\n \t\t\tErr(error) => {\n-\t\t\t\tlet error = match error {\n-\t\t\t\t\tReassignmentError::Constant(declared_at) => {\n-\t\t\t\t\t\tTypeCheckError::CannotAssignToConstant {\n-\t\t\t\t\t\t\tvariable_name,\n-\t\t\t\t\t\t\tvariable_position: declared_at,\n-\t\t\t\t\t\t\tassignment_position: assignment_span,\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tReassignmentError::VariableNotFound { variable } => {\n-\t\t\t\t\t\tTypeCheckError::CouldNotFindVariable {\n-\t\t\t\t\t\t\tvariable: variable_name,\n-\t\t\t\t\t\t\tpossibles: Default::default(),\n-\t\t\t\t\t\t\tposition: assignment_span,\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tReassignmentError::DoesNotMatchRestrictionType {\n-\t\t\t\t\t\tvariable_type,\n-\t\t\t\t\t\tvariable_declared_at,\n-\t\t\t\t\t} => TypeCheckError::InvalidAssignmentOrDeclaration {\n-\t\t\t\t\t\tvariable_type: crate::errors::TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\tvariable_type,\n-\t\t\t\t\t\t\t&self.into_general_environment(),\n-\t\t\t\t\t\t\t&checking_data.types,\n-\t\t\t\t\t\t\tfalse,\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tvalue_type: crate::errors::TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\tnew_type,\n-\t\t\t\t\t\t\t&self.into_general_environment(),\n-\t\t\t\t\t\t\t&checking_data.types,\n-\t\t\t\t\t\t\tfalse,\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tvariable_site: variable_declared_at,\n-\t\t\t\t\t\t// TODO not quite right\n-\t\t\t\t\t\tvalue_site: assignment_span,\n-\t\t\t\t\t},\n-\t\t\t\t};\n-\t\t\t\tchecking_data.diagnostics_container.add_error(error);\n+\t\t\t\tchecking_data\n+\t\t\t\t\t.diagnostics_container\n+\t\t\t\t\t.add_error(TypeCheckError::AssignmentError(error));\n \t\t\t\tTypeId::ERROR_TYPE\n \t\t\t}\n \t\t}\n \t}\n \n-\t/// This is top level variables, not properties (for now maybe).\n-\t/// This is also for both updates and initial initialisation\n-\t/// TODO check read has occurred\n-\t///\n-\t/// TODO Event is for...?\n-\t/// TODO setters\n-\tpub fn assign_variable<'b>(\n+\t/// This is top level variables, not properties.\n+\tpub fn assign_to_variable(\n \t\t&mut self,\n-\t\tvariable_name: &'b str,\n+\t\tvariable_name: &str,\n \t\tnew_type: TypeId,\n \t\tstore: &TypeStore,\n-\t) -> Result<TypeId, ReassignmentError<'b>> {\n+\t) -> Result<TypeId, AssignmentError> {\n \t\t// Get without the effects\n \t\tlet variable_in_map = self.get_variable_unbound(variable_name);\n \n \t\tif let Some((_, variable)) = variable_in_map {\n \t\t\tmatch variable.mutability {\n \t\t\t\tVariableMutability::Constant => {\n-\t\t\t\t\treturn Err(ReassignmentError::Constant(variable.declared_at.clone()))\n+\t\t\t\t\treturn Err(AssignmentError::Constant(variable.declared_at.clone()));\n \t\t\t\t}\n \t\t\t\tVariableMutability::Mutable { reassignment_constraint } => {\n \t\t\t\t\tlet variable = variable.clone();\n-\t\t\t\t\t// TODO tuple with position:\n-\t\t\t\t\tlet mut basic_subtyping = BasicEquality {\n-\t\t\t\t\t\tadd_property_restrictions: false,\n-\t\t\t\t\t\tposition: variable.declared_at.clone(),\n-\t\t\t\t\t};\n-\t\t\t\t\tlet result = type_is_subtype(\n-\t\t\t\t\t\treassignment_constraint,\n-\t\t\t\t\t\tnew_type,\n-\t\t\t\t\t\tNone,\n-\t\t\t\t\t\t&mut basic_subtyping,\n-\t\t\t\t\t\tself,\n-\t\t\t\t\t\tstore,\n-\t\t\t\t\t);\n-\t\t\t\t\tif let SubTypeResult::IsNotSubType(mismatches) = result {\n-\t\t\t\t\t\treturn Err(ReassignmentError::DoesNotMatchRestrictionType {\n-\t\t\t\t\t\t\tvariable_declared_at: variable.declared_at.clone(),\n-\t\t\t\t\t\t\tvariable_type: reassignment_constraint,\n-\t\t\t\t\t\t});\n+\n+\t\t\t\t\tif let Some(reassignment_constraint) = reassignment_constraint {\n+\t\t\t\t\t\t// TODO tuple with position:\n+\t\t\t\t\t\tlet mut basic_subtyping = BasicEquality {\n+\t\t\t\t\t\t\tadd_property_restrictions: false,\n+\t\t\t\t\t\t\tposition: variable.declared_at.clone(),\n+\t\t\t\t\t\t};\n+\t\t\t\t\t\tlet result = type_is_subtype(\n+\t\t\t\t\t\t\treassignment_constraint,\n+\t\t\t\t\t\t\tnew_type,\n+\t\t\t\t\t\t\tNone,\n+\t\t\t\t\t\t\t&mut basic_subtyping,\n+\t\t\t\t\t\t\tself,\n+\t\t\t\t\t\t\tstore,\n+\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\tif let SubTypeResult::IsNotSubType(mismatches) = result {\n+\t\t\t\t\t\t\treturn Err(AssignmentError::DoesNotMatchRestrictionType {\n+\t\t\t\t\t\t\t\tvariable_declared_at: variable.declared_at.clone(),\n+\t\t\t\t\t\t\t\tvariable_type: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\treassignment_constraint,\n+\t\t\t\t\t\t\t\t\t&self.into_general_environment(),\n+\t\t\t\t\t\t\t\t\tstore,\n+\t\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \n \t\t\t\t\tlet variable_id = variable.get_id();\n+\n \t\t\t\t\tself.context_type\n \t\t\t\t\t\t.events\n \t\t\t\t\t\t.push(Event::SetsVariable(variable_id.clone(), new_type));\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -190,7 +282,7 @@ impl<'a> Environment<'a> {\n \t\t\t}\n \t\t} else {\n \t\t\tcrate::utils::notify!(\"Could say it is on the window here\");\n-\t\t\tErr(ReassignmentError::VariableNotFound { variable: variable_name })\n+\t\t\tErr(AssignmentError::VariableNotFound { variable: variable_name.to_owned() })\n \t\t}\n \t}\n \ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -233,12 +325,12 @@ impl<'a> Environment<'a> {\n \n \tpub fn get_property_handle_errors<U: crate::FSResolver>(\n \t\t&mut self,\n-\t\tparent: TypeId,\n+\t\ton: TypeId,\n \t\tproperty: TypeId,\n \t\tchecking_data: &mut CheckingData<U>,\n \t\tsite: Span,\n \t) -> TypeId {\n-\t\tmatch self.get_property(parent, property, &mut checking_data.types, None) {\n+\t\tmatch self.get_property(on, property, &mut checking_data.types, None) {\n \t\t\tSome(ty) => ty.into(),\n \t\t\tNone => {\n \t\t\t\tchecking_data.diagnostics_container.add_error(\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -249,8 +341,8 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\t\t&checking_data.types,\n \t\t\t\t\t\t\tfalse,\n \t\t\t\t\t\t),\n-\t\t\t\t\t\tty: crate::errors::TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\tparent,\n+\t\t\t\t\t\ton: crate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\ton,\n \t\t\t\t\t\t\t&self.into_general_environment(),\n \t\t\t\t\t\t\t&checking_data.types,\n \t\t\t\t\t\t\tfalse,\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -287,21 +379,33 @@ impl<'a> Environment<'a> {\n \t\t\t}\n \t\t};\n \n-\t\tlet reference = Reference::VariableId(og_var.get_id());\n+\t\tlet reference = RootReference::VariableId(og_var.get_id());\n \t\t// TODO\n \t\t// let treat_as_in_same_scope = (og_var.is_constant && self.is_immutable(current_value));\n \n \t\tlet (value, reflects_dependency) = if let Some(boundary) = crossed_boundary {\n \t\t\tcrate::utils::notify!(\"Found closed over type\");\n \n+\t\t\tlet based_on = match og_var.mutability {\n+\t\t\t\tVariableMutability::Constant => {\n+\t\t\t\t\ttodo!(\"object constraint\")\n+\t\t\t\t}\n+\t\t\t\tVariableMutability::Mutable { reassignment_constraint } => {\n+\t\t\t\t\tmatch reassignment_constraint {\n+\t\t\t\t\t\tSome(constraint) => crate::types::PolyPointer::Fixed(constraint),\n+\t\t\t\t\t\tNone => todo!(),\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t};\n+\n \t\t\t// TODO\n-\t\t\tlet r#type = Type::RootPolyType(crate::types::PolyNature::ParentScope {\n+\t\t\tlet ty = Type::RootPolyType(crate::types::PolyNature::ParentScope {\n \t\t\t\treference: reference.clone(),\n-\t\t\t\tbased_on: crate::types::PolyPointer::Fixed(TypeId::ERROR_TYPE),\n+\t\t\t\tbased_on,\n \t\t\t});\n-\t\t\tlet type_id = checking_data.types.register_type(r#type);\n+\t\t\tlet type_id = checking_data.types.register_type(ty);\n \t\t\t// TODO what is rhs\n-\t\t\tself.context_type.closed_over_variables.insert(reference, type_id);\n+\t\t\tself.context_type.closed_over_references.insert(reference, type_id);\n \t\t\t// if inferred {\n \t\t\t// \tself.context_type.get_inferrable_constraints_mut().unwrap().insert(type_id);\n \t\t\t// }\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -312,7 +416,7 @@ impl<'a> Environment<'a> {\n \t\t};\n \n \t\tself.context_type.events.push(Event::ReadsReference {\n-\t\t\treference: crate::events::Reference::VariableId(og_var.get_id()),\n+\t\t\treference: crate::events::RootReference::VariableId(og_var.get_id()),\n \t\t\treflects_dependency,\n \t\t});\n \ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -337,7 +441,7 @@ impl<'a> Environment<'a> {\n \t\tnew: TypeId,\n \t\ttypes: &mut TypeStore,\n \t) -> Result<Option<TypeId>, SetPropertyError> {\n-\t\tcrate::types::properties::set_property(self, on, under, new, types)\n+\t\tcrate::types::properties::set_property(self, on, under, Property::Value(new), types)\n \t}\n \n \t/// Initializing\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -345,7 +449,7 @@ impl<'a> Environment<'a> {\n \t\t&mut self,\n \t\ton: TypeId,\n \t\tunder: TypeId,\n-\t\tnew: TypeId,\n+\t\tnew: Property,\n \t\tchecking_data: &mut CheckingData<U>,\n \t) {\n \t\tself.properties.entry(on).or_default().push((under, new));\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -14,15 +14,17 @@ pub(crate) use bases::InferenceBoundary;\n use source_map::Span;\n \n use crate::{\n-\tbehavior,\n-\terrors::{CannotRedeclareVariable, TypeCheckError},\n-\tevents::{Event, Reference},\n+\tbehavior::{self},\n+\terrors::{CannotRedeclareVariable, TypeCheckError, TypeStringRepresentation},\n+\tevents::{Event, RootReference},\n \tstructures::{\n-\t\tfunctions::{FunctionType, SynthesizedFunction},\n+\t\tfunctions::{FunctionKind, FunctionType},\n \t\tvariables::VariableMutability,\n \t},\n+\tsubtyping::{type_is_subtype, BasicEquality},\n \ttypes::{\n-\t\tcast_as_boolean, Constant, Constructor, PolyNature, PolyPointer, Type, TypeId, TypeStore,\n+\t\tcast_as_boolean, properties::Property, Constant, Constructor, PolyNature, PolyPointer,\n+\t\tType, TypeId, TypeStore,\n \t},\n \tutils::{EnforcedOr, EnforcedOrExt},\n \tCheckingData, TruthyFalsy, Variable,\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -173,8 +175,7 @@ pub struct Context<T: ContextType> {\n \t/// TODO explain\n \tpub(crate) tasks_to_run: Vec<(TypeId, FunctionId)>,\n \n-\t/// **Right hand side may be getter**\n-\tpub(crate) properties: HashMap<TypeId, Vec<(TypeId, TypeId)>>,\n+\tpub(crate) properties: HashMap<TypeId, Vec<(TypeId, Property)>>,\n \t/// PropertyValue -> fst[snd]\n \tpub(crate) reverse_properties: HashMap<TypeId, Vec<(TypeId, TypeId)>>,\n \ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -208,7 +209,7 @@ pub enum VariableRegisterBehavior {\n \t},\n \tFunctionParameter {\n \t\t/// TODO what happens to it\n-\t\tbase: TypeId,\n+\t\tannotation: Option<TypeId>,\n \t},\n \t// TODO document behavior\n \tCatchVariable {\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -241,7 +242,7 @@ impl<T: ContextType> Context<T> {\n \t\t// \t\t\tmatch nature {\n \t\t// \t\t\t\tPolyNature::ParentScope { reference } => {\n \t\t// \t\t\t\t\tself.context_type\n-\t\t// \t\t\t\t\t\t.get_closed_over_variables_mut()\n+\t\t// \t\t\t\t\t\t.get_closed_over_references_mut()\n \t\t// \t\t\t\t\t\t.insert(*reference, new_constraint);\n \n \t\t// \t\t\t\t\t*aliases = new_constraint;\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -357,7 +358,7 @@ impl<T: ContextType> Context<T> {\n \t\tbehavior: VariableRegisterBehavior,\n \t\ttypes: &mut TypeStore,\n \t) -> Result<TypeId, CannotRedeclareVariable<'a>> {\n-\t\tlet (existing_variable, r#type) = match behavior {\n+\t\tlet (existing_variable, ty) = match behavior {\n \t\t\tVariableRegisterBehavior::Declare { base } => {\n \t\t\t\t// TODO\n \t\t\t\tlet kind = VariableMutability::Constant;\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -382,27 +383,40 @@ impl<T: ContextType> Context<T> {\n \t\t\t\tself.variable_names.insert(id, name.to_owned());\n \t\t\t\t(self.variables.insert(name.to_owned(), variable), TypeId::ANY_TYPE)\n \t\t\t}\n-\t\t\tVariableRegisterBehavior::FunctionParameter { base } => {\n+\t\t\tVariableRegisterBehavior::FunctionParameter { annotation } => {\n \t\t\t\t// TODO maybe store separately\n \n-\t\t\t\t// TODO mutability constant\n-\t\t\t\tlet variable = Variable {\n-\t\t\t\t\tmutability: VariableMutability::Constant,\n-\t\t\t\t\tdeclared_at: id.0.clone(),\n+\t\t\t\t// TODO via a setting\n+\t\t\t\tconst FUNCTION_PARAM_MUTABLE: bool = true;\n+\t\t\t\tlet mutability = if FUNCTION_PARAM_MUTABLE {\n+\t\t\t\t\tVariableMutability::Mutable { reassignment_constraint: annotation }\n+\t\t\t\t} else {\n+\t\t\t\t\tVariableMutability::Constant\n \t\t\t\t};\n+\t\t\t\tlet variable = Variable { mutability, declared_at: id.0.clone() };\n \t\t\t\tself.variable_names.insert(id.clone(), name.to_owned());\n \t\t\t\tlet existing_variable = self.variables.insert(name.to_owned(), variable);\n-\t\t\t\t// TODO inferred\n-\t\t\t\tlet parameter_ty = types.register_type(Type::RootPolyType(PolyNature::Parameter {\n-\t\t\t\t\tfixed_to: PolyPointer::Fixed(base),\n-\t\t\t\t}));\n+\t\t\t\tlet parameter_ty = if let Some(annotation) = annotation {\n+\t\t\t\t\tif let Type::RootPolyType(_) = types.get_type_by_id(annotation) {\n+\t\t\t\t\t\tannotation\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\ttypes.register_type(Type::RootPolyType(PolyNature::Parameter {\n+\t\t\t\t\t\t\tfixed_to: PolyPointer::Fixed(annotation),\n+\t\t\t\t\t\t}))\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\ttypes.register_type(Type::RootPolyType(PolyNature::Parameter {\n+\t\t\t\t\t\tfixed_to: PolyPointer::Inferred(InferenceBoundary(self.context_id)),\n+\t\t\t\t\t}))\n+\t\t\t\t};\n+\n \t\t\t\tself.variable_current_value.insert(id, parameter_ty);\n \t\t\t\t(existing_variable, parameter_ty)\n \t\t\t}\n \t\t};\n \n \t\tif existing_variable.is_none() {\n-\t\t\tOk(r#type)\n+\t\t\tOk(ty)\n \t\t} else {\n \t\t\tErr(CannotRedeclareVariable { name })\n \t\t}\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -435,7 +449,12 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t\t\tlet to = self\n \t\t\t\t\t\t\t.parents_iter()\n \t\t\t\t\t\t\t.find_map(|ctx| get_env!(ctx.bases.get_local_type_base(on)))\n-\t\t\t\t\t\t\t.unwrap();\n+\t\t\t\t\t\t\t// TODO temp\n+\t\t\t\t\t\t\t.unwrap_or_else(|| {\n+\t\t\t\t\t\t\t\tcrate::utils::notify!(\"No type base on inferred poly type\");\n+\t\t\t\t\t\t\t\tTypeId::ANY_TYPE\n+\t\t\t\t\t\t\t});\n+\n \t\t\t\t\t\tSome(PolyBase::Dynamic { to, boundary })\n \t\t\t\t\t}\n \t\t\t\t}\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -560,7 +579,10 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t\t// TODO temp\n \t\t\t\t\tlet result = self\n \t\t\t\t\t\t.get_property_unbound(on_constraint, property_constraint, types)\n-\t\t\t\t\t\t.map(Logical::to_type)\n+\t\t\t\t\t\t.map(|property| match property {\n+\t\t\t\t\t\t\tLogical::Pure(Property::Value(v)) => v,\n+\t\t\t\t\t\t\t_ => todo!(),\n+\t\t\t\t\t\t})\n \t\t\t\t\t\t.expect(\"Inference did not change type\");\n \n \t\t\t\t\t// TODO property boundary\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -589,7 +611,7 @@ impl<T: ContextType> Context<T> {\n \t\t}\n \t}\n \n-\t/// Only on current\n+\t/// Only on current environment, doesn't walk\n \tfn get_this_constraint(&self) -> Option<TypeId> {\n \t\tmatch self.into_general_environment() {\n \t\t\tGeneralEnvironment::Syntax(syn) => match &syn.context_type.scope {\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -709,7 +731,7 @@ impl<T: ContextType> Context<T> {\n \t\tself.parents_iter()\n \t\t\t.flat_map(|env| get_env!(env.properties.get(&base)).map(|v| v.iter()))\n \t\t\t.flatten()\n-\t\t\t.cloned()\n+\t\t\t.map(|(key, prop)| (*key, prop.as_get_type()))\n \t\t\t.collect()\n \t}\n \ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -718,18 +740,18 @@ impl<T: ContextType> Context<T> {\n \t\ton: TypeId,\n \t\tunder: TypeId,\n \t\ttypes: &TypeStore,\n-\t) -> Option<Logical<TypeId>> {\n+\t) -> Option<Logical<Property>> {\n \t\tfn get_property(\n \t\t\tenv: GeneralEnvironment,\n \t\t\ton: TypeId,\n \t\t\tunder: (&TypeStore, &Constant),\n-\t\t) -> Option<TypeId> {\n+\t\t) -> Option<Property> {\n \t\t\tget_env!(env.properties.get(&on)).and_then(|properties| {\n \t\t\t\t// TODO rev is important\n \t\t\t\tproperties.iter().rev().find_map(|(key, value)| {\n \t\t\t\t\tlet key_ty = under.0.get_type_by_id(*key);\n \t\t\t\t\tif let Type::Constant(cst) = key_ty {\n-\t\t\t\t\t\t(cst == under.1).then_some(*value)\n+\t\t\t\t\t\t(cst == under.1).then_some(value.clone())\n \t\t\t\t\t} else {\n \t\t\t\t\t\ttodo!(\"key {key:?} returned {key_ty:?}\")\n \t\t\t\t\t}\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -747,9 +769,10 @@ impl<T: ContextType> Context<T> {\n \t/// TODO temp\n \tpub(crate) fn get_tag_name(&self, tag_name: TypeId, types: &TypeStore) -> Option<TypeId> {\n \t\tself.get_property_unbound(TypeId::HTML_ELEMENT_TAG_NAME_MAP, tag_name, types)\n-\t\t\t.map(Logical::to_type)\n+\t\t\t.map(Logical::prop_to_type)\n \t}\n \n+\t/// Note: this also returns base generic types like `Array`\n \tpub fn get_type_from_name(&self, name: &str) -> Option<TypeId> {\n \t\tself.parents_iter().find_map(|env| get_env!(env.named_types.get(name))).cloned()\n \t}\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -761,17 +784,21 @@ impl<T: ContextType> Context<T> {\n \t\t\tCanUseThis::ConstructorCalled { this_ty } => this_ty,\n \t\t\tCanUseThis::Yeah { this_ty } => {\n \t\t\t\t// TODO `this_ty` can be error here..?\n+\t\t\t\tif this_ty == TypeId::ERROR_TYPE {\n+\t\t\t\t\tunreachable!()\n+\t\t\t\t}\n+\n \t\t\t\ttodo!();\n \n \t\t\t\t// let mut last = None;\n \t\t\t\t// for parent in self.parents_iter() {\n \t\t\t\t// \tif let Some(constraint) = get_env!(parent.get_this_constraint()) {\n-\t\t\t\t// \t\t// last = Some((constraint, get_env!(parent.context_id)));\n+\t\t\t\t// \t\tlast = Some((constraint, get_env!(parent.context_id)));\n \t\t\t\t// \t\tbreak;\n \t\t\t\t// \t}\n \t\t\t\t// }\n \n-\t\t\t\t// let reference = Reference::This;\n+\t\t\t\t// let reference = RootReference::This;\n \n \t\t\t\t// let (value, reflects_dependency) = if let Some(boundary) = crossed_boundary {\n \t\t\t\t// \tlet this_inferred = constraint_of_this.is_none();\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -780,7 +807,7 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t// \t\tNone => PolyPointer::Inferred(boundary),\n \t\t\t\t// \t};\n \t\t\t\t// \tlet poly_nature = PolyNature::ParentScope { reference, based_on };\n-\t\t\t\t// \tlet ty = types.new_type(Type::RootPolyType(poly_nature));\n+\t\t\t\t// \tlet ty = types.register_type(Type::RootPolyType(poly_nature));\n \t\t\t\t// \t(ty, Some(ty))\n \t\t\t\t// } else {\n \t\t\t\t// \t// TODO... always replace\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -789,7 +816,7 @@ impl<T: ContextType> Context<T> {\n \n \t\t\t\t// if let Some(events) = self.context_type.get_events() {\n \t\t\t\t// \tevents.push(Event::ReadsReference {\n-\t\t\t\t// \t\treference: Reference::This,\n+\t\t\t\t// \t\treference: RootReference::This,\n \t\t\t\t// \t\treflects_dependency,\n \t\t\t\t// \t});\n \t\t\t\t// }\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -804,14 +831,11 @@ impl<T: ContextType> Context<T> {\n \t}\n \n \tpub(crate) fn get_value_of_variable(&self, id: VariableId) -> TypeId {\n-\t\tif let Some(found) = self.parents_iter().find_map(|env| {\n-\t\t\t// crate::utils::notify!(\n-\t\t\t// \t\"Current values {:?} {:?}\",\n-\t\t\t// \tget_env!(&env.variable_current_value),\n-\t\t\t// \tid\n-\t\t\t// );\n-\t\t\tget_env!(env.variable_current_value.get(&id)).copied()\n-\t\t}) {\n+\t\tlet variable = self\n+\t\t\t.parents_iter()\n+\t\t\t.find_map(|env| get_env!(env.variable_current_value.get(&id)).copied());\n+\n+\t\tif let Some(found) = variable {\n \t\t\tfound\n \t\t} else {\n \t\t\tpanic!(\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -881,7 +905,7 @@ impl<T: ContextType> Context<T> {\n \t\t\t\tparent: T::into_parent_or_root(self),\n \t\t\t\tevents: Default::default(),\n \t\t\t\tasync_events: Default::default(),\n-\t\t\t\tclosed_over_variables: Default::default(),\n+\t\t\t\tclosed_over_references: Default::default(),\n \t\t\t},\n \t\t\tcan_use_this,\n \t\t\t// TODO maybe based on something in the AST\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -904,14 +928,16 @@ impl<T: ContextType> Context<T> {\n \t\t}\n \t}\n \n-\tpub fn new_function_context<\n+\tpub fn new_function<\n \t\tU: crate::FSResolver,\n+\t\tV: crate::behavior::functions::RegisterBehavior,\n \t\tF: behavior::functions::SynthesizableFunction,\n \t>(\n-\t\t&self,\n+\t\t&mut self,\n \t\tchecking_data: &mut CheckingData<U>,\n \t\tfunc: &F,\n-\t) -> SynthesizedFunction {\n+\t\tregister_behavior: V,\n+\t) -> V::Return {\n \t\tlet mut func_env = self.new_lexical_environment(Scope::Function {\n \t\t\t// TODO\n \t\t\tthis_constraint: TypeId::ERROR_TYPE,\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -920,19 +946,27 @@ impl<T: ContextType> Context<T> {\n \t\t\tconstructor_on: None,\n \t\t});\n \n+\t\tif func.is_async() {\n+\t\t\ttodo!()\n+\t\t}\n+\n \t\tlet type_parameters = func.type_parameters(&mut func_env, checking_data);\n \n+\t\tif let Some(_) = func.this_constraint(&mut func_env, checking_data) {\n+\t\t\ttodo!();\n+\t\t} else {\n+\t\t\t// TODO inferred\n+\t\t}\n+\n \t\t// TODO could reuse existing if hoisted\n \t\tlet synthesized_parameters = func.parameters(&mut func_env, checking_data);\n \n-\t\tlet return_type = func.return_type(&mut func_env, checking_data);\n+\t\tlet return_type_annotation = func.return_type_annotation(&mut func_env, checking_data);\n \n \t\t// TODO temp\n \t\tlet returned = if !func.is_declare() {\n \t\t\tfunc.body(&mut func_env, checking_data);\n \n-\t\t\tcrate::utils::notify!(\"Found events {:#?}\", func_env.context_type.events);\n-\n \t\t\t// TODO check with annotation\n \t\t\tlet returned = func_env\n \t\t\t\t.context_type\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -947,20 +981,73 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t})\n \t\t\t\t.unwrap_or(TypeId::UNDEFINED_TYPE);\n \n-\t\t\t// TODO check returned against return type here\n+\t\t\tif let Some((expected_return_type, annotation_span)) = return_type_annotation {\n+\t\t\t\tlet mut behavior = BasicEquality {\n+\t\t\t\t\tadd_property_restrictions: true,\n+\t\t\t\t\tposition: annotation_span.clone(),\n+\t\t\t\t};\n+\n+\t\t\t\tlet result = type_is_subtype(\n+\t\t\t\t\texpected_return_type,\n+\t\t\t\t\treturned,\n+\t\t\t\t\tNone,\n+\t\t\t\t\t&mut behavior,\n+\t\t\t\t\t&mut func_env,\n+\t\t\t\t\t&checking_data.types,\n+\t\t\t\t);\n+\n+\t\t\t\tif let crate::subtyping::SubTypeResult::IsNotSubType(_) = result {\n+\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n+\t\t\t\t\t\tTypeCheckError::ReturnedTypeDoesNotMatch {\n+\t\t\t\t\t\t\texpected_return_type: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\texpected_return_type,\n+\t\t\t\t\t\t\t\t&func_env.into_general_environment(),\n+\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\treturned_type: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\treturned,\n+\t\t\t\t\t\t\t\t&func_env.into_general_environment(),\n+\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tposition: annotation_span,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\t\t\t}\n \n \t\t\treturned\n \t\t} else {\n-\t\t\treturn_type.expect(\"declare without return type\")\n+\t\t\treturn_type_annotation.expect(\"declare without return type\").0\n \t\t};\n \n-\t\tSynthesizedFunction {\n-\t\t\ttype_parameters,\n-\t\t\treturned,\n-\t\t\tevents: func_env.context_type.events,\n-\t\t\tclosed_over_references: func_env.context_type.closed_over_variables,\n-\t\t\tsynthesized_parameters,\n+\t\tlet Syntax { events, closed_over_references, .. } = func_env.context_type;\n+\n+\t\t// crate::utils::notify!(\"Function returned events {:#?}\", events);\n+\n+\t\t// TODO temp ...\n+\t\tfor (on, mut properties) in func_env.properties.into_iter() {\n+\t\t\tmatch self.properties.entry(on) {\n+\t\t\t\thash_map::Entry::Occupied(mut occupied) => {}\n+\t\t\t\thash_map::Entry::Vacant(vacant) => {\n+\t\t\t\t\tvacant.insert(properties);\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n+\n+\t\tlet get_set = func.get_set_generator_or_none();\n+\t\tlet func_ty = FunctionType {\n+\t\t\ttype_parameters,\n+\t\t\treturn_type: returned,\n+\t\t\teffects: events,\n+\t\t\tclosed_over_references,\n+\t\t\tparameters: synthesized_parameters,\n+\t\t\tconstant_id: None,\n+\t\t\tkind: FunctionKind::Arrow { get_set },\n+\t\t};\n+\n+\t\tregister_behavior.func(func, func_ty, self, &mut checking_data.types)\n \t}\n \n \tpub fn new_try_context<U: crate::FSResolver>(\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1001,7 +1088,7 @@ impl<T: ContextType> Context<T> {\n \t\tenvironment_type: Scope,\n \t\tchecking_data: &mut CheckingData<U>,\n \t\tcb: impl for<'a> FnOnce(&'a mut Environment, &'a mut CheckingData<U>) -> Res,\n-\t) -> (Res, Option<(Vec<Event>, HashMap<Reference, TypeId>)>, ContextId) {\n+\t) -> (Res, Option<(Vec<Event>, HashMap<RootReference, TypeId>)>, ContextId) {\n \t\tlet mut new_environment = self.new_lexical_environment(environment_type);\n \t\tlet res = cb(&mut new_environment, checking_data);\n \t\tlet context_id = new_environment.context_id;\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1017,7 +1104,7 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t\tparent: _,\n \t\t\t\t\tmut events,\n \t\t\t\t\tasync_events,\n-\t\t\t\t\tclosed_over_variables,\n+\t\t\t\t\tclosed_over_references,\n \t\t\t\t},\n \t\t\tcan_use_this,\n \t\t\tbases,\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1069,7 +1156,7 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t);\n \t\t\t\tself.properties.extend(properties.into_iter());\n \n-\t\t\t\tSome((events, closed_over_variables))\n+\t\t\t\tSome((events, closed_over_references))\n \t\t\t}\n \t\t\tScope::InterfaceEnvironment { .. }\n \t\t\t| Scope::ClassEnvironment {}\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1083,8 +1170,8 @@ impl<T: ContextType> Context<T> {\n \n \t\t\t\t// \t// TODO temp\n \t\t\t\t// \tself.context_type\n-\t\t\t\t// \t\t.get_closed_over_variables_mut()\n-\t\t\t\t// \t\t.extend(closed_over_variables.into_iter());\n+\t\t\t\t// \t\t.get_closed_over_references_mut()\n+\t\t\t\t// \t\t.extend(closed_over_references.into_iter());\n \t\t\t\t// }\n \n \t\t\t\t// self.proofs.merge(proofs);\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1123,7 +1210,7 @@ impl<T: ContextType> Context<T> {\n \t\tmut chain: Vec<(ContextId, ExistingContext)>,\n \t\tchecking_data: &mut CheckingData<U>,\n \t\tcb: impl for<'a> FnOnce(&'a mut Environment, &'a mut CheckingData<U>) -> Res,\n-\t) -> (Res, Option<(Vec<Event>, HashMap<Reference, TypeId>)>, ContextId) {\n+\t) -> (Res, Option<(Vec<Event>, HashMap<RootReference, TypeId>)>, ContextId) {\n \t\tlet (context_id, environment) = chain.pop().unwrap();\n \n \t\tlet mut environment = Environment {\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1132,7 +1219,7 @@ impl<T: ContextType> Context<T> {\n \t\t\t\tparent: self.into_general_environment(),\n \t\t\t\tevents: Default::default(),\n \t\t\t\tasync_events: Default::default(),\n-\t\t\t\tclosed_over_variables: Default::default(),\n+\t\t\t\tclosed_over_references: Default::default(),\n \t\t\t},\n \t\t\tcontext_id,\n \t\t\tvariables: environment.variables,\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1156,7 +1243,7 @@ impl<T: ContextType> Context<T> {\n \n \t\tenum Results<U> {\n \t\t\tU(U),\n-\t\t\tBottom((U, Option<(Vec<Event>, HashMap<Reference, TypeId>)>, ContextId)),\n+\t\t\tBottom((U, Option<(Vec<Event>, HashMap<RootReference, TypeId>)>, ContextId)),\n \t\t}\n \n \t\tlet results = if !chain.is_empty() {\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1180,7 +1267,7 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t\t\tparent: _,\n \t\t\t\t\t\tmut events,\n \t\t\t\t\t\tasync_events,\n-\t\t\t\t\t\tclosed_over_variables,\n+\t\t\t\t\t\tclosed_over_references,\n \t\t\t\t\t},\n \t\t\t\tcan_use_this,\n \t\t\t\tbases,\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1226,7 +1313,7 @@ impl<T: ContextType> Context<T> {\n \t\t\t\tScope::Function { .. } => {\n \t\t\t\t\t// self.proofs.merge(proofs);\n \n-\t\t\t\t\tSome((events, closed_over_variables))\n+\t\t\t\t\tSome((events, closed_over_references))\n \t\t\t\t}\n \t\t\t\tScope::InterfaceEnvironment { .. }\n \t\t\t\t| Scope::TryBlock {}\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1245,8 +1332,8 @@ impl<T: ContextType> Context<T> {\n \n \t\t\t\t\t// \t// TODO temp\n \t\t\t\t\t// \tself.context_type\n-\t\t\t\t\t// \t\t.get_closed_over_variables_mut()\n-\t\t\t\t\t// \t\t.extend(closed_over_variables.into_iter());\n+\t\t\t\t\t// \t\t.get_closed_over_references_mut()\n+\t\t\t\t\t// \t\t.extend(closed_over_references.into_iter());\n \t\t\t\t\t// }\n \n \t\t\t\t\t// self.proofs.merge(proofs);\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1319,14 +1406,9 @@ impl<T: ContextType> Context<T> {\n \t}\n \n \t/// TODO temp\n-\tpub fn register_property(&mut self, on: TypeId, under: TypeId, to: TypeId) {\n+\tpub fn register_property(&mut self, on: TypeId, under: TypeId, to: Property) {\n \t\t// crate::utils::notify!(\"Registering {:?} {:?} {:?}\", on, under, to);\n-\t\tself.properties.entry(on).or_default().push((under, to));\n-\t}\n-\n-\t/// TODO should use above and be automatic\n-\tpub fn register_property_on_object(&mut self, on: TypeId, under: TypeId, to: TypeId) {\n-\t\tself.properties.entry(on).or_default().push((under, to));\n+\t\tself.properties.entry(on).or_default().push((under, to.clone()));\n \t\tself.context_type.get_events().unwrap().push(Event::Setter {\n \t\t\ton,\n \t\t\tunder,\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1336,33 +1418,6 @@ impl<T: ContextType> Context<T> {\n \t\t});\n \t}\n \n-\t/// TODO temp\n-\tpub fn attach_to_existing_function(\n-\t\t&mut self,\n-\t\tas_str: &str,\n-\t\treturned: SynthesizedFunction,\n-\t\ttypes: &mut TypeStore,\n-\t\tfunction_id: FunctionId,\n-\t) {\n-\t\tlet r#type = types.register_type(Type::Function(\n-\t\t\tFunctionType {\n-\t\t\t\tgeneric_type_parameters: returned.type_parameters,\n-\t\t\t\tparameters: returned.synthesized_parameters,\n-\t\t\t\treturn_type: returned.returned,\n-\t\t\t\teffects: returned.events,\n-\t\t\t\tclosed_over_references: returned.closed_over_references,\n-\t\t\t\t// TODO temp\n-\t\t\t\tnature: crate::structures::functions::FunctionNature::Arrow,\n-\t\t\t\tconstant_id: None,\n-\t\t\t},\n-\t\t\tcrate::types::FunctionNature::Source(function_id, None, None),\n-\t\t));\n-\n-\t\tlet variable_id = self.variables.get(as_str).unwrap().declared_at.clone();\n-\n-\t\tself.variable_current_value.insert(VariableId(variable_id), r#type);\n-\t}\n-\n \tpub fn new_explicit_type_parameter(\n \t\t&mut self,\n \t\tname: &str,\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1370,17 +1425,17 @@ impl<T: ContextType> Context<T> {\n \t\tdefault_type: Option<TypeId>,\n \t\ttypes: &mut TypeStore,\n \t) -> crate::types::poly_types::GenericTypeParameter {\n-\t\tlet r#type = Type::RootPolyType(PolyNature::Generic {\n+\t\tlet ty = Type::RootPolyType(PolyNature::Generic {\n \t\t\tname: name.to_owned(),\n \t\t\teager_fixed: PolyPointer::Fixed(constraint_type.unwrap_or(TypeId::ANY_TYPE)),\n \t\t});\n \n-\t\tlet r#type = types.register_type(r#type);\n-\t\tself.named_types.insert(name.to_owned(), r#type);\n+\t\tlet ty = types.register_type(ty);\n+\t\tself.named_types.insert(name.to_owned(), ty);\n \n \t\tcrate::types::poly_types::GenericTypeParameter {\n \t\t\tname: name.to_owned(),\n-\t\t\tid: r#type,\n+\t\t\tid: ty,\n \t\t\tdefault: default_type,\n \t\t}\n \t}\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1406,8 +1461,8 @@ impl<T: ContextType> Context<T> {\n \t/// TODO extends + parameters\n \tpub fn new_interface(&mut self, name: &str, position: Span, types: &mut TypeStore) -> TypeId {\n \t\t// TODO temp\n-\t\tlet r#type = Type::NamedRooted { name: name.to_owned(), parameters: None };\n-\t\tlet interface_ty = types.register_type(r#type);\n+\t\tlet ty = Type::NamedRooted { name: name.to_owned(), parameters: None };\n+\t\tlet interface_ty = types.register_type(ty);\n \n \t\t// Interface merging!\n \t\tlet existing =\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1424,8 +1479,8 @@ impl<T: ContextType> Context<T> {\n \t/// TODO parameters\n \tpub fn new_alias(&mut self, name: &str, to: TypeId, types: &mut TypeStore) -> TypeId {\n \t\t// TODO temp\n-\t\tlet r#type = Type::AliasTo { to, name: name.to_owned(), parameters: None };\n-\t\tlet alias_ty = types.register_type(r#type);\n+\t\tlet ty = Type::AliasTo { to, name: name.to_owned(), parameters: None };\n+\t\tlet alias_ty = types.register_type(ty);\n \t\tlet existing_type = self.named_types.insert(name.to_owned(), alias_ty);\n \n \t\tif existing_type.is_some() {\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1435,7 +1490,11 @@ impl<T: ContextType> Context<T> {\n \t\t}\n \t}\n \n-\tpub fn set_variable_declaration_value(&mut self, id: VariableId, value_ty: TypeId) {\n+\tpub fn register_initial_variable_declaration_value(\n+\t\t&mut self,\n+\t\tid: VariableId,\n+\t\tvalue_ty: TypeId,\n+\t) {\n \t\tself.variable_current_value.insert(id, value_ty);\n \t}\n \ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1471,17 +1530,23 @@ fn extract_throw_events(events: Vec<Event>, thrown: &mut Vec<TypeId>) -> Vec<Eve\n \tnew_events\n }\n \n-#[derive(Debug)]\n-pub enum ReassignmentError<'a> {\n+pub enum AssignmentError {\n \t/// Non writable, could have position info\n \tConstant(Span),\n \tVariableNotFound {\n-\t\tvariable: &'a str,\n+\t\tvariable: String,\n \t},\n \tDoesNotMatchRestrictionType {\n-\t\tvariable_type: TypeId,\n+\t\tvariable_type: TypeStringRepresentation,\n \t\tvariable_declared_at: Span,\n \t},\n+\t// TODO merge with above\n+\tInvalidDeclaration {\n+\t\tvariable_type: TypeStringRepresentation,\n+\t\tvariable_site: Span,\n+\t\tvalue_type: TypeStringRepresentation,\n+\t\tvalue_site: Span,\n+\t},\n }\n \n /// Resolved [crate::PolyPointer]\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1539,6 +1604,7 @@ impl<'a, T: Clone> Logical<&'a T> {\n \t}\n }\n \n+// TODO temp\n impl Logical<TypeId> {\n \tpub(crate) fn to_type(self) -> TypeId {\n \t\tmatch self {\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1549,8 +1615,19 @@ impl Logical<TypeId> {\n \t}\n }\n \n+// TODO temp\n+impl Logical<Property> {\n+\tpub(crate) fn prop_to_type(self) -> TypeId {\n+\t\tmatch self {\n+\t\t\tLogical::Pure(ty) => ty.as_get_type(),\n+\t\t\tLogical::Or(_) => todo!(),\n+\t\t\tLogical::Implies(_, _) => todo!(),\n+\t\t}\n+\t}\n+}\n+\n #[derive(Debug)]\n pub enum SetPropertyError {\n \tNotWriteable,\n-\tDoesNotMeetConstraint(crate::types::subtyping::NonEqualityReason),\n+\tDoesNotMeetConstraint(TypeId, crate::types::subtyping::NonEqualityReason),\n }\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -1,4 +1,3 @@\n-use either::Either;\n use serde::Serialize;\n use source_map::{SourceId, Span};\n use std::{\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -7,55 +6,43 @@ use std::{\n \tpath::PathBuf,\n };\n \n+#[derive(Serialize, Debug)]\n+#[serde(tag = \"type\")]\n+pub enum DiagnosticKind {\n+\tError,\n+\tWarning,\n+\tInfo,\n+}\n+\n /// Contains information\n #[derive(Serialize, Debug)]\n-// #[serde(tag = \"type\")]\n+#[serde(tag = \"type\")]\n pub enum Diagnostic {\n \t/// Does not have positional information\n-\tGlobal(String),\n+\tGlobal {\n+\t\treason: String,\n+\t\tkind: DiagnosticKind,\n+\t},\n \tPosition {\n \t\treason: String,\n-\t\tpos: Span,\n+\t\tposition: Span,\n+\t\tkind: DiagnosticKind,\n \t},\n \tPositionWithAdditionLabels {\n \t\treason: String,\n-\t\tpos: Span,\n+\t\tposition: Span,\n \t\tlabels: Vec<(String, Option<Span>)>,\n+\t\tkind: DiagnosticKind,\n \t},\n }\n \n-#[derive(serde::Serialize)]\n-#[serde(tag = \"type\")]\n-pub enum ErrorWarningInfo {\n-\t/// For errors, will back out and not produce output\n-\tError(Diagnostic),\n-\t/// For actionable warnings\n-\tWarning(Diagnostic),\n-\t/// For diagnostic, TODO maybe disabled via debug\n-\tInfo(Diagnostic),\n-\t/// For things...\n-\tData(Box<dyn erased_serde::Serialize>),\n-}\n-\n-impl ErrorWarningInfo {\n-\tpub fn get_diagnostic(self) -> Option<Diagnostic> {\n-\t\tif let Self::Error(diag) | Self::Warning(diag) | Self::Info(diag) = self {\n-\t\t\tSome(diag)\n-\t\t} else {\n-\t\t\tNone\n-\t\t}\n-\t}\n-}\n-\n impl Diagnostic {\n \tpub fn sources<'a>(&'a self) -> impl Iterator<Item = SourceId> + 'a {\n \t\tuse either::{Left, Right};\n \t\tmatch self {\n-\t\t\tDiagnostic::Global(_) => Left(Left(iter::empty())),\n-\t\t\tDiagnostic::Position { reason: _, pos: span } => {\n-\t\t\t\tLeft(Right(iter::once(span.source_id)))\n-\t\t\t}\n-\t\t\tDiagnostic::PositionWithAdditionLabels { pos, labels, .. } => {\n+\t\t\tDiagnostic::Global { .. } => Left(Left(iter::empty())),\n+\t\t\tDiagnostic::Position { position: span, .. } => Left(Right(iter::once(span.source_id))),\n+\t\t\tDiagnostic::PositionWithAdditionLabels { position: pos, labels, .. } => {\n \t\t\t\tRight(iter::once(pos.source_id).chain(\n \t\t\t\t\tlabels.iter().flat_map(|(_, span)| span.as_ref().map(|span| span.source_id)),\n \t\t\t\t))\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -65,7 +52,7 @@ impl Diagnostic {\n \n \tpub fn reason(&self) -> &str {\n \t\tmatch self {\n-\t\t\tDiagnostic::Global(reason)\n+\t\t\tDiagnostic::Global { reason, .. }\n \t\t\t| Diagnostic::Position { reason, .. }\n \t\t\t| Diagnostic::PositionWithAdditionLabels { reason, .. } => &reason,\n \t\t}\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -75,7 +62,7 @@ impl Diagnostic {\n #[derive(Default, serde::Serialize)]\n #[serde(transparent)]\n pub struct DiagnosticsContainer {\n-\tcontainer: Vec<ErrorWarningInfo>,\n+\tdiagnostics: Vec<Diagnostic>,\n \t// Quick way to check whether a error was added\n \t#[serde(skip_serializing)]\n \thas_error: bool,\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -88,19 +75,15 @@ impl DiagnosticsContainer {\n \n \tpub fn add_error<T: Into<Diagnostic>>(&mut self, error: T) {\n \t\tself.has_error = true;\n-\t\tself.container.push(ErrorWarningInfo::Error(error.into()))\n+\t\tself.diagnostics.push(error.into())\n \t}\n \n \tpub fn add_warning<T: Into<Diagnostic>>(&mut self, warning: T) {\n-\t\tself.container.push(ErrorWarningInfo::Warning(warning.into()))\n+\t\tself.diagnostics.push(warning.into())\n \t}\n \n \tpub fn add_info<T: Into<Diagnostic>>(&mut self, info: T) {\n-\t\tself.container.push(ErrorWarningInfo::Info(info.into()))\n-\t}\n-\n-\tpub fn add_data(&mut self, data: Box<dyn erased_serde::Serialize>) {\n-\t\tself.container.push(ErrorWarningInfo::Data(data))\n+\t\tself.diagnostics.push(info.into())\n \t}\n \n \tpub fn has_error(&self) -> bool {\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -108,16 +91,16 @@ impl DiagnosticsContainer {\n \t}\n \n \tpub fn sources<'a>(&'a self) -> impl Iterator<Item = SourceId> + 'a {\n-\t\tself.container.iter().flat_map(|item| match item {\n-\t\t\tErrorWarningInfo::Error(diag)\n-\t\t\t| ErrorWarningInfo::Warning(diag)\n-\t\t\t| ErrorWarningInfo::Info(diag) => Either::Left(diag.sources()),\n-\t\t\tErrorWarningInfo::Data(_) => Either::Right(iter::empty()),\n-\t\t})\n+\t\tself.diagnostics.iter().flat_map(|item| item.sources())\n+\t}\n+\n+\tpub fn into_iter(self) -> impl DoubleEndedIterator<Item = Diagnostic> {\n+\t\tself.diagnostics.into_iter()\n \t}\n \n-\tpub fn into_iter(self) -> impl DoubleEndedIterator<Item = ErrorWarningInfo> {\n-\t\tself.container.into_iter()\n+\t#[doc(hidden)]\n+\tpub fn get_diagnostics(self) -> Vec<Diagnostic> {\n+\t\tself.diagnostics\n \t}\n \n \tpub fn into_result(self) -> Result<Self, Self> {\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -137,7 +120,7 @@ use crate::{\n };\n \n /// TODO could be more things, for instance a property missing etc\n-pub(crate) enum TypeStringRepresentation {\n+pub enum TypeStringRepresentation {\n \tType(String),\n }\n \ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -171,35 +154,45 @@ pub(crate) struct NoEnvironmentSpecified;\n \n impl From<NoEnvironmentSpecified> for Diagnostic {\n \tfn from(error: NoEnvironmentSpecified) -> Self {\n-\t\tDiagnostic::Global(\"No environment\".to_owned())\n+\t\tDiagnostic::Global { reason: \"No environment\".to_owned(), kind: DiagnosticKind::Error }\n \t}\n }\n \n // Contains known internal errors and warnings\n // Contained here in a module to separate user facing\n mod defined_errors_and_warnings {\n+\tuse crate::context::AssignmentError;\n \tuse source_map::Span;\n \n \tuse crate::{\n-\t\tstructures::{self, operators::UnaryOperator},\n+\t\tstructures::{self, functions::FunctionCallingError, operators::UnaryOperator},\n \t\tDiagnostic,\n \t};\n \tuse std::path;\n \n \tuse super::TypeStringRepresentation;\n \n+\t/// Covers multiplication, subtraction, modulo etc\n+\t/// TODO something better?\n+\tpub struct InvalidMathematicalOperation {\n+\t\tpub(crate) lhs: TypeStringRepresentation,\n+\t\tpub(crate) rhs: TypeStringRepresentation,\n+\t\tpub(crate) operator: structures::operators::BinaryOperator,\n+\t\tpub(crate) position: Span,\n+\t}\n+\n \t/// Reasons for errors, intermediate type for generating [Diagnostic]s\n \t/// e.g. cannot Call, cannot equate, duplicate key etc\n \tpub(crate) enum TypeCheckError<'a> {\n+\t\tFunctionCallingError(FunctionCallingError),\n \t\tPropertyDoesNotExist {\n \t\t\tproperty: TypeStringRepresentation,\n-\t\t\tty: TypeStringRepresentation,\n+\t\t\ton: TypeStringRepresentation,\n \t\t\tsite: Span,\n \t\t},\n \t\tRestParameterAnnotationShouldBeArrayType(Span),\n \t\t/// TODO better name\n \t\tNonExistentType(String),\n-\t\tCannotIndexType,\n \t\tCouldNotFindVariable {\n \t\t\tvariable: &'a str,\n \t\t\tpossibles: Vec<&'a str>,\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -207,59 +200,21 @@ mod defined_errors_and_warnings {\n \t\t},\n \t\tCouldNotFindType(&'a str, Span),\n \t\tTypeHasNoGenericParameters(String, Span),\n-\t\tArgumentDoesNotMatchParameter {\n-\t\t\tparameter_type: TypeStringRepresentation,\n-\t\t\tparameter_position: Span,\n-\t\t\targument_type: TypeStringRepresentation,\n-\t\t\targument_position: Span,\n-\t\t\trestriction: Option<(Span, TypeStringRepresentation)>,\n-\t\t},\n-\t\t/// TODO this also covers readonly\n-\t\t/// TODO should this contain information about the constant\n-\t\tCannotAssignToConstant {\n-\t\t\tvariable_name: &'a str,\n-\t\t\tvariable_position: Span,\n-\t\t\tassignment_position: Span,\n-\t\t},\n-\t\tCannotAssignToFrozen {\n-\t\t\tvariable_type: TypeStringRepresentation,\n-\t\t\tassignment_position: Span,\n-\t\t},\n-\t\tInvalidAssignmentOrDeclaration {\n-\t\t\tvariable_type: TypeStringRepresentation,\n-\t\t\tvalue_type: TypeStringRepresentation,\n-\t\t\tvariable_site: Span,\n-\t\t\tvalue_site: Span,\n-\t\t},\n-\t\tInvalidJSXAttribute {\n-\t\t\tattribute_name: String,\n-\t\t\tattribute_type: TypeStringRepresentation,\n-\t\t\tvalue_type: TypeStringRepresentation,\n-\t\t\t// TODO\n-\t\t\tattribute_type_site: (),\n-\t\t\tvalue_site: Span,\n-\t\t},\n+\t\tAssignmentError(AssignmentError),\n \t\tInvalidComparison(TypeStringRepresentation, TypeStringRepresentation),\n \t\tInvalidAddition(TypeStringRepresentation, TypeStringRepresentation),\n-\t\t/// Covers multiplication, subtraction, modulo etc\n-\t\t/// TODO something better?\n-\t\tInvalidMathematicalOperation(\n-\t\t\tTypeStringRepresentation,\n-\t\t\tTypeStringRepresentation,\n-\t\t\tstructures::operators::BinaryOperator,\n-\t\t\tSpan,\n-\t\t),\n+\t\tInvalidMathematicalOperation(InvalidMathematicalOperation),\n \t\tInvalidBitwiseOperation(\n \t\t\tTypeStringRepresentation,\n \t\t\tTypeStringRepresentation,\n \t\t\tstructures::operators::BitwiseOperators,\n \t\t),\n+\t\tInvalidUnaryOperation(UnaryOperator, TypeStringRepresentation),\n \t\tReturnedTypeDoesNotMatch {\n \t\t\texpected_return_type: TypeStringRepresentation,\n \t\t\treturned_type: TypeStringRepresentation,\n \t\t\tposition: Span,\n \t\t},\n-\t\tInvalidUnaryOperation(UnaryOperator, TypeStringRepresentation),\n \t\t// TODO are these the same errors?\n \t\tTypeIsNotIndexable(TypeStringRepresentation),\n \t\tTypeIsNotIterable(TypeStringRepresentation),\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -267,50 +222,33 @@ mod defined_errors_and_warnings {\n \t\tNonTopLevelExport,\n \t\t// TODO implies the presence of, which isn't always true\n \t\tFieldNotExported(&'a str, &'a path::Path, Span),\n-\t\tMissingArguments {\n-\t\t\tfunction: TypeStringRepresentation,\n-\t\t\tparameter_pos: Span,\n-\t\t\tcall_site: Span,\n+\t\tInvalidJSXAttribute {\n+\t\t\tattribute_name: String,\n+\t\t\tattribute_type: TypeStringRepresentation,\n+\t\t\tvalue_type: TypeStringRepresentation,\n+\t\t\t// TODO\n+\t\t\tattribute_type_site: (),\n+\t\t\tvalue_site: Span,\n \t\t},\n \t\tInvalidJSXInterpolatedValue {\n \t\t\tinterpolation_site: Span,\n \t\t\texpected: TypeStringRepresentation,\n \t\t\tfound: TypeStringRepresentation,\n \t\t},\n-\t\tNotCallable {\n-\t\t\tat: Span,\n-\t\t\tcalling: TypeStringRepresentation,\n-\t\t},\n \t\t/// for the `satisfies` keyword\n \t\tNotSatisfied {\n \t\t\tat: Span,\n \t\t\texpected: TypeStringRepresentation,\n \t\t\tfound: TypeStringRepresentation,\n \t\t},\n-\t\tExtraArgument {\n-\t\t\targument_position: Span,\n-\t\t},\n \t\tUnsupported {\n \t\t\tthing: &'static str,\n \t\t\tat: Span,\n \t\t},\n-\t\tNotWritable {\n-\t\t\tpos: Span,\n-\t\t},\n-\t\tValueDoesNotMeetConstraint {\n-\t\t\tpos: Span,\n-\t\t\tvalue_pos: Span,\n-\t\t},\n \t\tReDeclaredVariable {\n \t\t\tname: &'a str,\n \t\t\tpos: Span,\n \t\t},\n-\t\tHiddenArgumentDoesNotMatch {\n-\t\t\tidentifier: String,\n-\t\t\trequirement: TypeStringRepresentation,\n-\t\t\tfound: TypeStringRepresentation,\n-\t\t\tcall_site: Span,\n-\t\t},\n \t\t/// TODO temp, needs more info\n \t\tFunctionDoesNotMeetConstraint {\n \t\t\tfunction_constraint: TypeStringRepresentation,\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -332,70 +270,103 @@ mod defined_errors_and_warnings {\n \t\t\t\t\t\t\tvariable,\n \t\t\t\t\t\t\t// possibles Consider '{:?}'\n \t\t\t\t\t\t),\n-\t\t\t\t\t\tpos: position,\n+\t\t\t\t\t\tposition,\n+\t\t\t\t\t\tkind: super::DiagnosticKind::Error,\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tTypeCheckError::CouldNotFindType(reference, pos) => Diagnostic::Position {\n \t\t\t\t\treason: format!(\"Could not find type '{}'\", reference),\n-\t\t\t\t\tpos,\n+\t\t\t\t\tposition: pos,\n+\t\t\t\t\tkind: super::DiagnosticKind::Error,\n \t\t\t\t},\n-\t\t\t\tTypeCheckError::PropertyDoesNotExist { property, ty, site } => {\n+\t\t\t\tTypeCheckError::PropertyDoesNotExist { property, on, site } => {\n \t\t\t\t\tDiagnostic::Position {\n-\t\t\t\t\t\treason: format!(\"No property with {} on {}\", property, ty),\n-\t\t\t\t\t\tpos: site,\n+\t\t\t\t\t\treason: format!(\"No property with {} on {}\", property, on),\n+\t\t\t\t\t\tposition: site,\n+\t\t\t\t\t\tkind: super::DiagnosticKind::Error,\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tTypeCheckError::ArgumentDoesNotMatchParameter {\n-\t\t\t\t\tparameter_type,\n-\t\t\t\t\targument_type,\n-\t\t\t\t\targument_position,\n-\t\t\t\t\tparameter_position,\n-\t\t\t\t\trestriction,\n-\t\t\t\t} => {\n-\t\t\t\t\tif let Some((restriction_pos, restriction)) = restriction {\n-\t\t\t\t\t\tDiagnostic::PositionWithAdditionLabels {\n-\t\t\t\t\t\t\treason: format!(\n-\t\t\t\t\t\t\t\t\"Argument of type {} is not assignable to {}\",\n-\t\t\t\t\t\t\t\targument_type, restriction\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tpos: argument_position,\n-\t\t\t\t\t\t\tlabels: vec![(\n-\t\t\t\t\t\t\t\tformat!(\n-\t\t\t\t\t\t\t\t\t\"Parameter {} was specialized with type {}\",\n-\t\t\t\t\t\t\t\t\tparameter_type, restriction\n+\t\t\t\tTypeCheckError::FunctionCallingError(error) => match error {\n+\t\t\t\t\tFunctionCallingError::InvalidArgumentType {\n+\t\t\t\t\t\tparameter_type,\n+\t\t\t\t\t\targument_type,\n+\t\t\t\t\t\targument_position,\n+\t\t\t\t\t\tparameter_position,\n+\t\t\t\t\t\trestriction,\n+\t\t\t\t\t} => {\n+\t\t\t\t\t\tif let Some((restriction_pos, restriction)) = restriction {\n+\t\t\t\t\t\t\tDiagnostic::PositionWithAdditionLabels {\n+\t\t\t\t\t\t\t\treason: format!(\n+\t\t\t\t\t\t\t\t\t\"Argument of type {} is not assignable to {}\",\n+\t\t\t\t\t\t\t\t\targument_type, restriction\n \t\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\t\tSome(restriction_pos),\n-\t\t\t\t\t\t\t)],\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tDiagnostic::PositionWithAdditionLabels {\n-\t\t\t\t\t\t\treason: format!(\n-\t\t\t\t\t\t\t\t\"Argument of type {} is not assignable to {}\",\n-\t\t\t\t\t\t\t\targument_type, parameter_type\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tpos: argument_position,\n-\t\t\t\t\t\t\tlabels: vec![(\n-\t\t\t\t\t\t\t\tformat!(\"Parameter has type {}\", parameter_type),\n-\t\t\t\t\t\t\t\tSome(parameter_position),\n-\t\t\t\t\t\t\t)],\n+\t\t\t\t\t\t\t\tposition: argument_position,\n+\t\t\t\t\t\t\t\tlabels: vec![(\n+\t\t\t\t\t\t\t\t\tformat!(\n+\t\t\t\t\t\t\t\t\t\t\"Parameter {} was specialized with type {}\",\n+\t\t\t\t\t\t\t\t\t\tparameter_type, restriction\n+\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\t\tSome(restriction_pos),\n+\t\t\t\t\t\t\t\t)],\n+\t\t\t\t\t\t\t\tkind: super::DiagnosticKind::Error,\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tDiagnostic::PositionWithAdditionLabels {\n+\t\t\t\t\t\t\t\treason: format!(\n+\t\t\t\t\t\t\t\t\t\"Argument of type {} is not assignable to {}\",\n+\t\t\t\t\t\t\t\t\targument_type, parameter_type\n+\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\tposition: argument_position,\n+\t\t\t\t\t\t\t\tlabels: vec![(\n+\t\t\t\t\t\t\t\t\tformat!(\"Parameter has type {}\", parameter_type),\n+\t\t\t\t\t\t\t\t\tSome(parameter_position),\n+\t\t\t\t\t\t\t\t)],\n+\t\t\t\t\t\t\t\tkind: super::DiagnosticKind::Error,\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tTypeCheckError::InvalidAssignmentOrDeclaration {\n-\t\t\t\t\tvariable_type,\n-\t\t\t\t\tvalue_type,\n-\t\t\t\t\tvalue_site,\n-\t\t\t\t\tvariable_site,\n-\t\t\t\t} => Diagnostic::PositionWithAdditionLabels {\n-\t\t\t\t\treason: format!(\n-\t\t\t\t\t\t\"Type {} is not assignable to type {}\",\n-\t\t\t\t\t\tvalue_type, variable_type\n-\t\t\t\t\t),\n-\t\t\t\t\tpos: value_site,\n-\t\t\t\t\tlabels: vec![(\n-\t\t\t\t\t\tformat!(\"Variable declared with type {}\", variable_type),\n-\t\t\t\t\t\tSome(variable_site),\n-\t\t\t\t\t)],\n+\t\t\t\t\tFunctionCallingError::MissingArgument { parameter_pos } => todo!(),\n+\t\t\t\t\tFunctionCallingError::ExtraArguments { count, position } => todo!(),\n+\t\t\t\t\tFunctionCallingError::NotCallable { calling } => todo!(),\n+\t\t\t\t\t//  Diagnostic::Position {\n+\t\t\t\t\t// \treason: format!(\"Cannot call {}\", calling),\n+\t\t\t\t\t// \tposition: at,\n+\t\t\t\t\t// \tkind: super::DiagnosticKind::Error,\n+\t\t\t\t\t// },\n+\t\t\t\t\tFunctionCallingError::ReferenceRestrictionDoesNotMatch {\n+\t\t\t\t\t\treference,\n+\t\t\t\t\t\trequirement,\n+\t\t\t\t\t\tfound,\n+\t\t\t\t\t} => todo!(),\n+\t\t\t\t\t// Diagnostic::Position {\n+\t\t\t\t\t// \treason: format!(\n+\t\t\t\t\t// \t\t\"Calling function requires {} to be {}, found {}\",\n+\t\t\t\t\t// \t\tidentifier, requirement, found\n+\t\t\t\t\t// \t),\n+\t\t\t\t\t// \tposition: call_site,\n+\t\t\t\t\t// \tkind: super::DiagnosticKind::Error,\n+\t\t\t\t\t// },\n+\t\t\t\t},\n+\t\t\t\t//  => ,\n+\t\t\t\tTypeCheckError::AssignmentError(error) => match error {\n+\t\t\t\t\tAssignmentError::InvalidDeclaration {\n+\t\t\t\t\t\tvariable_type,\n+\t\t\t\t\t\tvariable_site,\n+\t\t\t\t\t\tvalue_type,\n+\t\t\t\t\t\tvalue_site,\n+\t\t\t\t\t} => Diagnostic::PositionWithAdditionLabels {\n+\t\t\t\t\t\treason: format!(\n+\t\t\t\t\t\t\t\"Type {} is not assignable to type {}\",\n+\t\t\t\t\t\t\tvalue_type, variable_type\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tposition: value_site,\n+\t\t\t\t\t\tlabels: vec![(\n+\t\t\t\t\t\t\tformat!(\"Variable declared with type {}\", variable_type),\n+\t\t\t\t\t\t\tSome(variable_site),\n+\t\t\t\t\t\t)],\n+\t\t\t\t\t\tkind: super::DiagnosticKind::Error,\n+\t\t\t\t\t},\n+\t\t\t\t\t_ => todo!(),\n \t\t\t\t},\n \t\t\t\tTypeCheckError::InvalidJSXAttribute {\n \t\t\t\t\tattribute_name,\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -408,7 +379,8 @@ mod defined_errors_and_warnings {\n \t\t\t\t\t\t\"Type {} is not assignable to {} attribute of type {}\",\n \t\t\t\t\t\tattribute_name, value_type, attribute_type\n \t\t\t\t\t),\n-\t\t\t\t\tpos: value_site,\n+\t\t\t\t\tposition: value_site,\n+\t\t\t\t\tkind: super::DiagnosticKind::Error,\n \t\t\t\t},\n \t\t\t\tTypeCheckError::ReturnedTypeDoesNotMatch {\n \t\t\t\t\tposition,\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -419,47 +391,51 @@ mod defined_errors_and_warnings {\n \t\t\t\t\t\t\"Function is expected to return {} but returned {}\",\n \t\t\t\t\t\texpected_return_type, returned_type\n \t\t\t\t\t),\n-\t\t\t\t\tpos: position,\n+\t\t\t\t\tposition,\n+\t\t\t\t\tkind: super::DiagnosticKind::Error,\n \t\t\t\t},\n-\t\t\t\tTypeCheckError::MissingArguments { function, parameter_pos, call_site } => {\n-\t\t\t\t\tDiagnostic::PositionWithAdditionLabels {\n-\t\t\t\t\t\treason: format!(\"Calling {}, found missing arguments\", function),\n-\t\t\t\t\t\tpos: call_site,\n-\t\t\t\t\t\tlabels: vec![(\"Parameter defined here\".to_owned(), Some(parameter_pos))],\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\t// TypeCheckError::MissingArguments { function, parameter_pos, call_site } => {\n+\t\t\t\t// Diagnostic::PositionWithAdditionLabels {\n+\t\t\t\t// \t\treason: format!(\"Calling {}, found missing arguments\", function),\n+\t\t\t\t// \t\tposition: call_site,\n+\t\t\t\t// \t\tlabels: vec![(\"Parameter defined here\".to_owned(), Some(parameter_pos))],\n+\t\t\t\t// \t\tkind: super::DiagnosticKind::Error,\n+\t\t\t\t// \t}\n+\t\t\t\t// }\n \t\t\t\tTypeCheckError::NonExistentType(_) => todo!(),\n-\t\t\t\tTypeCheckError::CannotIndexType => todo!(),\n \t\t\t\tTypeCheckError::TypeHasNoGenericParameters(_, _) => todo!(),\n-\t\t\t\tTypeCheckError::CannotAssignToConstant {\n-\t\t\t\t\tvariable_name,\n-\t\t\t\t\tvariable_position,\n-\t\t\t\t\tassignment_position,\n-\t\t\t\t} => Diagnostic::PositionWithAdditionLabels {\n-\t\t\t\t\treason: format!(\"Cannot reassign to constant variable '{}'\", variable_name),\n-\t\t\t\t\tpos: assignment_position,\n-\t\t\t\t\tlabels: vec![(\n-\t\t\t\t\t\t\"Constant variable defined here\".to_owned(),\n-\t\t\t\t\t\tSome(variable_position),\n-\t\t\t\t\t)],\n-\t\t\t\t},\n-\t\t\t\tTypeCheckError::CannotAssignToFrozen { variable_type, assignment_position } => {\n-\t\t\t\t\tDiagnostic::Position {\n-\t\t\t\t\t\treason: format!(\"{} is frozen\", variable_type),\n-\t\t\t\t\t\tpos: assignment_position,\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\t// TypeCheckError::CannotAssignToConstant {\n+\t\t\t\t// \tvariable_name,\n+\t\t\t\t// \tvariable_position,\n+\t\t\t\t// \tassignment_position,\n+\t\t\t\t// } => Diagnostic::PositionWithAdditionLabels {\n+\t\t\t\t// \treason: format!(\"Cannot reassign to constant variable '{}'\", variable_name),\n+\t\t\t\t// \tposition: assignment_position,\n+\t\t\t\t// \tlabels: vec![(\n+\t\t\t\t// \t\t\"Constant variable defined here\".to_owned(),\n+\t\t\t\t// \t\tSome(variable_position),\n+\t\t\t\t// \t)],\n+\t\t\t\t// \tkind: super::DiagnosticKind::Error,\n+\t\t\t\t// },\n+\t\t\t\t// TypeCheckError::CannotAssignToFrozen { variable_type, assignment_position } => {\n+\t\t\t\t// \tDiagnostic::Position {\n+\t\t\t\t// \t\treason: format!(\"{} is frozen\", variable_type),\n+\t\t\t\t// \t\tposition: assignment_position,\n+\t\t\t\t// \t\tkind: super::DiagnosticKind::Error,\n+\t\t\t\t// \t}\n+\t\t\t\t// }\n \t\t\t\tTypeCheckError::InvalidComparison(_, _) => todo!(),\n \t\t\t\tTypeCheckError::InvalidAddition(_, _) => todo!(),\n-\t\t\t\tTypeCheckError::InvalidMathematicalOperation(lhs, rhs, operation, pos) => {\n-\t\t\t\t\tDiagnostic::Position {\n-\t\t\t\t\t\treason: format!(\n-\t\t\t\t\t\t\t\"Invalid operation {}, between {} and {}\",\n-\t\t\t\t\t\t\t\"todo\", lhs, rhs\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tpos,\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\tTypeCheckError::InvalidMathematicalOperation(InvalidMathematicalOperation {\n+\t\t\t\t\tlhs,\n+\t\t\t\t\trhs,\n+\t\t\t\t\toperator,\n+\t\t\t\t\tposition,\n+\t\t\t\t}) => Diagnostic::Position {\n+\t\t\t\t\treason: format!(\"Cannot {:?} {} and {}\", operator, lhs, rhs),\n+\t\t\t\t\tposition,\n+\t\t\t\t\tkind: super::DiagnosticKind::Error,\n+\t\t\t\t},\n \t\t\t\tTypeCheckError::InvalidBitwiseOperation(_, _, _) => todo!(),\n \t\t\t\tTypeCheckError::InvalidUnaryOperation(_, _) => todo!(),\n \t\t\t\tTypeCheckError::TypeIsNotIndexable(_) => todo!(),\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -474,42 +450,34 @@ mod defined_errors_and_warnings {\n \t\t\t\tTypeCheckError::RestParameterAnnotationShouldBeArrayType(pos) => {\n \t\t\t\t\tDiagnostic::Position {\n \t\t\t\t\t\treason: \"Rest parameter annotation should be array type\".to_owned(),\n-\t\t\t\t\t\tpos,\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tTypeCheckError::Unsupported { thing, at } => {\n-\t\t\t\t\tDiagnostic::Position { reason: format!(\"Unsupported: {}\", thing), pos: at }\n-\t\t\t\t}\n-\t\t\t\tTypeCheckError::NotCallable { at, calling } => {\n-\t\t\t\t\tDiagnostic::Position { reason: format!(\"Cannot call {}\", calling), pos: at }\n-\t\t\t\t}\n-\t\t\t\tTypeCheckError::ExtraArgument { argument_position } => todo!(),\n-\t\t\t\tTypeCheckError::NotWritable { pos } => Diagnostic::Position {\n-\t\t\t\t\treason: format!(\"Cannot assign to immutable property\"),\n-\t\t\t\t\tpos,\n-\t\t\t\t},\n-\t\t\t\tTypeCheckError::ValueDoesNotMeetConstraint { pos, value_pos } => {\n-\t\t\t\t\tDiagnostic::Position {\n-\t\t\t\t\t\treason: format!(\"Assignment does not meet value constraint\"),\n-\t\t\t\t\t\tpos,\n+\t\t\t\t\t\tposition: pos,\n+\t\t\t\t\t\tkind: super::DiagnosticKind::Error,\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tTypeCheckError::ReDeclaredVariable { name, pos } => Diagnostic::Position {\n-\t\t\t\t\treason: format!(\"Cannot redeclare {} in scope\", name),\n-\t\t\t\t\tpos,\n-\t\t\t\t},\n-\t\t\t\tTypeCheckError::HiddenArgumentDoesNotMatch {\n-\t\t\t\t\tidentifier,\n-\t\t\t\t\trequirement,\n-\t\t\t\t\tfound,\n-\t\t\t\t\tcall_site,\n-\t\t\t\t} => Diagnostic::Position {\n-\t\t\t\t\treason: format!(\n-\t\t\t\t\t\t\"Calling function requires {} to be {}, found {}\",\n-\t\t\t\t\t\tidentifier, requirement, found\n-\t\t\t\t\t),\n-\t\t\t\t\tpos: call_site,\n+\t\t\t\tTypeCheckError::Unsupported { thing, at } => Diagnostic::Position {\n+\t\t\t\t\treason: format!(\"Unsupported: {}\", thing),\n+\t\t\t\t\tposition: at,\n+\t\t\t\t\tkind: super::DiagnosticKind::Error,\n \t\t\t\t},\n+\t\t\t\t// TypeCheckError::NotWritable { pos } => Diagnostic::Position {\n+\t\t\t\t// \treason: format!(\"Cannot assign to immutable property\"),\n+\t\t\t\t// \tposition: pos,\n+\t\t\t\t// \tkind: super::DiagnosticKind::Error,\n+\t\t\t\t// },\n+\t\t\t\t// TypeCheckError::CannotAssign { pos, value_pos, constraint, to } => {\n+\t\t\t\t// \tDiagnostic::PositionWithAdditionLabels {\n+\t\t\t\t// \t\treason: format!(\"Cannot assign {} to property of type {}\", to, constraint),\n+\t\t\t\t// \t\tposition: pos,\n+\t\t\t\t// \t\tlabels: vec![(format!(\"Expression has type {to}\"), Some(value_pos))],\n+\t\t\t\t// \t\tkind: super::DiagnosticKind::Error,\n+\t\t\t\t// \t}\n+\t\t\t\t// }\n+\t\t\t\t// TypeCheckError::ReDeclaredVariable { name, pos } => Diagnostic::Position {\n+\t\t\t\t// \treason: format!(\"Cannot redeclare {} in scope\", name),\n+\t\t\t\t// \tposition: pos,\n+\t\t\t\t// \tkind: super::DiagnosticKind::Error,\n+\t\t\t\t// },\n+\t\t\t\tTypeCheckError::ReDeclaredVariable { name, pos } => todo!(),\n \t\t\t\tTypeCheckError::FunctionDoesNotMeetConstraint {\n \t\t\t\t\tfunction_constraint,\n \t\t\t\t\tfunction_type,\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -519,15 +487,18 @@ mod defined_errors_and_warnings {\n \t\t\t\t\t\t\"{} constraint on function does not match synthesized form {}\",\n \t\t\t\t\t\tfunction_constraint, function_type\n \t\t\t\t\t),\n-\t\t\t\t\tpos: position,\n+\t\t\t\t\tposition,\n+\t\t\t\t\tkind: super::DiagnosticKind::Error,\n \t\t\t\t},\n \t\t\t\tTypeCheckError::StatementsNotRun { between } => Diagnostic::Position {\n \t\t\t\t\treason: \"Statements are never run\".to_owned(),\n-\t\t\t\t\tpos: between,\n+\t\t\t\t\tposition: between,\n+\t\t\t\t\tkind: super::DiagnosticKind::Error,\n \t\t\t\t},\n \t\t\t\tTypeCheckError::NotSatisfied { at, expected, found } => Diagnostic::Position {\n \t\t\t\t\treason: format!(\"Expected {} found {}\", expected, found),\n-\t\t\t\t\tpos: at,\n+\t\t\t\t\tposition: at,\n+\t\t\t\t\tkind: super::DiagnosticKind::Error,\n \t\t\t\t},\n \t\t\t}\n \t\t}\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -541,7 +512,7 @@ mod defined_errors_and_warnings {\n \t\t\texpression_value: bool,\n \t\t},\n \t\tIgnoringAsExpression(Span),\n-\t\tUnsupported {\n+\t\tUnimplemented {\n \t\t\tthing: &'static str,\n \t\t\tat: Span,\n \t\t},\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -556,24 +527,30 @@ mod defined_errors_and_warnings {\n \t\t\tmatch self {\n \t\t\t\tTypeCheckWarning::AwaitUsedOnNonPromise(span) => Diagnostic::Position {\n \t\t\t\t\treason: \"Unnecessary await expression / type is not promise\".to_owned(),\n-\t\t\t\t\tpos: span,\n+\t\t\t\t\tposition: span,\n+\t\t\t\t\tkind: super::DiagnosticKind::Warning,\n \t\t\t\t},\n \t\t\t\tTypeCheckWarning::DeadBranch { expression_span, expression_value } => {\n \t\t\t\t\tDiagnostic::Position {\n \t\t\t\t\t\treason: format!(\"Expression is always {:?}\", expression_value),\n-\t\t\t\t\t\tpos: expression_span,\n+\t\t\t\t\t\tposition: expression_span,\n+\t\t\t\t\t\tkind: super::DiagnosticKind::Warning,\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tTypeCheckWarning::IgnoringAsExpression(span) => Diagnostic::Position {\n \t\t\t\t\treason: \"'as' expressions are ignore by the checker\".to_owned(),\n-\t\t\t\t\tpos: span,\n+\t\t\t\t\tposition: span,\n+\t\t\t\t\tkind: super::DiagnosticKind::Warning,\n+\t\t\t\t},\n+\t\t\t\tTypeCheckWarning::Unimplemented { thing, at } => Diagnostic::Position {\n+\t\t\t\t\treason: format!(\"Unsupported: {}\", thing),\n+\t\t\t\t\tposition: at,\n+\t\t\t\t\tkind: super::DiagnosticKind::Warning,\n \t\t\t\t},\n-\t\t\t\tTypeCheckWarning::Unsupported { thing, at } => {\n-\t\t\t\t\tDiagnostic::Position { reason: format!(\"Unsupported: {}\", thing), pos: at }\n-\t\t\t\t}\n \t\t\t\tTypeCheckWarning::UselessExpression { expression_span } => Diagnostic::Position {\n \t\t\t\t\treason: \"Expression is always true\".to_owned(),\n-\t\t\t\t\tpos: expression_span,\n+\t\t\t\t\tposition: expression_span,\n+\t\t\t\t\tkind: super::DiagnosticKind::Warning,\n \t\t\t\t},\n \t\t\t}\n \t\t}\ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -590,10 +567,13 @@ pub(crate) struct TypeDefinitionModuleNotFound(pub PathBuf);\n \n impl Into<Diagnostic> for TypeDefinitionModuleNotFound {\n \tfn into(self) -> Diagnostic {\n-\t\tDiagnostic::Global(format!(\n-\t\t\t\"Could not find type definition module at '{}'\",\n-\t\t\tself.0.as_path().display()\n-\t\t))\n+\t\tDiagnostic::Global {\n+\t\t\treason: format!(\n+\t\t\t\t\"Could not find type definition module at '{}'\",\n+\t\t\t\tself.0.as_path().display()\n+\t\t\t),\n+\t\t\tkind: DiagnosticKind::Error,\n+\t\t}\n \t}\n }\n \ndiff --git a/checker/src/errors.rs b/checker/src/errors.rs\n--- a/checker/src/errors.rs\n+++ b/checker/src/errors.rs\n@@ -601,10 +581,10 @@ pub(crate) struct EntryPointNotFound(pub PathBuf);\n \n impl Into<Diagnostic> for EntryPointNotFound {\n \tfn into(self) -> Diagnostic {\n-\t\tDiagnostic::Global(format!(\n-\t\t\t\"Could not entry point module at '{}'\",\n-\t\t\tself.0.as_path().display()\n-\t\t))\n+\t\tDiagnostic::Global {\n+\t\t\treason: format!(\"Could not entry point module at '{}'\", self.0.as_path().display()),\n+\t\t\tkind: DiagnosticKind::Error,\n+\t\t}\n \t}\n }\n \ndiff --git a/checker/src/events/function_calling.rs b/checker/src/events/function_calling.rs\n--- a/checker/src/events/function_calling.rs\n+++ b/checker/src/events/function_calling.rs\n@@ -6,7 +6,7 @@ use source_map::{SourceId, Span};\n \n use crate::{\n \tstructures::functions::{\n-\t\tFunctionCallingError, FunctionNature, FunctionType, SynthesizedArgument,\n+\t\tFunctionCallingError, FunctionKind, FunctionType, SynthesizedArgument,\n \t},\n \ttypes::{\n \t\tpoly_types::{\ndiff --git a/checker/src/events/function_calling.rs b/checker/src/events/function_calling.rs\n--- a/checker/src/events/function_calling.rs\n+++ b/checker/src/events/function_calling.rs\n@@ -23,7 +23,7 @@ use crate::{\n \n use map_vec::Map as SmallMap;\n \n-use super::{apply_event, EarlyReturn, Reference};\n+use super::{apply_event, EarlyReturn, RootReference};\n \n /// TODO *result* name bad\n pub struct FunctionCallResult {\ndiff --git a/checker/src/events/function_calling.rs b/checker/src/events/function_calling.rs\n--- a/checker/src/events/function_calling.rs\n+++ b/checker/src/events/function_calling.rs\n@@ -68,9 +68,7 @@ impl FunctionType {\n \t\t// Type arguments of the function\n \t\tlet local_arguments: map_vec::Map<TypeId, FunctionTypeArgument> =\n \t\t\tif let Some(call_site_type_arguments) = call_site_type_arguments {\n-\t\t\t\tif let GenericFunctionTypeParameters::TypedParameters(ref typed_parameters) =\n-\t\t\t\t\tself.generic_type_parameters\n-\t\t\t\t{\n+\t\t\t\tif let Some(ref typed_parameters) = self.type_parameters {\n \t\t\t\t\ttyped_parameters\n \t\t\t\t\t\t.0\n \t\t\t\t\t\t.iter()\ndiff --git a/checker/src/events/function_calling.rs b/checker/src/events/function_calling.rs\n--- a/checker/src/events/function_calling.rs\n+++ b/checker/src/events/function_calling.rs\n@@ -124,13 +122,18 @@ impl FunctionType {\n \t\tlet mut type_arguments =\n \t\t\tTypeArguments { structure_arguments: parent_type_arguments.clone(), local_arguments };\n \n-\t\tmatch self.nature {\n-\t\t\tFunctionNature::Arrow => {\n-\t\t\t\tif !matches!(called_with_new, CalledWithNew::None) {\n-\t\t\t\t\ttodo!(\"Error\");\n+\t\tmatch self.kind {\n+\t\t\tFunctionKind::Arrow { get_set } => match get_set {\n+\t\t\t\tcrate::GetSetGeneratorOrNone::Generator => todo!(),\n+\t\t\t\tcrate::GetSetGeneratorOrNone::Get\n+\t\t\t\t| crate::GetSetGeneratorOrNone::Set\n+\t\t\t\t| crate::GetSetGeneratorOrNone::None => {\n+\t\t\t\t\tif !matches!(called_with_new, CalledWithNew::None) {\n+\t\t\t\t\t\ttodo!(\"Error\");\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n-\t\t\tFunctionNature::ClassConstructor { class_prototype, class_constructor } => {\n+\t\t\t},\n+\t\t\tFunctionKind::ClassConstructor { class_prototype, class_constructor } => {\n \t\t\t\tmatch called_with_new {\n \t\t\t\t\tCalledWithNew::New { .. } => {}\n \t\t\t\t\tCalledWithNew::SpecialSuperCall { on } => {\ndiff --git a/checker/src/events/function_calling.rs b/checker/src/events/function_calling.rs\n--- a/checker/src/events/function_calling.rs\n+++ b/checker/src/events/function_calling.rs\n@@ -142,7 +145,7 @@ impl FunctionType {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\tFunctionNature::Function { function_prototype: function } => {\n+\t\t\tFunctionKind::Function { function_prototype } => {\n \t\t\t\tif let (CalledWithNew::None { .. }, Some(arg)) = (called_with_new, &this_argument) {\n \t\t\t\t\ttype_arguments.set_this(*arg);\n \t\t\t\t}\ndiff --git a/checker/src/events/function_calling.rs b/checker/src/events/function_calling.rs\n--- a/checker/src/events/function_calling.rs\n+++ b/checker/src/events/function_calling.rs\n@@ -209,13 +212,31 @@ impl FunctionType {\n \t\t\t\t\t\t\tpos,\n \t\t\t\t\t\t} = reasons\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\tSome((pos, restriction))\n+\t\t\t\t\t\t\tSome((\n+\t\t\t\t\t\t\t\tpos,\n+\t\t\t\t\t\t\t\tcrate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\trestriction,\n+\t\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t))\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tNone\n \t\t\t\t\t\t};\n \t\t\t\t\t\terrors.push(FunctionCallingError::InvalidArgumentType {\n-\t\t\t\t\t\t\tparameter_type: parameter.ty,\n-\t\t\t\t\t\t\targument_type: *argument_type,\n+\t\t\t\t\t\t\tparameter_type: crate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\tparameter.ty,\n+\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\targument_type: crate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t*argument_type,\n+\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n \t\t\t\t\t\t\tparameter_position: parameter.position.clone(),\n \t\t\t\t\t\t\targument_position: argument_position.clone(),\n \t\t\t\t\t\t\trestriction,\ndiff --git a/checker/src/events/function_calling.rs b/checker/src/events/function_calling.rs\n--- a/checker/src/events/function_calling.rs\n+++ b/checker/src/events/function_calling.rs\n@@ -278,13 +299,31 @@ impl FunctionType {\n \t\t\t\t\t\tpos,\n \t\t\t\t\t} = reasons\n \t\t\t\t\t{\n-\t\t\t\t\t\tSome((pos, restriction))\n+\t\t\t\t\t\tSome((\n+\t\t\t\t\t\t\tpos,\n+\t\t\t\t\t\t\tcrate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\trestriction,\n+\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t))\n \t\t\t\t\t} else {\n \t\t\t\t\t\tNone\n \t\t\t\t\t};\n \t\t\t\t\terrors.push(FunctionCallingError::InvalidArgumentType {\n-\t\t\t\t\t\tparameter_type: parameter.ty,\n-\t\t\t\t\t\targument_type: *argument_type,\n+\t\t\t\t\t\tparameter_type: crate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\tparameter.ty,\n+\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\targument_type: crate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t*argument_type,\n+\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t),\n \t\t\t\t\t\targument_position: argument_pos.clone(),\n \t\t\t\t\t\tparameter_position: parameter.position.clone(),\n \t\t\t\t\t\trestriction,\ndiff --git a/checker/src/events/function_calling.rs b/checker/src/events/function_calling.rs\n--- a/checker/src/events/function_calling.rs\n+++ b/checker/src/events/function_calling.rs\n@@ -334,13 +373,33 @@ impl FunctionType {\n \t\t\t\t\t\t\t\t\tpos,\n \t\t\t\t\t\t\t\t} = reasons\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tSome((pos, restriction))\n+\t\t\t\t\t\t\t\t\tSome((\n+\t\t\t\t\t\t\t\t\t\tpos,\n+\t\t\t\t\t\t\t\t\t\tcrate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\t\t\trestriction,\n+\t\t\t\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\t\t))\n \t\t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\t\tNone\n \t\t\t\t\t\t\t\t};\n \t\t\t\t\t\t\terrors.push(FunctionCallingError::InvalidArgumentType {\n-\t\t\t\t\t\t\t\tparameter_type: rest_parameter.item_type,\n-\t\t\t\t\t\t\t\targument_type: *argument_type,\n+\t\t\t\t\t\t\t\tparameter_type:\n+\t\t\t\t\t\t\t\t\tcrate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\t\trest_parameter.item_type,\n+\t\t\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\targument_type:\n+\t\t\t\t\t\t\t\t\tcrate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\t\t*argument_type,\n+\t\t\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t\t\t),\n \t\t\t\t\t\t\t\targument_position: argument_pos.clone(),\n \t\t\t\t\t\t\t\tparameter_position: rest_parameter.position.clone(),\n \t\t\t\t\t\t\t\trestriction,\ndiff --git a/checker/src/events/function_calling.rs b/checker/src/events/function_calling.rs\n--- a/checker/src/events/function_calling.rs\n+++ b/checker/src/events/function_calling.rs\n@@ -348,11 +407,21 @@ impl FunctionType {\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\ttodo!(\"Collect extra arguments\")\n-\t\t\t\t\t// types.settings.allow_extra_arguments\n-\t\t\t\t\t// for idx in arguments.len()..all_parameters_length {\n-\t\t\t\t\t// \terrors.push(FunctionCallingError::ExtraArgument { idx });\n-\t\t\t\t\t// }\n+\t\t\t\t\t// TODO types.settings.allow_extra_arguments\n+\t\t\t\t\tlet mut left_over = arguments.iter().skip(all_parameters_length);\n+\t\t\t\t\tlet first = left_over.next().unwrap();\n+\t\t\t\t\tlet mut count = 1;\n+\t\t\t\t\tlet mut end = None;\n+\t\t\t\t\twhile let arg @ Some(_) = left_over.next() {\n+\t\t\t\t\t\tcount += 1;\n+\t\t\t\t\t\tend = arg;\n+\t\t\t\t\t}\n+\t\t\t\t\tlet position = if let Some(end) = end {\n+\t\t\t\t\t\tfirst.get_position().union(&end.get_position())\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tfirst.get_position()\n+\t\t\t\t\t};\n+\t\t\t\t\terrors.push(FunctionCallingError::ExtraArguments { count, position });\n \t\t\t\t}\n \t\t\t}\n \ndiff --git a/checker/src/events/function_calling.rs b/checker/src/events/function_calling.rs\n--- a/checker/src/events/function_calling.rs\n+++ b/checker/src/events/function_calling.rs\n@@ -363,7 +432,7 @@ impl FunctionType {\n \n \t\tfor (reference, restriction) in self.closed_over_references.clone().into_iter() {\n \t\t\tmatch reference {\n-\t\t\t\tReference::VariableId(ref variable) => {\n+\t\t\t\tRootReference::VariableId(ref variable) => {\n \t\t\t\t\tlet current_value = environment.get_value_of_variable(variable.clone());\n \n \t\t\t\t\tlet mut basic_subtyping = BasicEquality {\ndiff --git a/checker/src/events/function_calling.rs b/checker/src/events/function_calling.rs\n--- a/checker/src/events/function_calling.rs\n+++ b/checker/src/events/function_calling.rs\n@@ -381,14 +450,23 @@ impl FunctionType {\n \t\t\t\t\t) {\n \t\t\t\t\t\terrors.push(FunctionCallingError::ReferenceRestrictionDoesNotMatch {\n \t\t\t\t\t\t\treference,\n-\t\t\t\t\t\t\trequirement: restriction,\n-\t\t\t\t\t\t\tfound: current_value,\n+\t\t\t\t\t\t\trequirement: crate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\trestriction,\n+\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\t\t&types,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfound: crate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\tcurrent_value,\n+\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tReference::This if matches!(called_with_new, CalledWithNew::None) => {}\n-\t\t\t\tReference::This => {\n-\t\t\t\t\tcrate::utils::notify!(\"Here1\");\n+\t\t\t\tRootReference::This if matches!(called_with_new, CalledWithNew::None) => {}\n+\t\t\t\tRootReference::This => {\n \t\t\t\t\tlet value_of_this =\n \t\t\t\t\t\tthis_argument.unwrap_or_else(|| environment.get_value_of_this(types));\n \ndiff --git a/checker/src/events/function_calling.rs b/checker/src/events/function_calling.rs\n--- a/checker/src/events/function_calling.rs\n+++ b/checker/src/events/function_calling.rs\n@@ -407,8 +485,18 @@ impl FunctionType {\n \t\t\t\t\t) {\n \t\t\t\t\t\terrors.push(FunctionCallingError::ReferenceRestrictionDoesNotMatch {\n \t\t\t\t\t\t\treference,\n-\t\t\t\t\t\t\trequirement: restriction,\n-\t\t\t\t\t\t\tfound: value_of_this,\n+\t\t\t\t\t\t\trequirement: crate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\trestriction,\n+\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tfound: crate::errors::TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\tvalue_of_this,\n+\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n \t\t\t\t\t\t});\n \t\t\t\t\t}\n \t\t\t\t}\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -2,7 +2,10 @@\n //!\n //! Events is the general name for the IR. Effect = Events of a function\n \n-use crate::{context::VariableId, types::TypeStore};\n+use crate::{\n+\tcontext::VariableId,\n+\ttypes::{properties::Property, TypeStore},\n+};\n \n mod function_calling;\n pub use function_calling::*;\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -14,12 +17,12 @@ use crate::{\n };\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash, binary_serialize_derive::BinarySerializable)]\n-pub enum Reference {\n+pub enum RootReference {\n \tVariableId(VariableId),\n \tThis,\n }\n \n-impl Reference {\n+impl RootReference {\n \tpub fn get_name(self, environment: &Environment) -> String {\n \t\tmatch self {\n \t\t\tSelf::VariableId(id) => environment.get_variable_name(&id),\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -31,13 +34,18 @@ impl Reference {\n /// Events which happen\n ///\n /// Used for getting values and states\n+///\n+/// `reflects_dependency` means the result goes into the type argument map. This corresponds to the\n+/// type id (of constructor) it goes under\n+///\n+/// TODO store positions?\n #[derive(Debug, Clone, binary_serialize_derive::BinarySerializable)]\n pub enum Event {\n \t/// Reads variable\n \t///\n \t/// Can be used for DCE reasons, or finding variables in context\n \tReadsReference {\n-\t\treference: Reference,\n+\t\treference: RootReference,\n \t\treflects_dependency: Option<TypeId>,\n \t},\n \t/// Also used for DCE\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -47,7 +55,8 @@ pub enum Event {\n \tSetter {\n \t\ton: TypeId,\n \t\tunder: TypeId,\n-\t\tnew: TypeId,\n+\t\t// Can be a getter through define property\n+\t\tnew: Property,\n \t\treflects_dependency: Option<TypeId>,\n \t\t/// THIS DOES NOT CALL SETTERS, JUST SETS VALUE!\n \t\t/// TODO this is [define] property\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -66,9 +75,7 @@ pub enum Event {\n \tCallsType {\n \t\ton: TypeId,\n \t\twith: Box<[SynthesizedArgument]>,\n-\t\t/// The result of the call can go into the type argument map. This corresponds to the\n-\t\t/// key it goes under\n-\t\treturn_type_matches: Option<TypeId>,\n+\t\treflects_dependency: Option<TypeId>,\n \t\ttiming: CallingTiming,\n \t\tcalled_with_new: CalledWithNew,\n \t},\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -139,8 +146,10 @@ pub(crate) fn apply_event(\n \t\t\tif let Some(id) = reflects_dependency {\n \t\t\t\t// TODO checking constraints if inferred\n \t\t\t\tlet value = match variable {\n-\t\t\t\t\tReference::VariableId(variable) => environment.get_value_of_variable(variable),\n-\t\t\t\t\tReference::This => {\n+\t\t\t\t\tRootReference::VariableId(variable) => {\n+\t\t\t\t\t\tenvironment.get_value_of_variable(variable)\n+\t\t\t\t\t}\n+\t\t\t\t\tRootReference::This => {\n \t\t\t\t\t\tthis_argument.unwrap_or_else(|| environment.get_value_of_this(types))\n \t\t\t\t\t}\n \t\t\t\t};\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -159,7 +168,15 @@ pub(crate) fn apply_event(\n \t\t\tlet on = specialize(on, type_arguments, environment, types);\n \t\t\tlet under = specialize(under, type_arguments, environment, types);\n \n-\t\t\tlet new = specialize(new, type_arguments, environment, types);\n+\t\t\tlet new = match new {\n+\t\t\t\tProperty::Value(new) => {\n+\t\t\t\t\tProperty::Value(specialize(new, type_arguments, environment, types))\n+\t\t\t\t}\n+\t\t\t\tProperty::Get(_) => todo!(),\n+\t\t\t\tProperty::Set(_) => todo!(),\n+\t\t\t\tProperty::GetAndSet(_, _) => todo!(),\n+\t\t\t};\n+\n \t\t\t// crate::utils::notify!(\n \t\t\t// \t\"[Event::Setter] {}[{}] = {}\",\n \t\t\t// \tenvironment.debug_type(under),\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -168,19 +185,23 @@ pub(crate) fn apply_event(\n \t\t\t// );\n \n \t\t\tif initialization {\n-\t\t\t\tenvironment.properties.entry(on).or_default().push((under, new));\n-\t\t\t\tenvironment.context_type.events.push(Event::Setter {\n-\t\t\t\t\ton,\n-\t\t\t\t\tnew,\n-\t\t\t\t\tunder,\n-\t\t\t\t\treflects_dependency: None,\n-\t\t\t\t\tinitialization: true,\n-\t\t\t\t});\n+\t\t\t\tenvironment.register_property(on, under, new);\n \t\t\t} else {\n-\t\t\t\tlet returned = environment.set_property(on, under, new, types).unwrap();\n-\n-\t\t\t\tif let Some(id) = reflects_dependency {\n-\t\t\t\t\ttype_arguments.set_id(id, returned.unwrap_or(TypeId::UNDEFINED_TYPE), types);\n+\t\t\t\tmatch new {\n+\t\t\t\t\tProperty::Value(new) => {\n+\t\t\t\t\t\tlet returned = environment.set_property(on, under, new, types).unwrap();\n+\n+\t\t\t\t\t\tif let Some(id) = reflects_dependency {\n+\t\t\t\t\t\t\ttype_arguments.set_id(\n+\t\t\t\t\t\t\t\tid,\n+\t\t\t\t\t\t\t\treturned.unwrap_or(TypeId::UNDEFINED_TYPE),\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tProperty::Get(_) => todo!(),\n+\t\t\t\t\tProperty::Set(_) => todo!(),\n+\t\t\t\t\tProperty::GetAndSet(_, _) => todo!(),\n \t\t\t\t}\n \t\t\t}\n \t\t}\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -196,7 +217,7 @@ pub(crate) fn apply_event(\n \t\t\t\ttype_arguments.set_id(id, value.into(), types);\n \t\t\t}\n \t\t}\n-\t\tEvent::CallsType { on, with, return_type_matches, timing, called_with_new } => {\n+\t\tEvent::CallsType { on, with, reflects_dependency, timing, called_with_new } => {\n \t\t\tlet on = specialize(on, type_arguments, environment, types);\n \n \t\t\tlet with = with\ndiff --git a/checker/src/events/mod.rs b/checker/src/events/mod.rs\n--- a/checker/src/events/mod.rs\n+++ b/checker/src/events/mod.rs\n@@ -221,11 +242,18 @@ pub(crate) fn apply_event(\n \t\t\t\t\t\tenvironment,\n \t\t\t\t\t\ttypes,\n \t\t\t\t\t\tcalled_with_new,\n-\t\t\t\t\t)\n-\t\t\t\t\t.expect(\"Inference and/or checking failed\");\n-\n-\t\t\t\t\tif let Some(return_type_matches) = return_type_matches {\n-\t\t\t\t\t\ttype_arguments.set_id(return_type_matches, result.returned_type, types);\n+\t\t\t\t\t);\n+\t\t\t\t\tmatch result {\n+\t\t\t\t\t\tOk(result) => {\n+\t\t\t\t\t\t\tif let Some(reflects_dependency) = reflects_dependency {\n+\t\t\t\t\t\t\t\ttype_arguments.set_id(\n+\t\t\t\t\t\t\t\t\treflects_dependency,\n+\t\t\t\t\t\t\t\t\tresult.returned_type,\n+\t\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tErr(_) => todo!(\"inference and or checking failed at function\"),\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\t// TODO different\ndiff --git a/checker/src/lib.rs b/checker/src/lib.rs\n--- a/checker/src/lib.rs\n+++ b/checker/src/lib.rs\n@@ -31,9 +31,19 @@ use structures::functions::AutoConstructorId;\n \n use types::TypeStore;\n \n-pub use behavior::{functions::SynthesizableFunction, variables::check_variable_initialization};\n+pub use behavior::{\n+\tassignments::{\n+\t\tAssignable, AssignmentKind, AssignmentReturnStatus, IncrementOrDecrement, Reference,\n+\t\tSynthesizableExpression,\n+\t},\n+\tfunctions::{\n+\t\tGetSetGeneratorOrNone, RegisterAsType, RegisterOnExisting, RegisterOnExistingObject,\n+\t\tSynthesizableFunction,\n+\t},\n+\tvariables::check_variable_initialization,\n+};\n pub use context::{GeneralEnvironment, Root};\n-pub use errors::{Diagnostic, DiagnosticsContainer, ErrorWarningInfo};\n+pub use errors::{Diagnostic, DiagnosticKind, DiagnosticsContainer};\n pub use settings::TypeCheckSettings;\n pub use structures::{\n \tfunctions::{FunctionPointer, InternalFunctionId},\ndiff --git a/checker/src/lib.rs b/checker/src/lib.rs\n--- a/checker/src/lib.rs\n+++ b/checker/src/lib.rs\n@@ -42,12 +52,11 @@ pub use structures::{\n \tvariables::Variable,\n };\n pub use types::{\n-\tcalling::call_type_handle_errors, operations::*, poly_types::GenericFunctionTypeParameters,\n-\tsubtyping,\n+\tcalling::call_type_handle_errors, operations::*, poly_types::GenericTypeParameters, subtyping,\n };\n \n pub use type_mappings::*;\n-pub use types::{Constant, Type, TypeId};\n+pub use types::{properties::Property, Constant, Type, TypeId};\n \n pub use context::{Environment, Scope};\n pub(crate) use structures::functions;\ndiff --git a/checker/src/lib.rs b/checker/src/lib.rs\n--- a/checker/src/lib.rs\n+++ b/checker/src/lib.rs\n@@ -165,15 +174,22 @@ impl<'a, T: crate::FSResolver> CheckingData<'a, T> {\n \t\t// \t.unwrap();\n \n \t\t// // module.get_exports()\n-\t\t// Ok((todo!(), &mut self.error_warning_info_handler, &mut self.type_mappings))\n+\t\t// Ok((todo!(), &mut self.diagnostics_container, &mut self.type_mappings))\n \t}\n \n+\t/// TODO temp, needs better place\n \tpub fn raise_decidable_result_error(&mut self, span: Span, value: bool) {\n \t\tself.diagnostics_container.add_error(TypeCheckWarning::DeadBranch {\n \t\t\texpression_span: span,\n \t\t\texpression_value: value,\n \t\t})\n \t}\n+\n+\t/// TODO temp, needs better place\n+\tpub fn raise_unimplemented_error(&mut self, item: &'static str, span: Span) {\n+\t\tself.diagnostics_container\n+\t\t\t.add_warning(TypeCheckWarning::Unimplemented { thing: item, at: span })\n+\t}\n }\n \n /// TODO this is a bad name\ndiff --git a/checker/src/serialization.rs b/checker/src/serialization.rs\n--- a/checker/src/serialization.rs\n+++ b/checker/src/serialization.rs\n@@ -62,6 +62,16 @@ impl<T: BinarySerializable> BinarySerializable for Vec<T> {\n \t}\n }\n \n+impl<T: BinarySerializable> BinarySerializable for Box<T> {\n+\tfn serialize(self, buf: &mut Vec<u8>) {\n+\t\tBinarySerializable::serialize(*self, buf)\n+\t}\n+\n+\tfn deserialize<I: Iterator<Item = u8>>(iter: &mut I, buf_source: SourceId) -> Self {\n+\t\tBox::new(T::deserialize(iter, buf_source))\n+\t}\n+}\n+\n impl<T: BinarySerializable> BinarySerializable for Box<[T]> {\n \tfn serialize(self, buf: &mut Vec<u8>) {\n \t\tbuf.extend_from_slice(&u16::try_from(self.len()).unwrap().to_le_bytes());\ndiff --git a/checker/src/structures/functions.rs b/checker/src/structures/functions.rs\n--- a/checker/src/structures/functions.rs\n+++ b/checker/src/structures/functions.rs\n@@ -7,10 +7,12 @@ use derive_enum_from_into::{EnumFrom, EnumTryInto};\n use source_map::Span;\n \n use crate::{\n+\tbehavior::functions::GetSetGeneratorOrNone,\n \tcontext::FunctionId,\n-\tevents::{Event, Reference},\n+\terrors::TypeStringRepresentation,\n+\tevents::{Event, RootReference},\n \ttypes::{\n-\t\tpoly_types::{GenericFunctionTypeParameters, ResolveGenerics, TypeArguments},\n+\t\tpoly_types::{GenericTypeParameters, ResolveGenerics, TypeArguments},\n \t\tTypeId,\n \t},\n \tCheckingData,\ndiff --git a/checker/src/structures/functions.rs b/checker/src/structures/functions.rs\n--- a/checker/src/structures/functions.rs\n+++ b/checker/src/structures/functions.rs\n@@ -70,16 +72,6 @@ impl AutoConstructorId {\n \n impl Eq for FunctionPointer {}\n \n-/// TODO ...\n-pub struct SynthesizedFunction {\n-\tpub(crate) returned: TypeId,\n-\tpub(crate) events: Vec<Event>,\n-\t/// TODO explain\n-\tpub(crate) closed_over_references: HashMap<Reference, TypeId>,\n-\tpub(crate) synthesized_parameters: SynthesizedParameters,\n-\tpub(crate) type_parameters: GenericFunctionTypeParameters,\n-}\n-\n /// The type of `this` that a function has ....?\n /// TODO needs for work\n #[derive(Clone, Debug)]\ndiff --git a/checker/src/structures/functions.rs b/checker/src/structures/functions.rs\n--- a/checker/src/structures/functions.rs\n+++ b/checker/src/structures/functions.rs\n@@ -99,25 +91,25 @@ impl ThisBinding {\n #[derive(Clone, Debug, binary_serialize_derive::BinarySerializable)]\n pub struct FunctionType {\n \t/// TODO not sure about this field and how it tails with Pi Types\n-\tpub generic_type_parameters: GenericFunctionTypeParameters,\n+\tpub type_parameters: Option<GenericTypeParameters>,\n \tpub parameters: SynthesizedParameters,\n \tpub return_type: TypeId,\n \t/// Side effects of the function\n \tpub effects: Vec<Event>,\n \n \t/// TODO type alias\n-\tpub closed_over_references: HashMap<Reference, TypeId>,\n+\tpub closed_over_references: HashMap<RootReference, TypeId>,\n \n \t/// Can be called for constant result\n \tpub constant_id: Option<String>,\n \n-\tpub nature: FunctionNature,\n+\tpub kind: FunctionKind,\n }\n \n /// Decides what to do with `new`\n #[derive(Clone, Copy, Debug, binary_serialize_derive::BinarySerializable)]\n-pub enum FunctionNature {\n-\tArrow,\n+pub enum FunctionKind {\n+\tArrow { get_set: GetSetGeneratorOrNone },\n \tFunction { function_prototype: TypeId },\n \tClassConstructor { class_prototype: TypeId, class_constructor: TypeId },\n }\ndiff --git a/checker/src/structures/functions.rs b/checker/src/structures/functions.rs\n--- a/checker/src/structures/functions.rs\n+++ b/checker/src/structures/functions.rs\n@@ -188,28 +180,27 @@ impl ResolveGenerics for SynthesizedArgument {\n }\n \n /// Errors from trying to call a function\n-#[derive(Debug)]\n pub enum FunctionCallingError {\n \tInvalidArgumentType {\n-\t\tparameter_type: TypeId,\n-\t\targument_type: TypeId,\n+\t\tparameter_type: TypeStringRepresentation,\n+\t\targument_type: TypeStringRepresentation,\n \t\targument_position: Span,\n \t\tparameter_position: Span,\n-\t\trestriction: Option<(Span, TypeId)>,\n+\t\trestriction: Option<(Span, TypeStringRepresentation)>,\n \t},\n \tMissingArgument {\n \t\tparameter_pos: Span,\n \t},\n-\tExtraArgument {\n-\t\tidx: usize,\n+\tExtraArguments {\n+\t\tcount: usize,\n \t\tposition: Span,\n \t},\n \tNotCallable {\n-\t\tcalling: TypeId,\n+\t\tcalling: TypeStringRepresentation,\n \t},\n \tReferenceRestrictionDoesNotMatch {\n-\t\treference: Reference,\n-\t\trequirement: TypeId,\n-\t\tfound: TypeId,\n+\t\treference: RootReference,\n+\t\trequirement: TypeStringRepresentation,\n+\t\tfound: TypeStringRepresentation,\n \t},\n }\ndiff --git a/checker/src/structures/jsx.rs b/checker/src/structures/jsx.rs\n--- a/checker/src/structures/jsx.rs\n+++ b/checker/src/structures/jsx.rs\n@@ -1,15 +1,6 @@\n use std::collections::HashMap;\n \n-use crate::{context::VariableId, FunctionPointer, TypeId};\n-\n-/// Different *components* for JSX elements\n-/// e.g `<*component_name*>`\n-#[derive(Debug, Clone)]\n-pub enum JSXComponentReference {\n-\tFunction(Vec<FunctionPointer>),\n-\tClass(VariableId),\n-\t// ViaTagName(TagNamedMapping),\n-}\n+use crate::TypeId;\n \n // /// TODO not sure might be TypeId\n // #[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]\ndiff --git a/checker/src/structures/modules.rs b/checker/src/structures/modules.rs\n--- a/checker/src/structures/modules.rs\n+++ b/checker/src/structures/modules.rs\n@@ -28,15 +28,7 @@ pub enum ModuleFromPathError {\n \n impl From<ModuleFromPathError> for Diagnostic {\n \tfn from(err: ModuleFromPathError) -> Self {\n-\t\tmatch err {\n-\t\t\tModuleFromPathError::ParseError(parse_error) => todo!(\"parse_error.into()\"),\n-\t\t\tModuleFromPathError::PathDoesNotExist(path) => {\n-\t\t\t\tDiagnostic::Global(format!(\"Cannot find module '{}'\", path.display()))\n-\t\t\t}\n-\t\t\tModuleFromPathError::NoResolverForExtension(extension) => {\n-\t\t\t\tDiagnostic::Global(format!(\"No resolver for extension '.{}'\", extension))\n-\t\t\t}\n-\t\t}\n+\t\ttodo!()\n \t}\n }\n \ndiff --git a/checker/src/structures/objects.rs b/checker/src/structures/objects.rs\n--- a/checker/src/structures/objects.rs\n+++ b/checker/src/structures/objects.rs\n@@ -1,8 +1,12 @@\n-use crate::{context::Environment, events::Event, types::TypeStore, TypeId};\n+use crate::{\n+\tcontext::Environment,\n+\ttypes::{properties::Property, TypeStore},\n+\tTypeId,\n+};\n \n // TODO slice indexes\n pub struct ObjectBuilder {\n-\tobject: TypeId,\n+\tpub(crate) object: TypeId,\n }\n \n impl ObjectBuilder {\ndiff --git a/checker/src/structures/objects.rs b/checker/src/structures/objects.rs\n--- a/checker/src/structures/objects.rs\n+++ b/checker/src/structures/objects.rs\n@@ -15,17 +19,8 @@ impl ObjectBuilder {\n \t\tSelf { object }\n \t}\n \n-\tpub fn append(&mut self, environment: &mut Environment, under: TypeId, value: TypeId) {\n-\t\t// TODO combine\n-\t\tenvironment.properties.entry(self.object).or_default().push((under, value));\n-\n-\t\tenvironment.context_type.events.push(Event::Setter {\n-\t\t\ton: self.object,\n-\t\t\tnew: value,\n-\t\t\tunder,\n-\t\t\treflects_dependency: None,\n-\t\t\tinitialization: true,\n-\t\t});\n+\tpub fn append(&mut self, environment: &mut Environment, under: TypeId, value: Property) {\n+\t\tenvironment.register_property(self.object, under, value)\n \t}\n \n \tpub fn build_object(self) -> TypeId {\ndiff --git a/checker/src/structures/operators.rs b/checker/src/structures/operators.rs\n--- a/checker/src/structures/operators.rs\n+++ b/checker/src/structures/operators.rs\n@@ -4,10 +4,13 @@ pub enum BinaryOperator {\n \tAdd,\n \tMultiply,\n \tModulo,\n-\t/// TODO undecided\n \tExponent,\n \tBitwiseOperators(BitwiseOperators),\n \tRelationOperator(RelationOperator),\n+\t/// TODO undecided, how to represent of as composite of others?\n+\tSubtract,\n+\tDivide,\n+\tLogicalOperator(LogicalOperator),\n }\n \n #[derive(Debug, Clone, Copy, binary_serialize_derive::BinarySerializable)]\ndiff --git a/checker/src/structures/operators.rs b/checker/src/structures/operators.rs\n--- a/checker/src/structures/operators.rs\n+++ b/checker/src/structures/operators.rs\n@@ -36,7 +39,7 @@ pub enum LogicalOperator {\n pub enum UnaryOperator {\n \t/// `-x`\n \tNegation,\n-\t/// `1/x`\n+\t/// TODO non standard `1/x`\n \tMultiplicativeInverse,\n \tLogicalNegation,\n }\ndiff --git a/checker/src/structures/variables.rs b/checker/src/structures/variables.rs\n--- a/checker/src/structures/variables.rs\n+++ b/checker/src/structures/variables.rs\n@@ -21,7 +21,7 @@ impl Variable {\n #[derive(Copy, Clone, Debug, binary_serialize_derive::BinarySerializable)]\n pub enum VariableMutability {\n \tConstant,\n-\tMutable { reassignment_constraint: TypeId },\n+\tMutable { reassignment_constraint: Option<TypeId> },\n }\n \n #[derive(Clone, Debug)]\ndiff --git a/checker/src/temp.rs b/checker/src/temp.rs\n--- a/checker/src/temp.rs\n+++ b/checker/src/temp.rs\n@@ -53,7 +53,7 @@ pub struct AssertTypeExplainer;\n // \t\tdata.type_mappings.get_instance_for_expression(&argument.get_expression_id().unwrap());\n // \tlet diagnostic = if let Some(instance) = instance {\n // \t\tlet type_id = instance.get_type();\n-// \t\tlet r#type = data.environment.get_type_by_id(type_id);\n+// \t\tlet ty = data.environment.get_type_by_id(type_id);\n // \t\tlet mut value_as_string =\n // \t\t\tTypeDisplay::to_string(&type_id, &data.environment.into_general_environment());\n \ndiff --git a/checker/src/temp.rs b/checker/src/temp.rs\n--- a/checker/src/temp.rs\n+++ b/checker/src/temp.rs\n@@ -61,7 +61,7 @@ pub struct AssertTypeExplainer;\n // \t\tif let Some(specializations) = specializations {\n // \t\t\tvalue_as_string.push_str(\" specialized with \");\n // \t\t\tfor specialization in specializations.iter().copied() {\n-// \t\t\t\tlet r#type = data.environment.get_type_by_id(specialization);\n+// \t\t\t\tlet ty = data.environment.get_type_by_id(specialization);\n // \t\t\t\tlet specializations_as_string = TypeDisplay::to_string(\n // \t\t\t\t\t&specialization,\n // \t\t\t\t\t&data.environment.into_general_environment(),\ndiff --git a/checker/src/temp.rs b/checker/src/temp.rs\n--- a/checker/src/temp.rs\n+++ b/checker/src/temp.rs\n@@ -123,8 +123,8 @@ pub struct AssertTypeExplainer;\n // \t\t\ttodo!()\n // \t\t// value_as_string.push_str(\" specialized with \");\n // \t\t// for specialization in specializations.iter().copied() {\n-// \t\t// \tlet r#type = data.environment.get_type_by_id(specialization);\n-// \t\t// \tlet specializations_as_string = (specialization, r#type)\n+// \t\t// \tlet ty = data.environment.get_type_by_id(specialization);\n+// \t\t// \tlet specializations_as_string = (specialization, ty)\n // \t\t// \t\t.to_string(&data.environment.into_general_environment());\n \n // \t\t// \tvalue_as_string.push_str(&specializations_as_string);\ndiff --git a/checker/src/type_mappings.rs b/checker/src/type_mappings.rs\n--- a/checker/src/type_mappings.rs\n+++ b/checker/src/type_mappings.rs\n@@ -1,12 +1,31 @@\n-use std::{collections::HashMap, path::PathBuf};\n+use std::{\n+\tcollections::{HashMap, HashSet},\n+\tpath::PathBuf,\n+};\n \n use source_map::Span;\n \n use crate::{\n-\tcontext::VariableId, structures::variables::VariableWithValue, types::TypeId, FunctionPointer,\n-\tJSXComponentReference, Variable,\n+\tcontext::VariableId, structures::variables::VariableWithValue, types::TypeId, Variable,\n };\n \n+/// TODO temp\n+#[derive(PartialEq, Eq, Debug)]\n+pub struct HashableSpan(pub Span);\n+\n+impl From<Span> for HashableSpan {\n+\tfn from(item: Span) -> Self {\n+\t\tHashableSpan(item)\n+\t}\n+}\n+\n+impl std::hash::Hash for HashableSpan {\n+\tfn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+\t\tself.0.start.hash(state);\n+\t\tself.0.end.hash(state);\n+\t}\n+}\n+\n /// [TypeMappings] is used to retaining information between passes, including the synthesize and checking passes\n /// This for use in the both use in the compiler and compiler plugins\n /// Checking things are held on [crate::Memory], function things are held on [crate::HoistedFunctionContainer]\ndiff --git a/checker/src/type_mappings.rs b/checker/src/type_mappings.rs\n--- a/checker/src/type_mappings.rs\n+++ b/checker/src/type_mappings.rs\n@@ -16,33 +35,16 @@ use crate::{\n #[derive(Default, Debug)]\n pub struct TypeMappings {\n \t/// Figures out the types of the expressions in the AST\n-\tpub expressions_to_instances: HashMap<Span, Instance>,\n+\tpub expressions_to_instances: HashMap<HashableSpan, Instance>,\n \t/// [Variable] data to a AST mapping\n-\tpub variables_to_variables: HashMap<Span, Variable>,\n+\tpub variables_to_variables: HashMap<HashableSpan, Variable>,\n \t/// Property to type, TODO kind of temp\n-\tpub properties_to_types: HashMap<Span, TypeId>,\n+\tpub properties_to_types: HashMap<HashableSpan, TypeId>,\n \t/// Data to a AST mapping. For classes this points to the shape\n-\tpub types_to_types: HashMap<Span, TypeId>,\n-\t/// Returns the underlying type of a component referenced in JSX. etc whether <X> is a\n-\t/// function or a class. Contains the [VariableId] of said instance\n-\tpub jsx_element_map: HashMap<Span, JSXComponentReference>,\n-\tpub import_statements_to_pointing_path: HashMap<Span, PathBuf>,\n-\t/// TODO this is very similar to types to types apart from StatementFunctions do not have parser::TypeId\n-\tpub functions_to_prototypes: HashMap<Span, TypeId>,\n-\t/// TODO very similar to above\n-\tpub classes_to_constructors: HashMap<Span, TypeId>,\n-\t/// For for [FunctionPointer::Internal] this is the declaration in a module or definition\n-\tpub functions_to_positions: HashMap<FunctionPointer, Span>,\n-}\n-\n-impl TypeMappings {\n-\t/// Optional as new AST with new ExpressionId may not have added to the map\n-\t/// TODO funny function :0\n-\t/// TODO maybe return a error instance if cannot find instance for expression\n-\tpub fn get_instance_for_expression(&self, expression_id: &Span) -> Option<&Instance> {\n-\t\ttodo!()\n-\t\t// self.expressions_to_instances.get(expression_id)\n-\t}\n+\tpub types_to_types: HashMap<HashableSpan, TypeId>,\n+\tpub import_statements_to_pointing_path: HashMap<HashableSpan, PathBuf>,\n+\t/// can be used for tree shaking\n+\tpub called_functions: HashSet<HashableSpan>,\n }\n \n /// See https://www.internalpointers.com/post/understanding-meaning-lexpressions-and-rexpressions-c for a understanding\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -2,7 +2,7 @@ use source_map::Span;\n \n use crate::{\n \tcontext::{Environment, PolyBase},\n-\terrors::{TypeCheckError, TypeStringRepresentation},\n+\terrors::TypeCheckError,\n \tevents::{CalledWithNew, Event, FunctionCallResult},\n \tstructures::{\n \t\tfunctions::{FunctionType, SynthesizedArgument},\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -12,7 +12,7 @@ use crate::{\n \tTypeId,\n };\n \n-use super::{poly_types::GenericFunctionTypeParameters, Constructor, FunctionNature, TypeStore};\n+use super::{Constructor, FunctionNature, TypeStore};\n \n pub fn call_type_handle_errors<T: crate::FSResolver>(\n \tty: TypeId,\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -37,89 +37,10 @@ pub fn call_type_handle_errors<T: crate::FSResolver>(\n \tmatch result {\n \t\tOk(FunctionCallResult { returned_type, warnings }) => returned_type,\n \t\tErr(errors) => {\n-\t\t\tuse crate::structures::functions::FunctionCallingError;\n-\t\t\t// TODO map\n \t\t\tfor error in errors {\n-\t\t\t\tlet error = match error {\n-\t\t\t\t\tFunctionCallingError::InvalidArgumentType {\n-\t\t\t\t\t\targument_type,\n-\t\t\t\t\t\targument_position,\n-\t\t\t\t\t\tparameter_type,\n-\t\t\t\t\t\tparameter_position,\n-\t\t\t\t\t\trestriction,\n-\t\t\t\t\t} => TypeCheckError::ArgumentDoesNotMatchParameter {\n-\t\t\t\t\t\tparameter_type: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\tparameter_type,\n-\t\t\t\t\t\t\t&environment.into_general_environment(),\n-\t\t\t\t\t\t\t&checking_data.types,\n-\t\t\t\t\t\t\tchecking_data.settings.debug_types,\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\targument_type: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\targument_type,\n-\t\t\t\t\t\t\t&environment.into_general_environment(),\n-\t\t\t\t\t\t\t&checking_data.types,\n-\t\t\t\t\t\t\tchecking_data.settings.debug_types,\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tparameter_position,\n-\t\t\t\t\t\targument_position,\n-\t\t\t\t\t\trestriction: restriction.map(|(pos, restriction)| {\n-\t\t\t\t\t\t\t(\n-\t\t\t\t\t\t\t\tpos,\n-\t\t\t\t\t\t\t\tTypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\t\t\trestriction,\n-\t\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n-\t\t\t\t\t\t\t\t\t&checking_data.types,\n-\t\t\t\t\t\t\t\t\tchecking_data.settings.debug_types,\n-\t\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\t)\n-\t\t\t\t\t\t}),\n-\t\t\t\t\t},\n-\t\t\t\t\tFunctionCallingError::MissingArgument { parameter_pos } => {\n-\t\t\t\t\t\tTypeCheckError::MissingArguments {\n-\t\t\t\t\t\t\tfunction: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\t\tty,\n-\t\t\t\t\t\t\t\t&environment.into_general_environment(),\n-\t\t\t\t\t\t\t\t&checking_data.types,\n-\t\t\t\t\t\t\t\tchecking_data.settings.debug_types,\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tparameter_pos,\n-\t\t\t\t\t\t\tcall_site: call_site.clone(),\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tFunctionCallingError::ExtraArgument { idx, position } => {\n-\t\t\t\t\t\tTypeCheckError::ExtraArgument { argument_position: position }\n-\t\t\t\t\t}\n-\t\t\t\t\tFunctionCallingError::NotCallable { calling } => TypeCheckError::NotCallable {\n-\t\t\t\t\t\tat: call_site.clone(),\n-\t\t\t\t\t\tcalling: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\tty,\n-\t\t\t\t\t\t\t&environment.into_general_environment(),\n-\t\t\t\t\t\t\t&checking_data.types,\n-\t\t\t\t\t\t\tchecking_data.settings.debug_types,\n-\t\t\t\t\t\t),\n-\t\t\t\t\t},\n-\t\t\t\t\tFunctionCallingError::ReferenceRestrictionDoesNotMatch {\n-\t\t\t\t\t\treference,\n-\t\t\t\t\t\trequirement,\n-\t\t\t\t\t\tfound,\n-\t\t\t\t\t} => TypeCheckError::HiddenArgumentDoesNotMatch {\n-\t\t\t\t\t\tidentifier: reference.get_name(environment),\n-\t\t\t\t\t\trequirement: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\trequirement,\n-\t\t\t\t\t\t\t&environment.into_general_environment(),\n-\t\t\t\t\t\t\t&checking_data.types,\n-\t\t\t\t\t\t\tchecking_data.settings.debug_types,\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tfound: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\tfound,\n-\t\t\t\t\t\t\t&environment.into_general_environment(),\n-\t\t\t\t\t\t\t&checking_data.types,\n-\t\t\t\t\t\t\tchecking_data.settings.debug_types,\n-\t\t\t\t\t\t),\n-\t\t\t\t\t\tcall_site: call_site.clone(),\n-\t\t\t\t\t},\n-\t\t\t\t};\n-\t\t\t\tchecking_data.diagnostics_container.add_error(error)\n+\t\t\t\tchecking_data\n+\t\t\t\t\t.diagnostics_container\n+\t\t\t\t\t.add_error(TypeCheckError::FunctionCallingError(error))\n \t\t\t}\n \t\t\tTypeId::ERROR_TYPE\n \t\t}\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -140,14 +61,11 @@ pub fn call_type(\n \tif on == TypeId::ERROR_TYPE {\n \t\tOk(FunctionCallResult { returned_type: on, warnings: Default::default() })\n \t} else if let Type::Function(function_type, variant) = types.get_type_by_id(on) {\n-\t\tlet arg = if let FunctionNature::Source(_, _, id) = variant { id.clone() } else { None };\n-\t\tenvironment.context_type.events.push(Event::CallsType {\n-\t\t\ton,\n-\t\t\twith: arguments.clone().into_boxed_slice(),\n-\t\t\treturn_type_matches: None,\n-\t\t\ttiming: crate::events::CallingTiming::Synchronous,\n-\t\t\tcalled_with_new,\n-\t\t});\n+\t\t// TODO as Rc to avoid expensive clone\n+\t\tlet function_type = function_type.clone();\n+\t\tlet arg =\n+\t\t\tif let FunctionNature::Source(_, this_arg) = variant { this_arg.clone() } else { None };\n+\n \t\t// TODO should be done after call to check that arguments are correct\n \t\tif let Some(const_fn_ident) = function_type.constant_id.as_deref() {\n \t\t\tlet this_argument = this_argument.or(arg);\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -171,8 +89,7 @@ pub fn call_type(\n \t\t\t\t\t\ttypes,\n \t\t\t\t\t\tenvironment,\n \t\t\t\t\t\tcalled_with_new,\n-\t\t\t\t\t)\n-\t\t\t\t\t.unwrap()\n+\t\t\t\t\t)?\n \t\t\t\t\t.returned_type;\n \n \t\t\t\tlet new_type = Type::Constructor(Constructor::FunctionResult {\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -180,10 +97,22 @@ pub fn call_type(\n \t\t\t\t\twith: with.clone(),\n \t\t\t\t\tresult: super::PolyPointer::Fixed(result),\n \t\t\t\t});\n+\n+\t\t\t\tcrate::utils::notify!(\"{:?}\", types.debug_type(result));\n+\n \t\t\t\tlet ty = types.register_type(new_type);\n \n+\t\t\t\tenvironment.context_type.events.push(Event::CallsType {\n+\t\t\t\t\ton,\n+\t\t\t\t\twith: arguments.clone().into_boxed_slice(),\n+\t\t\t\t\treflects_dependency: Some(ty),\n+\t\t\t\t\ttiming: crate::events::CallingTiming::Synchronous,\n+\t\t\t\t\tcalled_with_new,\n+\t\t\t\t});\n+\n \t\t\t\treturn Ok(FunctionCallResult { returned_type: ty, warnings: Default::default() });\n \t\t\t} else {\n+\t\t\t\t// TODO event\n \t\t\t\tlet returned_type = crate::behavior::constant_functions::call_constant_function(\n \t\t\t\t\t// TODO temp\n \t\t\t\t\t&const_fn_ident.to_owned(),\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -193,23 +122,23 @@ pub fn call_type(\n \t\t\t\t);\n \n \t\t\t\tif let Ok(returned_type) = returned_type {\n-\t\t\t\t\tOk(FunctionCallResult { returned_type, warnings: Default::default() })\n+\t\t\t\t\treturn Ok(FunctionCallResult { returned_type, warnings: Default::default() });\n \t\t\t\t} else {\n-\t\t\t\t\tpanic!(\"Constant function calling failed\");\n+\t\t\t\t\tcrate::utils::notify!(\"Constant function calling failed, not constant pararms\");\n \t\t\t\t}\n \t\t\t}\n-\t\t} else {\n-\t\t\tfunction_type.clone().call(\n-\t\t\t\t&arguments,\n-\t\t\t\tthis_argument,\n-\t\t\t\tcall_site_type_arguments,\n-\t\t\t\t// TODO\n-\t\t\t\t&None,\n-\t\t\t\ttypes,\n-\t\t\t\tenvironment,\n-\t\t\t\tcalled_with_new,\n-\t\t\t)\n \t\t}\n+\n+\t\tfunction_type.call(\n+\t\t\t&arguments,\n+\t\t\tthis_argument,\n+\t\t\tcall_site_type_arguments,\n+\t\t\t// TODO\n+\t\t\t&None,\n+\t\t\ttypes,\n+\t\t\tenvironment,\n+\t\t\tcalled_with_new,\n+\t\t)\n \t} else if let Some(constraint) = environment.get_poly_base(on, &types) {\n \t\tmatch constraint {\n \t\t\tPolyBase::Fixed { to, is_open_poly } => {\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -276,7 +205,7 @@ pub fn call_type(\n \n \t\t\t\t\tlet function_type = FunctionType {\n \t\t\t\t\t\t// TODO explain\n-\t\t\t\t\t\tgeneric_type_parameters: GenericFunctionTypeParameters::None,\n+\t\t\t\t\t\ttype_parameters: None,\n \t\t\t\t\t\tparameters: SynthesizedParameters {\n \t\t\t\t\t\t\tparameters,\n \t\t\t\t\t\t\t// TODO I think this is okay\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -289,7 +218,9 @@ pub fn call_type(\n \t\t\t\t\t\teffects: Default::default(),\n \t\t\t\t\t\tclosed_over_references: Default::default(),\n \t\t\t\t\t\t// TODO\n-\t\t\t\t\t\tnature: crate::structures::functions::FunctionNature::Arrow,\n+\t\t\t\t\t\tkind: crate::structures::functions::FunctionKind::Arrow {\n+\t\t\t\t\t\t\tget_set: crate::GetSetGeneratorOrNone::None,\n+\t\t\t\t\t\t},\n \t\t\t\t\t\tconstant_id: None,\n \t\t\t\t\t};\n \ndiff --git a/checker/src/types/casts.rs b/checker/src/types/casts.rs\n--- a/checker/src/types/casts.rs\n+++ b/checker/src/types/casts.rs\n@@ -13,7 +13,7 @@ pub(crate) fn cast_as_number(cst: &Constant, strict_casts: bool) -> Result<f64,\n \t\tConstant::Number(number) => Ok(f64::from(*number)),\n \t\tConstant::String(str) => str.parse::<f64>().map_err(|_| ()),\n \t\tConstant::Boolean(val) => Ok(if *val { 1f64 } else { 0f64 }),\n-\t\tConstant::NaN | Constant::Undefined => Ok(f64::NAN),\n+\t\tConstant::Regexp(_) | Constant::NaN | Constant::Undefined => Ok(f64::NAN),\n \t\tConstant::Null => Ok(0f64),\n \t\tConstant::Symbol { key: _ } => todo!(),\n \t}\ndiff --git a/checker/src/types/casts.rs b/checker/src/types/casts.rs\n--- a/checker/src/types/casts.rs\n+++ b/checker/src/types/casts.rs\n@@ -37,7 +37,8 @@ pub(crate) fn cast_as_boolean(cst: &Constant, strict_casts: bool) -> Result<bool\n \t}\n \tOk(match cst {\n \t\tConstant::Number(number) => number.into_inner() != 0.,\n-\t\tConstant::String(str) => str.len() != 0,\n+\t\tConstant::String(value) => value.len() != 0,\n+\t\tConstant::Regexp(_) => true,\n \t\tConstant::Boolean(value) => *value,\n \t\tConstant::NaN | Constant::Undefined | Constant::Null => false,\n \t\tConstant::Symbol { key } => todo!(),\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -20,7 +20,7 @@ pub use terms::Constant;\n \n use crate::{\n \tcontext::{get_env, GeneralEnvironment, InferenceBoundary},\n-\tevents::Reference,\n+\tevents::RootReference,\n \tfunctions::FunctionType,\n \tstructures::{functions::SynthesizedArgument, operators::*},\n \tInternalFunctionId,\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -62,32 +62,33 @@ impl TypeId {\n \n \tpub const OBJECT_TYPE: Self = Self(10);\n \tpub const FUNCTION_TYPE: Self = Self(11);\n+\tpub const REGEXP_TYPE: Self = Self(12);\n \n-\tpub const STRING_OR_NUMBER: Self = Self(12);\n+\tpub const STRING_OR_NUMBER: Self = Self(13);\n \n \t/// For more direct stuff and the rules\n-\tpub const TRUE: Self = Self(13);\n-\tpub const FALSE: Self = Self(14);\n-\tpub const ZERO: Self = Self(15);\n-\tpub const ONE: Self = Self(16);\n-\tpub const NAN_TYPE: Self = Self(17);\n+\tpub const TRUE: Self = Self(14);\n+\tpub const FALSE: Self = Self(15);\n+\tpub const ZERO: Self = Self(16);\n+\tpub const ONE: Self = Self(17);\n+\tpub const NAN_TYPE: Self = Self(18);\n \t/// For arrays\n-\tpub const LENGTH_AS_STRING: Self = Self(18);\n+\tpub const LENGTH_AS_STRING: Self = Self(19);\n \n \t/// For this_arg for type constraints only\n-\tpub const THIS_ARG: Self = Self(19);\n+\tpub const THIS_ARG: Self = Self(20);\n \t/// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target\n-\tpub const NEW_TARGET_ARG: Self = Self(20);\n+\tpub const NEW_TARGET_ARG: Self = Self(21);\n \n-\tpub const SYMBOL_TO_PRIMITIVE: Self = Self(21);\n+\tpub const SYMBOL_TO_PRIMITIVE: Self = Self(22);\n \n \t// This exists in TS\n-\tpub const HTML_ELEMENT_TAG_NAME_MAP: Self = Self(22);\n+\tpub const HTML_ELEMENT_TAG_NAME_MAP: Self = Self(23);\n \n \t/// TODO explain, also might go\n-\tpub const OPERATORS_SPECIAL: Self = Self(23);\n+\tpub const OPERATORS_SPECIAL: Self = Self(24);\n \n-\tpub(crate) const INTERNAL_TYPE_COUNT: usize = 24;\n+\tpub(crate) const INTERNAL_TYPE_COUNT: usize = 25;\n }\n \n #[derive(Clone, Debug, binary_serialize_derive::BinarySerializable)]\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -135,7 +136,7 @@ pub enum PolyNature {\n \t/// For functions and for loops where something in the scope can mutate (so not constant)\n \t/// between runs.\n \tParentScope {\n-\t\treference: Reference,\n+\t\treference: RootReference,\n \t\tbased_on: PolyPointer,\n \t},\n \tRecursiveFunction(FunctionId, PolyPointer),\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -192,9 +193,9 @@ pub enum FunctionNature {\n \t\tthis_type: Option<TypeId>,\n \t},\n \t/// Last is 'this' type,\n-\t/// TODO needs improvement\n-\tSource(FunctionId, Option<GetterSetter>, Option<TypeId>),\n+\tSource(FunctionId, Option<TypeId>),\n \tConstructor(FunctionId),\n+\tReference,\n }\n \n #[derive(Copy, Clone, Debug, binary_serialize_derive::BinarySerializable)]\ndiff --git a/checker/src/types/operations.rs b/checker/src/types/operations.rs\n--- a/checker/src/types/operations.rs\n+++ b/checker/src/types/operations.rs\n@@ -2,6 +2,7 @@ use source_map::Span;\n \n use crate::{\n \tcontext::Environment,\n+\terrors::{InvalidMathematicalOperation, TypeCheckError, TypeStringRepresentation},\n \tstructures::{functions::SynthesizedArgument, operators::*},\n \ttypes::TypeStore,\n \tCheckingData, TypeId,\ndiff --git a/checker/src/types/operations.rs b/checker/src/types/operations.rs\n--- a/checker/src/types/operations.rs\n+++ b/checker/src/types/operations.rs\n@@ -24,8 +25,10 @@ pub fn evaluate_binary_operator_handle_errors<T: crate::FSResolver>(\n \t);\n \tmatch result {\n \t\tOk(ok) => ok,\n-\t\tErr(errors) => {\n-\t\t\t// TODO\n+\t\tErr(error) => {\n+\t\t\tchecking_data\n+\t\t\t\t.diagnostics_container\n+\t\t\t\t.add_error(TypeCheckError::InvalidMathematicalOperation(error));\n \t\t\tTypeId::ERROR_TYPE\n \t\t}\n \t}\ndiff --git a/checker/src/types/operations.rs b/checker/src/types/operations.rs\n--- a/checker/src/types/operations.rs\n+++ b/checker/src/types/operations.rs\n@@ -40,7 +43,7 @@ pub fn evaluate_binary_operator(\n \tenvironment: &mut Environment,\n \tstrict_casts: bool,\n \ttypes: &mut TypeStore,\n-) -> Result<TypeId, ()> {\n+) -> Result<TypeId, InvalidMathematicalOperation> {\n \t// TODO the function should be stored on Root environment on registration rather\n \t// than looking up a function using a key here\n \tlet op_type = match operator {\ndiff --git a/checker/src/types/operations.rs b/checker/src/types/operations.rs\n--- a/checker/src/types/operations.rs\n+++ b/checker/src/types/operations.rs\n@@ -63,10 +66,13 @@ pub fn evaluate_binary_operator(\n \t\t\t}\n \t\t\tRelationOperator::GreaterThan => todo!(),\n \t\t},\n+\t\tBinaryOperator::Subtract => todo!(),\n+\t\tBinaryOperator::Divide => todo!(),\n+\t\tBinaryOperator::LogicalOperator(_) => todo!(),\n \t};\n \t// TODO handle things and convert to bin exprs\n \tsuper::calling::call_type(\n-\t\top_type.unwrap().to_type(),\n+\t\top_type.unwrap().prop_to_type(),\n \t\t// TODO faster!\n \t\tvec![\n \t\t\tSynthesizedArgument::NonSpread { ty: lhs, position: Span::NULL_SPAN },\ndiff --git a/checker/src/types/operations.rs b/checker/src/types/operations.rs\n--- a/checker/src/types/operations.rs\n+++ b/checker/src/types/operations.rs\n@@ -78,20 +84,34 @@ pub fn evaluate_binary_operator(\n \t\ttypes,\n \t\tcrate::events::CalledWithNew::None,\n \t)\n-\t.map(|x| x.returned_type)\n-\t.map_err(|err| {\n-\t\tfor error in err {\n-\t\t\tmatch error {\n-\t\t\t\tcrate::structures::functions::FunctionCallingError::InvalidArgumentType { parameter_type, argument_type, argument_position, parameter_position, restriction } => {\n-\t\t\t\t\tcrate::utils::notify!(\"{} {}\", types.debug_type(parameter_type), types.debug_type(argument_type));\n-\t\t\t\t},\n-\t\t\t\tcrate::structures::functions::FunctionCallingError::MissingArgument { parameter_pos } => todo!(),\n-\t\t\t\tcrate::structures::functions::FunctionCallingError::ExtraArgument { idx, position } => todo!(),\n-\t\t\t\tcrate::structures::functions::FunctionCallingError::NotCallable { calling } => todo!(),\n-\t\t\t\tcrate::structures::functions::FunctionCallingError::ReferenceRestrictionDoesNotMatch { reference, requirement, found } => todo!(),\n-\t\t\t}\n+\t.map(|op| op.returned_type)\n+\t.map_err(|errors| {\n+\t\t// TODO temp\n+\t\tmatch errors.into_iter().next().unwrap() {\n+\t\t\tcrate::structures::functions::FunctionCallingError::InvalidArgumentType { parameter_type, argument_type, argument_position, parameter_position, restriction } => {\n+\t\t\t\tcrate::utils::notify!(\"{} {}\", parameter_type, argument_type);\n+\t\t\t\treturn InvalidMathematicalOperation {\n+\t\t\t\t\tlhs: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\tlhs,\n+\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t&types,\n+\t\t\t\t\t\tfalse,\n+\t\t\t\t\t),\n+\t\t\t\t\trhs: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\trhs,\n+\t\t\t\t\t\t&environment.into_general_environment(),\n+\t\t\t\t\t\t&types,\n+\t\t\t\t\t\tfalse,\n+\t\t\t\t\t),\n+\t\t\t\t\toperator,\n+\t\t\t\t\tposition: Span::NULL_SPAN, // lhs.1.union(&rhs.1),\n+\t\t\t\t};\n+\t\t\t},\n+\t\t\tcrate::structures::functions::FunctionCallingError::MissingArgument { .. } => unreachable!(\"binary operator should accept two operands\"),\n+\t\t\tcrate::structures::functions::FunctionCallingError::ExtraArguments { .. } => unreachable!(\"binary operator should have two operands\"),\n+\t\t\tcrate::structures::functions::FunctionCallingError::NotCallable { .. } => unreachable!(\"operator should be callable\"),\n+\t\t\tcrate::structures::functions::FunctionCallingError::ReferenceRestrictionDoesNotMatch { .. } => unreachable!(\"...\"),\n \t\t}\n-\t\t()\n \t})\n }\n \ndiff --git a/checker/src/types/poly_types/generics/generic_type_parameters.rs b/checker/src/types/poly_types/generics/generic_type_parameters.rs\n--- a/checker/src/types/poly_types/generics/generic_type_parameters.rs\n+++ b/checker/src/types/poly_types/generics/generic_type_parameters.rs\n@@ -27,12 +27,6 @@ impl From<Vec<GenericTypeParameter>> for GenericTypeParameters {\n \t}\n }\n \n-#[derive(Debug, Clone, binary_serialize_derive::BinarySerializable)]\n-pub enum GenericFunctionTypeParameters {\n-\tTypedParameters(GenericTypeParameters),\n-\tNone,\n-}\n-\n /// A generic type parameter. Used in verifying generic constructs.\n /// Ids used for parameter subtyping\n /// TODO could redesign later\ndiff --git a/checker/src/types/poly_types/specialization.rs b/checker/src/types/poly_types/specialization.rs\n--- a/checker/src/types/poly_types/specialization.rs\n+++ b/checker/src/types/poly_types/specialization.rs\n@@ -21,9 +21,9 @@ pub(crate) fn specialize(\n \t\treturn value;\n \t}\n \n-\tlet r#type = types.get_type_by_id(id);\n+\tlet ty = types.get_type_by_id(id);\n \n-\tmatch r#type {\n+\tmatch ty {\n \t\tType::Constant(_) | Type::Object(..) => id,\n \t\t// TODO temp\n \t\tType::Function(_, _) => id,\ndiff --git a/checker/src/types/poly_types/specialization.rs b/checker/src/types/poly_types/specialization.rs\n--- a/checker/src/types/poly_types/specialization.rs\n+++ b/checker/src/types/poly_types/specialization.rs\n@@ -53,14 +53,16 @@ pub(crate) fn specialize(\n \t\t\t\t\ttypes,\n \t\t\t\t);\n \n-\t\t\t\tlet value = evaluate_binary_operator.unwrap();\n+\t\t\t\ttodo!()\n \n-\t\t\t\tcrate::utils::notify!(\n-\t\t\t\t\t\"Specialized returned {}\",\n-\t\t\t\t\tenvironment.debug_type(value, types)\n-\t\t\t\t);\n+\t\t\t\t// match e\n+\n+\t\t\t\t// crate::utils::notify!(\n+\t\t\t\t// \t\"Specialized returned {}\",\n+\t\t\t\t// \tenvironment.debug_type(value, types)\n+\t\t\t\t// );\n \n-\t\t\t\tvalue\n+\t\t\t\t// value\n \t\t\t}\n \t\t\tConstructor::UnaryOperator { operand, operator, .. } => {\n \t\t\t\tevaluate_unary_operator(\ndiff --git a/checker/src/types/poly_types/specialization.rs b/checker/src/types/poly_types/specialization.rs\n--- a/checker/src/types/poly_types/specialization.rs\n+++ b/checker/src/types/poly_types/specialization.rs\n@@ -74,10 +76,23 @@ pub(crate) fn specialize(\n \t\t\t\t.unwrap()\n \t\t\t}\n \t\t\tConstructor::ConditionalTernary { on, true_res, false_res, result_union } => {\n+\t\t\t\tcrate::utils::notify!(\n+\t\t\t\t\t\"before {:?} {:?} {:?}\",\n+\t\t\t\t\ttypes.debug_type(on),\n+\t\t\t\t\ttypes.debug_type(true_res),\n+\t\t\t\t\ttypes.debug_type(false_res)\n+\t\t\t\t);\n \t\t\t\tlet on = specialize(on, arguments, environment, types);\n \t\t\t\tlet true_res = specialize(true_res, arguments, environment, types);\n \t\t\t\tlet false_res = specialize(false_res, arguments, environment, types);\n \n+\t\t\t\tcrate::utils::notify!(\n+\t\t\t\t\t\"after {:?} {:?} {:?}\",\n+\t\t\t\t\ttypes.debug_type(on),\n+\t\t\t\t\ttypes.debug_type(true_res),\n+\t\t\t\t\ttypes.debug_type(false_res)\n+\t\t\t\t);\n+\n \t\t\t\t// TODO falsy\n \t\t\t\tif let Type::Constant(cst) = types.get_type_by_id(on) {\n \t\t\t\t\tlet result = cast_as_boolean(cst, false).unwrap();\ndiff --git a/checker/src/types/poly_types/specialization.rs b/checker/src/types/poly_types/specialization.rs\n--- a/checker/src/types/poly_types/specialization.rs\n+++ b/checker/src/types/poly_types/specialization.rs\n@@ -87,13 +102,15 @@ pub(crate) fn specialize(\n \t\t\t\t\t\tfalse_res\n \t\t\t\t\t}\n \t\t\t\t} else {\n+\t\t\t\t\t// TODO result_union\n \t\t\t\t\tlet ty =\n \t\t\t\t\t\tConstructor::ConditionalTernary { on, true_res, false_res, result_union };\n+\n \t\t\t\t\ttypes.register_type(Type::Constructor(ty))\n \t\t\t\t}\n \t\t\t}\n \t\t\tConstructor::Property { .. } | Constructor::FunctionResult { .. } => {\n-\t\t\t\tunreachable!(\"todo this should have covered by event specialization\");\n+\t\t\t\tunreachable!(\"this should have covered by event specialization\");\n \n \t\t\t\t// let on = specialize(on, arguments, environment);\n \ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -1,10 +1,12 @@\n use crate::{context::get_env, GeneralEnvironment};\n \n-use super::{poly_types::GenericFunctionTypeParameters, PolyNature, Type, TypeId, TypeStore};\n+use super::{PolyNature, Type, TypeId, TypeStore};\n \n /// TODO temp, needs recursion safe, reuse buffer\n pub fn print_type(types: &TypeStore, id: TypeId, env: &GeneralEnvironment) -> String {\n-\tmatch types.get_type_by_id(id) {\n+\tlet ty = types.get_type_by_id(id);\n+\t// crate::utils::notify!(\"Printing {:?}\", ty);\n+\tmatch ty {\n \t\tType::AliasTo { to, name, parameters } => name.clone(),\n \t\tType::And(a, b) => {\n \t\t\tformat!(\"{} & {}\", print_type(types, *a, env), print_type(types, *b, env))\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -14,7 +16,7 @@ pub fn print_type(types: &TypeStore, id: TypeId, env: &GeneralEnvironment) -> St\n \t\t}\n \t\tType::RootPolyType(nature) => match nature {\n \t\t\tPolyNature::Generic { name, .. } => name.clone(),\n-\t\t\tPolyNature::Parameter { .. } => {\n+\t\t\tPolyNature::ParentScope { .. } | PolyNature::Parameter { .. } => {\n \t\t\t\tlet ty = get_env!(env.get_poly_base(id, types)).unwrap().get_type();\n \t\t\t\tprint_type(types, ty, env)\n \t\t\t}\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -51,9 +53,7 @@ pub fn print_type(types: &TypeStore, id: TypeId, env: &GeneralEnvironment) -> St\n \t\tType::Constant(cst) => cst.as_type_name(),\n \t\tType::Function(func, _) => {\n \t\t\tlet mut buf = String::new();\n-\t\t\tif let GenericFunctionTypeParameters::TypedParameters(ref parameters) =\n-\t\t\t\tfunc.generic_type_parameters\n-\t\t\t{\n+\t\t\tif let Some(ref parameters) = func.type_parameters {\n \t\t\t\tbuf.push('<');\n \t\t\t\tfor param in parameters.0.iter() {\n \t\t\t\t\tbuf.push_str(&param.name);\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -66,6 +66,7 @@ pub fn print_type(types: &TypeStore, id: TypeId, env: &GeneralEnvironment) -> St\n \t\t\t\t\tif let Some(ref default) = param.default {\n \t\t\t\t\t\ttodo!()\n \t\t\t\t\t}\n+\t\t\t\t\tbuf.push_str(\", \")\n \t\t\t\t}\n \t\t\t\tbuf.push('>');\n \t\t\t}\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -74,6 +75,7 @@ pub fn print_type(types: &TypeStore, id: TypeId, env: &GeneralEnvironment) -> St\n \t\t\t\tbuf.push_str(&param.name);\n \t\t\t\tbuf.push_str(\": \");\n \t\t\t\tbuf.push_str(&print_type(types, param.ty, env));\n+\t\t\t\tbuf.push_str(\", \");\n \t\t\t}\n \t\t\tbuf.push_str(\") => \");\n \t\t\tbuf.push_str(&print_type(types, func.return_type, env));\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -1,9 +1,13 @@\n use crate::{\n \tcontext::{get_env, Environment, Logical, PolyBase, SetPropertyError},\n \tevents::Event,\n+\tstructures::functions::FunctionType,\n+\tsubtyping::{type_is_subtype, SubTypeResult},\n \tTypeId,\n };\n \n+use source_map::{SourceId, Span};\n+\n use super::{Constructor, Type, TypeStore};\n \n pub enum PropertyResult {\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -22,6 +26,24 @@ impl From<PropertyResult> for TypeId {\n \t}\n }\n \n+#[derive(Clone, Debug, binary_serialize_derive::BinarySerializable)]\n+pub enum Property {\n+\tValue(TypeId),\n+\tGet(Box<FunctionType>),\n+\tSet(Box<FunctionType>),\n+\tGetAndSet(Box<FunctionType>, Box<FunctionType>),\n+}\n+impl Property {\n+\tpub(crate) fn as_get_type(&self) -> TypeId {\n+\t\tmatch self {\n+\t\t\tProperty::Value(value) => *value,\n+\t\t\tProperty::Get(func) => func.return_type,\n+\t\t\tProperty::Set(_) => todo!(),\n+\t\t\tProperty::GetAndSet(_, _) => todo!(),\n+\t\t}\n+\t}\n+}\n+\n /// Also evaluates getter and binds `this`\n ///\n /// *be aware this creates a new type every time, bc of this binding. could cache this bound\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -43,197 +65,217 @@ pub(crate) fn get_property(\n \t\tFromAObject(TypeId),\n \t}\n \n-\tlet value: GetResult =\n-\t\tif let Some(constraint) = environment.get_poly_base(on, types) {\n-\t\t\tmatch constraint {\n-\t\t\t\tPolyBase::Fixed { to, is_open_poly } => {\n-\t\t\t\t\tcrate::utils::notify!(\n-\t\t\t\t\t\t\"Get property found fixed constraint {}, is_open_poly={:?}\",\n-\t\t\t\t\t\tenvironment.debug_type(on, types),\n-\t\t\t\t\t\tis_open_poly\n-\t\t\t\t\t);\n-\n-\t\t\t\t\tlet fact = environment.get_property_unbound(to, under, types)?;\n-\n-\t\t\t\t\tmatch fact {\n-\t\t\t\t\t\tLogical::Pure(og) => {\n-\t\t\t\t\t\t\tmatch types.get_type_by_id(og) {\n-\t\t\t\t\t\t\t\tType::Function(func, _) => {\n-\t\t\t\t\t\t\t\t\t// TODO only want to do sometimes, or even never as it can be pulled using the poly chain\n-\t\t\t\t\t\t\t\t\tlet with_this = types.register_type(Type::Function(\n-\t\t\t\t\t\t\t\t\t\tfunc.clone(),\n-\t\t\t\t\t\t\t\t\t\tcrate::types::FunctionNature::BehindPoly {\n-\t\t\t\t\t\t\t\t\t\t\t// TODO\n-\t\t\t\t\t\t\t\t\t\t\tfunction_id_if_open_poly: None,\n-\t\t\t\t\t\t\t\t\t\t\tthis_type: Some(on),\n-\t\t\t\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t\t\t\t));\n-\t\t\t\t\t\t\t\t\tcrate::utils::notify!(\"Temp setting this on poly\");\n-\n-\t\t\t\t\t\t\t\t\tGetResult::AccessIntroducesDependence(with_this)\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tType::And(_, _) => todo!(),\n-\t\t\t\t\t\t\t\tType::Or(_, _) => todo!(),\n-\t\t\t\t\t\t\t\tType::RootPolyType(_) => todo!(),\n-\t\t\t\t\t\t\t\tType::Constructor(_) => todo!(),\n-\t\t\t\t\t\t\t\tType::AliasTo { .. } | Type::NamedRooted { .. } => {\n-\t\t\t\t\t\t\t\t\tif is_open_poly {\n-\t\t\t\t\t\t\t\t\t\tcrate::utils::notify!(\"TODO evaluate getter...\");\n-\t\t\t\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\t\t\t\tcrate::utils::notify!(\"TODO don't evaluate getter\");\n+\tlet value: GetResult = if let Some(constraint) = environment.get_poly_base(on, types) {\n+\t\tmatch constraint {\n+\t\t\tPolyBase::Fixed { to, is_open_poly } => {\n+\t\t\t\tcrate::utils::notify!(\n+\t\t\t\t\t\"Get property found fixed constraint {}, is_open_poly={:?}\",\n+\t\t\t\t\tenvironment.debug_type(on, types),\n+\t\t\t\t\tis_open_poly\n+\t\t\t\t);\n+\n+\t\t\t\tlet fact = environment.get_property_unbound(to, under, types)?;\n+\n+\t\t\t\tmatch fact {\n+\t\t\t\t\tLogical::Pure(og) => {\n+\t\t\t\t\t\tmatch og {\n+\t\t\t\t\t\t\tProperty::Value(og) => {\n+\t\t\t\t\t\t\t\tmatch types.get_type_by_id(og) {\n+\t\t\t\t\t\t\t\t\tType::Function(func, _) => {\n+\t\t\t\t\t\t\t\t\t\t// TODO only want to do sometimes, or even never as it can be pulled using the poly chain\n+\t\t\t\t\t\t\t\t\t\tlet with_this = types.register_type(Type::Function(\n+\t\t\t\t\t\t\t\t\t\t\tfunc.clone(),\n+\t\t\t\t\t\t\t\t\t\t\tcrate::types::FunctionNature::BehindPoly {\n+\t\t\t\t\t\t\t\t\t\t\t\t// TODO\n+\t\t\t\t\t\t\t\t\t\t\t\tfunction_id_if_open_poly: None,\n+\t\t\t\t\t\t\t\t\t\t\t\tthis_type: Some(on),\n+\t\t\t\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\t\t\t));\n+\t\t\t\t\t\t\t\t\t\tcrate::utils::notify!(\"Temp setting this on poly\");\n+\n+\t\t\t\t\t\t\t\t\t\tGetResult::AccessIntroducesDependence(with_this)\n \t\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\t\t// TODO don't have to recreate if don't have any events.\n-\t\t\t\t\t\t\t\t\tlet constructor_result = types.register_type(\n-\t\t\t\t\t\t\t\t\t\tType::Constructor(Constructor::Property { on, under }),\n-\t\t\t\t\t\t\t\t\t);\n-\n-\t\t\t\t\t\t\t\t\tGetResult::AccessIntroducesDependence(constructor_result)\n+\t\t\t\t\t\t\t\t\tType::And(_, _) => todo!(),\n+\t\t\t\t\t\t\t\t\tType::RootPolyType(_) => todo!(),\n+\t\t\t\t\t\t\t\t\tType::Constructor(_) => todo!(),\n+\t\t\t\t\t\t\t\t\tType::Or(_, _)\n+\t\t\t\t\t\t\t\t\t| Type::AliasTo { .. }\n+\t\t\t\t\t\t\t\t\t| Type::NamedRooted { .. } => {\n+\t\t\t\t\t\t\t\t\t\tif is_open_poly {\n+\t\t\t\t\t\t\t\t\t\t\tcrate::utils::notify!(\"TODO evaluate getter...\");\n+\t\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\t\tcrate::utils::notify!(\"TODO don't evaluate getter\");\n+\t\t\t\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t\t\t\t\t// TODO don't have to recreate if don't have any events.\n+\t\t\t\t\t\t\t\t\t\tlet constructor_result = types.register_type(\n+\t\t\t\t\t\t\t\t\t\t\tType::Constructor(Constructor::Property { on, under }),\n+\t\t\t\t\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t\t\t\t\tGetResult::AccessIntroducesDependence(constructor_result)\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tType::Constant(_) => GetResult::FromAObject(og),\n+\t\t\t\t\t\t\t\t\tType::Object(..) => todo!(),\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tType::Constant(_) => GetResult::FromAObject(og),\n-\t\t\t\t\t\t\t\tType::Object(..) => todo!(),\n \t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tProperty::Get(_) => todo!(),\n+\t\t\t\t\t\t\tProperty::Set(_) => todo!(),\n+\t\t\t\t\t\t\tProperty::GetAndSet(_, _) => todo!(),\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tLogical::Or(_) => todo!(),\n-\t\t\t\t\t\tLogical::Implies(_, _) => todo!(),\n \t\t\t\t\t}\n+\t\t\t\t\tLogical::Or(_) => todo!(),\n+\t\t\t\t\tLogical::Implies(_, _) => todo!(),\n \t\t\t\t}\n-\t\t\t\tPolyBase::Dynamic { to, boundary } => {\n-\t\t\t\t\tcrate::utils::notify!(\n-\t\t\t\t\t\t\"Getting property {:?} which has a dynamic constraint {:?}\",\n-\t\t\t\t\t\ton,\n+\t\t\t}\n+\t\t\tPolyBase::Dynamic { to, boundary } => {\n+\t\t\t\tcrate::utils::notify!(\n+\t\t\t\t\t\"Getting property {:?} which has a dynamic constraint {:?}\",\n+\t\t\t\t\ton,\n+\t\t\t\t\tto\n+\t\t\t\t);\n+\t\t\t\t// If the property on the dynamic constraint is None\n+\t\t\t\tif environment.get_property_unbound(to, under, types).is_none() {\n+\t\t\t\t\tlet on = if to == TypeId::ANY_TYPE {\n+\t\t\t\t\t\tlet new_constraint = types.register_type(Type::Object(\n+\t\t\t\t\t\t\tcrate::types::ObjectNature::ModifiableConstraint,\n+\t\t\t\t\t\t));\n+\t\t\t\t\t\tcrate::utils::notify!(\"Here!!!\");\n+\t\t\t\t\t\tenvironment.attempt_to_modify_base(on, boundary, new_constraint);\n+\t\t\t\t\t\tnew_constraint\n+\t\t\t\t\t} else if matches!(\n+\t\t\t\t\t\ttypes.get_type_by_id(to),\n+\t\t\t\t\t\tType::AliasTo { to: TypeId::OBJECT_TYPE, .. }\n+\t\t\t\t\t) {\n \t\t\t\t\t\tto\n-\t\t\t\t\t);\n-\t\t\t\t\t// If the property on the dynamic constraint is None\n-\t\t\t\t\tif environment.get_property_unbound(to, under, types).is_none() {\n-\t\t\t\t\t\tlet on = if to == TypeId::ANY_TYPE {\n-\t\t\t\t\t\t\tlet new_constraint = types.register_type(Type::Object(\n-\t\t\t\t\t\t\t\tcrate::types::ObjectNature::ModifiableConstraint,\n-\t\t\t\t\t\t\t));\n-\t\t\t\t\t\t\tcrate::utils::notify!(\"Here!!!\");\n-\t\t\t\t\t\t\tenvironment.attempt_to_modify_base(on, boundary, new_constraint);\n-\t\t\t\t\t\t\tnew_constraint\n-\t\t\t\t\t\t} else if matches!(\n-\t\t\t\t\t\t\ttypes.get_type_by_id(to),\n-\t\t\t\t\t\t\tType::AliasTo { to: TypeId::OBJECT_TYPE, .. }\n-\t\t\t\t\t\t) {\n-\t\t\t\t\t\t\tto\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\ttodo!(\"new and\")\n-\t\t\t\t\t\t};\n-\n-\t\t\t\t\t\tenvironment\n-\t\t\t\t\t\t\t.properties\n-\t\t\t\t\t\t\t.entry(on)\n-\t\t\t\t\t\t\t.or_default()\n-\t\t\t\t\t\t\t.push((under, with.unwrap_or(TypeId::ANY_TYPE)));\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tcrate::utils::notify!(\"Found existing property on dynamic constraint\");\n-\t\t\t\t\t}\n+\t\t\t\t\t\ttodo!(\"new and\")\n+\t\t\t\t\t};\n+\n+\t\t\t\t\tenvironment\n+\t\t\t\t\t\t.properties\n+\t\t\t\t\t\t.entry(on)\n+\t\t\t\t\t\t.or_default()\n+\t\t\t\t\t\t.push((under, Property::Value(with.unwrap_or(TypeId::ANY_TYPE))));\n+\t\t\t\t} else {\n+\t\t\t\t\tcrate::utils::notify!(\"Found existing property on dynamic constraint\");\n+\t\t\t\t}\n \n-\t\t\t\t\tlet constructor_result =\n-\t\t\t\t\t\ttypes.register_type(Type::Constructor(Constructor::Property { on, under }));\n+\t\t\t\tlet constructor_result =\n+\t\t\t\t\ttypes.register_type(Type::Constructor(Constructor::Property { on, under }));\n \n-\t\t\t\t\t// environment\n-\t\t\t\t\t// \t.context_type\n-\t\t\t\t\t// \t.get_inferrable_constraints_mut()\n-\t\t\t\t\t// \t.unwrap()\n-\t\t\t\t\t// \t.insert(constructor_result);\n+\t\t\t\t// environment\n+\t\t\t\t// \t.context_type\n+\t\t\t\t// \t.get_inferrable_constraints_mut()\n+\t\t\t\t// \t.unwrap()\n+\t\t\t\t// \t.insert(constructor_result);\n \n-\t\t\t\t\tGetResult::AccessIntroducesDependence(constructor_result)\n-\t\t\t\t}\n+\t\t\t\tGetResult::AccessIntroducesDependence(constructor_result)\n \t\t\t}\n-\t\t} else if let Some(_) = environment.get_poly_base(under, types) {\n-\t\t\ttodo!()\n-\t\t} else {\n-\t\t\tlet property = environment.get_property_unbound(on, under, types)?;\n-\n-\t\t\tlet property = if let Logical::Pure(og) = property {\n-\t\t\t\tog\n-\t\t\t} else {\n-\t\t\t\tunreachable!(\"TODO multiple properties\");\n-\t\t\t};\n-\n-\t\t\tlet ty = types.get_type_by_id(property);\n-\t\t\tlet value = match ty {\n-\t\t\t\tType::Function(ty, nature) => {\n-\t\t\t\t\t// TODO getter\n-\t\t\t\t\t// TODO if arrow function\n-\t\t\t\t\tmatch nature {\n-\t\t\t\t\t\tsuper::FunctionNature::BehindPoly { .. } => todo!(),\n-\t\t\t\t\t\tsuper::FunctionNature::Source(id, get_set, this) => {\n-\t\t\t\t\t\t\tif get_set.is_some() {\n+\t\t}\n+\t} else if let Some(_) = environment.get_poly_base(under, types) {\n+\t\ttodo!()\n+\t} else {\n+\t\tlet value = environment.get_property_unbound(on, under, types)?;\n+\n+\t\tlet value = match value {\n+\t\t\tLogical::Pure(property) => {\n+\t\t\t\tmatch property {\n+\t\t\t\t\tProperty::Value(value) => {\n+\t\t\t\t\t\tlet ty = types.get_type_by_id(value);\n+\t\t\t\t\t\tmatch ty {\n+\t\t\t\t\t\t\tType::Function(func, nature) => match nature {\n+\t\t\t\t\t\t\t\tsuper::FunctionNature::BehindPoly { .. } => todo!(),\n+\t\t\t\t\t\t\t\tsuper::FunctionNature::Source(id, this) => {\n+\t\t\t\t\t\t\t\t\tif this.is_some() {\n+\t\t\t\t\t\t\t\t\t\tpanic!()\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\ttypes.register_type(Type::Function(\n+\t\t\t\t\t\t\t\t\t\tfunc.clone(),\n+\t\t\t\t\t\t\t\t\t\tsuper::FunctionNature::Source(id.clone(), Some(on)),\n+\t\t\t\t\t\t\t\t\t))\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tsuper::FunctionNature::Constructor(_) => todo!(),\n+\t\t\t\t\t\t\t\tsuper::FunctionNature::Reference => unreachable!(),\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tType::Object(..) | Type::RootPolyType { .. } | Type::Constant(..) => {\n+\t\t\t\t\t\t\t\tvalue\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tType::NamedRooted { .. }\n+\t\t\t\t\t\t\t| Type::And(_, _)\n+\t\t\t\t\t\t\t| Type::Or(_, _)\n+\t\t\t\t\t\t\t| Type::Constructor(Constructor::StructureGenerics { .. }) => {\n+\t\t\t\t\t\t\t\tunreachable!(\n+\t\t\t\t\t\t\t\t\t\"property was {:?} {:?}, which should be able to be retutned from a function\",\n+\t\t\t\t\t\t\t\t\tproperty, ty\n+\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tType::Constructor(constructor) => {\n+\t\t\t\t\t\t\t\tunreachable!(\"Interesting property was {:?}\", constructor);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tType::AliasTo { to, name, parameters } => {\n \t\t\t\t\t\t\t\ttodo!()\n+\t\t\t\t\t\t\t\t// if environment.is_getter(property) {\n+\t\t\t\t\t\t\t\t// \t// TODO catch unwrap as error:\n+\t\t\t\t\t\t\t\t// \tlet result = call_type(\n+\t\t\t\t\t\t\t\t// \t\tproperty,\n+\t\t\t\t\t\t\t\t// \t\tvec![],\n+\t\t\t\t\t\t\t\t// \t\tSome(on),\n+\t\t\t\t\t\t\t\t// \t\tNone,\n+\t\t\t\t\t\t\t\t// \t\tenvironment,\n+\t\t\t\t\t\t\t\t// \t\tchecking_data,\n+\t\t\t\t\t\t\t\t// \t\tCalledWithNew::None,\n+\t\t\t\t\t\t\t\t// \t)\n+\t\t\t\t\t\t\t\t// \t.unwrap()\n+\t\t\t\t\t\t\t\t// \t.returned_type;\n+\n+\t\t\t\t\t\t\t\t// \treturn Some(PropertyResult::Getter(result));\n+\t\t\t\t\t\t\t\t// } else {\n+\t\t\t\t\t\t\t\t// \t// Bind this is this is function\n+\t\t\t\t\t\t\t\t// \tlet is_function = *to == TypeId::FUNCTION_TYPE\n+\t\t\t\t\t\t\t\t// \t\t|| matches!(environment.get_type_by_id(*to), Type::AliasTo { to, .. } if *to == TypeId::FUNCTION_TYPE);\n+\n+\t\t\t\t\t\t\t\t// \tif is_function {\n+\t\t\t\t\t\t\t\t// \t\tlet alias = environment.new_type(Type::AliasTo {\n+\t\t\t\t\t\t\t\t// \t\t\tto: property,\n+\t\t\t\t\t\t\t\t// \t\t\tname: None,\n+\t\t\t\t\t\t\t\t// \t\t\tparameters: None,\n+\t\t\t\t\t\t\t\t// \t\t});\n+\t\t\t\t\t\t\t\t// \t\tenvironment.this_bindings.insert(alias, on);\n+\t\t\t\t\t\t\t\t// \t\talias\n+\t\t\t\t\t\t\t\t// \t} else {\n+\t\t\t\t\t\t\t\t// \t\tproperty\n+\t\t\t\t\t\t\t\t// \t}\n+\t\t\t\t\t\t\t\t// }\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tif this.is_some() {\n-\t\t\t\t\t\t\t\tpanic!()\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tProperty::Get(func) => {\n+\t\t\t\t\t\treturn match func.call(\n+\t\t\t\t\t\t\t&[],\n+\t\t\t\t\t\t\tSome(on),\n+\t\t\t\t\t\t\tNone,\n+\t\t\t\t\t\t\t&None,\n+\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\tcrate::events::CalledWithNew::None,\n+\t\t\t\t\t\t) {\n+\t\t\t\t\t\t\tOk(res) => Some(PropertyResult::Getter(res.returned_type)),\n+\t\t\t\t\t\t\tErr(_) => {\n+\t\t\t\t\t\t\t\ttodo!()\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\ttypes.register_type(Type::Function(\n-\t\t\t\t\t\t\t\tty.clone(),\n-\t\t\t\t\t\t\t\tsuper::FunctionNature::Source(id.clone(), None, Some(on)),\n-\t\t\t\t\t\t\t))\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tsuper::FunctionNature::Constructor(_) => todo!(),\n \t\t\t\t\t}\n+\t\t\t\t\tProperty::Set(_) => todo!(),\n+\t\t\t\t\tProperty::GetAndSet(_, _) => todo!(),\n \t\t\t\t}\n-\t\t\t\tType::Constant(..) => property,\n-\t\t\t\tType::NamedRooted { .. }\n-\t\t\t\t| Type::And(_, _)\n-\t\t\t\t| Type::Or(_, _)\n-\t\t\t\t| Type::Constructor(Constructor::StructureGenerics { .. }) => {\n-\t\t\t\t\tunreachable!(\"property was {:?} {:?}\", property, ty)\n-\t\t\t\t}\n-\t\t\t\tType::Constructor(constructor) => {\n-\t\t\t\t\tunreachable!(\"Interesting property was {:?}\", constructor);\n-\t\t\t\t}\n-\t\t\t\tType::Object(..) | Type::RootPolyType { .. } => {\n-\t\t\t\t\tproperty\n-\t\t\t\t\t// if let super::PolyNature::Open = nature {\n-\t\t\t\t\t// } else {\n-\t\t\t\t\t// \tcrate::utils::notify!(\"Warning property has ty of nature: {:?}\", nature);\n-\t\t\t\t\t// \tproperty\n-\t\t\t\t\t// }\n-\t\t\t\t}\n-\t\t\t\tType::AliasTo { to, name, parameters } => {\n-\t\t\t\t\ttodo!()\n-\t\t\t\t\t// if environment.is_getter(property) {\n-\t\t\t\t\t// \t// TODO catch unwrap as error:\n-\t\t\t\t\t// \tlet result = call_type(\n-\t\t\t\t\t// \t\tproperty,\n-\t\t\t\t\t// \t\tvec![],\n-\t\t\t\t\t// \t\tSome(on),\n-\t\t\t\t\t// \t\tNone,\n-\t\t\t\t\t// \t\tenvironment,\n-\t\t\t\t\t// \t\tchecking_data,\n-\t\t\t\t\t// \t\tCalledWithNew::None,\n-\t\t\t\t\t// \t)\n-\t\t\t\t\t// \t.unwrap()\n-\t\t\t\t\t// \t.returned_type;\n-\n-\t\t\t\t\t// \treturn Some(PropertyResult::Getter(result));\n-\t\t\t\t\t// } else {\n-\t\t\t\t\t// \t// Bind this is this is function\n-\t\t\t\t\t// \tlet is_function = *to == TypeId::FUNCTION_TYPE\n-\t\t\t\t\t// \t\t|| matches!(environment.get_type_by_id(*to), Type::AliasTo { to, .. } if *to == TypeId::FUNCTION_TYPE);\n-\n-\t\t\t\t\t// \tif is_function {\n-\t\t\t\t\t// \t\tlet alias = environment.new_type(Type::AliasTo {\n-\t\t\t\t\t// \t\t\tto: property,\n-\t\t\t\t\t// \t\t\tname: None,\n-\t\t\t\t\t// \t\t\tparameters: None,\n-\t\t\t\t\t// \t\t});\n-\t\t\t\t\t// \t\tenvironment.this_bindings.insert(alias, on);\n-\t\t\t\t\t// \t\talias\n-\t\t\t\t\t// \t} else {\n-\t\t\t\t\t// \t\tproperty\n-\t\t\t\t\t// \t}\n-\t\t\t\t\t// }\n-\t\t\t\t}\n-\t\t\t};\n-\n-\t\t\tGetResult::FromAObject(value)\n+\t\t\t}\n+\t\t\tLogical::Or(_) => todo!(),\n+\t\t\tLogical::Implies(_, _) => todo!(),\n \t\t};\n \n+\t\tGetResult::FromAObject(value)\n+\t};\n+\n \tlet reflects_dependency = match value {\n \t\tGetResult::AccessIntroducesDependence(s) => Some(s),\n \t\tGetResult::FromAObject(_) => None,\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -259,7 +301,7 @@ pub(crate) fn set_property(\n \tenvironment: &mut Environment,\n \ton: TypeId,\n \tunder: TypeId,\n-\tnew: TypeId,\n+\tnew: Property,\n \ttypes: &mut TypeStore,\n ) -> Result<Option<TypeId>, SetPropertyError> {\n \tlet pair = (on, under);\ndiff --git a/checker/src/types/properties.rs b/checker/src/types/properties.rs\n--- a/checker/src/types/properties.rs\n+++ b/checker/src/types/properties.rs\n@@ -268,109 +310,148 @@ pub(crate) fn set_property(\n \t\treturn Err(SetPropertyError::NotWriteable);\n \t}\n \n-\tlet property_constraint = {\n-\t\tlet constraint = environment\n-\t\t\t.parents_iter()\n-\t\t\t.find_map(|env| get_env!(env.object_constraints.get(&on)).cloned());\n+\t{\n+\t\tlet property_constraint = {\n+\t\t\tlet constraint = environment\n+\t\t\t\t.parents_iter()\n+\t\t\t\t.find_map(|env| get_env!(env.object_constraints.get(&on)).cloned());\n \n-\t\tmatch constraint {\n-\t\t\tSome(constraint) => {\n-\t\t\t\tlet result = environment.get_property_unbound(constraint, under, types);\n-\t\t\t\tif result.is_none() {\n-\t\t\t\t\t// TODO does not exist\n-\t\t\t\t\treturn Err(SetPropertyError::DoesNotMeetConstraint(todo!()));\n+\t\t\tmatch constraint {\n+\t\t\t\tSome(constraint) => {\n+\t\t\t\t\tlet result = environment.get_property_unbound(constraint, under, types);\n+\t\t\t\t\tif result.is_none() {\n+\t\t\t\t\t\t// TODO does not exist\n+\t\t\t\t\t\treturn Err(SetPropertyError::DoesNotMeetConstraint(\n+\t\t\t\t\t\t\tnew.as_get_type(),\n+\t\t\t\t\t\t\ttodo!(\"no property\"),\n+\t\t\t\t\t\t));\n+\t\t\t\t\t}\n+\t\t\t\t\tresult\n \t\t\t\t}\n-\t\t\t\tresult\n+\t\t\t\tNone => None,\n \t\t\t}\n-\t\t\tNone => None,\n-\t\t}\n-\t};\n+\t\t};\n \n-\tif let Some(constraint) = property_constraint {\n-\t\ttodo!();\n-\t\t// TODO maybe perform update anyway...?\n-\n-\t\t// let mut basic_subtyping = crate::types::BasicEquality {\n-\t\t// \tadd_property_restrictions: true,\n-\t\t// \tposition: parser::Span { start: 0, end: 0, source_id: parser::SourceId::NULL },\n-\t\t// };\n-\t\t// if let SubTypeResult::IsNotSubType(sub_type_error) = type_is_subtype(\n-\t\t// \tconstraint,\n-\t\t// \tnew,\n-\t\t// \tNone,\n-\t\t// \t// TODO undecided here\n-\t\t// \t// TODO position here\n-\t\t// \t&mut basic_subtyping,\n-\t\t// \tenvironment,\n-\t\t// \t&checking_data.types,\n-\t\t// ) {\n-\t\t// \treturn Err(SetPropertyError::DoesNotMeetConstraint(sub_type_error));\n-\t\t// }\n+\t\tif let Some(constraint) = property_constraint {\n+\t\t\tlet mut basic_subtyping = crate::types::subtyping::BasicEquality {\n+\t\t\t\tadd_property_restrictions: true,\n+\t\t\t\tposition: Span { start: 0, end: 0, source_id: SourceId::NULL },\n+\t\t\t};\n+\t\t\tlet base_type = constraint.prop_to_type();\n+\t\t\tif let SubTypeResult::IsNotSubType(sub_type_error) = type_is_subtype(\n+\t\t\t\tbase_type,\n+\t\t\t\tnew.as_get_type(),\n+\t\t\t\tNone,\n+\t\t\t\t// TODO undecided here\n+\t\t\t\t// TODO position here\n+\t\t\t\t&mut basic_subtyping,\n+\t\t\t\tenvironment,\n+\t\t\t\ttypes,\n+\t\t\t) {\n+\t\t\t\t// TODO don't short circuit\n+\t\t\t\treturn Err(SetPropertyError::DoesNotMeetConstraint(base_type, sub_type_error));\n+\t\t\t}\n+\t\t}\n \t}\n \n+\tcrate::utils::notify!(\n+\t\t\"setting {:?} {:?} {:?}\",\n+\t\ttypes.debug_type(on),\n+\t\ttypes.debug_type(under),\n+\t\ttypes.debug_type(new.as_get_type())\n+\t);\n+\n \tlet current_property = environment.get_property_unbound(on, under, types);\n \n+\tlet new = Property::Value(new.as_get_type());\n+\n \tif let Some(fact) = current_property {\n \t\tmatch fact {\n-\t\t\tLogical::Pure(og) => match types.get_type_by_id(og) {\n-\t\t\t\tType::Function(..) => todo!(\"look at setter\"),\n-\t\t\t\tType::Object(..) | Type::Constant(_) => {\n-\t\t\t\t\tenvironment.properties.entry(on).or_default().push((under, new));\n-\t\t\t\t\tenvironment.context_type.events.push(Event::Setter {\n-\t\t\t\t\t\ton,\n-\t\t\t\t\t\tnew,\n-\t\t\t\t\t\tunder,\n-\t\t\t\t\t\treflects_dependency: None,\n-\t\t\t\t\t\tinitialization: true,\n-\t\t\t\t\t});\n-\t\t\t\t}\n-\t\t\t\tType::And(_, _) | Type::Or(_, _) => todo!(),\n-\t\t\t\tType::RootPolyType(_) => todo!(),\n-\t\t\t\tType::Constructor(_) => todo!(),\n-\t\t\t\tType::NamedRooted { name, parameters } => todo!(),\n-\t\t\t\tType::AliasTo { to, name, parameters } => {\n-\t\t\t\t\ttodo!();\n-\t\t\t\t\t// if environment.is_setter(og) {\n-\t\t\t\t\t// \t// TODO catch unwrap as error:\n-\t\t\t\t\t// \tlet arg = SynthesizedArgument::NonSpread {\n-\t\t\t\t\t// \t\tty: new,\n-\t\t\t\t\t// \t\tposition: parser::Span {\n-\t\t\t\t\t// \t\t\tstart: 0,\n-\t\t\t\t\t// \t\t\tend: 0,\n-\t\t\t\t\t// \t\t\tsource_id: parser::SourceId::NULL,\n-\t\t\t\t\t// \t\t},\n-\t\t\t\t\t// \t};\n-\t\t\t\t\t// \treturn Ok(Some(\n-\t\t\t\t\t// \t\tcall_type(\n-\t\t\t\t\t// \t\t\tog,\n-\t\t\t\t\t// \t\t\tvec![arg],\n-\t\t\t\t\t// \t\t\tSome(on),\n-\t\t\t\t\t// \t\t\tNone,\n-\t\t\t\t\t// \t\t\tenvironment,\n-\t\t\t\t\t// \t\t\tchecking_data,\n-\t\t\t\t\t// \t\t\tCalledWithNew::default(),\n-\t\t\t\t\t// \t\t)\n-\t\t\t\t\t// \t\t.unwrap()\n-\t\t\t\t\t// \t\t.returned_type,\n-\t\t\t\t\t// \t));\n-\t\t\t\t\t// } else {\n-\t\t\t\t\t// \tenvironment.context_type.events.push(Event::Setter {\n-\t\t\t\t\t// \t\ton,\n-\t\t\t\t\t// \t\tnew,\n-\t\t\t\t\t// \t\tunder,\n-\t\t\t\t\t// \t\treflects_dependency: None,\n-\t\t\t\t\t// \t\tinitialization: false,\n-\t\t\t\t\t// \t});\n-\t\t\t\t\t// \tenvironment.proofs.new_property(on, under, new, false);\n-\t\t\t\t\t// }\n+\t\t\tLogical::Pure(og) => match og {\n+\t\t\t\tProperty::Value(og) => {\n+\t\t\t\t\tmatch types.get_type_by_id(og) {\n+\t\t\t\t\t\tType::Function(..) => todo!(\"look at setter\"),\n+\t\t\t\t\t\tType::Object(..) | Type::Constant(_) => {\n+\t\t\t\t\t\t\tenvironment\n+\t\t\t\t\t\t\t\t.properties\n+\t\t\t\t\t\t\t\t.entry(on)\n+\t\t\t\t\t\t\t\t.or_default()\n+\t\t\t\t\t\t\t\t.push((under, new.clone()));\n+\t\t\t\t\t\t\tenvironment.context_type.events.push(Event::Setter {\n+\t\t\t\t\t\t\t\ton,\n+\t\t\t\t\t\t\t\tnew,\n+\t\t\t\t\t\t\t\tunder,\n+\t\t\t\t\t\t\t\treflects_dependency: None,\n+\t\t\t\t\t\t\t\tinitialization: false,\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tType::And(_, _) | Type::Or(_, _) => todo!(),\n+\t\t\t\t\t\tType::RootPolyType(_) => todo!(),\n+\t\t\t\t\t\tType::Constructor(_) => todo!(),\n+\t\t\t\t\t\tType::NamedRooted { name, parameters } => {\n+\t\t\t\t\t\t\tcrate::utils::notify!(\"TODO temp, this might break things\");\n+\t\t\t\t\t\t\tenvironment\n+\t\t\t\t\t\t\t\t.properties\n+\t\t\t\t\t\t\t\t.entry(on)\n+\t\t\t\t\t\t\t\t.or_default()\n+\t\t\t\t\t\t\t\t.push((under, new.clone()));\n+\t\t\t\t\t\t\tenvironment.context_type.events.push(Event::Setter {\n+\t\t\t\t\t\t\t\ton,\n+\t\t\t\t\t\t\t\tnew,\n+\t\t\t\t\t\t\t\tunder,\n+\t\t\t\t\t\t\t\t// TODO\n+\t\t\t\t\t\t\t\treflects_dependency: None,\n+\t\t\t\t\t\t\t\tinitialization: false,\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tType::AliasTo { to, name, parameters } => {\n+\t\t\t\t\t\t\ttodo!();\n+\t\t\t\t\t\t\t// if environment.is_setter(og) {\n+\t\t\t\t\t\t\t// \t// TODO catch unwrap as error:\n+\t\t\t\t\t\t\t// \tlet arg = SynthesizedArgument::NonSpread {\n+\t\t\t\t\t\t\t// \t\tty: new,\n+\t\t\t\t\t\t\t// \t\tposition: parser::Span {\n+\t\t\t\t\t\t\t// \t\t\tstart: 0,\n+\t\t\t\t\t\t\t// \t\t\tend: 0,\n+\t\t\t\t\t\t\t// \t\t\tsource_id: parser::SourceId::NULL,\n+\t\t\t\t\t\t\t// \t\t},\n+\t\t\t\t\t\t\t// \t};\n+\t\t\t\t\t\t\t// \treturn Ok(Some(\n+\t\t\t\t\t\t\t// \t\tcall_type(\n+\t\t\t\t\t\t\t// \t\t\tog,\n+\t\t\t\t\t\t\t// \t\t\tvec![arg],\n+\t\t\t\t\t\t\t// \t\t\tSome(on),\n+\t\t\t\t\t\t\t// \t\t\tNone,\n+\t\t\t\t\t\t\t// \t\t\tenvironment,\n+\t\t\t\t\t\t\t// \t\t\tchecking_data,\n+\t\t\t\t\t\t\t// \t\t\tCalledWithNew::default(),\n+\t\t\t\t\t\t\t// \t\t)\n+\t\t\t\t\t\t\t// \t\t.unwrap()\n+\t\t\t\t\t\t\t// \t\t.returned_type,\n+\t\t\t\t\t\t\t// \t));\n+\t\t\t\t\t\t\t// } else {\n+\t\t\t\t\t\t\t// \tenvironment.context_type.events.push(Event::Setter {\n+\t\t\t\t\t\t\t// \t\ton,\n+\t\t\t\t\t\t\t// \t\tnew,\n+\t\t\t\t\t\t\t// \t\tunder,\n+\t\t\t\t\t\t\t// \t\treflects_dependency: None,\n+\t\t\t\t\t\t\t// \t\tinitialization: false,\n+\t\t\t\t\t\t\t// \t});\n+\t\t\t\t\t\t\t// \tenvironment.proofs.new_property(on, under, new, false);\n+\t\t\t\t\t\t\t// }\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\tProperty::Get(_) => todo!(),\n+\t\t\t\tProperty::Set(_) => todo!(),\n+\t\t\t\tProperty::GetAndSet(_, _) => todo!(),\n \t\t\t},\n \t\t\tLogical::Or(_) => todo!(),\n \t\t\tLogical::Implies(_, _) => todo!(),\n \t\t}\n \t} else {\n \t\t// TODO abstract\n-\t\tenvironment.properties.entry(on).or_default().push((under, new));\n+\t\tenvironment.properties.entry(on).or_default().push((under, new.clone()));\n \t\tenvironment.context_type.events.push(Event::Setter {\n \t\t\ton,\n \t\t\tnew,\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -26,6 +26,7 @@ pub struct TypeStore {\n \n impl Default for TypeStore {\n \tfn default() -> Self {\n+\t\t// These have to be in the order of TypeId\n \t\tlet mut types = vec![\n \t\t\tType::NamedRooted { name: \"error\".to_owned(), parameters: None },\n \t\t\tType::NamedRooted { name: \"never\".to_owned(), parameters: None },\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -43,6 +44,7 @@ impl Default for TypeStore {\n \t\t\t}),\n \t\t\tType::NamedRooted { name: \"object\".to_owned(), parameters: None },\n \t\t\tType::NamedRooted { name: \"Function\".to_owned(), parameters: None },\n+\t\t\tType::NamedRooted { name: \"RegExp\".to_owned(), parameters: None },\n \t\t\tType::Or(TypeId::STRING_TYPE, TypeId::NUMBER_TYPE),\n \t\t\t// true\n \t\t\tType::Constant(crate::Constant::Boolean(true)),\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -57,7 +59,7 @@ impl Default for TypeStore {\n \t\t\tType::Constant(crate::Constant::String(\"length\".into())),\n \t\t\t// this arg shortcut\n \t\t\tType::RootPolyType(PolyNature::ParentScope {\n-\t\t\t\treference: crate::events::Reference::This,\n+\t\t\t\treference: crate::events::RootReference::This,\n \t\t\t\tbased_on: crate::types::PolyPointer::Fixed(TypeId::ANY_TYPE),\n \t\t\t}),\n \t\t\tType::RootPolyType(PolyNature::Generic {\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -91,14 +93,14 @@ impl Default for TypeStore {\n impl TypeStore {\n \tpub fn new_constant_type(&mut self, constant: crate::Constant) -> crate::TypeId {\n \t\t// TODO don't recreate same constant\n-\t\tlet r#type = Type::Constant(constant);\n+\t\tlet ty = Type::Constant(constant);\n \t\t// TODO maybe separate id\n-\t\tself.register_type(r#type)\n+\t\tself.register_type(ty)\n \t}\n \n-\tpub(crate) fn register_type(&mut self, r#type: Type) -> TypeId {\n+\tpub(crate) fn register_type(&mut self, ty: Type) -> TypeId {\n \t\tlet id = TypeId(self.types.len().try_into().expect(\"too many types!\"));\n-\t\tself.types.push(r#type);\n+\t\tself.types.push(ty);\n \t\tid\n \t}\n \ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -128,13 +130,13 @@ impl TypeStore {\n \t}\n \n \tpub fn new_or_type(&mut self, lhs: TypeId, rhs: TypeId) -> TypeId {\n-\t\tlet r#type = Type::Or(lhs, rhs);\n-\t\tself.register_type(r#type)\n+\t\tlet ty = Type::Or(lhs, rhs);\n+\t\tself.register_type(ty)\n \t}\n \n \tpub fn new_and_type(&mut self, lhs: TypeId, rhs: TypeId) -> TypeId {\n-\t\tlet r#type = Type::And(lhs, rhs);\n-\t\tself.register_type(r#type)\n+\t\tlet ty = Type::And(lhs, rhs);\n+\t\tself.register_type(ty)\n \t}\n \n \t/// TODO temp\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -144,7 +146,7 @@ impl TypeStore {\n \n \tpub fn new_function_type_reference(\n \t\t&mut self,\n-\t\ttype_parameters: super::poly_types::GenericFunctionTypeParameters,\n+\t\ttype_parameters: Option<super::poly_types::GenericTypeParameters>,\n \t\tparameters: crate::structures::parameters::SynthesizedParameters,\n \t\treturn_type: TypeId,\n \t\tspan: source_map::Span,\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -153,17 +155,19 @@ impl TypeStore {\n \t) -> TypeId {\n \t\tself.register_type(Type::Function(\n \t\t\tFunctionType {\n-\t\t\t\tgeneric_type_parameters: type_parameters,\n+\t\t\t\ttype_parameters,\n \t\t\t\tparameters,\n \t\t\t\treturn_type,\n \t\t\t\teffects,\n \t\t\t\t// TODO\n \t\t\t\tclosed_over_references: Default::default(),\n \t\t\t\t// TODO\n-\t\t\t\tnature: crate::structures::functions::FunctionNature::Arrow,\n+\t\t\t\tkind: crate::structures::functions::FunctionKind::Arrow {\n+\t\t\t\t\tget_set: crate::GetSetGeneratorOrNone::None,\n+\t\t\t\t},\n \t\t\t\tconstant_id,\n \t\t\t},\n-\t\t\tsuper::FunctionNature::Source(crate::context::FunctionId(span), None, None),\n+\t\t\tsuper::FunctionNature::Source(crate::context::FunctionId(span), None),\n \t\t))\n \t}\n \ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -179,17 +183,22 @@ impl TypeStore {\n \t\t\tTypeRelationOperator::Extends { ty: check_type, extends },\n \t\t)));\n \t\tlet result_union = self.register_type(Type::Or(true_res, false_res));\n-\t\tlet r#type = Type::Constructor(super::Constructor::ConditionalTernary {\n+\t\tlet ty = Type::Constructor(super::Constructor::ConditionalTernary {\n \t\t\ton,\n \t\t\ttrue_res,\n \t\t\tfalse_res,\n \t\t\tresult_union,\n \t\t});\n-\t\tself.register_type(r#type)\n+\t\tself.register_type(ty)\n \t}\n \n \tpub fn new_anonymous_interface_ty(&mut self) -> TypeId {\n-\t\tlet r#type = Type::Object(super::ObjectNature::AnonymousTypeAnnotation);\n-\t\tself.register_type(r#type)\n+\t\tlet ty = Type::Object(super::ObjectNature::AnonymousTypeAnnotation);\n+\t\tself.register_type(ty)\n+\t}\n+\n+\t/// From something like: let a: number => string. Rather than a actual function\n+\tpub fn new_type_annotation_function_type(&mut self, function_type: FunctionType) -> TypeId {\n+\t\tself.register_type(Type::Function(function_type, super::FunctionNature::Reference))\n \t}\n }\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -131,10 +131,18 @@ pub enum SubTypeResult {\n #[derive(Debug)]\n pub enum NonEqualityReason {\n \tMismatch,\n-\tPropertiesInvalid { key: Vec<(TypeId, PropertyError)> },\n+\tPropertiesInvalid {\n+\t\tkey: Vec<(TypeId, PropertyError)>,\n+\t},\n \t// For function call-site type arguments\n-\tGenericRestrictionMismatch { restriction: TypeId, reason: Box<NonEqualityReason>, pos: Span },\n+\tGenericRestrictionMismatch {\n+\t\trestriction: TypeId,\n+\t\treason: Box<NonEqualityReason>,\n+\t\tpos: Span,\n+\t},\n \tTooStrict,\n+\t/// TODO more information\n+\tMissingParameter,\n }\n \n #[derive(Debug)]\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -156,6 +164,8 @@ pub fn type_is_subtype<T: SubtypeBehavior>(\n \tenvironment: &mut Environment,\n \ttypes: &TypeStore,\n ) -> SubTypeResult {\n+\tcrate::utils::notify!(\"Checking {} <: {}\", types.debug_type(base_type), types.debug_type(ty));\n+\n \tif (base_type == TypeId::ERROR_TYPE || base_type == TypeId::ANY_TYPE)\n \t\t|| (ty == TypeId::ERROR_TYPE || ty == TypeId::NEVER_TYPE)\n \t{\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -169,8 +179,94 @@ pub fn type_is_subtype<T: SubtypeBehavior>(\n \tlet left_ty = types.get_type_by_id(base_type);\n \tlet right_ty = types.get_type_by_id(ty);\n \n+\tmatch right_ty {\n+\t\t// This is reverse and\n+\t\tType::Or(left, right) => {\n+\t\t\tlet right = *right;\n+\t\t\tlet left_result = type_is_subtype(\n+\t\t\t\tbase_type,\n+\t\t\t\t*left,\n+\t\t\t\tty_arguments.as_deref(),\n+\t\t\t\tbehavior,\n+\t\t\t\tenvironment,\n+\t\t\t\ttypes,\n+\t\t\t);\n+\n+\t\t\treturn if let SubTypeResult::IsSubtype = left_result {\n+\t\t\t\ttype_is_subtype(\n+\t\t\t\t\tbase_type,\n+\t\t\t\t\tright,\n+\t\t\t\t\tty_arguments.as_deref(),\n+\t\t\t\t\tbehavior,\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\ttypes,\n+\t\t\t\t)\n+\t\t\t} else {\n+\t\t\t\tleft_result\n+\t\t\t};\n+\t\t}\n+\t\tType::Constructor(..) | Type::RootPolyType(..) => {\n+\t\t\tif let Some(argument) = ty_arguments.and_then(|ty_args| ty_args.get(&base_type)) {\n+\t\t\t\treturn type_is_subtype(\n+\t\t\t\t\tbase_type,\n+\t\t\t\t\t*argument,\n+\t\t\t\t\tty_arguments.as_deref(),\n+\t\t\t\t\tbehavior,\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\ttypes,\n+\t\t\t\t);\n+\t\t\t} else {\n+\t\t\t\tlet constraint = environment.get_poly_base(ty, types).unwrap();\n+\n+\t\t\t\tcrate::utils::notify!(\n+\t\t\t\t\t\"Checking via constraint {:?}... think this is okay in function bodies\",\n+\t\t\t\t\tconstraint\n+\t\t\t\t);\n+\n+\t\t\t\treturn match constraint {\n+\t\t\t\t\tcrate::context::PolyBase::Fixed { to, .. } => {\n+\t\t\t\t\t\ttype_is_subtype(base_type, to, ty_arguments, behavior, environment, types)\n+\t\t\t\t\t}\n+\t\t\t\t\t_ => todo!(),\n+\t\t\t\t};\n+\t\t\t}\n+\t\t}\n+\t\t_ => {}\n+\t}\n+\n \tmatch left_ty {\n-\t\tType::Function(..) => todo!(),\n+\t\tType::Function(left_func, _) => {\n+\t\t\tif let Type::Function(func, _) = right_ty {\n+\t\t\t\t// TODO optional and rest parameters\n+\t\t\t\tfor (idx, lhs_param) in left_func.parameters.parameters.iter().enumerate() {\n+\t\t\t\t\tmatch func.parameters.get_type_constraint_at_index(idx) {\n+\t\t\t\t\t\tSome(ty) => {\n+\t\t\t\t\t\t\tlet result = type_is_subtype(\n+\t\t\t\t\t\t\t\tlhs_param.ty,\n+\t\t\t\t\t\t\t\tty,\n+\t\t\t\t\t\t\t\tty_arguments,\n+\t\t\t\t\t\t\t\tbehavior,\n+\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\tmatch result {\n+\t\t\t\t\t\t\t\tSubTypeResult::IsSubtype => {}\n+\t\t\t\t\t\t\t\terr @ SubTypeResult::IsNotSubType(_) => {\n+\t\t\t\t\t\t\t\t\t// TODO don't short circuit\n+\t\t\t\t\t\t\t\t\treturn err;\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tNone => {\n+\t\t\t\t\t\t\treturn SubTypeResult::IsNotSubType(NonEqualityReason::MissingParameter)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tSubTypeResult::IsSubtype\n+\t\t\t} else {\n+\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n+\t\t\t}\n+\t\t}\n \t\tType::Constant(lhs) => {\n \t\t\tif let Type::Constant(rhs) = right_ty {\n \t\t\t\tif lhs == rhs {\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -180,7 +276,7 @@ pub fn type_is_subtype<T: SubtypeBehavior>(\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// TODO what about if LHS has inferred constraint\n-\t\t\t\tcrate::utils::notify!(\"Constant {:?} against RHS {:?}\", lhs, right_ty);\n+\t\t\t\tcrate::utils::notify!(\"Constant {:?} against RHS {:#?}\", lhs, right_ty);\n \t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n \t\t\t}\n \t\t}\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -191,9 +287,32 @@ pub fn type_is_subtype<T: SubtypeBehavior>(\n \t\t\t{\n \t\t\t\treturn value;\n \t\t\t}\n+\t\t\tif behavior.add_property_restrictions() {\n+\t\t\t\tmatch environment.object_constraints.entry(ty) {\n+\t\t\t\t\tstd::collections::hash_map::Entry::Occupied(entry) => {\n+\t\t\t\t\t\ttodo!()\n+\t\t\t\t\t\t// let new = types.new_and_type(lhs, rhs);\n+\t\t\t\t\t\t// entry.insert(new);\n+\t\t\t\t\t}\n+\t\t\t\t\tstd::collections::hash_map::Entry::Vacant(vacant) => {\n+\t\t\t\t\t\tvacant.insert(base_type);\n+\t\t\t\t\t}\n+\t\t\t\t};\n+\t\t\t}\n+\n \t\t\tSubTypeResult::IsSubtype\n \t\t}\n-\t\tType::And(_, _) => todo!(),\n+\t\tType::And(left, right) => {\n+\t\t\tlet right = *right;\n+\t\t\tlet left_result =\n+\t\t\t\ttype_is_subtype(*left, ty, ty_arguments.as_deref(), behavior, environment, types);\n+\n+\t\t\tif let SubTypeResult::IsSubtype = left_result {\n+\t\t\t\ttype_is_subtype(right, ty, ty_arguments.as_deref(), behavior, environment, types)\n+\t\t\t} else {\n+\t\t\t\tleft_result\n+\t\t\t}\n+\t\t}\n \t\tType::Or(left, right) => {\n \t\t\tlet right = *right;\n \t\t\tlet left_result =\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -206,6 +325,13 @@ pub fn type_is_subtype<T: SubtypeBehavior>(\n \t\t\t}\n \t\t}\n \t\tType::RootPolyType(nature) => {\n+\t\t\t// let name = if let crate::types::PolyNature::Generic { name, .. } = nature {\n+\t\t\t// \tSome(name)\n+\t\t\t// } else {\n+\t\t\t// \tcrate::utils::notify!(\"Here {:?}\", nature);\n+\t\t\t// \tNone\n+\t\t\t// };\n+\n \t\t\tlet constraint = environment.get_poly_base(base_type, types).unwrap().get_type();\n \n \t\t\tif let SubTypeResult::IsNotSubType(reasons) = type_is_subtype(\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -216,6 +342,7 @@ pub fn type_is_subtype<T: SubtypeBehavior>(\n \t\t\t\tenvironment,\n \t\t\t\ttypes,\n \t\t\t) {\n+\t\t\t\tcrate::utils::notify!(\"RPT not subtype\");\n \t\t\t\treturn SubTypeResult::IsNotSubType(reasons);\n \t\t\t}\n \ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -258,9 +385,11 @@ pub fn type_is_subtype<T: SubtypeBehavior>(\n \t\t\tif matches!(base_type, TypeId::STRING_TYPE | TypeId::NUMBER_TYPE | TypeId::BOOLEAN_TYPE)\n \t\t\t\t&& !matches!(\n \t\t\t\t\tright_ty,\n-\t\t\t\t\tType::RootPolyType(..) | Type::Constructor(..) | Type::Constant(..)\n+\t\t\t\t\tType::RootPolyType(..)\n+\t\t\t\t\t\t| Type::Constructor(..) | Type::Constant(..)\n+\t\t\t\t\t\t| Type::Or(..)\n \t\t\t\t) {\n-\t\t\t\tcrate::utils::notify!(\"Skipped checking a nominal\");\n+\t\t\t\tcrate::utils::notify!(\"Short circuited on {:?} as it is nominal\", right_ty);\n \t\t\t\t// TODO not primitive error\n \t\t\t\t// TODO this might break with *properties* proofs on primitives\n \t\t\t\t// e.g. number :< Nat\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -288,36 +417,39 @@ pub fn type_is_subtype<T: SubtypeBehavior>(\n \t\t\t\t\tcrate::utils::notify!(\"TODO implement function checking\");\n \t\t\t\t\treturn SubTypeResult::IsNotSubType(NonEqualityReason::Mismatch);\n \t\t\t\t}\n-\t\t\t\tType::AliasTo { .. } | Type::NamedRooted { .. } => {\n-\t\t\t\t\ttodo!()\n-\t\t\t\t}\n \t\t\t\tType::And(_, _) => todo!(),\n \t\t\t\tType::Or(left, right) => {\n-\t\t\t\t\tlet right = *right;\n-\t\t\t\t\tlet left = type_is_subtype(\n-\t\t\t\t\t\tbase_type,\n-\t\t\t\t\t\t*left,\n-\t\t\t\t\t\tty_arguments.as_deref(),\n-\t\t\t\t\t\tbehavior,\n-\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\ttypes,\n-\t\t\t\t\t);\n-\t\t\t\t\tif let SubTypeResult::IsSubtype = left {\n-\t\t\t\t\t\ttype_is_subtype(\n-\t\t\t\t\t\t\tbase_type,\n-\t\t\t\t\t\t\tright,\n-\t\t\t\t\t\t\tty_arguments,\n-\t\t\t\t\t\t\tbehavior,\n-\t\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\t\ttypes,\n-\t\t\t\t\t\t)\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n-\t\t\t\t\t}\n+\t\t\t\t\tunreachable!()\n+\t\t\t\t\t// TODO fails if RHS is also OR type :(\n+\t\t\t\t\t// let right = *right;\n+\t\t\t\t\t// let left = type_is_subtype(\n+\t\t\t\t\t// \tbase_type,\n+\t\t\t\t\t// \t*left,\n+\t\t\t\t\t// \tty_arguments.as_deref(),\n+\t\t\t\t\t// \tbehavior,\n+\t\t\t\t\t// \tenvironment,\n+\t\t\t\t\t// \ttypes,\n+\t\t\t\t\t// );\n+\t\t\t\t\t// if let SubTypeResult::IsSubtype = left {\n+\t\t\t\t\t// \ttype_is_subtype(\n+\t\t\t\t\t// \t\tbase_type,\n+\t\t\t\t\t// \t\tright,\n+\t\t\t\t\t// \t\tty_arguments,\n+\t\t\t\t\t// \t\tbehavior,\n+\t\t\t\t\t// \t\tenvironment,\n+\t\t\t\t\t// \t\ttypes,\n+\t\t\t\t\t// \t)\n+\t\t\t\t\t// } else {\n+\t\t\t\t\t// \tcrate::utils::notify!(\"Left failed\");\n+\t\t\t\t\t// \tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n+\t\t\t\t\t// }\n \t\t\t\t}\n \t\t\t\tType::Constructor(Constructor::StructureGenerics { on, with }) => {\n \t\t\t\t\ttodo!()\n \t\t\t\t}\n+\t\t\t\tType::AliasTo { .. } | Type::NamedRooted { .. } => {\n+\t\t\t\t\ttodo!()\n+\t\t\t\t}\n \t\t\t\tType::Constructor(..) | Type::RootPolyType(..) => {\n \t\t\t\t\tif let Some(argument) = ty_arguments.and_then(|ty_args| ty_args.get(&base_type))\n \t\t\t\t\t{\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -330,12 +462,13 @@ pub fn type_is_subtype<T: SubtypeBehavior>(\n \t\t\t\t\t\t\ttypes,\n \t\t\t\t\t\t)\n \t\t\t\t\t} else {\n+\t\t\t\t\t\tlet constraint = environment.get_poly_base(ty, types).unwrap();\n+\n \t\t\t\t\t\tcrate::utils::notify!(\n-\t\t\t\t\t\t\t\"Checking via constraint... think this is okay in function bodies\"\n+\t\t\t\t\t\t\t\"Checking via constraint {:?}... think this is okay in function bodies\",\n+\t\t\t\t\t\t\tconstraint\n \t\t\t\t\t\t);\n \n-\t\t\t\t\t\tlet constraint = environment.get_poly_base(ty, types).unwrap();\n-\n \t\t\t\t\t\tmatch constraint {\n \t\t\t\t\t\t\tcrate::context::PolyBase::Fixed { to, .. } => type_is_subtype(\n \t\t\t\t\t\t\t\tbase_type,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -389,13 +522,15 @@ fn check_properties<T: SubtypeBehavior>(\n \tfor (key, property) in environment.get_properties_on_type(base_type) {\n \t\t// TODO\n \t\tlet rhs_property = environment.get_property_unbound(ty, key, types);\n+\n \t\tmatch rhs_property {\n \t\t\tSome(rhs_property) => {\n \t\t\t\tmatch rhs_property {\n \t\t\t\t\tLogical::Pure(rhs_property) => {\n+\t\t\t\t\t\tlet rhs_type = rhs_property.as_get_type();\n \t\t\t\t\t\tlet result = type_is_subtype(\n \t\t\t\t\t\t\tproperty,\n-\t\t\t\t\t\t\trhs_property,\n+\t\t\t\t\t\t\trhs_type,\n \t\t\t\t\t\t\tty_arguments,\n \t\t\t\t\t\t\tbehavior,\n \t\t\t\t\t\t\tenvironment,\ndiff --git a/checker/src/types/terms.rs b/checker/src/types/terms.rs\n--- a/checker/src/types/terms.rs\n+++ b/checker/src/types/terms.rs\n@@ -12,6 +12,8 @@ pub enum Constant {\n \tNumber(ordered_float::NotNan<f64>),\n \tString(String),\n \tBoolean(bool),\n+\t/// TODO alternative parser representation == JS spec\n+\tRegexp(String),\n \tSymbol {\n \t\tkey: String,\n \t},\ndiff --git a/checker/src/types/terms.rs b/checker/src/types/terms.rs\n--- a/checker/src/types/terms.rs\n+++ b/checker/src/types/terms.rs\n@@ -30,6 +32,7 @@ impl Constant {\n \t\t\tConstant::String(value) => value.clone(),\n \t\t\tConstant::Boolean(value) => if *value { \"true\" } else { \"false\" }.to_owned(),\n \t\t\tConstant::Symbol { key } => format!(\"Symbol({key})\"),\n+\t\t\tConstant::Regexp(value) => format!(\"/{value}/\"),\n \t\t\tConstant::Undefined => \"undefined\".to_owned(),\n \t\t\tConstant::Null => \"null\".to_owned(),\n \t\t\tConstant::NaN => \"NaN\".to_owned(),\ndiff --git a/checker/src/types/terms.rs b/checker/src/types/terms.rs\n--- a/checker/src/types/terms.rs\n+++ b/checker/src/types/terms.rs\n@@ -45,6 +48,8 @@ impl Constant {\n \t\t\tConstant::String(value) => format!(\"\\\"{value}\\\"\"),\n \t\t\tConstant::Boolean(value) => if *value { \"true\" } else { \"false\" }.to_owned(),\n \t\t\tConstant::Symbol { key } => format!(\"Symbol({key})\"),\n+\t\t\t// TODO\n+\t\t\tConstant::Regexp(value) => format!(\"/{value}/\"),\n \t\t\tConstant::Undefined => \"undefined\".to_owned(),\n \t\t\tConstant::Null => \"null\".to_owned(),\n \t\t\tConstant::NaN => \"NaN\".to_owned(),\ndiff --git a/checker/src/types/terms.rs b/checker/src/types/terms.rs\n--- a/checker/src/types/terms.rs\n+++ b/checker/src/types/terms.rs\n@@ -55,6 +60,7 @@ impl Constant {\n \t\tmatch self {\n \t\t\tConstant::Number(_) | Constant::NaN => TypeId::NUMBER_TYPE,\n \t\t\tConstant::String(_) => TypeId::STRING_TYPE,\n+\t\t\tConstant::Regexp(_) => TypeId::REGEXP_TYPE,\n \t\t\tConstant::Boolean(_) => TypeId::BOOLEAN_TYPE,\n \t\t\tConstant::Undefined => TypeId::UNDEFINED_TYPE,\n \t\t\tConstant::Null => TypeId::NULL_TYPE,\ndiff --git a/checker/src/utils.rs b/checker/src/utils.rs\n--- a/checker/src/utils.rs\n+++ b/checker/src/utils.rs\n@@ -71,21 +71,21 @@ pub fn shorten(s: &str) -> &str {\n macro_rules! notify {\n     () => {\n \t\tif crate::utils::is_debug_mode() {\n-\t\t\t#[cfg(debug_assertions)]\n+\t\t\t#[cfg(all(debug_assertions, not(target_arch = \"wasm32\")))]\n \t\t\teprintln!(\"[{}:{}]\", crate::utils::shorten(file!()), line!())\n \t\t}\n     };\n \n     ($content:expr) => {\n \t\tif crate::utils::is_debug_mode() {\n-\t\t\t#[cfg(debug_assertions)]\n+\t\t\t#[cfg(all(debug_assertions, not(target_arch = \"wasm32\")))]\n \t\t\teprintln!(\"[{}:{}] {}\", crate::utils::shorten(file!()), line!(), $content)\n \t\t}\n     };\n \n     ($content:literal, $($es:expr),+) => {\n \t\tif crate::utils::is_debug_mode() {\n-\t\t\t#[cfg(debug_assertions)]\n+\t\t\t#[cfg(all(debug_assertions, not(target_arch = \"wasm32\")))]\n \t\t\teprintln!(\"[{}:{}] {}\", crate::utils::shorten(file!()), line!(), format_args!($content, $($es),+))\n \t\t}\n     };\n",
        "test_patch": "diff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -425,10 +560,13 @@ impl NonEqualityReason {\n \t\tenvironment: &GeneralEnvironment,\n \t) -> ReadableSubTypeErrorMessage {\n \t\tmatch self {\n-\t\t\tNonEqualityReason::Mismatch => Vec::new(),\n+\t\t\tNonEqualityReason::MissingParameter | NonEqualityReason::Mismatch => Vec::new(),\n \t\t\tNonEqualityReason::GenericRestrictionMismatch { restriction, reason, pos } => todo!(),\n \t\t\tNonEqualityReason::PropertiesInvalid { key } => todo!(),\n \t\t\tNonEqualityReason::TooStrict => todo!(),\n \t\t}\n \t}\n }\n+\n+#[cfg(test)]\n+mod tests {}\n",
        "problem_statement": "Or / sum on the RHS type equality\n[subtyping.rs](https://github.com/kaleidawave/ezno/blob/main/checker/src/types/subtyping.rs) current implements subtyping. Subtyping (sometimes expression as `type1 <: type2`), represents whether the type on the RHS satisfies all the properties of the LHS type.\r\n\r\nFor or / sum / union types the following logic happens. \r\nIf the LHS is a or type, then the RHS has to subtype the LHS or the RHS.\r\n\r\nSo for `a | b <: b` (`let x: number | string = 4`);\r\n```\r\na | b <: b --> a <: b || b <: b\r\n```\r\nThe following is true as the RHS is `true`. \r\n\r\nThe problem is what happens if the Or type is on the RHS. Will elaborate on cases later but it is currently broken\n",
        "hints_text": "",
        "created_at": "2023-06-15T11:52:14Z",
        "version": "0.0"
    },
    {
        "repo": "kaleidawave/ezno",
        "pull_number": 141,
        "instance_id": "kaleidawave__ezno-141",
        "issue_numbers": [
            "140"
        ],
        "base_commit": "bfd2133287e68a8b32016b208dbcac18629c4eec",
        "patch": "diff --git a/checker/definitions/overrides.d.ts b/checker/definitions/overrides.d.ts\n--- a/checker/definitions/overrides.d.ts\n+++ b/checker/definitions/overrides.d.ts\n@@ -1,6 +1,16 @@\n @Constant\n declare function debug_type_independent(t: any): void;\n \n+interface ImportEnv {\n+    [key: string]: string | undefined;\n+}\n+\n+interface ImportMeta {\n+    env: ImportEnv;\n+    url: string;\n+    resolve(url: string): string;\n+}\n+\n declare class Array<T> {\n     [index: number]: T | undefined;\n \ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -1892,6 +1892,20 @@ c satisfies 3;\n - Expected boolean, found 3\n - Expected 3, found 1\n \n+#### `import.meta`\n+\n+> Unfortunately because of bundling `url` and `resolve` cannot have known results so just `string`.\n+\n+```ts\n+import.meta.url satisfies number;\n+import.meta.resolve(\"./lib/helper.js\") satisfies string;\n+\n+import.meta.env.production satisfies boolean;\n+```\n+\n+- Expected number, found string\n+- Expected boolean, found string | undefined\n+\n ### Async and `Promise`s\n \n > Position of await is not checked (here is fine because top level await)\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -796,6 +796,9 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t\t\"Boolean\" => {\n \t\t\t\t\t\treturn TypeId::BOOLEAN_TYPE;\n \t\t\t\t\t}\n+\t\t\t\t\t\"ImportMeta\" => {\n+\t\t\t\t\t\treturn TypeId::IMPORT_META;\n+\t\t\t\t\t}\n \t\t\t\t\t_ => {}\n \t\t\t\t}\n \t\t\t}\ndiff --git a/checker/src/context/root.rs b/checker/src/context/root.rs\n--- a/checker/src/context/root.rs\n+++ b/checker/src/context/root.rs\n@@ -68,6 +68,7 @@ impl RootContext {\n \t\t\t(\"void\".to_owned(), TypeId::VOID_TYPE),\n \t\t\t(\"Array\".to_owned(), TypeId::ARRAY_TYPE),\n \t\t\t(\"Promise\".to_owned(), TypeId::PROMISE_TYPE),\n+\t\t\t(\"ImportMeta\".to_owned(), TypeId::IMPORT_META),\n \t\t\t(\"Function\".to_owned(), TypeId::FUNCTION_TYPE),\n \t\t\t(\"object\".to_owned(), TypeId::OBJECT_TYPE),\n \t\t\t(\"Literal\".to_owned(), TypeId::LITERAL_RESTRICTION),\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -857,6 +857,9 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t}\n \t\t\tSpecialOperators::NonNullAssertion(_) => todo!(),\n \t\t},\n+\t\tExpression::ImportMeta(_) => {\n+\t\t\tInstance::RValue(checking_data.types.new_open_type(TypeId::IMPORT_META))\n+\t\t}\n \t\tExpression::DynamicImport { position, .. } => {\n \t\t\tchecking_data.raise_unimplemented_error(\n \t\t\t\t\"dynamic import\",\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -97,7 +97,9 @@ impl TypeId {\n \tpub const LITERAL_RESTRICTION: Self = Self(24);\n \tpub const READONLY_RESTRICTION: Self = Self(25);\n \n-\tpub(crate) const INTERNAL_TYPE_COUNT: usize = 26;\n+\tpub const IMPORT_META: Self = Self(26);\n+\n+\tpub(crate) const INTERNAL_TYPE_COUNT: usize = 27;\n }\n \n #[derive(Clone, Debug, binary_serialize_derive::BinarySerializable)]\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -337,11 +337,11 @@ fn print_type_into_buf<C: InformationChain>(\n \t\tType::Class { name, parameters: _, .. }\n \t\t| Type::Interface { name, parameters: _, .. }\n \t\t| Type::AliasTo { to: _, name, parameters: _ } => {\n-\t\t\t// if debug && ty.0 as usize > TypeId::INTERNAL_TYPE_COUNT {\n-\t\t\t// write!(buf, \"(r{} nom={:?}) {name}\", ty.0, nominal).unwrap();\n-\t\t\t// } else {\n-\t\t\tbuf.push_str(name);\n-\t\t\t// }\n+\t\t\tif debug {\n+\t\t\t\twrite!(buf, \"{name}#{}\", ty.0).unwrap();\n+\t\t\t} else {\n+\t\t\t\tbuf.push_str(name);\n+\t\t\t}\n \n \t\t\t// if let (true, Some(parameters)) = (debug, parameters) {\n \t\t\t// \tbuf.push('{');\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -120,6 +120,7 @@ impl Default for TypeStore {\n \t\t\t\tto: TypeId::T_TYPE,\n \t\t\t\tparameters: Some(vec![TypeId::T_TYPE]),\n \t\t\t},\n+\t\t\tType::Interface { name: \"ImportMeta\".to_owned(), parameters: None, nominal: false },\n \t\t];\n \n \t\t// Check that above is correct, TODO eventually a macro\ndiff --git a/parser/src/declarations/mod.rs b/parser/src/declarations/mod.rs\n--- a/parser/src/declarations/mod.rs\n+++ b/parser/src/declarations/mod.rs\n@@ -73,13 +73,13 @@ impl Declaration {\n \t\toptions: &ParseOptions,\n \t) -> bool {\n \t\tlet Some(Token(token, _)) = reader.peek() else { return false };\n+\n \t\tlet result = matches!(\n \t\t\ttoken,\n \t\t\tTSXToken::Keyword(\n \t\t\t\tTSXKeyword::Let\n \t\t\t\t\t| TSXKeyword::Const | TSXKeyword::Function\n-\t\t\t\t\t| TSXKeyword::Class | TSXKeyword::Import\n-\t\t\t\t\t| TSXKeyword::Export\n+\t\t\t\t\t| TSXKeyword::Class | TSXKeyword::Export\n \t\t\t) | TSXToken::At,\n \t\t);\n \ndiff --git a/parser/src/declarations/mod.rs b/parser/src/declarations/mod.rs\n--- a/parser/src/declarations/mod.rs\n+++ b/parser/src/declarations/mod.rs\n@@ -91,22 +91,45 @@ impl Declaration {\n \t\t\t\tlet TSXToken::Keyword(token) = *token else { return false };\n \t\t\t\tlet Some(Token(after, _)) = reader.peek_n(1) else { return false };\n \n-\t\t\t\tmatches!(\n-\t\t\t\t\ttoken,\n-\t\t\t\t\tTSXKeyword::Declare | TSXKeyword::Interface\n-\t\t\t\t\tif options.type_annotations\n-\t\t\t\t) || matches!(\n-\t\t\t\t\t(token, after),\n-\t\t\t\t\t(TSXKeyword::From, TSXToken::StringLiteral(..))\n-\t\t\t\t\t\t| (TSXKeyword::Async, TSXToken::Keyword(TSXKeyword::Function))\n-\t\t\t\t) || matches!(\n-\t\t\t\t\t(token, after),\n-\t\t\t\t\t(TSXKeyword::Async, TSXToken::Keyword(kw)) if options.custom_function_headers && kw.is_special_function_header()\n-\t\t\t\t)\n+\t\t\t\t#[allow(clippy::match_same_arms)]\n+\t\t\t\tmatch (token, after) {\n+\t\t\t\t\t// For dynamic import\n+\t\t\t\t\t(\n+\t\t\t\t\t\tTSXKeyword::Import,\n+\t\t\t\t\t\tTSXToken::OpenBrace\n+\t\t\t\t\t\t| TSXToken::Keyword(..)\n+\t\t\t\t\t\t| TSXToken::Identifier(..)\n+\t\t\t\t\t\t| TSXToken::StringLiteral(..)\n+\t\t\t\t\t\t| TSXToken::Multiply,\n+\t\t\t\t\t) => true,\n+\t\t\t\t\t(TSXKeyword::Declare | TSXKeyword::Interface, _) => options.type_annotations,\n+\t\t\t\t\t(TSXKeyword::Async, TSXToken::Keyword(TSXKeyword::Function)) => true,\n+\t\t\t\t\t(TSXKeyword::Async, TSXToken::Keyword(kw)) => {\n+\t\t\t\t\t\toptions.custom_function_headers && kw.is_special_function_header()\n+\t\t\t\t\t}\n+\t\t\t\t\t// Extra\n+\t\t\t\t\t(TSXKeyword::From, TSXToken::StringLiteral(..)) => true,\n+\t\t\t\t\t(..) => false,\n+\t\t\t\t}\n \t\t\t};\n \n \t\t#[cfg(not(feature = \"extras\"))]\n-\t\treturn result;\n+\t\treturn result || {\n+\t\t\tlet TSXToken::Keyword(token) = *token else { return false };\n+\n+\t\t\t// For dynamic import\n+\t\t\tmatches!(token, TSXKeyword::Import)\n+\t\t\t\t&& matches!(\n+\t\t\t\t\treader.peek_n(1),\n+\t\t\t\t\tSome(Token(\n+\t\t\t\t\t\tTSXToken::OpenBrace\n+\t\t\t\t\t\t\t| TSXToken::Keyword(..) | TSXToken::Identifier(..)\n+\t\t\t\t\t\t\t| TSXToken::StringLiteral(..)\n+\t\t\t\t\t\t\t| TSXToken::Multiply,\n+\t\t\t\t\t\t_\n+\t\t\t\t\t))\n+\t\t\t\t)\n+\t\t};\n \t}\n }\n \ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -115,6 +115,7 @@ pub enum Expression {\n \tSuperExpression(SuperReference, Span),\n \t/// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target\n \tNewTarget(Span),\n+\tImportMeta(Span),\n \tDynamicImport {\n \t\tpath: Box<Expression>,\n \t\toptions: Option<Box<Expression>>,\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -287,25 +288,36 @@ impl Expression {\n \t\t\tt @ Token(TSXToken::Keyword(TSXKeyword::This), _) => {\n \t\t\t\tExpression::ThisReference(t.get_span())\n \t\t\t}\n-\t\t\tToken(TSXToken::Keyword(TSXKeyword::Import), start) => {\n-\t\t\t\tlet _ = reader.expect_next(TSXToken::OpenParentheses)?;\n-\t\t\t\tlet path = Expression::from_reader(reader, state, options)?;\n-\t\t\t\tif let Expression::StringLiteral(path, ..) = &path {\n-\t\t\t\t\tstate.constant_imports.push(path.clone());\n-\t\t\t\t} else {\n-\t\t\t\t\t// TODO warning dynamic\n-\t\t\t\t}\n-\t\t\t\tlet options = if reader.conditional_next(|t| matches!(t, TSXToken::Comma)).is_some()\n-\t\t\t\t{\n-\t\t\t\t\tSome(Box::new(Expression::from_reader(reader, state, options)?))\n+\t\t\tt @ Token(TSXToken::Keyword(TSXKeyword::Import), start) => {\n+\t\t\t\tlet token = reader.next();\n+\t\t\t\tif let Some(Token(TSXToken::Dot, _)) = token {\n+\t\t\t\t\tlet meta_start = reader.expect_next(TSXToken::Identifier(\"meta\".into()))?;\n+\t\t\t\t\tExpression::ImportMeta(start.union(meta_start.get_end_after(\"meta\".len())))\n+\t\t\t\t} else if let Some(Token(TSXToken::OpenParentheses, _)) = token {\n+\t\t\t\t\tlet path = Expression::from_reader(reader, state, options)?;\n+\t\t\t\t\tif let Expression::StringLiteral(path, ..) = &path {\n+\t\t\t\t\t\tstate.constant_imports.push(path.clone());\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tlet options =\n+\t\t\t\t\t\tif reader.conditional_next(|t| matches!(t, TSXToken::Comma)).is_some() {\n+\t\t\t\t\t\t\tSome(Box::new(Expression::from_reader(reader, state, options)?))\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tNone\n+\t\t\t\t\t\t};\n+\t\t\t\t\tlet end = reader.expect_next(TSXToken::CloseParentheses)?;\n+\t\t\t\t\tExpression::DynamicImport {\n+\t\t\t\t\t\tpath: Box::new(path),\n+\t\t\t\t\t\toptions,\n+\t\t\t\t\t\tposition: start.union(end.get_end_after(1)),\n+\t\t\t\t\t}\n+\t\t\t\t} else if let Some(token) = token {\n+\t\t\t\t\treturn throw_unexpected_token_with_token(\n+\t\t\t\t\t\ttoken,\n+\t\t\t\t\t\t&[TSXToken::Dot, TSXToken::OpenParentheses],\n+\t\t\t\t\t);\n \t\t\t\t} else {\n-\t\t\t\t\tNone\n-\t\t\t\t};\n-\t\t\t\tlet end = reader.expect_next(TSXToken::OpenParentheses)?;\n-\t\t\t\tExpression::DynamicImport {\n-\t\t\t\t\tpath: Box::new(path),\n-\t\t\t\t\toptions,\n-\t\t\t\t\tposition: start.union(end.get_end_after(1)),\n+\t\t\t\t\treturn Err(ParseError::new(ParseErrors::LexingFailed, t.get_span()));\n \t\t\t\t}\n \t\t\t}\n \t\t\tt @ Token(TSXToken::Keyword(TSXKeyword::Super), _) => {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1224,6 +1236,7 @@ impl Expression {\n \t\t\t| Self::SuperExpression(..)\n \t\t\t| Self::NewTarget(..)\n \t\t\t| Self::ClassExpression(..)\n+\t\t\t| Self::ImportMeta(..)\n \t\t\t| Self::DynamicImport { .. }\n \t\t\t| Self::Marker { .. } => PARENTHESIZED_EXPRESSION_AND_LITERAL_PRECEDENCE,\n \t\t\tSelf::BinaryOperation { operator, .. } => operator.precedence(),\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1506,6 +1519,9 @@ impl Expression {\n \t\t\tSelf::NewTarget(..) => {\n \t\t\t\tbuf.push_str(\"new.target\");\n \t\t\t}\n+\t\t\tSelf::ImportMeta(..) => {\n+\t\t\t\tbuf.push_str(\"import.meta\");\n+\t\t\t}\n \t\t\tSelf::DynamicImport { path, .. } => {\n \t\t\t\tbuf.push_str(\"import(\");\n \t\t\t\tpath.to_string_from_buffer(buf, options, local);\n",
        "test_patch": "diff --git a/checker/definitions/simple.d.ts b/checker/definitions/simple.d.ts\n--- a/checker/definitions/simple.d.ts\n+++ b/checker/definitions/simple.d.ts\n@@ -1,168 +1,52 @@\n-// \u2193\u2193 Ezno testing functions \u2193\u2193\n-declare function debug_context(): void performs const debug_context;\n-declare function print_type(t: any): void performs const print_type;\n-declare function print_and_debug_type(t: any): void performs const print_and_debug_type;\n-declare function print_constraint(t: any): void performs const print_constraint;\n-declare function debug_type(t: any): void performs const debug_type;\n-declare function debug_type_independent(t: any): void performs const debug_type_independent;\n-declare function debug_type_rust(t: any): void performs const debug_type_rust;\n-declare function debug_type_rust_independent(t: any): void performs const debug_type_rust_independent;\n-declare function debug_effects_rust(t: () => {}): void performs const debug_effects_rust;\n-declare function debug_effects(t: () => {}): void performs const debug_effects;\n-declare function is_dependent(t: any): void performs const is_dependent;\n-\n-declare function context_id(): void performs const context_id;\n-declare function context_id_chain(): void performs const context_id_chain;\n+@Constant\n+declare function print_type<T>(...args: Array<T>): void;\n+@Constant\n+declare function debug_type<T>(...args: Array<T>): void;\n+@Constant\n+declare function print_and_debug_type<T>(...args: Array<T>): void;\n+@Constant\n+declare function print_constraint(t: any): void;\n+@Constant\n+declare function debug_type_rust(t: any): void;\n+@Constant\n+declare function debug_type_rust_independent(t: any): void;\n+\n+@Constant\n+declare function debug_effects_rust(t: () => {}): void;\n+@Constant\n+declare function debug_effects(t: () => {}): void;\n+\n+@Constant\n+declare function is_dependent(t: any): void;\n+@Constant\n+declare function print_environment_state<T>(): any;\n+\n+@Constant\n+declare function debug_context(): void;\n+@Constant\n+declare function context_id(): void;\n+@Constant\n+declare function context_id_chain(): void;\n \n // A function, as it should be!\n-declare function satisfies<T>(t: T): T performs const satisfies;\n-\n-declare function compile_type_to_object<T>(): any performs const compile_type_to_object;\n-// \u2191\u2191 Ezno Functions \u2191\u2191\n+@Constant\n+declare function satisfies<T>(t: T): T;\n \n-// declare var undefined: undefined;\n+@Constant\n+declare function compile_type_to_object<T>(): any;\n \n-interface nominal Array<T> {\n+declare class Array<T> {\n     [index: number]: T | undefined;\n-    \n-    length: number;\n-\n-    push(item: T) performs {\n-        this[this.length] = item;\n-        return ++this.length\n-    }\n-\n-    pop(): T | undefined performs {\n-        if (this.length === 0) {\n-            return undefined\n-        } else {\n-            const value = this[--this.length];\n-            delete this[this.length];\n-            return value\n-        }\n-    }\n-\n-    // TODO this argument\n-    map<U>(cb: (t: T, i?: number) => U): Array<U> performs {\n-        const { length } = this, u: Array<U> = [];\n-        let i: number = 0;\n-        while (i < length) {\n-            const value = this[i];\n-            u.push(cb(value, i++))\n-        }\n-        return u;\n-    }\n-\n-    map2<U>(cb: (t: T, i?: number) => U): any performs {\n-        return cb;\n-    }\n-\n-    filter(cb: (t: T, i?: number) => any): Array<T> performs {\n-        const { length } = this, filtered: Array<T> = [];\n-        let i: number = 0;\n-        while (i < length) {\n-            const value = this[i];\n-            const res = cb(value, i++)\n-            // debug_type_independent(res)\n-            if (res) {\n-                filtered.push(value)\n-            }\n-        }\n-        return filtered;\n-    }\n-\n-    // last() performs {\n-    //     return this[this.length - 1]\n-    // }\n-}\n \n-interface Math {\n-    @DoNotIncludeThis\n-    sin(x: number): number performs const sin;\n-    @DoNotIncludeThis\n-    cos(x: number): number performs const cos;\n-    @DoNotIncludeThis\n-    tan(x: number): number performs const tan;\n-    @DoNotIncludeThis\n-    floor(x: number): number performs const floor;\n-    @DoNotIncludeThis\n-    sqrt(x: number): number performs const sqrt;\n-    @DoNotIncludeThis\n-    cbrt(x: number): number performs const cbrt;\n-\n-    // TODO newer method\n-    trunc(x: number): number performs const trunc;\n-\n-    PI: 3.141592653589793\n-}\n-\n-interface nominal string {\n-    [index: number]: string | undefined;\n-\n-    toUpperCase(): string performs const uppercase;\n-    toLowerCase(): string performs const lowercase;\n-\n-    get length(): number performs const string_length;\n-}\n-\n-interface Console {\n-    @DoNotIncludeThis\n-    log(msg: any): void;\n-}\n-\n-interface JSON {\n-    // TODO any temp\n-    @DoNotIncludeThis\n-    parse(input: string): any;\n-\n-    // TODO any temp\n-    @DoNotIncludeThis\n-    stringify(input: any): string;\n-}\n-\n-interface Function {\n-    bind(this_ty: any): Function performs const bind;\n-}\n-\n-interface Symbols {\n-    // TODO temp\n-    iterator: 199\n-}\n-\n-declare const Symbol: Symbols;\n-\n-interface Object {\n-    @DoNotIncludeThis\n-    setPrototypeOf(on: object, to: object): object performs const set_prototype;\n-\n-    @DoNotIncludeThis\n-    getPrototypeOf(on: object): object | null performs const get_prototype;\n-\n-    // create(prototype: object): object performs {\n-    //     const n = {};\n-    //     Object.setProtoTypeOf(n, prototype);\n-    //     return n\n-    // }\n-}\n-\n-declare const JSON: JSON;\n-declare const Math: Math;\n-declare const console: Console;\n-declare const Object: Object;\n-\n-declare function JSXH(tag: string, attributes: any, children?: any) performs {\n-    return { tag, attributes, children }\n-}\n-\n-interface Document {\n-    title: string\n+    length: number;\n }\n \n-interface FormData {\n+interface ImportEnv {\n+    [key: string]: string | undefined;\n }\n \n-@client\n-declare const document: Document;\n-\n-// @server\n-// declare function createItem(a: any);\n\\ No newline at end of file\n+interface ImportMeta {\n+    env: ImportEnv;\n+    url: string;\n+    resolve(url: string): string;\n+}\n\\ No newline at end of file\ndiff --git a/parser/tests/expressions.rs b/parser/tests/expressions.rs\n--- a/parser/tests/expressions.rs\n+++ b/parser/tests/expressions.rs\n@@ -102,6 +102,25 @@ const d = /in a set[=/]/\n \tassert_eq!(output, input);\n }\n \n+#[test]\n+fn import_expression() {\n+\tlet input = r#\"\n+const a = import(\"file\");\n+const b = import(\"some\" + \"expression\");\n+const c = import.meta;\n+const d = import.meta.env;\n+const helperPath = import.meta.resolve(\"./lib/helper.js\")\n+    \"#\n+\t.trim();\n+\n+\tlet module = Module::from_string(input.to_owned(), Default::default()).unwrap();\n+\n+\teprintln!(\"Module: {module:#?}\");\n+\n+\tlet output = module.to_string(&ezno_parser::ToStringOptions::typescript());\n+\tassert_eq!(output, input);\n+}\n+\n #[cfg(feature = \"extras\")]\n #[test]\n fn jsx() {\n",
        "problem_statement": "Parsing import meta\nThere's no implementations for import meta. It is trying to parse as dynamic import.\r\n\r\n```\r\nerror:\r\n  \u250c\u2500 file.ts:1:23\r\n  \u2502\r\n1 \u2502 const isProduction = import.meta.env.PROD;\r\n  \u2502                       ^ Expected OpenParentheses found Dot\r\n```\n",
        "hints_text": "",
        "created_at": "2024-05-12T07:49:48Z",
        "version": "0.0"
    },
    {
        "repo": "kaleidawave/ezno",
        "pull_number": 155,
        "instance_id": "kaleidawave__ezno-155",
        "issue_numbers": [
            "162"
        ],
        "base_commit": "9dd05b7ca5aa973b65837e09b1fb2fb04e04dd1e",
        "patch": "diff --git a/.github/workflows/github-release.yml b/.github/workflows/github-release.yml\n--- a/.github/workflows/github-release.yml\n+++ b/.github/workflows/github-release.yml\n@@ -61,18 +61,18 @@ jobs:\n                 edges {\n                   node {\n                     sponsor {\n-                      name\n+                      name, login\n                     }\n                   }\n                 }\n               }\n             }\n-          }' -q '.data.user.sponsorshipsAsMaintainer.edges | map(.node.sponsor.name) | join(\",\")')\n+          }' -q '.data.user.sponsorshipsAsMaintainer.edges | map(.node.sponsor.name // .node.sponsor.login) | join(\",\") | join(\",\")')\n           \n           echo \"SPONSORS=$SPONSORS\" >> $GITHUB_OUTPUT\n \n           CONTRIBUTORS=$(\n-            gh pr list --search \"-author:@me\" --state merged --json author | jq 'map(.author.name) | unique | join(\",\")' --raw-output\n+            gh pr list --state merged --json author | jq 'map(.author.name // .author.login) | unique | join(\",\")' --raw-output\n           )\n \n           echo \"CONTRIBUTORS=$CONTRIBUTORS\" >> $GITHUB_OUTPUT\ndiff --git a/.github/workflows/performance-and-size.yml b/.github/workflows/performance-and-size.yml\n--- a/.github/workflows/performance-and-size.yml\n+++ b/.github/workflows/performance-and-size.yml\n@@ -55,6 +55,11 @@ jobs:\n \n           LINES_OF_CODE=$(scc -c --no-cocomo -f json demo.ts | jq \".[0].Code\")\n \n+          echo \"### Checking\n+          \\`\\`\\`shell\n+          $(hyperfine -i './target/release/ezno check demo.ts')\n+          \\`\\`\\`\" >> $GITHUB_STEP_SUMMARY\n+\n           echo \"<details>\n           <summary>Input</summary>\n \ndiff --git a/.github/workflows/performance-and-size.yml b/.github/workflows/performance-and-size.yml\n--- a/.github/workflows/performance-and-size.yml\n+++ b/.github/workflows/performance-and-size.yml\n@@ -72,23 +77,10 @@ jobs:\n           <summary>Diagnostics</summary>\n           \n           \\`\\`\\`\n-          $(./target/release/ezno check demo.ts --timings 2>&1 || true)\n+          $(./target/release/ezno check demo.ts --timings --max-diagnostics all 2>&1 || true)\n           \\`\\`\\`\n           </details>\n           \" >> $GITHUB_STEP_SUMMARY\n-          \n-          echo \"### Checking\n-          \\`\\`\\`shell\n-          $(hyperfine -i './target/release/ezno check demo.ts')\n-          \\`\\`\\`\" >> $GITHUB_STEP_SUMMARY\n-\n-          echo \"::group::Comparing printing of diagnostics\"\n-          hyperfine -i './target/release/ezno check demo.ts' './target/release/ezno check demo.ts --compact-diagnostics' './target/release/ezno check demo.ts --count-diagnostics'\n-          echo \"::endgroup::\"\n-        \n-          echo \"::group::cargo tree\"\n-          cargo tree\n-          echo \"::endgroup::\"\n \n       - name: Run parser, minfier/stringer performance\n         shell: bash\ndiff --git a/.github/workflows/publish.yml b/.github/workflows/publish.yml\n--- a/.github/workflows/publish.yml\n+++ b/.github/workflows/publish.yml\n@@ -66,18 +66,18 @@ jobs:\n                 edges {\n                   node {\n                     sponsor {\n-                      name\n+                      name, login\n                     }\n                   }\n                 }\n               }\n             }\n-          }' -q '.data.user.sponsorshipsAsMaintainer.edges | map(.node.sponsor.name) | join(\",\")')\n+          }' -q '.data.user.sponsorshipsAsMaintainer.edges | map(.node.sponsor.name // .node.sponsor.login) | join(\",\") | join(\",\")')\n           \n           echo \"SPONSORS=$SPONSORS\" >> $GITHUB_OUTPUT\n \n           CONTRIBUTORS=$(\n-            gh pr list --search \"-author:@me\" --state merged --json author | jq 'map(.author.name) | unique | join(\",\")' --raw-output\n+            gh pr list --state merged --json author | jq 'map(.author.name // .author.login) | unique | join(\",\")' --raw-output\n           )\n \n           echo \"CONTRIBUTORS=$CONTRIBUTORS\" >> $GITHUB_OUTPUT\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -270,6 +270,7 @@ dependencies = [\n  \"enum-variants-strings\",\n  \"ezno-checker\",\n  \"ezno-parser\",\n+ \"glob\",\n  \"js-sys\",\n  \"multiline-term-input\",\n  \"native-tls\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -427,6 +428,12 @@ dependencies = [\n  \"syn-helpers\",\n ]\n \n+[[package]]\n+name = \"glob\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d2fabcfbdc87f4758337ca535fb41a6d701b65693ce38287d856d1674551ec9b\"\n+\n [[package]]\n name = \"gloo-utils\"\n version = \"0.1.7\"\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -46,6 +46,7 @@ enum-variants-strings = \"0.3\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0\"\n simple-json-parser = \"0.0.2\"\n+glob = \"0.3\"\n \n [target.'cfg(not(target_family = \"wasm\"))'.dependencies]\n # For updating binary\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -23,11 +23,11 @@ What Ezno is not\n - Smarter as a means to allow more *dynamic patterns*. Keep things simple!\n - A binary executable compiler. It takes in JavaScript (or a TypeScript or Ezno superset) and does similar processes to traditional compilers, but at the end emits JavaScript. However, in the future, it _could_ generate a lower level format using its event (side-effect) representation.\n \n-Read more about Ezno:\n+Read more about Ezno (in chronological order)\n - [Introducing Ezno](https://kaleidawave.github.io/posts/introducing-ezno/)\n - [Ezno in '23](https://kaleidawave.github.io/posts/ezno-23/)\n - [A preview of the checker](https://kaleidawave.github.io/posts/a-preview-of-the-checker/)\n-- [The Quest Continues](https://kaleidawave.github.io/posts/the-quest-continues/)\n+- [The quest continues](https://kaleidawave.github.io/posts/the-quest-continues/)\n \n ---\n \ndiff --git a/checker/binary-serialize-derive/Cargo.toml b/checker/binary-serialize-derive/Cargo.toml\n--- a/checker/binary-serialize-derive/Cargo.toml\n+++ b/checker/binary-serialize-derive/Cargo.toml\n@@ -15,4 +15,4 @@ syn-helpers = \"0.5\"\n \n [lib]\n path = \"macro.rs\"\n-proc_macro = true\n+proc-macro = true\ndiff --git a/checker/documentation/getting-started.md b/checker/documentation/getting-started.md\n--- a/checker/documentation/getting-started.md\n+++ b/checker/documentation/getting-started.md\n@@ -2,13 +2,15 @@ Ezno is work in progress. It doesn't currently support all the features of JavaS\n \n While it **is not worth it trying it on existing codebases at this time** (as it likely will blow up \ud83d\udca5), **you can try out the snippets in the [specification](../specification/specification.md)** and other small pieces of code today.\n \n-You can try the `check` command of ezno using `npx`\n+The best way to try the type checker is on the [web playground](https://kaleidawave.github.io/ezno/playground).\n+\n+Alternative you can try the checker locally using the `check` command of ezno binary. The simplest way is using `npx`\n \n ```shell\n npx ezno check file.ts\n ```\n \n-Or download the binary with `npm install ezno`, `cargo install ezno` or on [GitHub releases](https://github.com/kaleidawave/ezno/releases).\n+You can also download the binary with `npm install ezno`. Or for the native (non WASM version) you can get it with `cargo install ezno` or on [GitHub releases](https://github.com/kaleidawave/ezno/releases).\n \n ---\n \ndiff --git a/checker/documentation/getting-started.md b/checker/documentation/getting-started.md\n--- a/checker/documentation/getting-started.md\n+++ b/checker/documentation/getting-started.md\n@@ -19,4 +21,4 @@ const x = 6;\n print_type(x + 8)\n ```\n \n-If you find any unexpected exceptions, please leave an issue \ud83d\ude01\n+If you find any unexpected exceptions, please [leave an issue \ud83d\ude01](https://github.com/kaleidawave/ezno/issues/new)\ndiff --git a/parser/README.md b/parser/README.md\n--- a/parser/README.md\n+++ b/parser/README.md\n@@ -35,7 +35,7 @@ fn main() {\n    \t- See expression identifiers can be used to bind information to\n    \t- Retain source positions for use in analysis diagnostics and generating source maps\n    \t- All AST should be visitable. Immutably to collect facts or mutable to transform/remove\n-- Optionally via configuration extend the ECMAscript language definition\n+- Optionally via configuration extend the *ECMAScript language definition*\n    \t- TypeScript type annotations\n       \t\t- Interfaces, enums and type alias statements\n       \t\t- Parameter, return type and variable annotations\ndiff --git a/parser/examples/code_blocks_to_script.rs b/parser/examples/code_blocks_to_script.rs\n--- a/parser/examples/code_blocks_to_script.rs\n+++ b/parser/examples/code_blocks_to_script.rs\n@@ -1,4 +1,4 @@\n-use std::{collections::HashSet, io::Write};\n+use std::{collections::HashSet, io::Write, path::PathBuf};\n \n use ezno_parser::{\n \tast::{InterfaceDeclaration, TypeAlias},\ndiff --git a/parser/examples/code_blocks_to_script.rs b/parser/examples/code_blocks_to_script.rs\n--- a/parser/examples/code_blocks_to_script.rs\n+++ b/parser/examples/code_blocks_to_script.rs\n@@ -8,9 +8,17 @@ use ezno_parser::{\n };\n \n fn main() -> Result<(), Box<dyn std::error::Error>> {\n-\tlet mut args = std::env::args().skip(1);\n-\tlet path = args.next().ok_or(\"expected path to markdown file\")?;\n-\tlet out = args.next();\n+\tlet args = std::env::args().skip(1).collect::<Vec<_>>();\n+\tlet path = args.first().ok_or(\"expected path to markdown file\")?;\n+\n+\tlet replace_satisfies_with_as = args.iter().any(|item| item == \"--satisfies-with-as\");\n+\n+\tlet into_files_directory_and_extension = args.windows(3).find_map(|item| {\n+\t\tmatches!(item[0].as_str(), \"--into-files\").then_some((item[1].clone(), item[2].clone()))\n+\t});\n+\tlet out_file = args\n+\t\t.windows(2)\n+\t\t.find_map(|item| matches!(item[0].as_str(), \"--out\").then_some(item[1].clone()));\n \n \tlet content = std::fs::read_to_string(&path)?;\n \ndiff --git a/parser/examples/code_blocks_to_script.rs b/parser/examples/code_blocks_to_script.rs\n--- a/parser/examples/code_blocks_to_script.rs\n+++ b/parser/examples/code_blocks_to_script.rs\n@@ -18,8 +26,9 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n \n \tlet blocks = if path.ends_with(\".md\") {\n \t\tlet mut blocks = Vec::new();\n-\n \t\tlet mut lines = content.lines();\n+\t\tlet mut current = String::default();\n+\n \t\twhile let Some(line) = lines.next() {\n \t\t\tif line.starts_with(\"```ts\") {\n \t\t\t\tlet mut indented_code = lines\ndiff --git a/parser/examples/code_blocks_to_script.rs b/parser/examples/code_blocks_to_script.rs\n--- a/parser/examples/code_blocks_to_script.rs\n+++ b/parser/examples/code_blocks_to_script.rs\n@@ -34,8 +43,10 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n \t\t\t\tdebug_assert_eq!(indented_code.pop(), Some('\\t'));\n \n \t\t\t\tif !filters.iter().any(|filter| indented_code.contains(filter)) {\n-\t\t\t\t\tblocks.push(indented_code);\n+\t\t\t\t\tblocks.push((std::mem::take(&mut current), indented_code));\n \t\t\t\t}\n+\t\t\t} else if let Some(header) = line.strip_prefix(\"#### \") {\n+\t\t\t\tcurrent = header.to_owned();\n \t\t\t}\n \t\t}\n \t\tblocks\ndiff --git a/parser/examples/code_blocks_to_script.rs b/parser/examples/code_blocks_to_script.rs\n--- a/parser/examples/code_blocks_to_script.rs\n+++ b/parser/examples/code_blocks_to_script.rs\n@@ -43,8 +54,26 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n \t\ttodo!(\"parse module, split by statement braced\")\n \t};\n \n+\tif let Some((under, extension)) = into_files_directory_and_extension {\n+\t\tlet under = PathBuf::from(under);\n+\t\tfor (header, code) in blocks {\n+\t\t\tlet mut name = heading_to_rust_identifier(&header);\n+\t\t\tname.push_str(\".\");\n+\t\t\tname.push_str(&extension);\n+\t\t\tlet mut file = std::fs::File::create(under.join(name))?;\n+\t\t\t// Fix for FLow\n+\t\t\tlet code =\n+\t\t\t\tif replace_satisfies_with_as { code.replace(\" satisfies \", \" as \") } else { code };\n+\t\t\tfor line in code.lines() {\n+\t\t\t\twriteln!(file, \"{}\", line.strip_prefix('\\t').unwrap_or(line))?;\n+\t\t\t}\n+\t\t}\n+\t\treturn Ok(());\n+\t}\n+\n+\t// Else bundle into one, bound in arrow functions to prevent namespace collision\n \tlet mut final_blocks: Vec<(HashSet<String>, String)> = Vec::new();\n-\tfor code in blocks {\n+\tfor (header, code) in blocks {\n \t\tlet module = Module::from_string(code.clone(), Default::default()).map_err(Box::new)?;\n \n \t\tlet mut names = HashSet::new();\ndiff --git a/parser/examples/code_blocks_to_script.rs b/parser/examples/code_blocks_to_script.rs\n--- a/parser/examples/code_blocks_to_script.rs\n+++ b/parser/examples/code_blocks_to_script.rs\n@@ -93,7 +122,9 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n \t\t\tfinal_blocks.iter_mut().find(|(uses, _)| uses.is_disjoint(&names))\n \t\t{\n \t\t\titems.extend(names.into_iter());\n-\t\t\tblock.push_str(\"\\n\");\n+\t\t\tblock.push_str(\"\\n// \");\n+\t\t\tblock.push_str(&header);\n+\t\t\tblock.push('\\n');\n \t\t\tblock.push_str(&code);\n \t\t} else {\n \t\t\tfinal_blocks.push((names, code));\ndiff --git a/parser/examples/code_blocks_to_script.rs b/parser/examples/code_blocks_to_script.rs\n--- a/parser/examples/code_blocks_to_script.rs\n+++ b/parser/examples/code_blocks_to_script.rs\n@@ -102,16 +133,16 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n \n \t// eprintln!(\"Generated {:?} blocks\", final_blocks.len());\n \n-\tif let Some(out) = out {\n-\t\tlet mut out = std::fs::File::create(out).expect(\"Cannot open file\");\n+\tif let Some(out) = out_file {\n+\t\tlet mut out = std::fs::File::create(out)?;\n \t\tfor (_items, block) in final_blocks {\n-\t\t\twriteln!(out, \"() => {{\\n{block}}};\\n\").unwrap();\n+\t\t\twriteln!(out, \"() => {{\\n{block}}};\\n\")?;\n \t\t}\n \t} else {\n \t\tlet mut out = std::io::stdout();\n \t\tfor (_items, block) in final_blocks {\n \t\t\t// eprintln!(\"block includes: {items:?}\\n{block}\\n---\");\n-\t\t\twriteln!(out, \"() => {{\\n{block}}};\\n\").unwrap();\n+\t\t\twriteln!(out, \"() => {{\\n{block}}};\\n\")?;\n \t\t}\n \t}\n \ndiff --git a/parser/examples/code_blocks_to_script.rs b/parser/examples/code_blocks_to_script.rs\n--- a/parser/examples/code_blocks_to_script.rs\n+++ b/parser/examples/code_blocks_to_script.rs\n@@ -137,3 +168,10 @@ impl<'a>\n \t\t}\n \t}\n }\n+\n+fn heading_to_rust_identifier(heading: &str) -> String {\n+\theading\n+\t\t.replace([' ', '-', '/', '&', '.', '+'], \"_\")\n+\t\t.replace(['*', '\\'', '`', '\"', '!', '(', ')', ','], \"\")\n+\t\t.to_lowercase()\n+}\ndiff --git a/src/ast_explorer.rs b/src/ast_explorer.rs\n--- a/src/ast_explorer.rs\n+++ b/src/ast_explorer.rs\n@@ -136,10 +136,13 @@ impl ExplorerSubCommand {\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\t// TODO temp\n-\t\t\t\t\tErr(err) => {\n-\t\t\t\t\t\temit_diagnostics(std::iter::once((err, source_id).into()), &fs, false)\n-\t\t\t\t\t\t\t.unwrap()\n-\t\t\t\t\t}\n+\t\t\t\t\tErr(err) => emit_diagnostics(\n+\t\t\t\t\t\tstd::iter::once((err, source_id).into()),\n+\t\t\t\t\t\t&fs,\n+\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\tcrate::utilities::MaxDiagnostics::All,\n+\t\t\t\t\t)\n+\t\t\t\t\t.unwrap(),\n \t\t\t\t}\n \t\t\t}\n \t\t\tExplorerSubCommand::FullAST(cfg) => {\ndiff --git a/src/ast_explorer.rs b/src/ast_explorer.rs\n--- a/src/ast_explorer.rs\n+++ b/src/ast_explorer.rs\n@@ -159,10 +162,13 @@ impl ExplorerSubCommand {\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\t// TODO temp\n-\t\t\t\t\tErr(err) => {\n-\t\t\t\t\t\temit_diagnostics(std::iter::once((err, source_id).into()), &fs, false)\n-\t\t\t\t\t\t\t.unwrap()\n-\t\t\t\t\t}\n+\t\t\t\t\tErr(err) => emit_diagnostics(\n+\t\t\t\t\t\tstd::iter::once((err, source_id).into()),\n+\t\t\t\t\t\t&fs,\n+\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\tcrate::utilities::MaxDiagnostics::All,\n+\t\t\t\t\t)\n+\t\t\t\t\t.unwrap(),\n \t\t\t\t}\n \t\t\t}\n \t\t\tExplorerSubCommand::Prettifier(_) | ExplorerSubCommand::Uglifier(_) => {\ndiff --git a/src/ast_explorer.rs b/src/ast_explorer.rs\n--- a/src/ast_explorer.rs\n+++ b/src/ast_explorer.rs\n@@ -179,10 +185,13 @@ impl ExplorerSubCommand {\n \t\t\t\t\t\t};\n \t\t\t\t\t\tprint_to_cli(format_args!(\"{}\", module.to_string(&options)));\n \t\t\t\t\t}\n-\t\t\t\t\tErr(err) => {\n-\t\t\t\t\t\temit_diagnostics(std::iter::once((err, source_id).into()), &fs, false)\n-\t\t\t\t\t\t\t.unwrap()\n-\t\t\t\t\t}\n+\t\t\t\t\tErr(err) => emit_diagnostics(\n+\t\t\t\t\t\tstd::iter::once((err, source_id).into()),\n+\t\t\t\t\t\t&fs,\n+\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\tcrate::utilities::MaxDiagnostics::All,\n+\t\t\t\t\t)\n+\t\t\t\t\t.unwrap(),\n \t\t\t\t}\n \t\t\t}\n \t\t\tExplorerSubCommand::Lexer(_) => {\ndiff --git a/src/build.rs b/src/build.rs\n--- a/src/build.rs\n+++ b/src/build.rs\n@@ -5,7 +5,7 @@ use std::{\n \n use checker::{DiagnosticsContainer, TypeCheckOptions};\n use parser::{\n-\tsource_map::{MapFileStore, WithPathMap},\n+\tsource_map::{MapFileStore, SourceMap, WithPathMap},\n \tToStringOptions,\n };\n \ndiff --git a/src/build.rs b/src/build.rs\n--- a/src/build.rs\n+++ b/src/build.rs\n@@ -13,7 +13,8 @@ use parser::{\n pub struct Output {\n \tpub output_path: PathBuf,\n \tpub content: String,\n-\tpub mappings: String,\n+\t#[cfg_attr(target_family = \"wasm\", serde(skip_serializing))]\n+\tpub mappings: SourceMap,\n }\n \n #[cfg_attr(target_family = \"wasm\", derive(serde::Serialize, tsify::Tsify))]\ndiff --git a/src/build.rs b/src/build.rs\n--- a/src/build.rs\n+++ b/src/build.rs\n@@ -39,6 +40,8 @@ pub struct FailedBuildOutput {\n pub struct BuildConfig {\n \t#[cfg_attr(target_family = \"wasm\", serde(default))]\n \tpub strip_whitespace: bool,\n+\t#[cfg_attr(target_family = \"wasm\", serde(default))]\n+\tpub source_maps: bool,\n }\n \n pub type EznoParsePostCheckVisitors =\ndiff --git a/src/build.rs b/src/build.rs\n--- a/src/build.rs\n+++ b/src/build.rs\n@@ -63,7 +66,7 @@ impl CheckingOutputWithoutDiagnostics {\n }\n \n pub fn build<T: crate::ReadFromFS>(\n-\tinput_paths: Vec<PathBuf>,\n+\tentry_points: Vec<PathBuf>,\n \tfs_resolver: &T,\n \ttype_definition_module: Option<&Path>,\n \toutput_path: &Path,\ndiff --git a/src/build.rs b/src/build.rs\n--- a/src/build.rs\n+++ b/src/build.rs\n@@ -73,7 +76,8 @@ pub fn build<T: crate::ReadFromFS>(\n \t// TODO parse options + non_standard_library & non_standard_syntax\n \tlet type_check_options = TypeCheckOptions { store_type_mappings: true, ..Default::default() };\n \n-\tlet result = crate::check(input_paths, fs_resolver, type_definition_module, type_check_options);\n+\tlet result =\n+\t\tcrate::check(entry_points, fs_resolver, type_definition_module, type_check_options);\n \n \tlet mut data = CheckingOutputWithoutDiagnostics {\n \t\tmodule_contents: result.module_contents,\ndiff --git a/src/build.rs b/src/build.rs\n--- a/src/build.rs\n+++ b/src/build.rs\n@@ -114,13 +118,15 @@ pub fn build<T: crate::ReadFromFS>(\n \t\t\t\tToStringOptions::default()\n \t\t\t};\n \n-\t\t\tlet content = parser::ASTNode::to_string(&module, &to_string_options);\n+\t\t\t// TODO under cfg\n+\n+\t\t\tlet (content, mappings) =\n+\t\t\t\tmodule.to_string_with_source_map(&to_string_options, source, &data.module_contents);\n \n \t\t\toutputs.push(Output {\n \t\t\t\toutput_path: output_path.to_path_buf(),\n \t\t\t\tcontent,\n-\t\t\t\t// TODO module.to_string_with_map\n-\t\t\t\tmappings: String::new(),\n+\t\t\t\tmappings: mappings.unwrap(),\n \t\t\t})\n \t\t}\n \ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -12,7 +12,7 @@ use crate::{\n \tbuild::{build, BuildConfig, BuildOutput, EznoParsePostCheckVisitors, FailedBuildOutput},\n \tcheck::check,\n \treporting::emit_diagnostics,\n-\tutilities::{self, print_to_cli},\n+\tutilities::{self, print_to_cli, MaxDiagnostics},\n };\n use argh::FromArgs;\n use checker::CheckOutput;\ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -62,14 +62,14 @@ pub(crate) enum ExperimentalSubcommand {\n \n // TODO definition file as list\n /// Build project\n-#[derive(FromArgs, PartialEq, Debug)]\n+#[derive(FromArgs, Debug)]\n #[argh(subcommand, name = \"build\")]\n // TODO: Can be refactored with bit to reduce memory\n #[allow(clippy::struct_excessive_bools)]\n pub(crate) struct BuildArguments {\n-\t/// path to input file\n+\t/// path to input file (accepts glob)\n \t#[argh(positional)]\n-\tpub input: PathBuf,\n+\tpub input: String,\n \t/// path to output\n \t#[argh(positional)]\n \tpub output: Option<PathBuf>,\ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -80,24 +80,18 @@ pub(crate) struct BuildArguments {\n \t/// whether to minify build output\n \t#[argh(switch, short = 'm')]\n \tpub minify: bool,\n-\t/// whether to include comments in the output\n-\t#[argh(switch)]\n-\tpub no_comments: bool,\n \t/// build source maps\n \t#[argh(switch)]\n \tpub source_maps: bool,\n \t/// compact diagnostics\n \t#[argh(switch)]\n \tpub compact_diagnostics: bool,\n-\t/// enable non standard syntax\n-\t#[argh(switch)]\n-\tpub non_standard_syntax: bool,\n-\t/// enable non standard library\n-\t#[argh(switch)]\n-\tpub non_standard_library: bool,\n-\t/// enable optimising transforms (warning can break code)\n+\t/// enable optimising transforms (warning can currently break code)\n \t#[argh(switch)]\n \tpub optimise: bool,\n+\t/// maximum diagnostics to print (defaults to 30, pass `all` for all and `0` to count)\n+\t#[argh(option, default = \"MaxDiagnostics::default()\")]\n+\tpub max_diagnostics: MaxDiagnostics,\n \n \t#[cfg(not(target_family = \"wasm\"))]\n \t/// whether to display compile times\ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -109,27 +103,27 @@ pub(crate) struct BuildArguments {\n }\n \n /// Type check project\n-#[derive(FromArgs, PartialEq, Debug)]\n+#[derive(FromArgs, Debug)]\n #[argh(subcommand, name = \"check\")]\n pub(crate) struct CheckArguments {\n-\t/// path to input file\n+\t/// path to input file (accepts glob)\n \t#[argh(positional)]\n-\tpub input: PathBuf,\n+\tpub input: String,\n \t/// paths to definition files\n \t#[argh(option, short = 'd')]\n \tpub definition_file: Option<PathBuf>,\n-\t/// whether to re-check on file changes\n+\t/// whether to re-check on file changes TODO #164\n \t#[argh(switch)]\n-\tpub watch: bool,\n+\tpub _watch: bool,\n \t/// whether to display check time\n \t#[argh(switch)]\n \tpub timings: bool,\n-\t/// whether to print all diagnostics\n-\t#[argh(switch)]\n-\tpub count_diagnostics: bool,\n \t/// compact diagnostics\n \t#[argh(switch)]\n \tpub compact_diagnostics: bool,\n+\t/// maximum diagnostics to print (defaults to 30, pass `all` for all and `0` to count)\n+\t#[argh(option, default = \"MaxDiagnostics::default()\")]\n+\tpub max_diagnostics: MaxDiagnostics,\n }\n \n /// Formats file in-place\ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -198,20 +192,24 @@ pub fn run_cli<T: crate::ReadFromFS, U: crate::WriteToFS, V: crate::CLIInputReso\n \t\tCompilerSubCommand::Check(check_arguments) => {\n \t\t\tlet CheckArguments {\n \t\t\t\tinput,\n-\t\t\t\twatch: _,\n+\t\t\t\t// TODO #164\n+\t\t\t\t_watch,\n \t\t\t\tdefinition_file,\n \t\t\t\ttimings,\n-\t\t\t\tcount_diagnostics,\n \t\t\t\tcompact_diagnostics,\n+\t\t\t\tmax_diagnostics,\n \t\t\t} = check_arguments;\n \n-\t\t\tlet entry_points = vec![input];\n-\n \t\t\t#[cfg(not(target_family = \"wasm\"))]\n \t\t\tlet start = timings.then(std::time::Instant::now);\n \n \t\t\tlet type_check_options = Default::default();\n \n+\t\t\tlet entry_points = match get_entry_points(input) {\n+\t\t\t\tOk(entry_points) => entry_points,\n+\t\t\t\tErr(_) => return ExitCode::FAILURE,\n+\t\t\t};\n+\n \t\t\tlet CheckOutput { diagnostics, module_contents, .. } =\n \t\t\t\tcheck(entry_points, read_file, definition_file.as_deref(), type_check_options);\n \ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -221,16 +219,28 @@ pub fn run_cli<T: crate::ReadFromFS, U: crate::WriteToFS, V: crate::CLIInputReso\n \t\t\t};\n \n \t\t\tif diagnostics.has_error() {\n-\t\t\t\tif count_diagnostics {\n+\t\t\t\tif let MaxDiagnostics::FixedTo(0) = max_diagnostics {\n \t\t\t\t\tlet count = diagnostics.into_iter().count();\n \t\t\t\t\tprint_to_cli(format_args!(\"Found {count} type errors and warnings \ud83d\ude2c\"))\n \t\t\t\t} else {\n-\t\t\t\t\temit_diagnostics(diagnostics, &module_contents, compact_diagnostics).unwrap();\n+\t\t\t\t\temit_diagnostics(\n+\t\t\t\t\t\tdiagnostics,\n+\t\t\t\t\t\t&module_contents,\n+\t\t\t\t\t\tcompact_diagnostics,\n+\t\t\t\t\t\tmax_diagnostics,\n+\t\t\t\t\t)\n+\t\t\t\t\t.unwrap();\n \t\t\t\t}\n \t\t\t\tExitCode::FAILURE\n \t\t\t} else {\n \t\t\t\t// May be warnings or information here\n-\t\t\t\temit_diagnostics(diagnostics, &module_contents, compact_diagnostics).unwrap();\n+\t\t\t\temit_diagnostics(\n+\t\t\t\t\tdiagnostics,\n+\t\t\t\t\t&module_contents,\n+\t\t\t\t\tcompact_diagnostics,\n+\t\t\t\t\tmax_diagnostics,\n+\t\t\t\t)\n+\t\t\t\t.unwrap();\n \t\t\t\tprint_to_cli(format_args!(\"No type errors found \ud83c\udf89\"));\n \t\t\t\tExitCode::SUCCESS\n \t\t\t}\ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -240,29 +250,43 @@ pub fn run_cli<T: crate::ReadFromFS, U: crate::WriteToFS, V: crate::CLIInputReso\n \t\t}) => {\n \t\t\tlet output_path = build_config.output.unwrap_or(\"ezno_output.js\".into());\n \n-\t\t\t// TODO\n-\t\t\tlet default_builders = EznoParsePostCheckVisitors {\n-\t\t\t\texpression_visitors_mut: vec![Box::new(\n-\t\t\t\t\tcrate::transformers::optimisations::ExpressionOptimiser,\n-\t\t\t\t)],\n-\t\t\t\tstatement_visitors_mut: vec![Box::new(\n-\t\t\t\t\tcrate::transformers::optimisations::StatementOptimiser,\n-\t\t\t\t)],\n-\t\t\t\tvariable_visitors_mut: Default::default(),\n-\t\t\t\tblock_visitors_mut: Default::default(),\n+\t\t\tlet mut default_builders = EznoParsePostCheckVisitors::default();\n+\n+\t\t\tif build_config.optimise {\n+\t\t\t\tdefault_builders\n+\t\t\t\t\t.expression_visitors_mut\n+\t\t\t\t\t.push(Box::new(crate::transformers::optimisations::ExpressionOptimiser));\n+\n+\t\t\t\tdefault_builders\n+\t\t\t\t\t.statement_visitors_mut\n+\t\t\t\t\t.push(Box::new(crate::transformers::optimisations::StatementOptimiser));\n+\t\t\t}\n+\n+\t\t\tlet entry_points = match get_entry_points(build_config.input) {\n+\t\t\t\tOk(entry_points) => entry_points,\n+\t\t\t\tErr(_) => return ExitCode::FAILURE,\n \t\t\t};\n \n-\t\t\tlet input_paths = vec![build_config.input];\n+\t\t\t#[cfg(not(target_family = \"wasm\"))]\n+\t\t\tlet start = build_config.timings.then(std::time::Instant::now);\n \n \t\t\tlet output = build(\n-\t\t\t\tinput_paths,\n+\t\t\t\tentry_points,\n \t\t\t\tread_file,\n \t\t\t\tbuild_config.definition_file.as_deref(),\n \t\t\t\t&output_path,\n-\t\t\t\t&BuildConfig { strip_whitespace: build_config.minify },\n+\t\t\t\t&BuildConfig {\n+\t\t\t\t\tstrip_whitespace: build_config.minify,\n+\t\t\t\t\tsource_maps: build_config.source_maps,\n+\t\t\t\t},\n \t\t\t\tSome(default_builders),\n \t\t\t);\n \n+\t\t\t#[cfg(not(target_family = \"wasm\"))]\n+\t\t\tif let Some(start) = start {\n+\t\t\t\teprintln!(\"Checked & built in {:?}\", start.elapsed());\n+\t\t\t};\n+\n \t\t\tlet compact_diagnostics = build_config.compact_diagnostics;\n \n \t\t\tmatch output {\ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -270,12 +294,24 @@ pub fn run_cli<T: crate::ReadFromFS, U: crate::WriteToFS, V: crate::CLIInputReso\n \t\t\t\t\tfor output in outputs {\n \t\t\t\t\t\twrite_file(output.output_path.as_path(), output.content);\n \t\t\t\t\t}\n-\t\t\t\t\temit_diagnostics(diagnostics, &fs, compact_diagnostics).unwrap();\n+\t\t\t\t\temit_diagnostics(\n+\t\t\t\t\t\tdiagnostics,\n+\t\t\t\t\t\t&fs,\n+\t\t\t\t\t\tcompact_diagnostics,\n+\t\t\t\t\t\tbuild_config.max_diagnostics,\n+\t\t\t\t\t)\n+\t\t\t\t\t.unwrap();\n \t\t\t\t\tprint_to_cli(format_args!(\"Project built successfully \ud83c\udf89\"));\n \t\t\t\t\tExitCode::SUCCESS\n \t\t\t\t}\n \t\t\t\tErr(FailedBuildOutput { fs, diagnostics }) => {\n-\t\t\t\t\temit_diagnostics(diagnostics, &fs, compact_diagnostics).unwrap();\n+\t\t\t\t\temit_diagnostics(\n+\t\t\t\t\t\tdiagnostics,\n+\t\t\t\t\t\t&fs,\n+\t\t\t\t\t\tcompact_diagnostics,\n+\t\t\t\t\t\tbuild_config.max_diagnostics,\n+\t\t\t\t\t)\n+\t\t\t\t\t.unwrap();\n \t\t\t\t\tExitCode::FAILURE\n \t\t\t\t}\n \t\t\t}\ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -301,15 +337,23 @@ pub fn run_cli<T: crate::ReadFromFS, U: crate::WriteToFS, V: crate::CLIInputReso\n \t\t\t);\n \t\t\tmatch res {\n \t\t\t\tOk(module) => {\n-\t\t\t\t\tlet options =\n-\t\t\t\t\t\tToStringOptions { trailing_semicolon: true, ..Default::default() };\n+\t\t\t\t\tlet options = ToStringOptions {\n+\t\t\t\t\t\ttrailing_semicolon: true,\n+\t\t\t\t\t\tinclude_type_annotations: true,\n+\t\t\t\t\t\t..Default::default()\n+\t\t\t\t\t};\n \t\t\t\t\tlet _ = fs::write(path.clone(), module.to_string(&options));\n \t\t\t\t\tprint_to_cli(format_args!(\"Formatted {} \ud83c\udf89\", path.display()));\n \t\t\t\t\tExitCode::SUCCESS\n \t\t\t\t}\n \t\t\t\tErr(err) => {\n-\t\t\t\t\temit_diagnostics(std::iter::once((err, source_id).into()), &files, false)\n-\t\t\t\t\t\t.unwrap();\n+\t\t\t\t\temit_diagnostics(\n+\t\t\t\t\t\tstd::iter::once((err, source_id).into()),\n+\t\t\t\t\t\t&files,\n+\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\tMaxDiagnostics::All,\n+\t\t\t\t\t)\n+\t\t\t\t\t.unwrap();\n \t\t\t\t\tExitCode::FAILURE\n \t\t\t\t}\n \t\t\t}\ndiff --git a/src/cli.rs b/src/cli.rs\n--- a/src/cli.rs\n+++ b/src/cli.rs\n@@ -371,3 +415,27 @@ pub fn run_cli<T: crate::ReadFromFS, U: crate::WriteToFS, V: crate::CLIInputReso\n \t\t  // }\n \t}\n }\n+\n+fn get_entry_points(input: String) -> Result<Vec<PathBuf>, ()> {\n+\tmatch glob::glob(&input) {\n+\t\tOk(files) => {\n+\t\t\tlet files = files\n+\t\t\t\t.into_iter()\n+\t\t\t\t.collect::<Result<Vec<PathBuf>, glob::GlobError>>()\n+\t\t\t\t.map_err(|err| {\n+\t\t\t\t\teprintln!(\"{err:?}\");\n+\t\t\t\t})?;\n+\n+\t\t\tif files.is_empty() {\n+\t\t\t\teprintln!(\"Input {input:?} matched no files\");\n+\t\t\t\tErr(())\n+\t\t\t} else {\n+\t\t\t\tOk(files)\n+\t\t\t}\n+\t\t}\n+\t\tErr(err) => {\n+\t\t\teprintln!(\"{err:?}\");\n+\t\t\tErr(())\n+\t\t}\n+\t}\n+}\ndiff --git a/src/repl.rs b/src/repl.rs\n--- a/src/repl.rs\n+++ b/src/repl.rs\n@@ -50,7 +50,8 @@ pub(crate) fn run_repl<U: crate::CLIInputResolver>(\n \tlet mut state = match state {\n \t\tOk(state) => state,\n \t\tErr((diagnostics, fs)) => {\n-\t\t\temit_diagnostics(diagnostics, &fs, false).unwrap();\n+\t\t\temit_diagnostics(diagnostics, &fs, false, crate::utilities::MaxDiagnostics::All)\n+\t\t\t\t.unwrap();\n \t\t\treturn;\n \t\t}\n \t};\ndiff --git a/src/repl.rs b/src/repl.rs\n--- a/src/repl.rs\n+++ b/src/repl.rs\n@@ -89,8 +90,13 @@ pub(crate) fn run_repl<U: crate::CLIInputResolver>(\n \t\tlet mut item = match result {\n \t\t\tOk(item) => item,\n \t\t\tErr(err) => {\n-\t\t\t\temit_diagnostics(std::iter::once((err, source).into()), state.get_fs_ref(), false)\n-\t\t\t\t\t.unwrap();\n+\t\t\t\temit_diagnostics(\n+\t\t\t\t\tstd::iter::once((err, source).into()),\n+\t\t\t\t\tstate.get_fs_ref(),\n+\t\t\t\t\tfalse,\n+\t\t\t\t\tcrate::utilities::MaxDiagnostics::All,\n+\t\t\t\t)\n+\t\t\t\t.unwrap();\n \t\t\t\tcontinue;\n \t\t\t}\n \t\t};\ndiff --git a/src/repl.rs b/src/repl.rs\n--- a/src/repl.rs\n+++ b/src/repl.rs\n@@ -111,13 +117,25 @@ pub(crate) fn run_repl<U: crate::CLIInputResolver>(\n \n \t\tmatch result {\n \t\t\tOk((last_ty, diagnostics)) => {\n-\t\t\t\temit_diagnostics(diagnostics, state.get_fs_ref(), false).unwrap();\n+\t\t\t\temit_diagnostics(\n+\t\t\t\t\tdiagnostics,\n+\t\t\t\t\tstate.get_fs_ref(),\n+\t\t\t\t\tfalse,\n+\t\t\t\t\tcrate::utilities::MaxDiagnostics::All,\n+\t\t\t\t)\n+\t\t\t\t.unwrap();\n \t\t\t\tif let Some(last_ty) = last_ty {\n \t\t\t\t\tprintln!(\"{last_ty}\");\n \t\t\t\t}\n \t\t\t}\n \t\t\tErr(diagnostics) => {\n-\t\t\t\temit_diagnostics(diagnostics, state.get_fs_ref(), false).unwrap();\n+\t\t\t\temit_diagnostics(\n+\t\t\t\t\tdiagnostics,\n+\t\t\t\t\tstate.get_fs_ref(),\n+\t\t\t\t\tfalse,\n+\t\t\t\t\tcrate::utilities::MaxDiagnostics::All,\n+\t\t\t\t)\n+\t\t\t\t.unwrap();\n \t\t\t}\n \t\t}\n \t}\ndiff --git a/src/reporting.rs b/src/reporting.rs\n--- a/src/reporting.rs\n+++ b/src/reporting.rs\n@@ -1,3 +1,5 @@\n+use std::io::Write;\n+\n use codespan_reporting::{\n \tdiagnostic::{Diagnostic, Label, Severity},\n \tterm::{\ndiff --git a/src/reporting.rs b/src/reporting.rs\n--- a/src/reporting.rs\n+++ b/src/reporting.rs\n@@ -9,6 +11,8 @@ use codespan_reporting::{\n \n use checker::source_map::{MapFileStore, PathMap, SourceId};\n \n+use crate::utilities::MaxDiagnostics;\n+\n fn ezno_diagnostic_to_severity(kind: &checker::DiagnosticKind) -> Severity {\n \tmatch kind {\n \t\tchecker::DiagnosticKind::Error => Severity::Error,\ndiff --git a/src/reporting.rs b/src/reporting.rs\n--- a/src/reporting.rs\n+++ b/src/reporting.rs\n@@ -76,11 +80,16 @@ fn checker_diagnostic_to_codespan_diagnostic(\n \t}\n }\n \n-pub(crate) fn emit_diagnostics<T: PathMap>(\n-\tdiagnostics: impl IntoIterator<Item = checker::Diagnostic>,\n+pub(crate) fn emit_diagnostics<T: PathMap, I>(\n+\tdiagnostics: I,\n \tfs: &MapFileStore<T>,\n \tcompact: bool,\n-) -> Result<(), codespan_reporting::files::Error> {\n+\tmaximum: MaxDiagnostics,\n+) -> Result<(), codespan_reporting::files::Error>\n+where\n+\tI: IntoIterator<Item = checker::Diagnostic>,\n+\tI::IntoIter: ExactSizeIterator,\n+{\n \t// TODO custom here\n \tlet config = Config {\n \t\tdisplay_style: if compact { DisplayStyle::Short } else { DisplayStyle::Rich },\ndiff --git a/src/reporting.rs b/src/reporting.rs\n--- a/src/reporting.rs\n+++ b/src/reporting.rs\n@@ -91,6 +100,13 @@ pub(crate) fn emit_diagnostics<T: PathMap>(\n \tlet mut writer = BufferedStandardStream::stderr(ColorChoice::Auto);\n \n \tlet files = fs.into_code_span_store();\n+\tlet diagnostics = diagnostics.into_iter();\n+\tlet count = diagnostics.len();\n+\tlet maximum = match maximum {\n+\t\tMaxDiagnostics::All => usize::MAX,\n+\t\tMaxDiagnostics::FixedTo(n) => n as usize,\n+\t};\n+\tlet diagnostics = diagnostics.into_iter().take(maximum);\n \n \tfor diagnostic in diagnostics {\n \t\tlet diagnostic = checker_diagnostic_to_codespan_diagnostic(diagnostic, compact);\ndiff --git a/src/reporting.rs b/src/reporting.rs\n--- a/src/reporting.rs\n+++ b/src/reporting.rs\n@@ -108,5 +124,15 @@ pub(crate) fn emit_diagnostics<T: PathMap>(\n \t\temit(&mut writer, &config, &files, &diagnostic)?;\n \t}\n \n+\tif count > maximum {\n+\t\t#[cfg(not(target_family = \"wasm\"))]\n+\t\twriter.flush().unwrap();\n+\n+\t\tcrate::utilities::print_to_cli(format_args!(\n+\t\t\t\"... and {difference} other errors and warnings\",\n+\t\t\tdifference = count - maximum\n+\t\t));\n+\t}\n+\n \tOk(())\n }\ndiff --git a/src/utilities.rs b/src/utilities.rs\n--- a/src/utilities.rs\n+++ b/src/utilities.rs\n@@ -26,16 +26,15 @@ pub(crate) fn print_info() {\n \t{\n \t\tconst SPONSORS_URL: &str = \"https://github.com/sponsors/kaleidawave\";\n \n-\t\tprint_to_cli(format_args!(\"With thanks to:\"));\n+\t\tprint_to_cli_with_break_after(format_args!(\n+\t\t\t\"With thanks to all supporters of the project including:\"\n+\t\t));\n \t\tprint_to_cli(format_args!(\n \t\t\t\"  Contributors (join them @ https://github.com/kaleidawave/ezno/issues):\"\n \t\t));\n \t\twrap_with_ident(contributors);\n \t\tprint_to_cli(format_args!(\"  Sponsors (join them @ {SPONSORS_URL}):\"));\n \t\twrap_with_ident(sponsors);\n-\t\tprint_to_cli_with_break_after(format_args!(\n-\t\t\t\"  and all the believers in me and the project \u2728\"\n-\t\t));\n \t}\n }\n \ndiff --git a/src/utilities.rs b/src/utilities.rs\n--- a/src/utilities.rs\n+++ b/src/utilities.rs\n@@ -46,12 +45,16 @@ fn wrap_with_ident(input: &str) {\n \tfor part in input.split(',') {\n \t\tbuf.push_str(part);\n \t\tbuf.push_str(\", \");\n-\t\tif buf.len() > 30 {\n+\t\tif buf.len() > 40 {\n \t\t\tprint_to_cli(format_args!(\"{INDENT}{buf}\"));\n \t\t\tbuf.clear();\n \t\t}\n \t}\n-\tprint_to_cli_with_break_after(format_args!(\"{INDENT}{buf}\"));\n+\tif !buf.is_empty() {\n+\t\tprint_to_cli_with_break_after(format_args!(\"{INDENT}{buf}\"));\n+\t} else {\n+\t\tprint_to_cli(format_args!(\"\\n\"))\n+\t}\n }\n \n /// Adds and extra new line afterwards\ndiff --git a/src/utilities.rs b/src/utilities.rs\n--- a/src/utilities.rs\n+++ b/src/utilities.rs\n@@ -86,6 +89,31 @@ pub(crate) fn print_to_cli_without_newline(arguments: Arguments) {\n \tio::Write::flush(&mut io::stdout()).unwrap();\n }\n \n+#[derive(Debug)]\n+pub(crate) enum MaxDiagnostics {\n+\tAll,\n+\tFixedTo(u16),\n+}\n+\n+impl argh::FromArgValue for MaxDiagnostics {\n+\tfn from_arg_value(value: &str) -> Result<Self, String> {\n+\t\tif value == \"all\" {\n+\t\t\tOk(Self::All)\n+\t\t} else {\n+\t\t\tmatch std::str::FromStr::from_str(value) {\n+\t\t\t\tOk(value) => Ok(Self::FixedTo(value)),\n+\t\t\t\tErr(reason) => Err(reason.to_string()),\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+impl Default for MaxDiagnostics {\n+\tfn default() -> Self {\n+\t\tSelf::FixedTo(30)\n+\t}\n+}\n+\n // yes i implemented it only using `native_tls`...\n // TODO or(..., debug_assertions)\n #[cfg(not(target_family = \"wasm\"))]\ndiff --git a/src/wasm_bindings.rs b/src/wasm_bindings.rs\n--- a/src/wasm_bindings.rs\n+++ b/src/wasm_bindings.rs\n@@ -37,7 +37,7 @@ pub fn experimental_build_wasm(\n \t\t&fs_resolver,\n \t\tNone,\n \t\tPath::new(\"out.js\"),\n-\t\t&crate::build::BuildConfig { strip_whitespace: minify },\n+\t\t&crate::build::BuildConfig { strip_whitespace: minify, source_maps: false },\n \t\tNone,\n \t);\n \n",
        "test_patch": "diff --git a/src/js-cli-and-library/README.md b/src/js-cli-and-library/README.md\n--- a/src/js-cli-and-library/README.md\n+++ b/src/js-cli-and-library/README.md\n@@ -17,25 +17,30 @@ deno run -A dist/cli.mjs info\n For a environment that supports `node:fs`, you can use a version that initializes the WASM for you\n \n ```js\n-import { build } from \"ezno/initialised\";\n-\n-// Just use a local string. Could use readFileSync for FS access\n-const fs_handler = (_path) => \"const x = !t ? 4 : 5;\";\n-console.dir(build(\"input.js\", fs_handler), { depth: 5 })\n+import { check } from 'ezno/initialised';\n+const fs_handler = (_path) => \"const x: string = t ? 4 : 5;\";\n+const output = check(\"input.ts\", fs_handler);\n+console.dir(output.diagnostics, { depth: 5 });\n ```\n \n For the web, `init()` is needed to load the WASM before calling any functions.\n \n ```js\n-import { init, build } from \"ezno\";\n+import { check, init } from 'ezno';\n \n await init();\n \n-const res = build(\"input.js\", () => \"const x = 2 + 5;\");\n-\n-document.querySelector('#app').innerHTML = `<pre>${JSON.stringify(res)}</pre>`;\n+const fs_handler = (_path) => \"const x: string = t ? 4 : 5;\";\n+const output = check(\"input.ts\", fs_handler);\n+console.dir(output.diagnostics, { depth: 5 });\n ```\n \n+See more usage in the [./test.mjs](./test.mjs) and in the [playground](../playground/main.js).\n+\n+You can see the Rust definitions of these exports under [../../src/wasm_bindings.rs](../../src/wasm_bindings.rs). Thanks to [#114](https://github.com/kaleidawave/ezno/pull/114) all these exports have associated type definitions.\n+\n+There also exists more functions such as `check_with_options` which takes an additional `TypeCheckOptions`. For parsing string to AST there is `parse_expression` & `parse_module`. If you find something implemented in Rust, but not exposed to the JS or WASM context: [feel to make a request issue for it to be exposed via the JS API](https://github.com/kaleidawave/ezno/issues/new).\n+\n ## Commands for building this package\n \n Run this **from this folder, not the root**:\n",
        "problem_statement": "Simple example of typechecking from code?\nDo you have an example of how I could run type checking on a string or file of typescript from within code?\r\n\r\nI tried \r\n```ts\r\nimport {check} from 'ezno/initialised'\r\nconst fs_handler = (_path) => \"const x = !t ? 4 : 5;\";\r\nconsole.dir(check(\"input.js\", fs_handler), { depth: 5 })\r\n```\r\n\r\nIt ran, but didn't seem to produce the desired output. I've been looking for awhile so figure i'd just ask.\n",
        "hints_text": "",
        "created_at": "2024-06-03T13:59:27Z",
        "version": "0.0"
    },
    {
        "repo": "kaleidawave/ezno",
        "pull_number": 23,
        "instance_id": "kaleidawave__ezno-23",
        "issue_numbers": [
            "10"
        ],
        "base_commit": "422a3591c9b577efd00843fba9036b3a90a678b7",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -110,6 +110,16 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"ctor\"\n+version = \"0.1.26\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6d2301688392eb071b0bf1a37be05c469d3cc4dbbd95df672fe28ab021e6a096\"\n+dependencies = [\n+ \"quote\",\n+ \"syn 1.0.109\",\n+]\n+\n [[package]]\n name = \"derive-debug-extras\"\n version = \"0.2.2\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -159,6 +169,12 @@ dependencies = [\n  \"syn-helpers\",\n ]\n \n+[[package]]\n+name = \"diff\"\n+version = \"0.1.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"56254986775e3233ffa9c4d7d3faaf6d36a2c09d30b20687e9f88bc8bafc16c8\"\n+\n [[package]]\n name = \"either\"\n version = \"1.8.1\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -285,6 +301,7 @@ dependencies = [\n  \"ezno-parser-visitable-derive 0.0.1\",\n  \"iterator-endiate 0.1.0\",\n  \"match_deref\",\n+ \"pretty_assertions\",\n  \"self-rust-tokenize\",\n  \"source-map\",\n  \"temporary-annex\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -608,6 +625,15 @@ dependencies = [\n  \"num-traits\",\n ]\n \n+[[package]]\n+name = \"output_vt100\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"628223faebab4e3e40667ee0b2336d34a5b960ff60ea743ddfdbcf7770bcfb66\"\n+dependencies = [\n+ \"winapi 0.3.9\",\n+]\n+\n [[package]]\n name = \"path-absolutize\"\n version = \"3.1.0\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -626,6 +652,18 @@ dependencies = [\n  \"once_cell\",\n ]\n \n+[[package]]\n+name = \"pretty_assertions\"\n+version = \"1.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a25e9bcb20aa780fd0bb16b72403a9064d6b3f22f026946029acb941a50af755\"\n+dependencies = [\n+ \"ctor\",\n+ \"diff\",\n+ \"output_vt100\",\n+ \"yansi\",\n+]\n+\n [[package]]\n name = \"proc-macro2\"\n version = \"1.0.52\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1045,3 +1083,9 @@ dependencies = [\n  \"winapi 0.2.8\",\n  \"winapi-build\",\n ]\n+\n+[[package]]\n+name = \"yansi\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"09041cd90cf85f7f8b2df60c646f853b7f535ce68f85244eb6731cf89fa498ec\"\ndiff --git a/parser/Cargo.toml b/parser/Cargo.toml\n--- a/parser/Cargo.toml\n+++ b/parser/Cargo.toml\n@@ -53,3 +53,4 @@ tokenizer-lib = { version = \"1.5.0\", features = [\n \n [dev-dependencies]\n match_deref = \"0.1.1\"\n+pretty_assertions = \"1.3.0\"\ndiff --git a/parser/src/errors.rs b/parser/src/errors.rs\n--- a/parser/src/errors.rs\n+++ b/parser/src/errors.rs\n@@ -19,6 +19,7 @@ pub enum ParseErrors<'a> {\n \tParameterCannotHaveDefaultValueHere,\n \tInvalidLHSAssignment,\n \tLexingFailed,\n+\tExpectedCatchOrFinally,\n }\n \n #[allow(missing_docs)]\ndiff --git a/parser/src/errors.rs b/parser/src/errors.rs\n--- a/parser/src/errors.rs\n+++ b/parser/src/errors.rs\n@@ -132,6 +133,9 @@ impl<'a> Display for ParseErrors<'a> {\n \t\t\t\tf.write_str(\"Function parameter cannot be have default value here\")\n \t\t\t}\n \t\t\tParseErrors::InvalidLHSAssignment => f.write_str(\"Invalid syntax on LHS of assignment\"),\n+\t\t\tParseErrors::ExpectedCatchOrFinally => {\n+\t\t\t\tf.write_str(\"Expected 'catch' or 'finally' to follow 'try'\")\n+\t\t\t}\n \t\t\tParseErrors::LexingFailed => {\n \t\t\t\t// unreachable!(\"This should never be written\"),\n \t\t\t\tf.write_str(\"Lexing issue\")\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -22,6 +22,7 @@ use crate::errors::parse_lexing_error;\n pub use for_statement::{ForLoopCondition, ForLoopStatement, ForLoopStatementInitializer};\n pub use if_statement::*;\n pub use switch_statement::{SwitchBranch, SwitchStatement};\n+pub use try_catch_statement::TryCatchStatement;\n use visitable_derive::Visitable;\n pub use while_statement::{DoWhileStatement, WhileStatement};\n \ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -43,6 +44,7 @@ pub enum Statement {\n \tSwitchStatement(SwitchStatement),\n \tWhileStatement(WhileStatement),\n \tDoWhileStatement(DoWhileStatement),\n+\tTryCatchStatement(TryCatchStatement),\n \t// Control flow\n \tReturn(Keyword<tsx_keywords::Return>, Option<MultipleExpression>),\n \t// TODO maybe an actual label struct:\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -91,6 +93,7 @@ impl ASTNode for Statement {\n \t\t\tStatement::SwitchStatement(ss) => ss.get_position(),\n \t\t\tStatement::WhileStatement(ws) => ws.get_position(),\n \t\t\tStatement::DoWhileStatement(dws) => dws.get_position(),\n+\t\t\tStatement::TryCatchStatement(tcs) => tcs.get_position(),\n \t\t\tStatement::Block(blk) => blk.get_position(),\n \t\t}\n \t}\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -144,7 +147,7 @@ impl ASTNode for Statement {\n \t\t\t\tDoWhileStatement::from_reader(reader, state, settings).map(Into::into)\n \t\t\t}\n \t\t\tTSXToken::Keyword(TSXKeyword::Try) => {\n-\t\t\t\ttodo!()\n+\t\t\t\tTryCatchStatement::from_reader(reader, state, settings).map(Into::into)\n \t\t\t}\n \t\t\tTSXToken::OpenBrace => {\n \t\t\t\tBlock::from_reader(reader, state, settings).map(Statement::Block)\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -240,6 +243,7 @@ impl ASTNode for Statement {\n \t\t\tStatement::SwitchStatement(ss) => ss.to_string_from_buffer(buf, settings, depth),\n \t\t\tStatement::WhileStatement(ws) => ws.to_string_from_buffer(buf, settings, depth),\n \t\t\tStatement::DoWhileStatement(dws) => dws.to_string_from_buffer(buf, settings, depth),\n+\t\t\tStatement::TryCatchStatement(tcs) => tcs.to_string_from_buffer(buf, settings, depth),\n \t\t\tStatement::Comment(comment, _) => {\n \t\t\t\tif settings.should_add_comment() {\n \t\t\t\t\tbuf.push_str(\"//\");\ndiff --git a/parser/src/statements/try_catch_statement.rs b/parser/src/statements/try_catch_statement.rs\n--- a/parser/src/statements/try_catch_statement.rs\n+++ b/parser/src/statements/try_catch_statement.rs\n@@ -1,1 +1,127 @@\n+use std::borrow::Cow;\n \n+use crate::{\n+\tASTNode, Block, ParseError, ParseErrors, TSXKeyword, TSXToken, TypeReference, VariableField,\n+\tVariableFieldInSourceCode, WithComment,\n+};\n+use source_map::Span;\n+use tokenizer_lib::Token;\n+use visitable_derive::Visitable;\n+\n+pub type ExceptionVarField = WithComment<VariableField<VariableFieldInSourceCode>>;\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Visitable)]\n+#[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n+pub struct TryCatchStatement {\n+\ttry_inner: Block,\n+\tcatch_inner: Option<Block>,\n+\texception_var: Option<(ExceptionVarField, Option<TypeReference>)>,\n+\tfinally_inner: Option<Block>,\n+\tposition: Span,\n+}\n+\n+impl ASTNode for TryCatchStatement {\n+\tfn get_position(&self) -> Cow<Span> {\n+\t\tCow::Borrowed(&self.position)\n+\t}\n+\n+\tfn from_reader(\n+\t\treader: &mut impl tokenizer_lib::TokenReader<TSXToken, Span>,\n+\t\tstate: &mut crate::ParsingState,\n+\t\tsettings: &crate::ParseSettings,\n+\t) -> Result<Self, crate::ParseError> {\n+\t\tlet start_span = reader.expect_next(TSXToken::Keyword(TSXKeyword::Try))?;\n+\t\tlet try_inner = Block::from_reader(reader, state, settings)?;\n+\n+\t\tlet mut catch_inner: Option<Block> = None;\n+\t\tlet mut exception_var: Option<(ExceptionVarField, Option<TypeReference>)> = None;\n+\n+\t\t// Optional `catch` clause\n+\t\tif let Some(Token(TSXToken::Keyword(TSXKeyword::Catch), _)) = reader.peek() {\n+\t\t\treader.expect_next(TSXToken::Keyword(TSXKeyword::Catch))?;\n+\n+\t\t\t// Optional exception variable field `catch (e)`\n+\t\t\tif let Some(Token(TSXToken::OpenParentheses, _)) = reader.peek() {\n+\t\t\t\treader.expect_next(TSXToken::OpenParentheses)?;\n+\t\t\t\tlet variable_field =\n+\t\t\t\t\tWithComment::<VariableField<VariableFieldInSourceCode>>::from_reader(\n+\t\t\t\t\t\treader, state, settings,\n+\t\t\t\t\t)?;\n+\n+\t\t\t\t// Optional type reference `catch (e: type)`\n+\t\t\t\tlet mut exception_var_type: Option<TypeReference> = None;\n+\t\t\t\tif let Some(Token(TSXToken::Colon, _)) = reader.peek() {\n+\t\t\t\t\treader.expect_next(TSXToken::Colon)?;\n+\t\t\t\t\texception_var_type = Some(TypeReference::from_reader(reader, state, settings)?);\n+\t\t\t\t}\n+\t\t\t\texception_var = Some((variable_field, exception_var_type));\n+\n+\t\t\t\treader.expect_next(TSXToken::CloseParentheses)?;\n+\t\t\t}\n+\n+\t\t\tcatch_inner = Some(Block::from_reader(reader, state, settings)?);\n+\t\t}\n+\n+\t\t// Optional `finally` clause\n+\t\tlet mut finally_inner: Option<Block> = None;\n+\t\tif let Some(Token(TSXToken::Keyword(TSXKeyword::Finally), _)) = reader.peek() {\n+\t\t\treader.expect_next(TSXToken::Keyword(TSXKeyword::Finally))?;\n+\t\t\tfinally_inner = Some(Block::from_reader(reader, state, settings)?);\n+\t\t}\n+\n+\t\t// Determine span based on which clauses are present\n+\t\tlet position: Span = if let Some(finally_block) = &finally_inner {\n+\t\t\tstart_span.union(&finally_block.get_position())\n+\t\t} else if let Some(catch_block) = &catch_inner {\n+\t\t\tstart_span.union(&catch_block.get_position())\n+\t\t} else {\n+\t\t\t// Parse error if neither catch nor finally clause is present\n+\t\t\treturn Err(ParseError::new(ParseErrors::ExpectedCatchOrFinally, start_span));\n+\t\t};\n+\n+\t\tOk(Self { position, try_inner, exception_var, catch_inner, finally_inner })\n+\t}\n+\n+\tfn to_string_from_buffer<T: source_map::ToString>(\n+\t\t&self,\n+\t\tbuf: &mut T,\n+\t\tsettings: &crate::ToStringSettings,\n+\t\tdepth: u8,\n+\t) {\n+\t\t// Required `try` block\n+\t\tbuf.push_str(\"try\");\n+\t\tsettings.add_gap(buf);\n+\t\tself.try_inner.to_string_from_buffer(buf, settings, depth + 1);\n+\n+\t\t// Optional `catch` block\n+\t\tif let Some(catch) = &self.catch_inner {\n+\t\t\tsettings.add_gap(buf);\n+\t\t\tbuf.push_str(\"catch\");\n+\t\t\tsettings.add_gap(buf);\n+\n+\t\t\t// Optional exception variable: `catch (e)`\n+\t\t\tif let Some((exception_var, exception_var_type)) = &self.exception_var {\n+\t\t\t\tbuf.push('(');\n+\t\t\t\texception_var.to_string_from_buffer(buf, settings, depth);\n+\n+\t\t\t\t// Optional type annotation: `catch (e: any)`\n+\t\t\t\tif let Some(exception_var_type) = exception_var_type {\n+\t\t\t\t\tbuf.push_str(\": \");\n+\t\t\t\t\texception_var_type.to_string_from_buffer(buf, settings, depth);\n+\t\t\t\t}\n+\t\t\t\tbuf.push(')');\n+\t\t\t\tsettings.add_gap(buf);\n+\t\t\t}\n+\n+\t\t\tcatch.to_string_from_buffer(buf, settings, depth + 1);\n+\t\t}\n+\n+\t\t// Optional `finally` block\n+\t\tif let Some(finally) = &self.finally_inner {\n+\t\t\tsettings.add_gap(buf);\n+\t\t\tbuf.push_str(\"finally\");\n+\t\t\tsettings.add_gap(buf);\n+\t\t\tfinally.to_string_from_buffer(buf, settings, depth + 1);\n+\t\t}\n+\t}\n+}\n",
        "test_patch": "diff --git a/parser/tests/statements.rs b/parser/tests/statements.rs\n--- a/parser/tests/statements.rs\n+++ b/parser/tests/statements.rs\n@@ -21,6 +21,11 @@ for (let i = 0; i < 4; i++) {\n     while (true) {\n         break\n     }\n+}\n+try {\n+    doThing()\n+} catch (e) {\n+    console.error(e)\n }\"#\n \t.trim_start();\n \ndiff --git /dev/null b/parser/tests/try_catch.rs\nnew file mode 100644\n--- /dev/null\n+++ b/parser/tests/try_catch.rs\n@@ -0,0 +1,68 @@\n+use ezno_parser::{ASTNode, Module, SourceId};\n+use pretty_assertions::assert_eq;\n+\n+#[test]\n+fn try_catch() {\n+\tlet input = r#\"\n+try {\n+    console.log(\"ordinary usage\")\n+} catch (e) {\n+    console.error(e)\n+}\n+try {\n+    console.log(\"no exception var\")\n+} catch {\n+    console.error(\"error\")\n+}\n+try {\n+    console.log(\"destructured catch\")\n+} catch ({ message }) {\n+    console.error(message)\n+}\n+try {\n+    console.log(\"catch with type annotation\")\n+} catch (error: unknown) {\n+    console.error(error)\n+}\n+try {\n+    console.log(\"finally clause\")\n+} catch (e) {\n+    console.error(e)\n+} finally {\n+    console.log(\"done\")\n+}\n+try {\n+    console.log(\"omitted catch clause\")\n+} finally {\n+    console.log(\"done\")\n+}\n+try {\n+    console.log(\"nesting\");\n+    try {\n+        doThing()\n+    } catch (e) {\n+        console.error(e)\n+    }\n+} catch (e) {\n+    try {\n+        doThing()\n+    } catch (e) {\n+        console.error(e)\n+    }\n+} finally {\n+    try {\n+        doThing()\n+    } catch (e) {\n+        console.error(e)\n+    }\n+}\"#\n+\t.trim_start();\n+\n+\tlet module =\n+\t\tModule::from_string(input.to_owned(), Default::default(), SourceId::NULL, None, Vec::new())\n+\t\t\t.unwrap();\n+\n+\tlet output = module.to_string(&Default::default());\n+\n+\tassert_eq!(output, input);\n+}\n",
        "problem_statement": "Try catch AST\nSomehow along the way have missed out parsing try catch (finally) statements: https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/try...catch\r\n\r\nhttps://github.com/kaleidawave/ezno/blob/d311155bcb4277843551bbf6b7421454c023c149/parser/src/statements/mod.rs#L146-L148\r\n\r\nThis should be very similar logic to statements like `if` and `while`, **however the spec says that statements have to be `Block`s and not allow single statements**.\r\n\r\nThe [while statement code](https://github.com/kaleidawave/ezno/blob/main/parser/src/statements/while_statement.rs) is a good reference for how it should be implemented. Can copy that and then adjust for the keywords and such. Then just need to import that back into `statements/mod.rs`, create a similar variant and hook it up to it's parse, position and `to_string` implementation.\r\n\r\nIf anyone wants to tackle this and needs more information/help, let me know \ud83d\udc4d \n",
        "hints_text": "",
        "created_at": "2023-06-08T22:02:15Z",
        "version": "0.0"
    },
    {
        "repo": "kaleidawave/ezno",
        "pull_number": 186,
        "instance_id": "kaleidawave__ezno-186",
        "issue_numbers": [
            "92"
        ],
        "base_commit": "c952b6d3f507d30c57ffd200a21cddbf18364300",
        "patch": "diff --git a/.github/workflows/performance-and-size.yml b/.github/workflows/performance-and-size.yml\n--- a/.github/workflows/performance-and-size.yml\n+++ b/.github/workflows/performance-and-size.yml\n@@ -93,6 +93,7 @@ jobs:\n           cargo run -p ezno-parser --example code_blocks_to_script all.md --comment-headers --out ./all.tsx\n \n           ./target/release/ezno check all.tsx --timings || true\n+          hyperfine -i './target/release/ezno check all.tsx'\n           echo \"::endgroup::\"\n             \n       - name: Run checker performance on large file\ndiff --git a/.github/workflows/performance-and-size.yml b/.github/workflows/performance-and-size.yml\n--- a/.github/workflows/performance-and-size.yml\n+++ b/.github/workflows/performance-and-size.yml\n@@ -108,6 +109,7 @@ jobs:\n           done\n \n           ./target/release/ezno check large.tsx --timings --max-diagnostics 0 || true\n+           hyperfine -i './target/release/ezno check large.tsx'\n           echo \"::endgroup::\"\n \n       - name: Run parsing & stringing (minfied) benchmarks\ndiff --git a/checker/definitions/overrides.d.ts b/checker/definitions/overrides.d.ts\n--- a/checker/definitions/overrides.d.ts\n+++ b/checker/definitions/overrides.d.ts\n@@ -77,7 +77,8 @@ declare class Array<T> {\n         let i: number = 0;\n         while (i < length) {\n             const value = this[i];\n-            if (!cb(value, i++)) {\n+            const result = cb(value, i++) as boolean;\n+            if (!result) {\n                 return false\n             }\n         }\ndiff --git a/checker/definitions/overrides.d.ts b/checker/definitions/overrides.d.ts\n--- a/checker/definitions/overrides.d.ts\n+++ b/checker/definitions/overrides.d.ts\n@@ -103,10 +104,10 @@ declare class Array<T> {\n         if (length === 0) {\n             return \"\"\n         }\n-        let s: string = \"\" + this[0];\n+        let s: string = \"\" + (this[0] as string);\n         while (i < length) {\n             s += joiner;\n-            s += this[i++];\n+            s += this[i++] as string;\n         }\n         return s\n     }\ndiff --git a/checker/definitions/overrides.d.ts b/checker/definitions/overrides.d.ts\n--- a/checker/definitions/overrides.d.ts\n+++ b/checker/definitions/overrides.d.ts\n@@ -118,10 +119,18 @@ declare class Array<T> {\n             return this[index]\n         }\n     }\n+\n+    static isArray(item: any) {\n+        return item instanceof Array;\n+    }\n }\n \n type Record<K extends string, T> = { [P in K]: T }\n \n+type LessThan<T extends number> = ExclusiveRange<NegativeInfinity, T>;\n+type GreaterThan<T extends number> = ExclusiveRange<T, Infinity>;\n+type Integer = MultipleOf<1>;\n+\n declare class Map<T, U> {\n     #keys: Array<T> = [];\n     #value: Array<T> = [];\ndiff --git a/checker/definitions/overrides.d.ts b/checker/definitions/overrides.d.ts\n--- a/checker/definitions/overrides.d.ts\n+++ b/checker/definitions/overrides.d.ts\n@@ -129,9 +138,9 @@ declare class Map<T, U> {\n \n declare class Math {\n     @Constant\n-    static sin(x: number): number;\n+    static sin(x: number): InclusiveRange<-1, 1>;\n     @Constant\n-    static cos(x: number): number;\n+    static cos(x: number): InclusiveRange<-1, 1>;\n     @Constant\n     static tan(x: number): number;\n     @Constant\ndiff --git a/checker/definitions/overrides.d.ts b/checker/definitions/overrides.d.ts\n--- a/checker/definitions/overrides.d.ts\n+++ b/checker/definitions/overrides.d.ts\n@@ -147,11 +156,14 @@ declare class Math {\n     @Constant\n     static trunc(x: number): number;\n \n+    @Constant\n+    static imul(x: number, y: number): number;\n+\n     static PI: 3.141592653589793\n     static E: 2.718281828459045\n \n     @InputOutput\n-    static random(): number;\n+    static random(): InclusiveRange<0, 1>;\n }\n \n @Primitive(\"string\")\ndiff --git a/checker/definitions/overrides.d.ts b/checker/definitions/overrides.d.ts\n--- a/checker/definitions/overrides.d.ts\n+++ b/checker/definitions/overrides.d.ts\n@@ -172,6 +184,20 @@ declare class String {\n     split(splitter: string): Array<string>;\n }\n \n+@Primitive(\"number\")\n+declare class Number {\n+    static NEGATIVE_INFINITY: NegativeInfinity;\n+    static POSITIVE_INFINITY: Infinity;\n+\n+    // static isFinite(item: any) {\n+    //     return !(item === Number.NEGATIVE_INFINITY || item === Number.POSITIVE_INFINITY || Number.isNaN(item))\n+    // }\n+\n+    static isNaN(item: any) {\n+        return item !== item;\n+    }\n+}\n+\n declare class Promise<T> { }\n \n declare class RegExp {\ndiff --git a/checker/definitions/overrides.d.ts b/checker/definitions/overrides.d.ts\n--- a/checker/definitions/overrides.d.ts\n+++ b/checker/definitions/overrides.d.ts\n@@ -377,7 +403,7 @@ declare class Object {\n         return entries\n     }\n \n-    // TODO multiple arguments\n+    // TODO spread source\n     static assign(target: object, source: object): object {\n         for (const key in source) {\n             target[key] = source[key]\ndiff --git a/checker/definitions/simple.d.ts b/checker/definitions/simple.d.ts\n--- a/checker/definitions/simple.d.ts\n+++ b/checker/definitions/simple.d.ts\n@@ -37,7 +37,7 @@ declare function debug_state(): void\n \n // A function, as it should be!\n @Constant\n-declare function satisfies<T>(t: T): T\n+declare function satisfies<YE>(t: YE): YE\n \n interface ImportEnv {\n     [key: string]: string;\ndiff --git a/checker/definitions/simple.d.ts b/checker/definitions/simple.d.ts\n--- a/checker/definitions/simple.d.ts\n+++ b/checker/definitions/simple.d.ts\n@@ -75,7 +75,7 @@ declare class Array<T> {\n     map<U>(cb: (t: T, i?: number) => U): Array<U> {\n         const { length } = this, mapped: Array<U> = [];\n         let i: number = 0;\n-        while (i < length) {\n+        while (i < (length as number)) {\n             const value = this[i];\n             const newValue = cb(value, i++);\n             mapped.push(newValue)\ndiff --git a/checker/definitions/simple.d.ts b/checker/definitions/simple.d.ts\n--- a/checker/definitions/simple.d.ts\n+++ b/checker/definitions/simple.d.ts\n@@ -176,6 +176,11 @@ declare class Array<T> {\n     //         return this[index]\n     //     }\n     // }\n+\n+    /// TODO incorrect definition, doesn't account for realms\n+    static isArray(item: any) {\n+        return item instanceof Array;\n+    }\n }\n \n declare class Map<K, V> {\ndiff --git a/checker/definitions/simple.d.ts b/checker/definitions/simple.d.ts\n--- a/checker/definitions/simple.d.ts\n+++ b/checker/definitions/simple.d.ts\n@@ -206,6 +211,10 @@ declare class Map<K, V> {\n \n type Record<K extends string, T> = { [P in K]: T }\n \n+type LessThan<T extends number> = ExclusiveRange<NegativeInfinity, T>;\n+type GreaterThan<T extends number> = ExclusiveRange<T, Infinity>;\n+type Integer = MultipleOf<1>;\n+\n /**\n  * Exclude from T those types that are assignable to U\n  */\ndiff --git a/checker/definitions/simple.d.ts b/checker/definitions/simple.d.ts\n--- a/checker/definitions/simple.d.ts\n+++ b/checker/definitions/simple.d.ts\n@@ -218,9 +227,9 @@ type Extract<T, U> = T extends U ? T : never;\n \n declare class Math {\n     @Constant\n-    static sin(x: number): number;\n+    static sin(x: number): InclusiveRange<-1, 1>;\n     @Constant\n-    static cos(x: number): number;\n+    static cos(x: number): InclusiveRange<-1, 1>;\n     @Constant\n     static tan(x: number): number;\n     @Constant\ndiff --git a/checker/definitions/simple.d.ts b/checker/definitions/simple.d.ts\n--- a/checker/definitions/simple.d.ts\n+++ b/checker/definitions/simple.d.ts\n@@ -232,15 +241,18 @@ declare class Math {\n     @Constant\n     static log(x: number): number;\n \n-    // TODO newer method\n+    // TODO newer methods\n     @Constant\n     static trunc(x: number): number;\n \n+    @Constant\n+    static imul(x: number, y: number): number;\n+\n     static PI: 3.141592653589793\n     static E: 2.718281828459045\n \n     @InputOutput\n-    static random(): number;\n+    static random(): 0 | InclusiveRange<0, 1>;\n }\n \n @Primitive(\"string\")\ndiff --git a/checker/definitions/simple.d.ts b/checker/definitions/simple.d.ts\n--- a/checker/definitions/simple.d.ts\n+++ b/checker/definitions/simple.d.ts\n@@ -261,6 +273,20 @@ declare class String {\n     split(splitter: string): Array<string>;\n }\n \n+@Primitive(\"number\")\n+declare class Number {\n+    static NEGATIVE_INFINITY: NegativeInfinity;\n+    static POSITIVE_INFINITY: Infinity;\n+\n+    // static isFinite(item: any) {\n+    //     return !(item === Number.NEGATIVE_INFINITY || item === Number.POSITIVE_INFINITY || Number.isNaN(item))\n+    // }\n+\n+    static isNaN(item: any) {\n+        return item !== item;\n+    }\n+}\n+\n declare class Promise<T> { }\n \n type ResponseBody = string;\ndiff --git a/checker/examples/run_checker.rs b/checker/examples/run_checker.rs\n--- a/checker/examples/run_checker.rs\n+++ b/checker/examples/run_checker.rs\n@@ -78,7 +78,7 @@ fn main() {\n \t\tlet end = now.elapsed();\n \t\tlet count = result.diagnostics.into_iter().len();\n \t\teprintln!(\"Found {count} diagnostics in {end:?}\");\n-\t} else if args.iter().any(|arg| arg == \"--debug-diagnostics\") {\n+\t} else if args.iter().any(|arg| arg == \"--verbose-diagnostics\") {\n \t\teprintln!(\"Diagnostics:\");\n \t\tfor diagnostic in result.diagnostics {\n \t\t\teprintln!(\"{diagnostic:?}\");\ndiff --git a/checker/fuzz/Cargo.toml b/checker/fuzz/Cargo.toml\n--- a/checker/fuzz/Cargo.toml\n+++ b/checker/fuzz/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"ezno-parser-fuzz\"\n+name = \"ezno-checker-fuzz\"\n version = \"0.0.0\"\n publish = false\n edition = \"2021\"\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -366,8 +366,10 @@ object[key] satisfies boolean;\n > TODO this creates a fat or type\n \n ```ts\n-const array = [1, 2, 3];\n-array[Math.random()] satisfies string;\n+function func(idx: number) {\n+\tconst array = [1, 2, 3];\n+\tarray[idx] satisfies string;\n+}\n ```\n \n - Expected string, found 1 | 2 | 3 | undefined\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -1061,7 +1063,7 @@ function func(value: number) {\n \treturn \"another\"\n }\n \n-loop satisfies (a: number) => \"is three\" | \"another\";\n+func satisfies (a: number) => \"is three\" | \"another\";\n \n function loop(value: number) {\n \tfor (let i = 0; i < 10; i++) {\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -2433,66 +2593,6 @@ interface X {\n - Expected 4, found 5\n - Type { a: 3 } is not assignable to type X\n \n-#### `RegExp` constructor\n-\n-> RegExp = Regular expression\n-> In the future, their definition could be considered and evaluated at runtime\n-\n-```ts\n-const regexp = /hi/ satisfies string;\n-```\n-\n-- Expected string, found /hi/\n-\n-#### Invalid regular expressions\n-\n-```ts\n-const regexp1 = /(?a2)/;\n-const regexp2 = new RegExp(\"?a2\");\n-```\n-\n-- Invalid regular expression: Invalid token at named capture group identifier\n-- Invalid regular expression: Invalid atom character\n-\n-#### Constant `RegExp.exec`\n-\n-```ts\n-const regexp = /hi/;\n-const match = regexp.exec(\"hi\");\n-match satisfies number;\n-match.index satisfies string;\n-match.input satisfies boolean;\n-```\n-\n-- Expected number, found [\"hi\"]\n-- Expected string, found 0\n-- Expected boolean, found \"hi\"\n-\n-#### Constant `RegExp.exec` groups\n-\n-```ts\n-const regexp = /Hi (?<name>.*)/;\n-const match = regexp.exec(\"Hi Ben\");\n-match.input satisfies number;\n-match.groups satisfies string;\n-```\n-\n-- Expected number, found \"Hi Ben\"\n-- Expected string, found { name: \"Ben\" }\n-\n-#### Constant `RegExp.exec` groups greedy\n-\n-```ts\n-const regexp = /.*(?<x>[a-z]+)(?<y>[0-9]+)/;\n-const match = regexp.exec(\"ez as abc123\");\n-match.input satisfies number;\n-match.groups.x satisfies \"c\";\n-match.groups.y satisfies boolean;\n-```\n-\n-- Expected number, found \"ez as abc123\"\n-- Expected boolean, found \"123\"\n-\n #### Null and undefined\n \n ```ts\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -2769,6 +2869,112 @@ myTag`${name}Hello ` satisfies string;\n \n - Expected string, found { static_parts: [\"\", \"Hello \"], other: \"Ben\" }\n \n+#### Interface generic constraint checking\n+\n+```ts\n+interface BoxString<T extends string> {\n+\tinner: T\n+}\n+\n+type BoxedFour = BoxString<\"4\">;\n+type BoxedFive = BoxString<5>;\n+```\n+\n+- Generic argument 5 does not match string\n+\n+#### Mismatch in generic argument count\n+\n+```ts\n+interface BoxString<T extends string> {\n+\tinner: T\n+}\n+\n+let x: BoxString<string, number>;\n+```\n+\n+- Expected 1 type argument, but got 2\n+\n+#### Optional property access\n+\n+```ts\n+interface X {\n+    a: string\n+    b: string\n+}\n+\n+function func(x: X | null) {\n+\tx.a;\n+\tx?.b satisfies number;\n+}\n+```\n+\n+> TODO message should just be null\n+\n+- No property 'a' on X | null\n+- Expected number, found undefined | string\n+\n+### Regular expressions\n+\n+#### `RegExp` constructor\n+\n+> RegExp = Regular expression\n+> In the future, their definition could be considered and evaluated at runtime\n+\n+```ts\n+const regexp = /hi/ satisfies string;\n+```\n+\n+- Expected string, found /hi/\n+\n+#### Invalid regular expressions\n+\n+```ts\n+const regexp1 = /(?a2)/;\n+const regexp2 = new RegExp(\"?a2\");\n+```\n+\n+- Invalid regular expression: Invalid token at named capture group identifier\n+- Invalid regular expression: Invalid atom character\n+\n+#### Constant `RegExp.exec`\n+\n+```ts\n+const regexp = /hi/;\n+const match = regexp.exec(\"hi\");\n+match satisfies number;\n+match.index satisfies string;\n+match.input satisfies boolean;\n+```\n+\n+- Expected number, found [\"hi\"]\n+- Expected string, found 0\n+- Expected boolean, found \"hi\"\n+\n+#### Constant `RegExp.exec` groups\n+\n+```ts\n+const regexp = /Hi (?<name>.*)/;\n+const match = regexp.exec(\"Hi Ben\");\n+match.input satisfies number;\n+match.groups satisfies string;\n+```\n+\n+- Expected number, found \"Hi Ben\"\n+- Expected string, found { name: \"Ben\" }\n+\n+#### Constant `RegExp.exec` groups greedy\n+\n+```ts\n+const regexp = /.*(?<x>[a-z]+)(?<y>[0-9]+)/;\n+const match = regexp.exec(\"ez as abc123\");\n+match.input satisfies number;\n+match.groups.x satisfies \"c\";\n+match.groups.y satisfies boolean;\n+```\n+\n+- Expected number, found \"ez as abc123\"\n+- Expected boolean, found \"123\"\n+\n ### Async and `Promise`s\n \n > Position of await is not checked (here is fine because top level await)\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -3089,7 +3295,7 @@ type X = number;\n const a: X<number> = 2;\n ```\n \n-- Type 'X' has no generic parameters\n+- Cannot pass a type argument to a non-generic type\n \n #### Type alias with type parameters\n \ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -4725,13 +4976,13 @@ register(document.title)\n 6 satisfies GreaterThan<2>;\n -4 satisfies GreaterThan<2>;\n \n-6 satisfies LessThan<2>;\n--4 satisfies LessThan<2>;\n+2 satisfies LessThan<2>;\n+-3 satisfies LessThan<2>;\n ```\n \n - Expected MultipleOf\\<2>, found 5\n - Expected GreaterThan\\<2>, found -4\n-- Expected LessThan\\<2>, found 6\n+- Expected LessThan\\<2>, found 2\n \n #### `Not`\n \ndiff --git a/checker/specification/to_implement.md b/checker/specification/to_implement.md\n--- a/checker/specification/to_implement.md\n+++ b/checker/specification/to_implement.md\n@@ -733,86 +721,19 @@ f(false)\n \n ### Narrowing\n \n-#### Has property\n-\n-> TODO maybe need to constrain side effects here\n-\n-```ts\n-function func(parameter: { property: string }) {\n-    if (parameter.property === \"hello\") {\n-        parameter.property satisfies 4;\n-    }\n-}\n-```\n-\n-- Expected 4, found \"hello\"\n-\n-> TODO `typeof`, `instanceof`, conditional, across a function\n-\n-#### Conditional operator\n-\n-```ts\n-function optionalNumber(n: number | undefined): string {\n-    return n ?? 2\n-}\n-```\n-\n-- Cannot return string, found number | 2\n-\n-#### Equality\n-\n-```ts\n-declare let a: string;\n-if (a === \"hi\") {\n-\ta satisfies \"hello\"\n-}\n-```\n-\n-- Expected \"hello\", found \"hi\"\n-\n-#### Condition as a function\n-\n-```ts\n-declare let a: string;\n-\n-const equalsHi = (p: string) => p === \"hi\";\n+#### In `while` loop\n \n-if (equalsHi(a)) {\n-\ta satisfies \"hello\"\n-}\n-```\n-\n-- Expected \"hello\", found \"hi\"\n-\n-#### Passed around\n-\n-```ts\n-declare let a: string;\n-\n-const b = a;\n-if (b === \"hi\") {\n-\ta satisfies \"hello\"\n-}\n-```\n-\n-- Expected \"hello\", found \"hi\"\n-\n-#### Optional property access\n+> This is fine because of registering of assignments\n+> This does not work because i = fv + 1\n \n ```ts\n-interface X {\n-    a: string\n-    b: string\n+let i: number = 0;\n+while (i++ < 5) {\n+\ti satisfies null;\n }\n-\n-declare let x: X | null;\n-\n-x.a;\n-x?.b satisfies number;\n ```\n \n-- Cannot get 'a' on null\n-- Expected number, found string\n+- Expected null, found LessThan<6>\n \n ### Generics\n \ndiff --git a/checker/specification/to_implement.md b/checker/specification/to_implement.md\n--- a/checker/specification/to_implement.md\n+++ b/checker/specification/to_implement.md\n@@ -849,32 +770,6 @@ a satisfies 0; b satisfies string;\n \n - Expected string, found 1\n \n-#### Always known math\n-\n-```ts\n-function func(a: number) { return a ** 0 }\n-\n-print_type(func)\n-\n-declare let x: NotNotANumber;\n-\n-print_type(x ** 1 === x)\n-```\n-\n-- Expected string, found 1\n-- True\n-\n-#### Less than checks\n-\n-```ts\n-function x(a: GreaterThan<4>) {\n-\t(a < 3) satisfies false;\n-\t(a < 10) satisfies string;\n-}\n-```\n-\n-- Expected string, found boolean\n-\n ### Control flow\n \n #### Conditional break\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -5,7 +5,7 @@ use crate::{\n \tcontext::{get_on_ctx, information::ReturnState},\n \tdiagnostics::{\n \t\tNotInLoopOrCouldNotFindLabel, PropertyKeyRepresentation, TypeCheckError,\n-\t\tTypeStringRepresentation, TDZ,\n+\t\tTypeStringRepresentation, VariableUsedInTDZ,\n \t},\n \tevents::{Event, FinalEvent, RootReference},\n \tfeatures::{\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -661,7 +661,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\t\t\t\t.get_chain_of_info()\n \t\t\t\t\t\t\t\t.any(|info| info.variable_current_value.contains_key(&variable_id))\n \t\t\t\t\t\t{\n-\t\t\t\t\t\t\treturn Err(AssignmentError::TDZ(TDZ {\n+\t\t\t\t\t\t\treturn Err(AssignmentError::VariableUsedInTDZ(VariableUsedInTDZ {\n \t\t\t\t\t\t\t\tposition: assignment_position,\n \t\t\t\t\t\t\t\tvariable_name: variable_name.to_owned(),\n \t\t\t\t\t\t\t}));\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -1035,10 +1035,12 @@ impl<'a> Environment<'a> {\n \t\t\tif let Some(current_value) = current_value {\n \t\t\t\tOk(VariableWithValue(og_var.clone(), current_value))\n \t\t\t} else {\n-\t\t\t\tchecking_data.diagnostics_container.add_error(TypeCheckError::TDZ(TDZ {\n-\t\t\t\t\tvariable_name: self.get_variable_name(og_var.get_id()).to_owned(),\n-\t\t\t\t\tposition,\n-\t\t\t\t}));\n+\t\t\t\tchecking_data.diagnostics_container.add_error(TypeCheckError::VariableUsedInTDZ(\n+\t\t\t\t\tVariableUsedInTDZ {\n+\t\t\t\t\t\tvariable_name: self.get_variable_name(og_var.get_id()).to_owned(),\n+\t\t\t\t\t\tposition,\n+\t\t\t\t\t},\n+\t\t\t\t));\n \t\t\t\tOk(VariableWithValue(og_var.clone(), TypeId::ERROR_TYPE))\n \t\t\t}\n \t\t}\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -1093,7 +1095,7 @@ impl<'a> Environment<'a> {\n \t\t\t\t\talready_checked: Default::default(),\n \t\t\t\t\tmode: Default::default(),\n \t\t\t\t\tcontributions: Default::default(),\n-\t\t\t\t\tothers: SubTypingOptions::satisfies(),\n+\t\t\t\t\tothers: SubTypingOptions::default(),\n \t\t\t\t\t// TODO don't think there is much case in constraining it here\n \t\t\t\t\tobject_constraints: None,\n \t\t\t\t};\ndiff --git a/checker/src/context/environment.rs b/checker/src/context/environment.rs\n--- a/checker/src/context/environment.rs\n+++ b/checker/src/context/environment.rs\n@@ -1519,4 +1521,28 @@ impl<'a> Environment<'a> {\n \t\t\t},\n \t\t));\n \t}\n+\n+\tpub fn new_infer_type(\n+\t\t&mut self,\n+\t\texpected: TypeId,\n+\t\tinfer_name: &str,\n+\t\ttypes: &mut TypeStore,\n+\t) -> TypeId {\n+\t\tif let Scope::TypeAnnotationCondition { ref mut infer_parameters } = self.context_type.scope\n+\t\t{\n+\t\t\tlet infer_type = types.register_type(Type::RootPolyType(PolyNature::InferGeneric {\n+\t\t\t\tname: infer_name.to_owned(),\n+\t\t\t\textends: expected,\n+\t\t\t}));\n+\n+\t\t\tlet existing = infer_parameters.insert(infer_name.to_owned(), infer_type);\n+\t\t\tif existing.is_some() {\n+\t\t\t\tcrate::utilities::notify!(\"Raise error diagnostic\");\n+\t\t\t}\n+\t\t\tinfer_type\n+\t\t} else {\n+\t\t\tcrate::utilities::notify!(\"Raise error diagnostic\");\n+\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n+\t\t}\n+\t}\n }\ndiff --git a/checker/src/context/information.rs b/checker/src/context/information.rs\n--- a/checker/src/context/information.rs\n+++ b/checker/src/context/information.rs\n@@ -82,8 +82,10 @@ impl ReturnState {\n \t\tmatch self {\n \t\t\tReturnState::Continued => *self = new,\n \t\t\tReturnState::Rolling { .. } => match new {\n-\t\t\t\tReturnState::Continued => todo!(),\n-\t\t\t\tReturnState::Rolling { .. } => todo!(),\n+\t\t\t\tReturnState::Continued => {}\n+\t\t\t\tReturnState::Rolling { .. } => {\n+\t\t\t\t\tcrate::utilities::notify!(\"Warning not accepting second rolling\");\n+\t\t\t\t}\n \t\t\t\tnew @ ReturnState::Finished(_) => {\n \t\t\t\t\tcrate::utilities::notify!(\"Warning overwriting conditional\");\n \t\t\t\t\t*self = new;\ndiff --git a/checker/src/context/information.rs b/checker/src/context/information.rs\n--- a/checker/src/context/information.rs\n+++ b/checker/src/context/information.rs\n@@ -245,12 +247,6 @@ pub trait InformationChain {\n \t}\n }\n \n-impl InformationChain for LocalInformation {\n-\tfn get_chain_of_info(&self) -> impl Iterator<Item = &'_ LocalInformation> {\n-\t\tstd::iter::once(self)\n-\t}\n-}\n-\n pub struct ModuleInformation<'a> {\n \tpub top: &'a LocalInformation,\n \tpub module: &'a LocalInformation,\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -14,7 +14,9 @@ use source_map::SpanWithSource;\n \n use crate::{\n \tcontext::environment::ExpectedReturnType,\n-\tdiagnostics::{CannotRedeclareVariable, TypeCheckError, TypeStringRepresentation, TDZ},\n+\tdiagnostics::{\n+\t\tCannotRedeclareVariable, TypeCheckError, TypeStringRepresentation, VariableUsedInTDZ,\n+\t},\n \tevents::RootReference,\n \tfeatures::{\n \t\tassignments::Reference,\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -392,7 +394,7 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t\t\t\tVariableMutability::Mutable { reassignment_constraint: None }\n \t\t\t\t\t\t\t| VariableMutability::Constant => {\n \t\t\t\t\t\t\t\tcrate::utilities::notify!(\"TODO get value\");\n-\t\t\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tVariableMutability::Mutable {\n \t\t\t\t\t\t\t\treassignment_constraint: Some(value),\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -401,19 +403,19 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t\t\t// TODO\n \t\t\t\t\t\tVariableOrImport::MutableImport { .. } => {\n \t\t\t\t\t\t\tcrate::utilities::notify!(\"TODO MutableImport\");\n-\t\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t\t\t}\n \t\t\t\t\t\t// TODO\n \t\t\t\t\t\tVariableOrImport::ConstantImport { .. } => {\n \t\t\t\t\t\t\tcrate::utilities::notify!(\"TODO ConstantImport\");\n-\t\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t})\n \t\t\t}\n \t\t\tReference::Property { .. } => {\n \t\t\t\tcrate::utilities::notify!(\"TODO get object constraint on object\");\n-\t\t\t\tSome(TypeId::ERROR_TYPE)\n+\t\t\t\tSome(TypeId::UNIMPLEMENTED_ERROR_TYPE)\n \t\t\t}\n \t\t}\n \t}\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -864,10 +866,8 @@ impl<T: ContextType> Context<T> {\n \t\t\t\t\t\t_ => None,\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tcrate::utilities::notify!(\n-\t\t\t\t\t\t\"TODO get root this type, returning ERROR_TYPE for now\"\n-\t\t\t\t\t);\n-\t\t\t\t\tSome(TypeId::ERROR_TYPE)\n+\t\t\t\t\tcrate::utilities::notify!(\"TODO get root this type\");\n+\t\t\t\t\tSome(TypeId::UNIMPLEMENTED_ERROR_TYPE)\n \t\t\t\t}\n \t\t\t})\n \t\t\t.unwrap()\ndiff --git a/checker/src/context/mod.rs b/checker/src/context/mod.rs\n--- a/checker/src/context/mod.rs\n+++ b/checker/src/context/mod.rs\n@@ -1008,7 +1008,7 @@ pub enum AssignmentError {\n \t\tvalue_type: TypeStringRepresentation,\n \t\tassignment_position: SpanWithSource,\n \t},\n-\tTDZ(TDZ),\n+\tVariableUsedInTDZ(VariableUsedInTDZ),\n }\n \n /// TODO mutable let imports\ndiff --git a/checker/src/context/root.rs b/checker/src/context/root.rs\n--- a/checker/src/context/root.rs\n+++ b/checker/src/context/root.rs\n@@ -76,12 +76,16 @@ impl RootContext {\n \t\t\t(\"Capitalize\".to_owned(), TypeId::STRING_CAPITALIZE),\n \t\t\t(\"Uncapitalize\".to_owned(), TypeId::STRING_UNCAPITALIZE),\n \t\t\t(\"NoInfer\".to_owned(), TypeId::NO_INFER),\n-\t\t\t(\"LessThan\".to_owned(), TypeId::LESS_THAN),\n-\t\t\t(\"GreaterThan\".to_owned(), TypeId::GREATER_THAN),\n+\t\t\t(\"InclusiveRange\".to_owned(), TypeId::INCLUSIVE_RANGE),\n+\t\t\t(\"ExclusiveRange\".to_owned(), TypeId::EXCLUSIVE_RANGE),\n \t\t\t(\"MultipleOf\".to_owned(), TypeId::MULTIPLE_OF),\n-\t\t\t(\"NotNotANumber\".to_owned(), TypeId::NOT_NOT_A_NUMBER),\n+\t\t\t(\"NotNotANumber\".to_owned(), TypeId::NUMBER_BUT_NOT_NOT_A_NUMBER),\n \t\t\t(\"Not\".to_owned(), TypeId::NOT_RESTRICTION),\n \t\t\t(\"CaseInsensitive\".to_owned(), TypeId::CASE_INSENSITIVE),\n+\t\t\t(\"Infinity\".to_owned(), TypeId::INFINITY),\n+\t\t\t(\"NegativeInfinity\".to_owned(), TypeId::NEG_INFINITY),\n+\t\t\t(\"MinFloat\".to_owned(), TypeId::FLOAT_MIN),\n+\t\t\t(\"MaxFloat\".to_owned(), TypeId::FLOAT_MAX),\n \t\t]);\n \n \t\tlet mut info = LocalInformation::default();\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -2,9 +2,7 @@\n use crate::{\n \tcontext::{environment::Label, AssignmentError, InformationChain},\n \tdiagnostics,\n-\tfeatures::{\n-\t\tmodules::CouldNotOpenFile, operations::MathematicalAndBitwise, CannotDeleteFromError,\n-\t},\n+\tfeatures::{modules::CouldNotOpenFile, CannotDeleteFromError},\n \ttypes::{\n \t\tcalling::FunctionCallingError,\n \t\tprinting::print_type_with_type_arguments,\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -53,12 +51,12 @@ pub enum Diagnostic {\n \n /// Temporary dead zone. Between the variable identifier being hoisted and the value being assigned\n #[allow(clippy::upper_case_acronyms)]\n-pub struct TDZ {\n+pub struct VariableUsedInTDZ {\n \tpub variable_name: String,\n \tpub position: SpanWithSource,\n }\n \n-pub struct InvalidRegexp {\n+pub struct InvalidRegExp {\n \tpub error: String,\n \tpub position: SpanWithSource,\n }\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -328,13 +326,8 @@ pub(crate) enum TypeCheckError<'a> {\n \t\tposition: SpanWithSource,\n \t},\n \tCouldNotFindType(&'a str, Vec<&'a str>, SpanWithSource),\n-\tTypeHasNoGenericParameters(String, SpanWithSource),\n \t/// For all `=`, including from declarations\n \tAssignmentError(AssignmentError),\n-\t#[allow(dead_code)]\n-\tInvalidComparison(TypeStringRepresentation, TypeStringRepresentation),\n-\t#[allow(dead_code)]\n-\tInvalidUnaryOperation(crate::features::operations::PureUnary, TypeStringRepresentation),\n \tSetPropertyError(SetPropertyError),\n \tReturnedTypeDoesNotMatch {\n \t\texpected_return_type: TypeStringRepresentation,\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -384,13 +377,18 @@ pub(crate) enum TypeCheckError<'a> {\n \t\tname: String,\n \t\tposition: SpanWithSource,\n \t},\n-\t/// This is for structure generics\n-\t#[allow(dead_code)]\n+\t/// This is for structure generics (type annotations)\n \tGenericArgumentDoesNotMeetRestriction {\n \t\tparameter_restriction: TypeStringRepresentation,\n \t\targument: TypeStringRepresentation,\n \t\tposition: SpanWithSource,\n \t},\n+\t/// This is for structure generics (type annotations)\n+\tGenericArgumentCountMismatch {\n+\t\texpected_count: usize,\n+\t\tcount: usize,\n+\t\tposition: SpanWithSource,\n+\t},\n \t#[allow(dead_code)]\n \tNotTopLevelImport(SpanWithSource),\n \tDuplicateImportName {\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -423,14 +421,25 @@ pub(crate) enum TypeCheckError<'a> {\n \t\tposition: SpanWithSource,\n \t},\n \t#[allow(clippy::upper_case_acronyms)]\n-\tTDZ(TDZ),\n-\t#[allow(dead_code)]\n+\tVariableUsedInTDZ(VariableUsedInTDZ),\n \tInvalidMathematicalOrBitwiseOperation {\n-\t\toperator: MathematicalAndBitwise,\n+\t\toperator: crate::features::operations::MathematicalAndBitwise,\n+\t\tlhs: TypeStringRepresentation,\n+\t\trhs: TypeStringRepresentation,\n+\t\tposition: SpanWithSource,\n+\t},\n+\t// Only for `<` `>` etc\n+\tInvalidEqualityOperation {\n+\t\toperator: crate::features::operations::EqualityAndInequality,\n \t\tlhs: TypeStringRepresentation,\n \t\trhs: TypeStringRepresentation,\n \t\tposition: SpanWithSource,\n \t},\n+\tInvalidUnaryOperation {\n+\t\toperator: crate::features::operations::UnaryOperation,\n+\t\toperand: TypeStringRepresentation,\n+\t\tposition: SpanWithSource,\n+\t},\n \t#[allow(dead_code)]\n \tInvalidCast {\n \t\tposition: SpanWithSource,\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -457,7 +466,7 @@ pub(crate) enum TypeCheckError<'a> {\n \t\tposition: SpanWithSource,\n \t},\n \tCannotDeleteProperty(CannotDeleteFromError),\n-\tInvalidRegexp(InvalidRegexp),\n+\tInvalidRegExp(InvalidRegExp),\n }\n \n #[allow(clippy::useless_format)]\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -571,7 +580,7 @@ impl From<TypeCheckError<'_>> for Diagnostic {\n \t\t\t\t\t\tkind,\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tAssignmentError::TDZ(TDZ { variable_name, position }) => {\n+\t\t\t\tAssignmentError::VariableUsedInTDZ(VariableUsedInTDZ { variable_name, position }) => {\n \t\t\t\t\tDiagnostic::Position {\n \t\t\t\t\t\treason: format!(\"Cannot assign to '{variable_name}' before declaration\"),\n \t\t\t\t\t\tposition,\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -613,13 +622,6 @@ impl From<TypeCheckError<'_>> for Diagnostic {\n \t\t\t\tposition: at,\n \t\t\t\tkind,\n \t\t\t},\n-\t\t\tTypeCheckError::TypeHasNoGenericParameters(name, position) => {\n-\t\t\t\tDiagnostic::Position {\n-\t\t\t\t\treason: format!(\"Type '{name}' has no generic parameters\"),\n-\t\t\t\t\tposition,\n-\t\t\t\t\tkind,\n-\t\t\t\t}\n-\t\t\t}\n \t\t\tTypeCheckError::NonTopLevelExport(position) => Diagnostic::Position {\n \t\t\t\treason: \"Cannot export at not top level\".to_owned(),\n \t\t\t\tposition,\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -682,6 +684,24 @@ impl From<TypeCheckError<'_>> for Diagnostic {\n \t\t\t\tposition,\n \t\t\t\tkind,\n \t\t\t},\n+\t\t\tTypeCheckError::GenericArgumentCountMismatch {\n+\t\t\t\tcount,\n+\t\t\t\texpected_count,\n+\t\t\t\tposition,\n+\t\t\t} => {\n+\t\t\t\tlet reason = if expected_count == 0 {\n+\t\t\t\t\t\"Cannot pass a type argument to a non-generic type\".to_owned()\n+\t\t\t\t} else if expected_count == 1 {\n+\t\t\t\t\tformat!(\"Expected 1 type argument, but got {count}\")\n+\t\t\t\t} else {\n+\t\t\t\t\tformat!(\"Expected {expected_count} type arguments, but got {count}\")\n+\t\t\t\t};\n+\t\t\t\tDiagnostic::Position {\n+\t\t\t\t\tposition,\n+\t\t\t\t\tkind,\n+\t\t\t\t\treason\n+\t\t\t\t}\n+\t\t\t},\n \t\t\tTypeCheckError::NotTopLevelImport(position) => Diagnostic::Position {\n \t\t\t\treason: \"Import must be in the top of the scope\".to_owned(),\n \t\t\t\tposition,\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -736,19 +756,35 @@ impl From<TypeCheckError<'_>> for Diagnostic {\n \t\t\t\tposition,\n \t\t\t\tkind,\n \t\t\t},\n-\t\t\tTypeCheckError::TDZ(TDZ { position, variable_name }) => Diagnostic::Position {\n+\t\t\tTypeCheckError::VariableUsedInTDZ(VariableUsedInTDZ { position, variable_name }) => Diagnostic::Position {\n \t\t\t\treason: format!(\"Variable '{variable_name}' used before declaration\"),\n \t\t\t\tposition,\n \t\t\t\tkind,\n \t\t\t},\n-\t\t\tTypeCheckError::InvalidComparison(_, _) => todo!(),\n-\t\t\tTypeCheckError::InvalidUnaryOperation(_, _) => todo!(),\n \t\t\tTypeCheckError::InvalidMathematicalOrBitwiseOperation { operator, lhs, rhs, position } => Diagnostic::Position {\n \t\t\t\t// TODO temp\n \t\t\t\treason: format!(\"Cannot {lhs} {operator:?} {rhs}\"),\n \t\t\t\tposition,\n \t\t\t\tkind,\n \t\t\t},\n+\t\t\tTypeCheckError::InvalidUnaryOperation {\n+\t\t\t\toperator,\n+\t\t\t\toperand,\n+\t\t\t\tposition,\n+\t\t\t} => {\n+\t\t\t\tDiagnostic::Position {\n+\t\t\t\t\t// TODO temp\n+\t\t\t\t\treason: format!(\"Cannot {operator:?} {operand}\"),\n+\t\t\t\t\tposition,\n+\t\t\t\t\tkind,\n+\t\t\t\t}\n+\t\t\t},\n+\t\t\tTypeCheckError::InvalidEqualityOperation { operator, lhs, rhs, position } => Diagnostic::Position {\n+\t\t\t\t// TODO temp\n+\t\t\t\treason: format!(\"Cannot {lhs} {operator:?} {rhs}\"),\n+\t\t\t\tposition,\n+\t\t\t\tkind,\n+\t\t\t},\n \t\t\tTypeCheckError::NotInLoopOrCouldNotFindLabel(NotInLoopOrCouldNotFindLabel {\n \t\t\t\tlabel: _,\n \t\t\t\tposition,\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -873,7 +909,7 @@ impl From<TypeCheckError<'_>> for Diagnostic {\n \t\t\t\t\tkind,\n \t\t\t\t}\n \t\t\t},\n-\t\t\tTypeCheckError::InvalidRegexp(InvalidRegexp { error, position }) => Diagnostic::Position {\n+\t\t\tTypeCheckError::InvalidRegExp(InvalidRegExp { error, position }) => Diagnostic::Position {\n \t\t\t\treason: format!(\"Invalid regular expression: {error}\"),\n \t\t\t\tposition,\n \t\t\t\tkind,\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -919,6 +955,11 @@ pub enum TypeCheckWarning {\n \t\tcall_site: SpanWithSource,\n \t},\n \tUnreachable(SpanWithSource),\n+\tDisjointEquality {\n+\t\tlhs: TypeStringRepresentation,\n+\t\trhs: TypeStringRepresentation,\n+\t\tposition: SpanWithSource,\n+\t},\n }\n \n impl From<TypeCheckWarning> for Diagnostic {\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -989,6 +1030,11 @@ impl From<TypeCheckWarning> for Diagnostic {\n \t\t\t\t\tkind,\n \t\t\t\t}\n \t\t\t}\n+\t\t\tTypeCheckWarning::DisjointEquality { lhs, rhs, position } => Diagnostic::Position {\n+\t\t\t\treason: format!(\"This equality is always false as {lhs} and {rhs} have no overlap\"),\n+\t\t\t\tposition,\n+\t\t\t\tkind,\n+\t\t\t},\n \t\t}\n \t}\n }\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -1131,7 +1177,7 @@ fn function_calling_error_diagnostic(\n \t\t\tkind,\n \t\t\tposition,\n \t\t},\n-\t\tFunctionCallingError::TDZ { error: TDZ { position, variable_name }, call_site } => {\n+\t\tFunctionCallingError::VariableUsedInTDZ { error: VariableUsedInTDZ { position, variable_name }, call_site } => {\n \t\t\tDiagnostic::PositionWithAdditionalLabels {\n \t\t\t\treason: format!(\"Variable '{variable_name}' used before declaration{context}\"),\n \t\t\t\tposition: call_site,\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -1174,7 +1220,7 @@ fn function_calling_error_diagnostic(\n \t\t\t\tkind,\n \t\t\t}\n \t\t}\n-\t\tFunctionCallingError::NotConfiguarable {\n+\t\tFunctionCallingError::NotConfigurable {\n \t\t\tproperty,\n \t\t\tcall_site,\n \t\t} => {\ndiff --git a/checker/src/diagnostics.rs b/checker/src/diagnostics.rs\n--- a/checker/src/diagnostics.rs\n+++ b/checker/src/diagnostics.rs\n@@ -1187,7 +1233,7 @@ fn function_calling_error_diagnostic(\n \t\t\t\tkind,\n \t\t\t}\n \t\t}\n-\t\tFunctionCallingError::InvalidRegexp(InvalidRegexp { error, position }) => Diagnostic::Position {\n+\t\tFunctionCallingError::InvalidRegExp(InvalidRegExp { error, position }) => Diagnostic::Position {\n \t\t\treason: format!(\"Invalid regular expression: {error}\"),\n \t\t\tposition,\n \t\t\tkind,\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -6,7 +6,7 @@ use super::{\n \n use crate::{\n \tcontext::{get_value_of_variable, invocation::InvocationContext, CallCheckingBehavior},\n-\tdiagnostics::{TypeStringRepresentation, TDZ},\n+\tdiagnostics::{TypeStringRepresentation, VariableUsedInTDZ},\n \tfeatures::{\n \t\titeration::{self, IterationKind},\n \t\tobjects::SpecialObject,\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -93,8 +93,8 @@ pub(crate) fn apply_events(\n \t\t\t\t\t\t\t\t\tty\n \t\t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\t\tdiagnostics.errors.push(\n-\t\t\t\t\t\t\t\t\t\tcrate::types::calling::FunctionCallingError::TDZ {\n-\t\t\t\t\t\t\t\t\t\t\terror: TDZ {\n+\t\t\t\t\t\t\t\t\t\tcrate::types::calling::FunctionCallingError::VariableUsedInTDZ {\n+\t\t\t\t\t\t\t\t\t\t\terror: VariableUsedInTDZ {\n \t\t\t\t\t\t\t\t\t\t\t\tvariable_name: top_environment\n \t\t\t\t\t\t\t\t\t\t\t\t\t.get_variable_name(*id)\n \t\t\t\t\t\t\t\t\t\t\t\t\t.to_owned(),\ndiff --git a/checker/src/events/application.rs b/checker/src/events/application.rs\n--- a/checker/src/events/application.rs\n+++ b/checker/src/events/application.rs\n@@ -110,6 +110,7 @@ pub(crate) fn apply_events(\n \t\t\t\t\t\t\t\tinput.this_value.get(top_environment, types, *position)\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t};\n+\t\t\t\t\t\tcrate::utilities::notify!(\"Set to {:?}\", value);\n \t\t\t\t\t\ttype_arguments.set_during_application(*id, value);\n \t\t\t\t\t}\n \t\t\t\t}\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -29,7 +29,7 @@ pub enum ConstantFunctionError {\n \tFunctionCallingError(FunctionCallingError),\n \tNoLogicForIdentifier(String),\n \t/// This will get picked up by the main calling logic\n-\tBadCall,\n+\tCannotComputeConstant,\n }\n \n /// From when\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -60,11 +60,16 @@ pub(crate) fn call_constant_function(\n \t\t\"sin\" | \"cos\" | \"tan\" | \"atan\" | \"acos\" | \"asin\" | \"sinh\" | \"cosh\" | \"tanh\" | \"asinh\"\n \t\t| \"acosh\" | \"atanh\" | \"exp\" | \"expm1\" | \"log\" | \"log10\" | \"log2\" | \"log1p\" | \"round\"\n \t\t| \"floor\" | \"ceil\" | \"trunc\" | \"sqrt\" | \"cbrt\" | \"abs\" => {\n-\t\t\tlet second_argument_type =\n-\t\t\t\ttypes.get_type_by_id(arguments.last().ok_or(ConstantFunctionError::BadCall)?.value);\n+\t\t\tif arguments.len() > 1 {\n+\t\t\t\treturn Err(ConstantFunctionError::CannotComputeConstant);\n+\t\t\t}\n+\n+\t\t\tlet first_argument = types.get_type_by_id(\n+\t\t\t\targuments.last().ok_or(ConstantFunctionError::CannotComputeConstant)?.value,\n+\t\t\t);\n \n-\t\t\tlet Type::Constant(Constant::Number(num)) = second_argument_type else {\n-\t\t\t\treturn Err(ConstantFunctionError::BadCall);\n+\t\t\tlet Type::Constant(Constant::Number(num)) = first_argument else {\n+\t\t\t\treturn Err(ConstantFunctionError::CannotComputeConstant);\n \t\t\t};\n \n \t\t\tlet result = match id {\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -96,13 +101,24 @@ pub(crate) fn call_constant_function(\n \t\t\t\t_ => unreachable!(),\n \t\t\t};\n \n-\t\t\tlet try_into = result.try_into();\n-\t\t\tmatch try_into {\n-\t\t\t\tOk(try_into) => {\n-\t\t\t\t\tlet ty = types.new_constant_type(Constant::Number(try_into));\n-\t\t\t\t\tOk(ConstantOutput::Value(ty))\n+\t\t\tlet Ok(num) = result.try_into() else { return Ok(ConstantOutput::Value(TypeId::NAN)) };\n+\t\t\tOk(ConstantOutput::Value(types.new_constant_type(Constant::Number(num))))\n+\t\t}\n+\t\t\"imul\" => {\n+\t\t\tif let [x, y] = arguments {\n+\t\t\t\tif let (Type::Constant(Constant::Number(x)), Type::Constant(Constant::Number(y))) =\n+\t\t\t\t\t(types.get_type_by_id(x.value), types.get_type_by_id(y.value))\n+\t\t\t\t{\n+\t\t\t\t\t// TODO is this correct, what about overflow?\n+\t\t\t\t\tlet result = (x.into_inner() as i32) * (y.into_inner() as i32);\n+\t\t\t\t\tOk(ConstantOutput::Value(\n+\t\t\t\t\t\ttypes.new_constant_type(Constant::Number(result.into())),\n+\t\t\t\t\t))\n+\t\t\t\t} else {\n+\t\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t\t\t}\n-\t\t\t\tErr(_) => Ok(ConstantOutput::Value(TypeId::NAN)),\n+\t\t\t} else {\n+\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t\t}\n \t\t}\n \t\t// String stuff. TODO could this be replaced by intrinsics\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -116,14 +132,14 @@ pub(crate) fn call_constant_function(\n \t\t\t\t\t\"string_length\" => Constant::Number(\n \t\t\t\t\t\t(s.encode_utf16().count() as f64)\n \t\t\t\t\t\t\t.try_into()\n-\t\t\t\t\t\t\t.map_err(|_| ConstantFunctionError::BadCall)?,\n+\t\t\t\t\t\t\t.map_err(|_| ConstantFunctionError::CannotComputeConstant)?,\n \t\t\t\t\t),\n \t\t\t\t\t_ => unreachable!(),\n \t\t\t\t});\n \t\t\t\tOk(ConstantOutput::Value(result))\n \t\t\t} else {\n \t\t\t\t// This can occur!!\n-\t\t\t\tErr(ConstantFunctionError::BadCall)\n+\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t\t}\n \t\t}\n \t\t\"print_type\" | \"debug_type\" | \"print_and_debug_type\" | \"debug_type_independent\" => {\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -156,7 +172,9 @@ pub(crate) fn call_constant_function(\n \t\t\t\tlet mut buf = String::from(\"Types: \");\n \t\t\t\tfor (not_at_end, arg) in arguments.iter().nendiate() {\n \t\t\t\t\t// crate::utilities::notify!(\"at end {:?} {:?}\", not_at_end, arg);\n-\t\t\t\t\tlet arg = arg.non_spread_type().map_err(|()| ConstantFunctionError::BadCall)?;\n+\t\t\t\t\tlet arg = arg\n+\t\t\t\t\t\t.non_spread_type()\n+\t\t\t\t\t\t.map_err(|()| ConstantFunctionError::CannotComputeConstant)?;\n \t\t\t\t\tbuf.push_str(&to_string(print, debug, arg, types, environment));\n \t\t\t\t\tif not_at_end {\n \t\t\t\t\t\tbuf.push_str(\", \");\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -168,9 +186,9 @@ pub(crate) fn call_constant_function(\n \t\t\"print_constraint\" => {\n \t\t\tlet ty = arguments\n \t\t\t\t.first()\n-\t\t\t\t.ok_or(ConstantFunctionError::BadCall)?\n+\t\t\t\t.ok_or(ConstantFunctionError::CannotComputeConstant)?\n \t\t\t\t.non_spread_type()\n-\t\t\t\t.map_err(|()| ConstantFunctionError::BadCall)?;\n+\t\t\t\t.map_err(|()| ConstantFunctionError::CannotComputeConstant)?;\n \n \t\t\tlet constraint = environment\n \t\t\t\t.get_chain_of_info()\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -186,9 +204,9 @@ pub(crate) fn call_constant_function(\n \t\t\"debug_type_rust\" | \"debug_type_rust_independent\" => {\n \t\t\tlet id = arguments\n \t\t\t\t.first()\n-\t\t\t\t.ok_or(ConstantFunctionError::BadCall)?\n+\t\t\t\t.ok_or(ConstantFunctionError::CannotComputeConstant)?\n \t\t\t\t.non_spread_type()\n-\t\t\t\t.map_err(|()| ConstantFunctionError::BadCall)?;\n+\t\t\t\t.map_err(|()| ConstantFunctionError::CannotComputeConstant)?;\n \n \t\t\tlet ty = types.get_type_by_id(id);\n \t\t\tOk(ConstantOutput::Diagnostic(format!(\"Type is: {id:?} = {ty:?}\")))\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -196,9 +214,9 @@ pub(crate) fn call_constant_function(\n \t\t\"debug_effects\" | \"debug_effects_rust\" => {\n \t\t\tlet ty = arguments\n \t\t\t\t.first()\n-\t\t\t\t.ok_or(ConstantFunctionError::BadCall)?\n+\t\t\t\t.ok_or(ConstantFunctionError::CannotComputeConstant)?\n \t\t\t\t.non_spread_type()\n-\t\t\t\t.map_err(|()| ConstantFunctionError::BadCall)?;\n+\t\t\t\t.map_err(|()| ConstantFunctionError::CannotComputeConstant)?;\n \n \t\t\t// Unwrap structure generics\n \t\t\tlet ty =\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -214,8 +232,10 @@ pub(crate) fn call_constant_function(\n \t\t\tlet message = if let Type::SpecialObject(SpecialObject::Function(func, _))\n \t\t\t| Type::FunctionReference(func) = get_type_by_id\n \t\t\t{\n-\t\t\t\tlet function_type =\n-\t\t\t\t\ttypes.functions.get(func).ok_or(ConstantFunctionError::BadCall)?;\n+\t\t\t\tlet function_type = types\n+\t\t\t\t\t.functions\n+\t\t\t\t\t.get(func)\n+\t\t\t\t\t.ok_or(ConstantFunctionError::CannotComputeConstant)?;\n \n \t\t\t\tlet effects = &function_type.effect;\n \t\t\t\tif id.ends_with(\"rust\") {\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -253,15 +273,16 @@ pub(crate) fn call_constant_function(\n \t\t\t\tSome(this_ty),\n \t\t\t) = (on, first_argument)\n \t\t\t{\n-\t\t\t\tlet type_id =\n-\t\t\t\t\tthis_ty.non_spread_type().map_err(|()| ConstantFunctionError::BadCall)?;\n+\t\t\t\tlet type_id = this_ty\n+\t\t\t\t\t.non_spread_type()\n+\t\t\t\t\t.map_err(|()| ConstantFunctionError::CannotComputeConstant)?;\n \t\t\t\tlet value = types.register_type(Type::SpecialObject(SpecialObject::Function(\n \t\t\t\t\t*func,\n \t\t\t\t\tThisValue::Passed(type_id),\n \t\t\t\t)));\n \t\t\t\tOk(ConstantOutput::Value(value))\n \t\t\t} else {\n-\t\t\t\tErr(ConstantFunctionError::BadCall)\n+\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t\t}\n \t\t}\n \t\t\"setPrototypeOf\" => {\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -273,7 +294,7 @@ pub(crate) fn call_constant_function(\n \t\t\t\t// TODO\n \t\t\t\tOk(ConstantOutput::Value(TypeId::UNDEFINED_TYPE))\n \t\t\t} else {\n-\t\t\t\tErr(ConstantFunctionError::BadCall)\n+\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t\t}\n \t\t}\n \t\t\"getPrototypeOf\" => {\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -282,7 +303,7 @@ pub(crate) fn call_constant_function(\n \t\t\t\tlet prototype = environment.get_prototype(on);\n \t\t\t\tOk(ConstantOutput::Value(prototype))\n \t\t\t} else {\n-\t\t\t\tErr(ConstantFunctionError::BadCall)\n+\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t\t}\n \t\t}\n \t\t\"freeze\" => {\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -292,7 +313,7 @@ pub(crate) fn call_constant_function(\n \t\t\t\tenvironment.info.frozen.insert(on);\n \t\t\t\tOk(ConstantOutput::Value(on))\n \t\t\t} else {\n-\t\t\t\tErr(ConstantFunctionError::BadCall)\n+\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t\t}\n \t\t}\n \t\t\"isFrozen\" => {\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -303,17 +324,21 @@ pub(crate) fn call_constant_function(\n \t\t\t\t\tenvironment.get_chain_of_info().any(|info| info.frozen.contains(&on));\n \t\t\t\tOk(ConstantOutput::Value(if is_frozen { TypeId::TRUE } else { TypeId::FALSE }))\n \t\t\t} else {\n-\t\t\t\tErr(ConstantFunctionError::BadCall)\n+\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t\t}\n \t\t}\n \t\t\"defineProperty\" => {\n \t\t\t// TODO check configurable\n \t\t\tif let [on, property, descriptor] = arguments {\n-\t\t\t\tlet on = on.non_spread_type().map_err(|()| ConstantFunctionError::BadCall)?;\n-\t\t\t\tlet property =\n-\t\t\t\t\tproperty.non_spread_type().map_err(|()| ConstantFunctionError::BadCall)?;\n-\t\t\t\tlet descriptor =\n-\t\t\t\t\tdescriptor.non_spread_type().map_err(|()| ConstantFunctionError::BadCall)?;\n+\t\t\t\tlet on = on\n+\t\t\t\t\t.non_spread_type()\n+\t\t\t\t\t.map_err(|()| ConstantFunctionError::CannotComputeConstant)?;\n+\t\t\t\tlet property = property\n+\t\t\t\t\t.non_spread_type()\n+\t\t\t\t\t.map_err(|()| ConstantFunctionError::CannotComputeConstant)?;\n+\t\t\t\tlet descriptor = descriptor\n+\t\t\t\t\t.non_spread_type()\n+\t\t\t\t\t.map_err(|()| ConstantFunctionError::CannotComputeConstant)?;\n \n \t\t\t\tlet under = PropertyKey::from_type(property, types);\n \t\t\t\t// TODO\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -357,7 +382,7 @@ pub(crate) fn call_constant_function(\n \t\t\t\t\t} else if let Some(setter) = setter {\n \t\t\t\t\t\tPropertyValue::Setter(Callable::from_type(setter, types))\n \t\t\t\t\t} else {\n-\t\t\t\t\t\treturn Err(ConstantFunctionError::BadCall);\n+\t\t\t\t\t\treturn Err(ConstantFunctionError::CannotComputeConstant);\n \t\t\t\t\t}\n \t\t\t\t};\n \ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -388,7 +413,7 @@ pub(crate) fn call_constant_function(\n \t\t\t\t\t\t\t};\n \t\t\t\t\t\tif !valid {\n \t\t\t\t\t\t\treturn Err(ConstantFunctionError::FunctionCallingError(\n-\t\t\t\t\t\t\t\tFunctionCallingError::NotConfiguarable {\n+\t\t\t\t\t\t\t\tFunctionCallingError::NotConfigurable {\n \t\t\t\t\t\t\t\t\tproperty: crate::diagnostics::PropertyKeyRepresentation::new(\n \t\t\t\t\t\t\t\t\t\t&under,\n \t\t\t\t\t\t\t\t\t\tenvironment,\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -428,14 +453,17 @@ pub(crate) fn call_constant_function(\n \n \t\t\t\tOk(ConstantOutput::Value(on))\n \t\t\t} else {\n-\t\t\t\tErr(ConstantFunctionError::BadCall)\n+\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t\t}\n \t\t}\n \t\t\"getOwnPropertyDescriptor\" => {\n \t\t\tif let [on, property] = arguments {\n-\t\t\t\tlet on = on.non_spread_type().map_err(|()| ConstantFunctionError::BadCall)?;\n-\t\t\t\tlet property =\n-\t\t\t\t\tproperty.non_spread_type().map_err(|()| ConstantFunctionError::BadCall)?;\n+\t\t\t\tlet on = on\n+\t\t\t\t\t.non_spread_type()\n+\t\t\t\t\t.map_err(|()| ConstantFunctionError::CannotComputeConstant)?;\n+\t\t\t\tlet property = property\n+\t\t\t\t\t.non_spread_type()\n+\t\t\t\t\t.map_err(|()| ConstantFunctionError::CannotComputeConstant)?;\n \n \t\t\t\tlet value = crate::types::properties::resolver(\n \t\t\t\t\t(on, None),\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -504,7 +532,7 @@ pub(crate) fn call_constant_function(\n \t\t\t\t\t\tmatch value {\n \t\t\t\t\t\t\tPropertyValue::ConditionallyExists { .. } => {\n \t\t\t\t\t\t\t\tcrate::utilities::notify!(\"TODO conditional. Union with undefined\");\n-\t\t\t\t\t\t\t\treturn Err(ConstantFunctionError::BadCall);\n+\t\t\t\t\t\t\t\treturn Err(ConstantFunctionError::CannotComputeConstant);\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tPropertyValue::Configured { on: _, descriptor: d } => {\n \t\t\t\t\t\t\t\tdescriptor = d;\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -540,7 +568,7 @@ pub(crate) fn call_constant_function(\n \t\t\t\t\tNone => Ok(ConstantOutput::Value(TypeId::UNDEFINED_TYPE)),\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tErr(ConstantFunctionError::BadCall)\n+\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t\t}\n \t\t}\n \t\t\"proxy:constructor\" => {\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -555,7 +583,7 @@ pub(crate) fn call_constant_function(\n \t\t\t\t));\n \t\t\t\tOk(ConstantOutput::Value(value))\n \t\t\t} else {\n-\t\t\t\tErr(ConstantFunctionError::BadCall)\n+\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t\t}\n \t\t}\n \t\t// \"RegExp:constructor\" => {\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -563,17 +591,17 @@ pub(crate) fn call_constant_function(\n \t\t// \tif let Some(arg) = arguments.first() {\n \t\t// \t\tOk(ConstantOutput::Value(features::regular_expressions::new_regexp(features::regular_expressions::TypeIdOrString::TypeId(arg), types, environment)))\n \t\t// \t} else {\n-\t\t// \t\tErr(ConstantFunctionError::BadCall)\n+\t\t// \t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t// \t}\n \t\t// }\n \t\t// TODO\n \t\t\"JSON:parse\" => {\n \t\t\tcrate::utilities::notify!(\"TODO JSON:parse\");\n-\t\t\tErr(ConstantFunctionError::BadCall)\n+\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t}\n \t\t\"JSON:stringify\" => {\n \t\t\tcrate::utilities::notify!(\"TODO JSON:stringify\");\n-\t\t\tErr(ConstantFunctionError::BadCall)\n+\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t}\n \t\t\"regexp:constructor\" => {\n \t\t\tlet pattern = types\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -582,12 +610,12 @@ pub(crate) fn call_constant_function(\n \t\t\t\targuments.get(1).map(|a| types.get_type_by_id(a.non_spread_type().expect(\"flags\")));\n \n \t\t\tlet Type::Constant(Constant::String(pattern)) = pattern else {\n-\t\t\t\treturn Err(ConstantFunctionError::BadCall);\n+\t\t\t\treturn Err(ConstantFunctionError::CannotComputeConstant);\n \t\t\t};\n \t\t\tlet flags = match flags {\n \t\t\t\tSome(flags) => {\n \t\t\t\t\tlet Type::Constant(Constant::String(flags)) = flags else {\n-\t\t\t\t\t\treturn Err(ConstantFunctionError::BadCall);\n+\t\t\t\t\t\treturn Err(ConstantFunctionError::CannotComputeConstant);\n \t\t\t\t\t};\n \n \t\t\t\t\tSome(flags.clone())\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -600,7 +628,7 @@ pub(crate) fn call_constant_function(\n \t\t\tmatch regexp {\n \t\t\t\tOk(regex) => Ok(ConstantOutput::Value(regex)),\n \t\t\t\tErr(error) => Err(ConstantFunctionError::FunctionCallingError(\n-\t\t\t\t\tFunctionCallingError::InvalidRegexp(crate::diagnostics::InvalidRegexp {\n+\t\t\t\t\tFunctionCallingError::InvalidRegExp(crate::diagnostics::InvalidRegExp {\n \t\t\t\t\t\terror,\n \t\t\t\t\t\tposition: call_site,\n \t\t\t\t\t}),\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -621,21 +649,21 @@ pub(crate) fn call_constant_function(\n \t\t\t\t\tcall_site,\n \t\t\t\t)))\n \t\t\t} else {\n-\t\t\t\tErr(ConstantFunctionError::BadCall)\n+\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t\t}\n \t\t}\n \t\t// \"satisfies\" => {\n \t\t// \tlet ty = arguments\n \t\t// \t\t.first()\n-\t\t// \t\t.ok_or(ConstantFunctionError::BadCall)?\n+\t\t// \t\t.ok_or(ConstantFunctionError::CannotComputeConstant)?\n \t\t// \t\t.non_spread_type()\n-\t\t// \t\t.map_err(|()| ConstantFunctionError::BadCall)?;\n+\t\t// \t\t.map_err(|()| ConstantFunctionError::CannotComputeConstant)?;\n \t\t// \t// TODO temp!!!\n \t\t// \tlet arg = call_site_type_args\n \t\t// \t\t.iter()\n \t\t// \t\t.flatten()\n \t\t// \t\t.next()\n-\t\t// \t\t.ok_or(ConstantFunctionError::BadCall)?\n+\t\t// \t\t.ok_or(ConstantFunctionError::CannotComputeConstant)?\n \t\t// \t\t.0;\n \t\t// \tif check_satisfies(arg, ty, types, environment) {\n \t\t// \t\tOk(ConstantOutput::Value(ty))\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -658,7 +686,7 @@ pub(crate) fn call_constant_function(\n \t\t\tlet mut buf = format!(\"{:?}\", environment.context_id);\n \t\t\tfor ctx in environment.parents_iter().skip(1) {\n \t\t\t\twrite!(&mut buf, \" <- {:?}\", get_on_ctx!(ctx.context_id))\n-\t\t\t\t\t.map_err(|_| ConstantFunctionError::BadCall)?;\n+\t\t\t\t\t.map_err(|_| ConstantFunctionError::CannotComputeConstant)?;\n \t\t\t}\n \t\t\tbuf\n \t\t})),\ndiff --git a/checker/src/features/constant_functions.rs b/checker/src/features/constant_functions.rs\n--- a/checker/src/features/constant_functions.rs\n+++ b/checker/src/features/constant_functions.rs\n@@ -668,23 +696,23 @@ pub(crate) fn call_constant_function(\n \t\t\t\t.get_type_by_id(\n \t\t\t\t\targuments\n \t\t\t\t\t\t.first()\n-\t\t\t\t\t\t.ok_or(ConstantFunctionError::BadCall)?\n+\t\t\t\t\t\t.ok_or(ConstantFunctionError::CannotComputeConstant)?\n \t\t\t\t\t\t.non_spread_type()\n-\t\t\t\t\t\t.map_err(|()| ConstantFunctionError::BadCall)?\n+\t\t\t\t\t\t.map_err(|()| ConstantFunctionError::CannotComputeConstant)?\n \t\t\t\t)\n \t\t\t\t.is_dependent()\n \t\t))),\n \t\t// \"compile_type_to_object\" => {\n \t\t// \tif let Some(value) = call_site_type_args {\n \t\t// \t\tlet value = crate::types::others::create_object_for_type(\n-\t\t// \t\t\tvalue.first().ok_or(ConstantFunctionError::BadCall)?.0,\n+\t\t// \t\t\tvalue.first().ok_or(ConstantFunctionError::CannotComputeConstant)?.0,\n \t\t// \t\t\tenvironment,\n \t\t// \t\t\ttypes,\n \t\t// \t\t\tcall_site,\n \t\t// \t\t);\n \t\t// \t\tOk(ConstantOutput::Value(value))\n \t\t// \t} else {\n-\t\t// \t\tErr(ConstantFunctionError::BadCall)\n+\t\t// \t\tErr(ConstantFunctionError::CannotComputeConstant)\n \t\t// \t}\n \t\t// }\n \t\tfunc => {\ndiff --git a/checker/src/features/functions.rs b/checker/src/features/functions.rs\n--- a/checker/src/features/functions.rs\n+++ b/checker/src/features/functions.rs\n@@ -455,13 +455,13 @@ where\n \t\t\tFunctionKind {\n \t\t\t\tbehavior: FunctionBehavior::Constructor {\n \t\t\t\t\tprototype,\n-\t\t\t\t\tthis_object_type: TypeId::ERROR_TYPE,\n+\t\t\t\t\tthis_object_type: TypeId::IS_ASSIGNED_VALUE_LATER,\n \t\t\t\t\tname,\n \t\t\t\t},\n \t\t\t\tscope: FunctionScope::Constructor {\n \t\t\t\t\textends: super_type.is_some(),\n \t\t\t\t\ttype_of_super: super_type,\n-\t\t\t\t\tthis_object_type: TypeId::ERROR_TYPE,\n+\t\t\t\t\tthis_object_type: TypeId::IS_ASSIGNED_VALUE_LATER,\n \t\t\t\t},\n \t\t\t\tinternal: internal_marker,\n \t\t\t\tconstructor: Some((prototype, properties)),\ndiff --git a/checker/src/features/functions.rs b/checker/src/features/functions.rs\n--- a/checker/src/features/functions.rs\n+++ b/checker/src/features/functions.rs\n@@ -489,7 +489,7 @@ where\n \t\t\tFunctionKind {\n \t\t\t\tbehavior: FunctionBehavior::ArrowFunction { is_async },\n \t\t\t\tscope: FunctionScope::ArrowFunction {\n-\t\t\t\t\tfree_this_type: TypeId::ERROR_TYPE,\n+\t\t\t\t\tfree_this_type: TypeId::IS_ASSIGNED_VALUE_LATER,\n \t\t\t\t\tis_async,\n \t\t\t\t\texpected_return: expected_return.map(ExpectedReturnType::Inferred),\n \t\t\t\t},\ndiff --git a/checker/src/features/functions.rs b/checker/src/features/functions.rs\n--- a/checker/src/features/functions.rs\n+++ b/checker/src/features/functions.rs\n@@ -520,7 +520,7 @@ where\n \t\t\t\tbehavior: FunctionBehavior::Function {\n \t\t\t\t\tis_async,\n \t\t\t\t\tis_generator,\n-\t\t\t\t\tthis_id: TypeId::ERROR_TYPE,\n+\t\t\t\t\tthis_id: TypeId::IS_ASSIGNED_VALUE_LATER,\n \t\t\t\t\tprototype,\n \t\t\t\t\tname,\n \t\t\t\t},\ndiff --git a/checker/src/features/functions.rs b/checker/src/features/functions.rs\n--- a/checker/src/features/functions.rs\n+++ b/checker/src/features/functions.rs\n@@ -528,7 +528,7 @@ where\n \t\t\t\t\tis_generator,\n \t\t\t\t\tis_async,\n \t\t\t\t\t// to set\n-\t\t\t\t\tthis_type: TypeId::ERROR_TYPE,\n+\t\t\t\t\tthis_type: TypeId::IS_ASSIGNED_VALUE_LATER,\n \t\t\t\t\ttype_of_super: TypeId::ANY_TYPE,\n \t\t\t\t\texpected_return: expected_return.map(ExpectedReturnType::Inferred),\n \t\t\t\t\tlocation,\ndiff --git a/checker/src/features/functions.rs b/checker/src/features/functions.rs\n--- a/checker/src/features/functions.rs\n+++ b/checker/src/features/functions.rs\n@@ -556,14 +556,14 @@ where\n \t\t\t\t\tis_async,\n \t\t\t\t\tis_generator,\n \t\t\t\t\tprototype,\n-\t\t\t\t\tthis_id: TypeId::ERROR_TYPE,\n+\t\t\t\t\tthis_id: TypeId::IS_ASSIGNED_VALUE_LATER,\n \t\t\t\t\tname,\n \t\t\t\t},\n \t\t\t\tscope: FunctionScope::Function {\n \t\t\t\t\tis_generator,\n \t\t\t\t\tis_async,\n-\t\t\t\t\tthis_type: TypeId::ERROR_TYPE,\n-\t\t\t\t\ttype_of_super: TypeId::ERROR_TYPE,\n+\t\t\t\t\tthis_type: TypeId::IS_ASSIGNED_VALUE_LATER,\n+\t\t\t\t\ttype_of_super: TypeId::IS_ASSIGNED_VALUE_LATER,\n \t\t\t\t\texpected_return: None,\n \t\t\t\t\tlocation,\n \t\t\t\t},\ndiff --git a/checker/src/features/functions.rs b/checker/src/features/functions.rs\n--- a/checker/src/features/functions.rs\n+++ b/checker/src/features/functions.rs\n@@ -618,11 +618,11 @@ where\n \t\t\t\tbehavior: FunctionBehavior::Method {\n \t\t\t\t\tis_async,\n \t\t\t\t\tis_generator,\n-\t\t\t\t\tfree_this_id: TypeId::ERROR_TYPE,\n+\t\t\t\t\tfree_this_id: TypeId::IS_ASSIGNED_VALUE_LATER,\n \t\t\t\t\tname,\n \t\t\t\t},\n \t\t\t\tscope: FunctionScope::MethodFunction {\n-\t\t\t\t\tfree_this_type: TypeId::ERROR_TYPE,\n+\t\t\t\t\tfree_this_type: TypeId::IS_ASSIGNED_VALUE_LATER,\n \t\t\t\t\tis_async,\n \t\t\t\t\tis_generator,\n \t\t\t\t\texpected_return: expected_return.map(ExpectedReturnType::Inferred),\ndiff --git a/checker/src/features/functions.rs b/checker/src/features/functions.rs\n--- a/checker/src/features/functions.rs\n+++ b/checker/src/features/functions.rs\n@@ -846,7 +846,7 @@ where\n \t\t\t\t\t\talready_checked: Default::default(),\n \t\t\t\t\t\tmode: Default::default(),\n \t\t\t\t\t\tcontributions: Default::default(),\n-\t\t\t\t\t\tothers: crate::subtyping::SubTypingOptions::satisfies(),\n+\t\t\t\t\t\tothers: crate::subtyping::SubTypingOptions::default(),\n \t\t\t\t\t\t// TODO don't think there is much case in constraining it here\n \t\t\t\t\t\tobject_constraints: None,\n \t\t\t\t\t};\ndiff --git a/checker/src/features/iteration.rs b/checker/src/features/iteration.rs\n--- a/checker/src/features/iteration.rs\n+++ b/checker/src/features/iteration.rs\n@@ -72,6 +72,17 @@ pub fn synthesise_iteration<T: crate::ReadFromFS, A: crate::ASTImplementation>(\n \t\t\t\t\t\tchecking_data,\n \t\t\t\t\t);\n \n+\t\t\t\t\tlet values = super::narrowing::narrow_based_on_expression_into_vec(\n+\t\t\t\t\t\tcondition,\n+\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t&mut checking_data.types,\n+\t\t\t\t\t);\n+\n+\t\t\t\t\tcrate::utilities::notify!(\"{:?}\", values);\n+\n+\t\t\t\t\tenvironment.info.narrowed_values = values;\n+\n \t\t\t\t\t// TODO not always needed\n \t\t\t\t\tadd_loop_described_break_event(\n \t\t\t\t\t\tcondition,\ndiff --git a/checker/src/features/iteration.rs b/checker/src/features/iteration.rs\n--- a/checker/src/features/iteration.rs\n+++ b/checker/src/features/iteration.rs\n@@ -279,6 +290,15 @@ pub fn synthesise_iteration<T: crate::ReadFromFS, A: crate::ASTImplementation>(\n \n \t\t\t\t\t\t// TODO copy value of variables between things, or however it works\n \n+\t\t\t\t\t\tlet values = super::narrowing::narrow_based_on_expression_into_vec(\n+\t\t\t\t\t\t\tcondition,\n+\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t&mut checking_data.types,\n+\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\tenvironment.info.narrowed_values = values;\n+\n \t\t\t\t\t\t(condition, events, dependent_variables)\n \t\t\t\t\t},\n \t\t\t\t);\ndiff --git a/checker/src/features/iteration.rs b/checker/src/features/iteration.rs\n--- a/checker/src/features/iteration.rs\n+++ b/checker/src/features/iteration.rs\n@@ -886,6 +906,7 @@ fn calculate_result_of_loop(\n \t\t\t\t\tlhs: assignment,\n \t\t\t\t\toperator: _,\n \t\t\t\t\trhs: increments_by,\n+\t\t\t\t\tresult: _,\n \t\t\t\t}) = value_after_running_expressions_in_loop\n \t\t\t\t{\n \t\t\t\t\tdebug_assert!(\ndiff --git a/checker/src/features/mod.rs b/checker/src/features/mod.rs\n--- a/checker/src/features/mod.rs\n+++ b/checker/src/features/mod.rs\n@@ -73,10 +73,6 @@ pub fn type_of_operator(on: TypeId, types: &mut TypeStore) -> TypeId {\n \t\t\t\tcrate::types::TypeOperator::TypeOf(on),\n \t\t\t)))\n \t\t}\n-\t} else if on == TypeId::UNDEFINED_TYPE {\n-\t\treturn types.new_constant_type(crate::Constant::String(\"undefined\".to_owned()));\n-\t} else if on == TypeId::NULL_TYPE {\n-\t\treturn types.new_constant_type(crate::Constant::String(\"object\".to_owned()));\n \t} else {\n \t\tlet ty = types.get_type_by_id(on);\n \t\tif let crate::Type::Constant(cst) = ty {\ndiff --git a/checker/src/features/mod.rs b/checker/src/features/mod.rs\n--- a/checker/src/features/mod.rs\n+++ b/checker/src/features/mod.rs\n@@ -86,16 +82,18 @@ pub fn type_of_operator(on: TypeId, types: &mut TypeStore) -> TypeId {\n \t\t\t\tcrate::Constant::String(_) => \"string\",\n \t\t\t\tcrate::Constant::Boolean(_) => \"boolean\",\n \t\t\t\tcrate::Constant::Symbol { key: _ } => \"symbol\",\n+\t\t\t\tcrate::Constant::Undefined => \"undefined\",\n \t\t\t};\n \t\t\t// TODO could Cow or something to not allocate?\n \t\t\ttypes.new_constant_type(crate::Constant::String(name.to_owned()))\n \t\t} else if let crate::Type::SpecialObject(SpecialObject::Function(..)) = ty {\n \t\t\ttypes.new_constant_type(crate::Constant::String(\"function\".to_owned()))\n \t\t} else if let crate::Type::Object(..) | crate::Type::SpecialObject(..) = ty {\n+\t\t\t// includes TypeId::NULL_TYPE\n \t\t\ttypes.new_constant_type(crate::Constant::String(\"object\".to_owned()))\n \t\t} else {\n \t\t\tcrate::utilities::notify!(\"Cannot `typeof {:?}`\", on);\n-\t\t\tTypeId::ERROR_TYPE\n+\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t}\n \t}\n }\ndiff --git a/checker/src/features/mod.rs b/checker/src/features/mod.rs\n--- a/checker/src/features/mod.rs\n+++ b/checker/src/features/mod.rs\n@@ -200,7 +198,7 @@ pub fn await_expression<T: crate::ReadFromFS, A: crate::ASTImplementation>(\n \t\t}\n \t} else {\n \t\tchecking_data.raise_unimplemented_error(\"await on object\", position);\n-\t\tTypeId::ERROR_TYPE\n+\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t}\n }\n \ndiff --git a/checker/src/features/mod.rs b/checker/src/features/mod.rs\n--- a/checker/src/features/mod.rs\n+++ b/checker/src/features/mod.rs\n@@ -455,20 +453,20 @@ pub(crate) fn has_property(\n \t\t\t\t\tLogical::Pure(_) => TypeId::TRUE,\n \t\t\t\t\tLogical::Or { .. } => {\n \t\t\t\t\t\tcrate::utilities::notify!(\"or or implies `in`\");\n-\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t\t}\n \t\t\t\t\tLogical::Implies { .. } => {\n \t\t\t\t\t\tcrate::utilities::notify!(\"or or implies `in`\");\n-\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t\t}\n \t\t\t\t\tLogical::BasedOnKey { .. } => {\n \t\t\t\t\t\tcrate::utilities::notify!(\"mapped in\");\n-\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t\t}\n \t\t\t\t},\n \t\t\t\tOk(LogicalOrValid::NeedsCalculation(result)) => {\n \t\t\t\t\tcrate::utilities::notify!(\"TODO {:?}\", result);\n-\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t}\n \t\t\t\tErr(err) => {\n \t\t\t\t\tcrate::utilities::notify!(\"TODO {:?}\", err);\ndiff --git a/checker/src/features/mod.rs b/checker/src/features/mod.rs\n--- a/checker/src/features/mod.rs\n+++ b/checker/src/features/mod.rs\n@@ -478,7 +476,7 @@ pub(crate) fn has_property(\n \t\t}\n \t\tType::Or(_, _) => {\n \t\t\tcrate::utilities::notify!(\"Condtionally\");\n-\t\t\tTypeId::ERROR_TYPE\n+\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t}\n \t\tType::RootPolyType(_) | Type::Constructor(_) => {\n \t\t\tcrate::utilities::notify!(\"Queue event / create dependent\");\ndiff --git a/checker/src/features/mod.rs b/checker/src/features/mod.rs\n--- a/checker/src/features/mod.rs\n+++ b/checker/src/features/mod.rs\n@@ -506,7 +504,6 @@ pub mod tsc {\n \t\t\t\tType::RootPolyType(_rpt) => true,\n \t\t\t\tType::Constructor(constr) => match constr {\n \t\t\t\t\tConstructor::CanonicalRelationOperator { .. }\n-\t\t\t\t\t| Constructor::UnaryOperator { .. }\n \t\t\t\t\t| Constructor::BinaryOperator { .. } => false,\n \t\t\t\t\tConstructor::TypeOperator(_) => todo!(),\n \t\t\t\t\tConstructor::TypeExtends(_) => todo!(),\ndiff --git a/checker/src/features/mod.rs b/checker/src/features/mod.rs\n--- a/checker/src/features/mod.rs\n+++ b/checker/src/features/mod.rs\n@@ -556,12 +553,24 @@ pub mod tsc {\n \t\tenvironment: &mut Environment,\n \t\tchecking_data: &mut CheckingData<T, A>,\n \t) {\n-\t\tif !crate::types::helpers::simple_subtype(\n-\t\t\texpr_ty,\n+\t\tuse crate::types::subtyping;\n+\n+\t\tlet mut state = subtyping::State {\n+\t\t\talready_checked: Default::default(),\n+\t\t\tmode: Default::default(),\n+\t\t\tcontributions: Default::default(),\n+\t\t\tothers: subtyping::SubTypingOptions { allow_errors: false },\n+\t\t\tobject_constraints: None,\n+\t\t};\n+\n+\t\tlet result = subtyping::type_is_subtype(\n \t\t\tto_satisfy,\n+\t\t\texpr_ty,\n+\t\t\t&mut state,\n \t\t\tenvironment,\n \t\t\t&checking_data.types,\n-\t\t) {\n+\t\t);\n+\t\tif result.is_mismatch() {\n \t\t\tlet expected = diagnostics::TypeStringRepresentation::from_type_id(\n \t\t\t\tto_satisfy,\n \t\t\t\tenvironment,\ndiff --git a/checker/src/features/modules.rs b/checker/src/features/modules.rs\n--- a/checker/src/features/modules.rs\n+++ b/checker/src/features/modules.rs\n@@ -324,7 +324,7 @@ pub fn import_items<\n \t\t\t\tchecking_data.types.register_type(import_object)\n \t\t\t} else {\n \t\t\t\tcrate::utilities::notify!(\"TODO :?\");\n-\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t};\n \t\t\tenvironment.register_variable_handle_error(\n \t\t\t\tunder,\ndiff --git a/checker/src/features/narrowing.rs b/checker/src/features/narrowing.rs\n--- a/checker/src/features/narrowing.rs\n+++ b/checker/src/features/narrowing.rs\n@@ -1,13 +1,14 @@\n use crate::{\n \tcontext::InformationChain,\n \ttypes::{\n-\t\tself, as_logical_and, as_logical_or, get_conditional, helpers::get_origin, properties,\n-\t\tConstant, Constructor, PolyNature, TypeOperator, TypeStore,\n+\t\tself, as_logical_and, as_logical_not, as_logical_or,\n+\t\thelpers::{get_conditional, get_origin},\n+\t\tproperties, Constant, Constructor, PolyNature, TypeOperator, TypeStore,\n \t},\n \tMap, Type, TypeId,\n };\n \n-use super::operations::{CanonicalEqualityAndInequality, MathematicalAndBitwise, PureUnary};\n+use super::operations::{CanonicalEqualityAndInequality, MathematicalAndBitwise};\n \n pub fn narrow_based_on_expression_into_vec(\n \tcondition: TypeId,\ndiff --git a/checker/src/features/narrowing.rs b/checker/src/features/narrowing.rs\n--- a/checker/src/features/narrowing.rs\n+++ b/checker/src/features/narrowing.rs\n@@ -68,6 +69,7 @@ pub fn narrow_based_on_expression(\n \t\t\t\t\tlhs: operand,\n \t\t\t\t\toperator: MathematicalAndBitwise::Modulo,\n \t\t\t\t\trhs: modulo,\n+\t\t\t\t\tresult: _,\n \t\t\t\t}) = types.get_type_by_id(*lhs)\n \t\t\t\t{\n \t\t\t\t\tif *rhs == TypeId::ZERO {\ndiff --git a/checker/src/features/narrowing.rs b/checker/src/features/narrowing.rs\n--- a/checker/src/features/narrowing.rs\n+++ b/checker/src/features/narrowing.rs\n@@ -77,9 +79,10 @@ pub fn narrow_based_on_expression(\n \t\t\t\t\t\tif negate {\n \t\t\t\t\t\t\tcrate::utilities::notify!(\"TODO do we not divisable by?\");\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tlet narrowed_to = types.new_intrinsic(\n+\t\t\t\t\t\t\tlet narrowed_to = crate::types::intrinsics::new_intrinsic(\n \t\t\t\t\t\t\t\t&crate::types::intrinsics::Intrinsic::MultipleOf,\n \t\t\t\t\t\t\t\tmodulo,\n+\t\t\t\t\t\t\t\ttypes,\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\t\tlet narrowed = types.new_narrowed(from, narrowed_to);\n \t\t\t\t\t\t\tinto.insert(from, narrowed);\ndiff --git a/checker/src/features/narrowing.rs b/checker/src/features/narrowing.rs\n--- a/checker/src/features/narrowing.rs\n+++ b/checker/src/features/narrowing.rs\n@@ -98,6 +101,11 @@ pub fn narrow_based_on_expression(\n \t\t\t\t\t\t);\n \t\t\t\t\t}\n \n+\t\t\t\t\tif negate && lhs == rhs {\n+\t\t\t\t\t\tinto.insert(*lhs, types.new_narrowed(*lhs, TypeId::NOT_NOT_A_NUMBER));\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n \t\t\t\t\tlet lhs = get_origin(*lhs, types);\n \n \t\t\t\t\tlet result = if negate {\ndiff --git a/checker/src/features/narrowing.rs b/checker/src/features/narrowing.rs\n--- a/checker/src/features/narrowing.rs\n+++ b/checker/src/features/narrowing.rs\n@@ -116,7 +124,11 @@ pub fn narrow_based_on_expression(\n \t\t\t\t\t\t\tlet narrowed_to = types.new_or_type_from_iterator(result);\n \t\t\t\t\t\t\ttypes.new_narrowed(lhs, narrowed_to)\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\ttypes.new_intrinsic(&crate::types::intrinsics::Intrinsic::Not, *rhs)\n+\t\t\t\t\t\t\tcrate::types::intrinsics::new_intrinsic(\n+\t\t\t\t\t\t\t\t&crate::types::intrinsics::Intrinsic::Not,\n+\t\t\t\t\t\t\t\t*rhs,\n+\t\t\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\t\t)\n \t\t\t\t\t\t};\n \t\t\t\t\t\ttypes.new_narrowed(lhs, narrowed_to)\n \t\t\t\t\t} else {\ndiff --git a/checker/src/features/narrowing.rs b/checker/src/features/narrowing.rs\n--- a/checker/src/features/narrowing.rs\n+++ b/checker/src/features/narrowing.rs\n@@ -172,20 +184,23 @@ pub fn narrow_based_on_expression(\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t\tif types.get_type_by_id(lhs).is_dependent() {\n-\t\t\t\t\tlet narrowed_to =\n-\t\t\t\t\t\ttypes.new_intrinsic(&crate::types::intrinsics::Intrinsic::LessThan, rhs);\n+\t\t\t\t\tlet narrowed_to = crate::types::intrinsics::new_intrinsic(\n+\t\t\t\t\t\t&crate::types::intrinsics::Intrinsic::LessThan,\n+\t\t\t\t\t\trhs,\n+\t\t\t\t\t\ttypes,\n+\t\t\t\t\t);\n \t\t\t\t\tlet narrowed = types.new_narrowed(lhs, narrowed_to);\n \t\t\t\t\tinto.insert(lhs, narrowed);\n \t\t\t\t} else if types.get_type_by_id(rhs).is_dependent() {\n-\t\t\t\t\tlet narrowed_to =\n-\t\t\t\t\t\ttypes.new_intrinsic(&crate::types::intrinsics::Intrinsic::GreaterThan, lhs);\n+\t\t\t\t\tlet narrowed_to = crate::types::intrinsics::new_intrinsic(\n+\t\t\t\t\t\t&crate::types::intrinsics::Intrinsic::GreaterThan,\n+\t\t\t\t\t\tlhs,\n+\t\t\t\t\t\ttypes,\n+\t\t\t\t\t);\n \t\t\t\t\tlet narrowed = types.new_narrowed(rhs, narrowed_to);\n \t\t\t\t\tinto.insert(rhs, narrowed);\n \t\t\t\t}\n \t\t\t}\n-\t\t\tConstructor::UnaryOperator { operator: PureUnary::LogicalNot, operand } => {\n-\t\t\t\tnarrow_based_on_expression(*operand, !negate, into, information, types);\n-\t\t\t}\n \t\t\tConstructor::TypeOperator(TypeOperator::IsPrototype { lhs, rhs_prototype }) => {\n \t\t\t\tlet (lhs, rhs_prototype) = (*lhs, *rhs_prototype);\n \t\t\t\tlet constraint = crate::types::get_constraint(lhs, types).unwrap_or(lhs);\ndiff --git a/checker/src/features/narrowing.rs b/checker/src/features/narrowing.rs\n--- a/checker/src/features/narrowing.rs\n+++ b/checker/src/features/narrowing.rs\n@@ -241,7 +256,10 @@ pub fn narrow_based_on_expression(\n \t\t\t\tinto.insert(on, types.new_narrowed(on, narrowed_to));\n \t\t\t}\n \t\t\tconstructor => {\n-\t\t\t\tif let Some((lhs, rhs)) = as_logical_and(constructor, types) {\n+\t\t\t\tif let Some(condition) = as_logical_not(constructor, types) {\n+\t\t\t\t\tcrate::utilities::notify!(\"Here\");\n+\t\t\t\t\tnarrow_based_on_expression(condition, !negate, into, information, types);\n+\t\t\t\t} else if let Some((lhs, rhs)) = as_logical_and(constructor, types) {\n \t\t\t\t\t// De Morgan's laws\n \t\t\t\t\tif negate {\n \t\t\t\t\t\t// OR: Pull assertions from left and right, merge if both branches assert something\ndiff --git a/checker/src/features/narrowing.rs b/checker/src/features/narrowing.rs\n--- a/checker/src/features/narrowing.rs\n+++ b/checker/src/features/narrowing.rs\n@@ -310,8 +328,20 @@ pub fn narrow_based_on_expression(\n \t\tif rpt.get_constraint() == TypeId::BOOLEAN_TYPE {\n \t\t\tlet result = if negate { TypeId::FALSE } else { TypeId::TRUE };\n \t\t\tinto.insert(condition, result);\n-\t\t} else {\n-\t\t\tcrate::utilities::notify!(\"Set, {:?} as truthy\", r#type);\n+\t\t} else if !negate {\n+\t\t\tlet mut result = Vec::new();\n+\t\t\tsuper::narrowing::build_union_from_filter(\n+\t\t\t\tcondition,\n+\t\t\t\tsuper::narrowing::NOT_FASLY,\n+\t\t\t\t&mut result,\n+\t\t\t\tinformation,\n+\t\t\t\ttypes,\n+\t\t\t);\n+\t\t\tlet narrowed_to = types.new_or_type_from_iterator(result);\n+\t\t\tinto.insert(\n+\t\t\t\tcondition,\n+\t\t\t\ttypes.register_type(Type::Narrowed { from: condition, narrowed_to }),\n+\t\t\t);\n \t\t}\n \t}\n }\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -7,8 +7,8 @@ use crate::{\n \tdiagnostics::{TypeCheckError, TypeStringRepresentation},\n \tfeatures::conditional::new_conditional_context,\n \ttypes::{\n-\t\tcast_as_number, cast_as_string, is_type_truthy_falsy, Constructor,\n-\t\tPartiallyAppliedGenerics, TypeStore,\n+\t\tcast_as_number, cast_as_string, helpers::simple_subtype, intrinsics, is_type_truthy_falsy,\n+\t\tConstructor, PartiallyAppliedGenerics, TypeStore,\n \t},\n \tCheckingData, Constant, Decidable, Environment, Type, TypeId,\n };\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -61,9 +61,11 @@ pub fn evaluate_pure_binary_operation_handle_errors<\n \t\t\t\tlhs,\n \t\t\t\toperator,\n \t\t\t\trhs,\n+\t\t\t\tenvironment,\n \t\t\t\t&mut checking_data.types,\n \t\t\t\tchecking_data.options.strict_casts,\n \t\t\t);\n+\n \t\t\tmatch result {\n \t\t\t\tOk(result) => result,\n \t\t\t\tErr(_err) => {\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -96,22 +98,79 @@ pub fn evaluate_pure_binary_operation_handle_errors<\n \t\t}\n \t\tPureBinaryOperation::EqualityAndInequality(operator) => {\n \t\t\t// Cannot error, but can be always true or false\n-\t\t\tevaluate_equality_inequality_operation(\n+\t\t\tlet result = evaluate_equality_inequality_operation(\n \t\t\t\tlhs,\n \t\t\t\t&operator,\n \t\t\t\trhs,\n+\t\t\t\tenvironment,\n \t\t\t\t&mut checking_data.types,\n \t\t\t\tchecking_data.options.strict_casts,\n-\t\t\t)\n+\t\t\t);\n+\n+\t\t\tif let Ok((result, warning)) = result {\n+\t\t\t\tif let EqualityAndInequalityResultKind::Disjoint = warning {\n+\t\t\t\t\tlet position = lhs_pos\n+\t\t\t\t\t\t.without_source()\n+\t\t\t\t\t\t.union(rhs_pos.without_source())\n+\t\t\t\t\t\t.with_source(environment.get_source());\n+\n+\t\t\t\t\tchecking_data.diagnostics_container.add_warning(\n+\t\t\t\t\t\tcrate::TypeCheckWarning::DisjointEquality {\n+\t\t\t\t\t\t\tlhs: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\tlhs,\n+\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\trhs: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\trhs,\n+\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tposition,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t);\n+\t\t\t\t}\n+\n+\t\t\t\tresult\n+\t\t\t} else {\n+\t\t\t\tlet position = lhs_pos\n+\t\t\t\t\t.without_source()\n+\t\t\t\t\t.union(rhs_pos.without_source())\n+\t\t\t\t\t.with_source(environment.get_source());\n+\n+\t\t\t\tchecking_data.diagnostics_container.add_error(\n+\t\t\t\t\tcrate::TypeCheckError::InvalidEqualityOperation {\n+\t\t\t\t\t\toperator,\n+\t\t\t\t\t\tlhs: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\tlhs,\n+\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\trhs: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\trhs,\n+\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t),\n+\t\t\t\t\t\tposition,\n+\t\t\t\t\t},\n+\t\t\t\t);\n+\n+\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t}\n \t\t}\n \t}\n }\n \n-/// TODO proper err\n+/// TODO proper error type\n pub fn evaluate_mathematical_operation(\n \tlhs: TypeId,\n \toperator: MathematicalAndBitwise,\n \trhs: TypeId,\n+\tinfo: &impl crate::context::InformationChain,\n \ttypes: &mut TypeStore,\n \tstrict_casts: bool,\n ) -> Result<TypeId, ()> {\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -187,9 +246,63 @@ pub fn evaluate_mathematical_operation(\n \tlet is_dependent =\n \t\ttypes.get_type_by_id(lhs).is_dependent() || types.get_type_by_id(rhs).is_dependent();\n \n-\t// TODO check sides\n \tif is_dependent {\n-\t\tlet constructor = crate::types::Constructor::BinaryOperator { lhs, operator, rhs };\n+\t\tlet can_be_string = if let MathematicalAndBitwise::Add = operator {\n+\t\t\tlet left_is_string = simple_subtype(lhs, TypeId::STRING_TYPE, info, types);\n+\t\t\tlet right_is_string = simple_subtype(lhs, TypeId::STRING_TYPE, info, types);\n+\t\t\tlet left_is_string_or_number =\n+\t\t\t\tleft_is_string || simple_subtype(lhs, TypeId::NUMBER_TYPE, info, types);\n+\t\t\tlet right_is_string_or_number =\n+\t\t\t\tright_is_string || simple_subtype(rhs, TypeId::NUMBER_TYPE, info, types);\n+\t\t\tif !left_is_string_or_number || !right_is_string_or_number {\n+\t\t\t\treturn Err(());\n+\t\t\t}\n+\t\t\tleft_is_string || right_is_string\n+\t\t} else {\n+\t\t\tlet left_is_number = simple_subtype(lhs, TypeId::NUMBER_TYPE, info, types);\n+\t\t\tif !left_is_number || !simple_subtype(rhs, TypeId::NUMBER_TYPE, info, types) {\n+\t\t\t\treturn Err(());\n+\t\t\t}\n+\t\t\tfalse\n+\t\t};\n+\n+\t\t// :)\n+\t\tif let (MathematicalAndBitwise::Exponent, TypeId::ONE, true) =\n+\t\t\t(operator, rhs, intrinsics::is_not_not_a_number(lhs, types))\n+\t\t{\n+\t\t\treturn Ok(lhs);\n+\t\t} else if let (MathematicalAndBitwise::Add, TypeId::ZERO)\n+\t\t| (MathematicalAndBitwise::Multiply, TypeId::ONE) = (operator, rhs)\n+\t\t{\n+\t\t\treturn Ok(lhs);\n+\t\t} else if let (MathematicalAndBitwise::Add, TypeId::ZERO)\n+\t\t| (MathematicalAndBitwise::Multiply, TypeId::ONE) = (operator, lhs)\n+\t\t{\n+\t\t\treturn Ok(rhs);\n+\t\t}\n+\n+\t\tlet result = if can_be_string {\n+\t\t\tTypeId::STRING_TYPE\n+\t\t} else if let (\n+\t\t\tMathematicalAndBitwise::Add | MathematicalAndBitwise::Multiply,\n+\t\t\tSome(lhs_range),\n+\t\t\tSome(rhs_range),\n+\t\t) = (operator, intrinsics::get_range(lhs, types), intrinsics::get_range(rhs, types))\n+\t\t{\n+\t\t\tmatch operator {\n+\t\t\t\tMathematicalAndBitwise::Add => {\n+\t\t\t\t\tintrinsics::range_to_type(lhs_range.space_addition(rhs_range), types)\n+\t\t\t\t}\n+\t\t\t\tMathematicalAndBitwise::Multiply => {\n+\t\t\t\t\tintrinsics::range_to_type(lhs_range.space_multiplication(rhs_range), types)\n+\t\t\t\t}\n+\t\t\t\t_ => unreachable!(),\n+\t\t\t}\n+\t\t} else {\n+\t\t\tTypeId::NUMBER_TYPE\n+\t\t};\n+\n+\t\tlet constructor = crate::types::Constructor::BinaryOperator { lhs, operator, rhs, result };\n \t\tOk(types.register_type(crate::Type::Constructor(constructor)))\n \t} else {\n \t\tattempt_constant_math_operator(lhs, operator, rhs, types, strict_casts)\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -217,16 +330,23 @@ pub enum CanonicalEqualityAndInequality {\n \tLessThan,\n }\n \n+pub enum EqualityAndInequalityResultKind {\n+\tConstant,\n+\tDisjoint,\n+\tCondition,\n+}\n+\n pub fn evaluate_equality_inequality_operation(\n \tmut lhs: TypeId,\n \toperator: &EqualityAndInequality,\n \tmut rhs: TypeId,\n+\tinfo: &impl crate::context::InformationChain,\n \ttypes: &mut TypeStore,\n \tstrict_casts: bool,\n-) -> TypeId {\n+) -> Result<(TypeId, EqualityAndInequalityResultKind), ()> {\n \t// `NaN == t` is always true\n \tif lhs == TypeId::NAN || rhs == TypeId::NAN {\n-\t\treturn TypeId::FALSE;\n+\t\treturn Ok((TypeId::FALSE, EqualityAndInequalityResultKind::Constant));\n \t}\n \n \tmatch operator {\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -236,8 +356,26 @@ pub fn evaluate_equality_inequality_operation(\n \t\t\tlet left_dependent = types.get_type_by_id(lhs).is_dependent();\n \t\t\tlet is_dependent = left_dependent || types.get_type_by_id(rhs).is_dependent();\n \n-\t\t\t// TODO check lhs and rhs type to see if they overlap\n \t\t\tif is_dependent {\n+\t\t\t\tif lhs == rhs\n+\t\t\t\t\t&& intrinsics::is_not_not_a_number(lhs, types)\n+\t\t\t\t\t&& intrinsics::is_not_not_a_number(rhs, types)\n+\t\t\t\t{\n+\t\t\t\t\t// I think this is okay\n+\t\t\t\t\treturn Ok((TypeId::TRUE, EqualityAndInequalityResultKind::Constant));\n+\t\t\t\t}\n+\n+\t\t\t\t// Checks lhs and rhs type to see if they overlap\n+\t\t\t\tif crate::types::disjoint::types_are_disjoint(\n+\t\t\t\t\tlhs,\n+\t\t\t\t\trhs,\n+\t\t\t\t\t&mut Vec::new(),\n+\t\t\t\t\tinfo,\n+\t\t\t\t\ttypes,\n+\t\t\t\t) {\n+\t\t\t\t\treturn Ok((TypeId::FALSE, EqualityAndInequalityResultKind::Disjoint));\n+\t\t\t\t}\n+\n \t\t\t\t// Sort if `*constant* == ...`. Ideally want constant type on the RHS\n \t\t\t\tlet (lhs, rhs) = if left_dependent { (lhs, rhs) } else { (rhs, rhs) };\n \t\t\t\tlet constructor = crate::types::Constructor::CanonicalRelationOperator {\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -246,10 +384,16 @@ pub fn evaluate_equality_inequality_operation(\n \t\t\t\t\trhs,\n \t\t\t\t};\n \n-\t\t\t\ttypes.register_type(crate::Type::Constructor(constructor))\n+\t\t\t\tOk((\n+\t\t\t\t\ttypes.register_type(crate::Type::Constructor(constructor)),\n+\t\t\t\t\tEqualityAndInequalityResultKind::Condition,\n+\t\t\t\t))\n \t\t\t} else {\n \t\t\t\tmatch attempt_constant_equality(lhs, rhs, types) {\n-\t\t\t\t\tOk(ty) => ty,\n+\t\t\t\t\tOk(ty) => Ok((\n+\t\t\t\t\t\tif ty { TypeId::TRUE } else { TypeId::FALSE },\n+\t\t\t\t\t\tEqualityAndInequalityResultKind::Constant,\n+\t\t\t\t\t)),\n \t\t\t\t\tErr(()) => {\n \t\t\t\t\t\tunreachable!(\n \t\t\t\t\t\t\t\"should have been caught `is_dependent` above, {:?} === {:?}\",\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -266,22 +410,25 @@ pub fn evaluate_equality_inequality_operation(\n \t\t\t\trhs: TypeId,\n \t\t\t\ttypes: &mut TypeStore,\n \t\t\t\tstrict_casts: bool,\n-\t\t\t) -> Result<TypeId, ()> {\n+\t\t\t) -> Result<bool, ()> {\n \t\t\t\t// Similar but reversed semantics to add\n \t\t\t\tmatch (types.get_type_by_id(lhs), types.get_type_by_id(rhs)) {\n-\t\t\t\t\t(Type::Constant(Constant::String(a)), Type::Constant(Constant::String(b))) => {\n+\t\t\t\t\t(\n+\t\t\t\t\t\tType::Constant(Constant::String(string1)),\n+\t\t\t\t\t\tType::Constant(Constant::String(string2)),\n+\t\t\t\t\t) => {\n \t\t\t\t\t\t// Yah rust includes string alphanumerical equivalence of strings\n-\t\t\t\t\t\tOk(types.new_constant_type(Constant::Boolean(a < b)))\n+\t\t\t\t\t\tOk(string1 < string2)\n \t\t\t\t\t}\n \t\t\t\t\t(Type::Constant(c1), Type::Constant(c2)) => {\n \t\t\t\t\t\tlet lhs = cast_as_number(c1, strict_casts)?;\n \t\t\t\t\t\tlet rhs = cast_as_number(c2, strict_casts)?;\n-\t\t\t\t\t\tOk(types.new_constant_type(Constant::Boolean(lhs < rhs)))\n+\t\t\t\t\t\tOk(lhs < rhs)\n \t\t\t\t\t}\n \t\t\t\t\t(lhs, rhs) => {\n \t\t\t\t\t\tcrate::utilities::notify!(\"{:?}\", (lhs, rhs));\n-\t\t\t\t\t\tOk(TypeId::OPEN_BOOLEAN_TYPE)\n-\t\t\t\t\t\t// Err(())\n+\t\t\t\t\t\t// Ok(TypeId::OPEN_BOOLEAN_TYPE)\n+\t\t\t\t\t\tErr(())\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -290,12 +437,12 @@ pub fn evaluate_equality_inequality_operation(\n \t\t\t\t|| types.get_type_by_id(rhs).is_dependent();\n \n \t\t\tif is_dependent {\n-\t\t\t\t// Tidies some things for counting loop iterations\n \t\t\t\t{\n \t\t\t\t\tif let Type::Constructor(Constructor::BinaryOperator {\n \t\t\t\t\t\tlhs: op_lhs,\n \t\t\t\t\t\toperator,\n \t\t\t\t\t\trhs: op_rhs,\n+\t\t\t\t\t\tresult: _,\n \t\t\t\t\t}) = types.get_type_by_id(lhs)\n \t\t\t\t\t{\n \t\t\t\t\t\tif let (\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -311,95 +458,137 @@ pub fn evaluate_equality_inequality_operation(\n \t\t\t\t\t}\n \t\t\t\t}\n \n+\t\t\t\t{\n+\t\t\t\t\t// let lhs = get_constraint(lhs, types).unwrap_or(lhs);\n+\t\t\t\t\t// let rhs = get_constraint(rhs, types).unwrap_or(rhs);\n+\n+\t\t\t\t\tif !simple_subtype(lhs, TypeId::NUMBER_TYPE, info, types)\n+\t\t\t\t\t\t|| !simple_subtype(rhs, TypeId::NUMBER_TYPE, info, types)\n+\t\t\t\t\t{\n+\t\t\t\t\t\treturn Err(());\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Tidies some things for counting loop iterations\n+\n+\t\t\t\t\t// Checking disjoint-ness for inequalities (TODO under option) via distribution\n+\t\t\t\t\tif let (Some(lhs_range), Some(rhs_range)) =\n+\t\t\t\t\t\t(intrinsics::get_range(lhs, types), intrinsics::get_range(rhs, types))\n+\t\t\t\t\t{\n+\t\t\t\t\t\tif lhs_range.below(rhs_range) {\n+\t\t\t\t\t\t\treturn Ok((TypeId::TRUE, EqualityAndInequalityResultKind::Constant));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif lhs_range.above(rhs_range) {\n+\t\t\t\t\t\t\treturn Ok((TypeId::FALSE, EqualityAndInequalityResultKind::Disjoint));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n \t\t\t\tlet constructor = Constructor::CanonicalRelationOperator {\n \t\t\t\t\tlhs,\n \t\t\t\t\toperator: CanonicalEqualityAndInequality::LessThan,\n \t\t\t\t\trhs,\n \t\t\t\t};\n-\t\t\t\ttypes.register_type(crate::Type::Constructor(constructor))\n+\t\t\t\tOk((\n+\t\t\t\t\ttypes.register_type(crate::Type::Constructor(constructor)),\n+\t\t\t\t\tEqualityAndInequalityResultKind::Condition,\n+\t\t\t\t))\n \t\t\t} else {\n-\t\t\t\tlet less_than_result = attempt_less_than(lhs, rhs, types, strict_casts);\n-\t\t\t\tif let Ok(result) = less_than_result {\n-\t\t\t\t\tresult\n-\t\t\t\t} else {\n-\t\t\t\t\tcrate::utilities::notify!(\n-\t\t\t\t\t\t\"Less than unreachable {:?}\",\n-\t\t\t\t\t\t(types.get_type_by_id(lhs), types.get_type_by_id(rhs))\n-\t\t\t\t\t);\n-\t\t\t\t\tTypeId::ERROR_TYPE\n-\t\t\t\t}\n+\t\t\t\tattempt_less_than(lhs, rhs, types, strict_casts).map(|value| {\n+\t\t\t\t\t(\n+\t\t\t\t\t\tif value { TypeId::TRUE } else { TypeId::FALSE },\n+\t\t\t\t\t\tEqualityAndInequalityResultKind::Constant,\n+\t\t\t\t\t)\n+\t\t\t\t})\n \t\t\t}\n \t\t}\n \t\t// equal OR less than\n \t\tEqualityAndInequality::LessThanOrEqual => {\n-\t\t\tlet equality_result = evaluate_equality_inequality_operation(\n+\t\t\tlet (equality_result, warning) = evaluate_equality_inequality_operation(\n \t\t\t\tlhs,\n \t\t\t\t&EqualityAndInequality::StrictEqual,\n \t\t\t\trhs,\n+\t\t\t\tinfo,\n \t\t\t\ttypes,\n \t\t\t\tstrict_casts,\n-\t\t\t);\n+\t\t\t)?;\n \n \t\t\tif equality_result == TypeId::TRUE {\n-\t\t\t\tequality_result\n+\t\t\t\tOk((equality_result, warning))\n \t\t\t} else if equality_result == TypeId::FALSE {\n \t\t\t\tevaluate_equality_inequality_operation(\n \t\t\t\t\tlhs,\n \t\t\t\t\t&EqualityAndInequality::LessThan,\n \t\t\t\t\trhs,\n+\t\t\t\t\tinfo,\n \t\t\t\t\ttypes,\n \t\t\t\t\tstrict_casts,\n \t\t\t\t)\n \t\t\t} else {\n-\t\t\t\tlet less_than_result = evaluate_equality_inequality_operation(\n+\t\t\t\tlet (less_than_result, warning) = evaluate_equality_inequality_operation(\n \t\t\t\t\tlhs,\n \t\t\t\t\t&EqualityAndInequality::LessThan,\n \t\t\t\t\trhs,\n+\t\t\t\t\tinfo,\n \t\t\t\t\ttypes,\n \t\t\t\t\tstrict_casts,\n-\t\t\t\t);\n-\t\t\t\ttypes.new_logical_or_type(equality_result, less_than_result)\n+\t\t\t\t)?;\n+\t\t\t\tOk((types.new_logical_or_type(equality_result, less_than_result), warning))\n \t\t\t}\n \t\t}\n \t\tEqualityAndInequality::StrictNotEqual => {\n-\t\t\tlet equality_result = evaluate_equality_inequality_operation(\n+\t\t\tlet (equality_result, kind) = evaluate_equality_inequality_operation(\n \t\t\t\tlhs,\n \t\t\t\t&EqualityAndInequality::StrictEqual,\n \t\t\t\trhs,\n+\t\t\t\tinfo,\n \t\t\t\ttypes,\n \t\t\t\tstrict_casts,\n-\t\t\t);\n-\t\t\tevaluate_pure_unary_operator(\n-\t\t\t\tPureUnary::LogicalNot,\n-\t\t\t\tequality_result,\n-\t\t\t\ttypes,\n-\t\t\t\tstrict_casts,\n-\t\t\t)\n+\t\t\t)?;\n+\t\t\tif let EqualityAndInequalityResultKind::Condition = kind {\n+\t\t\t\tOk((types.new_logical_negation_type(equality_result), kind))\n+\t\t\t} else {\n+\t\t\t\tlet negated = if let TypeId::TRUE = equality_result {\n+\t\t\t\t\tTypeId::FALSE\n+\t\t\t\t} else if let TypeId::FALSE = equality_result {\n+\t\t\t\t\tTypeId::TRUE\n+\t\t\t\t} else {\n+\t\t\t\t\ttodo!()\n+\t\t\t\t};\n+\t\t\t\tOk((negated, kind))\n+\t\t\t}\n \t\t}\n \t\tEqualityAndInequality::Equal => {\n \t\t\tcrate::utilities::notify!(\"TODO equal operator\");\n-\t\t\tTypeId::OPEN_BOOLEAN_TYPE\n+\t\t\tOk((TypeId::OPEN_BOOLEAN_TYPE, EqualityAndInequalityResultKind::Condition))\n \t\t}\n \t\tEqualityAndInequality::NotEqual => {\n-\t\t\tlet equality_result = evaluate_equality_inequality_operation(\n+\t\t\tlet (equality_result, kind) = evaluate_equality_inequality_operation(\n \t\t\t\tlhs,\n \t\t\t\t&EqualityAndInequality::Equal,\n \t\t\t\trhs,\n+\t\t\t\tinfo,\n \t\t\t\ttypes,\n \t\t\t\tstrict_casts,\n-\t\t\t);\n-\t\t\tevaluate_pure_unary_operator(\n-\t\t\t\tPureUnary::LogicalNot,\n-\t\t\t\tequality_result,\n-\t\t\t\ttypes,\n-\t\t\t\tstrict_casts,\n-\t\t\t)\n+\t\t\t)?;\n+\t\t\tif let EqualityAndInequalityResultKind::Condition = kind {\n+\t\t\t\tOk((types.new_logical_negation_type(equality_result), kind))\n+\t\t\t} else {\n+\t\t\t\tlet negated = if let TypeId::TRUE = equality_result {\n+\t\t\t\t\tTypeId::FALSE\n+\t\t\t\t} else if let TypeId::FALSE = equality_result {\n+\t\t\t\t\tTypeId::TRUE\n+\t\t\t\t} else {\n+\t\t\t\t\ttodo!()\n+\t\t\t\t};\n+\t\t\t\tOk((negated, kind))\n+\t\t\t}\n \t\t}\n \t\t// Swapping operands!\n \t\tEqualityAndInequality::GreaterThan => evaluate_equality_inequality_operation(\n \t\t\trhs,\n \t\t\t&EqualityAndInequality::LessThan,\n \t\t\tlhs,\n+\t\t\tinfo,\n \t\t\ttypes,\n \t\t\tstrict_casts,\n \t\t),\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -408,6 +597,7 @@ pub fn evaluate_equality_inequality_operation(\n \t\t\trhs,\n \t\t\t&EqualityAndInequality::LessThanOrEqual,\n \t\t\tlhs,\n+\t\t\tinfo,\n \t\t\ttypes,\n \t\t\tstrict_casts,\n \t\t),\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -415,25 +605,40 @@ pub fn evaluate_equality_inequality_operation(\n }\n \n #[allow(clippy::let_and_return)]\n-pub fn is_null_or_undefined(ty: TypeId, types: &mut TypeStore) -> TypeId {\n+pub fn is_null_or_undefined(\n+\tty: TypeId,\n+\tinfo: &impl crate::context::InformationChain,\n+\ttypes: &mut TypeStore,\n+) -> TypeId {\n \tlet is_null = evaluate_equality_inequality_operation(\n \t\tty,\n \t\t&EqualityAndInequality::StrictEqual,\n \t\tTypeId::NULL_TYPE,\n+\t\tinfo,\n \t\ttypes,\n \t\tfalse,\n-\t);\n-\t// TODO temp to fix narrowing\n-\t// let is_undefined = evaluate_equality_inequality_operation(\n-\t// \tty,\n-\t// \t&EqualityAndInequality::StrictEqual,\n-\t// \tTypeId::UNDEFINED_TYPE,\n-\t// \ttypes,\n-\t// \tfalse,\n-\t// );\n-\n-\t// types.new_logical_or_type(is_null, is_undefined)\n-\tis_null\n+\t)\n+\t.map_or(TypeId::ERROR_TYPE, |(left, _)| left);\n+\n+\tif let TypeId::TRUE = is_null {\n+\t\tis_null\n+\t} else {\n+\t\tlet is_undefined = evaluate_equality_inequality_operation(\n+\t\t\tty,\n+\t\t\t&EqualityAndInequality::StrictEqual,\n+\t\t\tTypeId::UNDEFINED_TYPE,\n+\t\t\tinfo,\n+\t\t\ttypes,\n+\t\t\tfalse,\n+\t\t)\n+\t\t.map_or(TypeId::ERROR_TYPE, |(left, _)| left);\n+\n+\t\tif let TypeId::FALSE = is_null {\n+\t\t\tis_undefined\n+\t\t} else {\n+\t\t\ttypes.new_logical_or_type(is_null, is_undefined)\n+\t\t}\n+\t}\n }\n \n #[derive(Copy, Clone, Debug)]\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -493,7 +698,8 @@ pub fn evaluate_logical_operation_with_expression<\n \t\t\tchecking_data,\n \t\t)),\n \t\tLogicalOperator::NullCoalescing => {\n-\t\t\tlet is_lhs_null_or_undefined = is_null_or_undefined(lhs.0, &mut checking_data.types);\n+\t\t\tlet is_lhs_null_or_undefined =\n+\t\t\t\tis_null_or_undefined(lhs.0, environment, &mut checking_data.types);\n \t\t\t// Equivalent to: `(lhs is null or undefined) ? lhs : rhs`\n \t\t\tOk(new_conditional_context(\n \t\t\t\tenvironment,\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -529,52 +735,77 @@ pub fn evaluate_logical_operation_with_expression<\n \n /// `typeof` and some others done elsewhere\n #[derive(Clone, Copy, Debug, binary_serialize_derive::BinarySerializable)]\n-pub enum PureUnary {\n+pub enum UnaryOperation {\n+\t/// Treated as `(value ? false : true)`\n \tLogicalNot,\n+\t/// Treated as `0 - value` (could also do -1 * value?)\n \tNegation,\n+\t/// Treated as `value ^ 0xFFFF_FFFF`\n \tBitwiseNot,\n }\n \n-pub fn evaluate_pure_unary_operator(\n-\toperator: PureUnary,\n+/// Tries to evaluate unary operation for constant terms. Else delegates to binary operations that handle equivalent thing\n+pub fn evaluate_unary_operator(\n+\toperator: UnaryOperation,\n \toperand: TypeId,\n+\tinfo: &impl crate::context::InformationChain,\n \ttypes: &mut TypeStore,\n \tstrict_casts: bool,\n-) -> TypeId {\n+) -> Result<TypeId, ()> {\n \tif operand == TypeId::ERROR_TYPE {\n-\t\treturn operand;\n+\t\treturn Ok(operand);\n \t}\n \n \tmatch operator {\n-\t\tPureUnary::LogicalNot => {\n+\t\tUnaryOperation::LogicalNot => {\n \t\t\tif let Decidable::Known(value) = is_type_truthy_falsy(operand, types) {\n \t\t\t\tif value {\n-\t\t\t\t\tTypeId::FALSE\n+\t\t\t\t\tOk(TypeId::FALSE)\n \t\t\t\t} else {\n-\t\t\t\t\tTypeId::TRUE\n+\t\t\t\t\tOk(TypeId::TRUE)\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\ttypes.new_logical_negation_type(operand)\n+\t\t\t\tlet is_boolean = simple_subtype(operand, TypeId::BOOLEAN_TYPE, info, types);\n+\t\t\t\tif is_boolean {\n+\t\t\t\t\tOk(types.new_logical_negation_type(operand))\n+\t\t\t\t} else {\n+\t\t\t\t\tErr(())\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tPureUnary::Negation | PureUnary::BitwiseNot => {\n+\t\tUnaryOperation::Negation | UnaryOperation::BitwiseNot => {\n \t\t\tif let Type::Constant(cst) = types.get_type_by_id(operand) {\n \t\t\t\tlet value = cast_as_number(cst, strict_casts).expect(\"hmm\");\n \t\t\t\tlet value = match operator {\n-\t\t\t\t\tPureUnary::LogicalNot => unreachable!(),\n-\t\t\t\t\tPureUnary::Negation => -value,\n-\t\t\t\t\tPureUnary::BitwiseNot => f64::from(!(value as i32)),\n+\t\t\t\t\tUnaryOperation::BitwiseNot => f64::from(!(value as i32)),\n+\t\t\t\t\tUnaryOperation::Negation => -value,\n+\t\t\t\t\tUnaryOperation::LogicalNot => unreachable!(),\n \t\t\t\t};\n \t\t\t\tlet value = ordered_float::NotNan::try_from(value);\n-\t\t\t\tmatch value {\n+\t\t\t\tOk(match value {\n \t\t\t\t\tOk(value) => types.new_constant_type(Constant::Number(value)),\n \t\t\t\t\tErr(_) => TypeId::NAN,\n-\t\t\t\t}\n+\t\t\t\t})\n \t\t\t} else {\n-\t\t\t\ttypes.register_type(Type::Constructor(crate::types::Constructor::UnaryOperator {\n-\t\t\t\t\toperator,\n-\t\t\t\t\toperand,\n-\t\t\t\t}))\n+\t\t\t\tmatch operator {\n+\t\t\t\t\tUnaryOperation::BitwiseNot => evaluate_mathematical_operation(\n+\t\t\t\t\t\tTypeId::MAX_U32,\n+\t\t\t\t\t\tMathematicalAndBitwise::BitwiseXOr,\n+\t\t\t\t\t\toperand,\n+\t\t\t\t\t\tinfo,\n+\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\tstrict_casts,\n+\t\t\t\t\t),\n+\t\t\t\t\tUnaryOperation::Negation => evaluate_mathematical_operation(\n+\t\t\t\t\t\tTypeId::ZERO,\n+\t\t\t\t\t\tMathematicalAndBitwise::Subtract,\n+\t\t\t\t\t\toperand,\n+\t\t\t\t\t\tinfo,\n+\t\t\t\t\t\ttypes,\n+\t\t\t\t\t\tstrict_casts,\n+\t\t\t\t\t),\n+\t\t\t\t\tUnaryOperation::LogicalNot => unreachable!(\"handled above\"),\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -583,28 +814,24 @@ pub fn evaluate_pure_unary_operator(\n /// Returns whether lhs and rhs are always equal or never equal. TODO more\n ///\n /// TODO return decidable.\n-fn attempt_constant_equality(\n-\tlhs: TypeId,\n-\trhs: TypeId,\n-\ttypes: &mut TypeStore,\n-) -> Result<TypeId, ()> {\n-\tlet are_equal = if lhs == rhs {\n-\t\ttrue\n+fn attempt_constant_equality(lhs: TypeId, rhs: TypeId, types: &mut TypeStore) -> Result<bool, ()> {\n+\tif lhs == rhs {\n+\t\tOk(true)\n \t} else if matches!(lhs, TypeId::NULL_TYPE | TypeId::UNDEFINED_TYPE)\n \t\t|| matches!(rhs, TypeId::NULL_TYPE | TypeId::UNDEFINED_TYPE)\n \t{\n \t\t// If above `==`` failed => false (as always have same `TypeId`)\n-\t\tfalse\n+\t\tOk(false)\n \t} else {\n \t\tlet lhs = types.get_type_by_id(lhs);\n \t\tlet rhs = types.get_type_by_id(rhs);\n \t\tif let (Type::Constant(cst1), Type::Constant(cst2)) = (lhs, rhs) {\n-\t\t\tcst1 == cst2\n+\t\t\tOk(cst1 == cst2)\n \t\t} else if let (Type::Object(..) | Type::SpecialObject(SpecialObject::Function(..)), _)\n \t\t| (_, Type::Object(..) | Type::SpecialObject(SpecialObject::Function(..))) = (lhs, rhs)\n \t\t{\n \t\t\t// Same objects and functions always have same type id. Poly case doesn't occur here\n-\t\t\tfalse\n+\t\t\tOk(false)\n \t\t}\n \t\t// Temp fix for closures\n \t\telse if let (\ndiff --git a/checker/src/features/operations.rs b/checker/src/features/operations.rs\n--- a/checker/src/features/operations.rs\n+++ b/checker/src/features/operations.rs\n@@ -613,12 +840,10 @@ fn attempt_constant_equality(\n \t\t) = (lhs, rhs)\n \t\t{\n \t\t\t// TODO does this work?\n-\t\t\treturn attempt_constant_equality(*on_lhs, *on_rhs, types);\n+\t\t\tattempt_constant_equality(*on_lhs, *on_rhs, types)\n \t\t} else {\n \t\t\tcrate::utilities::notify!(\"{:?} === {:?} is apparently false\", lhs, rhs);\n-\t\t\treturn Err(());\n+\t\t\tErr(())\n \t\t}\n-\t};\n-\n-\tOk(types.new_constant_type(Constant::Boolean(are_equal)))\n+\t}\n }\ndiff --git a/checker/src/features/template_literal.rs b/checker/src/features/template_literal.rs\n--- a/checker/src/features/template_literal.rs\n+++ b/checker/src/features/template_literal.rs\n@@ -8,7 +8,7 @@ use crate::{\n \t\t\tapplication_result_to_return_type, Callable, CallingContext, CallingInput,\n \t\t\tSynthesisedArgument,\n \t\t},\n-\t\tcast_as_string, TypeStore,\n+\t\tcast_as_string,\n \t},\n \tCheckingData, Constant, Environment, Type, TypeId,\n };\ndiff --git a/checker/src/features/template_literal.rs b/checker/src/features/template_literal.rs\n--- a/checker/src/features/template_literal.rs\n+++ b/checker/src/features/template_literal.rs\n@@ -146,6 +146,7 @@ where\n \t\t\t\tacc,\n \t\t\t\tcrate::features::operations::MathematicalAndBitwise::Add,\n \t\t\t\tlhs,\n+\t\t\t\tenvironment,\n \t\t\t\t&mut checking_data.types,\n \t\t\t\tchecking_data.options.strict_casts,\n \t\t\t);\ndiff --git a/checker/src/features/template_literal.rs b/checker/src/features/template_literal.rs\n--- a/checker/src/features/template_literal.rs\n+++ b/checker/src/features/template_literal.rs\n@@ -153,7 +154,7 @@ where\n \t\t\t\tacc = result;\n \t\t\t} else {\n \t\t\t\tcrate::utilities::notify!(\"Invalid template literal concatenation\");\n-\t\t\t\treturn TypeId::ERROR_TYPE;\n+\t\t\t\treturn TypeId::UNIMPLEMENTED_ERROR_TYPE;\n \t\t\t}\n \t\t\tlet rhs = A::synthesise_multiple_expression(\n \t\t\t\tdynamic_part,\ndiff --git a/checker/src/features/template_literal.rs b/checker/src/features/template_literal.rs\n--- a/checker/src/features/template_literal.rs\n+++ b/checker/src/features/template_literal.rs\n@@ -165,6 +166,7 @@ where\n \t\t\t\tacc,\n \t\t\t\tcrate::features::operations::MathematicalAndBitwise::Add,\n \t\t\t\trhs,\n+\t\t\t\tenvironment,\n \t\t\t\t&mut checking_data.types,\n \t\t\t\tchecking_data.options.strict_casts,\n \t\t\t);\ndiff --git a/checker/src/features/template_literal.rs b/checker/src/features/template_literal.rs\n--- a/checker/src/features/template_literal.rs\n+++ b/checker/src/features/template_literal.rs\n@@ -172,7 +174,7 @@ where\n \t\t\t\tacc = result;\n \t\t\t} else {\n \t\t\t\tcrate::utilities::notify!(\"Invalid template literal concatenation\");\n-\t\t\t\treturn TypeId::ERROR_TYPE;\n+\t\t\t\treturn TypeId::UNIMPLEMENTED_ERROR_TYPE;\n \t\t\t}\n \t\t}\n \t\tif final_part.is_empty() {\ndiff --git a/checker/src/features/template_literal.rs b/checker/src/features/template_literal.rs\n--- a/checker/src/features/template_literal.rs\n+++ b/checker/src/features/template_literal.rs\n@@ -184,6 +186,7 @@ where\n \t\t\t\tacc,\n \t\t\t\tcrate::features::operations::MathematicalAndBitwise::Add,\n \t\t\t\tvalue,\n+\t\t\t\tenvironment,\n \t\t\t\t&mut checking_data.types,\n \t\t\t\tchecking_data.options.strict_casts,\n \t\t\t);\ndiff --git a/checker/src/features/template_literal.rs b/checker/src/features/template_literal.rs\n--- a/checker/src/features/template_literal.rs\n+++ b/checker/src/features/template_literal.rs\n@@ -191,47 +194,8 @@ where\n \t\t\t\tresult\n \t\t\t} else {\n \t\t\t\tcrate::utilities::notify!(\"Invalid template literal concatenation\");\n-\t\t\t\tTypeId::ERROR_TYPE\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-/// **Expects static part first**\n-///\n-/// TODO API is different to the `synthesise_template_literal_expression` above\n-pub fn synthesize_template_literal_type(parts: Vec<TypeId>, types: &mut TypeStore) -> TypeId {\n-\tlet mut parts_iter = parts.into_iter();\n-\tif let Some(first) = parts_iter.next() {\n-\t\tlet mut acc = first;\n-\t\tfor other in parts_iter {\n-\t\t\t// TODO unfold_alias function\n-\t\t\tlet other = if let Type::AliasTo { to, .. } = types.get_type_by_id(other) {\n-\t\t\t\t*to\n-\t\t\t} else {\n-\t\t\t\tother\n-\t\t\t};\n-\t\t\tlet result = super::operations::evaluate_mathematical_operation(\n-\t\t\t\tacc,\n-\t\t\t\tcrate::features::operations::MathematicalAndBitwise::Add,\n-\t\t\t\tother,\n-\t\t\t\ttypes,\n-\t\t\t\ttrue,\n-\t\t\t);\n-\t\t\tmatch result {\n-\t\t\t\tOk(result) => acc = result,\n-\t\t\t\tErr(()) => {\n-\t\t\t\t\t// crate::utilities::notify!(\n-\t\t\t\t\t// \t\"acc is {:?}, other is {:?}\",\n-\t\t\t\t\t// \ttypes.get_type_by_id(acc),\n-\t\t\t\t\t// \ttypes.get_type_by_id(other)\n-\t\t\t\t\t// );\n-\t\t\t\t\tcrate::utilities::notify!(\"Invalid type template literal concatenation\");\n-\t\t\t\t}\n+\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t}\n \t\t}\n-\t\tacc\n-\t} else {\n-\t\ttypes.new_constant_type(Constant::String(String::new()))\n \t}\n }\ndiff --git a/checker/src/features/variables.rs b/checker/src/features/variables.rs\n--- a/checker/src/features/variables.rs\n+++ b/checker/src/features/variables.rs\n@@ -157,7 +157,7 @@ pub fn get_new_register_argument_under<T: crate::ReadFromFS, A: crate::ASTImplem\n \t\t\t\t\tLogical::BasedOnKey { .. } => todo!(),\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t}\n \t\t} else {\n \t\t\tlet keys;\ndiff --git a/checker/src/synthesis/classes.rs b/checker/src/synthesis/classes.rs\n--- a/checker/src/synthesis/classes.rs\n+++ b/checker/src/synthesis/classes.rs\n@@ -191,6 +191,8 @@ fn synthesise_class_declaration_extends_and_members<\n \t\t\t\t\t}\n \t\t\t\t};\n \n+\t\t\t\tcrate::utilities::notify!(\"{:?}\", (getter_setter, is_async, is_generator));\n+\n \t\t\t\tlet internal_marker = if let (true, ParserPropertyKey::Identifier(name, _, _)) =\n \t\t\t\t\t(is_declare, method.name.get_ast_ref())\n \t\t\t\t{\ndiff --git a/checker/src/synthesis/classes.rs b/checker/src/synthesis/classes.rs\n--- a/checker/src/synthesis/classes.rs\n+++ b/checker/src/synthesis/classes.rs\n@@ -360,6 +362,10 @@ fn synthesise_class_declaration_extends_and_members<\n \t// Adds event\n \tenvironment.register_constructable_function(class_variable_type, function_id);\n \n+\tif let Some(variable) = class.name.get_variable_id(environment.get_source()) {\n+\t\tenvironment.info.variable_current_value.insert(variable, class_variable_type);\n+\t}\n+\n \tcrate::utilities::notify!(\"At end {:?}\", environment.context_type.free_variables);\n \n \t{\ndiff --git a/checker/src/synthesis/classes.rs b/checker/src/synthesis/classes.rs\n--- a/checker/src/synthesis/classes.rs\n+++ b/checker/src/synthesis/classes.rs\n@@ -451,7 +457,7 @@ fn synthesise_class_declaration_extends_and_members<\n \t\t\t\t\t\t\tsynthesise_type_annotation(type_annotation, environment, checking_data)\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tcrate::utilities::notify!(\"Declare without type annotation\");\n-\t\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\tTypeId::UNDEFINED_TYPE\ndiff --git a/checker/src/synthesis/classes.rs b/checker/src/synthesis/classes.rs\n--- a/checker/src/synthesis/classes.rs\n+++ b/checker/src/synthesis/classes.rs\n@@ -480,10 +486,6 @@ fn synthesise_class_declaration_extends_and_members<\n \t\t}\n \t}\n \n-\tif let Some(variable) = class.name.get_variable_id(environment.get_source()) {\n-\t\tenvironment.info.variable_current_value.insert(variable, class_variable_type);\n-\t}\n-\n \tclass_variable_type\n }\n \ndiff --git a/checker/src/synthesis/classes.rs b/checker/src/synthesis/classes.rs\n--- a/checker/src/synthesis/classes.rs\n+++ b/checker/src/synthesis/classes.rs\n@@ -609,12 +611,20 @@ fn register_extends_and_member<T: crate::ReadFromFS>(\n \t\t\t\t\tenvironment,\n \t\t\t\t);\n \n+\t\t\t\tlet (getter_setter, is_async, is_generator) = match &method.header {\n+\t\t\t\t\tMethodHeader::Get => (Some(GetterSetter::Getter), false, false),\n+\t\t\t\t\tMethodHeader::Set => (Some(GetterSetter::Setter), false, false),\n+\t\t\t\t\tMethodHeader::Regular { is_async, generator } => {\n+\t\t\t\t\t\t(None, *is_async, generator.is_some())\n+\t\t\t\t\t}\n+\t\t\t\t};\n+\n \t\t\t\tlet value = build_overloaded_function(\n \t\t\t\t\tFunctionId(environment.get_source(), method.position.start),\n \t\t\t\t\tcrate::types::functions::FunctionBehavior::Method {\n \t\t\t\t\t\tfree_this_id: TypeId::ANY_TYPE,\n-\t\t\t\t\t\tis_async: method.header.is_async(),\n-\t\t\t\t\t\tis_generator: method.header.is_generator(),\n+\t\t\t\t\t\tis_async,\n+\t\t\t\t\t\tis_generator,\n \t\t\t\t\t\t// TODO\n \t\t\t\t\t\tname: TypeId::ANY_TYPE,\n \t\t\t\t\t},\ndiff --git a/checker/src/synthesis/classes.rs b/checker/src/synthesis/classes.rs\n--- a/checker/src/synthesis/classes.rs\n+++ b/checker/src/synthesis/classes.rs\n@@ -640,12 +650,17 @@ fn register_extends_and_member<T: crate::ReadFromFS>(\n \t\t\t\tif *initial_is_static {\n \t\t\t\t\tcrate::utilities::notify!(\"TODO static item?\");\n \t\t\t\t} else {\n-\t\t\t\t\tenvironment.info.register_property_on_type(\n-\t\t\t\t\t\tclass_type,\n-\t\t\t\t\t\tpublicity,\n-\t\t\t\t\t\tunder,\n-\t\t\t\t\t\tPropertyValue::Value(value),\n-\t\t\t\t\t);\n+\t\t\t\t\tuse crate::types::calling::Callable;\n+\t\t\t\t\tlet value = match getter_setter {\n+\t\t\t\t\t\tSome(GetterSetter::Getter) => {\n+\t\t\t\t\t\t\tPropertyValue::Getter(Callable::from_type(value, &checking_data.types))\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tSome(GetterSetter::Setter) => {\n+\t\t\t\t\t\t\tPropertyValue::Setter(Callable::from_type(value, &checking_data.types))\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tNone => PropertyValue::Value(value),\n+\t\t\t\t\t};\n+\t\t\t\t\tenvironment.info.register_property_on_type(class_type, publicity, under, value);\n \t\t\t\t}\n \t\t\t}\n \t\t\tClassMember::Property(is_static, property) => {\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -33,8 +33,8 @@ use crate::{\n \t\toperations::is_null_or_undefined,\n \t\toperations::{\n \t\t\tevaluate_logical_operation_with_expression,\n-\t\t\tevaluate_pure_binary_operation_handle_errors, evaluate_pure_unary_operator,\n-\t\t\tEqualityAndInequality, MathematicalAndBitwise, PureUnary,\n+\t\t\tevaluate_pure_binary_operation_handle_errors, evaluate_unary_operator,\n+\t\t\tEqualityAndInequality, MathematicalAndBitwise, UnaryOperation,\n \t\t},\n \t\ttemplate_literal::synthesise_template_literal_expression,\n \t\tvariables::VariableWithValue,\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -100,8 +100,8 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\tOk(regexp) => Instance::RValue(regexp),\n \t\t\t\tErr(error) => {\n \t\t\t\t\tchecking_data.diagnostics_container.add_error(\n-\t\t\t\t\t\tcrate::diagnostics::TypeCheckError::InvalidRegexp(\n-\t\t\t\t\t\t\tcrate::diagnostics::InvalidRegexp {\n+\t\t\t\t\t\tcrate::diagnostics::TypeCheckError::InvalidRegExp(\n+\t\t\t\t\t\t\tcrate::diagnostics::InvalidRegExp {\n \t\t\t\t\t\t\t\terror,\n \t\t\t\t\t\t\t\tposition: position.with_source(environment.get_source()),\n \t\t\t\t\t\t\t},\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -117,7 +117,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\tv.try_into().unwrap()\n \t\t\t} else {\n \t\t\t\tcrate::utilities::notify!(\"TODO big int\");\n-\t\t\t\treturn TypeId::ERROR_TYPE;\n+\t\t\t\treturn TypeId::UNIMPLEMENTED_ERROR_TYPE;\n \t\t\t};\n \t\t\t// if not_nan == 6. {\n \t\t\t// \tcrate::utilities::notify!(\"{:?}\", environment.get_all_named_types());\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -170,7 +170,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\t\tPropertyKey::Type(TypeId::NUMBER_TYPE)\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t};\n-\t\t\t\t\t\tSome((property, TypeId::ERROR_TYPE))\n+\t\t\t\t\t\tSome((property, TypeId::UNIMPLEMENTED_ERROR_TYPE))\n \t\t\t\t\t}\n \t\t\t\t\tFunctionArgument::Comment { .. } => None,\n \t\t\t\t})\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -313,7 +313,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\"special operations\",\n \t\t\t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\t\t);\n-\t\t\t\t\treturn TypeId::ERROR_TYPE;\n+\t\t\t\t\treturn TypeId::UNIMPLEMENTED_ERROR_TYPE;\n \t\t\t\t}\n \t\t\t};\n \t\t\tInstance::RValue(evaluate_pure_binary_operation_handle_errors(\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -343,28 +343,47 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\t\"Unary plus operator\",\n \t\t\t\t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\t\t\t);\n-\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tUnaryOperator::Negation | UnaryOperator::BitwiseNot | UnaryOperator::LogicalNot => {\n-\t\t\t\t\tlet operand_type = synthesise_expression(\n+\t\t\t\t\tlet operand = synthesise_expression(\n \t\t\t\t\t\toperand,\n \t\t\t\t\t\tenvironment,\n \t\t\t\t\t\tchecking_data,\n \t\t\t\t\t\tTypeId::ANY_TYPE,\n \t\t\t\t\t);\n \t\t\t\t\tlet operator = match operator {\n-\t\t\t\t\t\tUnaryOperator::Negation => PureUnary::Negation,\n-\t\t\t\t\t\tUnaryOperator::BitwiseNot => PureUnary::BitwiseNot,\n-\t\t\t\t\t\tUnaryOperator::LogicalNot => PureUnary::LogicalNot,\n+\t\t\t\t\t\tUnaryOperator::Negation => UnaryOperation::Negation,\n+\t\t\t\t\t\tUnaryOperator::BitwiseNot => UnaryOperation::BitwiseNot,\n+\t\t\t\t\t\tUnaryOperator::LogicalNot => UnaryOperation::LogicalNot,\n \t\t\t\t\t\t_ => unreachable!(),\n \t\t\t\t\t};\n-\t\t\t\t\tInstance::RValue(evaluate_pure_unary_operator(\n+\t\t\t\t\t// TODO abstract handling?\n+\t\t\t\t\tlet result = evaluate_unary_operator(\n \t\t\t\t\t\toperator,\n-\t\t\t\t\t\toperand_type,\n+\t\t\t\t\t\toperand,\n+\t\t\t\t\t\tenvironment,\n \t\t\t\t\t\t&mut checking_data.types,\n \t\t\t\t\t\tchecking_data.options.strict_casts,\n-\t\t\t\t\t))\n+\t\t\t\t\t);\n+\t\t\t\t\tif let Ok(result) = result {\n+\t\t\t\t\t\tInstance::RValue(result)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n+\t\t\t\t\t\t\tTypeCheckError::InvalidUnaryOperation {\n+\t\t\t\t\t\t\t\toperator,\n+\t\t\t\t\t\t\t\toperand: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\toperand,\n+\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\t\tfalse,\n+\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\tposition: position.with_source(environment.get_source()),\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\tInstance::RValue(TypeId::ERROR_TYPE)\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tUnaryOperator::Await => {\n \t\t\t\t\t// TODO get promise T\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -496,7 +515,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\"yield expression\",\n \t\t\t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\t\t);\n-\t\t\t\t\treturn TypeId::ERROR_TYPE;\n+\t\t\t\t\treturn TypeId::UNIMPLEMENTED_ERROR_TYPE;\n \t\t\t\t}\n \t\t\t}\n \t\t}\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -537,7 +556,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\"Invert operator\",\n \t\t\t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\t\t);\n-\t\t\t\t\treturn TypeId::ERROR_TYPE;\n+\t\t\t\t\treturn TypeId::UNIMPLEMENTED_ERROR_TYPE;\n \t\t\t\t}\n \t\t\t\tUnaryPrefixAssignmentOperator::IncrementOrDecrement(direction) => {\n \t\t\t\t\treturn environment.assign_handle_errors(\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -614,7 +633,11 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \n \t\t\tlet site = position.with_source(environment.get_source());\n \t\t\tif *is_optional {\n-\t\t\t\tlet null_or_undefined = is_null_or_undefined(on, &mut checking_data.types);\n+\t\t\t\tlet null_or_undefined =\n+\t\t\t\t\tis_null_or_undefined(on, environment, &mut checking_data.types);\n+\n+\t\t\t\t// crate::utilities::notify!(\"{:?}\", null_or_undefined);\n+\n \t\t\t\tInstance::RValue(new_conditional_context(\n \t\t\t\t\tenvironment,\n \t\t\t\t\t(null_or_undefined, parent.get_position()),\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -622,6 +645,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\t\t\tTypeId::UNDEFINED_TYPE\n \t\t\t\t\t},\n \t\t\t\t\tSome(|env: &mut Environment, data: &mut CheckingData<T, EznoParser>| {\n+\t\t\t\t\t\tlet on = env.info.narrowed_values.get(&on).copied().unwrap_or(on);\n \t\t\t\t\t\tlet result = env.get_property_handle_errors(\n \t\t\t\t\t\t\ton,\n \t\t\t\t\t\t\tpublicity,\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -661,7 +685,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \n \t\t\tif *is_optional {\n \t\t\t\tlet null_or_undefined =\n-\t\t\t\t\tis_null_or_undefined(being_indexed, &mut checking_data.types);\n+\t\t\t\t\tis_null_or_undefined(being_indexed, environment, &mut checking_data.types);\n \t\t\t\tInstance::RValue(new_conditional_context(\n \t\t\t\t\tenvironment,\n \t\t\t\t\t(null_or_undefined, indexee.get_position()),\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -756,19 +780,19 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\t\"Property access on super\",\n \t\t\t\t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\t\t\t);\n-\t\t\t\t\t\treturn TypeId::ERROR_TYPE;\n+\t\t\t\t\t\treturn TypeId::UNIMPLEMENTED_ERROR_TYPE;\n \t\t\t\t\t}\n \t\t\t\t\tSuperReference::Index { indexer: _ } => {\n \t\t\t\t\t\tchecking_data.raise_unimplemented_error(\n \t\t\t\t\t\t\t\"Index on super\",\n \t\t\t\t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\t\t\t);\n-\t\t\t\t\t\treturn TypeId::ERROR_TYPE;\n+\t\t\t\t\t\treturn TypeId::UNIMPLEMENTED_ERROR_TYPE;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tcrate::utilities::notify!(\"TODO error\");\n-\t\t\t\tInstance::RValue(TypeId::ERROR_TYPE)\n+\t\t\t\tInstance::RValue(TypeId::UNIMPLEMENTED_ERROR_TYPE)\n \t\t\t}\n \t\t}\n \t\tExpression::NewTarget(..) => {\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -1001,7 +1025,7 @@ pub(super) fn synthesise_expression<T: crate::ReadFromFS>(\n \t\t\t\t\"dynamic import\",\n \t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t);\n-\t\t\treturn TypeId::ERROR_TYPE;\n+\t\t\treturn TypeId::UNIMPLEMENTED_ERROR_TYPE;\n \t\t}\n \t\tExpression::IsExpression(is_expr) => {\n \t\t\tInstance::RValue(synthesise_is_expression(is_expr, environment, checking_data))\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -1285,7 +1309,7 @@ pub(super) fn synthesise_object_literal<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\tpos.with_source(environment.get_source()),\n \t\t\t\t\t\t);\n \n-\t\t\t\t\t\treturn TypeId::ERROR_TYPE;\n+\t\t\t\t\t\treturn TypeId::UNIMPLEMENTED_ERROR_TYPE;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\ndiff --git a/checker/src/synthesis/expressions.rs b/checker/src/synthesis/expressions.rs\n--- a/checker/src/synthesis/expressions.rs\n+++ b/checker/src/synthesis/expressions.rs\n@@ -1299,13 +1323,7 @@ pub(super) fn synthesise_object_literal<T: crate::ReadFromFS>(\n \t\t\t\tlet value = match get_variable {\n \t\t\t\t\tOk(VariableWithValue(_variable, value)) => value,\n \t\t\t\t\tErr(_err) => {\n-\t\t\t\t\t\t// checking_data.diagnostics_container.add_error(\n-\t\t\t\t\t\t// \tTypeCheckError::CouldNotFindVariable {\n-\t\t\t\t\t\t// \t\tvariable: err.name,\n-\t\t\t\t\t\t// \t\tpossibles: err.possibles,\n-\t\t\t\t\t\t// \t\tposition: position.clone(),\n-\t\t\t\t\t\t// \t},\n-\t\t\t\t\t\t// );\n+\t\t\t\t\t\t// missing handled above\n \t\t\t\t\t\tTypeId::ERROR_TYPE\n \t\t\t\t\t}\n \t\t\t\t};\ndiff --git a/checker/src/synthesis/extensions/jsx.rs b/checker/src/synthesis/extensions/jsx.rs\n--- a/checker/src/synthesis/extensions/jsx.rs\n+++ b/checker/src/synthesis/extensions/jsx.rs\n@@ -31,7 +31,7 @@ pub(crate) fn synthesise_jsx_root<T: crate::ReadFromFS>(\n \t\t\t\t\"JSX fragment\",\n \t\t\t\tfragment.get_position().with_source(environment.get_source()),\n \t\t\t);\n-\t\t\tTypeId::ERROR_TYPE\n+\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t}\n \t}\n }\ndiff --git a/checker/src/synthesis/extensions/jsx.rs b/checker/src/synthesis/extensions/jsx.rs\n--- a/checker/src/synthesis/extensions/jsx.rs\n+++ b/checker/src/synthesis/extensions/jsx.rs\n@@ -502,14 +502,14 @@ fn synthesise_attribute<T: crate::ReadFromFS>(\n \t\t\t\t\"spread JSX attribute\",\n \t\t\t\tpos.with_source(environment.get_source()),\n \t\t\t);\n-\t\t\treturn (PropertyKey::String(Cow::Borrowed(\"err\")), TypeId::ERROR_TYPE);\n+\t\t\treturn (PropertyKey::String(Cow::Borrowed(\"err\")), TypeId::UNIMPLEMENTED_ERROR_TYPE);\n \t\t}\n \t\tJSXAttribute::Shorthand(expr) => {\n \t\t\tchecking_data.raise_unimplemented_error(\n \t\t\t\t\"shorthand JSX attribute\",\n \t\t\t\texpr.get_position().with_source(environment.get_source()),\n \t\t\t);\n-\t\t\treturn (PropertyKey::String(Cow::Borrowed(\"err\")), TypeId::ERROR_TYPE);\n+\t\t\treturn (PropertyKey::String(Cow::Borrowed(\"err\")), TypeId::UNIMPLEMENTED_ERROR_TYPE);\n \t\t}\n \t};\n \ndiff --git a/checker/src/synthesis/hoisting.rs b/checker/src/synthesis/hoisting.rs\n--- a/checker/src/synthesis/hoisting.rs\n+++ b/checker/src/synthesis/hoisting.rs\n@@ -618,11 +618,11 @@ pub(crate) fn hoist_statements<T: crate::ReadFromFS>(\n \t\t\t\t\t\tlet value = super::functions::build_overloaded_function(\n \t\t\t\t\t\t\tcrate::FunctionId(environment.get_source(), function.position.start),\n \t\t\t\t\t\t\tcrate::types::functions::FunctionBehavior::Function {\n-\t\t\t\t\t\t\t\tthis_id: TypeId::ERROR_TYPE,\n-\t\t\t\t\t\t\t\tprototype: TypeId::ERROR_TYPE,\n+\t\t\t\t\t\t\t\tthis_id: TypeId::IS_ASSIGNED_VALUE_LATER,\n+\t\t\t\t\t\t\t\tprototype: TypeId::IS_ASSIGNED_VALUE_LATER,\n \t\t\t\t\t\t\t\tis_async: function.header.is_async(),\n \t\t\t\t\t\t\t\tis_generator: function.header.is_generator(),\n-\t\t\t\t\t\t\t\tname: TypeId::ERROR_TYPE,\n+\t\t\t\t\t\t\t\tname: TypeId::IS_ASSIGNED_VALUE_LATER,\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t\toverloads,\n \t\t\t\t\t\t\tactual,\ndiff --git a/checker/src/synthesis/interfaces.rs b/checker/src/synthesis/interfaces.rs\n--- a/checker/src/synthesis/interfaces.rs\n+++ b/checker/src/synthesis/interfaces.rs\n@@ -9,8 +9,9 @@ use crate::{\n \tsynthesis::parser_property_key_to_checker_property_key,\n \ttypes::{\n \t\tcalling::Callable,\n+\t\thelpers::references_key_of,\n \t\tproperties::{Descriptor, PropertyKey, PropertyValue, Publicity},\n-\t\treferences_key_of, FunctionType, Type,\n+\t\tFunctionType, Type,\n \t},\n \tCheckingData, Scope, TypeId,\n };\ndiff --git a/checker/src/synthesis/interfaces.rs b/checker/src/synthesis/interfaces.rs\n--- a/checker/src/synthesis/interfaces.rs\n+++ b/checker/src/synthesis/interfaces.rs\n@@ -206,7 +207,7 @@ pub(super) fn synthesise_signatures<T: crate::ReadFromFS, B: SynthesiseInterface\n \t\t\t\t\t\t\tis_async: header.is_async(),\n \t\t\t\t\t\t\tis_generator: header.is_generator(),\n \t\t\t\t\t\t\t// TODO ...\n-\t\t\t\t\t\t\tfree_this_id: TypeId::ERROR_TYPE,\n+\t\t\t\t\t\t\tfree_this_id: TypeId::UNIMPLEMENTED_ERROR_TYPE,\n \t\t\t\t\t\t\tname: TypeId::EMPTY_STRING,\n \t\t\t\t\t\t}\n \t\t\t\t\t};\ndiff --git a/checker/src/synthesis/interfaces.rs b/checker/src/synthesis/interfaces.rs\n--- a/checker/src/synthesis/interfaces.rs\n+++ b/checker/src/synthesis/interfaces.rs\n@@ -410,7 +411,9 @@ pub(super) fn synthesise_signatures<T: crate::ReadFromFS, B: SynthesiseInterface\n \t\tlet interface_type = behavior.interface_type().unwrap();\n \n \t\tenvironment.new_lexical_environment_fold_into_parent(\n-\t\t\tcrate::Scope::InterfaceEnvironment { this_constraint: TypeId::ERROR_TYPE },\n+\t\t\tcrate::Scope::InterfaceEnvironment {\n+\t\t\t\tthis_constraint: TypeId::UNIMPLEMENTED_ERROR_TYPE,\n+\t\t\t},\n \t\t\tchecking_data,\n \t\t\t|environment, checking_data| {\n \t\t\t\tlet parameter_types =\ndiff --git a/checker/src/synthesis/mod.rs b/checker/src/synthesis/mod.rs\n--- a/checker/src/synthesis/mod.rs\n+++ b/checker/src/synthesis/mod.rs\n@@ -266,7 +266,7 @@ pub(super) fn parser_property_key_to_checker_property_key<\n \t\t\t\t\t\"big int as property key\",\n \t\t\t\t\tpos.with_source(environment.get_source()),\n \t\t\t\t);\n-\t\t\t\tPropertyKey::Type(TypeId::ERROR_TYPE)\n+\t\t\t\tPropertyKey::Type(TypeId::UNIMPLEMENTED_ERROR_TYPE)\n \t\t\t}\n \t\t}\n \t\tParserPropertyKey::Computed(expression, _) => {\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -12,7 +12,7 @@ use crate::{\n \ttypes::{\n \t\tgenerics::generic_type_arguments::GenericArguments,\n \t\tproperties::{PropertyKey, PropertyValue, Publicity},\n-\t\tConstant, Constructor, PartiallyAppliedGenerics, Type, TypeId,\n+\t\tConstant, Constructor, PartiallyAppliedGenerics, PolyNature, Type, TypeId,\n \t},\n \ttypes::{\n \t\tgenerics::ExplicitTypeArguments,\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -111,56 +111,7 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tTypeAnnotation::Union(type_annotations, _) => {\n-\t\t\tlet iterator = type_annotations\n-\t\t\t\t.iter()\n-\t\t\t\t.map(|type_annotation| {\n-\t\t\t\t\tsynthesise_type_annotation(type_annotation, environment, checking_data)\n-\t\t\t\t})\n-\t\t\t\t.collect::<Vec<_>>()\n-\t\t\t\t.into_iter();\n-\n-\t\t\titerator\n-\t\t\t\t.reduce(|acc, right| checking_data.types.new_or_type(acc, right))\n-\t\t\t\t.expect(\"Empty union\")\n-\t\t}\n-\t\tTypeAnnotation::Intersection(type_annotations, position) => {\n-\t\t\tlet mut iterator = type_annotations\n-\t\t\t\t.iter()\n-\t\t\t\t.map(|type_annotation| {\n-\t\t\t\t\tsynthesise_type_annotation(type_annotation, environment, checking_data)\n-\t\t\t\t})\n-\t\t\t\t.collect::<Vec<_>>()\n-\t\t\t\t.into_iter();\n-\n-\t\t\tlet mut acc = iterator.next().expect(\"Empty intersection\");\n-\t\t\tfor right in iterator {\n-\t\t\t\tif let Ok(new_ty) = checking_data.types.new_and_type(acc, right) {\n-\t\t\t\t\tacc = new_ty;\n-\t\t\t\t} else {\n-\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n-\t\t\t\t\t\tTypeCheckWarning::TypesDoNotIntersect {\n-\t\t\t\t\t\t\tleft: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\t\tacc,\n-\t\t\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\t\t\t&checking_data.types,\n-\t\t\t\t\t\t\t\tchecking_data.options.debug_types,\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tright: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\t\tright,\n-\t\t\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\t\t\t&checking_data.types,\n-\t\t\t\t\t\t\t\tchecking_data.options.debug_types,\n-\t\t\t\t\t\t\t),\n-\t\t\t\t\t\t\tposition: position.with_source(environment.get_source()),\n-\t\t\t\t\t\t},\n-\t\t\t\t\t);\n-\t\t\t\t\treturn TypeId::ERROR_TYPE;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tacc\n-\t\t}\n-\t\t// This will take the found type and generate a `StructureGeneric` based on the type arguments\n+\t\t// This will take the found type and generate a `PartiallyAppliedGeneric` based on the type arguments\n \t\tTypeAnnotation::NameWithGenericArguments(name, arguments, position) => {\n \t\t\tmatch name {\n \t\t\t\tTypeName::Name(name) => {\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -183,71 +134,114 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\tlet mut type_arguments: crate::Map<TypeId, (TypeId, SpanWithSource)> =\n \t\t\t\t\t\t\t\tcrate::Map::default();\n \n-\t\t\t\t\t\t\tfor (parameter, argument_type_annotation) in\n-\t\t\t\t\t\t\t\tparameters.clone().into_iter().zip(arguments.iter())\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tlet argument = synthesise_type_annotation(\n-\t\t\t\t\t\t\t\t\targument_type_annotation,\n-\t\t\t\t\t\t\t\t\tenvironment,\n-\t\t\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t\t// TODO better diagnostic\n+\t\t\t\t\t\t\tif parameters.len() != arguments.len() {\n+\t\t\t\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n+\t\t\t\t\t\t\t\t\tTypeCheckError::GenericArgumentCountMismatch {\n+\t\t\t\t\t\t\t\t\t\texpected_count: parameters.len(),\n+\t\t\t\t\t\t\t\t\t\tcount: arguments.len(),\n+\t\t\t\t\t\t\t\t\t\tposition: position.with_source(environment.get_source()),\n+\t\t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t\t);\n+\t\t\t\t\t\t\t\t// Continue is fine\n+\t\t\t\t\t\t\t}\n \n+\t\t\t\t\t\t\tlet mut argument_type_annotations = arguments.iter();\n+\t\t\t\t\t\t\tfor parameter in parameters.iter().copied() {\n+\t\t\t\t\t\t\t\tlet parameter_restriction =\n+\t\t\t\t\t\t\t\t\tif let Type::RootPolyType(PolyNature::StructureGeneric {\n+\t\t\t\t\t\t\t\t\t\textends,\n+\t\t\t\t\t\t\t\t\t\t..\n+\t\t\t\t\t\t\t\t\t}) = checking_data.types.get_type_by_id(parameter)\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t*extends\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tcrate::utilities::notify!(\"Shouldn't be here\");\n+\t\t\t\t\t\t\t\t\t\tparameter\n+\t\t\t\t\t\t\t\t\t};\n+\n+\t\t\t\t\t\t\t\tlet (argument, position) = if let Some(argument_type_annotation) =\n+\t\t\t\t\t\t\t\t\targument_type_annotations.next()\n \t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\t// TODO check restriction on parameter\n-\t\t\t\t\t\t\t\t\t// let mut basic_equality = BasicEquality {\n-\t\t\t\t\t\t\t\t\t// \tadd_property_restrictions: true,\n-\t\t\t\t\t\t\t\t\t// \tposition: argument_type_annotation\n-\t\t\t\t\t\t\t\t\t// \t\t.get_position()\n-\t\t\t\t\t\t\t\t\t// \t\t.with_source(environment.get_source()),\n-\t\t\t\t\t\t\t\t\t// \t// TODO not needed\n-\t\t\t\t\t\t\t\t\t// \tobject_constraints: Default::default(),\n-\t\t\t\t\t\t\t\t\t// \tallow_errors: true,\n-\t\t\t\t\t\t\t\t\t// };\n-\n-\t\t\t\t\t\t\t\t\t// let Type::RootPolyType(PolyNature::InterfaceGeneric { name: _ }) =\n-\t\t\t\t\t\t\t\t\t// \tchecking_data.types.get_type_by_id(parameter)\n-\t\t\t\t\t\t\t\t\t// else {\n-\t\t\t\t\t\t\t\t\t// \tunreachable!()\n-\t\t\t\t\t\t\t\t\t// };\n-\n-\t\t\t\t\t\t\t\t\t// // TODO it is a bit weird with the arguments, maybe should get their restriction directly here?\n-\t\t\t\t\t\t\t\t\t// // Definition files don't necessary need to check ...\n-\t\t\t\t\t\t\t\t\t// let result = type_is_subtype(\n-\t\t\t\t\t\t\t\t\t// \t*parameter_restriction,\n-\t\t\t\t\t\t\t\t\t// \targument,\n-\t\t\t\t\t\t\t\t\t// \t&mut basic_equality,\n-\t\t\t\t\t\t\t\t\t// \tenvironment,\n-\t\t\t\t\t\t\t\t\t// \t&checking_data.types,\n-\t\t\t\t\t\t\t\t\t// );\n-\n-\t\t\t\t\t\t\t\t\t// if let SubTypeResult::IsNotSubType(_matches) = result {\n-\t\t\t\t\t\t\t\t\t// \tlet error = TypeCheckError::GenericArgumentDoesNotMeetRestriction {\n-\t\t\t\t\t\t\t\t\t// \t\tparameter_restriction: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\t\t\t// \t\t\t*parameter_restriction,\n-\t\t\t\t\t\t\t\t\t// \t\t\tenvironment,\n-\t\t\t\t\t\t\t\t\t// \t\t\t&checking_data.types,\n-\t\t\t\t\t\t\t\t\t// \t\t\tchecking_data.options.debug_types,\n-\t\t\t\t\t\t\t\t\t// \t\t),\n-\t\t\t\t\t\t\t\t\t// \t\targument: TypeStringRepresentation::from_type_id(\n-\t\t\t\t\t\t\t\t\t// \t\t\targument,\n-\t\t\t\t\t\t\t\t\t// \t\t\tenvironment,\n-\t\t\t\t\t\t\t\t\t// \t\t\t&checking_data.types,\n-\t\t\t\t\t\t\t\t\t// \t\t\tchecking_data.options.debug_types,\n-\t\t\t\t\t\t\t\t\t// \t\t),\n-\t\t\t\t\t\t\t\t\t// \t\tposition: argument_type_annotation\n-\t\t\t\t\t\t\t\t\t// \t\t\t.get_position()\n-\t\t\t\t\t\t\t\t\t// \t\t\t.with_source(environment.get_source()),\n-\t\t\t\t\t\t\t\t\t// \t};\n-\n-\t\t\t\t\t\t\t\t\t// \tchecking_data.diagnostics_container.add_error(error);\n-\t\t\t\t\t\t\t\t\t// }\n-\t\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\t\tlet with_source = argument_type_annotation\n-\t\t\t\t\t\t\t\t\t.get_position()\n-\t\t\t\t\t\t\t\t\t.with_source(environment.get_source());\n-\n-\t\t\t\t\t\t\t\ttype_arguments.insert(parameter, (argument, with_source));\n+\t\t\t\t\t\t\t\t\tlet argument = if let TypeAnnotation::Infer {\n+\t\t\t\t\t\t\t\t\t\tname,\n+\t\t\t\t\t\t\t\t\t\textends: None,\n+\t\t\t\t\t\t\t\t\t\tposition: _,\n+\t\t\t\t\t\t\t\t\t} = argument_type_annotation\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\tenvironment.new_infer_type(\n+\t\t\t\t\t\t\t\t\t\t\tparameter_restriction,\n+\t\t\t\t\t\t\t\t\t\t\tname,\n+\t\t\t\t\t\t\t\t\t\t\t&mut checking_data.types,\n+\t\t\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t\tsynthesise_type_annotation(\n+\t\t\t\t\t\t\t\t\t\t\targument_type_annotation,\n+\t\t\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t\t\tchecking_data,\n+\t\t\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t\t\t};\n+\n+\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\tuse crate::types::subtyping;\n+\n+\t\t\t\t\t\t\t\t\t\tlet mut state = subtyping::State {\n+\t\t\t\t\t\t\t\t\t\t\talready_checked: Default::default(),\n+\t\t\t\t\t\t\t\t\t\t\tmode: Default::default(),\n+\t\t\t\t\t\t\t\t\t\t\tcontributions: Default::default(),\n+\t\t\t\t\t\t\t\t\t\t\tothers: subtyping::SubTypingOptions {\n+\t\t\t\t\t\t\t\t\t\t\t\tallow_errors: true,\n+\t\t\t\t\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\t\t\t\t\tobject_constraints: None,\n+\t\t\t\t\t\t\t\t\t\t};\n+\n+\t\t\t\t\t\t\t\t\t\tlet result = subtyping::type_is_subtype(\n+\t\t\t\t\t\t\t\t\t\t\tparameter_restriction,\n+\t\t\t\t\t\t\t\t\t\t\targument,\n+\t\t\t\t\t\t\t\t\t\t\t&mut state,\n+\t\t\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\t\t\t);\n+\n+\t\t\t\t\t\t\t\t\t\tif let subtyping::SubTypeResult::IsNotSubType(_matches) =\n+\t\t\t\t\t\t\t\t\t\t\tresult\n+\t\t\t\t\t\t\t\t\t\t{\n+\t\t\t\t\t\t\t\t\t\t\tlet error =\n+\t\t\t\t\t\t\t\t\t\t\t\tTypeCheckError::GenericArgumentDoesNotMeetRestriction {\n+\t\t\t\t\t\t\t\t\t\t\t\t\tparameter_restriction:\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tTypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameter_restriction,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchecking_data.options.debug_types,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\t\t\t\t\t\targument: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\targument,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tchecking_data.options.debug_types,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\t\t\t\t\t\tposition: argument_type_annotation\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t.get_position()\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t.with_source(environment.get_source()),\n+\t\t\t\t\t\t\t\t\t\t\t\t};\n+\n+\t\t\t\t\t\t\t\t\t\t\tchecking_data.diagnostics_container.add_error(error);\n+\t\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\t\tlet position = argument_type_annotation\n+\t\t\t\t\t\t\t\t\t\t.get_position()\n+\t\t\t\t\t\t\t\t\t\t.with_source(environment.get_source());\n+\n+\t\t\t\t\t\t\t\t\t(argument, position)\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\t(\n+\t\t\t\t\t\t\t\t\t\tTypeId::ERROR_TYPE,\n+\t\t\t\t\t\t\t\t\t\t<SpanWithSource as source_map::Nullable>::NULL,\n+\t\t\t\t\t\t\t\t\t)\n+\t\t\t\t\t\t\t\t};\n+\n+\t\t\t\t\t\t\t\ttype_arguments.insert(parameter, (argument, position));\n \t\t\t\t\t\t\t}\n \n \t\t\t\t\t\t\t// Inline alias with arguments unless intrinsic\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -301,10 +295,11 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n-\t\t\t\t\t\t\t\tTypeCheckError::TypeHasNoGenericParameters(\n-\t\t\t\t\t\t\t\t\tname.clone(),\n-\t\t\t\t\t\t\t\t\tposition.with_source(environment.get_source()),\n-\t\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\t\tTypeCheckError::GenericArgumentCountMismatch {\n+\t\t\t\t\t\t\t\t\texpected_count: 0,\n+\t\t\t\t\t\t\t\t\tcount: arguments.len(),\n+\t\t\t\t\t\t\t\t\tposition: position.with_source(environment.get_source()),\n+\t\t\t\t\t\t\t\t},\n \t\t\t\t\t\t\t);\n \t\t\t\t\t\t\tTypeId::ERROR_TYPE\n \t\t\t\t\t\t}\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -331,10 +326,59 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\"namespace item\",\n \t\t\t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\t\t);\n-\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tTypeAnnotation::Union(type_annotations, _) => {\n+\t\t\tlet iterator = type_annotations\n+\t\t\t\t.iter()\n+\t\t\t\t.map(|type_annotation| {\n+\t\t\t\t\tsynthesise_type_annotation(type_annotation, environment, checking_data)\n+\t\t\t\t})\n+\t\t\t\t.collect::<Vec<_>>()\n+\t\t\t\t.into_iter();\n+\n+\t\t\titerator\n+\t\t\t\t.reduce(|acc, right| checking_data.types.new_or_type(acc, right))\n+\t\t\t\t.expect(\"Empty union\")\n+\t\t}\n+\t\tTypeAnnotation::Intersection(type_annotations, position) => {\n+\t\t\tlet mut iterator = type_annotations\n+\t\t\t\t.iter()\n+\t\t\t\t.map(|type_annotation| {\n+\t\t\t\t\tsynthesise_type_annotation(type_annotation, environment, checking_data)\n+\t\t\t\t})\n+\t\t\t\t.collect::<Vec<_>>()\n+\t\t\t\t.into_iter();\n+\n+\t\t\tlet mut acc = iterator.next().expect(\"Empty intersection\");\n+\t\t\tfor right in iterator {\n+\t\t\t\tif let Ok(new_ty) = checking_data.types.new_and_type(acc, right) {\n+\t\t\t\t\tacc = new_ty;\n+\t\t\t\t} else {\n+\t\t\t\t\tchecking_data.diagnostics_container.add_error(\n+\t\t\t\t\t\tTypeCheckWarning::TypesDoNotIntersect {\n+\t\t\t\t\t\t\tleft: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\tacc,\n+\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\tchecking_data.options.debug_types,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tright: TypeStringRepresentation::from_type_id(\n+\t\t\t\t\t\t\t\tright,\n+\t\t\t\t\t\t\t\tenvironment,\n+\t\t\t\t\t\t\t\t&checking_data.types,\n+\t\t\t\t\t\t\t\tchecking_data.options.debug_types,\n+\t\t\t\t\t\t\t),\n+\t\t\t\t\t\t\tposition: position.with_source(environment.get_source()),\n+\t\t\t\t\t\t},\n+\t\t\t\t\t);\n+\t\t\t\t\treturn TypeId::ERROR_TYPE;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tacc\n+\t\t}\n \t\tTypeAnnotation::FunctionLiteral {\n \t\t\ttype_parameters,\n \t\t\tparameters,\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -366,7 +410,7 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t\"abstact type annotation\",\n \t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t);\n-\t\t\tTypeId::ERROR_TYPE\n+\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t}\n \t\tTypeAnnotation::Readonly(type_annotation, position) => {\n \t\t\tlet underlying_type =\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -400,7 +444,7 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t\"constructor literal\",\n \t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t);\n-\t\t\tTypeId::ERROR_TYPE\n+\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t}\n \t\t// Object literals are first turned into types as if they were interface declarations and then\n \t\t// returns reference to object literal\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -482,9 +526,10 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t\t\tcrate::utilities::notify!(\"found wildcard\");\n \t\t\t\t\t\tlet after = idx.into_type(&mut checking_data.types);\n \n-\t\t\t\t\t\tlet key = checking_data.types.new_intrinsic(\n+\t\t\t\t\t\tlet key = crate::types::intrinsics::new_intrinsic(\n \t\t\t\t\t\t\t&crate::types::intrinsics::Intrinsic::GreaterThan,\n \t\t\t\t\t\t\tafter,\n+\t\t\t\t\t\t\t&mut checking_data.types,\n \t\t\t\t\t\t);\n \n \t\t\t\t\t\tlet item_type = checking_data.types.register_type(Type::Constructor(\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -557,7 +602,7 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t\t\"throw error for annotation\",\n \t\t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t\t);\n-\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t}\n \t\t}\n \t\tTypeAnnotation::Conditional { condition, resolve_true, resolve_false, position: _ } => {\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -673,18 +718,24 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\tlhs: acc,\n \t\t\t\t\t\t\toperator: crate::features::operations::MathematicalAndBitwise::Add,\n \t\t\t\t\t\t\trhs: lhs,\n+\t\t\t\t\t\t\tresult: TypeId::STRING_TYPE,\n \t\t\t\t\t\t},\n \t\t\t\t\t))\n \t\t\t\t};\n-\t\t\t\tlet rhs = synthesise_type_annotation(\n-\t\t\t\t\tdynamic_part.get_inner_ref(),\n-\t\t\t\t\tenvironment,\n-\t\t\t\t\tchecking_data,\n-\t\t\t\t);\n+\t\t\t\t// WIP fix correcting `infer T` to `infer T extends string` so that string addition works\n+\t\t\t\tlet dynamic_part = dynamic_part.get_inner_ref();\n+\t\t\t\tlet rhs = if let TypeAnnotation::Infer { name, extends: None, position: _ } =\n+\t\t\t\t\tdynamic_part\n+\t\t\t\t{\n+\t\t\t\t\tenvironment.new_infer_type(TypeId::STRING_TYPE, name, &mut checking_data.types)\n+\t\t\t\t} else {\n+\t\t\t\t\tsynthesise_type_annotation(dynamic_part, environment, checking_data)\n+\t\t\t\t};\n \t\t\t\tlet constructor = crate::types::Constructor::BinaryOperator {\n \t\t\t\t\tlhs: acc,\n \t\t\t\t\toperator: crate::features::operations::MathematicalAndBitwise::Add,\n \t\t\t\t\trhs,\n+\t\t\t\t\tresult: TypeId::STRING_TYPE,\n \t\t\t\t};\n \t\t\t\tacc = checking_data.types.register_type(Type::Constructor(constructor));\n \t\t\t}\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -700,6 +751,7 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t\t\t\tlhs: acc,\n \t\t\t\t\t\t\toperator: crate::features::operations::MathematicalAndBitwise::Add,\n \t\t\t\t\t\t\trhs: lhs,\n+\t\t\t\t\t\t\tresult: TypeId::STRING_TYPE,\n \t\t\t\t\t\t},\n \t\t\t\t\t))\n \t\t\t\t}\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -716,7 +768,7 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\tenvironment.context_type.scope\n \t\t\t{\n \t\t\t\tlet infer_type = checking_data.types.register_type(Type::RootPolyType(\n-\t\t\t\t\tcrate::types::PolyNature::InferGeneric { name: name.clone(), extends },\n+\t\t\t\t\tPolyNature::InferGeneric { name: name.clone(), extends },\n \t\t\t\t));\n \n \t\t\t\tlet existing = infer_parameters.insert(name.clone(), infer_type);\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -726,7 +778,7 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\tinfer_type\n \t\t\t} else {\n \t\t\t\tcrate::utilities::notify!(\"Raise error diagnostic\");\n-\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t}\n \t\t}\n \t\tTypeAnnotation::Extends { item, extends, position: _ } => {\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -752,8 +804,8 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t\t.copied(),\n \t\t\t\tparser::type_annotations::IsItem::This => {\n \t\t\t\t\t// TODO\n-\t\t\t\t\tlet based_on = TypeId::ERROR_TYPE;\n-\t\t\t\t\tlet ty = Type::RootPolyType(crate::types::PolyNature::FreeVariable {\n+\t\t\t\t\tlet based_on = TypeId::UNIMPLEMENTED_ERROR_TYPE;\n+\t\t\t\t\tlet ty = Type::RootPolyType(PolyNature::FreeVariable {\n \t\t\t\t\t\treference: crate::events::RootReference::This,\n \t\t\t\t\t\tbased_on,\n \t\t\t\t\t});\ndiff --git a/checker/src/synthesis/type_annotations.rs b/checker/src/synthesis/type_annotations.rs\n--- a/checker/src/synthesis/type_annotations.rs\n+++ b/checker/src/synthesis/type_annotations.rs\n@@ -799,7 +851,7 @@ pub fn synthesise_type_annotation<T: crate::ReadFromFS>(\n \t\t\t\t\"`this` annotation\",\n \t\t\t\tposition.with_source(environment.get_source()),\n \t\t\t);\n-\t\t\tTypeId::ERROR_TYPE\n+\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t}\n \t};\n \ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -3,7 +3,8 @@ use source_map::{BaseSpan, Nullable, SpanWithSource};\n use crate::{\n \tcontext::{invocation::CheckThings, CallCheckingBehavior, Environment, InformationChain},\n \tdiagnostics::{\n-\t\tInfoDiagnostic, TypeCheckError, TypeCheckWarning, TypeStringRepresentation, TDZ,\n+\t\tInfoDiagnostic, TypeCheckError, TypeCheckWarning, TypeStringRepresentation,\n+\t\tVariableUsedInTDZ,\n \t},\n \tevents::{\n \t\tapplication::ApplicationInput, apply_events, ApplicationResult, Event, RootReference,\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -278,15 +279,15 @@ pub fn call_type_handle_errors<T: crate::ReadFromFS, A: crate::ASTImplementation\n \t\tOk(LogicalOrValid::NeedsCalculation(l)) => match l {\n \t\t\tNeedsCalculation::Infer { on } => {\n \t\t\t\tif on == TypeId::ERROR_TYPE {\n-\t\t\t\t\t(TypeId::ERROR_TYPE, None)\n+\t\t\t\t\t(TypeId::UNIMPLEMENTED_ERROR_TYPE, None)\n \t\t\t\t} else {\n \t\t\t\t\tcrate::utilities::notify!(\"TODO function calling inference on {:?}\", on);\n-\t\t\t\t\t(TypeId::ERROR_TYPE, None)\n+\t\t\t\t\t(TypeId::UNIMPLEMENTED_ERROR_TYPE, None)\n \t\t\t\t}\n \t\t\t}\n \t\t\tNeedsCalculation::Proxy(..) => {\n \t\t\t\tcrate::utilities::notify!(\"TODO calling proxy\");\n-\t\t\t\t(TypeId::ERROR_TYPE, None)\n+\t\t\t\t(TypeId::UNIMPLEMENTED_ERROR_TYPE, None)\n \t\t\t}\n \t\t},\n \t\tErr(Invalid(ty)) => {\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -379,7 +380,7 @@ impl Callable {\n \t\t\t\t\ttypes.get_function_from_id(*id).return_type\n \t\t\t\t} else {\n \t\t\t\t\tcrate::utilities::notify!(\"Cannot get return type\");\n-\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t}\n \t\t\t}\n \t\t}\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -710,7 +711,7 @@ fn call_logical<B: CallCheckingBehavior>(\n \t\t\t\t\t\t\t\t\treturned_type: types.new_error_type(function_type.return_type),\n \t\t\t\t\t\t\t\t});\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tErr(ConstantFunctionError::BadCall) => {\n+\t\t\t\t\t\t\tErr(ConstantFunctionError::CannotComputeConstant) => {\n \t\t\t\t\t\t\t\tcrate::utilities::notify!(\n \t\t\t\t\t\t\t\t\t\"Constant function calling failed, non constant params\"\n \t\t\t\t\t\t\t\t);\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -865,11 +866,13 @@ fn call_logical<B: CallCheckingBehavior>(\n \n \t\t\t\tOk(result)\n \t\t\t} else {\n-\t\t\t\tpanic!()\n+\t\t\t\tpanic!(\"no function\")\n \t\t\t}\n \t\t}\n-\t\tLogical::Or { condition, left, right } => {\n-\t\t\ttodo!(\"{:?}\", (condition, left, right));\n+\t\tLogical::Or { .. } => {\n+\t\t\tcrate::utilities::notify!(\"Calling OR\");\n+\t\t\tErr(BadCallOutput { returned_type: TypeId::UNIMPLEMENTED_ERROR_TYPE })\n+\t\t\t// todo!(\"{:?}\", (condition, left, right));\n \t\t\t// if let (Ok(_left), Ok(_right)) = (*left, *right) {\n \t\t\t// let (truthy_result, otherwise_result) = behavior.evaluate_conditionally(\n \t\t\t// \ttop_environment,\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -933,7 +936,10 @@ fn call_logical<B: CallCheckingBehavior>(\n \t\t\t\t(behavior, diagnostics),\n \t\t\t)\n \t\t}\n-\t\tLogical::BasedOnKey { .. } => todo!(),\n+\t\tLogical::BasedOnKey { .. } => {\n+\t\t\tcrate::utilities::notify!(\"Calling based on key?\");\n+\t\t\tErr(BadCallOutput { returned_type: TypeId::UNIMPLEMENTED_ERROR_TYPE })\n+\t\t}\n \t}\n }\n \ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -989,7 +995,6 @@ pub enum FunctionCallingError {\n \t\tcount: usize,\n \t\tposition: SpanWithSource,\n \t},\n-\n \tExcessTypeArguments {\n \t\texpected_count: usize,\n \t\tcount: usize,\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -1007,12 +1012,12 @@ pub enum FunctionCallingError {\n \tCyclicRecursion(FunctionId, SpanWithSource),\n \tNoLogicForIdentifier(String, SpanWithSource),\n \tNeedsToBeCalledWithNewKeyword(SpanWithSource),\n-\tTDZ {\n-\t\terror: TDZ,\n+\tVariableUsedInTDZ {\n+\t\terror: VariableUsedInTDZ,\n \t\t/// Should be set by parent\n \t\tcall_site: SpanWithSource,\n \t},\n-\tInvalidRegexp(crate::diagnostics::InvalidRegexp),\n+\tInvalidRegExp(crate::diagnostics::InvalidRegExp),\n \t/// For #18\n \tSetPropertyConstraint {\n \t\tproperty_type: TypeStringRepresentation,\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -1028,7 +1033,7 @@ pub enum FunctionCallingError {\n \t\t/// Should be set by parent\n \t\tcall_site: SpanWithSource,\n \t},\n-\tNotConfiguarable {\n+\tNotConfigurable {\n \t\tproperty: crate::diagnostics::PropertyKeyRepresentation,\n \t\t/// Should be set by parent\n \t\tcall_site: SpanWithSource,\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -1192,7 +1197,10 @@ impl FunctionType {\n \n \t\t\t\t\t// Adjust call sites. (because they aren't currently passed down)\n \t\t\t\t\tfor d in &mut diagnostics.errors[current_errors..] {\n-\t\t\t\t\t\tif let FunctionCallingError::TDZ { call_site: ref mut c, .. }\n+\t\t\t\t\t\tif let FunctionCallingError::VariableUsedInTDZ {\n+\t\t\t\t\t\t\tcall_site: ref mut c,\n+\t\t\t\t\t\t\t..\n+\t\t\t\t\t\t}\n \t\t\t\t\t\t| FunctionCallingError::SetPropertyConstraint {\n \t\t\t\t\t\t\tcall_site: ref mut c,\n \t\t\t\t\t\t\t..\ndiff --git a/checker/src/types/calling.rs b/checker/src/types/calling.rs\n--- a/checker/src/types/calling.rs\n+++ b/checker/src/types/calling.rs\n@@ -1509,7 +1517,7 @@ impl FunctionType {\n \t\t\t\tCalledWithNew::New { on } => on,\n \t\t\t\tCalledWithNew::Super { .. } => {\n \t\t\t\t\tcrate::utilities::notify!(\"Get this type for super new.target\");\n-\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t\t// let ty = this_value.0;\n \t\t\t\t\t// let on = crate::types::printing::print_type(\n \t\t\t\t\t// \tty,\ndiff --git a/checker/src/types/casts.rs b/checker/src/types/casts.rs\n--- a/checker/src/types/casts.rs\n+++ b/checker/src/types/casts.rs\n@@ -17,7 +17,7 @@ pub(crate) fn cast_as_number(cst: &Constant, strict_casts: bool) -> Result<f64,\n \t\t\t}\n \t\t},\n \t\tConstant::Boolean(val) => Ok(if *val { 1f64 } else { 0f64 }),\n-\t\tConstant::NaN => Ok(f64::NAN),\n+\t\tConstant::Undefined | Constant::NaN => Ok(f64::NAN),\n \t\tConstant::Symbol { key: _ } => todo!(),\n \t}\n }\ndiff --git a/checker/src/types/casts.rs b/checker/src/types/casts.rs\n--- a/checker/src/types/casts.rs\n+++ b/checker/src/types/casts.rs\n@@ -41,7 +41,7 @@ pub(crate) fn cast_as_boolean(cst: &Constant, strict_casts: bool) -> Result<bool\n \t\tConstant::Number(number) => number.into_inner() != 0.,\n \t\tConstant::String(value) => !value.is_empty(),\n \t\tConstant::Boolean(value) => *value,\n-\t\tConstant::NaN => false,\n+\t\tConstant::Undefined | Constant::NaN => false,\n \t\tConstant::Symbol { key: _ } => todo!(),\n \t})\n }\ndiff --git a/checker/src/types/classes.rs b/checker/src/types/classes.rs\n--- a/checker/src/types/classes.rs\n+++ b/checker/src/types/classes.rs\n@@ -57,9 +57,9 @@ fn _register_class_properties_for_later_application<\n ) {\n \tlet scope = crate::Scope::Function(crate::context::environment::FunctionScope::Constructor {\n \t\textends: false,\n-\t\ttype_of_super: Some(TypeId::ERROR_TYPE),\n+\t\ttype_of_super: Some(TypeId::UNIMPLEMENTED_ERROR_TYPE),\n \t\t// TODO get from above\n-\t\tthis_object_type: TypeId::ERROR_TYPE,\n+\t\tthis_object_type: TypeId::UNIMPLEMENTED_ERROR_TYPE,\n \t});\n \n \tlet ((), result, _) = environment.new_lexical_environment_fold_into_parent(\ndiff --git a/checker/src/types/disjoint.rs b/checker/src/types/disjoint.rs\n--- a/checker/src/types/disjoint.rs\n+++ b/checker/src/types/disjoint.rs\n@@ -1,5 +1,5 @@\n-use super::PartiallyAppliedGenerics;\n-use crate::{context::InformationChain, types::TypeStore, Type, TypeId};\n+use super::{Constant, PartiallyAppliedGenerics, Type, TypeId, TypeStore};\n+use crate::context::InformationChain;\n \n /// For equality + [`crate::intrinsics::Intrinsics::Not`]\n ///\ndiff --git a/checker/src/types/disjoint.rs b/checker/src/types/disjoint.rs\n--- a/checker/src/types/disjoint.rs\n+++ b/checker/src/types/disjoint.rs\n@@ -9,56 +9,48 @@ use crate::{context::InformationChain, types::TypeStore, Type, TypeId};\n ///\n /// Could shrink some logic here but is more readable verbose\n pub fn types_are_disjoint(\n-\tleft: TypeId,\n-\tright: TypeId,\n+\tlhs: TypeId,\n+\trhs: TypeId,\n \talready_checked: &mut Vec<(TypeId, TypeId)>,\n \tinformation: &impl InformationChain,\n \ttypes: &TypeStore,\n ) -> bool {\n-\tif left == right {\n+\t// crate::utilities::notify!(\"are disjoint? {:?}\", (lhs, rhs));\n+\n+\tif lhs == rhs || lhs == TypeId::ANY_TYPE || rhs == TypeId::ANY_TYPE {\n \t\tfalse\n-\t} else if already_checked.iter().any(|pair| *pair == (left, right)) {\n+\t} else if already_checked.iter().any(|pair| *pair == (lhs, rhs)) {\n \t\t// TODO explain why `true`\n \t\ttrue\n \t} else {\n-\t\tlet left_ty = types.get_type_by_id(left);\n-\t\tlet right_ty = types.get_type_by_id(right);\n+\t\tlet lhs_ty = types.get_type_by_id(lhs);\n+\t\tlet rhs_ty = types.get_type_by_id(rhs);\n \n-\t\t// if let Type::Constructor(Constructor::KeyOf(_)) = left_ty {\n-\t\t// \ttodo!(\"get property != \")\n-\t\t// } else\n-\t\tif let Type::Constant(left_cst) = left_ty {\n-\t\t\tif let Type::Constant(right_cst) = right_ty {\n-\t\t\t\tleft_cst != right_cst\n-\t\t\t} else {\n-\t\t\t\tleft_cst.get_backing_type_id() != right\n-\t\t\t}\n-\t\t} else if let Type::Constant(right_cst) = right_ty {\n-\t\t\tright_cst.get_backing_type_id() != left\n-\t\t} else if let Type::Or(left_left, left_right) = left_ty {\n-\t\t\ttypes_are_disjoint(*left_left, right, already_checked, information, types)\n-\t\t\t\t&& types_are_disjoint(*left_right, right, already_checked, information, types)\n-\t\t} else if let Type::And(left_left, left_right) = left_ty {\n-\t\t\ttypes_are_disjoint(*left_left, right, already_checked, information, types)\n-\t\t\t\t|| types_are_disjoint(*left_right, right, already_checked, information, types)\n-\t\t} else if let Type::Or(right_left, right_right) = right_ty {\n-\t\t\ttypes_are_disjoint(left, *right_left, already_checked, information, types)\n-\t\t\t\t&& types_are_disjoint(left, *right_right, already_checked, information, types)\n-\t\t} else if let Type::And(right_left, right_right) = right_ty {\n-\t\t\ttypes_are_disjoint(left, *right_left, already_checked, information, types)\n-\t\t\t\t|| types_are_disjoint(left, *right_right, already_checked, information, types)\n-\t\t} else if let Type::AliasTo { to, parameters: None, name: _ } = left_ty {\n+\t\t// Order of these branches matter\n+\t\tif let Type::Or(lhs_lhs, lhs_rhs) = lhs_ty {\n+\t\t\ttypes_are_disjoint(*lhs_lhs, rhs, already_checked, information, types)\n+\t\t\t\t&& types_are_disjoint(*lhs_rhs, rhs, already_checked, information, types)\n+\t\t} else if let Type::And(lhs_lhs, lhs_rhs) = lhs_ty {\n+\t\t\ttypes_are_disjoint(*lhs_lhs, rhs, already_checked, information, types)\n+\t\t\t\t|| types_are_disjoint(*lhs_rhs, rhs, already_checked, information, types)\n+\t\t} else if let Type::Or(rhs_lhs, rhs_rhs) = rhs_ty {\n+\t\t\ttypes_are_disjoint(lhs, *rhs_lhs, already_checked, information, types)\n+\t\t\t\t&& types_are_disjoint(lhs, *rhs_rhs, already_checked, information, types)\n+\t\t} else if let Type::And(rhs_lhs, rhs_rhs) = rhs_ty {\n+\t\t\ttypes_are_disjoint(lhs, *rhs_lhs, already_checked, information, types)\n+\t\t\t\t|| types_are_disjoint(lhs, *rhs_rhs, already_checked, information, types)\n+\t\t} else if let Type::AliasTo { to, parameters: None, name: _ } = lhs_ty {\n \t\t\t// TODO temp fix, need infer ANY\n \t\t\tif matches!(*to, TypeId::ANY_TYPE) {\n \t\t\t\ttrue\n \t\t\t} else {\n-\t\t\t\ttypes_are_disjoint(*to, right, already_checked, information, types)\n+\t\t\t\ttypes_are_disjoint(*to, rhs, already_checked, information, types)\n \t\t\t}\n-\t\t} else if let Type::AliasTo { to, parameters: None, name: _ } = right_ty {\n+\t\t} else if let Type::AliasTo { to, parameters: None, name: _ } = rhs_ty {\n \t\t\tif matches!(*to, TypeId::ANY_TYPE) {\n \t\t\t\ttrue\n \t\t\t} else {\n-\t\t\t\ttypes_are_disjoint(left, *to, already_checked, information, types)\n+\t\t\t\ttypes_are_disjoint(lhs, *to, already_checked, information, types)\n \t\t\t}\n \t\t} else if let (\n \t\t\tType::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\ndiff --git a/checker/src/types/disjoint.rs b/checker/src/types/disjoint.rs\n--- a/checker/src/types/disjoint.rs\n+++ b/checker/src/types/disjoint.rs\n@@ -66,26 +58,145 @@ pub fn types_are_disjoint(\n \t\t\t\targuments: _arguments,\n \t\t\t}),\n \t\t\tType::Object(super::ObjectNature::RealDeal),\n-\t\t) = (left_ty, right_ty)\n+\t\t) = (lhs_ty, rhs_ty)\n \t\t{\n-\t\t\tlet rhs_prototype = information\n-\t\t\t\t.get_chain_of_info()\n-\t\t\t\t.find_map(|info| info.prototypes.get(&right).copied());\n+\t\t\tlet rhs_prototype =\n+\t\t\t\tinformation.get_chain_of_info().find_map(|info| info.prototypes.get(&rhs).copied());\n \t\t\t// {\n \t\t\t// \t\tif let Some(lhs_prototype) = info.prototypes.get(&lhs).copied() {\n-\t\t\t// \tlet rhs_prototype = information.get_prototype_of(right);\n+\t\t\t// \tlet rhs_prototype = information.get_prototype_of(rhs);\n \n \t\t\t// TODO leaving arguments out of picture for now\n \t\t\trhs_prototype != Some(TypeId::ARRAY_TYPE)\n-\t\t} else if let (Type::Object(super::ObjectNature::RealDeal), _)\n-\t\t| (_, Type::Object(super::ObjectNature::RealDeal)) = (left_ty, right_ty)\n+\t\t} else if let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n+\t\t\ton: TypeId::NOT_RESTRICTION,\n+\t\t\targuments,\n+\t\t}) = lhs_ty\n \t\t{\n-\t\t\ttrue\n+\t\t\tuse super::subtyping;\n+\t\t\tlet inner = arguments.get_structure_restriction(TypeId::T_TYPE).unwrap();\n+\t\t\tlet mut state = subtyping::State {\n+\t\t\t\t// TODO\n+\t\t\t\talready_checked: already_checked.clone(),\n+\t\t\t\tmode: Default::default(),\n+\t\t\t\tcontributions: None,\n+\t\t\t\tothers: subtyping::SubTypingOptions { allow_errors: true },\n+\t\t\t\tobject_constraints: None,\n+\t\t\t};\n+\n+\t\t\tcrate::utilities::notify!(\"{:?}\", (lhs, inner));\n+\n+\t\t\tsubtyping::type_is_subtype(rhs, inner, &mut state, information, types).is_subtype()\n+\t\t} else if let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n+\t\t\ton: TypeId::NOT_RESTRICTION,\n+\t\t\targuments,\n+\t\t}) = rhs_ty\n+\t\t{\n+\t\t\tuse super::subtyping;\n+\t\t\tlet inner = arguments.get_structure_restriction(TypeId::T_TYPE).unwrap();\n+\t\t\tlet mut state = subtyping::State {\n+\t\t\t\t// TODO\n+\t\t\t\talready_checked: already_checked.clone(),\n+\t\t\t\tmode: Default::default(),\n+\t\t\t\tcontributions: None,\n+\t\t\t\tothers: subtyping::SubTypingOptions { allow_errors: true },\n+\t\t\t\tobject_constraints: None,\n+\t\t\t};\n+\n+\t\t\tcrate::utilities::notify!(\"{:?}\", (lhs, inner));\n+\n+\t\t\tsubtyping::type_is_subtype(lhs, inner, &mut state, information, types).is_subtype()\n+\t\t} else if let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n+\t\t\ton: TypeId::INCLUSIVE_RANGE | TypeId::EXCLUSIVE_RANGE,\n+\t\t\targuments: _,\n+\t\t}) = lhs_ty\n+\t\t{\n+\t\t\tlet range = super::intrinsics::get_range(lhs, types).unwrap();\n+\t\t\tif let Some(rhs_range) = super::intrinsics::get_range(rhs, types) {\n+\t\t\t\tlet overlap = range.overlaps(rhs_range);\n+\t\t\t\tcrate::utilities::notify!(\"{:?}\", overlap);\n+\t\t\t\t!overlap\n+\t\t\t} else {\n+\t\t\t\tcrate::utilities::notify!(\"Here\");\n+\t\t\t\ttrue\n+\t\t\t}\n+\t\t} else if let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n+\t\t\ton: TypeId::INCLUSIVE_RANGE | TypeId::EXCLUSIVE_RANGE,\n+\t\t\targuments: _,\n+\t\t}) = rhs_ty\n+\t\t{\n+\t\t\tlet range = super::intrinsics::get_range(rhs, types).unwrap();\n+\t\t\tif let Some(lhs_range) = super::intrinsics::get_range(lhs, types) {\n+\t\t\t\tlet overlap = range.overlaps(lhs_range);\n+\t\t\t\tcrate::utilities::notify!(\"{:?}\", overlap);\n+\t\t\t\t!overlap\n+\t\t\t} else {\n+\t\t\t\tcrate::utilities::notify!(\"Here\");\n+\t\t\t\ttrue\n+\t\t\t}\n+\t\t} else if let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n+\t\t\ton: TypeId::MULTIPLE_OF,\n+\t\t\targuments,\n+\t\t}) = lhs_ty\n+\t\t{\n+\t\t\t// Little bit complex here because dealing with decimal types, not integers\n+\t\t\tif let (Type::Constant(Constant::Number(lhs)), Type::Constant(Constant::Number(rhs))) = (\n+\t\t\t\ttypes.get_type_by_id(\n+\t\t\t\t\targuments.get_structure_restriction(TypeId::NUMBER_FLOOR_GENERIC).unwrap(),\n+\t\t\t\t),\n+\t\t\t\ttypes.get_type_by_id(rhs),\n+\t\t\t) {\n+\t\t\t\tlet result = rhs % lhs != 0.;\n+\t\t\t\tcrate::utilities::notify!(\"{:?} {:?}\", rhs, lhs);\n+\t\t\t\tresult\n+\t\t\t} else {\n+\t\t\t\tcrate::utilities::notify!(\"Here\");\n+\t\t\t\tfalse\n+\t\t\t}\n+\t\t} else if let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n+\t\t\ton: TypeId::MULTIPLE_OF,\n+\t\t\targuments,\n+\t\t}) = rhs_ty\n+\t\t{\n+\t\t\t// Little bit complex here because dealing with decimal types, not integers\n+\t\t\tif let (Type::Constant(Constant::Number(lhs)), Type::Constant(Constant::Number(rhs))) = (\n+\t\t\t\ttypes.get_type_by_id(lhs),\n+\t\t\t\ttypes.get_type_by_id(\n+\t\t\t\t\targuments.get_structure_restriction(TypeId::NUMBER_FLOOR_GENERIC).unwrap(),\n+\t\t\t\t),\n+\t\t\t) {\n+\t\t\t\tlet result = lhs % rhs != 0.;\n+\t\t\t\tcrate::utilities::notify!(\"{:?} {:?}\", lhs, rhs);\n+\t\t\t\tresult\n+\t\t\t} else {\n+\t\t\t\tcrate::utilities::notify!(\"Here\");\n+\t\t\t\tfalse\n+\t\t\t}\n+\t\t} else if let Some(lhs) = super::get_constraint(lhs, types) {\n+\t\t\t// TODO not sure whether these should be here?\n+\t\t\ttypes_are_disjoint(lhs, rhs, already_checked, information, types)\n+\t\t} else if let Some(rhs) = super::get_constraint(rhs, types) {\n+\t\t\t// TODO not sure whether these should be here?\n+\t\t\ttypes_are_disjoint(lhs, rhs, already_checked, information, types)\n+\t\t} else if let Type::Constant(lhs_cst) = lhs_ty {\n+\t\t\tif let Type::Constant(rhs_cst) = rhs_ty {\n+\t\t\t\tlhs_cst != rhs_cst\n+\t\t\t} else {\n+\t\t\t\ttypes_are_disjoint(\n+\t\t\t\t\tlhs_cst.get_backing_type(),\n+\t\t\t\t\trhs,\n+\t\t\t\t\talready_checked,\n+\t\t\t\t\tinformation,\n+\t\t\t\t\ttypes,\n+\t\t\t\t)\n+\t\t\t}\n+\t\t} else if let Type::Constant(rhs_cst) = rhs_ty {\n+\t\t\ttypes_are_disjoint(rhs_cst.get_backing_type(), lhs, already_checked, information, types)\n \t\t} else {\n \t\t\tcrate::utilities::notify!(\n \t\t\t\t\"{:?} cap {:?} == empty ? cases. Might be missing, calling disjoint\",\n-\t\t\t\tleft_ty,\n-\t\t\t\tright_ty\n+\t\t\t\tlhs_ty,\n+\t\t\t\trhs_ty\n \t\t\t);\n \t\t\ttrue\n \t\t}\ndiff --git a/checker/src/types/functions.rs b/checker/src/types/functions.rs\n--- a/checker/src/types/functions.rs\n+++ b/checker/src/types/functions.rs\n@@ -94,7 +94,7 @@ impl FunctionType {\n \t\t\textends: false,\n \t\t\ttype_of_super: None,\n \t\t\t// Set later\n-\t\t\tthis_object_type: TypeId::ERROR_TYPE,\n+\t\t\tthis_object_type: TypeId::IS_ASSIGNED_VALUE_LATER,\n \t\t});\n \n \t\tlet (on, env_data, _) = environment.new_lexical_environment_fold_into_parent(\ndiff --git a/checker/src/types/generics/substitution.rs b/checker/src/types/generics/substitution.rs\n--- a/checker/src/types/generics/substitution.rs\n+++ b/checker/src/types/generics/substitution.rs\n@@ -7,10 +7,7 @@ use crate::{\n \tfeatures::{\n \t\tfunctions::{ClosureChain, ClosureId},\n \t\tobjects::{Proxy, SpecialObject},\n-\t\toperations::{\n-\t\t\tevaluate_equality_inequality_operation, evaluate_mathematical_operation,\n-\t\t\tevaluate_pure_unary_operator,\n-\t\t},\n+\t\toperations::{evaluate_equality_inequality_operation, evaluate_mathematical_operation},\n \t},\n \tsubtyping::{State, SubTypingOptions},\n \ttypes::{\ndiff --git a/checker/src/types/generics/substitution.rs b/checker/src/types/generics/substitution.rs\n--- a/checker/src/types/generics/substitution.rs\n+++ b/checker/src/types/generics/substitution.rs\n@@ -210,11 +207,13 @@ pub(crate) fn substitute(\n \t\tType::RootPolyType(nature) => {\n \t\t\tif let PolyNature::Open(_) | PolyNature::Error(_) = nature {\n \t\t\t\tid\n-\t\t\t} else if let PolyNature::FunctionGeneric { .. }\n-\t\t\t| PolyNature::StructureGeneric { .. }\n-\t\t\t| PolyNature::InferGeneric { .. } = nature\n-\t\t\t{\n+\t\t\t} else if let PolyNature::InferGeneric { .. } = nature {\n \t\t\t\t// Infer generic is fine for `type Index<T> = T extends Array<infer I> ? I : never`;\n+\t\t\t\tcrate::utilities::notify!(\"No argument for infer generic (sometimes fine)\");\n+\t\t\t\tid\n+\t\t\t} else if let PolyNature::FunctionGeneric { .. } | PolyNature::StructureGeneric { .. } =\n+\t\t\t\tnature\n+\t\t\t{\n \t\t\t\tcrate::utilities::notify!(\n \t\t\t\t\t\"Could not find argument for explicit generic {:?} (nature={:?})\",\n \t\t\t\t\tid,\ndiff --git a/checker/src/types/generics/substitution.rs b/checker/src/types/generics/substitution.rs\n--- a/checker/src/types/generics/substitution.rs\n+++ b/checker/src/types/generics/substitution.rs\n@@ -238,7 +237,8 @@ pub(crate) fn substitute(\n \t\t\t\tlet lhs = substitute(lhs, arguments, environment, types);\n \t\t\t\tlet rhs = substitute(rhs, arguments, environment, types);\n \n-\t\t\t\tmatch evaluate_mathematical_operation(lhs, operator, rhs, types, false) {\n+\t\t\t\tmatch evaluate_mathematical_operation(lhs, operator, rhs, environment, types, false)\n+\t\t\t\t{\n \t\t\t\t\tOk(result) => result,\n \t\t\t\t\tErr(()) => {\n \t\t\t\t\t\tunreachable!(\ndiff --git a/checker/src/types/generics/substitution.rs b/checker/src/types/generics/substitution.rs\n--- a/checker/src/types/generics/substitution.rs\n+++ b/checker/src/types/generics/substitution.rs\n@@ -249,14 +249,6 @@ pub(crate) fn substitute(\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\tConstructor::UnaryOperator { operand, operator, .. } => {\n-\t\t\t\tlet operand = substitute(operand, arguments, environment, types);\n-\t\t\t\tevaluate_pure_unary_operator(\n-\t\t\t\t\toperator, operand, types,\n-\t\t\t\t\t// Restrictions should have been made ahead of time\n-\t\t\t\t\tfalse,\n-\t\t\t\t)\n-\t\t\t}\n \t\t\tConstructor::ConditionalResult {\n \t\t\t\tcondition,\n \t\t\t\ttruthy_result,\ndiff --git a/checker/src/types/generics/substitution.rs b/checker/src/types/generics/substitution.rs\n--- a/checker/src/types/generics/substitution.rs\n+++ b/checker/src/types/generics/substitution.rs\n@@ -415,11 +407,11 @@ pub(crate) fn substitute(\n \t\t\t\t\t\t}\n \t\t\t\t\t\tOk(value) => {\n \t\t\t\t\t\t\tcrate::utilities::notify!(\"TODO {:?}\", value);\n-\t\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t\t\t}\n \t\t\t\t\t\tErr(err) => {\n \t\t\t\t\t\t\tcrate::utilities::notify!(\"{:?}\", err);\n-\t\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t} else {\ndiff --git a/checker/src/types/generics/substitution.rs b/checker/src/types/generics/substitution.rs\n--- a/checker/src/types/generics/substitution.rs\n+++ b/checker/src/types/generics/substitution.rs\n@@ -428,7 +420,7 @@ pub(crate) fn substitute(\n \t\t\t\t\t\ton_type,\n \t\t\t\t\t\tunder\n \t\t\t\t\t);\n-\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t}\n \t\t\t}\n \t\t\tConstructor::Image { .. } => {\ndiff --git a/checker/src/types/generics/substitution.rs b/checker/src/types/generics/substitution.rs\n--- a/checker/src/types/generics/substitution.rs\n+++ b/checker/src/types/generics/substitution.rs\n@@ -475,7 +467,21 @@ pub(crate) fn substitute(\n \t\t\t\tlet lhs = substitute(lhs, arguments, environment, types);\n \t\t\t\tlet rhs = substitute(rhs, arguments, environment, types);\n \n-\t\t\t\tevaluate_equality_inequality_operation(lhs, &operator, rhs, types, false)\n+\t\t\t\tlet result = evaluate_equality_inequality_operation(\n+\t\t\t\t\tlhs,\n+\t\t\t\t\t&operator,\n+\t\t\t\t\trhs,\n+\t\t\t\t\tenvironment,\n+\t\t\t\t\ttypes,\n+\t\t\t\t\tfalse,\n+\t\t\t\t);\n+\n+\t\t\t\tif let Ok((left, _warning)) = result {\n+\t\t\t\t\tleft\n+\t\t\t\t} else {\n+\t\t\t\t\tcrate::utilities::notify!(\"Error here\");\n+\t\t\t\t\tTypeId::OPEN_BOOLEAN_TYPE\n+\t\t\t\t}\n \t\t\t}\n \t\t\tConstructor::TypeOperator(op) => match op {\n \t\t\t\tcrate::types::TypeOperator::TypeOf(ty) => {\ndiff --git a/checker/src/types/generics/substitution.rs b/checker/src/types/generics/substitution.rs\n--- a/checker/src/types/generics/substitution.rs\n+++ b/checker/src/types/generics/substitution.rs\n@@ -487,6 +493,7 @@ pub(crate) fn substitute(\n \t\t\t\t}\n \t\t\t\tcrate::types::TypeOperator::IsPrototype { lhs, rhs_prototype } => {\n \t\t\t\t\tlet lhs = substitute(lhs, arguments, environment, types);\n+\t\t\t\t\tlet rhs_prototype = substitute(rhs_prototype, arguments, environment, types);\n \t\t\t\t\tcrate::features::instance_of_operator_rhs_prototype(\n \t\t\t\t\t\tlhs,\n \t\t\t\t\t\trhs_prototype,\ndiff --git a/checker/src/types/intrinsics.rs b/checker/src/types/intrinsics.rs\n--- a/checker/src/types/intrinsics.rs\n+++ b/checker/src/types/intrinsics.rs\n@@ -10,6 +10,8 @@ use crate::{\n \n use super::Type;\n \n+pub use crate::utilities::float_range::FloatRange;\n+\n /// These are special marker types (using [`Type::Alias`])\n ///\n /// Some are from TSC, others are added by me!\ndiff --git a/checker/src/types/intrinsics.rs b/checker/src/types/intrinsics.rs\n--- a/checker/src/types/intrinsics.rs\n+++ b/checker/src/types/intrinsics.rs\n@@ -118,43 +120,108 @@ pub fn is_intrinsic(id: TypeId) -> bool {\n \n #[must_use]\n pub fn ezno_number_intrinsic(id: TypeId) -> bool {\n-\tmatches!(id, TypeId::LESS_THAN | TypeId::GREATER_THAN | TypeId::MULTIPLE_OF)\n+\tmatches!(id, TypeId::INCLUSIVE_RANGE | TypeId::EXCLUSIVE_RANGE | TypeId::MULTIPLE_OF)\n }\n \n #[must_use]\n-pub fn get_greater_than(on: TypeId, types: &TypeStore) -> Option<TypeId> {\n+pub fn get_greater_than(on: TypeId, types: &TypeStore) -> Option<(bool, TypeId)> {\n \tlet on = get_constraint(on, types).unwrap_or(on);\n \tlet ty = types.get_type_by_id(on);\n \tif let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n-\t\ton: TypeId::GREATER_THAN,\n+\t\ton: on @ (TypeId::INCLUSIVE_RANGE | TypeId::EXCLUSIVE_RANGE),\n \t\targuments,\n \t}) = ty\n \t{\n-\t\targuments.get_structure_restriction(TypeId::NUMBER_GENERIC)\n+\t\tlet inclusive = *on == TypeId::INCLUSIVE_RANGE;\n+\t\tlet floor = arguments.get_structure_restriction(TypeId::NUMBER_FLOOR_GENERIC).unwrap();\n+\t\tSome((inclusive, floor))\n \t} else if let Type::And(lhs, rhs) = ty {\n \t\tget_greater_than(*lhs, types).or_else(|| get_greater_than(*rhs, types))\n+\t} else if let Type::Constant(crate::Constant::Number(..)) = ty {\n+\t\tSome((true, on))\n \t} else {\n \t\tNone\n \t}\n }\n \n #[must_use]\n-pub fn get_less_than(on: TypeId, types: &TypeStore) -> Option<TypeId> {\n+pub fn get_less_than(on: TypeId, types: &TypeStore) -> Option<(bool, TypeId)> {\n \tlet on = get_constraint(on, types).unwrap_or(on);\n \tlet ty = types.get_type_by_id(on);\n \tif let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n-\t\ton: TypeId::LESS_THAN,\n+\t\ton: on @ (TypeId::INCLUSIVE_RANGE | TypeId::EXCLUSIVE_RANGE),\n \t\targuments,\n \t}) = ty\n \t{\n-\t\targuments.get_structure_restriction(TypeId::NUMBER_GENERIC)\n+\t\tlet inclusive = *on == TypeId::INCLUSIVE_RANGE;\n+\t\tSome((\n+\t\t\tinclusive,\n+\t\t\targuments.get_structure_restriction(TypeId::NUMBER_CEILING_GENERIC).unwrap(),\n+\t\t))\n \t} else if let Type::And(lhs, rhs) = ty {\n \t\tget_less_than(*lhs, types).or_else(|| get_less_than(*rhs, types))\n+\t} else if let Type::Constant(crate::Constant::Number(..)) = ty {\n+\t\tSome((true, on))\n+\t} else {\n+\t\tNone\n+\t}\n+}\n+\n+#[must_use]\n+pub fn get_range(on: TypeId, types: &TypeStore) -> Option<FloatRange> {\n+\tlet on = get_constraint(on, types).unwrap_or(on);\n+\tlet ty = types.get_type_by_id(on);\n+\tif let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n+\t\ton: on @ (TypeId::INCLUSIVE_RANGE | TypeId::EXCLUSIVE_RANGE),\n+\t\targuments,\n+\t}) = ty\n+\t{\n+\t\tlet inclusive = *on == TypeId::INCLUSIVE_RANGE;\n+\t\tcrate::utilities::notify!(\"{:?} {:?}\", on, arguments);\n+\t\tlet floor = arguments.get_structure_restriction(TypeId::NUMBER_FLOOR_GENERIC).unwrap();\n+\t\tlet ceiling = arguments.get_structure_restriction(TypeId::NUMBER_CEILING_GENERIC).unwrap();\n+\t\tif let (\n+\t\t\tType::Constant(crate::Constant::Number(floor)),\n+\t\t\tType::Constant(crate::Constant::Number(ceiling)),\n+\t\t) = (types.get_type_by_id(floor), types.get_type_by_id(ceiling))\n+\t\t{\n+\t\t\tlet (floor, ceiling) = (*floor, *ceiling);\n+\t\t\tSome(if inclusive {\n+\t\t\t\tFloatRange::Inclusive { floor, ceiling }\n+\t\t\t} else {\n+\t\t\t\tFloatRange::Exclusive { floor, ceiling }\n+\t\t\t})\n+\t\t} else {\n+\t\t\tcrate::utilities::notify!(\"Not bottom top number\");\n+\t\t\tNone\n+\t\t}\n+\t} else if let Type::Constant(crate::Constant::Number(number)) = ty {\n+\t\tSome(FloatRange::single(*number))\n \t} else {\n \t\tNone\n \t}\n }\n \n+#[must_use]\n+pub fn range_to_type(range: FloatRange, types: &mut TypeStore) -> TypeId {\n+\tuse source_map::Nullable;\n+\n+\tlet on = if let FloatRange::Inclusive { .. } = range {\n+\t\tTypeId::INCLUSIVE_RANGE\n+\t} else {\n+\t\tTypeId::EXCLUSIVE_RANGE\n+\t};\n+\tlet (FloatRange::Inclusive { floor, ceiling } | FloatRange::Exclusive { floor, ceiling }) =\n+\t\trange;\n+\tlet floor = types.new_constant_type(crate::Constant::Number(floor));\n+\tlet ceiling = types.new_constant_type(crate::Constant::Number(ceiling));\n+\tlet arguments = GenericArguments::ExplicitRestrictions(crate::Map::from_iter([\n+\t\t(TypeId::NUMBER_FLOOR_GENERIC, (floor, SpanWithSource::NULL)),\n+\t\t(TypeId::NUMBER_CEILING_GENERIC, (ceiling, SpanWithSource::NULL)),\n+\t]));\n+\ttypes.register_type(Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics { on, arguments }))\n+}\n+\n #[must_use]\n pub fn get_multiple(on: TypeId, types: &TypeStore) -> Option<TypeId> {\n \tlet on = get_constraint(on, types).unwrap_or(on);\ndiff --git a/checker/src/types/intrinsics.rs b/checker/src/types/intrinsics.rs\n--- a/checker/src/types/intrinsics.rs\n+++ b/checker/src/types/intrinsics.rs\n@@ -164,9 +231,11 @@ pub fn get_multiple(on: TypeId, types: &TypeStore) -> Option<TypeId> {\n \t\targuments,\n \t}) = ty\n \t{\n-\t\targuments.get_structure_restriction(TypeId::NUMBER_GENERIC)\n+\t\targuments.get_structure_restriction(TypeId::NUMBER_FLOOR_GENERIC)\n \t} else if let Type::And(lhs, rhs) = ty {\n \t\tget_multiple(*lhs, types).or_else(|| get_multiple(*rhs, types))\n+\t} else if let Type::Constant(crate::Constant::Number(..)) = ty {\n+\t\tSome(on)\n \t} else {\n \t\tNone\n \t}\ndiff --git a/checker/src/types/intrinsics.rs b/checker/src/types/intrinsics.rs\n--- a/checker/src/types/intrinsics.rs\n+++ b/checker/src/types/intrinsics.rs\n@@ -174,22 +243,83 @@ pub fn get_multiple(on: TypeId, types: &TypeStore) -> Option<TypeId> {\n \n #[allow(clippy::match_like_matches_macro)]\n #[must_use]\n-pub fn can_be_not_a_number(on: TypeId, types: &TypeStore) -> bool {\n-\tlet on = get_constraint(on, types).unwrap_or(on);\n+pub fn is_not_not_a_number(on: TypeId, types: &TypeStore) -> bool {\n \tif on == TypeId::NOT_NOT_A_NUMBER {\n \t\ttrue\n+\t} else if on == TypeId::NUMBER_TYPE || on == TypeId::ANY_TYPE {\n+\t\tfalse\n \t} else {\n \t\tlet ty = types.get_type_by_id(on);\n \t\tif let Type::And(lhs, rhs) = ty {\n-\t\t\tcan_be_not_a_number(*lhs, types) || can_be_not_a_number(*rhs, types)\n+\t\t\tis_not_not_a_number(*lhs, types) || is_not_not_a_number(*rhs, types)\n+\t\t} else if let Type::Or(lhs, rhs) = ty {\n+\t\t\tis_not_not_a_number(*lhs, types) && is_not_not_a_number(*rhs, types)\n \t\t} else if let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n-\t\t\ton: TypeId::MULTIPLE_OF | TypeId::LESS_THAN | TypeId::GREATER_THAN,\n+\t\t\ton: TypeId::MULTIPLE_OF | TypeId::INCLUSIVE_RANGE | TypeId::EXCLUSIVE_RANGE,\n \t\t\targuments: _,\n \t\t}) = ty\n \t\t{\n \t\t\ttrue\n+\t\t} else if let Type::AliasTo { to, .. } = ty {\n+\t\t\tis_not_not_a_number(*to, types)\n+\t\t} else if let Some(constraint) = get_constraint(on, types) {\n+\t\t\tis_not_not_a_number(constraint, types)\n \t\t} else {\n-\t\t\tfalse\n+\t\t\ttrue\n \t\t}\n \t}\n }\n+\n+pub fn new_intrinsic(intrinsic: &Intrinsic, argument: TypeId, types: &mut TypeStore) -> TypeId {\n+\tuse source_map::Nullable;\n+\tlet (on, to_pair) =\n+\t\tmatch intrinsic {\n+\t\t\tIntrinsic::Uppercase => (TypeId::STRING_UPPERCASE, TypeId::STRING_GENERIC),\n+\t\t\tIntrinsic::Lowercase => (TypeId::STRING_LOWERCASE, TypeId::STRING_GENERIC),\n+\t\t\tIntrinsic::Capitalize => (TypeId::STRING_CAPITALIZE, TypeId::STRING_GENERIC),\n+\t\t\tIntrinsic::Uncapitalize => (TypeId::STRING_UNCAPITALIZE, TypeId::STRING_GENERIC),\n+\t\t\tIntrinsic::NoInfer => (TypeId::NO_INFER, TypeId::T_TYPE),\n+\t\t\tIntrinsic::Literal => (TypeId::LITERAL_RESTRICTION, TypeId::T_TYPE),\n+\t\t\tIntrinsic::LessThan => {\n+\t\t\t\tlet arguments = GenericArguments::ExplicitRestrictions(crate::Map::from_iter([\n+\t\t\t\t\t(TypeId::NUMBER_FLOOR_GENERIC, (TypeId::NEG_INFINITY, SpanWithSource::NULL)),\n+\t\t\t\t\t(TypeId::NUMBER_CEILING_GENERIC, (argument, SpanWithSource::NULL)),\n+\t\t\t\t]));\n+\n+\t\t\t\treturn types.register_type(Type::PartiallyAppliedGenerics(\n+\t\t\t\t\tPartiallyAppliedGenerics { on: TypeId::EXCLUSIVE_RANGE, arguments },\n+\t\t\t\t));\n+\t\t\t}\n+\t\t\tIntrinsic::GreaterThan => {\n+\t\t\t\tlet arguments = GenericArguments::ExplicitRestrictions(crate::Map::from_iter([\n+\t\t\t\t\t(TypeId::NUMBER_FLOOR_GENERIC, (argument, SpanWithSource::NULL)),\n+\t\t\t\t\t(TypeId::NUMBER_CEILING_GENERIC, (TypeId::INFINITY, SpanWithSource::NULL)),\n+\t\t\t\t]));\n+\n+\t\t\t\treturn types.register_type(Type::PartiallyAppliedGenerics(\n+\t\t\t\t\tPartiallyAppliedGenerics { on: TypeId::EXCLUSIVE_RANGE, arguments },\n+\t\t\t\t));\n+\t\t\t}\n+\t\t\tIntrinsic::MultipleOf => (TypeId::MULTIPLE_OF, TypeId::NUMBER_FLOOR_GENERIC),\n+\t\t\tIntrinsic::Exclusive => (TypeId::EXCLUSIVE_RESTRICTION, TypeId::T_TYPE),\n+\t\t\tIntrinsic::Not => {\n+\t\t\t\t// Double negation\n+\t\t\t\tif let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n+\t\t\t\t\ton: TypeId::NOT_RESTRICTION,\n+\t\t\t\t\targuments: GenericArguments::ExplicitRestrictions(args),\n+\t\t\t\t}) = types.get_type_by_id(argument)\n+\t\t\t\t{\n+\t\t\t\t\treturn args.get(&TypeId::T_TYPE).unwrap().0;\n+\t\t\t\t}\n+\n+\t\t\t\t(TypeId::NOT_RESTRICTION, TypeId::T_TYPE)\n+\t\t\t}\n+\t\t\tIntrinsic::CaseInsensitive => (TypeId::CASE_INSENSITIVE, TypeId::STRING_GENERIC),\n+\t\t};\n+\tlet arguments = GenericArguments::ExplicitRestrictions(crate::Map::from_iter([(\n+\t\tto_pair,\n+\t\t(argument, SpanWithSource::NULL),\n+\t)]));\n+\n+\ttypes.register_type(Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics { on, arguments }))\n+}\ndiff --git a/checker/src/types/logical.rs b/checker/src/types/logical.rs\n--- a/checker/src/types/logical.rs\n+++ b/checker/src/types/logical.rs\n@@ -51,7 +51,7 @@ impl<T> From<NeedsCalculation> for LogicalOrValid<T> {\n // pub enum MissingOrToCalculate {\n // \t/// Doesn't contain request\n // \tMissing,\n-// \t/// From [`TypeId::ERROR_TYPE`]\n+// \t/// From [`TypeId::UNIMPLEMENTED_ERROR_TYPE`]\n // \tError,\n // \t/// From [`TypeId::ANY_TYPE`]\n // \tInfer { on: TypeId },\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -33,7 +33,7 @@ pub use crate::features::objects::SpecialObject;\n use crate::{\n \tcontext::InformationChain,\n \tevents::RootReference,\n-\tfeatures::operations::{CanonicalEqualityAndInequality, MathematicalAndBitwise, PureUnary},\n+\tfeatures::operations::{CanonicalEqualityAndInequality, MathematicalAndBitwise},\n \tsubtyping::SliceArguments,\n \tDecidable, FunctionId,\n };\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -61,6 +61,7 @@ impl TypeId {\n \t/// Not to be confused with [`TypeId::NEVER_TYPE`]\n \tpub const ERROR_TYPE: Self = Self(0);\n \tpub const UNIMPLEMENTED_ERROR_TYPE: Self = Self::ERROR_TYPE;\n+\tpub const IS_ASSIGNED_VALUE_LATER: Self = Self::ERROR_TYPE;\n \n \tpub const NEVER_TYPE: Self = Self(1);\n \ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -90,72 +91,84 @@ impl TypeId {\n \t/// This points to the ???\n \tpub const SYMBOL_TYPE: Self = Self(15);\n \n-\t/// For more direct stuff and the rules\n+\t/// For direct constant and the rules\n \tpub const TRUE: Self = Self(16);\n \tpub const FALSE: Self = Self(17);\n \tpub const ZERO: Self = Self(18);\n \tpub const ONE: Self = Self(19);\n \tpub const NAN: Self = Self(20);\n-\tpub const EMPTY_STRING: Self = Self(21);\n+\tpub const NEG_INFINITY: Self = Self(21);\n+\tpub const INFINITY: Self = Self(22);\n+\tpub const FLOAT_MIN: Self = Self(23);\n+\tpub const FLOAT_MAX: Self = Self(24);\n+\tpub const FLOAT_EPSILON: Self = Self(25);\n+\t/// For bitwise negation\n+\tpub const MAX_U32: Self = Self(26);\n+\t/// \"\"\n+\tpub const EMPTY_STRING: Self = Self(27);\n \n \t/// Shortcut for inferred this\n \t/// TODO remove\n-\tpub const ANY_INFERRED_FREE_THIS: Self = Self(22);\n+\tpub const ANY_INFERRED_FREE_THIS: Self = Self(28);\n \n \t/// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target>\n-\tpub const NEW_TARGET_ARG: Self = Self(23);\n+\tpub const NEW_TARGET_ARG: Self = Self(29);\n \n-\tpub const IMPORT_META: Self = Self(24);\n+\tpub const IMPORT_META: Self = Self(30);\n \n \t// known symbols\n \t/// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator>\n-\tpub const SYMBOL_ITERATOR: Self = Self(25);\n+\tpub const SYMBOL_ITERATOR: Self = Self(31);\n \t/// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator>\n-\tpub const SYMBOL_ASYNC_ITERATOR: Self = Self(26);\n+\tpub const SYMBOL_ASYNC_ITERATOR: Self = Self(32);\n \t/// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance>\n-\tpub const SYMBOL_HAS_INSTANCE: Self = Self(27);\n+\tpub const SYMBOL_HAS_INSTANCE: Self = Self(33);\n \t/// <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive>\n-\tpub const SYMBOL_TO_PRIMITIVE: Self = Self(28);\n+\tpub const SYMBOL_TO_PRIMITIVE: Self = Self(34);\n \n \t// TSC intrinsics\n-\tpub const STRING_GENERIC: Self = Self(29);\n-\tpub const STRING_UPPERCASE: Self = Self(30);\n-\tpub const STRING_LOWERCASE: Self = Self(31);\n-\tpub const STRING_CAPITALIZE: Self = Self(32);\n-\tpub const STRING_UNCAPITALIZE: Self = Self(33);\n-\tpub const NO_INFER: Self = Self(34);\n+\tpub const STRING_GENERIC: Self = Self(35);\n+\tpub const STRING_UPPERCASE: Self = Self(36);\n+\tpub const STRING_LOWERCASE: Self = Self(37);\n+\tpub const STRING_CAPITALIZE: Self = Self(38);\n+\tpub const STRING_UNCAPITALIZE: Self = Self(39);\n+\tpub const NO_INFER: Self = Self(40);\n \n \t/// Might be a special type in TSC\n-\tpub const READONLY_RESTRICTION: Self = Self(35);\n+\tpub const READONLY_RESTRICTION: Self = Self(41);\n \n \t/// For mapped types\n-\tpub const NON_OPTIONAL_KEY_ARGUMENT: Self = Self(36);\n+\tpub const NON_OPTIONAL_KEY_ARGUMENT: Self = Self(42);\n \t/// For mapped types\n-\tpub const WRITABLE_KEY_ARGUMENT: Self = Self(37);\n+\tpub const WRITABLE_KEY_ARGUMENT: Self = Self(43);\n \n \t// Ezno intrinsics\n \n-\t/// Used in [`Self::LESS_THAN`], [`Self::LESS_THAN`] and [`Self::MULTIPLE_OF`]\n-\tpub const NUMBER_GENERIC: Self = Self(38);\n-\tpub const LESS_THAN: Self = Self(39);\n-\tpub const GREATER_THAN: Self = Self(40);\n-\tpub const MULTIPLE_OF: Self = Self(41);\n-\tpub const NOT_NOT_A_NUMBER: Self = Self(42);\n-\tpub const NUMBER_BUT_NOT_NOT_A_NUMBER: Self = Self(43);\n+\t/// Used in [`Self::INCLUSIVE_RANGE`], [`Self::EXCLUSIVE_RANGE`] and [`Self::MULTIPLE_OF`]\n+\tpub const NUMBER_FLOOR_GENERIC: Self = Self(44);\n+\tpub const NUMBER_CEILING_GENERIC: Self = Self(45);\n+\tpub const INCLUSIVE_RANGE: Self = Self(46);\n+\tpub const EXCLUSIVE_RANGE: Self = Self(47);\n+\tpub const MULTIPLE_OF: Self = Self(48);\n+\tpub const NOT_NOT_A_NUMBER: Self = Self(49);\n+\tpub const NUMBER_BUT_NOT_NOT_A_NUMBER: Self = Self(50);\n \n-\tpub const LITERAL_RESTRICTION: Self = Self(44);\n-\tpub const EXCLUSIVE_RESTRICTION: Self = Self(45);\n-\tpub const NOT_RESTRICTION: Self = Self(46);\n+\tpub const LITERAL_RESTRICTION: Self = Self(51);\n+\tpub const EXCLUSIVE_RESTRICTION: Self = Self(52);\n+\tpub const NOT_RESTRICTION: Self = Self(53);\n \n \t/// This is needed for the TSC string intrinsics\n-\tpub const CASE_INSENSITIVE: Self = Self(47);\n+\tpub const CASE_INSENSITIVE: Self = Self(54);\n \n \t/// WIP\n-\tpub const OPEN_BOOLEAN_TYPE: Self = Self(48);\n-\tpub const OPEN_NUMBER_TYPE: Self = Self(49);\n+\tpub const OPEN_BOOLEAN_TYPE: Self = Self(55);\n+\tpub const OPEN_NUMBER_TYPE: Self = Self(56);\n+\n+\t/// For `+` operator\n+\tpub const STRING_OR_NUMBER: Self = Self(57);\n \n \t/// Above add one (because [`TypeId`] starts at zero). Used to assert that the above is all correct\n-\tpub(crate) const INTERNAL_TYPE_COUNT: usize = 50;\n+\tpub(crate) const INTERNAL_TYPE_COUNT: usize = 58;\n }\n \n #[derive(Debug, binary_serialize_derive::BinarySerializable)]\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -356,23 +369,21 @@ impl Type {\n \n /// - Some of these can be specialised, others are only created via event specialisation\n /// - Note that no || and && etc. This is handled using [`Constructor::ConditionalResult`]\n+/// - Unary operations are encoded via [`Constructor::BinaryOperator`] equivalents\n #[derive(Clone, Debug, binary_serialize_derive::BinarySerializable)]\n pub enum Constructor {\n-\t// TODO separate add?\n \tBinaryOperator {\n \t\tlhs: TypeId,\n \t\toperator: MathematicalAndBitwise,\n \t\trhs: TypeId,\n+\t\t/// for add + number intrinsics\n+\t\tresult: TypeId,\n \t},\n \tCanonicalRelationOperator {\n \t\tlhs: TypeId,\n \t\toperator: CanonicalEqualityAndInequality,\n \t\trhs: TypeId,\n \t},\n-\tUnaryOperator {\n-\t\toperator: PureUnary,\n-\t\toperand: TypeId,\n-\t},\n \t/// JS type based operations\n \tTypeOperator(TypeOperator),\n \t/// TS operation\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -417,7 +428,6 @@ impl Constructor {\n \t\t\t| Constructor::Image { result, .. } => Some(*result),\n \t\t\tConstructor::BinaryOperator { .. }\n \t\t\t| Constructor::CanonicalRelationOperator { .. }\n-\t\t\t| Constructor::UnaryOperator { .. }\n \t\t\t| Constructor::TypeExtends(_)\n \t\t\t| Constructor::TypeOperator(_) => None,\n \t\t\t// TODO or symbol\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -426,6 +436,22 @@ impl Constructor {\n \t}\n }\n \n+#[must_use]\n+pub fn as_logical_not(constructor: &Constructor, types: &TypeStore) -> Option<TypeId> {\n+\t// TODO technically any falsy, truthy reverse pair is okay\n+\tif let Constructor::ConditionalResult {\n+\t\tcondition,\n+\t\ttruthy_result: TypeId::FALSE,\n+\t\totherwise_result: TypeId::TRUE,\n+\t\tresult_union: _,\n+\t} = constructor\n+\t{\n+\t\tSome(helpers::get_origin(*condition, types))\n+\t} else {\n+\t\tNone\n+\t}\n+}\n+\n #[must_use]\n pub fn as_logical_and(constructor: &Constructor, types: &TypeStore) -> Option<(TypeId, TypeId)> {\n \tif let Constructor::ConditionalResult {\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -535,6 +561,7 @@ impl TypeExtends {\n \t\t}\n \t}\n \n+\t#[must_use]\n \tpub fn equal_to_rhs(&self, rhs: TypeId, types: &TypeStore) -> bool {\n \t\tif let Ok(TypeExtends { item, extends }) = Self::from_type(rhs, types) {\n \t\t\t// TODO get origin on item\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -645,45 +672,8 @@ pub(crate) fn get_constraint(on: TypeId, types: &TypeStore) -> Option<TypeId> {\n \tmatch types.get_type_by_id(on) {\n \t\tType::RootPolyType(nature) => Some(nature.get_constraint()),\n \t\tType::Constructor(constructor) => match constructor.clone() {\n-\t\t\tConstructor::BinaryOperator { lhs, operator, rhs } => {\n-\t\t\t\tif let MathematicalAndBitwise::Add = operator {\n-\t\t\t\t\tlet lhs = get_larger_type(lhs, types);\n-\t\t\t\t\tlet rhs = get_larger_type(rhs, types);\n-\t\t\t\t\t// TODO these need to be generated\n-\t\t\t\t\tif let (TypeId::NUMBER_TYPE, TypeId::NUMBER_TYPE) = (lhs, rhs) {\n-\t\t\t\t\t\tSome(TypeId::NUMBER_TYPE)\n-\t\t\t\t\t} else if let (TypeId::STRING_TYPE, _) | (_, TypeId::STRING_TYPE) = (lhs, rhs) {\n-\t\t\t\t\t\tSome(TypeId::STRING_TYPE)\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tcrate::utilities::notify!(\"lhs = {:?}\", types.get_type_by_id(lhs));\n-\t\t\t\t\t\tcrate::utilities::notify!(\"TODO use existing conditional\");\n-\t\t\t\t\t\tSome(TypeId::NUMBER_TYPE)\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tSome(TypeId::NUMBER_TYPE)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tConstructor::UnaryOperator { operand: _, operator } => {\n-\t\t\t\tSome(match operator {\n-\t\t\t\t\tPureUnary::LogicalNot => TypeId::BOOLEAN_TYPE,\n-\t\t\t\t\tPureUnary::Negation | PureUnary::BitwiseNot => TypeId::NUMBER_TYPE,\n-\t\t\t\t})\n-\t\t\t\t// if *constraint == TypeId::ANY_TYPE && mutable_context {\n-\t\t\t\t// \tlet (operand, operator) = (operand.clone(), operator.clone());\n-\t\t\t\t// \tlet constraint = to(self, data);\n-\t\t\t\t// \tself.modify_type(\n-\t\t\t\t// \t\ton,\n-\t\t\t\t// \t\tSome(Type::Constructor(Constructor::UnaryOperator {\n-\t\t\t\t// \t\t\toperator,\n-\t\t\t\t// \t\t\toperand,\n-\t\t\t\t// \t\t\t\t\t\t\t\t// \t\t})),\n-\t\t\t\t// \t);\n-\t\t\t\t// \tSome(constraint)\n-\t\t\t\t// } else {\n-\t\t\t\t// \tSome(*constraint)\n-\t\t\t\t// }\n-\t\t\t}\n-\t\t\tConstructor::Awaited { on: _, result }\n+\t\t\tConstructor::BinaryOperator { result, .. }\n+\t\t\t| Constructor::Awaited { on: _, result }\n \t\t\t| Constructor::Image { on: _, with: _, result } => Some(result),\n \t\t\tConstructor::Property { on: _, under: _, result, mode: _ } => {\n \t\t\t\t// crate::utilities::notify!(\"Here, result of a property get\");\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -722,7 +712,7 @@ pub fn get_larger_type(on: TypeId, types: &TypeStore) -> TypeId {\n \tif let Some(poly_base) = get_constraint(on, types) {\n \t\tpoly_base\n \t} else if let Type::Constant(cst) = types.get_type_by_id(on) {\n-\t\tcst.get_backing_type_id()\n+\t\tcst.get_backing_type()\n \t} else {\n \t\ton\n \t}\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -931,6 +921,8 @@ impl Counter {\n \t\t\t\t\tlhs: *value,\n \t\t\t\t\toperator: MathematicalAndBitwise::Add,\n \t\t\t\t\trhs: TypeId::ONE,\n+\t\t\t\t\t// TODO could be greater than\n+\t\t\t\t\tresult: TypeId::NUMBER_TYPE,\n \t\t\t\t}));\n \t\t\t}\n \t\t}\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -942,6 +934,8 @@ impl Counter {\n \t\t\tlhs: ty,\n \t\t\toperator: MathematicalAndBitwise::Add,\n \t\t\trhs: current,\n+\t\t\t// TODO could be greater than\n+\t\t\tresult: TypeId::NUMBER_TYPE,\n \t\t}));\n \t\t*self = Counter::AddTo(new);\n \t}\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -963,108 +957,113 @@ impl Counter {\n \t}\n }\n \n-/// To fill in for TSC behavior for mapped types\n-#[must_use]\n-pub fn references_key_of(id: TypeId, types: &TypeStore) -> bool {\n-\tmatch types.get_type_by_id(id) {\n-\t\tType::AliasTo { to, .. } => references_key_of(*to, types),\n-\t\tType::Or(lhs, rhs) | Type::And(lhs, rhs) => {\n-\t\t\treferences_key_of(*lhs, types) || references_key_of(*rhs, types)\n-\t\t}\n-\t\tType::RootPolyType(c) => references_key_of(c.get_constraint(), types),\n-\t\tType::Constructor(c) => {\n-\t\t\tif let Constructor::KeyOf(..) = c {\n-\t\t\t\ttrue\n-\t\t\t} else if let Constructor::BinaryOperator { lhs, rhs, operator: _ } = c {\n+pub(crate) mod helpers {\n+\tuse super::{\n+\t\tget_constraint, subtyping, Constructor, GenericArguments, GenericChain, InformationChain,\n+\t\tPartiallyAppliedGenerics, PolyNature, Type, TypeId, TypeStore,\n+\t};\n+\n+\t/// To fill in for TSC behavior for mapped types\n+\t#[must_use]\n+\tpub fn references_key_of(id: TypeId, types: &TypeStore) -> bool {\n+\t\tmatch types.get_type_by_id(id) {\n+\t\t\tType::AliasTo { to, .. } => references_key_of(*to, types),\n+\t\t\tType::Or(lhs, rhs) | Type::And(lhs, rhs) => {\n \t\t\t\treferences_key_of(*lhs, types) || references_key_of(*rhs, types)\n-\t\t\t} else {\n-\t\t\t\t// TODO might have missed something here\n-\t\t\t\tfalse\n \t\t\t}\n-\t\t}\n-\t\tType::PartiallyAppliedGenerics(a) => {\n-\t\t\tif let GenericArguments::ExplicitRestrictions(ref e) = a.arguments {\n-\t\t\t\te.0.iter().any(|(_, (lhs, _))| references_key_of(*lhs, types))\n-\t\t\t} else {\n-\t\t\t\tfalse\n+\t\t\tType::RootPolyType(c) => references_key_of(c.get_constraint(), types),\n+\t\t\tType::Constructor(c) => {\n+\t\t\t\tif let Constructor::KeyOf(..) = c {\n+\t\t\t\t\ttrue\n+\t\t\t\t} else if let Constructor::BinaryOperator { lhs, rhs, operator: _, result: _ } = c {\n+\t\t\t\t\treferences_key_of(*lhs, types) || references_key_of(*rhs, types)\n+\t\t\t\t} else {\n+\t\t\t\t\tcrate::utilities::notify!(\"TODO might have missed keyof {:?}\", c);\n+\t\t\t\t\tfalse\n+\t\t\t\t}\n \t\t\t}\n+\t\t\tType::PartiallyAppliedGenerics(a) => {\n+\t\t\t\tif let GenericArguments::ExplicitRestrictions(ref e) = a.arguments {\n+\t\t\t\t\te.0.iter().any(|(_, (lhs, _))| references_key_of(*lhs, types))\n+\t\t\t\t} else {\n+\t\t\t\t\tfalse\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tType::Interface { .. }\n+\t\t\t| Type::Class { .. }\n+\t\t\t| Type::Constant(_)\n+\t\t\t| Type::Narrowed { .. }\n+\t\t\t| Type::FunctionReference(_)\n+\t\t\t| Type::Object(_)\n+\t\t\t| Type::SpecialObject(_) => false,\n \t\t}\n-\t\tType::Interface { .. }\n-\t\t| Type::Class { .. }\n-\t\t| Type::Constant(_)\n-\t\t| Type::Narrowed { .. }\n-\t\t| Type::FunctionReference(_)\n-\t\t| Type::Object(_)\n-\t\t| Type::SpecialObject(_) => false,\n \t}\n-}\n \n-#[allow(clippy::match_like_matches_macro)]\n-#[must_use]\n-pub fn type_is_error(ty: TypeId, types: &TypeStore) -> bool {\n-\tif ty == TypeId::ERROR_TYPE {\n-\t\ttrue\n-\t} else if let Type::RootPolyType(PolyNature::Error(_)) = types.get_type_by_id(ty) {\n-\t\ttrue\n-\t} else {\n-\t\tfalse\n+\t#[allow(clippy::match_like_matches_macro)]\n+\t#[must_use]\n+\tpub fn _type_is_error(ty: TypeId, types: &TypeStore) -> bool {\n+\t\tif ty == TypeId::UNIMPLEMENTED_ERROR_TYPE {\n+\t\t\ttrue\n+\t\t} else if let Type::RootPolyType(PolyNature::Error(_)) = types.get_type_by_id(ty) {\n+\t\t\ttrue\n+\t\t} else {\n+\t\t\tfalse\n+\t\t}\n \t}\n-}\n \n-/// TODO want to skip mapped generics because that would break subtyping\n-#[must_use]\n-pub fn get_conditional(ty: TypeId, types: &TypeStore) -> Option<(TypeId, TypeId, TypeId)> {\n-\tmatch types.get_type_by_id(ty) {\n-\t\tType::Constructor(crate::types::Constructor::ConditionalResult {\n-\t\t\tcondition,\n-\t\t\ttruthy_result,\n-\t\t\totherwise_result,\n-\t\t\tresult_union: _,\n-\t\t}) => Some((*condition, *truthy_result, *otherwise_result)),\n-\t\tType::Or(left, right) => Some((TypeId::OPEN_BOOLEAN_TYPE, *left, *right)),\n-\t\t// For reasons !\n-\t\tType::RootPolyType(PolyNature::MappedGeneric { .. }) => None,\n-\t\t_ => {\n-\t\t\tif let Some(constraint) = get_constraint(ty, types) {\n-\t\t\t\tget_conditional(constraint, types)\n-\t\t\t} else {\n-\t\t\t\tNone\n+\t/// TODO want to skip mapped generics because that would break subtyping\n+\t#[must_use]\n+\tpub fn get_conditional(ty: TypeId, types: &TypeStore) -> Option<(TypeId, TypeId, TypeId)> {\n+\t\tmatch types.get_type_by_id(ty) {\n+\t\t\tType::Constructor(crate::types::Constructor::ConditionalResult {\n+\t\t\t\tcondition,\n+\t\t\t\ttruthy_result,\n+\t\t\t\totherwise_result,\n+\t\t\t\tresult_union: _,\n+\t\t\t}) => Some((*condition, *truthy_result, *otherwise_result)),\n+\t\t\tType::Or(left, right) => Some((TypeId::OPEN_BOOLEAN_TYPE, *left, *right)),\n+\t\t\t// For reasons !\n+\t\t\tType::RootPolyType(PolyNature::MappedGeneric { .. }) => None,\n+\t\t\t_ => {\n+\t\t\t\tif let Some(constraint) = get_constraint(ty, types) {\n+\t\t\t\t\tget_conditional(constraint, types)\n+\t\t\t\t} else {\n+\t\t\t\t\tNone\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n-}\n \n-/// TODO wip\n-#[must_use]\n-pub fn is_pseudo_continous((ty, generics): (TypeId, GenericChain), types: &TypeStore) -> bool {\n-\tif let TypeId::NUMBER_TYPE | TypeId::STRING_TYPE = ty {\n-\t\ttrue\n-\t} else if let Some(arg) = generics.as_ref().and_then(|args| args.get_single_argument(ty)) {\n-\t\tis_pseudo_continous((arg, generics), types)\n-\t} else {\n-\t\tlet ty = types.get_type_by_id(ty);\n-\t\tif let Type::Or(left, right) = ty {\n-\t\t\tis_pseudo_continous((*left, generics), types)\n-\t\t\t\t|| is_pseudo_continous((*right, generics), types)\n-\t\t} else if let Type::And(left, right) = ty {\n-\t\t\tis_pseudo_continous((*left, generics), types)\n-\t\t\t\t&& is_pseudo_continous((*right, generics), types)\n-\t\t} else if let Type::RootPolyType(PolyNature::MappedGeneric { extends, .. }) = ty {\n-\t\t\tis_pseudo_continous((*extends, generics), types)\n+\t/// TODO wip\n+\t#[must_use]\n+\tpub fn is_pseudo_continous((ty, generics): (TypeId, GenericChain), types: &TypeStore) -> bool {\n+\t\tif let TypeId::NUMBER_TYPE | TypeId::STRING_TYPE = ty {\n+\t\t\ttrue\n+\t\t} else if let Some(arg) = generics.as_ref().and_then(|args| args.get_single_argument(ty)) {\n+\t\t\tis_pseudo_continous((arg, generics), types)\n \t\t} else {\n-\t\t\tfalse\n+\t\t\tlet ty = types.get_type_by_id(ty);\n+\t\t\tif let Type::Or(left, right) = ty {\n+\t\t\t\tis_pseudo_continous((*left, generics), types)\n+\t\t\t\t\t|| is_pseudo_continous((*right, generics), types)\n+\t\t\t} else if let Type::And(left, right) = ty {\n+\t\t\t\tis_pseudo_continous((*left, generics), types)\n+\t\t\t\t\t&& is_pseudo_continous((*right, generics), types)\n+\t\t\t} else if let Type::RootPolyType(PolyNature::MappedGeneric { extends, .. }) = ty {\n+\t\t\t\tis_pseudo_continous((*extends, generics), types)\n+\t\t\t} else {\n+\t\t\t\tfalse\n+\t\t\t}\n \t\t}\n \t}\n-}\n \n-#[must_use]\n-pub fn is_inferrable_type(ty: TypeId) -> bool {\n-\tmatches!(ty, TypeId::ANY_TO_INFER_TYPE | TypeId::OBJECT_TYPE)\n-}\n-\n-pub(crate) mod helpers {\n-\tuse super::{subtyping, InformationChain, Type, TypeId, TypeStore};\n+\t#[must_use]\n+\tpub fn is_inferrable_type(ty: TypeId) -> bool {\n+\t\tmatches!(ty, TypeId::ANY_TO_INFER_TYPE | TypeId::OBJECT_TYPE)\n+\t}\n \n+\t/// For quick checking\n+\t#[must_use]\n \tpub fn simple_subtype(\n \t\texpr_ty: TypeId,\n \t\tto_satisfy: TypeId,\ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -1075,7 +1074,7 @@ pub(crate) mod helpers {\n \t\t\talready_checked: Default::default(),\n \t\t\tmode: Default::default(),\n \t\t\tcontributions: Default::default(),\n-\t\t\tothers: subtyping::SubTypingOptions { allow_errors: false },\n+\t\t\tothers: subtyping::SubTypingOptions { allow_errors: true },\n \t\t\tobject_constraints: None,\n \t\t};\n \ndiff --git a/checker/src/types/mod.rs b/checker/src/types/mod.rs\n--- a/checker/src/types/mod.rs\n+++ b/checker/src/types/mod.rs\n@@ -1091,4 +1090,18 @@ pub(crate) mod helpers {\n \t\t\tty\n \t\t}\n \t}\n+\n+\t/// Temp fix for equality of narrowing stuff\n+\tpub fn is_not_of_constant(ty: TypeId, types: &TypeStore) -> bool {\n+\t\tif let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n+\t\t\ton: TypeId::NOT_RESTRICTION,\n+\t\t\targuments,\n+\t\t}) = types.get_type_by_id(ty)\n+\t\t{\n+\t\t\tlet inner = arguments.get_structure_restriction(TypeId::T_TYPE).unwrap();\n+\t\t\ttypes.get_type_by_id(inner).is_constant()\n+\t\t} else {\n+\t\t\tfalse\n+\t\t}\n+\t}\n }\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -87,9 +87,11 @@ pub fn print_type_into_buf<C: InformationChain>(\n \t\t\tbuf.push_str(\" | \");\n \t\t\tprint_type_into_buf(*b, buf, cycles, args, types, info, debug);\n \t\t}\n-\t\tType::Narrowed { narrowed_to, .. } => {\n+\t\tType::Narrowed { narrowed_to, from } => {\n \t\t\tif debug {\n-\t\t\t\tbuf.push_str(\"(narrowed) \");\n+\t\t\t\tbuf.push_str(\"(narrowed from \");\n+\t\t\t\tprint_type_into_buf(*from, buf, cycles, args, types, info, debug);\n+\t\t\t\tbuf.push_str(\") \");\n \t\t\t}\n \t\t\tprint_type_into_buf(*narrowed_to, buf, cycles, args, types, info, debug);\n \t\t}\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -146,6 +148,9 @@ pub fn print_type_into_buf<C: InformationChain>(\n \t\t\t\t}\n \t\t\t}\n \t\t\tPolyNature::InferGeneric { name, extends } => {\n+\t\t\t\tif debug {\n+\t\t\t\t\twrite!(buf, \"[IG {}] @ \", ty.0).unwrap();\n+\t\t\t\t}\n \t\t\t\tbuf.push_str(\"infer \");\n \t\t\t\tbuf.push_str(name);\n \t\t\t\tif *extends != TypeId::ANY_TYPE {\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -195,6 +200,26 @@ pub fn print_type_into_buf<C: InformationChain>(\n \t\t\t}\n \t\t},\n \t\tType::PartiallyAppliedGenerics(PartiallyAppliedGenerics { on, arguments }) => {\n+\t\t\t// TypeId::INCLUSIVE_RANGE |\n+\t\t\tif let TypeId::EXCLUSIVE_RANGE = *on {\n+\t\t\t\t// let inclusive = *on == TypeId::INCLUSIVE_RANGE;\n+\t\t\t\tlet floor =\n+\t\t\t\t\targuments.get_structure_restriction(TypeId::NUMBER_FLOOR_GENERIC).unwrap();\n+\t\t\t\tlet ceiling =\n+\t\t\t\t\targuments.get_structure_restriction(TypeId::NUMBER_CEILING_GENERIC).unwrap();\n+\t\t\t\tif let TypeId::NEG_INFINITY = floor {\n+\t\t\t\t\tbuf.push_str(\"LessThan<\");\n+\t\t\t\t\tprint_type_into_buf(ceiling, buf, cycles, args, types, info, debug);\n+\t\t\t\t\tbuf.push('>');\n+\t\t\t\t\treturn;\n+\t\t\t\t} else if let TypeId::INFINITY = ceiling {\n+\t\t\t\t\tbuf.push_str(\"GreaterThan<\");\n+\t\t\t\t\tprint_type_into_buf(floor, buf, cycles, args, types, info, debug);\n+\t\t\t\t\tbuf.push('>');\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\tif debug {\n \t\t\t\twrite!(buf, \"SG({:?})(\", ty.0).unwrap();\n \t\t\t\tprint_type_into_buf(*on, buf, cycles, args, types, info, debug);\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -262,7 +287,7 @@ pub fn print_type_into_buf<C: InformationChain>(\n \t\t\t\tresult_union: _,\n \t\t\t} => {\n \t\t\t\tif let (TypeId::NEVER_TYPE, Ok(crate::types::TypeExtends { item, extends })) =\n-\t\t\t\t\t(TypeId::NEVER_TYPE, crate::types::TypeExtends::from_type(*condition, types))\n+\t\t\t\t\t(*otherwise_result, crate::types::TypeExtends::from_type(*condition, types))\n \t\t\t\t{\n \t\t\t\t\tbuf.push_str(\"asserts \");\n \t\t\t\t\tprint_type_into_buf(item, buf, cycles, args, types, info, debug);\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -386,7 +411,7 @@ pub fn print_type_into_buf<C: InformationChain>(\n \t\t\t\t}\n \t\t\t}\n \t\t\tconstructor if debug => match constructor {\n-\t\t\t\tConstructor::BinaryOperator { lhs, operator, rhs } => {\n+\t\t\t\tConstructor::BinaryOperator { lhs, operator, rhs, result: _ } => {\n \t\t\t\t\tprint_type_into_buf(*lhs, buf, cycles, args, types, info, debug);\n \t\t\t\t\twrite!(buf, \" {operator:?} \").unwrap();\n \t\t\t\t\tprint_type_into_buf(*rhs, buf, cycles, args, types, info, debug);\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -403,10 +428,6 @@ pub fn print_type_into_buf<C: InformationChain>(\n \t\t\t\t\t\t}\n \t\t\t\t\tprint_type_into_buf(*rhs, buf, cycles, args, types, info, debug);\n \t\t\t\t}\n-\t\t\t\tConstructor::UnaryOperator { operator, operand } => {\n-\t\t\t\t\twrite!(buf, \"{operator:?} \").unwrap();\n-\t\t\t\t\tprint_type_into_buf(*operand, buf, cycles, args, types, info, debug);\n-\t\t\t\t}\n \t\t\t\tConstructor::TypeOperator(to) => {\n \t\t\t\t\twrite!(buf, \"TypeOperator.{to:?}\").unwrap();\n \t\t\t\t}\ndiff --git a/checker/src/types/properties/access.rs b/checker/src/types/properties/access.rs\n--- a/checker/src/types/properties/access.rs\n+++ b/checker/src/types/properties/access.rs\n@@ -9,7 +9,8 @@ use crate::{\n \t\tgenerics::{\n \t\t\tcontributions::CovariantContribution, generic_type_arguments::GenericArguments,\n \t\t},\n-\t\tget_conditional, get_constraint, is_inferrable_type, is_pseudo_continous,\n+\t\tget_constraint,\n+\t\thelpers::{get_conditional, is_inferrable_type, is_pseudo_continous},\n \t\tlogical::{\n \t\t\tBasedOnKey, Invalid, Logical, LogicalOrValid, NeedsCalculation, PossibleLogical,\n \t\t\tPropertyOn,\ndiff --git a/checker/src/types/properties/access.rs b/checker/src/types/properties/access.rs\n--- a/checker/src/types/properties/access.rs\n+++ b/checker/src/types/properties/access.rs\n@@ -542,12 +543,14 @@ pub(crate) fn get_property_unbound(\n \t\t\t\t}\n \t\t\t}\n \t\t\tType::Constant(Constant::String(s)) if under.is_equal_to(\"length\") => {\n-\t\t\t\t// TODO temp TypeId::NUMBER_GENERIC for slice member\n+\t\t\t\t// TODO temp TypeId::NUMBER_FLOOR_GENERIC for slice member\n \t\t\t\tlet count = s.chars().count();\n \t\t\t\tOk(Logical::BasedOnKey(BasedOnKey::Left {\n-\t\t\t\t\tvalue: Box::new(Logical::Pure(PropertyValue::Value(TypeId::NUMBER_GENERIC))),\n+\t\t\t\t\tvalue: Box::new(Logical::Pure(PropertyValue::Value(\n+\t\t\t\t\t\tTypeId::NUMBER_FLOOR_GENERIC,\n+\t\t\t\t\t))),\n \t\t\t\t\tkey_arguments: crate::Map::from_iter([(\n-\t\t\t\t\t\tTypeId::NUMBER_GENERIC,\n+\t\t\t\t\t\tTypeId::NUMBER_FLOOR_GENERIC,\n \t\t\t\t\t\t(CovariantContribution::Number(count as f64), 0),\n \t\t\t\t\t)]),\n \t\t\t\t})\ndiff --git a/checker/src/types/properties/access.rs b/checker/src/types/properties/access.rs\n--- a/checker/src/types/properties/access.rs\n+++ b/checker/src/types/properties/access.rs\n@@ -563,7 +566,7 @@ pub(crate) fn get_property_unbound(\n \t\t\t.map(LogicalOrValid::Logical)\n \t\t\t.ok_or(Invalid(on))\n \t\t\t.or_else(|_| {\n-\t\t\t\tlet backing_type = cst.get_backing_type_id();\n+\t\t\t\tlet backing_type = cst.get_backing_type();\n \t\t\t\tget_property_on_type_unbound(\n \t\t\t\t\t(backing_type, on_type_arguments),\n \t\t\t\t\t(publicity, under, under_type_arguments),\ndiff --git a/checker/src/types/properties/access.rs b/checker/src/types/properties/access.rs\n--- a/checker/src/types/properties/access.rs\n+++ b/checker/src/types/properties/access.rs\n@@ -734,7 +737,7 @@ pub(crate) fn get_property<B: CallCheckingBehavior>(\n \t);\n \n \t{\n-\t\tcrate::utilities::notify!(\"Access result {:?}\", result);\n+\t\tcrate::utilities::notify!(\"Access {:?} result {:?}\", under, result);\n \t}\n \n \tmatch result {\ndiff --git a/checker/src/types/properties/access.rs b/checker/src/types/properties/access.rs\n--- a/checker/src/types/properties/access.rs\n+++ b/checker/src/types/properties/access.rs\n@@ -938,13 +941,18 @@ fn resolve_property_on_logical<B: CallCheckingBehavior>(\n \t\t\t\t\t};\n \t\t\t\t\tlet result =\n \t\t\t\t\t\tgetter.call(Vec::new(), input, environment, (behavior, diagnostics), types);\n+\n \t\t\t\t\tif let Ok(res) = result {\n+\t\t\t\t\t\tcrate::utilities::notify!(\"{:?}\", res.result);\n+\n \t\t\t\t\t\tlet application_result =\n \t\t\t\t\t\t\tapplication_result_to_return_type(res.result, environment, types);\n+\n+\t\t\t\t\t\tcrate::utilities::notify!(\"{:?}\", application_result);\n \t\t\t\t\t\tSome((PropertyKind::Getter, application_result))\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tcrate::utilities::notify!(\"TODO merge calling\");\n-\t\t\t\t\t\tSome((PropertyKind::Getter, TypeId::ERROR_TYPE))\n+\t\t\t\t\t\tcrate::utilities::notify!(\"Here\");\n+\t\t\t\t\t\tSome((PropertyKind::Getter, TypeId::UNIMPLEMENTED_ERROR_TYPE))\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tPropertyValue::Setter(_) => {\ndiff --git a/checker/src/types/properties/access.rs b/checker/src/types/properties/access.rs\n--- a/checker/src/types/properties/access.rs\n+++ b/checker/src/types/properties/access.rs\n@@ -1172,7 +1180,7 @@ pub(crate) fn proxy_access<B: CallCheckingBehavior>(\n \t\t\tSome((PropertyKind::Getter, application_result))\n \t\t} else {\n \t\t\tcrate::utilities::notify!(\"TODO merge calling\");\n-\t\t\tSome((PropertyKind::Getter, TypeId::ERROR_TYPE))\n+\t\t\tSome((PropertyKind::Getter, TypeId::UNIMPLEMENTED_ERROR_TYPE))\n \t\t}\n \t} else {\n \t\tget_property(\ndiff --git a/checker/src/types/properties/list.rs b/checker/src/types/properties/list.rs\n--- a/checker/src/types/properties/list.rs\n+++ b/checker/src/types/properties/list.rs\n@@ -109,7 +109,7 @@ pub fn get_properties_on_single_type(\n \t\t\tget_properties_on_single_type(*to, types, info, filter_enumerable, filter_type)\n \t\t}\n \t\tType::Constant(c) => get_properties_on_single_type(\n-\t\t\tc.get_backing_type_id(),\n+\t\t\tc.get_backing_type(),\n \t\t\ttypes,\n \t\t\tinfo,\n \t\t\tfilter_enumerable,\ndiff --git a/checker/src/types/properties/list.rs b/checker/src/types/properties/list.rs\n--- a/checker/src/types/properties/list.rs\n+++ b/checker/src/types/properties/list.rs\n@@ -273,15 +273,15 @@ pub fn get_properties_on_single_type2(\n \t\t\t\t// \tinfo,\n \t\t\t\t// \ttypes,\n \t\t\t\t// );\n-\t\t\t\tcrate::utilities::notify!(\"Cannot get all properties on {:?}\", base);\n-\t\t\t\tDefault::default()\n+\t\t\t\tcrate::utilities::notify!(\"Getting on generic, losing generic {:?}\", base);\n+\t\t\t\tget_properties_on_single_type2((*on, base_arguments), types, info, filter_type)\n \t\t\t}\n \t\t}\n \t\tType::Narrowed { narrowed_to: to, .. } | Type::AliasTo { to, .. } => {\n \t\t\tget_properties_on_single_type2((*to, base_arguments), types, info, filter_type)\n \t\t}\n \t\tType::Constant(c) => get_properties_on_single_type2(\n-\t\t\t(c.get_backing_type_id(), base_arguments),\n+\t\t\t(c.get_backing_type(), base_arguments),\n \t\t\ttypes,\n \t\t\tinfo,\n \t\t\tfilter_type,\ndiff --git a/checker/src/types/properties/list.rs b/checker/src/types/properties/list.rs\n--- a/checker/src/types/properties/list.rs\n+++ b/checker/src/types/properties/list.rs\n@@ -300,29 +300,48 @@ pub fn get_properties_on_single_type2(\n \t}\n }\n \n+/// Just for diagnostic printing\n+#[must_use]\n pub fn get_property_key_names_on_a_single_type(\n \tbase: TypeId,\n \ttypes: &TypeStore,\n-\tenvironment: &mut crate::Environment,\n+\tenvironment: &crate::Environment,\n ) -> Vec<String> {\n-\tlet is_special = matches!(\n-\t\ttypes.get_type_by_id(base),\n-\t\tType::SpecialObject(_)\n-\t\t\t| Type::Constructor(_)\n-\t\t\t| Type::RootPolyType(_)\n-\t\t\t| Type::Or(..)\n-\t\t\t| Type::PartiallyAppliedGenerics(_)\n-\t\t\t| Type::Constant(_)\n-\t\t\t| Type::AliasTo { .. }\n-\t\t\t| Type::FunctionReference(_)\n-\t\t\t| Type::And(_, _)\n-\t);\n-\tif is_special {\n-\t\treturn vec![];\n+\tmatch types.get_type_by_id(base) {\n+\t\tType::Object(ObjectNature::AnonymousTypeAnnotation(properties)) => properties\n+\t\t\t.iter()\n+\t\t\t.map(|(_, property, _)| super::get_property_as_string(property, types, environment))\n+\t\t\t.collect(),\n+\t\tType::Interface { .. } | Type::Class { .. } | Type::Object(_) => environment\n+\t\t\t.get_chain_of_info()\n+\t\t\t.filter_map(|info| info.current_properties.get(&base).map(|v| v.iter()))\n+\t\t\t.flatten()\n+\t\t\t.map(|(_, property, _)| super::get_property_as_string(property, types, environment))\n+\t\t\t.collect(),\n+\t\tType::Constant(r) => {\n+\t\t\tget_property_key_names_on_a_single_type(r.get_backing_type(), types, environment)\n+\t\t}\n+\t\tType::SpecialObject(crate::types::SpecialObject::Function(..))\n+\t\t| Type::FunctionReference(_) => {\n+\t\t\tget_property_key_names_on_a_single_type(TypeId::FUNCTION_TYPE, types, environment)\n+\t\t}\n+\t\tType::Narrowed { narrowed_to: to, .. } | Type::AliasTo { to, .. } => {\n+\t\t\tget_property_key_names_on_a_single_type(*to, types, environment)\n+\t\t}\n+\t\tType::PartiallyAppliedGenerics(crate::types::PartiallyAppliedGenerics {\n+\t\t\ton,\n+\t\t\targuments: _,\n+\t\t}) => {\n+\t\t\t// TODO mapped types\n+\t\t\tget_property_key_names_on_a_single_type(*on, types, environment)\n+\t\t}\n+\t\tType::Constructor(_) | Type::RootPolyType(_) => {\n+\t\t\tlet backing = crate::types::get_constraint(base, types).unwrap();\n+\t\t\tget_property_key_names_on_a_single_type(backing, types, environment)\n+\t\t}\n+\t\tt @ (Type::SpecialObject(_) | Type::Or(..) | Type::And(_, _)) => {\n+\t\t\tcrate::utilities::notify!(\"Cannot get all propertie keys on {:?}\", t);\n+\t\t\tDefault::default()\n+\t\t}\n \t}\n-\n-\tget_properties_on_single_type(base, types, environment, false, TypeId::ANY_TYPE)\n-\t\t.into_iter()\n-\t\t.map(|property| super::get_property_as_string(&property.1, types, environment))\n-\t\t.collect()\n }\ndiff --git a/checker/src/types/properties/mod.rs b/checker/src/types/properties/mod.rs\n--- a/checker/src/types/properties/mod.rs\n+++ b/checker/src/types/properties/mod.rs\n@@ -101,7 +101,8 @@ impl<'a> PropertyKey<'a> {\n \t\t\t\t\t// Okay I think?\n \t\t\t\t\tPropertyKey::Type(ty)\n \t\t\t\t}\n-\t\t\t\tConstant::NaN => todo!(),\n+\t\t\t\tConstant::NaN => PropertyKey::String(Cow::Borrowed(\"NaN\")),\n+\t\t\t\tConstant::Undefined => PropertyKey::String(Cow::Borrowed(\"undefined\")),\n \t\t\t}\n \t\t} else {\n \t\t\tPropertyKey::Type(ty)\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -1,21 +1,20 @@\n use std::collections::{HashMap, HashSet};\n \n-use crate::{features::regexp::RegExp, types::intrinsics::Intrinsic, Constant, Map as SmallMap};\n use source_map::{Nullable, Span, SpanWithSource};\n \n use crate::{\n-\tfeatures::{functions::ClosureId, objects::SpecialObject},\n-\ttypes::{\n-\t\tfunctions::{FunctionBehavior, FunctionType},\n-\t\tlogical::{Logical, LogicalOrValid},\n-\t\tPolyNature, Type,\n-\t},\n-\tEnvironment, FunctionId, TypeId,\n+\tfeatures::{functions::ClosureId, objects::SpecialObject, regexp::RegExp},\n+\tConstant, Environment, FunctionId, Map as SmallMap, TypeId,\n };\n \n use super::{\n-\tgenerics::generic_type_arguments::GenericArguments, get_constraint, properties::PropertyKey,\n-\tConstructor, LookUpGeneric, LookUpGenericMap, PartiallyAppliedGenerics, TypeExtends,\n+\tfunctions::{FunctionBehavior, FunctionType},\n+\tgenerics::generic_type_arguments::GenericArguments,\n+\tget_constraint,\n+\tlogical::{Logical, LogicalOrValid},\n+\tproperties::PropertyKey,\n+\tConstructor, LookUpGeneric, LookUpGenericMap, PartiallyAppliedGenerics, PolyNature, Type,\n+\tTypeExtends,\n };\n \n /// Holds all the types. Eventually may be split across modules\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -41,9 +40,9 @@ pub struct TypeStore {\n \n impl Default for TypeStore {\n \tfn default() -> Self {\n-\t\t// These have to be in the order of TypeId\n+\t\t// These have to be in the order of the `impl TypeId`\n \t\tlet types = vec![\n-\t\t\t// TODO will `TypeId::ANY_TYPE` cause any problems\n+\t\t\t// TODO will `TypeId::ANY_TYPE` cause any problems?\n \t\t\tType::RootPolyType(PolyNature::Error(TypeId::ANY_TYPE)),\n \t\t\tType::Interface { name: \"never\".to_owned(), parameters: None, extends: None },\n \t\t\tType::Interface { name: \"any\".to_owned(), parameters: None, extends: None },\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -51,7 +50,7 @@ impl Default for TypeStore {\n \t\t\tType::Class { name: \"number\".to_owned(), type_parameters: None },\n \t\t\tType::Class { name: \"string\".to_owned(), type_parameters: None },\n \t\t\t// sure?\n-\t\t\tType::Interface { name: \"undefined\".to_owned(), parameters: None, extends: None },\n+\t\t\tType::Constant(Constant::Undefined),\n \t\t\tType::SpecialObject(SpecialObject::Null),\n \t\t\t// `void` type. Has special subtyping in returns\n \t\t\tType::AliasTo { to: TypeId::UNDEFINED_TYPE, name: \"void\".into(), parameters: None },\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -65,7 +64,7 @@ impl Default for TypeStore {\n \t\t\tType::Interface { name: \"object\".to_owned(), parameters: None, extends: None },\n \t\t\tType::Class { name: \"Function\".to_owned(), type_parameters: None },\n \t\t\tType::Class { name: \"RegExp\".to_owned(), type_parameters: None },\n-\t\t\tType::Or(TypeId::STRING_TYPE, TypeId::NUMBER_TYPE),\n+\t\t\tType::Class { name: \"Symbol\".to_owned(), type_parameters: None },\n \t\t\t// true\n \t\t\tType::Constant(Constant::Boolean(true)),\n \t\t\t// false\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -76,6 +75,15 @@ impl Default for TypeStore {\n \t\t\tType::Constant(Constant::Number(1.into())),\n \t\t\t// NaN\n \t\t\tType::Constant(Constant::NaN),\n+\t\t\tType::Constant(Constant::Number(f64::NEG_INFINITY.try_into().unwrap())),\n+\t\t\tType::Constant(Constant::Number(f64::INFINITY.try_into().unwrap())),\n+\t\t\tType::Constant(Constant::Number(f64::MIN.try_into().unwrap())),\n+\t\t\tType::Constant(Constant::Number(f64::MAX.try_into().unwrap())),\n+\t\t\tType::Constant(Constant::Number(f64::EPSILON.try_into().unwrap())),\n+\t\t\tType::Constant(Constant::Number({\n+\t\t\t\tconst THIRTY_TWO_ONE_BITS: i32 = -1i32;\n+\t\t\t\tTHIRTY_TWO_ONE_BITS.into()\n+\t\t\t})),\n \t\t\t// \"\"\n \t\t\tType::Constant(Constant::String(String::new())),\n \t\t\t// inferred this free variable shortcut\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -140,20 +148,30 @@ impl Default for TypeStore {\n \t\t\t\tname: \"T\".into(),\n \t\t\t\textends: TypeId::NUMBER_TYPE,\n \t\t\t}),\n+\t\t\tType::RootPolyType(PolyNature::StructureGeneric {\n+\t\t\t\tname: \"U\".into(),\n+\t\t\t\textends: TypeId::NUMBER_TYPE,\n+\t\t\t}),\n \t\t\tType::AliasTo {\n \t\t\t\tto: TypeId::NUMBER_TYPE,\n-\t\t\t\tname: \"LessThan\".into(),\n-\t\t\t\tparameters: Some(vec![TypeId::NUMBER_GENERIC]),\n+\t\t\t\tname: \"InclusiveRange\".into(),\n+\t\t\t\tparameters: Some(vec![\n+\t\t\t\t\tTypeId::NUMBER_FLOOR_GENERIC,\n+\t\t\t\t\tTypeId::NUMBER_CEILING_GENERIC,\n+\t\t\t\t]),\n \t\t\t},\n \t\t\tType::AliasTo {\n \t\t\t\tto: TypeId::NUMBER_TYPE,\n-\t\t\t\tname: \"GreaterThan\".into(),\n-\t\t\t\tparameters: Some(vec![TypeId::NUMBER_GENERIC]),\n+\t\t\t\tname: \"ExclusiveRange\".into(),\n+\t\t\t\tparameters: Some(vec![\n+\t\t\t\t\tTypeId::NUMBER_FLOOR_GENERIC,\n+\t\t\t\t\tTypeId::NUMBER_CEILING_GENERIC,\n+\t\t\t\t]),\n \t\t\t},\n \t\t\tType::AliasTo {\n \t\t\t\tto: TypeId::NUMBER_TYPE,\n \t\t\t\tname: \"MultipleOf\".into(),\n-\t\t\t\tparameters: Some(vec![TypeId::NUMBER_GENERIC]),\n+\t\t\t\tparameters: Some(vec![TypeId::NUMBER_FLOOR_GENERIC]),\n \t\t\t},\n \t\t\t// Intermediate for the below\n \t\t\tType::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -187,6 +205,7 @@ impl Default for TypeStore {\n \t\t\t},\n \t\t\tType::RootPolyType(PolyNature::Open(TypeId::BOOLEAN_TYPE)),\n \t\t\tType::RootPolyType(PolyNature::Open(TypeId::NUMBER_TYPE)),\n+\t\t\tType::Or(TypeId::STRING_TYPE, TypeId::NUMBER_TYPE),\n \t\t];\n \n \t\t// Check that above is correct, TODO eventually a macro\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -219,13 +238,10 @@ impl TypeStore {\n \t\t\tConstant::String(s) if s.is_empty() => TypeId::EMPTY_STRING,\n \t\t\tConstant::Number(number) if number == 0f64 => TypeId::ZERO,\n \t\t\tConstant::Number(number) if number == 1f64 => TypeId::ONE,\n-\t\t\tConstant::Boolean(value) => {\n-\t\t\t\tif value {\n-\t\t\t\t\tTypeId::TRUE\n-\t\t\t\t} else {\n-\t\t\t\t\tTypeId::FALSE\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tConstant::Number(number) if number == f64::NEG_INFINITY => TypeId::NEG_INFINITY,\n+\t\t\tConstant::Number(number) if number == f64::INFINITY => TypeId::INFINITY,\n+\t\t\tConstant::Boolean(true) => TypeId::TRUE,\n+\t\t\tConstant::Boolean(false) => TypeId::FALSE,\n \t\t\tConstant::NaN => TypeId::NAN,\n \t\t\t_ => {\n \t\t\t\tlet ty = Type::Constant(constant);\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -381,12 +397,16 @@ impl TypeStore {\n \t\t\totherwise_result\n \t\t} else if truthy_result == TypeId::TRUE && otherwise_result == TypeId::FALSE {\n \t\t\tcondition\n-\t\t} else if let Type::Constructor(Constructor::UnaryOperator {\n-\t\t\toperator: crate::features::operations::PureUnary::LogicalNot,\n-\t\t\toperand: reversed_condition,\n+\t\t} else if let Type::Constructor(Constructor::ConditionalResult {\n+\t\t\tcondition,\n+\t\t\t// TODO technically any falsy, truthy reverse pair is okay\n+\t\t\ttruthy_result: TypeId::FALSE,\n+\t\t\totherwise_result: TypeId::TRUE,\n+\t\t\tresult_union: _,\n \t\t}) = self.get_type_by_id(condition)\n \t\t{\n-\t\t\tself.new_conditional_type(*reversed_condition, otherwise_result, truthy_result)\n+\t\t\t// Revese the condition\n+\t\t\tself.new_conditional_type(*condition, otherwise_result, truthy_result)\n \t\t} else {\n \t\t\tlet ty = Type::Constructor(super::Constructor::ConditionalResult {\n \t\t\t\tcondition,\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -408,12 +428,13 @@ impl TypeStore {\n \t}\n \n \t/// Doesn't do constant compilation\n-\tpub(crate) fn new_logical_negation_type(&mut self, operand: TypeId) -> TypeId {\n-\t\tlet ty = Type::Constructor(Constructor::UnaryOperator {\n-\t\t\toperator: crate::features::operations::PureUnary::LogicalNot,\n-\t\t\toperand,\n-\t\t});\n-\t\tself.register_type(ty)\n+\tpub(crate) fn new_logical_negation_type(&mut self, condition: TypeId) -> TypeId {\n+\t\tself.register_type(Type::Constructor(super::Constructor::ConditionalResult {\n+\t\t\tcondition,\n+\t\t\ttruthy_result: TypeId::FALSE,\n+\t\t\totherwise_result: TypeId::TRUE,\n+\t\t\tresult_union: TypeId::BOOLEAN_TYPE,\n+\t\t}))\n \t}\n \n \t/// Doesn't evaluate events\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -479,14 +500,14 @@ impl TypeStore {\n \t\t\t\t\tLogicalOrValid::Logical(Logical::Pure(ty)) => ty.as_get_type(self),\n \t\t\t\t\tvalue => {\n \t\t\t\t\t\tcrate::utilities::notify!(\"value={:?}\", value);\n-\t\t\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t\t\t} // Logical::Or { .. } => todo!(),\n \t\t\t\t\t  // Logical::Implies { .. } => todo!(),\n \t\t\t\t\t  // Logical::BasedOnKey { .. } => todo!(),\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tcrate::utilities::notify!(\"Error: no index on type annotation\");\n-\t\t\t\tTypeId::ERROR_TYPE\n+\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t}\n \t\t}\n \t}\ndiff --git a/checker/src/types/store.rs b/checker/src/types/store.rs\n--- a/checker/src/types/store.rs\n+++ b/checker/src/types/store.rs\n@@ -612,41 +633,4 @@ impl TypeStore {\n \tpub(crate) fn new_key_of(&mut self, of: TypeId) -> TypeId {\n \t\tself.register_type(Type::Constructor(Constructor::KeyOf(of)))\n \t}\n-\n-\tpub(crate) fn new_intrinsic(&mut self, intrinsic: &Intrinsic, argument: TypeId) -> TypeId {\n-\t\tlet (on, to_pair) = match intrinsic {\n-\t\t\tIntrinsic::Uppercase => (TypeId::STRING_UPPERCASE, TypeId::STRING_GENERIC),\n-\t\t\tIntrinsic::Lowercase => (TypeId::STRING_LOWERCASE, TypeId::STRING_GENERIC),\n-\t\t\tIntrinsic::Capitalize => (TypeId::STRING_CAPITALIZE, TypeId::STRING_GENERIC),\n-\t\t\tIntrinsic::Uncapitalize => (TypeId::STRING_UNCAPITALIZE, TypeId::STRING_GENERIC),\n-\t\t\tIntrinsic::NoInfer => (TypeId::NO_INFER, TypeId::T_TYPE),\n-\t\t\tIntrinsic::Literal => (TypeId::LITERAL_RESTRICTION, TypeId::T_TYPE),\n-\t\t\tIntrinsic::LessThan => (TypeId::LESS_THAN, TypeId::NUMBER_GENERIC),\n-\t\t\tIntrinsic::GreaterThan => (TypeId::GREATER_THAN, TypeId::NUMBER_GENERIC),\n-\t\t\tIntrinsic::MultipleOf => (TypeId::MULTIPLE_OF, TypeId::NUMBER_GENERIC),\n-\t\t\tIntrinsic::Exclusive => (TypeId::EXCLUSIVE_RESTRICTION, TypeId::T_TYPE),\n-\t\t\tIntrinsic::Not => {\n-\t\t\t\t// Double negation\n-\t\t\t\tif let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n-\t\t\t\t\ton: TypeId::NOT_RESTRICTION,\n-\t\t\t\t\targuments: GenericArguments::ExplicitRestrictions(args),\n-\t\t\t\t}) = self.get_type_by_id(argument)\n-\t\t\t\t{\n-\t\t\t\t\treturn args.get(&TypeId::T_TYPE).unwrap().0;\n-\t\t\t\t}\n-\n-\t\t\t\t(TypeId::NOT_RESTRICTION, TypeId::T_TYPE)\n-\t\t\t}\n-\t\t\tIntrinsic::CaseInsensitive => (TypeId::CASE_INSENSITIVE, TypeId::STRING_GENERIC),\n-\t\t};\n-\t\tlet arguments = GenericArguments::ExplicitRestrictions(crate::Map::from_iter([(\n-\t\t\tto_pair,\n-\t\t\t(argument, <SpanWithSource as source_map::Nullable>::NULL),\n-\t\t)]));\n-\n-\t\tself.register_type(Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n-\t\t\ton,\n-\t\t\targuments,\n-\t\t}))\n-\t}\n }\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -8,23 +8,22 @@ use crate::{\n \t\tobjects::{self, SpecialObject},\n \t\toperations::MathematicalAndBitwise,\n \t},\n-\ttypes::{\n-\t\tgenerics::{\n-\t\t\tchain::{GenericChain, GenericChainLink, SpecialGenericChainLink},\n-\t\t\tcontributions::{ContributionDepth, Contributions, CovariantContribution, TriMap},\n-\t\t\tgeneric_type_arguments::GenericArguments,\n-\t\t},\n-\t\tintrinsics::apply_string_intrinsic,\n-\t\tlogical::{BasedOnKey, Logical, LogicalOrValid, NeedsCalculation, PropertyOn},\n-\t\tprinting::print_type,\n-\t\tproperties::{get_properties_on_single_type2, get_property_unbound, Publicity},\n-\t\tObjectNature, Type, TypeStore,\n-\t},\n \tConstant, Environment, PropertyValue, TypeId,\n };\n \n use super::{\n-\tget_constraint, properties::PropertyKey, Constructor, PartiallyAppliedGenerics, PolyNature,\n+\tgenerics::{\n+\t\tchain::{GenericChain, GenericChainLink, SpecialGenericChainLink},\n+\t\tcontributions::{ContributionDepth, Contributions, CovariantContribution, TriMap},\n+\t\tgeneric_type_arguments::GenericArguments,\n+\t},\n+\tget_constraint,\n+\tintrinsics::{self, apply_string_intrinsic},\n+\tlogical::{BasedOnKey, Logical, LogicalOrValid, NeedsCalculation, PropertyOn},\n+\tprinting::print_type,\n+\tproperties::PropertyKey,\n+\tproperties::{get_properties_on_single_type2, get_property_unbound, Publicity},\n+\tConstructor, ObjectNature, PartiallyAppliedGenerics, PolyNature, Type, TypeStore,\n };\n \n pub use super::{NonEqualityReason, PropertyError};\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -254,19 +253,36 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\tstate.already_checked.push((base_type, ty));\n \t}\n \n-\tlet left_ty = types.get_type_by_id(base_type);\n-\tlet right_ty = types.get_type_by_id(ty);\n+\tlet supertype = types.get_type_by_id(base_type);\n+\tlet subtype = types.get_type_by_id(ty);\n \n \t// Eager things\n-\tmatch right_ty {\n+\tmatch subtype {\n \t\tType::Narrowed { narrowed_to: right, .. } | Type::AliasTo { to: right, .. } => {\n-\t\t\treturn type_is_subtype_with_generics(\n+\t\t\tlet result = type_is_subtype_with_generics(\n \t\t\t\t(base_type, base_type_arguments),\n \t\t\t\t(*right, ty_structure_arguments),\n \t\t\t\tstate,\n \t\t\t\tinformation,\n \t\t\t\ttypes,\n \t\t\t);\n+\t\t\t// Temp fix for narrowing constants\n+\t\t\tcrate::utilities::notify!(\"{:?}\", super::helpers::is_not_of_constant(*right, types));\n+\t\t\t// SubTypeResult::IsNotSubType(_)\n+\t\t\treturn if let (Type::Narrowed { from, .. }, _, true) =\n+\t\t\t\t(subtype, &result, super::helpers::is_not_of_constant(*right, types))\n+\t\t\t{\n+\t\t\t\tcrate::utilities::notify!(\"Here\");\n+\t\t\t\ttype_is_subtype_with_generics(\n+\t\t\t\t\t(base_type, base_type_arguments),\n+\t\t\t\t\t(*from, ty_structure_arguments),\n+\t\t\t\t\tstate,\n+\t\t\t\t\tinformation,\n+\t\t\t\t\ttypes,\n+\t\t\t\t)\n+\t\t\t} else {\n+\t\t\t\tresult\n+\t\t\t};\n \t\t}\n \t\tType::Or(left, right) => {\n \t\t\tlet right = *right;\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -294,7 +310,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t}\n \t\t// Type::And(left, right) => {\n \t\t// \tlet left_is_operator_right_is_not =\n-\t\t// \t\tleft_ty.is_operator();\n+\t\t// \t\tsupertype.is_operator();\n \n \t\t// \t// edge cases on edge cases\n \t\t// \t// If any of these are true. Then do not perform constraint argument lookup\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -334,10 +350,9 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\tlet inner = arguments.get_structure_restriction(TypeId::T_TYPE).unwrap();\n \t\t\t\t\t// https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Basic.html#Set.subset_compl_comm -> https://leanprover-community.github.io/mathlib4_docs/Mathlib/Data/Set/Basic.html#Set.subset_compl_iff_disjoint_left\n \n-\t\t\t\t\t// Swapped\n \t\t\t\t\tlet result = super::disjoint::types_are_disjoint(\n+\t\t\t\t\t\tbase_type,\n \t\t\t\t\t\tinner,\n-\t\t\t\t\t\tty,\n \t\t\t\t\t\t&mut state.already_checked,\n \t\t\t\t\t\tinformation,\n \t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -355,6 +370,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\tt @ (Type::RootPolyType(..) | Type::Constructor(..)) => {\n \t\t\tif let Type::RootPolyType(PolyNature::Error(to)) = t {\n \t\t\t\t// (unless specified) treat as subtype as error would have already been thrown\n+\t\t\t\tcrate::utilities::notify!(\"Here {:?}\", state.others.allow_errors);\n \t\t\t\treturn if state.others.allow_errors && *to == TypeId::ANY_TYPE {\n \t\t\t\t\tSubTypeResult::IsSubType\n \t\t\t\t} else {\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -435,16 +451,16 @@ pub(crate) fn type_is_subtype_with_generics(\n \n \t\t\t// This is important that LHS is not operator\n \t\t\tlet left_is_operator_right_is_not =\n-\t\t\t\tleft_ty.is_operator() && !types.get_type_by_id(right_arg).is_operator();\n+\t\t\t\tsupertype.is_operator() && !types.get_type_by_id(right_arg).is_operator();\n \n \t\t\t// edge cases on edge cases\n \t\t\t// If any of these are true. Then do not perform constraint argument lookup\n \t\t\tlet edge_case = left_is_operator_right_is_not\n \t\t\t\t|| matches!(\n-\t\t\t\t\tleft_ty,\n+\t\t\t\t\tsupertype,\n \t\t\t\t\tType::RootPolyType(rpt)\n \t\t\t\t\tif rpt.is_substitutable()\n-\t\t\t\t) || matches!(left_ty, Type::Constructor(..));\n+\t\t\t\t) || matches!(supertype, Type::Constructor(..));\n \n \t\t\tif !edge_case {\n \t\t\t\tlet result = type_is_subtype_with_generics(\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -457,7 +473,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \n \t\t\t\t// TODO is the above event needed or constructor with constraint == TypeId::ANY_TYPE\n \t\t\t\treturn if result.is_mismatch()\n-\t\t\t\t\t&& matches!(right_ty, Type::RootPolyType(root) if root.is_inferrable())\n+\t\t\t\t\t&& matches!(subtype, Type::RootPolyType(root) if root.is_inferrable())\n \t\t\t\t{\n \t\t\t\t\tcrate::utilities::notify!(\"Setting inferred request\");\n \t\t\t\t\t// state.add_request(ty, base_type);\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -471,17 +487,17 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t_ => (),\n \t}\n \n-\tmatch left_ty {\n+\tmatch supertype {\n \t\tType::FunctionReference(left_func)\n \t\t| Type::SpecialObject(SpecialObject::Function(left_func, _)) => subtype_function(\n \t\t\t(*left_func, base_type_arguments),\n-\t\t\t(right_ty, ty, ty_structure_arguments),\n+\t\t\t(subtype, ty, ty_structure_arguments),\n \t\t\tstate,\n \t\t\tinformation,\n \t\t\ttypes,\n \t\t),\n \t\tType::Constant(lhs) => {\n-\t\t\tif let Type::Constant(rhs) = right_ty {\n+\t\t\tif let Type::Constant(rhs) = subtype {\n \t\t\t\tif lhs == rhs {\n \t\t\t\t\tSubTypeResult::IsSubType\n \t\t\t\t} else {\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -489,7 +505,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// TODO what about if LHS has inferred constraint\n-\t\t\t\tcrate::utilities::notify!(\"Constant {:?} against RHS {:#?}\", lhs, right_ty);\n+\t\t\t\tcrate::utilities::notify!(\"Constant {:?} against RHS {:#?}\", lhs, subtype);\n \t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n \t\t\t}\n \t\t}\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -594,7 +610,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\t\ttypes,\n \t\t\t\t\t),\n \t\t\t\t\tCovariantContribution::String(left_string) => {\n-\t\t\t\t\t\tif let Type::Constant(Constant::String(right_string)) = right_ty {\n+\t\t\t\t\t\tif let Type::Constant(Constant::String(right_string)) = subtype {\n \t\t\t\t\t\t\tif &left_string == right_string {\n \t\t\t\t\t\t\t\tSubTypeResult::IsSubType\n \t\t\t\t\t\t\t} else {\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -609,7 +625,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\tCovariantContribution::Number(n) => {\n \t\t\t\t\t\tunreachable!(\"{:?}\", n)\n \t\t\t\t\t\t// crate::utilities::notify!(\"Here?\");\n-\t\t\t\t\t\t// if let Type::Constant(Constant::String(right_string)) = right_ty {\n+\t\t\t\t\t\t// if let Type::Constant(Constant::String(right_string)) = subtype {\n \t\t\t\t\t\t// \tif left_string == right_string {\n \t\t\t\t\t\t// \t\tSubTypeResult::IsSubType\n \t\t\t\t\t\t// \t} else {\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -674,7 +690,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t} else {\n \t\t\t\t// TODO what does this do\n \t\t\t\t// TODO temp fix\n-\t\t\t\tif let Type::Constructor(c) = right_ty {\n+\t\t\t\tif let Type::Constructor(c) = subtype {\n \t\t\t\t\tcrate::utilities::notify!(\"TODO right hand side maybe okay\");\n \t\t\t\t\tif let Some(to) = c.get_base() {\n \t\t\t\t\t\tif to == base_type {\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -692,7 +708,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \n-\t\t\t\t\treturn if check_and_includes(base_type, right_ty) {\n+\t\t\t\t\treturn if check_and_includes(base_type, subtype) {\n \t\t\t\t\t\tSubTypeResult::IsSubType\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// Already eliminated equal == case above, so always invalid here\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -738,7 +754,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\treturn if let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n \t\t\t\t\t\ton: TypeId::READONLY_RESTRICTION,\n \t\t\t\t\t\targuments,\n-\t\t\t\t\t}) = right_ty\n+\t\t\t\t\t}) = subtype\n \t\t\t\t\t{\n \t\t\t\t\t\tlet ty = arguments.get_structure_restriction(TypeId::T_TYPE).unwrap();\n \t\t\t\t\t\ttype_is_subtype_with_generics(\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -749,7 +765,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\t\t\ttypes,\n \t\t\t\t\t\t)\n \t\t\t\t\t} else if information.get_chain_of_info().any(|info| info.frozen.contains(&ty))\n-\t\t\t\t\t\t|| matches!(right_ty, Type::Constant(_))\n+\t\t\t\t\t\t|| matches!(subtype, Type::Constant(_))\n \t\t\t\t\t\t|| matches!(\n \t\t\t\t\t\t\tty,\n \t\t\t\t\t\t\tTypeId::STRING_TYPE | TypeId::BOOLEAN_TYPE | TypeId::NUMBER_TYPE\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -805,7 +821,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t| TypeId::STRING_UNCAPITALIZE\n \t\t\t\t| TypeId::STRING_LOWERCASE\n \t\t\t\t| TypeId::STRING_UPPERCASE => {\n-\t\t\t\t\tif let Type::Constant(Constant::String(rs)) = right_ty {\n+\t\t\t\t\tif let Type::Constant(Constant::String(rs)) = subtype {\n \t\t\t\t\t\tlet contributions =\n \t\t\t\t\t\t\tstate.contributions.as_mut().map(|n| &mut n.staging_contravariant);\n \t\t\t\t\t\tlet matches = slice_matches_type(\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -827,10 +843,10 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t// Ezno intrinsic\n \t\t\t\tTypeId::LITERAL_RESTRICTION => {\n \t\t\t\t\tlet inner = arguments.get_structure_restriction(TypeId::T_TYPE).unwrap();\n-\t\t\t\t\treturn if let Type::Constant(rhs_constant) = right_ty {\n+\t\t\t\t\treturn if let Type::Constant(rhs_constant) = subtype {\n \t\t\t\t\t\ttype_is_subtype_with_generics(\n \t\t\t\t\t\t\t(inner, base_type_arguments),\n-\t\t\t\t\t\t\t(rhs_constant.get_backing_type_id(), ty_structure_arguments),\n+\t\t\t\t\t\t\t(rhs_constant.get_backing_type(), ty_structure_arguments),\n \t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\tinformation,\n \t\t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -861,35 +877,45 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\t}\n \t\t\t\t\treturn result;\n \t\t\t\t}\n-\t\t\t\tTypeId::LESS_THAN | TypeId::GREATER_THAN | TypeId::MULTIPLE_OF => {\n+\t\t\t\tTypeId::MULTIPLE_OF => {\n \t\t\t\t\tlet argument =\n-\t\t\t\t\t\targuments.get_structure_restriction(TypeId::NUMBER_GENERIC).unwrap();\n+\t\t\t\t\t\targuments.get_structure_restriction(TypeId::NUMBER_FLOOR_GENERIC).unwrap();\n+\n+\t\t\t\t\tlet right_multiple = crate::types::intrinsics::get_multiple(ty, types);\n \t\t\t\t\treturn if let (\n \t\t\t\t\t\tType::Constant(Constant::Number(argument)),\n-\t\t\t\t\t\tType::Constant(Constant::Number(value)),\n-\t\t\t\t\t) = (types.get_type_by_id(argument), right_ty)\n-\t\t\t\t\t{\n-\t\t\t\t\t\tlet result = match *on {\n-\t\t\t\t\t\t\tTypeId::LESS_THAN => value < argument,\n-\t\t\t\t\t\t\tTypeId::GREATER_THAN => value > argument,\n-\t\t\t\t\t\t\tTypeId::MULTIPLE_OF => value % argument == 0f64,\n-\t\t\t\t\t\t\t_ => unreachable!(),\n-\t\t\t\t\t\t};\n-\t\t\t\t\t\tif result {\n+\t\t\t\t\t\tSome(Type::Constant(Constant::Number(right_multiple))),\n+\t\t\t\t\t) = (\n+\t\t\t\t\t\ttypes.get_type_by_id(argument),\n+\t\t\t\t\t\tright_multiple.map(|right_multiple| types.get_type_by_id(right_multiple)),\n+\t\t\t\t\t) {\n+\t\t\t\t\t\tif (right_multiple % argument) == 0. {\n \t\t\t\t\t\t\tSubTypeResult::IsSubType\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tcrate::utilities::notify!(\n-\t\t\t\t\t\t\t\"Returning NonEqualityReason::Mismatch {:?}\",\n-\t\t\t\t\t\t\tright_ty\n-\t\t\t\t\t\t);\n+\t\t\t\t\t\tcrate::utilities::notify!(\"TODO multiple of {:?}\", (argument, ty, subtype));\n+\t\t\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n+\t\t\t\t\t};\n+\t\t\t\t}\n+\t\t\t\tTypeId::INCLUSIVE_RANGE | TypeId::EXCLUSIVE_RANGE => {\n+\t\t\t\t\treturn if let (super_range, Some(sub_range)) = (\n+\t\t\t\t\t\tintrinsics::get_range(base_type, types).unwrap(),\n+\t\t\t\t\t\tintrinsics::get_range(ty, types),\n+\t\t\t\t\t) {\n+\t\t\t\t\t\tif sub_range.contained_in(super_range) {\n+\t\t\t\t\t\t\tSubTypeResult::IsSubType\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tcrate::utilities::notify!(\"TODO\");\n \t\t\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tTypeId::CASE_INSENSITIVE => {\n-\t\t\t\t\tif let Type::Constant(Constant::String(rs)) = right_ty {\n+\t\t\t\t\tif let Type::Constant(Constant::String(rs)) = subtype {\n \t\t\t\t\t\tlet contributions =\n \t\t\t\t\t\t\tstate.contributions.as_mut().map(|n| &mut n.staging_contravariant);\n \t\t\t\t\t\t// Slice matches handles this\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -932,7 +958,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t}\n \t\t\t\t// TODO a bit of a mess\n \n-\t\t\t\treturn if let Some(sgs) = get_structure_generics_on(right_ty, *on) {\n+\t\t\t\treturn if let Some(sgs) = get_structure_generics_on(subtype, *on) {\n \t\t\t\t\tmatch (arguments, sgs) {\n \t\t\t\t\t\t(\n \t\t\t\t\t\t\tGenericArguments::ExplicitRestrictions(left),\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -955,7 +981,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\t\t}\n \t\t\t\t\t\tpair => todo!(\"{:?}\", pair),\n \t\t\t\t\t}\n-\t\t\t\t} else if let Type::Object(super::ObjectNature::RealDeal) = right_ty {\n+\t\t\t\t} else if let Type::Object(super::ObjectNature::RealDeal) = subtype {\n \t\t\t\t\tlet prototype =\n \t\t\t\t\t\tinformation.get_chain_of_info().find_map(|info| info.prototypes.get(&ty));\n \ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -994,7 +1020,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t);\n \n \t\t\t\t// TODO temp fix for general parameters\n-\t\t\t\tif let Type::Object(_) = right_ty {\n+\t\t\t\tif let Type::Object(_) = subtype {\n \t\t\t\t\t// let Some(lookup_restriction) =\n \t\t\t\t\t// \ttypes.get_look_up_generic_from_prototype(TypeId::ARRAY_TYPE, ty)\n \t\t\t\t\t// else {\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1015,7 +1041,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t} else if let Type::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n \t\t\t\t\ton: TypeId::ARRAY_TYPE,\n \t\t\t\t\targuments: right_arguments,\n-\t\t\t\t}) = right_ty\n+\t\t\t\t}) = subtype\n \t\t\t\t{\n \t\t\t\t\tlet left_arg = arguments.get_structure_restriction(TypeId::T_TYPE).unwrap();\n \t\t\t\t\tlet right_arg =\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1032,7 +1058,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\t\ttypes,\n \t\t\t\t\t)\n \t\t\t\t} else {\n-\t\t\t\t\tcrate::utilities::notify!(\"Not array-ish {:?}\", right_ty);\n+\t\t\t\t\tcrate::utilities::notify!(\"Not array-ish {:?}\", subtype);\n \t\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n \t\t\t\t}\n \t\t\t} else {\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1088,7 +1114,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\toperator: crate::types::MathematicalAndBitwise::Add,\n \t\t\t\t..\n \t\t\t} => {\n-\t\t\t\tif let Type::Constant(Constant::String(rs)) = right_ty {\n+\t\t\t\tif let Type::Constant(Constant::String(rs)) = subtype {\n \t\t\t\t\tlet matches = slice_matches_type(\n \t\t\t\t\t\t(base_type, base_type_arguments),\n \t\t\t\t\t\trs,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1114,9 +1140,9 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\t)\n \t\t\t\t}\n \t\t\t}\n-\t\t\tConstructor::BinaryOperator { .. }\n-\t\t\t| Constructor::CanonicalRelationOperator { .. }\n-\t\t\t| Constructor::UnaryOperator { .. } => unreachable!(\"invalid constructor on LHS\"),\n+\t\t\tConstructor::BinaryOperator { .. } | Constructor::CanonicalRelationOperator { .. } => {\n+\t\t\t\tunreachable!(\"invalid constructor on LHS\")\n+\t\t\t}\n \t\t\tConstructor::TypeOperator(_) => todo!(),\n \t\t\tConstructor::TypeExtends(_) => todo!(),\n \t\t\tConstructor::Image { on: _, with: _, result } => {\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1145,7 +1171,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\t\totherwise_result: TypeId::NEVER_TYPE,\n \t\t\t\t\t\tresult_union: _,\n \t\t\t\t\t}),\n-\t\t\t\t) = (types.get_type_by_id(*condition), *otherwise_result, right_ty)\n+\t\t\t\t) = (types.get_type_by_id(*condition), *otherwise_result, subtype)\n \t\t\t\t{\n \t\t\t\t\tif extends.equal_to_rhs(*rhs_condition, types) {\n \t\t\t\t\t\tSubTypeResult::IsSubType\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1157,7 +1183,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tcrate::utilities::notify!(\"Here {:?}\", right_ty);\n+\t\t\t\t\tcrate::utilities::notify!(\"Here {:?}\", subtype);\n \n \t\t\t\t\ttype_is_subtype_with_generics(\n \t\t\t\t\t\t(*result, base_type_arguments),\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1176,7 +1202,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t\tunder: r_under,\n \t\t\t\t\tresult: _,\n \t\t\t\t\tmode: _,\n-\t\t\t\t}) = right_ty\n+\t\t\t\t}) = subtype\n \t\t\t\t{\n \t\t\t\t\tif on == r_on && under == r_under {\n \t\t\t\t\t\treturn SubTypeResult::IsSubType;\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1331,7 +1357,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t}\n \t\t\tConstructor::Awaited { .. } => todo!(),\n \t\t\tConstructor::KeyOf(on) => {\n-\t\t\t\tif let Type::Constant(crate::Constant::String(s)) = right_ty {\n+\t\t\t\tif let Type::Constant(crate::Constant::String(s)) = subtype {\n \t\t\t\t\tlet get_property_unbound = get_property_unbound(\n \t\t\t\t\t\t(*on, base_type_arguments),\n \t\t\t\t\t\t(\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1371,9 +1397,9 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t)\n \t\t}\n \t\t// TODO WIP nominal mechanism\n-\t\tType::Class { .. } => match right_ty {\n+\t\tType::Class { .. } => match subtype {\n \t\t\tType::Constant(constant) => {\n-\t\t\t\tif constant.get_backing_type_id() == base_type {\n+\t\t\t\tif constant.get_backing_type() == base_type {\n \t\t\t\t\tSubTypeResult::IsSubType\n \t\t\t\t} else {\n \t\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1433,9 +1459,9 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t}\n \n \t\t\t// TODO a bit messy\n-\t\t\tmatch right_ty {\n+\t\t\tmatch subtype {\n \t\t\t\tType::Constant(constant) => {\n-\t\t\t\t\tif constant.get_backing_type_id() == base_type {\n+\t\t\t\t\tif constant.get_backing_type() == base_type {\n \t\t\t\t\t\tSubTypeResult::IsSubType\n \t\t\t\t\t} else {\n \t\t\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1481,7 +1507,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t\t| Type::Class { .. }\n \t\t\t\t| Type::AliasTo { .. }\n \t\t\t\t| Type::Interface { .. } => {\n-\t\t\t\t\tcrate::utilities::notify!(\"lhs={:?} rhs={:?}\", left_ty, right_ty);\n+\t\t\t\t\tcrate::utilities::notify!(\"supertype={:?}, subtype={:?}\", supertype, subtype);\n \t\t\t\t\t// TODO\n \t\t\t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n \t\t\t\t}\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1526,7 +1552,7 @@ pub(crate) fn type_is_subtype_with_generics(\n \t\t\t}\n \t\t}\n \t\tType::SpecialObject(SpecialObject::Null) => {\n-\t\t\tcrate::utilities::notify!(\"rhs={:?}\", right_ty);\n+\t\t\tcrate::utilities::notify!(\"rhs={:?}\", subtype);\n \t\t\tSubTypeResult::IsNotSubType(NonEqualityReason::Mismatch)\n \t\t}\n \t\tType::SpecialObject(_) => todo!(),\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1572,7 +1598,7 @@ fn subtype_function(\n \n \t\t\t// Reverse is important\n \t\t\tlet result = type_is_subtype_with_generics(\n-\t\t\t\t(right_param_ty, right_type_arguments),\n+\t\t\t\t(right_param_ty, subtypepe_arguments),\n \t\t\t\t(lhs_param.ty, base_type_arguments),\n \t\t\t\tstate,\n \t\t\t\tinformation,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1585,7 +1611,7 @@ fn subtype_function(\n \t\t\t\tcrate::utilities::notify!(\n \t\t\t\t\t\"Parameter invalid rhs ({:?} {:?}) <- lhs ({:?} {:?})\",\n \t\t\t\t\trhs,\n-\t\t\t\t\tright_type_arguments,\n+\t\t\t\t\tsubtypepe_arguments,\n \t\t\t\t\tlhs,\n \t\t\t\t\tbase_type_arguments\n \t\t\t\t);\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1611,7 +1637,7 @@ fn subtype_function(\n \t} else {\n \t\tlet type_is_subtype_with_generics = type_is_subtype_with_generics(\n \t\t\t(left_func.return_type, base_type_arguments),\n-\t\t\t(right_func.return_type, right_type_arguments),\n+\t\t\t(right_func.return_type, subtypepe_arguments),\n \t\t\tstate,\n \t\t\tinformation,\n \t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1627,7 +1653,7 @@ fn subtype_function(\n \n fn subtype_floating_properties(\n \t(base_type, base_type_arguments): (TypeId, GenericChain),\n-\t(ty, right_type_arguments): (TypeId, GenericChain),\n+\t(ty, subtypepe_arguments): (TypeId, GenericChain),\n \tstate: &mut State,\n \tinformation: &impl InformationChain,\n \ttypes: &TypeStore,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1639,7 +1665,7 @@ fn subtype_floating_properties(\n \n \tsubtype_properties(\n \t\t(base_type, reversed_flattened_properties_on_base, base_type_arguments),\n-\t\t(ty, right_type_arguments),\n+\t\t(ty, subtypepe_arguments),\n \t\tstate,\n \t\tinformation,\n \t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1648,7 +1674,7 @@ fn subtype_floating_properties(\n \n fn subtype_properties<'a, T>(\n \t(base_type, base_properties, base_type_arguments): (TypeId, T, GenericChain),\n-\t(ty, right_type_arguments): (TypeId, GenericChain),\n+\t(ty, subtypepe_arguments): (TypeId, GenericChain),\n \tstate: &mut State,\n \tinformation: &impl InformationChain,\n \ttypes: &TypeStore,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1685,7 +1711,7 @@ where\n \t\tlet result = check_lhs_property_is_super_type_of_rhs(\n \t\t\t(*publicity, key),\n \t\t\t(lhs_property, base_type_arguments, false),\n-\t\t\t(ty, right_type_arguments),\n+\t\t\t(ty, subtypepe_arguments),\n \t\t\tstate,\n \t\t\tinformation,\n \t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1702,7 +1728,7 @@ where\n \t\tif let Type::Interface { extends: Some(extends), .. } = types.get_type_by_id(base_type) {\n \t\t\tlet extends_result = type_is_subtype_with_generics(\n \t\t\t\t(*extends, base_type_arguments),\n-\t\t\t\t(ty, right_type_arguments),\n+\t\t\t\t(ty, subtypepe_arguments),\n \t\t\t\tstate,\n \t\t\t\tinformation,\n \t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1771,7 +1797,7 @@ where\n fn check_lhs_property_is_super_type_of_rhs(\n \t(publicity, key): (Publicity, &PropertyKey<'_>),\n \t(lhs_property, base_type_arguments, optional): (&PropertyValue, GenericChain, bool),\n-\t(ty, right_type_arguments): (TypeId, GenericChain),\n+\t(ty, subtypepe_arguments): (TypeId, GenericChain),\n \tstate: &mut State,\n \tinformation: &impl InformationChain,\n \ttypes: &TypeStore,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1779,7 +1805,7 @@ fn check_lhs_property_is_super_type_of_rhs(\n \tmatch lhs_property {\n \t\tPropertyValue::Value(lhs_value) => {\n \t\t\tlet right_result = get_property_unbound(\n-\t\t\t\t(ty, right_type_arguments),\n+\t\t\t\t(ty, subtypepe_arguments),\n \t\t\t\t(publicity, key, base_type_arguments),\n \t\t\t\tfalse,\n \t\t\t\tinformation,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1799,7 +1825,7 @@ fn check_lhs_property_is_super_type_of_rhs(\n \t\t\t\tOk(LogicalOrValid::Logical(res)) => {\n \t\t\t\t\tlet res = check_logical_property(\n \t\t\t\t\t\t(*lhs_value, base_type_arguments, optional),\n-\t\t\t\t\t\t(res, right_type_arguments),\n+\t\t\t\t\t\t(res, subtypepe_arguments),\n \t\t\t\t\t\tstate,\n \t\t\t\t\t\tinformation,\n \t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1821,7 +1847,7 @@ fn check_lhs_property_is_super_type_of_rhs(\n \t\t\t\t))) => {\n \t\t\t\t\tcrate::utilities::notify!(\"TODO set as well?\");\n \t\t\t\t\tlet get_handler = get_property_unbound(\n-\t\t\t\t\t\t(handler, right_type_arguments),\n+\t\t\t\t\t\t(handler, subtypepe_arguments),\n \t\t\t\t\t\t(\n \t\t\t\t\t\t\tPublicity::Public,\n \t\t\t\t\t\t\t&PropertyKey::String(std::borrow::Cow::Borrowed(\"get\")),\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1859,14 +1885,14 @@ fn check_lhs_property_is_super_type_of_rhs(\n \t\t\t\t\t\t\t\tmap.insert(third, (CovariantContribution::TypeId(handler), 0));\n \t\t\t\t\t\t\t}\n \n-\t\t\t\t\t\t\tlet right_type_arguments = Some(GenericChainLink::MappedPropertyLink {\n-\t\t\t\t\t\t\t\tparent_link: right_type_arguments.as_ref(),\n+\t\t\t\t\t\t\tlet subtypepe_arguments = Some(GenericChainLink::MappedPropertyLink {\n+\t\t\t\t\t\t\t\tparent_link: subtypepe_arguments.as_ref(),\n \t\t\t\t\t\t\t\tvalue: &map,\n \t\t\t\t\t\t\t});\n \n \t\t\t\t\t\t\tlet result = type_is_subtype_with_generics(\n \t\t\t\t\t\t\t\t(*lhs_value, base_type_arguments),\n-\t\t\t\t\t\t\t\t(function.return_type, right_type_arguments),\n+\t\t\t\t\t\t\t\t(function.return_type, subtypepe_arguments),\n \t\t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\t\tinformation,\n \t\t\t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1883,7 +1909,7 @@ fn check_lhs_property_is_super_type_of_rhs(\n \t\t\t\t\t\t\tcheck_lhs_property_is_super_type_of_rhs(\n \t\t\t\t\t\t\t\t(publicity, key),\n \t\t\t\t\t\t\t\t(lhs_property, base_type_arguments, optional),\n-\t\t\t\t\t\t\t\t(handler, right_type_arguments),\n+\t\t\t\t\t\t\t\t(handler, subtypepe_arguments),\n \t\t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\t\tinformation,\n \t\t\t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1893,7 +1919,7 @@ fn check_lhs_property_is_super_type_of_rhs(\n \t\t\t\t\t\tcheck_lhs_property_is_super_type_of_rhs(\n \t\t\t\t\t\t\t(publicity, key),\n \t\t\t\t\t\t\t(lhs_property, base_type_arguments, optional),\n-\t\t\t\t\t\t\t(handler, right_type_arguments),\n+\t\t\t\t\t\t\t(handler, subtypepe_arguments),\n \t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\tinformation,\n \t\t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1967,14 +1993,14 @@ fn check_lhs_property_is_super_type_of_rhs(\n \t\t\tcheck_lhs_property_is_super_type_of_rhs(\n \t\t\t\t(publicity, key),\n \t\t\t\t(truthy, base_type_arguments, is_optional),\n-\t\t\t\t(ty, right_type_arguments),\n+\t\t\t\t(ty, subtypepe_arguments),\n \t\t\t\tstate,\n \t\t\t\tinformation,\n \t\t\t\ttypes,\n \t\t\t)\n \t\t\t// if let PropertyValue::Value(lhs_value) = &**truthy {\n \t\t\t// let property = get_property_unbound(\n-\t\t\t// \t(ty, right_type_arguments),\n+\t\t\t// \t(ty, subtypepe_arguments),\n \t\t\t// \t(publicity, key, base_type_arguments),\n \t\t\t// \tinformation,\n \t\t\t// \ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1986,14 +2012,14 @@ fn check_lhs_property_is_super_type_of_rhs(\n \t\t\t// \tlet found = if let Logical::Pure(PropertyValue::Value(ref found)) = property {\n \t\t\t// \t\t*found\n \t\t\t// \t} else {\n-\t\t\t// \t\tTypeId::ERROR_TYPE\n+\t\t\t// \t\tTypeId::UNIMPLEMENTED_ERROR_TYPE\n \t\t\t// \t};\n \n \t\t\t// \tcrate::utilities::notify!(\"{:?}\", property);\n \n \t\t\t// \tlet res = check_logical_property(\n \t\t\t// \t\t(*lhs_value, base_type_arguments),\n-\t\t\t// \t\t(property, right_type_arguments),\n+\t\t\t// \t\t(property, subtypepe_arguments),\n \t\t\t// \t\tstate,\n \t\t\t// \t\tinformation,\n \t\t\t// \t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2024,7 +2050,7 @@ fn check_lhs_property_is_super_type_of_rhs(\n \t\t\tcheck_lhs_property_is_super_type_of_rhs(\n \t\t\t\t(publicity, key),\n \t\t\t\t(on, base_type_arguments, optional),\n-\t\t\t\t(ty, right_type_arguments),\n+\t\t\t\t(ty, subtypepe_arguments),\n \t\t\t\tstate,\n \t\t\t\tinformation,\n \t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2035,7 +2061,7 @@ fn check_lhs_property_is_super_type_of_rhs(\n \n fn check_logical_property(\n \t(lhs_property_value, lhs_property_value_type_arguments, optional): (TypeId, GenericChain, bool),\n-\t(rhs_property, right_type_arguments): (Logical<PropertyValue>, GenericChain),\n+\t(rhs_property, subtypepe_arguments): (Logical<PropertyValue>, GenericChain),\n \tstate: &mut State,\n \tinformation: &impl InformationChain,\n \ttypes: &TypeStore,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2053,7 +2079,7 @@ fn check_logical_property(\n \n \t\t\ttype_is_subtype_with_generics(\n \t\t\t\t(lhs_property_value, lhs_property_value_type_arguments),\n-\t\t\t\t(rhs_type, right_type_arguments),\n+\t\t\t\t(rhs_type, subtypepe_arguments),\n \t\t\t\tstate,\n \t\t\t\tinformation,\n \t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2066,7 +2092,7 @@ fn check_logical_property(\n \t\t\t{\n \t\t\t\tlet left_result = check_logical_property(\n \t\t\t\t\t(lhs_property_value, lhs_property_value_type_arguments, optional),\n-\t\t\t\t\t(left, right_type_arguments),\n+\t\t\t\t\t(left, subtypepe_arguments),\n \t\t\t\t\tstate,\n \t\t\t\t\tinformation,\n \t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2075,7 +2101,7 @@ fn check_logical_property(\n \t\t\t\tif let SubTypeResult::IsSubType = left_result {\n \t\t\t\t\tcheck_logical_property(\n \t\t\t\t\t\t(lhs_property_value, lhs_property_value_type_arguments, optional),\n-\t\t\t\t\t\t(right, right_type_arguments),\n+\t\t\t\t\t\t(right, subtypepe_arguments),\n \t\t\t\t\t\tstate,\n \t\t\t\t\t\tinformation,\n \t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2098,8 +2124,8 @@ fn check_logical_property(\n \t\t\t\t(\n \t\t\t\t\t*on,\n \t\t\t\t\tGenericChainLink::append(\n-\t\t\t\t\t\tTypeId::ERROR_TYPE,\n-\t\t\t\t\t\tright_type_arguments.as_ref(),\n+\t\t\t\t\t\tTypeId::UNIMPLEMENTED_ERROR_TYPE,\n+\t\t\t\t\t\tsubtypepe_arguments.as_ref(),\n \t\t\t\t\t\t&antecedent,\n \t\t\t\t\t),\n \t\t\t\t),\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2111,7 +2137,7 @@ fn check_logical_property(\n \t\tLogical::BasedOnKey(kind) => match kind {\n \t\t\tBasedOnKey::Left { value, key_arguments } => {\n \t\t\t\tlet property_generics = Some(GenericChainLink::MappedPropertyLink {\n-\t\t\t\t\tparent_link: right_type_arguments.as_ref(),\n+\t\t\t\t\tparent_link: subtypepe_arguments.as_ref(),\n \t\t\t\t\tvalue: &key_arguments,\n \t\t\t\t});\n \t\t\t\tcheck_logical_property(\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2129,7 +2155,7 @@ fn check_logical_property(\n \t\t\t\t\ttype_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\tMappedKey { value: (*extends).into(), key },\n \t\t\t\t\t\t(lhs_property_value, lhs_property_value_type_arguments, optional),\n-\t\t\t\t\t\t(on, right_type_arguments),\n+\t\t\t\t\t\t(on, subtypepe_arguments),\n \t\t\t\t\t\tstate,\n \t\t\t\t\t\tinformation,\n \t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2138,7 +2164,7 @@ fn check_logical_property(\n \t\t\t\t\tlet filter = get_constraint(key, types).unwrap_or(key);\n \n \t\t\t\t\tlet properties = get_properties_on_single_type2(\n-\t\t\t\t\t\t(on, right_type_arguments),\n+\t\t\t\t\t\t(on, subtypepe_arguments),\n \t\t\t\t\t\ttypes,\n \t\t\t\t\t\tinformation,\n \t\t\t\t\t\tfilter,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2146,7 +2172,7 @@ fn check_logical_property(\n \t\t\t\t\tfor (_key, rhs_property, _args) in properties {\n \t\t\t\t\t\tlet result = check_logical_property(\n \t\t\t\t\t\t\t(lhs_property_value, lhs_property_value_type_arguments, optional),\n-\t\t\t\t\t\t\t(Logical::Pure(rhs_property), right_type_arguments),\n+\t\t\t\t\t\t\t(Logical::Pure(rhs_property), subtypepe_arguments),\n \t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\tinformation,\n \t\t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2172,7 +2198,7 @@ pub struct MappedKey {\n pub fn type_is_subtype_of_property_mapped_key(\n \tmapped_key: MappedKey,\n \t(base, property_generics, optional): (TypeId, GenericChain, bool),\n-\t(ty, right_type_arguments): (TypeId, GenericChain),\n+\t(ty, subtypepe_arguments): (TypeId, GenericChain),\n \tstate: &mut State,\n \tinformation: &impl InformationChain,\n \ttypes: &TypeStore,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2185,11 +2211,11 @@ pub fn type_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\"Reading {:?}, with {:?} {:?}\",\n \t\t\t\t\ttypes.get_type_by_id(ty),\n \t\t\t\t\ts,\n-\t\t\t\t\t(property_generics.as_ref(), right_type_arguments.as_ref())\n+\t\t\t\t\t(property_generics.as_ref(), subtypepe_arguments.as_ref())\n \t\t\t\t);\n \t\t\t}\n \t\t\tlet right_property = get_property_unbound(\n-\t\t\t\t(ty, right_type_arguments),\n+\t\t\t\t(ty, subtypepe_arguments),\n \t\t\t\t(\n \t\t\t\t\tPublicity::Public,\n \t\t\t\t\t&PropertyKey::String(std::borrow::Cow::Owned(s.to_owned())),\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2209,7 +2235,7 @@ pub fn type_is_subtype_of_property_mapped_key(\n \t\t\t\t\t});\n \t\t\t\t\tlet result = check_logical_property(\n \t\t\t\t\t\t(base, property_generics, optional),\n-\t\t\t\t\t\t(right_property, right_type_arguments),\n+\t\t\t\t\t\t(right_property, subtypepe_arguments),\n \t\t\t\t\t\tstate,\n \t\t\t\t\t\tinformation,\n \t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2236,7 +2262,7 @@ pub fn type_is_subtype_of_property_mapped_key(\n \t\t\t\t| Type::AliasTo { to, name: _, parameters: _ } => type_is_subtype_of_property_mapped_key(\n \t\t\t\t\tMappedKey { value: (*to).into(), key: mapped_key.key },\n \t\t\t\t\t(base, property_generics, optional),\n-\t\t\t\t\t(ty, right_type_arguments),\n+\t\t\t\t\t(ty, subtypepe_arguments),\n \t\t\t\t\tstate,\n \t\t\t\t\tinformation,\n \t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2245,7 +2271,7 @@ pub fn type_is_subtype_of_property_mapped_key(\n \t\t\t\t\tlet left = type_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\tMappedKey { value: (*left).into(), key: mapped_key.key },\n \t\t\t\t\t\t(base, property_generics, optional),\n-\t\t\t\t\t\t(ty, right_type_arguments),\n+\t\t\t\t\t\t(ty, subtypepe_arguments),\n \t\t\t\t\t\tstate,\n \t\t\t\t\t\tinformation,\n \t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2254,7 +2280,7 @@ pub fn type_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\ttype_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\t\tMappedKey { value: (*right).into(), key: mapped_key.key },\n \t\t\t\t\t\t\t(base, property_generics, optional),\n-\t\t\t\t\t\t\t(ty, right_type_arguments),\n+\t\t\t\t\t\t\t(ty, subtypepe_arguments),\n \t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\tinformation,\n \t\t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2267,7 +2293,7 @@ pub fn type_is_subtype_of_property_mapped_key(\n \t\t\t\t\tlet left = type_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\tMappedKey { value: (*left).into(), key: mapped_key.key },\n \t\t\t\t\t\t(base, property_generics, optional),\n-\t\t\t\t\t\t(ty, right_type_arguments),\n+\t\t\t\t\t\t(ty, subtypepe_arguments),\n \t\t\t\t\t\tstate,\n \t\t\t\t\t\tinformation,\n \t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2278,7 +2304,7 @@ pub fn type_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\ttype_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\t\tMappedKey { value: (*right).into(), key: mapped_key.key },\n \t\t\t\t\t\t\t(base, property_generics, optional),\n-\t\t\t\t\t\t\t(ty, right_type_arguments),\n+\t\t\t\t\t\t\t(ty, subtypepe_arguments),\n \t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\tinformation,\n \t\t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2293,7 +2319,7 @@ pub fn type_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\ttype_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\t\tMappedKey { value: value.into(), key: mapped_key.key },\n \t\t\t\t\t\t\t(base, property_generics, optional),\n-\t\t\t\t\t\t\t(ty, right_type_arguments),\n+\t\t\t\t\t\t\t(ty, subtypepe_arguments),\n \t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\tinformation,\n \t\t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2323,7 +2349,7 @@ pub fn type_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\tlet result = type_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\t\tMappedKey { value, key: mapped_key.key },\n \t\t\t\t\t\t\t(base, property_generics, optional),\n-\t\t\t\t\t\t\t(ty, right_type_arguments),\n+\t\t\t\t\t\t\t(ty, subtypepe_arguments),\n \t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\tinformation,\n \t\t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2341,8 +2367,8 @@ pub fn type_is_subtype_of_property_mapped_key(\n \t\t\t\tType::Class { .. } => todo!(),\n \t\t\t\tType::Constant(_) => {\n \t\t\t\t\tlet right_property = get_property_unbound(\n-\t\t\t\t\t\t(ty, right_type_arguments),\n-\t\t\t\t\t\t(Publicity::Public, &PropertyKey::Type(key_ty), right_type_arguments),\n+\t\t\t\t\t\t(ty, subtypepe_arguments),\n+\t\t\t\t\t\t(Publicity::Public, &PropertyKey::Type(key_ty), subtypepe_arguments),\n \t\t\t\t\t\ttrue,\n \t\t\t\t\t\tinformation,\n \t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2358,7 +2384,7 @@ pub fn type_is_subtype_of_property_mapped_key(\n \t\t\t\t\t\t\t});\n \t\t\t\t\t\t\tcheck_logical_property(\n \t\t\t\t\t\t\t\t(base, property_generics, optional),\n-\t\t\t\t\t\t\t\t(right_property, right_type_arguments),\n+\t\t\t\t\t\t\t\t(right_property, subtypepe_arguments),\n \t\t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\t\tinformation,\n \t\t\t\t\t\t\t\ttypes,\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2708,7 +2734,7 @@ pub(crate) fn slice_matches_type(\n \t\t\t)\n \t\t}\n \t\tType::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n-\t\t\ton: TypeId::MULTIPLE_OF | TypeId::LESS_THAN | TypeId::GREATER_THAN,\n+\t\t\ton: TypeId::MULTIPLE_OF | TypeId::INCLUSIVE_RANGE | TypeId::EXCLUSIVE_RANGE,\n \t\t\targuments: _,\n \t\t}) if allow_casts => {\n \t\t\t// Special behavior here to treat numerical property keys (which are strings) as numbers\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2812,6 +2838,7 @@ pub(crate) fn slice_matches_type(\n \t\t\tlhs,\n \t\t\trhs,\n \t\t\toperator: MathematicalAndBitwise::Add,\n+\t\t\tresult: _,\n \t\t}) => {\n \t\t\tlet lhs = base_type_arguments\n \t\t\t\t.as_ref()\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -2890,33 +2917,31 @@ pub(crate) fn number_matches_type(\n \t\t\t}\n \t\t}\n \t\tType::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n-\t\t\ton: on @ (TypeId::MULTIPLE_OF | TypeId::LESS_THAN | TypeId::GREATER_THAN),\n+\t\t\ton: TypeId::MULTIPLE_OF,\n \t\t\targuments,\n \t\t}) => {\n-\t\t\t// Special behavior here to treat numerical property keys (which are strings) as numbers\n-\t\t\t// TODO unify with the subtyping\n-\t\t\tlet argument = arguments.get_structure_restriction(TypeId::NUMBER_GENERIC).unwrap();\n-\n-\t\t\tlet arg_ty = types.get_type_by_id(argument);\n-\t\t\tif let Type::Constant(Constant::Number(argument)) = arg_ty {\n+\t\t\tlet argument =\n+\t\t\t\targuments.get_structure_restriction(TypeId::NUMBER_FLOOR_GENERIC).unwrap();\n+\t\t\tif let Type::Constant(Constant::Number(argument)) = types.get_type_by_id(argument) {\n \t\t\t\tlet number: ordered_float::NotNan<f64> = number.try_into().unwrap();\n-\t\t\t\tcrate::utilities::notify!(\"value={:?}, arg={:?}\", number, argument);\n-\t\t\t\tmatch *on {\n-\t\t\t\t\tTypeId::LESS_THAN => *argument < number,\n-\t\t\t\t\tTypeId::GREATER_THAN => *argument > number,\n-\t\t\t\t\tTypeId::MULTIPLE_OF => number % *argument == 0f64,\n-\t\t\t\t\t_ => unreachable!(),\n-\t\t\t\t}\n+\t\t\t\t(number % argument) == 0.\n \t\t\t} else {\n-\t\t\t\tcrate::utilities::notify!(\"TODO argument is dependent {:?}\", arg_ty);\n+\t\t\t\tcrate::utilities::notify!(\"Here?\");\n \t\t\t\tfalse\n \t\t\t}\n \t\t}\n+\t\tType::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n+\t\t\ton: TypeId::INCLUSIVE_RANGE | TypeId::EXCLUSIVE_RANGE,\n+\t\t\targuments: _,\n+\t\t}) => {\n+\t\t\tlet lhs_range = intrinsics::get_range(base, types).unwrap();\n+\t\t\tintrinsics::FloatRange::single(number.try_into().unwrap()).contained_in(lhs_range)\n+\t\t}\n \t\tType::PartiallyAppliedGenerics(PartiallyAppliedGenerics {\n \t\t\ton: TypeId::NOT_RESTRICTION,\n \t\t\targuments,\n \t\t}) => {\n-\t\t\tlet argument = arguments.get_structure_restriction(TypeId::NUMBER_GENERIC).unwrap();\n+\t\t\tlet argument = arguments.get_structure_restriction(TypeId::T_TYPE).unwrap();\n \n \t\t\t!number_matches_type(\n \t\t\t\t(argument, base_type_arguments),\ndiff --git a/checker/src/types/terms.rs b/checker/src/types/terms.rs\n--- a/checker/src/types/terms.rs\n+++ b/checker/src/types/terms.rs\n@@ -2,7 +2,7 @@ use std::borrow::Cow;\n \n use super::TypeId;\n \n-/// Terms\n+/// Terms. `null` is a special object\n /// TODO:\n /// - `BigInt` (<https://github.com/rust-num/num-bigint>)\n #[derive(Eq, PartialEq, Hash, Debug, Clone, binary_serialize_derive::BinarySerializable)]\ndiff --git a/checker/src/types/terms.rs b/checker/src/types/terms.rs\n--- a/checker/src/types/terms.rs\n+++ b/checker/src/types/terms.rs\n@@ -12,6 +12,7 @@ pub enum Constant {\n \tBoolean(bool),\n \tSymbol { key: String },\n \tNaN,\n+\tUndefined,\n }\n \n impl Constant {\ndiff --git a/checker/src/types/terms.rs b/checker/src/types/terms.rs\n--- a/checker/src/types/terms.rs\n+++ b/checker/src/types/terms.rs\n@@ -24,6 +25,7 @@ impl Constant {\n \t\t\tConstant::Boolean(value) => Cow::Borrowed(if *value { \"true\" } else { \"false\" }),\n \t\t\tConstant::Symbol { key } => Cow::Owned(format!(\"Symbol({key})\")),\n \t\t\tConstant::NaN => Cow::Borrowed(\"NaN\"),\n+\t\t\tConstant::Undefined => Cow::Borrowed(\"undefined\"),\n \t\t}\n \t}\n \ndiff --git a/checker/src/types/terms.rs b/checker/src/types/terms.rs\n--- a/checker/src/types/terms.rs\n+++ b/checker/src/types/terms.rs\n@@ -37,16 +39,19 @@ impl Constant {\n \t\t\tConstant::Boolean(value) => if *value { \"true\" } else { \"false\" }.to_owned(),\n \t\t\tConstant::Symbol { key } => format!(\"Symbol({key})\"),\n \t\t\tConstant::NaN => \"NaN\".to_owned(),\n+\t\t\tConstant::Undefined => \"undefined\".to_owned(),\n \t\t}\n \t}\n \n \t#[must_use]\n-\tpub fn get_backing_type_id(&self) -> TypeId {\n+\tpub fn get_backing_type(&self) -> TypeId {\n \t\tmatch self {\n \t\t\tConstant::Number(_) | Constant::NaN => TypeId::NUMBER_TYPE,\n \t\t\tConstant::String(_) => TypeId::STRING_TYPE,\n \t\t\tConstant::Boolean(_) => TypeId::BOOLEAN_TYPE,\n \t\t\tConstant::Symbol { .. } => TypeId::SYMBOL_TYPE,\n+\t\t\t// TODO ...\n+\t\t\tConstant::Undefined => TypeId::NEVER_TYPE,\n \t\t}\n \t}\n }\ndiff --git a/checker/src/utilities/mod.rs b/checker/src/utilities/mod.rs\n--- a/checker/src/utilities/mod.rs\n+++ b/checker/src/utilities/mod.rs\n@@ -1,6 +1,7 @@\n //! These should probably be made into reusable crates at some point\n \n mod debugging;\n+pub mod float_range;\n pub mod map;\n pub mod range_map;\n pub mod serialization;\n",
        "test_patch": "diff --git /dev/null b/.github/workflows/examples.yml\nnew file mode 100644\n--- /dev/null\n+++ b/.github/workflows/examples.yml\n@@ -0,0 +1,55 @@\n+name: Examples\n+\n+on:\n+  push:\n+    branches: [main]\n+  workflow_dispatch:\n+\n+env:\n+  CARGO_TERM_COLOR: always\n+\n+jobs:\n+  run-examples:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+      - uses: actions/checkout@v4\n+      - uses: dtolnay/rust-toolchain@stable\n+      - uses: actions/cache@v4\n+        with:\n+          path: |\n+            ~/.cargo/bin/\n+            ~/.cargo/registry/index/\n+            ~/.cargo/registry/cache/\n+            ~/.cargo/git/db/\n+            target/\n+          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n+\n+      - name: Build Ezno\n+        run: cargo build --release\n+        env:\n+          CARGO_PROFILE_RELEASE_DEBUG: true\n+\n+      - name: Run checker on example files\n+        shell: bash\n+        run: |\n+          files=(\n+              \"https://jsr.io/@yossydev/hello-world/1.0.0/index.ts\"\n+              \"https://jsr.io/@bengineering/shuffle-binary/0.0.1/index.ts\"\n+              \"https://jsr.io/@bengineering/mulberry32/0.0.1/mod.ts\"\n+              \"https://jsr.io/@luca/cases/1.0.0/mod.ts\"\n+              \"https://jsr.io/@std/assert/1.0.2/assertion_error.ts\"\n+              \"https://jsr.io/@std/text/1.0.3/levenshtein_distance.ts\"\n+              \"https://jsr.io/@gnome/monads/0.0.0/src/option.ts\"\n+              \"https://raw.githubusercontent.com/getify/deePool/master/src/deePool.js\"\n+              \"https://raw.githubusercontent.com/silen-z/fiveway/main/packages/fiveway/src/id.ts\"\n+          )\n+\n+          for url in \"${files[@]}\"; do\n+              header=\"--- $url ---\"\n+              echo $header\n+              curl -s $url > temp.ts\n+              ./target/release/ezno check temp.ts --timings\n+              echo \"${header//?/-}\"\n+              echo \"\"\n+          done\n\\ No newline at end of file\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -2371,6 +2373,164 @@ fakeRead(array1)\n \n - Invalid assignment through parameter\n \n+### Operators\n+\n+#### Always known math\n+\n+```ts\n+// True regardless of \n+function func(a: number) { return a ** 0 }\n+\n+func satisfies string;\n+\n+declare let x: NotNotANumber;\n+(x ** 1 === x) satisfies true;\n+```\n+\n+- Expected string, found (a: number) => 1\n+\n+#### Inequality checks\n+\n+```ts\n+function func1(a: GreaterThan<4>) {\n+\t(a > 3) satisfies true;\n+\t(a < 3) satisfies false;\n+\t(a < 10) satisfies string;\n+}\n+\n+// thanks narrowing \ud83d\ude4f\n+function func2(a: number) {\n+\tif (a < 2) {\n+\t\t(a > 6) satisfies false;\n+\t\t(a < 7) satisfies true;\n+\t\t(a > 0) satisfies null;\n+\t}\n+}\n+```\n+\n+- This equality is always false as GreaterThan<4> and 3 have no overlap\n+- Expected string, found boolean\n+- This equality is always false as LessThan<2> and 6 have no overlap\n+- Expected null, found boolean\n+\n+#### Arithmetic operand check\n+\n+> This is allowed under non strict casts option (and will return NaN) but the tests run with strict casts on\n+\n+> This would need to support [Symbol.toPrimitive] + a bunch of error handling\n+\n+```ts\n+console + 2\n+```\n+\n+> TODO temp diagnostic\n+\n+- Cannot Console Add 2\n+\n+#### Inequality operand check\n+\n+```ts\n+function isLessThan(a: number) {\n+\ta < console;\n+}\n+```\n+\n+> TODO temp diagnostic\n+\n+- Cannot number LessThan Console\n+\n+#### Unary operand check\n+\n+```ts\n+function func(a: number, b: boolean) {\n+\tconst x = !a;\n+\tconst y = ~b;\n+\t(!b), (~a);\n+}\n+```\n+\n+> TODO temp diagnostic\n+\n+- Cannot LogicalNot number\n+- Cannot BitwiseNot boolean\n+\n+#### Disjoint equality\n+\n+```ts\n+function neverEqual(a: string, b: number) {\n+\t(a === b) satisfies false;\n+}\n+\n+function sometimes(a: string | number, b: number) {\n+\t(a === b) satisfies string;\n+}\n+```\n+\n+- This equality is always false as string and number have no overlap\n+- Expected string, found boolean\n+\n+#### Disjoint equality for number intrinsics\n+\n+```ts\n+declare function getNumberBetweenFive(): InclusiveRange<0, 5> & Integer;\n+\n+getNumberBetweenFive() === 2;\n+getNumberBetweenFive() === 2.2;\n+getNumberBetweenFive() === 7;\n+```\n+\n+- This equality is always false as InclusiveRange<0, 5> & Integer and 2.2 have no overlap\n+- This equality is always false as InclusiveRange<0, 5> & Integer and 7 have no overlap\n+\n+#### Identity equality\n+\n+> Can only do it not NaN\n+\n+```ts\n+function func(a: string, b: number) {\n+\t(a === a) satisfies string;\n+    (b === b) satisfies null;\n+}\n+```\n+\n+- Expected string, found true\n+- Expected null, found boolean\n+\n+#### Ranges for interal types\n+\n+```ts\n+function func(a: number) {\n+\t(Math.sin(a) > -2) satisfies true;\n+\t(Math.sin(a) > -1) satisfies string;\n+}\n+```\n+\n+- Expected string, found boolean\n+\n+#### Ranges after operators\n+\n+```ts\n+function func(a: number) {\n+\t(Math.sin(a) * 5) satisfies null;\n+\t((Math.sin(a) + 10)) * 2 satisfies string;\n+}\n+```\n+\n+- Expected null, found InclusiveRange\\<-5, 5>\n+- Expected string, found InclusiveRange\\<18, 22>\n+\n+#### Not disjoint\n+\n+```ts\n+function func(param: number) {\n+\tif (param !== 2) {\n+\t\treturn param === 2\n+\t}\n+}\n+```\n+\n+- This equality is always false as Not<2> and 2 have no overlap\n+\n ### Statements, declarations and expressions\n \n > Some of these are part of synthesis, rather than checking\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -4179,6 +4385,51 @@ function func2(param: any): asserts param is boolean {\n \n - Cannot return asserts any is string because the function is expected to return asserts any is number\n \n+#### External predicate\n+\n+```ts\n+function func(param: number | Array<string>) {\n+\tif (Array.isArray(param)) {\n+\t\tparam satisfies null;\n+\t}\n+}\n+```\n+\n+- Expected null, found Array\\<string>\n+\n+#### Number `isNan`\n+\n+```ts\n+function func(param: number) {\n+\tif (param !== param) {\n+\t\tparam satisfies string;\n+\t}\n+\n+\t// Derives from `!==`\n+\tif (Number.isNaN(param)) {\n+\t\tparam satisfies null;\n+\t}\n+}\n+```\n+\n+- Expected string, found Not\\<NaN>\n+- Expected null, found Not\\<NaN>\n+\n+#### Narrowing falsy values\n+\n+```ts\n+function getName(name?: string) {\n+\tif (name) {\n+\t\tname satisfies undefined;\n+\t\treturn name\n+\t} else {\n+\t\treturn \"default\"\n+\t}\n+}\n+```\n+\n+- Expected undefined, found string\n+\n ### Object constraint\n \n > Any references to a annotated variable **must** be within its LHS type. These test that it carries down to objects.\ndiff --git a/checker/specification/to_implement.md b/checker/specification/to_implement.md\n--- a/checker/specification/to_implement.md\n+++ b/checker/specification/to_implement.md\n@@ -519,18 +519,6 @@ y satisfies string;\n \n ### Expressions\n \n-#### Bad arithmetic operator\n-\n-> This is allowed under non strict casts option (and will return NaN) but the tests run with strict casts on\n-\n-> This would need to support [Symbol.toPrimitive] + a bunch of error handling\n-\n-```ts\n-console + 2\n-```\n-\n-- Expected number, found Console\n-\n #### Array spread\n \n ```ts\ndiff --git a/checker/src/types/subtyping.rs b/checker/src/types/subtyping.rs\n--- a/checker/src/types/subtyping.rs\n+++ b/checker/src/types/subtyping.rs\n@@ -1535,28 +1561,28 @@ pub(crate) fn type_is_subtype_with_generics(\n \n fn subtype_function(\n \t(left_func, base_type_arguments): (crate::FunctionId, GenericChain),\n-\t(right_ty, ty, right_type_arguments): (&Type, TypeId, GenericChain),\n+\t(subtype, ty, subtypepe_arguments): (&Type, TypeId, GenericChain),\n \tstate: &mut State,\n \tinformation: &impl InformationChain,\n \ttypes: &TypeStore,\n ) -> SubTypeResult {\n \tlet right_func = if let Type::FunctionReference(right_func)\n-\t| Type::SpecialObject(SpecialObject::Function(right_func, _)) = right_ty\n+\t| Type::SpecialObject(SpecialObject::Function(right_func, _)) = subtype\n \t{\n \t\tright_func\n \t} else if let Some(constraint) = get_constraint(ty, types) {\n \t\t// TODO explain why get_constraint early breaks a bunch of tests\n-\t\tlet right_ty = types.get_type_by_id(constraint);\n+\t\tlet subtype = types.get_type_by_id(constraint);\n \t\tif let Type::FunctionReference(right_func)\n-\t\t| Type::SpecialObject(SpecialObject::Function(right_func, _)) = right_ty\n+\t\t| Type::SpecialObject(SpecialObject::Function(right_func, _)) = subtype\n \t\t{\n \t\t\tright_func\n \t\t} else {\n-\t\t\tcrate::utilities::notify!(\"Not function after constraint!! {:?}\", right_ty);\n+\t\t\tcrate::utilities::notify!(\"Not function after constraint!! {:?}\", subtype);\n \t\t\treturn SubTypeResult::IsNotSubType(NonEqualityReason::Mismatch);\n \t\t}\n \t} else {\n-\t\tcrate::utilities::notify!(\"Not function!! {:?}\", right_ty);\n+\t\tcrate::utilities::notify!(\"Not function!! {:?}\", subtype);\n \t\treturn SubTypeResult::IsNotSubType(NonEqualityReason::Mismatch);\n \t};\n \ndiff --git /dev/null b/checker/src/utilities/float_range.rs\nnew file mode 100644\n--- /dev/null\n+++ b/checker/src/utilities/float_range.rs\n@@ -0,0 +1,207 @@\n+type BetterF64 = ordered_float::NotNan<f64>;\n+\n+// TODO\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+pub enum FloatRange {\n+\t/// yes or `===`\n+\tInclusive { floor: BetterF64, ceiling: BetterF64 },\n+\t/// but not necessarily `===`\n+\tExclusive { floor: BetterF64, ceiling: BetterF64 },\n+}\n+\n+impl FloatRange {\n+\t#[must_use]\n+\tpub fn single(on: BetterF64) -> Self {\n+\t\tSelf::Inclusive { floor: on, ceiling: on }\n+\t}\n+\n+\t/// For disjointness. TODO Think this is correct\n+\t#[must_use]\n+\tpub fn overlaps(self, other: Self) -> bool {\n+\t\tcrate::utilities::notify!(\"{:?} \u2229 {:?} != \u2205\", self, other);\n+\n+\t\tif let (\n+\t\t\tSelf::Inclusive { floor: l_floor, ceiling: l_ceiling },\n+\t\t\tSelf::Inclusive { floor: r_floor, ceiling: r_ceiling },\n+\t\t) = (self, other)\n+\t\t{\n+\t\t\tif l_floor <= r_floor {\n+\t\t\t\tl_ceiling >= r_floor\n+\t\t\t} else if l_ceiling >= r_ceiling {\n+\t\t\t\tl_floor <= r_ceiling\n+\t\t\t} else {\n+\t\t\t\tfalse\n+\t\t\t}\n+\t\t} else {\n+\t\t\tlet (Self::Inclusive { floor: l_floor, ceiling: l_ceiling }\n+\t\t\t| Self::Exclusive { floor: l_floor, ceiling: l_ceiling }) = self;\n+\t\t\tlet (Self::Inclusive { floor: r_floor, ceiling: r_ceiling }\n+\t\t\t| Self::Exclusive { floor: r_floor, ceiling: r_ceiling }) = other;\n+\t\t\tif l_floor < r_floor {\n+\t\t\t\tl_ceiling > r_floor\n+\t\t\t} else if l_ceiling > r_ceiling {\n+\t\t\t\tl_floor < r_ceiling\n+\t\t\t} else {\n+\t\t\t\tfalse\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/// The \u2286 relation (non-strict). For subtyping. TODO Think this is correct\n+\t#[must_use]\n+\tpub fn contained_in(self, other: Self) -> bool {\n+\t\tcrate::utilities::notify!(\"{:?} \u2286 {:?}\", self, other);\n+\t\t// Edge case\n+\t\tif let (\n+\t\t\tSelf::Inclusive { floor: l_floor, ceiling: l_ceiling },\n+\t\t\tSelf::Exclusive { floor: r_floor, ceiling: r_ceiling },\n+\t\t) = (self, other)\n+\t\t{\n+\t\t\tl_floor > r_floor && l_ceiling < r_ceiling\n+\t\t} else {\n+\t\t\tlet (Self::Inclusive { floor: l_floor, ceiling: l_ceiling }\n+\t\t\t| Self::Exclusive { floor: l_floor, ceiling: l_ceiling }) = self;\n+\t\t\tlet (Self::Inclusive { floor: r_floor, ceiling: r_ceiling }\n+\t\t\t| Self::Exclusive { floor: r_floor, ceiling: r_ceiling }) = other;\n+\t\t\tl_floor >= r_floor && l_ceiling <= r_ceiling\n+\t\t}\n+\t}\n+\n+\t/// \u2200 a in self, \u2200 b in other: a > b\n+\t#[must_use]\n+\tpub fn above(self, other: Self) -> bool {\n+\t\tcrate::utilities::notify!(\"{:?} > {:?}\", self, other);\n+\t\tif let (\n+\t\t\tSelf::Inclusive { floor: l_floor, ceiling: _ },\n+\t\t\tSelf::Inclusive { floor: _, ceiling: r_ceiling },\n+\t\t) = (self, other)\n+\t\t{\n+\t\t\tl_floor > r_ceiling\n+\t\t} else {\n+\t\t\tlet (Self::Inclusive { floor: l_floor, ceiling: _ }\n+\t\t\t| Self::Exclusive { floor: l_floor, ceiling: _ }) = self;\n+\t\t\tlet (Self::Inclusive { floor: _, ceiling: r_ceiling }\n+\t\t\t| Self::Exclusive { floor: _, ceiling: r_ceiling }) = other;\n+\t\t\tl_floor >= r_ceiling\n+\t\t}\n+\t}\n+\n+\t/// \u2200 a in self, \u2200 b in other: a < b\n+\t#[must_use]\n+\tpub fn below(self, other: Self) -> bool {\n+\t\tcrate::utilities::notify!(\"{:?} < {:?}\", self, other);\n+\t\tif let (\n+\t\t\tSelf::Inclusive { floor: _, ceiling: l_ceiling },\n+\t\t\tSelf::Inclusive { floor: r_floor, ceiling: _ },\n+\t\t) = (self, other)\n+\t\t{\n+\t\t\tl_ceiling < r_floor\n+\t\t} else {\n+\t\t\tlet (Self::Inclusive { floor: _, ceiling: l_ceiling }\n+\t\t\t| Self::Exclusive { floor: _, ceiling: l_ceiling }) = self;\n+\t\t\tlet (Self::Inclusive { floor: r_floor, ceiling: _ }\n+\t\t\t| Self::Exclusive { floor: r_floor, ceiling: _ }) = other;\n+\t\t\tl_ceiling <= r_floor\n+\t\t}\n+\t}\n+\n+\t#[must_use]\n+\tpub fn space_addition(self, other: Self) -> Self {\n+\t\tif let (\n+\t\t\tSelf::Inclusive { floor: l_floor, ceiling: l_ceiling },\n+\t\t\tSelf::Inclusive { floor: r_floor, ceiling: r_ceiling },\n+\t\t) = (self, other)\n+\t\t{\n+\t\t\tSelf::Inclusive { floor: l_floor + r_floor, ceiling: l_ceiling + r_ceiling }\n+\t\t} else {\n+\t\t\tlet (Self::Inclusive { floor: l_floor, ceiling: l_ceiling }\n+\t\t\t| Self::Exclusive { floor: l_floor, ceiling: l_ceiling }) = self;\n+\t\t\tlet (Self::Inclusive { floor: r_floor, ceiling: r_ceiling }\n+\t\t\t| Self::Exclusive { floor: r_floor, ceiling: r_ceiling }) = other;\n+\t\t\tSelf::Exclusive { floor: l_floor + r_floor, ceiling: l_ceiling + r_ceiling }\n+\t\t}\n+\t}\n+\n+\t#[must_use]\n+\tpub fn space_multiplication(self, other: Self) -> Self {\n+\t\tlet inclusive = matches!((self, other), (Self::Inclusive { .. }, Self::Inclusive { .. }));\n+\t\tlet (Self::Inclusive { floor: l_floor, ceiling: l_ceiling }\n+\t\t| Self::Exclusive { floor: l_floor, ceiling: l_ceiling }) = self;\n+\t\tlet (Self::Inclusive { floor: r_floor, ceiling: r_ceiling }\n+\t\t| Self::Exclusive { floor: r_floor, ceiling: r_ceiling }) = other;\n+\t\t// being lazy\n+\t\tlet corners =\n+\t\t\t[l_floor * r_floor, l_floor * r_ceiling, r_floor * l_ceiling, l_ceiling * r_ceiling];\n+\t\tlet floor = *corners.iter().min().unwrap();\n+\t\tlet ceiling = *corners.iter().max().unwrap();\n+\t\tif inclusive {\n+\t\t\tSelf::Inclusive { floor, ceiling }\n+\t\t} else {\n+\t\t\tSelf::Exclusive { floor, ceiling }\n+\t\t}\n+\t}\n+\n+\t// TODO more :)\n+}\n+\n+// TODO more\n+#[cfg(test)]\n+mod tests {\n+\tuse super::{BetterF64, FloatRange};\n+\n+\t#[test]\n+\tfn contained_in() {\n+\t\tassert!(FloatRange::single(2.into())\n+\t\t\t.contained_in(FloatRange::Exclusive { floor: 0.into(), ceiling: 5.into() }));\n+\t}\n+\n+\t#[test]\n+\tfn overlaps() {\n+\t\tassert!(FloatRange::Exclusive { floor: 0.into(), ceiling: 4.into() }\n+\t\t\t.overlaps(FloatRange::Exclusive { floor: 2.into(), ceiling: 5.into() }));\n+\t\tassert!(!FloatRange::Exclusive { floor: 0.into(), ceiling: 1.into() }\n+\t\t\t.overlaps(FloatRange::Exclusive { floor: 2.into(), ceiling: 5.into() }));\n+\t}\n+\n+\t#[test]\n+\tfn above() {\n+\t\tassert!(FloatRange::Exclusive { floor: 8.into(), ceiling: 10.into() }\n+\t\t\t.above(FloatRange::Exclusive { floor: 6.into(), ceiling: 7.into() }));\n+\t\tassert!(!FloatRange::Exclusive { floor: 0.into(), ceiling: 1.into() }\n+\t\t\t.above(FloatRange::Exclusive { floor: 0.into(), ceiling: 5.into() }));\n+\t}\n+\n+\t#[test]\n+\tfn below() {\n+\t\tassert!(FloatRange::Exclusive { floor: 0.into(), ceiling: 4.into() }\n+\t\t\t.below(FloatRange::Exclusive { floor: 6.into(), ceiling: 7.into() }));\n+\t\tassert!(!FloatRange::Exclusive { floor: 0.into(), ceiling: 1.into() }\n+\t\t\t.below(FloatRange::Exclusive { floor: 0.into(), ceiling: 5.into() }));\n+\t}\n+\n+\t#[test]\n+\tfn space_addition() {\n+\t\tassert_eq!(\n+\t\t\tFloatRange::Exclusive { floor: 0.into(), ceiling: 4.into() }\n+\t\t\t\t.space_addition(FloatRange::Exclusive { floor: 6.into(), ceiling: 7.into() }),\n+\t\t\tFloatRange::Exclusive { floor: 6.into(), ceiling: 11.into() }\n+\t\t);\n+\t}\n+\n+\t#[test]\n+\tfn space_multiplication() {\n+\t\tassert_eq!(\n+\t\t\tFloatRange::Exclusive { floor: 0.into(), ceiling: 4.into() }\n+\t\t\t\t.space_multiplication(FloatRange::Exclusive { floor: 6.into(), ceiling: 7.into() }),\n+\t\t\tFloatRange::Exclusive { floor: 0.into(), ceiling: 28.into() }\n+\t\t);\n+\t\tassert_eq!(\n+\t\t\tFloatRange::Exclusive { floor: BetterF64::from(-2i32), ceiling: 4.into() }\n+\t\t\t\t.space_multiplication(FloatRange::Exclusive {\n+\t\t\t\t\tfloor: BetterF64::from(-10i32),\n+\t\t\t\t\tceiling: 1.into()\n+\t\t\t\t}),\n+\t\t\tFloatRange::Exclusive { floor: BetterF64::from(-40i32), ceiling: 20.into() }\n+\t\t);\n+\t}\n+}\n",
        "problem_statement": "Binary operator checking\nCurrent the functions to doing binary operations don't check the types of either side. First a bit of background:\r\n\r\nThere are two functions for binary operators, they are split between\r\n- Mathematical and bitwise operations. Both sides have to be checked as there is no short circuiting behavior\r\n- Logical operators. These can have logical operators (and in the future the RHS can be narrowed for && operations)\r\n\r\n*`in` and `instanceof` operators are handled specially on `Environment`*\r\n\r\nThere is a also a current option `strict_casts` (it should probably be renamed to `no_implicit_casts`) in `TypeCheckOptions`. When this is `true` should not allow operations like `\"hi\" + 2`. \r\n\r\nThese two functions are currently set up to return a `Result`. However both the logic for checking the sides **and** the diagnostic has not been implemented. For example\r\n\r\nhttps://github.com/kaleidawave/ezno/blob/502126217170121cadb12cad3debe1ff388a37f1/checker/src/behavior/operations.rs#L76-L84\r\n\r\nThere are several things to carefully consider here\r\n- Still want to enable `Symbol.toPrimative` behaviour with hints and such (that will require these functions to have all the context to be able to do a `call_type`\r\n    - This should **disallow** `Object.toPrimative` fall through as this result are not useful\n",
        "hints_text": "",
        "created_at": "2024-08-08T20:42:05Z",
        "version": "0.0"
    },
    {
        "repo": "kaleidawave/ezno",
        "pull_number": 45,
        "instance_id": "kaleidawave__ezno-45",
        "issue_numbers": [
            "1"
        ],
        "base_commit": "7fc78261e9aa1d9012ff7e8cc7d07488459bf045",
        "patch": "diff --git a/parser/Cargo.toml b/parser/Cargo.toml\n--- a/parser/Cargo.toml\n+++ b/parser/Cargo.toml\n@@ -34,7 +34,7 @@ iterator-endiate = \"0.1.0\"\n enum_variant_type = \"0.3.1\"\n enum-variants-strings = \"0.2\"\n \n-source-map = { version = \"0.12\", features = [\n+source-map = { version = \"0.13\", features = [\n   \"span-serialize\",\n   \"self-rust-tokenize\",\n ] }\ndiff --git a/parser/examples/chain.rs b/parser/examples/chain.rs\n--- a/parser/examples/chain.rs\n+++ b/parser/examples/chain.rs\n@@ -11,7 +11,7 @@ struct ShowChain;\n \n impl Visitor<Expression, ()> for ShowChain {\n \tfn visit(&mut self, item: &Expression, _data: &mut (), chain: &Chain) {\n-\t\tif matches!(item, Expression::VariableReference(name, _, _) if name == \"chain\") {\n+\t\tif matches!(item, Expression::VariableReference(name, _) if name == \"chain\") {\n \t\t\teprintln!(\"{:#?}\", chain);\n \t\t}\n \t}\ndiff --git a/parser/examples/jsx.rs b/parser/examples/jsx.rs\n--- a/parser/examples/jsx.rs\n+++ b/parser/examples/jsx.rs\n@@ -1,4 +1,4 @@\n-use ezno_parser::{ASTNode, JSXRoot, SourceId, ToStringSettings};\n+use ezno_parser::{ASTNode, JSXRoot, SourceId, ToStringOptions};\n \n fn main() {\n \tlet source = \"<MySiteLayout> <p>My page content, wrapped in a layout!</p> </MySiteLayout>\";\ndiff --git a/parser/examples/jsx.rs b/parser/examples/jsx.rs\n--- a/parser/examples/jsx.rs\n+++ b/parser/examples/jsx.rs\n@@ -11,5 +11,5 @@ fn main() {\n \t)\n \t.unwrap();\n \n-\tprintln!(\"{}\", result.to_string(&ToStringSettings::default()));\n+\tprintln!(\"{}\", result.to_string(&ToStringOptions::default()));\n }\ndiff --git a/parser/examples/lex.rs b/parser/examples/lex.rs\n--- a/parser/examples/lex.rs\n+++ b/parser/examples/lex.rs\n@@ -6,7 +6,7 @@ use tokenizer_lib::{ParallelTokenQueue, TokenReader};\n fn main() -> Result<(), Box<dyn std::error::Error>> {\n \tlet path = std::env::args().skip(1).next().ok_or(\"expected argument\")?;\n \tlet content = std::fs::read_to_string(path)?;\n-\tlex_and_print_tokens(content, Some(vec![(31, EmptyCursorId::new(0))]));\n+\tlex_and_print_tokens(content, None);\n \tOk(())\n }\n \ndiff --git a/parser/examples/parse.rs b/parser/examples/parse.rs\n--- a/parser/examples/parse.rs\n+++ b/parser/examples/parse.rs\n@@ -1,15 +1,20 @@\n-use ezno_parser::{ASTNode, FromFileError, Module, ParseSettings, ToStringSettings};\n+use std::time::Instant;\n+\n+use ezno_parser::{ASTNode, FromFileError, Module, ParseOptions, ToStringOptions};\n \n fn main() -> Result<(), Box<dyn std::error::Error>> {\n \tlet path = std::env::args().skip(1).next().ok_or(\"expected argument\")?;\n+\tlet now = Instant::now();\n \tlet mut fs = source_map::MapFileStore::default();\n-\tmatch Module::from_file(&path, ParseSettings::default(), Vec::default(), &mut fs) {\n+\tmatch Module::from_file(&path, ParseOptions::default(), Vec::default(), &mut fs) {\n \t\tOk(module) => {\n-\t\t\tprintln!(\"{module:#?}\");\n-\n-\t\t\tlet output = module.to_string(&ToStringSettings::default());\n-\t\t\tprintln!(\"In string form:\");\n-\t\t\tprintln!(\"{output}\");\n+\t\t\tprintln!(\"{:?}\", now.elapsed());\n+\t\t\tif std::env::args().any(|item| item == \"--ast\") {\n+\t\t\t\tprintln!(\"{module:#?}\");\n+\t\t\t} else {\n+\t\t\t\tlet output = module.to_string(&ToStringOptions::default());\n+\t\t\t\tprintln!(\"{output}\");\n+\t\t\t}\n \t\t\tOk(())\n \t\t}\n \t\tErr(FromFileError::FileError(_file_err)) => {\ndiff --git a/parser/examples/parse.rs b/parser/examples/parse.rs\n--- a/parser/examples/parse.rs\n+++ b/parser/examples/parse.rs\n@@ -18,7 +23,10 @@ fn main() -> Result<(), Box<dyn std::error::Error>> {\n \t\t}\n \t\tErr(FromFileError::ParseError(parse_err)) => {\n \t\t\tprintln!(\"parse error {}\", parse_err.reason);\n-\t\t\tprintln!(\"error on {:?}\", parse_err.position.into_line_column_span(&fs));\n+\t\t\tprintln!(\n+\t\t\t\t\"error on {:?}\",\n+\t\t\t\tparse_err.position.into_line_column_span::<source_map::encodings::Utf8>(&fs)\n+\t\t\t);\n \t\t\tErr(Box::<dyn std::error::Error>::from(\"error\"))\n \t\t}\n \t}\ndiff --git a/parser/examples/type_references.rs b/parser/examples/type_references.rs\n--- a/parser/examples/type_references.rs\n+++ b/parser/examples/type_references.rs\n@@ -1,7 +1,7 @@\n-use ezno_parser::{ASTNode, Expression, SourceId, TypeReference};\n+use ezno_parser::{ASTNode, Expression, SourceId, TypeAnnotation};\n \n fn main() {\n-\tlet reference = TypeReference::from_string(\n+\tlet reference = TypeAnnotation::from_string(\n \t\t\"Pair<Nested<Object<2>>, Array<number>>\".into(),\n \t\tDefault::default(),\n \t\tSourceId::NULL,\ndiff --git a/parser/generator/generator.rs b/parser/generator/generator.rs\n--- a/parser/generator/generator.rs\n+++ b/parser/generator/generator.rs\n@@ -42,7 +42,7 @@ fn token_stream_to_ast_node<T: parser::ASTNode + self_rust_tokenize::SelfRustTok\n \n \tlet parse_result = T::from_string(\n \t\tstring,\n-\t\tparser::ParseSettings::default(),\n+\t\tparser::ParseOptions::default(),\n \t\tparser::SourceId::NULL,\n \t\tNone,\n \t\tcursors,\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -1,9 +1,5 @@\n-use std::{\n-\tborrow::Cow,\n-\tsync::atomic::{AtomicU16, Ordering},\n-};\n+use std::borrow::Cow;\n \n-use derive_debug_extras::DebugExtras;\n use derive_enum_from_into::EnumFrom;\n use iterator_endiate::EndiateIteratorExt;\n use tokenizer_lib::Token;\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -11,37 +7,9 @@ use visitable_derive::Visitable;\n \n use super::{ASTNode, Span, TSXToken, TokenReader};\n use crate::{\n-\texpect_semi_colon, Declaration, ParseResult, ParseSettings, Statement, VisitSettings, Visitable,\n+\texpect_semi_colon, Declaration, ParseOptions, ParseResult, Statement, VisitSettings, Visitable,\n };\n \n-static BLOCK_ID_COUNTER: AtomicU16 = AtomicU16::new(0);\n-\n-/// A identifier for a group of statements\n-#[derive(PartialEq, Eq, Clone, Copy, DebugExtras, Hash)]\n-pub struct BlockId(u16);\n-\n-// TODO not sure\n-#[cfg(feature = \"self-rust-tokenize\")]\n-impl self_rust_tokenize::SelfRustTokenize for BlockId {\n-\tfn append_to_token_stream(\n-\t\t&self,\n-\t\ttoken_stream: &mut self_rust_tokenize::proc_macro2::TokenStream,\n-\t) {\n-\t\ttoken_stream.extend(self_rust_tokenize::quote!(BlockId::new()))\n-\t}\n-}\n-\n-impl BlockId {\n-\tpub fn new() -> Self {\n-\t\tSelf(BLOCK_ID_COUNTER.fetch_add(1, Ordering::SeqCst))\n-\t}\n-\n-\t/// TODO temp\n-\tpub fn unwrap_counter(&self) -> u16 {\n-\t\tself.0\n-\t}\n-}\n-\n #[derive(Debug, Clone, PartialEq, Visitable)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum StatementOrDeclaration {\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -72,7 +40,7 @@ impl ASTNode for StatementOrDeclaration {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tif Declaration::is_declaration_start(reader) {\n \t\t\tlet dec = Declaration::from_reader(reader, state, settings)?;\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -87,7 +55,7 @@ impl ASTNode for StatementOrDeclaration {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -104,7 +72,7 @@ impl ASTNode for StatementOrDeclaration {\n /// A \"block\" of braced statements and declarations\n #[derive(Debug, Clone)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n-pub struct Block(pub Vec<StatementOrDeclaration>, pub BlockId, pub Span);\n+pub struct Block(pub Vec<StatementOrDeclaration>, pub Span);\n \n impl Eq for Block {}\n \ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -115,24 +83,22 @@ impl PartialEq for Block {\n }\n \n pub struct BlockLike<'a> {\n-\tpub block_id: BlockId,\n \tpub items: &'a Vec<StatementOrDeclaration>,\n }\n \n pub struct BlockLikeMut<'a> {\n-\tpub block_id: BlockId,\n \tpub items: &'a mut Vec<StatementOrDeclaration>,\n }\n \n impl<'a> From<&'a Block> for BlockLike<'a> {\n \tfn from(block: &'a Block) -> Self {\n-\t\tBlockLike { block_id: block.1, items: &block.0 }\n+\t\tBlockLike { items: &block.0 }\n \t}\n }\n \n impl<'a> From<&'a mut Block> for BlockLikeMut<'a> {\n \tfn from(block: &'a mut Block) -> Self {\n-\t\tBlockLikeMut { block_id: block.1, items: &mut block.0 }\n+\t\tBlockLikeMut { items: &mut block.0 }\n \t}\n }\n \ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -140,18 +106,18 @@ impl ASTNode for Block {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet start_span = reader.expect_next(TSXToken::OpenBrace)?;\n-\t\tlet (items, block_id) = parse_statements_and_declarations(reader, state, settings)?;\n+\t\tlet items = parse_statements_and_declarations(reader, state, settings)?;\n \t\tlet end_span = reader.expect_next(TSXToken::CloseBrace)?;\n-\t\tOk(Self(items, block_id, start_span.union(&end_span)))\n+\t\tOk(Self(items, start_span.union(&end_span)))\n \t}\n \n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push('{');\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -169,7 +135,7 @@ impl ASTNode for Block {\n \t}\n \n \tfn get_position(&self) -> Cow<Span> {\n-\t\tCow::Borrowed(&self.2)\n+\t\tCow::Borrowed(&self.1)\n \t}\n }\n \ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -193,11 +159,7 @@ impl Visitable for Block {\n \t\tchain: &mut temporary_annex::Annex<crate::visiting::Chain>,\n \t) {\n \t\t{\n-\t\t\tvisitors.visit_block(\n-\t\t\t\t&crate::block::BlockLike { block_id: self.1, items: &self.0 },\n-\t\t\t\tdata,\n-\t\t\t\tchain,\n-\t\t\t);\n+\t\t\tvisitors.visit_block(&crate::block::BlockLike { items: &self.0 }, data, chain);\n \t\t}\n \t\tlet iter = self.iter();\n \t\tif settings.reverse_statements {\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -217,7 +179,7 @@ impl Visitable for Block {\n \t) {\n \t\t{\n \t\t\tvisitors.visit_block_mut(\n-\t\t\t\t&mut crate::block::BlockLikeMut { block_id: self.1, items: &mut self.0 },\n+\t\t\t\t&mut crate::block::BlockLikeMut { items: &mut self.0 },\n \t\t\t\tdata,\n \t\t\t\tchain,\n \t\t\t);\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -258,18 +220,24 @@ impl ASTNode for BlockOrSingleStatement {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n-\t\tStatement::from_reader(reader, state, settings).map(|stmt| match stmt {\n+\t\tlet stmt = Statement::from_reader(reader, state, settings)?;\n+\t\tOk(match stmt {\n \t\t\tStatement::Block(blk) => Self::Braced(blk),\n-\t\t\tstmt => Box::new(stmt).into(),\n+\t\t\tstmt => {\n+\t\t\t\tif stmt.requires_semi_colon() {\n+\t\t\t\t\texpect_semi_colon(reader, &state.line_starts, stmt.get_position().start)?;\n+\t\t\t\t}\n+\t\t\t\tBox::new(stmt).into()\n+\t\t\t}\n \t\t})\n \t}\n \n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -282,9 +250,7 @@ impl ASTNode for BlockOrSingleStatement {\n \t\t\t\t\tsettings.add_gap(buf);\n \t\t\t\t\tstmt.to_string_from_buffer(buf, settings, depth);\n \t\t\t\t} else {\n-\t\t\t\t\tbuf.push('{');\n \t\t\t\t\tstmt.to_string_from_buffer(buf, settings, depth);\n-\t\t\t\t\tbuf.push('}');\n \t\t\t\t}\n \t\t\t}\n \t\t}\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -295,10 +261,9 @@ impl ASTNode for BlockOrSingleStatement {\n pub(crate) fn parse_statements_and_declarations(\n \treader: &mut impl TokenReader<TSXToken, Span>,\n \tstate: &mut crate::ParsingState,\n-\tsettings: &ParseSettings,\n-) -> ParseResult<(Vec<StatementOrDeclaration>, BlockId)> {\n+\tsettings: &ParseOptions,\n+) -> ParseResult<Vec<StatementOrDeclaration>> {\n \tlet mut items = Vec::new();\n-\tlet block_id = BlockId::new();\n \twhile let Some(Token(token_type, _)) = reader.peek() {\n \t\tif let TSXToken::EOS | TSXToken::CloseBrace = token_type {\n \t\t\tbreak;\ndiff --git a/parser/src/block.rs b/parser/src/block.rs\n--- a/parser/src/block.rs\n+++ b/parser/src/block.rs\n@@ -306,17 +271,17 @@ pub(crate) fn parse_statements_and_declarations(\n \n \t\tlet value = StatementOrDeclaration::from_reader(reader, state, settings)?;\n \t\tif value.requires_semi_colon() {\n-\t\t\texpect_semi_colon(reader)?;\n+\t\t\texpect_semi_colon(reader, &state.line_starts, value.get_position().end)?;\n \t\t}\n \t\titems.push(value);\n \t}\n-\tOk((items, block_id))\n+\tOk(items)\n }\n \n pub fn statements_and_declarations_to_string<T: source_map::ToString>(\n \titems: &[StatementOrDeclaration],\n \tbuf: &mut T,\n-\tsettings: &crate::ToStringSettings,\n+\tsettings: &crate::ToStringOptions,\n \tdepth: u8,\n ) {\n \tfor (at_end, item) in items.iter().endiate() {\ndiff --git a/parser/src/comments.rs b/parser/src/comments.rs\n--- a/parser/src/comments.rs\n+++ b/parser/src/comments.rs\n@@ -1,7 +1,7 @@\n //! Contains wrappers for AST with comments\n \n use super::{ASTNode, ParseError, Span, TSXToken, TokenReader};\n-use crate::ParseSettings;\n+use crate::ParseOptions;\n use std::{borrow::Cow, mem};\n use tokenizer_lib::Token;\n \ndiff --git a/parser/src/comments.rs b/parser/src/comments.rs\n--- a/parser/src/comments.rs\n+++ b/parser/src/comments.rs\n@@ -102,7 +102,7 @@ impl<T: ASTNode> ASTNode for WithComment<T> {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> Result<WithComment<T>, ParseError> {\n \t\tif matches!(reader.peek(), Some(Token(TSXToken::MultiLineComment(..), _))) {\n \t\t\tlet comment = if let TSXToken::MultiLineComment(comment) = reader.next().unwrap().0 {\ndiff --git a/parser/src/comments.rs b/parser/src/comments.rs\n--- a/parser/src/comments.rs\n+++ b/parser/src/comments.rs\n@@ -139,7 +139,7 @@ impl<T: ASTNode> ASTNode for WithComment<T> {\n \tfn to_string_from_buffer<U: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut U,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -5,9 +5,9 @@ use source_map::Span;\n use tokenizer_lib::{Token, TokenReader};\n \n use crate::{\n-\tfunctions::FunctionBased, ASTNode, Block, ChainVariable, Expression, FunctionBase,\n-\tGetSetGeneratorOrNone, Keyword, ParseError, ParseErrors, ParseResult, ParseSettings,\n-\tPropertyKey, TSXKeyword, TSXToken, TypeReference, VariableId, VisitSettings, WithComment,\n+\tfunctions::FunctionBased, ASTNode, Block, Expression, FunctionBase, GetSetGeneratorOrNone,\n+\tKeyword, ParseError, ParseErrors, ParseOptions, ParseResult, PropertyKey, TSXKeyword, TSXToken,\n+\tTypeAnnotation, VisitSettings, WithComment,\n };\n \n /// The variable id's of these is handled by their [PropertyKey]\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -29,7 +29,7 @@ pub type ClassFunction = FunctionBase<ClassFunctionBase>;\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ClassProperty {\n \tpub key: WithComment<PropertyKey>,\n-\tpub type_reference: Option<TypeReference>,\n+\tpub type_annotation: Option<TypeAnnotation>,\n \tpub value: Option<Box<Expression>>,\n }\n \ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -46,7 +46,7 @@ impl ASTNode for ClassMember {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tif let Some(Token(TSXToken::Keyword(TSXKeyword::Constructor), _)) = reader.peek() {\n \t\t\tlet constructor = ClassConstructor::from_reader(reader, state, settings)?;\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -86,11 +86,11 @@ impl ASTNode for ClassMember {\n \t\t\t\t\t\tposition,\n \t\t\t\t\t));\n \t\t\t\t}\n-\t\t\t\tlet member_type: Option<TypeReference> = match token {\n+\t\t\t\tlet member_type: Option<TypeAnnotation> = match token {\n \t\t\t\t\tTSXToken::Colon => {\n \t\t\t\t\t\treader.next();\n-\t\t\t\t\t\tlet type_reference = TypeReference::from_reader(reader, state, settings)?;\n-\t\t\t\t\t\tSome(type_reference)\n+\t\t\t\t\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\tSome(type_annotation)\n \t\t\t\t\t}\n \t\t\t\t\t_ => None,\n \t\t\t\t};\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -106,7 +106,7 @@ impl ASTNode for ClassMember {\n \t\t\t\t\tis_static,\n \t\t\t\t\tClassProperty {\n \t\t\t\t\t\tkey,\n-\t\t\t\t\t\ttype_reference: member_type,\n+\t\t\t\t\t\ttype_annotation: member_type,\n \t\t\t\t\t\tvalue: member_expression.map(Box::new),\n \t\t\t\t\t},\n \t\t\t\t))\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -117,18 +117,18 @@ impl ASTNode for ClassMember {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\n-\t\t\tSelf::Property(is_static, ClassProperty { key, type_reference, value }) => {\n+\t\t\tSelf::Property(is_static, ClassProperty { key, type_annotation, value }) => {\n \t\t\t\tif is_static.is_some() {\n \t\t\t\t\tbuf.push_str(\"static \");\n \t\t\t\t}\n \t\t\t\tkey.to_string_from_buffer(buf, settings, depth);\n-\t\t\t\tif let (true, Some(type_reference)) = (settings.include_types, type_reference) {\n+\t\t\t\tif let (true, Some(type_annotation)) = (settings.include_types, type_annotation) {\n \t\t\t\t\tbuf.push_str(\": \");\n-\t\t\t\t\ttype_reference.to_string_from_buffer(buf, settings, depth);\n+\t\t\t\t\ttype_annotation.to_string_from_buffer(buf, settings, depth);\n \t\t\t\t}\n \t\t\t\tif let Some(value) = value {\n \t\t\t\t\tbuf.push_str(if settings.pretty { \" = \" } else { \"=\" });\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -166,8 +166,6 @@ impl ClassMember {\n \t\tdata: &mut TData,\n \t\tsettings: &VisitSettings,\n \t\tchain: &mut temporary_annex::Annex<crate::visiting::Chain>,\n-\t\t// TODO VariableId and TypeId\n-\t\tclass_variable_id: VariableId,\n \t) {\n \t\tmatch self {\n \t\t\tClassMember::Constructor(..) => {\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -212,8 +210,6 @@ impl ClassMember {\n \t\tdata: &mut TData,\n \t\tsettings: &VisitSettings,\n \t\tchain: &mut temporary_annex::Annex<crate::visiting::Chain>,\n-\t\t// TODO remove\n-\t\tclass_variable_id: VariableId,\n \t) {\n \t\tmatch self {\n \t\t\tClassMember::Constructor(..) => {\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -264,7 +260,7 @@ impl ClassFunction {\n \tfn from_reader_with_config(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\tis_async: Option<Keyword<tsx_keywords::Async>>,\n \t\tget_set_generator_or_none: GetSetGeneratorOrNone,\n \t\tkey: WithComment<PropertyKey>,\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -284,14 +280,14 @@ impl FunctionBased for ClassFunctionBase {\n \ttype Header = (Option<Keyword<tsx_keywords::Async>>, GetSetGeneratorOrNone);\n \ttype Name = WithComment<PropertyKey>;\n \n-\tfn get_chain_variable(this: &FunctionBase<Self>) -> ChainVariable {\n-\t\tChainVariable::UnderClassMethod(this.body.1)\n-\t}\n+\t// fn get_chain_variable(this: &FunctionBase<Self>) -> ChainVariable {\n+\t// \tChainVariable::UnderClassMethod(this.body.1)\n+\t// }\n \n \tfn header_and_name_from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<(Self::Header, Self::Name)> {\n \t\tlet async_keyword = reader\n \t\t\t.conditional_next(|tok| matches!(tok, TSXToken::Keyword(TSXKeyword::Async)))\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -305,7 +301,7 @@ impl FunctionBased for ClassFunctionBase {\n \t\tbuf: &mut T,\n \t\theader: &Self::Header,\n \t\tname: &Self::Name,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tif let Some(_header) = &header.0 {\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -325,14 +321,14 @@ impl FunctionBased for ClassConstructorBase {\n \ttype Header = Keyword<tsx_keywords::Constructor>;\n \ttype Name = ();\n \n-\tfn get_chain_variable(this: &FunctionBase<Self>) -> ChainVariable {\n-\t\tChainVariable::UnderClassConstructor(this.body.1)\n-\t}\n+\t// fn get_chain_variable(this: &FunctionBase<Self>) -> ChainVariable {\n+\t// \tChainVariable::UnderClassConstructor(this.body.1)\n+\t// }\n \n \tfn header_and_name_from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\t_state: &mut crate::ParsingState,\n-\t\t_settings: &ParseSettings,\n+\t\t_settings: &ParseOptions,\n \t) -> ParseResult<(Self::Header, Self::Name)> {\n \t\tlet span = reader.expect_next(TSXToken::Keyword(TSXKeyword::Constructor))?;\n \t\tOk((Keyword::new(span), ()))\ndiff --git a/parser/src/declarations/classes/class_member.rs b/parser/src/declarations/classes/class_member.rs\n--- a/parser/src/declarations/classes/class_member.rs\n+++ b/parser/src/declarations/classes/class_member.rs\n@@ -342,7 +338,7 @@ impl FunctionBased for ClassConstructorBase {\n \t\tbuf: &mut T,\n \t\t_header: &Self::Header,\n \t\t_name: &Self::Name,\n-\t\t_settings: &crate::ToStringSettings,\n+\t\t_settings: &crate::ToStringOptions,\n \t\t_depth: u8,\n \t) {\n \t\tbuf.push_str(\"constructor\")\ndiff --git a/parser/src/declarations/classes/mod.rs b/parser/src/declarations/classes/mod.rs\n--- a/parser/src/declarations/classes/mod.rs\n+++ b/parser/src/declarations/classes/mod.rs\n@@ -8,8 +8,8 @@ use iterator_endiate::EndiateIteratorExt;\n \n use crate::{\n \textensions::decorators::Decorated, visiting::Visitable, ASTNode, ExpressionOrStatementPosition,\n-\tGenericTypeConstraint, Keyword, ParseResult, ParseSettings, Span, TSXKeyword, TSXToken, TypeId,\n-\tTypeReference, VariableId, VisitSettings,\n+\tGenericTypeConstraint, Keyword, ParseOptions, ParseResult, Span, TSXKeyword, TSXToken,\n+\tTypeAnnotation, VisitSettings,\n };\n use tokenizer_lib::{Token, TokenReader};\n \ndiff --git a/parser/src/declarations/classes/mod.rs b/parser/src/declarations/classes/mod.rs\n--- a/parser/src/declarations/classes/mod.rs\n+++ b/parser/src/declarations/classes/mod.rs\n@@ -19,12 +19,8 @@ pub struct ClassDeclaration<T: ExpressionOrStatementPosition> {\n \tpub name: T::Name,\n \tpub type_parameters: Option<Vec<GenericTypeConstraint>>,\n \t/// TODO shouldn't be type reference\n-\tpub extends: Option<TypeReference>,\n+\tpub extends: Option<TypeAnnotation>,\n \tpub members: Vec<Decorated<ClassMember>>,\n-\t/// The [TypeId] is the type of the instance the class defines\n-\tpub type_id: TypeId,\n-\t/// The [VariableId] is for `SomeClass.constructor` and possible static properties etc\n-\tpub variable_id: VariableId,\n \tpub position: Span,\n }\n \ndiff --git a/parser/src/declarations/classes/mod.rs b/parser/src/declarations/classes/mod.rs\n--- a/parser/src/declarations/classes/mod.rs\n+++ b/parser/src/declarations/classes/mod.rs\n@@ -46,7 +42,7 @@ impl<U: ExpressionOrStatementPosition + Debug + PartialEq + Eq + Clone + 'static\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet class_keyword_pos = reader.expect_next(TSXToken::Keyword(TSXKeyword::Class))?;\n \t\tlet class_keyword = Keyword::new(class_keyword_pos);\ndiff --git a/parser/src/declarations/classes/mod.rs b/parser/src/declarations/classes/mod.rs\n--- a/parser/src/declarations/classes/mod.rs\n+++ b/parser/src/declarations/classes/mod.rs\n@@ -56,7 +52,7 @@ impl<U: ExpressionOrStatementPosition + Debug + PartialEq + Eq + Clone + 'static\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tself.to_string_from_buffer(buf, settings, depth)\ndiff --git a/parser/src/declarations/classes/mod.rs b/parser/src/declarations/classes/mod.rs\n--- a/parser/src/declarations/classes/mod.rs\n+++ b/parser/src/declarations/classes/mod.rs\n@@ -71,14 +67,23 @@ impl<U: ExpressionOrStatementPosition> ClassDeclaration<U> {\n \tpub(crate) fn from_reader_sub_class_keyword(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\tclass_keyword: Keyword<tsx_keywords::Class>,\n \t) -> ParseResult<Self> {\n-\t\tlet (name, type_parameters) = U::from_reader(reader, state, settings)?;\n+\t\tlet name = U::from_reader(reader, state, settings)?;\n+\t\tlet type_parameters = reader\n+\t\t\t.conditional_next(|token| *token == TSXToken::OpenChevron)\n+\t\t\t.is_some()\n+\t\t\t.then(|| {\n+\t\t\t\tcrate::parse_bracketed(reader, state, settings, None, TSXToken::CloseChevron)\n+\t\t\t\t\t.map(|(params, _)| params)\n+\t\t\t})\n+\t\t\t.transpose()?;\n+\n \t\tlet extends = match reader.peek() {\n \t\t\tSome(Token(TSXToken::Keyword(TSXKeyword::Extends), _)) => {\n \t\t\t\treader.next();\n-\t\t\t\tSome(TypeReference::from_reader(reader, state, settings)?)\n+\t\t\t\tSome(TypeAnnotation::from_reader(reader, state, settings)?)\n \t\t\t}\n \t\t\t_ => None,\n \t\t};\ndiff --git a/parser/src/declarations/classes/mod.rs b/parser/src/declarations/classes/mod.rs\n--- a/parser/src/declarations/classes/mod.rs\n+++ b/parser/src/declarations/classes/mod.rs\n@@ -96,22 +101,13 @@ impl<U: ExpressionOrStatementPosition> ClassDeclaration<U> {\n \t\t\t}\n \t\t}\n \t\tlet position = class_keyword.1.union(&reader.expect_next(TSXToken::CloseBrace)?);\n-\t\tOk(ClassDeclaration {\n-\t\t\tclass_keyword,\n-\t\t\tname,\n-\t\t\ttype_id: TypeId::new(),\n-\t\t\tvariable_id: VariableId::new(),\n-\t\t\textends,\n-\t\t\tmembers,\n-\t\t\ttype_parameters,\n-\t\t\tposition,\n-\t\t})\n+\t\tOk(ClassDeclaration { class_keyword, name, extends, members, type_parameters, position })\n \t}\n \n \tpub(crate) fn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(\"class \");\ndiff --git a/parser/src/declarations/classes/mod.rs b/parser/src/declarations/classes/mod.rs\n--- a/parser/src/declarations/classes/mod.rs\n+++ b/parser/src/declarations/classes/mod.rs\n@@ -140,10 +136,6 @@ impl<U: ExpressionOrStatementPosition> ClassDeclaration<U> {\n \t\t}\n \t\tbuf.push('}');\n \t}\n-\n-\tpub fn get_variable_id(&self) -> VariableId {\n-\t\tself.variable_id\n-\t}\n }\n \n impl<T: ExpressionOrStatementPosition> Visitable for ClassDeclaration<T> {\ndiff --git a/parser/src/declarations/export.rs b/parser/src/declarations/export.rs\n--- a/parser/src/declarations/export.rs\n+++ b/parser/src/declarations/export.rs\n@@ -1,7 +1,7 @@\n use std::borrow::Cow;\n \n use crate::{\n-\terrors::parse_lexing_error, ASTNode, Expression, Keyword, ParseResult, ParseSettings, Span,\n+\terrors::parse_lexing_error, ASTNode, Expression, Keyword, ParseOptions, ParseResult, Span,\n \tStatementPosition, TSXKeyword, TSXToken, Token,\n };\n \ndiff --git a/parser/src/declarations/export.rs b/parser/src/declarations/export.rs\n--- a/parser/src/declarations/export.rs\n+++ b/parser/src/declarations/export.rs\n@@ -45,7 +45,7 @@ impl ASTNode for ExportDeclaration {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet start = reader.expect_next(TSXToken::Keyword(TSXKeyword::Export))?;\n \t\tlet is_default =\ndiff --git a/parser/src/declarations/export.rs b/parser/src/declarations/export.rs\n--- a/parser/src/declarations/export.rs\n+++ b/parser/src/declarations/export.rs\n@@ -111,7 +111,7 @@ impl ASTNode for ExportDeclaration {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/declarations/import.rs b/parser/src/declarations/import.rs\n--- a/parser/src/declarations/import.rs\n+++ b/parser/src/declarations/import.rs\n@@ -10,7 +10,7 @@ use tokenizer_lib::{Token, TokenReader};\n \n use crate::{\n \terrors::parse_lexing_error, parse_bracketed, tokens::token_as_identifier, ASTNode, ParseError,\n-\tParseErrors, ParseResult, ParseSettings, TSXKeyword, TSXToken, VariableId, VariableIdentifier,\n+\tParseErrors, ParseOptions, ParseResult, TSXKeyword, TSXToken, VariableIdentifier,\n };\n use visitable_derive::Visitable;\n \ndiff --git a/parser/src/declarations/import.rs b/parser/src/declarations/import.rs\n--- a/parser/src/declarations/import.rs\n+++ b/parser/src/declarations/import.rs\n@@ -52,7 +52,7 @@ impl ASTNode for ImportDeclaration {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet start_position = reader.expect_next(TSXToken::Keyword(TSXKeyword::Import))?;\n \t\tlet only_type: bool =\ndiff --git a/parser/src/declarations/import.rs b/parser/src/declarations/import.rs\n--- a/parser/src/declarations/import.rs\n+++ b/parser/src/declarations/import.rs\n@@ -131,7 +131,7 @@ impl ASTNode for ImportDeclaration {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\t_settings: &crate::ToStringSettings,\n+\t\t_settings: &crate::ToStringOptions,\n \t\t_depth: u8,\n \t) {\n \t\tbuf.push_str(\"import \");\ndiff --git a/parser/src/declarations/import.rs b/parser/src/declarations/import.rs\n--- a/parser/src/declarations/import.rs\n+++ b/parser/src/declarations/import.rs\n@@ -173,7 +173,7 @@ impl ASTNode for ImportDeclaration {\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum ImportPart {\n \tName(VariableIdentifier),\n-\tNameWithAlias { name: String, alias: String, variable_id: VariableId, position: Span },\n+\tNameWithAlias { name: String, alias: String, position: Span },\n }\n \n impl ASTNode for ImportPart {\ndiff --git a/parser/src/declarations/import.rs b/parser/src/declarations/import.rs\n--- a/parser/src/declarations/import.rs\n+++ b/parser/src/declarations/import.rs\n@@ -187,7 +187,7 @@ impl ASTNode for ImportPart {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\t_state: &mut crate::ParsingState,\n-\t\t_settings: &ParseSettings,\n+\t\t_settings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet (name, pos) =\n \t\t\ttoken_as_identifier(reader.next().ok_or_else(parse_lexing_error)?, \"imported name\")?;\ndiff --git a/parser/src/declarations/import.rs b/parser/src/declarations/import.rs\n--- a/parser/src/declarations/import.rs\n+++ b/parser/src/declarations/import.rs\n@@ -196,16 +196,16 @@ impl ASTNode for ImportPart {\n \t\t\tlet (alias, alias_pos) =\n \t\t\t\ttoken_as_identifier(reader.next().ok_or_else(parse_lexing_error)?, \"import alias\")?;\n \t\t\tlet position = pos.union(&alias_pos);\n-\t\t\tOk(Self::NameWithAlias { name, alias, position, variable_id: VariableId::new() })\n+\t\t\tOk(Self::NameWithAlias { name, alias, position })\n \t\t} else {\n-\t\t\tOk(Self::Name(VariableIdentifier::Standard(name, VariableId::new(), pos)))\n+\t\t\tOk(Self::Name(VariableIdentifier::Standard(name, pos)))\n \t\t}\n \t}\n \n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\t_settings: &crate::ToStringSettings,\n+\t\t_settings: &crate::ToStringOptions,\n \t\t_depth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/declarations/mod.rs b/parser/src/declarations/mod.rs\n--- a/parser/src/declarations/mod.rs\n+++ b/parser/src/declarations/mod.rs\n@@ -63,7 +63,8 @@ impl Declaration {\n \t\t\t\t\t\t| TSXKeyword::Class | TSXKeyword::Enum\n \t\t\t\t\t\t| TSXKeyword::Type | TSXKeyword::Declare\n \t\t\t\t\t\t| TSXKeyword::Import | TSXKeyword::Export\n-\t\t\t\t\t\t| TSXKeyword::Async | TSXKeyword::Generator\n+\t\t\t\t\t\t| TSXKeyword::Interface | TSXKeyword::Async\n+\t\t\t\t\t\t| TSXKeyword::Generator\n \t\t\t\t) | TSXToken::At,\n \t\t\t\t_\n \t\t\t))\ndiff --git a/parser/src/declarations/mod.rs b/parser/src/declarations/mod.rs\n--- a/parser/src/declarations/mod.rs\n+++ b/parser/src/declarations/mod.rs\n@@ -91,7 +92,7 @@ impl crate::ASTNode for Declaration {\n \tfn from_reader(\n \t\treader: &mut impl tokenizer_lib::TokenReader<crate::TSXToken, source_map::Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t) -> crate::ParseResult<Self> {\n \t\t// TODO assert decorators are used. If they exist but item is not `Decorated`\n \t\t// then need to throw a parse error\ndiff --git a/parser/src/declarations/mod.rs b/parser/src/declarations/mod.rs\n--- a/parser/src/declarations/mod.rs\n+++ b/parser/src/declarations/mod.rs\n@@ -208,7 +209,7 @@ impl crate::ASTNode for Declaration {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -4,7 +4,7 @@ use iterator_endiate::EndiateIteratorExt;\n \n use crate::{\n \terrors::parse_lexing_error, tsx_keywords, ASTNode, Expression, Keyword, ParseError,\n-\tParseResult, ParseSettings, Span, TSXKeyword, TSXToken, Token, TokenReader, TypeReference,\n+\tParseOptions, ParseResult, Span, TSXKeyword, TSXToken, Token, TokenReader, TypeAnnotation,\n \tVariableField, VariableFieldInSourceCode, WithComment,\n };\n use visitable_derive::Visitable;\ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -16,26 +16,28 @@ pub trait DeclarationExpression:\n \tfn decl_from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self>;\n \n \tfn decl_to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t);\n \n \tfn get_decl_position(&self) -> Option<Cow<Span>>;\n \n-\tfn as_option_mut_expr(&mut self) -> Option<&mut Expression>;\n+\tfn as_option_expr_ref(&self) -> Option<&Expression>;\n+\n+\tfn as_option_expr_mut(&mut self) -> Option<&mut Expression>;\n }\n \n impl DeclarationExpression for Option<Expression> {\n \tfn decl_from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tif let Some(Token(TSXToken::Assign, _)) = reader.peek() {\n \t\t\treader.next();\ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -49,7 +51,7 @@ impl DeclarationExpression for Option<Expression> {\n \tfn decl_to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tif let Some(expr) = self {\ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -62,7 +64,11 @@ impl DeclarationExpression for Option<Expression> {\n \t\tself.as_ref().map(|expr| expr.get_position())\n \t}\n \n-\tfn as_option_mut_expr(&mut self) -> Option<&mut Expression> {\n+\tfn as_option_expr_ref(&self) -> Option<&Expression> {\n+\t\tself.as_ref()\n+\t}\n+\n+\tfn as_option_expr_mut(&mut self) -> Option<&mut Expression> {\n \t\tself.as_mut()\n \t}\n }\ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -71,7 +77,7 @@ impl DeclarationExpression for crate::Expression {\n \tfn decl_from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\treader.expect_next(TSXToken::Assign)?;\n \t\tExpression::from_reader(reader, state, settings)\ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -80,7 +86,7 @@ impl DeclarationExpression for crate::Expression {\n \tfn decl_to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(if settings.pretty { \" = \" } else { \"=\" });\ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -91,7 +97,11 @@ impl DeclarationExpression for crate::Expression {\n \t\tSome(ASTNode::get_position(self))\n \t}\n \n-\tfn as_option_mut_expr(&mut self) -> Option<&mut Expression> {\n+\tfn as_option_expr_ref(&self) -> Option<&Expression> {\n+\t\tSome(self)\n+\t}\n+\n+\tfn as_option_expr_mut(&mut self) -> Option<&mut Expression> {\n \t\tSome(self)\n \t}\n }\ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -101,7 +111,7 @@ impl DeclarationExpression for crate::Expression {\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub struct VariableDeclarationItem<TExpr: DeclarationExpression> {\n \tpub name: WithComment<VariableField<VariableFieldInSourceCode>>,\n-\tpub type_reference: Option<TypeReference>,\n+\tpub type_annotation: Option<TypeAnnotation>,\n \tpub expression: TExpr,\n }\n \ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -110,7 +120,7 @@ impl<TExpr: DeclarationExpression + 'static> ASTNode for VariableDeclarationItem\n \t\tlet name_position = self.name.get_position();\n \t\tif let Some(expr_pos) = TExpr::get_decl_position(&self.expression) {\n \t\t\tCow::Owned(name_position.union(&expr_pos))\n-\t\t} else if let Some(ref ty_ref) = self.type_reference {\n+\t\t} else if let Some(ref ty_ref) = self.type_annotation {\n \t\t\tCow::Owned(name_position.union(&ty_ref.get_position()))\n \t\t} else {\n \t\t\tname_position\ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -120,32 +130,32 @@ impl<TExpr: DeclarationExpression + 'static> ASTNode for VariableDeclarationItem\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet name = WithComment::<VariableField<VariableFieldInSourceCode>>::from_reader(\n \t\t\treader, state, settings,\n \t\t)?;\n-\t\tlet type_reference = if let Some(Token(TSXToken::Colon, _)) = reader.peek() {\n+\t\tlet type_annotation = if let Some(Token(TSXToken::Colon, _)) = reader.peek() {\n \t\t\treader.next();\n-\t\t\tlet type_reference = TypeReference::from_reader(reader, state, settings)?;\n-\t\t\tSome(type_reference)\n+\t\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n+\t\t\tSome(type_annotation)\n \t\t} else {\n \t\t\tNone\n \t\t};\n \t\tlet expression = TExpr::decl_from_reader(reader, state, settings)?;\n-\t\tOk(Self { name, type_reference, expression })\n+\t\tOk(Self { name, type_annotation, expression })\n \t}\n \n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tself.name.to_string_from_buffer(buf, settings, depth);\n-\t\tif let (true, Some(type_reference)) = (settings.include_types, &self.type_reference) {\n+\t\tif let (true, Some(type_annotation)) = (settings.include_types, &self.type_annotation) {\n \t\t\tbuf.push_str(\": \");\n-\t\t\ttype_reference.to_string_from_buffer(buf, settings, depth);\n+\t\t\ttype_annotation.to_string_from_buffer(buf, settings, depth);\n \t\t}\n \t\tself.expression.decl_to_string_from_buffer(buf, settings, depth);\n \t}\ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -213,7 +223,7 @@ impl ASTNode for VariableDeclaration {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet kind =\n \t\t\tVariableDeclarationKeyword::from_reader(reader.next().ok_or_else(parse_lexing_error)?)?;\ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -254,7 +264,7 @@ impl ASTNode for VariableDeclaration {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/declarations/variable.rs b/parser/src/declarations/variable.rs\n--- a/parser/src/declarations/variable.rs\n+++ b/parser/src/declarations/variable.rs\n@@ -293,7 +303,7 @@ pub(crate) fn declarations_to_string<\n >(\n \tdeclarations: &[VariableDeclarationItem<U>],\n \tbuf: &mut T,\n-\tsettings: &crate::ToStringSettings,\n+\tsettings: &crate::ToStringOptions,\n \tdepth: u8,\n ) {\n \tfor (at_end, declaration) in declarations.iter().endiate() {\ndiff --git a/parser/src/errors.rs b/parser/src/errors.rs\n--- a/parser/src/errors.rs\n+++ b/parser/src/errors.rs\n@@ -14,7 +14,6 @@ pub enum ParseErrors<'a> {\n \tTypeArgumentsNotValidOnReference,\n \tUnmatchedBrackets,\n \tFunctionParameterOptionalAndDefaultValue,\n-\tNonOptionalFunctionParameterAfterOptionalFunctionParameter,\n \tExpectedIdent { found: TSXToken, at_location: &'a str },\n \tParameterCannotHaveDefaultValueHere,\n \tInvalidLHSAssignment,\ndiff --git a/parser/src/errors.rs b/parser/src/errors.rs\n--- a/parser/src/errors.rs\n+++ b/parser/src/errors.rs\n@@ -123,9 +122,6 @@ impl<'a> Display for ParseErrors<'a> {\n \t\t\tParseErrors::FunctionParameterOptionalAndDefaultValue => {\n \t\t\t\tf.write_str(\"Function parameter cannot be optional *and* have default expression\")\n \t\t\t}\n-\t\t\tParseErrors::NonOptionalFunctionParameterAfterOptionalFunctionParameter => {\n-\t\t\t\tf.write_str(\"Function parameter cannot be non optional after optional\")\n-\t\t\t}\n \t\t\tParseErrors::ExpectedIdent { found, at_location } => {\n \t\t\t\twrite!(f, \"Expected identifier at {at_location}, found {found:?}\")\n \t\t\t}\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -5,9 +5,9 @@ use visitable_derive::Visitable;\n \n use crate::{\n \terrors::parse_lexing_error, functions::FunctionBased, parameters::FunctionParameters,\n-\ttokens::token_as_identifier, ASTNode, Block, BlockId, ChainVariable, Expression, FunctionBase,\n-\tFunctionId, Keyword, Parameter, ParseResult, ParseSettings, Span, TSXKeyword, TSXToken, Token,\n-\tTokenReader, TypeReference, VariableField, VariableId, WithComment,\n+\ttokens::token_as_identifier, ASTNode, Block, Expression, FunctionBase, FunctionId, Keyword,\n+\tParameter, ParseOptions, ParseResult, Span, TSXKeyword, TSXToken, Token, TokenReader,\n+\tTypeAnnotation, VariableField, WithComment,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -20,14 +20,14 @@ impl FunctionBased for ArrowFunctionBase {\n \ttype Header = Option<Keyword<tsx_keywords::Async>>;\n \ttype Name = ();\n \n-\tfn get_chain_variable(this: &FunctionBase<Self>) -> ChainVariable {\n-\t\tChainVariable::UnderArrowFunction(this.body.get_block_id())\n-\t}\n+\t// fn get_chain_variable(this: &FunctionBase<Self>) -> ChainVariable {\n+\t// \tChainVariable::UnderArrowFunction(this.body.get_block_id())\n+\t// }\n \n \tfn header_and_name_from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\t_state: &mut crate::ParsingState,\n-\t\t_settings: &ParseSettings,\n+\t\t_settings: &ParseOptions,\n \t) -> ParseResult<(Self::Header, Self::Name)> {\n \t\tlet is_async = if let Some(Token(TSXToken::Keyword(TSXKeyword::Async), _)) = reader.peek() {\n \t\t\tlet Token(_, pos) = reader.next().unwrap();\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -42,7 +42,7 @@ impl FunctionBased for ArrowFunctionBase {\n \t\tbuf: &mut T,\n \t\tis_async: &Self::Header,\n \t\t_name: &Self::Name,\n-\t\t_settings: &crate::ToStringSettings,\n+\t\t_settings: &crate::ToStringOptions,\n \t\t_depth: u8,\n \t) {\n \t\tif is_async.is_some() {\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -53,7 +53,7 @@ impl FunctionBased for ArrowFunctionBase {\n \tfn parameters_from_reader<T: source_map::ToString>(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<FunctionParameters> {\n \t\tmatch reader.next().ok_or_else(parse_lexing_error)? {\n \t\t\tToken(TSXToken::OpenParentheses, open_paren) => {\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -66,17 +66,12 @@ impl FunctionBased for ArrowFunctionBase {\n \t\t\t\tlet (name, position) = token_as_identifier(token, \"arrow function parameter\")?;\n \t\t\t\tlet parameters = vec![Parameter {\n \t\t\t\t\tname: WithComment::None(\n-\t\t\t\t\t\tVariableIdentifier::Standard(name, VariableId::new(), position.clone())\n-\t\t\t\t\t\t\t.into(),\n+\t\t\t\t\t\tVariableIdentifier::Standard(name, position.clone()).into(),\n \t\t\t\t\t),\n-\t\t\t\t\ttype_reference: None,\n+\t\t\t\t\ttype_annotation: None,\n+\t\t\t\t\tadditionally: None,\n \t\t\t\t}];\n-\t\t\t\tOk(FunctionParameters {\n-\t\t\t\t\tparameters,\n-\t\t\t\t\toptional_parameters: Vec::new(),\n-\t\t\t\t\trest_parameter: None,\n-\t\t\t\t\tposition,\n-\t\t\t\t})\n+\t\t\t\tOk(FunctionParameters { parameters, rest_parameter: None, position })\n \t\t\t}\n \t\t}\n \t}\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -84,14 +79,13 @@ impl FunctionBased for ArrowFunctionBase {\n \tfn parameters_to_string_from_buffer<T: source_map::ToString>(\n \t\tbuf: &mut T,\n \t\tparameters: &FunctionParameters,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\t// Use shorthand if one parameter with no declared type\n-\t\tif let (true, [Parameter { name, .. }]) = (\n-\t\t\tparameters.optional_parameters.is_empty() && parameters.rest_parameter.is_none(),\n-\t\t\tparameters.parameters.as_slice(),\n-\t\t) {\n+\t\tif let (true, [Parameter { name, .. }]) =\n+\t\t\t(parameters.rest_parameter.is_none(), parameters.parameters.as_slice())\n+\t\t{\n \t\t\tif let VariableField::Name(name, ..) = name.get_ast() {\n \t\t\t\tbuf.push_str(name.as_str());\n \t\t\t} else {\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -104,7 +98,7 @@ impl FunctionBased for ArrowFunctionBase {\n \n \tfn parameter_body_boundary_token_to_string_from_buffer<T: source_map::ToString>(\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t) {\n \t\tbuf.push_str(if settings.pretty { \" => \" } else { \"=>\" });\n \t}\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -118,19 +112,15 @@ impl ArrowFunction {\n \tpub(crate) fn from_reader_with_first_parameter(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\tfirst_parameter: (String, Span),\n \t) -> ParseResult<Self> {\n \t\tlet parameters = vec![crate::Parameter {\n \t\t\tname: WithComment::None(\n-\t\t\t\tVariableIdentifier::Standard(\n-\t\t\t\t\tfirst_parameter.0,\n-\t\t\t\t\tVariableId::new(),\n-\t\t\t\t\tfirst_parameter.1.clone(),\n-\t\t\t\t)\n-\t\t\t\t.into(),\n+\t\t\t\tVariableIdentifier::Standard(first_parameter.0, first_parameter.1.clone()).into(),\n \t\t\t),\n-\t\t\ttype_reference: None,\n+\t\t\ttype_annotation: None,\n+\t\t\tadditionally: None,\n \t\t}];\n \t\treader.expect_next(TSXToken::Arrow)?;\n \t\tlet body = ExpressionOrBlock::from_reader(reader, state, settings)?;\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -139,7 +129,6 @@ impl ArrowFunction {\n \t\t\tname: (),\n \t\t\tparameters: crate::FunctionParameters {\n \t\t\t\tparameters,\n-\t\t\t\toptional_parameters: Vec::new(),\n \t\t\t\trest_parameter: None,\n \t\t\t\tposition: first_parameter.1,\n \t\t\t},\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -154,7 +143,7 @@ impl ArrowFunction {\n \tpub(crate) fn from_reader_sub_open_paren(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\tis_async: Option<Keyword<tsx_keywords::Async>>,\n \t\topen_paren_span: Span,\n \t) -> ParseResult<Self> {\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -166,7 +155,7 @@ impl ArrowFunction {\n \t\t)?;\n \t\tlet return_type = if matches!(reader.peek().unwrap().0, TSXToken::Colon) {\n \t\t\treader.next();\n-\t\t\tSome(TypeReference::from_reader(reader, state, settings)?)\n+\t\t\tSome(TypeAnnotation::from_reader(reader, state, settings)?)\n \t\t} else {\n \t\t\tNone\n \t\t};\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -192,15 +181,6 @@ pub enum ExpressionOrBlock {\n \tBlock(Block),\n }\n \n-impl ExpressionOrBlock {\n-\tpub fn get_block_id(&self) -> Option<BlockId> {\n-\t\tmatch self {\n-\t\t\tExpressionOrBlock::Expression(_) => None,\n-\t\t\tExpressionOrBlock::Block(block) => Some(block.1),\n-\t\t}\n-\t}\n-}\n-\n impl ASTNode for ExpressionOrBlock {\n \tfn get_position(&self) -> Cow<Span> {\n \t\tmatch self {\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -212,7 +192,7 @@ impl ASTNode for ExpressionOrBlock {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tif matches!(reader.peek().unwrap().0, TSXToken::OpenBrace) {\n \t\t\tOk(Self::Block(Block::from_reader(reader, state, settings)?))\ndiff --git a/parser/src/expressions/arrow_function.rs b/parser/src/expressions/arrow_function.rs\n--- a/parser/src/expressions/arrow_function.rs\n+++ b/parser/src/expressions/arrow_function.rs\n@@ -225,7 +205,7 @@ impl ASTNode for ExpressionOrBlock {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/expressions/assignments.rs b/parser/src/expressions/assignments.rs\n--- a/parser/src/expressions/assignments.rs\n+++ b/parser/src/expressions/assignments.rs\n@@ -12,31 +12,29 @@ use crate::{\n \tParseResult, VariableFieldInSourceCode, WithComment,\n };\n \n-use super::{ExpressionId, MultipleExpression};\n+use super::MultipleExpression;\n \n #[derive(Debug, Clone, PartialEq, Eq, Visitable)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum VariableOrPropertyAccess {\n-\tVariable(String, Span, ExpressionId),\n+\tVariable(String, Span),\n \tPropertyAccess {\n \t\tparent: Box<Expression>,\n \t\tproperty: PropertyReference,\n \t\tposition: Span,\n-\t\texpression_id: ExpressionId,\n \t},\n \t/// Using `x[y]`\n \tIndex {\n \t\tindexee: Box<Expression>,\n \t\tindexer: Box<MultipleExpression>,\n \t\tposition: Span,\n-\t\texpression_id: ExpressionId,\n \t},\n }\n \n impl ASTNode for VariableOrPropertyAccess {\n \tfn get_position(&self) -> Cow<Span> {\n \t\tmatch self {\n-\t\t\tVariableOrPropertyAccess::Variable(_, position, _)\n+\t\t\tVariableOrPropertyAccess::Variable(_, position)\n \t\t\t| VariableOrPropertyAccess::PropertyAccess { position, .. }\n \t\t\t| VariableOrPropertyAccess::Index { position, .. } => Cow::Borrowed(position),\n \t\t}\ndiff --git a/parser/src/expressions/assignments.rs b/parser/src/expressions/assignments.rs\n--- a/parser/src/expressions/assignments.rs\n+++ b/parser/src/expressions/assignments.rs\n@@ -45,7 +43,7 @@ impl ASTNode for VariableOrPropertyAccess {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tExpression::from_reader(reader, state, settings)?.try_into()\n \t}\ndiff --git a/parser/src/expressions/assignments.rs b/parser/src/expressions/assignments.rs\n--- a/parser/src/expressions/assignments.rs\n+++ b/parser/src/expressions/assignments.rs\n@@ -53,7 +51,7 @@ impl ASTNode for VariableOrPropertyAccess {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/expressions/assignments.rs b/parser/src/expressions/assignments.rs\n--- a/parser/src/expressions/assignments.rs\n+++ b/parser/src/expressions/assignments.rs\n@@ -79,28 +77,32 @@ impl ASTNode for VariableOrPropertyAccess {\n \t}\n }\n \n+impl VariableOrPropertyAccess {\n+\tpub(crate) fn from_reader_with_precedence(\n+\t\treader: &mut impl TokenReader<TSXToken, Span>,\n+\t\tstate: &mut crate::ParsingState,\n+\t\tsettings: &crate::ParseOptions,\n+\t\treturn_precedence: u8,\n+\t) -> ParseResult<Self> {\n+\t\tExpression::from_reader_with_precedence(reader, state, settings, return_precedence)?\n+\t\t\t.try_into()\n+\t}\n+}\n+\n impl TryFrom<Expression> for VariableOrPropertyAccess {\n \ttype Error = ParseError;\n \n \tfn try_from(expression: Expression) -> Result<Self, Self::Error> {\n \t\tmatch expression {\n-\t\t\tExpression::VariableReference(name, position, expression_id) => {\n-\t\t\t\tOk(Self::Variable(name, position, expression_id))\n-\t\t\t}\n-\t\t\tExpression::PropertyAccess {\n-\t\t\t\tparent,\n-\t\t\t\tposition,\n-\t\t\t\texpression_id,\n-\t\t\t\tproperty,\n-\t\t\t\tis_optional,\n-\t\t\t} => {\n+\t\t\tExpression::VariableReference(name, position) => Ok(Self::Variable(name, position)),\n+\t\t\tExpression::PropertyAccess { parent, position, property, is_optional } => {\n \t\t\t\tif is_optional {\n \t\t\t\t\ttodo!()\n \t\t\t\t}\n-\t\t\t\tOk(Self::PropertyAccess { parent, position, expression_id, property })\n+\t\t\t\tOk(Self::PropertyAccess { parent, position, property })\n \t\t\t}\n-\t\t\tExpression::Index { expression_id, indexer, position, indexee } => {\n-\t\t\t\tOk(Self::Index { indexer, position, indexee, expression_id })\n+\t\t\tExpression::Index { indexer, position, indexee } => {\n+\t\t\t\tOk(Self::Index { indexer, position, indexee })\n \t\t\t}\n \t\t\texpression => Err(ParseError::new(\n \t\t\t\tcrate::ParseErrors::InvalidLHSAssignment,\ndiff --git a/parser/src/expressions/assignments.rs b/parser/src/expressions/assignments.rs\n--- a/parser/src/expressions/assignments.rs\n+++ b/parser/src/expressions/assignments.rs\n@@ -113,24 +115,15 @@ impl TryFrom<Expression> for VariableOrPropertyAccess {\n impl From<VariableOrPropertyAccess> for Expression {\n \tfn from(this: VariableOrPropertyAccess) -> Self {\n \t\tmatch this {\n-\t\t\tVariableOrPropertyAccess::Variable(variable, position, expression_id) => {\n-\t\t\t\tExpression::VariableReference(variable, position, expression_id)\n+\t\t\tVariableOrPropertyAccess::Variable(variable, position) => {\n+\t\t\t\tExpression::VariableReference(variable, position)\n+\t\t\t}\n+\t\t\tVariableOrPropertyAccess::Index { indexee, indexer, position } => {\n+\t\t\t\tExpression::Index { indexee, indexer, position }\n \t\t\t}\n-\t\t\tVariableOrPropertyAccess::Index { expression_id, indexee, indexer, position } => {\n-\t\t\t\tExpression::Index { indexee, indexer, position, expression_id }\n+\t\t\tVariableOrPropertyAccess::PropertyAccess { parent, position, property } => {\n+\t\t\t\tExpression::PropertyAccess { parent, position, property, is_optional: false }\n \t\t\t}\n-\t\t\tVariableOrPropertyAccess::PropertyAccess {\n-\t\t\t\texpression_id,\n-\t\t\t\tparent,\n-\t\t\t\tposition,\n-\t\t\t\tproperty,\n-\t\t\t} => Expression::PropertyAccess {\n-\t\t\t\texpression_id,\n-\t\t\t\tparent,\n-\t\t\t\tposition,\n-\t\t\t\tproperty,\n-\t\t\t\tis_optional: false,\n-\t\t\t},\n \t\t}\n \t}\n }\ndiff --git a/parser/src/expressions/assignments.rs b/parser/src/expressions/assignments.rs\n--- a/parser/src/expressions/assignments.rs\n+++ b/parser/src/expressions/assignments.rs\n@@ -158,17 +151,15 @@ impl VariableOrPropertyAccess {\n /// TODO cursor\n #[derive(PartialEqExtras, Debug, Clone, Visitable, derive_enum_from_into::EnumFrom)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n-#[partial_eq_ignore_types(Span, ExpressionId)]\n+#[partial_eq_ignore_types(Span)]\n pub enum LHSOfAssignment {\n \tObjectDestructuring(\n \t\t#[visit_skip_field] Vec<WithComment<ObjectDestructuringField<VariableFieldInSourceCode>>>,\n \t\tSpan,\n-\t\tExpressionId,\n \t),\n \tArrayDestructuring(\n \t\t#[visit_skip_field] Vec<ArrayDestructuringField<VariableFieldInSourceCode>>,\n \t\tSpan,\n-\t\tExpressionId,\n \t),\n \tVariableOrPropertyAccess(VariableOrPropertyAccess),\n }\ndiff --git a/parser/src/expressions/assignments.rs b/parser/src/expressions/assignments.rs\n--- a/parser/src/expressions/assignments.rs\n+++ b/parser/src/expressions/assignments.rs\n@@ -176,8 +167,8 @@ pub enum LHSOfAssignment {\n impl LHSOfAssignment {\n \tpub fn get_position(&self) -> Cow<Span> {\n \t\tmatch self {\n-\t\t\tLHSOfAssignment::ObjectDestructuring(_, _, _) => todo!(),\n-\t\t\tLHSOfAssignment::ArrayDestructuring(_, _, _) => todo!(),\n+\t\t\tLHSOfAssignment::ObjectDestructuring(_, pos)\n+\t\t\t| LHSOfAssignment::ArrayDestructuring(_, pos) => Cow::Borrowed(pos),\n \t\t\tLHSOfAssignment::VariableOrPropertyAccess(var_prop_access) => {\n \t\t\t\tvar_prop_access.get_position()\n \t\t\t}\ndiff --git a/parser/src/expressions/assignments.rs b/parser/src/expressions/assignments.rs\n--- a/parser/src/expressions/assignments.rs\n+++ b/parser/src/expressions/assignments.rs\n@@ -187,11 +178,11 @@ impl LHSOfAssignment {\n \tpub(crate) fn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\n-\t\t\tLHSOfAssignment::ObjectDestructuring(members, _, _) => {\n+\t\t\tLHSOfAssignment::ObjectDestructuring(members, _) => {\n \t\t\t\tbuf.push('{');\n \t\t\t\tsettings.add_gap(buf);\n \t\t\t\tfor (at_end, member) in members.iter().endiate() {\ndiff --git a/parser/src/expressions/assignments.rs b/parser/src/expressions/assignments.rs\n--- a/parser/src/expressions/assignments.rs\n+++ b/parser/src/expressions/assignments.rs\n@@ -204,7 +195,7 @@ impl LHSOfAssignment {\n \t\t\t\tsettings.add_gap(buf);\n \t\t\t\tbuf.push('}');\n \t\t\t}\n-\t\t\tLHSOfAssignment::ArrayDestructuring(members, _, _) => {\n+\t\t\tLHSOfAssignment::ArrayDestructuring(members, _) => {\n \t\t\t\tbuf.push('[');\n \t\t\t\tfor (at_end, member) in members.iter().endiate() {\n \t\t\t\t\tmember.to_string_from_buffer(buf, settings, depth);\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -9,7 +9,7 @@ use crate::{\n \t\tFUNCTION_CALL_PRECEDENCE, OPTIONAL_CHAINING_PRECEDENCE,\n \t},\n \tparse_bracketed, to_string_bracketed,\n-\ttype_references::generic_arguments_from_reader_sub_open_angle,\n+\ttype_annotations::generic_arguments_from_reader_sub_open_angle,\n \tCursorId, ExpressionPosition, FunctionHeader, FunctionId, Keyword, NumberStructure,\n \tParseResult, Quoted, TSXKeyword,\n };\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -26,12 +26,11 @@ use super::{\n \t\tPARENTHESIZED_EXPRESSION_AND_LITERAL_PRECEDENCE, TERNARY_PRECEDENCE,\n \t},\n \ttokens::token_as_identifier,\n-\tASTNode, Block, FunctionBase, JSXRoot, ParseError, ParseSettings, Span, TSXToken, Token,\n-\tTokenReader, TypeReference,\n+\tASTNode, Block, FunctionBase, JSXRoot, ParseError, ParseOptions, Span, TSXToken, Token,\n+\tTokenReader, TypeAnnotation,\n };\n \n use crate::tsx_keywords::{self, As, Generator, Is, Satisfies};\n-use derive_debug_extras::DebugExtras;\n use derive_partial_eq_extras::PartialEqExtras;\n use visitable_derive::Visitable;\n \ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -49,118 +48,76 @@ pub type ExpressionFunction = FunctionBase<ExpressionFunctionBase>;\n use std::{\n \tborrow::Cow,\n \tconvert::{TryFrom, TryInto},\n-\tsync::atomic::{AtomicU16, Ordering},\n };\n \n-static EXPRESSION_ID_COUNTER: AtomicU16 = AtomicU16::new(1);\n-\n-/// Id given to AST that declares a type\n-/// Used for keeping track of expressions between passes\n-#[derive(PartialEq, Eq, Clone, Copy, DebugExtras, Hash)]\n-// #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n-pub struct ExpressionId(u16);\n-\n-impl ExpressionId {\n-\tpub fn new() -> Self {\n-\t\tSelf(EXPRESSION_ID_COUNTER.fetch_add(1, Ordering::SeqCst))\n-\t}\n-\n-\t/// **Use with care**\n-\tpub const NULL: Self = Self(0);\n-\n-\t/// TODO temp\n-\tpub fn unwrap_counter(&self) -> u16 {\n-\t\tself.0\n-\t}\n-}\n-\n-#[cfg(feature = \"self-rust-tokenize\")]\n-impl self_rust_tokenize::SelfRustTokenize for ExpressionId {\n-\tfn append_to_token_stream(\n-\t\t&self,\n-\t\ttoken_stream: &mut self_rust_tokenize::proc_macro2::TokenStream,\n-\t) {\n-\t\ttoken_stream.extend(self_rust_tokenize::quote!(ExpressionId::NULL));\n-\t}\n-}\n-\n /// Expression structures\n ///\n /// Comma is implemented as a [BinaryOperator]\n #[derive(PartialEqExtras, Debug, Clone, Visitable)]\n-#[partial_eq_ignore_types(Span, ExpressionId)]\n+#[partial_eq_ignore_types(Span)]\n #[visit_self]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum Expression {\n \t// Literals:\n-\tNumberLiteral(NumberStructure, Span, ExpressionId),\n-\tStringLiteral(String, #[partial_eq_ignore] Quoted, Span, ExpressionId),\n-\tBooleanLiteral(bool, Span, ExpressionId),\n+\tNumberLiteral(NumberStructure, Span),\n+\tStringLiteral(String, #[partial_eq_ignore] Quoted, Span),\n+\tBooleanLiteral(bool, Span),\n \tRegexLiteral {\n \t\tpattern: String,\n \t\tflags: Option<String>,\n \t\tposition: Span,\n-\t\tid: ExpressionId,\n \t},\n-\tArrayLiteral(Vec<SpreadExpression>, Span, ExpressionId),\n+\tArrayLiteral(Vec<SpreadExpression>, Span),\n \tObjectLiteral(ObjectLiteral),\n \tTemplateLiteral(TemplateLiteral),\n-\tParenthesizedExpression(Box<MultipleExpression>, Span, ExpressionId),\n+\tParenthesizedExpression(Box<MultipleExpression>, Span),\n \t// Regular operations:\n \tBinaryOperation {\n \t\tlhs: Box<Expression>,\n \t\toperator: BinaryOperator,\n \t\trhs: Box<Expression>,\n-\t\tid: ExpressionId,\n \t},\n-\tSpecialOperators(SpecialOperators, Span, ExpressionId),\n+\tSpecialOperators(SpecialOperators, Span),\n \tUnaryOperation {\n \t\toperator: UnaryOperator,\n \t\toperand: Box<Expression>,\n \t\tposition: Span,\n-\t\tid: ExpressionId,\n \t},\n \t// Assignment operations\n \tAssignment {\n \t\tlhs: LHSOfAssignment,\n \t\trhs: Box<Expression>,\n-\t\tid: ExpressionId,\n \t},\n \t/// Modified assignment cannot have destructured thingies\n \tBinaryAssignmentOperation {\n \t\tlhs: VariableOrPropertyAccess,\n \t\toperator: BinaryAssignmentOperator,\n \t\trhs: Box<Expression>,\n-\t\tid: ExpressionId,\n \t},\n \tUnaryPrefixAssignmentOperation {\n \t\toperator: UnaryPrefixAssignmentOperator,\n \t\toperand: VariableOrPropertyAccess,\n \t\tposition: Span,\n-\t\tid: ExpressionId,\n \t},\n \tUnaryPostfixAssignmentOperation {\n \t\toperand: VariableOrPropertyAccess,\n \t\toperator: UnaryPostfixAssignmentOperator,\n \t\tposition: Span,\n-\t\tid: ExpressionId,\n \t},\n \t/// e.g `x` or `(...).hi`\n-\tVariableReference(String, Span, ExpressionId),\n-\tThisReference(Span, ExpressionId),\n-\tSuperExpression(SuperReference, Span, ExpressionId),\n+\tVariableReference(String, Span),\n+\tThisReference(Span),\n+\tSuperExpression(SuperReference, Span),\n \t/// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target\n-\tNewTarget(Span, ExpressionId),\n+\tNewTarget(Span),\n \tDynamicImport {\n \t\tpath: Box<Expression>,\n \t\tposition: Span,\n-\t\texpression_id: ExpressionId,\n \t},\n \tPropertyAccess {\n \t\tparent: Box<Expression>,\n \t\tproperty: PropertyReference,\n \t\tposition: Span,\n-\t\texpression_id: ExpressionId,\n \t\tis_optional: bool,\n \t},\n \t/// e.g `...[4]`\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -168,39 +125,35 @@ pub enum Expression {\n \t\tindexee: Box<Expression>,\n \t\tindexer: Box<MultipleExpression>,\n \t\tposition: Span,\n-\t\texpression_id: ExpressionId,\n \t},\n \t// Function calls\n \tFunctionCall {\n \t\tfunction: Box<Expression>,\n-\t\ttype_arguments: Option<Vec<TypeReference>>,\n+\t\ttype_arguments: Option<Vec<TypeAnnotation>>,\n \t\targuments: Vec<SpreadExpression>,\n \t\tposition: Span,\n-\t\texpression_id: ExpressionId,\n \t},\n \tConstructorCall {\n \t\tconstructor: Box<Expression>,\n-\t\ttype_arguments: Option<Vec<TypeReference>>,\n+\t\ttype_arguments: Option<Vec<TypeAnnotation>>,\n \t\targuments: Option<Vec<SpreadExpression>>,\n \t\tposition: Span,\n-\t\texpression_id: ExpressionId,\n \t},\n \t/// e.g `... ? ... ? ...`\n \tTernaryExpression {\n \t\tcondition: Box<Expression>,\n \t\ttruthy_result: Box<Expression>,\n \t\tfalsy_result: Box<Expression>,\n-\t\tid: ExpressionId,\n \t},\n \t// Functions\n \tArrowFunction(ArrowFunction),\n \tExpressionFunction(ExpressionFunction),\n \t/// Yes classes can exist in expr position :?\n-\tClassExpression(ClassDeclaration<ExpressionPosition>, ExpressionId),\n-\tNull(Span, ExpressionId),\n+\tClassExpression(ClassDeclaration<ExpressionPosition>),\n+\tNull(Span),\n \t// Comments\n-\tPrefixComment(String, Box<Expression>, Span, ExpressionId),\n-\tPostfixComment(Box<Expression>, String, Span, ExpressionId),\n+\tPrefixComment(String, Box<Expression>, Span),\n+\tPostfixComment(Box<Expression>, String, Span),\n \t/// Allowed in trailing functions and JSX for some reason\n \tComment(String, Span),\n \t/// TODO under cfg\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -214,7 +167,6 @@ pub enum Expression {\n \t\t#[visit_skip_field]\n \t\tcursor_id: CursorId<Expression>,\n \t\tposition: Span,\n-\t\texpression_id: ExpressionId,\n \t},\n }\n \ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -232,7 +184,7 @@ impl ASTNode for Expression {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Expression> {\n \t\tSelf::from_reader_with_precedence(reader, state, settings, COMMA_PRECEDENCE)\n \t}\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -240,7 +192,7 @@ impl ASTNode for Expression {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tself.to_string_using_precedence(buf, settings, depth, COMMA_PRECEDENCE)\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -260,26 +212,26 @@ impl ASTNode for Expression {\n \t\t\tSelf::BinaryAssignmentOperation { lhs, rhs, .. } => {\n \t\t\t\tCow::Owned(lhs.get_position().union(&rhs.get_position()))\n \t\t\t}\n-\t\t\tSelf::NumberLiteral(_, pos, _)\n-\t\t\t| Self::StringLiteral(_, _, pos, _)\n-\t\t\t| Self::BooleanLiteral(_, pos, _)\n-\t\t\t| Self::ArrayLiteral(_, pos, _)\n-\t\t\t| Self::ParenthesizedExpression(_, pos, _)\n-\t\t\t| Self::SpecialOperators(_, pos, _)\n+\t\t\tSelf::NumberLiteral(_, pos)\n+\t\t\t| Self::StringLiteral(_, _, pos)\n+\t\t\t| Self::BooleanLiteral(_, pos)\n+\t\t\t| Self::ArrayLiteral(_, pos)\n+\t\t\t| Self::ParenthesizedExpression(_, pos)\n+\t\t\t| Self::SpecialOperators(_, pos)\n \t\t\t| Self::UnaryOperation { position: pos, .. }\n \t\t\t| Self::UnaryPrefixAssignmentOperation { position: pos, .. }\n \t\t\t| Self::UnaryPostfixAssignmentOperation { position: pos, .. }\n-\t\t\t| Self::VariableReference(_, pos, _)\n+\t\t\t| Self::VariableReference(_, pos)\n \t\t\t| Self::Index { position: pos, .. }\n-\t\t\t| Self::Null(pos, _)\n-\t\t\t| Self::PrefixComment(_, _, pos, _)\n-\t\t\t| Self::PostfixComment(_, _, pos, _)\n+\t\t\t| Self::Null(pos)\n+\t\t\t| Self::PrefixComment(_, _, pos)\n+\t\t\t| Self::PostfixComment(_, _, pos)\n \t\t\t| Self::Comment(_, pos)\n \t\t\t| Self::FunctionCall { position: pos, .. }\n \t\t\t| Self::PropertyAccess { position: pos, .. }\n-\t\t\t| Self::ThisReference(pos, _)\n-\t\t\t| Self::NewTarget(pos, _)\n-\t\t\t| Self::SuperExpression(_, pos, _)\n+\t\t\t| Self::ThisReference(pos)\n+\t\t\t| Self::NewTarget(pos)\n+\t\t\t| Self::SuperExpression(_, pos)\n \t\t\t| Self::DynamicImport { position: pos, .. }\n \t\t\t| Self::ConstructorCall { position: pos, .. }\n \t\t\t| Self::RegexLiteral { position: pos, .. }\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -287,7 +239,7 @@ impl ASTNode for Expression {\n \t\t\tSelf::JSXRoot(root) => root.get_position(),\n \t\t\tSelf::ObjectLiteral(object_literal) => object_literal.get_position(),\n \t\t\tSelf::TemplateLiteral(template_literal) => template_literal.get_position(),\n-\t\t\tSelf::ClassExpression(class_expression, _) => class_expression.get_position(),\n+\t\t\tSelf::ClassExpression(class_expression) => class_expression.get_position(),\n \t\t\tSelf::IsExpression(is) => is.get_position(),\n \t\t\tSelf::ArrowFunction(arrow_function) => arrow_function.get_position(),\n \t\t\tSelf::ExpressionFunction(function) => function.get_position(),\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -299,28 +251,26 @@ impl Expression {\n \tpub(self) fn from_reader_with_precedence(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\treturn_precedence: u8,\n \t) -> ParseResult<Self> {\n \t\tlet first_expression = match reader.next().ok_or_else(parse_lexing_error)? {\n \t\t\tToken(TSXToken::Cursor(cursor_id), position) => {\n-\t\t\t\treturn Ok(Expression::Cursor {\n-\t\t\t\t\tcursor_id: cursor_id.into_cursor(),\n-\t\t\t\t\tposition,\n-\t\t\t\t\texpression_id: ExpressionId::new(),\n-\t\t\t\t});\n+\t\t\t\treturn Ok(Expression::Cursor { cursor_id: cursor_id.into_cursor(), position });\n \t\t\t}\n \t\t\tToken(TSXToken::SingleQuotedStringLiteral(expression), position) => {\n-\t\t\t\tExpression::StringLiteral(expression, Quoted::Single, position, ExpressionId::new())\n+\t\t\t\tExpression::StringLiteral(expression, Quoted::Single, position)\n \t\t\t}\n \t\t\tToken(TSXToken::DoubleQuotedStringLiteral(expression), position) => {\n-\t\t\t\tExpression::StringLiteral(expression, Quoted::Double, position, ExpressionId::new())\n+\t\t\t\tExpression::StringLiteral(expression, Quoted::Double, position)\n+\t\t\t}\n+\t\t\tToken(TSXToken::NumberLiteral(value), position) => {\n+\t\t\t\tlet res = value.parse::<NumberStructure>();\n+\t\t\t\tmatch res {\n+\t\t\t\t\tOk(number) => Expression::NumberLiteral(number, position),\n+\t\t\t\t\tErr(_) => unreachable!(\"Could not parse {value}\"),\n+\t\t\t\t}\n \t\t\t}\n-\t\t\tToken(TSXToken::NumberLiteral(value), position) => Expression::NumberLiteral(\n-\t\t\t\tvalue.parse::<NumberStructure>().unwrap(),\n-\t\t\t\tposition,\n-\t\t\t\tExpressionId::new(),\n-\t\t\t),\n \t\t\tToken(TSXToken::RegexLiteral(pattern), mut position) => {\n \t\t\t\tlet flag_token =\n \t\t\t\t\treader.conditional_next(|t| matches!(t, TSXToken::RegexFlagLiteral(..)));\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -332,16 +282,16 @@ impl Expression {\n \t\t\t\t} else {\n \t\t\t\t\tNone\n \t\t\t\t};\n-\t\t\t\tExpression::RegexLiteral { pattern, flags, position, id: ExpressionId::new() }\n+\t\t\t\tExpression::RegexLiteral { pattern, flags, position }\n \t\t\t}\n \t\t\tToken(TSXToken::Keyword(TSXKeyword::True), position) => {\n-\t\t\t\tExpression::BooleanLiteral(true, position, ExpressionId::new())\n+\t\t\t\tExpression::BooleanLiteral(true, position)\n \t\t\t}\n \t\t\tToken(TSXToken::Keyword(TSXKeyword::False), position) => {\n-\t\t\t\tExpression::BooleanLiteral(false, position, ExpressionId::new())\n+\t\t\t\tExpression::BooleanLiteral(false, position)\n \t\t\t}\n \t\t\tToken(TSXToken::Keyword(TSXKeyword::This), position) => {\n-\t\t\t\tExpression::ThisReference(position, ExpressionId::new())\n+\t\t\t\tExpression::ThisReference(position)\n \t\t\t}\n \t\t\tToken(TSXToken::Keyword(TSXKeyword::Super), position) => {\n \t\t\t\tlet Token(token, modifier_pos) = reader.next().unwrap();\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -380,17 +330,15 @@ impl Expression {\n \t\t\t\t\t\t));\n \t\t\t\t\t}\n \t\t\t\t};\n-\t\t\t\tExpression::SuperExpression(reference, position.union(&end), ExpressionId::new())\n-\t\t\t}\n-\t\t\tToken(TSXToken::Keyword(TSXKeyword::Null), position) => {\n-\t\t\t\tExpression::Null(position, ExpressionId::new())\n+\t\t\t\tExpression::SuperExpression(reference, position.union(&end))\n \t\t\t}\n+\t\t\tToken(TSXToken::Keyword(TSXKeyword::Null), position) => Expression::Null(position),\n \t\t\tToken(TSXToken::Keyword(TSXKeyword::Class), position) => {\n \t\t\t\tlet keyword = Keyword(tsx_keywords::Class, position);\n \t\t\t\tlet class_declaration = ClassDeclaration::from_reader_sub_class_keyword(\n \t\t\t\t\treader, state, settings, keyword,\n \t\t\t\t)?;\n-\t\t\t\tExpression::ClassExpression(class_declaration, ExpressionId::new())\n+\t\t\t\tExpression::ClassExpression(class_declaration)\n \t\t\t}\n \t\t\tToken(TSXToken::OpenBracket, start_pos) => {\n \t\t\t\tlet mut bracket_depth = 1;\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -420,19 +368,13 @@ impl Expression {\n \t\t\t\t\t\t\tlhs: LHSOfAssignment::ArrayDestructuring(\n \t\t\t\t\t\t\t\tmembers,\n \t\t\t\t\t\t\t\tstart_pos.union(&end_span),\n-\t\t\t\t\t\t\t\tExpressionId::new(),\n \t\t\t\t\t\t\t),\n \t\t\t\t\t\t\trhs: Box::new(rhs),\n-\t\t\t\t\t\t\tid: ExpressionId::new(),\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\tlet (items, end_pos) =\n \t\t\t\t\t\t\tparse_bracketed(reader, state, settings, None, TSXToken::CloseBracket)?;\n-\t\t\t\t\t\tExpression::ArrayLiteral(\n-\t\t\t\t\t\t\titems,\n-\t\t\t\t\t\t\tstart_pos.union(&end_pos),\n-\t\t\t\t\t\t\tExpressionId::new(),\n-\t\t\t\t\t\t)\n+\t\t\t\t\t\tExpression::ArrayLiteral(items, start_pos.union(&end_pos))\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\treturn Err(ParseError::new(crate::ParseErrors::UnmatchedBrackets, start_pos));\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -466,10 +408,8 @@ impl Expression {\n \t\t\t\t\t\t\tlhs: LHSOfAssignment::ObjectDestructuring(\n \t\t\t\t\t\t\t\tmembers,\n \t\t\t\t\t\t\t\tstart_pos.union(&end_span),\n-\t\t\t\t\t\t\t\tExpressionId::new(),\n \t\t\t\t\t\t\t),\n \t\t\t\t\t\t\trhs: Box::new(rhs),\n-\t\t\t\t\t\t\tid: ExpressionId::new(),\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\tlet object_literal = ObjectLiteral::from_reader_sub_open_curly(\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -511,7 +451,6 @@ impl Expression {\n \t\t\t\t\t\tExpression::ParenthesizedExpression(\n \t\t\t\t\t\t\tBox::new(parenthesize_expression),\n \t\t\t\t\t\t\topen_paren_span.union(&close_paren_span),\n-\t\t\t\t\t\t\tExpressionId::new(),\n \t\t\t\t\t\t)\n \t\t\t\t\t}\n \t\t\t\t} else {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -526,7 +465,7 @@ impl Expression {\n \t\t\t\t\t// TODO assert not lonely, else syntax error\n \t\t\t\t\treader.expect_next(TSXToken::Dot)?;\n \t\t\t\t\treader.expect_next(TSXToken::IdentLiteral(\"target\".into()))?;\n-\t\t\t\t\tExpression::NewTarget(new_pos, ExpressionId::new())\n+\t\t\t\t\tExpression::NewTarget(new_pos)\n \t\t\t\t} else {\n \t\t\t\t\t// Pass as a function call and then adds the conversion\n \t\t\t\t\tlet constructor_expression = Self::from_reader_with_precedence(\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -561,7 +500,6 @@ impl Expression {\n \t\t\t\t\t\ttype_arguments,\n \t\t\t\t\t\targuments,\n \t\t\t\t\t\tposition: new_pos.union(&end_pos),\n-\t\t\t\t\t\texpression_id: ExpressionId::new(),\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -581,12 +519,7 @@ impl Expression {\n \t\t\t\tlet expression =\n \t\t\t\t\tSelf::from_reader_with_precedence(reader, state, settings, return_precedence)?;\n \t\t\t\tlet position = start_pos.union(&expression.get_position());\n-\t\t\t\tExpression::PrefixComment(\n-\t\t\t\t\tcomment,\n-\t\t\t\t\tBox::new(expression),\n-\t\t\t\t\tposition,\n-\t\t\t\t\tExpressionId::new(),\n-\t\t\t\t)\n+\t\t\t\tExpression::PrefixComment(comment, Box::new(expression), position)\n \t\t\t}\n \t\t\tToken(tok @ TSXToken::JSXOpeningTagStart | tok @ TSXToken::JSXFragmentStart, span) => {\n \t\t\t\tlet var_name = matches!(tok, TSXToken::JSXFragmentStart);\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -611,7 +544,7 @@ impl Expression {\n \t\t\t\t} else {\n \t\t\t\t\tlet (token, span) =\n \t\t\t\t\t\ttoken_as_identifier(reader.next().unwrap(), \"function name\")?;\n-\t\t\t\t\tSome(crate::VariableIdentifier::Standard(token, crate::VariableId::new(), span))\n+\t\t\t\t\tSome(crate::VariableIdentifier::Standard(token, span))\n \t\t\t\t};\n \t\t\t\tlet function: ExpressionFunction = FunctionBase::from_reader_with_header_and_name(\n \t\t\t\t\treader, state, settings, header, name,\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -657,11 +590,7 @@ impl Expression {\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tlet (token, span) =\n \t\t\t\t\t\t\t\ttoken_as_identifier(reader.next().unwrap(), \"function name\")?;\n-\t\t\t\t\t\t\tSome(crate::VariableIdentifier::Standard(\n-\t\t\t\t\t\t\t\ttoken,\n-\t\t\t\t\t\t\t\tcrate::VariableId::new(),\n-\t\t\t\t\t\t\t\tspan,\n-\t\t\t\t\t\t\t))\n+\t\t\t\t\t\t\tSome(crate::VariableIdentifier::Standard(token, span))\n \t\t\t\t\t\t};\n \t\t\t\t\t\tlet function: ExpressionFunction =\n \t\t\t\t\t\t\tFunctionBase::from_reader_with_header_and_name(\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -695,13 +624,16 @@ impl Expression {\n \t\t\t\t}\n \t\t\t}\n \t\t\t#[cfg(feature = \"extras\")]\n-\t\t\tToken(TSXToken::Keyword(TSXKeyword::Is), span) => is_expression_from_reader_sub_is_keyword(\n-\t\t\t\treader,\n-\t\t\t\tstate,\n-\t\t\t\tsettings,\n-\t\t\t\tKeyword::new(span),\n-\t\t\t)\n-\t\t\t.map(Expression::IsExpression)?,\n+\t\t\tToken(TSXToken::Keyword(TSXKeyword::Is), span) => {\n+\t\t\t\tlet is_expression_from_reader_sub_is_keyword =\n+\t\t\t\t\tis_expression_from_reader_sub_is_keyword(\n+\t\t\t\t\t\treader,\n+\t\t\t\t\t\tstate,\n+\t\t\t\t\t\tsettings,\n+\t\t\t\t\t\tKeyword::new(span),\n+\t\t\t\t\t);\n+\t\t\t\tis_expression_from_reader_sub_is_keyword.map(Expression::IsExpression)?\n+\t\t\t}\n \t\t\ttoken => {\n \t\t\t\tif let Ok(unary_operator) = UnaryOperator::try_from(&token.0) {\n \t\t\t\t\tlet op_precedence = unary_operator.precedence();\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -712,20 +644,23 @@ impl Expression {\n \t\t\t\t\t\toperand: Box::new(operand),\n \t\t\t\t\t\toperator: unary_operator,\n \t\t\t\t\t\tposition,\n-\t\t\t\t\t\tid: ExpressionId::new(),\n \t\t\t\t\t}\n \t\t\t\t} else if let Ok(unary_prefix_operator) =\n \t\t\t\t\tUnaryPrefixAssignmentOperator::try_from(&token.0)\n \t\t\t\t{\n \t\t\t\t\t// TODO is precedence needed...?\n-\t\t\t\t\t// let op_precedence = unary_prefix_operator.precedence();\n-\t\t\t\t\tlet operand = VariableOrPropertyAccess::from_reader(reader, state, settings)?;\n+\t\t\t\t\tlet op_precedence = unary_prefix_operator.precedence();\n+\t\t\t\t\tlet operand = VariableOrPropertyAccess::from_reader_with_precedence(\n+\t\t\t\t\t\treader,\n+\t\t\t\t\t\tstate,\n+\t\t\t\t\t\tsettings,\n+\t\t\t\t\t\top_precedence,\n+\t\t\t\t\t)?;\n \t\t\t\t\tlet position = token.1.union(&operand.get_position());\n \t\t\t\t\tExpression::UnaryPrefixAssignmentOperation {\n \t\t\t\t\t\toperand,\n \t\t\t\t\t\toperator: unary_prefix_operator,\n \t\t\t\t\t\tposition,\n-\t\t\t\t\t\tid: ExpressionId::new(),\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tlet (name, position) = token_as_identifier(token, \"variable reference\")?;\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -738,7 +673,7 @@ impl Expression {\n \t\t\t\t\t\t)?;\n \t\t\t\t\t\tExpression::ArrowFunction(function)\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tExpression::VariableReference(name, position, ExpressionId::new())\n+\t\t\t\t\t\tExpression::VariableReference(name, position)\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -755,7 +690,7 @@ impl Expression {\n \tpub(crate) fn from_reader_sub_first_expression(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\tparent_precedence: u8,\n \t\tfirst_expression: Expression,\n \t) -> ParseResult<Self> {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -781,7 +716,6 @@ impl Expression {\n \t\t\t\t\t\tcondition: Box::new(top),\n \t\t\t\t\t\ttruthy_result: Box::new(lhs),\n \t\t\t\t\t\tfalsy_result: Box::new(rhs),\n-\t\t\t\t\t\tid: ExpressionId::new(),\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tTSXToken::OpenParentheses => {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -799,7 +733,6 @@ impl Expression {\n \t\t\t\t\t\ttype_arguments: None,\n \t\t\t\t\t\targuments,\n \t\t\t\t\t\tposition,\n-\t\t\t\t\t\texpression_id: ExpressionId::new(),\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tTSXToken::OpenBracket => {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -816,7 +749,6 @@ impl Expression {\n \t\t\t\t\t\tposition,\n \t\t\t\t\t\tindexee: Box::new(top),\n \t\t\t\t\t\tindexer: Box::new(indexer),\n-\t\t\t\t\t\texpression_id: ExpressionId::new(),\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tTSXToken::TemplateLiteralStart => {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -861,7 +793,6 @@ impl Expression {\n \t\t\t\t\t\tparent: Box::new(top),\n \t\t\t\t\t\tproperty,\n \t\t\t\t\t\tposition,\n-\t\t\t\t\t\texpression_id: ExpressionId::new(),\n \t\t\t\t\t\tis_optional,\n \t\t\t\t\t};\n \t\t\t\t}\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -881,7 +812,6 @@ impl Expression {\n \t\t\t\t\ttop = Expression::Assignment {\n \t\t\t\t\t\tlhs: LHSOfAssignment::VariableOrPropertyAccess(top.try_into()?),\n \t\t\t\t\t\trhs: Box::new(new_rhs),\n-\t\t\t\t\t\tid: ExpressionId::new(),\n \t\t\t\t\t};\n \t\t\t\t}\n \t\t\t\tTSXToken::MultiLineComment(_) | TSXToken::Comment(_) => {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -889,12 +819,7 @@ impl Expression {\n \t\t\t\t\t\tTSXToken::MultiLineComment(comment) | TSXToken::Comment(comment),\n \t\t\t\t\t\tposition,\n \t\t\t\t\t) = reader.next().unwrap() else { unreachable!() } ;\n-\t\t\t\t\ttop = Expression::PostfixComment(\n-\t\t\t\t\t\tBox::new(top),\n-\t\t\t\t\t\tcomment,\n-\t\t\t\t\t\tposition,\n-\t\t\t\t\t\tExpressionId::new(),\n-\t\t\t\t\t);\n+\t\t\t\t\ttop = Expression::PostfixComment(Box::new(top), comment, position);\n \t\t\t\t}\n \t\t\t\tTSXToken::Keyword(TSXKeyword::As | TSXKeyword::Satisfies | TSXKeyword::Is) => {\n \t\t\t\t\tif AssociativityDirection::LeftToRight\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -904,7 +829,7 @@ impl Expression {\n \t\t\t\t\t}\n \n \t\t\t\t\tlet Token(token, keyword_pos) = reader.next().unwrap();\n-\t\t\t\t\tlet reference = TypeReference::from_reader(reader, state, settings)?;\n+\t\t\t\t\tlet reference = TypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\t\t\tlet position = top.get_position().union(&reference.get_position());\n \n \t\t\t\t\tlet special_operators = match token {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -927,7 +852,7 @@ impl Expression {\n \t\t\t\t\t\t}\n \t\t\t\t\t\t_ => unreachable!(),\n \t\t\t\t\t};\n-\t\t\t\t\ttop = Self::SpecialOperators(special_operators, position, ExpressionId::new());\n+\t\t\t\t\ttop = Self::SpecialOperators(special_operators, position);\n \t\t\t\t}\n \t\t\t\ttoken => {\n \t\t\t\t\tlet token = if *token == TSXToken::OpenChevron {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -948,7 +873,6 @@ impl Expression {\n \t\t\t\t\t\t\t\tfunction: Box::new(top),\n \t\t\t\t\t\t\t\ttype_arguments: Some(type_arguments),\n \t\t\t\t\t\t\t\targuments,\n-\t\t\t\t\t\t\t\texpression_id: ExpressionId::new(),\n \t\t\t\t\t\t\t};\n \t\t\t\t\t\t\tcontinue;\n \t\t\t\t\t\t} else {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -973,7 +897,6 @@ impl Expression {\n \t\t\t\t\t\t\toperand: top.try_into()?,\n \t\t\t\t\t\t\toperator,\n \t\t\t\t\t\t\tposition,\n-\t\t\t\t\t\t\tid: ExpressionId::new(),\n \t\t\t\t\t\t};\n \t\t\t\t\t} else if let Ok(operator) = BinaryOperator::try_from(token) {\n \t\t\t\t\t\tif operator\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -995,7 +918,6 @@ impl Expression {\n \t\t\t\t\t\t\tlhs: Box::new(top),\n \t\t\t\t\t\t\toperator,\n \t\t\t\t\t\t\trhs: Box::new(rhs),\n-\t\t\t\t\t\t\tid: ExpressionId::new(),\n \t\t\t\t\t\t};\n \t\t\t\t\t} else if let Ok(operator) = BinaryAssignmentOperator::try_from(token) {\n \t\t\t\t\t\tif operator\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1015,7 +937,6 @@ impl Expression {\n \t\t\t\t\t\t\tlhs: top.try_into()?,\n \t\t\t\t\t\t\toperator,\n \t\t\t\t\t\t\trhs: Box::new(new_rhs),\n-\t\t\t\t\t\t\tid: ExpressionId::new(),\n \t\t\t\t\t\t};\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// debug_assert!(\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1074,11 +995,11 @@ impl Expression {\n             }\n             Self::Index { .. } => INDEX_PRECEDENCE,\n             Self::TernaryExpression { .. } => TERNARY_PRECEDENCE,\n-            Self::PrefixComment(_, expression, _, _) | Self::PostfixComment(expression, _, _, _) => {\n+            Self::PrefixComment(_, expression, _) | Self::PostfixComment(expression, _, _) => {\n                 expression.get_precedence()\n             }\n             Self::Comment(_, _) => PARENTHESIZED_EXPRESSION_AND_LITERAL_PRECEDENCE, // TODO not sure about this\n-            Self::SpecialOperators(op, _, _) => match op {\n+            Self::SpecialOperators(op, _) => match op {\n \t\t\t\t // TODO not sure about this\n                 SpecialOperators::AsExpression { .. } => PARENTHESIZED_EXPRESSION_AND_LITERAL_PRECEDENCE,\n                 SpecialOperators::IsExpression { .. } => PARENTHESIZED_EXPRESSION_AND_LITERAL_PRECEDENCE,\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1090,7 +1011,7 @@ impl Expression {\n \tpub(crate) fn to_string_using_precedence<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t\t_parent_precedence: u8,\n \t) {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1100,13 +1021,13 @@ impl Expression {\n \t\t\t\t\tpanic!();\n \t\t\t\t}\n \t\t\t}\n-\t\t\tSelf::NumberLiteral(num, _, _) => buf.push_str(&num.to_string()),\n-\t\t\tSelf::StringLiteral(string, quoted, _, _) => {\n+\t\t\tSelf::NumberLiteral(num, _) => buf.push_str(&num.to_string()),\n+\t\t\tSelf::StringLiteral(string, quoted, _) => {\n \t\t\t\tbuf.push(quoted.as_char());\n \t\t\t\tbuf.push_str(string);\n \t\t\t\tbuf.push(quoted.as_char());\n \t\t\t}\n-\t\t\tSelf::BooleanLiteral(expression, _, _) => {\n+\t\t\tSelf::BooleanLiteral(expression, _) => {\n \t\t\t\tbuf.push_str(if *expression { \"true\" } else { \"false\" });\n \t\t\t}\n \t\t\tSelf::RegexLiteral { pattern, flags, .. } => {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1125,7 +1046,7 @@ impl Expression {\n \t\t\t\tsettings.add_gap(buf);\n \t\t\t\trhs.to_string_using_precedence(buf, settings, depth, op_precedence);\n \t\t\t}\n-\t\t\tSelf::SpecialOperators(special, _, _) => match special {\n+\t\t\tSelf::SpecialOperators(special, _) => match special {\n \t\t\t\tSpecialOperators::AsExpression { value, type_annotation, .. }\n \t\t\t\t| SpecialOperators::IsExpression { value, type_annotation, .. }\n \t\t\t\t| SpecialOperators::SatisfiesExpression { value, type_annotation, .. } => {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1165,7 +1086,7 @@ impl Expression {\n \t\t\t\toperand.to_string_from_buffer(buf, settings, depth);\n \t\t\t\tbuf.push_str(operator.to_str());\n \t\t\t}\n-\t\t\tSelf::VariableReference(name, _position, _) => {\n+\t\t\tSelf::VariableReference(name, _position) => {\n \t\t\t\tbuf.push_str(name);\n \t\t\t}\n \t\t\tSelf::ThisReference(..) => {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1191,7 +1112,7 @@ impl Expression {\n \t\t\t\t\tpanic!(\"found cursor\");\n \t\t\t\t}\n \t\t\t}\n-\t\t\tSelf::ParenthesizedExpression(expr, _, _) => {\n+\t\t\tSelf::ParenthesizedExpression(expr, _) => {\n \t\t\t\tbuf.push('(');\n \t\t\t\texpr.to_string_from_buffer(buf, settings, depth);\n \t\t\t\tbuf.push(')');\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1227,7 +1148,7 @@ impl Expression {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\tSelf::ArrayLiteral(values, _, _) => {\n+\t\t\tSelf::ArrayLiteral(values, _) => {\n \t\t\t\tto_string_bracketed(values, ('[', ']'), buf, settings, depth);\n \t\t\t}\n \t\t\tSelf::JSXRoot(root) => root.to_string_from_buffer(buf, settings, depth),\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1240,8 +1161,8 @@ impl Expression {\n \t\t\tSelf::ExpressionFunction(function) => {\n \t\t\t\tfunction.to_string_from_buffer(buf, settings, depth);\n \t\t\t}\n-\t\t\tSelf::ClassExpression(class, _) => class.to_string_from_buffer(buf, settings, depth),\n-\t\t\tSelf::PrefixComment(comment, expression, _, _) => {\n+\t\t\tSelf::ClassExpression(class) => class.to_string_from_buffer(buf, settings, depth),\n+\t\t\tSelf::PrefixComment(comment, expression, _) => {\n \t\t\t\tif settings.should_add_comment() {\n \t\t\t\t\tbuf.push_str(\"/*\");\n \t\t\t\t\tbuf.push_str_contains_new_line(comment.as_str());\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1249,7 +1170,7 @@ impl Expression {\n \t\t\t\t}\n \t\t\t\texpression.to_string_from_buffer(buf, settings, depth);\n \t\t\t}\n-\t\t\tSelf::PostfixComment(expression, comment, _, _) => {\n+\t\t\tSelf::PostfixComment(expression, comment, _) => {\n \t\t\t\texpression.to_string_from_buffer(buf, settings, depth);\n \t\t\t\tif settings.should_add_comment() {\n \t\t\t\t\tbuf.push_str(\" /*\");\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1276,7 +1197,7 @@ impl Expression {\n \t\t\t}\n \t\t\tSelf::Null(..) => buf.push_str(\"null\"),\n \t\t\tSelf::IsExpression(is_expr) => is_expr.to_string_from_buffer(buf, settings, depth),\n-\t\t\tSelf::SuperExpression(super_expr, _, _) => {\n+\t\t\tSelf::SuperExpression(super_expr, _) => {\n \t\t\t\tbuf.push_str(\"super\");\n \t\t\t\tmatch super_expr {\n \t\t\t\t\tSuperReference::Call { arguments } => {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1327,7 +1248,7 @@ impl ASTNode for MultipleExpression {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet first = Expression::from_reader(reader, state, settings)?;\n \t\tlet mut top: MultipleExpression = first.into();\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1342,12 +1263,12 @@ impl ASTNode for MultipleExpression {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tif let Some(ref lhs) = self.lhs {\n-\t\t\tbuf.push(',');\n \t\t\tlhs.to_string_from_buffer(buf, settings, depth);\n+\t\t\tbuf.push(',');\n \t\t}\n \t\tself.rhs.to_string_from_buffer(buf, settings, depth);\n \t}\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1410,26 +1331,26 @@ fn is_generic_arguments(reader: &mut impl TokenReader<TSXToken, Span>) -> bool {\n \n /// Binary operations whose RHS are types rather than [Expression]s\n #[derive(PartialEqExtras, Debug, Clone, Visitable)]\n-#[partial_eq_ignore_types(Span, ExpressionId)]\n+#[partial_eq_ignore_types(Span)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum SpecialOperators {\n \t/// TS Only\n \tAsExpression {\n \t\tvalue: Box<Expression>,\n \t\tas_keyword: Keyword<As>,\n-\t\ttype_annotation: Box<TypeReference>,\n+\t\ttype_annotation: Box<TypeAnnotation>,\n \t},\n \t/// TS Only\n \tSatisfiesExpression {\n \t\tvalue: Box<Expression>,\n \t\tsatisfies_keyword: Keyword<Satisfies>,\n-\t\ttype_annotation: Box<TypeReference>,\n+\t\ttype_annotation: Box<TypeAnnotation>,\n \t},\n \t#[cfg(feature = \"extras\")]\n \tIsExpression {\n \t\tvalue: Box<Expression>,\n \t\tis_keyword: Keyword<Is>,\n-\t\ttype_annotation: Box<TypeReference>,\n+\t\ttype_annotation: Box<TypeAnnotation>,\n \t},\n }\n \ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1454,7 +1375,7 @@ impl ASTNode for SpreadExpression {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet peek = &reader.peek().ok_or_else(parse_lexing_error)?.0;\n \t\tmatch peek {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1474,7 +1395,7 @@ impl ASTNode for SpreadExpression {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1491,16 +1412,6 @@ impl ASTNode for SpreadExpression {\n }\n \n impl SpreadExpression {\n-\t/// TODO Remover for get_inner_expression\n-\tpub fn get_expression_id(&self) -> Option<ExpressionId> {\n-\t\tmatch self {\n-\t\t\tSpreadExpression::Spread(expression, _) | SpreadExpression::NonSpread(expression) => {\n-\t\t\t\texpression.get_expression_id()\n-\t\t\t}\n-\t\t\t_ => panic!(),\n-\t\t}\n-\t}\n-\n \t/// Only for walking\n \tfn _get_inner_expression_ref(&self) -> &Expression {\n \t\tmatch self {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1520,45 +1431,6 @@ impl From<Expression> for SpreadExpression {\n \n // Utils for Expression\n impl Expression {\n-\tpub fn get_expression_id(&self) -> Option<ExpressionId> {\n-\t\tmatch self {\n-\t\t\tSelf::NumberLiteral(.., id)\n-\t\t\t| Self::StringLiteral(.., id)\n-\t\t\t| Self::BooleanLiteral(.., id)\n-\t\t\t| Self::RegexLiteral { id, .. }\n-\t\t\t| Self::ArrayLiteral(_, _, id)\n-\t\t\t| Self::ParenthesizedExpression(_, _, id)\n-\t\t\t| Self::BinaryOperation { id, .. }\n-\t\t\t| Self::Assignment { id, .. }\n-\t\t\t| Self::BinaryAssignmentOperation { id, .. }\n-\t\t\t| Self::UnaryOperation { id, .. }\n-\t\t\t| Self::UnaryPrefixAssignmentOperation { id, .. }\n-\t\t\t| Self::UnaryPostfixAssignmentOperation { id, .. }\n-\t\t\t| Self::VariableReference(_, _, id)\n-\t\t\t| Self::FunctionCall { expression_id: id, .. }\n-\t\t\t| Self::ConstructorCall { expression_id: id, .. }\n-\t\t\t| Self::Index { expression_id: id, .. }\n-\t\t\t| Self::TernaryExpression { id, .. }\n-\t\t\t| Self::Null(_, id)\n-\t\t\t| Self::SuperExpression(_, _, id)\n-\t\t\t| Self::ThisReference(_, id)\n-\t\t\t| Self::NewTarget(_, id)\n-\t\t\t| Self::TemplateLiteral(TemplateLiteral { expression_id: id, .. })\n-\t\t\t| Self::DynamicImport { expression_id: id, .. }\n-\t\t\t| Self::ClassExpression(_, id)\n-\t\t\t| Self::PrefixComment(_, _, _, id)\n-\t\t\t| Self::PostfixComment(_, _, _, id)\n-\t\t\t| Self::Cursor { expression_id: id, .. }\n-\t\t\t| Self::SpecialOperators(_, _, id)\n-\t\t\t| Self::PropertyAccess { expression_id: id, .. } => Some(*id),\n-\t\t\tSelf::JSXRoot(root) => Some(root.get_expression_id()),\n-\t\t\tSelf::ObjectLiteral(object_literal) => Some(object_literal.get_expression_id()),\n-\t\t\tSelf::IsExpression(is_expr) => Some(is_expr.expression_id),\n-\t\t\tSelf::Comment(..) => None,\n-\t\t\tSelf::ExpressionFunction(..) | Self::ArrowFunction(..) => None,\n-\t\t}\n-\t}\n-\n \t/// IIFE = immediate invoked function execution\n \tpub fn build_iife(block: Block) -> Self {\n \t\tlet position = block.get_position().into_owned();\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1571,7 +1443,6 @@ impl Expression {\n \t\t\t\t\t\tname: (),\n \t\t\t\t\t\tparameters: crate::FunctionParameters {\n \t\t\t\t\t\t\tparameters: Default::default(),\n-\t\t\t\t\t\t\toptional_parameters: Default::default(),\n \t\t\t\t\t\t\trest_parameter: Default::default(),\n \t\t\t\t\t\t\tposition: position.clone(),\n \t\t\t\t\t\t},\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1583,19 +1454,17 @@ impl Expression {\n \t\t\t\t\t.into(),\n \t\t\t\t),\n \t\t\t\tposition.clone(),\n-\t\t\t\tExpressionId::new(),\n \t\t\t)\n \t\t\t.into(),\n \t\t\ttype_arguments: None,\n \t\t\targuments: Vec::new(),\n \t\t\tposition,\n-\t\t\texpression_id: ExpressionId::new(),\n \t\t}\n \t}\n \n \tpub fn is_iife(&self) -> Option<&ExpressionOrBlock> {\n \t\tif let Expression::FunctionCall { arguments, function, .. } = self {\n-\t\t\tif let (true, Expression::ParenthesizedExpression(expression, _, _)) =\n+\t\t\tif let (true, Expression::ParenthesizedExpression(expression, _)) =\n \t\t\t\t(arguments.is_empty(), &**function)\n \t\t\t{\n \t\t\t\tif let MultipleExpression { lhs: None, rhs: Expression::ArrowFunction(function) } =\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1610,7 +1479,7 @@ impl Expression {\n \n \t/// Recurses to find first non parenthesized expression\n \tpub fn get_non_parenthesized(&self) -> &Self {\n-\t\tif let Expression::ParenthesizedExpression(inner_multiple_expr, _, _) = self {\n+\t\tif let Expression::ParenthesizedExpression(inner_multiple_expr, _) = self {\n \t\t\tif inner_multiple_expr.lhs.is_none() {\n \t\t\t\tinner_multiple_expr.rhs.get_non_parenthesized()\n \t\t\t} else {\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1642,7 +1511,7 @@ impl Expression {\n \n /// \"super\" cannot be used alone\n #[derive(PartialEqExtras, Debug, Clone, Visitable)]\n-#[partial_eq_ignore_types(Span, ExpressionId)]\n+#[partial_eq_ignore_types(Span)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum SuperReference {\n \tCall { arguments: Vec<SpreadExpression> },\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -3,11 +3,10 @@ use iterator_endiate::EndiateIteratorExt;\n use std::{borrow::Cow, fmt::Debug, mem};\n use visitable_derive::Visitable;\n \n-use super::ExpressionId;\n use crate::{\n-\terrors::parse_lexing_error, functions::FunctionBased, property_key::PropertyId, ASTNode, Block,\n-\tExpression, FunctionBase, GetSetGeneratorOrNone, ParseError, ParseErrors, ParseResult,\n-\tParseSettings, PropertyKey, Span, TSXToken, Token, TokenReader, WithComment,\n+\terrors::parse_lexing_error, functions::FunctionBased, ASTNode, Block, Expression, FunctionBase,\n+\tGetSetGeneratorOrNone, ParseError, ParseErrors, ParseOptions, ParseResult, PropertyKey, Span,\n+\tTSXToken, Token, TokenReader, WithComment,\n };\n \n #[derive(Debug, Clone, Eq, PartialEq, Visitable)]\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -15,7 +14,6 @@ use crate::{\n pub struct ObjectLiteral {\n \tpub members: Vec<ObjectLiteralMember>,\n \tpub position: Span,\n-\tpub expression_id: ExpressionId,\n }\n \n #[derive(Debug, Clone, PartialEqExtras)]\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -23,7 +21,7 @@ pub struct ObjectLiteral {\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum ObjectLiteralMember {\n \tSpreadExpression(Expression, Span),\n-\tShorthand(String, Span, ExpressionId, PropertyId),\n+\tShorthand(String, Span),\n \tProperty(WithComment<PropertyKey>, Expression, Span),\n \tMethod(ObjectLiteralMethod),\n }\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -38,7 +36,7 @@ impl crate::Visitable for ObjectLiteralMember {\n \t) {\n \t\tmatch self {\n \t\t\tObjectLiteralMember::SpreadExpression(_, _) => {}\n-\t\t\tObjectLiteralMember::Shorthand(_, _, _, _) => {}\n+\t\t\tObjectLiteralMember::Shorthand(_, _) => {}\n \t\t\tObjectLiteralMember::Property(_, _, _) => {}\n \t\t\tObjectLiteralMember::Method(method) => method.visit(visitors, data, settings, chain),\n \t\t}\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -53,7 +51,7 @@ impl crate::Visitable for ObjectLiteralMember {\n \t) {\n \t\tmatch self {\n \t\t\tObjectLiteralMember::SpreadExpression(_, _) => {}\n-\t\t\tObjectLiteralMember::Shorthand(_, _, _, _) => {}\n+\t\t\tObjectLiteralMember::Shorthand(_, _) => {}\n \t\t\tObjectLiteralMember::Property(_, _, _) => {}\n \t\t\tObjectLiteralMember::Method(method) => {\n \t\t\t\tmethod.visit_mut(visitors, data, settings, chain)\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -71,14 +69,14 @@ impl FunctionBased for ObjectLiteralMethodBase {\n \ttype Name = WithComment<PropertyKey>;\n \ttype Body = Block;\n \n-\tfn get_chain_variable(_this: &FunctionBase<Self>) -> crate::ChainVariable {\n-\t\tcrate::ChainVariable::UnderObjectLiteralMethod\n-\t}\n+\t// fn get_chain_variable(_this: &FunctionBase<Self>) -> crate::ChainVariable {\n+\t// \tcrate::ChainVariable::UnderObjectLiteralMethod\n+\t// }\n \n \tfn header_and_name_from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<(Self::Header, Self::Name)> {\n \t\tOk((\n \t\t\tGetSetGeneratorOrNone::from_reader(reader),\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -90,7 +88,7 @@ impl FunctionBased for ObjectLiteralMethodBase {\n \t\tbuf: &mut T,\n \t\theader: &Self::Header,\n \t\tname: &Self::Name,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\theader.to_string_from_buffer(buf);\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -112,7 +110,7 @@ impl ASTNode for ObjectLiteral {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet start = reader.expect_next(TSXToken::OpenBrace)?;\n \t\tSelf::from_reader_sub_open_curly(reader, state, settings, start)\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -121,7 +119,7 @@ impl ASTNode for ObjectLiteral {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push('{');\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -142,7 +140,7 @@ impl ObjectLiteral {\n \tpub(crate) fn from_reader_sub_open_curly(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\tstart_span: Span,\n \t) -> ParseResult<Self> {\n \t\tlet mut members: Vec<ObjectLiteralMember> = Vec::new();\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -158,15 +156,7 @@ impl ObjectLiteral {\n \t\t\t}\n \t\t}\n \t\tlet end_span = reader.expect_next(TSXToken::CloseBrace)?;\n-\t\tOk(ObjectLiteral {\n-\t\t\tmembers,\n-\t\t\tposition: start_span.union(&end_span),\n-\t\t\texpression_id: ExpressionId::new(),\n-\t\t})\n-\t}\n-\n-\tpub fn get_expression_id(&self) -> ExpressionId {\n-\t\tself.expression_id\n+\t\tOk(ObjectLiteral { members, position: start_span.union(&end_span) })\n \t}\n }\n \ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -174,7 +164,7 @@ impl ASTNode for ObjectLiteralMember {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\t// TODO this probably needs with comment here:\n \t\tlet mut get_set_generator_or_none = GetSetGeneratorOrNone::from_reader(reader);\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -193,7 +183,7 @@ impl ASTNode for ObjectLiteralMember {\n \t\t\t\tGetSetGeneratorOrNone::Set(kw) => (\"set\", kw.1),\n \t\t\t\t_ => unreachable!(),\n \t\t\t};\n-\t\t\tWithComment::None(PropertyKey::Ident(name.to_owned(), PropertyId::new(), position))\n+\t\t\tWithComment::None(PropertyKey::Ident(name.to_owned(), position))\n \t\t} else {\n \t\t\tWithComment::<PropertyKey>::from_reader(reader, state, settings)?\n \t\t};\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -224,8 +214,8 @@ impl ASTNode for ObjectLiteralMember {\n \t\t\t\t}\n \t\t\t\tif matches!(reader.peek(), Some(Token(TSXToken::Comma | TSXToken::CloseBrace, _))) {\n \t\t\t\t\t// TODO fix\n-\t\t\t\t\tif let PropertyKey::Ident(name, _, position) = key.unwrap_ast() {\n-\t\t\t\t\t\tOk(Self::Shorthand(name, position, ExpressionId::new(), PropertyId::new()))\n+\t\t\t\t\tif let PropertyKey::Ident(name, position) = key.unwrap_ast() {\n+\t\t\t\t\t\tOk(Self::Shorthand(name, position))\n \t\t\t\t\t} else {\n \t\t\t\t\t\ttodo!()\n \t\t\t\t\t}\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -242,7 +232,7 @@ impl ASTNode for ObjectLiteralMember {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/expressions/object_literal.rs b/parser/src/expressions/object_literal.rs\n--- a/parser/src/expressions/object_literal.rs\n+++ b/parser/src/expressions/object_literal.rs\n@@ -268,7 +258,7 @@ impl ASTNode for ObjectLiteralMember {\n \tfn get_position(&self) -> Cow<Span> {\n \t\tmatch self {\n \t\t\tSelf::Method(..) => todo!(),\n-\t\t\tSelf::Shorthand(_, pos, _, _)\n+\t\t\tSelf::Shorthand(_, pos)\n \t\t\t| Self::Property(_, _, pos)\n \t\t\t| Self::SpreadExpression(_, pos) => Cow::Borrowed(pos),\n \t\t}\ndiff --git a/parser/src/expressions/template_literal.rs b/parser/src/expressions/template_literal.rs\n--- a/parser/src/expressions/template_literal.rs\n+++ b/parser/src/expressions/template_literal.rs\n@@ -1,7 +1,7 @@\n use std::borrow::Cow;\n \n use crate::{\n-\terrors::parse_lexing_error, ASTNode, Expression, ParseResult, ParseSettings, Span, TSXToken,\n+\terrors::parse_lexing_error, ASTNode, Expression, ParseOptions, ParseResult, Span, TSXToken,\n \tToken, TokenReader,\n };\n use visitable_derive::Visitable;\ndiff --git a/parser/src/expressions/template_literal.rs b/parser/src/expressions/template_literal.rs\n--- a/parser/src/expressions/template_literal.rs\n+++ b/parser/src/expressions/template_literal.rs\n@@ -12,7 +12,6 @@ pub struct TemplateLiteral {\n \tpub tag: Option<Box<Expression>>,\n \tpub parts: Vec<TemplateLiteralPart<Expression>>,\n \tpub position: Span,\n-\tpub expression_id: super::ExpressionId,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\ndiff --git a/parser/src/expressions/template_literal.rs b/parser/src/expressions/template_literal.rs\n--- a/parser/src/expressions/template_literal.rs\n+++ b/parser/src/expressions/template_literal.rs\n@@ -78,7 +77,7 @@ impl ASTNode for TemplateLiteral {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet start_pos = reader.expect_next(TSXToken::TemplateLiteralStart)?;\n \t\tSelf::from_reader_sub_start_with_tag(reader, state, settings, None, start_pos)\ndiff --git a/parser/src/expressions/template_literal.rs b/parser/src/expressions/template_literal.rs\n--- a/parser/src/expressions/template_literal.rs\n+++ b/parser/src/expressions/template_literal.rs\n@@ -87,7 +86,7 @@ impl ASTNode for TemplateLiteral {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tif let Some(tag) = &self.tag {\ndiff --git a/parser/src/expressions/template_literal.rs b/parser/src/expressions/template_literal.rs\n--- a/parser/src/expressions/template_literal.rs\n+++ b/parser/src/expressions/template_literal.rs\n@@ -114,7 +113,7 @@ impl TemplateLiteral {\n \tpub(crate) fn from_reader_sub_start_with_tag(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\ttag: Option<Box<Expression>>,\n \t\tstart_position: Span,\n \t) -> ParseResult<Self> {\ndiff --git a/parser/src/expressions/template_literal.rs b/parser/src/expressions/template_literal.rs\n--- a/parser/src/expressions/template_literal.rs\n+++ b/parser/src/expressions/template_literal.rs\n@@ -130,12 +129,7 @@ impl TemplateLiteral {\n \t\t\t\t\tparts.push(TemplateLiteralPart::Dynamic(Box::new(expression)));\n \t\t\t\t}\n \t\t\t\tToken(TSXToken::TemplateLiteralEnd, end_position) => {\n-\t\t\t\t\treturn Ok(Self {\n-\t\t\t\t\t\tparts,\n-\t\t\t\t\t\ttag,\n-\t\t\t\t\t\tposition: start_position.union(&end_position),\n-\t\t\t\t\t\texpression_id: super::ExpressionId::new(),\n-\t\t\t\t\t});\n+\t\t\t\t\treturn Ok(Self { parts, tag, position: start_position.union(&end_position) });\n \t\t\t\t}\n \t\t\t\t_ => unreachable!(),\n \t\t\t}\ndiff --git a/parser/src/extensions/decorators.rs b/parser/src/extensions/decorators.rs\n--- a/parser/src/extensions/decorators.rs\n+++ b/parser/src/extensions/decorators.rs\n@@ -6,7 +6,7 @@ use tokenizer_lib::{Token, TokenReader};\n use visitable_derive::Visitable;\n \n use crate::{\n-\ttokens::token_as_identifier, ASTNode, Expression, ParseResult, ParseSettings, TSXToken,\n+\ttokens::token_as_identifier, ASTNode, Expression, ParseOptions, ParseResult, TSXToken,\n \tVisitable,\n };\n \ndiff --git a/parser/src/extensions/decorators.rs b/parser/src/extensions/decorators.rs\n--- a/parser/src/extensions/decorators.rs\n+++ b/parser/src/extensions/decorators.rs\n@@ -26,7 +26,7 @@ impl ASTNode for Decorator {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet at_pos = reader.expect_next(TSXToken::At)?;\n \t\tSelf::from_reader_sub_at_symbol(reader, state, settings, at_pos)\ndiff --git a/parser/src/extensions/decorators.rs b/parser/src/extensions/decorators.rs\n--- a/parser/src/extensions/decorators.rs\n+++ b/parser/src/extensions/decorators.rs\n@@ -35,7 +35,7 @@ impl ASTNode for Decorator {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tif settings.include_decorators {\ndiff --git a/parser/src/extensions/decorators.rs b/parser/src/extensions/decorators.rs\n--- a/parser/src/extensions/decorators.rs\n+++ b/parser/src/extensions/decorators.rs\n@@ -60,7 +60,7 @@ impl Decorator {\n \tpub(crate) fn from_reader_sub_at_symbol(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\tat_pos: Span,\n \t) -> ParseResult<Self> {\n \t\tlet (name, name_position) = token_as_identifier(reader.next().unwrap(), \"Decorator name\")?;\ndiff --git a/parser/src/extensions/decorators.rs b/parser/src/extensions/decorators.rs\n--- a/parser/src/extensions/decorators.rs\n+++ b/parser/src/extensions/decorators.rs\n@@ -106,7 +106,7 @@ impl<N: ASTNode> ASTNode for Decorated<N> {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet decorators = decorators_from_reader(reader, state, settings)?;\n \t\tN::from_reader(reader, state, settings).map(|on| Self { on, decorators })\ndiff --git a/parser/src/extensions/decorators.rs b/parser/src/extensions/decorators.rs\n--- a/parser/src/extensions/decorators.rs\n+++ b/parser/src/extensions/decorators.rs\n@@ -115,7 +115,7 @@ impl<N: ASTNode> ASTNode for Decorated<N> {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tself.to_string_from_buffer_just_decorators(buf, settings, depth);\ndiff --git a/parser/src/extensions/decorators.rs b/parser/src/extensions/decorators.rs\n--- a/parser/src/extensions/decorators.rs\n+++ b/parser/src/extensions/decorators.rs\n@@ -131,7 +131,7 @@ impl<U> Decorated<U> {\n \tpub(crate) fn to_string_from_buffer_just_decorators<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tif settings.include_decorators {\ndiff --git a/parser/src/extensions/decorators.rs b/parser/src/extensions/decorators.rs\n--- a/parser/src/extensions/decorators.rs\n+++ b/parser/src/extensions/decorators.rs\n@@ -150,7 +150,7 @@ impl<U> Decorated<U> {\n pub(crate) fn decorators_from_reader(\n \treader: &mut impl TokenReader<TSXToken, Span>,\n \tstate: &mut crate::ParsingState,\n-\tsettings: &ParseSettings,\n+\tsettings: &ParseOptions,\n ) -> ParseResult<Vec<Decorator>> {\n \tlet mut decorators = Vec::new();\n \twhile let Some(Token(TSXToken::At, _)) = reader.peek() {\ndiff --git a/parser/src/extensions/is_expression.rs b/parser/src/extensions/is_expression.rs\n--- a/parser/src/extensions/is_expression.rs\n+++ b/parser/src/extensions/is_expression.rs\n@@ -8,16 +8,15 @@ use visitable_derive::Visitable;\n \n use crate::{\n \terrors::parse_lexing_error,\n-\texpressions::{ExpressionId, ExpressionOrBlock, MultipleExpression},\n-\tASTNode, Keyword, TypeReference,\n+\texpressions::{ExpressionOrBlock, MultipleExpression},\n+\tASTNode, Keyword, TypeAnnotation,\n };\n \n #[derive(Debug, PartialEq, Eq, Clone, Visitable)]\n pub struct IsExpression {\n \tpub is: Keyword<Is>,\n \tpub matcher: Box<MultipleExpression>,\n-\tpub branches: Vec<(TypeReference, ExpressionOrBlock)>,\n-\tpub expression_id: ExpressionId,\n+\tpub branches: Vec<(TypeAnnotation, ExpressionOrBlock)>,\n \tpub position: Span,\n }\n \ndiff --git a/parser/src/extensions/is_expression.rs b/parser/src/extensions/is_expression.rs\n--- a/parser/src/extensions/is_expression.rs\n+++ b/parser/src/extensions/is_expression.rs\n@@ -39,7 +38,7 @@ impl ASTNode for IsExpression {\n \tfn from_reader(\n \t\treader: &mut impl tokenizer_lib::TokenReader<crate::TSXToken, source_map::Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t) -> crate::ParseResult<Self> {\n \t\tlet span = reader.expect_next(TSXToken::Keyword(TSXKeyword::Is))?;\n \t\tlet is = Keyword::new(span);\ndiff --git a/parser/src/extensions/is_expression.rs b/parser/src/extensions/is_expression.rs\n--- a/parser/src/extensions/is_expression.rs\n+++ b/parser/src/extensions/is_expression.rs\n@@ -49,7 +48,7 @@ impl ASTNode for IsExpression {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(\"is (\");\ndiff --git a/parser/src/extensions/is_expression.rs b/parser/src/extensions/is_expression.rs\n--- a/parser/src/extensions/is_expression.rs\n+++ b/parser/src/extensions/is_expression.rs\n@@ -70,7 +69,7 @@ impl ASTNode for IsExpression {\n pub(crate) fn is_expression_from_reader_sub_is_keyword(\n \treader: &mut impl TokenReader<TSXToken, source_map::Span>,\n \tstate: &mut crate::ParsingState,\n-\tsettings: &crate::ParseSettings,\n+\tsettings: &crate::ParseOptions,\n \tis: Keyword<Is>,\n ) -> Result<IsExpression, crate::ParseError> {\n \treader.expect_next(TSXToken::OpenParentheses)?;\ndiff --git a/parser/src/extensions/is_expression.rs b/parser/src/extensions/is_expression.rs\n--- a/parser/src/extensions/is_expression.rs\n+++ b/parser/src/extensions/is_expression.rs\n@@ -79,18 +78,17 @@ pub(crate) fn is_expression_from_reader_sub_is_keyword(\n \treader.expect_next(TSXToken::OpenBrace)?;\n \tlet mut branches = Vec::new();\n \tloop {\n-\t\tlet type_reference = TypeReference::from_reader(reader, state, settings)?;\n+\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n \t\treader.expect_next(TSXToken::Arrow)?;\n \t\tlet body = ExpressionOrBlock::from_reader(reader, state, settings)?;\n \t\tlet tokenizer_lib::Token(next, pos) = reader.next().ok_or_else(parse_lexing_error)?;\n-\t\tbranches.push((type_reference, body));\n+\t\tbranches.push((type_annotation, body));\n \t\tif next == TSXToken::CloseBrace {\n \t\t\treturn Ok(IsExpression {\n \t\t\t\tposition: is.1.union(&pos),\n \t\t\t\tis,\n \t\t\t\tmatcher: Box::new(matcher),\n \t\t\t\tbranches,\n-\t\t\t\texpression_id: ExpressionId::new(),\n \t\t\t});\n \t\t} else if next != TSXToken::Comma {\n \t\t\ttodo!(\"Error\")\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -1,7 +1,7 @@\n use std::borrow::Cow;\n \n use crate::{\n-\terrors::parse_lexing_error, ASTNode, Expression, ParseError, ParseResult, ParseSettings, Span,\n+\terrors::parse_lexing_error, ASTNode, Expression, ParseError, ParseOptions, ParseResult, Span,\n \tTSXToken, Token, TokenReader,\n };\n use visitable_derive::Visitable;\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -18,7 +18,6 @@ pub enum JSXRoot {\n pub struct JSXFragment {\n \tpub children: Vec<JSXNode>,\n \tpub position: Span,\n-\tpub expression_id: crate::expressions::ExpressionId,\n }\n \n impl ASTNode for JSXFragment {\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -29,7 +28,7 @@ impl ASTNode for JSXFragment {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet start_pos = reader.expect_next(TSXToken::JSXFragmentStart)?;\n \t\tSelf::from_reader_sub_start(reader, state, settings, start_pos)\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -38,7 +37,7 @@ impl ASTNode for JSXFragment {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(\"<>\");\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -51,16 +50,12 @@ impl JSXFragment {\n \tfn from_reader_sub_start(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\tstart_pos: Span,\n \t) -> ParseResult<Self> {\n \t\tlet children = parse_jsx_children(reader, state, settings)?;\n \t\tlet end_pos = reader.expect_next(TSXToken::JSXFragmentEnd)?;\n-\t\tOk(Self {\n-\t\t\tchildren,\n-\t\t\tposition: start_pos.union(&end_pos),\n-\t\t\texpression_id: crate::expressions::ExpressionId::new(),\n-\t\t})\n+\t\tOk(Self { children, position: start_pos.union(&end_pos) })\n \t}\n }\n \ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -68,7 +63,7 @@ impl ASTNode for JSXRoot {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet (is_fragment, span) = match reader.next().ok_or_else(parse_lexing_error)? {\n \t\t\tToken(TSXToken::JSXOpeningTagStart, span) => (false, span),\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -81,7 +76,7 @@ impl ASTNode for JSXRoot {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -101,7 +96,7 @@ impl ASTNode for JSXRoot {\n fn parse_jsx_children(\n \treader: &mut impl TokenReader<TSXToken, Span>,\n \tstate: &mut crate::ParsingState,\n-\tsettings: &ParseSettings,\n+\tsettings: &ParseOptions,\n ) -> Result<Vec<JSXNode>, ParseError> {\n \tlet mut children = Vec::new();\n \tloop {\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -135,7 +130,7 @@ fn parse_jsx_children(\n fn jsx_children_to_string<T: source_map::ToString>(\n \tchildren: &[JSXNode],\n \tbuf: &mut T,\n-\tsettings: &crate::ToStringSettings,\n+\tsettings: &crate::ToStringOptions,\n \tdepth: u8,\n ) {\n \tfor node in children.iter() {\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -154,7 +149,7 @@ impl JSXRoot {\n \tpub(crate) fn from_reader_sub_start(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\tis_fragment: bool,\n \t\tstart_position: Span,\n \t) -> ParseResult<Self> {\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -174,13 +169,6 @@ impl JSXRoot {\n \t\t\t)?))\n \t\t}\n \t}\n-\n-\tpub fn get_expression_id(&self) -> crate::expressions::ExpressionId {\n-\t\tmatch self {\n-\t\t\tJSXRoot::Element(element) => element.expression_id,\n-\t\t\tJSXRoot::Fragment(fragment) => fragment.expression_id,\n-\t\t}\n-\t}\n }\n \n // TODO Fragment\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -207,7 +195,7 @@ impl ASTNode for JSXNode {\n \tfn from_reader(\n \t\t_reader: &mut impl TokenReader<TSXToken, Span>,\n \t\t_state: &mut crate::ParsingState,\n-\t\t_settings: &ParseSettings,\n+\t\t_settings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\ttodo!()\n \t}\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -215,7 +203,7 @@ impl ASTNode for JSXNode {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -269,9 +257,6 @@ pub struct JSXElement {\n \tpub tag_name: String,\n \tpub attributes: Vec<JSXAttribute>,\n \tpub children: JSXElementChildren,\n-\t/// Used for getting the type of the element, (e.g. HTMLElement, HTMLButton) for\n-\t/// the expression cache\n-\tpub expression_id: crate::expressions::ExpressionId,\n \tpub position: Span,\n }\n \ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -285,7 +270,7 @@ impl ASTNode for JSXElement {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet start_position = reader.expect_next(TSXToken::JSXOpeningTagStart)?;\n \t\tSelf::from_reader_sub_start(reader, state, settings, start_position)\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -294,7 +279,7 @@ impl ASTNode for JSXElement {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push('<');\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -341,7 +326,7 @@ impl ASTNode for JSXAttribute {\n \tfn from_reader(\n \t\t_reader: &mut impl TokenReader<TSXToken, Span>,\n \t\t_state: &mut crate::ParsingState,\n-\t\t_settings: &ParseSettings,\n+\t\t_settings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\ttodo!()\n \t}\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -349,7 +334,7 @@ impl ASTNode for JSXAttribute {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -385,7 +370,7 @@ impl JSXElement {\n \tpub(crate) fn from_reader_sub_start(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\tmut start_position: Span,\n \t) -> ParseResult<Self> {\n \t\tlet tag_name = if let Some(Token(TSXToken::JSXTagName(tag_name), _)) = reader.next() {\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -406,7 +391,6 @@ impl JSXElement {\n \t\t\t\t\t\ttag_name,\n \t\t\t\t\t\tattributes,\n \t\t\t\t\t\tchildren: JSXElementChildren::SelfClosing,\n-\t\t\t\t\t\texpression_id: crate::expressions::ExpressionId::new(),\n \t\t\t\t\t\tposition: start_position.union(&position),\n \t\t\t\t\t});\n \t\t\t\t}\ndiff --git a/parser/src/extensions/jsx.rs b/parser/src/extensions/jsx.rs\n--- a/parser/src/extensions/jsx.rs\n+++ b/parser/src/extensions/jsx.rs\n@@ -475,7 +459,6 @@ impl JSXElement {\n \t\t\ttag_name,\n \t\t\tattributes,\n \t\t\tchildren: JSXElementChildren::Children(children),\n-\t\t\texpression_id: crate::expressions::ExpressionId::new(),\n \t\t\tposition: start_position,\n \t\t})\n \t}\ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -6,9 +6,9 @@ use std::{\n };\n \n use crate::{\n-\tparameters::*, parse_bracketed, to_string_bracketed, ASTNode, Block, ChainVariable,\n-\tExpressionOrStatementPosition, ExpressionPosition, GenericTypeConstraint, Keyword, ParseResult,\n-\tParseSettings, TSXToken, TypeReference, VisitSettings, Visitable,\n+\tparameters::*, parse_bracketed, to_string_bracketed, ASTNode, Block,\n+\tExpressionOrStatementPosition, ExpressionPosition, GenericTypeConstraint, Keyword,\n+\tParseOptions, ParseResult, TSXToken, TypeAnnotation, VisitSettings, Visitable,\n };\n use crate::{tsx_keywords, TSXKeyword};\n use derive_debug_extras::DebugExtras;\ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -59,21 +59,19 @@ pub trait FunctionBased: Debug + Clone + PartialEq + Eq + Send + Sync {\n \t/// The body of the function\n \ttype Body: ASTNode;\n \n-\tfn get_chain_variable(this: &FunctionBase<Self>) -> ChainVariable;\n-\n \tfn header_left(header: &Self::Header) -> Option<Cow<Span>>;\n \n \tfn header_and_name_from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<(Self::Header, Self::Name)>;\n \n \tfn header_and_name_to_string_from_buffer<T: ToString>(\n \t\tbuf: &mut T,\n \t\theader: &Self::Header,\n \t\tname: &Self::Name,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t);\n \ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -86,7 +84,7 @@ pub trait FunctionBased: Debug + Clone + PartialEq + Eq + Send + Sync {\n \tfn parameters_from_reader<T: ToString>(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<FunctionParameters> {\n \t\tFunctionParameters::from_reader(reader, state, settings)\n \t}\ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -95,7 +93,7 @@ pub trait FunctionBased: Debug + Clone + PartialEq + Eq + Send + Sync {\n \tfn parameters_to_string_from_buffer<T: ToString>(\n \t\tbuf: &mut T,\n \t\tparameters: &FunctionParameters,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tparameters.to_string_from_buffer(buf, settings, depth);\ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -104,7 +102,7 @@ pub trait FunctionBased: Debug + Clone + PartialEq + Eq + Send + Sync {\n \t/// For [crate::ArrowFunction]\n \tfn parameter_body_boundary_token_to_string_from_buffer<T: ToString>(\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t) {\n \t\tsettings.add_gap(buf);\n \t}\ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -122,7 +120,7 @@ pub struct FunctionBase<T: FunctionBased> {\n \tpub name: T::Name,\n \tpub type_parameters: Option<Vec<GenericTypeConstraint>>,\n \tpub parameters: FunctionParameters,\n-\tpub return_type: Option<TypeReference>,\n+\tpub return_type: Option<TypeAnnotation>,\n \tpub body: T::Body,\n }\n \ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -142,7 +140,7 @@ impl<T: FunctionBased + 'static> ASTNode for FunctionBase<T> {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet (header, name) = T::header_and_name_from_reader(reader, state, settings)?;\n \t\tSelf::from_reader_with_header_and_name(reader, state, settings, header, name)\ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -151,7 +149,7 @@ impl<T: FunctionBased + 'static> ASTNode for FunctionBase<T> {\n \tfn to_string_from_buffer<TS: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut TS,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tT::header_and_name_to_string_from_buffer(buf, &self.header, &self.name, settings, depth);\ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -181,7 +179,7 @@ impl<T: FunctionBased> FunctionBase<T> {\n \tpub(crate) fn from_reader_with_header_and_name(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\theader: T::Header,\n \t\tname: T::Name,\n \t) -> ParseResult<Self> {\ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -197,7 +195,7 @@ impl<T: FunctionBased> FunctionBase<T> {\n \t\tlet return_type = reader\n \t\t\t.conditional_next(|tok| matches!(tok, TSXToken::Colon))\n \t\t\t.is_some()\n-\t\t\t.then(|| TypeReference::from_reader(reader, state, settings))\n+\t\t\t.then(|| TypeAnnotation::from_reader(reader, state, settings))\n \t\t\t.transpose()?;\n \n \t\tif let Some(token) = T::get_parameter_body_boundary_token() {\ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -264,18 +262,18 @@ impl<T: ExpressionOrStatementPosition> FunctionBased for GeneralFunctionBase<T>\n \ttype Header = FunctionHeader;\n \ttype Name = T::Name;\n \n-\tfn get_chain_variable(_this: &FunctionBase<Self>) -> crate::ChainVariable {\n-\t\ttodo!()\n-\t\t// crate::ChainVariable::UnderExpressionFunctionBlock(self.base.body.1, self.expression_id)\n-\t}\n+\t// fn get_chain_variable(_this: &FunctionBase<Self>) -> crate::ChainVariable {\n+\t// \ttodo!()\n+\t// \t// crate::ChainVariable::UnderExpressionFunctionBlock(self.base.body.1, self.expression_id)\n+\t// }\n \n \tfn header_and_name_from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t) -> ParseResult<(Self::Header, Self::Name)> {\n \t\tlet header = FunctionHeader::from_reader(reader, state, settings)?;\n-\t\tlet (name, _) = T::from_reader(reader, state, settings)?;\n+\t\tlet name = T::from_reader(reader, state, settings)?;\n \t\tOk((header, name))\n \t}\n \ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -283,7 +281,7 @@ impl<T: ExpressionOrStatementPosition> FunctionBased for GeneralFunctionBase<T>\n \t\tbuf: &mut U,\n \t\theader: &Self::Header,\n \t\tname: &Self::Name,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\theader.to_string_from_buffer(buf, settings, depth);\ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -351,7 +349,7 @@ impl ASTNode for FunctionHeader {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\t_state: &mut crate::ParsingState,\n-\t\t_settings: &ParseSettings,\n+\t\t_settings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet async_keyword = reader\n \t\t\t.conditional_next(|tok| matches!(tok, TSXToken::Keyword(TSXKeyword::Async)))\ndiff --git a/parser/src/functions.rs b/parser/src/functions.rs\n--- a/parser/src/functions.rs\n+++ b/parser/src/functions.rs\n@@ -382,7 +380,7 @@ impl ASTNode for FunctionHeader {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\t_settings: &crate::ToStringSettings,\n+\t\t_settings: &crate::ToStringOptions,\n \t\t_depth: u8,\n \t) {\n \t\tif self.is_async() {\ndiff --git a/parser/src/generator_helpers.rs b/parser/src/generator_helpers.rs\n--- a/parser/src/generator_helpers.rs\n+++ b/parser/src/generator_helpers.rs\n@@ -1,5 +1,4 @@\n-use crate::expressions::ExpressionId;\n-use crate::{ASTNode, Expression, PropertyReference, Statement, VariableId, VariableIdentifier};\n+use crate::{ASTNode, Expression, PropertyReference, Statement, VariableIdentifier};\n \n use source_map::Span;\n \ndiff --git a/parser/src/generator_helpers.rs b/parser/src/generator_helpers.rs\n--- a/parser/src/generator_helpers.rs\n+++ b/parser/src/generator_helpers.rs\n@@ -18,18 +17,13 @@ pub struct Ident<'a>(&'a str);\n \n impl<'a> IntoAST<Expression> for Ident<'a> {\n \tfn into_ast(self) -> Expression {\n-\t\tExpression::VariableReference(self.0.to_owned(), Span::NULL_SPAN, ExpressionId::new())\n+\t\tExpression::VariableReference(self.0.to_owned(), Span::NULL_SPAN)\n \t}\n }\n \n impl<'a> IntoAST<Expression> for &'a str {\n \tfn into_ast(self) -> Expression {\n-\t\tExpression::StringLiteral(\n-\t\t\tself.to_owned(),\n-\t\t\tcrate::Quoted::Double,\n-\t\t\tSpan::NULL_SPAN,\n-\t\t\tExpressionId::new(),\n-\t\t)\n+\t\tExpression::StringLiteral(self.to_owned(), crate::Quoted::Double, Span::NULL_SPAN)\n \t}\n }\n \ndiff --git a/parser/src/generator_helpers.rs b/parser/src/generator_helpers.rs\n--- a/parser/src/generator_helpers.rs\n+++ b/parser/src/generator_helpers.rs\n@@ -41,27 +35,19 @@ impl<'a> IntoAST<PropertyReference> for &'a str {\n \n impl<'a> IntoAST<VariableIdentifier> for &'a str {\n \tfn into_ast(self) -> VariableIdentifier {\n-\t\tVariableIdentifier::Standard(self.to_owned(), VariableId::new(), Span::NULL_SPAN)\n+\t\tVariableIdentifier::Standard(self.to_owned(), Span::NULL_SPAN)\n \t}\n }\n \n impl IntoAST<Expression> for usize {\n \tfn into_ast(self) -> Expression {\n-\t\tExpression::NumberLiteral(\n-\t\t\tcrate::NumberStructure::Number(self as f64),\n-\t\t\tSpan::NULL_SPAN,\n-\t\t\tExpressionId::new(),\n-\t\t)\n+\t\tExpression::NumberLiteral(crate::NumberStructure::Number(self as f64), Span::NULL_SPAN)\n \t}\n }\n \n impl IntoAST<Expression> for f64 {\n \tfn into_ast(self) -> Expression {\n-\t\tExpression::NumberLiteral(\n-\t\t\tcrate::NumberStructure::Number(self),\n-\t\t\tSpan::NULL_SPAN,\n-\t\t\tExpressionId::new(),\n-\t\t)\n+\t\tExpression::NumberLiteral(crate::NumberStructure::Number(self), Span::NULL_SPAN)\n \t}\n }\n \ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -44,11 +44,11 @@ pub fn lex_source(\n \tscript: &str,\n \tsender: &mut impl TokenSender<TSXToken, Span>,\n \tsettings: &LexSettings,\n-\tsource_id: Option<SourceId>,\n+\tsource: Option<SourceId>,\n \toffset: Option<usize>,\n \tmut cursors: Vec<(usize, EmptyCursorId)>,\n ) -> Result<(), ParseError> {\n-\tlet source_id = source_id.unwrap_or(SourceId::NULL);\n+\tlet source = source.unwrap_or(SourceId::NULL);\n \n \tcursors.reverse();\n \ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -118,8 +118,11 @@ pub fn lex_source(\n \t\t// Literals:\n \t\tNumber {\n \t\t\tliteral_type: NumberLiteralType,\n-\t\t\t// For binary, hex, etc `0b0121`\n+\t\t\t/// For binary, hex, etc `0b0121`\n \t\t\tlast_character_zero: bool,\n+\t\t\t/// Past and `e` or `E`\n+\t\t\tpast_exponential: bool,\n+\t\t\tlast_was_underscore: bool,\n \t\t},\n \t\tString {\n \t\t\tdouble_quoted: bool,\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -170,11 +173,7 @@ pub fn lex_source(\n \t/// TODO not sure about this, maybe shouldn't return span\n \tmacro_rules! current_position {\n \t\t() => {\n-\t\t\tSpan {\n-\t\t\t\tstart: start as u32 + offset as u32,\n-\t\t\t\tend: start as u32 + offset as u32,\n-\t\t\t\tsource_id,\n-\t\t\t}\n+\t\t\tSpan { start: start as u32 + offset as u32, end: start as u32 + offset as u32, source }\n \t\t};\n \t}\n \ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -215,7 +214,7 @@ pub fn lex_source(\n \t\t\t\t\tSpan {\n \t\t\t\t\t\tstart: (start + offset) as u32,\n \t\t\t\t\t\tend: (idx + offset + chr.len_utf8()) as u32,\n-\t\t\t\t\t\tsource_id,\n+\t\t\t\t\t\tsource,\n \t\t\t\t\t},\n \t\t\t\t));\n \t\t\t\tif !res {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -226,7 +225,7 @@ pub fn lex_source(\n \t\t\t(EXCLUDING_LAST_CHAR, $t:expr $(,)?) => {{\n \t\t\t\tlet res = sender.push(Token(\n \t\t\t\t\t$t,\n-\t\t\t\t\tSpan { start: (start + offset) as u32, end: (idx + offset) as u32, source_id },\n+\t\t\t\t\tSpan { start: (start + offset) as u32, end: (idx + offset) as u32, source },\n \t\t\t\t));\n \t\t\t\tif !res {\n \t\t\t\t\treturn Ok(());\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -239,7 +238,7 @@ pub fn lex_source(\n \t\t\t\t\tSpan {\n \t\t\t\t\t\tstart: (start + offset) as u32,\n \t\t\t\t\t\tend: (idx + offset - $slice.len_utf8()) as u32,\n-\t\t\t\t\t\tsource_id,\n+\t\t\t\t\t\tsource,\n \t\t\t\t\t},\n \t\t\t\t));\n \t\t\t\tif !res {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -253,7 +252,7 @@ pub fn lex_source(\n \t\t\t\t\tSpan {\n \t\t\t\t\t\tstart: (idx + offset) as u32,\n \t\t\t\t\t\tend: (idx + offset + chr.len_utf8()) as u32,\n-\t\t\t\t\t\tsource_id,\n+\t\t\t\t\t\tsource,\n \t\t\t\t\t},\n \t\t\t\t));\n \t\t\t\tif !res {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -263,13 +262,20 @@ pub fn lex_source(\n \t\t}\n \n \t\tmatch state {\n-\t\t\tLexingState::Number { ref mut literal_type, ref mut last_character_zero } => {\n+\t\t\tLexingState::Number {\n+\t\t\t\tref mut literal_type,\n+\t\t\t\tref mut last_character_zero,\n+\t\t\t\tref mut past_exponential,\n+\t\t\t\tref mut last_was_underscore,\n+\t\t\t} => {\n \t\t\t\tmatch chr {\n \t\t\t\t\t'0' => {\n \t\t\t\t\t\t*last_character_zero = true;\n+\t\t\t\t\t\t*last_was_underscore = false;\n \t\t\t\t\t}\n \t\t\t\t\t'1'..='9' => {\n \t\t\t\t\t\t*last_character_zero = false;\n+\t\t\t\t\t\t*last_was_underscore = false;\n \t\t\t\t\t}\n \t\t\t\t\t'.' => {\n \t\t\t\t\t\tif let NumberLiteralType::Decimal { fractional } = literal_type {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -306,11 +312,17 @@ pub fn lex_source(\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\t'e' => {\n-\t\t\t\t\t\tunimplemented!();\n+\t\t\t\t\t'e' | 'E' => {\n+\t\t\t\t\t\tif *past_exponential {\n+\t\t\t\t\t\t\ttodo!()\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t*past_exponential = true;\n \t\t\t\t\t}\n \t\t\t\t\t'_' => {\n-\t\t\t\t\t\tunimplemented!();\n+\t\t\t\t\t\tif *last_was_underscore {\n+\t\t\t\t\t\t\ttodo!()\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t*last_was_underscore = true;\n \t\t\t\t\t}\n \t\t\t\t\t_ => {\n \t\t\t\t\t\tpush_token!(\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -358,7 +370,7 @@ pub fn lex_source(\n \t\t\t\t}\n \t\t\t}\n \t\t\tLexingState::Identifier => match chr {\n-\t\t\t\t'A'..='Z' | 'a'..='z' | '0'..='9' | '_' => {}\n+\t\t\t\t'A'..='Z' | 'a'..='z' | '0'..='9' | '_' | '$' => {}\n \t\t\t\t_ => {\n \t\t\t\t\tlet token = TSXToken::from_slice(&script[start..idx]);\n \t\t\t\t\tlet is_expression_prefix = token.is_expression_prefix();\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -466,7 +478,7 @@ pub fn lex_source(\n \t\t\t\t\t\t\tSpan {\n \t\t\t\t\t\t\t\tstart: (start + offset) as u32,\n \t\t\t\t\t\t\t\tend: (idx + offset) as u32,\n-\t\t\t\t\t\t\t\tsource_id,\n+\t\t\t\t\t\t\t\tsource,\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t));\n \t\t\t\t\t}\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -913,11 +925,15 @@ pub fn lex_source(\n \t\t\tmatch chr {\n \t\t\t\t'0' => set_state!(LexingState::Number {\n \t\t\t\t\tliteral_type: Default::default(),\n-\t\t\t\t\tlast_character_zero: true\n+\t\t\t\t\tlast_character_zero: true,\n+\t\t\t\t\tlast_was_underscore: false,\n+\t\t\t\t\tpast_exponential: false\n \t\t\t\t}),\n \t\t\t\t'1'..='9' => set_state!(LexingState::Number {\n \t\t\t\t\tliteral_type: Default::default(),\n-\t\t\t\t\tlast_character_zero: false\n+\t\t\t\t\tlast_character_zero: false,\n+\t\t\t\t\tlast_was_underscore: false,\n+\t\t\t\t\tpast_exponential: false\n \t\t\t\t}),\n \t\t\t\t'\"' => set_state!(LexingState::String { double_quoted: true, escaped: false }),\n \t\t\t\t'\\'' => set_state!(LexingState::String { double_quoted: false, escaped: false }),\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -1042,13 +1058,13 @@ pub fn lex_source(\n \t\tLexingState::Number { .. } => {\n \t\t\tsender.push(Token(\n \t\t\t\tTSXToken::NumberLiteral(script[start..].to_owned()),\n-\t\t\t\tSpan { start: (start + offset) as u32, end: end_of_source, source_id },\n+\t\t\t\tSpan { start: (start + offset) as u32, end: end_of_source, source },\n \t\t\t));\n \t\t}\n \t\tLexingState::Identifier => {\n \t\t\tsender.push(Token(\n \t\t\t\tTSXToken::from_slice(&script[start..]),\n-\t\t\t\tSpan { start: (start + offset) as u32, end: end_of_source, source_id },\n+\t\t\t\tSpan { start: (start + offset) as u32, end: end_of_source, source },\n \t\t\t));\n \t\t}\n \t\tLexingState::Symbol(symbol_state) => {\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -1061,7 +1077,7 @@ pub fn lex_source(\n \t\t\t\t} => {\n \t\t\t\t\tsender.push(Token(\n \t\t\t\t\t\tresult,\n-\t\t\t\t\t\tSpan { start: (start + offset) as u32, end: end_of_source, source_id },\n+\t\t\t\t\t\tSpan { start: (start + offset) as u32, end: end_of_source, source },\n \t\t\t\t\t));\n \t\t\t\t}\n \t\t\t\tGetNextResult::NewState(_new_state) => unreachable!(),\ndiff --git a/parser/src/lexer.rs b/parser/src/lexer.rs\n--- a/parser/src/lexer.rs\n+++ b/parser/src/lexer.rs\n@@ -1076,7 +1092,7 @@ pub fn lex_source(\n \t\tLexingState::Comment => {\n \t\t\tsender.push(Token(\n \t\t\t\tTSXToken::Comment(script[(start + 2)..].trim_end().to_owned()),\n-\t\t\t\tSpan { start: (start + offset) as u32, end: end_of_source, source_id },\n+\t\t\t\tSpan { start: (start + offset) as u32, end: end_of_source, source },\n \t\t\t));\n \t\t}\n \t\tLexingState::MultiLineComment { .. } => {\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -23,9 +23,7 @@ mod visiting;\n #[doc(hidden)]\n pub mod lexer;\n \n-pub use block::{\n-\tBlock, BlockId, BlockLike, BlockLikeMut, BlockOrSingleStatement, StatementOrDeclaration,\n-};\n+pub use block::{Block, BlockLike, BlockLikeMut, BlockOrSingleStatement, StatementOrDeclaration};\n pub use comments::WithComment;\n pub use cursor::{CursorId, EmptyCursorId};\n pub use declarations::Declaration;\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -42,20 +40,15 @@ pub use generator_helpers::IntoAST;\n use iterator_endiate::EndiateIteratorExt;\n pub use lexer::{lex_source, LexSettings};\n pub use modules::{FromFileError, Module, TypeDefinitionModule, TypeDefinitionModuleDeclaration};\n-pub use parameters::{\n-\tFunctionParameters, OptionalOrWithDefaultValueParameter, Parameter, SpreadParameter,\n-};\n-pub use property_key::{PropertyId, PropertyKey};\n+pub use parameters::{FunctionParameters, Parameter, SpreadParameter};\n+pub use property_key::PropertyKey;\n pub use source_map::{self, SourceId, Span};\n pub use statements::Statement;\n use temporary_annex::Annex;\n pub use tokens::{tsx_keywords, TSXKeyword, TSXToken};\n pub use types::{\n-\ttype_declarations,\n-\ttype_declarations::{GenericTypeConstraint, TypeDeclaration},\n-\ttype_references,\n-\ttype_references::TypeReference,\n-\tTypeId,\n+\ttype_annotations::{self, TypeAnnotation},\n+\ttype_declarations::{self, GenericTypeConstraint, TypeDeclaration},\n };\n pub use variable_fields::*;\n pub use visiting::*;\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -84,7 +77,7 @@ impl Quoted {\n /// Settings to customize parsing\n #[allow(unused)]\n #[derive(Clone)]\n-pub struct ParseSettings {\n+pub struct ParseOptions {\n \t/// Parsing of [JSX](https://facebook.github.io/jsx/) (includes some additions)\n \tpub jsx: bool,\n \tpub decorators: bool,\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -97,7 +90,7 @@ pub struct ParseSettings {\n }\n \n // TODO not sure about some of these defaults, may change in future\n-impl Default for ParseSettings {\n+impl Default for ParseOptions {\n \tfn default() -> Self {\n \t\tSelf {\n \t\t\tjsx: true,\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -111,7 +104,7 @@ impl Default for ParseSettings {\n }\n \n /// Settings for serializing ASTNodes\n-pub struct ToStringSettings {\n+pub struct ToStringOptions {\n \t/// Does not include whitespace minification\n \tpub pretty: bool,\n \t/// Include type annotation syntax\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -125,9 +118,9 @@ pub struct ToStringSettings {\n \tpub expect_cursors: bool,\n }\n \n-impl Default for ToStringSettings {\n+impl Default for ToStringOptions {\n \tfn default() -> Self {\n-\t\tToStringSettings {\n+\t\tToStringOptions {\n \t\t\tpretty: true,\n \t\t\tinclude_types: false,\n \t\t\tinclude_decorators: false,\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -139,9 +132,9 @@ impl Default for ToStringSettings {\n \t}\n }\n \n-impl ToStringSettings {\n+impl ToStringOptions {\n \tpub fn minified() -> Self {\n-\t\tToStringSettings {\n+\t\tToStringOptions {\n \t\t\tpretty: false,\n \t\t\tinclude_comments: false,\n \t\t\tindent_with: \"\".to_owned(),\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -151,7 +144,7 @@ impl ToStringSettings {\n \n \t/// With typescript type syntax\n \tpub fn typescript() -> Self {\n-\t\tToStringSettings { include_types: true, ..Default::default() }\n+\t\tToStringOptions { include_types: true, ..Default::default() }\n \t}\n \n \t/// Whether to include comment in source\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -179,8 +172,8 @@ pub trait ASTNode: Sized + Clone + PartialEq + std::fmt::Debug + Sync + Send + '\n \t#[cfg(target_arch = \"wasm32\")]\n \tfn from_string(\n \t\tstring: String,\n-\t\tsettings: ParseSettings,\n-\t\tsource_id: SourceId,\n+\t\tsettings: ParseOptions,\n+\t\tsource: SourceId,\n \t\toffset: Option<usize>,\n \t\tcursors: Vec<(usize, EmptyCursorId)>,\n \t) -> ParseResult<Self> {\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -190,7 +183,7 @@ pub trait ASTNode: Sized + Clone + PartialEq + std::fmt::Debug + Sync + Send + '\n \t\t\t..Default::default()\n \t\t};\n \t\tlet mut queue = tokenizer_lib::BufferedTokenQueue::new();\n-\t\tlexer::lex_source(&string, &mut queue, &lex_settings, Some(source_id), offset, cursors)?;\n+\t\tlexer::lex_source(&string, &mut queue, &lex_settings, Some(source), offset, cursors)?;\n \n \t\tlet mut state = ParsingState::default();\n \t\tlet res = Self::from_reader(&mut queue, &mut state, &settings);\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -204,11 +197,12 @@ pub trait ASTNode: Sized + Clone + PartialEq + std::fmt::Debug + Sync + Send + '\n \t#[cfg(not(target_arch = \"wasm32\"))]\n \tfn from_string(\n \t\tsource: String,\n-\t\tsettings: ParseSettings,\n+\t\tsettings: ParseOptions,\n \t\tsource_id: SourceId,\n \t\toffset: Option<usize>,\n \t\tcursors: Vec<(usize, EmptyCursorId)>,\n \t) -> ParseResult<Self> {\n+\t\tuse source_map::LineStarts;\n \t\tuse std::thread;\n \t\tuse tokenizer_lib::ParallelTokenQueue;\n \ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -217,9 +211,12 @@ pub trait ASTNode: Sized + Clone + PartialEq + std::fmt::Debug + Sync + Send + '\n \t\t\tlex_jsx: settings.jsx,\n \t\t\t..Default::default()\n \t\t};\n+\n+\t\tlet line_starts = LineStarts::new(source.as_str());\n+\n \t\tlet (mut sender, mut reader) = ParallelTokenQueue::new();\n \t\tlet parsing_thread = thread::spawn(move || {\n-\t\t\tlet mut state = ParsingState::default();\n+\t\t\tlet mut state = ParsingState { line_starts };\n \t\t\tlet res = Self::from_reader(&mut reader, &mut state, &settings);\n \t\t\tif res.is_ok() {\n \t\t\t\treader.expect_next(TSXToken::EOS)?;\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -239,27 +236,28 @@ pub trait ASTNode: Sized + Clone + PartialEq + std::fmt::Debug + Sync + Send + '\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self>;\n \n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t);\n \n \t/// Returns structure as valid string\n-\tfn to_string(&self, settings: &crate::ToStringSettings) -> String {\n+\tfn to_string(&self, settings: &crate::ToStringOptions) -> String {\n \t\tlet mut buf = String::new();\n \t\tself.to_string_from_buffer(&mut buf, settings, 0);\n \t\tbuf\n \t}\n }\n \n-/// TODO local identifiers\n-#[derive(Default, Debug)]\n-pub struct ParsingState {}\n+#[derive(Debug)]\n+pub struct ParsingState {\n+\tpub(crate) line_starts: source_map::LineStarts,\n+}\n \n /// A keyword\n #[derive(Debug, PartialEq, Eq, Clone)]\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -391,7 +389,7 @@ impl From<f64> for NumberStructure {\n }\n \n impl FromStr for NumberStructure {\n-\ttype Err = ();\n+\ttype Err = String;\n \n \t// TODO separators\n \tfn from_str(s: &str) -> Result<Self, Self::Err> {\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -406,17 +404,57 @@ impl FromStr for NumberStructure {\n \t\tif let Some(s) = s.strip_prefix('0') {\n \t\t\tlet next_char = s.chars().next();\n \t\t\tmatch next_char {\n-\t\t\t\tSome('.') => Ok(Self::Number(sign.apply(s.parse().map_err(|_| ())?))),\n-\t\t\t\t// TODO this is broken, needs to hex decoding etc\n-\t\t\t\tSome('X' | 'x') => Ok(Self::Hex(sign, s[2..].parse().map_err(|_| ())?)),\n-\t\t\t\tSome('b' | 'B') => Ok(Self::Bin(sign, s[2..].parse().map_err(|_| ())?)),\n-\t\t\t\tSome('o' | 'O') => Ok(Self::Octal(sign, s[2..].parse().map_err(|_| ())?)),\n-\t\t\t\tSome(_) => Ok(Self::Octal(sign, s[1..].parse().map_err(|_| ())?)),\n-\n+\t\t\t\tSome('.') => Ok(Self::Number(sign.apply(s.parse().map_err(|_| s.to_owned())?))),\n+\t\t\t\tSome('X' | 'x') => {\n+\t\t\t\t\tlet mut number = 0u64;\n+\t\t\t\t\tfor c in s[2..].as_bytes().iter().rev() {\n+\t\t\t\t\t\tnumber <<= 4; // 16=2^4\n+\t\t\t\t\t\tmatch c {\n+\t\t\t\t\t\t\tb'0'..=b'9' => {\n+\t\t\t\t\t\t\t\tnumber += (c - b'0') as u64;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tb'a'..=b'f' => {\n+\t\t\t\t\t\t\t\tnumber += (c - b'a') as u64 + 10;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tb'A'..=b'F' => {\n+\t\t\t\t\t\t\t\tnumber += (c - b'A') as u64 + 10;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t_ => return Err(s.to_owned()),\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tOk(Self::Hex(sign, number))\n+\t\t\t\t}\n+\t\t\t\tSome('b' | 'B') => {\n+\t\t\t\t\tlet mut number = 0u64;\n+\t\t\t\t\tfor c in s[2..].as_bytes().iter().rev() {\n+\t\t\t\t\t\tnumber <<= 1;\n+\t\t\t\t\t\tmatch c {\n+\t\t\t\t\t\t\tb'0' | b'1' => {\n+\t\t\t\t\t\t\t\tnumber += (c - b'0') as u64;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t_ => return Err(s.to_owned()),\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tOk(Self::Bin(sign, number))\n+\t\t\t\t}\n+\t\t\t\t// 'o' | 'O' but can also be missed\n+\t\t\t\tSome(c) => {\n+\t\t\t\t\tlet start = if matches!(c, 'o' | 'O') { 2 } else { 1 };\n+\t\t\t\t\tlet mut number = 0u64;\n+\t\t\t\t\tfor c in s[start..].as_bytes().iter().rev() {\n+\t\t\t\t\t\tnumber <<= 3; // 8=2^3\n+\t\t\t\t\t\tif matches!(c, b'0'..=b'7') {\n+\t\t\t\t\t\t\tnumber += (c - b'0') as u64;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\treturn Err(s.to_owned());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tOk(Self::Octal(sign, number))\n+\t\t\t\t}\n \t\t\t\tNone => Ok(Self::Number(0.)),\n \t\t\t}\n \t\t} else {\n-\t\t\tOk(Self::Number(sign.apply(s.parse().map_err(|_| ())?)))\n+\t\t\tOk(Self::Number(sign.apply(s.parse().map_err(|_| s.to_owned())?)))\n \t\t}\n \t}\n }\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -524,8 +562,8 @@ pub trait ExpressionOrStatementPosition:\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n-\t) -> ParseResult<(Self::Name, Option<Vec<GenericTypeConstraint>>)>;\n+\t\tsettings: &ParseOptions,\n+\t) -> ParseResult<Self::Name>;\n \n \tfn as_option_str(name: &Self::Name) -> Option<&str>;\n \tfn as_option_string_mut(name: &mut Self::Name) -> Option<&mut String>;\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -540,17 +578,9 @@ impl ExpressionOrStatementPosition for StatementPosition {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n-\t) -> ParseResult<(Self::Name, Option<Vec<GenericTypeConstraint>>)> {\n-\t\tlet type_declaration = TypeDeclaration::from_reader(reader, state, settings)?;\n-\t\tOk((\n-\t\t\tVariableIdentifier::Standard(\n-\t\t\t\ttype_declaration.name,\n-\t\t\t\tVariableId::new(),\n-\t\t\t\ttype_declaration.position,\n-\t\t\t),\n-\t\t\ttype_declaration.type_parameters,\n-\t\t))\n+\t\tsettings: &ParseOptions,\n+\t) -> ParseResult<Self::Name> {\n+\t\tVariableIdentifier::from_reader(reader, state, settings)\n \t}\n \n \tfn as_option_str(name: &Self::Name) -> Option<&str> {\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -579,13 +609,12 @@ impl ExpressionOrStatementPosition for ExpressionPosition {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n-\t) -> ParseResult<(Self::Name, Option<Vec<GenericTypeConstraint>>)> {\n-\t\tif let Token(TSXToken::OpenBrace, _) = reader.peek().unwrap() {\n-\t\t\tOk((None, None))\n+\t\tsettings: &ParseOptions,\n+\t) -> ParseResult<Self::Name> {\n+\t\tif let Some(Token(TSXToken::OpenBrace, _)) | None = reader.peek() {\n+\t\t\tOk(None)\n \t\t} else {\n-\t\t\tStatementPosition::from_reader(reader, state, settings)\n-\t\t\t\t.map(|(name, constraints)| (Some(name), constraints))\n+\t\t\tStatementPosition::from_reader(reader, state, settings).map(Some)\n \t\t}\n \t}\n \ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -602,7 +631,7 @@ impl ExpressionOrStatementPosition for ExpressionPosition {\n pub(crate) fn parse_bracketed<T: ASTNode>(\n \treader: &mut impl TokenReader<TSXToken, Span>,\n \tstate: &mut crate::ParsingState,\n-\tsettings: &ParseSettings,\n+\tsettings: &ParseOptions,\n \tstart: Option<TSXToken>,\n \tend: TSXToken,\n ) -> ParseResult<(Vec<T>, Span)> {\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -636,7 +665,7 @@ pub(crate) fn to_string_bracketed<T: source_map::ToString, U: ASTNode>(\n \tnodes: &[U],\n \tbrackets: (char, char),\n \tbuf: &mut T,\n-\tsettings: &crate::ToStringSettings,\n+\tsettings: &crate::ToStringOptions,\n \tdepth: u8,\n ) {\n \tbuf.push(brackets.0);\ndiff --git a/parser/src/lib.rs b/parser/src/lib.rs\n--- a/parser/src/lib.rs\n+++ b/parser/src/lib.rs\n@@ -651,20 +680,33 @@ pub(crate) fn to_string_bracketed<T: source_map::ToString, U: ASTNode>(\n }\n \n /// Part of [ASI](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#automatic_semicolon_insertion)\n-pub(crate) fn expect_semi_colon(reader: &mut impl TokenReader<TSXToken, Span>) -> ParseResult<()> {\n-\tif let Some(Token(TSXToken::CloseBrace, _)) = reader.peek() {\n-\t\treturn Ok(());\n+pub(crate) fn expect_semi_colon(\n+\treader: &mut impl TokenReader<TSXToken, Span>,\n+\tline_starts: &source_map::LineStarts,\n+\tprev: u32,\n+) -> ParseResult<()> {\n+\tif let Some(token) = reader.peek() {\n+\t\tlet Token(kind, Span { start: next, .. }) = token;\n+\t\t// eprintln!(\"{:?} {:?} {:?}\", prev, next, line_starts);\n+\t\tif let TSXToken::CloseBrace | TSXToken::EOS = kind {\n+\t\t\tOk(())\n+\t\t} else if !matches!(kind, TSXToken::SemiColon)\n+\t\t\t&& line_starts.byte_indexes_on_different_lines(prev as usize, *next as usize)\n+\t\t{\n+\t\t\tOk(())\n+\t\t} else {\n+\t\t\treader.expect_next(TSXToken::SemiColon).map(|_| ()).map_err(Into::into)\n+\t\t}\n+\t} else {\n+\t\tOk(())\n \t}\n-\treader.expect_next(TSXToken::SemiColon)?;\n-\tOk(())\n }\n \n /// Re-exports or generator and general use\n pub mod ast {\n \tpub use crate::{\n \t\tdeclarations::*, expressions::*, extensions::jsx::*, statements::*, Keyword,\n-\t\tNumberStructure, StatementOrDeclaration, VariableField, VariableId, VariableIdentifier,\n-\t\tWithComment,\n+\t\tNumberStructure, StatementOrDeclaration, VariableField, VariableIdentifier, WithComment,\n \t};\n \n \tpub use self::assignments::{LHSOfAssignment, VariableOrPropertyAccess};\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -1,6 +1,5 @@\n use derive_enum_from_into::EnumFrom;\n use source_map::SourceId;\n-use temporary_annex::Annex;\n \n use crate::{\n \tblock::{parse_statements_and_declarations, statements_and_declarations_to_string},\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -14,8 +13,8 @@ use crate::{\n \t\ttype_alias::TypeAlias,\n \t\tInterfaceDeclaration,\n \t},\n-\tBlockId, BlockLike, BlockLikeMut, Chain, ChainVariable, Decorated, Decorator, ParseResult,\n-\tParseSettings, ParsingState, StatementOrDeclaration, TSXKeyword, VisitSettings, Visitable,\n+\tBlockLike, BlockLikeMut, Decorated, Decorator, ParseOptions, ParseResult, ParsingState,\n+\tStatementOrDeclaration, TSXKeyword, VisitSettings,\n };\n \n use super::{lexer, ASTNode, EmptyCursorId, ParseError, Span, TSXToken, Token, TokenReader};\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -33,8 +32,7 @@ pub enum FromFileError {\n #[derive(Debug, Clone)]\n pub struct Module {\n \tpub items: Vec<StatementOrDeclaration>,\n-\tpub block_id: BlockId,\n-\tpub source_id: SourceId,\n+\tpub source: SourceId,\n }\n \n impl PartialEq for Module {\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -47,7 +45,7 @@ impl ASTNode for Module {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tstatements_and_declarations_to_string(&self.items, buf, settings, depth)\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -66,15 +64,13 @@ impl ASTNode for Module {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n-\t\tparse_statements_and_declarations(reader, state, settings).map(|(statements, block_id)| {\n+\t\tparse_statements_and_declarations(reader, state, settings).map(|statements| {\n \t\t\t// TODO null bad\n-\t\t\tlet source_id = statements\n-\t\t\t\t.last()\n-\t\t\t\t.map(|stmt| stmt.get_position().source_id)\n-\t\t\t\t.unwrap_or(SourceId::NULL);\n-\t\t\tModule { source_id, items: statements, block_id }\n+\t\t\tlet source =\n+\t\t\t\tstatements.last().map(|stmt| stmt.get_position().source).unwrap_or(SourceId::NULL);\n+\t\t\tModule { source, items: statements }\n \t\t})\n \t}\n }\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -82,7 +78,7 @@ impl ASTNode for Module {\n impl Module {\n \tpub fn to_string_with_source_map(\n \t\t&self,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tfs: &impl source_map::FileSystem,\n \t) -> (String, source_map::SourceMap) {\n \t\tlet mut buf = source_map::StringWithSourceMap::new();\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -90,7 +86,7 @@ impl Module {\n \t\tbuf.build(fs)\n \t}\n \n-\tpub fn length(&self, settings: &crate::ToStringSettings) -> usize {\n+\tpub fn length(&self, settings: &crate::ToStringOptions) -> usize {\n \t\tlet mut buf = source_map::Counter::new();\n \t\tself.to_string_from_buffer(&mut buf, settings, 0);\n \t\tbuf.get_count()\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -99,7 +95,7 @@ impl Module {\n \t#[cfg(not(target_family = \"wasm\"))]\n \tpub fn from_file(\n \t\tpath: impl AsRef<Path>,\n-\t\tsettings: ParseSettings,\n+\t\tsettings: ParseOptions,\n \t\tcursors: Vec<(usize, EmptyCursorId)>,\n \t\tfs: &mut impl source_map::FileSystem,\n \t) -> Result<Self, FromFileError> {\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -116,18 +112,19 @@ impl Module {\n \t\tdata: &mut TData,\n \t\tsettings: &VisitSettings,\n \t) {\n-\t\tlet mut chain =\n-\t\t\tChain::new_with_initial(ChainVariable::UnderModule(self.block_id, self.source_id));\n+\t\tuse crate::visiting::Visitable;\n+\t\tlet mut chain = crate::Chain::new_with_initial(crate::ChainVariable::Module(self.source));\n+\t\tlet mut chain = temporary_annex::Annex::new(&mut chain);\n \n-\t\tlet mut chain = Annex::new(&mut chain);\n-\n-\t\tvisitors.visit_block(&crate::block::BlockLike::from(self), data, &chain);\n+\t\t{\n+\t\t\tvisitors.visit_block(&mut crate::block::BlockLike { items: &self.items }, data, &chain);\n+\t\t}\n \n \t\tlet iter = self.items.iter();\n \t\tif settings.reverse_statements {\n-\t\t\titer.rev().for_each(|item| item.visit(visitors, data, settings, &mut chain));\n-\t\t} else {\n \t\t\titer.for_each(|item| item.visit(visitors, data, settings, &mut chain));\n+\t\t} else {\n+\t\t\titer.rev().for_each(|item| item.visit(visitors, data, settings, &mut chain));\n \t\t}\n \t}\n \ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -137,14 +134,13 @@ impl Module {\n \t\tdata: &mut TData,\n \t\tsettings: &VisitSettings,\n \t) {\n-\t\tlet mut chain =\n-\t\t\tChain::new_with_initial(ChainVariable::UnderModule(self.block_id, self.source_id));\n-\n-\t\tlet mut chain = Annex::new(&mut chain);\n+\t\tuse crate::visiting::Visitable;\n+\t\tlet mut chain = crate::Chain::new_with_initial(crate::ChainVariable::Module(self.source));\n+\t\tlet mut chain = temporary_annex::Annex::new(&mut chain);\n \n \t\t{\n \t\t\tvisitors.visit_block_mut(\n-\t\t\t\t&mut crate::block::BlockLikeMut { block_id: self.block_id, items: &mut self.items },\n+\t\t\t\t&mut crate::block::BlockLikeMut { items: &mut self.items },\n \t\t\t\tdata,\n \t\t\t\t&chain,\n \t\t\t);\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -161,13 +157,13 @@ impl Module {\n \n impl<'a> From<&'a Module> for BlockLike<'a> {\n \tfn from(module: &'a Module) -> Self {\n-\t\tBlockLike { block_id: module.block_id, items: &module.items }\n+\t\tBlockLike { items: &module.items }\n \t}\n }\n \n impl<'a> From<&'a mut Module> for BlockLikeMut<'a> {\n \tfn from(module: &'a mut Module) -> Self {\n-\t\tBlockLikeMut { block_id: module.block_id, items: &mut module.items }\n+\t\tBlockLikeMut { items: &mut module.items }\n \t}\n }\n \ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -197,7 +193,7 @@ impl TypeDefinitionModule {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet mut declarations = Vec::new();\n \t\tloop {\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -224,8 +220,8 @@ impl TypeDefinitionModule {\n \t#[cfg(target_family = \"wasm\")]\n \tpub fn from_string(\n \t\tsource: String,\n-\t\tsettings: ParseSettings,\n-\t\tsource_id: SourceId,\n+\t\tsettings: ParseOptions,\n+\t\tsource: SourceId,\n \t\tcursors: Vec<(usize, EmptyCursorId)>,\n \t) -> ParseResult<(Self, ParsingState)> {\n \t\t// TODO this should be covered by settings\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -239,7 +235,7 @@ impl TypeDefinitionModule {\n \n \t\t// Extension which includes pulling in the string as source\n \t\tlet mut queue = tokenizer_lib::BufferedTokenQueue::new();\n-\t\tlexer::lex_source(&source, &mut queue, &lex_settings, Some(source_id), None, cursors)?;\n+\t\tlexer::lex_source(&source, &mut queue, &lex_settings, Some(source), None, cursors)?;\n \n \t\tlet mut state = ParsingState::default();\n \t\tlet res = Self::from_reader(&mut queue, &mut state, &settings);\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -253,17 +249,20 @@ impl TypeDefinitionModule {\n \t#[cfg(not(target_family = \"wasm\"))]\n \tpub fn from_string(\n \t\tsource: String,\n-\t\tsettings: ParseSettings,\n+\t\tsettings: ParseOptions,\n \t\tsource_id: SourceId,\n \t\tcursors: Vec<(usize, EmptyCursorId)>,\n \t) -> ParseResult<(Self, ParsingState)> {\n+\t\tuse source_map::LineStarts;\n \t\tuse std::thread;\n \t\tuse tokenizer_lib::ParallelTokenQueue;\n \n \t\t// Extension which includes pulling in the string as source\n \t\tlet (mut sender, mut reader) = ParallelTokenQueue::new();\n+\t\tlet line_starts = LineStarts::new(source.as_str());\n+\n \t\tlet parsing_thread = thread::spawn(move || {\n-\t\t\tlet mut state = ParsingState::default();\n+\t\t\tlet mut state = ParsingState { line_starts };\n \t\t\tlet res = Self::from_reader(&mut reader, &mut state, &settings);\n \t\t\tmatch res {\n \t\t\t\tOk(ast) => {\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -289,7 +288,7 @@ impl TypeDefinitionModule {\n \t#[cfg(not(target_family = \"wasm\"))]\n \tpub fn from_file(\n \t\tpath: impl AsRef<Path>,\n-\t\tsettings: ParseSettings,\n+\t\tsettings: ParseOptions,\n \t\tcursors: Vec<(usize, EmptyCursorId)>,\n \t\tfs: &mut impl source_map::FileSystem,\n \t) -> Result<(Self, ParsingState), FromFileError> {\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -303,7 +302,7 @@ impl ASTNode for TypeDefinitionModuleDeclaration {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet decorators = decorators_from_reader(reader, state, settings)?;\n \t\tmatch reader.peek().ok_or_else(parse_lexing_error)? {\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -357,7 +356,7 @@ impl ASTNode for TypeDefinitionModuleDeclaration {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\t_buf: &mut T,\n-\t\t_settings: &crate::ToStringSettings,\n+\t\t_settings: &crate::ToStringOptions,\n \t\t_depth: u8,\n \t) {\n \t\ttodo!(\"tdms to_string_from_buffer\");\ndiff --git a/parser/src/modules.rs b/parser/src/modules.rs\n--- a/parser/src/modules.rs\n+++ b/parser/src/modules.rs\n@@ -371,7 +370,7 @@ impl ASTNode for TypeDefinitionModuleDeclaration {\n pub(crate) fn parse_declare_item(\n \treader: &mut impl TokenReader<TSXToken, Span>,\n \tstate: &mut crate::ParsingState,\n-\tsettings: &ParseSettings,\n+\tsettings: &ParseOptions,\n \tdecorators: Vec<Decorator>,\n \tdeclare_span: Span,\n ) -> Result<TypeDefinitionModuleDeclaration, ParseError> {\ndiff --git a/parser/src/operators.rs b/parser/src/operators.rs\n--- a/parser/src/operators.rs\n+++ b/parser/src/operators.rs\n@@ -38,8 +38,8 @@ pub enum BinaryAssignmentOperator {\n     \n     AddAssign, SubtractAssign, MultiplyAssign, DivideAssign, ModuloAssign, ExponentAssign,\n     LogicalAndAssign, LogicalOrAssign,\n-    BitwiseShiftLeftAssign, BitwiseShiftRightAssign, BitwiseShiftRightUnsignedAssign, \n-    BitwiseAndAssign, BitwiseXOrAssign, BitOrAssign,\n+    BitwiseShiftLeftAssign, BitwiseShiftRightAssign, BitwiseShiftRightUnsigned, \n+    BitwiseAndAssign, BitwiseXorAssign, BitwiseOrAssign,\n }\n \n #[rustfmt::skip]\ndiff --git a/parser/src/operators.rs b/parser/src/operators.rs\n--- a/parser/src/operators.rs\n+++ b/parser/src/operators.rs\n@@ -238,10 +238,10 @@ impl Operator for BinaryAssignmentOperator {\n \t\t\tBinaryAssignmentOperator::ExponentAssign => \"**=\",\n \t\t\tBinaryAssignmentOperator::BitwiseShiftLeftAssign => \"<<=\",\n \t\t\tBinaryAssignmentOperator::BitwiseShiftRightAssign => \">>=\",\n-\t\t\tBinaryAssignmentOperator::BitwiseShiftRightUnsignedAssign => \">>>=\",\n+\t\t\tBinaryAssignmentOperator::BitwiseShiftRightUnsigned => \">>>=\",\n \t\t\tBinaryAssignmentOperator::BitwiseAndAssign => \"&=\",\n-\t\t\tBinaryAssignmentOperator::BitwiseXOrAssign => \"^=\",\n-\t\t\tBinaryAssignmentOperator::BitOrAssign => \"|=\",\n+\t\t\tBinaryAssignmentOperator::BitwiseXorAssign => \"^=\",\n+\t\t\tBinaryAssignmentOperator::BitwiseOrAssign => \"|=\",\n \t\t\tBinaryAssignmentOperator::LogicalAndAssign => \"&&=\",\n \t\t\tBinaryAssignmentOperator::LogicalOrAssign => \"||=\",\n \t\t}\ndiff --git a/parser/src/operators.rs b/parser/src/operators.rs\n--- a/parser/src/operators.rs\n+++ b/parser/src/operators.rs\n@@ -323,12 +323,12 @@ impl From<BinaryAssignmentOperator> for BinaryOperator {\n \t\t\tBinaryAssignmentOperator::LogicalOrAssign => BinaryOperator::LogicalOr,\n \t\t\tBinaryAssignmentOperator::BitwiseShiftLeftAssign => BinaryOperator::BitwiseShiftLeft,\n \t\t\tBinaryAssignmentOperator::BitwiseShiftRightAssign => BinaryOperator::BitwiseShiftRight,\n-\t\t\tBinaryAssignmentOperator::BitwiseShiftRightUnsignedAssign => {\n+\t\t\tBinaryAssignmentOperator::BitwiseShiftRightUnsigned => {\n \t\t\t\tBinaryOperator::BitwiseShiftRightUnsigned\n \t\t\t}\n \t\t\tBinaryAssignmentOperator::BitwiseAndAssign => BinaryOperator::BitwiseAnd,\n-\t\t\tBinaryAssignmentOperator::BitwiseXOrAssign => BinaryOperator::BitwiseXOr,\n-\t\t\tBinaryAssignmentOperator::BitOrAssign => BinaryOperator::BitwiseOr,\n+\t\t\tBinaryAssignmentOperator::BitwiseXorAssign => BinaryOperator::BitwiseXOr,\n+\t\t\tBinaryAssignmentOperator::BitwiseOrAssign => BinaryOperator::BitwiseOr,\n \t\t}\n \t}\n }\ndiff --git a/parser/src/operators.rs b/parser/src/operators.rs\n--- a/parser/src/operators.rs\n+++ b/parser/src/operators.rs\n@@ -345,8 +345,18 @@ impl TryFrom<&TSXToken> for BinaryAssignmentOperator {\n \t\t\tTSXToken::ExponentAssign => Ok(BinaryAssignmentOperator::ExponentAssign),\n \t\t\tTSXToken::LogicalAndAssign => Ok(BinaryAssignmentOperator::LogicalAndAssign),\n \t\t\tTSXToken::LogicalOrAssign => Ok(BinaryAssignmentOperator::LogicalOrAssign),\n-\t\t\tTSXToken::BitwiseOrAssign => Ok(BinaryAssignmentOperator::BitOrAssign),\n-\t\t\tTSXToken::BitwiseXorAssign => Ok(BinaryAssignmentOperator::BitwiseXOrAssign),\n+\t\t\tTSXToken::BitwiseAndAssign => Ok(BinaryAssignmentOperator::BitwiseAndAssign),\n+\t\t\tTSXToken::BitwiseOrAssign => Ok(BinaryAssignmentOperator::BitwiseOrAssign),\n+\t\t\tTSXToken::BitwiseXorAssign => Ok(BinaryAssignmentOperator::BitwiseXorAssign),\n+\t\t\tTSXToken::BitwiseShiftLeftAssign => {\n+\t\t\t\tOk(BinaryAssignmentOperator::BitwiseShiftLeftAssign)\n+\t\t\t}\n+\t\t\tTSXToken::BitwiseShiftRightAssign => {\n+\t\t\t\tOk(BinaryAssignmentOperator::BitwiseShiftRightAssign)\n+\t\t\t}\n+\t\t\tTSXToken::BitwiseShiftRightUnsigned => {\n+\t\t\t\tOk(BinaryAssignmentOperator::BitwiseShiftRightUnsigned)\n+\t\t\t}\n \t\t\tTSXToken::NullishCoalescingAssign => {\n \t\t\t\tOk(BinaryAssignmentOperator::LogicalNullishAssignment)\n \t\t\t}\ndiff --git a/parser/src/parameters.rs b/parser/src/parameters.rs\n--- a/parser/src/parameters.rs\n+++ b/parser/src/parameters.rs\n@@ -9,21 +9,22 @@ use visitable_derive::Visitable;\n \n use crate::{\n \terrors::parse_lexing_error, tokens::token_as_identifier, ASTNode, Expression, ParseError,\n-\tParseResult, TypeReference, VariableField, VariableFieldInSourceCode, VariableId,\n-\tVariableIdentifier, WithComment,\n+\tParseResult, TypeAnnotation, VariableField, VariableFieldInSourceCode, VariableIdentifier,\n+\tWithComment,\n };\n \n #[derive(Debug, Clone, Eq, PartialEq, Visitable)]\n pub struct Parameter {\n \tpub name: WithComment<VariableField<VariableFieldInSourceCode>>,\n-\tpub type_reference: Option<TypeReference>,\n+\tpub type_annotation: Option<TypeAnnotation>,\n+\tpub additionally: Option<ParameterData>,\n }\n \n // TODO not sure whether parameter should implement ASTNode\n impl Parameter {\n \tpub fn get_position(&self) -> Cow<Span> {\n \t\tlet position = self.name.get_position();\n-\t\tif let Some(tr) = &self.type_reference {\n+\t\tif let Some(tr) = &self.type_annotation {\n \t\t\tCow::Owned(position.union(&tr.get_position()))\n \t\t} else {\n \t\t\tposition\ndiff --git a/parser/src/parameters.rs b/parser/src/parameters.rs\n--- a/parser/src/parameters.rs\n+++ b/parser/src/parameters.rs\n@@ -32,23 +33,15 @@ impl Parameter {\n }\n \n #[derive(Debug, Clone, Eq, PartialEq, Visitable)]\n-pub enum OptionalOrWithDefaultValueParameter {\n-\tOptional {\n-\t\t// WithComment<VariableField<VariableFieldInSourceCode>>\n-\t\tname: VariableIdentifier,\n-\t\ttype_reference: Option<TypeReference>,\n-\t},\n-\tWithDefaultValue {\n-\t\tname: WithComment<VariableField<VariableFieldInSourceCode>>,\n-\t\ttype_reference: Option<TypeReference>,\n-\t\tvalue: Box<Expression>,\n-\t},\n+pub enum ParameterData {\n+\tOptional,\n+\tWithDefaultValue(Box<Expression>),\n }\n \n #[derive(Debug, Clone, Eq, PartialEq, Visitable)]\n pub struct SpreadParameter {\n \tpub name: VariableIdentifier,\n-\tpub type_reference: Option<TypeReference>,\n+\tpub type_annotation: Option<TypeAnnotation>,\n }\n \n /// TODO need to something special to not enable `OptionalFunctionParameter::WithValue` in interfaces and other\ndiff --git a/parser/src/parameters.rs b/parser/src/parameters.rs\n--- a/parser/src/parameters.rs\n+++ b/parser/src/parameters.rs\n@@ -56,7 +49,6 @@ pub struct SpreadParameter {\n #[derive(Debug, Clone, PartialEqExtras, Visitable)]\n pub struct FunctionParameters {\n \tpub parameters: Vec<Parameter>,\n-\tpub optional_parameters: Vec<OptionalOrWithDefaultValueParameter>,\n \tpub rest_parameter: Option<Box<SpreadParameter>>,\n \t#[partial_eq_ignore]\n \tpub position: Span,\ndiff --git a/parser/src/parameters.rs b/parser/src/parameters.rs\n--- a/parser/src/parameters.rs\n+++ b/parser/src/parameters.rs\n@@ -72,7 +64,7 @@ impl ASTNode for FunctionParameters {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet open_paren_span = reader.expect_next(TSXToken::OpenParentheses)?;\n \t\tSelf::from_reader_sub_open_parenthesis(reader, state, settings, open_paren_span)\ndiff --git a/parser/src/parameters.rs b/parser/src/parameters.rs\n--- a/parser/src/parameters.rs\n+++ b/parser/src/parameters.rs\n@@ -81,47 +73,26 @@ impl ASTNode for FunctionParameters {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n-\t\tlet FunctionParameters { parameters, optional_parameters, rest_parameter, .. } = self;\n+\t\tlet FunctionParameters { parameters, rest_parameter, .. } = self;\n \t\tbuf.push('(');\n-\t\tfor (at_end, Parameter { name, type_reference, .. }) in parameters.iter().endiate() {\n+\t\tfor (at_end, Parameter { name, type_annotation, additionally, .. }) in\n+\t\t\tparameters.iter().endiate()\n+\t\t{\n \t\t\t// decorators_to_string_from_buffer(decorators, buf, settings, depth);\n \t\t\tname.to_string_from_buffer(buf, settings, depth);\n-\t\t\tif let (true, Some(ref type_reference)) = (settings.include_types, type_reference) {\n-\t\t\t\tbuf.push_str(\": \");\n-\t\t\t\ttype_reference.to_string_from_buffer(buf, settings, depth);\n-\t\t\t}\n-\t\t\tif !at_end || !optional_parameters.is_empty() || rest_parameter.is_some() {\n-\t\t\t\tbuf.push(',');\n-\t\t\t\tsettings.add_gap(buf);\n-\t\t\t}\n-\t\t}\n-\t\tfor (at_end, parameter) in optional_parameters.iter().endiate() {\n-\t\t\tmatch parameter {\n-\t\t\t\tOptionalOrWithDefaultValueParameter::Optional { name, type_reference, .. } => {\n-\t\t\t\t\tbuf.push_str(name.as_str());\n+\t\t\tif let (true, Some(ref type_annotation)) = (settings.include_types, type_annotation) {\n+\t\t\t\tif let Some(ParameterData::Optional) = additionally {\n \t\t\t\t\tbuf.push('?');\n-\t\t\t\t\tif let (true, Some(type_reference)) = (settings.include_types, type_reference) {\n-\t\t\t\t\t\tbuf.push_str(\": \");\n-\t\t\t\t\t\ttype_reference.to_string_from_buffer(buf, settings, depth);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tOptionalOrWithDefaultValueParameter::WithDefaultValue {\n-\t\t\t\t\tname,\n-\t\t\t\t\ttype_reference,\n-\t\t\t\t\tvalue,\n-\t\t\t\t\t..\n-\t\t\t\t} => {\n-\t\t\t\t\tname.to_string_from_buffer(buf, settings, depth);\n-\t\t\t\t\tif let (true, Some(type_reference)) = (settings.include_types, type_reference) {\n-\t\t\t\t\t\tbuf.push_str(\": \");\n-\t\t\t\t\t\ttype_reference.to_string_from_buffer(buf, settings, depth);\n-\t\t\t\t\t}\n-\t\t\t\t\tbuf.push_str(if settings.pretty { \" = \" } else { \"=\" });\n-\t\t\t\t\tvalue.to_string_from_buffer(buf, settings, depth);\n \t\t\t\t}\n+\t\t\t\tbuf.push_str(\": \");\n+\t\t\t\ttype_annotation.to_string_from_buffer(buf, settings, depth);\n+\t\t\t}\n+\t\t\tif let Some(ParameterData::WithDefaultValue(value)) = additionally {\n+\t\t\t\tbuf.push_str(if settings.pretty { \" = \" } else { \"=\" });\n+\t\t\t\tvalue.to_string_from_buffer(buf, settings, depth);\n \t\t\t}\n \t\t\tif !at_end || rest_parameter.is_some() {\n \t\t\t\tbuf.push(',');\ndiff --git a/parser/src/parameters.rs b/parser/src/parameters.rs\n--- a/parser/src/parameters.rs\n+++ b/parser/src/parameters.rs\n@@ -131,9 +102,9 @@ impl ASTNode for FunctionParameters {\n \t\tif let Some(rest_parameter) = rest_parameter {\n \t\t\tbuf.push_str(\"...\");\n \t\t\tbuf.push_str(rest_parameter.name.as_str());\n-\t\t\tif let Some(ref type_reference) = rest_parameter.type_reference {\n+\t\t\tif let Some(ref type_annotation) = rest_parameter.type_annotation {\n \t\t\t\tbuf.push_str(\": \");\n-\t\t\t\ttype_reference.to_string_from_buffer(buf, settings, depth);\n+\t\t\t\ttype_annotation.to_string_from_buffer(buf, settings, depth);\n \t\t\t}\n \t\t}\n \t\tbuf.push(')');\ndiff --git a/parser/src/parameters.rs b/parser/src/parameters.rs\n--- a/parser/src/parameters.rs\n+++ b/parser/src/parameters.rs\n@@ -144,11 +115,10 @@ impl FunctionParameters {\n \tpub(crate) fn from_reader_sub_open_parenthesis(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t\tstart_pos: Span,\n \t) -> Result<FunctionParameters, ParseError> {\n \t\tlet mut parameters = Vec::new();\n-\t\tlet mut optional_parameters = Vec::new();\n \t\tlet mut rest_parameter = None;\n \n \t\tloop {\ndiff --git a/parser/src/parameters.rs b/parser/src/parameters.rs\n--- a/parser/src/parameters.rs\n+++ b/parser/src/parameters.rs\n@@ -165,31 +135,32 @@ impl FunctionParameters {\n \t\t\t\t\treader.next().ok_or_else(parse_lexing_error)?,\n \t\t\t\t\t\"spread function parameter\",\n \t\t\t\t)?;\n-\t\t\t\tlet type_reference =\n+\t\t\t\tlet type_annotation =\n \t\t\t\t\tif reader.conditional_next(|tok| matches!(tok, TSXToken::Colon)).is_some() {\n-\t\t\t\t\t\tSome(TypeReference::from_reader(reader, state, settings)?)\n+\t\t\t\t\t\tSome(TypeAnnotation::from_reader(reader, state, settings)?)\n \t\t\t\t\t} else {\n \t\t\t\t\t\tNone\n \t\t\t\t\t};\n \t\t\t\trest_parameter = Some(Box::new(SpreadParameter {\n-\t\t\t\t\tname: VariableIdentifier::Standard(name, VariableId::new(), name_pos),\n-\t\t\t\t\ttype_reference,\n+\t\t\t\t\tname: VariableIdentifier::Standard(name, name_pos),\n+\t\t\t\t\ttype_annotation,\n \t\t\t\t}));\n \t\t\t\tbreak;\n \t\t\t} else {\n \t\t\t\tlet name = WithComment::<VariableField<VariableFieldInSourceCode>>::from_reader(\n \t\t\t\t\treader, state, settings,\n \t\t\t\t)?;\n-\t\t\t\tlet (is_optional, type_reference) = match reader.peek() {\n+\n+\t\t\t\tlet (is_optional, type_annotation) = match reader.peek() {\n \t\t\t\t\tSome(Token(TSXToken::Colon, _)) => {\n \t\t\t\t\t\treader.next();\n-\t\t\t\t\t\tlet type_reference = TypeReference::from_reader(reader, state, settings)?;\n-\t\t\t\t\t\t(false, Some(type_reference))\n+\t\t\t\t\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\t(false, Some(type_annotation))\n \t\t\t\t\t}\n \t\t\t\t\tSome(Token(TSXToken::OptionalMember, _)) => {\n \t\t\t\t\t\treader.next();\n-\t\t\t\t\t\tlet type_reference = TypeReference::from_reader(reader, state, settings)?;\n-\t\t\t\t\t\t(true, Some(type_reference))\n+\t\t\t\t\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\t(true, Some(type_annotation))\n \t\t\t\t\t}\n \t\t\t\t\tSome(Token(TSXToken::QuestionMark, _)) => {\n \t\t\t\t\t\tlet Token(_, _) = reader.next().unwrap();\ndiff --git a/parser/src/parameters.rs b/parser/src/parameters.rs\n--- a/parser/src/parameters.rs\n+++ b/parser/src/parameters.rs\n@@ -207,50 +178,20 @@ impl FunctionParameters {\n \t\t\t\t\t\t\tpos,\n \t\t\t\t\t\t));\n \t\t\t\t\t}\n-\t\t\t\t\tSome(Expression::from_reader(reader, state, settings)?)\n+\t\t\t\t\tSome(Box::new(Expression::from_reader(reader, state, settings)?))\n \t\t\t\t} else {\n \t\t\t\t\tNone\n \t\t\t\t};\n \n-\t\t\t\tmatch (is_optional, value) {\n+\t\t\t\tlet additionally = match (is_optional, value) {\n \t\t\t\t\t(true, Some(_)) => unreachable!(\"caught earlier by error\"),\n \t\t\t\t\t// =\n-\t\t\t\t\t(false, Some(value)) => {\n-\t\t\t\t\t\toptional_parameters.push(\n-\t\t\t\t\t\t\tOptionalOrWithDefaultValueParameter::WithDefaultValue {\n-\t\t\t\t\t\t\t\tname,\n-\t\t\t\t\t\t\t\ttype_reference,\n-\t\t\t\t\t\t\t\tvalue: Box::new(value),\n-\t\t\t\t\t\t\t},\n-\t\t\t\t\t\t);\n-\t\t\t\t\t}\n+\t\t\t\t\t(false, Some(value)) => Some(ParameterData::WithDefaultValue(value)),\n \t\t\t\t\t// ?:\n-\t\t\t\t\t(true, None) => {\n-\t\t\t\t\t\tlet name = if let VariableField::Name(VariableIdentifier::Standard(\n-\t\t\t\t\t\t\tname,\n-\t\t\t\t\t\t\tvariable_id,\n-\t\t\t\t\t\t\tposition,\n-\t\t\t\t\t\t)) = name.unwrap_ast()\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tVariableIdentifier::Standard(name, variable_id, position)\n-\t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\ttodo!(\"error\")\n-\t\t\t\t\t\t};\n-\t\t\t\t\t\toptional_parameters.push(OptionalOrWithDefaultValueParameter::Optional {\n-\t\t\t\t\t\t\tname,\n-\t\t\t\t\t\t\ttype_reference,\n-\t\t\t\t\t\t});\n-\t\t\t\t\t}\n-\t\t\t\t\t(false, None) => {\n-\t\t\t\t\t\tif !optional_parameters.is_empty() {\n-\t\t\t\t\t\t\treturn Err(ParseError::new(\n-                                crate::ParseErrors::NonOptionalFunctionParameterAfterOptionalFunctionParameter,\n-\t\t\t\t\t\t\t\tname.get_position().into_owned()\n-                            ));\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tparameters.push(Parameter { name, type_reference });\n-\t\t\t\t\t}\n-\t\t\t\t}\n+\t\t\t\t\t(true, None) => Some(ParameterData::Optional),\n+\t\t\t\t\t(false, None) => None,\n+\t\t\t\t};\n+\t\t\t\tparameters.push(Parameter { name, type_annotation, additionally });\n \t\t\t}\n \t\t\tif let Some(Token(TSXToken::Comma, _)) = reader.peek() {\n \t\t\t\treader.next();\ndiff --git a/parser/src/parameters.rs b/parser/src/parameters.rs\n--- a/parser/src/parameters.rs\n+++ b/parser/src/parameters.rs\n@@ -259,11 +200,6 @@ impl FunctionParameters {\n \t\t\t}\n \t\t}\n \t\tlet end_span = reader.expect_next(TSXToken::CloseParentheses)?;\n-\t\tOk(FunctionParameters {\n-\t\t\tposition: start_pos.union(&end_span),\n-\t\t\tparameters,\n-\t\t\toptional_parameters,\n-\t\t\trest_parameter,\n-\t\t})\n+\t\tOk(FunctionParameters { position: start_pos.union(&end_span), parameters, rest_parameter })\n \t}\n }\ndiff --git a/parser/src/property_key.rs b/parser/src/property_key.rs\n--- a/parser/src/property_key.rs\n+++ b/parser/src/property_key.rs\n@@ -6,67 +6,27 @@ use tokenizer_lib::{Token, TokenReader};\n \n use crate::{\n \terrors::parse_lexing_error, tokens::token_as_identifier, ASTNode, Expression, NumberStructure,\n-\tParseResult, ParseSettings,\n+\tParseOptions, ParseResult,\n };\n \n-#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n-pub struct PropertyId(u16);\n-\n-impl PropertyId {\n-\tpub fn new() -> Self {\n-\t\tuse std::sync::atomic::{AtomicU16, Ordering};\n-\n-\t\tstatic PROPERTY_ID_COUNTER: AtomicU16 = AtomicU16::new(2000);\n-\t\tSelf(PROPERTY_ID_COUNTER.fetch_add(1, Ordering::SeqCst))\n-\t}\n-\n-\tpub fn new_known(id: u16) -> Self {\n-\t\tSelf(id)\n-\t}\n-\n-\tpub fn unwrap_counter(&self) -> u16 {\n-\t\tself.0\n-\t}\n-}\n-\n-// TODO not sure\n-#[cfg(feature = \"self-rust-tokenize\")]\n-impl self_rust_tokenize::SelfRustTokenize for PropertyId {\n-\tfn append_to_token_stream(\n-\t\t&self,\n-\t\ttoken_stream: &mut self_rust_tokenize::proc_macro2::TokenStream,\n-\t) {\n-\t\ttoken_stream.extend(self_rust_tokenize::quote!(PropertyId::new()))\n-\t}\n-}\n-\n /// A key for a member in a class or object literal\n #[derive(Debug, PartialEq, Eq, Clone)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum PropertyKey {\n-\tIdent(String, PropertyId, Span),\n-\tStringLiteral(String, PropertyId, Span),\n-\tNumberLiteral(NumberStructure, PropertyId, Span),\n+\tIdent(String, Span),\n+\tStringLiteral(String, Span),\n+\tNumberLiteral(NumberStructure, Span),\n \t/// Includes anything in the `[...]` maybe a symbol\n-\tComputed(Box<Expression>, PropertyId, Span),\n+\tComputed(Box<Expression>, Span),\n }\n \n impl PropertyKey {\n-\tpub fn get_property_id(&self) -> PropertyId {\n-\t\tmatch self {\n-\t\t\tPropertyKey::Ident(_, variable_id, _)\n-\t\t\t| PropertyKey::StringLiteral(_, variable_id, _)\n-\t\t\t| PropertyKey::NumberLiteral(_, variable_id, _)\n-\t\t\t| PropertyKey::Computed(_, variable_id, _) => *variable_id,\n-\t\t}\n-\t}\n-\n \tpub fn get_position(&self) -> Cow<Span> {\n \t\tmatch self {\n-\t\t\tPropertyKey::Ident(_, _, pos)\n-\t\t\t| PropertyKey::StringLiteral(_, _, pos)\n-\t\t\t| PropertyKey::NumberLiteral(_, _, pos)\n-\t\t\t| PropertyKey::Computed(_, _, pos) => Cow::Borrowed(pos),\n+\t\t\tPropertyKey::Ident(_, pos)\n+\t\t\t| PropertyKey::StringLiteral(_, pos)\n+\t\t\t| PropertyKey::NumberLiteral(_, pos)\n+\t\t\t| PropertyKey::Computed(_, pos) => Cow::Borrowed(pos),\n \t\t}\n \t}\n }\ndiff --git a/parser/src/property_key.rs b/parser/src/property_key.rs\n--- a/parser/src/property_key.rs\n+++ b/parser/src/property_key.rs\n@@ -74,10 +34,8 @@ impl PropertyKey {\n impl PartialEq<str> for PropertyKey {\n \tfn eq(&self, other: &str) -> bool {\n \t\tmatch self {\n-\t\t\tPropertyKey::Ident(name, _, _) | PropertyKey::StringLiteral(name, _, _) => {\n-\t\t\t\tname == other\n-\t\t\t}\n-\t\t\tPropertyKey::NumberLiteral(_, _, _) | PropertyKey::Computed(_, _, _) => false,\n+\t\t\tPropertyKey::Ident(name, _) | PropertyKey::StringLiteral(name, _) => name == other,\n+\t\t\tPropertyKey::NumberLiteral(_, _) | PropertyKey::Computed(_, _) => false,\n \t\t}\n \t}\n }\ndiff --git a/parser/src/property_key.rs b/parser/src/property_key.rs\n--- a/parser/src/property_key.rs\n+++ b/parser/src/property_key.rs\n@@ -85,38 +43,34 @@ impl PartialEq<str> for PropertyKey {\n impl ASTNode for PropertyKey {\n \tfn get_position(&self) -> Cow<Span> {\n \t\tmatch self {\n-\t\t\tPropertyKey::Ident(_, _, pos)\n-\t\t\t| PropertyKey::StringLiteral(_, _, pos)\n-\t\t\t| PropertyKey::NumberLiteral(_, _, pos)\n-\t\t\t| PropertyKey::Computed(_, _, pos) => Cow::Borrowed(pos),\n+\t\t\tPropertyKey::Ident(_, pos)\n+\t\t\t| PropertyKey::StringLiteral(_, pos)\n+\t\t\t| PropertyKey::NumberLiteral(_, pos)\n+\t\t\t| PropertyKey::Computed(_, pos) => Cow::Borrowed(pos),\n \t\t}\n \t}\n \n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tmatch reader.next().ok_or_else(parse_lexing_error)? {\n \t\t\tToken(TSXToken::DoubleQuotedStringLiteral(content), position)\n \t\t\t| Token(TSXToken::SingleQuotedStringLiteral(content), position) => {\n-\t\t\t\tOk(Self::StringLiteral(content, PropertyId::new(), position))\n+\t\t\t\tOk(Self::StringLiteral(content, position))\n \t\t\t}\n \t\t\tToken(TSXToken::NumberLiteral(value), position) => {\n-\t\t\t\tOk(Self::NumberLiteral(value.parse().unwrap(), PropertyId::new(), position))\n+\t\t\t\tOk(Self::NumberLiteral(value.parse().unwrap(), position))\n \t\t\t}\n \t\t\tToken(TSXToken::OpenBracket, start_pos) => {\n \t\t\t\tlet expression = Expression::from_reader(reader, state, settings)?;\n \t\t\t\tlet end_pos = reader.expect_next(TSXToken::CloseBracket)?;\n-\t\t\t\tOk(Self::Computed(\n-\t\t\t\t\tBox::new(expression),\n-\t\t\t\t\tPropertyId::new(),\n-\t\t\t\t\tstart_pos.union(&end_pos),\n-\t\t\t\t))\n+\t\t\t\tOk(Self::Computed(Box::new(expression), start_pos.union(&end_pos)))\n \t\t\t}\n \t\t\ttoken => {\n \t\t\t\tlet (name, position) = token_as_identifier(token, \"property key\")?;\n-\t\t\t\tOk(Self::Ident(name, PropertyId::new(), position))\n+\t\t\t\tOk(Self::Ident(name, position))\n \t\t\t}\n \t\t}\n \t}\ndiff --git a/parser/src/property_key.rs b/parser/src/property_key.rs\n--- a/parser/src/property_key.rs\n+++ b/parser/src/property_key.rs\n@@ -124,18 +78,18 @@ impl ASTNode for PropertyKey {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\n-\t\t\tSelf::Ident(ident, _, _pos) => buf.push_str(ident.as_str()),\n-\t\t\tSelf::NumberLiteral(number, _, _) => buf.push_str(&number.to_string()),\n-\t\t\tSelf::StringLiteral(string, _, _) => {\n+\t\t\tSelf::Ident(ident, _pos) => buf.push_str(ident.as_str()),\n+\t\t\tSelf::NumberLiteral(number, _) => buf.push_str(&number.to_string()),\n+\t\t\tSelf::StringLiteral(string, _) => {\n \t\t\t\tbuf.push('\"');\n \t\t\t\tbuf.push_str(string.as_str());\n \t\t\t\tbuf.push('\"');\n \t\t\t}\n-\t\t\tSelf::Computed(expression, _, _) => {\n+\t\t\tSelf::Computed(expression, _) => {\n \t\t\t\tbuf.push('[');\n \t\t\t\texpression.to_string_from_buffer(buf, settings, depth);\n \t\t\t\tbuf.push(']');\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -1,13 +1,15 @@\n use std::borrow::Cow;\n \n use crate::{\n-\tblock::BlockOrSingleStatement,\n-\tdeclarations::variable::{VariableDeclaration, VariableDeclarationKeyword},\n-\tParseSettings, TSXKeyword, VariableField, VariableFieldInSourceCode, WithComment,\n+\tast::MultipleExpression, block::BlockOrSingleStatement,\n+\tdeclarations::variable::VariableDeclaration, tsx_keywords, Keyword, ParseOptions, TSXKeyword,\n+\tVariableField, VariableFieldInSourceCode, WithComment,\n };\n use visitable_derive::Visitable;\n \n-use super::{ASTNode, Expression, ParseResult, Span, TSXToken, Token, TokenReader};\n+use super::{\n+\tASTNode, Expression, ParseResult, Span, TSXToken, Token, TokenReader, VarVariableStatement,\n+};\n \n #[derive(Debug, Clone, PartialEq, Eq, Visitable)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -25,7 +27,7 @@ impl ASTNode for ForLoopStatement {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet start_pos = reader.expect_next(TSXToken::Keyword(TSXKeyword::For))?;\n \t\tlet condition = ForLoopCondition::from_reader(reader, state, settings)?;\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -37,7 +39,7 @@ impl ASTNode for ForLoopStatement {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(\"for\");\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -51,29 +53,79 @@ impl ASTNode for ForLoopStatement {\n #[derive(Debug, Clone, PartialEq, Eq, Visitable)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum ForLoopStatementInitializer {\n-\tStatement(VariableDeclaration),\n-\tExpression(Expression),\n+\tVariableDeclaration(VariableDeclaration),\n+\tVarStatement(VarVariableStatement),\n+\tExpression(MultipleExpression),\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Visitable)]\n+#[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n+pub enum ForLoopVariableKeyword {\n+\tConst(Keyword<tsx_keywords::Const>),\n+\tLet(Keyword<tsx_keywords::Let>),\n+\tVar(Keyword<tsx_keywords::Var>),\n+}\n+\n+impl ForLoopVariableKeyword {\n+\tpub fn is_token_variable_keyword(token: &TSXToken) -> bool {\n+\t\tmatches!(token, TSXToken::Keyword(TSXKeyword::Const | TSXKeyword::Let | TSXKeyword::Var))\n+\t}\n+\n+\tpub(crate) fn from_reader(token: Token<TSXToken, Span>) -> ParseResult<Self> {\n+\t\tmatch token {\n+\t\t\tToken(TSXToken::Keyword(TSXKeyword::Const), pos) => Ok(Self::Const(Keyword::new(pos))),\n+\t\t\tToken(TSXToken::Keyword(TSXKeyword::Let), pos) => Ok(Self::Let(Keyword::new(pos))),\n+\t\t\tToken(TSXToken::Keyword(TSXKeyword::Var), pos) => Ok(Self::Var(Keyword::new(pos))),\n+\t\t\tToken(token, position) => Err(crate::ParseError::new(\n+\t\t\t\tcrate::ParseErrors::UnexpectedToken {\n+\t\t\t\t\texpected: &[\n+\t\t\t\t\t\tTSXToken::Keyword(TSXKeyword::Const),\n+\t\t\t\t\t\tTSXToken::Keyword(TSXKeyword::Let),\n+\t\t\t\t\t\tTSXToken::Keyword(TSXKeyword::Var),\n+\t\t\t\t\t],\n+\t\t\t\t\tfound: token,\n+\t\t\t\t},\n+\t\t\t\tposition,\n+\t\t\t)),\n+\t\t}\n+\t}\n+\n+\tpub fn as_str(&self) -> &str {\n+\t\tmatch self {\n+\t\t\tSelf::Const(_) => \"const \",\n+\t\t\tSelf::Let(_) => \"let \",\n+\t\t\tSelf::Var(_) => \"var \",\n+\t\t}\n+\t}\n+\n+\tpub fn get_position(&self) -> &Span {\n+\t\tmatch self {\n+\t\t\tSelf::Const(kw) => kw.get_position(),\n+\t\t\tSelf::Let(kw) => kw.get_position(),\n+\t\t\tSelf::Var(kw) => kw.get_position(),\n+\t\t}\n+\t}\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Visitable)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum ForLoopCondition {\n \tForOf {\n-\t\tkeyword: Option<VariableDeclarationKeyword>,\n+\t\tkeyword: Option<ForLoopVariableKeyword>,\n \t\tvariable: WithComment<VariableField<VariableFieldInSourceCode>>,\n \t\t// TODO box...?\n \t\tof: Expression,\n \t},\n \tForIn {\n-\t\tkeyword: Option<VariableDeclarationKeyword>,\n+\t\tkeyword: Option<ForLoopVariableKeyword>,\n \t\tvariable: WithComment<VariableField<VariableFieldInSourceCode>>,\n \t\t// TODO box...?\n \t\tr#in: Expression,\n \t},\n \tStatements {\n \t\tinitializer: Option<ForLoopStatementInitializer>,\n-\t\tcondition: Option<Expression>,\n-\t\tafterthought: Option<Expression>,\n+\t\tcondition: Option<MultipleExpression>,\n+\t\tafterthought: Option<MultipleExpression>,\n \t},\n }\n \ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -84,7 +136,7 @@ impl ASTNode for ForLoopCondition {\n \t\t\t| ForLoopCondition::ForIn { keyword, variable, r#in: rhs } => Cow::Owned(\n \t\t\t\tkeyword\n \t\t\t\t\t.as_ref()\n-\t\t\t\t\t.map(VariableDeclarationKeyword::get_position)\n+\t\t\t\t\t.map(ForLoopVariableKeyword::get_position)\n \t\t\t\t\t.map(Cow::Borrowed)\n \t\t\t\t\t.unwrap_or_else(|| variable.get_position())\n \t\t\t\t\t.union(&rhs.get_position()),\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -92,7 +144,8 @@ impl ASTNode for ForLoopCondition {\n \t\t\tForLoopCondition::Statements { initializer, condition: _, afterthought } => {\n \t\t\t\tlet initializer_position = match initializer.as_ref().expect(\"TODO what about None\")\n \t\t\t\t{\n-\t\t\t\t\tForLoopStatementInitializer::Statement(stmt) => stmt.get_position(),\n+\t\t\t\t\tForLoopStatementInitializer::VariableDeclaration(stmt) => stmt.get_position(),\n+\t\t\t\t\tForLoopStatementInitializer::VarStatement(stmt) => stmt.get_position(),\n \t\t\t\t\tForLoopStatementInitializer::Expression(expr) => expr.get_position(),\n \t\t\t\t};\n \t\t\t\tCow::Owned(\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -107,7 +160,7 @@ impl ASTNode for ForLoopCondition {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\treader.expect_next(TSXToken::OpenParentheses)?;\n \t\t// Figure out if after variable declaration there exists a \"=\", \"in\" or a \"of\"\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -124,7 +177,7 @@ impl ASTNode for ForLoopCondition {\n \t\t\t\t\tdestructuring_depth == 0\n \t\t\t\t} else {\n \t\t\t\t\tate_variable_specifier = true;\n-\t\t\t\t\t!VariableDeclarationKeyword::is_token_variable_keyword(token)\n+\t\t\t\t\t!ForLoopVariableKeyword::is_token_variable_keyword(token)\n \t\t\t\t}\n \t\t\t})\n \t\t\t.map(|Token(tok, _)| tok);\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -132,9 +185,9 @@ impl ASTNode for ForLoopCondition {\n \t\tlet condition = match next {\n \t\t\tSome(TSXToken::Keyword(TSXKeyword::Of)) => {\n \t\t\t\tlet keyword = if let Some(token) =\n-\t\t\t\t\treader.conditional_next(VariableDeclarationKeyword::is_token_variable_keyword)\n+\t\t\t\t\treader.conditional_next(ForLoopVariableKeyword::is_token_variable_keyword)\n \t\t\t\t{\n-\t\t\t\t\tSome(VariableDeclarationKeyword::from_reader(token).unwrap())\n+\t\t\t\t\tSome(ForLoopVariableKeyword::from_reader(token).unwrap())\n \t\t\t\t} else {\n \t\t\t\t\tNone\n \t\t\t\t};\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -147,9 +200,9 @@ impl ASTNode for ForLoopCondition {\n \t\t\t}\n \t\t\tSome(TSXToken::Keyword(TSXKeyword::In)) => {\n \t\t\t\tlet keyword = if let Some(token) =\n-\t\t\t\t\treader.conditional_next(VariableDeclarationKeyword::is_token_variable_keyword)\n+\t\t\t\t\treader.conditional_next(ForLoopVariableKeyword::is_token_variable_keyword)\n \t\t\t\t{\n-\t\t\t\t\tSome(VariableDeclarationKeyword::from_reader(token).unwrap())\n+\t\t\t\t\tSome(ForLoopVariableKeyword::from_reader(token).unwrap())\n \t\t\t\t} else {\n \t\t\t\t\tNone\n \t\t\t\t};\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -162,29 +215,33 @@ impl ASTNode for ForLoopCondition {\n \t\t\t}\n \t\t\t_ => {\n \t\t\t\tlet peek = reader.peek();\n-\t\t\t\tlet initializer = if let Some(Token(\n-\t\t\t\t\tTSXToken::Keyword(TSXKeyword::Const | TSXKeyword::Let | TSXKeyword::Var),\n-\t\t\t\t\t_,\n-\t\t\t\t)) = peek\n-\t\t\t\t{\n-\t\t\t\t\tlet declaration = VariableDeclaration::from_reader(reader, state, settings)?;\n-\t\t\t\t\tSome(ForLoopStatementInitializer::Statement(declaration))\n-\t\t\t\t} else if let Some(Token(TSXToken::SemiColon, _)) = peek {\n-\t\t\t\t\tNone\n-\t\t\t\t} else {\n-\t\t\t\t\tlet expr = Expression::from_reader(reader, state, settings)?;\n-\t\t\t\t\tSome(ForLoopStatementInitializer::Expression(expr))\n-\t\t\t\t};\n+\t\t\t\tlet initializer =\n+\t\t\t\t\tif let Some(Token(TSXToken::Keyword(TSXKeyword::Const | TSXKeyword::Let), _)) =\n+\t\t\t\t\t\tpeek\n+\t\t\t\t\t{\n+\t\t\t\t\t\tlet declaration =\n+\t\t\t\t\t\t\tVariableDeclaration::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\tSome(ForLoopStatementInitializer::VariableDeclaration(declaration))\n+\t\t\t\t\t} else if let Some(Token(TSXToken::Keyword(TSXKeyword::Var), _)) = peek {\n+\t\t\t\t\t\tlet stmt = VarVariableStatement::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\tSome(ForLoopStatementInitializer::VarStatement(stmt))\n+\t\t\t\t\t} else if let Some(Token(TSXToken::SemiColon, _)) = peek {\n+\t\t\t\t\t\tNone\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tlet expr = MultipleExpression::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\tSome(ForLoopStatementInitializer::Expression(expr))\n+\t\t\t\t\t};\n+\n \t\t\t\treader.expect_next(TSXToken::SemiColon)?;\n \t\t\t\tlet condition = if !matches!(reader.peek(), Some(Token(TSXToken::SemiColon, _))) {\n-\t\t\t\t\tSome(Expression::from_reader(reader, state, settings)?)\n+\t\t\t\t\tSome(MultipleExpression::from_reader(reader, state, settings)?)\n \t\t\t\t} else {\n \t\t\t\t\tNone\n \t\t\t\t};\n \t\t\t\treader.expect_next(TSXToken::SemiColon)?;\n \t\t\t\tlet afterthought =\n \t\t\t\t\tif !matches!(reader.peek(), Some(Token(TSXToken::CloseParentheses, _))) {\n-\t\t\t\t\t\tSome(Expression::from_reader(reader, state, settings)?)\n+\t\t\t\t\t\tSome(MultipleExpression::from_reader(reader, state, settings)?)\n \t\t\t\t\t} else {\n \t\t\t\t\t\tNone\n \t\t\t\t\t};\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -198,7 +255,7 @@ impl ASTNode for ForLoopCondition {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push('(');\ndiff --git a/parser/src/statements/for_statement.rs b/parser/src/statements/for_statement.rs\n--- a/parser/src/statements/for_statement.rs\n+++ b/parser/src/statements/for_statement.rs\n@@ -224,12 +281,15 @@ impl ASTNode for ForLoopCondition {\n \t\t\tSelf::Statements { initializer, condition, afterthought } => {\n \t\t\t\tif let Some(initializer) = initializer {\n \t\t\t\t\tmatch initializer {\n-\t\t\t\t\t\tForLoopStatementInitializer::Statement(stmt) => {\n+\t\t\t\t\t\tForLoopStatementInitializer::VariableDeclaration(stmt) => {\n \t\t\t\t\t\t\tstmt.to_string_from_buffer(buf, settings, depth)\n \t\t\t\t\t\t}\n \t\t\t\t\t\tForLoopStatementInitializer::Expression(expr) => {\n \t\t\t\t\t\t\texpr.to_string_from_buffer(buf, settings, depth);\n \t\t\t\t\t\t}\n+\t\t\t\t\t\tForLoopStatementInitializer::VarStatement(stmt) => {\n+\t\t\t\t\t\t\tstmt.to_string_from_buffer(buf, settings, depth)\n+\t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tbuf.push(';');\ndiff --git a/parser/src/statements/if_statement.rs b/parser/src/statements/if_statement.rs\n--- a/parser/src/statements/if_statement.rs\n+++ b/parser/src/statements/if_statement.rs\n@@ -1,8 +1,9 @@\n use std::borrow::Cow;\n \n use crate::{\n-\tblock::BlockOrSingleStatement, expressions::MultipleExpression, ParseSettings, TSXKeyword,\n+\tblock::BlockOrSingleStatement, expressions::MultipleExpression, ParseOptions, TSXKeyword,\n };\n+use iterator_endiate::EndiateIteratorExt;\n use visitable_derive::Visitable;\n \n use super::{ASTNode, ParseResult, Span, TSXToken, Token, TokenReader};\ndiff --git a/parser/src/statements/if_statement.rs b/parser/src/statements/if_statement.rs\n--- a/parser/src/statements/if_statement.rs\n+++ b/parser/src/statements/if_statement.rs\n@@ -39,7 +40,7 @@ impl ASTNode for IfStatement {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet start_span = reader.expect_next(TSXToken::Keyword(TSXKeyword::If))?;\n \t\treader.expect_next(TSXToken::OpenParentheses)?;\ndiff --git a/parser/src/statements/if_statement.rs b/parser/src/statements/if_statement.rs\n--- a/parser/src/statements/if_statement.rs\n+++ b/parser/src/statements/if_statement.rs\n@@ -80,7 +81,7 @@ impl ASTNode for IfStatement {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(\"if\");\ndiff --git a/parser/src/statements/if_statement.rs b/parser/src/statements/if_statement.rs\n--- a/parser/src/statements/if_statement.rs\n+++ b/parser/src/statements/if_statement.rs\n@@ -90,9 +91,22 @@ impl ASTNode for IfStatement {\n \t\tbuf.push(')');\n \t\tsettings.add_gap(buf);\n \t\tself.inner.to_string_from_buffer(buf, settings, depth + 1);\n-\t\tfor else_statement in self.else_conditions.iter() {\n+\t\tif !settings.pretty\n+\t\t\t&& matches!(self.inner, BlockOrSingleStatement::SingleStatement(_))\n+\t\t\t&& (!self.else_conditions.is_empty() || self.trailing_else.is_some())\n+\t\t{\n+\t\t\tbuf.push(';');\n+\t\t}\n+\n+\t\tfor (at_end, else_statement) in self.else_conditions.iter().endiate() {\n \t\t\tsettings.add_gap(buf);\n \t\t\telse_statement.to_string_from_buffer(buf, settings, depth);\n+\t\t\tif !settings.pretty\n+\t\t\t\t&& matches!(else_statement.inner, BlockOrSingleStatement::SingleStatement(_))\n+\t\t\t\t&& at_end\n+\t\t\t{\n+\t\t\t\tbuf.push(';');\n+\t\t\t}\n \t\t}\n \t\tif let Some(else_statement) = &self.trailing_else {\n \t\t\tsettings.add_gap(buf);\ndiff --git a/parser/src/statements/if_statement.rs b/parser/src/statements/if_statement.rs\n--- a/parser/src/statements/if_statement.rs\n+++ b/parser/src/statements/if_statement.rs\n@@ -105,7 +119,7 @@ impl ASTNode for ConditionalElseStatement {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet else_position = reader.expect_next(TSXToken::Keyword(TSXKeyword::Else))?;\n \t\tSelf::from_reader_sub_without_else(reader, state, settings, else_position)\ndiff --git a/parser/src/statements/if_statement.rs b/parser/src/statements/if_statement.rs\n--- a/parser/src/statements/if_statement.rs\n+++ b/parser/src/statements/if_statement.rs\n@@ -118,7 +132,7 @@ impl ASTNode for ConditionalElseStatement {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(\"else if\");\ndiff --git a/parser/src/statements/if_statement.rs b/parser/src/statements/if_statement.rs\n--- a/parser/src/statements/if_statement.rs\n+++ b/parser/src/statements/if_statement.rs\n@@ -135,7 +149,7 @@ impl ConditionalElseStatement {\n \tfn from_reader_sub_without_else(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\telse_position: Span,\n \t) -> ParseResult<Self> {\n \t\treader.expect_next(TSXToken::Keyword(TSXKeyword::If))?;\ndiff --git a/parser/src/statements/if_statement.rs b/parser/src/statements/if_statement.rs\n--- a/parser/src/statements/if_statement.rs\n+++ b/parser/src/statements/if_statement.rs\n@@ -155,7 +169,7 @@ impl ASTNode for UnconditionalElseStatement {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet else_position = reader.expect_next(TSXToken::Keyword(TSXKeyword::Else))?;\n \t\tSelf::from_reader_sub_without_else(reader, state, settings, else_position)\ndiff --git a/parser/src/statements/if_statement.rs b/parser/src/statements/if_statement.rs\n--- a/parser/src/statements/if_statement.rs\n+++ b/parser/src/statements/if_statement.rs\n@@ -168,10 +182,13 @@ impl ASTNode for UnconditionalElseStatement {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(\"else\");\n+\t\tif !settings.pretty && matches!(self.inner, BlockOrSingleStatement::SingleStatement(_)) {\n+\t\t\tbuf.push(' ');\n+\t\t}\n \t\tsettings.add_gap(buf);\n \t\tself.inner.to_string_from_buffer(buf, settings, depth + 1);\n \t}\ndiff --git a/parser/src/statements/if_statement.rs b/parser/src/statements/if_statement.rs\n--- a/parser/src/statements/if_statement.rs\n+++ b/parser/src/statements/if_statement.rs\n@@ -181,7 +198,7 @@ impl UnconditionalElseStatement {\n \tfn from_reader_sub_without_else(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\telse_position: Span,\n \t) -> ParseResult<Self> {\n \t\tlet statements = BlockOrSingleStatement::from_reader(reader, state, settings)?;\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -6,7 +6,6 @@ mod while_statement;\n \n use crate::{\n \tdeclarations::variable::{declarations_to_string, VariableDeclarationItem},\n-\texpect_semi_colon,\n \ttokens::token_as_identifier,\n \ttsx_keywords,\n };\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -15,8 +14,8 @@ use derive_partial_eq_extras::PartialEqExtras;\n use std::{borrow::Cow, fmt::Debug};\n \n use super::{\n-\texpressions::MultipleExpression, ASTNode, Block, CursorId, Expression, Keyword, ParseResult,\n-\tParseSettings, Span, TSXKeyword, TSXToken, Token, TokenReader,\n+\texpressions::MultipleExpression, ASTNode, Block, CursorId, Expression, Keyword, ParseOptions,\n+\tParseResult, Span, TSXKeyword, TSXToken, Token, TokenReader,\n };\n use crate::errors::parse_lexing_error;\n pub use for_statement::{ForLoopCondition, ForLoopStatement, ForLoopStatementInitializer};\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -51,7 +50,7 @@ pub enum Statement {\n \tContinue(Option<String>, Span),\n \tBreak(Option<String>, Span),\n \t/// e.g `throw ...`\n-\tThrow(Keyword<tsx_keywords::Throw>, Box<Expression>),\n+\tThrow(Keyword<tsx_keywords::Throw>, Box<MultipleExpression>),\n \t// Comments\n \tComment(String, Span),\n \tMultiLineComment(String, Span),\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -61,6 +60,8 @@ pub enum Statement {\n \t\tstatement: Box<Statement>,\n \t},\n \tVarVariable(VarVariableStatement),\n+\t// TODO position\n+\tEmpty(Span),\n \t/// TODO under cfg\n \t#[self_tokenize_field(0)]\n \tCursor(#[visit_skip_field] CursorId<Statement>, Span),\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -78,6 +79,7 @@ impl ASTNode for Statement {\n \t\t\t| Statement::Break(_, pos)\n \t\t\t| Statement::Cursor(_, pos)\n \t\t\t| Statement::Comment(_, pos)\n+\t\t\t| Statement::Empty(pos)\n \t\t\t| Statement::Labelled { position: pos, .. }\n \t\t\t| Statement::MultiLineComment(_, pos) => Cow::Borrowed(pos),\n \t\t\tStatement::Return(kw, expr) => {\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -101,7 +103,7 @@ impl ASTNode for Statement {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tif let Some(Token(TSXToken::Colon, _)) = reader.peek_n(1) {\n \t\t\tlet (name, label_name_pos) = token_as_identifier(reader.next().unwrap(), \"label name\")?;\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -123,12 +125,11 @@ impl ASTNode for Statement {\n \t\t\t}\n \t\t\tTSXToken::Keyword(TSXKeyword::Var) => {\n \t\t\t\tlet stmt = VarVariableStatement::from_reader(reader, state, settings)?;\n-\t\t\t\texpect_semi_colon(reader)?;\n \t\t\t\tOk(Statement::VarVariable(stmt))\n \t\t\t}\n \t\t\tTSXToken::Keyword(TSXKeyword::Throw) => {\n \t\t\t\tlet Token(_, throw_pos) = reader.next().unwrap();\n-\t\t\t\tlet expression = Expression::from_reader(reader, state, settings)?;\n+\t\t\t\tlet expression = ASTNode::from_reader(reader, state, settings)?;\n \t\t\t\tOk(Statement::Throw(Keyword::new(throw_pos), Box::new(expression)))\n \t\t\t}\n \t\t\tTSXToken::Keyword(TSXKeyword::If) => {\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -211,6 +212,10 @@ impl ASTNode for Statement {\n \t\t\t\t\tunreachable!()\n \t\t\t\t}\n \t\t\t}\n+\t\t\tTSXToken::SemiColon => {\n+\t\t\t\tlet pos = reader.next().unwrap().1;\n+\t\t\t\tOk(Statement::Empty(pos))\n+\t\t\t}\n \t\t\t// Finally ...!\n \t\t\t_ => {\n \t\t\t\tlet expr = MultipleExpression::from_reader(reader, state, settings)?;\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -222,7 +227,7 @@ impl ASTNode for Statement {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -231,6 +236,9 @@ impl ASTNode for Statement {\n \t\t\t\t\tpanic!(\"tried to to-string cursor\")\n \t\t\t\t}\n \t\t\t}\n+\t\t\tStatement::Empty(..) => {\n+\t\t\t\tbuf.push(';');\n+\t\t\t}\n \t\t\tStatement::Return(_, expression) => {\n \t\t\t\tbuf.push_str(\"return\");\n \t\t\t\tif let Some(expression) = expression {\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -314,7 +322,7 @@ impl Statement {\n \t}\n }\n \n-#[derive(Debug, PartialEq, Clone, Visitable)]\n+#[derive(Debug, PartialEq, Eq, Clone, Visitable)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub struct VarVariableStatement {\n \tkeyword: Keyword<tsx_keywords::Var>,\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -329,7 +337,7 @@ impl ASTNode for VarVariableStatement {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet keyword = Keyword::new(reader.expect_next(TSXToken::Keyword(TSXKeyword::Var))?);\n \t\tlet mut declarations = Vec::new();\ndiff --git a/parser/src/statements/mod.rs b/parser/src/statements/mod.rs\n--- a/parser/src/statements/mod.rs\n+++ b/parser/src/statements/mod.rs\n@@ -350,11 +358,10 @@ impl ASTNode for VarVariableStatement {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(\"var \");\n \t\tdeclarations_to_string(&self.declarations, buf, settings, depth);\n-\t\tbuf.push(';');\n \t}\n }\ndiff --git a/parser/src/statements/switch_statement.rs b/parser/src/statements/switch_statement.rs\n--- a/parser/src/statements/switch_statement.rs\n+++ b/parser/src/statements/switch_statement.rs\n@@ -6,7 +6,7 @@ use tokenizer_lib::Token;\n use visitable_derive::Visitable;\n \n use crate::{\n-\terrors::parse_lexing_error, ASTNode, Expression, ParseSettings, Statement, TSXKeyword, TSXToken,\n+\terrors::parse_lexing_error, ASTNode, Expression, ParseOptions, Statement, TSXKeyword, TSXToken,\n };\n \n #[derive(Debug, PartialEq, Eq, Clone, Visitable)]\ndiff --git a/parser/src/statements/switch_statement.rs b/parser/src/statements/switch_statement.rs\n--- a/parser/src/statements/switch_statement.rs\n+++ b/parser/src/statements/switch_statement.rs\n@@ -32,7 +32,7 @@ impl ASTNode for SwitchStatement {\n \tfn from_reader(\n \t\treader: &mut impl tokenizer_lib::TokenReader<crate::TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> Result<Self, crate::ParseError> {\n \t\tlet start_span = reader.expect_next(TSXToken::Keyword(TSXKeyword::Switch))?;\n \t\treader.expect_next(crate::TSXToken::OpenParentheses)?;\ndiff --git a/parser/src/statements/switch_statement.rs b/parser/src/statements/switch_statement.rs\n--- a/parser/src/statements/switch_statement.rs\n+++ b/parser/src/statements/switch_statement.rs\n@@ -87,7 +87,7 @@ impl ASTNode for SwitchStatement {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(\"switch\");\ndiff --git a/parser/src/statements/try_catch_statement.rs b/parser/src/statements/try_catch_statement.rs\n--- a/parser/src/statements/try_catch_statement.rs\n+++ b/parser/src/statements/try_catch_statement.rs\n@@ -1,7 +1,7 @@\n use std::borrow::Cow;\n \n use crate::{\n-\tASTNode, Block, ParseError, ParseErrors, TSXKeyword, TSXToken, TypeReference, VariableField,\n+\tASTNode, Block, ParseError, ParseErrors, TSXKeyword, TSXToken, TypeAnnotation, VariableField,\n \tVariableFieldInSourceCode, WithComment,\n };\n use source_map::Span;\ndiff --git a/parser/src/statements/try_catch_statement.rs b/parser/src/statements/try_catch_statement.rs\n--- a/parser/src/statements/try_catch_statement.rs\n+++ b/parser/src/statements/try_catch_statement.rs\n@@ -15,7 +15,7 @@ pub type ExceptionVarField = WithComment<VariableField<VariableFieldInSourceCode\n pub struct TryCatchStatement {\n \ttry_inner: Block,\n \tcatch_inner: Option<Block>,\n-\texception_var: Option<(ExceptionVarField, Option<TypeReference>)>,\n+\texception_var: Option<(ExceptionVarField, Option<TypeAnnotation>)>,\n \tfinally_inner: Option<Block>,\n \tposition: Span,\n }\ndiff --git a/parser/src/statements/try_catch_statement.rs b/parser/src/statements/try_catch_statement.rs\n--- a/parser/src/statements/try_catch_statement.rs\n+++ b/parser/src/statements/try_catch_statement.rs\n@@ -28,13 +28,13 @@ impl ASTNode for TryCatchStatement {\n \tfn from_reader(\n \t\treader: &mut impl tokenizer_lib::TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t) -> Result<Self, crate::ParseError> {\n \t\tlet start_span = reader.expect_next(TSXToken::Keyword(TSXKeyword::Try))?;\n \t\tlet try_inner = Block::from_reader(reader, state, settings)?;\n \n \t\tlet mut catch_inner: Option<Block> = None;\n-\t\tlet mut exception_var: Option<(ExceptionVarField, Option<TypeReference>)> = None;\n+\t\tlet mut exception_var: Option<(ExceptionVarField, Option<TypeAnnotation>)> = None;\n \n \t\t// Optional `catch` clause\n \t\tif let Some(Token(TSXToken::Keyword(TSXKeyword::Catch), _)) = reader.peek() {\ndiff --git a/parser/src/statements/try_catch_statement.rs b/parser/src/statements/try_catch_statement.rs\n--- a/parser/src/statements/try_catch_statement.rs\n+++ b/parser/src/statements/try_catch_statement.rs\n@@ -49,10 +49,11 @@ impl ASTNode for TryCatchStatement {\n \t\t\t\t\t)?;\n \n \t\t\t\t// Optional type reference `catch (e: type)`\n-\t\t\t\tlet mut exception_var_type: Option<TypeReference> = None;\n+\t\t\t\tlet mut exception_var_type: Option<TypeAnnotation> = None;\n \t\t\t\tif let Some(Token(TSXToken::Colon, _)) = reader.peek() {\n \t\t\t\t\treader.expect_next(TSXToken::Colon)?;\n-\t\t\t\t\texception_var_type = Some(TypeReference::from_reader(reader, state, settings)?);\n+\t\t\t\t\texception_var_type =\n+\t\t\t\t\t\tSome(TypeAnnotation::from_reader(reader, state, settings)?);\n \t\t\t\t}\n \t\t\t\texception_var = Some((variable_field, exception_var_type));\n \ndiff --git a/parser/src/statements/try_catch_statement.rs b/parser/src/statements/try_catch_statement.rs\n--- a/parser/src/statements/try_catch_statement.rs\n+++ b/parser/src/statements/try_catch_statement.rs\n@@ -85,7 +86,7 @@ impl ASTNode for TryCatchStatement {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\t// Required `try` block\ndiff --git a/parser/src/statements/while_statement.rs b/parser/src/statements/while_statement.rs\n--- a/parser/src/statements/while_statement.rs\n+++ b/parser/src/statements/while_statement.rs\n@@ -21,7 +21,7 @@ impl ASTNode for WhileStatement {\n \tfn from_reader(\n \t\treader: &mut impl tokenizer_lib::TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t) -> Result<Self, crate::ParseError> {\n \t\tlet start_span = reader.expect_next(TSXToken::Keyword(TSXKeyword::While))?;\n \t\treader.expect_next(TSXToken::OpenParentheses)?;\ndiff --git a/parser/src/statements/while_statement.rs b/parser/src/statements/while_statement.rs\n--- a/parser/src/statements/while_statement.rs\n+++ b/parser/src/statements/while_statement.rs\n@@ -34,7 +34,7 @@ impl ASTNode for WhileStatement {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(\"while\");\ndiff --git a/parser/src/statements/while_statement.rs b/parser/src/statements/while_statement.rs\n--- a/parser/src/statements/while_statement.rs\n+++ b/parser/src/statements/while_statement.rs\n@@ -65,7 +65,7 @@ impl ASTNode for DoWhileStatement {\n \tfn from_reader(\n \t\treader: &mut impl tokenizer_lib::TokenReader<crate::TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t) -> Result<Self, crate::ParseError> {\n \t\tlet start_span = reader.expect_next(TSXToken::Keyword(TSXKeyword::Do))?;\n \t\tlet inner = BlockOrSingleStatement::from_reader(reader, state, settings)?;\ndiff --git a/parser/src/statements/while_statement.rs b/parser/src/statements/while_statement.rs\n--- a/parser/src/statements/while_statement.rs\n+++ b/parser/src/statements/while_statement.rs\n@@ -79,7 +79,7 @@ impl ASTNode for DoWhileStatement {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(\"do\");\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -4,18 +4,19 @@ use tokenizer_lib::Token;\n \n use crate::{\n \terrors::parse_lexing_error, parse_bracketed, to_string_bracketed, tokens::token_as_identifier,\n-\ttypes::type_references::TypeReferenceFunctionParameters, ASTNode, Decorator,\n-\tGenericTypeConstraint, ParseResult, ParseSettings, Span, TSXKeyword, TSXToken, TokenReader,\n-\tTypeId, TypeReference, VariableId,\n+\ttypes::type_annotations::TypeAnnotationFunctionParameters, ASTNode, Decorator,\n+\tGenericTypeConstraint, ParseOptions, ParseResult, Span, TSXKeyword, TSXToken, TokenReader,\n+\tTypeAnnotation,\n };\n \n+use super::AnnotationPerforms;\n+\n /// A `declare var` thingy.\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub struct DeclareVariableDeclaration {\n \tpub name: String,\n-\tpub type_restriction: TypeReference,\n-\tpub variable_id: VariableId,\n+\tpub type_restriction: TypeAnnotation,\n \tpub decorators: Vec<Decorator>,\n \tpub position: Span,\n }\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -28,7 +29,7 @@ impl ASTNode for DeclareVariableDeclaration {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet start_span = reader.expect_next(TSXToken::Keyword(TSXKeyword::Declare))?;\n \t\tSelf::from_reader_sub_declare(reader, state, settings, Some(start_span), Vec::new())\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -37,7 +38,7 @@ impl ASTNode for DeclareVariableDeclaration {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tif settings.include_types {\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -53,16 +54,16 @@ impl DeclareVariableDeclaration {\n \tpub fn from_reader_sub_declare(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\tdeclare_span: Option<Span>,\n \t\tdecorators: Vec<Decorator>,\n \t) -> ParseResult<Self> {\n \t\tlet var_pos = reader.expect_next(TSXToken::Keyword(TSXKeyword::Var))?;\n \t\tlet (name, _) = token_as_identifier(reader.next().unwrap(), \"declare variable name\")?;\n \t\treader.expect_next(TSXToken::Colon)?;\n-\t\tlet type_restriction = TypeReference::from_reader(reader, state, settings)?;\n+\t\tlet type_restriction = TypeAnnotation::from_reader(reader, state, settings)?;\n \t\tlet position = declare_span.unwrap_or(var_pos).union(&type_restriction.get_position());\n-\t\tOk(Self { name, type_restriction, variable_id: VariableId::new(), position, decorators })\n+\t\tOk(Self { name, type_restriction, position, decorators })\n \t}\n }\n \ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -71,9 +72,10 @@ impl DeclareVariableDeclaration {\n pub struct DeclareFunctionDeclaration {\n \tpub name: String,\n \tpub type_parameters: Option<Vec<GenericTypeConstraint>>,\n-\tpub parameters: TypeReferenceFunctionParameters,\n-\tpub return_type: Option<TypeReference>,\n-\tpub variable_id: VariableId,\n+\tpub parameters: TypeAnnotationFunctionParameters,\n+\tpub return_type: Option<TypeAnnotation>,\n+\t#[cfg(feature = \"extras\")]\n+\tpub performs: Option<AnnotationPerforms>,\n \tpub decorators: Vec<Decorator>,\n \tpub position: Span,\n }\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -86,7 +88,7 @@ impl ASTNode for DeclareFunctionDeclaration {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\treader.expect_next(TSXToken::Keyword(TSXKeyword::Declare))?;\n \t\tSelf::from_reader_sub_declare_with_decorators(reader, state, settings, Vec::new())\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -95,7 +97,7 @@ impl ASTNode for DeclareFunctionDeclaration {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tif settings.include_types {\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -117,7 +119,7 @@ impl DeclareFunctionDeclaration {\n \tpub fn from_reader_sub_declare_with_decorators(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\tdecorators: Vec<Decorator>,\n \t) -> ParseResult<Self> {\n \t\tlet start_pos = reader.expect_next(TSXToken::Keyword(TSXKeyword::Function))?;\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -131,28 +133,38 @@ impl DeclareFunctionDeclaration {\n \t\t\t} else {\n \t\t\t\tNone\n \t\t\t};\n-\t\tlet parameters = TypeReferenceFunctionParameters::from_reader(reader, state, settings)?;\n+\t\tlet parameters = TypeAnnotationFunctionParameters::from_reader(reader, state, settings)?;\n \t\tlet return_type = if let Some(Token(TSXToken::Colon, _)) = reader.peek() {\n \t\t\treader.next();\n-\t\t\tlet type_reference = TypeReference::from_reader(reader, state, settings)?;\n-\t\t\tSome(type_reference)\n+\t\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n+\t\t\tSome(type_annotation)\n \t\t} else {\n \t\t\tNone\n \t\t};\n+\n+\t\t#[cfg(feature = \"extras\")]\n+\t\tlet performs = if let Some(Token(TSXToken::Keyword(TSXKeyword::Performs), _)) = reader.peek() {\n+\t\t\tSome(AnnotationPerforms::from_reader(reader, state, settings)?)\n+\t\t} else {\n+\t\t\tNone\n+\t\t};\n+\n \t\tlet position = start_pos.union(\n \t\t\t&return_type\n \t\t\t\t.as_ref()\n \t\t\t\t.map(ASTNode::get_position)\n \t\t\t\t.unwrap_or(Cow::Borrowed(&parameters.position)),\n \t\t);\n+\n \t\tOk(Self {\n \t\t\tname,\n \t\t\ttype_parameters,\n \t\t\tparameters,\n \t\t\treturn_type,\n \t\t\tdecorators,\n-\t\t\tvariable_id: VariableId::new(),\n \t\t\tposition,\n+\t\t\t#[cfg(feature = \"extras\")]\n+\t\t\tperforms,\n \t\t})\n \t}\n }\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -161,9 +173,8 @@ impl DeclareFunctionDeclaration {\n pub struct DeclareClassDeclaration {\n \tpub name: String,\n \tpub type_parameters: Option<Vec<GenericTypeConstraint>>,\n-\tpub extends: Option<TypeReference>,\n-\tpub type_id: TypeId, // TODO:\n-\t                     // members: Vec<DeclareClassMember>\n+\tpub extends: Option<TypeAnnotation>,\n+\t// members: Vec<DeclareClassMember>\n }\n \n impl ASTNode for DeclareClassDeclaration {\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -174,7 +185,7 @@ impl ASTNode for DeclareClassDeclaration {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\treader.expect_next(TSXToken::Keyword(TSXKeyword::Declare))?;\n \t\tSelf::from_reader_sub_declare(reader, state, settings)\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -183,7 +194,7 @@ impl ASTNode for DeclareClassDeclaration {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\t_buf: &mut T,\n-\t\t_settings: &crate::ToStringSettings,\n+\t\t_settings: &crate::ToStringOptions,\n \t\t_depth: u8,\n \t) {\n \t\ttodo!()\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -194,7 +205,7 @@ impl DeclareClassDeclaration {\n \tpub(crate) fn from_reader_sub_declare(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\treader.expect_next(TSXToken::Keyword(TSXKeyword::Class))?;\n \t\tlet (name, _) =\ndiff --git a/parser/src/types/declares.rs b/parser/src/types/declares.rs\n--- a/parser/src/types/declares.rs\n+++ b/parser/src/types/declares.rs\n@@ -202,13 +213,13 @@ impl DeclareClassDeclaration {\n \t\tlet extends = if let Some(Token(TSXToken::Keyword(TSXKeyword::Extends), _)) = reader.peek()\n \t\t{\n \t\t\treader.next();\n-\t\t\tSome(TypeReference::from_reader(reader, state, settings)?)\n+\t\t\tSome(TypeAnnotation::from_reader(reader, state, settings)?)\n \t\t} else {\n \t\t\tNone\n \t\t};\n \t\treader.expect_next(TSXToken::OpenBrace)?;\n \t\t// TODO members\n \t\treader.expect_next(TSXToken::CloseBrace)?;\n-\t\tOk(Self { name, extends, type_parameters: None, type_id: TypeId::new() })\n+\t\tOk(Self { name, extends, type_parameters: None })\n \t}\n }\ndiff --git a/parser/src/types/enum_declaration.rs b/parser/src/types/enum_declaration.rs\n--- a/parser/src/types/enum_declaration.rs\n+++ b/parser/src/types/enum_declaration.rs\n@@ -25,7 +25,7 @@ impl ASTNode for EnumDeclaration {\n \tfn from_reader(\n \t\treader: &mut impl tokenizer_lib::TokenReader<crate::TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t) -> Result<Self, crate::ParseError> {\n \t\tlet const_pos = reader\n \t\t\t.conditional_next(|tok| matches!(tok, TSXToken::Keyword(TSXKeyword::Const)))\ndiff --git a/parser/src/types/enum_declaration.rs b/parser/src/types/enum_declaration.rs\n--- a/parser/src/types/enum_declaration.rs\n+++ b/parser/src/types/enum_declaration.rs\n@@ -59,7 +59,7 @@ impl ASTNode for EnumDeclaration {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tif self.is_constant {\ndiff --git a/parser/src/types/enum_declaration.rs b/parser/src/types/enum_declaration.rs\n--- a/parser/src/types/enum_declaration.rs\n+++ b/parser/src/types/enum_declaration.rs\n@@ -102,7 +102,7 @@ impl ASTNode for EnumMember {\n \tfn from_reader(\n \t\treader: &mut impl tokenizer_lib::TokenReader<crate::TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t) -> Result<Self, crate::ParseError> {\n \t\tlet (name, start_pos) =\n \t\t\ttoken_as_identifier(reader.next().ok_or_else(parse_lexing_error)?, \"Enum variant\")?;\ndiff --git a/parser/src/types/enum_declaration.rs b/parser/src/types/enum_declaration.rs\n--- a/parser/src/types/enum_declaration.rs\n+++ b/parser/src/types/enum_declaration.rs\n@@ -123,7 +123,7 @@ impl ASTNode for EnumMember {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -2,30 +2,29 @@ use std::borrow::Cow;\n \n use crate::{\n \terrors::parse_lexing_error,\n-\texpressions::ExpressionId,\n \textensions::decorators::Decorated,\n \tparse_bracketed, to_string_bracketed,\n \ttokens::token_as_identifier,\n \ttsx_keywords,\n-\ttypes::{type_declarations::*, type_references::TypeReferenceFunctionParameters},\n-\tASTNode, Block, Expression, GenericTypeConstraint, Keyword, NumberStructure, ParseError,\n-\tParseErrors, ParseResult, ParseSettings, PropertyId, PropertyKey, Span, TSXKeyword, TSXToken,\n-\tTypeId, TypeReference,\n+\ttypes::{type_annotations::TypeAnnotationFunctionParameters, type_declarations::*},\n+\tASTNode, Expression, GenericTypeConstraint, Keyword, NumberStructure, ParseError, ParseErrors,\n+\tParseOptions, ParseResult, PropertyKey, Span, TSXKeyword, TSXToken, TypeAnnotation,\n };\n \n use iterator_endiate::EndiateIteratorExt;\n use tokenizer_lib::{Token, TokenReader};\n \n+use super::AnnotationPerforms;\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub struct InterfaceDeclaration {\n \tpub name: String,\n \t#[cfg(feature = \"extras\")]\n \tpub nominal_keyword: Option<Keyword<tsx_keywords::Nominal>>,\n-\tpub type_id: TypeId,\n \tpub type_parameters: Option<Vec<GenericTypeConstraint>>,\n \t/// The document interface extends a multiple of other interfaces\n-\tpub extends: Option<Vec<TypeReference>>,\n+\tpub extends: Option<Vec<TypeAnnotation>>,\n \tpub members: Vec<Decorated<InterfaceMember>>,\n \tpub position: Span,\n }\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -51,7 +50,7 @@ impl ASTNode for InterfaceDeclaration {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet start = reader.expect_next(TSXToken::Keyword(TSXKeyword::Interface))?;\n \ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -64,19 +63,21 @@ impl ASTNode for InterfaceDeclaration {\n \n \t\tlet TypeDeclaration { name, type_parameters, .. } =\n \t\t\tTypeDeclaration::from_reader(reader, state, settings)?;\n-\t\tlet extends = if let TSXToken::Keyword(TSXKeyword::Extends) = reader.peek().unwrap().0 {\n+\n+\t\tlet extends = if let Some(Token(TSXToken::Keyword(TSXKeyword::Extends), _)) = reader.peek()\n+\t\t{\n \t\t\treader.next();\n-\t\t\tlet type_reference = TypeReference::from_reader(reader, state, settings)?;\n-\t\t\tlet mut extends = vec![type_reference];\n-\t\t\tif matches!(reader.peek().unwrap().0, TSXToken::Comma) {\n+\t\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n+\t\t\tlet mut extends = vec![type_annotation];\n+\t\t\tif matches!(reader.peek(), Some(Token(TSXToken::Comma, _))) {\n \t\t\t\treader.next();\n \t\t\t\tloop {\n-\t\t\t\t\textends.push(TypeReference::from_reader(reader, state, settings)?);\n-\t\t\t\t\tmatch reader.peek().unwrap().0 {\n-\t\t\t\t\t\tTSXToken::Comma => {\n+\t\t\t\t\textends.push(TypeAnnotation::from_reader(reader, state, settings)?);\n+\t\t\t\t\tmatch reader.peek() {\n+\t\t\t\t\t\tSome(Token(TSXToken::Comma, _)) => {\n \t\t\t\t\t\t\treader.next();\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tTSXToken::OpenBrace => break,\n+\t\t\t\t\t\tSome(Token(TSXToken::OpenBrace, _)) => break,\n \t\t\t\t\t\t_ => unimplemented!(),\n \t\t\t\t\t}\n \t\t\t\t}\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -85,6 +86,7 @@ impl ASTNode for InterfaceDeclaration {\n \t\t} else {\n \t\t\tNone\n \t\t};\n+\n \t\treader.expect_next(TSXToken::OpenBrace)?;\n \t\tlet members = parse_interface_members(reader, state, settings)?;\n \t\tlet position = start.union(&reader.expect_next(TSXToken::CloseBrace)?);\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -92,7 +94,6 @@ impl ASTNode for InterfaceDeclaration {\n \t\t\tnominal_keyword,\n \t\t\tname,\n \t\t\tmembers,\n-\t\t\ttype_id: TypeId::new(),\n \t\t\ttype_parameters,\n \t\t\textends,\n \t\t\tposition,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -102,7 +103,7 @@ impl ASTNode for InterfaceDeclaration {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tif settings.include_types {\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -126,7 +127,7 @@ impl ASTNode for InterfaceDeclaration {\n \t\t\t\tbuf.push_new_line();\n \t\t\t}\n \t\t\tfor member in self.members.iter() {\n-\t\t\t\tsettings.add_indent(depth, buf);\n+\t\t\t\tsettings.add_indent(depth + 1, buf);\n \t\t\t\tmember.to_string_from_buffer(buf, settings, depth + 1);\n \t\t\t\tif settings.pretty {\n \t\t\t\t\tbuf.push_new_line();\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -141,70 +142,23 @@ impl ASTNode for InterfaceDeclaration {\n \t}\n }\n \n-#[cfg(feature = \"extras\")]\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-#[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n-pub struct InterfaceMemberBody {\n-\tpub performs_keyword: Keyword<tsx_keywords::Performs>,\n-\tpub condition: Option<Box<crate::Expression>>,\n-\tpub body: Block,\n-}\n-\n-#[cfg(feature = \"extras\")]\n-impl ASTNode for InterfaceMemberBody {\n-\tfn get_position(&self) -> Cow<Span> {\n-\t\ttodo!()\n-\t}\n-\n-\tfn from_reader(\n-\t\treader: &mut impl TokenReader<TSXToken, Span>,\n-\t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n-\t) -> ParseResult<Self> {\n-\t\tlet performs_keyword =\n-\t\t\tKeyword::new(reader.expect_next(TSXToken::Keyword(TSXKeyword::Performs))?);\n-\t\tlet next_is_open_paren =\n-\t\t\treader.conditional_next(|tok| matches!(tok, TSXToken::OpenParentheses));\n-\t\tlet condition = if next_is_open_paren.is_some() {\n-\t\t\tlet expression = Expression::from_reader(reader, state, settings)?;\n-\t\t\treader.expect_next(TSXToken::CloseParentheses)?;\n-\t\t\tSome(Box::new(expression))\n-\t\t} else {\n-\t\t\tNone\n-\t\t};\n-\n-\t\tlet body = Block::from_reader(reader, state, settings)?;\n-\n-\t\tOk(InterfaceMemberBody { performs_keyword, condition, body })\n-\t}\n-\n-\tfn to_string_from_buffer<T: source_map::ToString>(\n-\t\t&self,\n-\t\t_buf: &mut T,\n-\t\t_settings: &crate::ToStringSettings,\n-\t\t_depth: u8,\n-\t) {\n-\t\ttodo!()\n-\t}\n-}\n-\n-/// This is also used for [TypeReference::ObjectLiteral]\n+/// This is also used for [TypeAnnotation::ObjectLiteral]\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum InterfaceMember {\n \tMethod {\n \t\tname: PropertyKey,\n \t\ttype_parameters: Option<Vec<GenericTypeConstraint>>,\n-\t\tparameters: TypeReferenceFunctionParameters,\n-\t\treturn_type: Option<TypeReference>,\n+\t\tparameters: TypeAnnotationFunctionParameters,\n+\t\treturn_type: Option<TypeAnnotation>,\n \t\tis_optional: bool,\n \t\t#[cfg(feature = \"extras\")]\n-\t\tbody: Option<InterfaceMemberBody>,\n+\t\tperforms: Option<AnnotationPerforms>,\n \t\tposition: Span,\n \t},\n \tProperty {\n \t\tname: PropertyKey,\n-\t\ttype_reference: TypeReference,\n+\t\ttype_annotation: TypeAnnotation,\n \t\tis_readonly: bool,\n \t\t/// Marked with `?:`\n \t\tis_optional: bool,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -212,8 +166,8 @@ pub enum InterfaceMember {\n \t},\n \tIndexer {\n \t\tname: String,\n-\t\tindexer_type: TypeReference,\n-\t\treturn_type: TypeReference,\n+\t\tindexer_type: TypeAnnotation,\n+\t\treturn_type: TypeAnnotation,\n \t\tis_readonly: bool,\n \t\tposition: Span,\n \t},\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -222,16 +176,16 @@ pub enum InterfaceMember {\n \t/// new (...params: any[]): HTMLElement\n \t/// ```\n \tConstructor {\n-\t\tparameters: TypeReferenceFunctionParameters,\n+\t\tparameters: TypeAnnotationFunctionParameters,\n \t\ttype_parameters: Option<Vec<GenericTypeConstraint>>,\n-\t\treturn_type: Option<TypeReference>,\n+\t\treturn_type: Option<TypeAnnotation>,\n \t\tis_readonly: bool,\n \t\tposition: Span,\n \t},\n \tCaller {\n-\t\tparameters: TypeReferenceFunctionParameters,\n+\t\tparameters: TypeAnnotationFunctionParameters,\n \t\ttype_parameters: Option<Vec<GenericTypeConstraint>>,\n-\t\treturn_type: Option<TypeReference>,\n+\t\treturn_type: Option<TypeAnnotation>,\n \t\tis_readonly: bool,\n \t\tposition: Span,\n \t},\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -239,10 +193,10 @@ pub enum InterfaceMember {\n \tRule {\n \t\tparameter: String,\n \t\trule: TypeRule,\n-\t\tmatching_type: Box<TypeReference>,\n+\t\tmatching_type: Box<TypeAnnotation>,\n \t\toptionality: Optionality,\n \t\tis_readonly: bool,\n-\t\toutput_type: Box<TypeReference>,\n+\t\toutput_type: Box<TypeAnnotation>,\n \t\tposition: Span,\n \t},\n \tComment(String),\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -252,7 +206,7 @@ impl ASTNode for InterfaceMember {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet readonly_pos = reader\n \t\t\t.conditional_next(|tok| matches!(tok, TSXToken::Keyword(TSXKeyword::Readonly)))\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -269,12 +223,11 @@ impl ASTNode for InterfaceMember {\n \t\t\t\tlet (name, end_pos) = match reader.next().ok_or_else(parse_lexing_error)? {\n \t\t\t\t\tToken(TSXToken::SingleQuotedStringLiteral(name), pos)\n \t\t\t\t\t| Token(TSXToken::DoubleQuotedStringLiteral(name), pos) => {\n-\t\t\t\t\t\t(PropertyKey::StringLiteral(name, PropertyId::new(), pos.clone()), pos)\n+\t\t\t\t\t\t(PropertyKey::StringLiteral(name, pos.clone()), pos)\n \t\t\t\t\t}\n \t\t\t\t\tToken(TSXToken::NumberLiteral(value), pos) => (\n \t\t\t\t\t\tPropertyKey::NumberLiteral(\n \t\t\t\t\t\t\tvalue.parse::<NumberStructure>().unwrap(),\n-\t\t\t\t\t\t\tPropertyId::new(),\n \t\t\t\t\t\t\tpos.clone(),\n \t\t\t\t\t\t),\n \t\t\t\t\t\tpos,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -285,8 +238,7 @@ impl ASTNode for InterfaceMember {\n \n \t\t\t\t\t\t// Catch for computed symbol: e.g. `[Symbol.instanceOf()]`, rather than indexer\n \t\t\t\t\t\tif let Some(Token(TSXToken::Dot, _)) = reader.peek() {\n-\t\t\t\t\t\t\tlet top =\n-\t\t\t\t\t\t\t\tExpression::VariableReference(name, name_pos, ExpressionId::new());\n+\t\t\t\t\t\t\tlet top = Expression::VariableReference(name, name_pos);\n \t\t\t\t\t\t\t// TODO bad\n \t\t\t\t\t\t\tlet expression = Expression::from_reader_sub_first_expression(\n \t\t\t\t\t\t\t\treader, state, settings, 0, top,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -295,7 +247,6 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\t\t\t(\n \t\t\t\t\t\t\t\tPropertyKey::Computed(\n \t\t\t\t\t\t\t\t\tBox::new(expression),\n-\t\t\t\t\t\t\t\t\tPropertyId::new(),\n \t\t\t\t\t\t\t\t\tstart_pos.union(&end_pos),\n \t\t\t\t\t\t\t\t),\n \t\t\t\t\t\t\t\tend_pos,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -305,11 +256,11 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\t\t\t\t// Indexed type\n \t\t\t\t\t\t\t\tToken(TSXToken::Colon, _) => {\n \t\t\t\t\t\t\t\t\tlet indexer_type =\n-\t\t\t\t\t\t\t\t\t\tTypeReference::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\t\t\t\t\tTypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\t\t\t\t\t\t\treader.expect_next(TSXToken::CloseBracket)?;\n \t\t\t\t\t\t\t\t\treader.expect_next(TSXToken::Colon)?;\n \t\t\t\t\t\t\t\t\tlet return_type =\n-\t\t\t\t\t\t\t\t\t\tTypeReference::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\t\t\t\t\tTypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\t\t\t\t\t\t\treturn Ok(InterfaceMember::Indexer {\n \t\t\t\t\t\t\t\t\t\tname,\n \t\t\t\t\t\t\t\t\t\tindexer_type,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -331,7 +282,7 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\t\t\t\t\t\tTypeRule::In\n \t\t\t\t\t\t\t\t\t};\n \t\t\t\t\t\t\t\t\tlet matching_type =\n-\t\t\t\t\t\t\t\t\t\tTypeReference::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\t\t\t\t\tTypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\t\t\t\t\t\t\treader.expect_next(TSXToken::CloseBracket)?;\n \t\t\t\t\t\t\t\t\t// TODO the -?: ?: : stuff '-?:' should be a token\n \t\t\t\t\t\t\t\t\tlet token = reader.next().ok_or_else(parse_lexing_error)?;\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -356,7 +307,7 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\t};\n \t\t\t\t\t\t\t\t\tlet output_type =\n-\t\t\t\t\t\t\t\t\t\tTypeReference::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\t\t\t\t\tTypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\t\t\t\t\t\t\tlet position = readonly_pos\n \t\t\t\t\t\t\t\t\t\t.unwrap_or(name_pos)\n \t\t\t\t\t\t\t\t\t\t.union(&output_type.get_position());\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -391,11 +342,11 @@ impl ASTNode for InterfaceMember {\n \t\t\t// Calling self\n \t\t\tTSXToken::OpenParentheses => {\n \t\t\t\tlet parameters =\n-\t\t\t\t\tTypeReferenceFunctionParameters::from_reader(reader, state, settings)?;\n+\t\t\t\t\tTypeAnnotationFunctionParameters::from_reader(reader, state, settings)?;\n \t\t\t\t// let parameters = function_parameters_from_reader(reader, state, settings)?;\n \t\t\t\tlet return_type = if let Some(Token(TSXToken::Colon, _)) = reader.peek() {\n \t\t\t\t\treader.next();\n-\t\t\t\t\tSome(TypeReference::from_reader(reader, state, settings)?)\n+\t\t\t\t\tSome(TypeAnnotation::from_reader(reader, state, settings)?)\n \t\t\t\t} else {\n \t\t\t\t\tNone\n \t\t\t\t};\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -419,10 +370,10 @@ impl ASTNode for InterfaceMember {\n \t\t\t\tlet (type_parameters, start_pos) =\n \t\t\t\t\tparse_bracketed(reader, state, settings, None, TSXToken::CloseChevron)?;\n \t\t\t\tlet parameters =\n-\t\t\t\t\tTypeReferenceFunctionParameters::from_reader(reader, state, settings)?;\n+\t\t\t\t\tTypeAnnotationFunctionParameters::from_reader(reader, state, settings)?;\n \t\t\t\tlet return_type = if let Some(Token(TSXToken::Colon, _)) = reader.peek() {\n \t\t\t\t\treader.next();\n-\t\t\t\t\tSome(TypeReference::from_reader(reader, state, settings)?)\n+\t\t\t\t\tSome(TypeAnnotation::from_reader(reader, state, settings)?)\n \t\t\t\t} else {\n \t\t\t\t\tNone\n \t\t\t\t};\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -451,10 +402,10 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\tNone\n \t\t\t\t};\n \t\t\t\tlet parameters =\n-\t\t\t\t\tTypeReferenceFunctionParameters::from_reader(reader, state, settings)?;\n+\t\t\t\t\tTypeAnnotationFunctionParameters::from_reader(reader, state, settings)?;\n \t\t\t\tlet return_type =\n \t\t\t\t\tif reader.conditional_next(|token| *token == TSXToken::Colon).is_some() {\n-\t\t\t\t\t\tSome(TypeReference::from_reader(reader, state, settings)?)\n+\t\t\t\t\t\tSome(TypeAnnotation::from_reader(reader, state, settings)?)\n \t\t\t\t\t} else {\n \t\t\t\t\t\tNone\n \t\t\t\t\t};\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -487,11 +438,7 @@ impl ASTNode for InterfaceMember {\n \t\t\t\tif let TSXToken::SingleQuotedStringLiteral(name)\n \t\t\t\t| TSXToken::DoubleQuotedStringLiteral(name) = token\n \t\t\t\t{\n-\t\t\t\t\t(\n-\t\t\t\t\t\tPropertyKey::StringLiteral(name, PropertyId::new(), position.clone()),\n-\t\t\t\t\t\tNone,\n-\t\t\t\t\t\tposition,\n-\t\t\t\t\t)\n+\t\t\t\t\t(PropertyKey::StringLiteral(name, position.clone()), None, position)\n \t\t\t\t} else {\n \t\t\t\t\tunreachable!()\n \t\t\t\t}\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -499,11 +446,7 @@ impl ASTNode for InterfaceMember {\n \t\t\t_ => {\n \t\t\t\tlet TypeDeclaration { name, type_parameters, position } =\n \t\t\t\t\tTypeDeclaration::from_reader(reader, state, settings)?;\n-\t\t\t\t(\n-\t\t\t\t\tPropertyKey::Ident(name, PropertyId::new(), position.clone()),\n-\t\t\t\t\ttype_parameters,\n-\t\t\t\t\tposition,\n-\t\t\t\t)\n+\t\t\t\t(PropertyKey::Ident(name, position.clone()), type_parameters, position)\n \t\t\t}\n \t\t};\n \ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -512,22 +455,23 @@ impl ASTNode for InterfaceMember {\n \t\t// TODO a little weird as only functions can have type parameters:\n \t\tmatch reader.next().ok_or_else(parse_lexing_error)? {\n \t\t\tToken(TSXToken::OpenParentheses, start_pos) => {\n-\t\t\t\tlet parameters = TypeReferenceFunctionParameters::from_reader_sub_open_parenthesis(\n-\t\t\t\t\treader, state, settings, start_pos,\n-\t\t\t\t)?;\n+\t\t\t\tlet parameters =\n+\t\t\t\t\tTypeAnnotationFunctionParameters::from_reader_sub_open_parenthesis(\n+\t\t\t\t\t\treader, state, settings, start_pos,\n+\t\t\t\t\t)?;\n \t\t\t\tposition = position.union(&parameters.position);\n \t\t\t\tlet return_type =\n \t\t\t\t\tif reader.conditional_next(|tok| matches!(tok, TSXToken::Colon)).is_some() {\n-\t\t\t\t\t\tlet type_reference = TypeReference::from_reader(reader, state, settings)?;\n-\t\t\t\t\t\tposition = position.union(&type_reference.get_position());\n-\t\t\t\t\t\tSome(type_reference)\n+\t\t\t\t\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\tposition = position.union(&type_annotation.get_position());\n+\t\t\t\t\t\tSome(type_annotation)\n \t\t\t\t\t} else {\n \t\t\t\t\t\tNone\n \t\t\t\t\t};\n \n \t\t\t\t#[cfg(feature = \"extras\")]\n-\t\t\t\tlet body = if let Some(Token(TSXToken::Keyword(TSXKeyword::Performs), _)) = reader.peek() {\n-\t\t\t\t\tSome(InterfaceMemberBody::from_reader(reader, state, settings)?)\n+\t\t\t\tlet performs = if let Some(Token(TSXToken::Keyword(TSXKeyword::Performs), _)) = reader.peek() {\n+\t\t\t\t\tSome(AnnotationPerforms::from_reader(reader, state, settings)?)\n \t\t\t\t} else {\n \t\t\t\t\tNone\n \t\t\t\t};\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -540,29 +484,29 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\tis_optional: false,\n \t\t\t\t\tposition,\n \t\t\t\t\t#[cfg(feature = \"extras\")]\n-\t\t\t\t\tbody,\n+\t\t\t\t\tperforms,\n \t\t\t\t})\n \t\t\t}\n \t\t\tToken(TSXToken::QuestionMark, _) => {\n \t\t\t\t// TODO this is a little weird, I don't think '?(' is a actual token and is\n \t\t\t\t// only used here. Making '?(' a token may break ternary where first expr is a group\n \t\t\t\tlet parameters =\n-\t\t\t\t\tTypeReferenceFunctionParameters::from_reader(reader, state, settings)?;\n+\t\t\t\t\tTypeAnnotationFunctionParameters::from_reader(reader, state, settings)?;\n \n \t\t\t\tposition = position.union(&parameters.position);\n \n \t\t\t\tlet return_type =\n \t\t\t\t\tif reader.conditional_next(|tok| matches!(tok, TSXToken::Colon)).is_some() {\n-\t\t\t\t\t\tlet type_reference = TypeReference::from_reader(reader, state, settings)?;\n-\t\t\t\t\t\tposition = position.union(&type_reference.get_position());\n-\t\t\t\t\t\tSome(type_reference)\n+\t\t\t\t\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\tposition = position.union(&type_annotation.get_position());\n+\t\t\t\t\t\tSome(type_annotation)\n \t\t\t\t\t} else {\n \t\t\t\t\t\tNone\n \t\t\t\t\t};\n \n \t\t\t\t#[cfg(feature = \"extras\")]\n-\t\t\t\tlet body = if let Some(Token(TSXToken::Keyword(TSXKeyword::Performs), _)) = reader.peek() {\n-\t\t\t\t\tSome(InterfaceMemberBody::from_reader(reader, state, settings)?)\n+\t\t\t\tlet performs = if let Some(Token(TSXToken::Keyword(TSXKeyword::Performs), _)) = reader.peek() {\n+\t\t\t\t\tSome(AnnotationPerforms::from_reader(reader, state, settings)?)\n \t\t\t\t} else {\n \t\t\t\t\tNone\n \t\t\t\t};\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -575,31 +519,31 @@ impl ASTNode for InterfaceMember {\n \t\t\t\t\tposition,\n \t\t\t\t\treturn_type,\n \t\t\t\t\t#[cfg(feature = \"extras\")]\n-\t\t\t\t\tbody,\n+\t\t\t\t\tperforms,\n \t\t\t\t})\n \t\t\t}\n \t\t\tToken(TSXToken::Colon, _) => {\n-\t\t\t\tlet mut type_reference = TypeReference::from_reader(reader, state, settings)?;\n+\t\t\t\tlet mut type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\t\tif is_readonly {\n \t\t\t\t\t// TODO positioning:\n-\t\t\t\t\tposition = position.union(&type_reference.get_position());\n-\t\t\t\t\ttype_reference =\n-\t\t\t\t\t\tTypeReference::Readonly(Box::new(type_reference), position.clone());\n+\t\t\t\t\tposition = position.union(&type_annotation.get_position());\n+\t\t\t\t\ttype_annotation =\n+\t\t\t\t\t\tTypeAnnotation::Readonly(Box::new(type_annotation), position.clone());\n \t\t\t\t}\n \t\t\t\tOk(InterfaceMember::Property {\n \t\t\t\t\tname,\n \t\t\t\t\tposition,\n-\t\t\t\t\ttype_reference,\n+\t\t\t\t\ttype_annotation,\n \t\t\t\t\tis_optional: false,\n \t\t\t\t\tis_readonly,\n \t\t\t\t})\n \t\t\t}\n \t\t\tToken(TSXToken::OptionalMember, _) => {\n-\t\t\t\tlet type_reference = TypeReference::from_reader(reader, state, settings)?;\n-\t\t\t\tlet position = position.union(&type_reference.get_position());\n+\t\t\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n+\t\t\t\tlet position = position.union(&type_annotation.get_position());\n \t\t\t\tOk(InterfaceMember::Property {\n \t\t\t\t\tname,\n-\t\t\t\t\ttype_reference,\n+\t\t\t\t\ttype_annotation,\n \t\t\t\t\tis_optional: true,\n \t\t\t\t\tis_readonly,\n \t\t\t\t\tposition,\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -623,18 +567,18 @@ impl ASTNode for InterfaceMember {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\n-\t\t\tSelf::Property { name, type_reference, is_readonly, .. } => {\n+\t\t\tSelf::Property { name, type_annotation, is_readonly, .. } => {\n \t\t\t\tif *is_readonly {\n \t\t\t\t\tbuf.push_str(\"readonly \");\n \t\t\t\t}\n \t\t\t\tname.to_string_from_buffer(buf, settings, depth);\n \t\t\t\tbuf.push(':');\n \t\t\t\tsettings.add_gap(buf);\n-\t\t\t\ttype_reference.to_string_from_buffer(buf, settings, depth);\n+\t\t\t\ttype_annotation.to_string_from_buffer(buf, settings, depth);\n \t\t\t}\n \t\t\tSelf::Method {\n \t\t\t\tname, type_parameters, parameters, return_type, is_optional, ..\ndiff --git a/parser/src/types/interface.rs b/parser/src/types/interface.rs\n--- a/parser/src/types/interface.rs\n+++ b/parser/src/types/interface.rs\n@@ -686,7 +630,7 @@ impl ASTNode for InterfaceMember {\n pub(crate) fn parse_interface_members(\n \treader: &mut impl TokenReader<TSXToken, Span>,\n \tstate: &mut crate::ParsingState,\n-\tsettings: &ParseSettings,\n+\tsettings: &ParseOptions,\n ) -> ParseResult<Vec<Decorated<InterfaceMember>>> {\n \tlet mut members = Vec::new();\n \tloop {\ndiff --git a/parser/src/types/mod.rs b/parser/src/types/mod.rs\n--- a/parser/src/types/mod.rs\n+++ b/parser/src/types/mod.rs\n@@ -3,48 +3,15 @@ pub mod enum_declaration;\n pub mod interface;\n pub mod namespace;\n pub mod type_alias;\n+pub mod type_annotations;\n pub mod type_declarations;\n-pub mod type_references;\n \n-pub use interface::InterfaceDeclaration;\n-\n-use std::sync::atomic::{AtomicU16, Ordering};\n-\n-use derive_debug_extras::DebugExtras;\n-\n-static TYPE_COUNTER: AtomicU16 = AtomicU16::new(1);\n+use std::borrow::Cow;\n \n-/// A id of a syntax types\n-#[derive(PartialEq, Eq, Clone, Copy, DebugExtras, Hash)]\n-pub struct TypeId(u16);\n-\n-impl TypeId {\n-\tpub fn new() -> Self {\n-\t\tTypeId(TYPE_COUNTER.fetch_add(1, Ordering::SeqCst))\n-\t}\n-\n-\tpub const fn new_from_id(id: u16) -> Self {\n-\t\tTypeId(id)\n-\t}\n-\n-\t#[doc(hidden)]\n-\tpub fn unwrap_identifier(self) -> u16 {\n-\t\tself.0\n-\t}\n+pub use interface::InterfaceDeclaration;\n+use source_map::Span;\n \n-\tpub const NULL: Self = Self(0);\n-}\n-\n-// TODO not sure\n-#[cfg(feature = \"self-rust-tokenize\")]\n-impl self_rust_tokenize::SelfRustTokenize for TypeId {\n-\tfn append_to_token_stream(\n-\t\t&self,\n-\t\ttoken_stream: &mut self_rust_tokenize::proc_macro2::TokenStream,\n-\t) {\n-\t\ttoken_stream.extend(self_rust_tokenize::quote!(TypeId::new()))\n-\t}\n-}\n+use crate::{tsx_keywords, ASTNode, Block, Keyword};\n \n // [See](https://www.typescriptlang.org/docs/handbook/2/classes.html#member-visibility)\n // #[derive(Debug, Clone, PartialEq, Eq)]\ndiff --git a/parser/src/types/mod.rs b/parser/src/types/mod.rs\n--- a/parser/src/types/mod.rs\n+++ b/parser/src/types/mod.rs\n@@ -63,3 +30,50 @@ impl self_rust_tokenize::SelfRustTokenize for TypeId {\n // \t\t}\n // \t}\n // }\n+\n+#[cfg(feature = \"extras\")]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+#[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n+pub enum AnnotationPerforms {\n+\tPerformsStatements { performs_keyword: Keyword<tsx_keywords::Performs>, statements: Block },\n+\tPerformsConst { performs_keyword: Keyword<tsx_keywords::Performs>, identifier: String },\n+}\n+\n+#[cfg(feature = \"extras\")]\n+impl ASTNode for AnnotationPerforms {\n+\tfn get_position(&self) -> Cow<Span> {\n+\t\ttodo!()\n+\t}\n+\n+\tfn from_reader(\n+\t\treader: &mut impl tokenizer_lib::TokenReader<crate::TSXToken, Span>,\n+\t\tstate: &mut crate::ParsingState,\n+\t\tsettings: &crate::ParseOptions,\n+\t) -> crate::ParseResult<Self> {\n+\t\tlet performs_keyword = Keyword::new(\n+\t\t\treader.expect_next(crate::TSXToken::Keyword(crate::TSXKeyword::Performs))?,\n+\t\t);\n+\t\tif let Some(tokenizer_lib::Token(crate::TSXToken::OpenBrace, _)) = reader.peek() {\n+\t\t\t// let expression = Expression::from_reader(reader, state, settings)?;\n+\t\t\t// reader.expect_next(TSXToken::CloseParentheses)?;\n+\t\t\t// Some(Box::new(expression))\n+\n+\t\t\tlet body = Block::from_reader(reader, state, settings)?;\n+\t\t\tOk(AnnotationPerforms::PerformsStatements { performs_keyword, statements: body })\n+\t\t} else {\n+\t\t\treader.expect_next(crate::TSXToken::Keyword(crate::TSXKeyword::Const))?;\n+\t\t\tlet (identifier, _) =\n+\t\t\t\tcrate::tokens::token_as_identifier(reader.next().unwrap(), \"performs const\")?;\n+\t\t\tOk(AnnotationPerforms::PerformsConst { performs_keyword, identifier })\n+\t\t}\n+\t}\n+\n+\tfn to_string_from_buffer<T: source_map::ToString>(\n+\t\t&self,\n+\t\t_buf: &mut T,\n+\t\t_settings: &crate::ToStringOptions,\n+\t\t_depth: u8,\n+\t) {\n+\t\ttodo!()\n+\t}\n+}\ndiff --git a/parser/src/types/namespace.rs b/parser/src/types/namespace.rs\n--- a/parser/src/types/namespace.rs\n+++ b/parser/src/types/namespace.rs\n@@ -11,7 +11,7 @@ impl crate::ASTNode for Namespace {\n \tfn from_reader(\n \t\treader: &mut impl tokenizer_lib::TokenReader<crate::TSXToken, source_map::Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t) -> crate::ParseResult<Self> {\n \t\treader.expect_next(crate::TSXToken::Keyword(crate::TSXKeyword::Namespace))?;\n \t\tlet (namespace_name, _) = crate::tokens::token_as_identifier(\ndiff --git a/parser/src/types/namespace.rs b/parser/src/types/namespace.rs\n--- a/parser/src/types/namespace.rs\n+++ b/parser/src/types/namespace.rs\n@@ -38,7 +38,7 @@ impl crate::ASTNode for Namespace {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\t_buf: &mut T,\n-\t\t_settings: &crate::ToStringSettings,\n+\t\t_settings: &crate::ToStringOptions,\n \t\t_depth: u8,\n \t) {\n \t\ttodo!()\ndiff --git a/parser/src/types/type_alias.rs b/parser/src/types/type_alias.rs\n--- a/parser/src/types/type_alias.rs\n+++ b/parser/src/types/type_alias.rs\n@@ -1,14 +1,13 @@\n use source_map::Span;\n \n-use crate::{ASTNode, TSXToken, TypeDeclaration, TypeId, TypeReference};\n+use crate::{ASTNode, TSXToken, TypeAnnotation, TypeDeclaration};\n \n /// e.g. `type NumberArray = Array<number>`\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub struct TypeAlias {\n \tpub type_name: TypeDeclaration,\n-\tpub type_expression: TypeReference,\n-\tpub type_id: TypeId,\n+\tpub type_expression: TypeAnnotation,\n \tposition: Span,\n }\n \ndiff --git a/parser/src/types/type_alias.rs b/parser/src/types/type_alias.rs\n--- a/parser/src/types/type_alias.rs\n+++ b/parser/src/types/type_alias.rs\n@@ -20,20 +19,20 @@ impl ASTNode for TypeAlias {\n \tfn from_reader(\n \t\treader: &mut impl tokenizer_lib::TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &crate::ParseSettings,\n+\t\tsettings: &crate::ParseOptions,\n \t) -> crate::ParseResult<Self> {\n \t\tlet start = reader.expect_next(TSXToken::Keyword(crate::TSXKeyword::Type))?;\n \t\tlet type_name = TypeDeclaration::from_reader(reader, state, settings)?;\n \t\treader.expect_next(TSXToken::Assign)?;\n-\t\tlet type_expression = TypeReference::from_reader(reader, state, settings)?;\n+\t\tlet type_expression = TypeAnnotation::from_reader(reader, state, settings)?;\n \t\tlet position = start.union(&type_expression.get_position());\n-\t\tOk(Self { type_name, type_expression, type_id: TypeId::new(), position })\n+\t\tOk(Self { type_name, type_expression, position })\n \t}\n \n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tif settings.include_types {\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -3,8 +3,8 @@ use std::borrow::Cow;\n use crate::tsx_keywords::New;\n use crate::{\n \terrors::parse_lexing_error, expressions::TemplateLiteralPart,\n-\textensions::decorators::Decorated, CursorId, Decorator, Keyword, ParseResult, TypeId,\n-\tVariableField, VariableFieldInTypeReference, WithComment,\n+\textensions::decorators::Decorated, CursorId, Decorator, Keyword, ParseResult, VariableField,\n+\tVariableFieldInTypeAnnotation, WithComment,\n };\n use crate::{parse_bracketed, to_string_bracketed};\n use derive_partial_eq_extras::PartialEqExtras;\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -16,7 +16,7 @@ use super::{\n };\n \n use crate::{\n-\ttokens::token_as_identifier, ASTNode, NumberStructure, ParseError, ParseSettings, Span,\n+\ttokens::token_as_identifier, ASTNode, NumberStructure, ParseError, ParseOptions, Span,\n \tTSXKeyword, TSXToken, Token, TokenReader,\n };\n \ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -26,17 +26,17 @@ use crate::{\n #[derive(Debug, Clone, PartialEqExtras, Eq)]\n #[partial_eq_ignore_types(Span, TypeId)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n-pub enum TypeReference {\n+pub enum TypeAnnotation {\n \t/// A name e.g. `IPost`\n \tName(String, Span),\n \t/// A name e.g. `Intl.IPost`. TODO can there be more than 2 members\n \tNamespacedName(String, String, Span),\n \t/// A name with generics e.g. `Array<number>`\n-\tNameWithGenericArguments(String, Vec<TypeReference>, Span),\n+\tNameWithGenericArguments(String, Vec<TypeAnnotation>, Span),\n \t/// Union e.g. `number | string`\n-\tUnion(Vec<TypeReference>),\n+\tUnion(Vec<TypeAnnotation>),\n \t/// Intersection e.g. `c & d`\n-\tIntersection(Vec<TypeReference>),\n+\tIntersection(Vec<TypeAnnotation>),\n \t/// String literal e.g. `\"foo\"`\n \tStringLiteral(String, Span),\n \t/// Number literal e.g. `45`\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -44,38 +44,36 @@ pub enum TypeReference {\n \t/// Boolean literal e.g. `true`\n \tBooleanLiteral(bool, Span),\n \t/// Array literal e.g. `string[]`. This is syntactic sugar for `Array` with type arguments. **This is not the same\n-\t/// as a [TypeReference::TupleLiteral]**\n-\tArrayLiteral(Box<TypeReference>, Span),\n+\t/// as a [TypeAnnotation::TupleLiteral]**\n+\tArrayLiteral(Box<TypeAnnotation>, Span),\n \t/// Function literal e.g. `(x: string) => string`\n \tFunctionLiteral {\n \t\ttype_parameters: Option<Vec<GenericTypeConstraint>>,\n-\t\tparameters: TypeReferenceFunctionParameters,\n-\t\treturn_type: Box<TypeReference>,\n-\t\t/// TODO...\n-\t\ttype_id: TypeId,\n+\t\tparameters: TypeAnnotationFunctionParameters,\n+\t\treturn_type: Box<TypeAnnotation>,\n \t},\n \t/// Construction literal e.g. `new (x: string) => string`\n \tConstructorLiteral {\n \t\tnew_keyword: Keyword<New>,\n \t\ttype_parameters: Option<Vec<GenericTypeConstraint>>,\n-\t\tparameters: TypeReferenceFunctionParameters,\n-\t\treturn_type: Box<TypeReference>,\n+\t\tparameters: TypeAnnotationFunctionParameters,\n+\t\treturn_type: Box<TypeAnnotation>,\n \t},\n \t/// Object literal e.g. `{ y: string }`\n \t/// Here [TypeId] refers to the type it declares\n-\tObjectLiteral(Vec<Decorated<InterfaceMember>>, TypeId, Span),\n+\tObjectLiteral(Vec<Decorated<InterfaceMember>>, Span),\n \t/// Tuple literal e.g. `[number, x: string]`\n-\tTupleLiteral(Vec<TupleElement>, TypeId, Span),\n+\tTupleLiteral(Vec<TupleElement>, Span),\n \t///\n-\tTemplateLiteral(Vec<TemplateLiteralPart<TypeReference>>, Span),\n+\tTemplateLiteral(Vec<TemplateLiteralPart<TypeAnnotation>>, Span),\n \t/// Declares type as not assignable (still has interior mutability) e.g. `readonly number`\n-\tReadonly(Box<TypeReference>, Span),\n+\tReadonly(Box<TypeAnnotation>, Span),\n \t/// Declares type as being union type of all property types e.g. `T[K]`\n-\tIndex(Box<TypeReference>, Box<TypeReference>, Span),\n+\tIndex(Box<TypeAnnotation>, Box<TypeAnnotation>, Span),\n \t/// KeyOf\n-\tKeyOf(Box<TypeReference>, Span),\n+\tKeyOf(Box<TypeAnnotation>, Span),\n \t/// For operation precedence reasons\n-\tParenthesizedReference(Box<TypeReference>, Span),\n+\tParenthesizedReference(Box<TypeAnnotation>, Span),\n \tConditional {\n \t\tcondition: TypeCondition,\n \t\tresolve_true: TypeConditionResult,\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -84,39 +82,39 @@ pub enum TypeReference {\n \t},\n \tDecorated(Decorator, Box<Self>, Span),\n \t#[self_tokenize_field(0)]\n-\tCursor(CursorId<TypeReference>, Span),\n+\tCursor(CursorId<TypeAnnotation>, Span),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum TupleElement {\n-\tNonSpread { name: Option<String>, ty: TypeReference },\n-\tSpread { name: Option<String>, ty: TypeReference },\n+\tNonSpread { name: Option<String>, ty: TypeAnnotation },\n+\tSpread { name: Option<String>, ty: TypeAnnotation },\n }\n \n-/// Condition in a [TypeReference::Conditional]\n+/// Condition in a [TypeAnnotation::Conditional]\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum TypeCondition {\n-\tExtends { r#type: Box<TypeReference>, extends: Box<TypeReference>, position: Span },\n-\tIs { r#type: Box<TypeReference>, is: Box<TypeReference>, position: Span },\n+\tExtends { ty: Box<TypeAnnotation>, extends: Box<TypeAnnotation>, position: Span },\n+\tIs { ty: Box<TypeAnnotation>, is: Box<TypeAnnotation>, position: Span },\n }\n \n impl TypeCondition {\n \tpub(crate) fn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\n-\t\t\tTypeCondition::Extends { r#type, extends, .. } => {\n-\t\t\t\tr#type.to_string_from_buffer(buf, settings, depth);\n+\t\t\tTypeCondition::Extends { ty, extends, .. } => {\n+\t\t\t\tty.to_string_from_buffer(buf, settings, depth);\n \t\t\t\tbuf.push_str(\" extends \");\n \t\t\t\textends.to_string_from_buffer(buf, settings, depth);\n \t\t\t}\n-\t\t\tTypeCondition::Is { r#type, is, .. } => {\n-\t\t\t\tr#type.to_string_from_buffer(buf, settings, depth);\n+\t\t\tTypeCondition::Is { ty, is, .. } => {\n+\t\t\t\tty.to_string_from_buffer(buf, settings, depth);\n \t\t\t\tbuf.push_str(\" is \");\n \t\t\t\tis.to_string_from_buffer(buf, settings, depth);\n \t\t\t}\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -132,13 +130,13 @@ impl TypeCondition {\n \t}\n }\n \n-/// The result of a [TypeReference::Condition]\n+/// The result of a [TypeAnnotation::Condition]\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum TypeConditionResult {\n \t/// TODO e.g. `infer number`\n-\tInfer(Box<TypeReference>, Span),\n-\tReference(Box<TypeReference>),\n+\tInfer(Box<TypeAnnotation>, Span),\n+\tReference(Box<TypeAnnotation>),\n }\n \n impl ASTNode for TypeConditionResult {\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -152,15 +150,15 @@ impl ASTNode for TypeConditionResult {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tif matches!(reader.peek().unwrap().0, TSXToken::Keyword(TSXKeyword::Infer)) {\n \t\t\tlet Token(_, start) = reader.next().unwrap();\n-\t\t\tlet inferred_type = TypeReference::from_reader(reader, state, settings)?;\n+\t\t\tlet inferred_type = TypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\tlet position = start.union(&inferred_type.get_position());\n \t\t\tOk(Self::Infer(Box::new(inferred_type), position))\n \t\t} else {\n-\t\t\tTypeReference::from_reader(reader, state, settings)\n+\t\t\tTypeAnnotation::from_reader(reader, state, settings)\n \t\t\t\t.map(|ty_ref| Self::Reference(Box::new(ty_ref)))\n \t\t}\n \t}\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -168,7 +166,7 @@ impl ASTNode for TypeConditionResult {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -183,11 +181,11 @@ impl ASTNode for TypeConditionResult {\n \t}\n }\n \n-impl ASTNode for TypeReference {\n+impl ASTNode for TypeAnnotation {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tSelf::from_reader_with_config(reader, state, settings, false)\n \t}\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -195,7 +193,7 @@ impl ASTNode for TypeReference {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -204,10 +202,10 @@ impl ASTNode for TypeReference {\n \t\t\t\t\tpanic!()\n \t\t\t\t}\n \t\t\t}\n-\t\t\tSelf::Decorated(decorator, on_type_reference, _) => {\n+\t\t\tSelf::Decorated(decorator, on_type_annotation, _) => {\n \t\t\t\tdecorator.to_string_from_buffer(buf, settings, depth);\n \t\t\t\tbuf.push(' ');\n-\t\t\t\ton_type_reference.to_string_from_buffer(buf, settings, depth)\n+\t\t\t\ton_type_annotation.to_string_from_buffer(buf, settings, depth)\n \t\t\t}\n \t\t\tSelf::Name(name, _) => buf.push_str(name),\n \t\t\tSelf::NameWithGenericArguments(name, arguments, _) => {\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -250,7 +248,7 @@ impl ASTNode for TypeReference {\n \t\t\t\t}\n \t\t\t}\n \t\t\tSelf::NamespacedName(..) => unimplemented!(),\n-\t\t\tSelf::ObjectLiteral(members, _, _) => {\n+\t\t\tSelf::ObjectLiteral(members, _) => {\n \t\t\t\tbuf.push('{');\n \t\t\t\tfor (at_end, member) in members.iter().endiate() {\n \t\t\t\t\tmember.to_string_from_buffer(buf, settings, depth);\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -260,7 +258,7 @@ impl ASTNode for TypeReference {\n \t\t\t\t}\n \t\t\t\tbuf.push('}');\n \t\t\t}\n-\t\t\tSelf::TupleLiteral(members, _, _) => {\n+\t\t\tSelf::TupleLiteral(members, _) => {\n \t\t\t\tbuf.push('[');\n \t\t\t\tfor (at_end, member) in members.iter().endiate() {\n \t\t\t\t\tmatch member {\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -342,8 +340,8 @@ impl ASTNode for TypeReference {\n \t\t\t| Self::NumberLiteral(_, position)\n \t\t\t| Self::Readonly(_, position)\n \t\t\t| Self::Conditional { position, .. }\n-\t\t\t| Self::ObjectLiteral(_, _, position)\n-\t\t\t| Self::TupleLiteral(_, _, position)\n+\t\t\t| Self::ObjectLiteral(_, position)\n+\t\t\t| Self::TupleLiteral(_, position)\n \t\t\t| Self::Index(_, _, position)\n \t\t\t| Self::KeyOf(_, position)\n \t\t\t| Self::ParenthesizedReference(_, position)\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -363,13 +361,13 @@ impl ASTNode for TypeReference {\n \t}\n }\n \n-impl TypeReference {\n+impl TypeAnnotation {\n \t/// Also returns the depth the generic arguments ran over\n \t/// TODO refactor and tidy a lot of this\n \tpub(crate) fn from_reader_with_config(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\treturn_on_union_or_intersection: bool,\n \t) -> ParseResult<Self> {\n \t\twhile let Some(Token(TSXToken::Comment(_) | TSXToken::MultiLineComment(_), _)) =\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -413,7 +411,7 @@ impl TypeReference {\n \t\t\t\t// If arrow function OR group\n \t\t\t\tif let Some(Token(TSXToken::Arrow, _)) = next {\n \t\t\t\t\tlet parameters =\n-\t\t\t\t\t\tTypeReferenceFunctionParameters::from_reader_sub_open_parenthesis(\n+\t\t\t\t\t\tTypeAnnotationFunctionParameters::from_reader_sub_open_parenthesis(\n \t\t\t\t\t\t\treader,\n \t\t\t\t\t\t\tstate,\n \t\t\t\t\t\t\tsettings,\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -424,27 +422,25 @@ impl TypeReference {\n \t\t\t\t\tSelf::FunctionLiteral {\n \t\t\t\t\t\ttype_parameters: None,\n \t\t\t\t\t\tparameters,\n-\t\t\t\t\t\ttype_id: TypeId::new(),\n \t\t\t\t\t\treturn_type: Box::new(return_type),\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tlet type_reference = Self::from_reader(reader, state, settings)?;\n+\t\t\t\t\tlet type_annotation = Self::from_reader(reader, state, settings)?;\n \t\t\t\t\tlet end_position = reader.expect_next(TSXToken::CloseParentheses)?;\n \t\t\t\t\tlet position = start_position.union(&end_position);\n-\t\t\t\t\tSelf::ParenthesizedReference(type_reference.into(), position)\n+\t\t\t\t\tSelf::ParenthesizedReference(type_annotation.into(), position)\n \t\t\t\t}\n \t\t\t}\n \t\t\tToken(TSXToken::OpenChevron, _start) => {\n \t\t\t\tlet (type_parameters, _) =\n \t\t\t\t\tparse_bracketed(reader, state, settings, None, TSXToken::CloseChevron)?;\n \t\t\t\tlet parameters =\n-\t\t\t\t\tTypeReferenceFunctionParameters::from_reader(reader, state, settings)?;\n+\t\t\t\t\tTypeAnnotationFunctionParameters::from_reader(reader, state, settings)?;\n \t\t\t\treader.expect_next(TSXToken::Arrow)?;\n \t\t\t\tlet return_type = Self::from_reader(reader, state, settings)?;\n \t\t\t\tSelf::FunctionLiteral {\n \t\t\t\t\ttype_parameters: Some(type_parameters),\n \t\t\t\t\tparameters,\n-\t\t\t\t\ttype_id: TypeId::new(),\n \t\t\t\t\treturn_type: Box::new(return_type),\n \t\t\t\t}\n \t\t\t}\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -452,7 +448,7 @@ impl TypeReference {\n \t\t\tToken(TSXToken::OpenBrace, start) => {\n \t\t\t\tlet members = parse_interface_members(reader, state, settings)?;\n \t\t\t\tlet position = start.union(&reader.expect_next(TSXToken::CloseBrace)?);\n-\t\t\t\tSelf::ObjectLiteral(members, TypeId::new(), position)\n+\t\t\t\tSelf::ObjectLiteral(members, position)\n \t\t\t}\n \t\t\t// Tuple literal type\n \t\t\tToken(TSXToken::OpenBracket, start_pos) => {\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -473,10 +469,10 @@ impl TypeReference {\n \t\t\t\t\t};\n \t\t\t\t\tlet member = if let Some(Token(TSXToken::Spread, _)) = reader.peek() {\n \t\t\t\t\t\treader.next();\n-\t\t\t\t\t\tlet ty = TypeReference::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\tlet ty = TypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\t\t\t\tTupleElement::Spread { name, ty }\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tlet ty = TypeReference::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\tlet ty = TypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\t\t\t\tTupleElement::NonSpread { name, ty }\n \t\t\t\t\t};\n \t\t\t\t\tmembers.push(member);\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -487,7 +483,7 @@ impl TypeReference {\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tlet end_pos = reader.expect_next(TSXToken::CloseBracket)?;\n-\t\t\t\tSelf::TupleLiteral(members, TypeId::new(), start_pos.union(&end_pos))\n+\t\t\t\tSelf::TupleLiteral(members, start_pos.union(&end_pos))\n \t\t\t}\n \t\t\tToken(TSXToken::TemplateLiteralStart, start) => {\n \t\t\t\tlet mut parts = Vec::new();\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -498,7 +494,7 @@ impl TypeReference {\n \t\t\t\t\t\t\tparts.push(TemplateLiteralPart::Static(chunk));\n \t\t\t\t\t\t}\n \t\t\t\t\t\tToken(TSXToken::TemplateLiteralExpressionStart, _) => {\n-\t\t\t\t\t\t\tlet expression = TypeReference::from_reader(reader, state, settings)?;\n+\t\t\t\t\t\t\tlet expression = TypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\t\t\t\t\treader.expect_next(TSXToken::TemplateLiteralExpressionEnd)?;\n \t\t\t\t\t\t\tparts.push(TemplateLiteralPart::Dynamic(Box::new(expression)));\n \t\t\t\t\t\t}\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -511,14 +507,14 @@ impl TypeReference {\n \t\t\t\tSelf::TemplateLiteral(parts, start.union(&end.unwrap()))\n \t\t\t}\n \t\t\tToken(TSXToken::Keyword(TSXKeyword::Readonly), start) => {\n-\t\t\t\tlet readonly_type = TypeReference::from_reader(reader, state, settings)?;\n+\t\t\t\tlet readonly_type = TypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\t\tlet position = start.union(&readonly_type.get_position());\n-\t\t\t\treturn Ok(TypeReference::Readonly(Box::new(readonly_type), position));\n+\t\t\t\treturn Ok(TypeAnnotation::Readonly(Box::new(readonly_type), position));\n \t\t\t}\n \t\t\tToken(TSXToken::Keyword(TSXKeyword::KeyOf), start) => {\n-\t\t\t\tlet key_of_type = TypeReference::from_reader(reader, state, settings)?;\n+\t\t\t\tlet key_of_type = TypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\t\tlet position = start.union(&key_of_type.get_position());\n-\t\t\t\treturn Ok(TypeReference::KeyOf(Box::new(key_of_type), position));\n+\t\t\t\treturn Ok(TypeAnnotation::KeyOf(Box::new(key_of_type), position));\n \t\t\t}\n \t\t\tToken(TSXToken::Keyword(TSXKeyword::New), span) => {\n \t\t\t\tlet type_parameters = reader\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -530,7 +526,7 @@ impl TypeReference {\n \t\t\t\t\t})\n \t\t\t\t\t.transpose()?;\n \t\t\t\tlet parameters =\n-\t\t\t\t\tTypeReferenceFunctionParameters::from_reader(reader, state, settings)?;\n+\t\t\t\t\tTypeAnnotationFunctionParameters::from_reader(reader, state, settings)?;\n \n \t\t\t\treader.expect_next(TSXToken::Arrow)?;\n \t\t\t\tlet return_type = Self::from_reader(reader, state, settings)?;\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -554,7 +550,7 @@ impl TypeReference {\n \t\t\tlet (namespace_member, end) =\n \t\t\t\ttoken_as_identifier(reader.next().unwrap(), \"namespace name\")?;\n \t\t\tlet position = start.union(&end);\n-\t\t\treturn Ok(TypeReference::NamespacedName(name, namespace_member, position));\n+\t\t\treturn Ok(TypeAnnotation::NamespacedName(name, namespace_member, position));\n \t\t}\n \t\t// Generics arguments:\n \t\tif let Some(Token(TSXToken::OpenChevron, _position)) = reader.peek() {\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -593,7 +589,7 @@ impl TypeReference {\n \t\t\t\treference = Self::ArrayLiteral(Box::new(reference), position);\n \t\t\t} else {\n \t\t\t\t// E.g type allTypes = Person[keyof Person];\n-\t\t\t\tlet indexer = TypeReference::from_reader(reader, state, settings)?;\n+\t\t\t\tlet indexer = TypeAnnotation::from_reader(reader, state, settings)?;\n \t\t\t\tlet position = start.union(&reader.expect_next(TSXToken::CloseBracket)?);\n \t\t\t\treference = Self::Index(Box::new(reference), Box::new(indexer), position);\n \t\t\t}\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -604,11 +600,11 @@ impl TypeReference {\n \t\t\tSome(Token(TSXToken::Keyword(TSXKeyword::Extends), _)) => {\n \t\t\t\treader.next();\n \t\t\t\tlet extends_type =\n-\t\t\t\t\tTypeReference::from_reader_with_config(reader, state, settings, true)?;\n+\t\t\t\t\tTypeAnnotation::from_reader_with_config(reader, state, settings, true)?;\n \t\t\t\t// TODO depth\n \t\t\t\tlet position = reference.get_position().union(&extends_type.get_position());\n \t\t\t\tlet condition = TypeCondition::Extends {\n-\t\t\t\t\tr#type: Box::new(reference),\n+\t\t\t\t\tty: Box::new(reference),\n \t\t\t\t\textends: Box::new(extends_type),\n \t\t\t\t\tposition,\n \t\t\t\t};\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -622,7 +618,7 @@ impl TypeReference {\n \t\t\t\tlet rhs = TypeConditionResult::from_reader(reader, state, settings)?;\n \t\t\t\tlet position = condition.get_position().union(&rhs.get_position());\n \t\t\t\t// TODO zero here ..?\n-\t\t\t\tOk(TypeReference::Conditional {\n+\t\t\t\tOk(TypeAnnotation::Conditional {\n \t\t\t\t\tcondition,\n \t\t\t\t\tresolve_true: lhs,\n \t\t\t\t\tresolve_false: rhs,\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -632,14 +628,11 @@ impl TypeReference {\n \t\t\tSome(Token(TSXToken::Keyword(TSXKeyword::Is), _)) => {\n \t\t\t\treader.next();\n \t\t\t\tlet is_type =\n-\t\t\t\t\tTypeReference::from_reader_with_config(reader, state, settings, true)?;\n+\t\t\t\t\tTypeAnnotation::from_reader_with_config(reader, state, settings, true)?;\n \t\t\t\t// TODO depth\n \t\t\t\tlet position = reference.get_position().union(&is_type.get_position());\n-\t\t\t\tlet condition = TypeCondition::Is {\n-\t\t\t\t\tr#type: Box::new(reference),\n-\t\t\t\t\tis: Box::new(is_type),\n-\t\t\t\t\tposition,\n-\t\t\t\t};\n+\t\t\t\tlet condition =\n+\t\t\t\t\tTypeCondition::Is { ty: Box::new(reference), is: Box::new(is_type), position };\n \t\t\t\treader.expect_next(TSXToken::QuestionMark)?;\n \t\t\t\t// TODO may need to return here\n \t\t\t\t// if return_on_union_or_intersection {\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -649,7 +642,7 @@ impl TypeReference {\n \t\t\t\treader.expect_next(TSXToken::Colon)?;\n \t\t\t\tlet resolve_false = TypeConditionResult::from_reader(reader, state, settings)?;\n \t\t\t\tlet position = condition.get_position().union(&resolve_false.get_position());\n-\t\t\t\tOk(TypeReference::Conditional { condition, resolve_true, resolve_false, position })\n+\t\t\t\tOk(TypeAnnotation::Conditional { condition, resolve_true, resolve_false, position })\n \t\t\t}\n \t\t\tSome(Token(TSXToken::BitwiseOr, _)) => {\n \t\t\t\tif return_on_union_or_intersection {\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -681,18 +674,17 @@ impl TypeReference {\n \t\t\t\tlet position = reference.get_position().into_owned();\n \t\t\t\tlet function = Self::FunctionLiteral {\n \t\t\t\t\ttype_parameters: None,\n-\t\t\t\t\tparameters: TypeReferenceFunctionParameters {\n-\t\t\t\t\t\tparameters: vec![TypeReferenceFunctionParameter {\n+\t\t\t\t\tparameters: TypeAnnotationFunctionParameters {\n+\t\t\t\t\t\tparameters: vec![TypeAnnotationFunctionParameter {\n \t\t\t\t\t\t\tname: None,\n-\t\t\t\t\t\t\ttype_reference: reference,\n+\t\t\t\t\t\t\ttype_annotation: reference,\n+\t\t\t\t\t\t\tis_optional: false,\n \t\t\t\t\t\t\tdecorators: Default::default(),\n \t\t\t\t\t\t}],\n-\t\t\t\t\t\toptional_parameters: Default::default(),\n \t\t\t\t\t\trest_parameter: None,\n \t\t\t\t\t\tposition,\n \t\t\t\t\t},\n \t\t\t\t\treturn_type: Box::new(return_type),\n-\t\t\t\t\ttype_id: TypeId::new(),\n \t\t\t\t};\n \t\t\t\tOk(function)\n \t\t\t}\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -701,19 +693,19 @@ impl TypeReference {\n \t}\n }\n \n-/// Parses the arguments (vector of [TypeReference]s) parsed to to a type reference or function call.\n+/// Parses the arguments (vector of [TypeAnnotation]s) parsed to to a type reference or function call.\n /// Returns arguments and the closing span.\n /// TODO could use parse bracketed but needs to have the more complex logic inside\n pub(crate) fn generic_arguments_from_reader_sub_open_angle(\n \treader: &mut impl TokenReader<TSXToken, Span>,\n \tstate: &mut crate::ParsingState,\n-\tsettings: &ParseSettings,\n+\tsettings: &ParseOptions,\n \treturn_on_union_or_intersection: bool,\n-) -> ParseResult<(Vec<TypeReference>, Span)> {\n+) -> ParseResult<(Vec<TypeAnnotation>, Span)> {\n \tlet mut generic_arguments = Vec::new();\n \n \tloop {\n-\t\tlet argument = TypeReference::from_reader_with_config(\n+\t\tlet argument = TypeAnnotation::from_reader_with_config(\n \t\t\treader,\n \t\t\tstate,\n \t\t\tsettings,\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -729,7 +721,7 @@ pub(crate) fn generic_arguments_from_reader_sub_open_angle(\n \n \t\tif let Some(Token(t @ TSXToken::BitwiseShiftRight, span)) = peek_mut {\n \t\t\tlet close_chevron_span =\n-\t\t\t\tSpan { start: span.start, end: span.start + 1, source_id: span.source_id };\n+\t\t\t\tSpan { start: span.start, end: span.start + 1, source: span.source };\n \t\t\t// Snipped\n \t\t\tspan.start += 1;\n \t\t\t*t = TSXToken::CloseChevron;\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -738,7 +730,7 @@ pub(crate) fn generic_arguments_from_reader_sub_open_angle(\n \n \t\tif let Some(Token(t @ TSXToken::BitwiseShiftRightUnsigned, span)) = peek_mut {\n \t\t\tlet close_chevron_span =\n-\t\t\t\tSpan { start: span.start, end: span.start + 1, source_id: span.source_id };\n+\t\t\t\tSpan { start: span.start, end: span.start + 1, source: span.source };\n \t\t\t// Snipped\n \t\t\tspan.start += 1;\n \t\t\t*t = TSXToken::CloseChevron;\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -764,14 +756,13 @@ pub(crate) fn generic_arguments_from_reader_sub_open_angle(\n /// Mirrors [crate::FunctionParameters]\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n-pub struct TypeReferenceFunctionParameters {\n-\tpub parameters: Vec<TypeReferenceFunctionParameter>,\n-\tpub optional_parameters: Vec<TypeReferenceFunctionParameter>,\n-\tpub rest_parameter: Option<Box<TypeReferenceSpreadFunctionParameter>>,\n+pub struct TypeAnnotationFunctionParameters {\n+\tpub parameters: Vec<TypeAnnotationFunctionParameter>,\n+\tpub rest_parameter: Option<Box<TypeAnnotationSpreadFunctionParameter>>,\n \tpub position: Span,\n }\n \n-impl ASTNode for TypeReferenceFunctionParameters {\n+impl ASTNode for TypeAnnotationFunctionParameters {\n \tfn get_position(&self) -> Cow<Span> {\n \t\tCow::Borrowed(&self.position)\n \t}\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -779,7 +770,7 @@ impl ASTNode for TypeReferenceFunctionParameters {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet span = reader.expect_next(TSXToken::OpenParentheses)?;\n \t\tSelf::from_reader_sub_open_parenthesis(reader, state, settings, span)\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -788,43 +779,39 @@ impl ASTNode for TypeReferenceFunctionParameters {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tfor parameter in self.parameters.iter() {\n \t\t\tif let Some(ref name) = parameter.name {\n \t\t\t\tname.to_string_from_buffer(buf, settings, depth);\n \t\t\t}\n-\t\t\tbuf.push_str(\": \");\n-\t\t\tparameter.type_reference.to_string_from_buffer(buf, settings, depth);\n-\t\t}\n-\t\tfor parameter in self.optional_parameters.iter() {\n-\t\t\tif let Some(ref name) = parameter.name {\n-\t\t\t\tname.to_string_from_buffer(buf, settings, depth);\n+\t\t\tif parameter.is_optional {\n+\t\t\t\tbuf.push_str(\"?: \");\n+\t\t\t} else {\n+\t\t\t\tbuf.push_str(\": \");\n \t\t\t}\n-\t\t\tbuf.push_str(\"?: \");\n-\t\t\tparameter.type_reference.to_string_from_buffer(buf, settings, depth);\n+\t\t\tparameter.type_annotation.to_string_from_buffer(buf, settings, depth);\n \t\t}\n \t\tif let Some(ref rest_parameter) = self.rest_parameter {\n \t\t\tbuf.push_str(\"...\");\n \t\t\tbuf.push_str(&rest_parameter.name);\n-\t\t\trest_parameter.type_reference.to_string_from_buffer(buf, settings, depth);\n+\t\t\trest_parameter.type_annotation.to_string_from_buffer(buf, settings, depth);\n \t\t}\n \t}\n }\n \n-impl TypeReferenceFunctionParameters {\n+impl TypeAnnotationFunctionParameters {\n \tpub(crate) fn from_reader_sub_open_parenthesis(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t\topen_paren_span: Span,\n \t) -> ParseResult<Self> {\n \t\tlet mut parameters = Vec::new();\n-\t\tlet mut optional_parameters = Vec::new();\n \t\tlet mut rest_parameter = None;\n \t\twhile !matches!(reader.peek(), Some(Token(TSXToken::CloseParentheses, _))) {\n-\t\t\twhile reader.peek().map_or(false, |Token(r#type, _)| r#type.is_comment()) {\n+\t\t\twhile reader.peek().map_or(false, |Token(ty, _)| ty.is_comment()) {\n \t\t\t\treader.next();\n \t\t\t}\n \t\t\tlet mut decorators = Vec::<Decorator>::new();\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -838,11 +825,11 @@ impl TypeReferenceFunctionParameters {\n \t\t\t\t\t\"spread function parameter\",\n \t\t\t\t)?;\n \t\t\t\treader.expect_next(TSXToken::Colon)?;\n-\t\t\t\tlet type_reference = TypeReference::from_reader(reader, state, settings)?;\n-\t\t\t\trest_parameter = Some(Box::new(TypeReferenceSpreadFunctionParameter {\n+\t\t\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n+\t\t\t\trest_parameter = Some(Box::new(TypeAnnotationSpreadFunctionParameter {\n \t\t\t\t\tspread_position: span,\n \t\t\t\t\tname,\n-\t\t\t\t\ttype_reference,\n+\t\t\t\t\ttype_annotation,\n \t\t\t\t\tdecorators,\n \t\t\t\t}));\n \t\t\t\tbreak;\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -859,7 +846,7 @@ impl TypeReferenceFunctionParameters {\n \t\t\t\t\t}\n \t\t\t\t\t_ => depth == 0,\n \t\t\t\t});\n-\t\t\t\tlet name: Option<WithComment<VariableField<VariableFieldInTypeReference>>> =\n+\t\t\t\tlet name: Option<WithComment<VariableField<VariableFieldInTypeAnnotation>>> =\n \t\t\t\t\tif let Some(Token(TSXToken::Colon | TSXToken::OptionalMember, _)) =\n \t\t\t\t\t\tafter_variable_field\n \t\t\t\t\t{\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -880,13 +867,13 @@ impl TypeReferenceFunctionParameters {\n \t\t\t\t\t\t));\n \t\t\t\t\t}\n \t\t\t\t};\n-\t\t\t\tlet type_reference = TypeReference::from_reader(reader, state, settings)?;\n-\t\t\t\tlet parameter = TypeReferenceFunctionParameter { decorators, name, type_reference };\n-\t\t\t\tif is_optional {\n-\t\t\t\t\toptional_parameters.push(parameter);\n-\t\t\t\t} else {\n-\t\t\t\t\tparameters.push(parameter);\n-\t\t\t\t}\n+\t\t\t\tlet type_annotation = TypeAnnotation::from_reader(reader, state, settings)?;\n+\t\t\t\tparameters.push(TypeAnnotationFunctionParameter {\n+\t\t\t\t\tdecorators,\n+\t\t\t\t\tname,\n+\t\t\t\t\ttype_annotation,\n+\t\t\t\t\tis_optional,\n+\t\t\t\t});\n \t\t\t}\n \n \t\t\tif reader.conditional_next(|tok| matches!(tok, TSXToken::Comma)).is_none() {\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -894,10 +881,9 @@ impl TypeReferenceFunctionParameters {\n \t\t\t}\n \t\t}\n \t\tlet end_span = reader.expect_next(TSXToken::CloseParentheses)?;\n-\t\tOk(TypeReferenceFunctionParameters {\n+\t\tOk(TypeAnnotationFunctionParameters {\n \t\t\tposition: open_paren_span.union(&end_span),\n \t\t\tparameters,\n-\t\t\toptional_parameters,\n \t\t\trest_parameter,\n \t\t})\n \t}\ndiff --git a/parser/src/types/type_declarations.rs b/parser/src/types/type_declarations.rs\n--- a/parser/src/types/type_declarations.rs\n+++ b/parser/src/types/type_declarations.rs\n@@ -2,7 +2,7 @@ use std::borrow::Cow;\n \n use crate::{\n \terrors::parse_lexing_error, parse_bracketed, to_string_bracketed, tokens::token_as_identifier,\n-\tASTNode, ParseResult, ParseSettings, Span, TSXKeyword, TSXToken, TypeReference,\n+\tASTNode, ParseOptions, ParseResult, Span, TSXKeyword, TSXToken, TypeAnnotation,\n };\n use tokenizer_lib::{Token, TokenReader};\n \ndiff --git a/parser/src/types/type_declarations.rs b/parser/src/types/type_declarations.rs\n--- a/parser/src/types/type_declarations.rs\n+++ b/parser/src/types/type_declarations.rs\n@@ -20,29 +20,29 @@ impl ASTNode for TypeDeclaration {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\t// Get initial name\n-\t\tlet (name, mut position) = token_as_identifier(\n+\t\tlet (name, position) = token_as_identifier(\n \t\t\treader.next().ok_or_else(parse_lexing_error)?,\n \t\t\t\"type declaration name\",\n \t\t)?;\n-\t\tlet type_parameters =\n-\t\t\tif reader.conditional_next(|tok| matches!(tok, TSXToken::OpenChevron)).is_some() {\n-\t\t\t\tlet (type_parameters, span) =\n-\t\t\t\t\tparse_bracketed(reader, state, settings, None, TSXToken::CloseChevron)?;\n-\t\t\t\tposition = position.union(&span);\n-\t\t\t\tSome(type_parameters)\n-\t\t\t} else {\n-\t\t\t\tNone\n-\t\t\t};\n+\n+\t\tlet type_parameters = reader\n+\t\t\t.conditional_next(|token| *token == TSXToken::OpenChevron)\n+\t\t\t.is_some()\n+\t\t\t.then(|| {\n+\t\t\t\tparse_bracketed(reader, state, settings, None, TSXToken::CloseChevron)\n+\t\t\t\t\t.map(|(params, _)| params)\n+\t\t\t})\n+\t\t\t.transpose()?;\n \t\tOk(Self { name, position, type_parameters })\n \t}\n \n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tbuf.push_str(&self.name);\ndiff --git a/parser/src/types/type_declarations.rs b/parser/src/types/type_declarations.rs\n--- a/parser/src/types/type_declarations.rs\n+++ b/parser/src/types/type_declarations.rs\n@@ -62,11 +62,11 @@ impl ASTNode for TypeDeclaration {\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum GenericTypeConstraint {\n-\tParameter { name: String, default: Option<TypeReference> },\n-\tExtends(String, TypeReference),\n-\tExtendsKeyOf(String, TypeReference),\n+\tParameter { name: String, default: Option<TypeAnnotation> },\n+\tExtends(String, TypeAnnotation),\n+\tExtendsKeyOf(String, TypeAnnotation),\n \t// TODO this should go\n-\tSpread { name: String, default: Option<TypeReference> },\n+\tSpread { name: String, default: Option<TypeAnnotation> },\n }\n \n impl GenericTypeConstraint {\ndiff --git a/parser/src/types/type_declarations.rs b/parser/src/types/type_declarations.rs\n--- a/parser/src/types/type_declarations.rs\n+++ b/parser/src/types/type_declarations.rs\n@@ -84,7 +84,7 @@ impl ASTNode for GenericTypeConstraint {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\t// Get name:\n \t\tlet token = reader.next().ok_or_else(parse_lexing_error)?;\ndiff --git a/parser/src/types/type_declarations.rs b/parser/src/types/type_declarations.rs\n--- a/parser/src/types/type_declarations.rs\n+++ b/parser/src/types/type_declarations.rs\n@@ -96,7 +96,7 @@ impl ASTNode for GenericTypeConstraint {\n \t\t\t\t\t.conditional_next(|token| *token == TSXToken::Keyword(TSXKeyword::KeyOf))\n \t\t\t\t\t.is_some();\n \t\t\t\tlet extends_type =\n-\t\t\t\t\tTypeReference::from_reader_with_config(reader, state, settings, false)?;\n+\t\t\t\t\tTypeAnnotation::from_reader_with_config(reader, state, settings, false)?;\n \t\t\t\tif key_of {\n \t\t\t\t\tOk(Self::ExtendsKeyOf(name, extends_type))\n \t\t\t\t} else {\ndiff --git a/parser/src/types/type_declarations.rs b/parser/src/types/type_declarations.rs\n--- a/parser/src/types/type_declarations.rs\n+++ b/parser/src/types/type_declarations.rs\n@@ -106,7 +106,7 @@ impl ASTNode for GenericTypeConstraint {\n \t\t\tSome(Token(TSXToken::Assign, _)) => {\n \t\t\t\treader.next();\n \t\t\t\tlet default_type =\n-\t\t\t\t\tTypeReference::from_reader_with_config(reader, state, settings, false)?;\n+\t\t\t\t\tTypeAnnotation::from_reader_with_config(reader, state, settings, false)?;\n \t\t\t\tOk(Self::Parameter { name, default: Some(default_type) })\n \t\t\t}\n \t\t\t_ => Ok(Self::Parameter { name, default: None }),\ndiff --git a/parser/src/types/type_declarations.rs b/parser/src/types/type_declarations.rs\n--- a/parser/src/types/type_declarations.rs\n+++ b/parser/src/types/type_declarations.rs\n@@ -116,7 +116,7 @@ impl ASTNode for GenericTypeConstraint {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -67,7 +26,7 @@ pub enum VariableIdentifier {\n impl ASTNode for VariableIdentifier {\n \tfn get_position(&self) -> Cow<Span> {\n \t\tmatch self {\n-\t\t\tVariableIdentifier::Standard(_, _, span) => Cow::Borrowed(span),\n+\t\t\tVariableIdentifier::Standard(_, span) => Cow::Borrowed(span),\n \t\t\tVariableIdentifier::Cursor(_) => todo!(),\n \t\t}\n \t}\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -75,21 +34,21 @@ impl ASTNode for VariableIdentifier {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\t_state: &mut crate::ParsingState,\n-\t\t_settings: &ParseSettings,\n+\t\t_settings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tlet token = reader.next().ok_or_else(parse_lexing_error)?;\n \t\tOk(if let Token(TSXToken::Cursor(id), _) = token {\n \t\t\tSelf::Cursor(id.into_cursor())\n \t\t} else {\n \t\t\tlet (ident, span) = token_as_identifier(token, \"variable identifier\")?;\n-\t\t\tSelf::Standard(ident, VariableId::new(), span)\n+\t\t\tSelf::Standard(ident, span)\n \t\t})\n \t}\n \n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\t_settings: &crate::ToStringSettings,\n+\t\t_settings: &crate::ToStringOptions,\n \t\t_depth: u8,\n \t) {\n \t\tbuf.push_str(self.as_str());\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -97,25 +56,19 @@ impl ASTNode for VariableIdentifier {\n }\n \n impl VariableIdentifier {\n+\t/// TODO temp\n \tpub fn as_str(&self) -> &str {\n \t\tmatch self {\n-\t\t\tVariableIdentifier::Standard(name, _, _) => name.as_str(),\n+\t\t\tVariableIdentifier::Standard(name, _) => name.as_str(),\n \t\t\tVariableIdentifier::Cursor(_) => \"\",\n \t\t}\n \t}\n-\n-\tfn try_get_id(&self) -> Option<VariableId> {\n-\t\tmatch self {\n-\t\t\tVariableIdentifier::Standard(_, id, _) => Some(*id),\n-\t\t\tVariableIdentifier::Cursor(_) => None,\n-\t\t}\n-\t}\n }\n \n /// A variable declaration name, used in variable declarations and function parameters.\n /// See [destructuring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\n #[derive(Debug, Clone)]\n-pub enum VariableField<T: VariableFieldTypes> {\n+pub enum VariableField<T: VariableFieldKind> {\n \t/// `x`\n \tName(VariableIdentifier),\n \t/// `[x, y, z]`\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -125,7 +78,7 @@ pub enum VariableField<T: VariableFieldTypes> {\n }\n \n #[cfg(feature = \"self-rust-tokenize\")]\n-impl<T: VariableFieldTypes> self_rust_tokenize::SelfRustTokenize for VariableField<T>\n+impl<T: VariableFieldKind> self_rust_tokenize::SelfRustTokenize for VariableField<T>\n where\n \tT::OptionalExpression: self_rust_tokenize::SelfRustTokenize,\n {\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -154,13 +107,13 @@ where\n \t}\n }\n \n-impl<T: VariableFieldTypes> From<VariableIdentifier> for VariableField<T> {\n+impl<T: VariableFieldKind> From<VariableIdentifier> for VariableField<T> {\n \tfn from(value: VariableIdentifier) -> Self {\n \t\tSelf::Name(value)\n \t}\n }\n \n-impl<T: VariableFieldTypes + PartialEq> PartialEq for VariableField<T> {\n+impl<T: VariableFieldKind + PartialEq> PartialEq for VariableField<T> {\n \tfn eq(&self, other: &Self) -> bool {\n \t\tmatch (self, other) {\n \t\t\t(Self::Name(l0), Self::Name(r0)) => l0 == r0,\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -171,26 +124,26 @@ impl<T: VariableFieldTypes + PartialEq> PartialEq for VariableField<T> {\n \t}\n }\n \n-impl<T: VariableFieldTypes> Eq for VariableField<T> {}\n+impl<T: VariableFieldKind> Eq for VariableField<T> {}\n \n /// Variable field can be used in type annotations but cannot have a value\n ///\n /// TODO value assignment this is VariableOrFieldAccess thingy\n ///\n /// TODO could have get_optional_expression_as_option(&Self::OptionalExpression) -> Option<Expression>\n-pub trait VariableFieldTypes: PartialEq + Eq + Debug + Clone + 'static {\n+pub trait VariableFieldKind: PartialEq + Eq + Debug + Clone + 'static {\n \ttype OptionalExpression: PartialEq + Eq + Debug + Clone + Sync + Send;\n \n \tfn optional_expression_from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> Result<Self::OptionalExpression, ParseError>;\n \n \tfn optional_expression_to_string_from_buffer<T: source_map::ToString>(\n \t\toptional_expression: &Self::OptionalExpression,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t);\n \ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -202,13 +155,13 @@ pub trait VariableFieldTypes: PartialEq + Eq + Debug + Clone + 'static {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct VariableFieldInSourceCode;\n \n-impl VariableFieldTypes for VariableFieldInSourceCode {\n+impl VariableFieldKind for VariableFieldInSourceCode {\n \ttype OptionalExpression = Option<Expression>;\n \n \tfn optional_expression_from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> Result<Self::OptionalExpression, ParseError> {\n \t\tOk(if reader.conditional_next(|tok| matches!(tok, TSXToken::Assign)).is_some() {\n \t\t\tSome(Expression::from_reader(reader, state, settings)?)\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -220,7 +173,7 @@ impl VariableFieldTypes for VariableFieldInSourceCode {\n \tfn optional_expression_to_string_from_buffer<T: source_map::ToString>(\n \t\toptional_expression: &Self::OptionalExpression,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tif let Some(optional_expression) = optional_expression {\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -238,15 +191,15 @@ impl VariableFieldTypes for VariableFieldInSourceCode {\n \n /// For function type references\n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct VariableFieldInTypeReference;\n+pub struct VariableFieldInTypeAnnotation;\n \n-impl VariableFieldTypes for VariableFieldInTypeReference {\n+impl VariableFieldKind for VariableFieldInTypeAnnotation {\n \ttype OptionalExpression = ();\n \n \tfn optional_expression_from_reader(\n \t\t_reader: &mut impl TokenReader<TSXToken, Span>,\n \t\t_state: &mut crate::ParsingState,\n-\t\t_settings: &ParseSettings,\n+\t\t_settings: &ParseOptions,\n \t) -> Result<Self::OptionalExpression, ParseError> {\n \t\tOk(())\n \t}\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -254,7 +207,7 @@ impl VariableFieldTypes for VariableFieldInTypeReference {\n \tfn optional_expression_to_string_from_buffer<T: source_map::ToString>(\n \t\t_optional_expression: &Self::OptionalExpression,\n \t\t_buf: &mut T,\n-\t\t_settings: &crate::ToStringSettings,\n+\t\t_settings: &crate::ToStringOptions,\n \t\t_depth: u8,\n \t) {\n \t}\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -266,11 +219,11 @@ impl VariableFieldTypes for VariableFieldInTypeReference {\n \t}\n }\n \n-impl<U: VariableFieldTypes> ASTNode for VariableField<U> {\n+impl<U: VariableFieldKind> ASTNode for VariableField<U> {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tmatch reader.peek().ok_or_else(parse_lexing_error)?.0 {\n \t\t\tTSXToken::OpenBrace => {\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -292,7 +245,7 @@ impl<U: VariableFieldTypes> ASTNode for VariableField<U> {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -334,20 +287,10 @@ impl<U: VariableFieldTypes> ASTNode for VariableField<U> {\n \t}\n }\n \n-impl<T: VariableFieldTypes> VariableField<T> {\n-\tpub fn try_get_id(&self) -> Option<VariableId> {\n-\t\tmatch self {\n-\t\t\tVariableField::Name(identifier) => identifier.try_get_id(),\n-\t\t\tVariableField::Array(_, _) => None,\n-\t\t\tVariableField::Object(_, _) => None,\n-\t\t}\n-\t}\n-}\n-\n #[derive(Debug, Clone, PartialEqExtras)]\n-#[partial_eq_ignore_types(Span, T::Id)]\n+#[partial_eq_ignore_types(Span)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n-pub enum ObjectDestructuringField<T: VariableFieldTypes> {\n+pub enum ObjectDestructuringField<T: VariableFieldKind> {\n \t/// `{ ...x }`\n \tSpread(Span, VariableIdentifier),\n \t/// `{ x }`\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -361,7 +304,7 @@ pub enum ObjectDestructuringField<T: VariableFieldTypes> {\n \t},\n }\n \n-impl<U: VariableFieldTypes> ASTNode for ObjectDestructuringField<U> {\n+impl<U: VariableFieldKind> ASTNode for ObjectDestructuringField<U> {\n \tfn get_position(&self) -> Cow<Span> {\n \t\tmatch self {\n \t\t\t// TODO account for `...` tokens\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -382,7 +325,7 @@ impl<U: VariableFieldTypes> ASTNode for ObjectDestructuringField<U> {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tmatch reader.peek().ok_or_else(parse_lexing_error)? {\n \t\t\tToken(TSXToken::Spread, _) => {\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -407,7 +350,7 @@ impl<U: VariableFieldTypes> ASTNode for ObjectDestructuringField<U> {\n \t\t\t\t\t\t\tkey.get_position().into_owned()\n \t\t\t\t\t\t};\n \t\t\t\t\tOk(Self::Map { from: key, variable_name, default_value, position })\n-\t\t\t\t} else if let PropertyKey::Ident(name, _, key_pos) = key {\n+\t\t\t\t} else if let PropertyKey::Ident(name, key_pos) = key {\n \t\t\t\t\tlet default_value =\n \t\t\t\t\t\tU::optional_expression_from_reader(reader, state, settings)?;\n \t\t\t\t\tlet position =\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -416,7 +359,7 @@ impl<U: VariableFieldTypes> ASTNode for ObjectDestructuringField<U> {\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tkey_pos\n \t\t\t\t\t\t};\n-\t\t\t\t\tlet standard = VariableIdentifier::Standard(name, VariableId::new(), position);\n+\t\t\t\t\tlet standard = VariableIdentifier::Standard(name, position);\n \t\t\t\t\tOk(Self::Name(standard, default_value))\n \t\t\t\t} else {\n \t\t\t\t\tlet Token(token, pos) = reader.next().unwrap();\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -432,7 +375,7 @@ impl<U: VariableFieldTypes> ASTNode for ObjectDestructuringField<U> {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -457,13 +400,13 @@ impl<U: VariableFieldTypes> ASTNode for ObjectDestructuringField<U> {\n /// TODO not sure about the positions here, is potential duplication if T::OptionalExpression is none\n #[derive(Debug, Clone)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n-pub enum ArrayDestructuringField<T: VariableFieldTypes> {\n+pub enum ArrayDestructuringField<T: VariableFieldKind> {\n \tSpread(Span, VariableIdentifier),\n \tName(WithComment<VariableField<T>>, T::OptionalExpression),\n \tNone,\n }\n \n-impl<T: VariableFieldTypes + PartialEq> PartialEq for ArrayDestructuringField<T> {\n+impl<T: VariableFieldKind + PartialEq> PartialEq for ArrayDestructuringField<T> {\n \tfn eq(&self, other: &Self) -> bool {\n \t\tmatch (self, other) {\n \t\t\t(Self::Spread(_, l0), Self::Spread(_, r0)) => l0 == r0,\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -473,9 +416,9 @@ impl<T: VariableFieldTypes + PartialEq> PartialEq for ArrayDestructuringField<T>\n \t}\n }\n \n-impl<T: VariableFieldTypes> Eq for ArrayDestructuringField<T> {}\n+impl<T: VariableFieldKind> Eq for ArrayDestructuringField<T> {}\n \n-impl<U: VariableFieldTypes> ASTNode for ArrayDestructuringField<U> {\n+impl<U: VariableFieldKind> ASTNode for ArrayDestructuringField<U> {\n \tfn get_position(&self) -> Cow<Span> {\n \t\tmatch self {\n \t\t\tArrayDestructuringField::Spread(spread_pos, ident) => {\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -497,7 +440,7 @@ impl<U: VariableFieldTypes> ASTNode for ArrayDestructuringField<U> {\n \tfn from_reader(\n \t\treader: &mut impl TokenReader<TSXToken, Span>,\n \t\tstate: &mut crate::ParsingState,\n-\t\tsettings: &ParseSettings,\n+\t\tsettings: &ParseOptions,\n \t) -> ParseResult<Self> {\n \t\tmatch reader.peek().ok_or_else(parse_lexing_error)?.0 {\n \t\t\tTSXToken::Spread => {\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -519,7 +462,7 @@ impl<U: VariableFieldTypes> ASTNode for ArrayDestructuringField<U> {\n \tfn to_string_from_buffer<T: source_map::ToString>(\n \t\t&self,\n \t\tbuf: &mut T,\n-\t\tsettings: &crate::ToStringSettings,\n+\t\tsettings: &crate::ToStringOptions,\n \t\tdepth: u8,\n \t) {\n \t\tmatch self {\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -536,18 +479,6 @@ impl<U: VariableFieldTypes> ASTNode for ArrayDestructuringField<U> {\n \t}\n }\n \n-impl<T: VariableFieldTypes> ArrayDestructuringField<T> {\n-\tpub fn try_get_id(&self) -> Option<VariableId> {\n-\t\tmatch self {\n-\t\t\tArrayDestructuringField::Spread(_, id) => id.try_get_id(),\n-\t\t\tArrayDestructuringField::Name(variable_field, _) => {\n-\t\t\t\tvariable_field.get_ast().try_get_id()\n-\t\t\t}\n-\t\t\tArrayDestructuringField::None => None,\n-\t\t}\n-\t}\n-}\n-\n /// For object literals and things with computable or literal keys\n impl Visitable for WithComment<VariableField<VariableFieldInSourceCode>> {\n \tfn visit<TData>(\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -560,9 +491,8 @@ impl Visitable for WithComment<VariableField<VariableFieldInSourceCode>> {\n \t\t// TODO map\n \t\tmatch self.get_ast() {\n \t\t\tVariableField::Name(id) => {\n-\t\t\t\tif let VariableIdentifier::Standard(name, variable_id, pos) = id {\n-\t\t\t\t\tlet item =\n-\t\t\t\t\t\tImmutableVariableOrPropertyPart::VariableFieldName(name, *variable_id, pos);\n+\t\t\t\tif let VariableIdentifier::Standard(name, pos) = id {\n+\t\t\t\t\tlet item = ImmutableVariableOrPropertyPart::VariableFieldName(name, pos);\n \t\t\t\t\tvisitors.visit_variable(&item, data, chain);\n \t\t\t\t}\n \t\t\t}\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -614,9 +544,9 @@ impl Visitable for WithComment<VariableField<VariableFieldInSourceCode>> {\n \t) {\n \t\tmatch self.get_ast_mut() {\n \t\t\tVariableField::Name(identifier) => {\n-\t\t\t\tif let VariableIdentifier::Standard(name, variable_id, _span) = identifier {\n+\t\t\t\tif let VariableIdentifier::Standard(name, _span) = identifier {\n \t\t\t\t\tvisitors.visit_variable_mut(\n-\t\t\t\t\t\t&mut MutableVariablePart::VariableFieldName(name, *variable_id),\n+\t\t\t\t\t\t&mut MutableVariablePart::VariableFieldName(name),\n \t\t\t\t\t\tdata,\n \t\t\t\t\t\tchain,\n \t\t\t\t\t);\ndiff --git a/parser/src/visiting.rs b/parser/src/visiting.rs\n--- a/parser/src/visiting.rs\n+++ b/parser/src/visiting.rs\n@@ -1,8 +1,8 @@\n use source_map::SourceId;\n \n use crate::{\n-\texpressions::ExpressionId, ArrayDestructuringField, BlockId, Expression, JSXElement,\n-\tObjectDestructuringField, PropertyKey, Statement, VariableId, WithComment,\n+\tArrayDestructuringField, Expression, JSXElement, ObjectDestructuringField, PropertyKey,\n+\tStatement, WithComment,\n };\n \n pub use ast::*;\ndiff --git a/parser/src/visiting.rs b/parser/src/visiting.rs\n--- a/parser/src/visiting.rs\n+++ b/parser/src/visiting.rs\n@@ -222,9 +222,7 @@ mod ast {\n \t\tstd::path::Path,\n \t\tstd::path::PathBuf,\n \t\tsource_map::Span,\n-\t\tcrate::expressions::ExpressionId,\n-\t\tcrate::variable_fields::VariableId,\n-\t\tcrate::TypeReference,\n+\t\tcrate::TypeAnnotation,\n \t\tcrate::NumberStructure,\n \t\tcrate::operators::BinaryOperator,\n \t\tcrate::operators::BinaryAssignmentOperator,\ndiff --git a/parser/src/visiting.rs b/parser/src/visiting.rs\n--- a/parser/src/visiting.rs\n+++ b/parser/src/visiting.rs\n@@ -236,7 +234,6 @@ mod ast {\n \t\tcrate::types::type_alias::TypeAlias,\n \t\tcrate::types::declares::DeclareFunctionDeclaration,\n \t\tcrate::types::declares::DeclareVariableDeclaration,\n-\t\tcrate::PropertyId,\n \t\tcrate::VariableIdentifier,\n \t\tcrate::PropertyReference,\n \t\tcrate::Quoted,\ndiff --git a/parser/src/visiting.rs b/parser/src/visiting.rs\n--- a/parser/src/visiting.rs\n+++ b/parser/src/visiting.rs\n@@ -248,49 +245,15 @@ mod ast {\n mod structures {\n \tuse std::borrow::Cow;\n \n-\tuse crate::{property_key::PropertyId, VariableFieldInSourceCode};\n+\tuse crate::VariableFieldInSourceCode;\n \n \tuse super::*;\n-\tuse derive_enum_from_into::EnumFrom;\n \tuse source_map::Span;\n \tuse temporary_annex::{Annex, Annexable};\n \n-\t/// Could borrow identifiers but most of them are smaller than a pointer so it doesn't matter =\n-\t///\n-\t/// TODO work out all the use cases for this\n-\t/// Currently used for\n \t#[derive(Debug, Clone)]\n \tpub enum ChainVariable {\n-\t\tBlock(BlockId),\n-\t\tUnderFunction(BlockId, VariableId),\n-\t\tUnderClassMethod(BlockId),\n-\t\tUnderClassConstructor(BlockId),\n-\t\tUnderObjectLiteralMethod,\n-\t\tUnderExpressionFunctionBlock(BlockId, ExpressionId),\n-\t\tUnderArrowFunction(Option<BlockId>),\n-\t\tUnderRhsOfOperation(ExpressionId),\n-\t\tUnderMatchArm(BlockId),\n-\t\tUnderModule(BlockId, SourceId),\n-\t\tSingleStatementOrExpression,\n-\t}\n-\n-\timpl ChainVariable {\n-\t\tpub fn get_block_id(&self) -> BlockId {\n-\t\t\tmatch self {\n-\t\t\t\tChainVariable::Block(block_id)\n-\t\t\t\t| ChainVariable::UnderFunction(block_id, _)\n-\t\t\t\t| ChainVariable::UnderClassMethod(block_id)\n-\t\t\t\t| ChainVariable::UnderClassConstructor(block_id)\n-\t\t\t\t| ChainVariable::UnderModule(block_id, _)\n-\t\t\t\t| ChainVariable::UnderArrowFunction(Some(block_id))\n-\t\t\t\t| ChainVariable::UnderExpressionFunctionBlock(block_id, _) => *block_id,\n-\t\t\t\tChainVariable::UnderMatchArm(block_id) => *block_id,\n-\t\t\t\tChainVariable::UnderArrowFunction(None)\n-\t\t\t\t| ChainVariable::SingleStatementOrExpression => panic!(),\n-\t\t\t\tChainVariable::UnderObjectLiteralMethod => todo!(),\n-\t\t\t\tChainVariable::UnderRhsOfOperation(_) => todo!(),\n-\t\t\t}\n-\t\t}\n+\t\tModule(SourceId),\n \t}\n \n \t/// The current location in the AST\ndiff --git a/parser/src/visiting.rs b/parser/src/visiting.rs\n--- a/parser/src/visiting.rs\n+++ b/parser/src/visiting.rs\n@@ -321,51 +284,13 @@ mod structures {\n \t\t\t&self.0\n \t\t}\n \n-\t\t// Returns the variableId this chain may be under\n-\t\tpub fn last_variable_id(&self) -> Option<VariableId> {\n-\t\t\tself.0.iter().rev().find_map(|chain_variable| {\n-\t\t\t\t// | ChainVariable::UnderClassMethod(_, variable_id)\n-\t\t\t\tif let ChainVariable::UnderFunction(_, variable_id) = chain_variable {\n-\t\t\t\t\tSome(*variable_id)\n-\t\t\t\t} else {\n-\t\t\t\t\tNone\n-\t\t\t\t}\n-\t\t\t})\n-\t\t}\n-\n-\t\tpub fn last_function(&self) -> Option<(BlockId, VariableId)> {\n-\t\t\tself.0.iter().rev().find_map(|chain_variable| {\n-\t\t\t\t// | ChainVariable::UnderClassMethod(block_id, variable_id)\n-\t\t\t\tif let ChainVariable::UnderFunction(block_id, variable_id) = chain_variable {\n-\t\t\t\t\tSome((*block_id, *variable_id))\n-\t\t\t\t} else {\n-\t\t\t\t\tNone\n-\t\t\t\t}\n-\t\t\t})\n-\t\t}\n-\n-\t\tpub fn first_function(&self) -> Option<(BlockId, VariableId)> {\n-\t\t\tself.0.iter().find_map(|chain_variable| {\n-\t\t\t\t// | ChainVariable::UnderClassMethod(block_id, variable_id)\n-\t\t\t\tif let ChainVariable::UnderFunction(block_id, variable_id) = chain_variable {\n-\t\t\t\t\tSome((*block_id, *variable_id))\n-\t\t\t\t} else {\n-\t\t\t\t\tNone\n-\t\t\t\t}\n-\t\t\t})\n-\t\t}\n-\n-\t\tpub fn last_block_id(&self) -> BlockId {\n-\t\t\t// TODO this needs changing\n-\t\t\tself.0.last().unwrap().get_block_id()\n-\t\t}\n-\n \t\tpub fn get_module(&self) -> SourceId {\n-\t\t\tif let ChainVariable::UnderModule(_, source_id) = self.0.first().unwrap() {\n-\t\t\t\t*source_id\n-\t\t\t} else {\n-\t\t\t\tpanic!()\n-\t\t\t}\n+\t\t\ttodo!()\n+\t\t\t// if let ChainVariable::UnderModule(_, source) = self.0.first().unwrap() {\n+\t\t\t// \t*source\n+\t\t\t// } else {\n+\t\t\t// \tpanic!()\n+\t\t\t// }\n \t\t}\n \n \t\t// TODO get function root. Aka last thing before in top level scope or\ndiff --git a/parser/src/visiting.rs b/parser/src/visiting.rs\n--- a/parser/src/visiting.rs\n+++ b/parser/src/visiting.rs\n@@ -390,98 +315,63 @@ mod structures {\n \t/// TODO these may go\n \t#[derive(Debug)]\n \tpub enum MutableVariablePart<'a> {\n-\t\tVariableFieldName(&'a mut String, VariableId),\n+\t\tVariableFieldName(&'a mut String),\n \t\t// TODO these should maybe only be the spread variables\n \t\tArrayDestructuringMember(&'a mut ArrayDestructuringField<VariableFieldInSourceCode>),\n \t\tObjectDestructuringMember(\n \t\t\t&'a mut WithComment<ObjectDestructuringField<VariableFieldInSourceCode>>,\n \t\t),\n \t\tPropertyKey(&'a mut WithComment<PropertyKey>, PropertyKeyLocation),\n-\t\tClassName(Option<&'a mut String>, VariableId),\n-\t\tFunctionName(&'a mut String, VariableId),\n+\t\tClassName(Option<&'a mut String>),\n+\t\tFunctionName(&'a mut String),\n \t}\n \n \t/// TODO these may go\n \t#[derive(Debug)]\n \tpub enum ImmutableVariableOrPropertyPart<'a> {\n \t\t// TODO maybe WithComment on some of these\n-\t\tVariableFieldName(&'a str, VariableId, &'a Span),\n+\t\tVariableFieldName(&'a str, &'a Span),\n \t\t// TODO these should maybe only be the spread variables\n \t\tArrayDestructuringMember(&'a ArrayDestructuringField<VariableFieldInSourceCode>),\n \t\tObjectDestructuringMember(\n \t\t\t&'a WithComment<ObjectDestructuringField<VariableFieldInSourceCode>>,\n \t\t),\n-\t\tClassName(Option<&'a str>, VariableId, &'a Span),\n-\t\tFunctionName(&'a str, VariableId, &'a Span),\n+\t\tClassName(Option<&'a str>, &'a Span),\n+\t\tFunctionName(&'a str, &'a Span),\n \t\tPropertyKey(&'a WithComment<PropertyKey>, PropertyKeyLocation),\n \t}\n \n \t#[derive(Debug, Clone, Copy)]\n \tpub enum PropertyKeyLocation {\n-\t\tClass(VariableId),\n-\t\tObjectLiteral(ExpressionId),\n-\t}\n-\n-\t#[derive(Debug, Clone, Copy, EnumFrom)]\n-\tpub enum VariableOrPropertyId {\n-\t\tVariableId(VariableId),\n-\t\tPropertyId(PropertyId),\n+\t\tClass,\n+\t\tObjectLiteral,\n \t}\n \n \timpl<'a> ImmutableVariableOrPropertyPart<'a> {\n-\t\tpub fn get_variable_id(&self) -> VariableOrPropertyId {\n-\t\t\tmatch self {\n-\t\t\t\tImmutableVariableOrPropertyPart::VariableFieldName(_, variable_id, _)\n-\t\t\t\t| ImmutableVariableOrPropertyPart::ClassName(_, variable_id, _)\n-\t\t\t\t| ImmutableVariableOrPropertyPart::FunctionName(_, variable_id, _) => (*variable_id).into(),\n-\t\t\t\tImmutableVariableOrPropertyPart::ArrayDestructuringMember(\n-\t\t\t\t\tarray_destructuring_member,\n-\t\t\t\t) => match array_destructuring_member {\n-\t\t\t\t\tArrayDestructuringField::Spread(_, _identifier) => {\n-\t\t\t\t\t\ttodo!()\n-\t\t\t\t\t}\n-\t\t\t\t\tArrayDestructuringField::Name(..) => todo!(),\n-\t\t\t\t\tArrayDestructuringField::None => todo!(),\n-\t\t\t\t},\n-\t\t\t\tImmutableVariableOrPropertyPart::ObjectDestructuringMember(\n-\t\t\t\t\tobject_destructuring_member,\n-\t\t\t\t) => match object_destructuring_member.get_ast() {\n-\t\t\t\t\tObjectDestructuringField::Spread(_, _identifier) => {\n-\t\t\t\t\t\ttodo!()\n-\t\t\t\t\t}\n-\t\t\t\t\tObjectDestructuringField::Name { .. } => todo!(),\n-\t\t\t\t\tObjectDestructuringField::Map { .. } => todo!(),\n-\t\t\t\t},\n-\t\t\t\tImmutableVariableOrPropertyPart::PropertyKey(property_key, _) => {\n-\t\t\t\t\tproperty_key.get_ast().get_property_id().into()\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\n \t\tpub fn get_name(&self) -> Option<&'a str> {\n \t\t\tmatch self {\n-\t\t\t\tImmutableVariableOrPropertyPart::FunctionName(name, _, _)\n-\t\t\t\t| ImmutableVariableOrPropertyPart::VariableFieldName(name, _, _) => Some(name),\n+\t\t\t\tImmutableVariableOrPropertyPart::FunctionName(name, _)\n+\t\t\t\t| ImmutableVariableOrPropertyPart::VariableFieldName(name, _) => Some(name),\n \t\t\t\tImmutableVariableOrPropertyPart::ArrayDestructuringMember(_)\n \t\t\t\t| ImmutableVariableOrPropertyPart::ObjectDestructuringMember(_) => None,\n-\t\t\t\tImmutableVariableOrPropertyPart::ClassName(name, _, _) => *name,\n-\t\t\t\tImmutableVariableOrPropertyPart::PropertyKey(property, _) => match property\n-\t\t\t\t\t.get_ast()\n-\t\t\t\t{\n-\t\t\t\t\tPropertyKey::Ident(ident, _, _) | PropertyKey::StringLiteral(ident, _, _) => {\n-\t\t\t\t\t\tSome(ident.as_str())\n+\t\t\t\tImmutableVariableOrPropertyPart::ClassName(name, _) => *name,\n+\t\t\t\tImmutableVariableOrPropertyPart::PropertyKey(property, _) => {\n+\t\t\t\t\tmatch property.get_ast() {\n+\t\t\t\t\t\tPropertyKey::Ident(ident, _) | PropertyKey::StringLiteral(ident, _) => {\n+\t\t\t\t\t\t\tSome(ident.as_str())\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tPropertyKey::NumberLiteral(_, _) | PropertyKey::Computed(_, _) => None,\n \t\t\t\t\t}\n-\t\t\t\t\tPropertyKey::NumberLiteral(_, _, _) | PropertyKey::Computed(_, _, _) => None,\n-\t\t\t\t},\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\tpub fn get_position(&self) -> Cow<Span> {\n \t\t\tuse crate::ASTNode;\n \t\t\tmatch self {\n-\t\t\t\tImmutableVariableOrPropertyPart::FunctionName(_, _, pos)\n-\t\t\t\t| ImmutableVariableOrPropertyPart::ClassName(_, _, pos)\n-\t\t\t\t| ImmutableVariableOrPropertyPart::VariableFieldName(_, _, pos) => Cow::Borrowed(pos),\n+\t\t\t\tImmutableVariableOrPropertyPart::FunctionName(_, pos)\n+\t\t\t\t| ImmutableVariableOrPropertyPart::ClassName(_, pos)\n+\t\t\t\t| ImmutableVariableOrPropertyPart::VariableFieldName(_, pos) => Cow::Borrowed(pos),\n \t\t\t\tImmutableVariableOrPropertyPart::ArrayDestructuringMember(member) => {\n \t\t\t\t\tmember.get_position()\n \t\t\t\t}\n",
        "test_patch": "diff --git a/parser/README.md b/parser/README.md\n--- a/parser/README.md\n+++ b/parser/README.md\n@@ -33,16 +33,28 @@ This is more of an exercise project in getting better at writing Rust and doesn'\n - Increase code size or decrease readability for speed improvements\n - Allow adding new syntax at runtime, that would require modifying the lexer at runtime adding new tokens\n \n+### Testing\n+\n+> If in main root rather than this folder, add `-p ezno-parser` after `cargo run` to the following commands.\n+\n+For testing whether the parser can lex a file\n+\n+```shell\n+cargo run --example lex path/to/file.js\n+```\n+\n+and parse\n+\n+```shell\n+cargo run --example parse path/to/file.js\n+```\n+\n ## Features\n \n ### Positions\n \n All syntax has reference to where it was in the source using a [Span](https://docs.rs/ezno-parser/0.0.2/ezno_parser/struct.Span.html). This uses the [source-map](https://github.com/kaleidawave/source-map) crate, so it can generate source maps.\n \n-### Identifiers\n-\n-Most expressions, functions, blocks and some other AST has a unique identifier. This can be used to associate information with the node. For example Ezno's checker associates type information with variable reference AST for later visitors or for hover information in the LSP.\n-\n ### \"Cursors\"\n \n Allows holes in AST where a cursor exists. This allows for LSP to provide suggestions here while the whole source might not be valid.\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1661,16 +1530,16 @@ mod tests {\n \tfn literal() {\n \t\tassert_matches_ast!(\n \t\t\t\"'string'\",\n-\t\t\tStringLiteral(Deref @ \"string\", Quoted::Single, span!(0, 8), _)\n+\t\t\tStringLiteral(Deref @ \"string\", Quoted::Single, span!(0, 8))\n \t\t);\n \t\tassert_matches_ast!(\n \t\t\t\"\\\"string\\\"\",\n-\t\t\tStringLiteral(Deref @ \"string\", Quoted::Double, span!(0, 8), _)\n+\t\t\tStringLiteral(Deref @ \"string\", Quoted::Double, span!(0, 8))\n \t\t);\n \t\t// TODO different method\n-\t\t// assert_matches_ast!(\"45\", NumberLiteral(NumberStructure::Number(45.0), span!(0, 2), _));\n-\t\t// assert_matches_ast!(\"45.63\", NumberLiteral(NumberStructure::Number(45.63), span!(0, 5), _));\n-\t\tassert_matches_ast!(\"true\", BooleanLiteral(true, span!(0, 4), _));\n+\t\t// assert_matches_ast!(\"45\", NumberLiteral(NumberStructure::Number(45.0), span!(0, 2)));\n+\t\t// assert_matches_ast!(\"45.63\", NumberLiteral(NumberStructure::Number(45.63), span!(0, 5)));\n+\t\tassert_matches_ast!(\"true\", BooleanLiteral(true, span!(0, 4)));\n \t}\n \n \t#[test]\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1680,10 +1549,9 @@ mod tests {\n \t\t\tParenthesizedExpression(\n \t\t\t\tDeref @ MultipleExpression {\n \t\t\t\t\tlhs: None,\n-\t\t\t\t\trhs: NumberLiteral(NumberStructure::Number(_), span!(1, 3), _),\n+\t\t\t\t\trhs: NumberLiteral(NumberStructure::Number(_), span!(1, 3)),\n \t\t\t\t},\n \t\t\t\tspan!(0, 4),\n-\t\t\t\t_,\n \t\t\t)\n \t\t);\n \t}\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1711,13 +1579,12 @@ mod tests {\n \t\t\t\t\t\tSome(\n \t\t\t\t\t\t\tDeref @ MultipleExpression {\n \t\t\t\t\t\t\t\tlhs: None,\n-\t\t\t\t\t\t\t\trhs: NumberLiteral(NumberStructure::Number(_), span!(1, 3), _),\n+\t\t\t\t\t\t\t\trhs: NumberLiteral(NumberStructure::Number(_), span!(1, 3)),\n \t\t\t\t\t\t\t},\n \t\t\t\t\t\t),\n-\t\t\t\t\trhs: NumberLiteral(NumberStructure::Number(_), span!(4, 5), _),\n+\t\t\t\t\trhs: NumberLiteral(NumberStructure::Number(_), span!(4, 5)),\n \t\t\t\t},\n \t\t\t\tspan!(0, 6),\n-\t\t\t\t_,\n \t\t\t)\n \t\t);\n \t}\ndiff --git a/parser/src/expressions/mod.rs b/parser/src/expressions/mod.rs\n--- a/parser/src/expressions/mod.rs\n+++ b/parser/src/expressions/mod.rs\n@@ -1725,34 +1592,29 @@ mod tests {\n \t#[test]\n \tfn binary_expressions() {\n \t\tassert_matches_ast!(\"2 + 3\", BinaryOperation {\n-\t\t\tlhs: Deref @ NumberLiteral(NumberStructure::Number(_), span!(0, 1), _),\n+\t\t\tlhs: Deref @ NumberLiteral(NumberStructure::Number(_), span!(0, 1)),\n \t\t\toperator: BinaryOperator::Add,\n-\t\t\trhs: Deref @ NumberLiteral(NumberStructure::Number(_), span!(4, 5), _),\n-\t\t\tid: _\n+\t\t\trhs: Deref @ NumberLiteral(NumberStructure::Number(_), span!(4, 5)),\n \t\t});\n \t\tassert_matches_ast!(\"xt === 3\", BinaryOperation {\n \t\t\tlhs: Deref @ VariableReference(..),\n \t\t\toperator: BinaryOperator::StrictEqual,\n-\t\t\trhs: Deref @ NumberLiteral(NumberStructure::Number(_), span!(7, 8), _),\n-\t\t\tid: _\n+\t\t\trhs: Deref @ NumberLiteral(NumberStructure::Number(_), span!(7, 8)),\n \t\t});\n \t\tassert_matches_ast!(\"x << 3\", BinaryOperation {\n \t\t\tlhs: Deref @ VariableReference(..),\n \t\t\toperator: BinaryOperator::BitwiseShiftLeft,\n-\t\t\trhs: Deref @ NumberLiteral(NumberStructure::Number(_), span!(5, 6), _),\n-\t\t\tid: _\n+\t\t\trhs: Deref @ NumberLiteral(NumberStructure::Number(_), span!(5, 6)),\n \t\t});\n \t\tassert_matches_ast!(\"x >> 3\", BinaryOperation {\n \t\t\tlhs: Deref @ VariableReference(..),\n \t\t\toperator: BinaryOperator::BitwiseShiftRight,\n-\t\t\trhs: Deref @ NumberLiteral(NumberStructure::Number(_), span!(5, 6), _),\n-\t\t\tid: _\n+\t\t\trhs: Deref @ NumberLiteral(NumberStructure::Number(_), span!(5, 6)),\n \t\t});\n \t\tassert_matches_ast!(\"x >>> 3\", BinaryOperation {\n \t\t\tlhs: Deref @ VariableReference(..),\n \t\t\toperator: BinaryOperator::BitwiseShiftRightUnsigned,\n-\t\t\trhs: Deref @ NumberLiteral(NumberStructure::Number(_), span!(6, 7), _),\n-\t\t\tid: _\n+\t\t\trhs: Deref @ NumberLiteral(NumberStructure::Number(_), span!(6, 7)),\n \t\t});\n \t}\n }\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -905,31 +891,32 @@ impl TypeReferenceFunctionParameters {\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n-pub struct TypeReferenceFunctionParameter {\n+pub struct TypeAnnotationFunctionParameter {\n \tpub decorators: Vec<Decorator>,\n \t/// Ooh nice optional\n-\tpub name: Option<WithComment<VariableField<VariableFieldInTypeReference>>>,\n-\tpub type_reference: TypeReference,\n+\tpub name: Option<WithComment<VariableField<VariableFieldInTypeAnnotation>>>,\n+\tpub type_annotation: TypeAnnotation,\n+\tpub is_optional: bool,\n }\n \n-impl TypeReferenceFunctionParameter {\n+impl TypeAnnotationFunctionParameter {\n \t// TODO decorators\n \tpub fn get_position(&self) -> Cow<Span> {\n \t\tif let Some(ref name) = self.name {\n-\t\t\tCow::Owned(name.get_position().union(&self.type_reference.get_position()))\n+\t\t\tCow::Owned(name.get_position().union(&self.type_annotation.get_position()))\n \t\t} else {\n-\t\t\tself.type_reference.get_position()\n+\t\t\tself.type_annotation.get_position()\n \t\t}\n \t}\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n-pub struct TypeReferenceSpreadFunctionParameter {\n+pub struct TypeAnnotationSpreadFunctionParameter {\n \tpub decorators: Vec<Decorator>,\n \tpub spread_position: Span,\n \tpub name: String,\n-\tpub type_reference: TypeReference,\n+\tpub type_annotation: TypeAnnotation,\n }\n \n #[cfg(test)]\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -939,50 +926,50 @@ mod tests {\n \n \t#[test]\n \tfn name() {\n-\t\tassert_matches_ast!(\"string\", TypeReference::Name(Deref @ \"string\", span!(0, 6)))\n+\t\tassert_matches_ast!(\"string\", TypeAnnotation::Name(Deref @ \"string\", span!(0, 6)))\n \t}\n \n \t#[test]\n \tfn literals() {\n \t\tassert_matches_ast!(\n \t\t\t\"\\\"string\\\"\",\n-\t\t\tTypeReference::StringLiteral(Deref @ \"string\", span!(0, 8))\n+\t\t\tTypeAnnotation::StringLiteral(Deref @ \"string\", span!(0, 8))\n \t\t);\n \t\tassert_matches_ast!(\n \t\t\t\"45\",\n-\t\t\tTypeReference::NumberLiteral(NumberStructure::Number(_), span!(0, 2))\n+\t\t\tTypeAnnotation::NumberLiteral(NumberStructure::Number(_), span!(0, 2))\n \t\t);\n-\t\tassert_matches_ast!(\"true\", TypeReference::BooleanLiteral(true, span!(0, 4)));\n+\t\tassert_matches_ast!(\"true\", TypeAnnotation::BooleanLiteral(true, span!(0, 4)));\n \t}\n \n \t#[test]\n \tfn generics() {\n \t\tassert_matches_ast!(\n \t\t\t\"Array<string>\",\n-\t\t\tTypeReference::NameWithGenericArguments(\n+\t\t\tTypeAnnotation::NameWithGenericArguments(\n \t\t\t\tDeref @ \"Array\",\n-\t\t\t\tDeref @ [TypeReference::Name(Deref @ \"string\", span!(6, 12))],\n+\t\t\t\tDeref @ [TypeAnnotation::Name(Deref @ \"string\", span!(6, 12))],\n \t\t\t\tspan!(0, 13),\n \t\t\t)\n \t\t);\n \n \t\tassert_matches_ast!(\n \t\t\t\"Map<string, number>\",\n-\t\t\tTypeReference::NameWithGenericArguments(\n+\t\t\tTypeAnnotation::NameWithGenericArguments(\n \t\t\t\tDeref @ \"Map\",\n \t\t\t\tDeref @\n-\t\t\t\t[TypeReference::Name(Deref @ \"string\", span!(4, 10)), TypeReference::Name(Deref @ \"number\", span!(12, 18))],\n+\t\t\t\t[TypeAnnotation::Name(Deref @ \"string\", span!(4, 10)), TypeAnnotation::Name(Deref @ \"number\", span!(12, 18))],\n \t\t\t\tspan!(0, 19),\n \t\t\t)\n \t\t);\n \n \t\tassert_matches_ast!(\n \t\t\t\"Array<Array<string>>\",\n-\t\t\tTypeReference::NameWithGenericArguments(\n+\t\t\tTypeAnnotation::NameWithGenericArguments(\n \t\t\t\tDeref @ \"Array\",\n-\t\t\t\tDeref @ [TypeReference::NameWithGenericArguments(\n+\t\t\t\tDeref @ [TypeAnnotation::NameWithGenericArguments(\n \t\t\t\t\tDeref @ \"Array\",\n-\t\t\t\t\tDeref @ [TypeReference::Name(Deref @ \"string\", span!(12, 18))],\n+\t\t\t\t\tDeref @ [TypeAnnotation::Name(Deref @ \"string\", span!(12, 18))],\n \t\t\t\t\tspan!(6, 19),\n \t\t\t\t)],\n \t\t\t\tspan!(0, 20),\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -994,9 +981,9 @@ mod tests {\n \tfn union() {\n \t\tassert_matches_ast!(\n \t\t\t\"string | number\",\n-\t\t\tTypeReference::Union(\n+\t\t\tTypeAnnotation::Union(\n \t\t\t\tDeref @\n-\t\t\t\t[TypeReference::Name(Deref @ \"string\", span!(0, 6)), TypeReference::Name(Deref @ \"number\", span!(9, 15))],\n+\t\t\t\t[TypeAnnotation::Name(Deref @ \"string\", span!(0, 6)), TypeAnnotation::Name(Deref @ \"number\", span!(9, 15))],\n \t\t\t)\n \t\t)\n \t}\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1005,9 +992,9 @@ mod tests {\n \tfn intersection() {\n \t\tassert_matches_ast!(\n \t\t\t\"string & number\",\n-\t\t\tTypeReference::Intersection(\n+\t\t\tTypeAnnotation::Intersection(\n \t\t\t\tDeref @\n-\t\t\t\t[TypeReference::Name(Deref @ \"string\", span!(0, 6)), TypeReference::Name(Deref @ \"number\", span!(9, 15))],\n+\t\t\t\t[TypeAnnotation::Name(Deref @ \"string\", span!(0, 6)), TypeAnnotation::Name(Deref @ \"number\", span!(9, 15))],\n \t\t\t)\n \t\t)\n \t}\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1016,15 +1003,14 @@ mod tests {\n \tfn tuple_literal() {\n \t\tassert_matches_ast!(\n \t\t\t\"[number, x: string]\",\n-\t\t\tTypeReference::TupleLiteral(\n+\t\t\tTypeAnnotation::TupleLiteral(\n \t\t\t\tDeref @ [TupleElement::NonSpread {\n \t\t\t\t\tname: None,\n-\t\t\t\t\tty: TypeReference::Name(Deref @ \"number\", span!(1, 7)),\n+\t\t\t\t\tty: TypeAnnotation::Name(Deref @ \"number\", span!(1, 7)),\n \t\t\t\t}, TupleElement::NonSpread {\n \t\t\t\t\tname: Some(Deref @ \"x\"),\n-\t\t\t\t\tty: TypeReference::Name(Deref @ \"string\", span!(12, 18)),\n+\t\t\t\t\tty: TypeAnnotation::Name(Deref @ \"string\", span!(12, 18)),\n \t\t\t\t}],\n-\t\t\t\t_,\n \t\t\t\tspan!(0, 19),\n \t\t\t)\n \t\t);\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1034,13 +1020,13 @@ mod tests {\n \tfn functions() {\n \t\tassert_matches_ast!(\n \t\t\t\"T => T\",\n-\t\t\tTypeReference::FunctionLiteral {\n+\t\t\tTypeAnnotation::FunctionLiteral {\n \t\t\t\ttype_parameters: None,\n-\t\t\t\tparameters: TypeReferenceFunctionParameters {\n-\t\t\t\t\tparameters: Deref @ [ TypeReferenceFunctionParameter { .. } ],\n+\t\t\t\tparameters: TypeAnnotationFunctionParameters {\n+\t\t\t\t\tparameters: Deref @ [ TypeAnnotationFunctionParameter { .. } ],\n \t\t\t\t\t..\n \t\t\t\t},\n-\t\t\t\treturn_type: Deref @ TypeReference::Name(Deref @ \"T\", span!(5, 6)),\n+\t\t\t\treturn_type: Deref @ TypeAnnotation::Name(Deref @ \"T\", span!(5, 6)),\n \t\t\t\t..\n \t\t\t}\n \t\t);\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1051,10 +1037,10 @@ mod tests {\n \tfn template_literal() {\n \t\tassert_matches_ast!(\n \t\t\t\"`test-${X}`\",\n-\t\t\tTypeReference::TemplateLiteral(\n+\t\t\tTypeAnnotation::TemplateLiteral(\n \t\t\t\tDeref\n \t\t\t\t@ [TemplateLiteralPart::Static(Deref @ \"test-\"), TemplateLiteralPart::Dynamic(\n-\t\t\t\t\tDeref @ TypeReference::Name(Deref @ \"X\", span!(8, 9)),\n+\t\t\t\t\tDeref @ TypeAnnotation::Name(Deref @ \"X\", span!(8, 9)),\n \t\t\t\t)],\n \t\t\t\t_,\n \t\t\t)\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1065,18 +1051,18 @@ mod tests {\n \tfn array_shorthand() {\n \t\tassert_matches_ast!(\n \t\t\t\"string[]\",\n-\t\t\tTypeReference::ArrayLiteral(\n-\t\t\t\tDeref @ TypeReference::Name(Deref @ \"string\", span!(0, 6)),\n+\t\t\tTypeAnnotation::ArrayLiteral(\n+\t\t\t\tDeref @ TypeAnnotation::Name(Deref @ \"string\", span!(0, 6)),\n \t\t\t\tspan!(0, 8),\n \t\t\t)\n \t\t);\n \t\tassert_matches_ast!(\n \t\t\t\"(number | null)[]\",\n-\t\t\tTypeReference::ArrayLiteral(\n-\t\t\t\tDeref @ TypeReference::ParenthesizedReference(\n-\t\t\t\t\tDeref @ TypeReference::Union(\n+\t\t\tTypeAnnotation::ArrayLiteral(\n+\t\t\t\tDeref @ TypeAnnotation::ParenthesizedReference(\n+\t\t\t\t\tDeref @ TypeAnnotation::Union(\n \t\t\t\t\t\tDeref @\n-\t\t\t\t\t\t[TypeReference::Name(Deref @ \"number\", span!(1, 7)), TypeReference::Name(Deref @ \"null\", span!(10, 14))],\n+\t\t\t\t\t\t[TypeAnnotation::Name(Deref @ \"number\", span!(1, 7)), TypeAnnotation::Name(Deref @ \"null\", span!(10, 14))],\n \t\t\t\t\t),\n \t\t\t\t\tspan!(0, 15),\n \t\t\t\t),\ndiff --git a/parser/src/types/type_references.rs b/parser/src/types/type_annotations.rs\n--- a/parser/src/types/type_references.rs\n+++ b/parser/src/types/type_annotations.rs\n@@ -1085,9 +1071,9 @@ mod tests {\n \t\t);\n \t\tassert_matches_ast!(\n \t\t\t\"string[][]\",\n-\t\t\tTypeReference::ArrayLiteral(\n-\t\t\t\tDeref @ TypeReference::ArrayLiteral(\n-\t\t\t\t\tDeref @ TypeReference::Name(Deref @ \"string\", span!(0, 6)),\n+\t\t\tTypeAnnotation::ArrayLiteral(\n+\t\t\t\tDeref @ TypeAnnotation::ArrayLiteral(\n+\t\t\t\t\tDeref @ TypeAnnotation::Name(Deref @ \"string\", span!(0, 6)),\n \t\t\t\t\tspan!(0, 8),\n \t\t\t\t),\n \t\t\t\tspan!(0, 10),\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -1,65 +1,24 @@\n /// Contains:\n /// - [VariableId] given to variable declaring items\n /// - [VariableField] for destructuring things and its nested derivatives + visiting behavior + tests for self\n-use std::{\n-\tborrow::Cow,\n-\tfmt::Debug,\n-\tsync::atomic::{AtomicU16, Ordering},\n-};\n+use std::{borrow::Cow, fmt::Debug};\n \n use crate::{\n \terrors::parse_lexing_error, parse_bracketed, property_key::PropertyKey,\n \ttokens::token_as_identifier, ASTNode, CursorId, Expression, ImmutableVariableOrPropertyPart,\n-\tMutableVariablePart, ParseError, ParseErrors, ParseResult, ParseSettings, Span, TSXToken,\n-\tToken, VisitSettings, Visitable, WithComment,\n+\tMutableVariablePart, ParseError, ParseErrors, ParseOptions, ParseResult, Span, TSXToken, Token,\n+\tVisitSettings, Visitable, WithComment,\n };\n \n-use derive_debug_extras::DebugExtras;\n use derive_partial_eq_extras::PartialEqExtras;\n use iterator_endiate::EndiateIteratorExt;\n use self_rust_tokenize::SelfRustTokenize;\n use tokenizer_lib::TokenReader;\n \n-static VARIABLE_COUNTER: AtomicU16 = AtomicU16::new(1);\n-\n-/// Id given to AST that declares a variable\n-#[derive(PartialEq, Eq, Clone, Copy, DebugExtras, Hash)]\n-pub struct VariableId(u16);\n-\n-#[cfg(feature = \"self-rust-tokenize\")]\n-impl self_rust_tokenize::SelfRustTokenize for VariableId {\n-\tfn append_to_token_stream(\n-\t\t&self,\n-\t\ttoken_stream: &mut self_rust_tokenize::proc_macro2::TokenStream,\n-\t) {\n-\t\ttoken_stream.extend(self_rust_tokenize::quote!(VariableId::new()))\n-\t}\n-}\n-\n-impl VariableId {\n-\tpub fn new() -> Self {\n-\t\tSelf(VARIABLE_COUNTER.fetch_add(1, Ordering::SeqCst))\n-\t}\n-\n-\t/// Only use if you know what you are not causing clashing\n-\tpub const fn new_from_id(id: u16) -> Self {\n-\t\tSelf(id)\n-\t}\n-\n-\t/// TODO temp\n-\tpub fn unwrap_counter(&self) -> u16 {\n-\t\tself.0\n-\t}\n-\n-\tpub fn set_counter_bad(value: u16) {\n-\t\tVARIABLE_COUNTER.store(value, Ordering::SeqCst)\n-\t}\n-}\n-\n #[derive(Debug, PartialEq, Eq, Clone)]\n #[cfg_attr(feature = \"self-rust-tokenize\", derive(self_rust_tokenize::SelfRustTokenize))]\n pub enum VariableIdentifier {\n-\tStandard(String, VariableId, Span),\n+\tStandard(String, Span),\n \t#[self_tokenize_field(0)]\n \tCursor(CursorId<Self>),\n }\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -673,7 +603,7 @@ mod tests {\n \tfn name() {\n \t\tassert_matches_ast!(\n \t\t\t\"x\",\n-\t\t\tVariableField::Name(VariableIdentifier::Standard(Deref @ \"x\", _, Span { start: 0, end: 1, .. }))\n+\t\t\tVariableField::Name(VariableIdentifier::Standard(Deref @ \"x\", Span { start: 0, end: 1, .. }))\n \t\t);\n \t}\n \ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -685,21 +615,18 @@ mod tests {\n \t\t\t\tDeref @ [ArrayDestructuringField::Name(\n \t\t\t\t\tWithComment::None(VariableField::Name(VariableIdentifier::Standard(\n \t\t\t\t\t\tDeref @ \"x\",\n-\t\t\t\t\t\t_,\n \t\t\t\t\t\tspan!(1, 2),\n \t\t\t\t\t))),\n \t\t\t\t\tNone,\n \t\t\t\t), ArrayDestructuringField::Name(\n \t\t\t\t\tWithComment::None(VariableField::Name(VariableIdentifier::Standard(\n \t\t\t\t\t\tDeref @ \"y\",\n-\t\t\t\t\t\t_,\n \t\t\t\t\t\tspan!(4, 5),\n \t\t\t\t\t))),\n \t\t\t\t\tNone,\n \t\t\t\t), ArrayDestructuringField::Name(\n \t\t\t\t\tWithComment::None(VariableField::Name(VariableIdentifier::Standard(\n \t\t\t\t\t\tDeref @ \"z\",\n-\t\t\t\t\t\t_,\n \t\t\t\t\t\tspan!(7, 8),\n \t\t\t\t\t))),\n \t\t\t\t\tNone,\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -714,14 +641,12 @@ mod tests {\n \t\t\t\tDeref @ [ArrayDestructuringField::Name(\n \t\t\t\t\tWithComment::None(VariableField::Name(VariableIdentifier::Standard(\n \t\t\t\t\t\tDeref @ \"x\",\n-\t\t\t\t\t\t_,\n \t\t\t\t\t\tspan!(1, 2),\n \t\t\t\t\t))),\n \t\t\t\t\tNone,\n \t\t\t\t), ArrayDestructuringField::None, ArrayDestructuringField::Name(\n \t\t\t\t\tWithComment::None(VariableField::Name(VariableIdentifier::Standard(\n \t\t\t\t\t\tDeref @ \"z\",\n-\t\t\t\t\t\t_,\n \t\t\t\t\t\tspan!(5, 6),\n \t\t\t\t\t))),\n \t\t\t\t\tNone,\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -737,13 +662,13 @@ mod tests {\n \t\t\t\"{x, y, z}\",\n \t\t\tVariableField::Object(\n \t\t\t\tDeref @ [WithComment::None(ObjectDestructuringField::Name(\n-\t\t\t\t\tVariableIdentifier::Standard(Deref @ \"x\", _, span!(1, 2)),\n+\t\t\t\t\tVariableIdentifier::Standard(Deref @ \"x\", span!(1, 2)),\n \t\t\t\t\tNone,\n \t\t\t\t)), WithComment::None(ObjectDestructuringField::Name(\n-\t\t\t\t\tVariableIdentifier::Standard(Deref @ \"y\", _, span!(4, 5)),\n+\t\t\t\t\tVariableIdentifier::Standard(Deref @ \"y\", span!(4, 5)),\n \t\t\t\t\tNone,\n \t\t\t\t)), WithComment::None(ObjectDestructuringField::Name(\n-\t\t\t\t\tVariableIdentifier::Standard(Deref @ \"z\", _, span!(7, 8)),\n+\t\t\t\t\tVariableIdentifier::Standard(Deref @ \"z\", span!(7, 8)),\n \t\t\t\t\tNone,\n \t\t\t\t))],\n \t\t\t\tspan!(0, 9),\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -757,12 +682,8 @@ mod tests {\n \t\t\t\"{ x = 2 }\",\n \t\t\tVariableField::Object(\n \t\t\t\tDeref @ [WithComment::None(ObjectDestructuringField::Name(\n-\t\t\t\t\tVariableIdentifier::Standard(Deref @ \"x\", _, span!(2, 7)),\n-\t\t\t\t\tSome(Expression::NumberLiteral(\n-\t\t\t\t\t\tcrate::NumberStructure::Number(_),\n-\t\t\t\t\t\tspan!(6, 7),\n-\t\t\t\t\t\t_,\n-\t\t\t\t\t)),\n+\t\t\t\t\tVariableIdentifier::Standard(Deref @ \"x\", span!(2, 7)),\n+\t\t\t\t\tSome(Expression::NumberLiteral(crate::NumberStructure::Number(_), span!(6, 7))),\n \t\t\t\t))],\n \t\t\t\tspan!(0, 9),\n \t\t\t)\ndiff --git a/parser/src/variable_fields.rs b/parser/src/variable_fields.rs\n--- a/parser/src/variable_fields.rs\n+++ b/parser/src/variable_fields.rs\n@@ -777,13 +698,12 @@ mod tests {\n \t\t\t\tDeref @ [ArrayDestructuringField::Name(\n \t\t\t\t\tWithComment::None(VariableField::Name(VariableIdentifier::Standard(\n \t\t\t\t\t\tDeref @ \"x\",\n-\t\t\t\t\t\t_,\n \t\t\t\t\t\tspan!(1, 2),\n \t\t\t\t\t))),\n \t\t\t\t\tNone,\n \t\t\t\t), ArrayDestructuringField::Spread(\n \t\t\t\t\tspan!(4, 7),\n-\t\t\t\t\tVariableIdentifier::Standard(Deref @ \"y\", _, span!(7, 8)),\n+\t\t\t\t\tVariableIdentifier::Standard(Deref @ \"y\", span!(7, 8)),\n \t\t\t\t)],\n \t\t\t\tspan!(0, 9),\n \t\t\t)\ndiff --git a/parser/tests/cursors.rs b/parser/tests/cursors.rs\n--- a/parser/tests/cursors.rs\n+++ b/parser/tests/cursors.rs\n@@ -1,6 +1,5 @@\n use ezno_parser::{\n-\texpressions::ExpressionId, ASTNode, CursorId, Expression, SourceId, Span, Statement,\n-\tStatementOrDeclaration,\n+\tASTNode, CursorId, Expression, SourceId, Span, Statement, StatementOrDeclaration,\n };\n \n #[test]\ndiff --git a/parser/tests/cursors.rs b/parser/tests/cursors.rs\n--- a/parser/tests/cursors.rs\n+++ b/parser/tests/cursors.rs\n@@ -52,14 +51,9 @@ fn cursor_at_property_access() {\n \tassert_eq!(\n \t\texpression,\n \t\tExpression::PropertyAccess {\n-\t\t\tparent: Box::new(Expression::VariableReference(\n-\t\t\t\t\"x\".to_owned(),\n-\t\t\t\tSpan::NULL_SPAN,\n-\t\t\t\tExpressionId::NULL\n-\t\t\t)),\n+\t\t\tparent: Box::new(Expression::VariableReference(\"x\".to_owned(), Span::NULL_SPAN,)),\n \t\t\tproperty: ezno_parser::PropertyReference::Cursor(CursorId(0, Default::default())),\n \t\t\tposition: Span::NULL_SPAN,\n-\t\t\texpression_id: ExpressionId::NULL,\n \t\t\tis_optional: false\n \t\t}\n \t);\ndiff --git a/parser/tests/statements.rs b/parser/tests/statements.rs\n--- a/parser/tests/statements.rs\n+++ b/parser/tests/statements.rs\n@@ -1,4 +1,5 @@\n-use ezno_parser::{ASTNode, Module, SourceId};\n+use ezno_parser::{ASTNode, Module, SourceId, ToStringOptions};\n+use pretty_assertions::assert_eq;\n \n #[test]\n fn statements() {\ndiff --git a/parser/tests/statements.rs b/parser/tests/statements.rs\n--- a/parser/tests/statements.rs\n+++ b/parser/tests/statements.rs\n@@ -26,6 +27,9 @@ try {\n     doThing()\n } catch (e) {\n     console.error(e)\n+}\n+interface X {\n+    a: string\n }\"#\n \t.trim_start();\n \ndiff --git a/parser/tests/statements.rs b/parser/tests/statements.rs\n--- a/parser/tests/statements.rs\n+++ b/parser/tests/statements.rs\n@@ -33,7 +37,7 @@ try {\n \t\tModule::from_string(input.to_owned(), Default::default(), SourceId::NULL, None, Vec::new())\n \t\t\t.unwrap();\n \n-\tlet output = module.to_string(&Default::default());\n+\tlet output = module.to_string(&ToStringOptions::typescript());\n \n \tassert_eq!(output, input);\n }\ndiff --git a/parser/tests/visiting.rs b/parser/tests/visiting.rs\n--- a/parser/tests/visiting.rs\n+++ b/parser/tests/visiting.rs\n@@ -1,7 +1,8 @@\n use ezno_parser::{\n \tstatements::UnconditionalElseStatement, ASTNode, Expression, Module, SourceId, Span, Statement,\n-\tToStringSettings, VisitSettings, VisitorMut, VisitorsMut,\n+\tToStringOptions, VisitSettings, VisitorMut, VisitorsMut,\n };\n+use pretty_assertions::assert_eq;\n \n #[test]\n fn visiting() {\ndiff --git a/parser/tests/visiting.rs b/parser/tests/visiting.rs\n--- a/parser/tests/visiting.rs\n+++ b/parser/tests/visiting.rs\n@@ -27,9 +28,9 @@ fn visiting() {\n \t};\n \tmodule.visit_mut(&mut visitors, &mut (), &VisitSettings::default());\n \n-\tlet output = module.to_string(&ToStringSettings::minified());\n+\tlet output = module.to_string(&ToStringOptions::minified());\n \n-\tlet expected = r#\"const x=\"HELLO WORLD\";function y(){if(condition){do_thing(\"HELLO WORLD\"+\" TEST\")}else{console.log(\"ELSE!\")}}\"#;\n+\tlet expected = r#\"const x=\"HELLO WORLD\";function y(){if(condition){do_thing(\"HELLO WORLD\"+\" TEST\")}else console.log(\"ELSE!\")}\"#;\n \tassert_eq!(output, expected);\n }\n \ndiff --git a/parser/tests/visiting.rs b/parser/tests/visiting.rs\n--- a/parser/tests/visiting.rs\n+++ b/parser/tests/visiting.rs\n@@ -38,7 +39,7 @@ struct MakeStringsUppercase;\n \n impl VisitorMut<Expression, ()> for MakeStringsUppercase {\n \tfn visit_mut(&mut self, item: &mut Expression, _data: &mut (), _chain: &ezno_parser::Chain) {\n-\t\tif let Expression::StringLiteral(content, _quoted, _, _) = item {\n+\t\tif let Expression::StringLiteral(content, _quoted, _) = item {\n \t\t\t*content = content.to_uppercase();\n \t\t}\n \t}\n",
        "problem_statement": "Automatic Semicolon Insertion\nCurrently the parser parses invalid script\r\n\r\n```javascript\r\n$ cargo run -- ast-explorer full-ast\r\nfull_ast> const x = 2 const y = 3\r\nParseOutput(\r\n    Module {\r\n        statements: [\r\n            VariableDeclaration(\r\n                ConstDeclaration {\r\n                    keyword: Keyword(\r\n                        Const,\r\n                        0..5,\r\n                    ),\r\n                    declarations: [\r\n                        VariableDeclaration {\r\n                            name: None(\r\n                                Name(\r\n                                    Standard(\r\n                                        \"x\",\r\n                                        VariableId(1),\r\n                                        6..7,\r\n                                    ),\r\n                                ),\r\n                            ),\r\n                            type_reference: None,\r\n                            expression: NumberLiteral(\r\n                                Number(\r\n                                    2.0,\r\n                                ),\r\n                                10..11,\r\n                                ExpressionId(1),\r\n                            ),\r\n                        },\r\n                    ],\r\n                },\r\n            ),\r\n            VariableDeclaration(\r\n                ConstDeclaration {\r\n                    keyword: Keyword(\r\n                        Const,\r\n                        12..17,\r\n                    ),\r\n                    declarations: [\r\n                        VariableDeclaration {\r\n                            name: None(\r\n                                Name(\r\n                                    Standard(\r\n                                        \"y\",\r\n                                        VariableId(2),\r\n                                        18..19,\r\n                                    ),\r\n                                ),\r\n                            ),\r\n                            type_reference: None,\r\n                            expression: NumberLiteral(\r\n                                Number(\r\n                                    3.0,\r\n                                ),\r\n                                22..23,\r\n                                ExpressionId(2),\r\n                            ),\r\n                        },\r\n                    ],\r\n                },\r\n            ),\r\n        ],\r\n        ..\r\n    },\r\n    ParsingState { .. },\r\n)\r\n```\r\n\r\nHere it should fail, there needs to be a semi colon after the `2` expression. This currently works because the check is not there. The check is not there because I wanted to get non semicolon lines to work before I added automatic semi-colon insertion.\r\n\r\n[JavaScript accepts places where semi-colons aren't necessary and automatically inserts them](https://262.ecma-international.org/7.0/#sec-rules-of-automatic-semicolon-insertion). \r\n\r\nOther links:\r\n- https://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi\r\n- https://blog.alexdevero.com/automatic-semicolon-insertion-in-javascript/\r\n\r\n### Steps to fix\r\n1. Add a `AutoSemiColon` variant to `TSXToken`\r\n2. The lexer should insert in places according to the rule\r\n3. Statement parsing should check either a `AutoSemiColon` or `SemiColon` token terminates some statements\n",
        "hints_text": "Have worked a bit on this with https://github.com/kaleidawave/ezno/pull/9/commits/47c4d51744e9a1d975b22b2c7bc9322e585d84d0 (part of PR #9). Removed the skipping code and now checks that the required statements/declarations finish with a semicolon (or sort of auto semi colon). Also improved the string output and where semi colons are added.\r\n\r\nOne thing is that auto semi colons aren't always going to be a token. It would be a bit wasteful that for every close brace to end up with two tokens added, so using a peek as an alternative. \r\n\r\nThe other rules in the document are more difficult to even understand (never mind implement). The lexer isn't hugely aware of context, so some of the rules might require making the lexer more complex \ud83d\ude10. So I would maybe say this is a 1/3 implemented atm.   \nI have an idea of how to do this. Will fix when I have the time again",
        "created_at": "2023-08-22T09:37:21Z",
        "version": "0.0"
    },
    {
        "repo": "kaleidawave/ezno",
        "pull_number": 218,
        "instance_id": "kaleidawave__ezno-218",
        "issue_numbers": [
            "188"
        ],
        "base_commit": "d0a21ba6b4ceb10299c9642c49ae2afc34e29faf",
        "patch": "diff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -2441,7 +2441,7 @@ fakeRead(array1)\n #### Always known math\n \n ```ts\n-// True regardless of \n+// True regardless of\n function func(a: number) { return a ** 0 }\n \n func satisfies string;\ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -4095,7 +4099,7 @@ x.property_a satisfies number;\n x.property_b\n ```\n \n-- No property 'property_b' on { [string]: X[keyof X & string] }\n+- No property 'property_b' on { [`property_${keyof X & string}`]: X[keyof X & string] }\n \n ### Readonly and `as const`\n \ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -57,6 +57,24 @@ pub fn print_type_with_type_arguments(\n \tbuf\n }\n \n+pub fn print_inner_template_literal_type_into_buf<C: InformationChain>(\n+\tty: TypeId,\n+\tbuf: &mut String,\n+\tcycles: &mut HashSet<TypeId>,\n+\targs: GenericChain,\n+\ttypes: &TypeStore,\n+\tinfo: &C,\n+\tdebug: bool,\n+) {\n+\tif let Type::Constant(cst) = types.get_type_by_id(ty) {\n+\t\tbuf.push_str(&cst.as_js_string());\n+\t} else {\n+\t\tbuf.push_str(\"${\");\n+\t\tprint_type_into_buf(ty, buf, cycles, args, types, info, debug);\n+\t\tbuf.push('}');\n+\t}\n+}\n+\n /// Recursion safe + reuses buffer\n pub fn print_type_into_buf<C: InformationChain>(\n \tty: TypeId,\ndiff --git a/checker/src/types/printing.rs b/checker/src/types/printing.rs\n--- a/checker/src/types/printing.rs\n+++ b/checker/src/types/printing.rs\n@@ -469,7 +487,25 @@ pub fn print_type_into_buf<C: InformationChain>(\n \t\t\t\t\tunreachable!()\n \t\t\t\t}\n \t\t\t},\n-\t\t\t_constructor => {\n+\t\t\tconstructor => {\n+\t\t\t\tif let Constructor::BinaryOperator { result: result_ty, lhs, rhs, .. } = constructor\n+\t\t\t\t{\n+\t\t\t\t\tif *result_ty != TypeId::NUMBER_TYPE\n+\t\t\t\t\t\t&& !matches!(\n+\t\t\t\t\t\t\ttypes.get_type_by_id(*result_ty),\n+\t\t\t\t\t\t\tType::PartiallyAppliedGenerics(_) | Type::RootPolyType(_)\n+\t\t\t\t\t\t) {\n+\t\t\t\t\t\tbuf.push('`');\n+\t\t\t\t\t\tprint_inner_template_literal_type_into_buf(\n+\t\t\t\t\t\t\t*lhs, buf, cycles, args, types, info, debug,\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\tprint_inner_template_literal_type_into_buf(\n+\t\t\t\t\t\t\t*rhs, buf, cycles, args, types, info, debug,\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\tbuf.push('`');\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n \t\t\t\tlet base = get_constraint(ty, types).unwrap();\n \t\t\t\tprint_type_into_buf(base, buf, cycles, args, types, info, debug);\n \t\t\t}\n",
        "test_patch": "diff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -3694,7 +3694,7 @@ type Name = \"Ben\"\n \n > Should be `Expected \"Hello Ben\", found \"test\"`. See #188\n \n-- Expected string, found \"test\"\n+- Expected `Hello ${Name}`, found \\\"test\\\"\n \n #### Template literal type specialisation\n \ndiff --git a/checker/specification/specification.md b/checker/specification/specification.md\n--- a/checker/specification/specification.md\n+++ b/checker/specification/specification.md\n@@ -3751,14 +3751,18 @@ interface X {\n \n #### Template literal types\n \n+> Last one tests printing\n+\n ```ts\n type Introduction = `Hello ${string}`;\n \n const first: Introduction = \"Hello Ben\";\n const second: Introduction = \"Hi Ben\";\n+const third: `Hiya ${string}` = \"Hello Ben\";\n ```\n \n - Type \"Hi Ben\" is not assignable to type Introduction\n+- Type \"Hello Ben\" is not assignable to type `Hiya ${string}`\n \n #### Assigning to types as keys\n \n",
        "problem_statement": "Template literal type printing\nAt the moment the template literal **type** `` `Hi${string}` `` is printed at `string` (as that is its base type).\r\n\r\nThere should be special logic to pick up the type `Constructor::BinaryOperation { lhs, rhs, operation: MathematicalAndBitwise::Addition }` and then form a chain of `parts: Vec<(String, TypeId)>, trailing: String` using recursive type traversal. If it looks like a template literal type (aka no number + number) then it can be printed like on (see example in parser)\r\n\r\nIt should be added around here\r\n\r\nhttps://github.com/kaleidawave/ezno/blob/e6f6ffd7cb48285cdaaf7e57e4d636bbaf038b03/checker/src/types/printing.rs#L254-L281\n",
        "hints_text": "Hello @kaleidawave, next I am working on this.\r\n\r\nhttps://github.com/kaleidawave/ezno/blob/d67cd1b0b9f5c308a8d3f8ea04c5ccb8baa470c5/checker/specification/specification.md#L4079-L4094\r\n\r\nWhen implementing type expansion in template literals, this case fails, but how far do you expect to expand?\r\n\r\n```\r\n// Current\r\nNo property 'property_b' on { [string]: X[keyof X & string] }\r\n\r\n// Option 1\r\nNo property 'property_b' on { [`property_${P}`]: X[keyof X & string] }\r\n\r\n// Option 2\r\nNo property 'property_b' on { [`property_${((keyof T) & string)}`]: X[keyof X & string] }\r\n\r\n// Option 3\r\nNo property 'property_b' on { [`property_${((keyof X) & string)}`]: X[keyof X & string] }\r\n```\r\n\r\nCurrent implementation is Option 3 https://github.com/kaleidawave/ezno/pull/218 (draft)\nAwesome! Yes I like option 3 as it has the most information. (is there any difference between 2 and 3?). It is fine to modify the specification if it is just a printing difference etc. \nIt is simply a question of how deep to search, so if Option 3 is fine, this seems to be the way to go!\r\n\r\nIncidentally, this is how this case currently works, but it is also supposed to be deployed, right?\r\n\r\n````\r\n\r\n```ts\r\nconst invalidStr: `Hi${string}` = 'Hello, there!';\r\ntype InvalidStr = `Hi${string}`;\r\nconst invalidStr2: InvalidStr = 'Hello, there2!';\r\n```\r\n\r\n- Type \"Hello, there!\" is not assignable to type `Hi${string}`\r\n- Type \"Hello, there2!\" is not assignable to type InvalidStr\r\n\r\n````\nYep I think that is fine. I am split on whether to print the name vs the value of an alias. I think it currently easiest to just print the name.\nOK, so I'm going to Open the PR as it is for now!",
        "created_at": "2024-11-09T10:13:26Z",
        "version": "0.0"
    }
]