[
    {
        "repo": "nuta/kerla",
        "pull_number": 152,
        "instance_id": "nuta__kerla-152",
        "issue_numbers": [
            "117",
            "117"
        ],
        "base_commit": "5c001ca5e6f3dc671730537ace97c67267d3dcac",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -186,6 +186,7 @@ dependencies = [\n  \"arrayvec 0.7.2\",\n  \"atomic_refcell\",\n  \"bitflags\",\n+ \"bitvec\",\n  \"boot2dump\",\n  \"crossbeam\",\n  \"goblin\",\ndiff --git a/kernel/Cargo.toml b/kernel/Cargo.toml\n--- a/kernel/Cargo.toml\n+++ b/kernel/Cargo.toml\n@@ -21,6 +21,7 @@ arrayvec = { version = \"0.7.2\", default-features = false }\n hashbrown = { version = \"0.12.0\", features = [\"nightly\"] }\n crossbeam = { version = \"0.8.1\", default-features = false, features = [\"alloc\"] }\n atomic_refcell = \"0.1.6\"\n+bitvec = { version = \"1.0.0\", default-features = false, features = [\"atomic\", \"alloc\"] }\n \n # Arch-specific dependencies.\n x86 = \"0.44.0\"\ndiff --git a/kernel/process/process.rs b/kernel/process/process.rs\n--- a/kernel/process/process.rs\n+++ b/kernel/process/process.rs\n@@ -36,7 +36,7 @@ use kerla_runtime::{\n     page_allocator::{alloc_pages, AllocPageFlags},\n     spinlock::{SpinLock, SpinLockGuard},\n };\n-use kerla_utils::{alignment::align_up, bitmap::BitMap};\n+use kerla_utils::{alignment::align_up};\n \n type ProcessTable = BTreeMap<PId, Arc<Process>>;\n \ndiff --git a/kernel/process/process.rs b/kernel/process/process.rs\n--- a/kernel/process/process.rs\n+++ b/kernel/process/process.rs\n@@ -143,7 +143,7 @@ impl Process {\n             opened_files: SpinLock::new(OpenedFileTable::new()),\n             signals: SpinLock::new(SignalDelivery::new()),\n             signaled_frame: AtomicCell::new(None),\n-            sigset: SpinLock::new(BitMap::zeroed()),\n+            sigset: SpinLock::new(SigSet::ZERO),\n         });\n \n         process_group.lock().add(Arc::downgrade(&proc));\ndiff --git a/kernel/process/process.rs b/kernel/process/process.rs\n--- a/kernel/process/process.rs\n+++ b/kernel/process/process.rs\n@@ -204,7 +204,7 @@ impl Process {\n             root_fs,\n             signals: SpinLock::new(SignalDelivery::new()),\n             signaled_frame: AtomicCell::new(None),\n-            sigset: SpinLock::new(BitMap::zeroed()),\n+            sigset: SpinLock::new(SigSet::ZERO),\n         });\n \n         process_group.lock().add(Arc::downgrade(&process));\ndiff --git a/kernel/process/process.rs b/kernel/process/process.rs\n--- a/kernel/process/process.rs\n+++ b/kernel/process/process.rs\n@@ -401,15 +401,16 @@ impl Process {\n         let mut sigset = self.sigset.lock();\n \n         if let Some(old) = oldset {\n-            old.write_bytes(sigset.as_slice())?;\n+            old.write_bytes(sigset.as_raw_slice())?;\n         }\n \n         if let Some(new) = set {\n             let new_set = new.read::<[u8; 128]>()?;\n+            let new_set = SigSet::new(new_set);\n             match how {\n-                SignalMask::Block => sigset.assign_or(new_set),\n-                SignalMask::Unblock => sigset.assign_and_not(new_set),\n-                SignalMask::Set => sigset.assign(new_set),\n+                SignalMask::Block => *sigset |= new_set,\n+                SignalMask::Unblock => *sigset &= !new_set,\n+                SignalMask::Set => *sigset = new_set,\n             }\n         }\n \ndiff --git a/kernel/process/process.rs b/kernel/process/process.rs\n--- a/kernel/process/process.rs\n+++ b/kernel/process/process.rs\n@@ -424,7 +425,7 @@ impl Process {\n         let current = current_process();\n         if let Some((signal, sigaction)) = current.signals.lock().pop_pending() {\n             let sigset = current.sigset.lock();\n-            if !sigset.get(signal as usize).unwrap_or(true) {\n+            if !sigset.get(signal as usize).as_deref().unwrap_or(&true) {\n                 match sigaction {\n                     SigAction::Ignore => {}\n                     SigAction::Terminate => {\ndiff --git a/kernel/process/process.rs b/kernel/process/process.rs\n--- a/kernel/process/process.rs\n+++ b/kernel/process/process.rs\n@@ -516,7 +517,7 @@ impl Process {\n             arch,\n             signals: SpinLock::new(SignalDelivery::new()),\n             signaled_frame: AtomicCell::new(None),\n-            sigset: SpinLock::new(sig_set.clone()),\n+            sigset: SpinLock::new(*sig_set),\n         });\n \n         process_group.lock().add(Arc::downgrade(&child));\ndiff --git a/kernel/process/signal.rs b/kernel/process/signal.rs\n--- a/kernel/process/signal.rs\n+++ b/kernel/process/signal.rs\n@@ -1,6 +1,6 @@\n use crate::{ctypes::c_int, prelude::*};\n use kerla_runtime::address::UserVAddr;\n-use kerla_utils::bitmap::BitMap;\n+use bitvec::prelude::*;\n \n pub type Signal = c_int;\n #[allow(unused)]\ndiff --git a/kernel/process/signal.rs b/kernel/process/signal.rs\n--- a/kernel/process/signal.rs\n+++ b/kernel/process/signal.rs\n@@ -159,7 +159,8 @@ impl SignalDelivery {\n     }\n }\n \n-pub type SigSet = BitMap<128 /* 1024 / 8 */>;\n+//pub type SigSet = BitMap<128 /* 1024 / 8 */>;\n+pub type SigSet = BitArray<[u8; 1024 / 8 /* quark no_std? */], LocalBits>;\n pub enum SignalMask {\n     Block,\n     Unblock,\ndiff --git a/libs/kerla_utils/id_table.rs b/libs/kerla_utils/id_table.rs\n--- a/libs/kerla_utils/id_table.rs\n+++ b/libs/kerla_utils/id_table.rs\n@@ -1,21 +1,22 @@\n-use crate::bitmap::BitMap;\n+use core::mem::size_of;\n+use bitvec::prelude::*;\n \n-pub struct IdTable<const SZ: usize>(BitMap<SZ>);\n+pub struct IdTable<const BIT_LENGTH: usize>(BitArray<[usize; BIT_LENGTH], LocalBits>); // const expr arithmetic unstable\n \n-impl<const SZ: usize> IdTable<SZ> {\n-    pub const fn new() -> IdTable<SZ> {\n-        IdTable(BitMap::zeroed())\n+impl<const BIT_LENGTH: usize> IdTable<BIT_LENGTH> {\n+    pub const fn new() -> IdTable<BIT_LENGTH> {\n+        IdTable(BitArray::ZERO)\n     }\n \n     pub fn alloc(&mut self) -> Option<usize> {\n         self.0.first_zero().map(|id| {\n-            self.0.set(id);\n+            self.0.set(id, true);\n             id\n         })\n     }\n \n     pub fn free(&mut self, id: usize) {\n-        debug_assert_eq!(self.0.get(id), Some(true));\n-        self.0.unset(id);\n+        debug_assert_eq!(self.0.get(id).as_deref(), Some(&true));\n+        self.0.set(id, false);\n     }\n }\ndiff --git a/libs/kerla_utils/lib.rs b/libs/kerla_utils/lib.rs\n--- a/libs/kerla_utils/lib.rs\n+++ b/libs/kerla_utils/lib.rs\n@@ -15,7 +15,6 @@ extern crate alloc;\n extern crate log;\n \n pub mod alignment;\n-pub mod bitmap;\n pub mod bitmap_allocator;\n pub mod buddy_allocator;\n pub mod bump_allocator;\n",
        "test_patch": "diff --git a/libs/kerla_utils/bitmap.rs /dev/null\n--- a/libs/kerla_utils/bitmap.rs\n+++ /dev/null\n@@ -1,106 +0,0 @@\n-use core::slice::memchr::memchr;\n-\n-#[derive(Clone)]\n-pub struct BitMap<const SZ: usize>([u8; SZ]);\n-\n-impl<const SZ: usize> BitMap<SZ> {\n-    pub const fn zeroed() -> BitMap<SZ> {\n-        BitMap([0; SZ])\n-    }\n-\n-    #[cfg(test)]\n-    pub const fn from_array(array: [u8; SZ]) -> BitMap<SZ> {\n-        BitMap(array)\n-    }\n-\n-    pub fn as_slice(&self) -> &[u8] {\n-        &self.0\n-    }\n-\n-    #[inline]\n-    pub fn bits(&self) -> usize {\n-        SZ * 8\n-    }\n-\n-    #[inline]\n-    pub fn get(&self, index: usize) -> Option<bool> {\n-        if index >= self.bits() {\n-            return None;\n-        }\n-\n-        Some(self.0[index / 8] & (1 << (index % 8)) != 0)\n-    }\n-\n-    #[inline(always)]\n-    pub fn set(&mut self, index: usize) {\n-        self.0[index / 8] |= 1 << (index % 8);\n-    }\n-\n-    #[inline(always)]\n-    pub fn unset(&mut self, index: usize) {\n-        self.0[index / 8] &= !(1 << (index % 8));\n-    }\n-\n-    #[inline]\n-    pub fn first_zero(&self) -> Option<usize> {\n-        for (byte_index, byte) in self.0.iter().enumerate() {\n-            if *byte != 0xff {\n-                return Some(byte_index * 8 + (byte.trailing_ones() as usize));\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    pub fn assign(&mut self, rhs: [u8; SZ]) {\n-        self.0 = rhs;\n-    }\n-\n-    /// This method will panic if SZ != rhs.len()\n-    pub fn assign_or(&mut self, rhs: [u8; SZ]) {\n-        for (i, byte) in self.0.iter_mut().enumerate() {\n-            *byte |= rhs[i];\n-        }\n-    }\n-\n-    /// This method will panic if SZ != rhs.len()\n-    pub fn assign_and_not(&mut self, rhs: [u8; SZ]) {\n-        for (i, byte) in self.0.iter_mut().enumerate() {\n-            *byte &= !rhs[i];\n-        }\n-    }\n-}\n-\n-#[cfg(all(test, not(feature = \"no_std\")))]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_bit_map() {\n-        let mut bitmap = BitMap::from_array([0xff, 0xff, 0xff]);\n-        assert_eq!(bitmap.first_zero(), None);\n-        bitmap.unset(13);\n-        assert_eq!(bitmap.first_zero(), Some(13));\n-\n-        let mut bitmap = BitMap::from_array([0b1111_1111, 0b1111_0001]);\n-        assert_eq!(bitmap.get(11), Some(false));\n-        bitmap.set(11);\n-        assert_eq!(bitmap.get(11), Some(true));\n-        assert_eq!(bitmap.as_slice(), &[0b1111_1111, 0b1111_1001]);\n-        assert_eq!(bitmap.first_zero(), Some(9));\n-    }\n-\n-    #[test]\n-    fn or() {\n-        let mut bitmap = BitMap::from_array([0b0100_0010, 0b1000_0001]);\n-        bitmap.assign_or([0b0010_0100, 0b1010_0110]);\n-        assert_eq!(bitmap.as_slice(), &[0b0110_0110, 0b1010_0111]);\n-    }\n-\n-    #[test]\n-    fn assign_and_not() {\n-        let mut bitmap = BitMap::from_array([0b0100_0010, 0b1000_0001]);\n-        bitmap.assign_and_not([0b0110_0100, 0b1010_0110]);\n-        assert_eq!(bitmap.as_slice(), &[0b0000_0010, 0b0000_0001]);\n-    }\n-}\n",
        "problem_statement": "Replace `kerla_utils::bitmap` with `bitvec::array::BitArray`\nI noticed that [bitvec](https://docs.rs/bitvec/latest/bitvec/array/struct.BitArray.html) provides sufficient features for us as a bitmap container. This is a refactoring issue to replace all bitmaps in Kerla with bitvec.\nReplace `kerla_utils::bitmap` with `bitvec::array::BitArray`\nI noticed that [bitvec](https://docs.rs/bitvec/latest/bitvec/array/struct.BitArray.html) provides sufficient features for us as a bitmap container. This is a refactoring issue to replace all bitmaps in Kerla with bitvec.\n",
        "hints_text": "\n",
        "created_at": "2022-02-07T09:03:07Z"
    },
    {
        "repo": "nuta/kerla",
        "pull_number": 55,
        "instance_id": "nuta__kerla-55",
        "issue_numbers": [
            "54"
        ],
        "base_commit": "04b459347e6321a355ca902a6874343a4e47cd55",
        "patch": "diff --git a/kernel/fs/opened_file.rs b/kernel/fs/opened_file.rs\n--- a/kernel/fs/opened_file.rs\n+++ b/kernel/fs/opened_file.rs\n@@ -386,6 +386,11 @@ impl OpenedFileTable {\n         self.clone()\n     }\n \n+    /// Closes all opened files.\n+    pub fn close_all(&mut self) {\n+        self.files.clear();\n+    }\n+\n     /// Closes opened files with `CLOEXEC` set.\n     pub fn close_cloexec_files(&mut self) {\n         for slot in &mut self.files {\ndiff --git a/kernel/process/process.rs b/kernel/process/process.rs\n--- a/kernel/process/process.rs\n+++ b/kernel/process/process.rs\n@@ -315,6 +315,11 @@ impl Process {\n             parent.send_signal(SIGCHLD);\n         }\n \n+        // Close opened files here instead of in Drop::drop because `proc` is\n+        // not dropped until it's joined by the parent process. Drop them to\n+        // make pipes closed.\n+        proc.opened_files.lock().close_all();\n+\n         PROCESSES.lock().remove(&proc.pid);\n         JOIN_WAIT_QUEUE.wake_all();\n         switch();\n",
        "test_patch": "diff --git /dev/null b/initramfs/integration_tests/close_pipes_on_exit.test\nnew file mode 100644\n--- /dev/null\n+++ b/initramfs/integration_tests/close_pipes_on_exit.test\n@@ -0,0 +1,13 @@\n+#\n+# Checks if a pipe is closed on a process exit.\n+#\n+# Busybox runs $(echo foo) in a forked process and the parent process read child's\n+# output through a pipe until read(2) return 0, i.e. EOF. Since the parent calls\n+# wait4(2) after the pipe is closed, on child's exit, its opened files must be\n+# closed to return EOF to the parent.\n+#\n+# This script is a regression test for: https://github.com/nuta/kerla/issues/54\n+set -ue\n+\n+result=$(echo hello from pipe)\n+echo $result | grep \"hello from pipe\"\n",
        "problem_statement": "`foo=$(echo bar)` freezes the shell\n```\r\nBusyBox v1.31.1 (2021-11-04 11:38:59 UTC) built-in shell (ash)\r\n\r\n[   0.038] [1:/bin/sh] syscall: open(44af99, 2, 0, 0, 0, 0)\r\n[   0.038] [1:/bin/sh] open(\"/dev/tty\")\r\n[   0.040] [1:/bin/sh] syscall: fcntl(3, 406, a, a, 48, 0)\r\n[   0.041] [1:/bin/sh] syscall: fcntl(a, 2, 1, a, 48, 0)\r\n[   0.041] [1:/bin/sh] syscall: close(3, 0, 0, 0, 0, 0)\r\n[   0.042] [1:/bin/sh] syscall: ioctl(a, 540f, 9ffffed14, 0, 0, 0)\r\n[   0.043] [1:/bin/sh] syscall: getpgid(0, 540f, 9ffffed14, 0, 0, 0)\r\n[   0.044] [1:/bin/sh] syscall: rt_sigaction(14, 0, 9ffffec00, 8, 0, 0)\r\n[   0.045] [1:/bin/sh] syscall: rt_sigaction(14, 9ffffebe0, 0, 8, 0, 0)\r\n[   0.046] [1:/bin/sh] syscall: rt_sigaction(16, 0, 9ffffec00, 8, 0, 0)\r\n[   0.046] [1:/bin/sh] syscall: rt_sigaction(16, 9ffffebe0, 0, 8, 0, 0)\r\n[   0.046] [1:/bin/sh] syscall: rt_sigaction(15, 0, 9ffffec00, 8, 0, 0)\r\n[   0.047] [1:/bin/sh] syscall: setpgid(0, 1, 0, 8, 0, 0)\r\n[   0.048] [1:/bin/sh] syscall: ioctl(a, 5410, 9ffffed04, 8, 0, 0)\r\n[   0.049] [1:/bin/sh] syscall: wait4(ffffffffffffffff, 9ffffebec, 3, 0, 0, 0)\r\n# x=$(echo)\r\n[   4.895] [1:/bin/sh] syscall: pipe(9ffffea40, 1, 451400, 2, 101010101010101, 3)\r\n[   4.896] [1:/bin/sh] syscall: rt_sigprocmask(0, 449d58, 9ffffe910, 8, 452150, 3)\r\n[   4.896] WARN: unimplemented system call: rt_sigprocmask (n=14)\r\n[   4.896] WARN: rt_sigprocmask: error: ENOSYS: This error originates from:\r\n    #1: ffff800000214179  kerla::printk::capture_backtrace()+0x79\r\n    #2: ffff8000001ad443  kerla::result::Error::new()+0x23\r\n    #3: ffff80000014ba77  kerla::syscalls::SyscallHandler::do_dispatch()+0x9c7\r\n    #4: ffff80000014a87c  kerla::syscalls::SyscallHandler::dispatch()+0x1ac\r\n    #5: ffff8000001b6dbc  x64_handle_syscall()+0x9c\r\n    #6: ffff800000100235  syscall_entry()+0x3d\r\n\r\n[   4.897] [1:/bin/sh] syscall: fork(0, 449d58, 9ffffe910, 8, 452150, 3)\r\n[   4.898] [1:/bin/sh] syscall: rt_sigprocmask(2, 9ffffe910, 0, 8, 452150, 3)\r\n[   4.898] WARN: unimplemented system call: rt_sigprocmask (n=14)\r\n[   4.898] WARN: rt_sigprocmask: error: ENOSYS: This error originates from:\r\n    #1: ffff800000214179  kerla::printk::capture_backtrace()+0x79\r\n    #2: ffff8000001ad443  kerla::result::Error::new()+0x23\r\n    #3: ffff80000014ba77  kerla::syscalls::SyscallHandler::do_dispatch()+0x9c7\r\n    #4: ffff80000014a87c  kerla::syscalls::SyscallHandler::dispatch()+0x1ac\r\n    #5: ffff8000001b6dbc  x64_handle_syscall()+0x9c\r\n    #6: ffff800000100235  syscall_entry()+0x3d\r\n\r\n[   4.899] [1:/bin/sh] syscall: close(4, 0, 0, 0, 0, 0)\r\n[   4.899] [1:/bin/sh] syscall: read(3, 9ffffea48, 80, 0, 0, 0)\r\n[   4.900] [2:/bin/sh] syscall: gettid(0, 449d58, 450438, 8, 452150, 3)\r\n[   4.900] WARN: unimplemented system call: gettid (n=186)\r\n[   4.900] WARN: gettid: error: ENOSYS: This error originates from:\r\n    #1: ffff800000214179  kerla::printk::capture_backtrace()+0x79\r\n    #2: ffff8000001ad443  kerla::result::Error::new()+0x23\r\n    #3: ffff80000014ba77  kerla::syscalls::SyscallHandler::do_dispatch()+0x9c7\r\n    #4: ffff80000014a87c  kerla::syscalls::SyscallHandler::dispatch()+0x1ac\r\n    #5: ffff8000001b6dbc  x64_handle_syscall()+0x9c\r\n    #6: ffff800000100235  syscall_entry()+0x3d\r\n\r\n[   4.901] [2:/bin/sh] syscall: rt_sigprocmask(2, 9ffffe910, 0, 8, 452150, 3)\r\n[   4.901] WARN: unimplemented system call: rt_sigprocmask (n=14)\r\n[   4.901] WARN: rt_sigprocmask: error: ENOSYS: This error originates from:\r\n    #1: ffff800000214179  kerla::printk::capture_backtrace()+0x79\r\n    #2: ffff8000001ad443  kerla::result::Error::new()+0x23\r\n    #3: ffff80000014ba77  kerla::syscalls::SyscallHandler::do_dispatch()+0x9c7\r\n    #4: ffff80000014a87c  kerla::syscalls::SyscallHandler::dispatch()+0x1ac\r\n    #5: ffff8000001b6dbc  x64_handle_syscall()+0x9c\r\n    #6: ffff800000100235  syscall_entry()+0x3d\r\n\r\n[   4.902] [2:/bin/sh] syscall: rt_sigaction(2, 9ffffe820, 0, 8, 452150, 3)\r\n[   4.903] [2:/bin/sh] syscall: rt_sigaction(f, 9ffffe820, 0, 8, 452150, 3)\r\n[   4.903] [2:/bin/sh] syscall: rt_sigaction(3, 9ffffe820, 0, 8, 452150, 3)\r\n[   4.903] [2:/bin/sh] syscall: close(3, 0, 0, 0, 0, 0)\r\n[   4.903] [2:/bin/sh] syscall: dup2(4, 1, 0, 0, 21, 0)\r\n[   4.904] [2:/bin/sh] syscall: close(4, 0, 0, 0, 0, 0)\r\n[   4.906] [2:/bin/sh] syscall: wait4(ffffffffffffffff, 9ffffe7ac, 1, 0, 0, 0)\r\n[   4.908] [2:/bin/sh] syscall: exit_group(0, 0, 451020, 0, 452050, 0)\r\n[   4.908] WARN: unimplemented system call: exit_group (n=231)\r\n[   4.908] WARN: exit_group: error: ENOSYS: This error originates from:\r\n    #1: ffff800000214179  kerla::printk::capture_backtrace()+0x79\r\n    #2: ffff8000001ad443  kerla::result::Error::new()+0x23\r\n    #3: ffff80000014ba77  kerla::syscalls::SyscallHandler::do_dispatch()+0x9c7\r\n    #4: ffff80000014a87c  kerla::syscalls::SyscallHandler::dispatch()+0x1ac\r\n    #5: ffff8000001b6dbc  x64_handle_syscall()+0x9c\r\n    #6: ffff800000100235  syscall_entry()+0x3d\r\n\r\n[   4.909] [2:/bin/sh] syscall: exit(0, 0, 3c, 0, 452050, 0)\r\n[   4.909] WARN: read: error: EINTR: This error originates from:\r\n    #1: ffff800000214179  kerla::printk::capture_backtrace()+0x79\r\n    #2: ffff8000001ad443  kerla::result::Error::new()+0x23\r\n    #3: ffff8000001ada17  <kerla::result::Error as c...la::result::Errno>>::from()+0x17\r\n    #4: ffff8000001ab467  <T as core::convert::Into<U>>::into()+0x17\r\n    #5: ffff800000136cfe  kerla::process::wait_queue...e::sleep_signalable_until()+0x1ae\r\n    #6: ffff800000152e4c  <kerla::pipe::PipeReader a...s::inode::FileLike>::read()+0x7c\r\n    #7: ffff80000012dfcd  kerla::fs::opened_file::OpenedFile::read()+0x14d\r\n    #8: ffff800000146276  kerla::syscalls::read::<im...SyscallHandler>::sys_read()+0x1d6\r\n\r\n[   4.909] delivering 17 to PId(1)\r\n[   4.910] [1:/bin/sh] syscall: rt_sigreturn(11, 0, 0, 0, 0, 0)\r\n[   4.910] WARN: rt_sigreturn: error: EINTR: This error originates from:\r\n    #1: ffff800000214179  kerla::printk::capture_backtrace()+0x79\r\n    #2: ffff8000001ad443  kerla::result::Error::new()+0x23\r\n    #3: ffff8000001ada17  <kerla::result::Error as c...la::result::Errno>>::from()+0x17\r\n    #4: ffff8000001ab467  <T as core::convert::Into<U>>::into()+0x17\r\n    #5: ffff8000001477f4  kerla::syscalls::rt_sigret...andler>::sys_rt_sigreturn()+0x44\r\n    #6: ffff80000014b577  kerla::syscalls::SyscallHandler::do_dispatch()+0x4c7\r\n    #7: ffff80000014a87c  kerla::syscalls::SyscallHandler::dispatch()+0x1ac\r\n    #8: ffff8000001b6dbc  x64_handle_syscall()+0x9c\r\n\r\n[   4.911] [1:/bin/sh] syscall: read(3, 9ffffea48, 80, 0, 0, 0)\r\n[   4.912] [1:/bin/sh] syscall: read(3, 9ffffea48, 80, 0, 0, 0)\r\n\r\n[freezes here]\r\n```\n",
        "hints_text": "",
        "created_at": "2021-11-07T11:05:52Z"
    },
    {
        "repo": "nuta/kerla",
        "pull_number": 92,
        "instance_id": "nuta__kerla-92",
        "issue_numbers": [
            "87"
        ],
        "base_commit": "ba2158b1325add0f62f30675fb355a5821a76e65",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -194,6 +194,7 @@ dependencies = [\n  \"cfg-if\",\n  \"kerla_utils\",\n  \"log\",\n+ \"log_filter\",\n  \"spin 0.9.2\",\n  \"vte\",\n  \"x86\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -231,6 +232,13 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"log_filter\"\n+version = \"0.0.1\"\n+dependencies = [\n+ \"log\",\n+]\n+\n [[package]]\n name = \"managed\"\n version = \"0.7.2\"\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -3,6 +3,7 @@ export V         ?=\n export GUI       ?=\n export RELEASE   ?=\n export ARCH      ?= x64\n+export LOG       ?=\n export KEXTS     ?= $(patsubst exts/%/Cargo.toml,%,$(wildcard exts/*/Cargo.toml))\n \n # The default build target.\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -111,12 +112,13 @@ iso: build\n \n .PHONY: run\n run: build\n-\t$(PYTHON3) tools/run-qemu.py              \\\n-\t\t--arch $(ARCH)                    \\\n-\t\t$(if $(GUI),--gui,)               \\\n-\t\t$(if $(KVM),--kvm,)               \\\n-\t\t$(if $(GDB),--gdb,)               \\\n-\t\t$(if $(QEMU),--qemu $(QEMU),)     \\\n+\t$(PYTHON3) tools/run-qemu.py                               \\\n+\t\t--arch $(ARCH)                                     \\\n+\t\t$(if $(GUI),--gui,)                                \\\n+\t\t$(if $(KVM),--kvm,)                                \\\n+\t\t$(if $(GDB),--gdb,)                                \\\n+\t\t$(if $(LOG),--append-cmdline \"log=$(LOG)\",)        \\\n+\t\t$(if $(QEMU),--qemu $(QEMU),)                      \\\n \t\t$(kernel_elf)\n \n .PHONY: bochs\ndiff --git /dev/null b/libs/log_filter/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/libs/log_filter/Cargo.toml\n@@ -0,0 +1,14 @@\n+[package]\n+name = \"log_filter\"\n+version = \"0.0.1\"\n+authors = [\"The Kerla Authors\"]\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[lib]\n+name = \"log_filter\"\n+path = \"lib.rs\"\n+\n+[dependencies]\n+log = \"0\"\ndiff --git a/runtime/Cargo.toml b/runtime/Cargo.toml\n--- a/runtime/Cargo.toml\n+++ b/runtime/Cargo.toml\n@@ -23,3 +23,4 @@ x86 = \"0.43.0\"\n vte = \"0.10\"\n \n kerla_utils = { path = \"../libs/kerla_utils\", features = [\"no_std\"] }\n+log_filter = { path = \"../libs/log_filter\" }\ndiff --git a/runtime/bootinfo.rs b/runtime/bootinfo.rs\n--- a/runtime/bootinfo.rs\n+++ b/runtime/bootinfo.rs\n@@ -1,4 +1,4 @@\n-use arrayvec::ArrayVec;\n+use arrayvec::{ArrayString, ArrayVec};\n \n use crate::address::PAddr;\n \ndiff --git a/runtime/bootinfo.rs b/runtime/bootinfo.rs\n--- a/runtime/bootinfo.rs\n+++ b/runtime/bootinfo.rs\n@@ -15,5 +15,6 @@ pub struct VirtioMmioDevice {\n pub struct BootInfo {\n     pub ram_areas: ArrayVec<RamArea, 8>,\n     pub virtio_mmio_devices: ArrayVec<VirtioMmioDevice, 4>,\n+    pub log_filter: ArrayString<64>,\n     pub pci_enabled: bool,\n }\ndiff --git a/runtime/logger.rs b/runtime/logger.rs\n--- a/runtime/logger.rs\n+++ b/runtime/logger.rs\n@@ -1,12 +1,13 @@\n-struct Logger;\n+use atomic_refcell::AtomicRefCell;\n+use log_filter::LogFilter;\n+\n+struct Logger {\n+    filter: AtomicRefCell<LogFilter>,\n+}\n \n impl log::Log for Logger {\n-    fn enabled(&self, metadata: &log::Metadata) -> bool {\n-        if cfg!(debug_assertions) {\n-            true\n-        } else {\n-            metadata.level() <= log::Level::Info\n-        }\n+    fn enabled(&self, _metadata: &log::Metadata) -> bool {\n+        true\n     }\n \n     fn log(&self, record: &log::Record) {\ndiff --git a/runtime/logger.rs b/runtime/logger.rs\n--- a/runtime/logger.rs\n+++ b/runtime/logger.rs\n@@ -16,20 +17,22 @@ impl log::Log for Logger {\n         const WARN_COLOR: &str = \"\\x1b[33m\";\n         const ERROR_COLOR: &str = \"\\x1b[1;31m\";\n \n-        if self.enabled(record.metadata()) {\n-            match record.level() {\n-                Level::Trace | Level::Debug => {\n-                    println!(\"{}\", record.args());\n-                }\n-                Level::Info => {\n-                    println!(\"{}{}{}\", INFO_COLOR, record.args(), RESET);\n-                }\n-                Level::Warn => {\n-                    println!(\"{}{}{}\", WARN_COLOR, record.args(), RESET);\n-                }\n-                Level::Error => {\n-                    println!(\"{}{}{}\", ERROR_COLOR, record.args(), RESET);\n-                }\n+        if !self.filter.borrow().should_print(record) {\n+            return;\n+        }\n+\n+        match record.level() {\n+            Level::Trace | Level::Debug => {\n+                println!(\"{}\", record.args());\n+            }\n+            Level::Info => {\n+                println!(\"{}{}{}\", INFO_COLOR, record.args(), RESET);\n+            }\n+            Level::Warn => {\n+                println!(\"{}{}{}\", WARN_COLOR, record.args(), RESET);\n+            }\n+            Level::Error => {\n+                println!(\"{}{}{}\", ERROR_COLOR, record.args(), RESET);\n             }\n         }\n     }\ndiff --git a/runtime/logger.rs b/runtime/logger.rs\n--- a/runtime/logger.rs\n+++ b/runtime/logger.rs\n@@ -37,7 +40,14 @@ impl log::Log for Logger {\n     fn flush(&self) {}\n }\n \n-static LOGGER: Logger = Logger;\n+static LOGGER: Logger = Logger {\n+    filter: AtomicRefCell::new(LogFilter::empty()),\n+};\n+\n+pub fn set_log_filter(pattern: &str) {\n+    let new_filter = LogFilter::new(pattern);\n+    *LOGGER.filter.borrow_mut() = new_filter;\n+}\n \n pub(crate) fn init() {\n     log::set_logger(&LOGGER).unwrap();\ndiff --git a/runtime/print.rs b/runtime/print.rs\n--- a/runtime/print.rs\n+++ b/runtime/print.rs\n@@ -111,41 +111,3 @@ macro_rules! warn_if_err {\n         }\n     };\n }\n-\n-pub struct PrintkPrinter;\n-impl log::Log for PrintkPrinter {\n-    fn enabled(&self, metadata: &log::Metadata) -> bool {\n-        if cfg!(debug_assertions) {\n-            true\n-        } else {\n-            metadata.level() <= log::Level::Info\n-        }\n-    }\n-\n-    fn log(&self, record: &log::Record) {\n-        use log::Level;\n-        const RESET: &str = \"\\x1b[0m\";\n-        const INFO_COLOR: &str = \"\\x1b[36m\";\n-        const WARN_COLOR: &str = \"\\x1b[33m\";\n-        const ERROR_COLOR: &str = \"\\x1b[1;31m\";\n-\n-        if self.enabled(record.metadata()) {\n-            match record.level() {\n-                Level::Trace | Level::Debug => {\n-                    println!(\"{}\", record.args());\n-                }\n-                Level::Info => {\n-                    println!(\"{}{}{}\", INFO_COLOR, record.args(), RESET);\n-                }\n-                Level::Warn => {\n-                    println!(\"{}{}{}\", WARN_COLOR, record.args(), RESET);\n-                }\n-                Level::Error => {\n-                    println!(\"{}{}{}\", ERROR_COLOR, record.args(), RESET);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn flush(&self) {}\n-}\ndiff --git a/runtime/x64/boot.rs b/runtime/x64/boot.rs\n--- a/runtime/x64/boot.rs\n+++ b/runtime/x64/boot.rs\n@@ -82,6 +82,8 @@ unsafe extern \"C\" fn bsp_early_init(boot_magic: u32, boot_params: u64) -> ! {\n     let boot_info = bootinfo::parse(boot_magic, PAddr::new(boot_params as usize));\n     page_allocator::init(&boot_info.ram_areas);\n \n+    logger::set_log_filter(&boot_info.log_filter);\n+\n     serial::init();\n     init_pic();\n     common_setup(VAddr::new(&__bsp_cpu_local as *const _ as usize));\ndiff --git a/runtime/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/runtime/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -1,8 +1,9 @@\n use crate::address::{PAddr, VAddr};\n use crate::bootinfo::{BootInfo, RamArea, VirtioMmioDevice};\n-use arrayvec::ArrayVec;\n+use arrayvec::{ArrayString, ArrayVec};\n use core::cmp::max;\n use core::mem::size_of;\n+use core::slice;\n use kerla_utils::alignment::align_up;\n use kerla_utils::byte_size::ByteSize;\n \ndiff --git a/runtime/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/runtime/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -126,6 +127,7 @@ extern \"C\" {\n struct Cmdline {\n     pub pci_enabled: bool,\n     pub virtio_mmio_devices: ArrayVec<VirtioMmioDevice, 4>,\n+    pub log_filter: ArrayString<64>,\n }\n \n impl Cmdline {\ndiff --git a/runtime/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/runtime/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -135,6 +137,7 @@ impl Cmdline {\n \n         let mut pci_enabled = true;\n         let mut virtio_mmio_devices = ArrayVec::new();\n+        let mut log_filter = ArrayString::new();\n         if !s.is_empty() {\n             for config in s.split(' ') {\n                 let mut words = config.splitn(2, '=');\ndiff --git a/runtime/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/runtime/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -143,6 +146,11 @@ impl Cmdline {\n                         warn!(\"bootinfo: PCI disabled\");\n                         pci_enabled = false;\n                     }\n+                    (Some(\"log\"), Some(value)) => {\n+                        if log_filter.try_push_str(value).is_err() {\n+                            warn!(\"bootinfo: log filter is too long\");\n+                        }\n+                    }\n                     (Some(\"virtio_mmio.device\"), Some(value)) => {\n                         let mut size_and_rest = value.splitn(2, \"@0x\");\n                         let _size = size_and_rest.next().unwrap();\ndiff --git a/runtime/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/runtime/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -161,6 +169,9 @@ impl Cmdline {\n                             irq,\n                         })\n                     }\n+                    (Some(path), None) if path.starts_with('/') => {\n+                        // QEMU appends a kernel image path. Just ignore it.\n+                    }\n                     _ => {\n                         warn!(\"cmdline: unsupported option, ignoring: '{}'\", config);\n                     }\ndiff --git a/runtime/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/runtime/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -171,6 +182,7 @@ impl Cmdline {\n         Cmdline {\n             pci_enabled,\n             virtio_mmio_devices,\n+            log_filter,\n         }\n     }\n }\ndiff --git a/runtime/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/runtime/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -215,26 +227,47 @@ unsafe fn parse_multiboot2_info(header: &Multiboot2InfoHeader) -> BootInfo {\n     let header_vaddr = VAddr::new(header as *const _ as usize);\n     let mut off = size_of::<Multiboot2TagHeader>();\n     let mut ram_areas = ArrayVec::new();\n+    let mut cmdline = None;\n     while off + size_of::<Multiboot2TagHeader>() < header.total_size as usize {\n         let tag_vaddr = header_vaddr.add(off);\n         let tag = &*tag_vaddr.as_ptr::<Multiboot2TagHeader>();\n-        if tag.tag_type == 6 {\n-            // Memory map.\n-            let tag = &*(tag as *const Multiboot2TagHeader as *const Multiboot2MemoryMapTag);\n-            let mut entry_off = size_of::<Multiboot2MemoryMapTag>();\n-            while entry_off < tag.tag_size as usize {\n-                let entry = &*tag_vaddr\n-                    .add(entry_off)\n-                    .as_ptr::<Multiboot2MemoryMapEntry>();\n-\n-                process_memory_map_entry(\n-                    &mut ram_areas,\n-                    entry.entry_type,\n-                    entry.base as usize,\n-                    entry.len as usize,\n+        match tag.tag_type {\n+            1 => {\n+                // Command line.\n+                let cstr = tag_vaddr\n+                    .add(size_of::<Multiboot2TagHeader>())\n+                    .as_ptr::<u8>();\n+                let mut len = 0;\n+                while cstr.add(len).read() != 0 {\n+                    len += 1;\n+                }\n+\n+                cmdline = Some(\n+                    core::str::from_utf8(slice::from_raw_parts(cstr, len))\n+                        .expect(\"cmdline is not a utf-8 string\"),\n                 );\n+            }\n+            6 => {\n+                // Memory map.\n+                let tag = &*(tag as *const Multiboot2TagHeader as *const Multiboot2MemoryMapTag);\n+                let mut entry_off = size_of::<Multiboot2MemoryMapTag>();\n+                while entry_off < tag.tag_size as usize {\n+                    let entry = &*tag_vaddr\n+                        .add(entry_off)\n+                        .as_ptr::<Multiboot2MemoryMapEntry>();\n+\n+                    process_memory_map_entry(\n+                        &mut ram_areas,\n+                        entry.entry_type,\n+                        entry.base as usize,\n+                        entry.len as usize,\n+                    );\n \n-                entry_off += tag.entry_size as usize;\n+                    entry_off += tag.entry_size as usize;\n+                }\n+            }\n+            _ => {\n+                // Unsupported tag. Ignored .\n             }\n         }\n \ndiff --git a/runtime/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/runtime/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -242,11 +275,12 @@ unsafe fn parse_multiboot2_info(header: &Multiboot2InfoHeader) -> BootInfo {\n     }\n \n     assert!(!ram_areas.is_empty());\n-    let cmdline = Cmdline::parse(b\"\" /* TODO: */);\n+    let cmdline = Cmdline::parse(cmdline.unwrap_or(\"\").as_bytes());\n     BootInfo {\n         ram_areas,\n         pci_enabled: cmdline.pci_enabled,\n         virtio_mmio_devices: cmdline.virtio_mmio_devices,\n+        log_filter: cmdline.log_filter,\n     }\n }\n \ndiff --git a/runtime/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/runtime/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -265,11 +299,28 @@ unsafe fn parse_multiboot_legacy_info(info: &MultibootLegacyInfo) -> BootInfo {\n         off += entry.entry_size + size_of::<u32>() as u32;\n     }\n \n-    let cmdline = Cmdline::parse(b\"\" /* TODO: */);\n+    let mut cmdline = None;\n+    if info.cmdline != 0 {\n+        // Command line.\n+        let cstr = PAddr::new(info.cmdline as usize).as_ptr::<u8>();\n+        let mut len = 0;\n+        while cstr.add(len).read() != 0 {\n+            len += 1;\n+        }\n+\n+        cmdline = Some(\n+            core::str::from_utf8(slice::from_raw_parts(cstr, len))\n+                .expect(\"cmdline is not a utf-8 string\"),\n+        );\n+        trace!(\"cmdline={:?}\", cmdline);\n+    }\n+\n+    let cmdline = Cmdline::parse(cmdline.unwrap_or(\"\").as_bytes());\n     BootInfo {\n         ram_areas,\n         pci_enabled: cmdline.pci_enabled,\n         virtio_mmio_devices: cmdline.virtio_mmio_devices,\n+        log_filter: cmdline.log_filter,\n     }\n }\n \ndiff --git a/runtime/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/runtime/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -299,6 +350,7 @@ unsafe fn parse_linux_boot_params(boot_params: PAddr) -> BootInfo {\n         ram_areas,\n         pci_enabled: cmdline.pci_enabled,\n         virtio_mmio_devices: cmdline.virtio_mmio_devices,\n+        log_filter: cmdline.log_filter,\n     }\n }\n \ndiff --git a/tools/run-qemu.py b/tools/run-qemu.py\n--- a/tools/run-qemu.py\n+++ b/tools/run-qemu.py\n@@ -34,6 +34,7 @@ def main():\n     parser.add_argument(\"--gui\", action=\"store_true\")\n     parser.add_argument(\"--gdb\", action=\"store_true\")\n     parser.add_argument(\"--kvm\", action=\"store_true\")\n+    parser.add_argument(\"--append-cmdline\", action=\"append\")\n     parser.add_argument(\"--qemu\")\n     parser.add_argument(\"kernel_elf\", help=\"The kernel ELF executable.\")\n     args = parser.parse_args()\ndiff --git a/tools/run-qemu.py b/tools/run-qemu.py\n--- a/tools/run-qemu.py\n+++ b/tools/run-qemu.py\n@@ -66,6 +67,8 @@ def main():\n         argv += [\"-gdb\", \"tcp::7789\", \"-S\"]\n     if args.kvm:\n         argv += [\"-accel\", \"kvm\"]\n+    if args.append_cmdline is not None:\n+        argv += [\"-append\", \" \".join(args.append_cmdline)]\n \n     p = subprocess.run(argv, preexec_fn=os.setsid)\n     if p.returncode != 33:\n",
        "test_patch": "diff --git /dev/null b/libs/log_filter/lib.rs\nnew file mode 100644\n--- /dev/null\n+++ b/libs/log_filter/lib.rs\n@@ -0,0 +1,154 @@\n+#![cfg_attr(not(test), no_std)]\n+\n+extern crate alloc;\n+\n+use alloc::{\n+    string::{String, ToString},\n+    vec::Vec,\n+};\n+use log::{warn, Level, Record};\n+\n+static DEFAULT_LOG_LEVEL: Level = Level::Info;\n+\n+pub struct LogFilter {\n+    patterns: Vec<Pattern>,\n+}\n+\n+struct Pattern {\n+    level: Level,\n+    module_prefix: String,\n+}\n+\n+impl LogFilter {\n+    /// Constructs a log filter with an empty rule. It accepts all logs.\n+    pub const fn empty() -> LogFilter {\n+        LogFilter {\n+            patterns: Vec::new(),\n+        }\n+    }\n+\n+    pub fn new(pattern: &str) -> LogFilter {\n+        let mut filter = LogFilter::empty();\n+        filter.overwrite_filter(pattern);\n+        filter\n+    }\n+\n+    pub fn overwrite_filter(&mut self, pattern: &str) {\n+        self.patterns.clear();\n+        if pattern.is_empty() {\n+            return;\n+        }\n+\n+        for p in pattern.split(',') {\n+            let mut parts = p.split('=');\n+            let (prefix_str, level_str) = match (parts.next(), parts.next()) {\n+                // \"foo=warn\"\n+                (Some(prefix), Some(level)) => (prefix, level),\n+                // \"warn\" (default log level)\n+                (\n+                    Some(level @ \"error\")\n+                    | Some(level @ \"warn\")\n+                    | Some(level @ \"info\")\n+                    | Some(level @ \"debug\")\n+                    | Some(level @ \"trace\"),\n+                    None,\n+                ) => (\"\", level),\n+                // \"foo\" (enable all logs from \"foo\")\n+                (Some(prefix), None) => (prefix, \"trace\"),\n+                (_, _) => unreachable!(),\n+            };\n+\n+            let prefix = prefix_str.strip_prefix(\"kerla_\").unwrap_or(prefix_str);\n+            let level = match level_str {\n+                \"error\" => Level::Error,\n+                \"warn\" => Level::Warn,\n+                \"info\" => Level::Info,\n+                \"debug\" => Level::Debug,\n+                \"trace\" => Level::Trace,\n+                _ => {\n+                    warn!(\n+                        \"invalid log level: \\\"{}\\\", setting\n+                    \\\"info\\\" level\",\n+                        level_str\n+                    );\n+                    Level::Info\n+                }\n+            };\n+\n+            self.patterns.push(Pattern {\n+                level,\n+                module_prefix: prefix.to_string(),\n+            });\n+        }\n+    }\n+\n+    pub fn should_print(&self, record: &Record) -> bool {\n+        let mut longest_match = 0;\n+        let mut log_level = DEFAULT_LOG_LEVEL;\n+        if let Some(module_path) = record.module_path() {\n+            let module_path = module_path.strip_prefix(\"kerla_\").unwrap_or(module_path);\n+            for pat in &self.patterns {\n+                if pat.module_prefix.len() >= longest_match\n+                    && module_path.starts_with(&pat.module_prefix)\n+                {\n+                    longest_match = pat.module_prefix.len();\n+                    log_level = pat.level;\n+                }\n+            }\n+        }\n+\n+        record.metadata().level() <= log_level\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use log::RecordBuilder;\n+\n+    use super::*;\n+\n+    fn build_record(module: &str, level: Level) -> Record {\n+        RecordBuilder::new()\n+            .module_path(Some(module))\n+            .level(level)\n+            .build()\n+    }\n+\n+    fn run(pattern: &str, module: &str, level: Level) -> bool {\n+        LogFilter::new(pattern).should_print(&build_record(module, level))\n+    }\n+\n+    #[test]\n+    fn test_default_level() {\n+        assert_eq!(run(\"\", \"foo\", Level::Error), true);\n+        assert_eq!(run(\"\", \"foo\", Level::Warn), true);\n+        assert_eq!(run(\"\", \"foo\", Level::Info), true);\n+        assert_eq!(run(\"\", \"foo\", Level::Trace), false);\n+    }\n+\n+    #[test]\n+    fn test_simple_pattern() {\n+        assert_eq!(run(\"foo=warn\", \"foo\", Level::Warn), true);\n+        assert_eq!(run(\"foo=warn\", \"foo\", Level::Info), false);\n+        assert_eq!(run(\"foo=warn\", \"foo\", Level::Debug), false);\n+    }\n+\n+    #[test]\n+    fn test_multiple_patterns() {\n+        assert_eq!(run(\"foo=warn,bar=trace\", \"foo\", Level::Warn), true);\n+        assert_eq!(run(\"foo=warn,bar=trace\", \"foo\", Level::Info), false);\n+        assert_eq!(run(\"foo=warn,bar=trace\", \"foo\", Level::Debug), false);\n+        assert_eq!(run(\"foo=warn,bar=trace\", \"bar\", Level::Warn), true);\n+        assert_eq!(run(\"foo=warn,bar=trace\", \"bar\", Level::Info), true);\n+        assert_eq!(run(\"foo=warn,bar=trace\", \"bar\", Level::Debug), true);\n+    }\n+\n+    #[test]\n+    fn test_changing_default_level() {\n+        assert_eq!(run(\"foo\", \"foo\", Level::Trace), true);\n+        assert_eq!(run(\"foo\", \"bar\", Level::Trace), false);\n+\n+        assert_eq!(run(\"warn\", \"foo\", Level::Warn), true);\n+        assert_eq!(run(\"warn\", \"foo\", Level::Info), false);\n+    }\n+}\n",
        "problem_statement": "Make log messages less verbose\nThe debug build prints too much log messages. Implement something like `$RUST_LOG` to control log levels.\n",
        "hints_text": "",
        "created_at": "2021-11-13T08:47:14Z"
    },
    {
        "repo": "nuta/kerla",
        "pull_number": 97,
        "instance_id": "nuta__kerla-97",
        "issue_numbers": [
            "96"
        ],
        "base_commit": "b6e0a3e3705edeb64b32ddacf67f43ebc9b8d6e9",
        "patch": "diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml\n--- a/.github/workflows/ci.yml\n+++ b/.github/workflows/ci.yml\n@@ -44,6 +44,9 @@ jobs:\n       - name: Install cargo crates\n         run: cargo install cargo-binutils rustfilt\n \n+      - name: make check\n+        run: make check\n+\n       - name: Build Kerla\n         run: make ${{ matrix.build_options }}\n \ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -166,21 +166,13 @@ dependencies = [\n  \"goblin\",\n  \"hashbrown\",\n  \"kerla_api\",\n- \"kerla_kexts_loader\",\n  \"kerla_runtime\",\n  \"kerla_utils\",\n  \"log\",\n  \"smoltcp\",\n  \"spin 0.9.2\",\n- \"x86\",\n-]\n-\n-[[package]]\n-name = \"kerla_kexts_loader\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"log\",\n  \"virtio_net\",\n+ \"x86\",\n ]\n \n [[package]]\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -4,7 +4,6 @@ members = [\n     \"kernel\",\n     \"libs/*\",\n     \"exts/*\",\n-    \"build/kexts_loader\",\n ]\n \n [profile.release]\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -6,7 +6,6 @@ export ARCH       ?= x64\n export LOG        ?=\n export LOG_SERIAL ?=\n export QEMU_ARGS  ?=\n-export KEXTS      ?= $(patsubst exts/%/Cargo.toml,%,$(wildcard exts/*/Cargo.toml))\n \n # The default build target.\n .PHONY: default\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -91,9 +90,6 @@ build:\n build-crate:\n \t$(MAKE) initramfs\n \n-\t$(PROGRESS) \"GEN\" \"kexts-loader ($(KEXTS))\"\n-\t$(PYTHON3) tools/generate-kexts-loader.py --out-dir build/kexts_loader $(KEXTS)\n-\n \t$(PROGRESS) \"CARGO\" \"kernel\"\n \t$(CARGO) build $(CARGOFLAGS) --manifest-path kernel/Cargo.toml\n \ndiff --git a/kernel/Cargo.toml b/kernel/Cargo.toml\n--- a/kernel/Cargo.toml\n+++ b/kernel/Cargo.toml\n@@ -29,5 +29,5 @@ kerla_runtime = { path = \"../runtime\" }\n kerla_api = { path = \"../libs/kerla_api\" }\n kerla_utils = { path = \"../libs/kerla_utils\", features = [\"no_std\"] }\n \n-# Automatically generated dependencies.\n-kerla_kexts_loader = { path = \"../build/kexts_loader\" }\n+# Kernel Extensions.\n+virtio_net = { path = \"../exts/virtio_net\" }\ndiff --git a/kernel/fs/initramfs.rs b/kernel/fs/initramfs.rs\n--- a/kernel/fs/initramfs.rs\n+++ b/kernel/fs/initramfs.rs\n@@ -320,6 +320,10 @@ impl FileSystem for InitramFs {\n pub fn init() {\n     INITRAM_FS.init(|| {\n         let image = include_bytes!(concat!(\"../../\", env!(\"INITRAMFS_PATH\")));\n+        if image.is_empty() {\n+            panic!(\"initramfs is not embedded\");\n+        }\n+\n         Arc::new(InitramFs::new(image))\n     });\n }\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -177,8 +177,9 @@ pub fn boot_kernel(#[cfg_attr(debug_assertions, allow(unused))] bootinfo: &BootI\n     profiler.lap_time(\"kerla_api init\");\n \n     // Load kernel extensions.\n-    kerla_kexts_loader::load_all();\n-    profiler.lap_time(\"kernel extensions init\");\n+    info!(\"kext: Loading virtio_net...\");\n+    virtio_net::init();\n+    profiler.lap_time(\"virtio_net init\");\n \n     // Initialize device drivers.\n     kerla_api::kernel_ops::init_drivers(bootinfo.pci_enabled, &bootinfo.virtio_mmio_devices);\ndiff --git a/tools/generate-kexts-loader.py /dev/null\n--- a/tools/generate-kexts-loader.py\n+++ /dev/null\n@@ -1,45 +0,0 @@\n-#!/usr/bin/env python3\n-import argparse\n-import os\n-from pathlib import Path\n-\n-def main():\n-    parser = argparse.ArgumentParser()\n-    parser.add_argument(\"--out-dir\", help=\"The output directory.\")\n-    parser.add_argument(\"kexts\", nargs=\"+\", help=\"The list of kernel extensions (see kexts/*).\")\n-    args = parser.parse_args()\n-\n-    os.makedirs(args.out_dir, exist_ok=True)\n-    cargo_toml = \"\"\"\\\n-[package]\n-name = \"kerla_kexts_loader\"\n-description = \"Kerla kernel extensions loader. Automatically generated.\"\n-version = \"0.0.0\"\n-edition = \"2021\"\n-\n-[lib]\n-name = \"kerla_kexts_loader\"\n-path = \"lib.rs\"\n-\n-[dependencies]\n-log = \"0\"\n-\"\"\"\n-    lib_rs = \"\"\"\\\n-#![no_std]\n-\n-pub fn load_all() {\n-\"\"\"\n-    for kext in args.kexts:\n-        cargo_toml += f\"{kext} = {{ path = \\\"{os.getcwd()}/exts/{kext}\\\" }}\\n\"\n-        lib_rs += f\"    log::info!(\\\"kext: loading {kext}\\\");\\n\"\n-        lib_rs += f\"    ::{kext}::init();\\n\"\n-\n-    lib_rs += \"\"\"\n-}\n-\"\"\"\n-\n-    (Path(args.out_dir) / \"Cargo.toml\").write_text(cargo_toml)\n-    (Path(args.out_dir) / \"lib.rs\").write_text(lib_rs)\n-\n-if __name__ == \"__main__\":\n-    main()\n",
        "test_patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -139,6 +135,8 @@ testw:\n \n .PHONY: check\n check:\n+\tmkdir -p $(dir $(INITRAMFS_PATH))\n+\ttouch $(INITRAMFS_PATH)\n \t$(CARGO) check $(CARGOFLAGS)\n \n .PHONY: checkw\n",
        "problem_statement": "Make dependencies broken\nThe 70d4c1c3a1b248534d7e7264f440f7ef307415ba for #85 introduced problems with Make targets where generation of extensions loader isn't dependencies for all targets invoking `cargo`, where root crate refers to the generated dependency.\r\n\r\nSymptom:\r\n```\r\nerror: failed to load manifest for workspace member `/home/manveru/projects/kerla/kernel`\r\n\r\nCaused by:\r\n  failed to load manifest for dependency `kerla_kexts_loader`\r\n\r\nCaused by:\r\n  failed to read `/home/manveru/projects/kerla/build/kexts_loader/Cargo.toml`\r\n\r\nCaused by:\r\n  No such file or directory (os error 2)\r\nmake: *** [Makefile:142: check] Error 101\r\n```\n",
        "hints_text": "",
        "created_at": "2021-11-18T11:14:18Z"
    },
    {
        "repo": "nuta/kerla",
        "pull_number": 77,
        "instance_id": "nuta__kerla-77",
        "issue_numbers": [
            "73"
        ],
        "base_commit": "8f2fce6273d4f8a713344e33bcab42f031c540a6",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -144,22 +144,36 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"kerla\"\n+name = \"kerla_kernel\"\n version = \"0.0.4\"\n dependencies = [\n  \"arrayvec 0.7.2\",\n  \"atomic_refcell\",\n  \"bitflags\",\n- \"buddy_system_allocator\",\n- \"cfg-if\",\n  \"crossbeam\",\n  \"goblin\",\n  \"hashbrown\",\n+ \"kerla_runtime\",\n  \"kerla_utils\",\n  \"log\",\n  \"memoffset\",\n  \"smoltcp\",\n  \"spin 0.9.2\",\n+ \"x86\",\n+]\n+\n+[[package]]\n+name = \"kerla_runtime\"\n+version = \"0.0.4\"\n+dependencies = [\n+ \"arrayvec 0.7.2\",\n+ \"atomic_refcell\",\n+ \"bitflags\",\n+ \"buddy_system_allocator\",\n+ \"cfg-if\",\n+ \"kerla_utils\",\n+ \"log\",\n+ \"spin 0.9.2\",\n  \"vte\",\n  \"x86\",\n ]\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -168,6 +182,7 @@ dependencies = [\n name = \"kerla_utils\"\n version = \"0.0.1\"\n dependencies = [\n+ \"crossbeam\",\n  \"spin 0.9.2\",\n ]\n \ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -1,5 +1,6 @@\n [workspace]\n members = [\n+    \"runtime\",\n     \"kernel\",\n     \"libs/*\",\n ]\ndiff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -62,7 +63,7 @@ export NM\n .PHONY: build\n build:\n \t$(MAKE) build-crate\n-\tcp target/$(ARCH)/$(build_mode)/kerla $(kernel_elf)\n+\tcp target/$(ARCH)/$(build_mode)/kerla_kernel $(kernel_elf)\n \n \t$(PROGRESS) \"NM\" $(kernel_symbols)\n \t$(NM) $(kernel_elf) | rustfilt | awk '{ $$2=\"\"; print $$0 }' > $(kernel_symbols)\ndiff --git a/kernel/Cargo.toml b/kernel/Cargo.toml\n--- a/kernel/Cargo.toml\n+++ b/kernel/Cargo.toml\n@@ -1,26 +1,30 @@\n [package]\n-name = \"kerla\"\n+name = \"kerla_kernel\"\n version = \"0.0.4\"\n authors = [\"Seiya Nuta <nuta@seiya.me>\"]\n edition = \"2018\"\n \n [[bin]]\n-name = \"kerla\"\n+name = \"kerla_kernel\"\n path = \"main.rs\"\n \n [dependencies]\n-kerla_utils = { path = \"../libs/kerla_utils\", features = [\"no_std\"] }\n-spin = \"0.9.2\"\n-x86 = \"0.43.0\"\n memoffset = \"0.6.4\"\n-buddy_system_allocator = \"0.8.0\"\n-arrayvec = { version = \"0.7.2\", default-features = false }\n+log = \"0.4\"\n+spin = \"0.9.2\"\n goblin = { version = \"0.4\", default-features = false, features = [\"elf64\"] }\n+smoltcp = { version = \"0.7.5\", default-features = false, features = [\"alloc\", \"proto-ipv4\", \"socket\", \"socket-raw\", \"socket-udp\", \"socket-tcp\", \"proto-dhcpv4\", \"ethernet\"] }\n+\n+# Data structues.\n bitflags = \"1.3.2\"\n+arrayvec = { version = \"0.7.2\", default-features = false }\n hashbrown = { version = \"0.11.2\", features = [\"nightly\"] }\n-log = \"0.4\"\n crossbeam = { version = \"0.8.1\", default-features = false, features = [\"alloc\"] }\n-smoltcp = { version = \"0.7.5\", default-features = false, features = [\"alloc\", \"proto-ipv4\", \"socket\", \"socket-raw\", \"socket-udp\", \"socket-tcp\", \"proto-dhcpv4\", \"ethernet\"] }\n-cfg-if = \"1\"\n atomic_refcell = \"0.1.6\"\n-vte = \"0.10\"\n+\n+# Arch-specific dependencies.\n+x86 = \"0.43.0\"\n+\n+# Local dependencies.\n+kerla_runtime = { path = \"../runtime\" }\n+kerla_utils = { path = \"../libs/kerla_utils\", features = [\"no_std\"] }\ndiff --git a/kernel/arch/x64/arch_prctl.rs b/kernel/arch/x64/arch_prctl.rs\n--- a/kernel/arch/x64/arch_prctl.rs\n+++ b/kernel/arch/x64/arch_prctl.rs\n@@ -9,7 +9,6 @@ const ARCH_SET_FS: i32 = 0x1002;\n \n pub fn arch_prctl(current: &Arc<Process>, code: i32, uaddr: UserVAddr) -> Result<()> {\n     match code {\n-        // TODO: Move to arch directory.\n         ARCH_SET_FS => {\n             let value = uaddr.value() as u64;\n             current.arch().fsbase.store(value);\ndiff --git a/kernel/arch/x64/process.rs b/kernel/arch/x64/process.rs\n--- a/kernel/arch/x64/process.rs\n+++ b/kernel/arch/x64/process.rs\n@@ -1,19 +1,15 @@\n use core::cell::UnsafeCell;\n \n-use super::{\n-    address::VAddr,\n-    gdt::{USER_CS64, USER_DS},\n-    syscall::SyscallFrame,\n-    tss::TSS,\n-    UserVAddr, KERNEL_STACK_SIZE, PAGE_SIZE,\n-};\n-use super::{cpu_local::cpu_local_head, gdt::USER_RPL};\n use crate::result::Result;\n-use crate::{\n-    mm::page_allocator::{alloc_pages, AllocPageFlags},\n-    process::signal::Signal,\n-};\n+use crate::{arch::KERNEL_STACK_SIZE, process::signal::Signal};\n use crossbeam::atomic::AtomicCell;\n+use kerla_runtime::address::{UserVAddr, VAddr};\n+use kerla_runtime::{\n+    arch::x64_specific::{cpu_local_head, TSS, USER_CS64, USER_DS, USER_RPL},\n+    arch::SyscallFrame,\n+    arch::PAGE_SIZE,\n+    page_allocator::{alloc_pages, AllocPageFlags},\n+};\n use x86::current::segmentation::wrfsbase;\n \n #[repr(C, packed)]\ndiff --git a/kernel/arch/x64/trap.S b/kernel/arch/x64/usermode.S\n--- a/kernel/arch/x64/trap.S\n+++ b/kernel/arch/x64/usermode.S\n@@ -1,6 +1,6 @@\n-.set INTERRUPT_HANDLER_SIZE, 16\n-.set GS_RSP0,                0\n-.set GS_RSP3,                8\n+// Offsets in CpuLocalHead.\n+.set GS_RSP0, 0\n+.set GS_RSP3, 8\n \n .global syscall_entry\n syscall_entry:\ndiff --git a/kernel/build.rs /dev/null\n--- a/kernel/build.rs\n+++ /dev/null\n@@ -1,12 +0,0 @@\n-fn main() {\n-    env!(\"CARGO_FROM_MAKE\"); // Abort if cargo is called directly -- Use make(1) instead!\n-\n-    println!(\n-        \"cargo:rerun-if-changed=arch/{arch}/{arch}.ld\",\n-        arch = env!(\"ARCH\")\n-    );\n-    println!(\n-        \"cargo:rerun-if-changed=arch/{arch}/{arch}.json\",\n-        arch = env!(\"ARCH\")\n-    );\n-}\ndiff --git a/kernel/drivers/driver.rs b/kernel/drivers/driver.rs\n--- a/kernel/drivers/driver.rs\n+++ b/kernel/drivers/driver.rs\n@@ -1,5 +1,6 @@\n use super::pci::PciDevice;\n-use crate::{boot::VirtioMmioDevice, result::Result};\n+use crate::result::Result;\n+use kerla_runtime::bootinfo::VirtioMmioDevice;\n \n #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n pub struct MacAddress([u8; 6]);\ndiff --git a/kernel/drivers/mod.rs b/kernel/drivers/mod.rs\n--- a/kernel/drivers/mod.rs\n+++ b/kernel/drivers/mod.rs\n@@ -1,4 +1,3 @@\n-use crate::arch::SpinLock;\n use alloc::sync::Arc;\n use alloc::vec::Vec;\n \ndiff --git a/kernel/drivers/mod.rs b/kernel/drivers/mod.rs\n--- a/kernel/drivers/mod.rs\n+++ b/kernel/drivers/mod.rs\n@@ -10,6 +9,7 @@ pub mod virtio;\n pub use driver::*;\n \n use alloc::boxed::Box;\n+use kerla_runtime::spinlock::SpinLock;\n \n use self::virtio::virtio_net::VirtioNetBuilder;\n \ndiff --git a/kernel/drivers/pci.rs b/kernel/drivers/pci.rs\n--- a/kernel/drivers/pci.rs\n+++ b/kernel/drivers/pci.rs\n@@ -1,9 +1,9 @@\n-use crate::arch::PAddr;\n use crate::drivers::DRIVER_BUILDERS;\n use crate::prelude::*;\n use arrayvec::ArrayVec;\n use core::convert::TryInto;\n use core::{mem::size_of, mem::MaybeUninit};\n+use kerla_runtime::address::PAddr;\n use kerla_utils::alignment::is_aligned;\n use x86::io::{inl, outl};\n \ndiff --git a/kernel/drivers/virtio/mod.rs b/kernel/drivers/virtio/mod.rs\n--- a/kernel/drivers/virtio/mod.rs\n+++ b/kernel/drivers/virtio/mod.rs\n@@ -1,4 +1,4 @@\n-use crate::boot::VirtioMmioDevice;\n+use kerla_runtime::bootinfo::VirtioMmioDevice;\n \n use super::DRIVER_BUILDERS;\n \ndiff --git a/kernel/drivers/virtio/transports/mod.rs b/kernel/drivers/virtio/transports/mod.rs\n--- a/kernel/drivers/virtio/transports/mod.rs\n+++ b/kernel/drivers/virtio/transports/mod.rs\n@@ -1,4 +1,6 @@\n-use crate::{arch::PAddr, drivers::virtio::virtio::IsrStatus};\n+use kerla_runtime::address::PAddr;\n+\n+use crate::drivers::virtio::virtio::IsrStatus;\n \n pub mod virtio_mmio;\n pub mod virtio_pci;\ndiff --git a/kernel/drivers/virtio/transports/virtio_mmio.rs b/kernel/drivers/virtio/transports/virtio_mmio.rs\n--- a/kernel/drivers/virtio/transports/virtio_mmio.rs\n+++ b/kernel/drivers/virtio/transports/virtio_mmio.rs\n@@ -1,4 +1,4 @@\n-use crate::arch::{PAddr, VAddr};\n+use kerla_runtime::address::{PAddr, VAddr};\n \n use super::VirtioTransport;\n use crate::drivers::virtio::virtio::IsrStatus;\ndiff --git a/kernel/drivers/virtio/transports/virtio_pci.rs b/kernel/drivers/virtio/transports/virtio_pci.rs\n--- a/kernel/drivers/virtio/transports/virtio_pci.rs\n+++ b/kernel/drivers/virtio/transports/virtio_pci.rs\n@@ -3,15 +3,11 @@ use core::convert::TryInto;\n use memoffset::offset_of;\n \n use super::VirtioTransport;\n-use crate::{\n-    arch::VAddr,\n-    drivers::{pci::PciCapability, virtio::virtio::IsrStatus},\n-};\n-use crate::{\n-    arch::{PAddr, SpinLock},\n-    drivers::pci::{Bar, PciDevice},\n-};\n+use crate::drivers::pci::{Bar, PciDevice};\n+use crate::drivers::{pci::PciCapability, virtio::virtio::IsrStatus};\n use crate::{drivers::Driver, prelude::*};\n+use kerla_runtime::address::{VAddr,PAddr};\n+use kerla_runtime::spinlock::SpinLock;\n \n const VIRTIO_PCI_CAP_COMMON_CFG: u8 = 1;\n const VIRTIO_PCI_CAP_NOTIFY_CFG: u8 = 2;\ndiff --git a/kernel/drivers/virtio/virtio.rs b/kernel/drivers/virtio/virtio.rs\n--- a/kernel/drivers/virtio/virtio.rs\n+++ b/kernel/drivers/virtio/virtio.rs\n@@ -1,15 +1,14 @@\n //! A virtio device driver library.\n use crate::prelude::*;\n use crate::result::{Errno, Result};\n-use crate::{\n-    arch::{PAddr, VAddr, PAGE_SIZE},\n-    mm::page_allocator::{alloc_pages, AllocPageFlags},\n-};\n use bitflags::bitflags;\n use core::cmp::min;\n use core::convert::TryInto;\n use core::mem::size_of;\n use core::sync::atomic::{self, Ordering};\n+use kerla_runtime::address::{PAddr, VAddr};\n+use kerla_runtime::arch::PAGE_SIZE;\n+use kerla_runtime::page_allocator::{alloc_pages, AllocPageFlags};\n use kerla_utils::alignment::align_up;\n \n use super::transports::VirtioTransport;\ndiff --git a/kernel/drivers/virtio/virtio_net.rs b/kernel/drivers/virtio/virtio_net.rs\n--- a/kernel/drivers/virtio/virtio_net.rs\n+++ b/kernel/drivers/virtio/virtio_net.rs\n@@ -2,8 +2,10 @@\n use super::virtio::{IsrStatus, Virtio};\n use crate::net::{process_packets, receive_ethernet_frame};\n use crate::{\n-    arch::{SpinLock, VAddr, PAGE_SIZE},\n-    boot::VirtioMmioDevice,\n+    drivers::register_ethernet_driver,\n+    result::{Errno, Result},\n+};\n+use crate::{\n     drivers::{\n         pci::PciDevice,\n         virtio::{\ndiff --git a/kernel/drivers/virtio/virtio_net.rs b/kernel/drivers/virtio/virtio_net.rs\n--- a/kernel/drivers/virtio/virtio_net.rs\n+++ b/kernel/drivers/virtio/virtio_net.rs\n@@ -13,14 +15,16 @@ use crate::{\n         Driver, DriverBuilder, EthernetDriver, MacAddress,\n     },\n     interrupt::attach_irq,\n-    mm::page_allocator::{alloc_pages, AllocPageFlags},\n-};\n-use crate::{\n-    drivers::register_ethernet_driver,\n-    result::{Errno, Result},\n };\n use alloc::sync::Arc;\n use core::mem::size_of;\n+use kerla_runtime::arch::PAGE_SIZE;\n+use kerla_runtime::spinlock::SpinLock;\n+use kerla_runtime::{\n+    address::VAddr,\n+    bootinfo::VirtioMmioDevice,\n+    page_allocator::{alloc_pages, AllocPageFlags},\n+};\n use kerla_utils::alignment::align_up;\n \n const VIRTIO_NET_F_MAC: u64 = 1 << 5;\ndiff --git a/kernel/fs/devfs/tty.rs b/kernel/fs/devfs/tty.rs\n--- a/kernel/fs/devfs/tty.rs\n+++ b/kernel/fs/devfs/tty.rs\n@@ -2,7 +2,6 @@ use arrayvec::ArrayString;\n use core::fmt;\n \n use crate::{\n-    arch::{print_str, SpinLock, UserVAddr},\n     ctypes::*,\n     fs::{\n         inode::{FileLike, INodeNo},\ndiff --git a/kernel/fs/devfs/tty.rs b/kernel/fs/devfs/tty.rs\n--- a/kernel/fs/devfs/tty.rs\n+++ b/kernel/fs/devfs/tty.rs\n@@ -16,6 +15,7 @@ use crate::{\n     user_buffer::UserBuffer,\n     user_buffer::{UserBufReader, UserBufferMut},\n };\n+use kerla_runtime::{address::UserVAddr, print::print_bytes, spinlock::SpinLock};\n \n pub struct Tty {\n     name: ArrayString<8>,\ndiff --git a/kernel/fs/devfs/tty.rs b/kernel/fs/devfs/tty.rs\n--- a/kernel/fs/devfs/tty.rs\n+++ b/kernel/fs/devfs/tty.rs\n@@ -38,7 +38,7 @@ impl Tty {\n                 match ctrl {\n                     LineControl::Backspace => {\n                         // Remove the previous character by overwriting with a whitespace.\n-                        print_str(b\"\\x08 \\x08\");\n+                        print_bytes(b\"\\x08 \\x08\");\n                     }\n                     LineControl::Echo(ch) => {\n                         self.write(0, [ch].as_slice().into(), &OpenOptions::readwrite())\ndiff --git a/kernel/fs/devfs/tty.rs b/kernel/fs/devfs/tty.rs\n--- a/kernel/fs/devfs/tty.rs\n+++ b/kernel/fs/devfs/tty.rs\n@@ -113,16 +113,16 @@ impl FileLike for Tty {\n     }\n \n     fn write(&self, _offset: usize, buf: UserBuffer<'_>, _options: &OpenOptions) -> Result<usize> {\n-        print_str(b\"\\x1b[1m\");\n+        print_bytes(b\"\\x1b[1m\");\n         let mut tmp = [0; 32];\n         let mut total_len = 0;\n         let mut reader = UserBufReader::from(buf);\n         while reader.remaining_len() > 0 {\n             let copied_len = reader.read_bytes(&mut tmp)?;\n-            print_str(&tmp.as_slice()[..copied_len]);\n+            print_bytes(&tmp.as_slice()[..copied_len]);\n             total_len += copied_len;\n         }\n-        print_str(b\"\\x1b[0m\");\n+        print_bytes(b\"\\x1b[0m\");\n         Ok(total_len)\n     }\n }\ndiff --git a/kernel/fs/opened_file.rs b/kernel/fs/opened_file.rs\n--- a/kernel/fs/opened_file.rs\n+++ b/kernel/fs/opened_file.rs\n@@ -468,3 +468,9 @@ impl OpenedFileTable {\n         Err(Error::new(Errno::ENFILE))\n     }\n }\n+\n+impl Default for OpenedFileTable {\n+    fn default() -> OpenedFileTable {\n+        OpenedFileTable::new()\n+    }\n+}\ndiff --git a/kernel/fs/tmpfs.rs b/kernel/fs/tmpfs.rs\n--- a/kernel/fs/tmpfs.rs\n+++ b/kernel/fs/tmpfs.rs\n@@ -14,12 +14,12 @@ use super::{\n     stat::{FileMode, Stat, S_IFDIR, S_IFREG},\n };\n use crate::{\n-    arch::SpinLock,\n     result::{Errno, Error, Result},\n     user_buffer::UserBuffer,\n     user_buffer::UserBufferMut,\n };\n use hashbrown::HashMap;\n+use kerla_runtime::spinlock::SpinLock;\n use kerla_utils::{downcast::downcast, once::Once};\n \n pub static TMP_FS: Once<Arc<TmpFs>> = Once::new();\ndiff --git a/kernel/interrupt.rs b/kernel/interrupt.rs\n--- a/kernel/interrupt.rs\n+++ b/kernel/interrupt.rs\n@@ -1,8 +1,8 @@\n //! Interrupt handling.\n \n-use crate::arch::{enable_irq, SpinLock};\n use alloc::boxed::Box;\n use core::mem::MaybeUninit;\n+use kerla_runtime::{arch::enable_irq, spinlock::SpinLock};\n use kerla_utils::bitmap::BitMap;\n \n fn empty_irq_handler() {}\ndiff --git a/kernel/lang_items.rs b/kernel/lang_items.rs\n--- a/kernel/lang_items.rs\n+++ b/kernel/lang_items.rs\n@@ -9,12 +14,12 @@ fn panic(info: &core::panic::PanicInfo) -> ! {\n     use core::sync::atomic::Ordering;\n \n     if PANICKED.load(Ordering::SeqCst) {\n-        crate::arch::print_str(b\"double panic!\\n\");\n-        crate::arch::halt();\n+        kerla_runtime::print::print_bytes(b\"double panic!\\n\");\n+        kerla_runtime::arch::halt();\n     }\n \n     PANICKED.store(true, Ordering::SeqCst);\n     error!(\"{}\", info);\n-    crate::printk::backtrace();\n-    crate::arch::halt();\n+    kerla_runtime::backtrace::backtrace();\n+    kerla_runtime::arch::halt();\n }\ndiff --git /dev/null b/kernel/logger.rs\nnew file mode 100644\n--- /dev/null\n+++ b/kernel/logger.rs\n@@ -0,0 +1,74 @@\n+use kerla_runtime::arch::console_write;\n+use kerla_runtime::print::{set_printer, Printer};\n+use kerla_utils::ring_buffer::RingBuffer;\n+\n+use crate::lang_items::PANICKED;\n+use core::sync::atomic::Ordering;\n+\n+pub struct LoggedPrinter;\n+\n+pub const KERNEL_LOG_BUF_SIZE: usize = 8192;\n+// We use spin::Mutex here because SpinLock's debugging features may cause a\n+// problem (capturing a backtrace requires memory allocation).\n+pub static KERNEL_LOG_BUF: spin::Mutex<RingBuffer<u8, KERNEL_LOG_BUF_SIZE>> =\n+    spin::Mutex::new(RingBuffer::new());\n+\n+impl Printer for LoggedPrinter {\n+    fn print_bytes(&self, s: &[u8]) {\n+        console_write(s);\n+\n+        // Don't write into the kernel log buffer as it may call a printk function\n+        // due to an assertion.\n+        if !PANICKED.load(Ordering::SeqCst) {\n+            KERNEL_LOG_BUF.lock().push_slice(s);\n+        }\n+    }\n+}\n+\n+/// Prints a warning message only in the debug build.\n+#[macro_export]\n+macro_rules! debug_warn {\n+    ($fmt:expr) => {\n+        if cfg!(debug_assertions) {\n+            ::kerla_runtime::println!(concat!(\"\\x1b[1;33mWARN: \", $fmt, \"\\x1b[0m\"));\n+        }\n+    };\n+    ($fmt:expr, $($arg:tt)*) => {\n+        if cfg!(debug_assertions) {\n+            ::kerla_runtime::println!(concat!(\"\\x1b[1;33mWARN: \", $fmt, \"\\x1b[0m\"), $($arg)*);\n+        }\n+    };\n+}\n+\n+/// Prints a warning message only once.\n+#[macro_export]\n+macro_rules! warn_once {\n+    ($fmt:expr) => {{\n+        static ONCE: ::spin::Once<()> = ::spin::Once::new();\n+        ONCE.call_once(|| {\n+            ::kerla_runtime::println!(concat!(\"\\x1b[1;33mWARN: \", $fmt, \"\\x1b[0m\"));\n+        });\n+    }};\n+    ($fmt:expr, $($arg:tt)*) => {{\n+        static ONCE: ::spin::Once<()> = ::spin::Once::new();\n+        ONCE.call_once(|| {\n+            ::kerla_runtime::println!(concat!(\"\\x1b[1;33mWARN: \", $fmt, \"\\x1b[0m\"), $($arg)*);\n+        });\n+    }};\n+}\n+\n+/// Prints a warning message if it is `Err`.\n+#[macro_export]\n+macro_rules! warn_if_err {\n+    ($result:expr) => {\n+        if cfg!(debug_assertions) {\n+            if let Err(err) = $result {\n+                $crate::debug_warn!(\"{}:{}: error returned: {:?}\", file!(), line!(), err);\n+            }\n+        }\n+    };\n+}\n+\n+pub fn init() {\n+    set_printer(&LoggedPrinter);\n+}\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -19,14 +18,16 @@ extern crate alloc;\n extern crate log;\n \n #[macro_use]\n-mod printk;\n+extern crate kerla_runtime;\n+\n+#[macro_use]\n+mod logger;\n #[macro_use]\n mod result;\n #[macro_use]\n mod arch;\n #[macro_use]\n mod user_buffer;\n-mod boot;\n mod ctypes;\n mod drivers;\n mod fs;\ndiff --git a/kernel/mm/mod.rs b/kernel/mm/mod.rs\n--- a/kernel/mm/mod.rs\n+++ b/kernel/mm/mod.rs\n@@ -1,4 +1,2 @@\n-pub mod global_allocator;\n-pub mod page_allocator;\n pub mod page_fault;\n pub mod vm;\ndiff --git a/kernel/mm/page_fault.rs b/kernel/mm/page_fault.rs\n--- a/kernel/mm/page_fault.rs\n+++ b/kernel/mm/page_fault.rs\n@@ -1,18 +1,34 @@\n use kerla_utils::alignment::align_down;\n \n-use super::{\n-    page_allocator::{alloc_pages, AllocPageFlags},\n-    vm::VmAreaType,\n-};\n+use super::vm::VmAreaType;\n use crate::{\n-    arch::{PageFaultReason, UserVAddr, PAGE_SIZE},\n     fs::opened_file::OpenOptions,\n-    process::{current_process, signal::SIGSEGV, Process},\n+    process::{\n+        current_process,\n+        signal::{self, SIGSEGV},\n+        Process,\n+    },\n };\n use core::cmp::min;\n use core::slice;\n+use kerla_runtime::{\n+    address::UserVAddr,\n+    arch::{PageFaultReason, PAGE_SIZE},\n+    page_allocator::{alloc_pages, AllocPageFlags},\n+};\n+\n+pub fn handle_page_fault(unaligned_vaddr: Option<UserVAddr>, ip: usize, _reason: PageFaultReason) {\n+    let unaligned_vaddr = match unaligned_vaddr {\n+        Some(unaligned_vaddr) => unaligned_vaddr,\n+        None => {\n+            debug_warn!(\n+                \"null pointer access (ip={:x}), killing the current process...\",\n+                ip\n+            );\n+            Process::exit_by_signal(signal::SIGSEGV);\n+        }\n+    };\n \n-pub fn handle_page_fault(unaligned_vaddr: UserVAddr, ip: usize, _reason: PageFaultReason) {\n     let current = current_process();\n     let aligned_vaddr = match UserVAddr::new_nonnull(align_down(unaligned_vaddr.value(), PAGE_SIZE))\n     {\ndiff --git a/kernel/mm/vm.rs b/kernel/mm/vm.rs\n--- a/kernel/mm/vm.rs\n+++ b/kernel/mm/vm.rs\n@@ -1,13 +1,14 @@\n+use crate::fs::inode::FileLike;\n use crate::{\n-    arch::PageTable, arch::UserVAddr, arch::PAGE_SIZE, arch::USER_VALLOC_BASE,\n-    arch::USER_VALLOC_END, fs::inode::FileLike,\n-};\n-use crate::{\n-    arch::USER_STACK_TOP,\n+    arch::{USER_STACK_TOP, USER_VALLOC_BASE, USER_VALLOC_END},\n     result::{Errno, Result},\n };\n use alloc::sync::Arc;\n use alloc::vec::Vec;\n+use kerla_runtime::{\n+    address::UserVAddr,\n+    arch::{PageTable, PAGE_SIZE},\n+};\n use kerla_utils::alignment::{align_up, is_aligned};\n \n #[derive(Clone)]\ndiff --git a/kernel/net/mod.rs b/kernel/net/mod.rs\n--- a/kernel/net/mod.rs\n+++ b/kernel/net/mod.rs\n@@ -1,5 +1,4 @@\n use crate::{\n-    arch::SpinLock,\n     drivers::{get_ethernet_driver, EthernetDriver},\n     poll::POLL_WAIT_QUEUE,\n     process::WaitQueue,\ndiff --git a/kernel/net/mod.rs b/kernel/net/mod.rs\n--- a/kernel/net/mod.rs\n+++ b/kernel/net/mod.rs\n@@ -10,6 +9,7 @@ use alloc::collections::BTreeMap;\n use alloc::sync::Arc;\n use alloc::vec::Vec;\n use crossbeam::queue::ArrayQueue;\n+use kerla_runtime::spinlock::SpinLock;\n use kerla_utils::once::Once;\n use smoltcp::wire::{self, EthernetAddress, IpCidr};\n use smoltcp::{\ndiff --git a/kernel/net/socket.rs b/kernel/net/socket.rs\n--- a/kernel/net/socket.rs\n+++ b/kernel/net/socket.rs\n@@ -1,7 +1,8 @@\n-use crate::{arch::UserVAddr, result::*};\n+use crate::result::*;\n use bitflags::bitflags;\n use core::convert::TryFrom;\n use core::mem::size_of;\n+use kerla_runtime::address::UserVAddr;\n use smoltcp::wire::{IpAddress, IpEndpoint, Ipv4Address};\n \n bitflags! {\ndiff --git a/kernel/net/tcp_socket.rs b/kernel/net/tcp_socket.rs\n--- a/kernel/net/tcp_socket.rs\n+++ b/kernel/net/tcp_socket.rs\n@@ -1,20 +1,17 @@\n use crate::{\n-    arch::SpinLock,\n     fs::{\n         inode::{FileLike, PollStatus},\n         opened_file::OpenOptions,\n     },\n     net::{socket::SockAddr, RecvFromFlags},\n+    result::{Errno, Result},\n     user_buffer::UserBuffer,\n     user_buffer::{UserBufReader, UserBufWriter, UserBufferMut},\n };\n-use crate::{\n-    arch::SpinLockGuard,\n-    result::{Errno, Result},\n-};\n use alloc::{collections::BTreeSet, sync::Arc, vec::Vec};\n use core::{cmp::min, convert::TryInto, fmt};\n use crossbeam::atomic::AtomicCell;\n+use kerla_runtime::spinlock::{SpinLock, SpinLockGuard};\n use smoltcp::socket::{SocketRef, TcpSocketBuffer};\n use smoltcp::wire::{IpAddress, IpEndpoint, Ipv4Address};\n \ndiff --git a/kernel/net/udp_socket.rs b/kernel/net/udp_socket.rs\n--- a/kernel/net/udp_socket.rs\n+++ b/kernel/net/udp_socket.rs\n@@ -1,5 +1,4 @@\n use crate::{\n-    arch::SpinLock,\n     fs::{\n         inode::{FileLike, PollStatus},\n         opened_file::OpenOptions,\ndiff --git a/kernel/net/udp_socket.rs b/kernel/net/udp_socket.rs\n--- a/kernel/net/udp_socket.rs\n+++ b/kernel/net/udp_socket.rs\n@@ -10,6 +9,7 @@ use crate::{\n };\n use alloc::{collections::BTreeSet, sync::Arc};\n use core::{convert::TryInto, fmt};\n+use kerla_runtime::spinlock::SpinLock;\n use smoltcp::socket::{UdpPacketMetadata, UdpSocketBuffer};\n use smoltcp::wire::IpEndpoint;\n \ndiff --git a/kernel/pipe.rs b/kernel/pipe.rs\n--- a/kernel/pipe.rs\n+++ b/kernel/pipe.rs\n@@ -1,10 +1,10 @@\n //! Unnamed pipe (`pipe(2)`).\n use core::fmt;\n \n+use kerla_runtime::spinlock::SpinLock;\n use kerla_utils::{once::Once, ring_buffer::RingBuffer};\n \n use crate::{\n-    arch::SpinLock,\n     fs::{\n         inode::{FileLike, PollStatus},\n         opened_file::OpenOptions,\ndiff --git a/kernel/printk.rs /dev/null\n--- a/kernel/printk.rs\n+++ /dev/null\n@@ -1,293 +0,0 @@\n-use alloc::boxed::Box;\n-use arrayvec::ArrayVec;\n-use kerla_utils::ring_buffer::RingBuffer;\n-\n-use crate::arch::{print_str, printchar, Backtrace, VAddr};\n-use crate::lang_items::PANICKED;\n-use core::mem::size_of;\n-use core::str;\n-use core::sync::atomic::Ordering;\n-use core::{fmt, slice};\n-pub struct Printer;\n-\n-pub const KERNEL_LOG_BUF_SIZE: usize = 8192;\n-// We use spin::Mutex here because SpinLock's debugging features may cause a\n-// problem (capturing a backtrace requires memory allocation).\n-pub static KERNEL_LOG_BUF: spin::Mutex<RingBuffer<u8, KERNEL_LOG_BUF_SIZE>> =\n-    spin::Mutex::new(RingBuffer::new());\n-\n-impl core::fmt::Write for Printer {\n-    fn write_char(&mut self, c: char) -> core::fmt::Result {\n-        printchar(c);\n-\n-        // Don't write into the kernel log buffer as it may call a printk function\n-        // due to an assertion.\n-        if !PANICKED.load(Ordering::SeqCst) {\n-            KERNEL_LOG_BUF.lock().push(c as u8).ok();\n-        }\n-        Ok(())\n-    }\n-\n-    fn write_str(&mut self, s: &str) -> core::fmt::Result {\n-        print_str(s.as_bytes());\n-\n-        // Don't write into the kernel log buffer as it may call a printk function\n-        // due to an assertion.\n-        if !PANICKED.load(Ordering::SeqCst) {\n-            KERNEL_LOG_BUF.lock().push_slice(s.as_bytes());\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// Prints a string.\n-#[macro_export]\n-macro_rules! print {\n-    ($($arg:tt)*) => {{\n-        #![allow(unused_import)]\n-        use core::fmt::Write;\n-        write!($crate::printk::Printer, \"{}\", format_args!($($arg)*)).ok();\n-    }};\n-}\n-\n-/// Prints a string and a newline.\n-#[macro_export]\n-macro_rules! println {\n-    () => {{\n-        let now = crate::timer::read_monotonic_clock();\n-        $crate::print!(\n-            concat!(\"[{:>4}.{:03}] \"),\n-            now.secs(),\n-            now.msecs() % 1000,\n-        );\n-    }};\n-    ($fmt:expr) => {{\n-        let now = crate::timer::read_monotonic_clock();\n-        $crate::print!(\n-            concat!(\"[{:>4}.{:03}] \", $fmt),\n-            now.secs(),\n-            now.msecs() % 1000,\n-        );\n-    }};\n-    ($fmt:expr, $($arg:tt)*) => {{\n-        let now = crate::timer::read_monotonic_clock();\n-        $crate::print!(\n-            concat!(\"[{:>4}.{:03}] \", $fmt, \"\\n\"),\n-            now.secs(),\n-            now.msecs() % 1000,\n-            $($arg)*\n-        );\n-    }};\n-}\n-\n-/// Prints a warning message only in the debug build.\n-#[macro_export]\n-macro_rules! debug_warn {\n-    ($fmt:expr) => {\n-        #[cfg(debug_assertions)]\n-        $crate::println!(concat!(\"\\x1b[1;33mWARN: \", $fmt, \"\\x1b[0m\"));\n-    };\n-    ($fmt:expr, $($arg:tt)*) => {\n-        #[cfg(debug_assertions)]\n-        $crate::println!(concat!(\"\\x1b[1;33mWARN: \", $fmt, \"\\x1b[0m\"), $($arg)*);\n-    };\n-}\n-\n-/// Prints a warning message only once.\n-#[macro_export]\n-macro_rules! warn_once {\n-    ($fmt:expr) => {{\n-        static ONCE: ::spin::Once<()> = ::spin::Once::new();\n-        ONCE.call_once(|| {\n-            $crate::println!(concat!(\"\\x1b[1;33mWARN: \", $fmt, \"\\x1b[0m\"));\n-        });\n-    }};\n-    ($fmt:expr, $($arg:tt)*) => {{\n-        static ONCE: ::spin::Once<()> = ::spin::Once::new();\n-        ONCE.call_once(|| {\n-            $crate::println!(concat!(\"\\x1b[1;33mWARN: \", $fmt, \"\\x1b[0m\"), $($arg)*);\n-        });\n-    }};\n-}\n-\n-/// Prints a warning message if it is `Err`.\n-#[macro_export]\n-macro_rules! warn_if_err {\n-    ($result:expr) => {\n-        #[cfg(debug_assertions)]\n-        if let Err(err) = $result {\n-            $crate::debug_warn!(\"{}:{}: error returned: {:?}\", file!(), line!(), err);\n-        }\n-    };\n-}\n-\n-pub struct PrintkLogger;\n-impl log::Log for PrintkLogger {\n-    fn enabled(&self, metadata: &log::Metadata) -> bool {\n-        if cfg!(debug_assertions) {\n-            true\n-        } else {\n-            metadata.level() <= log::Level::Info\n-        }\n-    }\n-\n-    fn log(&self, record: &log::Record) {\n-        use log::Level;\n-        const RESET: &str = \"\\x1b[0m\";\n-        const INFO_COLOR: &str = \"\\x1b[36m\";\n-        const WARN_COLOR: &str = \"\\x1b[33m\";\n-        const ERROR_COLOR: &str = \"\\x1b[1;31m\";\n-\n-        if self.enabled(record.metadata()) {\n-            match record.level() {\n-                Level::Trace | Level::Debug => {\n-                    println!(\"{}\", record.args());\n-                }\n-                Level::Info => {\n-                    println!(\"{}{}{}\", INFO_COLOR, record.args(), RESET);\n-                }\n-                Level::Warn => {\n-                    println!(\"{}{}{}\", WARN_COLOR, record.args(), RESET);\n-                }\n-                Level::Error => {\n-                    println!(\"{}{}{}\", ERROR_COLOR, record.args(), RESET);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn flush(&self) {}\n-}\n-\n-/// A symbol.\n-#[repr(C, packed)]\n-struct SymbolEntry {\n-    addr: u64,\n-    name: [u8; 56],\n-}\n-\n-#[repr(C, packed)]\n-struct SymbolTable {\n-    magic: u32,\n-    num_symbols: i32,\n-    padding: u64,\n-}\n-\n-extern \"C\" {\n-    static __symbol_table: SymbolTable;\n-}\n-\n-global_asm!(\n-    r#\"\n-    .rodata\n-    .align 8\n-    .global __symbol_table\n-    __symbol_table:\n-       .ascii \"__SYMBOL_TABLE_START__\"\n-       .space 725 * 1024\n-       .ascii \"__SYMBOL_TABLE_END__\"\n-\"#\n-);\n-\n-struct Symbol {\n-    name: &'static str,\n-    addr: VAddr,\n-}\n-\n-fn resolve_symbol(vaddr: VAddr) -> Option<Symbol> {\n-    assert!(unsafe { __symbol_table.magic } == 0xbeefbeef);\n-\n-    let num_symbols = unsafe { __symbol_table.num_symbols };\n-    let symbols = unsafe {\n-        slice::from_raw_parts(\n-            ((&__symbol_table as *const _ as usize) + size_of::<SymbolTable>())\n-                as *const SymbolEntry,\n-            __symbol_table.num_symbols as usize,\n-        )\n-    };\n-\n-    // Do a binary search.\n-    let mut l = -1;\n-    let mut r = num_symbols;\n-    while r - l > 1 {\n-        let mid = (l + r) / 2;\n-        if vaddr.value() >= symbols[mid as usize].addr as usize {\n-            l = mid;\n-        } else {\n-            r = mid;\n-        }\n-    }\n-\n-    if l >= 0 {\n-        let symbol = &symbols[l as usize];\n-        Some(Symbol {\n-            name: unsafe { str::from_utf8_unchecked(&symbol.name) },\n-            addr: VAddr::new(symbol.addr as usize),\n-        })\n-    } else {\n-        None\n-    }\n-}\n-\n-/// Prints a backtrace.\n-pub fn backtrace() {\n-    Backtrace::current_frame().traverse(|i, vaddr| {\n-        if let Some(symbol) = resolve_symbol(vaddr) {\n-            warn!(\n-                \"    {index}: {vaddr} {symbol_name}()+0x{offset:x}\",\n-                index = i,\n-                vaddr = vaddr,\n-                symbol_name = symbol.name,\n-                offset = vaddr.value() - symbol.addr.value(),\n-            );\n-        } else {\n-            warn!(\n-                \"    {index}: {vaddr} (symbol unknown)\",\n-                index = i,\n-                vaddr = vaddr,\n-            );\n-        }\n-    });\n-}\n-\n-pub struct CapturedBacktraceFrame {\n-    pub vaddr: VAddr,\n-    pub offset: usize,\n-    pub symbol_name: &'static str,\n-}\n-\n-pub struct CapturedBacktrace {\n-    pub trace: Box<ArrayVec<CapturedBacktraceFrame, 8>>,\n-}\n-\n-/// Returns a saved backtrace.\n-pub fn capture_backtrace() -> CapturedBacktrace {\n-    let mut trace = Box::new(ArrayVec::new());\n-    Backtrace::current_frame().traverse(|_, vaddr| {\n-        if let Some(symbol) = resolve_symbol(vaddr) {\n-            let _ = trace.try_push(CapturedBacktraceFrame {\n-                vaddr,\n-                symbol_name: symbol.name,\n-                offset: vaddr.value() - symbol.addr.value(),\n-            });\n-        }\n-    });\n-    CapturedBacktrace { trace }\n-}\n-\n-impl fmt::Debug for CapturedBacktrace {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        for (i, frame) in self.trace.iter().enumerate() {\n-            let _ = writeln!(\n-                f,\n-                \"    #{}: {} {}()+0x{:x}\",\n-                i + 1,\n-                frame.vaddr,\n-                frame.symbol_name,\n-                frame.offset\n-            );\n-        }\n-\n-        Ok(())\n-    }\n-}\ndiff --git a/kernel/process/elf.rs b/kernel/process/elf.rs\n--- a/kernel/process/elf.rs\n+++ b/kernel/process/elf.rs\n@@ -1,8 +1,8 @@\n-use crate::arch::UserVAddr;\n use crate::prelude::*;\n use core::{mem::size_of, slice::from_raw_parts};\n use goblin::elf64::header::{Header, ELFMAG, EM_X86_64, ET_EXEC};\n pub use goblin::elf64::program_header::ProgramHeader;\n+use kerla_runtime::address::UserVAddr;\n \n /// A parsed ELF object.\n pub struct Elf<'a> {\ndiff --git a/kernel/process/elf.rs b/kernel/process/elf.rs\n--- a/kernel/process/elf.rs\n+++ b/kernel/process/elf.rs\n@@ -49,7 +49,7 @@ impl<'a> Elf<'a> {\n \n     /// The entry point of the ELF file.\n     pub fn entry(&self) -> Result<UserVAddr> {\n-        UserVAddr::new_nonnull(self.header.e_entry as usize)\n+        UserVAddr::new_nonnull(self.header.e_entry as usize).map_err(Into::into)\n     }\n \n     /// The ELF header.\ndiff --git a/kernel/process/init_stack.rs b/kernel/process/init_stack.rs\n--- a/kernel/process/init_stack.rs\n+++ b/kernel/process/init_stack.rs\n@@ -1,10 +1,7 @@\n-use crate::{\n-    arch::{self, VAddr},\n-    result::{Errno, Error, Result},\n-};\n+use crate::result::{Errno, Error, Result};\n \n use alloc::vec::Vec;\n-use arch::UserVAddr;\n+use kerla_runtime::address::{UserVAddr, VAddr};\n \n use core::mem::size_of;\n \ndiff --git a/kernel/process/mod.rs b/kernel/process/mod.rs\n--- a/kernel/process/mod.rs\n+++ b/kernel/process/mod.rs\n@@ -1,8 +1,6 @@\n-use crate::arch::{self, SpinLock};\n-\n use alloc::sync::Arc;\n \n-use arch::UserVAddr;\n+use kerla_runtime::{address::UserVAddr, spinlock::SpinLock};\n \n use kerla_utils::lazy::Lazy;\n use kerla_utils::once::Once;\ndiff --git a/kernel/process/process.rs b/kernel/process/process.rs\n--- a/kernel/process/process.rs\n+++ b/kernel/process/process.rs\n@@ -1,8 +1,5 @@\n use crate::{\n-    arch::{\n-        self, SpinLock, SpinLockGuard, SyscallFrame, KERNEL_STACK_SIZE, PAGE_SIZE, USER_STACK_TOP,\n-    },\n-    boot::INITIAL_ROOT_FS,\n+    arch::{self, KERNEL_STACK_SIZE, USER_STACK_TOP},\n     ctypes::*,\n     fs::{\n         devfs::SERIAL_TTY,\ndiff --git a/kernel/process/process.rs b/kernel/process/process.rs\n--- a/kernel/process/process.rs\n+++ b/kernel/process/process.rs\n@@ -10,10 +7,7 @@ use crate::{\n         opened_file::{Fd, OpenFlags, OpenOptions, OpenedFile, OpenedFileTable, PathComponent},\n         path::Path,\n     },\n-    mm::{\n-        page_allocator::{alloc_pages, AllocPageFlags},\n-        vm::{Vm, VmAreaType},\n-    },\n+    mm::vm::{Vm, VmAreaType},\n     prelude::*,\n     process::{\n         cmdline::Cmdline,\ndiff --git a/kernel/process/process.rs b/kernel/process/process.rs\n--- a/kernel/process/process.rs\n+++ b/kernel/process/process.rs\n@@ -25,6 +19,7 @@ use crate::{\n         switch, UserVAddr, JOIN_WAIT_QUEUE, SCHEDULER,\n     },\n     random::read_secure_random,\n+    INITIAL_ROOT_FS,\n };\n \n use alloc::collections::BTreeMap;\ndiff --git a/kernel/process/process.rs b/kernel/process/process.rs\n--- a/kernel/process/process.rs\n+++ b/kernel/process/process.rs\n@@ -36,6 +31,11 @@ use core::mem::size_of;\n use core::sync::atomic::{AtomicI32, Ordering};\n use crossbeam::atomic::AtomicCell;\n use goblin::elf64::program_header::PT_LOAD;\n+use kerla_runtime::{\n+    arch::{SyscallFrame, PAGE_SIZE},\n+    page_allocator::{alloc_pages, AllocPageFlags},\n+    spinlock::{SpinLock, SpinLockGuard},\n+};\n use kerla_utils::alignment::align_up;\n \n type ProcessTable = BTreeMap<PId, Arc<Process>>;\ndiff --git a/kernel/process/process.rs b/kernel/process/process.rs\n--- a/kernel/process/process.rs\n+++ b/kernel/process/process.rs\n@@ -563,8 +563,8 @@ fn do_setup_userspace(\n     )?;\n \n     let mut vm = Vm::new(\n-        UserVAddr::new_nonnull(user_stack_bottom).unwrap(),\n-        UserVAddr::new_nonnull(user_heap_bottom).unwrap(),\n+        UserVAddr::new(user_stack_bottom).unwrap(),\n+        UserVAddr::new(user_heap_bottom).unwrap(),\n     )?;\n     for i in 0..(file_header_len / PAGE_SIZE) {\n         vm.page_table_mut().map_user_page(\ndiff --git a/kernel/process/process_group.rs b/kernel/process/process_group.rs\n--- a/kernel/process/process_group.rs\n+++ b/kernel/process/process_group.rs\n@@ -1,6 +1,6 @@\n-use crate::arch::SpinLock;\n use crate::prelude::*;\n use alloc::{collections::BTreeMap, vec::Vec};\n+use kerla_runtime::spinlock::SpinLock;\n \n use super::{signal::Signal, Process};\n \ndiff --git a/kernel/process/scheduler.rs b/kernel/process/scheduler.rs\n--- a/kernel/process/scheduler.rs\n+++ b/kernel/process/scheduler.rs\n@@ -1,6 +1,6 @@\n-use crate::arch::SpinLock;\n use crate::process::PId;\n use alloc::collections::VecDeque;\n+use kerla_runtime::spinlock::SpinLock;\n \n /// The process scheduler.\n ///\ndiff --git a/kernel/process/signal.rs b/kernel/process/signal.rs\n--- a/kernel/process/signal.rs\n+++ b/kernel/process/signal.rs\n@@ -1,4 +1,5 @@\n-use crate::{arch::UserVAddr, ctypes::c_int, prelude::*};\n+use crate::{ctypes::c_int, prelude::*};\n+use kerla_runtime::address::UserVAddr;\n \n pub type Signal = c_int;\n #[allow(unused)]\ndiff --git a/kernel/process/wait_queue.rs b/kernel/process/wait_queue.rs\n--- a/kernel/process/wait_queue.rs\n+++ b/kernel/process/wait_queue.rs\n@@ -1,8 +1,9 @@\n use super::{current_process, switch, Process, ProcessState};\n+use crate::result::Errno;\n use crate::result::Result;\n-use crate::{arch::SpinLock, result::Errno};\n \n use alloc::{collections::VecDeque, sync::Arc};\n+use kerla_runtime::spinlock::SpinLock;\n \n pub struct WaitQueue {\n     queue: SpinLock<VecDeque<Arc<Process>>>,\ndiff --git a/kernel/result.rs b/kernel/result.rs\n--- a/kernel/result.rs\n+++ b/kernel/result.rs\n@@ -1,10 +1,17 @@\n use core::fmt;\n \n-use crate::printk::{capture_backtrace, CapturedBacktrace};\n+use kerla_runtime::{\n+    address::{AccessError, NullUserPointerError},\n+    page_allocator::PageAllocError,\n+};\n+\n+#[cfg(debug_assertions)]\n+use kerla_runtime::backtrace::CapturedBacktrace;\n \n #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n #[repr(i32)]\n #[allow(unused)]\n+#[allow(clippy::upper_case_acronyms)]\n pub enum Errno {\n     EPERM = 1,\n     ENOENT = 2,\ndiff --git a/kernel/result.rs b/kernel/result.rs\n--- a/kernel/result.rs\n+++ b/kernel/result.rs\n@@ -75,7 +82,7 @@ impl Error {\n             errno,\n             message: None,\n             #[cfg(debug_assertions)]\n-            backtrace: Some(capture_backtrace()),\n+            backtrace: Some(CapturedBacktrace::capture()),\n         }\n     }\n \ndiff --git a/kernel/result.rs b/kernel/result.rs\n--- a/kernel/result.rs\n+++ b/kernel/result.rs\n@@ -84,7 +91,7 @@ impl Error {\n             errno,\n             message: Some(ErrorMessage::StaticStr(message)),\n             #[cfg(debug_assertions)]\n-            backtrace: Some(capture_backtrace()),\n+            backtrace: Some(CapturedBacktrace::capture()),\n         }\n     }\n \ndiff --git a/kernel/result.rs b/kernel/result.rs\n--- a/kernel/result.rs\n+++ b/kernel/result.rs\n@@ -150,9 +157,26 @@ impl From<Errno> for Error {\n     }\n }\n \n+impl From<AccessError> for Error {\n+    fn from(_error: AccessError) -> Error {\n+        Error::new(Errno::EFAULT)\n+    }\n+}\n+\n+impl From<PageAllocError> for Error {\n+    fn from(_error: PageAllocError) -> Error {\n+        Error::new(Errno::ENOMEM)\n+    }\n+}\n+\n+impl From<NullUserPointerError> for Error {\n+    fn from(_error: NullUserPointerError) -> Error {\n+        Error::new(Errno::EFAULT)\n+    }\n+}\n+\n impl From<smoltcp::Error> for Error {\n     fn from(error: smoltcp::Error) -> Error {\n-        debug_warn!(\"smoltcp: {}\", error);\n         match error {\n             smoltcp::Error::Exhausted => Error::with_message(Errno::EINVAL, \"smoltcp(Exhausted)\"),\n             smoltcp::Error::Illegal => Error::with_message(Errno::EINVAL, \"smoltcp(Illegal)\"),\ndiff --git a/kernel/syscalls/accept.rs b/kernel/syscalls/accept.rs\n--- a/kernel/syscalls/accept.rs\n+++ b/kernel/syscalls/accept.rs\n@@ -1,5 +1,6 @@\n+use kerla_runtime::address::UserVAddr;\n+\n use crate::{\n-    arch::UserVAddr,\n     fs::opened_file::{Fd, OpenOptions, PathComponent},\n     net::socket::write_sockaddr,\n     prelude::*,\ndiff --git a/kernel/syscalls/arch_prctl.rs b/kernel/syscalls/arch_prctl.rs\n--- a/kernel/syscalls/arch_prctl.rs\n+++ b/kernel/syscalls/arch_prctl.rs\n@@ -1,7 +1,6 @@\n-use crate::{\n-    arch::{arch_prctl, UserVAddr},\n-    result::Result,\n-};\n+use kerla_runtime::address::UserVAddr;\n+\n+use crate::{arch::arch_prctl, result::Result};\n use crate::{process::current_process, syscalls::SyscallHandler};\n \n impl<'a> SyscallHandler<'a> {\ndiff --git a/kernel/syscalls/bind.rs b/kernel/syscalls/bind.rs\n--- a/kernel/syscalls/bind.rs\n+++ b/kernel/syscalls/bind.rs\n@@ -1,6 +1,7 @@\n use crate::fs::opened_file::Fd;\n-use crate::{arch::UserVAddr, result::Result};\n+use crate::result::Result;\n use crate::{net::socket::read_sockaddr, process::current_process, syscalls::SyscallHandler};\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_bind(&mut self, fd: Fd, addr: UserVAddr, addr_len: usize) -> Result<isize> {\ndiff --git a/kernel/syscalls/brk.rs b/kernel/syscalls/brk.rs\n--- a/kernel/syscalls/brk.rs\n+++ b/kernel/syscalls/brk.rs\n@@ -1,5 +1,6 @@\n-use crate::{arch::UserVAddr, result::Result};\n+use crate::result::Result;\n use crate::{process::current_process, syscalls::SyscallHandler};\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_brk(&mut self, new_heap_end: Option<UserVAddr>) -> Result<isize> {\ndiff --git a/kernel/syscalls/clock_gettime.rs b/kernel/syscalls/clock_gettime.rs\n--- a/kernel/syscalls/clock_gettime.rs\n+++ b/kernel/syscalls/clock_gettime.rs\n@@ -1,8 +1,7 @@\n+use kerla_runtime::address::UserVAddr;\n+\n+use crate::result::{Errno, Result};\n use crate::user_buffer::UserBufWriter;\n-use crate::{\n-    arch::UserVAddr,\n-    result::{Errno, Result},\n-};\n use crate::{\n     ctypes::{c_clockid, c_long, c_time, CLOCK_MONOTONIC, CLOCK_REALTIME},\n     timer::read_wall_clock,\ndiff --git a/kernel/syscalls/connect.rs b/kernel/syscalls/connect.rs\n--- a/kernel/syscalls/connect.rs\n+++ b/kernel/syscalls/connect.rs\n@@ -1,6 +1,7 @@\n use crate::fs::opened_file::Fd;\n-use crate::{arch::UserVAddr, net::socket::read_sockaddr, result::Result};\n+use crate::{net::socket::read_sockaddr, result::Result};\n use crate::{process::current_process, syscalls::SyscallHandler};\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_connect(&mut self, fd: Fd, addr: UserVAddr, addr_len: usize) -> Result<isize> {\ndiff --git a/kernel/syscalls/execve.rs b/kernel/syscalls/execve.rs\n--- a/kernel/syscalls/execve.rs\n+++ b/kernel/syscalls/execve.rs\n@@ -1,10 +1,10 @@\n-use crate::arch::UserVAddr;\n use crate::fs::path::Path;\n use crate::prelude::*;\n use crate::process::Process;\n use crate::user_buffer::UserCStr;\n use crate::{process::current_process, syscalls::SyscallHandler};\n use core::mem::size_of;\n+use kerla_runtime::address::UserVAddr;\n \n const ARG_MAX: usize = 512;\n const ARG_LEN_MAX: usize = 4096;\ndiff --git a/kernel/syscalls/execve.rs b/kernel/syscalls/execve.rs\n--- a/kernel/syscalls/execve.rs\n+++ b/kernel/syscalls/execve.rs\n@@ -24,8 +24,7 @@ impl<'a> SyscallHandler<'a> {\n         let mut argv = Vec::new();\n         for i in 0..ARG_MAX {\n             let ptr = argv_uaddr.add(i * size_of::<usize>());\n-            let str_ptr = UserVAddr::new(ptr.read::<usize>()?)?;\n-            match str_ptr {\n+            match UserVAddr::new(ptr.read::<usize>()?) {\n                 Some(str_ptr) => argv.push(UserCStr::new(str_ptr, ARG_LEN_MAX)?),\n                 None => break,\n             }\ndiff --git a/kernel/syscalls/execve.rs b/kernel/syscalls/execve.rs\n--- a/kernel/syscalls/execve.rs\n+++ b/kernel/syscalls/execve.rs\n@@ -34,8 +33,7 @@ impl<'a> SyscallHandler<'a> {\n         let mut envp = Vec::new();\n         for i in 0..ENV_MAX {\n             let ptr = envp_uaddr.add(i * size_of::<usize>());\n-            let str_ptr = UserVAddr::new(ptr.read::<usize>()?)?;\n-            match str_ptr {\n+            match UserVAddr::new(ptr.read::<usize>()?) {\n                 Some(str_ptr) => envp.push(UserCStr::new(str_ptr, ENV_LEN_MAX)?),\n                 None => break,\n             }\ndiff --git a/kernel/syscalls/fstat.rs b/kernel/syscalls/fstat.rs\n--- a/kernel/syscalls/fstat.rs\n+++ b/kernel/syscalls/fstat.rs\n@@ -1,6 +1,7 @@\n use crate::fs::opened_file::Fd;\n-use crate::{arch::UserVAddr, result::Result};\n+use crate::result::Result;\n use crate::{process::current_process, syscalls::SyscallHandler};\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_fstat(&mut self, fd: Fd, buf: UserVAddr) -> Result<isize> {\ndiff --git a/kernel/syscalls/getcwd.rs b/kernel/syscalls/getcwd.rs\n--- a/kernel/syscalls/getcwd.rs\n+++ b/kernel/syscalls/getcwd.rs\n@@ -1,8 +1,7 @@\n+use kerla_runtime::address::UserVAddr;\n+\n+use crate::result::{Errno, Result};\n use crate::syscalls::SyscallHandler;\n-use crate::{\n-    arch::UserVAddr,\n-    result::{Errno, Result},\n-};\n use crate::{ctypes::*, process::current_process};\n \n use crate::user_buffer::UserBufWriter;\ndiff --git a/kernel/syscalls/getdents64.rs b/kernel/syscalls/getdents64.rs\n--- a/kernel/syscalls/getdents64.rs\n+++ b/kernel/syscalls/getdents64.rs\n@@ -1,7 +1,8 @@\n use crate::fs::opened_file::Fd;\n-use crate::{arch::UserVAddr, result::Result};\n+use crate::result::Result;\n use crate::{process::current_process, syscalls::SyscallHandler};\n use core::mem::size_of;\n+use kerla_runtime::address::UserVAddr;\n use kerla_utils::alignment::align_up;\n \n use crate::user_buffer::UserBufWriter;\ndiff --git a/kernel/syscalls/getpeername.rs b/kernel/syscalls/getpeername.rs\n--- a/kernel/syscalls/getpeername.rs\n+++ b/kernel/syscalls/getpeername.rs\n@@ -1,5 +1,6 @@\n-use crate::{arch::UserVAddr, fs::opened_file::Fd, result::Result};\n+use crate::{fs::opened_file::Fd, result::Result};\n use crate::{net::socket::write_sockaddr, process::current_process, syscalls::SyscallHandler};\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_getpeername(\ndiff --git a/kernel/syscalls/getrandom.rs b/kernel/syscalls/getrandom.rs\n--- a/kernel/syscalls/getrandom.rs\n+++ b/kernel/syscalls/getrandom.rs\n@@ -1,9 +1,10 @@\n use crate::random::{read_insecure_random, read_secure_random};\n+use crate::result::Result;\n use crate::syscalls::SyscallHandler;\n-use crate::{arch::UserVAddr, result::Result};\n use crate::{ctypes::c_uint, user_buffer::UserBufferMut};\n use bitflags::bitflags;\n use core::cmp::min;\n+use kerla_runtime::address::UserVAddr;\n \n const GETRANDOM_LEN_MAX: usize = 256;\n \ndiff --git a/kernel/syscalls/getsockname.rs b/kernel/syscalls/getsockname.rs\n--- a/kernel/syscalls/getsockname.rs\n+++ b/kernel/syscalls/getsockname.rs\n@@ -1,5 +1,6 @@\n-use crate::{arch::UserVAddr, fs::opened_file::Fd, result::Result};\n+use crate::{fs::opened_file::Fd, result::Result};\n use crate::{net::socket::write_sockaddr, process::current_process, syscalls::SyscallHandler};\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_getsockname(\ndiff --git a/kernel/syscalls/getsockopt.rs b/kernel/syscalls/getsockopt.rs\n--- a/kernel/syscalls/getsockopt.rs\n+++ b/kernel/syscalls/getsockopt.rs\n@@ -1,4 +1,5 @@\n-use crate::{arch::UserVAddr, ctypes::c_int, fs::opened_file::Fd, prelude::*};\n+use crate::{ctypes::c_int, fs::opened_file::Fd, prelude::*};\n+use kerla_runtime::address::UserVAddr;\n \n use super::SyscallHandler;\n \ndiff --git a/kernel/syscalls/lstat.rs b/kernel/syscalls/lstat.rs\n--- a/kernel/syscalls/lstat.rs\n+++ b/kernel/syscalls/lstat.rs\n@@ -1,6 +1,7 @@\n use crate::fs::path::Path;\n-use crate::{arch::UserVAddr, result::Result};\n+use crate::result::Result;\n use crate::{process::current_process, syscalls::SyscallHandler};\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_lstat(&mut self, path: &Path, buf: UserVAddr) -> Result<isize> {\ndiff --git a/kernel/syscalls/mmap.rs b/kernel/syscalls/mmap.rs\n--- a/kernel/syscalls/mmap.rs\n+++ b/kernel/syscalls/mmap.rs\n@@ -1,8 +1,9 @@\n+use kerla_runtime::{address::UserVAddr, arch::PAGE_SIZE};\n use kerla_utils::alignment::is_aligned;\n \n use crate::{\n-    arch::UserVAddr, arch::PAGE_SIZE, ctypes::*, fs::opened_file::Fd, mm::vm::VmAreaType,\n-    prelude::*, process::current_process, syscalls::SyscallHandler,\n+    ctypes::*, fs::opened_file::Fd, mm::vm::VmAreaType, prelude::*, process::current_process,\n+    syscalls::SyscallHandler,\n };\n \n impl<'a> SyscallHandler<'a> {\ndiff --git a/kernel/syscalls/mod.rs b/kernel/syscalls/mod.rs\n--- a/kernel/syscalls/mod.rs\n+++ b/kernel/syscalls/mod.rs\n@@ -1,5 +1,4 @@\n use crate::{\n-    arch::{SyscallFrame, UserVAddr},\n     ctypes::*,\n     fs::path::PathBuf,\n     fs::{\ndiff --git a/kernel/syscalls/mod.rs b/kernel/syscalls/mod.rs\n--- a/kernel/syscalls/mod.rs\n+++ b/kernel/syscalls/mod.rs\n@@ -15,6 +14,7 @@ use crate::{\n     user_buffer::UserCStr,\n };\n use bitflags::bitflags;\n+use kerla_runtime::{address::UserVAddr, arch::SyscallFrame};\n \n pub(self) mod accept;\n pub(self) mod arch_prctl;\ndiff --git a/kernel/syscalls/mod.rs b/kernel/syscalls/mod.rs\n--- a/kernel/syscalls/mod.rs\n+++ b/kernel/syscalls/mod.rs\n@@ -188,6 +188,7 @@ impl<'a> SyscallHandler<'a> {\n         if !((n == 0 && a1 == 0)\n             || (n == 1) && (a1 == 1)\n             || (n == 1) && (a1 == 2)\n+            || (n == 20) && (a1 == 1)\n             || (n == 20) && (a1 == 2))\n         {\n             let current = current_process();\ndiff --git a/kernel/syscalls/mod.rs b/kernel/syscalls/mod.rs\n--- a/kernel/syscalls/mod.rs\n+++ b/kernel/syscalls/mod.rs\n@@ -239,7 +240,7 @@ impl<'a> SyscallHandler<'a> {\n             SYS_WRITE => self.sys_write(Fd::new(a1 as i32), UserVAddr::new_nonnull(a2)?, a3),\n             SYS_WRITEV => self.sys_writev(Fd::new(a1 as i32), UserVAddr::new_nonnull(a2)?, a3),\n             SYS_MMAP => self.sys_mmap(\n-                UserVAddr::new(a1)?,\n+                UserVAddr::new(a1),\n                 a2 as c_size,\n                 bitflags_from_user!(MMapProt, a3 as c_int)?,\n                 bitflags_from_user!(MMapFlags, a4 as c_int)?,\ndiff --git a/kernel/syscalls/mod.rs b/kernel/syscalls/mod.rs\n--- a/kernel/syscalls/mod.rs\n+++ b/kernel/syscalls/mod.rs\n@@ -264,17 +265,17 @@ impl<'a> SyscallHandler<'a> {\n             SYS_CHMOD => self.sys_chmod(&resolve_path(a1)?, FileMode::new(a2 as u32)),\n             SYS_CHOWN => Ok(0), // TODO:\n             SYS_FSYNC => self.sys_fsync(Fd::new(a1 as i32)),\n-            SYS_UTIMES => self.sys_utimes(&resolve_path(a1)?, UserVAddr::new(a2)?),\n+            SYS_UTIMES => self.sys_utimes(&resolve_path(a1)?, UserVAddr::new(a2)),\n             SYS_GETDENTS64 => {\n                 self.sys_getdents64(Fd::new(a1 as i32), UserVAddr::new_nonnull(a2)?, a3)\n             }\n             SYS_POLL => self.sys_poll(UserVAddr::new_nonnull(a1)?, a2 as c_ulong, a3 as c_int),\n             SYS_SELECT => self.sys_select(\n                 a1 as c_int,\n-                UserVAddr::new(a2)?,\n-                UserVAddr::new(a3)?,\n-                UserVAddr::new(a4)?,\n-                UserVAddr::new(a5)?\n+                UserVAddr::new(a2),\n+                UserVAddr::new(a3),\n+                UserVAddr::new(a4),\n+                UserVAddr::new(a5)\n                     .map(|uaddr| uaddr.read::<Timeval>())\n                     .transpose()?,\n             ),\ndiff --git a/kernel/syscalls/mod.rs b/kernel/syscalls/mod.rs\n--- a/kernel/syscalls/mod.rs\n+++ b/kernel/syscalls/mod.rs\n@@ -283,7 +284,7 @@ impl<'a> SyscallHandler<'a> {\n             SYS_CHDIR => self.sys_chdir(&resolve_path(a1)?),\n             SYS_MKDIR => self.sys_mkdir(&resolve_path(a1)?, FileMode::new(a2 as u32)),\n             SYS_ARCH_PRCTL => self.sys_arch_prctl(a1 as i32, UserVAddr::new_nonnull(a2)?),\n-            SYS_BRK => self.sys_brk(UserVAddr::new(a1)?),\n+            SYS_BRK => self.sys_brk(UserVAddr::new(a1)),\n             SYS_IOCTL => self.sys_ioctl(Fd::new(a1 as i32), a2, a3),\n             SYS_GETPID => self.sys_getpid(),\n             SYS_GETPGID => self.sys_getpgid(PId::new(a1 as i32)),\ndiff --git a/kernel/syscalls/mod.rs b/kernel/syscalls/mod.rs\n--- a/kernel/syscalls/mod.rs\n+++ b/kernel/syscalls/mod.rs\n@@ -296,7 +297,7 @@ impl<'a> SyscallHandler<'a> {\n             SYS_GETPPID => self.sys_getppid(),\n             SYS_SET_TID_ADDRESS => self.sys_set_tid_address(UserVAddr::new_nonnull(a1)?),\n             SYS_PIPE => self.sys_pipe(UserVAddr::new_nonnull(a1)?),\n-            SYS_RT_SIGACTION => self.sys_rt_sigaction(a1 as c_int, a2, UserVAddr::new(a3)?),\n+            SYS_RT_SIGACTION => self.sys_rt_sigaction(a1 as c_int, a2, UserVAddr::new(a3)),\n             SYS_RT_SIGRETURN => self.sys_rt_sigreturn(),\n             SYS_EXECVE => self.sys_execve(\n                 &resolve_path(a1)?,\ndiff --git a/kernel/syscalls/mod.rs b/kernel/syscalls/mod.rs\n--- a/kernel/syscalls/mod.rs\n+++ b/kernel/syscalls/mod.rs\n@@ -306,9 +307,9 @@ impl<'a> SyscallHandler<'a> {\n             SYS_FORK => self.sys_fork(),\n             SYS_WAIT4 => self.sys_wait4(\n                 PId::new(a1 as i32),\n-                UserVAddr::new(a2)?,\n+                UserVAddr::new(a2),\n                 bitflags_from_user!(WaitOptions, a3 as c_int)?,\n-                UserVAddr::new(a4)?,\n+                UserVAddr::new(a4),\n             ),\n             SYS_EXIT => self.sys_exit(a1 as i32),\n             SYS_SOCKET => self.sys_socket(a1 as i32, a2 as i32, a3 as i32),\ndiff --git a/kernel/syscalls/mod.rs b/kernel/syscalls/mod.rs\n--- a/kernel/syscalls/mod.rs\n+++ b/kernel/syscalls/mod.rs\n@@ -331,18 +332,18 @@ impl<'a> SyscallHandler<'a> {\n                 Fd::new(a1 as i32),\n                 a2 as c_int,\n                 a3 as c_int,\n-                UserVAddr::new(a4)?,\n-                UserVAddr::new(a5)?,\n+                UserVAddr::new(a4),\n+                UserVAddr::new(a5),\n             ),\n             SYS_ACCEPT => {\n-                self.sys_accept(Fd::new(a1 as i32), UserVAddr::new(a2)?, UserVAddr::new(a3)?)\n+                self.sys_accept(Fd::new(a1 as i32), UserVAddr::new(a2), UserVAddr::new(a3))\n             }\n             SYS_SENDTO => self.sys_sendto(\n                 Fd::new(a1 as i32),\n                 UserVAddr::new_nonnull(a2)?,\n                 a3 as usize,\n                 bitflags_from_user!(SendToFlags, a4 as i32)?,\n-                UserVAddr::new(a5)?,\n+                UserVAddr::new(a5),\n                 a6,\n             ),\n             SYS_RECVFROM => self.sys_recvfrom(\ndiff --git a/kernel/syscalls/mod.rs b/kernel/syscalls/mod.rs\n--- a/kernel/syscalls/mod.rs\n+++ b/kernel/syscalls/mod.rs\n@@ -350,8 +351,8 @@ impl<'a> SyscallHandler<'a> {\n                 UserVAddr::new_nonnull(a2)?,\n                 a3 as usize,\n                 bitflags_from_user!(RecvFromFlags, a4 as i32)?,\n-                UserVAddr::new(a5)?,\n-                UserVAddr::new(a6)?,\n+                UserVAddr::new(a5),\n+                UserVAddr::new(a6),\n             ),\n             SYS_UNAME => self.sys_uname(UserVAddr::new_nonnull(a1)?),\n             SYS_CLOCK_GETTIME => {\ndiff --git a/kernel/syscalls/mod.rs b/kernel/syscalls/mod.rs\n--- a/kernel/syscalls/mod.rs\n+++ b/kernel/syscalls/mod.rs\n@@ -362,7 +363,7 @@ impl<'a> SyscallHandler<'a> {\n                 a2,\n                 bitflags_from_user!(GetRandomFlags, a3 as c_uint)?,\n             ),\n-            SYS_SYSLOG => self.sys_syslog(a1 as c_int, UserVAddr::new(a2)?, a3 as c_int),\n+            SYS_SYSLOG => self.sys_syslog(a1 as c_int, UserVAddr::new(a2), a3 as c_int),\n             SYS_REBOOT => self.sys_reboot(a1 as c_int, a2 as c_int, a3),\n             _ => {\n                 debug_warn!(\ndiff --git a/kernel/syscalls/pipe.rs b/kernel/syscalls/pipe.rs\n--- a/kernel/syscalls/pipe.rs\n+++ b/kernel/syscalls/pipe.rs\n@@ -1,9 +1,9 @@\n use core::mem::size_of;\n \n use alloc::sync::Arc;\n+use kerla_runtime::address::UserVAddr;\n \n use crate::{\n-    arch::UserVAddr,\n     ctypes::*,\n     fs::{\n         inode::{FileLike, INode},\ndiff --git a/kernel/syscalls/poll.rs b/kernel/syscalls/poll.rs\n--- a/kernel/syscalls/poll.rs\n+++ b/kernel/syscalls/poll.rs\n@@ -1,7 +1,8 @@\n use core::mem::size_of;\n \n+use kerla_runtime::address::UserVAddr;\n+\n use crate::{\n-    arch::UserVAddr,\n     ctypes::{c_int, c_nfds, c_short},\n     fs::{inode::PollStatus, opened_file::Fd},\n     poll::POLL_WAIT_QUEUE,\ndiff --git a/kernel/syscalls/read.rs b/kernel/syscalls/read.rs\n--- a/kernel/syscalls/read.rs\n+++ b/kernel/syscalls/read.rs\n@@ -1,7 +1,8 @@\n use super::MAX_READ_WRITE_LEN;\n-use crate::{arch::UserVAddr, fs::opened_file::Fd, prelude::*, user_buffer::UserBufferMut};\n+use crate::{fs::opened_file::Fd, prelude::*, user_buffer::UserBufferMut};\n use crate::{process::current_process, syscalls::SyscallHandler};\n use core::cmp::min;\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_read(&mut self, fd: Fd, uaddr: UserVAddr, len: usize) -> Result<isize> {\ndiff --git a/kernel/syscalls/readlink.rs b/kernel/syscalls/readlink.rs\n--- a/kernel/syscalls/readlink.rs\n+++ b/kernel/syscalls/readlink.rs\n@@ -1,7 +1,8 @@\n+use kerla_runtime::address::UserVAddr;\n+\n use crate::result::Result;\n use crate::syscalls::SyscallHandler;\n use crate::{\n-    arch::UserVAddr,\n     fs::{opened_file::Fd, path::Path},\n     process::current_process,\n     result::Errno,\ndiff --git a/kernel/syscalls/reboot.rs b/kernel/syscalls/reboot.rs\n--- a/kernel/syscalls/reboot.rs\n+++ b/kernel/syscalls/reboot.rs\n@@ -1,8 +1,6 @@\n-use crate::{\n-    ctypes::c_int,\n-    syscalls::SyscallHandler,\n-    {arch::halt, result::Result},\n-};\n+use kerla_runtime::arch::halt;\n+\n+use crate::{ctypes::c_int, result::Result, syscalls::SyscallHandler};\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_reboot(&mut self, _magic: c_int, _magic2: c_int, _arg: usize) -> Result<isize> {\ndiff --git a/kernel/syscalls/recvfrom.rs b/kernel/syscalls/recvfrom.rs\n--- a/kernel/syscalls/recvfrom.rs\n+++ b/kernel/syscalls/recvfrom.rs\n@@ -1,8 +1,9 @@\n use super::MAX_READ_WRITE_LEN;\n-use crate::{arch::UserVAddr, fs::opened_file::Fd, result::Result};\n+use crate::{fs::opened_file::Fd, result::Result};\n use crate::{net::socket::write_sockaddr, net::RecvFromFlags, user_buffer::UserBufferMut};\n use crate::{process::current_process, syscalls::SyscallHandler};\n use core::cmp::min;\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_recvfrom(\ndiff --git a/kernel/syscalls/rt_sigaction.rs b/kernel/syscalls/rt_sigaction.rs\n--- a/kernel/syscalls/rt_sigaction.rs\n+++ b/kernel/syscalls/rt_sigaction.rs\n@@ -1,8 +1,9 @@\n use crate::ctypes::*;\n use crate::prelude::*;\n+use crate::process::current_process;\n use crate::process::signal::{SigAction, DEFAULT_ACTIONS, SIG_DFL, SIG_IGN};\n use crate::syscalls::SyscallHandler;\n-use crate::{arch::UserVAddr, process::current_process};\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_rt_sigaction(\ndiff --git a/kernel/syscalls/rt_sigaction.rs b/kernel/syscalls/rt_sigaction.rs\n--- a/kernel/syscalls/rt_sigaction.rs\n+++ b/kernel/syscalls/rt_sigaction.rs\n@@ -11,7 +12,7 @@ impl<'a> SyscallHandler<'a> {\n         act: usize,\n         _oldact: Option<UserVAddr>,\n     ) -> Result<isize> {\n-        if let Some(act) = UserVAddr::new(act)? {\n+        if let Some(act) = UserVAddr::new(act) {\n             let handler = act.read::<usize>()?;\n             let new_action = match handler {\n                 SIG_IGN => SigAction::Ignore,\ndiff --git a/kernel/syscalls/rt_sigaction.rs b/kernel/syscalls/rt_sigaction.rs\n--- a/kernel/syscalls/rt_sigaction.rs\n+++ b/kernel/syscalls/rt_sigaction.rs\n@@ -20,7 +21,7 @@ impl<'a> SyscallHandler<'a> {\n                     None => return Err(Errno::EINVAL.into()),\n                 },\n                 _ => SigAction::Handler {\n-                    handler: UserVAddr::new_nonnull(handler)?,\n+                    handler: UserVAddr::new(handler).ok_or_else(|| Error::new(Errno::EFAULT))?,\n                 },\n             };\n \ndiff --git a/kernel/syscalls/select.rs b/kernel/syscalls/select.rs\n--- a/kernel/syscalls/select.rs\n+++ b/kernel/syscalls/select.rs\n@@ -1,7 +1,7 @@\n+use kerla_runtime::address::UserVAddr;\n use kerla_utils::alignment::align_up;\n \n use crate::{\n-    arch::UserVAddr,\n     ctypes::c_int,\n     fs::{inode::PollStatus, opened_file::Fd},\n     poll::POLL_WAIT_QUEUE,\ndiff --git a/kernel/syscalls/sendto.rs b/kernel/syscalls/sendto.rs\n--- a/kernel/syscalls/sendto.rs\n+++ b/kernel/syscalls/sendto.rs\n@@ -1,11 +1,12 @@\n use super::MAX_READ_WRITE_LEN;\n-use crate::{arch::UserVAddr, fs::opened_file::Fd, result::Result};\n+use crate::{fs::opened_file::Fd, result::Result};\n use crate::{\n     net::{socket::*, SendToFlags},\n     user_buffer::UserBuffer,\n };\n use crate::{process::current_process, syscalls::SyscallHandler};\n use core::cmp::min;\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_sendto(\ndiff --git a/kernel/syscalls/set_tid_address.rs b/kernel/syscalls/set_tid_address.rs\n--- a/kernel/syscalls/set_tid_address.rs\n+++ b/kernel/syscalls/set_tid_address.rs\n@@ -1,5 +1,6 @@\n+use crate::result::Result;\n use crate::syscalls::SyscallHandler;\n-use crate::{arch::UserVAddr, result::Result};\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_set_tid_address(&mut self, _uaddr: UserVAddr) -> Result<isize> {\ndiff --git a/kernel/syscalls/stat.rs b/kernel/syscalls/stat.rs\n--- a/kernel/syscalls/stat.rs\n+++ b/kernel/syscalls/stat.rs\n@@ -1,6 +1,7 @@\n use crate::fs::path::Path;\n-use crate::{arch::UserVAddr, result::Result};\n+use crate::result::Result;\n use crate::{process::current_process, syscalls::SyscallHandler};\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_stat(&mut self, path: &Path, buf: UserVAddr) -> Result<isize> {\ndiff --git a/kernel/syscalls/syslog.rs b/kernel/syscalls/syslog.rs\n--- a/kernel/syscalls/syslog.rs\n+++ b/kernel/syscalls/syslog.rs\n@@ -1,10 +1,12 @@\n+use kerla_runtime::address::UserVAddr;\n+\n use crate::{\n     ctypes::c_int,\n-    printk::{KERNEL_LOG_BUF, KERNEL_LOG_BUF_SIZE},\n+    logger::{KERNEL_LOG_BUF, KERNEL_LOG_BUF_SIZE},\n     result::Errno,\n+    result::Result,\n     syscalls::SyscallHandler,\n     user_buffer::UserBufWriter,\n-    {arch::UserVAddr, result::Result},\n };\n \n const SYSLOG_ACTION_READ_ALL: c_int = 3;\ndiff --git a/kernel/syscalls/uname.rs b/kernel/syscalls/uname.rs\n--- a/kernel/syscalls/uname.rs\n+++ b/kernel/syscalls/uname.rs\n@@ -1,5 +1,6 @@\n+use crate::result::Result;\n use crate::syscalls::SyscallHandler;\n-use crate::{arch::UserVAddr, result::Result};\n+use kerla_runtime::address::UserVAddr;\n \n use crate::user_buffer::UserBufWriter;\n \ndiff --git a/kernel/syscalls/utimes.rs b/kernel/syscalls/utimes.rs\n--- a/kernel/syscalls/utimes.rs\n+++ b/kernel/syscalls/utimes.rs\n@@ -1,4 +1,5 @@\n-use crate::arch::UserVAddr;\n+use kerla_runtime::address::UserVAddr;\n+\n use crate::fs::path::Path;\n use crate::prelude::*;\n use crate::{process::current_process, syscalls::SyscallHandler};\ndiff --git a/kernel/syscalls/wait4.rs b/kernel/syscalls/wait4.rs\n--- a/kernel/syscalls/wait4.rs\n+++ b/kernel/syscalls/wait4.rs\n@@ -1,5 +1,4 @@\n use crate::{\n-    arch::UserVAddr,\n     ctypes::*,\n     prelude::*,\n     process::{current_process, PId, ProcessState, JOIN_WAIT_QUEUE},\ndiff --git a/kernel/syscalls/wait4.rs b/kernel/syscalls/wait4.rs\n--- a/kernel/syscalls/wait4.rs\n+++ b/kernel/syscalls/wait4.rs\n@@ -7,6 +6,7 @@ use crate::{\n };\n \n use bitflags::bitflags;\n+use kerla_runtime::address::UserVAddr;\n \n bitflags! {\n     pub struct WaitOptions: c_int {\ndiff --git a/kernel/syscalls/write.rs b/kernel/syscalls/write.rs\n--- a/kernel/syscalls/write.rs\n+++ b/kernel/syscalls/write.rs\n@@ -1,8 +1,9 @@\n use super::MAX_READ_WRITE_LEN;\n use crate::prelude::*;\n-use crate::{arch::UserVAddr, fs::opened_file::Fd, user_buffer::UserBuffer};\n+use crate::{fs::opened_file::Fd, user_buffer::UserBuffer};\n use crate::{process::current_process, syscalls::SyscallHandler};\n use core::cmp::min;\n+use kerla_runtime::address::UserVAddr;\n \n impl<'a> SyscallHandler<'a> {\n     pub fn sys_write(&mut self, fd: Fd, uaddr: UserVAddr, len: usize) -> Result<isize> {\ndiff --git a/kernel/syscalls/writev.rs b/kernel/syscalls/writev.rs\n--- a/kernel/syscalls/writev.rs\n+++ b/kernel/syscalls/writev.rs\n@@ -1,8 +1,9 @@\n use super::{IoVec, IOV_MAX, MAX_READ_WRITE_LEN};\n use crate::prelude::*;\n-use crate::{arch::UserVAddr, fs::opened_file::Fd, user_buffer::UserBuffer};\n+use crate::{fs::opened_file::Fd, user_buffer::UserBuffer};\n use crate::{process::current_process, syscalls::SyscallHandler};\n use core::cmp::min;\n+use kerla_runtime::address::UserVAddr;\n \n use core::mem::size_of;\n \ndiff --git a/kernel/timer.rs b/kernel/timer.rs\n--- a/kernel/timer.rs\n+++ b/kernel/timer.rs\n@@ -1,10 +1,10 @@\n use crate::{\n-    arch::{SpinLock, TICK_HZ},\n     ctypes::*,\n     prelude::*,\n     process::{self, current_process, Process, ProcessState},\n };\n use core::sync::atomic::{AtomicUsize, Ordering};\n+use kerla_runtime::{arch::TICK_HZ, spinlock::SpinLock};\n use process::switch;\n \n const PREEMPT_PER_TICKS: usize = 30;\ndiff --git a/kernel/tty/line_discipline.rs b/kernel/tty/line_discipline.rs\n--- a/kernel/tty/line_discipline.rs\n+++ b/kernel/tty/line_discipline.rs\n@@ -1,12 +1,12 @@\n //! Line discipline.\n \n use crate::{\n-    arch::SpinLock,\n     prelude::*,\n     process::{current_process, process_group::ProcessGroup, signal::SIGINT, WaitQueue},\n     user_buffer::{UserBufReader, UserBufWriter, UserBuffer, UserBufferMut},\n };\n use bitflags::bitflags;\n+use kerla_runtime::spinlock::SpinLock;\n use kerla_utils::ring_buffer::RingBuffer;\n \n bitflags! {\ndiff --git a/kernel/tty/pty.rs b/kernel/tty/pty.rs\n--- a/kernel/tty/pty.rs\n+++ b/kernel/tty/pty.rs\n@@ -4,10 +4,10 @@ use core::{cmp::min, fmt};\n \n use alloc::sync::Arc;\n use alloc::vec::Vec;\n+use kerla_runtime::spinlock::SpinLock;\n use kerla_utils::id_table::IdTable;\n \n use crate::{\n-    arch::SpinLock,\n     fs::{\n         inode::{FileLike, INodeNo, PollStatus},\n         opened_file::OpenOptions,\ndiff --git a/kernel/user_buffer.rs b/kernel/user_buffer.rs\n--- a/kernel/user_buffer.rs\n+++ b/kernel/user_buffer.rs\n@@ -1,7 +1,7 @@\n //! User pointers.\n-use crate::arch::UserVAddr;\n use crate::prelude::*;\n use core::{cmp::min, mem::size_of, slice};\n+use kerla_runtime::address::UserVAddr;\n use kerla_utils::alignment::align_up;\n \n /// Parses a bitflags field given from the user. Returns `Result<T>`.\ndiff --git a/libs/kerla_utils/Cargo.toml b/libs/kerla_utils/Cargo.toml\n--- a/libs/kerla_utils/Cargo.toml\n+++ b/libs/kerla_utils/Cargo.toml\n@@ -15,3 +15,4 @@ no_std = []\n \n [dependencies]\n spin = \"0.9.2\"\n+crossbeam = { version = \"0.8.1\", default-features = false }\ndiff --git a/libs/kerla_utils/lib.rs b/libs/kerla_utils/lib.rs\n--- a/libs/kerla_utils/lib.rs\n+++ b/libs/kerla_utils/lib.rs\n@@ -1,6 +1,7 @@\n #![cfg_attr(feature = \"no_std\", no_std)]\n #![feature(slice_internals)]\n #![feature(const_maybe_uninit_assume_init)]\n+#![feature(const_fn_trait_bound)]\n #![allow(unused)]\n \n #[cfg(not(feature = \"no_std\"))]\ndiff --git a/libs/kerla_utils/lib.rs b/libs/kerla_utils/lib.rs\n--- a/libs/kerla_utils/lib.rs\n+++ b/libs/kerla_utils/lib.rs\n@@ -21,3 +22,4 @@ pub mod id_table;\n pub mod lazy;\n pub mod once;\n pub mod ring_buffer;\n+pub mod static_cell;\ndiff --git /dev/null b/libs/kerla_utils/static_cell.rs\nnew file mode 100644\n--- /dev/null\n+++ b/libs/kerla_utils/static_cell.rs\n@@ -0,0 +1,30 @@\n+//! A thread-safe and almost readonly cell.\n+//!\n+//! Currently it is just a wrapper of AtomicCell, but we may optimize it to\n+//! eliminate atomic operations in reading.\n+use core::ops::Deref;\n+\n+use crossbeam::atomic::AtomicCell;\n+\n+pub struct StaticCell<T: Copy> {\n+    value: AtomicCell<T>,\n+}\n+\n+impl<T: Copy> StaticCell<T> {\n+    pub const fn new(value: T) -> StaticCell<T> {\n+        StaticCell {\n+            value: AtomicCell::new(value),\n+        }\n+    }\n+\n+    pub fn store(&self, value: T) {\n+        self.value.store(value)\n+    }\n+\n+    pub fn load(&self) -> T {\n+        // TODO: Stop using AtomicCell: avoid using atomic operations.\n+        self.value.load()\n+    }\n+}\n+\n+// TODO: Implement Deref for StaticCell<&'static T>\ndiff --git /dev/null b/runtime/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/runtime/Cargo.toml\n@@ -0,0 +1,25 @@\n+[package]\n+name = \"kerla_runtime\"\n+description = \"An OS-agnostic bootstrap and runtime support library for kernels.\"\n+version = \"0.0.4\"\n+authors = [\"Seiya Nuta <nuta@seiya.me>\"]\n+edition = \"2018\"\n+\n+[lib]\n+name = \"kerla_runtime\"\n+path = \"lib.rs\"\n+\n+[dependencies]\n+log = \"0.4\"\n+cfg-if = \"1\"\n+arrayvec = { version = \"0.7.2\", default-features = false }\n+bitflags = \"1.3.2\"\n+atomic_refcell = \"0.1.6\"\n+spin = \"0.9.2\"\n+buddy_system_allocator = { version = \"0.8.0\", features = [\"const_fn\"] }\n+\n+# x64-specific dependencies.\n+x86 = \"0.43.0\"\n+vte = \"0.10\"\n+\n+kerla_utils = { path = \"../libs/kerla_utils\", features = [\"no_std\"] }\ndiff --git a/kernel/arch/x64/address.rs b/runtime/address.rs\n--- a/kernel/arch/x64/address.rs\n+++ b/runtime/address.rs\n@@ -1,7 +1,8 @@\n-use crate::{\n-    process::current_process,\n-    result::{Errno, Error, Result},\n-};\n+use crate::arch::{KERNEL_BASE_ADDR, KERNEL_STRAIGHT_MAP_PADDR_END};\n+\n+#[cfg(debug_assertions)]\n+use crate::handler;\n+\n use core::{\n     fmt,\n     mem::{size_of, MaybeUninit},\ndiff --git a/kernel/arch/x64/address.rs b/runtime/address.rs\n--- a/kernel/arch/x64/address.rs\n+++ b/runtime/address.rs\n@@ -9,21 +10,14 @@ use core::{\n };\n use kerla_utils::alignment::align_down;\n \n-/// The base virtual address of straight mapping.\n-pub const KERNEL_BASE_ADDR: u64 = 0xffff_8000_0000_0000;\n-\n-/// The end of straight mapping. Any physical address `P` is mapped into the\n-/// kernel's virtual memory address `KERNEL_BASE_ADDR + P`.\n-const KERNEL_STRAIGHT_MAP_PADDR_END: u64 = 0x1_0000_0000;\n-\n /// Represents a physical memory address.\n #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n #[repr(transparent)]\n-pub struct PAddr(u64);\n+pub struct PAddr(usize);\n \n impl PAddr {\n     pub const fn new(addr: usize) -> PAddr {\n-        PAddr(addr as u64)\n+        PAddr(addr)\n     }\n \n     #[inline(always)]\ndiff --git a/kernel/arch/x64/address.rs b/runtime/address.rs\n--- a/kernel/arch/x64/address.rs\n+++ b/runtime/address.rs\n@@ -33,15 +27,15 @@ impl PAddr {\n \n     pub const fn as_vaddr(self) -> VAddr {\n         debug_assert!(self.0 < KERNEL_STRAIGHT_MAP_PADDR_END);\n-        VAddr::new((self.0 + KERNEL_BASE_ADDR) as usize)\n+        VAddr::new(self.0 + KERNEL_BASE_ADDR)\n     }\n \n-    pub const unsafe fn as_ptr<T>(self) -> *const T {\n+    pub const fn as_ptr<T>(self) -> *const T {\n         debug_assert!(self.0 < KERNEL_STRAIGHT_MAP_PADDR_END);\n         (self.0 + KERNEL_BASE_ADDR) as *const _\n     }\n \n-    pub const unsafe fn as_mut_ptr<T>(self) -> *mut T {\n+    pub const fn as_mut_ptr<T>(self) -> *mut T {\n         debug_assert!(self.0 < KERNEL_STRAIGHT_MAP_PADDR_END);\n         (self.0 + KERNEL_BASE_ADDR) as *mut _\n     }\ndiff --git a/kernel/arch/x64/address.rs b/runtime/address.rs\n--- a/kernel/arch/x64/address.rs\n+++ b/runtime/address.rs\n@@ -49,12 +43,12 @@ impl PAddr {\n     #[inline(always)]\n     #[must_use]\n     pub const fn add(self, offset: usize) -> PAddr {\n-        PAddr(self.0 + offset as u64)\n+        PAddr(self.0 + offset)\n     }\n \n     #[inline(always)]\n     pub const fn value(self) -> usize {\n-        self.0 as usize\n+        self.0\n     }\n }\n \ndiff --git a/kernel/arch/x64/address.rs b/runtime/address.rs\n--- a/kernel/arch/x64/address.rs\n+++ b/runtime/address.rs\n@@ -67,38 +61,41 @@ impl fmt::Display for PAddr {\n /// Represents a *kernel* virtual memory address.\n #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n #[repr(transparent)]\n-pub struct VAddr(u64);\n+pub struct VAddr(usize);\n \n impl VAddr {\n     pub const fn new(addr: usize) -> VAddr {\n-        debug_assert!(addr as u64 >= KERNEL_BASE_ADDR);\n-        VAddr(addr as u64)\n+        debug_assert!(addr >= KERNEL_BASE_ADDR);\n+        VAddr(addr)\n     }\n \n     pub const fn as_paddr(self) -> PAddr {\n         debug_assert!(self.0 >= KERNEL_BASE_ADDR);\n-        PAddr::new((self.0 - KERNEL_BASE_ADDR) as usize)\n+        PAddr::new(self.0 - KERNEL_BASE_ADDR)\n     }\n \n     pub const fn is_accessible_from_kernel(addr: usize) -> bool {\n-        (addr as u64) >= KERNEL_BASE_ADDR\n-            && (addr as u64) < KERNEL_BASE_ADDR + KERNEL_STRAIGHT_MAP_PADDR_END\n+        (addr) >= KERNEL_BASE_ADDR && (addr) < KERNEL_BASE_ADDR + KERNEL_STRAIGHT_MAP_PADDR_END\n     }\n \n-    pub const unsafe fn as_ptr<T>(self) -> *const T {\n+    pub const fn as_ptr<T>(self) -> *const T {\n         debug_assert!(self.0 >= KERNEL_BASE_ADDR);\n         self.0 as *const _\n     }\n \n-    pub const unsafe fn as_mut_ptr<T>(self) -> *mut T {\n+    pub const fn as_mut_ptr<T>(self) -> *mut T {\n         debug_assert!(self.0 >= KERNEL_BASE_ADDR);\n         self.0 as *mut _\n     }\n \n+    /// # Safety\n+    /// See <https://doc.rust-lang.org/std/ptr/fn.read_volatile.html>.\n     pub unsafe fn read_volatile<T: Copy>(self) -> T {\n         ptr::read_volatile(self.as_ptr::<T>())\n     }\n \n+    /// # Safety\n+    /// See <https://doc.rust-lang.org/std/ptr/fn.write_volatile.html>.\n     pub unsafe fn write_volatile<T: Copy>(self, value: T) {\n         ptr::write_volatile(self.as_mut_ptr(), value);\n     }\ndiff --git a/kernel/arch/x64/address.rs b/runtime/address.rs\n--- a/kernel/arch/x64/address.rs\n+++ b/runtime/address.rs\n@@ -113,24 +110,24 @@ impl VAddr {\n     #[inline(always)]\n     #[must_use]\n     pub const fn add(self, offset: usize) -> VAddr {\n-        VAddr::new(self.0 as usize + offset)\n+        VAddr::new(self.0 + offset)\n     }\n \n     #[inline(always)]\n     #[must_use]\n     pub const fn sub(self, offset: usize) -> VAddr {\n-        VAddr::new(self.0 as usize - offset)\n+        VAddr::new(self.0 - offset)\n     }\n \n     #[inline(always)]\n     #[must_use]\n     pub const fn align_down(self, alignment: usize) -> VAddr {\n-        VAddr::new(align_down(self.0 as usize, alignment))\n+        VAddr::new(align_down(self.0, alignment))\n     }\n \n     #[inline(always)]\n     pub const fn value(self) -> usize {\n-        self.0 as usize\n+        self.0\n     }\n }\n \ndiff --git a/kernel/arch/x64/address.rs b/runtime/address.rs\n--- a/kernel/arch/x64/address.rs\n+++ b/runtime/address.rs\n@@ -147,12 +144,17 @@ extern \"C\" {\n     fn memset_user(dst: *mut u8, value: u8, len: usize);\n }\n \n-fn ensure_vm_lock_is_unheld() {\n-    // We should not hold the vm lock since we'll try to acquire it in the\n-    // page fault handler when copying caused a page fault.\n-    debug_assert!(!current_process().vm().as_ref().unwrap().is_locked());\n+fn call_usercopy_hook() {\n+    #[cfg(debug_assertions)]\n+    handler().usercopy_hook();\n }\n \n+#[derive(Debug)]\n+pub struct AccessError;\n+\n+#[derive(Debug)]\n+pub struct NullUserPointerError;\n+\n /// Represents a user virtual memory address.\n ///\n /// It is guaranteed that `UserVaddr` contains a valid address, in other words,\ndiff --git a/kernel/arch/x64/address.rs b/runtime/address.rs\n--- a/kernel/arch/x64/address.rs\n+++ b/runtime/address.rs\n@@ -162,44 +164,29 @@ fn ensure_vm_lock_is_unheld() {\n /// represent a nullable user pointer.\n #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n #[repr(transparent)]\n-pub struct UserVAddr(u64);\n+pub struct UserVAddr(usize);\n \n impl UserVAddr {\n-    pub const fn new(addr: usize) -> Result<Option<UserVAddr>> {\n-        if (addr as u64) >= KERNEL_BASE_ADDR {\n-            return Err(Error::with_message_const(\n-                Errno::EFAULT,\n-                \"invalid user pointer\",\n-            ));\n-        }\n-\n+    pub const fn new(addr: usize) -> Option<UserVAddr> {\n         if addr == 0 {\n-            Ok(None)\n+            None\n         } else {\n-            Ok(Some(UserVAddr(addr as u64)))\n+            Some(UserVAddr(addr))\n         }\n     }\n \n-    pub const fn new_nonnull(addr: usize) -> Result<UserVAddr> {\n-        if (addr as u64) >= KERNEL_BASE_ADDR {\n-            return Err(Error::with_message_const(\n-                Errno::EFAULT,\n-                \"invalid user pointer\",\n-            ));\n-        }\n-\n-        if addr == 0 {\n-            return Err(Error::with_message_const(\n-                Errno::EFAULT,\n-                \"null user pointer\",\n-            ));\n+    pub const fn new_nonnull(addr: usize) -> Result<UserVAddr, NullUserPointerError> {\n+        match UserVAddr::new(addr) {\n+            Some(uaddr) => Ok(uaddr),\n+            None => Err(NullUserPointerError),\n         }\n-\n-        Ok(UserVAddr(addr as u64))\n     }\n \n+    /// # Safety\n+    /// Make sure `addr` doesn't point to the kernel memory address or it can\n+    /// lead to a serious vulnerability!\n     pub const unsafe fn new_unchecked(addr: usize) -> UserVAddr {\n-        UserVAddr(addr as u64)\n+        UserVAddr(addr)\n     }\n \n     #[inline(always)]\ndiff --git a/kernel/arch/x64/address.rs b/runtime/address.rs\n--- a/kernel/arch/x64/address.rs\n+++ b/runtime/address.rs\n@@ -211,34 +198,29 @@ impl UserVAddr {\n \n     #[inline(always)]\n     pub const fn add(self, offset: usize) -> UserVAddr {\n-        unsafe { UserVAddr::new_unchecked(self.0 as usize + offset) }\n+        unsafe { UserVAddr::new_unchecked(self.0 + offset) }\n     }\n \n     #[inline(always)]\n     pub const fn sub(self, offset: usize) -> UserVAddr {\n-        unsafe { UserVAddr::new_unchecked(self.0 as usize - offset) }\n+        unsafe { UserVAddr::new_unchecked(self.0 - offset) }\n     }\n \n     #[inline(always)]\n     pub const fn value(self) -> usize {\n-        self.0 as usize\n+        self.0\n     }\n \n-    pub fn access_ok(self, len: usize) -> Result<()> {\n+    pub fn access_ok(self, len: usize) -> Result<(), AccessError> {\n         match self.value().checked_add(len) {\n-            Some(end) if end <= KERNEL_BASE_ADDR as usize => Ok(()),\n-            Some(_end) => Err(Error::with_message_const(\n-                Errno::EFAULT,\n-                \"invalid user pointer\",\n-            )),\n-            None => Err(Error::with_message_const(\n-                Errno::EFAULT,\n-                \"overflow in access_ok\",\n-            )),\n+            Some(end) if end <= KERNEL_BASE_ADDR => Ok(()),\n+            Some(_end) => Err(AccessError),\n+            // Overflow.\n+            None => Err(AccessError),\n         }\n     }\n \n-    pub fn read<T>(self) -> Result<T> {\n+    pub fn read<T>(self) -> Result<T, AccessError> {\n         let mut buf: MaybeUninit<T> = MaybeUninit::uninit();\n         self.read_bytes(unsafe {\n             slice::from_raw_parts_mut(buf.as_mut_ptr() as *mut u8, size_of::<T>())\ndiff --git a/kernel/arch/x64/address.rs b/runtime/address.rs\n--- a/kernel/arch/x64/address.rs\n+++ b/runtime/address.rs\n@@ -246,8 +228,8 @@ impl UserVAddr {\n         Ok(unsafe { buf.assume_init() })\n     }\n \n-    pub fn read_bytes(self, buf: &mut [u8]) -> Result<()> {\n-        ensure_vm_lock_is_unheld();\n+    pub fn read_bytes(self, buf: &mut [u8]) -> Result<(), AccessError> {\n+        call_usercopy_hook();\n         self.access_ok(buf.len())?;\n         unsafe {\n             copy_from_user(buf.as_mut_ptr(), self.value() as *const u8, buf.len());\ndiff --git a/kernel/arch/x64/address.rs b/runtime/address.rs\n--- a/kernel/arch/x64/address.rs\n+++ b/runtime/address.rs\n@@ -259,22 +241,22 @@ impl UserVAddr {\n     /// excluding the NUL character.\n     ///\n     /// Unlike strcnpy, **`dst` is NOT terminated by NULL**.\n-    pub fn read_cstr(self, buf: &mut [u8]) -> Result<usize> {\n-        ensure_vm_lock_is_unheld();\n+    pub fn read_cstr(self, buf: &mut [u8]) -> Result<usize, AccessError> {\n+        call_usercopy_hook();\n         self.access_ok(buf.len())?;\n         let read_len =\n             unsafe { strncpy_from_user(buf.as_mut_ptr(), self.value() as *const u8, buf.len()) };\n         Ok(read_len)\n     }\n \n-    pub fn write<T>(self, buf: &T) -> Result<usize> {\n+    pub fn write<T>(self, buf: &T) -> Result<usize, AccessError> {\n         let len = size_of::<T>();\n         self.write_bytes(unsafe { slice::from_raw_parts(buf as *const T as *const u8, len) })?;\n         Ok(len)\n     }\n \n-    pub fn write_bytes(self, buf: &[u8]) -> Result<usize> {\n-        ensure_vm_lock_is_unheld();\n+    pub fn write_bytes(self, buf: &[u8]) -> Result<usize, AccessError> {\n+        call_usercopy_hook();\n         self.access_ok(buf.len())?;\n         unsafe {\n             copy_to_user(self.value() as *mut u8, buf.as_ptr(), buf.len());\ndiff --git a/kernel/arch/x64/address.rs b/runtime/address.rs\n--- a/kernel/arch/x64/address.rs\n+++ b/runtime/address.rs\n@@ -282,8 +264,8 @@ impl UserVAddr {\n         Ok(buf.len())\n     }\n \n-    pub fn fill(self, value: u8, len: usize) -> Result<usize> {\n-        ensure_vm_lock_is_unheld();\n+    pub fn fill(self, value: u8, len: usize) -> Result<usize, AccessError> {\n+        call_usercopy_hook();\n         self.access_ok(len)?;\n         unsafe {\n             memset_user(self.value() as *mut u8, value, len);\ndiff --git /dev/null b/runtime/backtrace.rs\nnew file mode 100644\n--- /dev/null\n+++ b/runtime/backtrace.rs\n@@ -0,0 +1,141 @@\n+use core::{fmt, mem::size_of, slice, str};\n+\n+use alloc::boxed::Box;\n+use arrayvec::ArrayVec;\n+\n+use crate::{address::VAddr, arch::Backtrace};\n+\n+/// A symbol.\n+#[repr(C, packed)]\n+struct SymbolEntry {\n+    addr: u64,\n+    name: [u8; 56],\n+}\n+\n+#[repr(C, packed)]\n+struct SymbolTable {\n+    magic: u32,\n+    num_symbols: i32,\n+    padding: u64,\n+}\n+\n+extern \"C\" {\n+    static __symbol_table: SymbolTable;\n+}\n+\n+global_asm!(\n+    r#\"\n+    .rodata\n+    .align 8\n+    .global __symbol_table\n+    __symbol_table:\n+       .ascii \"__SYMBOL_TABLE_START__\"\n+       .space 2 * 1024 * 1024\n+       .ascii \"__SYMBOL_TABLE_END__\"\n+\"#\n+);\n+\n+struct Symbol {\n+    name: &'static str,\n+    addr: VAddr,\n+}\n+\n+fn resolve_symbol(vaddr: VAddr) -> Option<Symbol> {\n+    assert!(unsafe { __symbol_table.magic } == 0xbeefbeef);\n+\n+    let num_symbols = unsafe { __symbol_table.num_symbols };\n+    let symbols = unsafe {\n+        slice::from_raw_parts(\n+            ((&__symbol_table as *const _ as usize) + size_of::<SymbolTable>())\n+                as *const SymbolEntry,\n+            __symbol_table.num_symbols as usize,\n+        )\n+    };\n+\n+    // Do a binary search.\n+    let mut l = -1;\n+    let mut r = num_symbols;\n+    while r - l > 1 {\n+        let mid = (l + r) / 2;\n+        if vaddr.value() >= symbols[mid as usize].addr as usize {\n+            l = mid;\n+        } else {\n+            r = mid;\n+        }\n+    }\n+\n+    if l >= 0 {\n+        let symbol = &symbols[l as usize];\n+        Some(Symbol {\n+            name: unsafe { str::from_utf8_unchecked(&symbol.name) },\n+            addr: VAddr::new(symbol.addr as usize),\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Prints a backtrace.\n+pub fn backtrace() {\n+    Backtrace::current_frame().traverse(|i, vaddr| {\n+        if let Some(symbol) = resolve_symbol(vaddr) {\n+            warn!(\n+                \"    {index}: {vaddr} {symbol_name}()+0x{offset:x}\",\n+                index = i,\n+                vaddr = vaddr,\n+                symbol_name = symbol.name,\n+                offset = vaddr.value() - symbol.addr.value(),\n+            );\n+        } else {\n+            warn!(\n+                \"    {index}: {vaddr} (symbol unknown)\",\n+                index = i,\n+                vaddr = vaddr,\n+            );\n+        }\n+    });\n+}\n+\n+pub struct CapturedBacktraceFrame {\n+    pub vaddr: VAddr,\n+    pub offset: usize,\n+    pub symbol_name: &'static str,\n+}\n+\n+pub struct CapturedBacktrace {\n+    pub trace: Box<ArrayVec<CapturedBacktraceFrame, 8>>,\n+}\n+\n+impl CapturedBacktrace {\n+    /// Returns a saved backtrace.\n+    pub fn capture() -> CapturedBacktrace {\n+        let mut trace = Box::new(ArrayVec::new());\n+        Backtrace::current_frame().traverse(|_, vaddr| {\n+            if let Some(symbol) = resolve_symbol(vaddr) {\n+                let _ = trace.try_push(CapturedBacktraceFrame {\n+                    vaddr,\n+                    symbol_name: symbol.name,\n+                    offset: vaddr.value() - symbol.addr.value(),\n+                });\n+            }\n+        });\n+        CapturedBacktrace { trace }\n+    }\n+}\n+\n+impl fmt::Debug for CapturedBacktrace {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        for (i, frame) in self.trace.iter().enumerate() {\n+            let _ = writeln!(\n+                f,\n+                \"    #{}: {} {}()+0x{:x}\",\n+                i + 1,\n+                frame.vaddr,\n+                frame.symbol_name,\n+                frame.offset\n+            );\n+        }\n+\n+        Ok(())\n+    }\n+}\ndiff --git /dev/null b/runtime/bootinfo.rs\nnew file mode 100644\n--- /dev/null\n+++ b/runtime/bootinfo.rs\n@@ -0,0 +1,19 @@\n+use arrayvec::ArrayVec;\n+\n+use crate::address::PAddr;\n+\n+pub struct RamArea {\n+    pub base: PAddr,\n+    pub len: usize,\n+}\n+\n+pub struct VirtioMmioDevice {\n+    pub mmio_base: PAddr,\n+    pub irq: u8,\n+}\n+\n+pub struct BootInfo {\n+    pub ram_areas: ArrayVec<RamArea, 8>,\n+    pub virtio_mmio_devices: ArrayVec<VirtioMmioDevice, 4>,\n+    pub pci_enabled: bool,\n+}\ndiff --git /dev/null b/runtime/global_allocator.rs\nnew file mode 100644\n--- /dev/null\n+++ b/runtime/global_allocator.rs\n@@ -0,0 +1,41 @@\n+use core::alloc::Layout;\n+use core::sync::atomic::{AtomicBool, Ordering};\n+\n+use buddy_system_allocator::{Heap, LockedHeapWithRescue};\n+use kerla_utils::alignment::align_up;\n+\n+use crate::arch::PAGE_SIZE;\n+use crate::page_allocator::{alloc_pages, AllocPageFlags};\n+\n+const ORDER: usize = 32;\n+const KERNEL_HEAP_CHUNK_SIZE: usize = 1024 * 1024; // 1MiB\n+\n+#[global_allocator]\n+static ALLOCATOR: LockedHeapWithRescue<ORDER> = LockedHeapWithRescue::new(expand_kernel_heap);\n+static KERNEL_HEAP_ENABLED: AtomicBool = AtomicBool::new(false);\n+\n+pub fn is_kernel_heap_enabled() -> bool {\n+    KERNEL_HEAP_ENABLED.load(Ordering::Acquire)\n+}\n+\n+fn expand_kernel_heap(heap: &mut Heap<ORDER>, layout: &Layout) {\n+    if layout.size() > KERNEL_HEAP_CHUNK_SIZE {\n+        panic!(\n+            \"tried to allocate too large object in the kernel heap (requested {} bytes)\",\n+            layout.size()\n+        );\n+    }\n+\n+    let num_pages = align_up(KERNEL_HEAP_CHUNK_SIZE, PAGE_SIZE) / PAGE_SIZE;\n+    let start = alloc_pages(num_pages, AllocPageFlags::KERNEL)\n+        .expect(\"run out of memory: failed to expand the kernel heap\")\n+        .as_vaddr()\n+        .value();\n+    let end = start + KERNEL_HEAP_CHUNK_SIZE;\n+\n+    unsafe {\n+        heap.add_to_heap(start, end);\n+    }\n+\n+    KERNEL_HEAP_ENABLED.store(true, Ordering::Release)\n+}\ndiff --git /dev/null b/runtime/lib.rs\nnew file mode 100644\n--- /dev/null\n+++ b/runtime/lib.rs\n@@ -0,0 +1,103 @@\n+//! An OS-agnostic bootstrap and runtime support library for operating system\n+//! kernels.\n+#![no_std]\n+#![feature(asm)]\n+#![feature(global_asm)]\n+\n+extern crate alloc;\n+\n+#[macro_use]\n+extern crate log;\n+\n+#[macro_use]\n+pub mod print;\n+\n+pub mod address;\n+pub mod backtrace;\n+pub mod bootinfo;\n+pub mod global_allocator;\n+pub mod logger;\n+pub mod page_allocator;\n+pub mod profile;\n+pub mod spinlock;\n+\n+mod x64;\n+\n+pub mod arch {\n+    pub use super::x64::{\n+        console_write, enable_irq, halt, idle, read_clock_counter, semihosting_halt, x64_specific,\n+        Backtrace, PageFaultReason, PageTable, SavedInterruptStatus, SemihostingExitStatus,\n+        SyscallFrame, KERNEL_BASE_ADDR, KERNEL_STRAIGHT_MAP_PADDR_END, PAGE_SIZE, TICK_HZ,\n+    };\n+}\n+\n+use address::UserVAddr;\n+use kerla_utils::static_cell::StaticCell;\n+\n+pub trait Handler: Sync {\n+    fn handle_console_rx(&self, char: u8);\n+    fn handle_irq(&self, irq: u8);\n+    fn handle_timer_irq(&self);\n+    fn handle_page_fault(\n+        &self,\n+        unaligned_vaddr: Option<UserVAddr>,\n+        ip: usize,\n+        _reason: arch::PageFaultReason,\n+    );\n+\n+    #[allow(clippy::too_many_arguments)]\n+    fn handle_syscall(\n+        &self,\n+        a1: usize,\n+        a2: usize,\n+        a3: usize,\n+        a4: usize,\n+        a5: usize,\n+        a6: usize,\n+        n: usize,\n+        frame: *mut arch::SyscallFrame,\n+    ) -> isize;\n+\n+    #[cfg(debug_assertions)]\n+    fn usercopy_hook(&self) {}\n+}\n+\n+static HANDLER: StaticCell<&dyn Handler> = StaticCell::new(&NopHandler);\n+\n+struct NopHandler;\n+\n+impl Handler for NopHandler {\n+    fn handle_console_rx(&self, _char: u8) {}\n+    fn handle_irq(&self, _irq: u8) {}\n+    fn handle_timer_irq(&self) {}\n+\n+    fn handle_page_fault(\n+        &self,\n+        _unaligned_vaddr: Option<UserVAddr>,\n+        _ip: usize,\n+        _reason: arch::PageFaultReason,\n+    ) {\n+    }\n+\n+    fn handle_syscall(\n+        &self,\n+        _a1: usize,\n+        _a2: usize,\n+        _a3: usize,\n+        _a4: usize,\n+        _a5: usize,\n+        _a6: usize,\n+        _n: usize,\n+        _frame: *mut x64::SyscallFrame,\n+    ) -> isize {\n+        0\n+    }\n+}\n+\n+fn handler() -> &'static dyn Handler {\n+    HANDLER.load()\n+}\n+\n+pub fn set_handler(handler: &'static dyn Handler) {\n+    HANDLER.store(handler);\n+}\ndiff --git /dev/null b/runtime/logger.rs\nnew file mode 100644\n--- /dev/null\n+++ b/runtime/logger.rs\n@@ -0,0 +1,49 @@\n+struct Logger;\n+\n+impl log::Log for Logger {\n+    fn enabled(&self, metadata: &log::Metadata) -> bool {\n+        if cfg!(debug_assertions) {\n+            true\n+        } else {\n+            metadata.level() <= log::Level::Info\n+        }\n+    }\n+\n+    fn log(&self, record: &log::Record) {\n+        use log::Level;\n+        const RESET: &str = \"\\x1b[0m\";\n+        const INFO_COLOR: &str = \"\\x1b[36m\";\n+        const WARN_COLOR: &str = \"\\x1b[33m\";\n+        const ERROR_COLOR: &str = \"\\x1b[1;31m\";\n+\n+        if self.enabled(record.metadata()) {\n+            match record.level() {\n+                Level::Trace | Level::Debug => {\n+                    println!(\"{}\", record.args());\n+                }\n+                Level::Info => {\n+                    println!(\"{}{}{}\", INFO_COLOR, record.args(), RESET);\n+                }\n+                Level::Warn => {\n+                    println!(\"{}{}{}\", WARN_COLOR, record.args(), RESET);\n+                }\n+                Level::Error => {\n+                    println!(\"{}{}{}\", ERROR_COLOR, record.args(), RESET);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn flush(&self) {}\n+}\n+\n+static LOGGER: Logger = Logger;\n+\n+pub(crate) fn init() {\n+    log::set_logger(&LOGGER).unwrap();\n+    log::set_max_level(if cfg!(debug_assertions) {\n+        log::LevelFilter::Trace\n+    } else {\n+        log::LevelFilter::Info\n+    });\n+}\ndiff --git a/kernel/mm/page_allocator.rs b/runtime/page_allocator.rs\n--- a/kernel/mm/page_allocator.rs\n+++ b/runtime/page_allocator.rs\n@@ -1,8 +1,4 @@\n-use crate::{\n-    arch::{PAddr, SpinLock, PAGE_SIZE},\n-    boot::RamArea,\n-    result::{Errno, Result},\n-};\n+use crate::{address::PAddr, arch::PAGE_SIZE, bootinfo::RamArea, spinlock::SpinLock};\n use arrayvec::ArrayVec;\n use bitflags::bitflags;\n use kerla_utils::bump_allocator::BumpAllocator as Allocator;\ndiff --git a/kernel/mm/page_allocator.rs b/runtime/page_allocator.rs\n--- a/kernel/mm/page_allocator.rs\n+++ b/runtime/page_allocator.rs\n@@ -38,7 +34,10 @@ bitflags! {\n     }\n }\n \n-pub fn alloc_pages(num_pages: usize, flags: AllocPageFlags) -> Result<PAddr> {\n+#[derive(Debug)]\n+pub struct PageAllocError;\n+\n+pub fn alloc_pages(num_pages: usize, flags: AllocPageFlags) -> Result<PAddr, PageAllocError> {\n     let order = num_pages_to_order(num_pages);\n     let mut zones = ZONES.lock();\n     for i in 0..zones.len() {\ndiff --git a/kernel/mm/page_allocator.rs b/runtime/page_allocator.rs\n--- a/kernel/mm/page_allocator.rs\n+++ b/runtime/page_allocator.rs\n@@ -54,7 +53,7 @@ pub fn alloc_pages(num_pages: usize, flags: AllocPageFlags) -> Result<PAddr> {\n         }\n     }\n \n-    Err(Errno::ENOMEM.into())\n+    Err(PageAllocError)\n }\n \n pub fn init(areas: &[RamArea]) {\ndiff --git a/kernel/mm/page_allocator.rs b/runtime/page_allocator.rs\n--- a/kernel/mm/page_allocator.rs\n+++ b/runtime/page_allocator.rs\n@@ -67,7 +66,7 @@ pub fn init(areas: &[RamArea]) {\n         );\n \n         zones.push(Allocator::new(\n-            unsafe { area.base.as_mut_ptr() },\n+            area.base.as_mut_ptr(),\n             area.base.value(),\n             area.len,\n         ));\ndiff --git /dev/null b/runtime/print.rs\nnew file mode 100644\n--- /dev/null\n+++ b/runtime/print.rs\n@@ -0,0 +1,151 @@\n+use core::{fmt, str};\n+\n+use kerla_utils::static_cell::StaticCell;\n+\n+static PRINTER: StaticCell<&dyn Printer> = StaticCell::new(&NopPrinter);\n+\n+/// Sets the global log printer.\n+pub fn set_printer(new_printer: &'static dyn Printer) {\n+    PRINTER.store(new_printer);\n+}\n+\n+pub trait Printer: Sync {\n+    fn print_str(&self, s: &str) {\n+        self.print_bytes(s.as_bytes());\n+    }\n+\n+    fn print_bytes(&self, s: &[u8]);\n+}\n+\n+struct NopPrinter;\n+\n+impl Printer for NopPrinter {\n+    fn print_bytes(&self, _s: &[u8]) {\n+        // Because the panic handler cannot use the printer, we have no way\n+        // to print a message. Use a debugger to check whether CPU reached here.\n+    }\n+}\n+\n+/// A private struct internally used in print macros. Don't use this!\n+pub struct PrinterWrapper;\n+\n+impl fmt::Write for PrinterWrapper {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        print_bytes(s.as_bytes());\n+        Ok(())\n+    }\n+}\n+\n+pub fn print_bytes(s: &[u8]) {\n+    PRINTER.load().print_bytes(s);\n+}\n+\n+/// Prints a string.\n+#[macro_export]\n+macro_rules! print {\n+    ($($arg:tt)*) => {{\n+        #![allow(unused_imports)]\n+        use core::fmt::Write;\n+        write!($crate::print::PrinterWrapper, \"{}\", format_args!($($arg)*)).ok();\n+    }};\n+}\n+\n+/// Prints a string and a newline.\n+#[macro_export]\n+macro_rules! println {\n+    () => {{\n+        $crate::print!(\n+            \"\"\n+        );\n+    }};\n+    ($fmt:expr) => {{\n+        $crate::print!(\n+            $fmt\n+        );\n+    }};\n+    ($fmt:expr, $($arg:tt)*) => {{\n+        $crate::print!(\n+            concat!( $fmt, \"\\n\"),\n+            $($arg)*\n+        );\n+    }};\n+}\n+\n+/// Prints a warning message only in the debug build.\n+#[macro_export]\n+macro_rules! debug_warn {\n+    ($fmt:expr) => {\n+        #[cfg(debug_assertions)]\n+        $crate::println!(concat!(\"\\x1b[1;33mWARN: \", $fmt, \"\\x1b[0m\"));\n+    };\n+    ($fmt:expr, $($arg:tt)*) => {\n+        #[cfg(debug_assertions)]\n+        $crate::println!(concat!(\"\\x1b[1;33mWARN: \", $fmt, \"\\x1b[0m\"), $($arg)*);\n+    };\n+}\n+\n+/// Prints a warning message only once.\n+#[macro_export]\n+macro_rules! warn_once {\n+    ($fmt:expr) => {{\n+        static ONCE: ::spin::Once<()> = ::spin::Once::new();\n+        ONCE.call_once(|| {\n+            $crate::println!(concat!(\"\\x1b[1;33mWARN: \", $fmt, \"\\x1b[0m\"));\n+        });\n+    }};\n+    ($fmt:expr, $($arg:tt)*) => {{\n+        static ONCE: ::spin::Once<()> = ::spin::Once::new();\n+        ONCE.call_once(|| {\n+            $crate::println!(concat!(\"\\x1b[1;33mWARN: \", $fmt, \"\\x1b[0m\"), $($arg)*);\n+        });\n+    }};\n+}\n+\n+/// Prints a warning message if it is `Err`.\n+#[macro_export]\n+macro_rules! warn_if_err {\n+    ($result:expr) => {\n+        #[cfg(debug_assertions)]\n+        if let Err(err) = $result {\n+            $crate::debug_warn!(\"{}:{}: error returned: {:?}\", file!(), line!(), err);\n+        }\n+    };\n+}\n+\n+pub struct PrintkPrinter;\n+impl log::Log for PrintkPrinter {\n+    fn enabled(&self, metadata: &log::Metadata) -> bool {\n+        if cfg!(debug_assertions) {\n+            true\n+        } else {\n+            metadata.level() <= log::Level::Info\n+        }\n+    }\n+\n+    fn log(&self, record: &log::Record) {\n+        use log::Level;\n+        const RESET: &str = \"\\x1b[0m\";\n+        const INFO_COLOR: &str = \"\\x1b[36m\";\n+        const WARN_COLOR: &str = \"\\x1b[33m\";\n+        const ERROR_COLOR: &str = \"\\x1b[1;31m\";\n+\n+        if self.enabled(record.metadata()) {\n+            match record.level() {\n+                Level::Trace | Level::Debug => {\n+                    println!(\"{}\", record.args());\n+                }\n+                Level::Info => {\n+                    println!(\"{}{}{}\", INFO_COLOR, record.args(), RESET);\n+                }\n+                Level::Warn => {\n+                    println!(\"{}{}{}\", WARN_COLOR, record.args(), RESET);\n+                }\n+                Level::Error => {\n+                    println!(\"{}{}{}\", ERROR_COLOR, record.args(), RESET);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn flush(&self) {}\n+}\ndiff --git a/kernel/arch/x64/lock.rs b/runtime/spinlock.rs\n--- a/kernel/arch/x64/lock.rs\n+++ b/runtime/spinlock.rs\n@@ -1,11 +1,16 @@\n-use atomic_refcell::AtomicRefCell;\n use cfg_if::cfg_if;\n use core::mem::ManuallyDrop;\n use core::ops::{Deref, DerefMut};\n-use x86::current::rflags::{self, RFlags};\n \n-use crate::mm::global_allocator::is_kernel_heap_enabled;\n-use crate::printk::{backtrace, capture_backtrace, CapturedBacktrace};\n+use crate::arch::SavedInterruptStatus;\n+use crate::backtrace::backtrace;\n+\n+#[cfg(debug_assertions)]\n+use crate::backtrace::CapturedBacktrace;\n+#[cfg(debug_assertions)]\n+use crate::global_allocator::is_kernel_heap_enabled;\n+#[cfg(debug_assertions)]\n+use atomic_refcell::AtomicRefCell;\n \n pub struct SpinLock<T: ?Sized> {\n     #[cfg(debug_assertions)]\ndiff --git a/kernel/arch/x64/lock.rs b/runtime/spinlock.rs\n--- a/kernel/arch/x64/lock.rs\n+++ b/runtime/spinlock.rs\n@@ -51,7 +56,7 @@ impl<T: ?Sized> SpinLock<T> {\n             backtrace();\n         }\n \n-        let rflags = rflags::read();\n+        let saved_intr_status = SavedInterruptStatus::save();\n         unsafe {\n             asm!(\"cli\");\n         }\ndiff --git a/kernel/arch/x64/lock.rs b/runtime/spinlock.rs\n--- a/kernel/arch/x64/lock.rs\n+++ b/runtime/spinlock.rs\n@@ -60,12 +65,12 @@ impl<T: ?Sized> SpinLock<T> {\n \n         #[cfg(debug_assertions)]\n         if is_kernel_heap_enabled() {\n-            *self.locked_by.borrow_mut() = Some(capture_backtrace());\n+            *self.locked_by.borrow_mut() = Some(CapturedBacktrace::capture());\n         }\n \n         SpinLockGuard {\n             inner: ManuallyDrop::new(guard),\n-            rflags,\n+            saved_intr_status: ManuallyDrop::new(saved_intr_status),\n             #[cfg(debug_assertions)]\n             locked_by: &self.locked_by,\n         }\ndiff --git a/kernel/arch/x64/lock.rs b/runtime/spinlock.rs\n--- a/kernel/arch/x64/lock.rs\n+++ b/runtime/spinlock.rs\n@@ -83,14 +88,13 @@ pub struct SpinLockGuard<'a, T: ?Sized> {\n     inner: ManuallyDrop<spin::mutex::SpinMutexGuard<'a, T>>,\n     #[cfg(debug_assertions)]\n     locked_by: &'a AtomicRefCell<Option<CapturedBacktrace>>,\n-    rflags: RFlags,\n+    saved_intr_status: ManuallyDrop<SavedInterruptStatus>,\n }\n \n impl<'a, T: ?Sized> Drop for SpinLockGuard<'a, T> {\n     fn drop(&mut self) {\n         unsafe {\n             ManuallyDrop::drop(&mut self.inner);\n-            rflags::set(rflags::read() | (self.rflags & rflags::RFlags::FLAGS_IF));\n         }\n \n         cfg_if! {\ndiff --git a/kernel/arch/x64/lock.rs b/runtime/spinlock.rs\n--- a/kernel/arch/x64/lock.rs\n+++ b/runtime/spinlock.rs\n@@ -98,6 +102,10 @@ impl<'a, T: ?Sized> Drop for SpinLockGuard<'a, T> {\n                 *self.locked_by.borrow_mut() = None;\n             }\n         }\n+\n+        unsafe {\n+            ManuallyDrop::drop(&mut self.saved_intr_status);\n+        }\n     }\n }\n \ndiff --git a/kernel/arch/x64/apic.rs b/runtime/x64/apic.rs\n--- a/kernel/arch/x64/apic.rs\n+++ b/runtime/x64/apic.rs\n@@ -1,5 +1,5 @@\n-use super::address::PAddr;\n-use super::lock::SpinLock;\n+use crate::address::PAddr;\n+use crate::spinlock::SpinLock;\n use core::ptr::{read_volatile, write_volatile};\n use x86::msr::{self, rdmsr, wrmsr};\n \ndiff --git a/kernel/arch/x64/apic.rs b/runtime/x64/apic.rs\n--- a/kernel/arch/x64/apic.rs\n+++ b/runtime/x64/apic.rs\n@@ -12,7 +12,7 @@ static APIC: SpinLock<LocalApic> = SpinLock::new(LocalApic::new(PAddr::new(0xfee\n #[derive(Debug, Copy, Clone)]\n #[repr(u32)]\n enum LocalApicReg {\n-    EOI = 0xb0,\n+    Eoi = 0xb0,\n     SpuriousInterrupt = 0xf0,\n }\n \ndiff --git a/kernel/arch/x64/apic.rs b/runtime/x64/apic.rs\n--- a/kernel/arch/x64/apic.rs\n+++ b/runtime/x64/apic.rs\n@@ -27,7 +27,7 @@ impl LocalApic {\n \n     pub unsafe fn write_eoi(&self) {\n         // The EOI register accepts only 0. CPU raises #GP otherwise.\n-        self.mmio_write(LocalApicReg::EOI, 0);\n+        self.mmio_write(LocalApicReg::Eoi, 0);\n     }\n \n     pub unsafe fn write_spurious_interrupt(&self, value: u32) {\ndiff --git a/kernel/arch/x64/backtrace.rs b/runtime/x64/backtrace.rs\n--- a/kernel/arch/x64/backtrace.rs\n+++ b/runtime/x64/backtrace.rs\n@@ -1,4 +1,4 @@\n-use super::address::VAddr;\n+use crate::address::VAddr;\n \n const BACKTRACE_MAX: usize = 16;\n \ndiff --git a/kernel/arch/x64/boot.S b/runtime/x64/boot.S\n--- a/kernel/arch/x64/boot.S\n+++ b/runtime/x64/boot.S\n@@ -237,7 +237,7 @@ setup_bsp:\n     pop  rdi // multiboot magic\n \n     // Clear the frame pointer to stop backtracing here.\n-    xor ebx, ebx\n+    xor rbp, rbp\n \n     lea  rax, [rip + bsp_early_init]\n     call rax\ndiff --git a/kernel/arch/x64/boot.rs b/runtime/x64/boot.rs\n--- a/kernel/arch/x64/boot.rs\n+++ b/runtime/x64/boot.rs\n@@ -1,8 +1,8 @@\n-use super::{\n-    address::{PAddr, VAddr},\n-    apic, bootinfo, cpu_local, gdt, idt, ioapic, pit, printchar, serial, syscall, tss, vga,\n-};\n-use crate::boot::{boot_kernel, init_logger};\n+use super::{apic, bootinfo, cpu_local, gdt, idt, ioapic, pit, serial, syscall, tss, vga};\n+use crate::address::{PAddr, VAddr};\n+use crate::bootinfo::BootInfo;\n+use crate::logger;\n+use crate::page_allocator;\n \n use x86::{\n     controlregs::{self, Cr4, Xcr0},\ndiff --git a/kernel/arch/x64/boot.rs b/runtime/x64/boot.rs\n--- a/kernel/arch/x64/boot.rs\n+++ b/runtime/x64/boot.rs\n@@ -62,6 +62,10 @@ unsafe fn init_pic() {\n     outb(0x21, 0xff);\n }\n \n+extern \"Rust\" {\n+    fn boot_kernel(bootinfo: &BootInfo) -> !;\n+}\n+\n /// Initializes the CPU. This function is called exactly once in the Bootstrap\n /// Processor (BSP).\n #[no_mangle]\ndiff --git a/kernel/arch/x64/boot.rs b/runtime/x64/boot.rs\n--- a/kernel/arch/x64/boot.rs\n+++ b/runtime/x64/boot.rs\n@@ -73,17 +77,14 @@ unsafe extern \"C\" fn bsp_early_init(boot_magic: u32, boot_params: u64) -> ! {\n     // Initialize the serial driver first to enable print macros.\n     serial::early_init();\n     vga::init();\n-    init_logger();\n-    printchar('\\n');\n+    logger::init();\n \n     let boot_info = bootinfo::parse(boot_magic, PAddr::new(boot_params as usize));\n+    page_allocator::init(&boot_info.ram_areas);\n \n+    serial::init();\n     init_pic();\n     common_setup(VAddr::new(&__bsp_cpu_local as *const _ as usize));\n-    boot_kernel(&boot_info);\n-}\n \n-/// Called after the memory allocator is initialized.\n-pub fn init() {\n-    serial::init();\n+    boot_kernel(&boot_info);\n }\ndiff --git a/kernel/arch/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/kernel/arch/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -1,5 +1,5 @@\n-use super::address::{PAddr, VAddr};\n-use crate::boot::{BootInfo, RamArea, VirtioMmioDevice};\n+use crate::address::{PAddr, VAddr};\n+use crate::bootinfo::{BootInfo, RamArea, VirtioMmioDevice};\n use arrayvec::ArrayVec;\n use core::cmp::max;\n use core::mem::size_of;\ndiff --git a/kernel/arch/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/kernel/arch/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -125,7 +125,6 @@ extern \"C\" {\n \n struct Cmdline {\n     pub pci_enabled: bool,\n-    pub omikuji: bool,\n     pub virtio_mmio_devices: ArrayVec<VirtioMmioDevice, 4>,\n }\n \ndiff --git a/kernel/arch/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/kernel/arch/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -135,7 +134,6 @@ impl Cmdline {\n         info!(\"cmdline: {}\", if s.is_empty() { \"(empty)\" } else { s });\n \n         let mut pci_enabled = true;\n-        let mut omikuji = false;\n         let mut virtio_mmio_devices = ArrayVec::new();\n         if !s.is_empty() {\n             for config in s.split(' ') {\ndiff --git a/kernel/arch/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/kernel/arch/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -145,9 +143,6 @@ impl Cmdline {\n                         warn!(\"bootinfo: PCI disabled\");\n                         pci_enabled = false;\n                     }\n-                    (Some(\"omikuji\"), Some(\"on\")) => {\n-                        omikuji = true;\n-                    }\n                     (Some(\"virtio_mmio.device\"), Some(value)) => {\n                         let mut size_and_rest = value.splitn(2, \"@0x\");\n                         let _size = size_and_rest.next().unwrap();\ndiff --git a/kernel/arch/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/kernel/arch/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -176,7 +171,6 @@ impl Cmdline {\n         Cmdline {\n             pci_enabled,\n             virtio_mmio_devices,\n-            omikuji,\n         }\n     }\n }\ndiff --git a/kernel/arch/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/kernel/arch/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -253,7 +247,6 @@ unsafe fn parse_multiboot2_info(header: &Multiboot2InfoHeader) -> BootInfo {\n         ram_areas,\n         pci_enabled: cmdline.pci_enabled,\n         virtio_mmio_devices: cmdline.virtio_mmio_devices,\n-        omikuji: cmdline.omikuji,\n     }\n }\n \ndiff --git a/kernel/arch/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/kernel/arch/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -277,7 +270,6 @@ unsafe fn parse_multiboot_legacy_info(info: &MultibootLegacyInfo) -> BootInfo {\n         ram_areas,\n         pci_enabled: cmdline.pci_enabled,\n         virtio_mmio_devices: cmdline.virtio_mmio_devices,\n-        omikuji: cmdline.omikuji,\n     }\n }\n \ndiff --git a/kernel/arch/x64/bootinfo.rs b/runtime/x64/bootinfo.rs\n--- a/kernel/arch/x64/bootinfo.rs\n+++ b/runtime/x64/bootinfo.rs\n@@ -307,7 +299,6 @@ unsafe fn parse_linux_boot_params(boot_params: PAddr) -> BootInfo {\n         ram_areas,\n         pci_enabled: cmdline.pci_enabled,\n         virtio_mmio_devices: cmdline.virtio_mmio_devices,\n-        omikuji: cmdline.omikuji,\n     }\n }\n \ndiff --git a/kernel/arch/x64/cpu_local.rs b/runtime/x64/cpu_local.rs\n--- a/kernel/arch/x64/cpu_local.rs\n+++ b/runtime/x64/cpu_local.rs\n@@ -1,11 +1,13 @@\n-use crate::arch::VAddr;\n+use crate::address::VAddr;\n use core::mem::MaybeUninit;\n use core::ptr;\n use x86::bits64::segmentation::{rdgsbase, wrgsbase};\n \n+#[macro_export]\n macro_rules! __cpu_local_impl {\n     ($V:vis, $N:ident, $T:ty, $E:expr) => {\n         #[allow(non_camel_case_types)]\n+        #[allow(clippy::upper_case_acronyms)]\n         pub struct $N {\n             #[allow(unused)]\n             initial_value: $T,\ndiff --git a/kernel/arch/x64/cpu_local.rs b/runtime/x64/cpu_local.rs\n--- a/kernel/arch/x64/cpu_local.rs\n+++ b/runtime/x64/cpu_local.rs\n@@ -29,7 +31,7 @@ macro_rules! __cpu_local_impl {\n             }\n \n             #[allow(unused)]\n-            $V fn vaddr(&self) -> $crate::arch::x64::VAddr {\n+            $V fn vaddr(&self) -> $crate::address::VAddr {\n                 extern \"C\" {\n                     static __cpu_local: u8;\n                 }\ndiff --git a/kernel/arch/x64/cpu_local.rs b/runtime/x64/cpu_local.rs\n--- a/kernel/arch/x64/cpu_local.rs\n+++ b/runtime/x64/cpu_local.rs\n@@ -38,7 +40,7 @@ macro_rules! __cpu_local_impl {\n                     let cpu_local_base = &__cpu_local as *const _ as usize;\n                     let offset = (self as *const _ as usize) - cpu_local_base;\n                     let gsbase = x86::bits64::segmentation::rdgsbase() as usize;\n-                    $crate::arch::x64::VAddr::new((gsbase + offset) as usize)\n+                    $crate::address::VAddr::new((gsbase + offset) as usize)\n                 }\n             }\n         }\ndiff --git a/kernel/arch/x64/cpu_local.rs b/runtime/x64/cpu_local.rs\n--- a/kernel/arch/x64/cpu_local.rs\n+++ b/runtime/x64/cpu_local.rs\n@@ -68,6 +70,7 @@ macro_rules! __cpu_local_impl {\n ///\n /// To get the memory address, use `.vaddr()`. **DO NOT USE `&` operator**  --\n /// it points to the initial value area instead!\n+#[macro_export]\n macro_rules! cpu_local {\n     (static ref $N:ident : $T:ty = $E:expr ;) => {\n         __cpu_local_impl!(, $N, $T, $E);\ndiff --git a/kernel/arch/x64/gdt.rs b/runtime/x64/gdt.rs\n--- a/kernel/arch/x64/gdt.rs\n+++ b/runtime/x64/gdt.rs\n@@ -1,4 +1,4 @@\n-use super::tss::{Tss, TSS};\n+use super::tss::TSS;\n use core::convert::TryInto;\n use core::mem::size_of;\n use x86::dtables::{lgdt, DescriptorTablePointer};\ndiff --git a/kernel/arch/x64/gdt.rs b/runtime/x64/gdt.rs\n--- a/kernel/arch/x64/gdt.rs\n+++ b/runtime/x64/gdt.rs\n@@ -28,7 +28,7 @@ pub unsafe fn init() {\n     let tss_addr = TSS.vaddr().value() as u64;\n     let gdt = GDT.as_mut();\n     gdt[(TSS_SEG as usize) / 8] = 0x0000890000000000\n-        | (size_of::<Tss>() as u64)\n+        | (size_of::<GDT>() as u64)\n         | ((tss_addr & 0xffff) << 16)\n         | (((tss_addr >> 16) & 0xff) << 32)\n         | (((tss_addr >> 24) & 0xff) << 56);\ndiff --git a/kernel/arch/x64/idle.rs b/runtime/x64/idle.rs\n--- a/kernel/arch/x64/idle.rs\n+++ b/runtime/x64/idle.rs\n@@ -1,4 +1,4 @@\n-use super::semihosting::{semihosting_halt, ExitStatus};\n+use super::semihosting::{semihosting_halt, SemihostingExitStatus};\n \n pub fn idle() {\n     unsafe {\ndiff --git a/kernel/arch/x64/interrupt.rs b/runtime/x64/interrupt.rs\n--- a/kernel/arch/x64/interrupt.rs\n+++ b/runtime/x64/interrupt.rs\n@@ -1,14 +1,11 @@\n-use super::{\n-    apic::ack_interrupt, ioapic::VECTOR_IRQ_BASE, serial::SERIAL_IRQ, PageFaultReason, UserVAddr,\n-};\n-use crate::{\n-    interrupt::handle_irq,\n-    mm::page_fault::handle_page_fault,\n-    process::{signal::SIGSEGV, Process},\n-    timer::handle_timer_irq,\n-};\n+use crate::{address::UserVAddr, handler};\n \n-use x86::{controlregs::cr2, irq::*};\n+use super::{apic::ack_interrupt, ioapic::VECTOR_IRQ_BASE, serial::SERIAL_IRQ, PageFaultReason};\n+use x86::{\n+    controlregs::cr2,\n+    current::rflags::{self, RFlags},\n+    irq::*,\n+};\n \n /// The interrupt stack frame.\n #[derive(Debug, Copy, Clone)]\ndiff --git a/kernel/arch/x64/interrupt.rs b/runtime/x64/interrupt.rs\n--- a/kernel/arch/x64/interrupt.rs\n+++ b/runtime/x64/interrupt.rs\n@@ -44,6 +41,7 @@ extern \"C\" {\n }\n \n #[no_mangle]\n+#[allow(unaligned_references)]\n unsafe extern \"C\" fn x64_handle_interrupt(vec: u8, frame: *const InterruptFrame) {\n     let frame = &*frame;\n \ndiff --git a/kernel/arch/x64/interrupt.rs b/runtime/x64/interrupt.rs\n--- a/kernel/arch/x64/interrupt.rs\n+++ b/runtime/x64/interrupt.rs\n@@ -72,13 +70,13 @@ unsafe extern \"C\" fn x64_handle_interrupt(vec: u8, frame: *const InterruptFrame)\n             let irq = vec - VECTOR_IRQ_BASE;\n             match irq {\n                 TIMER_IRQ | TIMER_IRQ2 => {\n-                    handle_timer_irq();\n+                    handler().handle_timer_irq();\n                 }\n                 SERIAL_IRQ => {\n                     super::serial::irq_handler();\n                 }\n                 _ => {\n-                    handle_irq(irq);\n+                    handler().handle_irq(irq);\n                 }\n             }\n         }\ndiff --git a/kernel/arch/x64/interrupt.rs b/runtime/x64/interrupt.rs\n--- a/kernel/arch/x64/interrupt.rs\n+++ b/runtime/x64/interrupt.rs\n@@ -156,19 +154,8 @@ unsafe extern \"C\" fn x64_handle_interrupt(vec: u8, frame: *const InterruptFrame)\n             }\n \n             // Abort if the virtual address points to out of the user's address space.\n-            let unaligned_vaddr = match UserVAddr::new(cr2() as usize) {\n-                Ok(Some(uvaddr)) => uvaddr,\n-                Ok(None) | Err(_) => {\n-                    debug_warn!(\n-                        \"user tried to access a kernel address {:x} (rip={:x}), killing the current process...\",\n-                        cr2(),\n-                        frame.rip,\n-                    );\n-                    Process::exit_by_signal(SIGSEGV);\n-                }\n-            };\n-\n-            handle_page_fault(unaligned_vaddr, frame.rip as usize, reason);\n+            let unaligned_vaddr = UserVAddr::new(cr2() as usize);\n+            handler().handle_page_fault(unaligned_vaddr, frame.rip as usize, reason);\n         }\n         X87_FPU_VECTOR => {\n             // TODO:\ndiff --git a/kernel/arch/x64/interrupt.rs b/runtime/x64/interrupt.rs\n--- a/kernel/arch/x64/interrupt.rs\n+++ b/runtime/x64/interrupt.rs\n@@ -195,3 +182,21 @@ unsafe extern \"C\" fn x64_handle_interrupt(vec: u8, frame: *const InterruptFrame)\n         }\n     }\n }\n+\n+pub struct SavedInterruptStatus {\n+    rflags: RFlags,\n+}\n+\n+impl SavedInterruptStatus {\n+    pub fn save() -> SavedInterruptStatus {\n+        SavedInterruptStatus {\n+            rflags: rflags::read(),\n+        }\n+    }\n+}\n+\n+impl Drop for SavedInterruptStatus {\n+    fn drop(&mut self) {\n+        rflags::set(rflags::read() | (self.rflags & rflags::RFlags::FLAGS_IF));\n+    }\n+}\ndiff --git a/kernel/arch/x64/ioapic.rs b/runtime/x64/ioapic.rs\n--- a/kernel/arch/x64/ioapic.rs\n+++ b/runtime/x64/ioapic.rs\n@@ -1,5 +1,5 @@\n-use super::address::PAddr;\n-use super::lock::SpinLock;\n+use crate::address::PAddr;\n+use crate::spinlock::SpinLock;\n use core::ptr::{read_volatile, write_volatile};\n use x86::io::outb;\n \ndiff --git /dev/null b/runtime/x64/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/runtime/x64/mod.rs\n@@ -0,0 +1,50 @@\n+global_asm!(include_str!(\"boot.S\"));\n+global_asm!(include_str!(\"trap.S\"));\n+global_asm!(include_str!(\"usercopy.S\"));\n+\n+#[macro_use]\n+mod cpu_local;\n+\n+mod apic;\n+mod backtrace;\n+mod boot;\n+mod bootinfo;\n+mod gdt;\n+mod idle;\n+mod idt;\n+mod interrupt;\n+mod ioapic;\n+mod paging;\n+mod pit;\n+mod profile;\n+mod semihosting;\n+mod serial;\n+mod syscall;\n+mod tss;\n+mod vga;\n+\n+pub use backtrace::Backtrace;\n+pub use idle::{halt, idle};\n+pub use interrupt::SavedInterruptStatus;\n+pub use ioapic::enable_irq;\n+pub use paging::{PageFaultReason, PageTable};\n+pub use profile::read_clock_counter;\n+pub use semihosting::{semihosting_halt, SemihostingExitStatus};\n+pub use serial::console_write;\n+pub use syscall::SyscallFrame;\n+\n+pub mod x64_specific {\n+    pub use super::cpu_local::cpu_local_head;\n+    pub use super::gdt::{USER_CS32, USER_CS64, USER_DS, USER_RPL};\n+    pub use super::tss::TSS;\n+}\n+\n+pub const PAGE_SIZE: usize = 4096;\n+pub const TICK_HZ: usize = 1000;\n+\n+/// The base virtual address of straight mapping.\n+pub const KERNEL_BASE_ADDR: usize = 0xffff_8000_0000_0000;\n+\n+/// The end of straight mapping. Any physical address `P` is mapped into the\n+/// kernel's virtual memory address `KERNEL_BASE_ADDR + P`.\n+pub const KERNEL_STRAIGHT_MAP_PADDR_END: usize = 0x1_0000_0000;\ndiff --git a/kernel/arch/x64/page_table.rs b/runtime/x64/paging.rs\n--- a/kernel/arch/x64/page_table.rs\n+++ b/runtime/x64/paging.rs\n@@ -1,6 +1,6 @@\n-use super::{PAddr, UserVAddr, PAGE_SIZE};\n-use crate::mm::page_allocator::{alloc_pages, AllocPageFlags};\n-use crate::result::Result;\n+use super::PAGE_SIZE;\n+use crate::address::{PAddr, UserVAddr};\n+use crate::page_allocator::{alloc_pages, AllocPageFlags, PageAllocError};\n use bitflags::bitflags;\n use core::{\n     debug_assert,\ndiff --git a/kernel/arch/x64/page_table.rs b/runtime/x64/paging.rs\n--- a/kernel/arch/x64/page_table.rs\n+++ b/runtime/x64/paging.rs\n@@ -48,7 +48,7 @@ fn traverse(\n     attrs: PageAttrs,\n ) -> Option<NonNull<PageTableEntry>> {\n     debug_assert!(is_aligned(vaddr.value(), PAGE_SIZE));\n-    let mut table = unsafe { pml4.as_mut_ptr::<PageTableEntry>() };\n+    let mut table = pml4.as_mut_ptr::<PageTableEntry>();\n     for level in (2..=4).rev() {\n         let index = nth_level_table_index(vaddr, level);\n         let entry = unsafe { table.offset(index) };\ndiff --git a/kernel/arch/x64/page_table.rs b/runtime/x64/paging.rs\n--- a/kernel/arch/x64/page_table.rs\n+++ b/runtime/x64/paging.rs\n@@ -70,7 +70,7 @@ fn traverse(\n         }\n \n         unsafe { *entry = table_paddr.value() as u64 | attrs.bits() };\n-        table = unsafe { table_paddr.as_mut_ptr::<PageTableEntry>() };\n+        table = table_paddr.as_mut_ptr::<PageTableEntry>();\n     }\n \n     unsafe {\ndiff --git a/kernel/arch/x64/page_table.rs b/runtime/x64/paging.rs\n--- a/kernel/arch/x64/page_table.rs\n+++ b/runtime/x64/paging.rs\n@@ -84,10 +84,10 @@ fn traverse(\n /// nth-level page table. Returns the newly created copy of the page table.\n ///\n /// fork(2) uses this funciton to duplicate the memory space.\n-fn duplicate_table(original_table_paddr: PAddr, level: usize) -> Result<PAddr> {\n-    let orig_table = unsafe { original_table_paddr.as_ptr::<PageTableEntry>() };\n+fn duplicate_table(original_table_paddr: PAddr, level: usize) -> Result<PAddr, PageAllocError> {\n+    let orig_table = original_table_paddr.as_ptr::<PageTableEntry>();\n     let new_table_paddr = alloc_pages(1, AllocPageFlags::KERNEL)?;\n-    let new_table = unsafe { new_table_paddr.as_mut_ptr::<PageTableEntry>() };\n+    let new_table = new_table_paddr.as_mut_ptr::<PageTableEntry>();\n \n     debug_assert!(level > 0);\n     for i in 0..ENTRIES_PER_TABLE {\ndiff --git a/kernel/arch/x64/page_table.rs b/runtime/x64/paging.rs\n--- a/kernel/arch/x64/page_table.rs\n+++ b/runtime/x64/paging.rs\n@@ -127,7 +127,7 @@ fn duplicate_table(original_table_paddr: PAddr, level: usize) -> Result<PAddr> {\n     Ok(new_table_paddr)\n }\n \n-fn allocate_pml4() -> Result<PAddr> {\n+fn allocate_pml4() -> Result<PAddr, PageAllocError> {\n     extern \"C\" {\n         static __kernel_pml4: u8;\n     }\ndiff --git a/kernel/arch/x64/page_table.rs b/runtime/x64/paging.rs\n--- a/kernel/arch/x64/page_table.rs\n+++ b/runtime/x64/paging.rs\n@@ -158,12 +158,12 @@ pub struct PageTable {\n }\n \n impl PageTable {\n-    pub fn new() -> Result<PageTable> {\n+    pub fn new() -> Result<PageTable, PageAllocError> {\n         let pml4 = allocate_pml4()?;\n         Ok(PageTable { pml4 })\n     }\n \n-    pub fn duplicate_from(original: &PageTable) -> Result<PageTable> {\n+    pub fn duplicate_from(original: &PageTable) -> Result<PageTable, PageAllocError> {\n         // TODO: Implement copy-on-write.\n         Ok(PageTable {\n             pml4: duplicate_table(original.pml4, 4)?,\ndiff --git a/kernel/arch/x64/serial.rs b/runtime/x64/serial.rs\n--- a/kernel/arch/x64/serial.rs\n+++ b/runtime/x64/serial.rs\n@@ -1,6 +1,9 @@\n use x86::io::{inb, outb};\n \n-use crate::fs::devfs::SERIAL_TTY;\n+use crate::{\n+    handler,\n+    print::{set_printer, Printer},\n+};\n \n use super::{ioapic::enable_irq, vga};\n \ndiff --git a/kernel/arch/x64/serial.rs b/runtime/x64/serial.rs\n--- a/kernel/arch/x64/serial.rs\n+++ b/runtime/x64/serial.rs\n@@ -15,24 +18,32 @@ const LCR: u16 = 3;\n const LSR: u16 = 5;\n const TX_READY: u8 = 0x20;\n \n-unsafe fn serial_write(ch: char) {\n+unsafe fn serial_write(ch: u8) {\n     while (inb(IOPORT_SERIAL + LSR) & TX_READY) == 0 {}\n-    outb(IOPORT_SERIAL, ch as u8);\n+    outb(IOPORT_SERIAL, ch);\n }\n \n-pub fn printchar(ch: char) {\n+pub fn printchar(ch: u8) {\n     unsafe {\n-        if ch == '\\n' && option_env!(\"DISABLE_AUTO_CR_PRINT\").is_none() {\n-            serial_write('\\r');\n+        if ch == b'\\n' && option_env!(\"DISABLE_AUTO_CR_PRINT\").is_none() {\n+            serial_write(b'\\r');\n         }\n         serial_write(ch);\n-        vga::printchar(ch as u8);\n     }\n }\n \n-pub fn print_str(s: &[u8]) {\n+pub fn console_write(s: &[u8]) {\n     for ch in s {\n-        printchar(*ch as char);\n+        printchar(*ch);\n+        vga::printchar(*ch);\n+    }\n+}\n+\n+struct SerialPrinter;\n+\n+impl Printer for SerialPrinter {\n+    fn print_bytes(&self, s: &[u8]) {\n+        console_write(s);\n     }\n }\n \ndiff --git a/kernel/arch/x64/serial.rs b/runtime/x64/serial.rs\n--- a/kernel/arch/x64/serial.rs\n+++ b/runtime/x64/serial.rs\n@@ -49,9 +60,9 @@ fn read_char() -> Option<u8> {\n pub fn irq_handler() {\n     while let Some(ch) = read_char() {\n         if ch == b'\\r' {\n-            SERIAL_TTY.input_char(b'\\n');\n+            handler().handle_console_rx(b'\\n');\n         } else {\n-            SERIAL_TTY.input_char(ch);\n+            handler().handle_console_rx(ch);\n         }\n     }\n }\ndiff --git a/kernel/arch/x64/serial.rs b/runtime/x64/serial.rs\n--- a/kernel/arch/x64/serial.rs\n+++ b/runtime/x64/serial.rs\n@@ -64,6 +75,9 @@ pub unsafe fn early_init() {\n     outb(IOPORT_SERIAL + LCR, 0x03); // 8n1.\n     outb(IOPORT_SERIAL + FCR, 0x01); // Enable FIFO.\n     outb(IOPORT_SERIAL + IER, 0x01); // Enable interrupts.\n+\n+    set_printer(&SerialPrinter);\n+    printchar(b'\\n');\n }\n \n pub fn init() {\ndiff --git a/kernel/arch/x64/syscall.rs b/runtime/x64/syscall.rs\n--- a/kernel/arch/x64/syscall.rs\n+++ b/runtime/x64/syscall.rs\n@@ -1,4 +1,4 @@\n-use crate::syscalls::SyscallHandler;\n+use crate::handler;\n \n use super::gdt::{KERNEL_CS, USER_CS32};\n use x86::msr::{self, rdmsr, wrmsr};\ndiff --git a/kernel/arch/x64/syscall.rs b/runtime/x64/syscall.rs\n--- a/kernel/arch/x64/syscall.rs\n+++ b/runtime/x64/syscall.rs\n@@ -10,21 +10,21 @@ const SYSCALL_RFLAGS_MASK: u64 = 0x200;\n #[repr(C, packed)]\n #[derive(Clone, Copy)]\n pub struct SyscallFrame {\n-    pub(super) r15: u64,\n-    pub(super) r14: u64,\n-    pub(super) r13: u64,\n-    pub(super) r12: u64,\n-    pub(super) r10: u64,\n-    pub(super) r9: u64,\n-    pub(super) r8: u64,\n-    pub(super) rsi: u64,\n-    pub(super) rdi: u64,\n-    pub(super) rdx: u64,\n-    pub(super) rbx: u64,\n-    pub(super) rbp: u64,\n-    pub(super) rip: u64,\n-    pub(super) rflags: u64,\n-    pub(super) rsp: u64,\n+    pub r15: u64,\n+    pub r14: u64,\n+    pub r13: u64,\n+    pub r12: u64,\n+    pub r10: u64,\n+    pub r9: u64,\n+    pub r8: u64,\n+    pub rsi: u64,\n+    pub rdi: u64,\n+    pub rdx: u64,\n+    pub rbx: u64,\n+    pub rbp: u64,\n+    pub rip: u64,\n+    pub rflags: u64,\n+    pub rsp: u64,\n }\n \n #[no_mangle]\ndiff --git a/kernel/arch/x64/syscall.rs b/runtime/x64/syscall.rs\n--- a/kernel/arch/x64/syscall.rs\n+++ b/runtime/x64/syscall.rs\n@@ -38,10 +38,7 @@ extern \"C\" fn x64_handle_syscall(\n     n: usize,\n     frame: *mut SyscallFrame,\n ) -> isize {\n-    let mut handler = SyscallHandler::new(unsafe { &mut *frame });\n-    handler\n-        .dispatch(a1, a2, a3, a4, a5, a6, n)\n-        .unwrap_or_else(|err| -(err.errno() as isize))\n+    handler().handle_syscall(a1, a2, a3, a4, a5, a6, n, frame)\n }\n \n extern \"C\" {\ndiff --git a/kernel/arch/x64/vga.rs b/runtime/x64/vga.rs\n--- a/kernel/arch/x64/vga.rs\n+++ b/runtime/x64/vga.rs\n@@ -1,10 +1,10 @@\n+use crate::address::{PAddr, VAddr};\n+\n use core::ptr;\n \n use kerla_utils::once::Once;\n use x86::io::outb;\n \n-use super::{PAddr, VAddr};\n-\n #[repr(u8)]\n #[derive(Copy, Clone)]\n #[allow(unused)]\n",
        "test_patch": "diff --git a/Makefile b/Makefile\n--- a/Makefile\n+++ b/Makefile\n@@ -47,9 +47,10 @@ export RUSTFLAGS = -Z emit-stack-sizes\n CARGOFLAGS += -Z build-std=core,alloc -Z build-std-features=compiler-builtins-mem\n CARGOFLAGS += --target $(target_json)\n CARGOFLAGS += $(if $(RELEASE),--release,)\n-TESTCARGOFLAGS += --package kerla -Z unstable-options\n+TESTCARGOFLAGS += --package kerla_kernel -Z unstable-options\n TESTCARGOFLAGS += --config \"target.$(ARCH).runner = './tools/run-unittests.sh'\"\n WATCHFLAGS += --clear\n+\n export CARGO_FROM_MAKE=1\n export INITRAMFS_PATH\n export ARCH\ndiff --git a/kernel/arch/x64/mod.rs b/kernel/arch/x64/mod.rs\n--- a/kernel/arch/x64/mod.rs\n+++ b/kernel/arch/x64/mod.rs\n@@ -1,49 +1,14 @@\n-global_asm!(include_str!(\"boot.S\"));\n-global_asm!(include_str!(\"trap.S\"));\n-global_asm!(include_str!(\"usercopy.S\"));\n+use kerla_runtime::{address::UserVAddr, arch::PAGE_SIZE};\n+\n+global_asm!(include_str!(\"usermode.S\"));\n \n-#[macro_use]\n-mod cpu_local;\n-mod address;\n-mod apic;\n mod arch_prctl;\n-mod backtrace;\n-mod boot;\n-mod bootinfo;\n-mod gdt;\n-mod idle;\n-mod idt;\n-mod interrupt;\n-mod ioapic;\n-mod lock;\n-mod page_table;\n-mod pit;\n mod process;\n-mod profile;\n-mod semihosting;\n-mod serial;\n-mod syscall;\n-mod tss;\n-mod vga;\n \n pub const KERNEL_STACK_SIZE: usize = PAGE_SIZE * 256;\n pub const USER_VALLOC_END: UserVAddr = unsafe { UserVAddr::new_unchecked(0x0000_0fff_0000_0000) };\n pub const USER_VALLOC_BASE: UserVAddr = unsafe { UserVAddr::new_unchecked(0x0000_000a_0000_0000) };\n pub const USER_STACK_TOP: UserVAddr = USER_VALLOC_BASE;\n-pub const PAGE_SIZE: usize = 4096;\n-pub const TICK_HZ: usize = 1000;\n \n-pub use address::{PAddr, UserVAddr, VAddr};\n pub use arch_prctl::arch_prctl;\n-pub use backtrace::Backtrace;\n-pub use boot::init;\n-pub use idle::{halt, idle};\n-pub use ioapic::enable_irq;\n-pub use lock::{SpinLock, SpinLockGuard};\n-pub use page_table::{PageFaultReason, PageTable};\n pub use process::{switch_thread, Process};\n-pub use profile::read_clock_counter;\n-#[cfg(test)]\n-pub use semihosting::{semihosting_halt, ExitStatus};\n-pub use serial::{print_str, printchar};\n-pub use syscall::SyscallFrame;\ndiff --git a/kernel/arch/x64/trap.S b/kernel/arch/x64/usermode.S\n--- a/kernel/arch/x64/trap.S\n+++ b/kernel/arch/x64/usermode.S\n@@ -78,115 +78,6 @@ syscall_entry:\n     swapgs\n     sysretq\n \n-//\n-//  Interrupt/exception handlers\n-//\n-.align INTERRUPT_HANDLER_SIZE\n-.global interrupt_handlers\n-interrupt_handlers:\n-.set i, 0\n-.rept 256\n-.set handler_start, .\n-// Exceptions with error code.\n-.if i == 8 || 10 <= i && i <= 14 || i == 17\n-    .align INTERRUPT_HANDLER_SIZE\n-    cli\n-    push i\n-    jmp interrupt_common\n-    .align INTERRUPT_HANDLER_SIZE\n-// Interrupts and exceptions without error code.\n-.else\n-    .align INTERRUPT_HANDLER_SIZE\n-    cli\n-    push 0 // Dummy value as error code.\n-    push i\n-    jmp interrupt_common\n-    .align INTERRUPT_HANDLER_SIZE\n-.endif\n-\n-// Increment the counter.\n-.set i, i + 1\n-.endr\n-\n-.extern x64_handle_interrupt\n-interrupt_common:\n-    //\n-    //  The current stack frame:\n-    //\n-    //            +--------------------+\n-    //     48     |        SS          |\n-    //            +--------------------+\n-    //     40     |        RSP         |\n-    //            +--------------------+\n-    //     32     |       RFLAGS       |\n-    //            +--------------------+\n-    //     24     |        CS          |\n-    //            +--------------------+\n-    //     16     |        RIP         |\n-    //            +--------------------+\n-    //      8     |     Error code     |\n-    //            +--------------------+\n-    //      0     |     IRQ Number     | <- RSP\n-    //            +--------------------+\n-    //\n-\n-    // Check CS register in the IRET frame to determine if the interrupt has\n-    // occurred in user mode.\n-    test qword ptr [rsp + 24], 3\n-    jz 1f\n-    swapgs\n-1:\n-    // Save RDI and set the IRQ number to RDI at once.\n-    xchg rdi, [rsp]\n-\n-    // Save registers except RDI (we have already saved it above).\n-    push r15\n-    push r14\n-    push r13\n-    push r12\n-    push r11\n-    push r10\n-    push r9\n-    push r8\n-    push rbp\n-    push rsi\n-    push rdx\n-    push rcx\n-    push rbx\n-    push rax\n-\n-    mov rsi, rsp\n-    call x64_handle_interrupt\n-\n-    pop rax\n-    pop rbx\n-    pop rcx\n-    pop rdx\n-    pop rsi\n-    pop rbp\n-    pop r8\n-    pop r9\n-    pop r10\n-    pop r11\n-    pop r12\n-    pop r13\n-    pop r14\n-    pop r15\n-    pop rdi\n-\n-    // Skip error code.\n-    add rsp, 8\n-\n-    // Check CS register in the IRET frame to determine whether the exception\n-    // occur in the userspace. If so, do SWAPGS.\n-    test qword ptr [rsp + 8], 3\n-    jz 1f\n-\n-    cli\n-    swapgs\n-1:\n-    iretq\n-\n .global kthread_entry\n kthread_entry:\n     sti\ndiff --git a/kernel/boot.rs /dev/null\n--- a/kernel/boot.rs\n+++ /dev/null\n@@ -1,179 +0,0 @@\n-#![cfg_attr(test, allow(unreachable_code))]\n-\n-use crate::{\n-    arch::{self, idle, PAddr, SpinLock},\n-    drivers,\n-    fs::tmpfs,\n-    fs::{\n-        devfs::{self, DEV_FS},\n-        initramfs::{self, INITRAM_FS},\n-        mount::RootFs,\n-        path::Path,\n-    },\n-    interrupt,\n-    mm::{global_allocator, page_allocator},\n-    net, pipe, poll,\n-    printk::PrintkLogger,\n-    process::{self, switch, Process},\n-    profile::StopWatch,\n-};\n-use alloc::sync::Arc;\n-use kerla_utils::once::Once;\n-use tmpfs::TMP_FS;\n-\n-#[cfg(test)]\n-use crate::test_runner::end_tests;\n-use arrayvec::ArrayVec;\n-\n-pub struct RamArea {\n-    pub base: PAddr,\n-    pub len: usize,\n-}\n-\n-pub struct VirtioMmioDevice {\n-    pub mmio_base: PAddr,\n-    pub irq: u8,\n-}\n-\n-pub struct BootInfo {\n-    pub ram_areas: ArrayVec<RamArea, 8>,\n-    pub virtio_mmio_devices: ArrayVec<VirtioMmioDevice, 4>,\n-    pub pci_enabled: bool,\n-    pub omikuji: bool,\n-}\n-\n-static LOGGER: PrintkLogger = PrintkLogger;\n-\n-pub fn init_logger() {\n-    log::set_logger(&LOGGER).unwrap();\n-    log::set_max_level(if cfg!(debug_assertions) {\n-        log::LevelFilter::Trace\n-    } else {\n-        log::LevelFilter::Info\n-    });\n-}\n-\n-fn idle_thread() -> ! {\n-    loop {\n-        idle();\n-    }\n-}\n-\n-pub static INITIAL_ROOT_FS: Once<Arc<SpinLock<RootFs>>> = Once::new();\n-\n-pub fn boot_kernel(bootinfo: &BootInfo) -> ! {\n-    info!(\"Booting Kerla...\");\n-    let mut profiler = StopWatch::start();\n-\n-    // Initialize memory allocators first.\n-    page_allocator::init(&bootinfo.ram_areas);\n-    profiler.lap_time(\"page allocator init\");\n-    global_allocator::init();\n-    profiler.lap_time(\"global allocator init\");\n-    interrupt::init();\n-    profiler.lap_time(\"global interrupt init\");\n-\n-    #[cfg(test)]\n-    {\n-        crate::test_main();\n-        end_tests();\n-    }\n-\n-    // Initialize kernel subsystems.\n-    arch::init();\n-    profiler.lap_time(\"arch init\");\n-    pipe::init();\n-    profiler.lap_time(\"pipe init\");\n-    poll::init();\n-    profiler.lap_time(\"poll init\");\n-    devfs::init();\n-    profiler.lap_time(\"devfs init\");\n-    tmpfs::init();\n-    profiler.lap_time(\"tmpfs init\");\n-    initramfs::init();\n-    profiler.lap_time(\"initramfs init\");\n-    drivers::init();\n-    profiler.lap_time(\"drivers init\");\n-\n-    if bootinfo.pci_enabled {\n-        drivers::pci::init();\n-        profiler.lap_time(\"pci init\");\n-    }\n-\n-    if !bootinfo.virtio_mmio_devices.is_empty() {\n-        drivers::virtio::init(&bootinfo.virtio_mmio_devices);\n-        profiler.lap_time(\"virtio init\");\n-    }\n-\n-    net::init();\n-    profiler.lap_time(\"net init\");\n-\n-    // Prepare the root file system.\n-    let mut root_fs = RootFs::new(INITRAM_FS.clone()).unwrap();\n-    let dev_dir = root_fs\n-        .lookup_dir(Path::new(\"/dev\"))\n-        .expect(\"failed to locate /dev\");\n-    let tmp_dir = root_fs\n-        .lookup_dir(Path::new(\"/tmp\"))\n-        .expect(\"failed to locate /tmp\");\n-    root_fs\n-        .mount(dev_dir, DEV_FS.clone())\n-        .expect(\"failed to mount devfs\");\n-    root_fs\n-        .mount(tmp_dir, TMP_FS.clone())\n-        .expect(\"failed to mount tmpfs\");\n-\n-    // Open /dev/console for the init process.\n-    let console = root_fs\n-        .lookup_path(Path::new(\"/dev/console\"), true)\n-        .expect(\"failed to open /dev/console\");\n-\n-    // Open the init's executable.\n-    let argv0 = if option_env!(\"INIT_SCRIPT\").is_some() {\n-        \"/bin/sh\"\n-    } else {\n-        \"/sbin/init\"\n-    };\n-    let executable_path = root_fs\n-        .lookup_path(Path::new(argv0), true)\n-        .expect(\"failed to open the init executable\");\n-\n-    // We cannot initialize the process subsystem until INITIAL_ROOT_FS is initialized.\n-    INITIAL_ROOT_FS.init(|| Arc::new(SpinLock::new(root_fs)));\n-\n-    profiler.lap_time(\"root fs init\");\n-\n-    process::init();\n-    profiler.lap_time(\"process init\");\n-\n-    // Create the init process.\n-    if let Some(script) = option_env!(\"INIT_SCRIPT\") {\n-        let argv = &[b\"sh\", b\"-c\", script.as_bytes()];\n-        info!(\"running init script: {:?}\", script);\n-        Process::new_init_process(INITIAL_ROOT_FS.clone(), executable_path, console, argv)\n-            .expect(\"failed to execute the init script: \");\n-    } else {\n-        info!(\"running /sbin/init\");\n-        Process::new_init_process(\n-            INITIAL_ROOT_FS.clone(),\n-            executable_path,\n-            console,\n-            &[b\"/sbin/init\"],\n-        )\n-        .expect(\"failed to execute /sbin/init\");\n-    }\n-\n-    profiler.lap_time(\"first process init\");\n-\n-    if bootinfo.omikuji {\n-        // \"Chosen by fair dice roll. Guaranteed to be random.\"\n-        // https://xkcd.com/221/\n-        info!(\"omikuji: \u4e2d\u5409\");\n-    }\n-\n-    // We've done the kernel initialization. Switch into the init...\n-    switch();\n-\n-    // We're now in the idle thread context.\n-    idle_thread();\n-}\ndiff --git a/kernel/lang_items.rs b/kernel/lang_items.rs\n--- a/kernel/lang_items.rs\n+++ b/kernel/lang_items.rs\n@@ -2,6 +2,11 @@ use core::sync::atomic::AtomicBool;\n \n pub static PANICKED: AtomicBool = AtomicBool::new(false);\n \n+#[alloc_error_handler]\n+fn alloc_error_handler(layout: core::alloc::Layout) -> ! {\n+    panic!(\"alloc error: layout={:?}\", layout);\n+}\n+\n /// This function is called on panic.\n #[panic_handler]\n #[cfg(not(test))]\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -8,7 +8,6 @@\n #![feature(array_methods)]\n #![test_runner(crate::test_runner::run_tests)]\n #![reexport_test_harness_main = \"test_main\"]\n-#![allow(clippy::upper_case_acronyms)]\n // FIXME:\n #![allow(unaligned_references)]\n \ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -38,9 +39,202 @@ mod pipe;\n mod poll;\n mod prelude;\n mod process;\n-mod profile;\n mod random;\n mod syscalls;\n mod test_runner;\n mod timer;\n mod tty;\n+\n+use crate::{\n+    fs::{devfs::SERIAL_TTY, tmpfs},\n+    fs::{\n+        devfs::{self, DEV_FS},\n+        initramfs::{self, INITRAM_FS},\n+        mount::RootFs,\n+        path::Path,\n+    },\n+    process::{switch, Process},\n+    syscalls::SyscallHandler,\n+};\n+use alloc::sync::Arc;\n+use kerla_runtime::{\n+    arch::{idle, PageFaultReason, SyscallFrame},\n+    bootinfo::BootInfo,\n+    profile::StopWatch,\n+    spinlock::SpinLock,\n+};\n+use kerla_utils::once::Once;\n+use tmpfs::TMP_FS;\n+\n+#[cfg(test)]\n+use crate::test_runner::end_tests;\n+\n+struct Handler;\n+\n+impl kerla_runtime::Handler for Handler {\n+    fn handle_console_rx(&self, ch: u8) {\n+        SERIAL_TTY.input_char(ch);\n+    }\n+\n+    fn handle_irq(&self, irq: u8) {\n+        crate::interrupt::handle_irq(irq);\n+    }\n+\n+    fn handle_timer_irq(&self) {\n+        crate::timer::handle_timer_irq();\n+    }\n+\n+    fn handle_page_fault(\n+        &self,\n+        unaligned_vaddr: Option<kerla_runtime::address::UserVAddr>,\n+        ip: usize,\n+        reason: PageFaultReason,\n+    ) {\n+        crate::mm::page_fault::handle_page_fault(unaligned_vaddr, ip, reason);\n+    }\n+\n+    fn handle_syscall(\n+        &self,\n+        a1: usize,\n+        a2: usize,\n+        a3: usize,\n+        a4: usize,\n+        a5: usize,\n+        a6: usize,\n+        n: usize,\n+        frame: *mut SyscallFrame,\n+    ) -> isize {\n+        let mut handler = SyscallHandler::new(unsafe { &mut *frame });\n+        handler\n+            .dispatch(a1, a2, a3, a4, a5, a6, n)\n+            .unwrap_or_else(|err| -(err.errno() as isize))\n+    }\n+\n+    #[cfg(debug_assertions)]\n+    fn usercopy_hook(&self) {\n+        use crate::process::current_process;\n+\n+        // We should not hold the vm lock since we'll try to acquire it in the\n+        // page fault handler when copying caused a page fault.\n+        debug_assert!(!current_process().vm().as_ref().unwrap().is_locked());\n+    }\n+}\n+\n+pub static INITIAL_ROOT_FS: Once<Arc<SpinLock<RootFs>>> = Once::new();\n+\n+#[no_mangle]\n+#[cfg_attr(test, allow(unreachable_code))]\n+pub fn boot_kernel(#[cfg_attr(debug_assertions, allow(unused))] bootinfo: &BootInfo) -> ! {\n+    logger::init();\n+\n+    info!(\"Booting Kerla...\");\n+    let mut profiler = StopWatch::start();\n+\n+    kerla_runtime::set_handler(&Handler);\n+\n+    // Initialize memory allocators first.\n+    interrupt::init();\n+    profiler.lap_time(\"global interrupt init\");\n+\n+    #[cfg(test)]\n+    {\n+        crate::test_main();\n+        end_tests();\n+    }\n+\n+    // Initialize kernel subsystems.\n+    pipe::init();\n+    profiler.lap_time(\"pipe init\");\n+    poll::init();\n+    profiler.lap_time(\"poll init\");\n+    devfs::init();\n+    profiler.lap_time(\"devfs init\");\n+    tmpfs::init();\n+    profiler.lap_time(\"tmpfs init\");\n+    initramfs::init();\n+    profiler.lap_time(\"initramfs init\");\n+    drivers::init();\n+    profiler.lap_time(\"drivers init\");\n+\n+    if bootinfo.pci_enabled {\n+        drivers::pci::init();\n+        profiler.lap_time(\"pci init\");\n+    }\n+\n+    if !bootinfo.virtio_mmio_devices.is_empty() {\n+        drivers::virtio::init(&bootinfo.virtio_mmio_devices);\n+        profiler.lap_time(\"virtio init\");\n+    }\n+\n+    net::init();\n+    profiler.lap_time(\"net init\");\n+\n+    // Prepare the root file system.\n+    let mut root_fs = RootFs::new(INITRAM_FS.clone()).unwrap();\n+    let dev_dir = root_fs\n+        .lookup_dir(Path::new(\"/dev\"))\n+        .expect(\"failed to locate /dev\");\n+    let tmp_dir = root_fs\n+        .lookup_dir(Path::new(\"/tmp\"))\n+        .expect(\"failed to locate /tmp\");\n+    root_fs\n+        .mount(dev_dir, DEV_FS.clone())\n+        .expect(\"failed to mount devfs\");\n+    root_fs\n+        .mount(tmp_dir, TMP_FS.clone())\n+        .expect(\"failed to mount tmpfs\");\n+\n+    // Open /dev/console for the init process.\n+    let console = root_fs\n+        .lookup_path(Path::new(\"/dev/console\"), true)\n+        .expect(\"failed to open /dev/console\");\n+\n+    // Open the init's executable.\n+    let argv0 = if option_env!(\"INIT_SCRIPT\").is_some() {\n+        \"/bin/sh\"\n+    } else {\n+        \"/sbin/init\"\n+    };\n+    let executable_path = root_fs\n+        .lookup_path(Path::new(argv0), true)\n+        .expect(\"failed to open the init executable\");\n+\n+    // We cannot initialize the process subsystem until INITIAL_ROOT_FS is initialized.\n+    INITIAL_ROOT_FS.init(|| Arc::new(SpinLock::new(root_fs)));\n+\n+    profiler.lap_time(\"root fs init\");\n+\n+    process::init();\n+    profiler.lap_time(\"process init\");\n+\n+    // Create the init process.\n+    if let Some(script) = option_env!(\"INIT_SCRIPT\") {\n+        let argv = &[b\"sh\", b\"-c\", script.as_bytes()];\n+        info!(\"running init script: {:?}\", script);\n+        Process::new_init_process(INITIAL_ROOT_FS.clone(), executable_path, console, argv)\n+            .expect(\"failed to execute the init script: \");\n+    } else {\n+        info!(\"running /sbin/init\");\n+        Process::new_init_process(\n+            INITIAL_ROOT_FS.clone(),\n+            executable_path,\n+            console,\n+            &[b\"/sbin/init\"],\n+        )\n+        .expect(\"failed to execute /sbin/init\");\n+    }\n+\n+    profiler.lap_time(\"first process init\");\n+\n+    // We've done the kernel initialization. Switch into the init...\n+    switch();\n+\n+    // We're now in the idle thread context.\n+    idle_thread();\n+}\n+\n+fn idle_thread() -> ! {\n+    loop {\n+        idle();\n+    }\n+}\ndiff --git a/kernel/mm/global_allocator.rs /dev/null\n--- a/kernel/mm/global_allocator.rs\n+++ /dev/null\n@@ -1,48 +0,0 @@\n-use core::sync::atomic::{AtomicBool, Ordering};\n-\n-use crate::arch::PAGE_SIZE;\n-use buddy_system_allocator::LockedHeap;\n-\n-use super::page_allocator::{alloc_pages, AllocPageFlags};\n-\n-#[global_allocator]\n-static ALLOCATOR: LockedHeap<32 /* order */> = LockedHeap::empty();\n-static KERNEL_HEAP_ENABLED: AtomicBool = AtomicBool::new(false);\n-\n-#[alloc_error_handler]\n-fn alloc_error_handler(layout: core::alloc::Layout) -> ! {\n-    panic!(\"alloc error: layout={:?}\", layout);\n-}\n-\n-pub fn is_kernel_heap_enabled() -> bool {\n-    KERNEL_HEAP_ENABLED.load(Ordering::Acquire)\n-}\n-\n-pub fn init() {\n-    unsafe {\n-        // TODO: Expand the kernel heap when it has been exhausted.\n-        let size = 1024 * 1024;\n-        let start = alloc_pages(size / PAGE_SIZE, AllocPageFlags::KERNEL)\n-            .expect(\"failed to reserve memory pages for the global alllocator\")\n-            .as_vaddr()\n-            .value();\n-        ALLOCATOR.lock().init(start, size);\n-    }\n-\n-    KERNEL_HEAP_ENABLED.store(true, Ordering::Release);\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    #![allow(clippy::vec_init_then_push)]\n-\n-    #[test_case]\n-    fn alloc_crate_test() {\n-        use alloc::vec::Vec;\n-        let mut v = Vec::with_capacity(1);\n-        v.push('a');\n-        v.push('b');\n-        v.push('c');\n-        assert_eq!(v.as_slice(), &['a', 'b', 'c']);\n-    }\n-}\ndiff --git a/kernel/test_runner.rs b/kernel/test_runner.rs\n--- a/kernel/test_runner.rs\n+++ b/kernel/test_runner.rs\n@@ -1,10 +1,11 @@\n #![cfg(test)]\n #![allow(clippy::print_with_newline)]\n \n-use crate::arch::*;\n use core::panic::PanicInfo;\n use core::sync::atomic::Ordering;\n \n+use kerla_runtime::arch::{semihosting_halt, SemihostingExitStatus};\n+\n pub trait Testable {\n     fn run(&self);\n }\ndiff --git a/kernel/test_runner.rs b/kernel/test_runner.rs\n--- a/kernel/test_runner.rs\n+++ b/kernel/test_runner.rs\n@@ -30,7 +31,7 @@ pub fn run_tests(tests: &[&dyn Testable]) {\n }\n \n pub fn end_tests() -> ! {\n-    semihosting_halt(ExitStatus::Success);\n+    semihosting_halt(SemihostingExitStatus::Success);\n \n     #[allow(clippy::empty_loop)]\n     loop {}\ndiff --git a/kernel/test_runner.rs b/kernel/test_runner.rs\n--- a/kernel/test_runner.rs\n+++ b/kernel/test_runner.rs\n@@ -47,6 +48,6 @@ fn panic(info: &PanicInfo) -> ! {\n \n     PANICKED.store(true, Ordering::SeqCst);\n     print!(\"\\x1b[1;91mfail\\npanic: {}\\x1b[0m\", info);\n-    semihosting_halt(ExitStatus::Failure);\n+    semihosting_halt(SemihostingExitStatus::Failure);\n     loop {}\n }\ndiff --git a/kernel/arch/x64/idle.rs b/runtime/x64/idle.rs\n--- a/kernel/arch/x64/idle.rs\n+++ b/runtime/x64/idle.rs\n@@ -8,7 +8,7 @@ pub fn idle() {\n \n #[cfg_attr(test, allow(unused))]\n pub fn halt() -> ! {\n-    semihosting_halt(ExitStatus::Success);\n+    semihosting_halt(SemihostingExitStatus::Success);\n \n     loop {\n         unsafe {\ndiff --git a/kernel/arch/x64/semihosting.rs b/runtime/x64/semihosting.rs\n--- a/kernel/arch/x64/semihosting.rs\n+++ b/runtime/x64/semihosting.rs\n@@ -2,13 +2,12 @@ use x86::io::outw;\n \n #[repr(u32)]\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum ExitStatus {\n+pub enum SemihostingExitStatus {\n     Success = 0x10,\n-    #[cfg(test)]\n     Failure = 0x11,\n }\n \n-pub fn semihosting_halt(status: ExitStatus) {\n+pub fn semihosting_halt(status: SemihostingExitStatus) {\n     unsafe {\n         outw(0x501, status as u16);\n     }\ndiff --git /dev/null b/runtime/x64/trap.S\nnew file mode 100644\n--- /dev/null\n+++ b/runtime/x64/trap.S\n@@ -0,0 +1,110 @@\n+//\n+//  Interrupt/exception handlers\n+//\n+.set INTERRUPT_HANDLER_SIZE, 16\n+\n+.align INTERRUPT_HANDLER_SIZE\n+.global interrupt_handlers\n+interrupt_handlers:\n+.set i, 0\n+.rept 256\n+.set handler_start, .\n+// Exceptions with error code.\n+.if i == 8 || 10 <= i && i <= 14 || i == 17\n+    .align INTERRUPT_HANDLER_SIZE\n+    cli\n+    push i\n+    jmp interrupt_common\n+    .align INTERRUPT_HANDLER_SIZE\n+// Interrupts and exceptions without error code.\n+.else\n+    .align INTERRUPT_HANDLER_SIZE\n+    cli\n+    push 0 // Dummy value as error code.\n+    push i\n+    jmp interrupt_common\n+    .align INTERRUPT_HANDLER_SIZE\n+.endif\n+\n+// Increment the counter.\n+.set i, i + 1\n+.endr\n+\n+.extern x64_handle_interrupt\n+interrupt_common:\n+    //\n+    //  The current stack frame:\n+    //\n+    //            +--------------------+\n+    //     48     |        SS          |\n+    //            +--------------------+\n+    //     40     |        RSP         |\n+    //            +--------------------+\n+    //     32     |       RFLAGS       |\n+    //            +--------------------+\n+    //     24     |        CS          |\n+    //            +--------------------+\n+    //     16     |        RIP         |\n+    //            +--------------------+\n+    //      8     |     Error code     |\n+    //            +--------------------+\n+    //      0     |     IRQ Number     | <- RSP\n+    //            +--------------------+\n+    //\n+\n+    // Check CS register in the IRET frame to determine if the interrupt has\n+    // occurred in user mode.\n+    test qword ptr [rsp + 24], 3\n+    jz 1f\n+    swapgs\n+1:\n+    // Save RDI and set the IRQ number to RDI at once.\n+    xchg rdi, [rsp]\n+\n+    // Save registers except RDI (we have already saved it above).\n+    push r15\n+    push r14\n+    push r13\n+    push r12\n+    push r11\n+    push r10\n+    push r9\n+    push r8\n+    push rbp\n+    push rsi\n+    push rdx\n+    push rcx\n+    push rbx\n+    push rax\n+\n+    mov rsi, rsp\n+    call x64_handle_interrupt\n+\n+    pop rax\n+    pop rbx\n+    pop rcx\n+    pop rdx\n+    pop rsi\n+    pop rbp\n+    pop r8\n+    pop r9\n+    pop r10\n+    pop r11\n+    pop r12\n+    pop r13\n+    pop r14\n+    pop r15\n+    pop rdi\n+\n+    // Skip error code.\n+    add rsp, 8\n+\n+    // Check CS register in the IRET frame to determine whether the exception\n+    // occur in the userspace. If so, do SWAPGS.\n+    test qword ptr [rsp + 8], 3\n+    jz 1f\n+\n+    cli\n+    swapgs\n+1:\n+    iretq\n",
        "problem_statement": "Turn hardware abstraction layer into a library\nTo implement kernel extensions (#71), we need to isolate arch-specific stuff from the kernel crate. Moreover, it makes a lot easier to port Kerla to another CPU architectures like Arm.\n",
        "hints_text": "",
        "created_at": "2021-11-11T13:22:15Z"
    },
    {
        "repo": "nuta/kerla",
        "pull_number": 80,
        "instance_id": "nuta__kerla-80",
        "issue_numbers": [
            "71"
        ],
        "base_commit": "81b2774324a913d50d1bde0b42852558a64cfaef",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -143,6 +143,18 @@ dependencies = [\n  \"ahash\",\n ]\n \n+[[package]]\n+name = \"kerla_api\"\n+version = \"0.0.1\"\n+dependencies = [\n+ \"arrayvec 0.7.2\",\n+ \"kerla_runtime\",\n+ \"kerla_utils\",\n+ \"log\",\n+ \"memoffset\",\n+ \"x86\",\n+]\n+\n [[package]]\n name = \"kerla_kernel\"\n version = \"0.0.4\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -153,12 +165,13 @@ dependencies = [\n  \"crossbeam\",\n  \"goblin\",\n  \"hashbrown\",\n+ \"kerla_api\",\n  \"kerla_runtime\",\n  \"kerla_utils\",\n  \"log\",\n- \"memoffset\",\n  \"smoltcp\",\n  \"spin 0.9.2\",\n+ \"virtio_net\",\n  \"x86\",\n ]\n \ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -320,6 +333,27 @@ version = \"0.9.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5fecdca9a5291cc2b8dcf7dc02453fee791a280f3743cb0905f8822ae463b3fe\"\n \n+[[package]]\n+name = \"virtio\"\n+version = \"0.0.1\"\n+dependencies = [\n+ \"bitflags\",\n+ \"kerla_api\",\n+ \"kerla_utils\",\n+ \"memoffset\",\n+]\n+\n+[[package]]\n+name = \"virtio_net\"\n+version = \"0.0.1\"\n+dependencies = [\n+ \"bitflags\",\n+ \"kerla_api\",\n+ \"kerla_utils\",\n+ \"memoffset\",\n+ \"virtio\",\n+]\n+\n [[package]]\n name = \"vte\"\n version = \"0.10.1\"\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -3,6 +3,7 @@ members = [\n     \"runtime\",\n     \"kernel\",\n     \"libs/*\",\n+    \"exts/*\",\n ]\n \n [profile.release]\ndiff --git /dev/null b/exts/virtio_net/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/exts/virtio_net/Cargo.toml\n@@ -0,0 +1,17 @@\n+[package]\n+name = \"virtio_net\"\n+version = \"0.0.1\"\n+authors = [\"Seiya Nuta <nuta@seiya.me>\"]\n+edition = \"2021\"\n+\n+[lib]\n+name = \"virtio_net\"\n+path = \"lib.rs\"\n+\n+[dependencies]\n+bitflags = \"1.3.2\"\n+memoffset = \"0.6.4\"\n+\n+kerla_api = { path = \"../../libs/kerla_api\" }\n+kerla_utils = { path = \"../../libs/kerla_utils\" }\n+virtio = { path = \"../../libs/virtio\" }\ndiff --git /dev/null b/exts/virtio_net/lib.rs\nnew file mode 100644\n--- /dev/null\n+++ b/exts/virtio_net/lib.rs\n@@ -0,0 +1,317 @@\n+//! A virtio-net device driver.\n+#![no_std]\n+\n+extern crate alloc;\n+\n+#[macro_use]\n+extern crate kerla_api;\n+\n+use alloc::boxed::Box;\n+use alloc::sync::Arc;\n+use core::mem::size_of;\n+use kerla_api::driver::register_driver_prober;\n+use kerla_api::net::receive_ethernet_frame;\n+use memoffset::offset_of;\n+\n+use virtio::device::{IsrStatus, Virtio, VirtqDescBuffer, VirtqUsedChain};\n+use virtio::transports::virtio_pci::VirtioAttachError;\n+use virtio::transports::{virtio_mmio::VirtioMmio, virtio_pci::VirtioPci, VirtioTransport};\n+\n+use kerla_api::address::VAddr;\n+use kerla_api::arch::PAGE_SIZE;\n+use kerla_api::driver::{\n+    attach_irq,\n+    net::{register_ethernet_driver, Driver, EthernetDriver, MacAddress},\n+    DeviceProber,\n+};\n+use kerla_api::driver::{pci::PciDevice, VirtioMmioDevice};\n+use kerla_api::mm::{alloc_pages, AllocPageFlags};\n+use kerla_api::sync::SpinLock;\n+use kerla_utils::alignment::align_up;\n+\n+const VIRTIO_NET_F_MAC: u64 = 1 << 5;\n+\n+const VIRTIO_NET_QUEUE_RX: u16 = 0;\n+const VIRTIO_NET_QUEUE_TX: u16 = 1;\n+\n+const PACKET_LEN_MAX: usize = 2048;\n+\n+#[derive(Debug, Copy, Clone)]\n+#[repr(C, packed)]\n+struct VirtioNetHeader {\n+    flags: u8,\n+    gso_type: u8,\n+    hdr_len: u16,\n+    gso_size: u16,\n+    checksum_start: u16,\n+    checksum_offset: u16,\n+    num_buffer: u16,\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+#[repr(C, packed)]\n+struct VirtioNetConfig {\n+    mac: [u8; 6],\n+    status: u16,\n+    max_virtqueue_pairs: u16,\n+    mtu: u16,\n+}\n+\n+pub struct VirtioNet {\n+    mac_addr: MacAddress,\n+    virtio: Virtio,\n+    tx_ring_len: usize,\n+    tx_ring_index: usize,\n+    tx_buffer: VAddr,\n+    _rx_buffer: VAddr,\n+}\n+\n+impl VirtioNet {\n+    pub fn new(transport: Arc<dyn VirtioTransport>) -> Result<VirtioNet, VirtioAttachError> {\n+        let mut virtio = Virtio::new(transport);\n+        virtio.initialize(VIRTIO_NET_F_MAC, 2 /* RX and TX queues. */)?;\n+\n+        // Read the MAC address.\n+        let mut mac_addr = [0; 6];\n+        for (i, byte) in mac_addr.iter_mut().enumerate() {\n+            *byte = virtio.read_device_config8((offset_of!(VirtioNetConfig, mac) + i) as u16);\n+        }\n+        info!(\n+            \"virtio-net: MAC address is {:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}\",\n+            mac_addr[0], mac_addr[1], mac_addr[2], mac_addr[3], mac_addr[4], mac_addr[5],\n+        );\n+\n+        let tx_ring_len = virtio.virtq(VIRTIO_NET_QUEUE_RX).num_descs() as usize;\n+        let rx_ring_len = virtio.virtq(VIRTIO_NET_QUEUE_TX).num_descs() as usize;\n+        let tx_buffer = alloc_pages(\n+            (align_up(PACKET_LEN_MAX * tx_ring_len, PAGE_SIZE)) / PAGE_SIZE,\n+            AllocPageFlags::KERNEL,\n+        )\n+        .unwrap()\n+        .as_vaddr();\n+        let rx_buffer = alloc_pages(\n+            (align_up(PACKET_LEN_MAX * rx_ring_len, PAGE_SIZE)) / PAGE_SIZE,\n+            AllocPageFlags::KERNEL,\n+        )\n+        .unwrap()\n+        .as_vaddr();\n+\n+        let rx_virtq = virtio.virtq_mut(VIRTIO_NET_QUEUE_RX);\n+        for i in 0..rx_ring_len {\n+            rx_virtq.enqueue(&[VirtqDescBuffer::WritableFromDevice {\n+                addr: rx_buffer.add(i * PACKET_LEN_MAX).as_paddr(),\n+                len: PACKET_LEN_MAX,\n+            }])\n+        }\n+\n+        Ok(VirtioNet {\n+            mac_addr: MacAddress::new(mac_addr),\n+            virtio,\n+            tx_buffer,\n+            _rx_buffer: rx_buffer,\n+            tx_ring_len,\n+            tx_ring_index: 0,\n+        })\n+    }\n+\n+    pub fn handle_irq(&mut self) {\n+        if !self\n+            .virtio\n+            .read_isr_status()\n+            .contains(IsrStatus::QUEUE_INTR)\n+        {\n+            return;\n+        }\n+\n+        let rx_virtq = self.virtio.virtq_mut(VIRTIO_NET_QUEUE_RX);\n+\n+        while let Some(VirtqUsedChain { descs, total_len }) = rx_virtq.pop_used() {\n+            debug_assert!(descs.len() == 1);\n+            let addr = match descs[0] {\n+                VirtqDescBuffer::WritableFromDevice { addr, .. } => addr,\n+                VirtqDescBuffer::ReadOnlyFromDevice { .. } => unreachable!(),\n+            };\n+\n+            if total_len < size_of::<VirtioNetHeader>() {\n+                warn!(\"virtio-net: received a too short buffer, ignoring...\");\n+                continue;\n+            }\n+\n+            trace!(\n+                \"virtio-net: received {} octets (paddr={}, payload_len={})\",\n+                total_len,\n+                addr,\n+                total_len - size_of::<VirtioNetHeader>()\n+            );\n+\n+            let buffer = unsafe {\n+                core::slice::from_raw_parts(\n+                    addr.as_ptr::<u8>().add(size_of::<VirtioNetHeader>()),\n+                    total_len - size_of::<VirtioNetHeader>(),\n+                )\n+            };\n+            receive_ethernet_frame(buffer);\n+\n+            rx_virtq.enqueue(&[VirtqDescBuffer::WritableFromDevice {\n+                addr,\n+                len: PACKET_LEN_MAX,\n+            }])\n+        }\n+    }\n+\n+    fn mac_addr(&self) -> MacAddress {\n+        self.mac_addr\n+    }\n+\n+    fn transmit(&mut self, frame: &[u8]) {\n+        let i = self.tx_ring_index % self.tx_ring_len;\n+        let addr = self.tx_buffer.add(i * PACKET_LEN_MAX);\n+\n+        trace!(\n+            \"virtio-net: transmitting {} octets (tx_ring={}, paddr={})\",\n+            frame.len(),\n+            i,\n+            addr.as_paddr()\n+        );\n+\n+        // Fill the virtio-net header.\n+        let header_len = size_of::<VirtioNetHeader>();\n+        assert!(frame.len() <= PACKET_LEN_MAX - header_len);\n+        let header = unsafe { &mut *addr.as_mut_ptr::<VirtioNetHeader>() };\n+        header.flags = 0;\n+        header.gso_type = 0;\n+        header.gso_size = 0;\n+        header.checksum_start = 0;\n+        header.checksum_offset = 0;\n+        header.num_buffer = 1;\n+\n+        // Copy the payload into the our buffer.\n+        unsafe {\n+            addr.as_mut_ptr::<u8>()\n+                .add(header_len)\n+                .copy_from_nonoverlapping(frame.as_ptr(), frame.len());\n+        }\n+\n+        // Construct a descriptor chain.\n+        let chain = &[VirtqDescBuffer::ReadOnlyFromDevice {\n+            addr: addr.as_paddr(),\n+            len: header_len + frame.len(),\n+        }];\n+\n+        // Enqueue the transmission request and kick the device.\n+        let tx_virtq = self.virtio.virtq_mut(VIRTIO_NET_QUEUE_TX);\n+        tx_virtq.enqueue(chain);\n+        tx_virtq.notify();\n+\n+        self.tx_ring_index += 1;\n+    }\n+}\n+\n+struct VirtioNetDriver {\n+    device: Arc<SpinLock<VirtioNet>>,\n+}\n+\n+impl VirtioNetDriver {\n+    fn new(device: Arc<SpinLock<VirtioNet>>) -> VirtioNetDriver {\n+        VirtioNetDriver { device }\n+    }\n+}\n+\n+impl Driver for VirtioNetDriver {\n+    fn name(&self) -> &str {\n+        \"virtio-net\"\n+    }\n+}\n+\n+impl EthernetDriver for VirtioNetDriver {\n+    fn mac_addr(&self) -> MacAddress {\n+        self.device.lock().mac_addr()\n+    }\n+\n+    fn transmit(&self, frame: &[u8]) {\n+        self.device.lock().transmit(frame);\n+    }\n+}\n+\n+pub struct VirtioNetProber {}\n+\n+#[allow(clippy::new_without_default)]\n+impl VirtioNetProber {\n+    pub fn new() -> VirtioNetProber {\n+        VirtioNetProber {}\n+    }\n+}\n+\n+impl DeviceProber for VirtioNetProber {\n+    fn probe_pci(&self, pci_device: &PciDevice) {\n+        // Check if the device is a network card (\"4.1.2 PCI Device Discovery\").\n+        if pci_device.config().vendor_id() == 0x1af4\n+            && pci_device.config().device_id() != 0x1040 + 1\n+        {\n+            return;\n+        }\n+\n+        trace!(\"virtio-net: found the device (over PCI)\");\n+        let device = match VirtioPci::probe_pci(pci_device, VirtioNet::new) {\n+            Ok(device) => Arc::new(SpinLock::new(device)),\n+            Err(VirtioAttachError::InvalidVendorId) => {\n+                // Not a virtio-net device.\n+                return;\n+            }\n+            Err(err) => {\n+                warn!(\"failed to attach a virtio-net: {:?}\", err);\n+                return;\n+            }\n+        };\n+\n+        register_ethernet_driver(Box::new(VirtioNetDriver::new(device.clone())));\n+        attach_irq(pci_device.config().interrupt_line(), move || {\n+            device.lock().handle_irq();\n+        });\n+    }\n+\n+    fn probe_virtio_mmio(&self, mmio_device: &VirtioMmioDevice) {\n+        let mmio = mmio_device.mmio_base.as_vaddr();\n+        let magic = unsafe { *mmio.as_ptr::<u32>() };\n+        let virtio_version = unsafe { *mmio.add(4).as_ptr::<u32>() };\n+        let device_id = unsafe { *mmio.add(8).as_ptr::<u32>() };\n+\n+        if magic != 0x74726976 {\n+            return;\n+        }\n+\n+        if virtio_version != 2 {\n+            warn!(\"unsupported virtio device version: {}\", virtio_version);\n+            return;\n+        }\n+\n+        // It looks like a virtio device. Check if the device is a network card.\n+        if device_id != 1 {\n+            return;\n+        }\n+\n+        trace!(\"virtio-net: found the device (over MMIO)\");\n+\n+        let transport = Arc::new(VirtioMmio::new(mmio_device.mmio_base));\n+        let device = match VirtioNet::new(transport) {\n+            Ok(device) => Arc::new(SpinLock::new(device)),\n+            Err(VirtioAttachError::InvalidVendorId) => {\n+                // Not a virtio-net device.\n+                return;\n+            }\n+            Err(err) => {\n+                warn!(\"failed to attach a virtio-net: {:?}\", err);\n+                return;\n+            }\n+        };\n+\n+        register_ethernet_driver(Box::new(VirtioNetDriver::new(device.clone())));\n+        attach_irq(mmio_device.irq, move || {\n+            device.lock().handle_irq();\n+        });\n+    }\n+}\n+\n+pub fn init() {\n+    register_driver_prober(Box::new(VirtioNetProber::new()));\n+}\ndiff --git a/kernel/drivers/virtio/transports/mod.rs b/exts/virtio_net/transports/mod.rs\n--- a/kernel/drivers/virtio/transports/mod.rs\n+++ b/exts/virtio_net/transports/mod.rs\n@@ -1,6 +1,6 @@\n-use kerla_runtime::address::PAddr;\n+use crate::virtio::IsrStatus;\n \n-use crate::drivers::virtio::virtio::IsrStatus;\n+use kerla_api::address::PAddr;\n \n pub mod virtio_mmio;\n pub mod virtio_pci;\ndiff --git a/kernel/drivers/virtio/transports/virtio_mmio.rs b/exts/virtio_net/transports/virtio_mmio.rs\n--- a/kernel/drivers/virtio/transports/virtio_mmio.rs\n+++ b/exts/virtio_net/transports/virtio_mmio.rs\n@@ -1,7 +1,8 @@\n-use kerla_runtime::address::{PAddr, VAddr};\n+use crate::virtio::IsrStatus;\n+\n+use kerla_api::address::{PAddr, VAddr};\n \n use super::VirtioTransport;\n-use crate::drivers::virtio::virtio::IsrStatus;\n \n pub struct VirtioMmio {\n     mmio_base: VAddr,\ndiff --git a/kernel/drivers/virtio/transports/virtio_pci.rs b/exts/virtio_net/transports/virtio_pci.rs\n--- a/kernel/drivers/virtio/transports/virtio_pci.rs\n+++ b/exts/virtio_net/transports/virtio_pci.rs\n@@ -1,13 +1,15 @@\n+use crate::virtio::IsrStatus;\n+\n use core::convert::TryInto;\n \n+use alloc::sync::Arc;\n+use kerla_api::{\n+    address::{PAddr, VAddr},\n+    driver::pci::{Bar, PciCapability, PciDevice},\n+};\n use memoffset::offset_of;\n \n use super::VirtioTransport;\n-use crate::drivers::pci::{Bar, PciDevice};\n-use crate::drivers::{pci::PciCapability, virtio::virtio::IsrStatus};\n-use crate::{drivers::Driver, prelude::*};\n-use kerla_runtime::address::{VAddr,PAddr};\n-use kerla_runtime::spinlock::SpinLock;\n \n const VIRTIO_PCI_CAP_COMMON_CFG: u8 = 1;\n const VIRTIO_PCI_CAP_NOTIFY_CFG: u8 = 2;\ndiff --git a/kernel/drivers/virtio/transports/virtio_pci.rs b/exts/virtio_net/transports/virtio_pci.rs\n--- a/kernel/drivers/virtio/transports/virtio_pci.rs\n+++ b/exts/virtio_net/transports/virtio_pci.rs\n@@ -45,6 +47,13 @@ fn get_bar_for_cfg_type(pci_device: &PciDevice, cfg_type: u8) -> Option<(&PciCap\n     }\n }\n \n+#[derive(Debug)]\n+pub enum VirtioAttachError {\n+    InvalidVendorId,\n+    MissingFeatures,\n+    FeatureNegotiationFailure,\n+}\n+\n pub struct VirtioPci {\n     common_cfg: VAddr,\n     device_cfg: VAddr,\ndiff --git a/kernel/drivers/virtio/transports/virtio_pci.rs b/exts/virtio_net/transports/virtio_pci.rs\n--- a/kernel/drivers/virtio/transports/virtio_pci.rs\n+++ b/exts/virtio_net/transports/virtio_pci.rs\n@@ -54,14 +63,13 @@ pub struct VirtioPci {\n }\n \n impl VirtioPci {\n-    pub fn attach_pci<F, T>(pci_device: &PciDevice, ctor: F) -> Result<Arc<SpinLock<T>>>\n+    pub fn probe_pci<F, T>(pci_device: &PciDevice, ctor: F) -> Result<T, VirtioAttachError>\n     where\n-        F: FnOnce(Arc<dyn VirtioTransport>) -> Result<T>,\n-        T: Driver,\n+        F: FnOnce(Arc<dyn VirtioTransport>) -> Result<T, VirtioAttachError>,\n     {\n         // TODO: Check device type\n         if pci_device.config().vendor_id() != 0x1af4 {\n-            return Err(Errno::EINVAL.into());\n+            return Err(VirtioAttachError::InvalidVendorId);\n         }\n \n         let common_cfg = get_bar_for_cfg_type(pci_device, VIRTIO_PCI_CAP_COMMON_CFG)\ndiff --git a/kernel/drivers/virtio/transports/virtio_pci.rs b/exts/virtio_net/transports/virtio_pci.rs\n--- a/kernel/drivers/virtio/transports/virtio_pci.rs\n+++ b/exts/virtio_net/transports/virtio_pci.rs\n@@ -96,9 +104,8 @@ impl VirtioPci {\n             notify_off_multiplier,\n             isr,\n         });\n-        let driver = Arc::new(SpinLock::new(ctor(transport)?));\n \n-        Ok(driver)\n+        ctor(transport)\n     }\n }\n \ndiff --git a/kernel/drivers/virtio/virtio.rs b/exts/virtio_net/virtio.rs\n--- a/kernel/drivers/virtio/virtio.rs\n+++ b/exts/virtio_net/virtio.rs\n@@ -1,16 +1,18 @@\n //! A virtio device driver library.\n-use crate::prelude::*;\n-use crate::result::{Errno, Result};\n+use alloc::sync::Arc;\n+use alloc::vec::Vec;\n use bitflags::bitflags;\n use core::cmp::min;\n use core::convert::TryInto;\n use core::mem::size_of;\n use core::sync::atomic::{self, Ordering};\n-use kerla_runtime::address::{PAddr, VAddr};\n-use kerla_runtime::arch::PAGE_SIZE;\n-use kerla_runtime::page_allocator::{alloc_pages, AllocPageFlags};\n+use kerla_api::address::{PAddr, VAddr};\n+use kerla_api::arch::PAGE_SIZE;\n+use kerla_api::mm::{alloc_pages, AllocPageFlags};\n use kerla_utils::alignment::align_up;\n \n+use crate::transports::virtio_pci::VirtioAttachError;\n+\n use super::transports::VirtioTransport;\n \n const VIRTIO_STATUS_ACK: u8 = 1;\ndiff --git a/kernel/drivers/virtio/virtio.rs b/exts/virtio_net/virtio.rs\n--- a/kernel/drivers/virtio/virtio.rs\n+++ b/exts/virtio_net/virtio.rs\n@@ -140,7 +142,7 @@ impl VirtQueue {\n     ///\n     /// Once you've enqueued all requests, you need to notify the device through\n     /// the `notify` method.\n-    pub fn enqueue(&mut self, chain: &[VirtqDescBuffer]) -> Result<()> {\n+    pub fn enqueue(&mut self, chain: &[VirtqDescBuffer]) {\n         debug_assert!(!chain.is_empty());\n \n         // Try freeing used descriptors.\ndiff --git a/kernel/drivers/virtio/virtio.rs b/exts/virtio_net/virtio.rs\n--- a/kernel/drivers/virtio/virtio.rs\n+++ b/exts/virtio_net/virtio.rs\n@@ -172,7 +174,7 @@ impl VirtQueue {\n \n         // Check if we have the enough number of free descriptors.\n         if (self.num_free_descs as usize) < chain.len() {\n-            return Err(Errno::ENOMEM.into());\n+            return;\n         }\n \n         let head_index = self.free_head;\ndiff --git a/kernel/drivers/virtio/virtio.rs b/exts/virtio_net/virtio.rs\n--- a/kernel/drivers/virtio/virtio.rs\n+++ b/exts/virtio_net/virtio.rs\n@@ -204,8 +206,6 @@ impl VirtQueue {\n         let avail_elem_index = self.avail().index;\n         *self.avail_elem_mut(avail_elem_index) = head_index;\n         self.avail_mut().index = self.avail_mut().index.wrapping_add(1);\n-\n-        Ok(())\n     }\n \n     /// Notifies the device to start processing descriptors.\ndiff --git a/kernel/drivers/virtio/virtio.rs b/exts/virtio_net/virtio.rs\n--- a/kernel/drivers/virtio/virtio.rs\n+++ b/exts/virtio_net/virtio.rs\n@@ -337,7 +337,11 @@ impl Virtio {\n \n     /// Initialize the virtio device. It aborts if any of the features is not\n     /// supported.\n-    pub fn initialize(&mut self, mut features: u64, num_virtqueues: u16) -> Result<()> {\n+    pub fn initialize(\n+        &mut self,\n+        mut features: u64,\n+        num_virtqueues: u16,\n+    ) -> Result<(), VirtioAttachError> {\n         features |= VIRTIO_F_VERSION_1;\n \n         // \"3.1.1 Driver Requirements: Device Initialization\"\ndiff --git a/kernel/drivers/virtio/virtio.rs b/exts/virtio_net/virtio.rs\n--- a/kernel/drivers/virtio/virtio.rs\n+++ b/exts/virtio_net/virtio.rs\n@@ -355,7 +359,7 @@ impl Virtio {\n                 device_features,\n                 features & !device_features\n             );\n-            return Err(Errno::EINVAL.into());\n+            return Err(VirtioAttachError::MissingFeatures);\n         }\n \n         self.transport.write_driver_features(features);\ndiff --git a/kernel/drivers/virtio/virtio.rs b/exts/virtio_net/virtio.rs\n--- a/kernel/drivers/virtio/virtio.rs\n+++ b/exts/virtio_net/virtio.rs\n@@ -363,7 +367,7 @@ impl Virtio {\n             .write_device_status(self.transport.read_device_status() | VIRTIO_STATUS_FEAT_OK);\n \n         if (self.transport.read_device_status() & VIRTIO_STATUS_FEAT_OK) == 0 {\n-            return Err(Errno::EINVAL.into());\n+            return Err(VirtioAttachError::FeatureNegotiationFailure);\n         }\n \n         // Initialize virtqueues.\ndiff --git a/kernel/drivers/virtio/virtio_net.rs b/exts/virtio_net/virtio_net.rs\n--- a/kernel/drivers/virtio/virtio_net.rs\n+++ b/exts/virtio_net/virtio_net.rs\n@@ -1,30 +1,25 @@\n //! A virtio-net device driver.\n-use super::virtio::{IsrStatus, Virtio};\n-use crate::net::{process_packets, receive_ethernet_frame};\n-use crate::{\n-    drivers::register_ethernet_driver,\n-    result::{Errno, Result},\n-};\n-use crate::{\n-    drivers::{\n-        pci::PciDevice,\n-        virtio::{\n-            transports::{virtio_mmio::VirtioMmio, virtio_pci::VirtioPci, VirtioTransport},\n-            virtio::VirtqUsedChain,\n-        },\n-        Driver, DriverBuilder, EthernetDriver, MacAddress,\n-    },\n-    interrupt::attach_irq,\n-};\n+use alloc::boxed::Box;\n use alloc::sync::Arc;\n use core::mem::size_of;\n-use kerla_runtime::arch::PAGE_SIZE;\n-use kerla_runtime::spinlock::SpinLock;\n-use kerla_runtime::{\n-    address::VAddr,\n-    bootinfo::VirtioMmioDevice,\n-    page_allocator::{alloc_pages, AllocPageFlags},\n+use kerla_api::driver::register_driver_builder;\n+use kerla_api::net::receive_ethernet_frame;\n+use memoffset::offset_of;\n+\n+use crate::transports::virtio_pci::VirtioAttachError;\n+use crate::transports::{virtio_mmio::VirtioMmio, virtio_pci::VirtioPci, VirtioTransport};\n+use crate::virtio::{IsrStatus, Virtio, VirtqUsedChain};\n+\n+use kerla_api::address::VAddr;\n+use kerla_api::arch::PAGE_SIZE;\n+use kerla_api::driver::{\n+    attach_irq,\n+    net::{register_ethernet_driver, Driver, EthernetDriver, MacAddress},\n+    DriverBuilder,\n };\n+use kerla_api::driver::{pci::PciDevice, VirtioMmioDevice};\n+use kerla_api::mm::{alloc_pages, AllocPageFlags};\n+use kerla_api::sync::SpinLock;\n use kerla_utils::alignment::align_up;\n \n const VIRTIO_NET_F_MAC: u64 = 1 << 5;\ndiff --git a/kernel/drivers/virtio/virtio_net.rs b/exts/virtio_net/virtio_net.rs\n--- a/kernel/drivers/virtio/virtio_net.rs\n+++ b/exts/virtio_net/virtio_net.rs\n@@ -65,15 +60,14 @@ pub struct VirtioNet {\n }\n \n impl VirtioNet {\n-    pub fn new(transport: Arc<dyn VirtioTransport>) -> Result<VirtioNet> {\n+    pub fn new(transport: Arc<dyn VirtioTransport>) -> Result<VirtioNet, VirtioAttachError> {\n         let mut virtio = Virtio::new(transport);\n         virtio.initialize(VIRTIO_NET_F_MAC, 2 /* RX and TX queues. */)?;\n \n         // Read the MAC address.\n         let mut mac_addr = [0; 6];\n         for (i, byte) in mac_addr.iter_mut().enumerate() {\n-            *byte = virtio\n-                .read_device_config8((memoffset::offset_of!(VirtioNetConfig, mac) + i) as u16);\n+            *byte = virtio.read_device_config8((offset_of!(VirtioNetConfig, mac) + i) as u16);\n         }\n         info!(\n             \"virtio-net: MAC address is {:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}\",\ndiff --git a/kernel/drivers/virtio/virtio_net.rs b/exts/virtio_net/virtio_net.rs\n--- a/kernel/drivers/virtio/virtio_net.rs\n+++ b/exts/virtio_net/virtio_net.rs\n@@ -97,12 +91,10 @@ impl VirtioNet {\n \n         let rx_virtq = virtio.virtq_mut(VIRTIO_NET_QUEUE_RX);\n         for i in 0..rx_ring_len {\n-            rx_virtq\n-                .enqueue(&[super::virtio::VirtqDescBuffer::WritableFromDevice {\n-                    addr: rx_buffer.add(i * PACKET_LEN_MAX).as_paddr(),\n-                    len: PACKET_LEN_MAX,\n-                }])\n-                .unwrap();\n+            rx_virtq.enqueue(&[super::virtio::VirtqDescBuffer::WritableFromDevice {\n+                addr: rx_buffer.add(i * PACKET_LEN_MAX).as_paddr(),\n+                len: PACKET_LEN_MAX,\n+            }])\n         }\n \n         Ok(VirtioNet {\ndiff --git a/kernel/drivers/virtio/virtio_net.rs b/exts/virtio_net/virtio_net.rs\n--- a/kernel/drivers/virtio/virtio_net.rs\n+++ b/exts/virtio_net/virtio_net.rs\n@@ -153,28 +145,18 @@ impl VirtioNet {\n             };\n             receive_ethernet_frame(buffer);\n \n-            warn_if_err!(\n-                rx_virtq.enqueue(&[super::virtio::VirtqDescBuffer::WritableFromDevice {\n-                    addr,\n-                    len: PACKET_LEN_MAX,\n-                }])\n-            );\n+            rx_virtq.enqueue(&[super::virtio::VirtqDescBuffer::WritableFromDevice {\n+                addr,\n+                len: PACKET_LEN_MAX,\n+            }])\n         }\n     }\n-}\n-\n-impl Driver for VirtioNet {\n-    fn name(&self) -> &str {\n-        \"virtio-net\"\n-    }\n-}\n \n-impl EthernetDriver for VirtioNet {\n-    fn mac_addr(&self) -> Result<MacAddress> {\n-        Ok(self.mac_addr)\n+    fn mac_addr(&self) -> MacAddress {\n+        self.mac_addr\n     }\n \n-    fn transmit(&mut self, frame: &[u8]) -> Result<()> {\n+    fn transmit(&mut self, frame: &[u8]) {\n         let i = self.tx_ring_index % self.tx_ring_len;\n         let addr = self.tx_buffer.add(i * PACKET_LEN_MAX);\n \ndiff --git a/kernel/drivers/virtio/virtio_net.rs b/exts/virtio_net/virtio_net.rs\n--- a/kernel/drivers/virtio/virtio_net.rs\n+++ b/exts/virtio_net/virtio_net.rs\n@@ -211,11 +193,36 @@ impl EthernetDriver for VirtioNet {\n \n         // Enqueue the transmission request and kick the device.\n         let tx_virtq = self.virtio.virtq_mut(VIRTIO_NET_QUEUE_TX);\n-        tx_virtq.enqueue(chain)?;\n+        tx_virtq.enqueue(chain);\n         tx_virtq.notify();\n \n         self.tx_ring_index += 1;\n-        Ok(())\n+    }\n+}\n+\n+struct VirtioNetDriver {\n+    device: Arc<SpinLock<VirtioNet>>,\n+}\n+\n+impl VirtioNetDriver {\n+    fn new(device: Arc<SpinLock<VirtioNet>>) -> VirtioNetDriver {\n+        VirtioNetDriver { device }\n+    }\n+}\n+\n+impl Driver for VirtioNetDriver {\n+    fn name(&self) -> &str {\n+        \"virtio-net\"\n+    }\n+}\n+\n+impl EthernetDriver for VirtioNetDriver {\n+    fn mac_addr(&self) -> MacAddress {\n+        self.device.lock().mac_addr()\n+    }\n+\n+    fn transmit(&self, frame: &[u8]) {\n+        self.device.lock().transmit(frame);\n     }\n }\n \ndiff --git a/kernel/drivers/virtio/virtio_net.rs b/exts/virtio_net/virtio_net.rs\n--- a/kernel/drivers/virtio/virtio_net.rs\n+++ b/exts/virtio_net/virtio_net.rs\n@@ -227,57 +234,75 @@ impl VirtioNetBuilder {\n }\n \n impl DriverBuilder for VirtioNetBuilder {\n-    fn attach_pci(&self, pci_device: &PciDevice) -> Result<()> {\n+    fn attach_pci(&self, pci_device: &PciDevice) {\n         // Check if the device is a network card (\"4.1.2 PCI Device Discovery\").\n         if pci_device.config().vendor_id() == 0x1af4\n             && pci_device.config().device_id() != 0x1040 + 1\n         {\n-            return Err(Errno::EINVAL.into());\n+            return;\n         }\n \n         trace!(\"virtio-net: found the device (over PCI)\");\n-        let driver = VirtioPci::attach_pci(pci_device, VirtioNet::new)?;\n+        let device = match VirtioPci::attach_pci(pci_device, VirtioNet::new) {\n+            Ok(device) => Arc::new(SpinLock::new(device)),\n+            Err(VirtioAttachError::InvalidVendorId) => {\n+                // Not a virtio-net device.\n+                return;\n+            }\n+            Err(err) => {\n+                warn!(\"failed to attach a virtio-net: {:?}\", err);\n+                return;\n+            }\n+        };\n \n-        register_ethernet_driver(driver.clone());\n+        register_ethernet_driver(Box::new(VirtioNetDriver::new(device.clone())));\n         attach_irq(pci_device.config().interrupt_line(), move || {\n-            driver.lock().handle_irq();\n-            process_packets();\n+            device.lock().handle_irq();\n         });\n-\n-        Ok(())\n     }\n \n-    fn attach_virtio_mmio(&self, mmio_device: &VirtioMmioDevice) -> Result<()> {\n+    fn attach_virtio_mmio(&self, mmio_device: &VirtioMmioDevice) {\n         let mmio = mmio_device.mmio_base.as_vaddr();\n         let magic = unsafe { *mmio.as_ptr::<u32>() };\n         let virtio_version = unsafe { *mmio.add(4).as_ptr::<u32>() };\n         let device_id = unsafe { *mmio.add(8).as_ptr::<u32>() };\n \n         if magic != 0x74726976 {\n-            return Err(Errno::EINVAL.into());\n+            return;\n         }\n \n         if virtio_version != 2 {\n             warn!(\"unsupported virtio device version: {}\", virtio_version);\n-            return Err(Errno::EINVAL.into());\n+            return;\n         }\n \n         // It looks like a virtio device. Check if the device is a network card.\n         if device_id != 1 {\n-            return Err(Errno::EINVAL.into());\n+            return;\n         }\n \n         trace!(\"virtio-net: found the device (over MMIO)\");\n \n         let transport = Arc::new(VirtioMmio::new(mmio_device.mmio_base));\n-        let driver = Arc::new(SpinLock::new(VirtioNet::new(transport)?));\n-        register_ethernet_driver(driver.clone());\n+        let device = match VirtioNet::new(transport) {\n+            Ok(device) => Arc::new(SpinLock::new(device)),\n+            Err(VirtioAttachError::InvalidVendorId) => {\n+                // Not a virtio-net device.\n+                return;\n+            }\n+            Err(err) => {\n+                warn!(\"failed to attach a virtio-net: {:?}\", err);\n+                return;\n+            }\n+        };\n \n+        register_ethernet_driver(Box::new(VirtioNetDriver::new(device.clone())));\n         attach_irq(mmio_device.irq, move || {\n-            driver.lock().handle_irq();\n-            process_packets();\n+            device.lock().handle_irq();\n         });\n-\n-        Ok(())\n     }\n }\n+\n+pub fn init() {\n+    register_driver_builder(Box::new(VirtioNetBuilder::new()));\n+}\ndiff --git a/kernel/Cargo.toml b/kernel/Cargo.toml\n--- a/kernel/Cargo.toml\n+++ b/kernel/Cargo.toml\n@@ -9,7 +9,6 @@ name = \"kerla_kernel\"\n path = \"main.rs\"\n \n [dependencies]\n-memoffset = \"0.6.4\"\n log = \"0.4\"\n spin = \"0.9.2\"\n goblin = { version = \"0.4\", default-features = false, features = [\"elf64\"] }\ndiff --git a/kernel/Cargo.toml b/kernel/Cargo.toml\n--- a/kernel/Cargo.toml\n+++ b/kernel/Cargo.toml\n@@ -27,4 +26,8 @@ x86 = \"0.43.0\"\n \n # Local dependencies.\n kerla_runtime = { path = \"../runtime\" }\n+kerla_api = { path = \"../libs/kerla_api\" }\n kerla_utils = { path = \"../libs/kerla_utils\", features = [\"no_std\"] }\n+\n+# Kernel extensions.\n+virtio_net = { path = \"../exts/virtio_net\" }\ndiff --git a/kernel/drivers/driver.rs /dev/null\n--- a/kernel/drivers/driver.rs\n+++ /dev/null\n@@ -1,29 +0,0 @@\n-use super::pci::PciDevice;\n-use crate::result::Result;\n-use kerla_runtime::bootinfo::VirtioMmioDevice;\n-\n-#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-pub struct MacAddress([u8; 6]);\n-\n-impl MacAddress {\n-    pub fn new(addr: [u8; 6]) -> MacAddress {\n-        MacAddress(addr)\n-    }\n-    pub fn as_array(&self) -> [u8; 6] {\n-        self.0\n-    }\n-}\n-\n-pub trait Driver: Send + Sync {\n-    fn name(&self) -> &str;\n-}\n-\n-pub trait EthernetDriver: Driver {\n-    fn mac_addr(&self) -> Result<MacAddress>;\n-    fn transmit(&mut self, frame: &[u8]) -> Result<()>;\n-}\n-\n-pub trait DriverBuilder: Send + Sync {\n-    fn attach_pci(&self, pci_device: &PciDevice) -> Result<()>;\n-    fn attach_virtio_mmio(&self, mmio_device: &VirtioMmioDevice) -> Result<()>;\n-}\ndiff --git a/kernel/drivers/mod.rs /dev/null\n--- a/kernel/drivers/mod.rs\n+++ /dev/null\n@@ -1,36 +0,0 @@\n-use alloc::sync::Arc;\n-use alloc::vec::Vec;\n-\n-pub mod driver;\n-pub mod ioport;\n-pub mod pci;\n-pub mod virtio;\n-\n-pub use driver::*;\n-\n-use alloc::boxed::Box;\n-use kerla_runtime::spinlock::SpinLock;\n-\n-use self::virtio::virtio_net::VirtioNetBuilder;\n-\n-pub(super) static DRIVER_BUILDERS: SpinLock<Vec<Box<dyn DriverBuilder>>> =\n-    SpinLock::new(Vec::new());\n-\n-/// Activated ethernet device drivers.\n-static ETHERNET_DRIVERS: SpinLock<Vec<Arc<SpinLock<dyn EthernetDriver>>>> =\n-    SpinLock::new(Vec::new());\n-\n-pub fn register_ethernet_driver(driver: Arc<SpinLock<dyn EthernetDriver>>) {\n-    ETHERNET_DRIVERS.lock().push(driver);\n-}\n-\n-pub fn get_ethernet_driver() -> Option<Arc<SpinLock<dyn EthernetDriver>>> {\n-    ETHERNET_DRIVERS.lock().get(0).cloned()\n-}\n-\n-pub fn init() {\n-    // Initialize the array of all device drivers.\n-    DRIVER_BUILDERS\n-        .lock()\n-        .push(Box::new(VirtioNetBuilder::new()));\n-}\ndiff --git a/kernel/drivers/virtio/mod.rs /dev/null\n--- a/kernel/drivers/virtio/mod.rs\n+++ /dev/null\n@@ -1,16 +0,0 @@\n-use kerla_runtime::bootinfo::VirtioMmioDevice;\n-\n-use super::DRIVER_BUILDERS;\n-\n-pub mod transports;\n-#[allow(clippy::module_inception)]\n-pub mod virtio;\n-pub mod virtio_net;\n-\n-pub fn init(mmio_devices: &[VirtioMmioDevice]) {\n-    for device in mmio_devices {\n-        for builder in DRIVER_BUILDERS.lock().iter() {\n-            builder.attach_virtio_mmio(device).ok();\n-        }\n-    }\n-}\ndiff --git a/kernel/interrupt.rs b/kernel/interrupt.rs\n--- a/kernel/interrupt.rs\n+++ b/kernel/interrupt.rs\n@@ -5,6 +5,8 @@ use core::mem::MaybeUninit;\n use kerla_runtime::{arch::enable_irq, spinlock::SpinLock};\n use kerla_utils::bitmap::BitMap;\n \n+use crate::net::process_packets;\n+\n fn empty_irq_handler() {}\n \n type IrqHandler = dyn FnMut() + Send + Sync;\ndiff --git a/kernel/interrupt.rs b/kernel/interrupt.rs\n--- a/kernel/interrupt.rs\n+++ b/kernel/interrupt.rs\n@@ -20,13 +22,13 @@ pub fn init() {\n     }\n }\n \n-pub fn attach_irq<F: FnMut() + Send + Sync + 'static>(irq: u8, f: F) {\n+pub fn attach_irq(irq: u8, f: Box<dyn FnMut() + Send + Sync + 'static>) {\n     let mut attached_irq_map = ATTACHED_IRQS.lock();\n     match attached_irq_map.get(irq as usize) {\n         Some(true) => panic!(\"handler for IRQ #{} is already attached\", irq),\n         Some(false) => {\n             attached_irq_map.set(irq as usize);\n-            IRQ_HANDLERS.lock()[irq as usize].write(Box::new(f));\n+            IRQ_HANDLERS.lock()[irq as usize].write(f);\n             enable_irq(irq);\n         }\n         None => panic!(\"IRQ #{} is out of bound\", irq),\ndiff --git a/kernel/interrupt.rs b/kernel/interrupt.rs\n--- a/kernel/interrupt.rs\n+++ b/kernel/interrupt.rs\n@@ -37,5 +39,8 @@ pub fn handle_irq(irq: u8) {\n     let handler = &mut IRQ_HANDLERS.lock()[irq as usize];\n     unsafe {\n         (*handler.assume_init_mut())();\n+        // FIXME: Temporarily moved to here to avoid dead locking in receive_ethernet_frame.\n+        //        To be replaced soon with a new mechanism like softirq.\n+        process_packets();\n     }\n }\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -29,7 +29,6 @@ mod arch;\n #[macro_use]\n mod user_buffer;\n mod ctypes;\n-mod drivers;\n mod fs;\n mod interrupt;\n mod lang_items;\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -56,7 +55,9 @@ use crate::{\n     process::{switch, Process},\n     syscalls::SyscallHandler,\n };\n-use alloc::sync::Arc;\n+use alloc::{boxed::Box, sync::Arc};\n+use interrupt::attach_irq;\n+use kerla_api::kernel_ops::KernelOps;\n use kerla_runtime::{\n     arch::{idle, PageFaultReason, SyscallFrame},\n     bootinfo::BootInfo,\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -120,6 +122,22 @@ impl kerla_runtime::Handler for Handler {\n     }\n }\n \n+struct ApiOps;\n+\n+impl KernelOps for ApiOps {\n+    fn attach_irq(&self, irq: u8, f: alloc::boxed::Box<dyn FnMut() + Send + Sync + 'static>) {\n+        attach_irq(irq, f);\n+    }\n+\n+    fn register_ethernet_driver(&self, driver: Box<dyn kerla_api::driver::net::EthernetDriver>) {\n+        register_ethernet_driver(driver)\n+    }\n+\n+    fn receive_etherframe_packet(&self, pkt: &[u8]) {\n+        net::receive_ethernet_frame(pkt);\n+    }\n+}\n+\n pub static INITIAL_ROOT_FS: Once<Arc<SpinLock<RootFs>>> = Once::new();\n \n #[no_mangle]\ndiff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -153,20 +171,20 @@ pub fn boot_kernel(#[cfg_attr(debug_assertions, allow(unused))] bootinfo: &BootI\n     profiler.lap_time(\"tmpfs init\");\n     initramfs::init();\n     profiler.lap_time(\"initramfs init\");\n-    drivers::init();\n-    profiler.lap_time(\"drivers init\");\n+    kerla_api::kernel_ops::init(&ApiOps);\n+    profiler.lap_time(\"kerla_api init\");\n \n-    if bootinfo.pci_enabled {\n-        drivers::pci::init();\n-        profiler.lap_time(\"pci init\");\n-    }\n+    // Load kernel extensions.\n+    info!(\"Initializing virtio_net...\");\n+    virtio_net::init();\n+    profiler.lap_time(\"kernel extensions init\");\n \n-    if !bootinfo.virtio_mmio_devices.is_empty() {\n-        drivers::virtio::init(&bootinfo.virtio_mmio_devices);\n-        profiler.lap_time(\"virtio init\");\n-    }\n+    // Initialize device drivers.\n+    kerla_api::kernel_ops::init_drivers(bootinfo.pci_enabled, &bootinfo.virtio_mmio_devices);\n+    profiler.lap_time(\"drivers init\");\n \n-    net::init();\n+    // Connect to the network.\n+    net::init_and_start_dhcp_discover();\n     profiler.lap_time(\"net init\");\n \n     // Prepare the root file system.\ndiff --git a/kernel/net/mod.rs b/kernel/net/mod.rs\n--- a/kernel/net/mod.rs\n+++ b/kernel/net/mod.rs\n@@ -1,14 +1,12 @@\n use crate::{\n-    drivers::{get_ethernet_driver, EthernetDriver},\n-    poll::POLL_WAIT_QUEUE,\n-    process::WaitQueue,\n-    timer::read_monotonic_clock,\n-    timer::MonotonicClock,\n+    poll::POLL_WAIT_QUEUE, process::WaitQueue, timer::read_monotonic_clock, timer::MonotonicClock,\n };\n+use alloc::boxed::Box;\n use alloc::collections::BTreeMap;\n-use alloc::sync::Arc;\n use alloc::vec::Vec;\n+use atomic_refcell::AtomicRefCell;\n use crossbeam::queue::ArrayQueue;\n+use kerla_api::driver::net::EthernetDriver;\n use kerla_runtime::spinlock::SpinLock;\n use kerla_utils::once::Once;\n use smoltcp::wire::{self, EthernetAddress, IpCidr};\ndiff --git a/kernel/net/mod.rs b/kernel/net/mod.rs\n--- a/kernel/net/mod.rs\n+++ b/kernel/net/mod.rs\n@@ -38,11 +36,6 @@ pub use udp_socket::*;\n pub use unix_socket::*;\n \n static RX_PACKET_QUEUE: Once<SpinLock<ArrayQueue<Vec<u8>>>> = Once::new();\n-static DRIVER: Once<Arc<SpinLock<dyn EthernetDriver>>> = Once::new();\n-\n-pub fn send_ethernet_frame(frame: &[u8]) {\n-    DRIVER.lock().transmit(frame).unwrap();\n-}\n \n pub fn receive_ethernet_frame(frame: &[u8]) {\n     if RX_PACKET_QUEUE.lock().push(frame.to_vec()).is_err() {\ndiff --git a/kernel/net/mod.rs b/kernel/net/mod.rs\n--- a/kernel/net/mod.rs\n+++ b/kernel/net/mod.rs\n@@ -135,7 +128,7 @@ impl TxToken for OurTxToken {\n         let mut buffer = vec![0; len];\n         let return_value = f(&mut buffer)?;\n         if EthernetFrame::new_checked(&mut buffer).is_ok() {\n-            send_ethernet_frame(&buffer);\n+            use_ethernet_driver(|driver| driver.transmit(&buffer));\n         }\n \n         Ok(return_value)\ndiff --git a/kernel/net/mod.rs b/kernel/net/mod.rs\n--- a/kernel/net/mod.rs\n+++ b/kernel/net/mod.rs\n@@ -166,10 +159,24 @@ impl<'a> Device<'a> for OurDevice {\n     }\n }\n \n-pub fn init() {\n+static ETHERNET_DRIVER: AtomicRefCell<Option<Box<dyn EthernetDriver>>> = AtomicRefCell::new(None);\n+\n+pub fn register_ethernet_driver(driver: Box<dyn EthernetDriver>) {\n+    assert!(\n+        ETHERNET_DRIVER.borrow().is_none(),\n+        \"multiple net drivers are not supported\"\n+    );\n+    *ETHERNET_DRIVER.borrow_mut() = Some(driver);\n+}\n+\n+pub fn use_ethernet_driver<F: FnOnce(&Box<dyn EthernetDriver>) -> R, R>(f: F) -> R {\n+    let driver = ETHERNET_DRIVER.borrow();\n+    f(driver.as_ref().expect(\"no ethernet drivers\"))\n+}\n+\n+pub fn init_and_start_dhcp_discover() {\n     let neighbor_cache = NeighborCache::new(BTreeMap::new());\n-    let driver = get_ethernet_driver().expect(\"no ethernet drivers\");\n-    let mac_addr = driver.lock().mac_addr().unwrap();\n+    let mac_addr = use_ethernet_driver(|driver| driver.mac_addr());\n     let ethernet_addr = EthernetAddress(mac_addr.as_array());\n     let ip_addrs = [IpCidr::new(wire::Ipv4Address::UNSPECIFIED.into(), 0)];\n     let routes = Routes::new(BTreeMap::new());\ndiff --git a/kernel/net/mod.rs b/kernel/net/mod.rs\n--- a/kernel/net/mod.rs\n+++ b/kernel/net/mod.rs\n@@ -195,7 +202,6 @@ pub fn init() {\n     INTERFACE.init(|| SpinLock::new(iface));\n     SOCKETS.init(|| SpinLock::new(sockets));\n     DHCP_CLIENT.init(|| SpinLock::new(dhcp));\n-    DRIVER.init(|| driver);\n \n     process_packets();\n }\ndiff --git /dev/null b/libs/kerla_api/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/libs/kerla_api/Cargo.toml\n@@ -0,0 +1,21 @@\n+[package]\n+name = \"kerla_api\"\n+version = \"0.0.1\"\n+authors = [\"Seiya Nuta <nuta@seiya.me>\"]\n+edition = \"2021\"\n+\n+[lib]\n+name = \"kerla_api\"\n+path = \"lib.rs\"\n+\n+[dependencies]\n+log = \"0.4\"\n+memoffset = \"0.6.4\"\n+arrayvec = { version = \"0.7.2\", default-features = false }\n+\n+# Arch-specific dependencies.\n+x86 = \"0.43.0\"\n+\n+# Local dependencies.\n+kerla_runtime = { path = \"../../runtime\" }\n+kerla_utils = { path = \"../kerla_utils\" }\ndiff --git a/kernel/drivers/ioport.rs b/libs/kerla_api/driver/ioport.rs\n--- a/kernel/drivers/ioport.rs\n+++ b/libs/kerla_api/driver/ioport.rs\n@@ -1,4 +1,3 @@\n-#![allow(unused)] // TODO: remove me\n use x86::io::{inb, inl, inw, outb, outl, outw};\n \n #[derive(Debug, Copy, Clone)]\ndiff --git /dev/null b/libs/kerla_api/driver/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/libs/kerla_api/driver/mod.rs\n@@ -0,0 +1,56 @@\n+//! Device driver APIs.\n+use crate::kernel_ops::kernel_ops;\n+\n+use alloc::vec::Vec;\n+\n+pub mod ioport;\n+pub mod net;\n+pub mod pci;\n+\n+pub use kerla_runtime::bootinfo::VirtioMmioDevice;\n+\n+use alloc::boxed::Box;\n+use kerla_runtime::spinlock::SpinLock;\n+\n+use self::pci::PciDevice;\n+\n+static DEVICE_PROBERS: SpinLock<Vec<Box<dyn DeviceProber>>> = SpinLock::new(Vec::new());\n+\n+pub trait DeviceProber: Send + Sync {\n+    fn probe_pci(&self, pci_device: &PciDevice);\n+    fn probe_virtio_mmio(&self, mmio_device: &VirtioMmioDevice);\n+}\n+\n+pub fn register_driver_prober(driver: Box<dyn DeviceProber>) {\n+    DEVICE_PROBERS.lock().push(driver);\n+}\n+\n+pub fn attach_irq<F: FnMut() + Send + Sync + 'static>(irq: u8, f: F) {\n+    kernel_ops().attach_irq(irq, Box::new(f))\n+}\n+\n+pub fn init(pci_enabled: bool, mmio_devices: &[VirtioMmioDevice]) {\n+    // Scan PCI devices.\n+    if pci_enabled {\n+        for device in pci::enumerate_pci_devices() {\n+            trace!(\n+                \"pci: found a device: id={:04x}:{:04x}, bar0={:016x?}, irq={}\",\n+                device.config().vendor_id(),\n+                device.config().device_id(),\n+                device.config().bar(0),\n+                device.config().interrupt_line()\n+            );\n+\n+            for prober in DEVICE_PROBERS.lock().iter() {\n+                prober.probe_pci(&device);\n+            }\n+        }\n+    }\n+\n+    // Register Virtio devices connected over MMIO.\n+    for device in mmio_devices {\n+        for prober in DEVICE_PROBERS.lock().iter() {\n+            prober.probe_virtio_mmio(device);\n+        }\n+    }\n+}\ndiff --git /dev/null b/libs/kerla_api/driver/net.rs\nnew file mode 100644\n--- /dev/null\n+++ b/libs/kerla_api/driver/net.rs\n@@ -0,0 +1,28 @@\n+use alloc::boxed::Box;\n+\n+use crate::kernel_ops::kernel_ops;\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+pub struct MacAddress([u8; 6]);\n+\n+impl MacAddress {\n+    pub fn new(addr: [u8; 6]) -> MacAddress {\n+        MacAddress(addr)\n+    }\n+    pub fn as_array(&self) -> [u8; 6] {\n+        self.0\n+    }\n+}\n+\n+pub trait Driver: Send + Sync {\n+    fn name(&self) -> &str;\n+}\n+\n+pub trait EthernetDriver: Driver {\n+    fn mac_addr(&self) -> MacAddress;\n+    fn transmit(&self, frame: &[u8]);\n+}\n+\n+pub fn register_ethernet_driver(driver: Box<dyn EthernetDriver>) {\n+    kernel_ops().register_ethernet_driver(driver);\n+}\ndiff --git a/kernel/drivers/pci.rs b/libs/kerla_api/driver/pci.rs\n--- a/kernel/drivers/pci.rs\n+++ b/libs/kerla_api/driver/pci.rs\n@@ -1,5 +1,4 @@\n-use crate::drivers::DRIVER_BUILDERS;\n-use crate::prelude::*;\n+use alloc::vec::Vec;\n use arrayvec::ArrayVec;\n use core::convert::TryInto;\n use core::{mem::size_of, mem::MaybeUninit};\ndiff --git a/kernel/drivers/pci.rs b/libs/kerla_api/driver/pci.rs\n--- a/kernel/drivers/pci.rs\n+++ b/libs/kerla_api/driver/pci.rs\n@@ -230,20 +229,3 @@ impl Iterator for PciScanner {\n         None\n     }\n }\n-\n-pub fn init() {\n-    // Scan PCI devices.\n-    for device in enumerate_pci_devices() {\n-        trace!(\n-            \"pci: found a device: id={:04x}:{:04x}, bar0={:016x?}, irq={}\",\n-            device.config().vendor_id(),\n-            device.config().device_id(),\n-            device.config().bar(0),\n-            device.config().interrupt_line()\n-        );\n-\n-        for builder in DRIVER_BUILDERS.lock().iter() {\n-            builder.attach_pci(&device).ok();\n-        }\n-    }\n-}\ndiff --git /dev/null b/libs/kerla_api/kernel_ops.rs\nnew file mode 100644\n--- /dev/null\n+++ b/libs/kerla_api/kernel_ops.rs\n@@ -0,0 +1,38 @@\n+//! Internal APIs exposed for kerla_kernel crate. **Don't use from your kernel extensions!**\n+use alloc::boxed::Box;\n+use kerla_runtime::bootinfo::VirtioMmioDevice;\n+use kerla_utils::static_cell::StaticCell;\n+\n+use crate::driver::{self, net::EthernetDriver};\n+\n+pub trait KernelOps: Sync {\n+    fn receive_etherframe_packet(&self, pkt: &[u8]);\n+    fn register_ethernet_driver(&self, driver: Box<dyn EthernetDriver>);\n+    fn attach_irq(&self, irq: u8, f: Box<dyn FnMut() + Send + Sync + 'static>);\n+}\n+\n+static OPS: StaticCell<&dyn KernelOps> = StaticCell::new(&NopOps);\n+\n+struct NopOps;\n+\n+impl KernelOps for NopOps {\n+    fn attach_irq(&self, _irq: u8, _f: Box<dyn FnMut() + Send + Sync + 'static>) {}\n+    fn register_ethernet_driver(&self, _driver: Box<dyn EthernetDriver>) {}\n+    fn receive_etherframe_packet(&self, _pkt: &[u8]) {}\n+}\n+\n+pub(crate) fn kernel_ops() -> &'static dyn KernelOps {\n+    OPS.load()\n+}\n+\n+pub fn set_kernel_ops(ops: &'static dyn KernelOps) {\n+    OPS.store(ops);\n+}\n+\n+pub fn init(ops: &'static dyn KernelOps) {\n+    set_kernel_ops(ops);\n+}\n+\n+pub fn init_drivers(pci_enabled: bool, mmio_devices: &[VirtioMmioDevice]) {\n+    driver::init(pci_enabled, mmio_devices);\n+}\ndiff --git /dev/null b/libs/kerla_api/lib.rs\nnew file mode 100644\n--- /dev/null\n+++ b/libs/kerla_api/lib.rs\n@@ -0,0 +1,30 @@\n+//! Kerla API for kernel extensions.\n+#![no_std]\n+\n+extern crate alloc;\n+\n+#[macro_use]\n+extern crate log;\n+\n+pub mod driver;\n+pub mod kernel_ops;\n+pub mod net;\n+\n+pub use kerla_runtime::{debug_warn, warn_if_err, warn_once};\n+pub use log::{debug, error, info, trace, warn};\n+\n+pub mod address {\n+    pub use kerla_runtime::address::{PAddr, VAddr};\n+}\n+\n+pub mod mm {\n+    pub use kerla_runtime::page_allocator::{alloc_pages, AllocPageFlags, PageAllocError};\n+}\n+\n+pub mod sync {\n+    pub use kerla_runtime::spinlock::{SpinLock, SpinLockGuard};\n+}\n+\n+pub mod arch {\n+    pub use kerla_runtime::arch::PAGE_SIZE;\n+}\ndiff --git /dev/null b/libs/kerla_api/net.rs\nnew file mode 100644\n--- /dev/null\n+++ b/libs/kerla_api/net.rs\n@@ -0,0 +1,6 @@\n+//! Network APIs.\n+use crate::kernel_ops::kernel_ops;\n+\n+pub fn receive_ethernet_frame(pkt: &[u8]) {\n+    kernel_ops().receive_etherframe_packet(pkt);\n+}\ndiff --git /dev/null b/libs/virtio/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/libs/virtio/Cargo.toml\n@@ -0,0 +1,16 @@\n+[package]\n+name = \"virtio\"\n+version = \"0.0.1\"\n+authors = [\"Seiya Nuta <nuta@seiya.me>\"]\n+edition = \"2021\"\n+\n+[lib]\n+name = \"virtio\"\n+path = \"lib.rs\"\n+\n+[dependencies]\n+bitflags = \"1.3.2\"\n+memoffset = \"0.6.4\"\n+\n+kerla_api = { path = \"../../libs/kerla_api\" }\n+kerla_utils = { path = \"../../libs/kerla_utils\" }\ndiff --git /dev/null b/libs/virtio/device.rs\nnew file mode 100644\n--- /dev/null\n+++ b/libs/virtio/device.rs\n@@ -0,0 +1,403 @@\n+//! A virtio device driver library.\n+use alloc::sync::Arc;\n+use alloc::vec::Vec;\n+use bitflags::bitflags;\n+use core::cmp::min;\n+use core::convert::TryInto;\n+use core::mem::size_of;\n+use core::sync::atomic::{self, Ordering};\n+use kerla_api::address::{PAddr, VAddr};\n+use kerla_api::arch::PAGE_SIZE;\n+use kerla_api::mm::{alloc_pages, AllocPageFlags};\n+use kerla_utils::alignment::align_up;\n+\n+use crate::transports::virtio_pci::VirtioAttachError;\n+\n+use super::transports::VirtioTransport;\n+\n+const VIRTIO_STATUS_ACK: u8 = 1;\n+const VIRTIO_STATUS_DRIVER: u8 = 2;\n+const VIRTIO_STATUS_DRIVER_OK: u8 = 4;\n+const VIRTIO_STATUS_FEAT_OK: u8 = 8;\n+const VIRTIO_F_VERSION_1: u64 = 1 << 32;\n+\n+const VIRTQ_DESC_F_NEXT: u16 = 1;\n+const VIRTQ_DESC_F_WRITE: u16 = 2;\n+\n+#[derive(Debug, Copy, Clone)]\n+#[repr(C, packed)]\n+pub struct VirtqDesc {\n+    pub addr: u64,\n+    pub len: u32,\n+    pub flags: u16,\n+    pub next: u16,\n+}\n+\n+impl VirtqDesc {\n+    pub fn is_writable(&self) -> bool {\n+        self.flags & VIRTQ_DESC_F_WRITE != 0\n+    }\n+\n+    pub fn has_next(&self) -> bool {\n+        self.flags & VIRTQ_DESC_F_NEXT != 0\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+#[repr(C, packed)]\n+struct VirtqAvail {\n+    flags: u16,\n+    index: u16,\n+    // The rings (an array of descriptor indices) immediately follows here.\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+#[repr(C, packed)]\n+pub struct VirtqUsedElem {\n+    id: u32,\n+    len: u32,\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+#[repr(C, packed)]\n+struct VirtqUsed {\n+    flags: u16,\n+    index: u16,\n+    // The rings (an array of VirtqUsedElem) immediately follows here.\n+}\n+\n+pub enum VirtqDescBuffer {\n+    ReadOnlyFromDevice { addr: PAddr, len: usize },\n+    WritableFromDevice { addr: PAddr, len: usize },\n+}\n+\n+pub struct VirtqUsedChain {\n+    pub descs: Vec<VirtqDescBuffer>,\n+    pub total_len: usize,\n+}\n+\n+/// A virtqueue.\n+pub struct VirtQueue {\n+    index: u16,\n+    transport: Arc<dyn VirtioTransport>,\n+    num_descs: u16,\n+    last_used_index: u16,\n+    free_head: u16,\n+    num_free_descs: u16,\n+    descs: VAddr,\n+    avail: VAddr,\n+    used: VAddr,\n+}\n+\n+impl VirtQueue {\n+    pub fn new(index: u16, transport: Arc<dyn VirtioTransport>) -> VirtQueue {\n+        transport.select_queue(index);\n+\n+        let num_descs = min(transport.queue_max_size(), 512);\n+        transport.set_queue_size(num_descs);\n+\n+        let avail_ring_off = size_of::<VirtqDesc>() * (num_descs as usize);\n+        let avail_ring_size: usize = size_of::<u16>() * (3 + (num_descs as usize));\n+        let used_ring_off = align_up(avail_ring_off + avail_ring_size, PAGE_SIZE);\n+        let used_ring_size =\n+            size_of::<u16>() * 3 + size_of::<VirtqUsedElem>() * (num_descs as usize);\n+        let virtq_size = used_ring_off + align_up(used_ring_size, PAGE_SIZE);\n+\n+        let virtqueue_paddr = alloc_pages(\n+            align_up(virtq_size, PAGE_SIZE) / PAGE_SIZE,\n+            AllocPageFlags::KERNEL | AllocPageFlags::ZEROED,\n+        )\n+        .expect(\"failed to allocate virtuqeue\");\n+\n+        let descs = virtqueue_paddr;\n+        let avail = virtqueue_paddr.add(avail_ring_off);\n+        let used = virtqueue_paddr.add(used_ring_off);\n+\n+        transport.set_queue_desc_paddr(descs);\n+        transport.set_queue_driver_paddr(avail);\n+        transport.set_queue_device_paddr(used);\n+        transport.enable_queue();\n+\n+        // Add descriptors into the free list.\n+        for i in 0..num_descs {\n+            let desc = unsafe { &mut *descs.as_mut_ptr::<VirtqDesc>().offset(i as isize) };\n+            desc.next = if i == num_descs - 1 { 0 } else { i + 1 };\n+        }\n+\n+        VirtQueue {\n+            index,\n+            transport,\n+            num_descs,\n+            last_used_index: 0,\n+            free_head: 0,\n+            num_free_descs: num_descs,\n+            descs: descs.as_vaddr(),\n+            avail: avail.as_vaddr(),\n+            used: used.as_vaddr(),\n+        }\n+    }\n+\n+    /// Enqueues a request to the device. A request is a chain of descriptors\n+    /// (e.g. `struct virtio_blk_req` as defined in the spec).\n+    ///\n+    /// Once you've enqueued all requests, you need to notify the device through\n+    /// the `notify` method.\n+    pub fn enqueue(&mut self, chain: &[VirtqDescBuffer]) {\n+        debug_assert!(!chain.is_empty());\n+\n+        // Try freeing used descriptors.\n+        if (self.num_free_descs as usize) < chain.len() {\n+            while self.last_used_index != self.used().index {\n+                let used_elem_index = self.used_elem(self.last_used_index).id as u16;\n+\n+                // Enqueue the popped chain back into the free list.\n+                self.free_head = used_elem_index;\n+\n+                // Count the number of descriptors in the chain.\n+                let mut num_freed = 0;\n+                let mut next_desc_index = used_elem_index;\n+                loop {\n+                    let desc = self.desc(next_desc_index);\n+                    num_freed += 1;\n+\n+                    if (desc.flags & VIRTQ_DESC_F_NEXT) == 0 {\n+                        break;\n+                    }\n+\n+                    next_desc_index = desc.next;\n+                }\n+\n+                self.num_free_descs += num_freed;\n+                self.last_used_index = self.last_used_index.wrapping_add(1);\n+            }\n+        }\n+\n+        // Check if we have the enough number of free descriptors.\n+        if (self.num_free_descs as usize) < chain.len() {\n+            return;\n+        }\n+\n+        let head_index = self.free_head;\n+        let mut desc_index = self.free_head;\n+        for (i, buffer) in chain.iter().enumerate() {\n+            let desc = self.desc_mut(desc_index);\n+            let (addr, len, flags) = match buffer {\n+                VirtqDescBuffer::ReadOnlyFromDevice { addr, len } => (addr, *len, 0),\n+                VirtqDescBuffer::WritableFromDevice { addr, len } => {\n+                    (addr, *len, VIRTQ_DESC_F_WRITE)\n+                }\n+            };\n+\n+            desc.addr = addr.value() as u64;\n+            desc.len = len.try_into().unwrap();\n+            desc.flags = flags;\n+\n+            if i == chain.len() - 1 {\n+                let unused_next = desc.next;\n+                desc.next = 0;\n+                self.free_head = unused_next;\n+                self.num_free_descs -= chain.len() as u16;\n+            } else {\n+                desc.flags |= VIRTQ_DESC_F_NEXT;\n+                desc_index = desc.next;\n+            }\n+        }\n+\n+        let avail_elem_index = self.avail().index;\n+        *self.avail_elem_mut(avail_elem_index) = head_index;\n+        self.avail_mut().index = self.avail_mut().index.wrapping_add(1);\n+    }\n+\n+    /// Notifies the device to start processing descriptors.\n+    pub fn notify(&self) {\n+        atomic::fence(Ordering::Release);\n+        self.transport.notify_queue(self.index);\n+    }\n+\n+    /// Returns a chain of descriptors processed by the device.\n+    pub fn pop_used(&mut self) -> Option<VirtqUsedChain> {\n+        if self.last_used_index == self.used().index {\n+            return None;\n+        }\n+\n+        let head = *self.used_elem(self.last_used_index);\n+        self.last_used_index = self.last_used_index.wrapping_add(1);\n+\n+        let mut used_descs = Vec::new();\n+        let mut next_desc_index = head.id as u16;\n+        let mut num_descs_in_chain = 1;\n+        let current_free_head = self.free_head;\n+        loop {\n+            let desc = self.desc_mut(next_desc_index);\n+            used_descs.push(if desc.is_writable() {\n+                VirtqDescBuffer::WritableFromDevice {\n+                    addr: PAddr::new(desc.addr as usize),\n+                    len: desc.len as usize,\n+                }\n+            } else {\n+                VirtqDescBuffer::ReadOnlyFromDevice {\n+                    addr: PAddr::new(desc.addr as usize),\n+                    len: desc.len as usize,\n+                }\n+            });\n+\n+            if !desc.has_next() {\n+                // Prepend the popped chain into the free list.\n+                desc.next = current_free_head;\n+                self.free_head = head.id as u16;\n+                self.num_free_descs += num_descs_in_chain;\n+                break;\n+            }\n+\n+            next_desc_index = desc.next;\n+            num_descs_in_chain += 1;\n+        }\n+\n+        Some(VirtqUsedChain {\n+            total_len: head.len as usize,\n+            descs: used_descs,\n+        })\n+    }\n+\n+    /// Returns the defined number of descriptors in the virtqueue.\n+    pub fn num_descs(&self) -> u16 {\n+        self.num_descs\n+    }\n+\n+    fn desc(&mut self, index: u16) -> &VirtqDesc {\n+        unsafe {\n+            &*self\n+                .descs\n+                .as_ptr::<VirtqDesc>()\n+                .offset((index % self.num_descs) as isize)\n+        }\n+    }\n+\n+    fn desc_mut(&mut self, index: u16) -> &mut VirtqDesc {\n+        unsafe {\n+            &mut *self\n+                .descs\n+                .as_mut_ptr::<VirtqDesc>()\n+                .offset((index % self.num_descs) as isize)\n+        }\n+    }\n+\n+    fn avail(&self) -> &VirtqAvail {\n+        unsafe { &*self.avail.as_ptr::<VirtqAvail>() }\n+    }\n+\n+    fn avail_mut(&mut self) -> &mut VirtqAvail {\n+        unsafe { &mut *self.avail.as_mut_ptr::<VirtqAvail>() }\n+    }\n+\n+    fn avail_elem_mut(&mut self, index: u16) -> &mut u16 {\n+        unsafe {\n+            &mut *self\n+                .avail\n+                .add(size_of::<VirtqAvail>())\n+                .as_mut_ptr::<u16>()\n+                .offset((index % self.num_descs) as isize)\n+        }\n+    }\n+\n+    fn used(&self) -> &VirtqUsed {\n+        unsafe { &*self.used.as_ptr::<VirtqUsed>() }\n+    }\n+\n+    fn used_elem(&self, index: u16) -> &VirtqUsedElem {\n+        unsafe {\n+            &*self\n+                .used\n+                .add(size_of::<VirtqUsed>())\n+                .as_ptr::<VirtqUsedElem>()\n+                .offset((index % self.num_descs) as isize)\n+        }\n+    }\n+}\n+\n+bitflags! {\n+    pub struct IsrStatus: u8 {\n+        const QUEUE_INTR = 1 << 0;\n+        const DEVICE_CONFIG_INTR = 1 << 1;\n+    }\n+}\n+\n+pub struct Virtio {\n+    transport: Arc<dyn VirtioTransport>,\n+    virtqueues: Vec<VirtQueue>,\n+}\n+\n+impl Virtio {\n+    pub fn new(transport: Arc<dyn VirtioTransport>) -> Virtio {\n+        Virtio {\n+            transport,\n+            virtqueues: Vec::new(),\n+        }\n+    }\n+\n+    /// Initialize the virtio device. It aborts if any of the features is not\n+    /// supported.\n+    pub fn initialize(\n+        &mut self,\n+        mut features: u64,\n+        num_virtqueues: u16,\n+    ) -> Result<(), VirtioAttachError> {\n+        features |= VIRTIO_F_VERSION_1;\n+\n+        // \"3.1.1 Driver Requirements: Device Initialization\"\n+        self.transport.write_device_status(0); // Reset the device.\n+        self.transport\n+            .write_device_status(self.transport.read_device_status() | VIRTIO_STATUS_ACK);\n+        self.transport\n+            .write_device_status(self.transport.read_device_status() | VIRTIO_STATUS_DRIVER);\n+\n+        let device_features = self.transport.read_device_features();\n+        if (device_features & features) != features {\n+            warn!(\n+                \"virtio: feature negotiation failure: driver={:x}, device={:x}, unspported={:x}\",\n+                features,\n+                device_features,\n+                features & !device_features\n+            );\n+            return Err(VirtioAttachError::MissingFeatures);\n+        }\n+\n+        self.transport.write_driver_features(features);\n+        self.transport\n+            .write_device_status(self.transport.read_device_status() | VIRTIO_STATUS_FEAT_OK);\n+\n+        if (self.transport.read_device_status() & VIRTIO_STATUS_FEAT_OK) == 0 {\n+            return Err(VirtioAttachError::FeatureNegotiationFailure);\n+        }\n+\n+        // Initialize virtqueues.\n+        let mut virtqueues = Vec::new();\n+        for index in 0..num_virtqueues {\n+            virtqueues.push(VirtQueue::new(index, self.transport.clone()));\n+        }\n+        self.virtqueues = virtqueues;\n+\n+        self.transport\n+            .write_device_status(self.transport.read_device_status() | VIRTIO_STATUS_DRIVER_OK);\n+\n+        Ok(())\n+    }\n+\n+    pub fn read_device_config8(&self, offset: u16) -> u8 {\n+        self.transport.read_device_config8(offset)\n+    }\n+\n+    pub fn read_isr_status(&self) -> IsrStatus {\n+        self.transport.read_isr_status()\n+    }\n+\n+    /// Returns the `i`-th virtqueue.\n+    pub fn virtq(&self, i: u16) -> &VirtQueue {\n+        self.virtqueues.get(i as usize).unwrap()\n+    }\n+\n+    /// Returns the `i`-th virtqueue.\n+    pub fn virtq_mut(&mut self, i: u16) -> &mut VirtQueue {\n+        self.virtqueues.get_mut(i as usize).unwrap()\n+    }\n+}\ndiff --git /dev/null b/libs/virtio/lib.rs\nnew file mode 100644\n--- /dev/null\n+++ b/libs/virtio/lib.rs\n@@ -0,0 +1,8 @@\n+#![no_std]\n+extern crate alloc;\n+\n+#[macro_use]\n+extern crate kerla_api;\n+\n+pub mod device;\n+pub mod transports;\ndiff --git /dev/null b/libs/virtio/transports/mod.rs\nnew file mode 100644\n--- /dev/null\n+++ b/libs/virtio/transports/mod.rs\n@@ -0,0 +1,23 @@\n+use crate::device::IsrStatus;\n+\n+use kerla_api::address::PAddr;\n+\n+pub mod virtio_mmio;\n+pub mod virtio_pci;\n+\n+pub trait VirtioTransport: Send + Sync {\n+    fn read_device_config8(&self, offset: u16) -> u8;\n+    fn read_isr_status(&self) -> IsrStatus;\n+    fn read_device_status(&self) -> u8;\n+    fn write_device_status(&self, value: u8);\n+    fn read_device_features(&self) -> u64;\n+    fn write_driver_features(&self, value: u64);\n+    fn select_queue(&self, index: u16);\n+    fn queue_max_size(&self) -> u16;\n+    fn set_queue_size(&self, queue_size: u16);\n+    fn notify_queue(&self, index: u16);\n+    fn enable_queue(&self);\n+    fn set_queue_desc_paddr(&self, paddr: PAddr);\n+    fn set_queue_driver_paddr(&self, paddr: PAddr);\n+    fn set_queue_device_paddr(&self, paddr: PAddr);\n+}\ndiff --git /dev/null b/libs/virtio/transports/virtio_mmio.rs\nnew file mode 100644\n--- /dev/null\n+++ b/libs/virtio/transports/virtio_mmio.rs\n@@ -0,0 +1,128 @@\n+use crate::device::IsrStatus;\n+\n+use kerla_api::address::{PAddr, VAddr};\n+\n+use super::VirtioTransport;\n+\n+pub struct VirtioMmio {\n+    mmio_base: VAddr,\n+}\n+\n+impl VirtioMmio {\n+    pub fn new(mmio_base: PAddr) -> VirtioMmio {\n+        VirtioMmio {\n+            mmio_base: mmio_base.as_vaddr(),\n+        }\n+    }\n+}\n+\n+impl VirtioTransport for VirtioMmio {\n+    fn read_device_config8(&self, offset: u16) -> u8 {\n+        unsafe {\n+            self.mmio_base\n+                .add((0x100 + offset) as usize)\n+                .read_volatile::<u8>() as u8\n+        }\n+    }\n+\n+    fn read_isr_status(&self) -> IsrStatus {\n+        IsrStatus::from_bits(unsafe { self.mmio_base.add(0x60).read_volatile::<u32>() as u8 })\n+            .unwrap()\n+    }\n+\n+    fn read_device_status(&self) -> u8 {\n+        unsafe { self.mmio_base.add(0x70).read_volatile::<u32>() as u8 }\n+    }\n+\n+    fn write_device_status(&self, value: u8) {\n+        unsafe {\n+            self.mmio_base.add(0x70).write_volatile::<u32>(value as u32);\n+        }\n+    }\n+\n+    fn read_device_features(&self) -> u64 {\n+        unsafe {\n+            self.mmio_base.add(0x14).write_volatile::<u32>(0);\n+            let low = self.mmio_base.add(0x10).read_volatile::<u32>();\n+            self.mmio_base.add(0x14).write_volatile::<u32>(1);\n+            let high = self.mmio_base.add(0x10).read_volatile::<u32>();\n+            ((high as u64) << 32) | (low as u64)\n+        }\n+    }\n+\n+    fn write_driver_features(&self, value: u64) {\n+        unsafe {\n+            self.mmio_base.add(0x24).write_volatile::<u32>(0);\n+            self.mmio_base\n+                .add(0x20)\n+                .write_volatile::<u32>((value & 0xffff_ffff) as u32);\n+            self.mmio_base.add(0x24).write_volatile::<u32>(1);\n+            self.mmio_base\n+                .add(0x20)\n+                .write_volatile::<u32>((value >> 32) as u32);\n+        }\n+    }\n+\n+    fn select_queue(&self, index: u16) {\n+        unsafe {\n+            self.mmio_base.add(0x30).write_volatile::<u32>(index as u32);\n+        }\n+    }\n+\n+    fn queue_max_size(&self) -> u16 {\n+        unsafe { self.mmio_base.add(0x34).read_volatile::<u32>() as u16 }\n+    }\n+\n+    fn set_queue_size(&self, queue_size: u16) {\n+        unsafe {\n+            self.mmio_base\n+                .add(0x38)\n+                .write_volatile::<u32>(queue_size as u32)\n+        }\n+    }\n+\n+    fn notify_queue(&self, index: u16) {\n+        unsafe {\n+            self.mmio_base.add(0x50).write_volatile::<u32>(index as u32);\n+        }\n+    }\n+\n+    fn enable_queue(&self) {\n+        unsafe {\n+            self.mmio_base.add(0x44).write_volatile::<u32>(1);\n+        }\n+    }\n+\n+    fn set_queue_desc_paddr(&self, paddr: PAddr) {\n+        unsafe {\n+            self.mmio_base\n+                .add(0x80)\n+                .write_volatile::<u32>((paddr.value() & 0xffff_ffff) as u32);\n+            self.mmio_base\n+                .add(0x84)\n+                .write_volatile::<u32>((paddr.value() >> 32) as u32);\n+        }\n+    }\n+\n+    fn set_queue_device_paddr(&self, paddr: PAddr) {\n+        unsafe {\n+            self.mmio_base\n+                .add(0xa0)\n+                .write_volatile::<u32>((paddr.value() & 0xffff_ffff) as u32);\n+            self.mmio_base\n+                .add(0xa4)\n+                .write_volatile::<u32>((paddr.value() >> 32) as u32);\n+        }\n+    }\n+\n+    fn set_queue_driver_paddr(&self, paddr: PAddr) {\n+        unsafe {\n+            self.mmio_base\n+                .add(0x90)\n+                .write_volatile::<u32>((paddr.value() & 0xffff_ffff) as u32);\n+            self.mmio_base\n+                .add(0x94)\n+                .write_volatile::<u32>((paddr.value() >> 32) as u32);\n+        }\n+    }\n+}\ndiff --git /dev/null b/libs/virtio/transports/virtio_pci.rs\nnew file mode 100644\n--- /dev/null\n+++ b/libs/virtio/transports/virtio_pci.rs\n@@ -0,0 +1,277 @@\n+use crate::device::IsrStatus;\n+\n+use core::convert::TryInto;\n+\n+use alloc::sync::Arc;\n+use kerla_api::{\n+    address::{PAddr, VAddr},\n+    driver::pci::{Bar, PciCapability, PciDevice},\n+};\n+use memoffset::offset_of;\n+\n+use super::VirtioTransport;\n+\n+const VIRTIO_PCI_CAP_COMMON_CFG: u8 = 1;\n+const VIRTIO_PCI_CAP_NOTIFY_CFG: u8 = 2;\n+const VIRTIO_PCI_CAP_ISR_CFG: u8 = 3;\n+const VIRTIO_PCI_CAP_DEVICE_CFG: u8 = 4;\n+\n+/// Walk capabilities list. A capability consists of the following fields\n+/// (from \"4.1.4 Virtio Structure PCI Capabilities\"):\n+///\n+/// ```text\n+/// struct virtio_pci_cap {\n+///     u8 cap_vndr;    /* Generic PCI field: PCI_CAP_ID_VNDR */\n+///     u8 cap_next;    /* Generic PCI field: next ptr. */\n+///     u8 cap_len;     /* Generic PCI field: capability length */\n+///     u8 cfg_type;    /* Identifies the structure. */\n+///     u8 bar;         /* Where to find it. */\n+///     u8 padding[3];  /* Pad to full dword. */\n+///     le32 offset;    /* Offset within bar. */\n+///     le32 length;    /* Length of the structure, in bytes. */\n+/// };\n+/// ```\n+fn get_bar_for_cfg_type(pci_device: &PciDevice, cfg_type: u8) -> Option<(&PciCapability, VAddr)> {\n+    let cap = pci_device\n+        .capabilities()\n+        .iter()\n+        .find(|cap| cap.id == 9 && cap.data.len() >= 16 && cap.data[3] == cfg_type)?;\n+\n+    let offset = u32::from_le_bytes(cap.data[8..12].try_into().unwrap()) as usize;\n+    match pci_device.config().bar(cap.data[4] as usize) {\n+        Bar::MemoryMapped { paddr } => Some((cap, paddr.as_vaddr().add(offset))),\n+        _ => {\n+            warn!(\"virtio-pci only supports memory-mapped I/O access for now\");\n+            None\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub enum VirtioAttachError {\n+    InvalidVendorId,\n+    MissingFeatures,\n+    FeatureNegotiationFailure,\n+}\n+\n+pub struct VirtioPci {\n+    common_cfg: VAddr,\n+    device_cfg: VAddr,\n+    notify: VAddr,\n+    notify_off_multiplier: u32,\n+    isr: VAddr,\n+}\n+\n+impl VirtioPci {\n+    pub fn probe_pci<F, T>(pci_device: &PciDevice, ctor: F) -> Result<T, VirtioAttachError>\n+    where\n+        F: FnOnce(Arc<dyn VirtioTransport>) -> Result<T, VirtioAttachError>,\n+    {\n+        // TODO: Check device type\n+        if pci_device.config().vendor_id() != 0x1af4 {\n+            return Err(VirtioAttachError::InvalidVendorId);\n+        }\n+\n+        let common_cfg = get_bar_for_cfg_type(pci_device, VIRTIO_PCI_CAP_COMMON_CFG)\n+            .expect(\"failed to locate pci_cap for common_cfg\")\n+            .1;\n+        let device_cfg = get_bar_for_cfg_type(pci_device, VIRTIO_PCI_CAP_DEVICE_CFG)\n+            .expect(\"failed to locate pci_cap for device_cfg\")\n+            .1;\n+        let isr = get_bar_for_cfg_type(pci_device, VIRTIO_PCI_CAP_ISR_CFG)\n+            .expect(\"failed to locate pci_cap for isr\")\n+            .1;\n+\n+        let (notify, notify_off_multiplier) =\n+            get_bar_for_cfg_type(pci_device, VIRTIO_PCI_CAP_NOTIFY_CFG)\n+                .map(|(cap, mmio)| {\n+                    // struct virtio_pci_notify_cap {\n+                    //     struct virtio_pci_cap cap;\n+                    //     le32 notify_off_multiplier; /* Multiplier for queue_notify_off. */\n+                    // };\n+                    let notify_off_multiplier =\n+                        u32::from_le_bytes(cap.data[16..20].try_into().unwrap());\n+                    (mmio, notify_off_multiplier)\n+                })\n+                .expect(\"failed to locate pci_cap for notify\");\n+\n+        pci_device.enable_bus_master();\n+\n+        let transport = Arc::new(VirtioPci {\n+            common_cfg,\n+            device_cfg,\n+            notify,\n+            notify_off_multiplier,\n+            isr,\n+        });\n+\n+        ctor(transport)\n+    }\n+}\n+\n+#[repr(C, packed)]\n+struct CommonCfg {\n+    device_feature_select: u32,\n+    device_feature: u32,\n+    driver_feature_select: u32,\n+    driver_feature: u32,\n+    msix_config: u16,\n+    num_queues: u16,\n+    device_status: u8,\n+    config_generation: u8,\n+    queue_select: u16,\n+    queue_size: u16,\n+    queue_msix_vector: u16,\n+    queue_enable: u16,\n+    queue_notify_off: u16,\n+    queue_desc_lo: u32,\n+    queue_desc_hi: u32,\n+    queue_driver_lo: u32,\n+    queue_driver_hi: u32,\n+    queue_device_lo: u32,\n+    queue_device_hi: u32,\n+}\n+\n+impl VirtioTransport for VirtioPci {\n+    fn read_device_config8(&self, offset: u16) -> u8 {\n+        unsafe { self.device_cfg.add(offset as usize).read_volatile::<u8>() }\n+    }\n+\n+    fn read_isr_status(&self) -> IsrStatus {\n+        IsrStatus::from_bits_truncate(unsafe { self.isr.add(0).read_volatile::<u8>() })\n+    }\n+\n+    fn read_device_status(&self) -> u8 {\n+        unsafe {\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, device_status))\n+                .read_volatile::<u8>()\n+        }\n+    }\n+\n+    fn write_device_status(&self, value: u8) {\n+        unsafe {\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, device_status))\n+                .write_volatile::<u8>(value)\n+        }\n+    }\n+\n+    fn read_device_features(&self) -> u64 {\n+        unsafe {\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, device_feature_select))\n+                .write_volatile::<u32>(0);\n+            let low = self\n+                .common_cfg\n+                .add(offset_of!(CommonCfg, device_feature))\n+                .read_volatile::<u32>();\n+\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, device_feature_select))\n+                .write_volatile::<u32>(1);\n+            let high = self\n+                .common_cfg\n+                .add(offset_of!(CommonCfg, device_feature))\n+                .read_volatile::<u32>();\n+\n+            ((high as u64) << 32) | (low as u64)\n+        }\n+    }\n+\n+    fn write_driver_features(&self, value: u64) {\n+        unsafe {\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, driver_feature_select))\n+                .write_volatile::<u32>(0);\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, driver_feature))\n+                .write_volatile::<u32>((value & 0xffff_ffff) as u32);\n+\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, driver_feature_select))\n+                .write_volatile::<u32>(1);\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, driver_feature))\n+                .write_volatile::<u32>((value >> 32) as u32);\n+        }\n+    }\n+\n+    fn select_queue(&self, index: u16) {\n+        unsafe {\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, queue_select))\n+                .write_volatile::<u16>(index)\n+        }\n+    }\n+\n+    fn queue_max_size(&self) -> u16 {\n+        unsafe {\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, queue_size))\n+                .read_volatile::<u16>()\n+        }\n+    }\n+\n+    fn set_queue_size(&self, queue_size: u16) {\n+        unsafe {\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, queue_size))\n+                .write_volatile::<u16>(queue_size)\n+        }\n+    }\n+\n+    fn notify_queue(&self, index: u16) {\n+        unsafe {\n+            let offset = self.notify_off_multiplier\n+                * self\n+                    .common_cfg\n+                    .add(offset_of!(CommonCfg, queue_notify_off))\n+                    .read_volatile::<u16>() as u32;\n+            self.notify\n+                .add(offset as usize)\n+                .write_volatile::<u16>(index)\n+        }\n+    }\n+\n+    fn enable_queue(&self) {\n+        unsafe {\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, queue_enable))\n+                .write_volatile::<u16>(1);\n+        }\n+    }\n+\n+    fn set_queue_desc_paddr(&self, paddr: PAddr) {\n+        unsafe {\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, queue_desc_lo))\n+                .write_volatile::<u32>((paddr.value() & 0xffff_ffff) as u32);\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, queue_desc_hi))\n+                .write_volatile::<u32>((paddr.value() >> 32) as u32);\n+        }\n+    }\n+\n+    fn set_queue_driver_paddr(&self, paddr: PAddr) {\n+        unsafe {\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, queue_driver_lo))\n+                .write_volatile::<u32>((paddr.value() & 0xffff_ffff) as u32);\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, queue_driver_hi))\n+                .write_volatile::<u32>((paddr.value() >> 32) as u32);\n+        }\n+    }\n+\n+    fn set_queue_device_paddr(&self, paddr: PAddr) {\n+        unsafe {\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, queue_device_lo))\n+                .write_volatile::<u32>((paddr.value() & 0xffff_ffff) as u32);\n+            self.common_cfg\n+                .add(offset_of!(CommonCfg, queue_device_hi))\n+                .write_volatile::<u32>((paddr.value() >> 32) as u32);\n+        }\n+    }\n+}\n",
        "test_patch": "diff --git a/kernel/main.rs b/kernel/main.rs\n--- a/kernel/main.rs\n+++ b/kernel/main.rs\n@@ -64,6 +65,7 @@ use kerla_runtime::{\n     spinlock::SpinLock,\n };\n use kerla_utils::once::Once;\n+use net::register_ethernet_driver;\n use tmpfs::TMP_FS;\n \n #[cfg(test)]\n",
        "problem_statement": "Turn device drivers into libraries (i.e. support Kernel Extensions)\n- [ ] Survey prior work\r\n- [ ] Design Kernel Extension API\r\n- [ ] Turn virtio-net driver into a separate crate\n",
        "hints_text": "Stuff used in existing device drivers:\r\n```rust\r\n// prelude\r\npub use crate::alloc::borrow::ToOwned;\r\npub use alloc::string::{String, ToString};\r\npub use alloc::sync::{Arc, Weak};\r\npub use alloc::vec;\r\npub use alloc::vec::Vec;\r\n\r\nuse crate::arch::{SpinLock, PAddr, VAddr, PAGE_SIZE};\r\n\r\nuse crate::{\r\n    net::{process_packets, receive_ethernet_frame},\r\n    result::{Errno, Error, Result}\r\n    boot::VirtioMmioDevice,\r\n    drivers::{\r\n        register_ethernet_driver,\r\n        pci::PciDevice,\r\n        virtio::{\r\n            transports::{virtio_mmio::VirtioMmio, virtio_pci::VirtioPci, VirtioTransport},\r\n            virtio::VirtqUsedChain,\r\n        },\r\n        Driver, DriverBuilder, EthernetDriver, MacAddress,\r\n    },\r\n    interrupt::attach_irq,\r\n    mm::page_allocator::{alloc_pages, AllocPageFlags},\r\n};\r\n```",
        "created_at": "2021-11-12T09:27:23Z"
    }
]