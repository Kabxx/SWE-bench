[
    {
        "repo": "openethereum/openethereum",
        "pull_number": 570,
        "instance_id": "openethereum__openethereum-570",
        "issue_numbers": [
            "552"
        ],
        "base_commit": "64a16147690f3d9d39acd7052001818ab00b94f0",
        "patch": "diff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -666,6 +666,20 @@ impl TransactionQueue {\n         }\n     }\n \n+    /// Returns effective priority fee gas price of currently the worst transaction in the pool.\n+    /// If the worst transaction has zero gas price, the minimal gas price is returned.\n+    pub fn current_worst_effective_priority_fee(&self) -> U256 {\n+        self.pool\n+            .read()\n+            .worst_transaction()\n+            .filter(|tx| !tx.signed().has_zero_gas_price())\n+            .map(|tx| {\n+                tx.signed()\n+                    .effective_priority_fee(self.options.read().block_base_fee)\n+            })\n+            .unwrap_or(self.options.read().minimal_gas_price)\n+    }\n+\n     /// Returns a status of the queue.\n     pub fn status(&self) -> Status {\n         let pool = self.pool.read();\ndiff --git a/crates/ethcore/src/client/traits.rs b/crates/ethcore/src/client/traits.rs\n--- a/crates/ethcore/src/client/traits.rs\n+++ b/crates/ethcore/src/client/traits.rs\n@@ -416,6 +416,40 @@ pub trait BlockChainClient:\n         corpus.into()\n     }\n \n+    /// Sorted list of transaction priority gas prices from at least last sample_size blocks.\n+    fn priority_gas_price_corpus(\n+        &self,\n+        sample_size: usize,\n+        eip1559_transition: BlockNumber,\n+    ) -> ::stats::Corpus<U256> {\n+        let mut h = self.chain_info().best_block_hash;\n+        let mut corpus = Vec::new();\n+        while corpus.is_empty() {\n+            for _ in 0..sample_size {\n+                let block = match self.block(BlockId::Hash(h)) {\n+                    Some(block) => block,\n+                    None => return corpus.into(),\n+                };\n+\n+                if block.number() == 0 || block.number() < eip1559_transition {\n+                    return corpus.into();\n+                }\n+                block\n+                    .transaction_views()\n+                    .iter()\n+                    .filter(\n+                        |t| t.gas_price() > 0.into(), /* filter zero cost transactions */\n+                    )\n+                    .foreach(|t| {\n+                        // As block.number() >= eip_1559_transition, the base_fee should exist\n+                        corpus.push(t.effective_priority_gas_price(Some(block.header().base_fee())))\n+                    });\n+                h = block.parent_hash().clone();\n+            }\n+        }\n+        corpus.into()\n+    }\n+\n     /// Get the preferred chain ID to sign on\n     fn signing_chain_id(&self) -> Option<u64>;\n \ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -1006,6 +1006,14 @@ impl miner::MinerService for Miner {\n         self.transaction_queue.current_worst_gas_price() * 110u32 / 100\n     }\n \n+    fn sensible_max_priority_fee(&self) -> U256 {\n+        // 10% above our minimum.\n+        self.transaction_queue\n+            .current_worst_effective_priority_fee()\n+            * 110u32\n+            / 100\n+    }\n+\n     fn sensible_gas_limit(&self) -> U256 {\n         self.params.read().gas_range_target.0 / 5\n     }\ndiff --git a/crates/ethcore/src/miner/mod.rs b/crates/ethcore/src/miner/mod.rs\n--- a/crates/ethcore/src/miner/mod.rs\n+++ b/crates/ethcore/src/miner/mod.rs\n@@ -260,6 +260,9 @@ pub trait MinerService: Send + Sync {\n     /// Suggested gas price.\n     fn sensible_gas_price(&self) -> U256;\n \n+    /// Suggested max priority fee gas price\n+    fn sensible_max_priority_fee(&self) -> U256;\n+\n     /// Suggested gas limit.\n     fn sensible_gas_limit(&self) -> U256;\n \ndiff --git a/crates/ethcore/types/src/views/typed_transaction.rs b/crates/ethcore/types/src/views/typed_transaction.rs\n--- a/crates/ethcore/types/src/views/typed_transaction.rs\n+++ b/crates/ethcore/types/src/views/typed_transaction.rs\n@@ -137,6 +137,29 @@ impl<'a> TypedTransactionView<'a> {\n         }\n     }\n \n+    /// Get the actual priority gas price paid to the miner\n+    pub fn effective_priority_gas_price(&self, block_base_fee: Option<U256>) -> U256 {\n+        match self.transaction_type {\n+            TypedTxId::Legacy => self\n+                .gas_price()\n+                .saturating_sub(block_base_fee.unwrap_or_default()),\n+            TypedTxId::AccessList => self\n+                .gas_price()\n+                .saturating_sub(block_base_fee.unwrap_or_default()),\n+            TypedTxId::EIP1559Transaction => {\n+                let max_priority_fee_per_gas: U256 =\n+                    view!(Self, &self.rlp.rlp.data().unwrap()[1..])\n+                        .rlp\n+                        .val_at(2);\n+                min(\n+                    max_priority_fee_per_gas,\n+                    self.gas_price()\n+                        .saturating_sub(block_base_fee.unwrap_or_default()),\n+                )\n+            }\n+        }\n+    }\n+\n     /// Get the gas field of the transaction.\n     pub fn gas(&self) -> U256 {\n         match self.transaction_type {\ndiff --git a/crates/rpc/src/v1/helpers/dispatch/mod.rs b/crates/rpc/src/v1/helpers/dispatch/mod.rs\n--- a/crates/rpc/src/v1/helpers/dispatch/mod.rs\n+++ b/crates/rpc/src/v1/helpers/dispatch/mod.rs\n@@ -91,7 +91,10 @@ use ethcore::{client::BlockChainClient, miner::MinerService};\n use ethereum_types::{Address, H256, H520, U256};\n use ethkey::Password;\n use hash::keccak;\n-use types::transaction::{PendingTransaction, SignedTransaction};\n+use types::{\n+    transaction::{PendingTransaction, SignedTransaction},\n+    BlockNumber,\n+};\n \n use jsonrpc_core::{\n     futures::{future, Future, IntoFuture},\ndiff --git a/crates/rpc/src/v1/helpers/dispatch/mod.rs b/crates/rpc/src/v1/helpers/dispatch/mod.rs\n--- a/crates/rpc/src/v1/helpers/dispatch/mod.rs\n+++ b/crates/rpc/src/v1/helpers/dispatch/mod.rs\n@@ -397,6 +400,24 @@ where\n         .unwrap_or_else(|| miner.sensible_gas_price())\n }\n \n+/// Extract the default priority gas price from a client and miner.\n+pub fn default_max_priority_fee_per_gas<C, M>(\n+    client: &C,\n+    miner: &M,\n+    percentile: usize,\n+    eip1559_transition: BlockNumber,\n+) -> U256\n+where\n+    C: BlockChainClient,\n+    M: MinerService,\n+{\n+    client\n+        .priority_gas_price_corpus(100, eip1559_transition)\n+        .percentile(percentile)\n+        .cloned()\n+        .unwrap_or_else(|| miner.sensible_max_priority_fee())\n+}\n+\n /// Convert RPC confirmation payload to signer confirmation payload.\n /// May need to resolve in the future to fetch things like gas price.\n pub fn from_rpc<D>(\ndiff --git a/crates/rpc/src/v1/helpers/errors.rs b/crates/rpc/src/v1/helpers/errors.rs\n--- a/crates/rpc/src/v1/helpers/errors.rs\n+++ b/crates/rpc/src/v1/helpers/errors.rs\n@@ -273,6 +273,10 @@ where\n     }\n }\n \n+pub fn eip1559_not_activated() -> Error {\n+    unsupported(\"EIP-1559 is not activated\", None)\n+}\n+\n pub fn not_enough_data() -> Error {\n     Error {\n         code: ErrorCode::ServerError(codes::UNSUPPORTED_REQUEST),\ndiff --git a/crates/rpc/src/v1/impls/eth.rs b/crates/rpc/src/v1/impls/eth.rs\n--- a/crates/rpc/src/v1/impls/eth.rs\n+++ b/crates/rpc/src/v1/impls/eth.rs\n@@ -52,7 +52,7 @@ use v1::{\n         self,\n         block_import::is_major_importing,\n         deprecated::{self, DeprecationNotice},\n-        dispatch::{default_gas_price, FullDispatcher},\n+        dispatch::{default_gas_price, default_max_priority_fee_per_gas, FullDispatcher},\n         errors, fake_sign, limit_logs,\n     },\n     metadata::Metadata,\ndiff --git a/crates/rpc/src/v1/impls/eth.rs b/crates/rpc/src/v1/impls/eth.rs\n--- a/crates/rpc/src/v1/impls/eth.rs\n+++ b/crates/rpc/src/v1/impls/eth.rs\n@@ -805,8 +821,11 @@ where\n \n                                                 gas_and_reward.push((\n                                                     gas_used,\n-                                                    txs[i].effective_gas_price(base_fee)\n-                                                        - base_fee.unwrap_or_default(),\n+                                                    txs[i]\n+                                                        .effective_gas_price(base_fee)\n+                                                        .saturating_sub(\n+                                                            base_fee.unwrap_or_default(),\n+                                                        ),\n                                                 ));\n                                             }\n                                         }\ndiff --git a/crates/rpc/src/v1/traits/eth.rs b/crates/rpc/src/v1/traits/eth.rs\n--- a/crates/rpc/src/v1/traits/eth.rs\n+++ b/crates/rpc/src/v1/traits/eth.rs\n@@ -60,6 +60,10 @@ pub trait Eth {\n     #[rpc(name = \"eth_gasPrice\")]\n     fn gas_price(&self) -> BoxFuture<U256>;\n \n+    /// Returns current max_priority_fee\n+    #[rpc(name = \"eth_maxPriorityFeePerGas\")]\n+    fn max_priority_fee_per_gas(&self) -> BoxFuture<U256>;\n+\n     /// Returns transaction fee history.\n     #[rpc(name = \"eth_feeHistory\")]\n     fn fee_history(&self, _: U256, _: BlockNumber, _: Option<Vec<f64>>)\n",
        "test_patch": "diff --git a/crates/ethcore/src/client/test_client.rs b/crates/ethcore/src/client/test_client.rs\n--- a/crates/ethcore/src/client/test_client.rs\n+++ b/crates/ethcore/src/client/test_client.rs\n@@ -1090,6 +1090,10 @@ impl BlockChainClient for TestBlockChainClient {\n         }\n         None\n     }\n+\n+    fn is_aura(&self) -> bool {\n+        self.engine().name() == \"AuthorityRound\"\n+    }\n }\n \n impl IoClient for TestBlockChainClient {\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -504,7 +504,10 @@ mod test {\n     use super::{super::tests::*, *};\n     use blocks::SyncHeader;\n     use bytes::Bytes;\n-    use ethcore::client::{BlockChainClient, EachBlockWith, TestBlockChainClient};\n+    use ethcore::{\n+        client::{BlockChainClient, EachBlockWith, TestBlockChainClient},\n+        spec::Spec,\n+    };\n     use ethereum_types::H256;\n     use parking_lot::RwLock;\n     use rlp::{Rlp, RlpStream};\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -769,7 +772,7 @@ mod test {\n \n     #[test]\n     fn return_nodes() {\n-        let mut client = TestBlockChainClient::new();\n+        let mut client = TestBlockChainClient::new_with_spec(Spec::new_test_round());\n         let queue = RwLock::new(VecDeque::new());\n         let sync = dummy_sync_with_peer(H256::zero(), &client);\n         let ss = TestSnapshotService::new();\ndiff --git a/crates/ethcore/types/src/views/typed_transaction.rs b/crates/ethcore/types/src/views/typed_transaction.rs\n--- a/crates/ethcore/types/src/views/typed_transaction.rs\n+++ b/crates/ethcore/types/src/views/typed_transaction.rs\n@@ -260,6 +283,7 @@ mod tests {\n         assert_eq!(view.nonce(), 0.into());\n         assert_eq!(view.gas_price(), 1.into());\n         assert_eq!(view.effective_gas_price(None), 1.into());\n+        assert_eq!(view.effective_priority_gas_price(None), 1.into());\n         assert_eq!(view.gas(), 0x61a8.into());\n         assert_eq!(view.value(), 0xa.into());\n         assert_eq!(\ndiff --git a/crates/ethcore/types/src/views/typed_transaction.rs b/crates/ethcore/types/src/views/typed_transaction.rs\n--- a/crates/ethcore/types/src/views/typed_transaction.rs\n+++ b/crates/ethcore/types/src/views/typed_transaction.rs\n@@ -285,6 +309,7 @@ mod tests {\n         let view = view!(TypedTransactionView, &rlp);\n         assert_eq!(view.nonce(), 0x1.into());\n         assert_eq!(view.gas_price(), 0xa.into());\n+        assert_eq!(view.effective_priority_gas_price(None), 0xa.into());\n         assert_eq!(view.gas(), 0x1e241.into());\n         assert_eq!(view.value(), 0x0.into());\n         assert_eq!(view.data(), \"\".from_hex().unwrap());\ndiff --git a/crates/ethcore/types/src/views/typed_transaction.rs b/crates/ethcore/types/src/views/typed_transaction.rs\n--- a/crates/ethcore/types/src/views/typed_transaction.rs\n+++ b/crates/ethcore/types/src/views/typed_transaction.rs\n@@ -306,6 +331,10 @@ mod tests {\n         assert_eq!(view.nonce(), 0x1.into());\n         assert_eq!(view.gas_price(), 0xa.into());\n         assert_eq!(view.effective_gas_price(Some(0x07.into())), 0x08.into());\n+        assert_eq!(\n+            view.effective_priority_gas_price(Some(0x07.into())),\n+            0x01.into()\n+        );\n         assert_eq!(view.gas(), 0x1e241.into());\n         assert_eq!(view.value(), 0x0.into());\n         assert_eq!(view.data(), \"\".from_hex().unwrap());\ndiff --git a/crates/rpc/src/v1/impls/eth.rs b/crates/rpc/src/v1/impls/eth.rs\n--- a/crates/rpc/src/v1/impls/eth.rs\n+++ b/crates/rpc/src/v1/impls/eth.rs\n@@ -696,6 +696,22 @@ where\n         )))\n     }\n \n+    fn max_priority_fee_per_gas(&self) -> BoxFuture<U256> {\n+        let latest_block = self.client.chain_info().best_block_number;\n+        let eip1559_transition = self.client.engine().params().eip1559_transition;\n+\n+        if latest_block + 1 >= eip1559_transition {\n+            Box::new(future::ok(default_max_priority_fee_per_gas(\n+                &*self.client,\n+                &*self.miner,\n+                self.options.gas_price_percentile,\n+                eip1559_transition,\n+            )))\n+        } else {\n+            Box::new(future::done(Err(errors::eip1559_not_activated())))\n+        }\n+    }\n+\n     fn fee_history(\n         &self,\n         mut block_count: U256,\ndiff --git a/crates/rpc/src/v1/tests/eth.rs b/crates/rpc/src/v1/tests/eth.rs\n--- a/crates/rpc/src/v1/tests/eth.rs\n+++ b/crates/rpc/src/v1/tests/eth.rs\n@@ -19,7 +19,7 @@ use std::{env, sync::Arc};\n \n use accounts::AccountProvider;\n use ethcore::{\n-    client::{BlockChainClient, ChainInfo, Client, ClientConfig, ImportBlock},\n+    client::{BlockChainClient, ChainInfo, Client, ClientConfig, EvmTestClient, ImportBlock},\n     ethereum,\n     miner::Miner,\n     spec::{Genesis, Spec},\ndiff --git a/crates/rpc/src/v1/tests/eth.rs b/crates/rpc/src/v1/tests/eth.rs\n--- a/crates/rpc/src/v1/tests/eth.rs\n+++ b/crates/rpc/src/v1/tests/eth.rs\n@@ -67,7 +67,7 @@ fn snapshot_service() -> Arc<TestSnapshotService> {\n \n fn make_spec(chain: &BlockChain) -> Spec {\n     let genesis = Genesis::from(chain.genesis());\n-    let mut spec = ethereum::new_frontier_test();\n+    let mut spec = EvmTestClient::spec_from_json(&chain.network).unwrap();\n     let state = chain.pre_state.clone().into();\n     spec.set_genesis_state(state)\n         .expect(\"unable to set genesis state\");\ndiff --git a/crates/rpc/src/v1/tests/eth.rs b/crates/rpc/src/v1/tests/eth.rs\n--- a/crates/rpc/src/v1/tests/eth.rs\n+++ b/crates/rpc/src/v1/tests/eth.rs\n@@ -281,6 +281,26 @@ fn eth_get_block() {\n     );\n }\n \n+#[test]\n+fn eth_get_max_priority_fee_per_gas() {\n+    let chain = extract_non_legacy_chain!(\n+        \"BlockchainTests/ValidBlocks/bcEIP1559/transType\",\n+        ForkSpec::London\n+    );\n+    let tester = EthTester::from_chain(&chain);\n+    let request = r#\"{\"method\":\"eth_maxPriorityFeePerGas\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}\"#;\n+\n+    // We are expecting for 50-th percentile of the previous 100 blocks transactions priority fees.\n+    //\n+    // Sorted priority fees: 0x64 0x64 0x64 0x7d 0x7d 0xea 0x149.\n+    // Currently, the way 50-th percentile is calculated, the 3rd fee would be the result.\n+    let response = r#\"{\"jsonrpc\":\"2.0\",\"result\":\"0x64\",\"id\":1}\"#;\n+    assert_eq!(\n+        tester.handler.handle_request_sync(request).unwrap(),\n+        response\n+    )\n+}\n+\n #[test]\n fn eth_get_block_by_hash() {\n     let chain = extract_chain!(\"BlockchainTests/ValidBlocks/bcGasPricerTest/RPC_API_Test\");\ndiff --git a/crates/rpc/src/v1/tests/helpers/miner_service.rs b/crates/rpc/src/v1/tests/helpers/miner_service.rs\n--- a/crates/rpc/src/v1/tests/helpers/miner_service.rs\n+++ b/crates/rpc/src/v1/tests/helpers/miner_service.rs\n@@ -359,6 +359,10 @@ impl MinerService for TestMinerService {\n         20_000_000_000u64.into()\n     }\n \n+    fn sensible_max_priority_fee(&self) -> U256 {\n+        2_000_000_000u64.into()\n+    }\n+\n     fn sensible_gas_limit(&self) -> U256 {\n         0x5208.into()\n     }\ndiff --git a/crates/rpc/src/v1/tests/mocked/eth.rs b/crates/rpc/src/v1/tests/mocked/eth.rs\n--- a/crates/rpc/src/v1/tests/mocked/eth.rs\n+++ b/crates/rpc/src/v1/tests/mocked/eth.rs\n@@ -23,7 +23,7 @@ use std::{\n \n use accounts::AccountProvider;\n use ethcore::{\n-    client::{BlockChainClient, EachBlockWith, Executed, TestBlockChainClient},\n+    client::{BlockChainClient, EachBlockWith, EvmTestClient, Executed, TestBlockChainClient},\n     miner::{self, MinerService},\n };\n use ethereum_types::{Address, Bloom, H160, H256, U256};\ndiff --git a/crates/rpc/src/v1/tests/mocked/eth.rs b/crates/rpc/src/v1/tests/mocked/eth.rs\n--- a/crates/rpc/src/v1/tests/mocked/eth.rs\n+++ b/crates/rpc/src/v1/tests/mocked/eth.rs\n@@ -51,6 +51,12 @@ fn blockchain_client() -> Arc<TestBlockChainClient> {\n     Arc::new(client)\n }\n \n+fn eip1559_blockchain_client() -> Arc<TestBlockChainClient> {\n+    let spec = EvmTestClient::spec_from_json(&ethjson::spec::ForkSpec::London).unwrap();\n+    let client = TestBlockChainClient::new_with_spec(spec);\n+    Arc::new(client)\n+}\n+\n fn accounts_provider() -> Arc<AccountProvider> {\n     Arc::new(AccountProvider::transient_provider())\n }\ndiff --git a/crates/rpc/src/v1/tests/mocked/eth.rs b/crates/rpc/src/v1/tests/mocked/eth.rs\n--- a/crates/rpc/src/v1/tests/mocked/eth.rs\n+++ b/crates/rpc/src/v1/tests/mocked/eth.rs\n@@ -89,8 +95,25 @@ impl Default for EthTester {\n \n impl EthTester {\n     pub fn new_with_options(options: EthClientOptions) -> Self {\n-        let runtime = Runtime::with_thread_count(1);\n         let client = blockchain_client();\n+        EthTester::new_with_client_and_options(client, options)\n+    }\n+\n+    fn new_eip1559_with_options(options: EthClientOptions) -> Self {\n+        let client = eip1559_blockchain_client();\n+        EthTester::new_with_client_and_options(client, options)\n+    }\n+\n+    pub fn add_blocks(&self, count: usize, with: EachBlockWith) {\n+        self.client.add_blocks(count, with);\n+        self.sync.increase_imported_block_number(count as u64);\n+    }\n+\n+    fn new_with_client_and_options(\n+        client: Arc<TestBlockChainClient>,\n+        options: EthClientOptions,\n+    ) -> Self {\n+        let runtime = Runtime::with_thread_count(1);\n         let sync = sync_provider();\n         let ap = accounts_provider();\n         let ap2 = ap.clone();\ndiff --git a/crates/rpc/src/v1/tests/mocked/eth.rs b/crates/rpc/src/v1/tests/mocked/eth.rs\n--- a/crates/rpc/src/v1/tests/mocked/eth.rs\n+++ b/crates/rpc/src/v1/tests/mocked/eth.rs\n@@ -126,11 +149,6 @@ impl EthTester {\n             hashrates,\n         }\n     }\n-\n-    pub fn add_blocks(&self, count: usize, with: EachBlockWith) {\n-        self.client.add_blocks(count, with);\n-        self.sync.increase_imported_block_number(count as u64);\n-    }\n }\n \n #[test]\ndiff --git a/crates/rpc/src/v1/tests/mocked/eth.rs b/crates/rpc/src/v1/tests/mocked/eth.rs\n--- a/crates/rpc/src/v1/tests/mocked/eth.rs\n+++ b/crates/rpc/src/v1/tests/mocked/eth.rs\n@@ -537,6 +555,33 @@ fn rpc_eth_gas_price() {\n     );\n }\n \n+#[test]\n+fn rpc_eth_get_max_priority_fee_per_gas() {\n+    let tester = EthTester::new_eip1559_with_options(Default::default());\n+\n+    let request = r#\"{\"method\":\"eth_maxPriorityFeePerGas\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}\"#;\n+    let response = r#\"{\"jsonrpc\":\"2.0\",\"result\":\"0x77359400\",\"id\":1}\"#; // 2 GWei\n+\n+    assert_eq!(\n+        tester.io.handle_request_sync(request),\n+        Some(response.to_owned())\n+    );\n+}\n+\n+#[test]\n+fn rpc_eth_get_max_priority_fee_per_gas_error() {\n+    let tester = EthTester::default();\n+\n+    let request = r#\"{\"method\":\"eth_maxPriorityFeePerGas\",\"params\":[],\"id\":1,\"jsonrpc\":\"2.0\"}\"#;\n+    let response =\n+        r#\"{\"jsonrpc\":\"2.0\",\"error\":{\"code\":-32000,\"message\":\"EIP-1559 is not activated\"},\"id\":1}\"#;\n+\n+    assert_eq!(\n+        tester.io.handle_request_sync(request),\n+        Some(response.to_owned())\n+    );\n+}\n+\n #[test]\n fn rpc_eth_accounts() {\n     let tester = EthTester::default();\ndiff --git a/crates/rpc/src/v1/tests/mod.rs b/crates/rpc/src/v1/tests/mod.rs\n--- a/crates/rpc/src/v1/tests/mod.rs\n+++ b/crates/rpc/src/v1/tests/mod.rs\n@@ -51,6 +51,23 @@ macro_rules! register_test {\n \t};\n }\n \n+macro_rules! extract_non_legacy_chain {\n+    ($file: expr, $network: expr) => {{\n+        const RAW_DATA: &'static [u8] = include_bytes!(concat!(\n+            \"../../../../ethcore/res/json_tests/\",\n+            $file,\n+            \".json\"\n+        ));\n+        ::ethjson::blockchain::Test::load(RAW_DATA)\n+            .unwrap()\n+            .into_iter()\n+            .filter(|&(_, ref t)| t.network == $network)\n+            .next()\n+            .unwrap()\n+            .1\n+    }};\n+}\n+\n #[cfg(test)]\n mod eth;\n #[cfg(test)]\n",
        "problem_statement": "Lack of eth_maxPriorityFeePerGas implementation on OE 3.3.0-rc.8.\nSummary:\r\n\r\n- **OpenEthereum version3.3.0-rc.8\r\n- **Fully synchronized**:  yes\r\n- **Network**: Volta (PoA, AuRa)\r\n\r\nIssue:\r\n\r\nLack of eth_maxPriorityFeePerGas implementation on OE 3.3.0-rc.8.\r\n\r\nWe have recently upgraded our Volta test Chain to London, and received some community raised issues related to the lack of eth_maxPriorityFeePerGas implementation on OE. \r\n\r\nAre there any plans on introducing the above on OE? Maybe in future rc release ?\r\n\r\nInformation on that front will be an important input for the plan on our mainnet (EWC) London Hard fork release. \r\n\r\nWoudl you kindly please advise?\r\n\r\n\r\n\n",
        "hints_text": "",
        "created_at": "2021-11-19T09:16:45Z",
        "version": "3.3"
    },
    {
        "repo": "openethereum/openethereum",
        "pull_number": 469,
        "instance_id": "openethereum__openethereum-469",
        "issue_numbers": [
            "466"
        ],
        "base_commit": "43ee52090498d947f95ff0055ef21101855db4c0",
        "patch": "diff --git a/crates/db/journaldb/src/archivedb.rs b/crates/db/journaldb/src/archivedb.rs\n--- a/crates/db/journaldb/src/archivedb.rs\n+++ b/crates/db/journaldb/src/archivedb.rs\n@@ -25,12 +25,14 @@ use std::{\n use super::{\n     error_key_already_exists, error_negatively_reference_hash, memory_db::*, LATEST_ERA_KEY,\n };\n+use bytes::Bytes;\n use ethcore_db::{DBTransaction, DBValue, KeyValueDB};\n use ethereum_types::H256;\n use hash_db::HashDB;\n use keccak_hasher::KeccakHasher;\n use rlp::{decode, encode};\n use traits::JournalDB;\n+use DB_PREFIX_LEN;\n \n /// Implementation of the `HashDB` trait for a disk-backed database with a memory overlay\n /// and latent-removal semantics.\ndiff --git a/crates/db/journaldb/src/earlymergedb.rs b/crates/db/journaldb/src/earlymergedb.rs\n--- a/crates/db/journaldb/src/earlymergedb.rs\n+++ b/crates/db/journaldb/src/earlymergedb.rs\n@@ -35,6 +35,7 @@ use parity_util_mem::MallocSizeOf;\n use parking_lot::RwLock;\n use rlp::{decode, encode};\n use util::{DatabaseKey, DatabaseValueRef, DatabaseValueView};\n+use DB_PREFIX_LEN;\n \n #[derive(Debug, Clone, PartialEq, Eq, MallocSizeOf)]\n struct RefInfo {\ndiff --git a/crates/db/journaldb/src/overlayrecentdb.rs b/crates/db/journaldb/src/overlayrecentdb.rs\n--- a/crates/db/journaldb/src/overlayrecentdb.rs\n+++ b/crates/db/journaldb/src/overlayrecentdb.rs\n@@ -23,6 +23,7 @@ use std::{\n };\n \n use super::{error_negatively_reference_hash, JournalDB, DB_PREFIX_LEN, LATEST_ERA_KEY};\n+use bytes::Bytes;\n use ethcore_db::{DBTransaction, DBValue, KeyValueDB};\n use ethereum_types::H256;\n use fastmap::H256FastMap;\ndiff --git a/crates/db/journaldb/src/overlayrecentdb.rs b/crates/db/journaldb/src/overlayrecentdb.rs\n--- a/crates/db/journaldb/src/overlayrecentdb.rs\n+++ b/crates/db/journaldb/src/overlayrecentdb.rs\n@@ -509,6 +510,26 @@ impl JournalDB for OverlayRecentDB {\n     fn consolidate(&mut self, with: MemoryDB<KeccakHasher, DBValue>) {\n         self.transaction_overlay.consolidate(with);\n     }\n+\n+    fn state(&self, key: &H256) -> Option<Bytes> {\n+        let journal_overlay = self.journal_overlay.read();\n+        let key = to_short_key(key);\n+        journal_overlay\n+            .backing_overlay\n+            .get(&key)\n+            .map(|v| v.into_vec())\n+            .or_else(|| {\n+                journal_overlay\n+                    .pending_overlay\n+                    .get(&key)\n+                    .map(|d| d.clone().into_vec())\n+            })\n+            .or_else(|| {\n+                self.backing\n+                    .get_by_prefix(self.column, &key[0..DB_PREFIX_LEN])\n+                    .map(|b| b.into_vec())\n+            })\n+    }\n }\n \n impl HashDB<KeccakHasher, DBValue> for OverlayRecentDB {\ndiff --git a/crates/db/journaldb/src/refcounteddb.rs b/crates/db/journaldb/src/refcounteddb.rs\n--- a/crates/db/journaldb/src/refcounteddb.rs\n+++ b/crates/db/journaldb/src/refcounteddb.rs\n@@ -23,6 +23,7 @@ use std::{\n };\n \n use super::{traits::JournalDB, LATEST_ERA_KEY};\n+use bytes::Bytes;\n use ethcore_db::{DBTransaction, DBValue, KeyValueDB};\n use ethereum_types::H256;\n use hash_db::HashDB;\ndiff --git a/crates/db/journaldb/src/refcounteddb.rs b/crates/db/journaldb/src/refcounteddb.rs\n--- a/crates/db/journaldb/src/refcounteddb.rs\n+++ b/crates/db/journaldb/src/refcounteddb.rs\n@@ -32,6 +33,7 @@ use overlaydb::OverlayDB;\n use parity_util_mem::{allocators::new_malloc_size_ops, MallocSizeOf};\n use rlp::{decode, encode};\n use util::{DatabaseKey, DatabaseValueRef, DatabaseValueView};\n+use DB_PREFIX_LEN;\n \n /// Implementation of the `HashDB` trait for a disk-backed database with a memory overlay\n /// and latent-removal semantics.\ndiff --git a/crates/db/journaldb/src/traits.rs b/crates/db/journaldb/src/traits.rs\n--- a/crates/db/journaldb/src/traits.rs\n+++ b/crates/db/journaldb/src/traits.rs\n@@ -18,6 +18,7 @@\n \n use std::{io, sync::Arc};\n \n+use bytes::Bytes;\n use ethcore_db::{DBTransaction, DBValue, KeyValueDB};\n use ethereum_types::H256;\n use hash_db::{AsHashDB, HashDB};\ndiff --git a/crates/ethcore/src/client/client.rs b/crates/ethcore/src/client/client.rs\n--- a/crates/ethcore/src/client/client.rs\n+++ b/crates/ethcore/src/client/client.rs\n@@ -2776,6 +2776,10 @@ impl BlockChainClient for Client {\n     fn registrar_address(&self) -> Option<Address> {\n         self.registrar_address.clone()\n     }\n+\n+    fn state_data(&self, hash: &H256) -> Option<Bytes> {\n+        self.state_db.read().journal_db().state(hash)\n+    }\n }\n \n impl IoClient for Client {\ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -169,6 +169,7 @@ pub const PAR_PROTOCOL_VERSION_2: (u8, u8) = (2, 0x16);\n \n pub const MAX_BODIES_TO_SEND: usize = 256;\n pub const MAX_HEADERS_TO_SEND: usize = 512;\n+pub const MAX_NODE_DATA_TO_SEND: usize = 1024;\n pub const MAX_RECEIPTS_HEADERS_TO_SEND: usize = 256;\n pub const MAX_TRANSACTIONS_TO_REQUEST: usize = 256;\n const MIN_PEERS_PROPAGATION: usize = 4;\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -40,6 +40,7 @@ use super::{\n     ChainSync, PacketProcessError, RlpResponseResult, SyncHandler, MAX_BODIES_TO_SEND,\n     MAX_HEADERS_TO_SEND, MAX_RECEIPTS_HEADERS_TO_SEND,\n };\n+use chain::MAX_NODE_DATA_TO_SEND;\n use std::borrow::Borrow;\n \n /// The Chain Sync Supplier: answers requests from peers with available data\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -88,6 +89,15 @@ impl SyncSupplier {\n                         |e| format!(\"Error sending block headers: {:?}\", e),\n                     ),\n \n+                    GetNodeDataPacket => SyncSupplier::return_rlp(\n+                        io,\n+                        &rlp,\n+                        peer,\n+                        request_id,\n+                        SyncSupplier::return_node_data,\n+                        |e| format!(\"Error sending node data: {:?}\", e),\n+                    ),\n+\n                     GetReceiptsPacket => SyncSupplier::return_rlp(\n                         io,\n                         &rlp,\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -340,6 +350,32 @@ impl SyncSupplier {\n         Ok(Some((BlockBodiesPacket, rlp)))\n     }\n \n+    fn return_node_data(io: &dyn SyncIo, rlp: &Rlp, peer_id: PeerId) -> RlpResponseResult {\n+        let count = cmp::min(rlp.item_count().unwrap_or(0), MAX_NODE_DATA_TO_SEND);\n+        if count == 0 {\n+            debug!(target: \"sync\", \"Empty GetNodeData request, ignoring.\");\n+            return Ok(None);\n+        }\n+\n+        let mut data = Bytes::new();\n+\n+        let mut added = 0usize;\n+        for i in 0..count {\n+            if let Some(ref mut node_data) = io.chain().state_data(&rlp.val_at::<H256>(i)?) {\n+                data.append(node_data);\n+                added += 1;\n+                if data.len() > PAYLOAD_SOFT_LIMIT {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        let mut rlp = RlpStream::new_list(added);\n+        rlp.append_raw(&data, added);\n+        trace!(target: \"sync\", \"{} -> GetNodeData: returned {} entries\", peer_id, added);\n+        Ok(Some((NodeDataPacket, rlp)))\n+    }\n+\n     fn return_receipts(io: &dyn SyncIo, rlp: &Rlp, peer_id: PeerId) -> RlpResponseResult {\n         let mut count = rlp.item_count().unwrap_or(0);\n         trace!(target: \"sync\", \"{} -> GetReceipts: {} entries\", peer_id, count);\ndiff --git a/crates/ethcore/sync/src/chain/sync_packet.rs b/crates/ethcore/sync/src/chain/sync_packet.rs\n--- a/crates/ethcore/sync/src/chain/sync_packet.rs\n+++ b/crates/ethcore/sync/src/chain/sync_packet.rs\n@@ -48,8 +48,8 @@ pub enum SyncPacket {\n     GetPooledTransactionsPacket = 0x09,\n     PooledTransactionsPacket = 0x0a,\n \n-    //GetNodeDataPacket = 0x0d,\n-    //NodeDataPacket = 0x0e,\n+    GetNodeDataPacket = 0x0d,\n+    NodeDataPacket = 0x0e,\n     GetReceiptsPacket = 0x0f,\n     ReceiptsPacket = 0x10,\n \ndiff --git a/crates/ethcore/sync/src/chain/sync_packet.rs b/crates/ethcore/sync/src/chain/sync_packet.rs\n--- a/crates/ethcore/sync/src/chain/sync_packet.rs\n+++ b/crates/ethcore/sync/src/chain/sync_packet.rs\n@@ -87,8 +87,8 @@ impl PacketInfo for SyncPacket {\n             | NewPooledTransactionHashesPacket\n             | GetPooledTransactionsPacket\n             | PooledTransactionsPacket\n-            //| GetNodeDataPacket\n-            //| NodeDataPacket\n+            | GetNodeDataPacket\n+            | NodeDataPacket\n             | GetReceiptsPacket\n             | ReceiptsPacket => ETH_PROTOCOL,\n \ndiff --git a/crates/ethcore/sync/src/chain/sync_packet.rs b/crates/ethcore/sync/src/chain/sync_packet.rs\n--- a/crates/ethcore/sync/src/chain/sync_packet.rs\n+++ b/crates/ethcore/sync/src/chain/sync_packet.rs\n@@ -105,7 +105,6 @@ impl PacketInfo for SyncPacket {\n     }\n \n     fn has_request_id_in_eth_66(&self) -> bool {\n-        // Note: NodeDataPacket and GetNodeDataPacket also get a request id in eth-66.\n         match self {\n             GetBlockHeadersPacket\n             | BlockHeadersPacket\ndiff --git a/crates/ethcore/sync/src/chain/sync_packet.rs b/crates/ethcore/sync/src/chain/sync_packet.rs\n--- a/crates/ethcore/sync/src/chain/sync_packet.rs\n+++ b/crates/ethcore/sync/src/chain/sync_packet.rs\n@@ -113,6 +112,8 @@ impl PacketInfo for SyncPacket {\n             | BlockBodiesPacket\n             | GetPooledTransactionsPacket\n             | PooledTransactionsPacket\n+            | GetNodeDataPacket\n+            | NodeDataPacket\n             | GetReceiptsPacket\n             | ReceiptsPacket => true,\n             _ => false,\n",
        "test_patch": "diff --git a/crates/db/journaldb/src/archivedb.rs b/crates/db/journaldb/src/archivedb.rs\n--- a/crates/db/journaldb/src/archivedb.rs\n+++ b/crates/db/journaldb/src/archivedb.rs\n@@ -214,12 +216,19 @@ impl JournalDB for ArchiveDB {\n     fn consolidate(&mut self, with: MemoryDB<KeccakHasher, DBValue>) {\n         self.overlay.consolidate(with);\n     }\n+\n+    fn state(&self, id: &H256) -> Option<Bytes> {\n+        self.backing\n+            .get_by_prefix(self.column, &id[0..DB_PREFIX_LEN])\n+            .map(|b| b.into_vec())\n+    }\n }\n \n #[cfg(test)]\n mod tests {\n \n     use super::*;\n+    use ethcore_db::InMemoryWithMetrics;\n     use hash_db::HashDB;\n     use keccak::keccak;\n     use JournalDB;\ndiff --git a/crates/db/journaldb/src/archivedb.rs b/crates/db/journaldb/src/archivedb.rs\n--- a/crates/db/journaldb/src/archivedb.rs\n+++ b/crates/db/journaldb/src/archivedb.rs\n@@ -497,4 +506,22 @@ mod tests {\n \n         assert!(jdb.get(&key).is_none());\n     }\n+\n+    #[test]\n+    fn returns_state() {\n+        let shared_db = Arc::new(InMemoryWithMetrics::create(0));\n+\n+        let key = {\n+            let mut jdb = ArchiveDB::new(shared_db.clone(), None);\n+            let key = jdb.insert(b\"foo\");\n+            jdb.commit_batch(0, &keccak(b\"0\"), None).unwrap();\n+            key\n+        };\n+\n+        {\n+            let jdb = ArchiveDB::new(shared_db, None);\n+            let state = jdb.state(&key);\n+            assert!(state.is_some());\n+        }\n+    }\n }\ndiff --git a/crates/db/journaldb/src/earlymergedb.rs b/crates/db/journaldb/src/earlymergedb.rs\n--- a/crates/db/journaldb/src/earlymergedb.rs\n+++ b/crates/db/journaldb/src/earlymergedb.rs\n@@ -608,6 +609,12 @@ impl JournalDB for EarlyMergeDB {\n     fn consolidate(&mut self, with: MemoryDB<KeccakHasher, DBValue>) {\n         self.overlay.consolidate(with);\n     }\n+\n+    fn state(&self, id: &H256) -> Option<Bytes> {\n+        self.backing\n+            .get_by_prefix(self.column, &id[0..DB_PREFIX_LEN])\n+            .map(|b| b.into_vec())\n+    }\n }\n \n #[cfg(test)]\ndiff --git a/crates/db/journaldb/src/refcounteddb.rs b/crates/db/journaldb/src/refcounteddb.rs\n--- a/crates/db/journaldb/src/refcounteddb.rs\n+++ b/crates/db/journaldb/src/refcounteddb.rs\n@@ -245,6 +247,12 @@ impl JournalDB for RefCountedDB {\n             }\n         }\n     }\n+\n+    fn state(&self, id: &H256) -> Option<Bytes> {\n+        self.backing\n+            .get_by_prefix(self.column, &id[0..DB_PREFIX_LEN])\n+            .map(|b| b.into_vec())\n+    }\n }\n \n #[cfg(test)]\ndiff --git a/crates/db/journaldb/src/traits.rs b/crates/db/journaldb/src/traits.rs\n--- a/crates/db/journaldb/src/traits.rs\n+++ b/crates/db/journaldb/src/traits.rs\n@@ -95,6 +96,9 @@ pub trait JournalDB: KeyedHashDB {\n     /// Consolidate all the insertions and deletions in the given memory overlay.\n     fn consolidate(&mut self, overlay: ::memory_db::MemoryDB<KeccakHasher, DBValue>);\n \n+    /// State data query\n+    fn state(&self, id: &H256) -> Option<Bytes>;\n+\n     /// Commit all changes in a single batch\n     #[cfg(test)]\n     fn commit_batch(&mut self, now: u64, id: &H256, end: Option<(u64, H256)>) -> io::Result<u32> {\ndiff --git a/crates/ethcore/src/client/test_client.rs b/crates/ethcore/src/client/test_client.rs\n--- a/crates/ethcore/src/client/test_client.rs\n+++ b/crates/ethcore/src/client/test_client.rs\n@@ -1078,6 +1078,18 @@ impl BlockChainClient for TestBlockChainClient {\n     fn registrar_address(&self) -> Option<Address> {\n         None\n     }\n+\n+    fn state_data(&self, hash: &H256) -> Option<Bytes> {\n+        let begins_with_f =\n+            H256::from_str(\"f000000000000000000000000000000000000000000000000000000000000000\")\n+                .unwrap();\n+        if *hash > begins_with_f {\n+            let mut rlp = RlpStream::new();\n+            rlp.append(&hash.clone());\n+            return Some(rlp.out());\n+        }\n+        None\n+    }\n }\n \n impl IoClient for TestBlockChainClient {\ndiff --git a/crates/ethcore/src/client/traits.rs b/crates/ethcore/src/client/traits.rs\n--- a/crates/ethcore/src/client/traits.rs\n+++ b/crates/ethcore/src/client/traits.rs\n@@ -333,6 +333,9 @@ pub trait BlockChainClient:\n     /// Get all possible uncle hashes for a block.\n     fn find_uncles(&self, hash: &H256) -> Option<Vec<H256>>;\n \n+    /// Get latest state node\n+    fn state_data(&self, hash: &H256) -> Option<Bytes>;\n+\n     /// Get block receipts data by block header hash.\n     fn block_receipts(&self, hash: &H256) -> Option<BlockReceipts>;\n \ndiff --git a/crates/ethcore/src/tests/client.rs b/crates/ethcore/src/tests/client.rs\n--- a/crates/ethcore/src/tests/client.rs\n+++ b/crates/ethcore/src/tests/client.rs\n@@ -591,3 +591,12 @@ fn import_export_binary() {\n     assert!(client.block_header(BlockId::Number(17)).is_some());\n     assert!(client.block_header(BlockId::Number(16)).is_some());\n }\n+\n+#[test]\n+fn returns_state_root_basic() {\n+    let client = generate_dummy_client(6);\n+    let test_spec = Spec::new_test();\n+    let genesis_header = test_spec.genesis_header();\n+\n+    assert!(client.state_data(genesis_header.state_root()).is_some());\n+}\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -723,4 +759,51 @@ mod test {\n         );\n         assert_eq!(1, io.packets.len());\n     }\n+\n+    #[test]\n+    fn return_nodes() {\n+        let mut client = TestBlockChainClient::new();\n+        let queue = RwLock::new(VecDeque::new());\n+        let sync = dummy_sync_with_peer(H256::zero(), &client);\n+        let ss = TestSnapshotService::new();\n+        let mut io = TestIo::new(&mut client, &ss, &queue, None);\n+\n+        let mut node_list = RlpStream::new_list(3);\n+        node_list.append(\n+            &H256::from_str(\"0000000000000000000000000000000000000000000000005555555555555555\")\n+                .unwrap(),\n+        );\n+        node_list.append(\n+            &H256::from_str(\"ffffffffffffffffffffffffffffffffffffffffffffaaaaaaaaaaaaaaaaaaaa\")\n+                .unwrap(),\n+        );\n+        node_list.append(\n+            &H256::from_str(\"aff0000000000000000000000000000000000000000000000000000000000000\")\n+                .unwrap(),\n+        );\n+\n+        let node_request = node_list.out();\n+        // it returns rlp ONLY for hashes started with \"f\"\n+        let result = SyncSupplier::return_node_data(&io, &Rlp::new(&node_request.clone()), 0);\n+\n+        assert!(result.is_ok());\n+        let rlp_result = result.unwrap();\n+        assert!(rlp_result.is_some());\n+\n+        // the length of one rlp-encoded hashe\n+        let rlp = rlp_result.unwrap().1.out();\n+        let rlp = Rlp::new(&rlp);\n+        assert_eq!(Ok(1), rlp.item_count());\n+\n+        io.sender = Some(2usize);\n+\n+        SyncSupplier::dispatch_packet(\n+            &RwLock::new(sync),\n+            &mut io,\n+            0usize,\n+            GetNodeDataPacket.id(),\n+            &node_request,\n+        );\n+        assert_eq!(1, io.packets.len());\n+    }\n }\n",
        "problem_statement": "GetNodeData from eth63 is missing\nGetNodeData function was removed in 3.1.0 version.\r\n\r\nIt should be reverted.\n",
        "hints_text": "Thanks for creating the issue.\r\n\r\nOn xDai chain we use Nethermind and OpenEthereum clients at the same time.\r\n\r\nNethermind team just noticed that `GetNodeData` was [removed from OpenEthereum](https://github.com/openethereum/openethereum/pull/14), so state sync on xDai chain works only off Nethermind nodes.\r\n\r\nWe are asking to bring `GetNodeData` back to OpenEthereum so Nethermind nodes could sync with OpenEthereum nodes on xDai. Thank you\r\n\nSince it's another eth protocol task, I'll do this while I'm at it. Do you know if there was a problem with the GetNodeData implementation, or was it just removed due to not being used?",
        "created_at": "2021-07-03T16:36:58Z",
        "version": "0.6"
    },
    {
        "repo": "openethereum/openethereum",
        "pull_number": 581,
        "instance_id": "openethereum__openethereum-581",
        "issue_numbers": [
            "328"
        ],
        "base_commit": "f13fa10b8a0803116642f349c5557923afb2b5ba",
        "patch": "diff --git a/crates/ethcore/src/engines/authority_round/mod.rs b/crates/ethcore/src/engines/authority_round/mod.rs\n--- a/crates/ethcore/src/engines/authority_round/mod.rs\n+++ b/crates/ethcore/src/engines/authority_round/mod.rs\n@@ -1557,6 +1557,43 @@ impl Engine<EthereumMachine> for AuthorityRound {\n         }\n     }\n \n+    // Mostly is the same as `fn sealing_state(&self)` except that it does not\n+    // check whether the node is a step proposer.\n+    fn is_allowed_to_seal(&self) -> bool {\n+        let our_addr = match *self.signer.read() {\n+            Some(ref signer) => signer.address(),\n+            None => return false,\n+        };\n+\n+        let client = match self.upgrade_client_or(\"Not preparing block\") {\n+            Ok(client) => client,\n+            Err(_) => return false,\n+        };\n+\n+        let parent = match client.as_full_client() {\n+            Some(full_client) => full_client.best_block_header(),\n+            None => {\n+                return false;\n+            }\n+        };\n+\n+        let validators = if self.immediate_transitions {\n+            CowLike::Borrowed(&*self.validators)\n+        } else {\n+            let mut epoch_manager = self.epoch_manager.lock();\n+            if !epoch_manager.zoom_to_after(\n+                &*client,\n+                &self.machine,\n+                &*self.validators,\n+                parent.hash(),\n+            ) {\n+                return false;\n+            }\n+            CowLike::Owned(epoch_manager.validators().clone())\n+        };\n+        validators.contains(&parent.hash(), &our_addr)\n+    }\n+\n     fn sealing_state(&self) -> SealingState {\n         let our_addr = match *self.signer.read() {\n             Some(ref signer) => signer.address(),\ndiff --git a/crates/ethcore/src/engines/mod.rs b/crates/ethcore/src/engines/mod.rs\n--- a/crates/ethcore/src/engines/mod.rs\n+++ b/crates/ethcore/src/engines/mod.rs\n@@ -470,6 +470,14 @@ pub trait Engine<M: Machine>: Sync + Send {\n     /// Register a component which signs consensus messages.\n     fn set_signer(&self, _signer: Option<Box<dyn EngineSigner>>) {}\n \n+    /// Returns whether the current node is a validator and\n+    /// actually may seal a block if AuRa engine is used.\n+    ///\n+    /// Used by `eth_mining` rpc call.\n+    fn is_allowed_to_seal(&self) -> bool {\n+        true\n+    }\n+\n     /// Sign using the EngineSigner, to be used for consensus tx signing.\n     fn sign(&self, _hash: H256) -> Result<Signature, M::Error> {\n         unimplemented!()\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -1377,7 +1377,7 @@ impl miner::MinerService for Miner {\n     }\n \n     fn is_currently_sealing(&self) -> bool {\n-        self.sealing.lock().enabled\n+        self.sealing.lock().enabled && self.engine.is_allowed_to_seal()\n     }\n \n     fn work_package<C>(&self, chain: &C) -> Option<(H256, BlockNumber, u64, U256)>\n",
        "test_patch": "diff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -1608,7 +1608,9 @@ mod tests {\n \n     use client::{ChainInfo, EachBlockWith, ImportSealedBlock, TestBlockChainClient};\n     use miner::{MinerService, PendingOrdering};\n-    use test_helpers::{generate_dummy_client, generate_dummy_client_with_spec};\n+    use test_helpers::{\n+        dummy_engine_signer_with_address, generate_dummy_client, generate_dummy_client_with_spec,\n+    };\n     use types::transaction::{Transaction, TypedTransaction};\n \n     #[test]\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -2078,6 +2080,31 @@ mod tests {\n         assert!(miner.is_currently_sealing());\n     }\n \n+    #[test]\n+    fn should_not_mine_if_is_not_allowed_to_seal() {\n+        let spec = Spec::new_test_round();\n+        let miner = Miner::new_for_tests_force_sealing(&spec, None, true);\n+        assert!(!miner.is_currently_sealing());\n+    }\n+\n+    #[test]\n+    fn should_mine_if_is_allowed_to_seal() {\n+        let verifier: Address = [\n+            0x7d, 0x57, 0x7a, 0x59, 0x7b, 0x27, 0x42, 0xb4, 0x98, 0xcb, 0x5c, 0xf0, 0xc2, 0x6c,\n+            0xdc, 0xd7, 0x26, 0xd3, 0x9e, 0x6e,\n+        ]\n+        .into();\n+\n+        let spec = Spec::new_test_round();\n+        let client: Arc<dyn EngineClient> = generate_dummy_client(2);\n+\n+        let miner = Miner::new_for_tests_force_sealing(&spec, None, true);\n+        miner.engine.register_client(Arc::downgrade(&client));\n+        miner.set_author(Author::Sealer(dummy_engine_signer_with_address(verifier)));\n+\n+        assert!(miner.is_currently_sealing());\n+    }\n+\n     #[test]\n     fn should_set_new_minimum_gas_price() {\n         // Creates a new GasPricer::Fixed behind the scenes\ndiff --git a/crates/ethcore/src/test_helpers.rs b/crates/ethcore/src/test_helpers.rs\n--- a/crates/ethcore/src/test_helpers.rs\n+++ b/crates/ethcore/src/test_helpers.rs\n@@ -46,6 +46,8 @@ use block::{Drain, OpenBlock};\n use client::{\n     ChainInfo, ChainMessageType, ChainNotify, Client, ClientConfig, ImportBlock, PrepareOpenBlock,\n };\n+use engines::EngineSigner;\n+use ethjson::crypto::publickey::{Public, Signature};\n use factory::Factories;\n use miner::Miner;\n use spec::Spec;\ndiff --git a/crates/ethcore/src/test_helpers.rs b/crates/ethcore/src/test_helpers.rs\n--- a/crates/ethcore/src/test_helpers.rs\n+++ b/crates/ethcore/src/test_helpers.rs\n@@ -644,3 +646,38 @@ impl ChainNotify for TestNotify {\n         self.messages.write().push(data);\n     }\n }\n+\n+/// Returns engine signer with specified address\n+pub fn dummy_engine_signer_with_address(addr: Address) -> Box<dyn EngineSigner> {\n+    struct TestEngineSigner(Address);\n+\n+    impl TestEngineSigner {\n+        fn with_address(addr: Address) -> Self {\n+            Self(addr)\n+        }\n+    }\n+\n+    impl EngineSigner for TestEngineSigner {\n+        fn sign(&self, _hash: H256) -> Result<Signature, ethjson::crypto::publickey::Error> {\n+            unimplemented!()\n+        }\n+\n+        fn address(&self) -> Address {\n+            self.0\n+        }\n+\n+        fn decrypt(\n+            &self,\n+            _auth_data: &[u8],\n+            _cipher: &[u8],\n+        ) -> Result<Vec<u8>, parity_crypto::publickey::Error> {\n+            unimplemented!()\n+        }\n+\n+        fn public(&self) -> Option<Public> {\n+            unimplemented!()\n+        }\n+    }\n+\n+    Box::new(TestEngineSigner::with_address(addr))\n+}\n",
        "problem_statement": "`eth_mining` returns `true` for a non-validator node\n- **OpenEthereum version (>=3.1.0)**: 3.1.0\r\n- **Operating system**: MacOS / Linux\r\n- **Fully synchronized**: yes\r\n- **Network**: xDai (AuRa consensus)\r\n\r\nWe recently discovered that `eth_mining` returns a false-positive result (`true`) when a node has `force_sealing = true` option and doesn't have `engine_signer` option (and actually not a miner).\r\n\r\nI think it should return `false` for a non-validator node even if `force_sealing = true`\n",
        "hints_text": "",
        "created_at": "2021-12-08T11:20:38Z",
        "version": "3.3"
    },
    {
        "repo": "openethereum/openethereum",
        "pull_number": 467,
        "instance_id": "openethereum__openethereum-467",
        "issue_numbers": [
            "465"
        ],
        "base_commit": "fdaee51ca07710081d27722449478b20dfbf72c9",
        "patch": "diff --git a/crates/ethcore/sync/src/api.rs b/crates/ethcore/sync/src/api.rs\n--- a/crates/ethcore/sync/src/api.rs\n+++ b/crates/ethcore/sync/src/api.rs\n@@ -33,7 +33,7 @@ use std::{\n use chain::{\n     fork_filter::ForkFilterApi, ChainSyncApi, SyncState, SyncStatus as EthSyncStatus,\n     ETH_PROTOCOL_VERSION_63, ETH_PROTOCOL_VERSION_64, ETH_PROTOCOL_VERSION_65,\n-    PAR_PROTOCOL_VERSION_1, PAR_PROTOCOL_VERSION_2,\n+    ETH_PROTOCOL_VERSION_66, PAR_PROTOCOL_VERSION_1, PAR_PROTOCOL_VERSION_2,\n };\n use ethcore::{\n     client::{BlockChainClient, ChainMessageType, ChainNotify, NewBlocks},\ndiff --git a/crates/ethcore/sync/src/api.rs b/crates/ethcore/sync/src/api.rs\n--- a/crates/ethcore/sync/src/api.rs\n+++ b/crates/ethcore/sync/src/api.rs\n@@ -571,6 +571,7 @@ impl ChainNotify for EthSync {\n                     ETH_PROTOCOL_VERSION_63,\n                     ETH_PROTOCOL_VERSION_64,\n                     ETH_PROTOCOL_VERSION_65,\n+                    ETH_PROTOCOL_VERSION_66,\n                 ],\n             )\n             .unwrap_or_else(|e| warn!(\"Error registering ethereum protocol: {:?}\", e));\ndiff --git a/crates/ethcore/sync/src/chain/handler.rs b/crates/ethcore/sync/src/chain/handler.rs\n--- a/crates/ethcore/sync/src/chain/handler.rs\n+++ b/crates/ethcore/sync/src/chain/handler.rs\n@@ -32,14 +32,17 @@ use std::{cmp, mem, time::Instant};\n use sync_io::SyncIo;\n use types::{block_status::BlockStatus, ids::BlockId, BlockNumber};\n \n-use super::sync_packet::{\n-    PacketInfo,\n-    SyncPacket::{self, *},\n+use super::{\n+    request_id::strip_request_id,\n+    sync_packet::{\n+        PacketInfo,\n+        SyncPacket::{self, *},\n+    },\n };\n \n use super::{\n     BlockSet, ChainSync, ForkConfirmation, PacketProcessError, PeerAsking, PeerInfo, SyncRequester,\n-    SyncState, ETH_PROTOCOL_VERSION_63, ETH_PROTOCOL_VERSION_64, ETH_PROTOCOL_VERSION_65,\n+    SyncState, ETH_PROTOCOL_VERSION_63, ETH_PROTOCOL_VERSION_64, ETH_PROTOCOL_VERSION_66,\n     MAX_NEW_BLOCK_AGE, MAX_NEW_HASHES, PAR_PROTOCOL_VERSION_1, PAR_PROTOCOL_VERSION_2,\n };\n \ndiff --git a/crates/ethcore/sync/src/chain/handler.rs b/crates/ethcore/sync/src/chain/handler.rs\n--- a/crates/ethcore/sync/src/chain/handler.rs\n+++ b/crates/ethcore/sync/src/chain/handler.rs\n@@ -55,27 +58,33 @@ impl SyncHandler {\n         packet_id: u8,\n         data: &[u8],\n     ) {\n-        let rlp = Rlp::new(data);\n         if let Some(packet_id) = SyncPacket::from_u8(packet_id) {\n-            let result = match packet_id {\n-                StatusPacket => SyncHandler::on_peer_status(sync, io, peer, &rlp),\n-                BlockHeadersPacket => SyncHandler::on_peer_block_headers(sync, io, peer, &rlp),\n-                BlockBodiesPacket => SyncHandler::on_peer_block_bodies(sync, io, peer, &rlp),\n-                ReceiptsPacket => SyncHandler::on_peer_block_receipts(sync, io, peer, &rlp),\n-                NewBlockPacket => SyncHandler::on_peer_new_block(sync, io, peer, &rlp),\n-                NewBlockHashesPacket => SyncHandler::on_peer_new_hashes(sync, io, peer, &rlp),\n-                NewPooledTransactionHashesPacket => {\n-                    SyncHandler::on_peer_new_pooled_transaction_hashes(sync, io, peer, &rlp)\n-                }\n-                PooledTransactionsPacket => {\n-                    SyncHandler::on_peer_pooled_transactions(sync, io, peer, &rlp)\n-                }\n-                SnapshotManifestPacket => SyncHandler::on_snapshot_manifest(sync, io, peer, &rlp),\n-                SnapshotDataPacket => SyncHandler::on_snapshot_data(sync, io, peer, &rlp),\n-                _ => {\n-                    debug!(target: \"sync\", \"{}: Unknown packet {}\", peer, packet_id.id());\n-                    Ok(())\n-                }\n+            let rlp_result = strip_request_id(data, sync, &peer, &packet_id);\n+\n+            let result = match rlp_result {\n+                Ok((rlp, _)) => match packet_id {\n+                    StatusPacket => SyncHandler::on_peer_status(sync, io, peer, &rlp),\n+                    BlockHeadersPacket => SyncHandler::on_peer_block_headers(sync, io, peer, &rlp),\n+                    BlockBodiesPacket => SyncHandler::on_peer_block_bodies(sync, io, peer, &rlp),\n+                    ReceiptsPacket => SyncHandler::on_peer_block_receipts(sync, io, peer, &rlp),\n+                    NewBlockPacket => SyncHandler::on_peer_new_block(sync, io, peer, &rlp),\n+                    NewBlockHashesPacket => SyncHandler::on_peer_new_hashes(sync, io, peer, &rlp),\n+                    NewPooledTransactionHashesPacket => {\n+                        SyncHandler::on_peer_new_pooled_transaction_hashes(sync, io, peer, &rlp)\n+                    }\n+                    PooledTransactionsPacket => {\n+                        SyncHandler::on_peer_pooled_transactions(sync, io, peer, &rlp)\n+                    }\n+                    SnapshotManifestPacket => {\n+                        SyncHandler::on_snapshot_manifest(sync, io, peer, &rlp)\n+                    }\n+                    SnapshotDataPacket => SyncHandler::on_snapshot_data(sync, io, peer, &rlp),\n+                    _ => {\n+                        debug!(target: \"sync\", \"{}: Unknown packet {}\", peer, packet_id.id());\n+                        Ok(())\n+                    }\n+                },\n+                Err(e) => Err(e.into()),\n             };\n \n             match result {\ndiff --git a/crates/ethcore/sync/src/chain/handler.rs b/crates/ethcore/sync/src/chain/handler.rs\n--- a/crates/ethcore/sync/src/chain/handler.rs\n+++ b/crates/ethcore/sync/src/chain/handler.rs\n@@ -797,7 +806,7 @@ impl SyncHandler {\n                     || peer.protocol_version > PAR_PROTOCOL_VERSION_2.0))\n             || (!warp_protocol\n                 && (peer.protocol_version < ETH_PROTOCOL_VERSION_63.0\n-                    || peer.protocol_version > ETH_PROTOCOL_VERSION_65.0))\n+                    || peer.protocol_version > ETH_PROTOCOL_VERSION_66.0))\n         {\n             trace!(target: \"sync\", \"Peer {} unsupported eth protocol ({})\", peer_id, peer.protocol_version);\n             return Err(DownloaderImportError::Invalid);\ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -90,6 +90,7 @@\n pub mod fork_filter;\n mod handler;\n mod propagator;\n+pub mod request_id;\n mod requester;\n mod supplier;\n pub mod sync_packet;\ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -153,6 +154,8 @@ impl From<DecoderError> for PacketProcessError {\n     }\n }\n \n+/// Version 66 of the Ethereum protocol and number of packet IDs reserved by the protocol (packet count).\n+pub const ETH_PROTOCOL_VERSION_66: (u8, u8) = (66, 0x11);\n /// Version 65 of the Ethereum protocol and number of packet IDs reserved by the protocol (packet count).\n pub const ETH_PROTOCOL_VERSION_65: (u8, u8) = (65, 0x11);\n /// 64 version of Ethereum protocol.\ndiff --git a/crates/ethcore/sync/src/chain/requester.rs b/crates/ethcore/sync/src/chain/requester.rs\n--- a/crates/ethcore/sync/src/chain/requester.rs\n+++ b/crates/ethcore/sync/src/chain/requester.rs\n@@ -23,7 +23,10 @@ use std::time::Instant;\n use sync_io::SyncIo;\n use types::BlockNumber;\n \n-use super::sync_packet::{SyncPacket::*, *};\n+use super::{\n+    request_id::generate_request_id,\n+    sync_packet::{SyncPacket::*, *},\n+};\n \n use super::{BlockSet, ChainSync, PeerAsking};\n \ndiff --git a/crates/ethcore/sync/src/chain/requester.rs b/crates/ethcore/sync/src/chain/requester.rs\n--- a/crates/ethcore/sync/src/chain/requester.rs\n+++ b/crates/ethcore/sync/src/chain/requester.rs\n@@ -243,6 +246,8 @@ impl SyncRequester {\n             peer.asking = asking;\n             peer.ask_time = Instant::now();\n \n+            let (packet, _) = generate_request_id(packet, peer, packet_id);\n+\n             let result = io.send(peer_id, packet_id, packet);\n \n             if let Err(e) = result {\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -31,12 +31,16 @@ use types::{ids::BlockId, BlockNumber};\n \n use sync_io::SyncIo;\n \n-use super::sync_packet::{PacketInfo, SyncPacket, SyncPacket::*};\n+use super::{\n+    request_id::{prepend_request_id, strip_request_id, RequestId},\n+    sync_packet::{PacketInfo, SyncPacket, SyncPacket::*},\n+};\n \n use super::{\n     ChainSync, PacketProcessError, RlpResponseResult, SyncHandler, MAX_BODIES_TO_SEND,\n     MAX_HEADERS_TO_SEND, MAX_RECEIPTS_HEADERS_TO_SEND,\n };\n+use std::borrow::Borrow;\n \n /// The Chain Sync Supplier: answers requests from peers with available data\n pub struct SyncSupplier;\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -52,87 +56,98 @@ impl SyncSupplier {\n         packet_id: u8,\n         data: &[u8],\n     ) {\n-        let rlp = Rlp::new(data);\n-\n         if let Some(id) = SyncPacket::from_u8(packet_id) {\n-            let result = match id {\n-                GetPooledTransactionsPacket => SyncSupplier::return_rlp(\n-                    io,\n-                    &rlp,\n-                    peer,\n-                    SyncSupplier::return_pooled_transactions,\n-                    |e| format!(\"Error sending pooled transactions: {:?}\", e),\n-                ),\n-\n-                GetBlockBodiesPacket => SyncSupplier::return_rlp(\n-                    io,\n-                    &rlp,\n-                    peer,\n-                    SyncSupplier::return_block_bodies,\n-                    |e| format!(\"Error sending block bodies: {:?}\", e),\n-                ),\n-\n-                GetBlockHeadersPacket => SyncSupplier::return_rlp(\n-                    io,\n-                    &rlp,\n-                    peer,\n-                    SyncSupplier::return_block_headers,\n-                    |e| format!(\"Error sending block headers: {:?}\", e),\n-                ),\n-\n-                GetReceiptsPacket => {\n-                    SyncSupplier::return_rlp(io, &rlp, peer, SyncSupplier::return_receipts, |e| {\n-                        format!(\"Error sending receipts: {:?}\", e)\n-                    })\n-                }\n-                GetSnapshotManifestPacket => SyncSupplier::return_rlp(\n-                    io,\n-                    &rlp,\n-                    peer,\n-                    SyncSupplier::return_snapshot_manifest,\n-                    |e| format!(\"Error sending snapshot manifest: {:?}\", e),\n-                ),\n-\n-                GetSnapshotDataPacket => SyncSupplier::return_rlp(\n-                    io,\n-                    &rlp,\n-                    peer,\n-                    SyncSupplier::return_snapshot_data,\n-                    |e| format!(\"Error sending snapshot data: {:?}\", e),\n-                ),\n-\n-                StatusPacket => {\n-                    sync.write().on_packet(io, peer, packet_id, data);\n-                    Ok(())\n-                }\n-                // Packets that require the peer to be confirmed\n-                _ => {\n-                    if !sync.read().peers.contains_key(&peer) {\n-                        debug!(target:\"sync\", \"Unexpected packet {} from unregistered peer: {}:{}\", packet_id, peer, io.peer_version(peer));\n-                        return;\n+            let rlp_result = strip_request_id(data, sync.read().borrow(), &peer, &id);\n+\n+            let result = match rlp_result {\n+                Ok((rlp, request_id)) => match id {\n+                    GetPooledTransactionsPacket => SyncSupplier::return_rlp(\n+                        io,\n+                        &rlp,\n+                        peer,\n+                        request_id,\n+                        SyncSupplier::return_pooled_transactions,\n+                        |e| format!(\"Error sending pooled transactions: {:?}\", e),\n+                    ),\n+\n+                    GetBlockBodiesPacket => SyncSupplier::return_rlp(\n+                        io,\n+                        &rlp,\n+                        peer,\n+                        request_id,\n+                        SyncSupplier::return_block_bodies,\n+                        |e| format!(\"Error sending block bodies: {:?}\", e),\n+                    ),\n+\n+                    GetBlockHeadersPacket => SyncSupplier::return_rlp(\n+                        io,\n+                        &rlp,\n+                        peer,\n+                        request_id,\n+                        SyncSupplier::return_block_headers,\n+                        |e| format!(\"Error sending block headers: {:?}\", e),\n+                    ),\n+\n+                    GetReceiptsPacket => SyncSupplier::return_rlp(\n+                        io,\n+                        &rlp,\n+                        peer,\n+                        request_id,\n+                        SyncSupplier::return_receipts,\n+                        |e| format!(\"Error sending receipts: {:?}\", e),\n+                    ),\n+\n+                    GetSnapshotManifestPacket => SyncSupplier::return_rlp(\n+                        io,\n+                        &rlp,\n+                        peer,\n+                        request_id,\n+                        SyncSupplier::return_snapshot_manifest,\n+                        |e| format!(\"Error sending snapshot manifest: {:?}\", e),\n+                    ),\n+\n+                    GetSnapshotDataPacket => SyncSupplier::return_rlp(\n+                        io,\n+                        &rlp,\n+                        peer,\n+                        request_id,\n+                        SyncSupplier::return_snapshot_data,\n+                        |e| format!(\"Error sending snapshot data: {:?}\", e),\n+                    ),\n+\n+                    StatusPacket => {\n+                        sync.write().on_packet(io, peer, packet_id, data);\n+                        Ok(())\n                     }\n-                    debug!(target: \"sync\", \"{} -> Dispatching packet: {}\", peer, packet_id);\n-\n-                    match id {\n-                        ConsensusDataPacket => SyncHandler::on_consensus_packet(io, peer, &rlp),\n-                        TransactionsPacket => {\n-                            let res = {\n-                                let sync_ro = sync.read();\n-                                SyncHandler::on_peer_transactions(&*sync_ro, io, peer, &rlp)\n-                            };\n-                            if res.is_err() {\n-                                // peer sent invalid data, disconnect.\n-                                io.disable_peer(peer);\n-                                sync.write().deactivate_peer(io, peer);\n-                            }\n+                    // Packets that require the peer to be confirmed\n+                    _ => {\n+                        if !sync.read().peers.contains_key(&peer) {\n+                            debug!(target: \"sync\", \"Unexpected packet {} from unregistered peer: {}:{}\", packet_id, peer, io.peer_version(peer));\n+                            return;\n                         }\n-                        _ => {\n-                            sync.write().on_packet(io, peer, packet_id, data);\n+                        debug!(target: \"sync\", \"{} -> Dispatching packet: {}\", peer, packet_id);\n+\n+                        match id {\n+                            ConsensusDataPacket => SyncHandler::on_consensus_packet(io, peer, &rlp),\n+                            TransactionsPacket => {\n+                                let res = {\n+                                    let sync_ro = sync.read();\n+                                    SyncHandler::on_peer_transactions(&*sync_ro, io, peer, &rlp)\n+                                };\n+                                if res.is_err() {\n+                                    // peer sent invalid data, disconnect.\n+                                    io.disable_peer(peer);\n+                                    sync.write().deactivate_peer(io, peer);\n+                                }\n+                            }\n+                            _ => {\n+                                sync.write().on_packet(io, peer, packet_id, data);\n+                            }\n                         }\n+                        Ok(())\n                     }\n-\n-                    Ok(())\n-                }\n+                },\n+                Err(e) => Err(e.into()),\n             };\n \n             match result {\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -156,22 +171,26 @@ impl SyncSupplier {\n         packet_id: u8,\n         data: &[u8],\n     ) {\n-        let rlp = Rlp::new(data);\n-\n         if let Some(id) = SyncPacket::from_u8(packet_id) {\n-            let result = match id {\n-                GetBlockHeadersPacket => SyncSupplier::send_rlp(\n-                    io,\n-                    &rlp,\n-                    peer,\n-                    SyncSupplier::return_block_headers,\n-                    |e| format!(\"Error sending block headers: {:?}\", e),\n-                ),\n-\n-                _ => {\n-                    debug!(target:\"sync\", \"Unexpected packet {} was dispatched for delayed processing\", packet_id);\n-                    Ok(())\n-                }\n+            let rlp_result = strip_request_id(data, sync.read().borrow(), &peer, &id);\n+\n+            let result = match rlp_result {\n+                Ok((rlp, request_id)) => match id {\n+                    GetBlockHeadersPacket => SyncSupplier::send_rlp(\n+                        io,\n+                        &rlp,\n+                        peer,\n+                        request_id,\n+                        SyncSupplier::return_block_headers,\n+                        |e| format!(\"Error sending block headers: {:?}\", e),\n+                    ),\n+\n+                    _ => {\n+                        debug!(target: \"sync\", \"Unexpected packet {} was dispatched for delayed processing\", packet_id);\n+                        Ok(())\n+                    }\n+                },\n+                Err(e) => Err(e.into()),\n             };\n \n             match result {\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -394,6 +413,7 @@ impl SyncSupplier {\n         io: &mut dyn SyncIo,\n         rlp: &Rlp,\n         peer: PeerId,\n+        request_id: Option<RequestId>,\n         rlp_func: FRlp,\n         error_func: FError,\n     ) -> Result<(), PacketProcessError>\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -403,6 +423,7 @@ impl SyncSupplier {\n     {\n         let response = rlp_func(io, rlp, peer);\n         if let Some((packet_id, rlp_stream)) = response? {\n+            let rlp_stream = prepend_request_id(rlp_stream, request_id);\n             io.respond(packet_id.id(), rlp_stream.out())\n                 .unwrap_or_else(|e| debug!(target: \"sync\", \"{:?}\", error_func(e)));\n         }\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -413,6 +434,7 @@ impl SyncSupplier {\n         io: &mut dyn SyncIo,\n         rlp: &Rlp,\n         peer: PeerId,\n+        request_id: Option<RequestId>,\n         rlp_func: FRlp,\n         error_func: FError,\n     ) -> Result<(), PacketProcessError>\ndiff --git a/crates/ethcore/sync/src/chain/supplier.rs b/crates/ethcore/sync/src/chain/supplier.rs\n--- a/crates/ethcore/sync/src/chain/supplier.rs\n+++ b/crates/ethcore/sync/src/chain/supplier.rs\n@@ -424,6 +446,7 @@ impl SyncSupplier {\n         match response {\n             Err(e) => Err(e),\n             Ok(Some((packet_id, rlp_stream))) => {\n+                let rlp_stream = prepend_request_id(rlp_stream, request_id);\n                 io.send(peer, packet_id, rlp_stream.out())\n                     .unwrap_or_else(|e| debug!(target: \"sync\", \"{:?}\", error_func(e)));\n                 Ok(())\ndiff --git a/crates/ethcore/sync/src/chain/sync_packet.rs b/crates/ethcore/sync/src/chain/sync_packet.rs\n--- a/crates/ethcore/sync/src/chain/sync_packet.rs\n+++ b/crates/ethcore/sync/src/chain/sync_packet.rs\n@@ -68,6 +68,7 @@ use self::SyncPacket::*;\n pub trait PacketInfo {\n     fn id(&self) -> PacketId;\n     fn protocol(&self) -> ProtocolId;\n+    fn has_request_id_in_eth_66(&self) -> bool;\n }\n \n // The mechanism to match packet ids and protocol may be improved\n",
        "test_patch": "diff --git /dev/null b/crates/ethcore/sync/src/chain/request_id.rs\nnew file mode 100644\n--- /dev/null\n+++ b/crates/ethcore/sync/src/chain/request_id.rs\n@@ -0,0 +1,148 @@\n+use bytes::Bytes;\n+use chain::{\n+    sync_packet::{PacketInfo, SyncPacket},\n+    ChainSync, PeerInfo,\n+};\n+use network::PeerId;\n+use rlp::{DecoderError, Rlp, RlpStream};\n+\n+pub type RequestId = u64;\n+\n+// Separate the eth/66 request id from a packet, if it exists.\n+pub fn strip_request_id<'a>(\n+    data: &'a [u8],\n+    sync: &ChainSync,\n+    peer: &PeerId,\n+    packet_id: &SyncPacket,\n+) -> Result<(Rlp<'a>, Option<RequestId>), DecoderError> {\n+    let protocol_version = if let Some(peer_info) = sync.peers.get(peer) {\n+        peer_info.protocol_version\n+    } else {\n+        trace!(\n+            \"Peer info missing for peer {}, assuming protocol version 66\",\n+            peer\n+        );\n+        66\n+    };\n+\n+    let has_request_id = protocol_version >= 66 && packet_id.has_request_id_in_eth_66();\n+\n+    do_strip_request_id(data, has_request_id)\n+}\n+\n+fn do_strip_request_id<'a>(\n+    data: &'a [u8],\n+    has_request_id: bool,\n+) -> Result<(Rlp<'a>, Option<RequestId>), DecoderError> {\n+    let rlp = Rlp::new(data);\n+\n+    if has_request_id {\n+        let request_id: RequestId = rlp.val_at(0)?;\n+        let stripped_rlp = rlp.at(1)?;\n+        Ok((stripped_rlp, Some(request_id)))\n+    } else {\n+        Ok((rlp, None))\n+    }\n+}\n+\n+// Add a given eth/66 request id to a packet being built.\n+pub fn prepend_request_id(rlp: RlpStream, request_id: Option<RequestId>) -> RlpStream {\n+    match request_id {\n+        Some(ref id) => {\n+            let mut stream = RlpStream::new_list(2);\n+            stream.append(id);\n+            stream.append_raw(&rlp.out(), 1);\n+            stream\n+        }\n+        None => rlp,\n+    }\n+}\n+\n+/// Prepend a new eth/66 request id to the packet if appropriate.\n+pub fn generate_request_id(\n+    packet: Bytes,\n+    peer: &PeerInfo,\n+    packet_id: SyncPacket,\n+) -> (Bytes, Option<RequestId>) {\n+    if peer.protocol_version >= 66 && packet_id.has_request_id_in_eth_66() {\n+        do_generate_request_id(&packet)\n+    } else {\n+        (packet, None)\n+    }\n+}\n+\n+fn do_generate_request_id(packet: &Bytes) -> (Bytes, Option<RequestId>) {\n+    let request_id: RequestId = rand::random();\n+\n+    let mut rlp = RlpStream::new_list(2);\n+    rlp.append(&request_id);\n+    rlp.append_raw(packet, 1);\n+\n+    (rlp.out(), Some(request_id))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use ethereum_types::H256;\n+\n+    #[test]\n+    fn test_prepend_request_id() {\n+        let mut request = RlpStream::new_list(2);\n+        request.append(&H256::from_low_u64_be(1));\n+        request.append(&H256::from_low_u64_be(2));\n+\n+        let with_id = prepend_request_id(request, Some(10));\n+        let rlp = Rlp::new(with_id.as_raw());\n+        let recovered_id: RequestId = rlp.val_at(0).unwrap();\n+        let recovered_request: Vec<H256> = rlp.at(1).unwrap().as_list().unwrap();\n+\n+        assert_eq!(recovered_id, 10);\n+        assert_eq!(\n+            recovered_request,\n+            [H256::from_low_u64_be(1), H256::from_low_u64_be(2)]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_strip_request_id() {\n+        let request = vec![\n+            H256::from_low_u64_be(1),\n+            H256::from_low_u64_be(2),\n+            H256::from_low_u64_be(3),\n+        ];\n+\n+        let mut request_with_id = RlpStream::new_list(2);\n+        request_with_id.append(&20u64);\n+        request_with_id.append_list(&request);\n+        let data = request_with_id.out();\n+\n+        let (rlp, id) = do_strip_request_id(&data, true).unwrap();\n+\n+        assert_eq!(id, Some(20));\n+        assert_eq!(rlp.as_list::<H256>().unwrap(), request);\n+    }\n+\n+    #[test]\n+    fn test_generate_request_id() {\n+        let request = vec![\n+            H256::from_low_u64_be(1),\n+            H256::from_low_u64_be(2),\n+            H256::from_low_u64_be(3),\n+        ];\n+\n+        let mut stream = RlpStream::new_list(3);\n+        for hash in &request {\n+            stream.append(hash);\n+        }\n+        let data = stream.out();\n+\n+        let (new_data, id) = do_generate_request_id(&data);\n+\n+        let recovered = Rlp::new(&new_data);\n+        let recovered_id: RequestId = recovered.val_at(0).unwrap();\n+        let recovered_request: Vec<H256> = recovered.at(1).unwrap().as_list().unwrap();\n+        assert_eq!(recovered_id, id.unwrap());\n+        assert_eq!(recovered_request, request);\n+    }\n+}\ndiff --git a/crates/ethcore/sync/src/chain/sync_packet.rs b/crates/ethcore/sync/src/chain/sync_packet.rs\n--- a/crates/ethcore/sync/src/chain/sync_packet.rs\n+++ b/crates/ethcore/sync/src/chain/sync_packet.rs\n@@ -102,6 +103,21 @@ impl PacketInfo for SyncPacket {\n     fn id(&self) -> PacketId {\n         (*self) as PacketId\n     }\n+\n+    fn has_request_id_in_eth_66(&self) -> bool {\n+        // Note: NodeDataPacket and GetNodeDataPacket also get a request id in eth-66.\n+        match self {\n+            GetBlockHeadersPacket\n+            | BlockHeadersPacket\n+            | GetBlockBodiesPacket\n+            | BlockBodiesPacket\n+            | GetPooledTransactionsPacket\n+            | PooledTransactionsPacket\n+            | GetReceiptsPacket\n+            | ReceiptsPacket => true,\n+            _ => false,\n+        }\n+    }\n }\n \n #[cfg(test)]\ndiff --git a/crates/ethcore/sync/src/tests/helpers.rs b/crates/ethcore/sync/src/tests/helpers.rs\n--- a/crates/ethcore/sync/src/tests/helpers.rs\n+++ b/crates/ethcore/sync/src/tests/helpers.rs\n@@ -18,7 +18,7 @@ use api::PAR_PROTOCOL;\n use bytes::Bytes;\n use chain::{\n     sync_packet::{PacketInfo, SyncPacket},\n-    ChainSync, ForkFilterApi, SyncSupplier, ETH_PROTOCOL_VERSION_65, PAR_PROTOCOL_VERSION_2,\n+    ChainSync, ForkFilterApi, SyncSupplier, ETH_PROTOCOL_VERSION_66, PAR_PROTOCOL_VERSION_2,\n };\n use ethcore::{\n     client::{\ndiff --git a/crates/ethcore/sync/src/tests/helpers.rs b/crates/ethcore/sync/src/tests/helpers.rs\n--- a/crates/ethcore/sync/src/tests/helpers.rs\n+++ b/crates/ethcore/sync/src/tests/helpers.rs\n@@ -172,7 +172,7 @@ where\n         if protocol == PAR_PROTOCOL {\n             PAR_PROTOCOL_VERSION_2.0\n         } else {\n-            ETH_PROTOCOL_VERSION_65.0\n+            ETH_PROTOCOL_VERSION_66.0\n         }\n     }\n \n",
        "problem_statement": "Implement eth/66\nSo far we have been relying on eth/65 support by other clients for the rest of OpenEthereum's lifetime. Since geth is planning to drop eth/65 earlier, we will need to implement eth/66.\n",
        "hints_text": "",
        "created_at": "2021-07-02T15:19:13Z",
        "version": "0.6"
    },
    {
        "repo": "openethereum/openethereum",
        "pull_number": 324,
        "instance_id": "openethereum__openethereum-324",
        "issue_numbers": [
            "314"
        ],
        "base_commit": "504777e87969776d398c6db537b5eea02c0ed041",
        "patch": "diff --git a/crates/net/network/src/client_version.rs b/crates/net/network/src/client_version.rs\n--- a/crates/net/network/src/client_version.rs\n+++ b/crates/net/network/src/client_version.rs\n@@ -128,8 +128,8 @@ pub trait ClientCapabilities {\n     /// if this version can handle requests for a large number of block bodies.\n     fn can_handle_large_requests(&self) -> bool;\n \n-    /// Service transactions are specific to parity. Query if this version\n-    /// accepts them.\n+    /// Service transactions are specific to parity and nethermind. Query if\n+    /// this version accepts them.\n     fn accepts_service_transaction(&self) -> bool;\n }\n \ndiff --git a/crates/net/network/src/client_version.rs b/crates/net/network/src/client_version.rs\n--- a/crates/net/network/src/client_version.rs\n+++ b/crates/net/network/src/client_version.rs\n@@ -146,7 +146,7 @@ impl ClientCapabilities for ClientVersion {\n         match self {\n             ClientVersion::ParityClient(_) => true,\n             ClientVersion::ParityUnknownFormat(_) => true,\n-            ClientVersion::Other(_) => false,\n+            ClientVersion::Other(client_id) => is_nethermind(client_id),\n         }\n     }\n }\ndiff --git a/crates/net/network/src/client_version.rs b/crates/net/network/src/client_version.rs\n--- a/crates/net/network/src/client_version.rs\n+++ b/crates/net/network/src/client_version.rs\n@@ -156,6 +156,10 @@ fn is_parity(client_id: &str) -> bool {\n         || client_id.starts_with(CURRENT_CLIENT_ID_PREFIX)\n }\n \n+fn is_nethermind(client_id: &str) -> bool {\n+    client_id.starts_with(\"Nethermind\")\n+}\n+\n /// Parse known parity formats. Recognizes either a short format with four fields\n /// or a long format which includes the same fields and an identity one.\n fn parse_parity_format(client_version: &str) -> Result<ParityClientData, ()> {\n",
        "test_patch": "diff --git a/crates/net/network/src/client_version.rs b/crates/net/network/src/client_version.rs\n--- a/crates/net/network/src/client_version.rs\n+++ b/crates/net/network/src/client_version.rs\n@@ -531,6 +535,15 @@ pub mod tests {\n             ClientVersion::from(\"Parity-Ethereum/ABCDEFGH/v2.7.3/linux/rustc\")\n                 .accepts_service_transaction()\n         );\n+        assert!(\n+            ClientVersion::from(\"OpenEthereum//v3.2.0/x86_64-linux-gnu/rustc1.49.0\")\n+                .accepts_service_transaction()\n+        );\n+        assert!(ClientVersion::from(\"OpenEthereum/ABCDEFGH\").accepts_service_transaction());\n+        assert!(\n+            ClientVersion::from(\"Nethermind/v1.10.37-0-068e5c399-20210311/X64-Linux/5.0.4\")\n+                .accepts_service_transaction()\n+        )\n     }\n \n     #[test]\n",
        "problem_statement": "OpenEthereum doesn't propagate service transactions to Nethermind nodes\nWe recently discovered that OpenEthereum doesn't propagate service transactions (transactions with zero gas price) to clients other than OpenEthereum: https://github.com/openethereum/openethereum/blob/f1dc6821689c7f47d8fd07dfc0a2c5ad557b98ec/crates/ethcore/sync/src/chain/propagator.rs#L121-L155\r\n\r\nThe limitation is in `accepts_service_transaction()`: https://github.com/openethereum/openethereum/blob/f1dc6821689c7f47d8fd07dfc0a2c5ad557b98ec/crates/net/network/src/client_version.rs#L145-L151\r\n\r\nxDai chain has Nethermind nodes that can work with service transactions, but they don't receive such transactions from OpenEthereum nodes.\r\n\r\nCould you please add a condition for Nethermind to `accepts_service_transaction()`?\r\n\r\nExample of Nethermind client id: `Nethermind/v1.10.37-0-068e5c399-20210311/X64-Linux/5.0.4`\n",
        "hints_text": "",
        "created_at": "2021-03-17T12:56:04Z",
        "version": "3.2"
    },
    {
        "repo": "openethereum/openethereum",
        "pull_number": 593,
        "instance_id": "openethereum__openethereum-593",
        "issue_numbers": [
            "592"
        ],
        "base_commit": "63bab44e3c24bf6d577488edf756a2c5f31fcfd6",
        "patch": "diff --git a/bin/oe/configuration.rs b/bin/oe/configuration.rs\n--- a/bin/oe/configuration.rs\n+++ b/bin/oe/configuration.rs\n@@ -640,7 +640,7 @@ impl Configuration {\n \n     fn pool_verification_options(&self) -> Result<pool::verifier::Options, String> {\n         Ok(pool::verifier::Options {\n-            // NOTE min_gas_price,block_gas_limit and block_base_fee will be overwritten right after start.\n+            // NOTE min_gas_price,block_gas_limit block_base_fee, and allow_non_eoa_sender will be overwritten right after start.\n             minimal_gas_price: U256::from(20_000_000) * 1_000u32,\n             block_gas_limit: U256::max_value(),\n             block_base_fee: None,\ndiff --git a/bin/oe/configuration.rs b/bin/oe/configuration.rs\n--- a/bin/oe/configuration.rs\n+++ b/bin/oe/configuration.rs\n@@ -649,6 +649,7 @@ impl Configuration {\n                 None => U256::max_value(),\n             },\n             no_early_reject: self.args.flag_tx_queue_no_early_reject,\n+            allow_non_eoa_sender: false,\n         })\n     }\n \ndiff --git a/bin/oe/run.rs b/bin/oe/run.rs\n--- a/bin/oe/run.rs\n+++ b/bin/oe/run.rs\n@@ -370,7 +370,14 @@ pub fn execute(cmd: RunCmd, logger: Arc<RotatingLogger>) -> Result<RunningClient\n     let base_fee = client\n         .engine()\n         .calculate_base_fee(&client.best_block_header());\n-    miner.update_transaction_queue_limits(*client.best_block_header().gas_limit(), base_fee);\n+    let allow_non_eoa_sender = client\n+        .engine()\n+        .allow_non_eoa_sender(client.best_block_header().number() + 1);\n+    miner.update_transaction_queue_limits(\n+        *client.best_block_header().gas_limit(),\n+        base_fee,\n+        allow_non_eoa_sender,\n+    );\n \n     let connection_filter = connection_filter_address.map(|a| {\n         Arc::new(NodeFilter::new(\ndiff --git a/crates/concensus/miner/src/pool/client.rs b/crates/concensus/miner/src/pool/client.rs\n--- a/crates/concensus/miner/src/pool/client.rs\n+++ b/crates/concensus/miner/src/pool/client.rs\n@@ -32,6 +32,8 @@ pub struct AccountDetails {\n     pub nonce: U256,\n     /// Current account balance\n     pub balance: U256,\n+    /// Code hash associated with an account if any\n+    pub code_hash: Option<H256>,\n     /// Is this account a local account?\n     pub is_local: bool,\n }\ndiff --git a/crates/concensus/miner/src/pool/verifier.rs b/crates/concensus/miner/src/pool/verifier.rs\n--- a/crates/concensus/miner/src/pool/verifier.rs\n+++ b/crates/concensus/miner/src/pool/verifier.rs\n@@ -31,6 +31,7 @@ use std::{\n };\n \n use ethereum_types::{H256, U256};\n+use hash::KECCAK_EMPTY;\n use txpool;\n use types::transaction;\n \ndiff --git a/crates/concensus/miner/src/pool/verifier.rs b/crates/concensus/miner/src/pool/verifier.rs\n--- a/crates/concensus/miner/src/pool/verifier.rs\n+++ b/crates/concensus/miner/src/pool/verifier.rs\n@@ -63,6 +66,7 @@ impl Default for Options {\n             block_base_fee: None,\n             tx_gas_limit: U256::max_value(),\n             no_early_reject: false,\n+            allow_non_eoa_sender: false,\n         }\n     }\n }\ndiff --git a/crates/concensus/miner/src/pool/verifier.rs b/crates/concensus/miner/src/pool/verifier.rs\n--- a/crates/concensus/miner/src/pool/verifier.rs\n+++ b/crates/concensus/miner/src/pool/verifier.rs\n@@ -317,6 +321,20 @@ impl<C: Client> txpool::Verifier<Transaction>\n         let sender = transaction.sender();\n         let account_details = self.client.account_details(&sender);\n \n+        if !self.options.allow_non_eoa_sender {\n+            if let Some(code_hash) = account_details.code_hash {\n+                if code_hash != KECCAK_EMPTY {\n+                    debug!(\n+                        target: \"txqueue\",\n+                        \"[{:?}] Rejected tx, sender is not an EOA: {}\",\n+                        hash,\n+                        code_hash\n+                    );\n+                    bail!(transaction::Error::SenderIsNotEOA);\n+                }\n+            }\n+        }\n+\n         let effective_priority_fee =\n             transaction.effective_priority_fee(self.options.block_base_fee);\n \ndiff --git a/crates/ethcore/src/engines/mod.rs b/crates/ethcore/src/engines/mod.rs\n--- a/crates/ethcore/src/engines/mod.rs\n+++ b/crates/ethcore/src/engines/mod.rs\n@@ -668,6 +668,14 @@ pub trait EthEngine: Engine<::machine::EthereumMachine> {\n     fn min_gas_limit(&self) -> U256 {\n         self.params().min_gas_limit\n     }\n+\n+    /// Returns whether transactions from non externally owned accounts (EOA)\n+    /// are allowed in the given block number (see EIP-3607).\n+    ///\n+    /// That is only possible if EIP-3607 is still not activated.\n+    fn allow_non_eoa_sender(&self, best_block_number: BlockNumber) -> bool {\n+        self.params().eip3607_transition > best_block_number\n+    }\n }\n \n // convenience wrappers for existing functions.\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -190,6 +190,7 @@ impl Default for MinerOptions {\n                 block_base_fee: None,\n                 tx_gas_limit: U256::max_value(),\n                 no_early_reject: false,\n+                allow_non_eoa_sender: false,\n             },\n         }\n     }\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -341,6 +342,7 @@ impl Miner {\n                     block_base_fee: None,\n                     tx_gas_limit: U256::max_value(),\n                     no_early_reject: false,\n+                    allow_non_eoa_sender: false,\n                 },\n                 reseal_min_period: Duration::from_secs(0),\n                 force_sealing,\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -382,6 +384,7 @@ impl Miner {\n         &self,\n         block_gas_limit: U256,\n         block_base_fee: Option<U256>,\n+        allow_non_eoa_sender: bool,\n     ) {\n         trace!(target: \"miner\", \"minimal_gas_price: recalibrating...\");\n         let txq = self.transaction_queue.clone();\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -391,6 +394,7 @@ impl Miner {\n             options.minimal_gas_price = gas_price;\n             options.block_gas_limit = block_gas_limit;\n             options.block_base_fee = block_base_fee;\n+            options.allow_non_eoa_sender = allow_non_eoa_sender;\n             txq.set_verifier_options(options);\n         });\n \ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -1466,7 +1470,10 @@ impl miner::MinerService for Miner {\n                 } else {\n                     1\n                 };\n-        self.update_transaction_queue_limits(gas_limit, base_fee);\n+        let allow_non_eoa_sender = self\n+            .engine\n+            .allow_non_eoa_sender(chain.best_block_header().number() + 1);\n+        self.update_transaction_queue_limits(gas_limit, base_fee, allow_non_eoa_sender);\n \n         // t_nb 10.2 Then import all transactions from retracted blocks (retracted means from side chain).\n         let client = self.pool_client(chain);\ndiff --git a/crates/ethcore/src/miner/pool_client.rs b/crates/ethcore/src/miner/pool_client.rs\n--- a/crates/ethcore/src/miner/pool_client.rs\n+++ b/crates/ethcore/src/miner/pool_client.rs\n@@ -30,7 +30,7 @@ use types::{\n };\n \n use call_contract::CallContract;\n-use client::{BlockInfo, Nonce, TransactionId};\n+use client::{BlockId, BlockInfo, Nonce, TransactionId};\n use engines::EthEngine;\n use miner;\n use transaction_ext::Transaction;\ndiff --git a/crates/ethcore/src/spec/spec.rs b/crates/ethcore/src/spec/spec.rs\n--- a/crates/ethcore/src/spec/spec.rs\n+++ b/crates/ethcore/src/spec/spec.rs\n@@ -147,6 +147,8 @@ pub struct CommonParams {\n     pub eip3529_transition: BlockNumber,\n     /// Number of first block where EIP-3541 rule begins.\n     pub eip3541_transition: BlockNumber,\n+    /// Number of first block where EIP-3607 rule begins.\n+    pub eip3607_transition: BlockNumber,\n     /// Number of first block where dust cleanup rules (EIP-168 and EIP169) begin.\n     pub dust_protection_transition: BlockNumber,\n     /// Nonce cap increase per block. Nonce cap is only checked if dust protection is enabled.\ndiff --git a/crates/ethcore/src/spec/spec.rs b/crates/ethcore/src/spec/spec.rs\n--- a/crates/ethcore/src/spec/spec.rs\n+++ b/crates/ethcore/src/spec/spec.rs\n@@ -434,6 +436,7 @@ impl From<ethjson::spec::Params> for CommonParams {\n             dust_protection_transition: p\n                 .dust_protection_transition\n                 .map_or_else(BlockNumber::max_value, Into::into),\n+            eip3607_transition: p.eip3607_transition.map_or(0, Into::into),\n             nonce_cap_increment: p.nonce_cap_increment.map_or(64, Into::into),\n             remove_dust_contracts: p.remove_dust_contracts.unwrap_or(false),\n             gas_limit_bound_divisor: p.gas_limit_bound_divisor.into(),\ndiff --git a/crates/ethcore/types/src/transaction/error.rs b/crates/ethcore/types/src/transaction/error.rs\n--- a/crates/ethcore/types/src/transaction/error.rs\n+++ b/crates/ethcore/types/src/transaction/error.rs\n@@ -93,6 +93,8 @@ pub enum Error {\n     InvalidRlp(String),\n     /// Transaciton is still not enabled.\n     TransactionTypeNotEnabled,\n+    /// Transaction sender is not an EOA (see EIP-3607)\n+    SenderIsNotEOA,\n }\n \n impl From<crypto::publickey::Error> for Error {\ndiff --git a/crates/ethcore/types/src/transaction/error.rs b/crates/ethcore/types/src/transaction/error.rs\n--- a/crates/ethcore/types/src/transaction/error.rs\n+++ b/crates/ethcore/types/src/transaction/error.rs\n@@ -154,6 +156,7 @@ impl fmt::Display for Error {\n             TransactionTypeNotEnabled => {\n                 format!(\"Transaction type is not enabled for current block\")\n             }\n+            SenderIsNotEOA => \"Transaction sender is not an EOA (see EIP-3607)\".into(),\n         };\n \n         f.write_fmt(format_args!(\"Transaction error ({})\", msg))\ndiff --git a/crates/ethjson/src/spec/params.rs b/crates/ethjson/src/spec/params.rs\n--- a/crates/ethjson/src/spec/params.rs\n+++ b/crates/ethjson/src/spec/params.rs\n@@ -120,6 +120,8 @@ pub struct Params {\n     /// See `CommonParams` docs.\n     pub eip3541_transition: Option<Uint>,\n     /// See `CommonParams` docs.\n+    pub eip3607_transition: Option<Uint>,\n+    /// See `CommonParams` docs.\n     pub dust_protection_transition: Option<Uint>,\n     /// See `CommonParams` docs.\n     pub nonce_cap_increment: Option<Uint>,\ndiff --git a/crates/rpc/src/v1/helpers/errors.rs b/crates/rpc/src/v1/helpers/errors.rs\n--- a/crates/rpc/src/v1/helpers/errors.rs\n+++ b/crates/rpc/src/v1/helpers/errors.rs\n@@ -408,6 +408,7 @@ pub fn transaction_message(error: &TransactionError) -> String {\n \t\tTooBig => \"Transaction is too big, see chain specification for the limit.\".into(),\n         InvalidRlp(ref descr) => format!(\"Invalid RLP data: {}\", descr),\n         TransactionTypeNotEnabled => format!(\"Transaction type is not enabled for current block\"),\n+        SenderIsNotEOA => \"Transaction sender is not an EOA (see EIP-3607)\".into(),\n \t}\n }\n \n",
        "test_patch": "diff --git a/crates/concensus/miner/src/pool/tests/client.rs b/crates/concensus/miner/src/pool/tests/client.rs\n--- a/crates/concensus/miner/src/pool/tests/client.rs\n+++ b/crates/concensus/miner/src/pool/tests/client.rs\n@@ -43,6 +43,7 @@ impl Default for TestClient {\n             account_details: AccountDetails {\n                 nonce: 123.into(),\n                 balance: 63_100.into(),\n+                code_hash: None,\n                 is_local: false,\n             },\n             gas_required: 21_000.into(),\ndiff --git a/crates/concensus/miner/src/pool/tests/client.rs b/crates/concensus/miner/src/pool/tests/client.rs\n--- a/crates/concensus/miner/src/pool/tests/client.rs\n+++ b/crates/concensus/miner/src/pool/tests/client.rs\n@@ -68,6 +69,11 @@ impl TestClient {\n         self\n     }\n \n+    pub fn with_code_hash<T: Into<H256>>(mut self, code_hash: T) -> Self {\n+        self.account_details.code_hash = Some(code_hash.into());\n+        self\n+    }\n+\n     pub fn with_gas_required<T: Into<U256>>(mut self, gas_required: T) -> Self {\n         self.gas_required = gas_required.into();\n         self\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -15,6 +15,7 @@\n // along with OpenEthereum.  If not, see <http://www.gnu.org/licenses/>.\n \n use ethereum_types::U256;\n+use hash::KECCAK_EMPTY;\n use txpool;\n use types::transaction::{self, PendingTransaction};\n \ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -47,6 +48,7 @@ fn new_queue() -> TransactionQueue {\n             tx_gas_limit: 1_000_000.into(),\n             no_early_reject: false,\n             block_base_fee: None,\n+            allow_non_eoa_sender: false,\n         },\n         PrioritizationStrategy::GasPriceOnly,\n     )\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -66,6 +68,7 @@ fn should_return_correct_nonces_when_dropped_because_of_limit() {\n             tx_gas_limit: 1_000_000.into(),\n             no_early_reject: false,\n             block_base_fee: None,\n+            allow_non_eoa_sender: false,\n         },\n         PrioritizationStrategy::GasPriceOnly,\n     );\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -127,6 +130,7 @@ fn should_never_drop_local_transactions_from_different_senders() {\n             tx_gas_limit: 1_000_000.into(),\n             no_early_reject: false,\n             block_base_fee: None,\n+            allow_non_eoa_sender: false,\n         },\n         PrioritizationStrategy::GasPriceOnly,\n     );\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -272,6 +276,71 @@ fn should_import_transaction_below_min_gas_price_threshold_if_local() {\n     assert_eq!(txq.status().status.transaction_count, 1);\n }\n \n+#[test]\n+fn should_reject_transaction_from_non_eoa_if_non_eoa_sender_is_not_allowed() {\n+    // given\n+    let txq = new_queue();\n+    let tx = Tx::default();\n+    let code_hash = [\n+        0x0c, 0x0a, 0x0f, 0x0e, 0x0c, 0x0a, 0x0f, 0x0e, 0x0c, 0x0a, 0x0f, 0x0e, 0x0c, 0x0a, 0x0f,\n+        0x0e, 0x0c, 0x0a, 0x0f, 0x0e, 0x0c, 0x0a, 0x0f, 0x0e, 0x0c, 0x0a, 0x0f, 0x0e, 0x0c, 0x0a,\n+        0x0f, 0x0e,\n+    ];\n+\n+    // when\n+    let res = txq.import(\n+        TestClient::new().with_code_hash(code_hash),\n+        vec![tx.signed().unverified()],\n+    );\n+\n+    // then\n+    assert_eq!(res, vec![Err(transaction::Error::SenderIsNotEOA)]);\n+    assert_eq!(txq.status().status.transaction_count, 0);\n+}\n+\n+#[test]\n+fn should_import_transaction_from_non_eoa_if_non_eoa_sender_is_allowed() {\n+    // given\n+    let txq = new_queue();\n+    let tx = Tx::default();\n+    let code_hash = [\n+        0x0c, 0x0a, 0x0f, 0x0e, 0x0c, 0x0a, 0x0f, 0x0e, 0x0c, 0x0a, 0x0f, 0x0e, 0x0c, 0x0a, 0x0f,\n+        0x0e, 0x0c, 0x0a, 0x0f, 0x0e, 0x0c, 0x0a, 0x0f, 0x0e, 0x0c, 0x0a, 0x0f, 0x0e, 0x0c, 0x0a,\n+        0x0f, 0x0e,\n+    ];\n+    txq.set_verifier_options(verifier::Options {\n+        allow_non_eoa_sender: true,\n+        ..Default::default()\n+    });\n+\n+    // when\n+    let res = txq.import(\n+        TestClient::new().with_code_hash(code_hash),\n+        vec![tx.signed().unverified()],\n+    );\n+\n+    // then\n+    assert_eq!(res, vec![Ok(())]);\n+    assert_eq!(txq.status().status.transaction_count, 1);\n+}\n+\n+#[test]\n+fn should_import_transaction_if_account_code_hash_is_keccak_empty() {\n+    // given\n+    let txq = new_queue();\n+    let tx = Tx::default();\n+\n+    // when\n+    let res = txq.import(\n+        TestClient::new().with_code_hash(KECCAK_EMPTY),\n+        vec![tx.signed().unverified()],\n+    );\n+\n+    // then\n+    assert_eq!(res, vec![Ok(())]);\n+    assert_eq!(txq.status().status.transaction_count, 1);\n+}\n+\n #[test]\n fn should_import_txs_from_same_sender() {\n     // given\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -545,6 +614,7 @@ fn should_prefer_current_transactions_when_hitting_the_limit() {\n             tx_gas_limit: 1_000_000.into(),\n             no_early_reject: false,\n             block_base_fee: None,\n+            allow_non_eoa_sender: false,\n         },\n         PrioritizationStrategy::GasPriceOnly,\n     );\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -1043,6 +1113,7 @@ fn should_include_local_transaction_to_a_full_pool() {\n             tx_gas_limit: 1_000_000.into(),\n             no_early_reject: false,\n             block_base_fee: None,\n+            allow_non_eoa_sender: false,\n         },\n         PrioritizationStrategy::GasPriceOnly,\n     );\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -1076,6 +1147,7 @@ fn should_avoid_verifying_transaction_already_in_pool() {\n             tx_gas_limit: 1_000_000.into(),\n             no_early_reject: false,\n             block_base_fee: None,\n+            allow_non_eoa_sender: false,\n         },\n         PrioritizationStrategy::GasPriceOnly,\n     );\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -1112,6 +1184,7 @@ fn should_avoid_reverifying_recently_rejected_transactions() {\n             tx_gas_limit: 1_000_000.into(),\n             no_early_reject: false,\n             block_base_fee: None,\n+            allow_non_eoa_sender: false,\n         },\n         PrioritizationStrategy::GasPriceOnly,\n     );\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -1161,6 +1234,7 @@ fn should_reject_early_in_case_gas_price_is_less_than_min_effective() {\n             tx_gas_limit: 1_000_000.into(),\n             no_early_reject: false,\n             block_base_fee: None,\n+            allow_non_eoa_sender: false,\n         },\n         PrioritizationStrategy::GasPriceOnly,\n     );\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -1204,6 +1278,7 @@ fn should_not_reject_early_in_case_gas_price_is_less_than_min_effective() {\n             tx_gas_limit: 1_000_000.into(),\n             no_early_reject: true,\n             block_base_fee: None,\n+            allow_non_eoa_sender: false,\n         },\n         PrioritizationStrategy::GasPriceOnly,\n     );\ndiff --git a/crates/concensus/miner/src/pool/verifier.rs b/crates/concensus/miner/src/pool/verifier.rs\n--- a/crates/concensus/miner/src/pool/verifier.rs\n+++ b/crates/concensus/miner/src/pool/verifier.rs\n@@ -52,6 +53,8 @@ pub struct Options {\n     pub tx_gas_limit: U256,\n     /// Skip checks for early rejection, to make sure that local transactions are always imported.\n     pub no_early_reject: bool,\n+    /// Accept transactions from non EOAs (see EIP-3607)\n+    pub allow_non_eoa_sender: bool,\n }\n \n #[cfg(test)]\ndiff --git /dev/null b/crates/ethcore/res/chainspec/test/eip3607_test.json\nnew file mode 100644\n--- /dev/null\n+++ b/crates/ethcore/res/chainspec/test/eip3607_test.json\n@@ -0,0 +1,47 @@\n+{\n+  \"name\": \"Morden\",\n+  \"engine\": {\n+    \"null\": {\n+      \"params\": {}\n+    }\n+  },\n+  \"params\": {\n+    \"gasLimitBoundDivisor\": \"0x0400\",\n+    \"accountStartNonce\": \"0x0\",\n+    \"maximumExtraDataSize\": \"0x20\",\n+    \"minGasLimit\": \"0x1388\",\n+    \"networkID\" : \"0x2\",\n+    \"registrar\" : \"0x0000000000000000000000000000000000001337\",\n+    \"eip140Transition\": \"0x0\",\n+    \"eip211Transition\": \"0x0\",\n+    \"eip214Transition\": \"0x0\",\n+    \"eip658Transition\": \"0x0\",\n+    \"eip3607Transition\": \"0x2\"\n+  },\n+  \"genesis\": {\n+    \"seal\": {\n+      \"ethereum\": {\n+        \"nonce\": \"0x00006d6f7264656e\",\n+        \"mixHash\": \"0x00000000000000000000000000000000000000647572616c65787365646c6578\"\n+      }\n+    },\n+    \"difficulty\": \"0x20000\",\n+    \"author\": \"0x0000000000000000000000000000000000000000\",\n+    \"timestamp\": \"0x00\",\n+    \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\",\n+    \"extraData\": \"0x\",\n+    \"gasLimit\": \"0x2fefd8\"\n+  },\n+  \"accounts\": {\n+    \"0000000000000000000000000000000000000001\": { \"balance\": \"1\", \"nonce\": \"1048576\", \"builtin\": { \"name\": \"ecrecover\", \"pricing\": { \"linear\": { \"base\": 3000, \"word\": 0 } } } },\n+    \"0000000000000000000000000000000000000002\": { \"balance\": \"1\", \"nonce\": \"1048576\", \"builtin\": { \"name\": \"sha256\", \"pricing\": { \"linear\": { \"base\": 60, \"word\": 12 } } } },\n+    \"0000000000000000000000000000000000000003\": { \"balance\": \"1\", \"nonce\": \"1048576\", \"builtin\": { \"name\": \"ripemd160\", \"pricing\": { \"linear\": { \"base\": 600, \"word\": 120 } } } },\n+    \"0000000000000000000000000000000000000004\": { \"balance\": \"1\", \"nonce\": \"1048576\", \"builtin\": { \"name\": \"identity\", \"pricing\": { \"linear\": { \"base\": 15, \"word\": 3 } } } },\n+    \"102e61f5d8f9bc71d0ad4a084df4e65e05ce0e1c\": { \"balance\": \"1606938044258990275541962092341162602522202993782792835301376\", \"nonce\": \"1048576\" },\n+    \"0x71562b71999873DB5b286dF957af199Ec94617F7\": {\n+      \"balance\": \"1000000000000000000\",\n+      \"nonce\": \"0\",\n+      \"code\": \"0xB0B0FACE\"\n+    }\n+  }\n+}\n\\ No newline at end of file\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -1670,6 +1677,7 @@ mod tests {\n                     block_base_fee: None,\n                     tx_gas_limit: U256::max_value(),\n                     no_early_reject: false,\n+                    allow_non_eoa_sender: false,\n                 },\n             },\n             GasPricer::new_fixed(0u64.into()),\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -1815,6 +1823,40 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn should_activate_eip_3607_according_to_spec() {\n+        // given\n+        let spec = Spec::new_test_eip3607();\n+        let miner = Miner::new_for_tests(&spec, None);\n+        let client = TestBlockChainClient::new_with_spec(spec);\n+\n+        let imported = [H256::zero()];\n+        let empty = &[];\n+\n+        // the client best block is below EIP-3607 transition number\n+        miner.chain_new_blocks(&client, &imported, empty, &imported, empty, false);\n+        assert!(\n+            miner.queue_status().options.allow_non_eoa_sender,\n+            \"The client best block is below EIP-3607 transition number. Non EOA senders should be allowed\"\n+        );\n+\n+        // the client best block equals EIP-3607 transition number\n+        client.add_block(EachBlockWith::Nothing, |header| header);\n+        miner.chain_new_blocks(&client, &imported, empty, &imported, empty, false);\n+        assert!(\n+            !miner.queue_status().options.allow_non_eoa_sender,\n+            \"The client best block equals EIP-3607 transition number. Non EOA senders should not be allowed\"\n+        );\n+\n+        // the client best block is above EIP-3607 transition number\n+        client.add_block(EachBlockWith::Nothing, |header| header);\n+        miner.chain_new_blocks(&client, &imported, empty, &imported, empty, false);\n+        assert!(\n+            !miner.queue_status().options.allow_non_eoa_sender,\n+            \"The client best block is above EIP-3607 transition number. Non EOA senders should not be allowed\"\n+        );\n+    }\n+\n     #[test]\n     fn should_treat_unfamiliar_locals_selectively() {\n         // given\ndiff --git a/crates/ethcore/src/miner/pool_client.rs b/crates/ethcore/src/miner/pool_client.rs\n--- a/crates/ethcore/src/miner/pool_client.rs\n+++ b/crates/ethcore/src/miner/pool_client.rs\n@@ -168,6 +168,7 @@ where\n         pool::client::AccountDetails {\n             nonce: self.cached_nonces.account_nonce(address),\n             balance: self.chain.latest_balance(address),\n+            code_hash: self.chain.code_hash(address, BlockId::Latest),\n             is_local: self.accounts.is_local(address),\n         }\n     }\ndiff --git a/crates/ethcore/src/spec/spec.rs b/crates/ethcore/src/spec/spec.rs\n--- a/crates/ethcore/src/spec/spec.rs\n+++ b/crates/ethcore/src/spec/spec.rs\n@@ -1151,6 +1154,13 @@ impl Spec {\n         load_bundled!(\"test/constructor\")\n     }\n \n+    /// Create a new Spec which is a NullEngine consensus with EIP3607 transition equal to 2,\n+    /// and with a contract at address '0x71562b71999873DB5b286dF957af199Ec94617F7'.\n+    #[cfg(any(test, feature = \"test-helpers\"))]\n+    pub fn new_test_eip3607() -> Self {\n+        load_bundled!(\"test/eip3607_test\")\n+    }\n+\n     /// Create a new Spec with Autority Round randomness contract\n     #[cfg(any(test, feature = \"test-helpers\"))]\n     pub fn new_test_round_randomness_contract() -> Spec {\ndiff --git a/crates/rpc/src/v1/tests/helpers/miner_service.rs b/crates/rpc/src/v1/tests/helpers/miner_service.rs\n--- a/crates/rpc/src/v1/tests/helpers/miner_service.rs\n+++ b/crates/rpc/src/v1/tests/helpers/miner_service.rs\n@@ -335,6 +335,7 @@ impl MinerService for TestMinerService {\n                 tx_gas_limit: 5_000_000.into(),\n                 no_early_reject: false,\n                 block_base_fee: None,\n+                allow_non_eoa_sender: false,\n             },\n             status: txpool::LightStatus {\n                 mem_usage: 1_000,\n",
        "problem_statement": "Implement EIP-3607\nhttps://eips.ethereum.org/EIPS/eip-3607\n",
        "hints_text": "",
        "created_at": "2021-12-28T23:02:26Z",
        "version": "3.3"
    },
    {
        "repo": "openethereum/openethereum",
        "pull_number": 295,
        "instance_id": "openethereum__openethereum-295",
        "issue_numbers": [
            "159"
        ],
        "base_commit": "33a3a9deec896c245935f5abf8d5e07bb8977939",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1188,6 +1188,9 @@ dependencies = [\n  \"price-info\",\n  \"rlp\",\n  \"rustc-hex 1.0.0\",\n+ \"serde\",\n+ \"serde_derive\",\n+ \"serde_json\",\n  \"trace-time\",\n  \"transaction-pool\",\n  \"url 2.1.0\",\ndiff --git a/crates/concensus/miner/Cargo.toml b/crates/concensus/miner/Cargo.toml\n--- a/crates/concensus/miner/Cargo.toml\n+++ b/crates/concensus/miner/Cargo.toml\n@@ -32,6 +32,9 @@ parity-util-mem = \"0.7\"\n parking_lot = \"0.7\"\n price-info = { path = \"./price-info\", optional = true }\n rlp = { version = \"0.4.6\" }\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_derive = \"1.0\"\n+serde_json = \"1.0\"\n trace-time = \"0.1\"\n transaction-pool = \"2.0.1\"\n \ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -32,7 +32,10 @@ use txpool::{self, Verifier};\n use types::transaction;\n \n use pool::{\n-    self, client, listener, local_transactions::LocalTransactionsList, ready, replace, scoring,\n+    self, client, listener,\n+    local_transactions::LocalTransactionsList,\n+    ready, replace, scoring,\n+    transaction_filter::{match_filter, TransactionFilter},\n     verifier, PendingOrdering, PendingSettings, PrioritizationStrategy,\n };\n \ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -120,6 +123,17 @@ impl CachedPending {\n         current_timestamp: u64,\n         nonce_cap: Option<&U256>,\n         max_len: usize,\n+    ) -> Option<Vec<Arc<pool::VerifiedTransaction>>> {\n+        self.pending_filtered(block_number, current_timestamp, nonce_cap, max_len, None)\n+    }\n+\n+    pub fn pending_filtered(\n+        &self,\n+        block_number: u64,\n+        current_timestamp: u64,\n+        nonce_cap: Option<&U256>,\n+        max_len: usize,\n+        filter: Option<TransactionFilter>,\n     ) -> Option<Vec<Arc<pool::VerifiedTransaction>>> {\n         // First check if we have anything in cache.\n         let pending = self.pending.as_ref()?;\ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -149,7 +163,14 @@ impl CachedPending {\n             return None;\n         }\n \n-        Some(pending.iter().take(max_len).cloned().collect())\n+        Some(\n+            pending\n+                .iter()\n+                .filter(|tx| match_filter(&filter, tx))\n+                .take(max_len)\n+                .cloned()\n+                .collect(),\n+        )\n     }\n }\n \ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -426,6 +447,31 @@ impl TransactionQueue {\n         pending\n     }\n \n+    /// Returns current pending transactions filtered.\n+    ///\n+    /// Different to the pending() method, this one does not cache.\n+    pub fn pending_filtered<C>(\n+        &self,\n+        client: C,\n+        settings: PendingSettings,\n+        filter: &TransactionFilter,\n+    ) -> Vec<Arc<pool::VerifiedTransaction>>\n+    where\n+        C: client::NonceClient,\n+    {\n+        self.collect_pending(\n+            client,\n+            settings.block_number,\n+            settings.current_timestamp,\n+            settings.nonce_cap,\n+            |i| {\n+                i.filter(|tx| filter.matches(tx))\n+                    .take(settings.max_len)\n+                    .collect()\n+            },\n+        )\n+    }\n+\n     /// Collect pending transactions.\n     ///\n     /// NOTE This is re-computing the pending set and it might be expensive to do so.\ndiff --git /dev/null b/crates/concensus/miner/src/pool/transaction_filter.rs\nnew file mode 100644\n--- /dev/null\n+++ b/crates/concensus/miner/src/pool/transaction_filter.rs\n@@ -0,0 +1,129 @@\n+// Copyright 2015-2021 Parity Technologies (UK) Ltd.\n+// This file is part of OpenEthereum.\n+\n+// OpenEthereum is free software: you can redistribute it and/or modify\n+// it under the terms of the GNU General Public License as published by\n+// the Free Software Foundation, either version 3 of the License, or\n+// (at your option) any later version.\n+\n+// OpenEthereum is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with OpenEthereum.  If not, see <http://www.gnu.org/licenses/>.\n+\n+//! Filter options available in the parity_pendingTransaction endpoint of the JSONRPC API.\n+\n+#![allow(missing_docs)]\n+\n+use ethereum_types::{Address, U256};\n+\n+use pool::VerifiedTransaction;\n+use types::transaction::Action;\n+\n+#[allow(non_camel_case_types)]\n+#[derive(Debug, Deserialize, Serialize)]\n+#[serde()]\n+pub enum SenderArgument {\n+    eq(Address),\n+    None,\n+}\n+\n+impl Default for SenderArgument {\n+    fn default() -> Self {\n+        Self::None\n+    }\n+}\n+\n+impl SenderArgument {\n+    fn matches(&self, value: &Address) -> bool {\n+        match self {\n+            Self::eq(expected) => value == expected,\n+            Self::None => true,\n+        }\n+    }\n+}\n+\n+#[allow(non_camel_case_types)]\n+#[derive(Debug, Deserialize, Serialize)]\n+#[serde()]\n+pub enum ActionArgument {\n+    eq(Address),\n+    action(String),\n+    None,\n+}\n+\n+impl Default for ActionArgument {\n+    fn default() -> Self {\n+        Self::None\n+    }\n+}\n+\n+impl ActionArgument {\n+    fn matches(&self, value: &Action) -> bool {\n+        match self {\n+            Self::eq(expected) => *value == Action::Call(*expected),\n+            Self::action(name) => *value == Action::Create && name == \"contract_creation\",\n+            Self::None => true,\n+        }\n+    }\n+}\n+\n+#[allow(non_camel_case_types)]\n+#[derive(Debug, Deserialize, Serialize)]\n+#[serde()]\n+pub enum ValueFilterArgument {\n+    eq(U256),\n+    lt(U256),\n+    gt(U256),\n+    None,\n+}\n+\n+impl Default for ValueFilterArgument {\n+    fn default() -> Self {\n+        Self::None\n+    }\n+}\n+\n+impl ValueFilterArgument {\n+    fn matches(&self, value: &U256) -> bool {\n+        match self {\n+            ValueFilterArgument::eq(expected) => value == expected,\n+            ValueFilterArgument::lt(threshold) => value < threshold,\n+            ValueFilterArgument::gt(threshold) => value > threshold,\n+            ValueFilterArgument::None => true,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Default, Deserialize, Serialize)]\n+#[serde(default, rename_all = \"camelCase\")]\n+pub struct TransactionFilter {\n+    from: SenderArgument,\n+    to: ActionArgument,\n+    gas: ValueFilterArgument,\n+    gas_price: ValueFilterArgument,\n+    value: ValueFilterArgument,\n+    nonce: ValueFilterArgument,\n+}\n+\n+impl TransactionFilter {\n+    pub fn matches(&self, transaction: &VerifiedTransaction) -> bool {\n+        let tx = transaction.signed().tx();\n+        self.from.matches(&transaction.sender)\n+            && self.to.matches(&tx.action)\n+            && self.gas.matches(&tx.gas)\n+            && self.gas_price.matches(&tx.gas_price)\n+            && self.nonce.matches(&tx.nonce)\n+            && self.value.matches(&tx.value)\n+    }\n+}\n+\n+pub fn match_filter(filter: &Option<TransactionFilter>, transaction: &VerifiedTransaction) -> bool {\n+    match filter {\n+        Some(f) => f.matches(transaction),\n+        None => true,\n+    }\n+}\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -29,7 +29,11 @@ use ethcore_miner::work_notify::NotifyWork;\n use ethcore_miner::{\n     gas_pricer::GasPricer,\n     local_accounts::LocalAccounts,\n-    pool::{self, PrioritizationStrategy, QueueStatus, TransactionQueue, VerifiedTransaction},\n+    pool::{\n+        self,\n+        transaction_filter::{match_filter, TransactionFilter},\n+        PrioritizationStrategy, QueueStatus, TransactionQueue, VerifiedTransaction,\n+    },\n     service_transaction_checker::ServiceTransactionChecker,\n };\n use ethereum_types::{Address, H256, U256};\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -1099,10 +1103,11 @@ impl miner::MinerService for Miner {\n         }\n     }\n \n-    fn ready_transactions<C>(\n+    fn ready_transactions_filtered<C>(\n         &self,\n         chain: &C,\n         max_len: usize,\n+        filter: Option<TransactionFilter>,\n         ordering: miner::PendingOrdering,\n     ) -> Vec<Arc<VerifiedTransaction>>\n     where\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -1116,16 +1121,20 @@ impl miner::MinerService for Miner {\n             // those transactions are valid and will just be ready to be included in next block.\n             let nonce_cap = None;\n \n-            self.transaction_queue.pending(\n-                CachedNonceClient::new(chain, &self.nonce_cache),\n-                pool::PendingSettings {\n-                    block_number: chain_info.best_block_number,\n-                    current_timestamp: chain_info.best_block_timestamp,\n-                    nonce_cap,\n-                    max_len,\n-                    ordering,\n-                },\n-            )\n+            let client = CachedNonceClient::new(chain, &self.nonce_cache);\n+            let settings = pool::PendingSettings {\n+                block_number: chain_info.best_block_number,\n+                current_timestamp: chain_info.best_block_timestamp,\n+                nonce_cap,\n+                max_len,\n+                ordering,\n+            };\n+\n+            if let Some(ref f) = filter {\n+                self.transaction_queue.pending_filtered(client, settings, f)\n+            } else {\n+                self.transaction_queue.pending(client, settings)\n+            }\n         };\n \n         let from_pending = || {\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -1139,6 +1148,7 @@ impl miner::MinerService for Miner {\n                                 signed.clone(),\n                             )\n                         })\n+                        .filter(|tx| match_filter(&filter, tx))\n                         .map(Arc::new)\n                         .take(max_len)\n                         .collect()\ndiff --git a/crates/ethcore/src/miner/mod.rs b/crates/ethcore/src/miner/mod.rs\n--- a/crates/ethcore/src/miner/mod.rs\n+++ b/crates/ethcore/src/miner/mod.rs\n@@ -26,7 +26,10 @@ pub mod pool_client;\n pub mod stratum;\n \n pub use self::miner::{Author, AuthoringParams, Miner, MinerOptions, Penalization, PendingSet};\n-pub use ethcore_miner::{local_accounts::LocalAccounts, pool::PendingOrdering};\n+pub use ethcore_miner::{\n+    local_accounts::LocalAccounts,\n+    pool::{transaction_filter::TransactionFilter, PendingOrdering},\n+};\n \n use std::{\n     collections::{BTreeMap, BTreeSet},\ndiff --git a/crates/ethcore/src/miner/mod.rs b/crates/ethcore/src/miner/mod.rs\n--- a/crates/ethcore/src/miner/mod.rs\n+++ b/crates/ethcore/src/miner/mod.rs\n@@ -209,20 +212,35 @@ pub trait MinerService: Send + Sync {\n     where\n         C: ChainInfo + Sync;\n \n-    /// Get a list of all ready transactions either ordered by priority or unordered (cheaper).\n+    /// Get a list of all ready transactions either ordered by priority or unordered (cheaper),\n+    /// and optionally filtered by sender, recipient, gas, gas price, value and/or nonce.\n     ///\n     /// Depending on the settings may look in transaction pool or only in pending block.\n     /// If you don't need a full set of transactions, you can add `max_len` and create only a limited set of\n     /// transactions.\n-    fn ready_transactions<C>(\n+    fn ready_transactions_filtered<C>(\n         &self,\n         chain: &C,\n         max_len: usize,\n+        filter: Option<TransactionFilter>,\n         ordering: PendingOrdering,\n     ) -> Vec<Arc<VerifiedTransaction>>\n     where\n         C: ChainInfo + Nonce + Sync;\n \n+    /// Get an unfiltered list of all ready transactions.\n+    fn ready_transactions<C>(\n+        &self,\n+        chain: &C,\n+        max_len: usize,\n+        ordering: PendingOrdering,\n+    ) -> Vec<Arc<VerifiedTransaction>>\n+    where\n+        C: ChainInfo + Nonce + Sync,\n+    {\n+        self.ready_transactions_filtered(chain, max_len, None, ordering)\n+    }\n+\n     /// Get a list of all transactions in the pool (some of them might not be ready for inclusion yet).\n     fn queued_transactions(&self) -> Vec<Arc<VerifiedTransaction>>;\n \ndiff --git a/crates/rpc/src/v1/impls/parity.rs b/crates/rpc/src/v1/impls/parity.rs\n--- a/crates/rpc/src/v1/impls/parity.rs\n+++ b/crates/rpc/src/v1/impls/parity.rs\n@@ -20,7 +20,7 @@ use std::{collections::BTreeMap, str::FromStr, sync::Arc};\n use crypto::{publickey::ecies, DEFAULT_MAC};\n use ethcore::{\n     client::{BlockChainClient, Call, StateClient},\n-    miner::{self, MinerService},\n+    miner::{self, MinerService, TransactionFilter},\n     snapshot::{RestorationStatus, SnapshotService},\n     state::StateInfo,\n };\ndiff --git a/crates/rpc/src/v1/impls/parity.rs b/crates/rpc/src/v1/impls/parity.rs\n--- a/crates/rpc/src/v1/impls/parity.rs\n+++ b/crates/rpc/src/v1/impls/parity.rs\n@@ -32,8 +32,6 @@ use jsonrpc_core::{futures::future, BoxFuture, Result};\n use stats::PrometheusMetrics;\n use sync::{ManageNetwork, SyncProvider};\n use types::ids::BlockId;\n-use version::version_data;\n-\n use v1::{\n     helpers::{\n         self,\ndiff --git a/crates/rpc/src/v1/impls/parity.rs b/crates/rpc/src/v1/impls/parity.rs\n--- a/crates/rpc/src/v1/impls/parity.rs\n+++ b/crates/rpc/src/v1/impls/parity.rs\n@@ -50,6 +48,7 @@ use v1::{\n         Transaction, TransactionStats,\n     },\n };\n+use version::version_data;\n use Host;\n \n /// Parity implementation.\ndiff --git a/crates/rpc/src/v1/impls/parity.rs b/crates/rpc/src/v1/impls/parity.rs\n--- a/crates/rpc/src/v1/impls/parity.rs\n+++ b/crates/rpc/src/v1/impls/parity.rs\n@@ -265,10 +264,15 @@ where\n             .map(Into::into)\n     }\n \n-    fn pending_transactions(&self, limit: Option<usize>) -> Result<Vec<Transaction>> {\n-        let ready_transactions = self.miner.ready_transactions(\n+    fn pending_transactions(\n+        &self,\n+        limit: Option<usize>,\n+        filter: Option<TransactionFilter>,\n+    ) -> Result<Vec<Transaction>> {\n+        let ready_transactions = self.miner.ready_transactions_filtered(\n             &*self.client,\n             limit.unwrap_or_else(usize::max_value),\n+            filter,\n             miner::PendingOrdering::Priority,\n         );\n \ndiff --git a/crates/rpc/src/v1/traits/parity.rs b/crates/rpc/src/v1/traits/parity.rs\n--- a/crates/rpc/src/v1/traits/parity.rs\n+++ b/crates/rpc/src/v1/traits/parity.rs\n@@ -21,6 +21,8 @@ use std::collections::BTreeMap;\n use ethereum_types::{H160, H256, H512, H64, U256, U64};\n use jsonrpc_core::{BoxFuture, Result};\n use jsonrpc_derive::rpc;\n+\n+use ethcore::miner::TransactionFilter;\n use v1::types::{\n     BlockNumber, Bytes, CallRequest, ChainStatus, Histogram, LocalTransactionStatus, Peers,\n     Receipt, RecoveredAccount, RichHeader, RpcSettings, Transaction, TransactionStats,\ndiff --git a/crates/rpc/src/v1/traits/parity.rs b/crates/rpc/src/v1/traits/parity.rs\n--- a/crates/rpc/src/v1/traits/parity.rs\n+++ b/crates/rpc/src/v1/traits/parity.rs\n@@ -132,7 +134,11 @@ pub trait Parity {\n \n     /// Returns all pending transactions from transaction queue.\n     #[rpc(name = \"parity_pendingTransactions\")]\n-    fn pending_transactions(&self, _: Option<usize>) -> Result<Vec<Transaction>>;\n+    fn pending_transactions(\n+        &self,\n+        _: Option<usize>,\n+        _: Option<TransactionFilter>,\n+    ) -> Result<Vec<Transaction>>;\n \n     /// Returns all transactions from transaction queue.\n     ///\n",
        "test_patch": "diff --git a/crates/concensus/miner/src/lib.rs b/crates/concensus/miner/src/lib.rs\n--- a/crates/concensus/miner/src/lib.rs\n+++ b/crates/concensus/miner/src/lib.rs\n@@ -44,6 +44,8 @@ extern crate error_chain;\n #[macro_use]\n extern crate log;\n #[macro_use]\n+extern crate serde_derive;\n+#[macro_use]\n extern crate trace_time;\n \n #[cfg(test)]\ndiff --git a/crates/concensus/miner/src/pool/mod.rs b/crates/concensus/miner/src/pool/mod.rs\n--- a/crates/concensus/miner/src/pool/mod.rs\n+++ b/crates/concensus/miner/src/pool/mod.rs\n@@ -29,6 +29,7 @@ pub mod client;\n pub mod local_transactions;\n pub mod replace;\n pub mod scoring;\n+pub mod transaction_filter;\n pub mod verifier;\n \n #[cfg(test)]\ndiff --git a/crates/rpc/src/v1/tests/helpers/miner_service.rs b/crates/rpc/src/v1/tests/helpers/miner_service.rs\n--- a/crates/rpc/src/v1/tests/helpers/miner_service.rs\n+++ b/crates/rpc/src/v1/tests/helpers/miner_service.rs\n@@ -30,7 +30,7 @@ use ethcore::{\n     },\n     engines::{signer::EngineSigner, EthEngine},\n     error::Error,\n-    miner::{self, AuthoringParams, MinerService},\n+    miner::{self, AuthoringParams, MinerService, TransactionFilter},\n };\n use ethereum_types::{Address, H256, U256};\n use miner::pool::{\ndiff --git a/crates/rpc/src/v1/tests/helpers/miner_service.rs b/crates/rpc/src/v1/tests/helpers/miner_service.rs\n--- a/crates/rpc/src/v1/tests/helpers/miner_service.rs\n+++ b/crates/rpc/src/v1/tests/helpers/miner_service.rs\n@@ -264,13 +264,21 @@ impl MinerService for TestMinerService {\n             .collect()\n     }\n \n-    fn ready_transactions<C>(\n+    fn ready_transactions_filtered<C>(\n         &self,\n         _chain: &C,\n         _max_len: usize,\n+        filter: Option<TransactionFilter>,\n         _ordering: miner::PendingOrdering,\n     ) -> Vec<Arc<VerifiedTransaction>> {\n-        self.queued_transactions()\n+        match filter {\n+            Some(f) => self\n+                .queued_transactions()\n+                .into_iter()\n+                .filter(|tx| f.matches(tx))\n+                .collect(),\n+            None => self.queued_transactions(),\n+        }\n     }\n \n     fn pending_transaction_hashes<C>(&self, _chain: &C) -> BTreeSet<H256> {\ndiff --git a/crates/rpc/src/v1/tests/mocked/parity.rs b/crates/rpc/src/v1/tests/mocked/parity.rs\n--- a/crates/rpc/src/v1/tests/mocked/parity.rs\n+++ b/crates/rpc/src/v1/tests/mocked/parity.rs\n@@ -19,7 +19,7 @@ use ethcore::client::{Executed, TestBlockChainClient, TransactionId};\n use ethcore_logger::RotatingLogger;\n use ethereum_types::{Address, BigEndianHash, Bloom, H256, U256};\n use miner::pool::local_transactions::Status as LocalTransactionStatus;\n-use std::sync::Arc;\n+use std::{str::FromStr, sync::Arc};\n use sync::ManageNetwork;\n use types::{\n     receipt::{LocalizedReceipt, TransactionOutcome},\ndiff --git a/crates/rpc/src/v1/tests/mocked/parity.rs b/crates/rpc/src/v1/tests/mocked/parity.rs\n--- a/crates/rpc/src/v1/tests/mocked/parity.rs\n+++ b/crates/rpc/src/v1/tests/mocked/parity.rs\n@@ -290,6 +290,85 @@ fn rpc_parity_pending_transactions() {\n     assert_eq!(io.handle_request_sync(request), Some(response.to_owned()));\n }\n \n+fn assert_txs_filtered(io: &IoHandler<Metadata>, filter: &str, expected: Vec<u8>) {\n+    let request = format!(\n+        r#\"{{\"jsonrpc\": \"2.0\", \"method\": \"parity_pendingTransactions\",\n+        \"params\":[10, {}], \"id\": 1}}\"#,\n+        filter\n+    );\n+    let response_str = io.handle_request_sync(&request).unwrap();\n+    let response = serde_json::Value::from_str(&response_str).unwrap();\n+    assert_eq!(response[\"result\"].as_array().unwrap().len(), expected.len());\n+    for n in expected {\n+        let expected_sender = format!(\"0x000000000000000000000000000000000000005{}\", n);\n+        assert!(response_str.contains(&expected_sender));\n+    }\n+}\n+\n+#[test]\n+fn rpc_parity_pending_transactions_with_filter() {\n+    use types::transaction::{Action, Transaction, TypedTransaction};\n+    let deps = Dependencies::new();\n+    let io = deps.default_client();\n+\n+    for i in 1..6 {\n+        let tx = TypedTransaction::Legacy(Transaction {\n+            value: i.into(),\n+            gas: (i + 0x10).into(),\n+            gas_price: (i + 0x20).into(),\n+            nonce: (i + 0x30).into(),\n+            action: Action::Call(Address::from_low_u64_be(i + 0x40)),\n+            data: vec![],\n+        })\n+        .fake_sign(Address::from_low_u64_be(i + 0x50));\n+        deps.miner\n+            .pending_transactions\n+            .lock()\n+            .insert(H256::from_low_u64_be(i + 0x60), tx);\n+    }\n+\n+    let tx = TypedTransaction::Legacy(Transaction {\n+        value: 0.into(),\n+        gas: 0x16.into(),\n+        gas_price: 0x26.into(),\n+        nonce: 0x36.into(),\n+        action: Action::Create,\n+        data: vec![0x01, 0x02, 0x03],\n+    })\n+    .fake_sign(Address::from_low_u64_be(0x56));\n+    deps.miner\n+        .pending_transactions\n+        .lock()\n+        .insert(H256::from_low_u64_be(0x66), tx);\n+\n+    assert_txs_filtered(\n+        &io,\n+        r#\"{\"from\":{\"eq\":\"0x0000000000000000000000000000000000000052\"}}\"#,\n+        vec![2],\n+    );\n+    assert_txs_filtered(\n+        &io,\n+        r#\"{\"to\":{\"eq\":\"0x0000000000000000000000000000000000000041\"}}\"#,\n+        vec![1],\n+    );\n+    assert_txs_filtered(&io, r#\"{\"to\":{\"action\":\"contract_creation\"}}\"#, vec![6]);\n+    assert_txs_filtered(&io, r#\"{\"gas\":{\"gt\":\"0x12\"}}\"#, vec![3, 4, 5, 6]);\n+    assert_txs_filtered(&io, r#\"{\"gasPrice\":{\"eq\":\"0x24\"}}\"#, vec![4]);\n+    assert_txs_filtered(&io, r#\"{\"nonce\":{\"lt\":\"0x33\"}}\"#, vec![1, 2]);\n+    assert_txs_filtered(&io, r#\"{\"value\":{\"lt\":\"0x2\"}}\"#, vec![1, 6]);\n+    assert_txs_filtered(\n+        &io,\n+        r#\"{\"value\":{\"gt\":\"0x1\"},\"gas\":{\"lt\":\"0x14\"}}\"#,\n+        vec![2, 3],\n+    );\n+    assert_txs_filtered(&io, r#\"{\"value\":{\"gt\":\"0x6\"},\"gas\":{\"gt\":\"0x1\"}}\"#, vec![]);\n+    assert_txs_filtered(\n+        &io,\n+        r#\"{\"value\":{\"lt\":\"0x60\"},\"nonce\":{\"lt\":\"0x60\"}}\"#,\n+        vec![1, 2, 3, 4, 5, 6],\n+    );\n+}\n+\n #[test]\n fn rpc_parity_encrypt() {\n     let deps = Dependencies::new();\ndiff --git a/crates/rpc/src/v1/types/mod.rs b/crates/rpc/src/v1/types/mod.rs\n--- a/crates/rpc/src/v1/types/mod.rs\n+++ b/crates/rpc/src/v1/types/mod.rs\n@@ -16,37 +16,6 @@\n \n //! RPC types\n \n-#[cfg(test)]\n-mod eth_types;\n-\n-mod account_info;\n-mod block;\n-mod block_number;\n-mod bytes;\n-mod call_request;\n-mod confirmations;\n-mod derivation;\n-mod eip191;\n-mod filter;\n-mod histogram;\n-mod index;\n-mod log;\n-mod node_kind;\n-mod provenance;\n-mod receipt;\n-mod rpc_settings;\n-mod secretstore;\n-mod sync;\n-mod trace;\n-mod trace_filter;\n-mod transaction;\n-mod transaction_access_list;\n-mod transaction_condition;\n-mod transaction_request;\n-mod work;\n-\n-pub mod pubsub;\n-\n pub use self::{\n     account_info::{AccountInfo, EthAccount, ExtAccountInfo, RecoveredAccount, StorageProof},\n     block::{Block, BlockTransactions, Header, Rich, RichBlock, RichHeader},\ndiff --git a/crates/rpc/src/v1/types/mod.rs b/crates/rpc/src/v1/types/mod.rs\n--- a/crates/rpc/src/v1/types/mod.rs\n+++ b/crates/rpc/src/v1/types/mod.rs\n@@ -82,6 +51,37 @@ pub use self::{\n     work::Work,\n };\n \n+#[cfg(test)]\n+mod eth_types;\n+\n+mod account_info;\n+mod block;\n+mod block_number;\n+mod bytes;\n+mod call_request;\n+mod confirmations;\n+mod derivation;\n+mod eip191;\n+mod filter;\n+mod histogram;\n+mod index;\n+mod log;\n+mod node_kind;\n+mod provenance;\n+mod receipt;\n+mod rpc_settings;\n+mod secretstore;\n+mod sync;\n+mod trace;\n+mod trace_filter;\n+mod transaction;\n+mod transaction_access_list;\n+mod transaction_condition;\n+mod transaction_request;\n+mod work;\n+\n+pub mod pubsub;\n+\n // TODO [ToDr] Refactor to a proper type Vec of enums?\n /// Expected tracing type.\n pub type TraceOptions = Vec<String>;\n",
        "problem_statement": "Can no longer apply filters to parity_pendingtransactions\nThis is a regression of https://github.com/openethereum/parity-ethereum/issues/11189. Using the request of the doc, OpenEthereum complains that only one parameter is accepted not 2.\n",
        "hints_text": "The reason is simple! https://github.com/openethereum/parity-ethereum/pull/10506 is no longer part of the commit history for some reason.\r\n@lamafab would it be possible to reimplment your pull request?\nFacing the same issue with\r\n\r\n```\r\nopenethereum --version\r\nOpenEthereum Client.\r\n  version OpenEthereum/v3.1.0-stable-94a784b-20201106/x86_64-macos/rustc1.47.0\r\nCopyright 2015-2020 Parity Technologies (UK) Ltd.\r\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\r\nThis is free software: you are free to change and redistribute it.\r\nThere is NO WARRANTY, to the extent permitted by law.\r\n\r\nBy Wood/Paronyan/Kotewicz/Drwi\u0119ga/Volf/Greeff\r\n   Habermeier/Czaban/Gotchac/Redman/Nikolsky\r\n   Schoedon/Tang/Adolfsson/Silva/Palm/Hirsz et al.\r\n```\n@ytrezq yeah I guess I could re-implement it again, it's not too hard. In the previous PR I wrote a custom `Deserialize` implementation, which was way overkill. `serde` offers attributes which handle most of the part, anyway. If the team thinks this should be included I can write a new PR. This time I'd appreciate it if people could tell me where the tests should go, and how to generate good test data (assuming there's a mechanism for that).\r\n\r\nEDIT: Sorry for the late response.\n@lamafab that would be great if you can help us. Just make pull request on `dev` branch. \nAny news on this breaking change?\n@pedrobranco I did not start with it yet, sorry.",
        "created_at": "2021-03-04T11:03:14Z",
        "version": "3.2"
    },
    {
        "repo": "openethereum/openethereum",
        "pull_number": 604,
        "instance_id": "openethereum__openethereum-604",
        "issue_numbers": [
            "496"
        ],
        "base_commit": "2e26d1d2f04c097699994c7032abb641e976ad8f",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -579,6 +579,16 @@ dependencies = [\n  \"itertools 0.8.1\",\n ]\n \n+[[package]]\n+name = \"crossbeam-channel\"\n+version = \"0.5.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e54ea8bc3fb1ee042f5aace6e3c6e025d3874866da222930f70ce62aceba0bfa\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"crossbeam-utils 0.8.6\",\n+]\n+\n [[package]]\n name = \"crossbeam-deque\"\n version = \"0.6.3\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -654,6 +664,16 @@ dependencies = [\n  \"lazy_static\",\n ]\n \n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.8.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cfcae03edb34f947e64acdb1c33ec169824e20657e9ecb61cef6c8c74dcb8120\"\n+dependencies = [\n+ \"cfg-if 1.0.0\",\n+ \"lazy_static\",\n+]\n+\n [[package]]\n name = \"crunchy\"\n version = \"0.1.6\"\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -979,6 +999,7 @@ dependencies = [\n  \"blooms-db\",\n  \"common-types\",\n  \"criterion 0.2.11\",\n+ \"crossbeam-channel\",\n  \"crossbeam-utils 0.6.6\",\n  \"derive_more\",\n  \"eip-152\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1322,11 +1343,13 @@ name = \"ethcore-sync\"\n version = \"1.12.0\"\n dependencies = [\n  \"common-types\",\n+ \"crossbeam-channel\",\n  \"derive_more\",\n  \"enum_primitive\",\n  \"env_logger\",\n  \"ethcore\",\n  \"ethcore-io\",\n+ \"ethcore-miner\",\n  \"ethcore-network\",\n  \"ethcore-network-devp2p\",\n  \"ethereum-forkid\",\ndiff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -2929,6 +2952,7 @@ dependencies = [\n  \"clap\",\n  \"cli-signer\",\n  \"common-types\",\n+ \"crossbeam-channel\",\n  \"ctrlc\",\n  \"dir\",\n  \"docopt\",\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -23,6 +23,7 @@ rpassword = \"1.0\"\n semver = \"0.9\"\n ansi_term = \"0.10\"\n parking_lot = \"0.11.1\"\n+crossbeam-channel = \"0.5.2\"\n regex = \"1.0\"\n atty = \"0.2.8\"\n toml = \"0.4\"\ndiff --git a/bin/oe/cli/mod.rs b/bin/oe/cli/mod.rs\n--- a/bin/oe/cli/mod.rs\n+++ b/bin/oe/cli/mod.rs\n@@ -718,6 +718,10 @@ usage! {\n             \"--max-round-blocks-to-import=[S]\",\n             \"Maximal number of blocks to import for each import round.\",\n \n+            ARG arg_new_transactions_stats_period: (u64) = 0u64, or |c: &Config| c.mining.as_ref()?.new_transactions_stats_period.clone(),\n+            \"--new-transactions-stats-period=[N]\",\n+            \"Specify number of blocks for which new transactions will be returned in a result of `parity_newTransactionsStats` RPC call. Setting this parameter to 0 will return only transactions imported during the current block. (default: 0)\",\n+\n         [\"Internal Options\"]\n             FLAG flag_can_restart: (bool) = false, or |_| None,\n             \"--can-restart\",\ndiff --git a/bin/oe/cli/mod.rs b/bin/oe/cli/mod.rs\n--- a/bin/oe/cli/mod.rs\n+++ b/bin/oe/cli/mod.rs\n@@ -990,6 +994,7 @@ struct Mining {\n     refuse_service_transactions: Option<bool>,\n     infinite_pending_block: Option<bool>,\n     max_round_blocks_to_import: Option<usize>,\n+    new_transactions_stats_period: Option<u64>,\n }\n \n #[derive(Default, Debug, PartialEq, Deserialize)]\ndiff --git a/bin/oe/configuration.rs b/bin/oe/configuration.rs\n--- a/bin/oe/configuration.rs\n+++ b/bin/oe/configuration.rs\n@@ -428,6 +428,7 @@ impl Configuration {\n                 custom_bootnodes: self.args.arg_bootnodes.is_some(),\n                 check_seal: !self.args.flag_no_seal_check,\n                 download_old_blocks: !self.args.flag_no_ancient_blocks,\n+                new_transactions_stats_period: self.args.arg_new_transactions_stats_period,\n                 verifier_settings: verifier_settings,\n                 no_persistent_txqueue: self.args.flag_no_persistent_txqueue,\n                 max_round_blocks_to_import: self.args.arg_max_round_blocks_to_import,\ndiff --git a/bin/oe/modules.rs b/bin/oe/modules.rs\n--- a/bin/oe/modules.rs\n+++ b/bin/oe/modules.rs\n@@ -26,12 +26,14 @@ use std::collections::BTreeSet;\n pub use crate::sync::{EthSync, ManageNetwork, SyncProvider};\n pub use ethcore::client::ChainNotify;\n use ethcore_logger::Config as LogConfig;\n+use ethereum_types::H256;\n \n pub type SyncModules = (\n     Arc<dyn SyncProvider>,\n     Arc<dyn ManageNetwork>,\n     Arc<dyn ChainNotify>,\n     mpsc::Sender<sync::PriorityTask>,\n+    crossbeam_channel::Sender<H256>,\n );\n \n pub fn sync(\ndiff --git a/bin/oe/modules.rs b/bin/oe/modules.rs\n--- a/bin/oe/modules.rs\n+++ b/bin/oe/modules.rs\n@@ -59,5 +61,6 @@ pub fn sync(\n         eth_sync.clone() as Arc<dyn ManageNetwork>,\n         eth_sync.clone() as Arc<dyn ChainNotify>,\n         eth_sync.priority_tasks(),\n+        eth_sync.new_transaction_hashes(),\n     ))\n }\ndiff --git a/bin/oe/run.rs b/bin/oe/run.rs\n--- a/bin/oe/run.rs\n+++ b/bin/oe/run.rs\n@@ -108,6 +108,7 @@ pub struct RunCmd {\n     pub check_seal: bool,\n     pub allow_missing_blocks: bool,\n     pub download_old_blocks: bool,\n+    pub new_transactions_stats_period: u64,\n     pub verifier_settings: VerifierSettings,\n     pub no_persistent_txqueue: bool,\n     pub max_round_blocks_to_import: usize,\ndiff --git a/bin/oe/run.rs b/bin/oe/run.rs\n--- a/bin/oe/run.rs\n+++ b/bin/oe/run.rs\n@@ -255,6 +256,7 @@ pub fn execute(cmd: RunCmd, logger: Arc<RotatingLogger>) -> Result<RunningClient\n     };\n     sync_config.download_old_blocks = cmd.download_old_blocks;\n     sync_config.eip1559_transition = spec.params().eip1559_transition;\n+    sync_config.new_transactions_stats_period = cmd.new_transactions_stats_period;\n \n     let passwords = passwords_from_files(&cmd.acc_conf.password_files)?;\n \ndiff --git a/bin/oe/run.rs b/bin/oe/run.rs\n--- a/bin/oe/run.rs\n+++ b/bin/oe/run.rs\n@@ -441,25 +443,26 @@ pub fn execute(cmd: RunCmd, logger: Arc<RotatingLogger>) -> Result<RunningClient\n     }\n \n     // create sync object\n-    let (sync_provider, manage_network, chain_notify, priority_tasks) = modules::sync(\n-        sync_config,\n-        net_conf.clone().into(),\n-        client.clone(),\n-        forks,\n-        snapshot_service.clone(),\n-        &cmd.logger_config,\n-        connection_filter\n-            .clone()\n-            .map(|f| f as Arc<dyn crate::sync::ConnectionFilter + 'static>),\n-    )\n-    .map_err(|e| format!(\"Sync error: {}\", e))?;\n+    let (sync_provider, manage_network, chain_notify, priority_tasks, new_transaction_hashes) =\n+        modules::sync(\n+            sync_config,\n+            net_conf.clone().into(),\n+            client.clone(),\n+            forks,\n+            snapshot_service.clone(),\n+            &cmd.logger_config,\n+            connection_filter\n+                .clone()\n+                .map(|f| f as Arc<dyn crate::sync::ConnectionFilter + 'static>),\n+        )\n+        .map_err(|e| format!(\"Sync error: {}\", e))?;\n \n     service.add_notify(chain_notify.clone());\n \n     // Propagate transactions as soon as they are imported.\n     let tx = ::parking_lot::Mutex::new(priority_tasks);\n     let is_ready = Arc::new(atomic::AtomicBool::new(true));\n-    miner.add_transactions_listener(Box::new(move |_hashes| {\n+    miner.add_transactions_listener(Box::new(move |hashes| {\n         // we want to have only one PendingTransactions task in the queue.\n         if is_ready\n             .compare_exchange(\ndiff --git a/bin/oe/run.rs b/bin/oe/run.rs\n--- a/bin/oe/run.rs\n+++ b/bin/oe/run.rs\n@@ -470,6 +473,11 @@ pub fn execute(cmd: RunCmd, logger: Arc<RotatingLogger>) -> Result<RunningClient\n             )\n             .is_ok()\n         {\n+            for hash in hashes {\n+                new_transaction_hashes\n+                    .send(hash.clone())\n+                    .expect(\"new_transaction_hashes receiving side is disconnected\");\n+            }\n             let task =\n                 crate::sync::PriorityTask::PropagateTransactions(Instant::now(), is_ready.clone());\n             // we ignore error cause it means that we are closing\ndiff --git a/crates/concensus/miner/src/pool/mod.rs b/crates/concensus/miner/src/pool/mod.rs\n--- a/crates/concensus/miner/src/pool/mod.rs\n+++ b/crates/concensus/miner/src/pool/mod.rs\n@@ -74,6 +74,9 @@ pub struct PendingSettings {\n     /// Value of score that is a boundary between includable and non-includable transactions\n     /// Before EIP1559 it should be equal to zero, after EIP1559 it should be equal to block_base_fee\n     pub includable_boundary: U256,\n+    /// If `true` all non-local transactions in the pending set should have\n+    /// `effective_priority_fee` to be at least `min_gas_price`.\n+    pub enforce_priority_fees: bool,\n }\n \n impl PendingSettings {\ndiff --git a/crates/concensus/miner/src/pool/mod.rs b/crates/concensus/miner/src/pool/mod.rs\n--- a/crates/concensus/miner/src/pool/mod.rs\n+++ b/crates/concensus/miner/src/pool/mod.rs\n@@ -86,6 +89,7 @@ impl PendingSettings {\n             max_len: usize::max_value(),\n             ordering: PendingOrdering::Priority,\n             includable_boundary: Default::default(),\n+            enforce_priority_fees: false,\n         }\n     }\n }\ndiff --git a/crates/concensus/miner/src/pool/mod.rs b/crates/concensus/miner/src/pool/mod.rs\n--- a/crates/concensus/miner/src/pool/mod.rs\n+++ b/crates/concensus/miner/src/pool/mod.rs\n@@ -124,6 +128,9 @@ pub trait ScoredTransaction {\n     /// Gets transaction gas price.\n     fn effective_gas_price(&self, block_base_fee: Option<U256>) -> U256;\n \n+    /// Gets the actual reward miner will get if the transaction is added into the current block.\n+    fn effective_priority_fee(&self, block_base_fee: Option<U256>) -> U256;\n+\n     /// Gets transaction nonce.\n     fn nonce(&self) -> U256;\n \ndiff --git a/crates/concensus/miner/src/pool/mod.rs b/crates/concensus/miner/src/pool/mod.rs\n--- a/crates/concensus/miner/src/pool/mod.rs\n+++ b/crates/concensus/miner/src/pool/mod.rs\n@@ -207,6 +214,10 @@ impl ScoredTransaction for VerifiedTransaction {\n         self.transaction.effective_gas_price(block_base_fee)\n     }\n \n+    fn effective_priority_fee(&self, block_base_fee: Option<U256>) -> U256 {\n+        self.transaction.effective_priority_fee(block_base_fee)\n+    }\n+\n     /// Gets transaction nonce.\n     fn nonce(&self) -> U256 {\n         self.transaction.tx().nonce\ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -230,7 +230,10 @@ pub struct TransactionQueue {\n     insertion_id: Arc<AtomicUsize>,\n     pool: RwLock<Pool>,\n     options: RwLock<verifier::Options>,\n-    cached_pending: RwLock<CachedPending>,\n+    /// Cached pending transactions got *with* priority fee enforcement.\n+    cached_enforced_pending: RwLock<CachedPending>,\n+    /// Cached pending transactions got *without* priority fee enforcement.\n+    cached_non_enforced_pending: RwLock<CachedPending>,\n     recently_rejected: RecentlyRejected,\n }\n \ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -253,7 +256,8 @@ impl TransactionQueue {\n                 limits,\n             )),\n             options: RwLock::new(verification_options),\n-            cached_pending: RwLock::new(CachedPending::none()),\n+            cached_enforced_pending: RwLock::new(CachedPending::none()),\n+            cached_non_enforced_pending: RwLock::new(CachedPending::none()),\n             recently_rejected: RecentlyRejected::new(cmp::max(\n                 MIN_REJECTED_CACHE_SIZE,\n                 max_count / 4,\ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -277,7 +281,8 @@ impl TransactionQueue {\n                 ScoringEvent::BlockBaseFeeChanged,\n             );\n \n-            self.cached_pending.write().clear();\n+            self.cached_enforced_pending.write().clear();\n+            self.cached_non_enforced_pending.write().clear();\n         }\n     }\n \ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -371,7 +376,8 @@ impl TransactionQueue {\n         (self.pool.write().listener_mut().1).0.notify();\n \n         if results.iter().any(|r| r.is_ok()) {\n-            self.cached_pending.write().clear();\n+            self.cached_enforced_pending.write().clear();\n+            self.cached_non_enforced_pending.write().clear();\n         }\n \n         results\ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -431,24 +437,34 @@ impl TransactionQueue {\n             max_len,\n             ordering,\n             includable_boundary,\n+            enforce_priority_fees,\n         } = settings;\n-        if let Some(pending) = self.cached_pending.read().pending(\n-            block_number,\n-            current_timestamp,\n-            nonce_cap.as_ref(),\n-            max_len,\n-        ) {\n+\n+        let cached = if enforce_priority_fees {\n+            &self.cached_enforced_pending\n+        } else {\n+            &self.cached_non_enforced_pending\n+        };\n+\n+        if let Some(pending) =\n+            cached\n+                .read()\n+                .pending(block_number, current_timestamp, nonce_cap.as_ref(), max_len)\n+        {\n             return pending;\n         }\n \n         // Double check after acquiring write lock\n-        let mut cached_pending = self.cached_pending.write();\n+        let mut cached_pending = cached.write();\n         if let Some(pending) =\n             cached_pending.pending(block_number, current_timestamp, nonce_cap.as_ref(), max_len)\n         {\n             return pending;\n         }\n \n+        let effective_priority_fee_filter =\n+            self.build_effective_priority_fee_filter(enforce_priority_fees, includable_boundary);\n+\n         // In case we don't have a cached set, but we don't care about order\n         // just return the unordered set.\n         if let PendingOrdering::Unordered = ordering {\ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -457,6 +473,7 @@ impl TransactionQueue {\n                 .pool\n                 .read()\n                 .unordered_pending(ready, includable_boundary)\n+                .filter(effective_priority_fee_filter)\n                 .take(max_len)\n                 .collect();\n         }\ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -467,7 +484,11 @@ impl TransactionQueue {\n             block_number,\n             current_timestamp,\n             nonce_cap,\n-            |i| i.take(max_len).collect(),\n+            |i| {\n+                i.filter(effective_priority_fee_filter)\n+                    .take(max_len)\n+                    .collect()\n+            },\n         );\n \n         *cached_pending = CachedPending {\ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -494,6 +515,10 @@ impl TransactionQueue {\n     where\n         C: client::NonceClient,\n     {\n+        let effective_priority_fee_filter = self.build_effective_priority_fee_filter(\n+            settings.enforce_priority_fees,\n+            settings.includable_boundary,\n+        );\n         self.collect_pending(\n             client,\n             settings.includable_boundary,\ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -502,6 +527,7 @@ impl TransactionQueue {\n             settings.nonce_cap,\n             |i| {\n                 i.filter(|tx| filter.matches(tx))\n+                    .filter(effective_priority_fee_filter)\n                     .take(settings.max_len)\n                     .collect()\n             },\ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -538,6 +564,28 @@ impl TransactionQueue {\n         collect(self.pool.read().pending(ready, includable_boundary))\n     }\n \n+    /// Depending on `enforce_priority_fees` parameter creates a filter that returns only\n+    /// external transactions with enough effective priority fee and local transactions,\n+    /// or a filter that just returns all transactions.\n+    fn build_effective_priority_fee_filter(\n+        &self,\n+        enforce_priority_fees: bool,\n+        includable_boundary: U256,\n+    ) -> Box<dyn Fn(&Arc<pool::VerifiedTransaction>) -> bool> {\n+        if enforce_priority_fees {\n+            let min_gas_price = self.status().options.minimal_gas_price;\n+            Box::new(move |tx| {\n+                tx.priority.is_local()\n+                    || tx\n+                        .transaction\n+                        .effective_priority_fee(Some(includable_boundary))\n+                        >= min_gas_price\n+            })\n+        } else {\n+            Box::new(|_| true)\n+        }\n+    }\n+\n     fn ready<C>(\n         client: C,\n         block_number: u64,\ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -634,7 +682,8 @@ impl TransactionQueue {\n         };\n \n         if results.iter().any(Option::is_some) {\n-            self.cached_pending.write().clear();\n+            self.cached_enforced_pending.write().clear();\n+            self.cached_non_enforced_pending.write().clear();\n         }\n \n         results\ndiff --git a/crates/concensus/miner/src/pool/verifier.rs b/crates/concensus/miner/src/pool/verifier.rs\n--- a/crates/concensus/miner/src/pool/verifier.rs\n+++ b/crates/concensus/miner/src/pool/verifier.rs\n@@ -135,6 +135,16 @@ impl Transaction {\n         }\n     }\n \n+    /// Return maximum transaction fee that may go to the miner:\n+    /// transaction gas price for non 1559 transactions or maxPriorityFeePerGas for 1559 transactions.\n+    pub fn max_priority_fee(&self) -> U256 {\n+        match *self {\n+            Transaction::Unverified(ref tx) => tx.max_priority_fee_per_gas(),\n+            Transaction::Retracted(ref tx) => tx.max_priority_fee_per_gas(),\n+            Transaction::Local(ref tx) => tx.max_priority_fee_per_gas(),\n+        }\n+    }\n+\n     /// Check if transaction has zero gas price\n     pub fn has_zero_gas_price(&self) -> bool {\n         match *self {\ndiff --git a/crates/concensus/miner/src/pool/verifier.rs b/crates/concensus/miner/src/pool/verifier.rs\n--- a/crates/concensus/miner/src/pool/verifier.rs\n+++ b/crates/concensus/miner/src/pool/verifier.rs\n@@ -254,19 +264,19 @@ impl<C: Client> txpool::Verifier<Transaction>\n         // or the effective minimal gas price in case the pool is full.\n \n         if !has_zero_gas_price && !is_own {\n-            let effective_priority_fee = tx.effective_priority_fee(self.options.block_base_fee);\n+            let max_priority_fee = tx.max_priority_fee();\n \n-            if effective_priority_fee < self.options.minimal_gas_price {\n+            if max_priority_fee < self.options.minimal_gas_price {\n                 trace!(\n                     target: \"txqueue\",\n                     \"[{:?}] Rejected tx below minimal gas price threshold: {} < {}\",\n                     hash,\n-                    effective_priority_fee,\n+                    max_priority_fee,\n                     self.options.minimal_gas_price,\n                 );\n                 bail!(transaction::Error::InsufficientGasPrice {\n                     minimal: self.options.minimal_gas_price,\n-                    got: effective_priority_fee,\n+                    got: max_priority_fee,\n                 });\n             }\n \ndiff --git a/crates/concensus/miner/src/pool/verifier.rs b/crates/concensus/miner/src/pool/verifier.rs\n--- a/crates/concensus/miner/src/pool/verifier.rs\n+++ b/crates/concensus/miner/src/pool/verifier.rs\n@@ -335,10 +345,9 @@ impl<C: Client> txpool::Verifier<Transaction>\n             }\n         }\n \n-        let effective_priority_fee =\n-            transaction.effective_priority_fee(self.options.block_base_fee);\n+        let max_priority_fee = transaction.max_priority_fee_per_gas();\n \n-        if effective_priority_fee < self.options.minimal_gas_price {\n+        if max_priority_fee < self.options.minimal_gas_price {\n             let transaction_type = self.client.transaction_type(&transaction);\n             if let TransactionType::Service = transaction_type {\n                 debug!(target: \"txqueue\", \"Service tx {:?} below minimal gas price accepted\", hash);\ndiff --git a/crates/concensus/miner/src/pool/verifier.rs b/crates/concensus/miner/src/pool/verifier.rs\n--- a/crates/concensus/miner/src/pool/verifier.rs\n+++ b/crates/concensus/miner/src/pool/verifier.rs\n@@ -349,12 +358,12 @@ impl<C: Client> txpool::Verifier<Transaction>\n                     target: \"txqueue\",\n                     \"[{:?}] Rejected tx below minimal gas price threshold: {} < {}\",\n                     hash,\n-                    effective_priority_fee,\n+                    max_priority_fee,\n                     self.options.minimal_gas_price,\n                 );\n                 bail!(transaction::Error::InsufficientGasPrice {\n                     minimal: self.options.minimal_gas_price,\n-                    got: effective_priority_fee,\n+                    got: max_priority_fee,\n                 });\n             }\n         }\ndiff --git a/crates/ethcore/Cargo.toml b/crates/ethcore/Cargo.toml\n--- a/crates/ethcore/Cargo.toml\n+++ b/crates/ethcore/Cargo.toml\n@@ -11,6 +11,7 @@ ansi_term = \"0.10\"\n blooms-db = { path = \"../db/blooms-db\", optional = true }\n common-types = { path = \"types\" }\n crossbeam-utils = \"0.6\"\n+crossbeam-channel = \"0.5.2\"\n eip-152 = { version = \"0.1\", path = \"../util/EIP-152\" }\n env_logger = { version = \"0.5\", optional = true }\n error-chain = { version = \"0.12\", default-features = false }\ndiff --git a/crates/ethcore/src/client/traits.rs b/crates/ethcore/src/client/traits.rs\n--- a/crates/ethcore/src/client/traits.rs\n+++ b/crates/ethcore/src/client/traits.rs\n@@ -384,6 +384,9 @@ pub trait BlockChainClient:\n     /// List all ready transactions that should be propagated to other peers.\n     fn transactions_to_propagate(&self) -> Vec<Arc<VerifiedTransaction>>;\n \n+    /// Get verified transaction with specified transaction hash.\n+    fn transaction(&self, tx_hash: &H256) -> Option<Arc<VerifiedTransaction>>;\n+\n     /// Sorted list of transaction gas prices from at least last sample_size blocks.\n     fn gas_price_corpus(&self, sample_size: usize) -> ::stats::Corpus<U256> {\n         let mut h = self.chain_info().best_block_hash;\ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -550,6 +550,7 @@ impl Miner {\n                     .engine\n                     .calculate_base_fee(&chain.best_block_header())\n                     .unwrap_or_default(),\n+                enforce_priority_fees: true,\n             },\n         );\n \ndiff --git a/crates/ethcore/src/miner/miner.rs b/crates/ethcore/src/miner/miner.rs\n--- a/crates/ethcore/src/miner/miner.rs\n+++ b/crates/ethcore/src/miner/miner.rs\n@@ -1207,6 +1208,7 @@ impl miner::MinerService for Miner {\n                     .engine\n                     .calculate_base_fee(&chain.best_block_header())\n                     .unwrap_or_default(),\n+                enforce_priority_fees: false,\n             };\n \n             if let Some(ref f) = filter {\ndiff --git a/crates/ethcore/sync/Cargo.toml b/crates/ethcore/sync/Cargo.toml\n--- a/crates/ethcore/sync/Cargo.toml\n+++ b/crates/ethcore/sync/Cargo.toml\n@@ -15,6 +15,7 @@ ethcore = { path = \"..\" }\n ethcore-io = { path = \"../../runtime/io\" }\n ethcore-network = { path = \"../../net/network\" }\n ethcore-network-devp2p = { path = \"../../net/network-devp2p\" }\n+ethcore-miner = { path = \"../../concensus/miner\" }\n ethereum-forkid = \"0.2\"\n primitive_types07 = { package = \"primitive-types\", version = \"0.7\"}\n ethereum-types = \"0.9.2\"\ndiff --git a/crates/ethcore/sync/Cargo.toml b/crates/ethcore/sync/Cargo.toml\n--- a/crates/ethcore/sync/Cargo.toml\n+++ b/crates/ethcore/sync/Cargo.toml\n@@ -37,6 +38,7 @@ rlp = { version = \"0.4.6\" }\n trace-time = \"0.1\"\n triehash-ethereum = {version = \"0.2\", path = \"../../util/triehash-ethereum\" }\n stats = { path = \"../../util/stats\" }\n+crossbeam-channel = \"0.5.2\"\n \n [dev-dependencies]\n env_logger = \"0.5\"\ndiff --git a/crates/ethcore/sync/src/api.rs b/crates/ethcore/sync/src/api.rs\n--- a/crates/ethcore/sync/src/api.rs\n+++ b/crates/ethcore/sync/src/api.rs\n@@ -112,6 +112,8 @@ pub struct SyncConfig {\n     pub warp_sync: WarpSync,\n     /// Number of first block where EIP-1559 rules begin. New encoding/decoding block format.\n     pub eip1559_transition: BlockNumber,\n+    /// Number of blocks for which new transactions will be returned in a result of `parity_newTransactionsStats` RPC call\n+    pub new_transactions_stats_period: u64,\n }\n \n impl Default for SyncConfig {\ndiff --git a/crates/ethcore/sync/src/api.rs b/crates/ethcore/sync/src/api.rs\n--- a/crates/ethcore/sync/src/api.rs\n+++ b/crates/ethcore/sync/src/api.rs\n@@ -124,6 +126,7 @@ impl Default for SyncConfig {\n             fork_block: None,\n             warp_sync: WarpSync::Disabled,\n             eip1559_transition: BlockNumber::max_value(),\n+            new_transactions_stats_period: 0,\n         }\n     }\n }\ndiff --git a/crates/ethcore/sync/src/api.rs b/crates/ethcore/sync/src/api.rs\n--- a/crates/ethcore/sync/src/api.rs\n+++ b/crates/ethcore/sync/src/api.rs\n@@ -140,7 +143,10 @@ pub trait SyncProvider: Send + Sync + PrometheusMetrics {\n     fn enode(&self) -> Option<String>;\n \n     /// Returns propagation count for pending transactions.\n-    fn transactions_stats(&self) -> BTreeMap<H256, TransactionStats>;\n+    fn pending_transactions_stats(&self) -> BTreeMap<H256, TransactionStats>;\n+\n+    /// Returns propagation count for new transactions.\n+    fn new_transactions_stats(&self) -> BTreeMap<H256, TransactionStats>;\n }\n \n /// Transaction stats\ndiff --git a/crates/ethcore/sync/src/api.rs b/crates/ethcore/sync/src/api.rs\n--- a/crates/ethcore/sync/src/api.rs\n+++ b/crates/ethcore/sync/src/api.rs\n@@ -237,6 +243,8 @@ pub struct EthSync {\n     subprotocol_name: ProtocolId,\n     /// Priority tasks notification channel\n     priority_tasks: Mutex<mpsc::Sender<PriorityTask>>,\n+    /// New incoming transactions notification channel\n+    new_transaction_hashes: crossbeam_channel::Sender<H256>,\n }\n \n impl EthSync {\ndiff --git a/crates/ethcore/sync/src/api.rs b/crates/ethcore/sync/src/api.rs\n--- a/crates/ethcore/sync/src/api.rs\n+++ b/crates/ethcore/sync/src/api.rs\n@@ -246,6 +254,7 @@ impl EthSync {\n         connection_filter: Option<Arc<dyn ConnectionFilter>>,\n     ) -> Result<Arc<EthSync>, Error> {\n         let (priority_tasks_tx, priority_tasks_rx) = mpsc::channel();\n+        let (new_transaction_hashes_tx, new_transaction_hashes_rx) = crossbeam_channel::unbounded();\n         let fork_filter = ForkFilterApi::new(&*params.chain, params.forks);\n \n         let sync = ChainSyncApi::new(\ndiff --git a/crates/ethcore/sync/src/api.rs b/crates/ethcore/sync/src/api.rs\n--- a/crates/ethcore/sync/src/api.rs\n+++ b/crates/ethcore/sync/src/api.rs\n@@ -253,6 +262,7 @@ impl EthSync {\n             &*params.chain,\n             fork_filter,\n             priority_tasks_rx,\n+            new_transaction_hashes_rx,\n         );\n         let service = NetworkService::new(\n             params.network_config.clone().into_basic()?,\ndiff --git a/crates/ethcore/sync/src/api.rs b/crates/ethcore/sync/src/api.rs\n--- a/crates/ethcore/sync/src/api.rs\n+++ b/crates/ethcore/sync/src/api.rs\n@@ -269,6 +279,7 @@ impl EthSync {\n             }),\n             subprotocol_name: params.config.subprotocol_name,\n             priority_tasks: Mutex::new(priority_tasks_tx),\n+            new_transaction_hashes: new_transaction_hashes_tx,\n         });\n \n         Ok(sync)\ndiff --git a/crates/ethcore/sync/src/api.rs b/crates/ethcore/sync/src/api.rs\n--- a/crates/ethcore/sync/src/api.rs\n+++ b/crates/ethcore/sync/src/api.rs\n@@ -278,6 +289,11 @@ impl EthSync {\n     pub fn priority_tasks(&self) -> mpsc::Sender<PriorityTask> {\n         self.priority_tasks.lock().clone()\n     }\n+\n+    /// New transactions hashes producer\n+    pub fn new_transaction_hashes(&self) -> crossbeam_channel::Sender<H256> {\n+        self.new_transaction_hashes.clone()\n+    }\n }\n \n impl SyncProvider for EthSync {\ndiff --git a/crates/ethcore/sync/src/api.rs b/crates/ethcore/sync/src/api.rs\n--- a/crates/ethcore/sync/src/api.rs\n+++ b/crates/ethcore/sync/src/api.rs\n@@ -321,8 +337,12 @@ impl SyncProvider for EthSync {\n         self.network.external_url()\n     }\n \n-    fn transactions_stats(&self) -> BTreeMap<H256, TransactionStats> {\n-        self.eth_handler.sync.transactions_stats()\n+    fn pending_transactions_stats(&self) -> BTreeMap<H256, TransactionStats> {\n+        self.eth_handler.sync.pending_transactions_stats()\n+    }\n+\n+    fn new_transactions_stats(&self) -> BTreeMap<H256, TransactionStats> {\n+        self.eth_handler.sync.new_transactions_stats()\n     }\n }\n \ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -426,9 +426,15 @@ impl ChainSyncApi {\n         chain: &dyn BlockChainClient,\n         fork_filter: ForkFilterApi,\n         priority_tasks: mpsc::Receiver<PriorityTask>,\n+        new_transaction_hashes: crossbeam_channel::Receiver<H256>,\n     ) -> Self {\n         ChainSyncApi {\n-            sync: RwLock::new(ChainSync::new(config, chain, fork_filter)),\n+            sync: RwLock::new(ChainSync::new(\n+                config,\n+                chain,\n+                fork_filter,\n+                new_transaction_hashes,\n+            )),\n             priority_tasks: Mutex::new(priority_tasks),\n         }\n     }\ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -449,11 +455,21 @@ impl ChainSyncApi {\n         self.sync.read().status()\n     }\n \n-    /// Returns transactions propagation statistics\n-    pub fn transactions_stats(&self) -> BTreeMap<H256, ::TransactionStats> {\n+    /// Returns pending transactions propagation statistics\n+    pub fn pending_transactions_stats(&self) -> BTreeMap<H256, ::TransactionStats> {\n         self.sync\n             .read()\n-            .transactions_stats()\n+            .pending_transactions_stats()\n+            .iter()\n+            .map(|(hash, stats)| (*hash, stats.into()))\n+            .collect()\n+    }\n+\n+    /// Returns new transactions propagation statistics\n+    pub fn new_transactions_stats(&self) -> BTreeMap<H256, ::TransactionStats> {\n+        self.sync\n+            .read()\n+            .new_transactions_stats()\n             .iter()\n             .map(|(hash, stats)| (*hash, stats.into()))\n             .collect()\ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -542,7 +558,8 @@ impl ChainSyncApi {\n                     debug!(target: \"sync\", \"Finished block propagation, took {}ms\", as_ms(started));\n                 }\n                 PriorityTask::PropagateTransactions(time, _) => {\n-                    SyncPropagator::propagate_new_transactions(&mut sync, io, || {\n+                    let hashes = sync.new_transaction_hashes(None);\n+                    SyncPropagator::propagate_new_transactions(&mut sync, io, hashes, || {\n                         check_deadline(deadline).is_some()\n                     });\n                     debug!(target: \"sync\", \"Finished transaction propagation, took {}ms\", as_ms(time));\ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -691,6 +708,8 @@ pub struct ChainSync {\n     delayed_requests_ids: HashSet<(PeerId, u8)>,\n     /// Sync start timestamp. Measured when first peer is connected\n     sync_start_time: Option<Instant>,\n+    /// Receiver of transactions that came after last propagation and should be broadcast\n+    new_transaction_hashes: crossbeam_channel::Receiver<H256>,\n     /// Transactions propagation statistics\n     transactions_stats: TransactionsStats,\n     /// Enable ancient block downloading\ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -699,6 +718,8 @@ pub struct ChainSync {\n     warp_sync: WarpSync,\n     /// New block encoding/decoding format is introduced by the EIP1559\n     eip1559_transition: BlockNumber,\n+    /// Number of blocks for which new transactions will be returned in a result of `parity_newTransactionsStats` RPC call\n+    new_transactions_stats_period: BlockNumber,\n }\n \n #[derive(Debug, Default)]\ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -755,6 +776,7 @@ impl ChainSync {\n         config: SyncConfig,\n         chain: &dyn BlockChainClient,\n         fork_filter: ForkFilterApi,\n+        new_transaction_hashes: crossbeam_channel::Receiver<H256>,\n     ) -> Self {\n         let chain_info = chain.chain_info();\n         let best_block = chain.chain_info().best_block_number;\ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -782,9 +804,11 @@ impl ChainSync {\n             download_old_blocks: config.download_old_blocks,\n             snapshot: Snapshot::new(),\n             sync_start_time: None,\n+            new_transaction_hashes,\n             transactions_stats: TransactionsStats::default(),\n             warp_sync: config.warp_sync,\n             eip1559_transition: config.eip1559_transition,\n+            new_transactions_stats_period: config.new_transactions_stats_period,\n         };\n         sync.update_targets(chain);\n         sync\ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -842,9 +866,42 @@ impl ChainSync {\n         })\n     }\n \n-    /// Returns transactions propagation statistics\n-    pub fn transactions_stats(&self) -> &H256FastMap<TransactionStats> {\n-        self.transactions_stats.stats()\n+    /// Returns pending transactions propagation statistics\n+    pub fn pending_transactions_stats(&self) -> &H256FastMap<TransactionStats> {\n+        self.transactions_stats.pending_transactions_stats()\n+    }\n+\n+    /// Returns new transactions propagation statistics\n+    pub fn new_transactions_stats(&self) -> &H256FastMap<TransactionStats> {\n+        self.transactions_stats.new_transactions_stats()\n+    }\n+\n+    /// Get transaction hashes that were imported but not yet processed,\n+    /// but no more than `max_len` if provided.\n+    pub fn new_transaction_hashes(&self, max_len: Option<usize>) -> Vec<H256> {\n+        let size = std::cmp::min(\n+            self.new_transaction_hashes.len(),\n+            max_len.unwrap_or(usize::MAX),\n+        );\n+        let mut hashes = Vec::with_capacity(size);\n+        for _ in 0..size {\n+            match self.new_transaction_hashes.try_recv() {\n+                Ok(hash) => hashes.push(hash),\n+                Err(err) => {\n+                    // In general that should not be the case as the `size`\n+                    // must not be greater than number of messages in the channel.\n+                    // However if any error occurs we just log it for further analysis and break the loop.\n+                    debug!(target: \"sync\", \"Error while receiving new transaction hashes: {}\", err);\n+                    break;\n+                }\n+            }\n+        }\n+        trace!(\n+            target: \"sync\",\n+            \"New transaction hashes received for processing. Expected: {}. Actual: {}\",\n+            size, hashes.len()\n+        );\n+        hashes\n     }\n \n     /// Updates transactions were received by a peer\ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -1590,7 +1647,7 @@ impl ChainSync {\n     /// propagates new transactions to all peers\n     pub fn propagate_new_transactions(&mut self, io: &mut dyn SyncIo) {\n         let deadline = Instant::now() + Duration::from_millis(500);\n-        SyncPropagator::propagate_new_transactions(self, io, || {\n+        SyncPropagator::propagate_ready_transactions(self, io, || {\n             if deadline > Instant::now() {\n                 true\n             } else {\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -31,6 +31,8 @@ use super::{\n     random, ChainSync, ETH_PROTOCOL_VERSION_65, MAX_PEERS_PROPAGATION, MAX_PEER_LAG_PROPAGATION,\n     MAX_TRANSACTION_PACKET_SIZE, MIN_PEERS_PROPAGATION,\n };\n+use ethcore_miner::pool::VerifiedTransaction;\n+use std::sync::Arc;\n \n const NEW_POOLED_HASHES_LIMIT: usize = 4096;\n \ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -101,59 +103,25 @@ impl SyncPropagator {\n     pub fn propagate_new_transactions<F: FnMut() -> bool>(\n         sync: &mut ChainSync,\n         io: &mut dyn SyncIo,\n-        mut should_continue: F,\n+        tx_hashes: Vec<H256>,\n+        should_continue: F,\n     ) -> usize {\n-        // Early out if nobody to send to.\n-        if sync.peers.is_empty() {\n-            return 0;\n-        }\n-\n-        let transactions = io.chain().transactions_to_propagate();\n-        if transactions.is_empty() {\n-            return 0;\n-        }\n-\n-        if !should_continue() {\n-            return 0;\n-        }\n-\n-        let (transactions, service_transactions): (Vec<_>, Vec<_>) = transactions\n-            .iter()\n-            .map(|tx| tx.signed())\n-            .partition(|tx| !tx.tx().gas_price.is_zero());\n-\n-        // usual transactions could be propagated to all peers\n-        let mut affected_peers = HashSet::new();\n-        if !transactions.is_empty() {\n-            let peers = SyncPropagator::select_peers_for_transactions(sync, |_| true);\n-            affected_peers = SyncPropagator::propagate_transactions_to_peers(\n-                sync,\n-                io,\n-                peers,\n-                transactions,\n-                &mut should_continue,\n-            );\n-        }\n-\n-        // most of times service_transactions will be empty\n-        // => there's no need to merge packets\n-        if !service_transactions.is_empty() {\n-            let service_transactions_peers =\n-                SyncPropagator::select_peers_for_transactions(sync, |peer_id| {\n-                    io.peer_version(*peer_id).accepts_service_transaction()\n-                });\n-            let service_transactions_affected_peers =\n-                SyncPropagator::propagate_transactions_to_peers(\n-                    sync,\n-                    io,\n-                    service_transactions_peers,\n-                    service_transactions,\n-                    &mut should_continue,\n-                );\n-            affected_peers.extend(&service_transactions_affected_peers);\n-        }\n+        let transactions = move |io: &dyn SyncIo| {\n+            tx_hashes\n+                .iter()\n+                .filter_map(|hash| io.chain().transaction(hash))\n+                .collect()\n+        };\n+        SyncPropagator::propagate_transactions(sync, io, transactions, true, should_continue)\n+    }\n \n-        affected_peers.len()\n+    pub fn propagate_ready_transactions<F: FnMut() -> bool>(\n+        sync: &mut ChainSync,\n+        io: &mut dyn SyncIo,\n+        should_continue: F,\n+    ) -> usize {\n+        let transactions = |io: &dyn SyncIo| io.chain().transactions_to_propagate();\n+        SyncPropagator::propagate_transactions(sync, io, transactions, false, should_continue)\n     }\n \n     fn propagate_transactions_to_peers<F: FnMut() -> bool>(\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -161,6 +129,7 @@ impl SyncPropagator {\n         io: &mut dyn SyncIo,\n         peers: Vec<PeerId>,\n         transactions: Vec<&SignedTransaction>,\n+        are_new: bool,\n         mut should_continue: F,\n     ) -> HashSet<PeerId> {\n         let all_transactions_hashes = transactions\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -177,8 +146,15 @@ impl SyncPropagator {\n         let all_transactions_hashes_rlp =\n             rlp::encode_list(&all_transactions_hashes.iter().copied().collect::<Vec<_>>());\n \n-        // Clear old transactions from stats\n-        sync.transactions_stats.retain(&all_transactions_hashes);\n+        let block_number = io.chain().chain_info().best_block_number;\n+\n+        if are_new {\n+            sync.transactions_stats\n+                .retain_new(block_number, sync.new_transactions_stats_period);\n+        } else {\n+            sync.transactions_stats\n+                .retain_pending(&all_transactions_hashes);\n+        }\n \n         let send_packet = |io: &mut dyn SyncIo,\n                            peer_id: PeerId,\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -199,7 +175,6 @@ impl SyncPropagator {\n             trace!(target: \"sync\", \"{:02} <- {} ({} entries; {} bytes)\", peer_id, if is_hashes { \"NewPooledTransactionHashes\" } else { \"Transactions\" }, sent, size);\n         };\n \n-        let block_number = io.chain().chain_info().best_block_number;\n         let mut sent_to_peers = HashSet::new();\n         let mut max_sent = 0;\n \ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -221,7 +196,7 @@ impl SyncPropagator {\n                 // update stats\n                 for hash in &all_transactions_hashes {\n                     let id = io.peer_session_info(peer_id).and_then(|info| info.id);\n-                    stats.propagated(hash, id, block_number);\n+                    stats.propagated(hash, are_new, id, block_number);\n                 }\n                 peer_info.last_sent_transactions = all_transactions_hashes.clone();\n \ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -278,10 +253,10 @@ impl SyncPropagator {\n                 (packet, to_send_new)\n             };\n \n-            // Update stats\n+            // Update stats.\n             let id = io.peer_session_info(peer_id).and_then(|info| info.id);\n             for hash in &to_send {\n-                stats.propagated(hash, id, block_number);\n+                stats.propagated(hash, are_new, id, block_number);\n             }\n \n             peer_info.last_sent_transactions = all_transactions_hashes\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -352,21 +327,28 @@ impl SyncPropagator {\n         }\n     }\n \n-    fn select_peers_for_transactions<F>(sync: &ChainSync, filter: F) -> Vec<PeerId>\n+    fn select_peers_for_transactions<F>(sync: &ChainSync, filter: F, are_new: bool) -> Vec<PeerId>\n     where\n         F: Fn(&PeerId) -> bool,\n     {\n-        // sqrt(x)/x scaled to max u32\n-        let fraction =\n-            ((sync.peers.len() as f64).powf(-0.5) * (u32::max_value() as f64).round()) as u32;\n-        let small = sync.peers.len() < MIN_PEERS_PROPAGATION;\n+        let fraction_filter: Box<dyn FnMut(&PeerId) -> bool> = if are_new {\n+            // We propagate new transactions to all peers initially.\n+            Box::new(|_| true)\n+        } else {\n+            // Otherwise, we propagate transaction only to squire root of all peers.\n+            let mut random = random::new();\n+            // sqrt(x)/x scaled to max u32\n+            let fraction =\n+                ((sync.peers.len() as f64).powf(-0.5) * (u32::max_value() as f64).round()) as u32;\n+            let small = sync.peers.len() < MIN_PEERS_PROPAGATION;\n+            Box::new(move |_| small || random.next_u32() < fraction)\n+        };\n \n-        let mut random = random::new();\n         sync.peers\n             .keys()\n             .cloned()\n             .filter(filter)\n-            .filter(|_| small || random.next_u32() < fraction)\n+            .filter(fraction_filter)\n             .take(MAX_PEERS_PROPAGATION)\n             .collect()\n     }\ndiff --git a/crates/ethcore/sync/src/lib.rs b/crates/ethcore/sync/src/lib.rs\n--- a/crates/ethcore/sync/src/lib.rs\n+++ b/crates/ethcore/sync/src/lib.rs\n@@ -37,6 +37,7 @@ extern crate parity_bytes as bytes;\n extern crate parity_crypto as crypto;\n #[macro_use]\n extern crate parity_util_mem;\n+extern crate crossbeam_channel;\n extern crate parking_lot;\n extern crate primitive_types07;\n extern crate rand;\ndiff --git a/crates/ethcore/sync/src/lib.rs b/crates/ethcore/sync/src/lib.rs\n--- a/crates/ethcore/sync/src/lib.rs\n+++ b/crates/ethcore/sync/src/lib.rs\n@@ -60,6 +61,7 @@ extern crate macros;\n extern crate log;\n #[macro_use]\n extern crate trace_time;\n+extern crate ethcore_miner;\n \n mod block_sync;\n mod blocks;\ndiff --git a/crates/ethcore/sync/src/transactions_stats.rs b/crates/ethcore/sync/src/transactions_stats.rs\n--- a/crates/ethcore/sync/src/transactions_stats.rs\n+++ b/crates/ethcore/sync/src/transactions_stats.rs\n@@ -56,6 +56,7 @@ impl<'a> From<&'a Stats> for TransactionStats {\n #[derive(Debug, Default)]\n pub struct TransactionsStats {\n     pending_transactions: H256FastMap<Stats>,\n+    new_transactions: H256FastMap<Stats>,\n }\n \n impl TransactionsStats {\ndiff --git a/crates/rpc/src/v1/impls/parity.rs b/crates/rpc/src/v1/impls/parity.rs\n--- a/crates/rpc/src/v1/impls/parity.rs\n+++ b/crates/rpc/src/v1/impls/parity.rs\n@@ -301,7 +301,15 @@ where\n     }\n \n     fn pending_transactions_stats(&self) -> Result<BTreeMap<H256, TransactionStats>> {\n-        let stats = self.sync.transactions_stats();\n+        let stats = self.sync.pending_transactions_stats();\n+        Ok(stats\n+            .into_iter()\n+            .map(|(hash, stats)| (hash, stats.into()))\n+            .collect())\n+    }\n+\n+    fn new_transactions_stats(&self) -> Result<BTreeMap<H256, TransactionStats>> {\n+        let stats = self.sync.new_transactions_stats();\n         Ok(stats\n             .into_iter()\n             .map(|(hash, stats)| (hash, stats.into()))\ndiff --git a/crates/rpc/src/v1/traits/parity.rs b/crates/rpc/src/v1/traits/parity.rs\n--- a/crates/rpc/src/v1/traits/parity.rs\n+++ b/crates/rpc/src/v1/traits/parity.rs\n@@ -158,6 +158,10 @@ pub trait Parity {\n     #[rpc(name = \"parity_pendingTransactionsStats\")]\n     fn pending_transactions_stats(&self) -> Result<BTreeMap<H256, TransactionStats>>;\n \n+    /// Returns propagation statistics on transactions recently added into the queue.\n+    #[rpc(name = \"parity_newTransactionsStats\")]\n+    fn new_transactions_stats(&self) -> Result<BTreeMap<H256, TransactionStats>>;\n+\n     /// Returns a list of current and past local transactions with status details.\n     #[rpc(name = \"parity_localTransactions\")]\n     fn local_transactions(&self) -> Result<BTreeMap<H256, LocalTransactionStatus>>;\n",
        "test_patch": "diff --git a/bin/oe/cli/mod.rs b/bin/oe/cli/mod.rs\n--- a/bin/oe/cli/mod.rs\n+++ b/bin/oe/cli/mod.rs\n@@ -1399,6 +1404,7 @@ mod tests {\n                 flag_refuse_service_transactions: false,\n                 flag_infinite_pending_block: false,\n                 arg_max_round_blocks_to_import: 1usize,\n+                arg_new_transactions_stats_period: 0u64,\n \n                 flag_stratum: false,\n                 arg_stratum_interface: \"local\".to_owned(),\ndiff --git a/bin/oe/cli/mod.rs b/bin/oe/cli/mod.rs\n--- a/bin/oe/cli/mod.rs\n+++ b/bin/oe/cli/mod.rs\n@@ -1606,6 +1612,7 @@ mod tests {\n                     refuse_service_transactions: None,\n                     infinite_pending_block: None,\n                     max_round_blocks_to_import: None,\n+                    new_transactions_stats_period: None,\n                 }),\n                 footprint: Some(Footprint {\n                     tracing: Some(\"on\".into()),\ndiff --git a/bin/oe/cli/tests/config.full.toml b/bin/oe/cli/tests/config.full.toml\n--- a/bin/oe/cli/tests/config.full.toml\n+++ b/bin/oe/cli/tests/config.full.toml\n@@ -101,6 +101,7 @@ extra_data = \"Parity\"\n remove_solved = false\n notify_work = [\"http://localhost:3001\"]\n refuse_service_transactions = false\n+new_transactions_stats_period = 0\n \n [footprint]\n tracing = \"auto\"\ndiff --git a/bin/oe/configuration.rs b/bin/oe/configuration.rs\n--- a/bin/oe/configuration.rs\n+++ b/bin/oe/configuration.rs\n@@ -1564,6 +1565,7 @@ mod tests {\n             stratum: None,\n             check_seal: true,\n             download_old_blocks: true,\n+            new_transactions_stats_period: 0,\n             verifier_settings: Default::default(),\n             no_persistent_txqueue: false,\n             max_round_blocks_to_import: 1,\ndiff --git a/crates/concensus/miner/src/pool/queue.rs b/crates/concensus/miner/src/pool/queue.rs\n--- a/crates/concensus/miner/src/pool/queue.rs\n+++ b/crates/concensus/miner/src/pool/queue.rs\n@@ -725,8 +774,13 @@ impl TransactionQueue {\n \n     /// Check if pending set is cached.\n     #[cfg(test)]\n-    pub fn is_pending_cached(&self) -> bool {\n-        self.cached_pending.read().pending.is_some()\n+    pub fn is_enforced_pending_cached(&self) -> bool {\n+        self.cached_enforced_pending.read().pending.is_some()\n+    }\n+\n+    #[cfg(test)]\n+    pub fn is_non_enforced_pending_cached(&self) -> bool {\n+        self.cached_non_enforced_pending.read().pending.is_some()\n     }\n }\n \ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -19,7 +19,10 @@ use hash::KECCAK_EMPTY;\n use txpool;\n use types::transaction::{self, PendingTransaction};\n \n-use pool::{verifier, PendingOrdering, PendingSettings, PrioritizationStrategy, TransactionQueue};\n+use pool::{\n+    transaction_filter::TransactionFilter, verifier, PendingOrdering, PendingSettings,\n+    PrioritizationStrategy, TransactionQueue,\n+};\n \n pub mod client;\n pub mod tx;\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -38,7 +41,7 @@ const TEST_QUEUE_MAX_MEM: usize = 100;\n fn new_queue() -> TransactionQueue {\n     TransactionQueue::new(\n         txpool::Options {\n-            max_count: 3,\n+            max_count: 4,\n             max_per_sender: 3,\n             max_mem_usage: TEST_QUEUE_MAX_MEM,\n         },\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -276,6 +279,35 @@ fn should_import_transaction_below_min_gas_price_threshold_if_local() {\n     assert_eq!(txq.status().status.transaction_count, 1);\n }\n \n+#[test]\n+fn should_import_transaction_with_priority_fee_above_min_gas_price_threshold_but_max_fee_below_current_base_fee_if_external(\n+) {\n+    // given\n+    let txq = new_queue();\n+    txq.set_verifier_options(verifier::Options {\n+        minimal_gas_price: 3.into(),\n+        block_base_fee: Some(10.into()),\n+        ..Default::default()\n+    });\n+    // when\n+    let tx1 = Tx::gas_price(3).signed(); // Legacy transaction\n+    let client = TestClient::new().with_balance(1_000_000);\n+    let res = txq.import(client, vec![tx1.unverified()]);\n+\n+    // then\n+    assert_eq!(res, vec![Ok(())]);\n+    assert_eq!(txq.status().status.transaction_count, 1);\n+\n+    // when\n+    let tx2 = Tx::gas_price(5).eip1559_one(3); // EIP1559 transaction\n+    let client = TestClient::new().with_balance(1_000_000);\n+    let res = txq.import(client, vec![tx2.unverified()]);\n+\n+    // then\n+    assert_eq!(res, vec![Ok(())]);\n+    assert_eq!(txq.status().status.transaction_count, 2);\n+}\n+\n #[test]\n fn should_reject_transaction_from_non_eoa_if_non_eoa_sender_is_not_allowed() {\n     // given\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -954,7 +986,16 @@ fn should_not_accept_external_service_transaction_if_sender_not_certified() {\n }\n \n #[test]\n-fn should_not_return_transactions_over_nonce_cap() {\n+fn should_not_return_transactions_over_nonce_cap_with_enforced_fees() {\n+    should_not_return_transactions_over_nonce_cap(true)\n+}\n+\n+#[test]\n+fn should_not_return_transactions_over_nonce_cap_with_non_enforced_fees() {\n+    should_not_return_transactions_over_nonce_cap(false)\n+}\n+\n+fn should_not_return_transactions_over_nonce_cap(enforce_priority_fees: bool) {\n     // given\n     let txq = new_queue();\n     let (tx1, tx2, tx3) = Tx::default().signed_triple();\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -973,6 +1014,7 @@ fn should_not_return_transactions_over_nonce_cap() {\n             max_len: usize::max_value(),\n             ordering: PendingOrdering::Priority,\n             includable_boundary: Default::default(),\n+            enforce_priority_fees,\n         },\n     );\n \ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -982,7 +1024,16 @@ fn should_not_return_transactions_over_nonce_cap() {\n }\n \n #[test]\n-fn should_return_cached_pending_even_if_unordered_is_requested() {\n+fn should_return_cached_pending_even_if_unordered_is_requested_with_enforced_fees() {\n+    should_return_cached_pending_even_if_unordered_is_requested(true)\n+}\n+\n+#[test]\n+fn should_return_cached_pending_even_if_unordered_is_requested_with_non_enforced_fees() {\n+    should_return_cached_pending_even_if_unordered_is_requested(false)\n+}\n+\n+fn should_return_cached_pending_even_if_unordered_is_requested(enforce_priority_fees: bool) {\n     // given\n     let txq = new_queue();\n     let tx1 = Tx::default().signed();\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -994,7 +1045,18 @@ fn should_return_cached_pending_even_if_unordered_is_requested() {\n     assert_eq!(res, vec![Ok(()), Ok(())]);\n \n     // when\n-    let all = txq.pending(TestClient::new(), PendingSettings::all_prioritized(0, 0));\n+    let all = txq.pending(\n+        TestClient::new(),\n+        PendingSettings {\n+            block_number: 0,\n+            current_timestamp: 0,\n+            nonce_cap: None,\n+            max_len: 3,\n+            ordering: PendingOrdering::Priority,\n+            includable_boundary: Default::default(),\n+            enforce_priority_fees,\n+        },\n+    );\n     assert_eq!(all[0].hash, tx2_1_hash);\n     assert_eq!(all.len(), 3);\n \ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -1008,6 +1070,7 @@ fn should_return_cached_pending_even_if_unordered_is_requested() {\n             max_len: 3,\n             ordering: PendingOrdering::Unordered,\n             includable_boundary: Default::default(),\n+            enforce_priority_fees,\n         },\n     );\n \ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -1016,7 +1079,16 @@ fn should_return_cached_pending_even_if_unordered_is_requested() {\n }\n \n #[test]\n-fn should_return_unordered_and_not_populate_the_cache() {\n+fn should_return_unordered_and_not_populate_the_cache_with_enforced_fees() {\n+    should_return_unordered_and_not_populate_the_cache(true)\n+}\n+\n+#[test]\n+fn should_return_unordered_and_not_populate_the_cache_with_non_enforced_fees() {\n+    should_return_unordered_and_not_populate_the_cache(false)\n+}\n+\n+fn should_return_unordered_and_not_populate_the_cache(enforce_priority_fees: bool) {\n     // given\n     let txq = new_queue();\n     let tx1 = Tx::default().signed();\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -1037,12 +1109,17 @@ fn should_return_unordered_and_not_populate_the_cache() {\n             max_len: usize::max_value(),\n             ordering: PendingOrdering::Unordered,\n             includable_boundary: Default::default(),\n+            enforce_priority_fees,\n         },\n     );\n \n     // then\n     assert_eq!(limited.len(), 3);\n-    assert!(!txq.is_pending_cached());\n+    if enforce_priority_fees {\n+        assert!(!txq.is_enforced_pending_cached());\n+    } else {\n+        assert!(!txq.is_non_enforced_pending_cached());\n+    }\n }\n \n #[test]\ndiff --git a/crates/concensus/miner/src/pool/tests/mod.rs b/crates/concensus/miner/src/pool/tests/mod.rs\n--- a/crates/concensus/miner/src/pool/tests/mod.rs\n+++ b/crates/concensus/miner/src/pool/tests/mod.rs\n@@ -1302,3 +1379,147 @@ fn should_not_reject_early_in_case_gas_price_is_less_than_min_effective() {\n     assert_eq!(txq.status().status.transaction_count, 2);\n     assert!(client.was_verification_triggered());\n }\n+\n+#[test]\n+fn should_not_return_pending_external_transactions_with_too_low_priority_fee_if_priority_fees_are_enforced_by_pending(\n+) {\n+    should_not_return_pending_external_transactions_with_too_low_priority_fee_if_priority_fees_are_enforced(false)\n+}\n+\n+#[test]\n+fn should_not_return_pending_external_transactions_with_too_low_priority_fee_if_priority_fees_are_enforced_by_pending_filtered(\n+) {\n+    should_not_return_pending_external_transactions_with_too_low_priority_fee_if_priority_fees_are_enforced(true)\n+}\n+\n+fn should_not_return_pending_external_transactions_with_too_low_priority_fee_if_priority_fees_are_enforced(\n+    pending_filtered: bool,\n+) {\n+    // given\n+    let client = TestClient::new().with_balance(1_000_000);\n+    let block_base_fee = 1.into();\n+    let txq = new_queue();\n+    txq.set_verifier_options(verifier::Options {\n+        minimal_gas_price: 3.into(),\n+        block_base_fee: Some(block_base_fee),\n+        ..Default::default()\n+    });\n+    let tx1 = Tx::gas_price(4).signed();\n+    let tx1_hash = tx1.hash();\n+    let tx2 = Tx::gas_price(3).signed();\n+    let tx3 = Tx::gas_price(4).signed();\n+    let tx3_hash = tx3.hash();\n+    let tx4 = Tx::gas_price(3).signed();\n+    let tx4_hash = tx4.hash();\n+    let res = txq.import(client.clone(), vec![tx1, tx2].unverified());\n+    assert_eq!(res, vec![Ok(()), Ok(())]);\n+    let res = txq.import(client.clone(), vec![tx3, tx4].local());\n+    assert_eq!(res, vec![Ok(()), Ok(())]);\n+\n+    // when (priority fees are enforced)\n+    let pending_settings = PendingSettings {\n+        block_number: 0,\n+        current_timestamp: 0,\n+        nonce_cap: None,\n+        max_len: 4,\n+        ordering: PendingOrdering::Priority,\n+        includable_boundary: block_base_fee,\n+        enforce_priority_fees: true,\n+    };\n+    let all = if !pending_filtered {\n+        txq.pending(client.clone(), pending_settings)\n+    } else {\n+        txq.pending_filtered(\n+            client.clone(),\n+            pending_settings,\n+            &TransactionFilter::default(),\n+        )\n+    };\n+\n+    // then\n+    assert_eq!(all.len(), 3);\n+    assert_eq!(all[0].hash, tx3_hash);\n+    assert_eq!(all[1].hash, tx4_hash);\n+    assert_eq!(all[2].hash, tx1_hash);\n+\n+    // when (priority fees are not enforced)\n+    let pending_settings = PendingSettings {\n+        block_number: 0,\n+        current_timestamp: 0,\n+        nonce_cap: None,\n+        max_len: 4,\n+        ordering: PendingOrdering::Priority,\n+        includable_boundary: block_base_fee,\n+        enforce_priority_fees: false,\n+    };\n+    let all = if !pending_filtered {\n+        txq.pending(client.clone(), pending_settings)\n+    } else {\n+        txq.pending_filtered(\n+            client.clone(),\n+            pending_settings,\n+            &TransactionFilter::default(),\n+        )\n+    };\n+\n+    // then\n+    assert_eq!(all.len(), 4);\n+}\n+\n+#[test]\n+fn should_return_correct_cached_pending_depending_on_fees_enforcement_if_enforced() {\n+    should_return_correct_cached_pending_depending_on_fees_enforcement(true)\n+}\n+\n+#[test]\n+fn should_return_correct_cached_pending_depending_on_fees_enforcement_if_do_not_enforced() {\n+    should_return_correct_cached_pending_depending_on_fees_enforcement(false)\n+}\n+\n+fn should_return_correct_cached_pending_depending_on_fees_enforcement(enforce_priority_fees: bool) {\n+    // given\n+    let client = TestClient::new().with_balance(1_000_000);\n+    let block_base_fee = 1.into();\n+    let txq = new_queue();\n+    txq.set_verifier_options(verifier::Options {\n+        minimal_gas_price: 3.into(),\n+        block_base_fee: Some(block_base_fee),\n+        ..Default::default()\n+    });\n+    let tx1 = Tx::gas_price(4).signed();\n+    let tx2 = Tx::gas_price(3).signed();\n+    let tx3 = Tx::gas_price(3).signed();\n+    let res = txq.import(client.clone(), vec![tx1, tx2].unverified());\n+    assert_eq!(res, vec![Ok(()), Ok(())]);\n+    let res = txq.import(client.clone(), vec![tx3].local());\n+    assert_eq!(res, vec![Ok(())]);\n+\n+    // when (priority fees are enforced)\n+    let pending_settings = PendingSettings {\n+        block_number: 0,\n+        current_timestamp: 0,\n+        nonce_cap: None,\n+        max_len: 4,\n+        ordering: PendingOrdering::Priority,\n+        includable_boundary: block_base_fee,\n+        enforce_priority_fees,\n+    };\n+    let all = txq.pending(client.clone(), pending_settings);\n+\n+    // This should not invalidate the cache!\n+    let limited = txq.pending(\n+        TestClient::new(),\n+        PendingSettings {\n+            block_number: 0,\n+            current_timestamp: 0,\n+            nonce_cap: None,\n+            max_len: 3,\n+            ordering: PendingOrdering::Unordered,\n+            includable_boundary: Default::default(),\n+            enforce_priority_fees,\n+        },\n+    );\n+\n+    // then\n+    assert_eq!(all, limited);\n+}\ndiff --git a/crates/concensus/miner/src/pool/tests/tx.rs b/crates/concensus/miner/src/pool/tests/tx.rs\n--- a/crates/concensus/miner/src/pool/tests/tx.rs\n+++ b/crates/concensus/miner/src/pool/tests/tx.rs\n@@ -18,7 +18,8 @@ use crypto::publickey::{Generator, Random};\n use ethereum_types::{H256, U256};\n use rustc_hex::FromHex;\n use types::transaction::{\n-    self, SignedTransaction, Transaction, TypedTransaction, UnverifiedTransaction,\n+    self, AccessListTx, EIP1559TransactionTx, SignedTransaction, Transaction, TypedTransaction,\n+    UnverifiedTransaction,\n };\n \n use pool::{verifier, VerifiedTransaction};\ndiff --git a/crates/concensus/miner/src/pool/tests/tx.rs b/crates/concensus/miner/src/pool/tests/tx.rs\n--- a/crates/concensus/miner/src/pool/tests/tx.rs\n+++ b/crates/concensus/miner/src/pool/tests/tx.rs\n@@ -110,6 +111,25 @@ impl Tx {\n         });\n         tx.sign(keypair.secret(), None)\n     }\n+\n+    pub fn eip1559_one(self, max_priority_fee_per_gas: u64) -> SignedTransaction {\n+        let keypair = Random.generate();\n+        let tx = TypedTransaction::EIP1559Transaction(EIP1559TransactionTx {\n+            transaction: AccessListTx {\n+                transaction: Transaction {\n+                    action: transaction::Action::Create,\n+                    value: U256::from(100),\n+                    data: \"3331600055\".from_hex().unwrap(),\n+                    gas: self.gas.into(),\n+                    gas_price: self.gas_price.into(),\n+                    nonce: self.nonce.into(),\n+                },\n+                access_list: vec![],\n+            },\n+            max_priority_fee_per_gas: max_priority_fee_per_gas.into(),\n+        });\n+        tx.sign(keypair.secret(), None)\n+    }\n }\n pub trait TxExt: Sized {\n     type Out;\ndiff --git a/crates/ethcore/src/client/client.rs b/crates/ethcore/src/client/client.rs\n--- a/crates/ethcore/src/client/client.rs\n+++ b/crates/ethcore/src/client/client.rs\n@@ -2745,6 +2745,10 @@ impl BlockChainClient for Client {\n             .ready_transactions(self, max_len, ::miner::PendingOrdering::Priority)\n     }\n \n+    fn transaction(&self, tx_hash: &H256) -> Option<Arc<VerifiedTransaction>> {\n+        self.importer.miner.transaction(tx_hash)\n+    }\n+\n     fn signing_chain_id(&self) -> Option<u64> {\n         self.engine.signing_chain_id(&self.latest_env_info())\n     }\ndiff --git a/crates/ethcore/src/client/test_client.rs b/crates/ethcore/src/client/test_client.rs\n--- a/crates/ethcore/src/client/test_client.rs\n+++ b/crates/ethcore/src/client/test_client.rs\n@@ -127,6 +127,8 @@ pub struct TestBlockChainClient {\n     pub history: RwLock<Option<u64>>,\n     /// Is disabled\n     pub disabled: AtomicBool,\n+    /// Transaction hashes producer\n+    pub new_transaction_hashes: RwLock<Option<crossbeam_channel::Sender<H256>>>,\n }\n \n /// Used for generating test client blocks.\ndiff --git a/crates/ethcore/src/client/test_client.rs b/crates/ethcore/src/client/test_client.rs\n--- a/crates/ethcore/src/client/test_client.rs\n+++ b/crates/ethcore/src/client/test_client.rs\n@@ -196,6 +198,7 @@ impl TestBlockChainClient {\n             history: RwLock::new(None),\n             disabled: AtomicBool::new(false),\n             error_on_logs: RwLock::new(None),\n+            new_transaction_hashes: RwLock::new(None),\n         };\n \n         // insert genesis hash.\ndiff --git a/crates/ethcore/src/client/test_client.rs b/crates/ethcore/src/client/test_client.rs\n--- a/crates/ethcore/src/client/test_client.rs\n+++ b/crates/ethcore/src/client/test_client.rs\n@@ -388,6 +391,14 @@ impl TestBlockChainClient {\n             .import_external_transactions(self, vec![signed_tx.into()]);\n         let res = res.into_iter().next().unwrap();\n         assert!(res.is_ok());\n+\n+        // if new_transaction_hashes producer channel exists, send the transaction hash\n+        let _ = self\n+            .new_transaction_hashes\n+            .write()\n+            .as_ref()\n+            .and_then(|tx| Some(tx.send(hash)));\n+\n         hash\n     }\n \ndiff --git a/crates/ethcore/src/client/test_client.rs b/crates/ethcore/src/client/test_client.rs\n--- a/crates/ethcore/src/client/test_client.rs\n+++ b/crates/ethcore/src/client/test_client.rs\n@@ -405,6 +416,13 @@ impl TestBlockChainClient {\n     pub fn is_disabled(&self) -> bool {\n         self.disabled.load(AtomicOrder::SeqCst)\n     }\n+\n+    pub fn set_new_transaction_hashes_producer(\n+        &self,\n+        new_transaction_hashes: crossbeam_channel::Sender<H256>,\n+    ) {\n+        *self.new_transaction_hashes.write() = Some(new_transaction_hashes);\n+    }\n }\n \n /// Get temporary db state1\ndiff --git a/crates/ethcore/src/client/test_client.rs b/crates/ethcore/src/client/test_client.rs\n--- a/crates/ethcore/src/client/test_client.rs\n+++ b/crates/ethcore/src/client/test_client.rs\n@@ -1101,6 +1119,10 @@ impl BlockChainClient for TestBlockChainClient {\n         }\n         None\n     }\n+\n+    fn transaction(&self, tx_hash: &H256) -> Option<Arc<VerifiedTransaction>> {\n+        self.miner.transaction(tx_hash)\n+    }\n }\n \n impl IoClient for TestBlockChainClient {\ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -1705,10 +1762,19 @@ pub mod tests {\n     }\n \n     pub fn dummy_sync(client: &dyn BlockChainClient) -> ChainSync {\n+        let (_, transaction_hashes_rx) = crossbeam_channel::unbounded();\n+        dummy_sync_with_tx_hashes_rx(client, transaction_hashes_rx)\n+    }\n+\n+    pub fn dummy_sync_with_tx_hashes_rx(\n+        client: &dyn BlockChainClient,\n+        transaction_hashes_rx: crossbeam_channel::Receiver<H256>,\n+    ) -> ChainSync {\n         ChainSync::new(\n             SyncConfig::default(),\n             client,\n             ForkFilterApi::new_dummy(client),\n+            transaction_hashes_rx,\n         )\n     }\n \ndiff --git a/crates/ethcore/sync/src/chain/mod.rs b/crates/ethcore/sync/src/chain/mod.rs\n--- a/crates/ethcore/sync/src/chain/mod.rs\n+++ b/crates/ethcore/sync/src/chain/mod.rs\n@@ -1716,11 +1782,16 @@ pub mod tests {\n         peer_latest_hash: H256,\n         client: &dyn BlockChainClient,\n     ) -> ChainSync {\n-        let mut sync = ChainSync::new(\n-            SyncConfig::default(),\n-            client,\n-            ForkFilterApi::new_dummy(client),\n-        );\n+        let (_, transaction_hashes_rx) = crossbeam_channel::unbounded();\n+        dummy_sync_with_peer_and_tx_hashes_rx(peer_latest_hash, client, transaction_hashes_rx)\n+    }\n+\n+    pub fn dummy_sync_with_peer_and_tx_hashes_rx(\n+        peer_latest_hash: H256,\n+        client: &dyn BlockChainClient,\n+        transaction_hashes_rx: crossbeam_channel::Receiver<H256>,\n+    ) -> ChainSync {\n+        let mut sync = dummy_sync_with_tx_hashes_rx(client, transaction_hashes_rx);\n         insert_dummy_peer(&mut sync, 0, peer_latest_hash);\n         sync\n     }\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -383,6 +365,74 @@ impl SyncPropagator {\n             sync.disconnect_peer(peer_id);\n         }\n     }\n+\n+    /// propagates new transactions to all peers\n+    fn propagate_transactions<'a, F, G>(\n+        sync: &mut ChainSync,\n+        io: &mut dyn SyncIo,\n+        get_transactions: G,\n+        are_new: bool,\n+        mut should_continue: F,\n+    ) -> usize\n+    where\n+        F: FnMut() -> bool,\n+        G: Fn(&dyn SyncIo) -> Vec<Arc<VerifiedTransaction>>,\n+    {\n+        // Early out if nobody to send to.\n+        if sync.peers.is_empty() {\n+            return 0;\n+        }\n+\n+        let transactions = get_transactions(io);\n+        if transactions.is_empty() {\n+            return 0;\n+        }\n+\n+        if !should_continue() {\n+            return 0;\n+        }\n+\n+        let (transactions, service_transactions): (Vec<_>, Vec<_>) = transactions\n+            .iter()\n+            .map(|tx| tx.signed())\n+            .partition(|tx| !tx.tx().gas_price.is_zero());\n+\n+        // usual transactions could be propagated to all peers\n+        let mut affected_peers = HashSet::new();\n+        if !transactions.is_empty() {\n+            let peers = SyncPropagator::select_peers_for_transactions(sync, |_| true, are_new);\n+            affected_peers = SyncPropagator::propagate_transactions_to_peers(\n+                sync,\n+                io,\n+                peers,\n+                transactions,\n+                are_new,\n+                &mut should_continue,\n+            );\n+        }\n+\n+        // most of times service_transactions will be empty\n+        // => there's no need to merge packets\n+        if !service_transactions.is_empty() {\n+            let service_transactions_peers = SyncPropagator::select_peers_for_transactions(\n+                sync,\n+                |peer_id| io.peer_version(*peer_id).accepts_service_transaction(),\n+                are_new,\n+            );\n+            let service_transactions_affected_peers =\n+                SyncPropagator::propagate_transactions_to_peers(\n+                    sync,\n+                    io,\n+                    service_transactions_peers,\n+                    service_transactions,\n+                    are_new,\n+                    &mut should_continue,\n+                );\n+            affected_peers.extend(&service_transactions_affected_peers);\n+        }\n+\n+        affected_peers.len()\n+    }\n }\n \n #[cfg(test)]\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -398,6 +448,7 @@ mod tests {\n         super::{tests::*, *},\n         *,\n     };\n+    use ethcore::ethereum::new_london_test;\n \n     #[test]\n     fn sends_new_hashes_to_lagging_peer() {\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -475,11 +526,7 @@ mod tests {\n         client.add_blocks(2, EachBlockWith::Uncle);\n         let queue = RwLock::new(VecDeque::new());\n         let block = client.block(BlockId::Latest).unwrap().into_inner();\n-        let mut sync = ChainSync::new(\n-            SyncConfig::default(),\n-            &client,\n-            ForkFilterApi::new_dummy(&client),\n-        );\n+        let mut sync = dummy_sync(&client);\n         sync.peers.insert(\n             0,\n             PeerInfo {\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -516,7 +563,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn propagates_transactions() {\n+    fn propagates_ready_transactions() {\n         let mut client = TestBlockChainClient::new();\n         client.add_blocks(100, EachBlockWith::Uncle);\n         client.insert_transaction_to_queue();\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -524,13 +571,13 @@ mod tests {\n         let queue = RwLock::new(VecDeque::new());\n         let ss = TestSnapshotService::new();\n         let mut io = TestIo::new(&mut client, &ss, &queue, None);\n-        let peer_count = SyncPropagator::propagate_new_transactions(&mut sync, &mut io, || true);\n+        let peer_count = SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n         // Try to propagate same transactions for the second time\n-        let peer_count2 = SyncPropagator::propagate_new_transactions(&mut sync, &mut io, || true);\n+        let peer_count2 = SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n         // Even after new block transactions should not be propagated twice\n         sync.chain_new_blocks(&mut io, &[], &[], &[], &[], &[], &[]);\n         // Try to propagate same transactions for the third time\n-        let peer_count3 = SyncPropagator::propagate_new_transactions(&mut sync, &mut io, || true);\n+        let peer_count3 = SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n \n         // 1 message should be send\n         assert_eq!(1, io.packets.len());\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -543,7 +590,83 @@ mod tests {\n     }\n \n     #[test]\n-    fn does_not_propagate_new_transactions_after_new_block() {\n+    fn propagates_ready_transactions_to_subset_of_peers() {\n+        let mut client = TestBlockChainClient::new();\n+        client.add_blocks(100, EachBlockWith::Uncle);\n+        client.insert_transaction_to_queue();\n+        let mut sync = dummy_sync(&client);\n+        for id in 0..25 {\n+            insert_dummy_peer(&mut sync, id, client.block_hash_delta_minus(1))\n+        }\n+        let queue = RwLock::new(VecDeque::new());\n+        let ss = TestSnapshotService::new();\n+        let mut io = TestIo::new(&mut client, &ss, &queue, None);\n+        let peer_count = SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n+\n+        // Currently random implementation for test returns 8 peers as result of peers selection.\n+        assert_eq!(8, peer_count);\n+    }\n+\n+    #[test]\n+    fn propagates_new_transactions_to_all_peers() {\n+        let (new_transaction_hashes_tx, new_transaction_hashes_rx) = crossbeam_channel::unbounded();\n+\n+        let mut client = TestBlockChainClient::new();\n+        client.set_new_transaction_hashes_producer(new_transaction_hashes_tx);\n+        client.add_blocks(100, EachBlockWith::Uncle);\n+        let tx_hash = client.insert_transaction_to_queue();\n+        let mut sync = dummy_sync_with_tx_hashes_rx(&client, new_transaction_hashes_rx);\n+        for id in 0..25 {\n+            insert_dummy_peer(&mut sync, id, client.block_hash_delta_minus(1))\n+        }\n+        let queue = RwLock::new(VecDeque::new());\n+        let ss = TestSnapshotService::new();\n+        let mut io = TestIo::new(&mut client, &ss, &queue, None);\n+        let peer_count =\n+            SyncPropagator::propagate_new_transactions(&mut sync, &mut io, vec![tx_hash], || true);\n+\n+        assert_eq!(25, peer_count);\n+    }\n+\n+    #[test]\n+    fn propagates_new_transactions() {\n+        let (new_transaction_hashes_tx, new_transaction_hashes_rx) = crossbeam_channel::unbounded();\n+\n+        let mut client = TestBlockChainClient::new();\n+        client.set_new_transaction_hashes_producer(new_transaction_hashes_tx);\n+        client.add_blocks(100, EachBlockWith::Uncle);\n+        let tx_hash = client.insert_transaction_to_queue();\n+        let mut sync = dummy_sync_with_peer_and_tx_hashes_rx(\n+            client.block_hash_delta_minus(1),\n+            &client,\n+            new_transaction_hashes_rx,\n+        );\n+        let queue = RwLock::new(VecDeque::new());\n+        let ss = TestSnapshotService::new();\n+        let mut io = TestIo::new(&mut client, &ss, &queue, None);\n+        let peer_count =\n+            SyncPropagator::propagate_new_transactions(&mut sync, &mut io, vec![tx_hash], || true);\n+        // Try to propagate same transactions for the second time\n+        let peer_count2 =\n+            SyncPropagator::propagate_new_transactions(&mut sync, &mut io, vec![tx_hash], || true);\n+        // Even after new block transactions should not be propagated twice\n+        sync.chain_new_blocks(&mut io, &[], &[], &[], &[], &[], &[]);\n+        // Try to propagate same transactions for the third time\n+        let peer_count3 =\n+            SyncPropagator::propagate_new_transactions(&mut sync, &mut io, vec![tx_hash], || true);\n+\n+        // 1 message should be send\n+        assert_eq!(1, io.packets.len());\n+        // 1 peer should be updated but only once\n+        assert_eq!(1, peer_count);\n+        assert_eq!(0, peer_count2);\n+        assert_eq!(0, peer_count3);\n+        // TRANSACTIONS_PACKET\n+        assert_eq!(0x02, io.packets[0].packet_id);\n+    }\n+\n+    #[test]\n+    fn does_not_propagate_ready_transactions_after_new_block() {\n         let mut client = TestBlockChainClient::new();\n         client.add_blocks(100, EachBlockWith::Uncle);\n         client.insert_transaction_to_queue();\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -551,7 +674,7 @@ mod tests {\n         let queue = RwLock::new(VecDeque::new());\n         let ss = TestSnapshotService::new();\n         let mut io = TestIo::new(&mut client, &ss, &queue, None);\n-        let peer_count = SyncPropagator::propagate_new_transactions(&mut sync, &mut io, || true);\n+        let peer_count = SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n         io.chain.insert_transaction_to_queue();\n         // New block import should not trigger propagation.\n         // (we only propagate on timeout)\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -566,27 +689,63 @@ mod tests {\n     }\n \n     #[test]\n-    fn does_not_fail_for_no_peers() {\n+    fn does_not_propagate_new_transactions_after_new_block() {\n+        let (new_transaction_hashes_tx, new_transaction_hashes_rx) = crossbeam_channel::unbounded();\n+\n         let mut client = TestBlockChainClient::new();\n+        client.set_new_transaction_hashes_producer(new_transaction_hashes_tx);\n         client.add_blocks(100, EachBlockWith::Uncle);\n-        client.insert_transaction_to_queue();\n-        // Sync with no peers\n-        let mut sync = ChainSync::new(\n-            SyncConfig::default(),\n+        let tx_hash = client.insert_transaction_to_queue();\n+        let mut sync = dummy_sync_with_peer_and_tx_hashes_rx(\n+            client.block_hash_delta_minus(1),\n             &client,\n-            ForkFilterApi::new_dummy(&client),\n+            new_transaction_hashes_rx,\n         );\n         let queue = RwLock::new(VecDeque::new());\n         let ss = TestSnapshotService::new();\n         let mut io = TestIo::new(&mut client, &ss, &queue, None);\n-        let peer_count = SyncPropagator::propagate_new_transactions(&mut sync, &mut io, || true);\n+        let peer_count =\n+            SyncPropagator::propagate_new_transactions(&mut sync, &mut io, vec![tx_hash], || true);\n+        io.chain.insert_transaction_to_queue();\n+        // New block import should not trigger propagation.\n+        // (we only propagate on timeout)\n+        sync.chain_new_blocks(&mut io, &[], &[], &[], &[], &[], &[]);\n+\n+        // 2 message should be send\n+        assert_eq!(1, io.packets.len());\n+        // 1 peer should receive the message\n+        assert_eq!(1, peer_count);\n+        // TRANSACTIONS_PACKET\n+        assert_eq!(0x02, io.packets[0].packet_id);\n+    }\n+\n+    #[test]\n+    fn does_not_fail_for_no_peers() {\n+        let (new_transaction_hashes_tx, new_transaction_hashes_rx) = crossbeam_channel::unbounded();\n+\n+        let mut client = TestBlockChainClient::new();\n+        client.set_new_transaction_hashes_producer(new_transaction_hashes_tx);\n+        client.add_blocks(100, EachBlockWith::Uncle);\n+        let tx_hash = client.insert_transaction_to_queue();\n+        // Sync with no peers\n+        let mut sync = dummy_sync_with_tx_hashes_rx(&client, new_transaction_hashes_rx);\n+        let queue = RwLock::new(VecDeque::new());\n+        let ss = TestSnapshotService::new();\n+        let mut io = TestIo::new(&mut client, &ss, &queue, None);\n+        let peer_count = SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n+        let peer_count_new =\n+            SyncPropagator::propagate_new_transactions(&mut sync, &mut io, vec![tx_hash], || true);\n         sync.chain_new_blocks(&mut io, &[], &[], &[], &[], &[], &[]);\n         // Try to propagate same transactions for the second time\n-        let peer_count2 = SyncPropagator::propagate_new_transactions(&mut sync, &mut io, || true);\n+        let peer_count2 = SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n+        let peer_count_new2 =\n+            SyncPropagator::propagate_new_transactions(&mut sync, &mut io, vec![tx_hash], || true);\n \n         assert_eq!(0, io.packets.len());\n         assert_eq!(0, peer_count);\n         assert_eq!(0, peer_count2);\n+        assert_eq!(0, peer_count_new);\n+        assert_eq!(0, peer_count_new2);\n     }\n \n     #[test]\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -601,7 +760,7 @@ mod tests {\n         {\n             let mut io = TestIo::new(&mut client, &ss, &queue, None);\n             let peer_count =\n-                SyncPropagator::propagate_new_transactions(&mut sync, &mut io, || true);\n+                SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n             assert_eq!(1, io.packets.len());\n             assert_eq!(1, peer_count);\n         }\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -611,10 +770,10 @@ mod tests {\n             let mut io = TestIo::new(&mut client, &ss, &queue, None);\n             // Propagate new transactions\n             let peer_count2 =\n-                SyncPropagator::propagate_new_transactions(&mut sync, &mut io, || true);\n+                SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n             // And now the peer should have all transactions\n             let peer_count3 =\n-                SyncPropagator::propagate_new_transactions(&mut sync, &mut io, || true);\n+                SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n             (peer_count2, peer_count3)\n         };\n \ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -629,22 +788,53 @@ mod tests {\n     }\n \n     #[test]\n-    fn should_maintain_transations_propagation_stats() {\n+    fn should_maintain_transactions_propagation_stats() {\n+        let (new_transaction_hashes_tx, new_transaction_hashes_rx) = crossbeam_channel::unbounded();\n+\n         let mut client = TestBlockChainClient::new();\n+        client.set_new_transaction_hashes_producer(new_transaction_hashes_tx);\n         client.add_blocks(100, EachBlockWith::Uncle);\n-        client.insert_transaction_to_queue();\n-        let mut sync = dummy_sync_with_peer(client.block_hash_delta_minus(1), &client);\n+        let tx_hash1 = client.insert_transaction_to_queue();\n+        let mut sync = dummy_sync_with_peer_and_tx_hashes_rx(\n+            client.block_hash_delta_minus(1),\n+            &client,\n+            new_transaction_hashes_rx,\n+        );\n         let queue = RwLock::new(VecDeque::new());\n         let ss = TestSnapshotService::new();\n-        let mut io = TestIo::new(&mut client, &ss, &queue, None);\n-        SyncPropagator::propagate_new_transactions(&mut sync, &mut io, || true);\n \n-        let stats = sync.transactions_stats();\n+        {\n+            let mut io = TestIo::new(&mut client, &ss, &queue, None);\n+            SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n+        }\n+\n+        let tx_hash2 = client.insert_transaction_to_queue();\n+        {\n+            let mut io = TestIo::new(&mut client, &ss, &queue, None);\n+            SyncPropagator::propagate_new_transactions(&mut sync, &mut io, vec![tx_hash2], || true);\n+        }\n+\n+        let stats = sync.pending_transactions_stats();\n+        assert_eq!(\n+            stats.len(),\n+            1,\n+            \"Should maintain stats for single ready transaction.\"\n+        );\n+        assert!(\n+            stats.contains_key(&tx_hash1),\n+            \"Should maintain stats for propagated ready transaction.\"\n+        );\n+\n+        let stats = sync.new_transactions_stats();\n         assert_eq!(\n             stats.len(),\n             1,\n-            \"Should maintain stats for single transaction.\"\n-        )\n+            \"Should maintain stats for single new transaction.\"\n+        );\n+        assert!(\n+            stats.contains_key(&tx_hash2),\n+            \"Should maintain stats for propagated new transaction.\"\n+        );\n     }\n \n     #[test]\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -652,11 +842,7 @@ mod tests {\n         let mut client = TestBlockChainClient::new();\n         client.insert_transaction_with_gas_price_to_queue(U256::zero());\n         let block_hash = client.block_hash_delta_minus(1);\n-        let mut sync = ChainSync::new(\n-            SyncConfig::default(),\n-            &client,\n-            ForkFilterApi::new_dummy(&client),\n-        );\n+        let mut sync = dummy_sync(&client);\n         let queue = RwLock::new(VecDeque::new());\n         let ss = TestSnapshotService::new();\n         let mut io = TestIo::new(&mut client, &ss, &queue, None);\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -674,7 +860,7 @@ mod tests {\n             .insert(3, \"OpenEthereum/ABCDEFGH/v2.7.3/linux/rustc\".to_owned());\n \n         // and new service transaction is propagated to peers\n-        SyncPropagator::propagate_new_transactions(&mut sync, &mut io, || true);\n+        SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n \n         // peer#2 && peer#3 are receiving service transaction\n         assert!(io\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -694,11 +880,7 @@ mod tests {\n         let tx1_hash = client.insert_transaction_to_queue();\n         let tx2_hash = client.insert_transaction_with_gas_price_to_queue(U256::zero());\n         let block_hash = client.block_hash_delta_minus(1);\n-        let mut sync = ChainSync::new(\n-            SyncConfig::default(),\n-            &client,\n-            ForkFilterApi::new_dummy(&client),\n-        );\n+        let mut sync = dummy_sync(&client);\n         let queue = RwLock::new(VecDeque::new());\n         let ss = TestSnapshotService::new();\n         let mut io = TestIo::new(&mut client, &ss, &queue, None);\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -709,7 +891,7 @@ mod tests {\n             .insert(1, \"OpenEthereum/v2.6.0/linux/rustc\".to_owned());\n \n         // and service + non-service transactions are propagated to peers\n-        SyncPropagator::propagate_new_transactions(&mut sync, &mut io, || true);\n+        SyncPropagator::propagate_ready_transactions(&mut sync, &mut io, || true);\n \n         // two separate packets for peer are queued:\n         // 1) with non-service-transaction\ndiff --git a/crates/ethcore/sync/src/chain/propagator.rs b/crates/ethcore/sync/src/chain/propagator.rs\n--- a/crates/ethcore/sync/src/chain/propagator.rs\n+++ b/crates/ethcore/sync/src/chain/propagator.rs\n@@ -738,4 +920,29 @@ mod tests {\n         assert!(sent_transactions.iter().any(|tx| tx.hash() == tx1_hash));\n         assert!(sent_transactions.iter().any(|tx| tx.hash() == tx2_hash));\n     }\n+\n+    #[test]\n+    fn should_propagate_transactions_with_max_fee_per_gas_lower_than_base_fee() {\n+        let (new_transaction_hashes_tx, new_transaction_hashes_rx) = crossbeam_channel::unbounded();\n+\n+        let spec = new_london_test();\n+        let mut client = TestBlockChainClient::new_with_spec(spec);\n+        client.set_new_transaction_hashes_producer(new_transaction_hashes_tx);\n+        client.add_blocks(100, EachBlockWith::Uncle);\n+        let tx_hash = client.insert_transaction_to_queue();\n+        let mut sync = dummy_sync_with_peer_and_tx_hashes_rx(\n+            client.block_hash_delta_minus(1),\n+            &client,\n+            new_transaction_hashes_rx,\n+        );\n+        let queue = RwLock::new(VecDeque::new());\n+        let ss = TestSnapshotService::new();\n+\n+        let mut io = TestIo::new(&mut client, &ss, &queue, None);\n+        let peer_count =\n+            SyncPropagator::propagate_new_transactions(&mut sync, &mut io, vec![tx_hash], || true);\n+\n+        assert_eq!(1, io.packets.len());\n+        assert_eq!(1, peer_count);\n+    }\n }\ndiff --git a/crates/ethcore/sync/src/tests/helpers.rs b/crates/ethcore/sync/src/tests/helpers.rs\n--- a/crates/ethcore/sync/src/tests/helpers.rs\n+++ b/crates/ethcore/sync/src/tests/helpers.rs\n@@ -398,7 +398,13 @@ impl TestNet<EthPeer<TestBlockChainClient>> {\n         for _ in 0..n {\n             let chain = TestBlockChainClient::new();\n             let ss = Arc::new(TestSnapshotService::new());\n-            let sync = ChainSync::new(config.clone(), &chain, ForkFilterApi::new_dummy(&chain));\n+            let (_, transaction_hashes_rx) = crossbeam_channel::unbounded();\n+            let sync = ChainSync::new(\n+                config.clone(),\n+                &chain,\n+                ForkFilterApi::new_dummy(&chain),\n+                transaction_hashes_rx,\n+            );\n             net.peers.push(Arc::new(EthPeer {\n                 sync: RwLock::new(sync),\n                 snapshot_service: ss,\ndiff --git a/crates/ethcore/sync/src/tests/helpers.rs b/crates/ethcore/sync/src/tests/helpers.rs\n--- a/crates/ethcore/sync/src/tests/helpers.rs\n+++ b/crates/ethcore/sync/src/tests/helpers.rs\n@@ -447,7 +453,13 @@ impl TestNet<EthPeer<EthcoreClient>> {\n         .unwrap();\n \n         let ss = Arc::new(TestSnapshotService::new());\n-        let sync = ChainSync::new(config, &*client, ForkFilterApi::new_dummy(&*client));\n+        let (_, transaction_hashes_rx) = crossbeam_channel::unbounded();\n+        let sync = ChainSync::new(\n+            config,\n+            &*client,\n+            ForkFilterApi::new_dummy(&*client),\n+            transaction_hashes_rx,\n+        );\n         let peer = Arc::new(EthPeer {\n             sync: RwLock::new(sync),\n             snapshot_service: ss,\ndiff --git a/crates/ethcore/sync/src/transactions_stats.rs b/crates/ethcore/sync/src/transactions_stats.rs\n--- a/crates/ethcore/sync/src/transactions_stats.rs\n+++ b/crates/ethcore/sync/src/transactions_stats.rs\n@@ -63,30 +64,50 @@ impl TransactionsStats {\n     pub fn propagated(\n         &mut self,\n         hash: &H256,\n+        is_new: bool,\n         enode_id: Option<NodeId>,\n         current_block_num: BlockNumber,\n     ) {\n         let enode_id = enode_id.unwrap_or_default();\n-        let stats = self\n-            .pending_transactions\n-            .entry(*hash)\n-            .or_insert_with(|| Stats::new(current_block_num));\n+        let stats = if is_new {\n+            self.new_transactions\n+                .entry(*hash)\n+                .or_insert_with(|| Stats::new(current_block_num))\n+        } else {\n+            self.pending_transactions\n+                .entry(*hash)\n+                .or_insert_with(|| Stats::new(current_block_num))\n+        };\n         let count = stats.propagated_to.entry(enode_id).or_insert(0);\n         *count = count.saturating_add(1);\n     }\n \n-    /// Returns propagation stats for given hash or `None` if hash is not known.\n+    /// Returns propagation stats for given hash or `None` if hash is not known or\n+    /// does not correspond to pending transaction.\n     #[cfg(test)]\n-    pub fn get(&self, hash: &H256) -> Option<&Stats> {\n+    pub fn get_pending(&self, hash: &H256) -> Option<&Stats> {\n         self.pending_transactions.get(hash)\n     }\n \n-    pub fn stats(&self) -> &H256FastMap<Stats> {\n+    /// Returns propagation stats for given hash or `None` if hash is not known or\n+    /// does not correspond to new transaction.\n+    #[cfg(test)]\n+    pub fn get_new(&self, hash: &H256) -> Option<&Stats> {\n+        self.new_transactions.get(hash)\n+    }\n+\n+    /// Stats for pending transactions.\n+    pub fn pending_transactions_stats(&self) -> &H256FastMap<Stats> {\n         &self.pending_transactions\n     }\n \n-    /// Retains only transactions present in given `HashSet`.\n-    pub fn retain<S: BuildHasher>(&mut self, hashes: &HashSet<H256, S>) {\n+    /// Stats for new transactions.\n+    pub fn new_transactions_stats(&self) -> &H256FastMap<Stats> {\n+        &self.new_transactions\n+    }\n+\n+    /// Retains only pending transactions present in given `HashSet`.\n+    pub fn retain_pending<S: BuildHasher>(&mut self, hashes: &HashSet<H256, S>) {\n         let to_remove = self\n             .pending_transactions\n             .keys()\ndiff --git a/crates/ethcore/sync/src/transactions_stats.rs b/crates/ethcore/sync/src/transactions_stats.rs\n--- a/crates/ethcore/sync/src/transactions_stats.rs\n+++ b/crates/ethcore/sync/src/transactions_stats.rs\n@@ -98,6 +119,25 @@ impl TransactionsStats {\n             self.pending_transactions.remove(&hash);\n         }\n     }\n+\n+    pub fn retain_new(\n+        &mut self,\n+        current_block_num: BlockNumber,\n+        new_transactions_stats_period: BlockNumber,\n+    ) {\n+        let to_remove = self\n+            .new_transactions\n+            .iter()\n+            .filter(|(_, stats)| {\n+                current_block_num.saturating_sub(stats.first_seen) > new_transactions_stats_period\n+            })\n+            .map(|(hash, _)| hash.clone())\n+            .collect::<Vec<_>>();\n+\n+        for hash in to_remove {\n+            self.new_transactions.remove(&hash);\n+        }\n+    }\n }\n \n #[cfg(test)]\ndiff --git a/crates/ethcore/sync/src/transactions_stats.rs b/crates/ethcore/sync/src/transactions_stats.rs\n--- a/crates/ethcore/sync/src/transactions_stats.rs\n+++ b/crates/ethcore/sync/src/transactions_stats.rs\n@@ -110,43 +150,118 @@ mod tests {\n     #[test]\n     fn should_keep_track_of_propagations() {\n         // given\n-        let mut stats = TransactionsStats::default();\n         let hash = H256::from_low_u64_be(5);\n         let enodeid1 = H512::from_low_u64_be(2);\n         let enodeid2 = H512::from_low_u64_be(5);\n \n-        // when\n-        stats.propagated(&hash, Some(enodeid1), 5);\n-        stats.propagated(&hash, Some(enodeid1), 10);\n-        stats.propagated(&hash, Some(enodeid2), 15);\n+        {\n+            // given\n+            let mut stats = TransactionsStats::default();\n \n-        // then\n-        let stats = stats.get(&hash);\n-        assert_eq!(\n-            stats,\n-            Some(&Stats {\n-                first_seen: 5,\n-                propagated_to: hash_map![\n-                    enodeid1 => 2,\n-                    enodeid2 => 1\n-                ],\n-            })\n-        );\n+            // when\n+            stats.propagated(&hash, false, Some(enodeid1), 5);\n+            stats.propagated(&hash, false, Some(enodeid1), 10);\n+            stats.propagated(&hash, false, Some(enodeid2), 15);\n+\n+            // then\n+            let pending_stats = stats.get_pending(&hash);\n+            assert_eq!(\n+                pending_stats,\n+                Some(&Stats {\n+                    first_seen: 5,\n+                    propagated_to: hash_map![\n+                        enodeid1 => 2,\n+                        enodeid2 => 1\n+                    ],\n+                }),\n+                \"Pending transactions propagation should update pending_transactions stats\"\n+            );\n+\n+            let new_stats = stats.get_new(&hash);\n+            assert_eq!(\n+                new_stats, None,\n+                \"Pending transactions propagation should not update new_transactions stats\"\n+            );\n+        }\n+\n+        {\n+            // given\n+            let mut stats = TransactionsStats::default();\n+\n+            // when\n+            stats.propagated(&hash, true, Some(enodeid1), 5);\n+            stats.propagated(&hash, true, Some(enodeid1), 10);\n+            stats.propagated(&hash, true, Some(enodeid2), 15);\n+\n+            // then\n+            let pending_stats = stats.get_pending(&hash);\n+            assert_eq!(\n+                pending_stats, None,\n+                \"New transactions propagation should not update pending_transactions stats\"\n+            );\n+\n+            let new_stats = stats.get_new(&hash);\n+            assert_eq!(\n+                new_stats,\n+                Some(&Stats {\n+                    first_seen: 5,\n+                    propagated_to: hash_map![\n+                        enodeid1 => 2,\n+                        enodeid2 => 1\n+                    ],\n+                }),\n+                \"New transactions propagation should update new_transactions stats\"\n+            );\n+        }\n     }\n \n     #[test]\n-    fn should_remove_hash_from_tracking() {\n+    fn should_remove_pending_hash_from_tracking() {\n         // given\n         let mut stats = TransactionsStats::default();\n         let hash = H256::from_low_u64_be(5);\n         let enodeid1 = H512::from_low_u64_be(5);\n-        stats.propagated(&hash, Some(enodeid1), 10);\n+        stats.propagated(&hash, false, Some(enodeid1), 10);\n \n         // when\n-        stats.retain(&HashSet::new());\n+        stats.retain_pending(&HashSet::new());\n \n         // then\n-        let stats = stats.get(&hash);\n+        let stats = stats.get_pending(&hash);\n         assert_eq!(stats, None);\n     }\n+\n+    #[test]\n+    fn should_remove_expired_new_hashes_from_tracking() {\n+        //given\n+        let mut stats = TransactionsStats::default();\n+\n+        let hash1 = H256::from_low_u64_be(5);\n+        let hash2 = H256::from_low_u64_be(6);\n+        let hash3 = H256::from_low_u64_be(7);\n+\n+        let enodeid1 = H512::from_low_u64_be(5);\n+        let enodeid2 = H512::from_low_u64_be(6);\n+        let enodeid3 = H512::from_low_u64_be(7);\n+\n+        stats.propagated(&hash1, true, Some(enodeid1), 5);\n+        stats.propagated(&hash2, true, Some(enodeid2), 6);\n+        stats.propagated(&hash3, true, Some(enodeid3), 7);\n+\n+        // when\n+        stats.retain_new(10, 3);\n+\n+        // then\n+        assert_eq!(stats.get_new(&hash1), None);\n+        assert_eq!(stats.get_new(&hash2), None);\n+        assert_eq!(\n+            stats.get_new(&hash3),\n+            Some(&Stats {\n+                first_seen: 7,\n+                propagated_to: hash_map![\n+                    enodeid3 => 1\n+                ],\n+            }),\n+        )\n+    }\n }\ndiff --git a/crates/rpc/src/v1/tests/helpers/sync_provider.rs b/crates/rpc/src/v1/tests/helpers/sync_provider.rs\n--- a/crates/rpc/src/v1/tests/helpers/sync_provider.rs\n+++ b/crates/rpc/src/v1/tests/helpers/sync_provider.rs\n@@ -110,7 +110,7 @@ impl SyncProvider for TestSyncProvider {\n         None\n     }\n \n-    fn transactions_stats(&self) -> BTreeMap<H256, TransactionStats> {\n+    fn pending_transactions_stats(&self) -> BTreeMap<H256, TransactionStats> {\n         map![\n             H256::from_low_u64_be(1) => TransactionStats {\n                 first_seen: 10,\ndiff --git a/crates/rpc/src/v1/tests/helpers/sync_provider.rs b/crates/rpc/src/v1/tests/helpers/sync_provider.rs\n--- a/crates/rpc/src/v1/tests/helpers/sync_provider.rs\n+++ b/crates/rpc/src/v1/tests/helpers/sync_provider.rs\n@@ -126,4 +126,15 @@ impl SyncProvider for TestSyncProvider {\n             }\n         ]\n     }\n+\n+    fn new_transactions_stats(&self) -> BTreeMap<H256, TransactionStats> {\n+        map![\n+            H256::from_low_u64_be(1) => TransactionStats {\n+                first_seen: 10,\n+                propagated_to: map![\n+                    H512::from_low_u64_be(128) => 2\n+                ],\n+            }\n+        ]\n+    }\n }\n",
        "problem_statement": "Local txs not sending if they are below min-gas-price\nFor questions please use https://discord.io/openethereum, issues are for bugs and feature requests.\r\n\r\n_Before filing a new issue, please **provide the following information**._\r\n\r\n- **OpenEthereum version (>=3.1.0)**: v3.3.0rc4\r\n- **Operating system**: Windows\r\n- **Installation**: one-line installer\r\n- **Fully synchronized**: yes\r\n- **Network**: ethereum\r\n- **Restarted**: yes\r\n\r\nI keep my node at min-gas-price 999000000000 (this is 999 gwei) since I don't care about seeing the mempool. I used to be able to submit txs at any gas price since local txs bypassed the min-gas-price limit. But now my ~30gwei txs do not reach the mempool unless either\r\n1) I lower the min-gas-price to below 30 gwei OR\r\n2) I send at another gasprice higher than min-gas-price\r\n\r\nThis has only happened since upgrading from v3.2.3 to v3.3.0rc4\r\n\r\nFYI I use eth_sendRawTransaction method to send txs\n",
        "hints_text": "What exact error do you get?\nI can confirm this issue for client `OpenEthereum/v3.3.0-rc.8-stable-d8305c5-20210903/x86_64-linux-gnu/rustc1.52.1`\r\nI have set 60gwei for minimal gas price, the node got the TX and accepted with the following log message and responded the TX hash:\r\n```\r\n2021-10-22 15:13:24  Local tx 0xa649ca3d97c558bf4cf3c990d39deff13d4a3914e4e7d6f88dbcd94f2fc52ce9 below minimal gas price accepted\r\n```\r\nAfter this it was not propagated for any client just hanging in the queue.\r\n\r\n\nAny update on this issue anyone?\r\n\r\n@varasev \nNoticed, that the transaction where the gasPrice is below the actual block baseFee will not be propagated.\n`-ltxqueue=trace,own_tx=trace` logging results:\r\n```\r\n2021-11-21 20:27:54  http.worker00 TRACE own_tx  Importing transaction: PendingTransaction { transaction: SignedTransaction { transaction: UnverifiedTransaction { unsigned: Legacy(Transaction { nonce: 2313, gas_price: 78000000000, gas: 21000, action: Call(0xa53857a3931c5b18f9fc42ec243c105f87272906), value: 6240000000000000, data: [] }), signature: SignatureComponents { standard_v: 1, r: 92013966681440102715109973460658076055065802869876154443999098677058329049507, s: 28947670180978235317458111994968652337577197769461621296298348832440253231432 }, chain_id: Some(1), hash: 0x22a86cc73b61cef592dba7667d2153cff09f62f1cf286d1939b71fdea475b655 }, sender: 0x268eb6e0c09790faf4fe70955a6d02933c04673f, public: Some(0xf1e10481d2af4bdabe29e30554e6692551983c689ac36b22c874f6b67a767f43aa3b20e5198430ce30454d3ee52d7311b3fbe9cd192c2ff43dcccf041d7d9c6f) }, condition: None }\r\n2021-11-21 20:27:54  http.worker00 INFO own_tx  Local tx 0x22a86cc73b61cef592dba7667d2153cff09f62f1cf286d1939b71fdea475b655 below minimal gas price accepted\r\n2021-11-21 20:27:54  http.worker00 DEBUG own_tx  Imported to the pool (hash 0x22a86cc73b61cef592dba7667d2153cff09f62f1cf286d1939b71fdea475b655)\r\n2021-11-21 20:27:54  http.worker00 DEBUG txqueue  [0x22a86cc73b61cef592dba7667d2153cff09f62f1cf286d1939b71fdea475b655] Added to the pool.\r\n2021-11-21 20:27:54  http.worker00 DEBUG txqueue  [0x22a86cc73b61cef592dba7667d2153cff09f62f1cf286d1939b71fdea475b655] Sender: 0x268e\u2026673f, nonce: 2313, gasPrice: 78000000000, gas: 21000, value: 6240000000000000, dataLen: 0))\r\n```\r\nThat's all log what i got for my txhash.. the transaction still not broadcasted.\r\nEven i don't understand why they think that the transaction is under minimal gas price. `parity_minGasPrice` gives back 1 gwei what i have set.\n@iFA88 \r\n\r\nTry setting `-min-gas-price` to a lower value in `[mining]` section, e.g. set min_gas_price to 1 Gwei:\r\n\r\n```\r\n[mining]\r\n# Minimum amount of Wei per GAS to be paid for a transaction to be accepted for mining. Overrides --usd-per-tx.\r\nmin_gas_price = 1000000000\r\n```\nOk.\n\nOn Sun, 21 Nov 2021, 22:43 gituser, ***@***.***> wrote:\n\n> @iFA88 <https://github.com/iFA88>\n>\n> Try setting -min-gas-price to a lower value in [mining] section, e.g. set\n> min_gas_price to 1 Gwei:\n>\n> [mining]\n> # Minimum amount of Wei per GAS to be paid for a transaction to be accepted for mining. Overrides --usd-per-tx.\n> min_gas_price = 1000000000\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/openethereum/openethereum/issues/496#issuecomment-974911114>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AS2UXSA4LP6MMNZ2MLDDOTTUNFYZLANCNFSM5BJNYM3A>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n\n@gituser \r\nI have tried with 1gwei and tried without the parameter, nothing changed.\nI think the reason is that after EIP-1559 activation, the `--min-gas-price` CLI (config) option is responsible for setting min priority fee. If you set --min-gas-price to 1 GWei, a miner node expects that a user should pay at least `1 GWei + baseFee` for gas.\n@varasev \r\nOkay, and what happens when i did not set that parameter?\r\n\r\n**update**\r\nNevermind, i see that it will be adjust automatic for the eth/usd price.\n```\r\n2021-11-22 10:21:15  http.worker80 TRACE own_tx  Importing transaction: PendingTransaction { transaction: SignedTransaction { transaction: UnverifiedTransaction { unsigned: Legacy(Transaction { nonce: 130, gas_price: 10000000000, gas: 21000, action: Call(0x610e3b4e804b367c182c5fc4d65d09c089723389), value: 1, data: [] }), signature: SignatureComponents { standard_v: 0, r: 55754326573550405364023190324906168662212853490666669412494019454875860588406, s: 44101255877958525967658530657821143604465675763137664642274163831706394838998 }, chain_id: Some(1), hash: 0xf98a957376a5f2c22bafaf4820ce342cf262556b6d801bb143d930d463a050d6 }, sender: 0x610e3b4e804b367c182c5fc4d65d09c089723389, public: Some(0x1a449e836a31c1a15b8d1b703d4add7950ea750371e69ee9528e8970ab5eb868ca49158ad6c8aea31d0ba4d15e15a07bc682bee424a6ae9a760475ec5004db08) }, condition: None }\r\n2021-11-22 10:21:15  Worker devp2p2 DEBUG sync  3 -> Dispatching packet: 8\r\n2021-11-22 10:21:15  Worker devp2p2 TRACE sync  Skipping peer 3, force=false, td=Some(34964994126940701551480), our td=34964994126940701551480, state=Blocks\r\n2021-11-22 10:21:15  Worker devp2p3 DEBUG sync  3 -> Dispatching packet: 8\r\n2021-11-22 10:21:15  Worker devp2p3 TRACE sync  Skipping peer 3, force=false, td=Some(34964994126940701551480), our td=34964994126940701551480, state=Blocks\r\n2021-11-22 10:21:15  http.worker80 INFO own_tx  Local tx 0xf98a957376a5f2c22bafaf4820ce342cf262556b6d801bb143d930d463a050d6 below minimal gas price accepted\r\n2021-11-22 10:21:15  http.worker80 DEBUG own_tx  Imported to the pool (hash 0xf98a957376a5f2c22bafaf4820ce342cf262556b6d801bb143d930d463a050d6)\r\n2021-11-22 10:21:15  http.worker80 DEBUG txqueue  [0xf98a957376a5f2c22bafaf4820ce342cf262556b6d801bb143d930d463a050d6] Added to the pool.\r\n2021-11-22 10:21:15  http.worker80 DEBUG txqueue  [0xf98a957376a5f2c22bafaf4820ce342cf262556b6d801bb143d930d463a050d6] Sender: 0x610e\u20263389, nonce: 130, gasPrice: 10000000000, gas: 21000, value: 1, dataLen: 0))\r\n2021-11-22 10:21:15  Worker devp2p0 DEBUG txqueue  Re-computing pending set for block: 13663666\r\n2021-11-22 10:21:15  Worker devp2p0 TRACE sync  18 <- Transactions (2 entries; 247 bytes)\r\n2021-11-22 10:21:15  Worker devp2p0 TRACE sync  11 <- NewPooledTransactionHashes (2 entries; 68 bytes)\r\n2021-11-22 10:21:15  Worker devp2p0 TRACE sync  37 <- NewPooledTransactionHashes (2 entries; 68 bytes)\r\n2021-11-22 10:21:15  Worker devp2p0 TRACE sync  05 <- NewPooledTransactionHashes (2 entries; 68 bytes)\r\n2021-11-22 10:21:15  Worker devp2p0 TRACE sync  52 <- NewPooledTransactionHashes (2 entries; 68 bytes)\r\n2021-11-22 10:21:15  Worker devp2p0 TRACE sync  38 <- NewPooledTransactionHashes (4 entries; 134 bytes)\r\n2021-11-22 10:21:15  Worker devp2p0 TRACE sync  07 <- Transactions (4 entries; 537 bytes)\r\n2021-11-22 10:21:15  Worker devp2p0 TRACE sync  32 <- Transactions (2 entries; 247 bytes)\r\n2021-11-22 10:21:15  Worker devp2p0 DEBUG sync  Sent up to 4 transactions to 8 peers.\r\n2021-11-22 10:21:15  Worker devp2p0 DEBUG sync  Finished transaction propagation, took 0ms\r\n```\r\nOkay, **maybe** the transaction is propagated, but why i did not see that in the `parity_pendingTransactionsStats` list? **Maybe** the other client doesn't accepts it?\r\n\r\n\r\nUPDATE:\r\nI connected an other openethereum client to my node with debug logging, but they did not get my transaction. So the transaction is not propagated.\nNotice: V2 transaction have the same issue.\n@rimrakhimov will look at this issue soon.\n@iFA88 \r\nCould you please provide options you run your client with, and the way you submit a transaction?\n@rimrakhimov \r\nI submit the transaction via jsonrpc `eth_sendRawTransaction` method from localhost.\r\nFor client parameter have tried lot of combination. The latest was:\r\n```\r\nopenethereum --base-path /mnt/data/nodes/eth --chain foundation --tracing on --pruning fast --no-warp --no-ws --no-secretstore --reserved-peers=/mnt/data/nodes/eth/reservedPeers.json --port 3001 --interface 94.199.178.233 --nat=extip:94.199.178.233 --cache-size-db 4096 --cache-size-blocks 64 --cache-size-queue 128 --cache-size-state 1024 --pruning-history 1024 --no-ipc --jsonrpc-port 3000 --jsonrpc-apis all --jsonrpc-server-threads 12 --jsonrpc-allow-missing-blocks --no-persistent-txqueue --tx-queue-no-early-reject --tx-queue-per-sender=128 --refuse-service-transactions --reseal-on-txs=none --log-file /own/logs/nodes/eth/eth.log\r\n```\nJust to clarify, are you running a client node through which you would like to submit a transaction with the priority fee price lower than min-gas-price set by the node? And the transaction is submitted but is not propagated to other nodes.\r\n\r\nAlso, did you run `parity_pendingTransactionsStats` call on the node you submitted transaction, or the other client you connected?\n> Just to clarify, are you running a client node through which you would like to submit a transaction with the priority fee price lower than min-gas-price set by the node? And the transaction is submitted but is not propagated to other nodes.\r\n\r\nYes.\r\n\r\n> Also, did you run parity_pendingTransactionsStats call on the node you submitted transaction, or the other client you connected?\r\n\r\nYes. The transaction was not available on the SECOND node (not in `parity_pendingTransactionsStats` and not in `parity_allTransactionHashes`)\r\nOn the FIRST node my transaction was available in `parity_allTransactionHashes` and `parity_allTransactions`, but in `parity_pendingTransactionsStats` NOT.\r\n\r\nWhen the `gasPrice` (v1 legacy transaction) or the `maxPriorityFeePerGas` (v2 transaction) is below as the current (?pending?) block base fee it will NOT be propagated anywhere.\n@rimrakhimov Any other question?\n@iFA88, sorry for the delay. I've checked the transaction pool. If I got you right, I believe that the behavior you described is still completely valid.\r\n\r\n> On the FIRST node my transaction was available in `parity_allTransactionHashes` and `parity_allTransactions`, but in `parity_pendingTransactionsStats` NOT.\r\n\r\n`parity_pendingTransactionsStats` returns only transactions that are _pending_ (are ready to be added in the current block). As the transaction you sent has `gasPrice` (v1 legacy transaction) or `maxFeePerGas` (v2 legacy transaction) less than block base fee, it cannot be added into the current block and, thus, is not _pending_.\r\n\r\n> The transaction was not available on the SECOND node (not in parity_pendingTransactionsStats and not in parity_allTransactionHashes)\r\n\r\nIn the current implementation, only transactions that are ready to be added into the block are propagated. So, as the gas transaction is ready to pay is less than the block base fee, it is not propagated. However, the transaction is still kept in the FIRST node's transaction pool, and will be propagated at the moment block base fee becomes less than `gasPrice` or `maxFeePerGas`.\r\n\r\n\r\n\r\nThe main difference with v3.2.3 most probably was an introduction of _block base fee_ notation. Before that any transactions were absolutely valid to be added into the next block no matter what gas price they specified. I believe that was the only change occurred. It is still possible to set `--min-gas-price` option to some large value and locally submit a transaction with effective priority gas price lower than `--min-gas-price`, however `maxFeePerGas` value should be greater than current block base fee in order the transaction to be propagated immediately.\n@rimrakhimov Thank you for your effort.\r\nI think local transaction should propagated at any way even when they are lower as the current/pending block base fee OR even lower as the `--min-gas-price`.\r\nThere is any workaround for this or it will be fixed soon?\r\nThanks!\n@iFA88, I believe at the moment there is no way to get round block base fee limitation. Moreover, OpenEthereum peer nodes would reject such a transaction in the current implementation even if the transaction was propagated, as a node calculates `effective_priority_fee_per_gas` value to be zero in that case.\r\n\r\nRegarding fixing it, we will discuss the problem this week, and I will return later with an answer.\nThanks man..:)\n\n@rimrakhimov  I tried to make a local test on `posdao-test-setup` and changed the port number on [this line](https://github.com/poanetwork/posdao-test-setup/blob/2faffc1bc3ab1f44c35bebee4bd856db008c2e13/test/01_staking.js#L7) to `8540` instead of `8541` (to make txs go to local rpc `node0`). Transactions sent to port `8540` are not propagated to the local validator nodes for some reason (after block 8 at which EIP-1559 is activated).\r\n\r\nIf I experimentally set `eip1559Transition` to some later block (say, 28) [here](https://github.com/poanetwork/posdao-test-setup/blob/2faffc1bc3ab1f44c35bebee4bd856db008c2e13/scripts/copy-spec.js#L29), and repeat the experiment, transactions are propagated successfully (until block 28). So, it seems they are not propagated after EIP-1559 is activated.\r\n\r\nIt seems this happens even if I set `min_gas_price = 0` for all local nodes.\n@varasev, yes. The node only propagates transactions that are ready to be added into the next block. Before `eip1559Transition` any `gasPrice` was valid if the node was ready to add such a transaction (either `gasPrice >= min_gas_price` or the transaction is local) into the transaction pool. \r\n\r\nHowever, after `eip1559Transition` if `gasPrice` is lower than current `baseFee` the transaction cannot be added into the block. That is the reason, why it is not propagated even if `min_gas_price = 0` for all nodes.\n@rimrakhimov Can you please check it yourself locally using `posdao-test-setup`? The gas price seems to be correct there as it is higher than the base fee.\n@varasev Oh, I see. Will check it\n@rimrakhimov Sorry, everything is fine there. My mistake. The reason was in `eth_sendTransaction` request that was sent to the node which didn't have a key for sender.\nWe decided that the way transaction pool currently works is valid and we are not going to change the implementation. Likewise, it seems, that some other clients (i.e. Geth, Nethermind) work in the same way, thus, changing our implementation may result in other clients rejecting such transactions anyway.\r\n\r\nSo, I'm closing the issue\nYou are kidding?\r\n\r\nTo be clear:\r\nYou **can not** broadcast a transaction which has lower fee as the actual block base fee.\r\nFor example you can not send transaction with 500gwei gasPrice when the actual block has 1200 baseFee.\r\n\r\nThat is **ridiculous**!\r\n\r\nI need a other client (geth), that my clients can broadcast his transactions... OMG!\n@iFA88 Can you please reproduce it on https://github.com/poanetwork/posdao-test-setup and write here the steps to reproduce? You can try to send a test transaction to `node0` (which is RPC) when the `baseFee` is higher than your gas price and see if it is mined by some validator's node (`node1`, `node2`, or `node3`) once the `baseFee` reduces to an appropriate value.\n@varasev \r\nFor `npm run all` got build error: https://gist.github.com/iFA88/a6d2175bbd36d51d83195b2294d850e1\r\nPlease contact me on telegram @iFA88\n@iFA88 Could you please clarify a use case how you are using transaction broadcast. I believe, currently if the transaction is local, it will be accepted by the OE node, even though not being broadcasted until actual `baseFee` will become lower than specified `gasPrice`. So, the transaction **should be broadcasted** when it becomes possible to add it into the block. Why do you find such behavior as unacceptable?\nI'm using simply RPC `eth_sendRawTransaction`.\r\nThe main problem, that the node returns the transaction hash as response, like everything is okay. Then this transaction will be STUCK inside the local mem pool and **WILL NOT BE** broadcasted for any peer when the actual block base fee is higher as the transaction gas price.\r\n\r\nI thought the issue is clear for you. Almost a high severity issue.\nFor answer to you question is NO.\r\nMy partners send me the transaction because they will have it to be broadcasted. After that the transaction exists only in my (one of more) client and will may be not propagated for hours/days.\r\nWhen it happens, that the base fee is lower, then the transaction has **missed** at least one block and may the next block has higher base fee again.\r\nAfter i restart my client the transaction is gone, because i don't use persistent pending transactions.\r\n\r\nI definitely know that other clients propagate transactions which have lower fee as the actual block. That's why i need maintenance a geth to sending new transactions there.. but then why i need openethereum?\n@iFA88 Ok, I think you are right. I was wrong about other clients. \r\n\r\nI believe there are two main problems with current transaction pool implementation:\r\n1. Local transactions with `maxFeePerGas` (or `gasPrice`) value lower than pending block `baseFee` are not propagated to other clients (even if some clients would accept such transactions into their transaction pools).\r\n2. If transaction is not local (i.e. was got from another client propagated it), the transaction will most probably be rejected due to `--min-gas-price` or `--usd-per-tx` parameters set. Transaction will not be rejected only if `--min-gas-price` was explicitly set to zero.\r\n\r\nWe will fix the first problem. So, transactions with too low `maxFeePerGas` (or `gasPrice`) will be propagated to other nodes. That way, such transactions will be able to be added into transaction pools of the clients that accepts them (i.e. Geth). \r\n\r\nFixing the second problem is still under discussion. Before, other OE nodes will reject such transactions, but it should not be a great problem for RPC nodes.\n@rimrakhimov \r\nThank you! Yeah that's my bad, i said clients but i meant partners/customers.\r\nFor the second issue:\r\nI think you should not be worried about that, when the node receives a transaction which is below his `--min-gas-price` OR there is more transactions in the mempool which worth more AND the mempool is full THEN the new pending transaction SHOULD be rejected. This test is not easy because there is a lot of transaction in the network and the mempool will be fast full, and there is a bug (related #346 ) when you have too big limit.\n@rimrakhimov any update on this issue?\r\n\r\nparity seems to be not broadcasting transactions even if they are local\r\n\r\n> @iFA88 Ok, I think you are right. I was wrong about other clients.\r\n> \r\n> I believe there are two main problems with current transaction pool implementation:\r\n> \r\n> 1. Local transactions with `maxFeePerGas` (or `gasPrice`) value lower than pending block `baseFee` are not propagated to other clients (even if some clients would accept such transactions into their transaction pools).\r\n> 2. If transaction is not local (i.e. was got from another client propagated it), the transaction will most probably be rejected due to `--min-gas-price` or `--usd-per-tx` parameters set. Transaction will not be rejected only if `--min-gas-price` was explicitly set to zero.\r\n> \r\n> We will fix the first problem. So, transactions with too low `maxFeePerGas` (or `gasPrice`) will be propagated to other nodes. That way, such transactions will be able to be added into transaction pools of the clients that accepts them (i.e. Geth).\r\n> \r\n> Fixing the second problem is still under discussion. Before, other OE nodes will reject such transactions, but it should not be a great problem for RPC nodes.\r\n\r\nany update on this @rimrakhimov ?",
        "created_at": "2022-01-24T11:04:22Z",
        "version": "3.3"
    },
    {
        "repo": "openethereum/openethereum",
        "pull_number": 406,
        "instance_id": "openethereum__openethereum-406",
        "issue_numbers": [
            "390"
        ],
        "base_commit": "f9f492638cce143efc5106c1bdf6f4dba5cdff8b",
        "patch": "diff --git a/crates/ethcore/src/executive.rs b/crates/ethcore/src/executive.rs\n--- a/crates/ethcore/src/executive.rs\n+++ b/crates/ethcore/src/executive.rs\n@@ -1463,12 +1463,18 @@ impl<'a, B: 'a + StateBackend> Executive<'a, B> {\n             U256::from(schedule.suicide_refund_gas) * U256::from(substate.suicides.len());\n         let refunds_bound = sstore_refunds + suicide_refunds;\n \n-        // real ammount to refund\n+        // real amount to refund\n         let gas_left_prerefund = match result {\n             Ok(FinalizationResult { gas_left, .. }) => gas_left,\n             _ => 0.into(),\n         };\n-        let refunded = cmp::min(refunds_bound, (t.tx().gas - gas_left_prerefund) >> 1);\n+        let refunded = if refunds_bound.is_zero() {\n+            refunds_bound\n+        } else {\n+            let gas_used = t.tx().gas - gas_left_prerefund;\n+            let max_refund = gas_used / schedule.max_refund_quotient;\n+            cmp::min(max_refund, refunds_bound)\n+        };\n         let gas_left = gas_left_prerefund + refunded;\n \n         let gas_used = t.tx().gas.saturating_sub(gas_left);\ndiff --git a/crates/ethcore/src/spec/spec.rs b/crates/ethcore/src/spec/spec.rs\n--- a/crates/ethcore/src/spec/spec.rs\n+++ b/crates/ethcore/src/spec/spec.rs\n@@ -139,6 +139,8 @@ pub struct CommonParams {\n     pub eip2929_transition: BlockNumber,\n     /// Number of first block where EIP-2930 rules begin.\n     pub eip2930_transition: BlockNumber,\n+    /// Number of first block where EIP-3529 rules begin.\n+    pub eip3529_transition: BlockNumber,\n     /// Number of first block where dust cleanup rules (EIP-168 and EIP169) begin.\n     pub dust_protection_transition: BlockNumber,\n     /// Nonce cap increase per block. Nonce cap is only checked if dust protection is enabled.\ndiff --git a/crates/ethcore/src/spec/spec.rs b/crates/ethcore/src/spec/spec.rs\n--- a/crates/ethcore/src/spec/spec.rs\n+++ b/crates/ethcore/src/spec/spec.rs\n@@ -245,6 +247,11 @@ impl CommonParams {\n             schedule.sload_gas = ::vm::schedule::EIP2929_WARM_STORAGE_READ_COST;\n             schedule.sstore_reset_gas = ::vm::schedule::EIP2929_SSTORE_RESET_GAS;\n         }\n+        if block_number >= self.eip3529_transition {\n+            schedule.suicide_refund_gas = 0;\n+            schedule.sstore_refund_gas = ::vm::schedule::EIP3529_SSTORE_CLEARS_SCHEDULE;\n+            schedule.max_refund_quotient = ::vm::schedule::EIP3529_MAX_REFUND_QUOTIENT;\n+        }\n \n         if block_number >= self.dust_protection_transition {\n             schedule.kill_dust = match self.remove_dust_contracts {\ndiff --git a/crates/ethcore/src/spec/spec.rs b/crates/ethcore/src/spec/spec.rs\n--- a/crates/ethcore/src/spec/spec.rs\n+++ b/crates/ethcore/src/spec/spec.rs\n@@ -378,6 +385,9 @@ impl From<ethjson::spec::Params> for CommonParams {\n             eip2930_transition: p\n                 .eip2930_transition\n                 .map_or_else(BlockNumber::max_value, Into::into),\n+            eip3529_transition: p\n+                .eip3529_transition\n+                .map_or_else(BlockNumber::max_value, Into::into),\n             dust_protection_transition: p\n                 .dust_protection_transition\n                 .map_or_else(BlockNumber::max_value, Into::into),\ndiff --git a/crates/ethcore/src/spec/spec.rs b/crates/ethcore/src/spec/spec.rs\n--- a/crates/ethcore/src/spec/spec.rs\n+++ b/crates/ethcore/src/spec/spec.rs\n@@ -667,6 +677,7 @@ impl Spec {\n             params.eip2315_transition,\n             params.eip2929_transition,\n             params.eip2930_transition,\n+            params.eip3529_transition,\n             params.dust_protection_transition,\n             params.wasm_activation_transition,\n             params.wasm_disable_transition,\ndiff --git a/crates/ethjson/src/spec/params.rs b/crates/ethjson/src/spec/params.rs\n--- a/crates/ethjson/src/spec/params.rs\n+++ b/crates/ethjson/src/spec/params.rs\n@@ -112,6 +112,8 @@ pub struct Params {\n     /// See `CommonParams` docs.\n     pub eip2930_transition: Option<Uint>,\n     /// See `CommonParams` docs.\n+    pub eip3529_transition: Option<Uint>,\n+    /// See `CommonParams` docs.\n     pub dust_protection_transition: Option<Uint>,\n     /// See `CommonParams` docs.\n     pub nonce_cap_increment: Option<Uint>,\ndiff --git a/crates/vm/vm/src/schedule.rs b/crates/vm/vm/src/schedule.rs\n--- a/crates/vm/vm/src/schedule.rs\n+++ b/crates/vm/vm/src/schedule.rs\n@@ -28,6 +28,12 @@ pub const EIP2929_SSTORE_RESET_GAS: usize = 5000 - EIP2929_COLD_SLOAD_COST;\n pub const EIP2930_ACCESS_LIST_STORAGE_KEY_COST: usize = 1900;\n /// Gas per received address\n pub const EIP2930_ACCESS_LIST_ADDRESS_COST: usize = 2400;\n+/// Gas used per transaction divided by this number is the maximum refundable amount\n+pub const MAX_REFUND_QUOTIENT: usize = 2;\n+pub const EIP3529_MAX_REFUND_QUOTIENT: usize = 5;\n+/// Reduced SSTORE refund as by EIP-3529\n+pub const EIP3529_SSTORE_CLEARS_SCHEDULE: usize =\n+    EIP2929_SSTORE_RESET_GAS + EIP2930_ACCESS_LIST_STORAGE_KEY_COST;\n \n /// Definition of the cost schedule and other parameterisations for the EVM.\n #[derive(Debug)]\ndiff --git a/crates/vm/vm/src/schedule.rs b/crates/vm/vm/src/schedule.rs\n--- a/crates/vm/vm/src/schedule.rs\n+++ b/crates/vm/vm/src/schedule.rs\n@@ -155,6 +161,8 @@ pub struct Schedule {\n     pub eip2929: bool,\n     /// Enable EIP-2930 rules for optional access list transactions. it depends on EIP-2929\n     pub eip2930: bool,\n+    /// Gas used in transaction divided by this number is the maximum refundable amount.\n+    pub max_refund_quotient: usize,\n }\n \n /// Wasm cost table\ndiff --git a/crates/vm/vm/src/schedule.rs b/crates/vm/vm/src/schedule.rs\n--- a/crates/vm/vm/src/schedule.rs\n+++ b/crates/vm/vm/src/schedule.rs\n@@ -302,6 +310,7 @@ impl Schedule {\n             wasm: None,\n             eip2929: false,\n             eip2930: false,\n+            max_refund_quotient: MAX_REFUND_QUOTIENT,\n         }\n     }\n \ndiff --git a/crates/vm/vm/src/schedule.rs b/crates/vm/vm/src/schedule.rs\n--- a/crates/vm/vm/src/schedule.rs\n+++ b/crates/vm/vm/src/schedule.rs\n@@ -359,6 +368,17 @@ impl Schedule {\n         schedule\n     }\n \n+    pub fn new_london() -> Schedule {\n+        let mut schedule = Self::new_berlin();\n+\n+        // EIP-3529 changes\n+        schedule.suicide_refund_gas = 0;\n+        schedule.sstore_refund_gas = EIP3529_SSTORE_CLEARS_SCHEDULE;\n+        schedule.max_refund_quotient = EIP3529_MAX_REFUND_QUOTIENT;\n+\n+        schedule\n+    }\n+\n     fn new(efcd: bool, hdc: bool, tcg: usize) -> Schedule {\n         Schedule {\n             exceptional_failed_code_deposit: efcd,\ndiff --git a/crates/vm/vm/src/schedule.rs b/crates/vm/vm/src/schedule.rs\n--- a/crates/vm/vm/src/schedule.rs\n+++ b/crates/vm/vm/src/schedule.rs\n@@ -422,6 +442,7 @@ impl Schedule {\n             wasm: None,\n             eip2929: false,\n             eip2930: false,\n+            max_refund_quotient: MAX_REFUND_QUOTIENT,\n         }\n     }\n \n",
        "test_patch": "diff --git a/crates/vm/evm/src/tests.rs b/crates/vm/evm/src/tests.rs\n--- a/crates/vm/evm/src/tests.rs\n+++ b/crates/vm/evm/src/tests.rs\n@@ -1661,6 +1661,61 @@ fn test_access_list_cheap_expensive_cheap(factory: super::Factory) {\n     assert_eq!(gas_left, U256::from(0));\n }\n \n+evm_test! {test_refund_post_london: test_refund_post_london_int}\n+fn test_refund_post_london(factory: super::Factory) {\n+    // Compare EIP-3529 for the test cases\n+\n+    let code = hex!(\"60006000556000600055\").to_vec();\n+    london_refund_test(&factory, code, &[], 0);\n+\n+    let code = hex!(\"60006000556001600055\").to_vec();\n+    london_refund_test(&factory, code, &[], 0);\n+\n+    let code = hex!(\"60016000556000600055\").to_vec();\n+    london_refund_test(&factory, code, &[], 19900);\n+\n+    let code = hex!(\"60006000556000600055\").to_vec();\n+    london_refund_test(&factory, code, &[1], 4800);\n+\n+    let code = hex!(\"60006000556001600055\").to_vec();\n+    london_refund_test(&factory, code, &[1], 2800);\n+\n+    let code = hex!(\"60006000556002600055\").to_vec();\n+    london_refund_test(&factory, code, &[1], 0);\n+\n+    let code = hex!(\"60026000556000600055\").to_vec();\n+    london_refund_test(&factory, code, &[1], 4800);\n+\n+    let code = hex!(\"60026000556001600055\").to_vec();\n+    london_refund_test(&factory, code, &[1], 2800);\n+\n+    let code = hex!(\"60016000556000600055\").to_vec();\n+    london_refund_test(&factory, code, &[], 19900);\n+\n+    let code = hex!(\"600060005560016000556000600055\").to_vec();\n+    london_refund_test(&factory, code, &[1], 7600);\n+}\n+\n+fn london_refund_test(\n+    factory: &super::Factory,\n+    code: Vec<u8>,\n+    fill: &[u64],\n+    expected_refund: i128,\n+) {\n+    let mut params = ActionParams::default();\n+    params.gas = U256::from(22318);\n+    params.code = Some(Arc::new(code));\n+    let mut ext = FakeExt::new_london(\n+        Address::from_str(\"0000000000000000000000000000000000000000\").unwrap(),\n+        Address::from_str(\"000000000000000000000000636F6E7472616374\").unwrap(),\n+        &[],\n+    );\n+    ext.prefill(fill);\n+    let vm = factory.create(params, ext.schedule(), ext.depth());\n+    vm.exec(&mut ext).ok().unwrap().unwrap();\n+    assert_eq!(ext.sstore_clears, expected_refund);\n+}\n+\n fn push_two_pop_one_constantinople_test(\n     factory: &super::Factory,\n     opcode: u8,\ndiff --git a/crates/vm/vm/src/tests.rs b/crates/vm/vm/src/tests.rs\n--- a/crates/vm/vm/src/tests.rs\n+++ b/crates/vm/vm/src/tests.rs\n@@ -63,6 +63,7 @@ pub struct FakeCall {\n /// Can't do recursive calls.\n #[derive(Default)]\n pub struct FakeExt {\n+    pub initial_store: HashMap<H256, H256>,\n     pub store: HashMap<H256, H256>,\n     pub suicides: HashSet<Address>,\n     pub calls: HashSet<FakeCall>,\ndiff --git a/crates/vm/vm/src/tests.rs b/crates/vm/vm/src/tests.rs\n--- a/crates/vm/vm/src/tests.rs\n+++ b/crates/vm/vm/src/tests.rs\n@@ -130,6 +131,12 @@ impl FakeExt {\n         ext\n     }\n \n+    pub fn new_london(from: Address, to: Address, builtins: &[Address]) -> Self {\n+        let mut ext = FakeExt::new_berlin(from, to, builtins);\n+        ext.schedule = Schedule::new_london();\n+        ext\n+    }\n+\n     /// Alter fake externalities to allow wasm\n     pub fn with_wasm(mut self) -> Self {\n         self.schedule.wasm = Some(Default::default());\ndiff --git a/crates/vm/vm/src/tests.rs b/crates/vm/vm/src/tests.rs\n--- a/crates/vm/vm/src/tests.rs\n+++ b/crates/vm/vm/src/tests.rs\n@@ -141,11 +148,30 @@ impl FakeExt {\n         self.chain_id = chain_id;\n         self\n     }\n+\n+    pub fn set_initial_storage(&mut self, key: H256, value: H256) {\n+        self.initial_store.insert(key, value);\n+    }\n+\n+    /// Fill the storage before the transaction with `data`, i. e. set\n+    /// both original and current values, beginning from address 0.\n+    pub fn prefill(&mut self, data: &[u64]) {\n+        for (k, v) in data.iter().enumerate() {\n+            let key = H256::from_low_u64_be(k as u64);\n+            let value = H256::from_low_u64_be(*v);\n+            self.set_initial_storage(key, value);\n+            self.set_storage(key, value)\n+                .expect(\"FakeExt::set_storage() never returns an Err.\");\n+        }\n+    }\n }\n \n impl Ext for FakeExt {\n-    fn initial_storage_at(&self, _key: &H256) -> Result<H256> {\n-        Ok(H256::default())\n+    fn initial_storage_at(&self, key: &H256) -> Result<H256> {\n+        match self.initial_store.get(key) {\n+            Some(value) => Ok(*value),\n+            None => Ok(H256::default()),\n+        }\n     }\n \n     fn storage_at(&self, key: &H256) -> Result<H256> {\n",
        "problem_statement": "Implement EIP-3529 in next release\nThe next release should implement EIP-3529 (gas refund adjustments) as it has recently been added to London, see issue 306 in https://github.com/ethereum/pm.\n",
        "hints_text": "",
        "created_at": "2021-05-17T09:44:20Z",
        "version": "3.2"
    },
    {
        "repo": "openethereum/openethereum",
        "pull_number": 580,
        "instance_id": "openethereum__openethereum-580",
        "issue_numbers": [
            "583"
        ],
        "base_commit": "f13fa10b8a0803116642f349c5557923afb2b5ba",
        "patch": "diff --git a/crates/ethcore/types/src/transaction/transaction_id.rs b/crates/ethcore/types/src/transaction/transaction_id.rs\n--- a/crates/ethcore/types/src/transaction/transaction_id.rs\n+++ b/crates/ethcore/types/src/transaction/transaction_id.rs\n@@ -51,6 +51,7 @@ impl TypedTxId {\n     pub fn from_U64_option_id(n: Option<U64>) -> Option<Self> {\n         match n.map(|t| t.as_u64()) {\n             None => Some(Self::Legacy),\n+            Some(0x00) => Some(Self::Legacy),\n             Some(0x01) => Some(Self::AccessList),\n             Some(0x02) => Some(Self::EIP1559Transaction),\n             _ => None,\ndiff --git a/crates/ethcore/types/src/transaction/transaction_id.rs b/crates/ethcore/types/src/transaction/transaction_id.rs\n--- a/crates/ethcore/types/src/transaction/transaction_id.rs\n+++ b/crates/ethcore/types/src/transaction/transaction_id.rs\n@@ -59,10 +60,7 @@ impl TypedTxId {\n \n     #[allow(non_snake_case)]\n     pub fn to_U64_option_id(self) -> Option<U64> {\n-        match self {\n-            Self::Legacy => None,\n-            _ => Some(U64::from(self as u8)),\n-        }\n+        Some(U64::from(self as u8))\n     }\n }\n \n",
        "test_patch": "diff --git a/crates/ethcore/types/src/transaction/transaction_id.rs b/crates/ethcore/types/src/transaction/transaction_id.rs\n--- a/crates/ethcore/types/src/transaction/transaction_id.rs\n+++ b/crates/ethcore/types/src/transaction/transaction_id.rs\n@@ -93,7 +91,7 @@ mod tests {\n \n     #[test]\n     fn typed_tx_id_to_u64_option_id() {\n-        assert_eq!(None, TypedTxId::Legacy.to_U64_option_id());\n+        assert_eq!(Some(U64::from(0x00)), TypedTxId::Legacy.to_U64_option_id());\n         assert_eq!(\n             Some(U64::from(0x01)),\n             TypedTxId::AccessList.to_U64_option_id()\ndiff --git a/crates/rpc/src/v1/tests/mocked/eth.rs b/crates/rpc/src/v1/tests/mocked/eth.rs\n--- a/crates/rpc/src/v1/tests/mocked/eth.rs\n+++ b/crates/rpc/src/v1/tests/mocked/eth.rs\n@@ -765,7 +765,7 @@ fn rpc_eth_pending_transaction_by_hash() {\n             .insert(H256::zero(), tx);\n     }\n \n-    let response = r#\"{\"jsonrpc\":\"2.0\",\"result\":{\"blockHash\":null,\"blockNumber\":null,\"chainId\":null,\"condition\":null,\"creates\":null,\"from\":\"0x0f65fe9276bc9a24ae7083ae28e2660ef72df99e\",\"gas\":\"0x5208\",\"gasPrice\":\"0x1\",\"hash\":\"0x41df922fd0d4766fcc02e161f8295ec28522f329ae487f14d811e4b64c8d6e31\",\"input\":\"0x\",\"nonce\":\"0x0\",\"publicKey\":\"0x7ae46da747962c2ee46825839c1ef9298e3bd2e70ca2938495c3693a485ec3eaa8f196327881090ff64cf4fbb0a48485d4f83098e189ed3b7a87d5941b59f789\",\"r\":\"0x48b55bfa915ac795c431978d8a6a992b628d557da5ff759b307d495a36649353\",\"raw\":\"0xf85f800182520894095e7baea6a6c7c4c2dfeb977efac326af552d870a801ba048b55bfa915ac795c431978d8a6a992b628d557da5ff759b307d495a36649353a0efffd310ac743f371de3b9f7f9cb56c0b28ad43601b4ab949f53faa07bd2c804\",\"s\":\"0xefffd310ac743f371de3b9f7f9cb56c0b28ad43601b4ab949f53faa07bd2c804\",\"standardV\":\"0x0\",\"to\":\"0x095e7baea6a6c7c4c2dfeb977efac326af552d87\",\"transactionIndex\":null,\"v\":\"0x1b\",\"value\":\"0xa\"},\"id\":1}\"#;\n+    let response = r#\"{\"jsonrpc\":\"2.0\",\"result\":{\"blockHash\":null,\"blockNumber\":null,\"chainId\":null,\"condition\":null,\"creates\":null,\"from\":\"0x0f65fe9276bc9a24ae7083ae28e2660ef72df99e\",\"gas\":\"0x5208\",\"gasPrice\":\"0x1\",\"hash\":\"0x41df922fd0d4766fcc02e161f8295ec28522f329ae487f14d811e4b64c8d6e31\",\"input\":\"0x\",\"nonce\":\"0x0\",\"publicKey\":\"0x7ae46da747962c2ee46825839c1ef9298e3bd2e70ca2938495c3693a485ec3eaa8f196327881090ff64cf4fbb0a48485d4f83098e189ed3b7a87d5941b59f789\",\"r\":\"0x48b55bfa915ac795c431978d8a6a992b628d557da5ff759b307d495a36649353\",\"raw\":\"0xf85f800182520894095e7baea6a6c7c4c2dfeb977efac326af552d870a801ba048b55bfa915ac795c431978d8a6a992b628d557da5ff759b307d495a36649353a0efffd310ac743f371de3b9f7f9cb56c0b28ad43601b4ab949f53faa07bd2c804\",\"s\":\"0xefffd310ac743f371de3b9f7f9cb56c0b28ad43601b4ab949f53faa07bd2c804\",\"standardV\":\"0x0\",\"to\":\"0x095e7baea6a6c7c4c2dfeb977efac326af552d87\",\"transactionIndex\":null,\"type\":\"0x0\",\"v\":\"0x1b\",\"value\":\"0xa\"},\"id\":1}\"#;\n     let request = r#\"{\n \t\t\"jsonrpc\": \"2.0\",\n \t\t\"method\": \"eth_getTransactionByHash\",\ndiff --git a/crates/rpc/src/v1/tests/mocked/eth.rs b/crates/rpc/src/v1/tests/mocked/eth.rs\n--- a/crates/rpc/src/v1/tests/mocked/eth.rs\n+++ b/crates/rpc/src/v1/tests/mocked/eth.rs\n@@ -1245,7 +1245,7 @@ fn rpc_eth_transaction_receipt() {\n \t\t\"params\": [\"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"],\n \t\t\"id\": 1\n \t}\"#;\n-    let response = r#\"{\"jsonrpc\":\"2.0\",\"result\":{\"blockHash\":\"0xed76641c68a1c641aee09a94b3b471f4dc0316efe5ac19cf488e2674cf8d05b5\",\"blockNumber\":\"0x4510c\",\"contractAddress\":null,\"cumulativeGasUsed\":\"0x20\",\"effectiveGasPrice\":\"0x0\",\"from\":\"0xb60e8dd61c5d32be8058bb8eb970870f07233155\",\"gasUsed\":\"0x10\",\"logs\":[{\"address\":\"0x33990122638b9132ca29c723bdf037f1a891a70c\",\"blockHash\":\"0xed76641c68a1c641aee09a94b3b471f4dc0316efe5ac19cf488e2674cf8d05b5\",\"blockNumber\":\"0x4510c\",\"data\":\"0x\",\"logIndex\":\"0x1\",\"removed\":false,\"topics\":[\"0xa6697e974e6a320f454390be03f74955e8978f1a6971ea6730542e37b66179bc\",\"0x4861736852656700000000000000000000000000000000000000000000000000\"],\"transactionHash\":\"0x0000000000000000000000000000000000000000000000000000000000000000\",\"transactionIndex\":\"0x0\",\"transactionLogIndex\":\"0x0\",\"type\":\"mined\"}],\"logsBloom\":\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\"root\":\"0x0000000000000000000000000000000000000000000000000000000000000000\",\"to\":\"0xd46e8dd67c5d32be8058bb8eb970870f07244567\",\"transactionHash\":\"0x0000000000000000000000000000000000000000000000000000000000000000\",\"transactionIndex\":\"0x0\"},\"id\":1}\"#;\n+    let response = r#\"{\"jsonrpc\":\"2.0\",\"result\":{\"blockHash\":\"0xed76641c68a1c641aee09a94b3b471f4dc0316efe5ac19cf488e2674cf8d05b5\",\"blockNumber\":\"0x4510c\",\"contractAddress\":null,\"cumulativeGasUsed\":\"0x20\",\"effectiveGasPrice\":\"0x0\",\"from\":\"0xb60e8dd61c5d32be8058bb8eb970870f07233155\",\"gasUsed\":\"0x10\",\"logs\":[{\"address\":\"0x33990122638b9132ca29c723bdf037f1a891a70c\",\"blockHash\":\"0xed76641c68a1c641aee09a94b3b471f4dc0316efe5ac19cf488e2674cf8d05b5\",\"blockNumber\":\"0x4510c\",\"data\":\"0x\",\"logIndex\":\"0x1\",\"removed\":false,\"topics\":[\"0xa6697e974e6a320f454390be03f74955e8978f1a6971ea6730542e37b66179bc\",\"0x4861736852656700000000000000000000000000000000000000000000000000\"],\"transactionHash\":\"0x0000000000000000000000000000000000000000000000000000000000000000\",\"transactionIndex\":\"0x0\",\"transactionLogIndex\":\"0x0\",\"type\":\"mined\"}],\"logsBloom\":\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\"root\":\"0x0000000000000000000000000000000000000000000000000000000000000000\",\"to\":\"0xd46e8dd67c5d32be8058bb8eb970870f07244567\",\"transactionHash\":\"0x0000000000000000000000000000000000000000000000000000000000000000\",\"transactionIndex\":\"0x0\",\"type\":\"0x0\"},\"id\":1}\"#;\n \n     assert_eq!(\n         tester.io.handle_request_sync(request),\ndiff --git a/crates/rpc/src/v1/tests/mocked/eth.rs b/crates/rpc/src/v1/tests/mocked/eth.rs\n--- a/crates/rpc/src/v1/tests/mocked/eth.rs\n+++ b/crates/rpc/src/v1/tests/mocked/eth.rs\n@@ -1300,7 +1300,7 @@ fn rpc_eth_pending_receipt() {\n \t\t\"params\": [\"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"],\n \t\t\"id\": 1\n \t}\"#;\n-    let response = r#\"{\"jsonrpc\":\"2.0\",\"result\":{\"blockHash\":null,\"blockNumber\":null,\"contractAddress\":null,\"cumulativeGasUsed\":\"0x20\",\"effectiveGasPrice\":\"0x0\",\"from\":\"0xb60e8dd61c5d32be8058bb8eb970870f07233155\",\"gasUsed\":\"0x10\",\"logs\":[],\"logsBloom\":\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\"to\":\"0xd46e8dd67c5d32be8058bb8eb970870f07244567\",\"transactionHash\":\"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\",\"transactionIndex\":\"0x0\"},\"id\":1}\"#;\n+    let response = r#\"{\"jsonrpc\":\"2.0\",\"result\":{\"blockHash\":null,\"blockNumber\":null,\"contractAddress\":null,\"cumulativeGasUsed\":\"0x20\",\"effectiveGasPrice\":\"0x0\",\"from\":\"0xb60e8dd61c5d32be8058bb8eb970870f07233155\",\"gasUsed\":\"0x10\",\"logs\":[],\"logsBloom\":\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\"to\":\"0xd46e8dd67c5d32be8058bb8eb970870f07244567\",\"transactionHash\":\"0xb903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\",\"transactionIndex\":\"0x0\",\"type\":\"0x0\"},\"id\":1}\"#;\n     assert_eq!(\n         tester.io.handle_request_sync(request),\n         Some(response.to_owned())\ndiff --git a/crates/rpc/src/v1/tests/mocked/parity.rs b/crates/rpc/src/v1/tests/mocked/parity.rs\n--- a/crates/rpc/src/v1/tests/mocked/parity.rs\n+++ b/crates/rpc/src/v1/tests/mocked/parity.rs\n@@ -572,7 +572,7 @@ fn rpc_parity_block_receipts() {\n \t\t\"params\": [],\n \t\t\"id\": 1\n \t}\"#;\n-    let response = r#\"{\"jsonrpc\":\"2.0\",\"result\":[{\"blockHash\":\"0x0000000000000000000000000000000000000000000000000000000000000003\",\"blockNumber\":\"0x0\",\"contractAddress\":null,\"cumulativeGasUsed\":\"0x5208\",\"effectiveGasPrice\":\"0x0\",\"from\":\"0x0000000000000000000000000000000000000009\",\"gasUsed\":\"0x5208\",\"logs\":[],\"logsBloom\":\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\",\"to\":null,\"transactionHash\":\"0x0000000000000000000000000000000000000000000000000000000000000001\",\"transactionIndex\":\"0x0\"}],\"id\":1}\"#;\n+    let response = r#\"{\"jsonrpc\":\"2.0\",\"result\":[{\"blockHash\":\"0x0000000000000000000000000000000000000000000000000000000000000003\",\"blockNumber\":\"0x0\",\"contractAddress\":null,\"cumulativeGasUsed\":\"0x5208\",\"effectiveGasPrice\":\"0x0\",\"from\":\"0x0000000000000000000000000000000000000009\",\"gasUsed\":\"0x5208\",\"logs\":[],\"logsBloom\":\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\",\"to\":null,\"transactionHash\":\"0x0000000000000000000000000000000000000000000000000000000000000001\",\"transactionIndex\":\"0x0\",\"type\":\"0x0\"}],\"id\":1}\"#;\n \n     assert_eq!(io.handle_request_sync(request), Some(response.to_owned()));\n }\ndiff --git a/crates/rpc/src/v1/tests/mocked/parity_set.rs b/crates/rpc/src/v1/tests/mocked/parity_set.rs\n--- a/crates/rpc/src/v1/tests/mocked/parity_set.rs\n+++ b/crates/rpc/src/v1/tests/mocked/parity_set.rs\n@@ -202,7 +202,7 @@ fn rpc_parity_remove_transaction() {\n         .to_owned()\n         + &format!(\"0x{:x}\", hash)\n         + r#\"\"], \"id\": 1}\"#;\n-    let response = r#\"{\"jsonrpc\":\"2.0\",\"result\":{\"blockHash\":null,\"blockNumber\":null,\"chainId\":null,\"condition\":null,\"creates\":null,\"from\":\"0x0000000000000000000000000000000000000002\",\"gas\":\"0x76c0\",\"gasPrice\":\"0x9184e72a000\",\"hash\":\"0x49569012bc8523519642c337fded3f20ba987beab31e14c67223b3d31359956f\",\"input\":\"0x\",\"nonce\":\"0x1\",\"publicKey\":null,\"r\":\"0x1\",\"raw\":\"0xe9018609184e72a0008276c0940000000000000000000000000000000000000005849184e72a801f0101\",\"s\":\"0x1\",\"standardV\":\"0x4\",\"to\":\"0x0000000000000000000000000000000000000005\",\"transactionIndex\":null,\"v\":\"0x1f\",\"value\":\"0x9184e72a\"},\"id\":1}\"#;\n+    let response = r#\"{\"jsonrpc\":\"2.0\",\"result\":{\"blockHash\":null,\"blockNumber\":null,\"chainId\":null,\"condition\":null,\"creates\":null,\"from\":\"0x0000000000000000000000000000000000000002\",\"gas\":\"0x76c0\",\"gasPrice\":\"0x9184e72a000\",\"hash\":\"0x49569012bc8523519642c337fded3f20ba987beab31e14c67223b3d31359956f\",\"input\":\"0x\",\"nonce\":\"0x1\",\"publicKey\":null,\"r\":\"0x1\",\"raw\":\"0xe9018609184e72a0008276c0940000000000000000000000000000000000000005849184e72a801f0101\",\"s\":\"0x1\",\"standardV\":\"0x4\",\"to\":\"0x0000000000000000000000000000000000000005\",\"transactionIndex\":null,\"type\":\"0x0\",\"v\":\"0x1f\",\"value\":\"0x9184e72a\"},\"id\":1}\"#;\n \n     miner.pending_transactions.lock().insert(hash, signed);\n     assert_eq!(io.handle_request_sync(&request), Some(response.to_owned()));\ndiff --git a/crates/rpc/src/v1/tests/mocked/signer.rs b/crates/rpc/src/v1/tests/mocked/signer.rs\n--- a/crates/rpc/src/v1/tests/mocked/signer.rs\n+++ b/crates/rpc/src/v1/tests/mocked/signer.rs\n@@ -656,6 +656,7 @@ fn should_confirm_sign_transaction_with_rlp() {\n         + &format!(\"\\\"s\\\":\\\"0x{:x}\\\",\", U256::from(signature.s()))\n         + &format!(\"\\\"standardV\\\":\\\"0x{:x}\\\",\", U256::from(t.standard_v()))\n         + r#\"\"to\":\"0xd46e8dd67c5d32be8058bb8eb970870f07244567\",\"transactionIndex\":null,\"#\n+        + r#\"\"type\":\"0x0\",\"#\n         + &format!(\"\\\"v\\\":\\\"0x{:x}\\\",\", U256::from(t.v()))\n         + r#\"\"value\":\"0x1\"\"#\n         + r#\"}},\"id\":1}\"#;\ndiff --git a/crates/rpc/src/v1/tests/mocked/signing.rs b/crates/rpc/src/v1/tests/mocked/signing.rs\n--- a/crates/rpc/src/v1/tests/mocked/signing.rs\n+++ b/crates/rpc/src/v1/tests/mocked/signing.rs\n@@ -427,6 +427,7 @@ fn should_add_sign_transaction_to_the_queue() {\n         + &format!(\"\\\"s\\\":\\\"0x{:x}\\\",\", U256::from(signature.s()))\n         + &format!(\"\\\"standardV\\\":\\\"0x{:x}\\\",\", U256::from(t.standard_v()))\n         + r#\"\"to\":\"0xd46e8dd67c5d32be8058bb8eb970870f07244567\",\"transactionIndex\":null,\"#\n+        + r#\"\"type\":\"0x0\",\"#\n         + &format!(\"\\\"v\\\":\\\"0x{:x}\\\",\", U256::from(t.v()))\n         + r#\"\"value\":\"0x9184e72a\"\"#\n         + r#\"}},\"id\":1}\"#;\ndiff --git a/crates/rpc/src/v1/tests/mocked/signing_unsafe.rs b/crates/rpc/src/v1/tests/mocked/signing_unsafe.rs\n--- a/crates/rpc/src/v1/tests/mocked/signing_unsafe.rs\n+++ b/crates/rpc/src/v1/tests/mocked/signing_unsafe.rs\n@@ -227,6 +227,7 @@ fn rpc_eth_sign_transaction() {\n         + &format!(\"\\\"s\\\":\\\"0x{:x}\\\",\", U256::from(signature.s()))\n         + &format!(\"\\\"standardV\\\":\\\"0x{:x}\\\",\", U256::from(t.standard_v()))\n         + r#\"\"to\":\"0xd46e8dd67c5d32be8058bb8eb970870f07244567\",\"transactionIndex\":null,\"#\n+        + r#\"\"type\":\"0x0\",\"#\n         + &format!(\"\\\"v\\\":\\\"0x{:x}\\\",\", U256::from(t.v()))\n         + r#\"\"value\":\"0x9184e72a\"\"#\n         + r#\"}},\"id\":1}\"#;\n",
        "problem_statement": "OE node doesn't return type of transaction according to EIP-1559\nOE node doesn't return type of transaction according to eip1559 neither in eth_getTransactionByHash nor in eth_getTransactionReceipt  JSON RPC methods.\r\nAn example of transaction:\r\n```\r\ncurl --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByHash\",\"params\":[\"0x84abc461c2a6179596c80c869eb2528d0c6256ffdcec9b091af598559568803f\"],\"id\":1}' -H \"Content-Type: application/json\" -X POST https://xdai-archive.blockscout.com/oe-only\r\n{\"jsonrpc\":\"2.0\",\"result\":{\"blockHash\":\"0xbbf087c2c12dc2cebc5f76a59e1a5a163df6e4ddc3d2c0f9c9ea612b2f91324c\",\"blockNumber\":\"0x128fa62\",\"chainId\":\"0x64\",\"condition\":null,\"creates\":null,\"from\":\"0xef5c9267d2921d8eb50c41fca00f15ce153aedcb\",\"gas\":\"0x5208\",\"gasPrice\":\"0x3b9aca00\",\"hash\":\"0x84abc461c2a6179596c80c869eb2528d0c6256ffdcec9b091af598559568803f\",\"input\":\"0x\",\"nonce\":\"0x74f\",\"publicKey\":\"0xc7cb6076aaa58c0156a99f1414cc234341ea6e4ba4e9787f8c47e87a6877d51e452f8d21808ff53c4720d52ca4822aba0b39612d9ab5a7f424229929bbcbfeef\",\"r\":\"0x9bae6e3aa1a5b5812ef0a593230a1ccd3cd299e5a92d3f0423808e1e445f76ee\",\"raw\":\"0xf86e82074f843b9aca008252089472d9e579f691d62aa7e0703840db6dd2fa9fae218801bfc02ebce7ce008081eba09bae6e3aa1a5b5812ef0a593230a1ccd3cd299e5a92d3f0423808e1e445f76eea03a288307f1a01444380a583cf3626547ddb306f1e839e48329bfbf19c6f46319\",\"s\":\"0x3a288307f1a01444380a583cf3626547ddb306f1e839e48329bfbf19c6f46319\",\"standardV\":\"0x0\",\"to\":\"0x72d9e579f691d62aa7e0703840db6dd2fa9fae21\",\"transactionIndex\":\"0x2\",\"v\":\"0xeb\",\"value\":\"0x1bfc02ebce7ce00\"},\"id\":1}\r\n```\r\nWhereas NE node returns type in both methods. This issue causes the termination of one of the fetchers in Blockscout.\r\n\r\nHere is the response for the same transaction from NE node:\r\n```\r\ncurl --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByHash\",\"params\":[\"0x84abc461c2a6179596c80c869eb2528d0c6256ffdcec9b091af598559568803f\"],\"id\":1}' -H \"Content-Type: application/json\" -X POST https://xdai-archive.blockscout.com/ne-only\r\n{\"jsonrpc\":\"2.0\",\"result\":{\"hash\":\"0x84abc461c2a6179596c80c869eb2528d0c6256ffdcec9b091af598559568803f\",\"nonce\":\"0x74f\",\"blockHash\":\"0xbbf087c2c12dc2cebc5f76a59e1a5a163df6e4ddc3d2c0f9c9ea612b2f91324c\",\"blockNumber\":\"0x128fa62\",\"transactionIndex\":\"0x2\",\"from\":\"0xef5c9267d2921d8eb50c41fca00f15ce153aedcb\",\"to\":\"0x72d9e579f691d62aa7e0703840db6dd2fa9fae21\",\"value\":\"0x1bfc02ebce7ce00\",\"gasPrice\":\"0x3b9aca00\",\"gas\":\"0x5208\",\"data\":\"0x\",\"input\":\"0x\",\"type\":\"0x0\",\"v\":\"0xeb\",\"s\":\"0x3a288307f1a01444380a583cf3626547ddb306f1e839e48329bfbf19c6f46319\",\"r\":\"0x9bae6e3aa1a5b5812ef0a593230a1ccd3cd299e5a92d3f0423808e1e445f76ee\"},\"id\":1}\r\n```\r\nAs far as we can see, the difference is only with `type` property.\n",
        "hints_text": "",
        "created_at": "2021-12-08T09:46:57Z",
        "version": "3.3"
    }
]