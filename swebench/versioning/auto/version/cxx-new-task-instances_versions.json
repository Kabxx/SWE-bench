[
    {
        "repo": "dtolnay/cxx",
        "pull_number": 325,
        "instance_id": "dtolnay__cxx-325",
        "issue_numbers": [
            "313"
        ],
        "base_commit": "f2fbac79ab6d2880929a3cdc8e021e53b01ee7e1",
        "patch": "diff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -80,6 +80,11 @@ pub(super) fn gen(\n                     write_struct_with_methods(out, ety, methods);\n                 }\n             }\n+            Api::TypeAlias(ety) => {\n+                if types.required_trivial_aliases.contains(&ety.ident) {\n+                    check_trivial_extern_type(out, &ety.ident)\n+                }\n+            }\n             _ => {}\n         }\n     }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -124,13 +129,18 @@ pub(super) fn gen(\n fn write_includes(out: &mut OutFile, types: &Types) {\n     for ty in types {\n         match ty {\n-            Type::Ident(ident) => match Atom::from(ident) {\n-                Some(U8) | Some(U16) | Some(U32) | Some(U64) | Some(I8) | Some(I16) | Some(I32)\n-                | Some(I64) => out.include.cstdint = true,\n-                Some(Usize) => out.include.cstddef = true,\n-                Some(CxxString) => out.include.string = true,\n-                Some(Bool) | Some(Isize) | Some(F32) | Some(F64) | Some(RustString) | None => {}\n-            },\n+            Type::Ident(ident) => {\n+                match Atom::from(ident) {\n+                    Some(U8) | Some(U16) | Some(U32) | Some(U64) | Some(I8) | Some(I16)\n+                    | Some(I32) | Some(I64) => out.include.cstdint = true,\n+                    Some(Usize) => out.include.cstddef = true,\n+                    Some(CxxString) => out.include.string = true,\n+                    Some(Bool) | Some(Isize) | Some(F32) | Some(F64) | Some(RustString) | None => {}\n+                };\n+                if types.required_trivial_aliases.contains(&ident) {\n+                    out.include.type_traits = true;\n+                };\n+            }\n             Type::RustBox(_) => out.include.type_traits = true,\n             Type::UniquePtr(_) => out.include.memory = true,\n             Type::CxxVector(_) => out.include.vector = true,\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -401,6 +411,11 @@ fn check_enum(out: &mut OutFile, enm: &Enum) {\n     }\n }\n \n+fn check_trivial_extern_type(out: &mut OutFile, id: &Ident) {\n+    writeln!(out, \"static_assert(std::is_trivially_move_constructible<{}>::value,\\\"type {} marked as Trivial in Rust is not trivially move constructible in C++\\\");\", id, id);\n+    writeln!(out, \"static_assert(std::is_trivially_destructible<{}>::value,\\\"type {} marked as Trivial in Rust is not trivially destructible in C++\\\");\", id, id);\n+}\n+\n fn write_exception_glue(out: &mut OutFile, apis: &[Api]) {\n     let mut has_cxx_throws = false;\n     for api in apis {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -57,6 +57,10 @@ fn expand(ffi: Module, apis: &[Api], types: &Types) -> TokenStream {\n             Api::TypeAlias(alias) => {\n                 expanded.extend(expand_type_alias(alias));\n                 hidden.extend(expand_type_alias_verify(namespace, alias));\n+                let ident = &alias.ident;\n+                if types.required_trivial_aliases.contains(ident) {\n+                    hidden.extend(expand_type_alias_kind_trivial_verify(alias));\n+                }\n             }\n         }\n     }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -179,6 +183,7 @@ fn expand_cxx_type(namespace: &Namespace, ety: &ExternType) -> TokenStream {\n \n         unsafe impl ::cxx::ExternType for #ident {\n             type Id = #type_id;\n+            type Kind = ::cxx::Opaque;\n         }\n     }\n }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -677,6 +682,18 @@ fn expand_type_alias_verify(namespace: &Namespace, alias: &TypeAlias) -> TokenSt\n     }\n }\n \n+fn expand_type_alias_kind_trivial_verify(type_alias: &TypeAlias) -> TokenStream {\n+    let ident = &type_alias.ident;\n+    let begin_span = type_alias.type_token.span;\n+    let end_span = type_alias.semi_token.span;\n+    let begin = quote_spanned!(begin_span=> ::cxx::private::verify_extern_kind::<);\n+    let end = quote_spanned!(end_span=> >);\n+\n+    quote! {\n+        const _: fn() = #begin #ident, ::cxx::Trivial #end;\n+    }\n+}\n+\n fn type_id(namespace: &Namespace, ident: &Ident) -> TokenStream {\n     let mut path = String::new();\n     for name in namespace {\ndiff --git a/src/extern_type.rs b/src/extern_type.rs\n--- a/src/extern_type.rs\n+++ b/src/extern_type.rs\n@@ -54,7 +54,7 @@\n /// ## Integrating with bindgen-generated types\n ///\n /// Handwritten `ExternType` impls make it possible to plug in a data structure\n-/// emitted by bindgen as the definition of an opaque C++ type emitted by CXX.\n+/// emitted by bindgen as the definition of a C++ type emitted by CXX.\n ///\n /// By writing the unsafe `ExternType` impl, the programmer asserts that the C++\n /// namespace and type name given in the type id refers to a C++ type that is\ndiff --git a/src/extern_type.rs b/src/extern_type.rs\n--- a/src/extern_type.rs\n+++ b/src/extern_type.rs\n@@ -69,10 +69,11 @@\n /// #     pub struct StringPiece([usize; 2]);\n /// # }\n ///\n-/// use cxx::{type_id, ExternType};\n+/// use cxx::{type_id, ExternType, Opaque};\n ///\n /// unsafe impl ExternType for folly_sys::StringPiece {\n ///     type Id = type_id!(\"folly::StringPiece\");\n+///     type Kind = Opaque;\n /// }\n ///\n /// #[cxx::bridge(namespace = folly)]\ndiff --git a/src/extern_type.rs b/src/extern_type.rs\n--- a/src/extern_type.rs\n+++ b/src/extern_type.rs\n@@ -92,6 +93,29 @@\n /// #\n /// # fn main() {}\n /// ```\n+///\n+/// ## Opaque and Trivial types\n+///\n+/// Some C++ types are safe to hold and pass around in Rust, by value.\n+/// Those C++ types must have a trivial move constructor, and must\n+/// have no destructor.\n+///\n+/// If you believe your C++ type is indeed trivial, you can specify\n+/// ```\n+/// # struct TypeName;\n+/// # unsafe impl cxx::ExternType for TypeName {\n+/// type Id = cxx::type_id!(\"name::space::of::TypeName\");\n+/// type Kind = cxx::Trivial;\n+/// # }\n+/// ```\n+/// which will enable you to pass it into C++ functions by value,\n+/// return it by value from such functions, and include it in\n+/// `struct`s that you have declared to `cxx::bridge`. Your promises\n+/// about the triviality of the C++ type will be checked using\n+/// `static_assert`s in the generated C++.\n+///\n+/// Opaque types can't be passed by value, but can still be held\n+/// in `UniquePtr`.\n pub unsafe trait ExternType {\n     /// A type-level representation of the type's C++ namespace and type name.\n     ///\ndiff --git a/src/extern_type.rs b/src/extern_type.rs\n--- a/src/extern_type.rs\n+++ b/src/extern_type.rs\n@@ -101,10 +125,32 @@ pub unsafe trait ExternType {\n     /// # struct TypeName;\n     /// # unsafe impl cxx::ExternType for TypeName {\n     /// type Id = cxx::type_id!(\"name::space::of::TypeName\");\n+    /// type Kind = cxx::Opaque;\n     /// # }\n     /// ```\n     type Id;\n+\n+    /// Either `cxx::Opaque` or `cxx::Trivial`. If in doubt, use\n+    /// `cxx::Opaque`.\n+    type Kind;\n+}\n+\n+pub(crate) mod kind {\n+\n+    /// An opaque type which can't be passed or held by value within Rust.\n+    /// For example, a C++ type with a destructor, or a non-trivial move\n+    /// constructor. Rust's strict move semantics mean that we can't own\n+    /// these by value in Rust, but they can still be owned by a\n+    /// `UniquePtr`...\n+    pub struct Opaque;\n+\n+    /// A type with trivial move constructors and no destructor, which\n+    /// can therefore be owned and moved around in Rust code directly.\n+    pub struct Trivial;\n }\n \n #[doc(hidden)]\n pub fn verify_extern_type<T: ExternType<Id = Id>, Id>() {}\n+\n+#[doc(hidden)]\n+pub fn verify_extern_kind<T: ExternType<Kind = Kind>, Kind>() {}\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -395,6 +395,8 @@ mod unwind;\n pub use crate::cxx_string::CxxString;\n pub use crate::cxx_vector::CxxVector;\n pub use crate::exception::Exception;\n+pub use crate::extern_type::kind::Opaque;\n+pub use crate::extern_type::kind::Trivial;\n pub use crate::extern_type::ExternType;\n pub use crate::unique_ptr::UniquePtr;\n pub use cxxbridge_macro::bridge;\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -422,6 +424,7 @@ pub type Vector<T> = CxxVector<T>;\n #[doc(hidden)]\n pub mod private {\n     pub use crate::cxx_vector::VectorElement;\n+    pub use crate::extern_type::verify_extern_kind;\n     pub use crate::extern_type::verify_extern_type;\n     pub use crate::function::FatFunction;\n     pub use crate::opaque::Opaque;\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -338,6 +338,7 @@ fn is_unsized(cx: &mut Check, ty: &Type) -> bool {\n         || cx.types.cxx.contains(ident)\n             && !cx.types.structs.contains_key(ident)\n             && !cx.types.enums.contains_key(ident)\n+            && !cx.types.required_trivial_aliases.contains(ident)\n         || cx.types.rust.contains(ident)\n }\n \ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -376,7 +377,11 @@ fn describe(cx: &mut Check, ty: &Type) -> String {\n             } else if cx.types.enums.contains_key(ident) {\n                 \"enum\".to_owned()\n             } else if cx.types.cxx.contains(ident) {\n-                \"C++ type\".to_owned()\n+                if cx.types.required_trivial_aliases.contains(ident) {\n+                    \"trivial C++ type\".to_owned()\n+                } else {\n+                    \"non-trivial C++ type\".to_owned()\n+                }\n             } else if cx.types.rust.contains(ident) {\n                 \"opaque Rust type\".to_owned()\n             } else if Atom::from(ident) == Some(CxxString) {\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -14,6 +14,7 @@ pub struct Types<'a> {\n     pub rust: Set<&'a Ident>,\n     pub aliases: Map<&'a Ident, &'a TypeAlias>,\n     pub untrusted: Map<&'a Ident, &'a ExternType>,\n+    pub required_trivial_aliases: Set<&'a Ident>,\n }\n \n impl<'a> Types<'a> {\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -135,6 +136,55 @@ impl<'a> Types<'a> {\n             }\n         }\n \n+        // All these APIs may contain types passed by value. We need to ensure\n+        // we check that this is permissible. We do this _after_ scanning all\n+        // the APIs above, in case some function or struct references a type\n+        // which is declared subsequently.\n+        let mut required_trivial_aliases = Set::new();\n+\n+        fn insist_alias_types_are_trivial<'c>(\n+            required_trivial_aliases: &mut Set<&'c Ident>,\n+            aliases: &Map<&'c Ident, &'c TypeAlias>,\n+            ty: &'c Type,\n+        ) {\n+            if let Type::Ident(ident) = ty {\n+                if aliases.contains_key(ident) {\n+                    required_trivial_aliases.insert(ident);\n+                }\n+            }\n+        }\n+\n+        for api in apis {\n+            match api {\n+                Api::Struct(strct) => {\n+                    for field in &strct.fields {\n+                        insist_alias_types_are_trivial(\n+                            &mut required_trivial_aliases,\n+                            &aliases,\n+                            &field.ty,\n+                        );\n+                    }\n+                }\n+                Api::CxxFunction(efn) | Api::RustFunction(efn) => {\n+                    for arg in &efn.args {\n+                        insist_alias_types_are_trivial(\n+                            &mut required_trivial_aliases,\n+                            &aliases,\n+                            &arg.ty,\n+                        );\n+                    }\n+                    if let Some(ret) = &efn.ret {\n+                        insist_alias_types_are_trivial(\n+                            &mut required_trivial_aliases,\n+                            &aliases,\n+                            &ret,\n+                        );\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n         Types {\n             all,\n             structs,\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -143,6 +193,7 @@ impl<'a> Types<'a> {\n             rust,\n             aliases,\n             untrusted,\n+            required_trivial_aliases,\n         }\n     }\n \n",
        "test_patch": "diff --git a/tests/ui/by_value_not_supported.stderr b/tests/ui/by_value_not_supported.stderr\n--- a/tests/ui/by_value_not_supported.stderr\n+++ b/tests/ui/by_value_not_supported.stderr\n@@ -1,4 +1,4 @@\n-error: using C++ type by value is not supported\n+error: using non-trivial C++ type by value is not supported\n  --> $DIR/by_value_not_supported.rs:4:9\n   |\n 4 |         c: C,\ndiff --git a/tests/ui/by_value_not_supported.stderr b/tests/ui/by_value_not_supported.stderr\n--- a/tests/ui/by_value_not_supported.stderr\n+++ b/tests/ui/by_value_not_supported.stderr\n@@ -16,13 +16,13 @@ error: using C++ string by value is not supported\n 6 |         s: CxxString,\n   |         ^^^^^^^^^^^^\n \n-error: passing C++ type by value is not supported\n+error: passing non-trivial C++ type by value is not supported\n   --> $DIR/by_value_not_supported.rs:16:14\n    |\n 16 |         fn f(c: C) -> C;\n    |              ^^^^\n \n-error: returning C++ type by value is not supported\n+error: returning non-trivial C++ type by value is not supported\n   --> $DIR/by_value_not_supported.rs:16:23\n    |\n 16 |         fn f(c: C) -> C;\n",
        "problem_statement": "ExternTypes may be safely passed and returned by value\n```rust\r\n        unsafe impl cxx::ExternType for bindgen::Bob {\r\n            type Id = cxx::type_id!(\"Bob\");\r\n        }\r\n        mod bindgen {\r\n            #[repr(C)]\r\n            pub struct Bob {\r\n                pub a: u32,\r\n                pub b: u32,\r\n            }\r\n        }\r\n        #[cxx::bridge]\r\n        pub mod cxxbridge {\r\n            extern \"C\" {\r\n                include!(\"input.h\");\r\n                pub fn give_bob() -> Bob;\r\n                type Bob = super::bindgen::Bob;\r\n            }\r\n        }\r\n```\r\n\r\ndoesn't work because we can't return `ExternType`s by value.\r\n\r\nEach extern type may be one of three fundamental categories of type:\r\n\r\n* An alias to another `cxx::bridge` type (in which case it's a simple alias and we don't do anything in the current instantiation)\r\n* A type which `is_trivially_move_constructible && is_trivially_destructible`. If so, we allow allow it to be passed by value into/our of cxx types, and we check this with `static_asserts` as discussed in #280. (\"trivial\" types for short henceforth)\r\n* A type which isn't trivially move constructable/destructable. In these cases we don't allow use by value but we do allow generation of `UniquePtr` traits etc. as per #312.\r\n\r\nThis distinction is implied by #280 but this could be done as a pre-requisite step first. I also feel it would be desirable to pin this down before finalizing design for #312.\r\n\r\nThe question is, for a given `ExternType`, how does cxx know which of these three categories of type it is? What's your plan there? Is it to require the developer to implement an extra trait for trivial types which is then checked for safety using `static_assert`? Or did you plan to do something funky to auto-detect trivial types at build time?\r\n\r\n(NB for this last category of types, my higher-level code generator plans to create shims which allow us to call pre-existing C++ APIs that take a `T` by instead passing a `UniquePtr<T>`. I have yet to do this bit. It makes superficial sense that \"complicated\" types need to be entirely allocated, accessed, and managed within C++ but can still be owned by Rust. Figuring out whether this is ergonomic in practice is arguably the entire point of my https://github.com/google/autocxx experiments... if this doesn't work out it's back to the drawing board!)\n",
        "hints_text": "Hypothetical design:\r\n\r\n* `ExternType` gains a new method along these lines:\r\n```rust\r\npub enum TypeCategory { // better name needed\r\n   #[doc(hidden)]\r\n   Alias,\r\n   Trivial,\r\n   NonTrivial\r\n}\r\n\r\npub unsafe trait ExternType {\r\n    //...\r\n    type Id;\r\n\r\n    fn get_category() -> TypeCategory {\r\n       TypeCategory::NonTrivial // default implementation\r\n    }\r\n}\r\n```\r\n\r\nWhere we expand `ExternType` ourselves, we return `Alias`. Users' pre-existing implementations of `ExternType` will (obviously) get `NonTrivial` and thus get current behavior.\r\n\r\nBut folk can override `get_category` if they need to state that their type is trivial.\r\n\r\nThen:\r\n* For `Alias` types, we do nothing.\r\n* For `Trivial` or `NonTrivial` types, we _may_ generate `UniquePtrTarget` and other traits depending on the decisions in #312.\r\n* For `Trivial` types, we allow them to be passed by value into and out of functions just as if the type were declared in the `cxx::bridge` block. We also generate some `static_asserts` to verify that they really are trivial.\n(though maybe if the `ExternType` is never actually instantiated, we may need to do this with an associated type like for `Id`. But something along these lines...)\nI'm fiddling around here. I so far have concluded:\r\n* I probably can't use the existing `ExternType` trait derivation, since it's probably not accessible at the point of macro expansion or C++ expansion. As I understand it, it's only used to generate something which can be used for a compile-time assertion check when building the resultant Rust code.\r\n* Instead, it's probably necessary for this \"trivial\" annotation to be somewhere inside the `#[cxx::bridge]` mod. Right now I'm imagining that a type can `impl` a new trait here to indicate that it's trivial. Fiddling in that direction.\r\n\r\nI probably won't have another chance to touch this till next week.\nThat approach looks promising to me.\r\n\r\nAs you found, the design of cxx is such that we can't *know* most things during macro expansion, but we can generate static assertions to *verify* things post macro expansion.\r\n\r\nLooking at your categorization of Alias, Trivial, NonTrivial --- is there any need to distinguish Alias vs NonTrivial? I hope we can treat those exactly the same.\r\n\r\nAt that point the only relevant distinction would be Trivial (obtainable by value in Rust) vs NonTrivial (not obtainable by value in Rust). And the only *verification* we would need to emit is that every type alias which is exposed by value to Rust (whether in an extern function signature or as a field of a shared struct) has an ExternType impl which indicates it is Trivial.\r\n\r\nOur current scheme for verifying (though this is certainly not the only possible one) is based on:\r\n\r\nhttps://github.com/dtolnay/cxx/blob/acc7fb05f9bbf07e7d6e1accce9cdbdf26b91411/src/extern_type.rs#L109-L110\r\n\r\nwhich we instantiate as follows to verify post macro expansion that a particular type has a specific expected Id in its ExternType impl.\r\n\r\n```rust\r\nconst _: fn() = verify_extern_type::<YourType, TheExpectedId>;\r\n```\r\n\r\nI imagine a verify similar mechanism for verifying the Trivial vs NonTrivial distinction too.\r\n\r\n```rust\r\n// if your type alias was exposed by value to Rust, then we generate:\r\nconst _: fn() = verify_triviality::<YourType, Trivial>;\r\n```\r\n\r\nBeyond that, I believe the existing Rust orphan rules are good enough that we should be able to let you put #312-style \"request for an impl\" wherever the user wants. (But I need to revisit this more carefully to confirm that I am sure about this.)\nAha, I think you're saying that there should be _both_ something in the `ExternType` impl (presumably outside the `#[cxx::bridge]` block) _and_ some syntax inside the `#[cxx::bridge]` block. I was now thinking we only need the latter? Then there should be no need for the Rust-side verification that you outline, and just C++-side `static_assert`s?\r\n\r\nIs there some need to do something in the `ExternType` impl as well as inside the `#[cxx::bridge]`?\r\n\r\nAs for your question:\r\n> Looking at your categorization of Alias, Trivial, NonTrivial --- is there any need to distinguish Alias vs NonTrivial?\r\n\r\nFirst, an assumption: if there's an alias, the _target_ `cxx::bridge` actually generates all the code for the type, e.g. `UniquePtrTarget` impls, plus all the Rust-side and C++-side wrappers, and the alias therefore means there is no codegen beyond just a simple Rust `type`.\r\n\r\nI haven't yet checked that assumption, but that motivated the distinction I made.\r\n\r\nI was therefore thinking:\r\n\r\n* Alias: we need to look up the Trivial-ness by examining the target type over in its distant `#[cxx::bridge]` section. (Which we can't, of course, and I don't really have a plan there. As it affects how _we_ do codegen based on _our_ `#[cxx::bridge]` section, we really do _need_ to know. But it would be a shame if we had to specify the trivial-ness in both `#[cxx::bridge]` blocks). Also, for an `Alias`, we will _never_ generate `UniquePtrTarget` or other traits because that will be done by the target `#[cxx::bridge]`.\r\n* NonTrivial: may generate `UniquePtrTarget` etc. but can't pass by value.\r\n* Trivial: may generate `UniquePtrTarget` etc. and can pass by value.\r\n\r\nI'm also trying to plan ahead for all the different properties we might ever want to attach to types. If we're designing syntax for trivial/non-trivial maybe we should be thinking of a more general type traits arrangement.\r\n\r\nPossible properties (and I _know_ many of these will never happen, and may be more appropriate for a higher level code generator; my point is really just to indicate that we might want some general syntax for specifying what the user wants of a type):\r\n\r\nProperty | Description | Applies to extern types | Applies to opaque C++ types | C++ codegen or static assertions needed | Rust codegen needed\r\n--------- | ----------- | ------------------------ | ------------------------ | ------------------------ | ----------\r\nTrivial | Whether this can be passed by value in Rust, as discussed | Yes | No | Yes | No except in APIs\r\nUnique pointer target | Whether we should allow this too be stored in `UniquePtrs` per #236  | Yes | Yes | No | Yes\r\nVector target, etc. | Other traits as per the previous line | Yes | Yes | No | Yes\r\nGenerate field accessors | Generate accessor _functions_ to get and set C++ fields | Yes (probably non-trivial only) | Yes | Yes | Yes\r\nAllow pass UniquePtr by value | Allow this type to be passed into C++ functions \"by value\" when all we have is a UniquePtr, for compatibility with existing functions that take the type by value | Yes (non-trivial only) | Yes | Yes | Modifies existing codegen\r\n\r\nEach of those _could_ be its own `impl` block within the `#[cxx::bridge]` (as you propose in #236 and I'm starting to hack about with in 84744b7) but I do wonder if we need something nicer. e.g.\r\n\r\n```rust\r\n#[cxx::bridge]\r\nmod ffi {\r\n  // ...\r\n  impl TypeTraits for MyRustType {\r\n    const TRAITS = TypeTraits {\r\n       trivial = true;\r\n       generate_accessors = true;\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nbut it's not very Rusty syntax.\nFocusing just on Trivial/NonTrivial for now:\r\n\r\n> I think you're saying that there should be _both_ something in the `ExternType` impl (presumably outside the `#[cxx::bridge]` block) _and_ some syntax inside the `#[cxx::bridge]` block. I was now thinking we only need the latter? Then there should be no need for the Rust-side verification that you outline, and just C++-side `static_assert`s?\r\n>\r\n> Is there some need to do something in the `ExternType` impl as well as inside the `#[cxx::bridge]`?\r\n\r\nI think my plan is the opposite of your plan. You're thinking about what syntax goes in the cxx::bridge module. I am thinking no new syntax or annotation is needed in the cxx::bridge module at all to support this feature.\r\n\r\nHere are the expansion rules:\r\n\r\n```rust\r\nextern \"C++\" {\r\n    // If this type is an \"original\", not an alias:\r\n    //   pub struct ZeusClient(::cxx::private::Opaque);  // same as today\r\n    //   impl ExternType for ZeusClient { type Kind = cxx::kind::Opaque; }  // \"Opaque\" == NonTrivial\r\n    type ZeusClient;\r\n\r\n    // If an alias, only validate the type Id; no new impl:\r\n    //   verify_id::<crate::bindgen::ZeusClient, cxx::type_id!(\"ZeusClient\")>;\r\n    type ZeusClient = crate::bindgen::ZeusClient;\r\n\r\n    // If type is ever mentioned by value, verify trivial:\r\n    //   verify_kind::<ZeusClient, cxx::kind::Trivial>;\r\n    fn new(arg: &str) -> ZeusClient;\r\n\r\n    // As per #312. Allowed wherever the user feels like, subject to orphan rules.\r\n    // Optional if T is an \"original\" and has some signature involving UniquePtr<T> in the same cxx::bridge.\r\n    impl UniquePtr<ZeusClient> {}\r\n}\r\n```\r\n\r\nThe user handwrites or uses a bindgen to bring Rust definitions of trivial extern types.\r\n\r\n```rust\r\nmod bindgen {\r\n    #[repr(C)]\r\n    pub struct ZeusClient {\r\n        pub port: u16,\r\n    }\r\n}\r\n\r\nunsafe impl cxx::ExternType for bindgen::ZeusClient {\r\n    type Id = cxx::type_id!(\"ZeusClient\");\r\n    type Kind = cxx::kind::Trivial;\r\n}\r\n```\r\n\r\nNext to `verify_kind::<ZeusClient, cxx::kind::Trivial>` we can also verify is_trivially_move_constructible && is_trivially_destructible on the C++ side, but actually this is just nice-to-have since the user went on the record with their `unsafe impl` to unsafely claim it is trivial, so it's on them if that were wrong.\r\n\r\nI read your last two comments again and don't spot anything that would require more ceremony/new syntax in the cxx::bridge module, but I could just be missing it.\nAh! I hadn't thought of making this determination based on how the type is _used_. OK! I will think on that, thanks.",
        "created_at": "2020-09-25T21:20:19Z",
        "version": "0.4"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 322,
        "instance_id": "dtolnay__cxx-322",
        "issue_numbers": [
            "320"
        ],
        "base_commit": "950fb211a80de163a8b19990a9d3f3ba221455a2",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -859,12 +859,12 @@ fn expand_cxx_vector(namespace: &Namespace, elem: &Ident) -> TokenStream {\n                 }\n                 unsafe { __vector_size(v) }\n             }\n-            unsafe fn __get_unchecked(v: &::cxx::CxxVector<Self>, pos: usize) -> &Self {\n+            unsafe fn __get_unchecked(v: &::cxx::CxxVector<Self>, pos: usize) -> *const Self {\n                 extern \"C\" {\n                     #[link_name = #link_get_unchecked]\n                     fn __get_unchecked(_: &::cxx::CxxVector<#elem>, _: usize) -> *const #elem;\n                 }\n-                &*__get_unchecked(v, pos)\n+                __get_unchecked(v, pos)\n             }\n             fn __unique_ptr_null() -> *mut ::std::ffi::c_void {\n                 extern \"C\" {\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -4,6 +4,7 @@ use core::fmt::{self, Display};\n use core::marker::PhantomData;\n use core::mem;\n use core::ptr;\n+use core::slice;\n \n /// Binding to C++ `std::vector<T, std::allocator<T>>`.\n ///\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -44,7 +45,7 @@ where\n     /// out of bounds.\n     pub fn get(&self, pos: usize) -> Option<&T> {\n         if pos < self.len() {\n-            Some(unsafe { T::__get_unchecked(self, pos) })\n+            Some(unsafe { self.get_unchecked(pos) })\n         } else {\n             None\n         }\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -61,7 +62,24 @@ where\n     ///\n     /// [operator_at]: https://en.cppreference.com/w/cpp/container/vector/operator_at\n     pub unsafe fn get_unchecked(&self, pos: usize) -> &T {\n-        T::__get_unchecked(self, pos)\n+        &*T::__get_unchecked(self, pos)\n+    }\n+\n+    /// Returns a slice to the underlying contiguous array of elements.\n+    pub fn as_slice(&self) -> &[T] {\n+        let len = self.len();\n+        if len == 0 {\n+            // The slice::from_raw_parts in the other branch requires a nonnull\n+            // and properly aligned data ptr. C++ standard does not guarantee\n+            // that data() on a vector with size 0 would return a nonnull\n+            // pointer or sufficiently aligned pointer, so using it would be\n+            // undefined behavior. Create our own empty slice in Rust instead\n+            // which upholds the invariants.\n+            <&[T]>::default()\n+        } else {\n+            let ptr = unsafe { T::__get_unchecked(self, 0) };\n+            unsafe { slice::from_raw_parts(ptr, len) }\n+        }\n     }\n }\n \ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -122,7 +140,7 @@ where\n pub unsafe trait VectorElement: Sized {\n     const __NAME: &'static dyn Display;\n     fn __vector_size(v: &CxxVector<Self>) -> usize;\n-    unsafe fn __get_unchecked(v: &CxxVector<Self>, pos: usize) -> &Self;\n+    unsafe fn __get_unchecked(v: &CxxVector<Self>, pos: usize) -> *const Self;\n     fn __unique_ptr_null() -> *mut c_void;\n     unsafe fn __unique_ptr_raw(raw: *mut CxxVector<Self>) -> *mut c_void;\n     unsafe fn __unique_ptr_get(repr: *mut c_void) -> *const CxxVector<Self>;\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -145,14 +163,14 @@ macro_rules! impl_vector_element {\n                 }\n                 unsafe { __vector_size(v) }\n             }\n-            unsafe fn __get_unchecked(v: &CxxVector<$ty>, pos: usize) -> &$ty {\n+            unsafe fn __get_unchecked(v: &CxxVector<$ty>, pos: usize) -> *const $ty {\n                 extern \"C\" {\n                     attr! {\n                         #[link_name = concat!(\"cxxbridge04$std$vector$\", $segment, \"$get_unchecked\")]\n                         fn __get_unchecked(_: &CxxVector<$ty>, _: usize) -> *const $ty;\n                     }\n                 }\n-                &*__get_unchecked(v, pos)\n+                __get_unchecked(v, pos)\n             }\n             fn __unique_ptr_null() -> *mut c_void {\n                 extern \"C\" {\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -6,7 +6,7 @@\n \n pub mod module;\n \n-use cxx::{CxxString, UniquePtr};\n+use cxx::{CxxString, CxxVector, UniquePtr};\n use std::fmt::{self, Display};\n \n #[cxx::bridge(namespace = tests)]\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -144,6 +144,8 @@ pub mod ffi {\n         fn r_take_sliceu8(s: &[u8]);\n         fn r_take_rust_string(s: String);\n         fn r_take_unique_ptr_string(s: UniquePtr<CxxString>);\n+        fn r_take_ref_vector(v: &CxxVector<u8>);\n+        fn r_take_ref_empty_vector(v: &CxxVector<u64>);\n         fn r_take_rust_vec(v: Vec<u8>);\n         fn r_take_rust_vec_string(v: Vec<String>);\n         fn r_take_ref_rust_vec(v: &Vec<u8>);\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -307,6 +309,16 @@ fn r_take_unique_ptr_string(s: UniquePtr<CxxString>) {\n     assert_eq!(s.as_ref().unwrap().to_str().unwrap(), \"2020\");\n }\n \n+fn r_take_ref_vector(v: &CxxVector<u8>) {\n+    let slice = v.as_slice();\n+    assert_eq!(slice, [20, 2, 0]);\n+}\n+\n+fn r_take_ref_empty_vector(v: &CxxVector<u64>) {\n+    assert!(v.as_slice().is_empty());\n+    assert!(v.is_empty());\n+}\n+\n fn r_take_rust_vec(v: Vec<u8>) {\n     let _ = v;\n }\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -399,6 +399,11 @@ extern \"C\" const char *cxx_run_test() noexcept {\n   r_take_rust_string(rust::String(\"2020\"));\n   r_take_unique_ptr_string(\n       std::unique_ptr<std::string>(new std::string(\"2020\")));\n+  r_take_ref_vector(std::vector<uint8_t>{20, 2, 0});\n+  std::vector<uint64_t> empty_vector;\n+  r_take_ref_empty_vector(empty_vector);\n+  empty_vector.reserve(10);\n+  r_take_ref_empty_vector(empty_vector);\n   r_take_enum(Enum::AVal);\n \n   ASSERT(r_try_return_primitive() == 2020);\n",
        "problem_statement": "Retrieve slice from CxxVector\nThere is currently no way to get a slice out of a CxxVector. Let's add the a new get_slice() helper so that rust code can use a slice. \r\n\r\nBackground, we're doing some C++ -> rust API in-house and there's been a wish for that functionality to have \"nicer C++ APIs\".\r\n\r\nYes, one can use a slice in the FFI API as a work-around. I.e. use rust::Slice<T> in C++.\r\n\r\nPull request incoming.\n",
        "hints_text": "",
        "created_at": "2020-09-24T20:03:33Z",
        "version": "0.4"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 319,
        "instance_id": "dtolnay__cxx-319",
        "issue_numbers": [
            "64"
        ],
        "base_commit": "13213b7a85cc1b5dcac0848bb664f34d463ac7e7",
        "patch": "diff --git a/gen/cmd/src/app.rs b/gen/cmd/src/app.rs\n--- a/gen/cmd/src/app.rs\n+++ b/gen/cmd/src/app.rs\n@@ -65,18 +65,25 @@ pub(super) fn from_args() -> Opt {\n         .unwrap_or_default()\n         .map(str::to_owned)\n         .collect();\n-    let output = match matches.value_of_os(OUTPUT) {\n-        None => Output::Stdout,\n-        Some(path) if path == \"-\" => Output::Stdout,\n-        Some(path) => Output::File(PathBuf::from(path)),\n-    };\n+\n+    let mut outputs = Vec::new();\n+    for path in matches.values_of_os(OUTPUT).unwrap_or_default() {\n+        outputs.push(if path == \"-\" {\n+            Output::Stdout\n+        } else {\n+            Output::File(PathBuf::from(path))\n+        });\n+    }\n+    if outputs.is_empty() {\n+        outputs.push(Output::Stdout);\n+    }\n \n     Opt {\n         input,\n         cxx_impl_annotations,\n         header,\n         include,\n-        output,\n+        outputs,\n     }\n }\n \ndiff --git a/gen/cmd/src/app.rs b/gen/cmd/src/app.rs\n--- a/gen/cmd/src/app.rs\n+++ b/gen/cmd/src/app.rs\n@@ -142,6 +149,7 @@ not specified.\n         .long(OUTPUT)\n         .short(\"o\")\n         .takes_value(true)\n+        .multiple(true)\n         .validator_os(validate_utf8)\n         .help(HELP)\n }\ndiff --git a/gen/cmd/src/main.rs b/gen/cmd/src/main.rs\n--- a/gen/cmd/src/main.rs\n+++ b/gen/cmd/src/main.rs\n@@ -25,7 +25,7 @@ struct Opt {\n     header: bool,\n     cxx_impl_annotations: Option<String>,\n     include: Vec<String>,\n-    output: Output,\n+    outputs: Vec<Output>,\n }\n \n fn main() {\ndiff --git a/gen/cmd/src/main.rs b/gen/cmd/src/main.rs\n--- a/gen/cmd/src/main.rs\n+++ b/gen/cmd/src/main.rs\n@@ -35,35 +35,54 @@ fn main() {\n     }\n }\n \n+enum Kind {\n+    GeneratedHeader,\n+    GeneratedImplementation,\n+    Header,\n+}\n+\n fn try_main() -> Result<()> {\n     let opt = app::from_args();\n \n-    let gen_header = opt.header || opt.output.ends_with(\".h\");\n+    let mut outputs = Vec::new();\n+    let mut gen_header = false;\n+    let mut gen_implementation = false;\n+    for output in opt.outputs {\n+        let kind = if opt.input.is_none() {\n+            Kind::Header\n+        } else if opt.header || output.ends_with(\".h\") {\n+            gen_header = true;\n+            Kind::GeneratedHeader\n+        } else {\n+            gen_implementation = true;\n+            Kind::GeneratedImplementation\n+        };\n+        outputs.push((output, kind));\n+    }\n \n     let gen = gen::Opt {\n         include: opt.include,\n         cxx_impl_annotations: opt.cxx_impl_annotations,\n         gen_header,\n-        gen_implementation: !gen_header,\n+        gen_implementation,\n     };\n \n-    let content;\n-    let content = match (opt.input, gen_header) {\n-        (Some(input), true) => {\n-            content = gen::generate_from_path(&input, &gen).header;\n-            content.as_slice()\n-        }\n-        (Some(input), false) => {\n-            content = gen::generate_from_path(&input, &gen).implementation;\n-            content.as_slice()\n-        }\n-        (None, true) => include::HEADER.as_bytes(),\n-        (None, false) => unreachable!(), // enforced by required_unless\n+    let generated_code = if let Some(input) = opt.input {\n+        gen::generate_from_path(&input, &gen)\n+    } else {\n+        Default::default()\n     };\n \n-    match opt.output {\n-        Output::Stdout => drop(io::stdout().write_all(content)),\n-        Output::File(path) => fs::write(path, content)?,\n+    for (output, kind) in outputs {\n+        let content = match kind {\n+            Kind::GeneratedHeader => &generated_code.header,\n+            Kind::GeneratedImplementation => &generated_code.implementation,\n+            Kind::Header => include::HEADER.as_bytes(),\n+        };\n+        match output {\n+            Output::Stdout => drop(io::stdout().write_all(content)),\n+            Output::File(path) => fs::write(path, content)?,\n+        }\n     }\n \n     Ok(())\ndiff --git a/gen/src/mod.rs b/gen/src/mod.rs\n--- a/gen/src/mod.rs\n+++ b/gen/src/mod.rs\n@@ -50,6 +50,7 @@ pub struct Opt {\n }\n \n /// Results of code generation.\n+#[derive(Default)]\n pub struct GeneratedCode {\n     /// The bytes of a C++ header file.\n     pub header: Vec<u8>,\n",
        "test_patch": "diff --git a/gen/cmd/src/test.rs b/gen/cmd/src/test.rs\n--- a/gen/cmd/src/test.rs\n+++ b/gen/cmd/src/test.rs\n@@ -32,7 +32,7 @@ OPTIONS:\n             parse or even require the given paths to exist; they simply go\n             into the generated C++ code as #include lines.\n                \\x20\n-    -o, --output <output>\n+    -o, --output <output>...\n             Path of file to write as output. Output goes to stdout if -o is\n             not specified.\n                \\x20\n",
        "problem_statement": "Consider allowing one cxxbridge cli invocation to emit both header and cc\nAs currently implemented, two invocations of the cli command are required and the output goes to stdout.\r\n\r\n```bash\r\n$ cxxbridge path/to/lib.rs --header > generated.h\r\n$ cxxbridge path/to/lib.rs > generated.cc\r\n```\r\n\r\nIn some Starlark-based environments (or others) it turns out to be desirable to emit both outputs from a single invocation.\r\n\r\n```python\r\ngenrule(\r\n    name = \"gen\",\r\n    src = \"...\",\r\n    cmd = \"$(exe //path/to:cxxbridge-cmd) ${SRC}\",\r\n    outs = {\r\n        \"header\": [\"generated.h\"],\r\n        \"source\": [\"generated.cc\"],\r\n    },\r\n)\r\n```\n",
        "hints_text": "",
        "created_at": "2020-09-24T15:35:19Z",
        "version": "0.4"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 311,
        "instance_id": "dtolnay__cxx-311",
        "issue_numbers": [
            "309"
        ],
        "base_commit": "d22babaeb43d3329c6ad64d85e792792248f82ba",
        "patch": "diff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -775,9 +775,11 @@ fn write_rust_function_shim_impl(\n         write!(out, \"extern$\");\n     }\n     write!(out, \")\");\n-    if let Some(ret) = &sig.ret {\n-        if let Type::RustBox(_) | Type::UniquePtr(_) = ret {\n-            write!(out, \")\");\n+    if !indirect_return {\n+        if let Some(ret) = &sig.ret {\n+            if let Type::RustBox(_) | Type::UniquePtr(_) = ret {\n+                write!(out, \")\");\n+            }\n         }\n     }\n     writeln!(out, \";\");\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -580,42 +580,42 @@ fn expand_rust_function_shim_impl(\n     };\n     call.extend(quote! { (#(#vars),*) });\n \n-    let mut expr = sig\n-        .ret\n-        .as_ref()\n-        .and_then(|ret| match ret {\n-            Type::Ident(ident) if ident == RustString => {\n-                Some(quote!(::cxx::private::RustString::from(#call)))\n-            }\n-            Type::RustBox(_) => Some(quote!(::std::boxed::Box::into_raw(#call))),\n-            Type::RustVec(vec) => {\n-                if vec.inner == RustString {\n-                    Some(quote!(::cxx::private::RustVec::from_vec_string(#call)))\n-                } else {\n-                    Some(quote!(::cxx::private::RustVec::from(#call)))\n-                }\n+    let conversion = sig.ret.as_ref().and_then(|ret| match ret {\n+        Type::Ident(ident) if ident == RustString => Some(quote!(::cxx::private::RustString::from)),\n+        Type::RustBox(_) => Some(quote!(::std::boxed::Box::into_raw)),\n+        Type::RustVec(vec) => {\n+            if vec.inner == RustString {\n+                Some(quote!(::cxx::private::RustVec::from_vec_string))\n+            } else {\n+                Some(quote!(::cxx::private::RustVec::from))\n             }\n-            Type::UniquePtr(_) => Some(quote!(::cxx::UniquePtr::into_raw(#call))),\n-            Type::Ref(ty) => match &ty.inner {\n-                Type::Ident(ident) if ident == RustString => match ty.mutability {\n-                    None => Some(quote!(::cxx::private::RustString::from_ref(#call))),\n-                    Some(_) => Some(quote!(::cxx::private::RustString::from_mut(#call))),\n-                },\n-                Type::RustVec(vec) if vec.inner == RustString => match ty.mutability {\n-                    None => Some(quote!(::cxx::private::RustVec::from_ref_vec_string(#call))),\n-                    Some(_) => Some(quote!(::cxx::private::RustVec::from_mut_vec_string(#call))),\n-                },\n-                Type::RustVec(_) => match ty.mutability {\n-                    None => Some(quote!(::cxx::private::RustVec::from_ref(#call))),\n-                    Some(_) => Some(quote!(::cxx::private::RustVec::from_mut(#call))),\n-                },\n-                _ => None,\n+        }\n+        Type::UniquePtr(_) => Some(quote!(::cxx::UniquePtr::into_raw)),\n+        Type::Ref(ty) => match &ty.inner {\n+            Type::Ident(ident) if ident == RustString => match ty.mutability {\n+                None => Some(quote!(::cxx::private::RustString::from_ref)),\n+                Some(_) => Some(quote!(::cxx::private::RustString::from_mut)),\n+            },\n+            Type::RustVec(vec) if vec.inner == RustString => match ty.mutability {\n+                None => Some(quote!(::cxx::private::RustVec::from_ref_vec_string)),\n+                Some(_) => Some(quote!(::cxx::private::RustVec::from_mut_vec_string)),\n+            },\n+            Type::RustVec(_) => match ty.mutability {\n+                None => Some(quote!(::cxx::private::RustVec::from_ref)),\n+                Some(_) => Some(quote!(::cxx::private::RustVec::from_mut)),\n             },\n-            Type::Str(_) => Some(quote!(::cxx::private::RustStr::from(#call))),\n-            Type::SliceRefU8(_) => Some(quote!(::cxx::private::RustSliceU8::from(#call))),\n             _ => None,\n-        })\n-        .unwrap_or(call);\n+        },\n+        Type::Str(_) => Some(quote!(::cxx::private::RustStr::from)),\n+        Type::SliceRefU8(_) => Some(quote!(::cxx::private::RustSliceU8::from)),\n+        _ => None,\n+    });\n+\n+    let mut expr = match conversion {\n+        None => call,\n+        Some(conversion) if !sig.throws => quote!(#conversion(#call)),\n+        Some(conversion) => quote!(::std::result::Result::map(#call, #conversion)),\n+    };\n \n     let mut outparam = None;\n     let indirect_return = indirect_return(sig, types);\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -152,6 +152,7 @@ pub mod ffi {\n \n         fn r_try_return_void() -> Result<()>;\n         fn r_try_return_primitive() -> Result<usize>;\n+        fn r_try_return_box() -> Result<Box<R>>;\n         fn r_fail_return_primitive() -> Result<usize>;\n \n         fn r_return_r2(n: usize) -> Box<R2>;\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -334,6 +335,10 @@ fn r_try_return_primitive() -> Result<usize, Error> {\n     Ok(2020)\n }\n \n+fn r_try_return_box() -> Result<Box<R>, Error> {\n+    Ok(Box::new(2020))\n+}\n+\n fn r_fail_return_primitive() -> Result<usize, Error> {\n     Err(Error)\n }\n",
        "problem_statement": "Can't return Result<Box<T>>\nI am trying to return a Result<Box< T >> and I am getting the below compile errors. \r\n>expected struct `std::boxed::Box`, found enum `std::result::Result`\r\n>expected enum `std::result::Result`, found *-ptr\r\n\r\nI have tried setting the return type to Result<T> and Box<T> and both compile fine.\r\n\r\nHere is a simple proof. \r\n\r\n```rust\r\n#[cxx::bridge()]\r\nmod test {\r\n    struct Test {\r\n        size: usize,\r\n    }\r\n\r\n    extern \"Rust\" {\r\n        fn test() -> Result<Box<Test>>;\r\n    }   \r\n}       \r\n        \r\nfn test() -> Result<Box<test::Test>> {\r\n    Ok(Box::<test::Test>::new(test::Test{size: 0}))\r\n}\r\n```\r\n\r\nThe reason I want to return a Result<Box<T>> is because in my use case T is a rust opaque type, but I made T a shared type to check that both Result<T> and Box<T> compile fine where Result<Box<T>> doesn't.\n",
        "hints_text": "",
        "created_at": "2020-09-21T22:23:31Z",
        "version": "0.4"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 661,
        "instance_id": "dtolnay__cxx-661",
        "issue_numbers": [
            "658"
        ],
        "base_commit": "a2bd047d68e64d42df1d278549d41c4a313809e9",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -436,7 +436,7 @@ fn expand_cxx_function_shim(efn: &ExternFn, types: &Types) -> TokenStream {\n     let receiver = efn.receiver.iter().map(|receiver| {\n         let var = receiver.var;\n         if receiver.pinned {\n-            let ty = receiver.ty();\n+            let ty = receiver.ty_self();\n             quote!(#var: #ty)\n         } else {\n             let ampersand = receiver.ampersand;\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -270,12 +270,18 @@ impl ToTokens for NamedType {\n }\n \n pub struct ReceiverType<'a>(&'a Receiver);\n+pub struct ReceiverTypeSelf<'a>(&'a Receiver);\n \n impl Receiver {\n     // &TheType\n     pub fn ty(&self) -> ReceiverType {\n         ReceiverType(self)\n     }\n+\n+    // &Self\n+    pub fn ty_self(&self) -> ReceiverTypeSelf {\n+        ReceiverTypeSelf(self)\n+    }\n }\n \n impl ToTokens for ReceiverType<'_> {\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -304,3 +310,30 @@ impl ToTokens for ReceiverType<'_> {\n         }\n     }\n }\n+\n+impl ToTokens for ReceiverTypeSelf<'_> {\n+    fn to_tokens(&self, tokens: &mut TokenStream) {\n+        let Receiver {\n+            pinned: _,\n+            ampersand,\n+            lifetime,\n+            mutable: _,\n+            var: _,\n+            ty,\n+            shorthand: _,\n+            pin_tokens,\n+            mutability,\n+        } = &self.0;\n+        if let Some((pin, langle, _rangle)) = pin_tokens {\n+            tokens.extend(quote_spanned!(pin.span=> ::std::pin::Pin));\n+            langle.to_tokens(tokens);\n+        }\n+        ampersand.to_tokens(tokens);\n+        lifetime.to_tokens(tokens);\n+        mutability.to_tokens(tokens);\n+        Token![Self](ty.rust.span()).to_tokens(tokens);\n+        if let Some((_pin, _langle, rangle)) = pin_tokens {\n+            rangle.to_tokens(tokens);\n+        }\n+    }\n+}\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -224,6 +224,7 @@ pub mod ffi {\n         fn c_return_borrow(s: &CxxString) -> UniquePtr<Borrow>;\n \n         fn const_member(self: &Borrow);\n+        fn nonconst_member(self: Pin<&mut Borrow>);\n     }\n \n     #[repr(u32)]\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -211,6 +211,8 @@ Borrow::Borrow(const std::string &s) : s(s) {}\n \n void Borrow::const_member() const {}\n \n+void Borrow::nonconst_member() {}\n+\n std::unique_ptr<Borrow> c_return_borrow(const std::string &s) {\n   return std::unique_ptr<Borrow>(new Borrow(s));\n }\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -80,6 +80,7 @@ enum COwnedEnum {\n struct Borrow {\n   Borrow(const std::string &s);\n   void const_member() const;\n+  void nonconst_member();\n   const std::string &s;\n };\n \n",
        "problem_statement": "Lifetime doesn't work in pinned member function receiver\n```cpp\r\n// include/example.h\r\n\r\n#pragma once\r\n#include <memory>\r\n\r\nstruct Object {\r\n  void f() {}\r\n};\r\n```\r\n\r\n```rust\r\n// src/main.rs\r\n\r\n#[cxx::bridge]\r\nmod ffi {\r\n    unsafe extern \"C++\" {\r\n        include!(\"example/include/example.h\");\r\n\r\n        type Object<'a>;\r\n\r\n        fn f(self: Pin<&mut Object>);\r\n    }\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\nThe above code should work but currently does not.\r\n\r\n```console\r\nerror[E0726]: implicit elided lifetime not allowed here\r\n --> src/main.rs:8:29\r\n  |\r\n8 |         fn f(self: Pin<&mut Object>);\r\n  |                             ^^^^^^- help: indicate the anonymous lifetime: `<'_>`\r\n\r\nerror[E0308]: mismatched `self` parameter type\r\n --> src/main.rs:8:20\r\n  |\r\n8 |         fn f(self: Pin<&mut Object>);\r\n  |                    ^^^^^^^^^^^^^^^^ lifetime mismatch\r\n  |\r\n  = note: expected struct `Object<'static>`\r\n             found struct `Object<'_>`\r\nnote: the anonymous lifetime #2 defined on the method body at 8:12...\r\n --> src/main.rs:8:12\r\n  |\r\n8 |         fn f(self: Pin<&mut Object>);\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  = note: ...does not necessarily outlive the static lifetime\r\n```\r\n\r\n<br>\r\n\r\nVarious attempted fixes also do not work:\r\n\r\n<details>\r\n<summary><code>fn f(self: Pin<&mut Object<'_>>)</code></summary>\r\n\r\n```console\r\nerror[E0308]: mismatched `self` parameter type\r\n --> src/main.rs:8:20\r\n  |\r\n8 |         fn f(self: Pin<&mut Object<'_>>);\r\n  |                    ^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\r\n  |\r\n  = note: expected struct `Object<'_>`\r\n             found struct `Object<'_>`\r\nnote: the anonymous lifetime #2 defined on the method body at 8:12...\r\n --> src/main.rs:8:12\r\n  |\r\n8 |         fn f(self: Pin<&mut Object<'_>>);\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nnote: ...does not necessarily outlive the lifetime `'_` as defined on the impl at 8:36\r\n --> src/main.rs:8:36\r\n  |\r\n8 |         fn f(self: Pin<&mut Object<'_>>);\r\n  |                                    ^^\r\n\r\nerror[E0308]: mismatched `self` parameter type\r\n --> src/main.rs:8:20\r\n  |\r\n8 |         fn f(self: Pin<&mut Object<'_>>);\r\n  |                    ^^^^^^^^^^^^^^^^^^^^ lifetime mismatch\r\n  |\r\n  = note: expected struct `Object<'_>`\r\n             found struct `Object<'_>`\r\nnote: the lifetime `'_` as defined on the impl at 8:36...\r\n --> src/main.rs:8:36\r\n  |\r\n8 |         fn f(self: Pin<&mut Object<'_>>);\r\n  |                                    ^^\r\nnote: ...does not necessarily outlive the anonymous lifetime #2 defined on the method body at 8:12\r\n --> src/main.rs:8:12\r\n  |\r\n8 |         fn f(self: Pin<&mut Object<'_>>);\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary><code> fn f<'a>(self: Pin<&mut Object<'a>>)</code></summary>\r\n\r\n```console\r\nerror[E0261]: use of undeclared lifetime name `'a`\r\n --> src/main.rs:8:40\r\n  |\r\n1 | #[cxx::bridge]\r\n  |               - help: consider introducing lifetime `'a` here: `<'a>`\r\n...\r\n8 |         fn f<'a>(self: Pin<&mut Object<'a>>);\r\n  |                                        ^^ undeclared lifetime\r\n  |\r\n  = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\r\n```\r\n</details>\r\n\r\n<br>\r\n\r\nThis issue might be related to #657 but might be a separate bug because in the case of Pin it won't compile even with a `<'_>` added.\n",
        "hints_text": "",
        "created_at": "2021-01-04T05:05:25Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 660,
        "instance_id": "dtolnay__cxx-660",
        "issue_numbers": [
            "657"
        ],
        "base_commit": "7c969ce953986c878a18f1fc65cb53e5c1119b30",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -6,13 +6,13 @@ use crate::syntax::instantiate::ImplKey;\n use crate::syntax::report::Errors;\n use crate::syntax::symbol::Symbol;\n use crate::syntax::{\n-    self, check, mangle, Api, Doc, Enum, ExternFn, ExternType, Impl, Pair, Signature, Struct,\n-    Trait, Type, TypeAlias, Types,\n+    self, check, mangle, Api, Doc, Enum, ExternFn, ExternType, Impl, Lifetimes, Pair, Signature,\n+    Struct, Trait, Type, TypeAlias, Types,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote, quote_spanned, ToTokens};\n use std::mem;\n-use syn::{parse_quote, Result, Token};\n+use syn::{parse_quote, punctuated, Lifetime, Result, Token};\n \n pub fn bridge(mut ffi: Module) -> Result<TokenStream> {\n     let ref mut errors = Errors::new();\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -617,16 +617,44 @@ fn expand_cxx_function_shim(efn: &ExternFn, types: &Types) -> TokenStream {\n         #trampolines\n         #dispatch\n     });\n-    let function_shim = quote! {\n-        #doc\n-        #attrs\n-        #visibility #unsafety #fn_token #ident #generics #arg_list #ret #fn_body\n-    };\n     match &efn.receiver {\n-        None => function_shim,\n+        None => {\n+            quote! {\n+                #doc\n+                #attrs\n+                #visibility #unsafety #fn_token #ident #generics #arg_list #ret #fn_body\n+            }\n+        }\n         Some(receiver) => {\n-            let receiver_type = &receiver.ty;\n-            quote!(impl #receiver_type { #function_shim })\n+            let elided_generics;\n+            let receiver_ident = &receiver.ty.rust;\n+            let resolve = types.resolve(&receiver.ty);\n+            let receiver_generics = if receiver.ty.generics.lt_token.is_some() {\n+                &receiver.ty.generics\n+            } else {\n+                elided_generics = Lifetimes {\n+                    lt_token: resolve.generics.lt_token,\n+                    lifetimes: resolve\n+                        .generics\n+                        .lifetimes\n+                        .pairs()\n+                        .map(|pair| {\n+                            let lifetime = Lifetime::new(\"'_\", pair.value().apostrophe);\n+                            let punct = pair.punct().map(|&&comma| comma);\n+                            punctuated::Pair::new(lifetime, punct)\n+                        })\n+                        .collect(),\n+                    gt_token: resolve.generics.gt_token,\n+                };\n+                &elided_generics\n+            };\n+            quote! {\n+                impl #generics #receiver_ident #receiver_generics {\n+                    #doc\n+                    #attrs\n+                    #visibility #unsafety #fn_token #ident #arg_list #ret #fn_body\n+                }\n+            }\n         }\n     }\n }\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -222,6 +222,8 @@ pub mod ffi {\n \n         #[rust_name = \"c_return_borrow_elided\"]\n         fn c_return_borrow(s: &CxxString) -> UniquePtr<Borrow>;\n+\n+        fn const_member(self: &Borrow);\n     }\n \n     #[repr(u32)]\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -209,6 +209,8 @@ ::A::B::ABEnum c_return_nested_ns_enum(uint16_t n) {\n \n Borrow::Borrow(const std::string &s) : s(s) {}\n \n+void Borrow::const_member() const {}\n+\n std::unique_ptr<Borrow> c_return_borrow(const std::string &s) {\n   return std::unique_ptr<Borrow>(new Borrow(s));\n }\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -79,6 +79,7 @@ enum COwnedEnum {\n \n struct Borrow {\n   Borrow(const std::string &s);\n+  void const_member() const;\n   const std::string &s;\n };\n \n",
        "problem_statement": "Support elided lifetime in member function receiver\n```cpp\r\n// include/example.h\r\n\r\n#pragma once\r\n#include <memory>\r\n\r\nstruct Object {\r\n  void f() const {}\r\n};\r\n```\r\n\r\n```rust\r\n// src/main.rs\r\n\r\n#[cxx::bridge]\r\nmod ffi {\r\n    unsafe extern \"C++\" {\r\n        include!(\"repro/include/example.h\");\r\n\r\n        type Object<'a>;\r\n\r\n        fn f(self: &Object);\r\n    }\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\nThe above should work (with an elided lifetime on `Object` but currently doesn't.\r\n\r\n```console\r\nerror[E0726]: implicit elided lifetime not allowed here\r\n --> src/main.rs:8:21\r\n  |\r\n8 |         fn f(self: &Object);\r\n  |                     ^^^^^^- help: indicate the anonymous lifetime: `<'_>`\r\n```\r\n\r\nWriting `fn f(self: &Object<'_>)` instead makes it work but shouldn't be necessary.\r\n\r\nLifetime elision is already support in non-member functions, e.g. `fn f(obj: &Object)`.\n",
        "hints_text": "",
        "created_at": "2021-01-04T04:52:18Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 659,
        "instance_id": "dtolnay__cxx-659",
        "issue_numbers": [
            "656"
        ],
        "base_commit": "fb5e1bad327eae247f124d37849f3e4b464cd132",
        "patch": "diff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -16,9 +16,9 @@ use syn::punctuated::Punctuated;\n use syn::{\n     Abi, Attribute, Error, Expr, Fields, FnArg, ForeignItem, ForeignItemFn, ForeignItemType,\n     GenericArgument, GenericParam, Generics, Ident, ItemEnum, ItemImpl, ItemStruct, Lit, LitStr,\n-    Pat, PathArguments, Result, ReturnType, Token, TraitBound, TraitBoundModifier,\n-    Type as RustType, TypeArray, TypeBareFn, TypeParamBound, TypePath, TypeReference,\n-    Variant as RustVariant, Visibility,\n+    Pat, PathArguments, Result, ReturnType, Signature as RustSignature, Token, TraitBound,\n+    TraitBoundModifier, Type as RustType, TypeArray, TypeBareFn, TypeParamBound, TypePath,\n+    TypeReference, Variant as RustVariant, Visibility,\n };\n \n pub mod kw {\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -662,69 +662,90 @@ fn parse_extern_verbatim(\n     |input: ParseStream| -> Result<Api> {\n         let attrs = input.call(Attribute::parse_outer)?;\n         let visibility: Visibility = input.parse()?;\n-        let type_token: Token![type] = match input.parse()? {\n-            Some(type_token) => type_token,\n-            None => {\n-                let span = input.cursor().token_stream();\n-                return Err(Error::new_spanned(span, \"unsupported foreign item\"));\n-            }\n-        };\n-        let ident: Ident = input.parse()?;\n-        let generics: Generics = input.parse()?;\n-        let mut lifetimes = Punctuated::new();\n-        let mut has_unsupported_generic_param = false;\n-        for pair in generics.params.into_pairs() {\n-            let (param, punct) = pair.into_tuple();\n-            match param {\n-                GenericParam::Lifetime(param) => {\n-                    if !param.bounds.is_empty() && !has_unsupported_generic_param {\n-                        let msg = \"lifetime parameter with bounds is not supported yet\";\n-                        cx.error(&param, msg);\n-                        has_unsupported_generic_param = true;\n-                    }\n-                    lifetimes.push_value(param.lifetime);\n-                    if let Some(punct) = punct {\n-                        lifetimes.push_punct(punct);\n-                    }\n+        if input.peek(Token![type]) {\n+            parse_extern_verbatim_type(cx, attrs, visibility, input, lang, trusted, namespace)\n+        } else if input.peek(Token![fn]) {\n+            parse_extern_verbatim_fn(input)\n+        } else {\n+            let span = input.cursor().token_stream();\n+            Err(Error::new_spanned(\n+                span,\n+                \"unsupported foreign item, expected `type` or `fn`\",\n+            ))\n+        }\n+    }\n+    .parse2(tokens)\n+}\n+\n+fn parse_extern_verbatim_type(\n+    cx: &mut Errors,\n+    attrs: Vec<Attribute>,\n+    visibility: Visibility,\n+    input: ParseStream,\n+    lang: Lang,\n+    trusted: bool,\n+    namespace: &Namespace,\n+) -> Result<Api> {\n+    let type_token: Token![type] = input.parse()?;\n+    let ident: Ident = input.parse()?;\n+    let generics: Generics = input.parse()?;\n+    let mut lifetimes = Punctuated::new();\n+    let mut has_unsupported_generic_param = false;\n+    for pair in generics.params.into_pairs() {\n+        let (param, punct) = pair.into_tuple();\n+        match param {\n+            GenericParam::Lifetime(param) => {\n+                if !param.bounds.is_empty() && !has_unsupported_generic_param {\n+                    let msg = \"lifetime parameter with bounds is not supported yet\";\n+                    cx.error(&param, msg);\n+                    has_unsupported_generic_param = true;\n                 }\n-                GenericParam::Type(param) => {\n-                    if !has_unsupported_generic_param {\n-                        let msg = \"extern type with generic type parameter is not supported yet\";\n-                        cx.error(&param, msg);\n-                        has_unsupported_generic_param = true;\n-                    }\n+                lifetimes.push_value(param.lifetime);\n+                if let Some(punct) = punct {\n+                    lifetimes.push_punct(punct);\n                 }\n-                GenericParam::Const(param) => {\n-                    if !has_unsupported_generic_param {\n-                        let msg = \"extern type with const generic parameter is not supported yet\";\n-                        cx.error(&param, msg);\n-                        has_unsupported_generic_param = true;\n-                    }\n+            }\n+            GenericParam::Type(param) => {\n+                if !has_unsupported_generic_param {\n+                    let msg = \"extern type with generic type parameter is not supported yet\";\n+                    cx.error(&param, msg);\n+                    has_unsupported_generic_param = true;\n+                }\n+            }\n+            GenericParam::Const(param) => {\n+                if !has_unsupported_generic_param {\n+                    let msg = \"extern type with const generic parameter is not supported yet\";\n+                    cx.error(&param, msg);\n+                    has_unsupported_generic_param = true;\n                 }\n             }\n-        }\n-        let lifetimes = Lifetimes {\n-            lt_token: generics.lt_token,\n-            lifetimes,\n-            gt_token: generics.gt_token,\n-        };\n-        let lookahead = input.lookahead1();\n-        if lookahead.peek(Token![=]) {\n-            // type Alias = crate::path::to::Type;\n-            parse_type_alias(\n-                cx, attrs, visibility, type_token, ident, lifetimes, input, lang, namespace,\n-            )\n-        } else if lookahead.peek(Token![:]) || lookahead.peek(Token![;]) {\n-            // type Opaque: Bound2 + Bound2;\n-            parse_extern_type_bounded(\n-                cx, attrs, visibility, type_token, ident, lifetimes, input, lang, trusted,\n-                namespace,\n-            )\n-        } else {\n-            Err(lookahead.error())\n         }\n     }\n-    .parse2(tokens)\n+    let lifetimes = Lifetimes {\n+        lt_token: generics.lt_token,\n+        lifetimes,\n+        gt_token: generics.gt_token,\n+    };\n+    let lookahead = input.lookahead1();\n+    if lookahead.peek(Token![=]) {\n+        // type Alias = crate::path::to::Type;\n+        parse_type_alias(\n+            cx, attrs, visibility, type_token, ident, lifetimes, input, lang, namespace,\n+        )\n+    } else if lookahead.peek(Token![:]) || lookahead.peek(Token![;]) {\n+        // type Opaque: Bound2 + Bound2;\n+        parse_extern_type_bounded(\n+            cx, attrs, visibility, type_token, ident, lifetimes, input, lang, trusted, namespace,\n+        )\n+    } else {\n+        Err(lookahead.error())\n+    }\n+}\n+\n+fn parse_extern_verbatim_fn(input: ParseStream) -> Result<Api> {\n+    input.parse::<RustSignature>()?;\n+    input.parse::<Token![;]>()?;\n+    unreachable!()\n }\n \n fn parse_type_alias(\n",
        "test_patch": "diff --git /dev/null b/tests/ui/function_with_body.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/function_with_body.rs\n@@ -0,0 +1,8 @@\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+        fn f() {}\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/function_with_body.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/function_with_body.stderr\n@@ -0,0 +1,5 @@\n+error: expected `;`\n+ --> $DIR/function_with_body.rs:4:16\n+  |\n+4 |         fn f() {}\n+  |                ^\n",
        "problem_statement": "Improve error on extern functions accidentally containing function body\nIf the user mistakenly types `{}` instead of `;` after a function signature out of muscle memory, they get a pretty poor error message.\r\n\r\n```rust\r\n#[cxx::bridge]\r\nmod ffi {\r\n    unsafe extern \"C++\" {\r\n        fn f() {}\r\n    }\r\n}\r\n```\r\n\r\n```console\r\nerror[cxxbridge]: unsupported foreign item\r\n  \u250c\u2500 src/main.rs:4:9\r\n  \u2502\r\n4 \u2502         fn f() {}\r\n  \u2502         ^^^^^^^^^ unsupported foreign item\r\n```\r\n\r\nThe error message should instead point to the `{}` and say to replace with `;`.\n",
        "hints_text": "",
        "created_at": "2021-01-04T04:25:58Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 652,
        "instance_id": "dtolnay__cxx-652",
        "issue_numbers": [
            "608"
        ],
        "base_commit": "30d46731ef3905ffa0df7240e4c9562a36e871e9",
        "patch": "diff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -71,11 +71,6 @@ fn check_type_ident(cx: &mut Check, name: &NamedType) {\n     {\n         let msg = format!(\"unsupported type: {}\", ident);\n         cx.error(ident, &msg);\n-        return;\n-    }\n-\n-    if !name.generics.lifetimes.is_empty() {\n-        cx.error(name, \"type with lifetime parameter is not supported yet\");\n     }\n }\n \ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -341,7 +336,10 @@ fn check_api_type(cx: &mut Check, ety: &ExternType) {\n     }\n \n     if let Some(lifetime) = ety.generics.lifetimes.first() {\n-        cx.error(lifetime, \"extern type with lifetimes is not supported yet\");\n+        if ety.lang == Lang::Rust {\n+            let msg = \"extern Rust type with lifetimes is not supported yet\";\n+            cx.error(lifetime, msg);\n+        }\n     }\n \n     if !ety.bounds.is_empty() {\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -447,10 +445,6 @@ fn check_api_type_alias(cx: &mut Check, alias: &TypeAlias) {\n         let msg = format!(\"derive({}) on extern type alias is not supported\", derive);\n         cx.error(derive, msg);\n     }\n-\n-    if let Some(lifetime) = alias.generics.lifetimes.first() {\n-        cx.error(lifetime, \"extern type with lifetimes is not supported yet\");\n-    }\n }\n \n fn check_api_impl(cx: &mut Check, imp: &Impl) {\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -210,6 +210,15 @@ pub mod ffi {\n         type Job = crate::module::ffi::Job;\n     }\n \n+    unsafe extern \"C++\" {\n+        type Borrow<'a>;\n+\n+        fn c_return_borrow<'a>(s: &'a CxxString) -> UniquePtr<Borrow<'a>>;\n+\n+        #[rust_name = \"c_return_borrow_elided\"]\n+        fn c_return_borrow(s: &CxxString) -> UniquePtr<Borrow>;\n+    }\n+\n     #[repr(u32)]\n     #[derive(Hash)]\n     enum COwnedEnum {\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -207,6 +207,12 @@ ::A::B::ABEnum c_return_nested_ns_enum(uint16_t n) {\n   }\n }\n \n+Borrow::Borrow(const std::string &s) : s(s) {}\n+\n+std::unique_ptr<Borrow> c_return_borrow(const std::string &s) {\n+  return std::unique_ptr<Borrow>(new Borrow(s));\n+}\n+\n void c_take_primitive(size_t n) {\n   if (n == 2020) {\n     cxx_test_suite_set_correct();\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -77,6 +77,11 @@ enum COwnedEnum {\n   CVAL2,\n };\n \n+struct Borrow {\n+  Borrow(const std::string &s);\n+  const std::string &s;\n+};\n+\n size_t c_return_primitive();\n Shared c_return_shared();\n ::A::AShared c_return_ns_shared();\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -110,6 +115,7 @@ size_t c_return_sum(size_t n1, size_t n2);\n Enum c_return_enum(uint16_t n);\n ::A::AEnum c_return_ns_enum(uint16_t n);\n ::A::B::ABEnum c_return_nested_ns_enum(uint16_t n);\n+std::unique_ptr<Borrow> c_return_borrow(const std::string &s);\n \n void c_take_primitive(size_t n);\n void c_take_shared(Shared shared);\ndiff --git a/tests/ui/extern_type_lifetime.rs /dev/null\n--- a/tests/ui/extern_type_lifetime.rs\n+++ /dev/null\n@@ -1,8 +0,0 @@\n-#[cxx::bridge]\n-mod ffi {\n-    extern \"C++\" {\n-        type Complex<'a, 'b>;\n-    }\n-}\n-\n-fn main() {}\ndiff --git a/tests/ui/extern_type_lifetime.stderr /dev/null\n--- a/tests/ui/extern_type_lifetime.stderr\n+++ /dev/null\n@@ -1,5 +0,0 @@\n-error: extern type with lifetimes is not supported yet\n- --> $DIR/extern_type_lifetime.rs:4:22\n-  |\n-4 |         type Complex<'a, 'b>;\n-  |                      ^^\n",
        "problem_statement": "Lifetimes on an opaque C++ type\nFor example suppose we have a C++ type which stores references:\r\n\r\n```cpp\r\nclass Resource;\r\n\r\nclass Holder {\r\n  Holder(const Resource &resource) : resource(resource) {}\r\n  const Resource &resource;\r\n};\r\n\r\nstd::shared_ptr<Holder> makeHolder(const Resource &resource) {\r\n  return std::make_shared<Holder>(resource);\r\n}\r\n```\r\n\r\nIt would be most appropriate to describe this in Rust with a lifetime as:\r\n\r\n```rust\r\n#[cxx::bridge]\r\nmod ffi {\r\n    unsafe extern \"C++\" {\r\n        type Resource;\r\n        type Holder<'a>;\r\n\r\n        fn makeHolder<'a>(resource: &'a Resource) -> SharedPtr<Holder<'a>>;\r\n\r\n        // or with lifetime elision\r\n        fn makeHolder(resource: &Resource) -> SharedPtr<Holder>;\r\n    }\r\n}\r\n```\r\n\r\nCurrently CXX doesn't handle the lifetimes on an extern type:\r\n\r\n```console\r\n  error[cxxbridge]: expected `=` or `:`\r\n    \u250c\u2500 src/main.rs:5:20\r\n    \u2502\r\n  5 \u2502         type Holder<'a>;\r\n    \u2502                    ^ expected `=` or `:`\r\n```\n",
        "hints_text": "Hit an ICE while working on this: https://github.com/rust-lang/rust/issues/80468. I think it happens only in otherwise erroneous code so it shouldn't be a blocker, but it's possible it would come up often when using this feature.",
        "created_at": "2021-01-03T07:33:03Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 642,
        "instance_id": "dtolnay__cxx-642",
        "issue_numbers": [
            "58"
        ],
        "base_commit": "d00bc40aa796d670a5ead765998b748d3b98213e",
        "patch": "diff --git a/book/src/binding/box.md b/book/src/binding/box.md\n--- a/book/src/binding/box.md\n+++ b/book/src/binding/box.md\n@@ -25,6 +25,8 @@ public:\n   explicit Box(const T &);\n   explicit Box(T &&);\n \n+  void swap(Box &) noexcept;\n+\n   Box &operator=(const Box &);\n   Box &operator=(Box &&) noexcept;\n \ndiff --git a/book/src/binding/slice.md b/book/src/binding/slice.md\n--- a/book/src/binding/slice.md\n+++ b/book/src/binding/slice.md\n@@ -32,6 +32,8 @@ public:\n   size_t length() const noexcept;\n   bool empty() const noexcept;\n \n+  void swap(Slice & rhs) noexcept;\n+\n   T &operator[](size_t n) const noexcept;\n   T &at(size_t n) const;\n   T &front() const noexcept;\ndiff --git a/book/src/binding/str.md b/book/src/binding/str.md\n--- a/book/src/binding/str.md\n+++ b/book/src/binding/str.md\n@@ -31,6 +31,8 @@ public:\n   size_t size() const noexcept;\n   size_t length() const noexcept;\n \n+  void swap(Str & rhs) noexcept;\n+\n   using iterator = const char *;\n   using const_iterator = const char *;\n   const_iterator begin() const noexcept;\ndiff --git a/book/src/binding/string.md b/book/src/binding/string.md\n--- a/book/src/binding/string.md\n+++ b/book/src/binding/string.md\n@@ -35,6 +35,8 @@ public:\n \n   const char *c_str() noexcept;\n \n+  void swap(String & rhs) noexcept;\n+\n   using iterator = char *;\n   iterator begin() noexcept;\n   iterator end() noexcept;\ndiff --git a/book/src/binding/vec.md b/book/src/binding/vec.md\n--- a/book/src/binding/vec.md\n+++ b/book/src/binding/vec.md\n@@ -31,6 +31,8 @@ public:\n   const T *data() const noexcept;\n   T *data() noexcept;\n   size_t capacity() const noexcept;\n+  \n+  void swap(Vec & rhs) noexcept;\n \n   const T &operator[](size_t n) const noexcept;\n   const T &at(size_t n) const;\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -56,6 +56,8 @@ class String final {\n \n   const char *c_str() noexcept;\n \n+  void swap(String & rhs) noexcept;\n+\n   using iterator = char *;\n   iterator begin() noexcept;\n   iterator end() noexcept;\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -77,9 +79,14 @@ class String final {\n   String(unsafe_bitcopy_t, const String &) noexcept;\n \n private:\n+  friend void swap(String& lhs, String& rhs) noexcept {\n+    lhs.swap(rhs);\n+  }\n+\n   // Size and alignment statically verified by rust_string.rs.\n   std::array<std::uintptr_t, 3> repr;\n };\n+\n #endif // CXXBRIDGE1_RUST_STRING\n \n #ifndef CXXBRIDGE1_RUST_STR\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -101,6 +108,8 @@ class Str final {\n   std::size_t size() const noexcept;\n   std::size_t length() const noexcept;\n \n+  void swap(Str & rhs) noexcept;\n+\n   // Important in order for System V ABI to pass in registers.\n   Str(const Str &) noexcept = default;\n   ~Str() noexcept = default;\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -120,6 +129,10 @@ class Str final {\n   bool operator>=(const Str &) const noexcept;\n \n private:\n+  friend void swap(Str & lhs, Str & rhs) noexcept {\n+    lhs.swap(rhs);\n+  }\n+\n   // Not necessarily ABI compatible with &str. Codegen will translate to\n   // cxx::rust_str::RustStr which matches this layout.\n   const char *ptr;\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -159,6 +172,8 @@ class Slice final\n   std::size_t length() const noexcept;\n   bool empty() const noexcept;\n \n+  void swap(Slice & rhs) noexcept;\n+\n   T &operator[](std::size_t n) const noexcept;\n   T &at(std::size_t n) const;\n   T &front() const noexcept;\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -173,6 +188,10 @@ class Slice final\n   iterator end() const noexcept;\n \n private:\n+  friend void swap(Slice<T> & lhs, Slice<T> & rhs) noexcept {\n+    lhs.swap(rhs);\n+  }\n+\n   // Not necessarily ABI compatible with &[T]. Codegen will translate to\n   // cxx::rust_slice::RustSlice which matches this layout.\n   void *ptr;\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -235,6 +254,8 @@ class Box final {\n   explicit Box(const T &);\n   explicit Box(T &&);\n \n+  void swap(Box & rhs) noexcept;\n+\n   Box &operator=(const Box &);\n   Box &operator=(Box &&) noexcept;\n \ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -259,6 +280,11 @@ class Box final {\n   class allocation;\n   Box(uninit) noexcept;\n   void drop() noexcept;\n+\n+  friend void swap(Box & lhs, Box & rhs) noexcept {\n+    lhs.swap(rhs);\n+  }\n+\n   T *ptr;\n };\n #endif // CXXBRIDGE1_RUST_BOX\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -285,6 +311,8 @@ class Vec final {\n   T *data() noexcept;\n   std::size_t capacity() const noexcept;\n \n+  void swap(Vec & rhs) noexcept;\n+\n   const T &operator[](std::size_t n) const noexcept;\n   const T &at(std::size_t n) const;\n   const T &front() const noexcept;\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -319,6 +347,10 @@ class Vec final {\n   void set_len(std::size_t len) noexcept;\n   void drop() noexcept;\n \n+  friend void swap(Vec<T> & lhs, Vec<T> & rhs) noexcept {\n+    lhs.swap(rhs);\n+  }\n+\n   // Size and alignment statically verified by rust_vec.rs.\n   std::array<std::uintptr_t, 3> repr;\n };\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -506,6 +538,13 @@ std::size_t Slice<T>::length() const noexcept {\n   return this->len;\n }\n \n+template <typename T>\n+void Slice<T>::swap(Slice<T> & rhs) noexcept {\n+  using std::swap;\n+  swap(this->ptr, rhs.ptr);\n+  swap(this->len, rhs.len);\n+}\n+\n template <typename T>\n bool Slice<T>::empty() const noexcept {\n   return this->len == 0;\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -711,6 +750,12 @@ Box<T>::Box(T &&val) {\n   alloc.ptr = nullptr;\n }\n \n+template <typename T>\n+void Box<T>::swap(Box<T> & rhs) noexcept {\n+  using std::swap;\n+  swap(this->ptr, rhs.ptr);\n+}\n+\n template <typename T>\n Box<T>::~Box() noexcept {\n   if (this->ptr) {\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -842,6 +887,12 @@ T *Vec<T>::data() noexcept {\n   return const_cast<T *>(const_cast<const Vec<T> *>(this)->data());\n }\n \n+template <typename T>\n+void Vec<T>::swap(Vec<T> & rhs) noexcept {\n+  using std::swap;\n+  swap(this->repr, rhs.repr);\n+}\n+\n template <typename T>\n const T &Vec<T>::operator[](std::size_t n) const noexcept {\n   assert(n < this->size());\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -130,6 +130,11 @@ const char *String::c_str() noexcept {\n   return ptr;\n }\n \n+void String::swap(String& rhs) noexcept {\n+  using std::swap;\n+  swap(this->repr, rhs.repr);\n+}\n+\n String::iterator String::begin() noexcept {\n   return const_cast<char *>(this->data());\n }\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -210,6 +215,12 @@ Str::operator std::string() const {\n   return std::string(this->data(), this->size());\n }\n \n+void Str::swap(Str& rhs) noexcept {\n+  using std::swap;\n+  swap(this->ptr, rhs.ptr);\n+  swap(this->len, rhs.len);\n+}\n+\n Str::const_iterator Str::begin() const noexcept { return this->cbegin(); }\n \n Str::const_iterator Str::end() const noexcept { return this->cend(); }\n",
        "test_patch": "diff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -752,8 +752,12 @@ extern \"C\" const char *cxx_run_test() noexcept {\n   ASSERT(r->get() == 2020);\n   ASSERT(r->set(2021) == 2021);\n   ASSERT(r->get() == 2021);\n-  ASSERT(r->set(2020) == 2020);\n+  auto r2 = r_return_box();\n+  swap(r, r2);\n   ASSERT(r->get() == 2020);\n+  ASSERT(r2->get() == 2021);\n+\n+\n   ASSERT(std::string(Shared{0}.r_method_on_shared()) == \"2020\");\n \n   ASSERT(std::string(rAliasedFunction(2020)) == \"2020\");\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -786,6 +790,23 @@ extern \"C\" const char *cxx_run_test() noexcept {\n   ASSERT(strncmp(cstring.c_str(), \"test\", 5) == 0);\n   ASSERT(cstring.length() == 4);\n \n+  rust::String other_cstring = \"foo\";\n+  swap(cstring, other_cstring);\n+  ASSERT(cstring == \"foo\");\n+  ASSERT(other_cstring == \"test\");\n+\n+  rust::Str cstr = \"test\";\n+  rust::Str other_cstr = \"foo\";\n+  swap(cstr, other_cstr);\n+  ASSERT(cstr == \"foo\");\n+  ASSERT(other_cstr == \"test\");\n+\n+  rust::Vec<int> vec1{1, 2};\n+  rust::Vec<int> vec2{3, 4};\n+  swap(vec1, vec2);\n+  ASSERT(vec1[0] == 3 && vec1[1] == 4);\n+  ASSERT(vec2[0] == 1 && vec2[1] == 2);\n+\n   cxx_test_suite_set_correct();\n   return nullptr;\n }\n",
        "problem_statement": "Provide a `swap` implementation for types in cxxbridge.h\nAs recommended in #8. String, Str, and Box should have an efficient `swap`.\n",
        "hints_text": "",
        "created_at": "2021-01-02T18:38:38Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 541,
        "instance_id": "dtolnay__cxx-541",
        "issue_numbers": [
            "535"
        ],
        "base_commit": "56f78f34339a64e57b67689d73013dedd2867464",
        "patch": "diff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -93,6 +93,7 @@ fn check_type_box(cx: &mut Check, ptr: &Ty1) {\n fn check_type_rust_vec(cx: &mut Check, ty: &Ty1) {\n     if let Type::Ident(ident) = &ty.inner {\n         if cx.types.cxx.contains(&ident.rust)\n+            && !cx.types.aliases.contains_key(&ident.rust)\n             && !cx.types.structs.contains_key(&ident.rust)\n             && !cx.types.enums.contains_key(&ident.rust)\n         {\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -328,6 +329,7 @@ fn check_api_type(cx: &mut Check, ety: &ExternType) {\n             TrivialReason::StructField(strct) => format!(\"a field of `{}`\", strct.name.rust),\n             TrivialReason::FunctionArgument(efn) => format!(\"an argument of `{}`\", efn.name.rust),\n             TrivialReason::FunctionReturn(efn) => format!(\"a return value of `{}`\", efn.name.rust),\n+            TrivialReason::VecElement => format!(\"a vector element in Vec<{}>\", ety.name.rust),\n         };\n         let msg = format!(\n             \"needs a cxx::ExternType impl in order to be used as {}\",\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -201,6 +201,12 @@ impl<'a> Types<'a> {\n                 _ => {}\n             }\n         }\n+        for ty in &all {\n+            if let Type::RustVec(ty) = ty {\n+                let reason = TrivialReason::VecElement;\n+                insist_alias_types_are_trivial(&ty.inner, reason);\n+            }\n+        }\n \n         let mut types = Types {\n             all,\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -297,6 +303,7 @@ pub enum TrivialReason<'a> {\n     StructField(&'a Struct),\n     FunctionArgument(&'a ExternFn),\n     FunctionReturn(&'a ExternFn),\n+    VecElement,\n }\n \n fn duplicate_name(cx: &mut Errors, sp: impl ToTokens, ident: &Ident) {\n",
        "test_patch": "diff --git a/tests/BUCK b/tests/BUCK\n--- a/tests/BUCK\n+++ b/tests/BUCK\n@@ -32,6 +32,7 @@ cxx_library(\n     ],\n     headers = {\n         \"ffi/lib.rs.h\": \":bridge/header\",\n+        \"ffi/module.rs.h\": \":module/header\",\n         \"ffi/tests.h\": \"ffi/tests.h\",\n     },\n     deps = [\"//:core\"],\ndiff --git a/tests/BUILD b/tests/BUILD\n--- a/tests/BUILD\n+++ b/tests/BUILD\n@@ -35,6 +35,7 @@ cc_library(\n     hdrs = [\"ffi/tests.h\"],\n     deps = [\n         \":bridge/include\",\n+        \":module/include\",\n         \"//:core\",\n     ],\n )\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -184,7 +184,10 @@ pub mod ffi {\n     }\n \n     extern \"C++\" {\n+        include!(\"tests/ffi/module.rs.h\");\n+\n         type COwnedEnum;\n+        type Job = crate::module::ffi::Job;\n     }\n \n     #[repr(u32)]\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -211,6 +214,7 @@ pub mod ffi {\n         fn r_return_unique_ptr_string() -> UniquePtr<CxxString>;\n         fn r_return_rust_vec() -> Vec<u8>;\n         fn r_return_rust_vec_string() -> Vec<String>;\n+        fn r_return_rust_vec_extern_struct() -> Vec<Job>;\n         fn r_return_ref_rust_vec(shared: &Shared) -> &Vec<u8>;\n         fn r_return_mut_rust_vec(shared: &mut Shared) -> &mut Vec<u8>;\n         fn r_return_identity(_: usize) -> usize;\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -435,6 +439,10 @@ fn r_return_rust_vec_string() -> Vec<String> {\n     Vec::new()\n }\n \n+fn r_return_rust_vec_extern_struct() -> Vec<ffi::Job> {\n+    Vec::new()\n+}\n+\n fn r_return_ref_rust_vec(shared: &ffi::Shared) -> &Vec<u8> {\n     let _ = shared;\n     unimplemented!()\ndiff --git a/tests/ffi/module.rs b/tests/ffi/module.rs\n--- a/tests/ffi/module.rs\n+++ b/tests/ffi/module.rs\n@@ -1,5 +1,9 @@\n #[cxx::bridge(namespace = \"tests\")]\n pub mod ffi {\n+    struct Job {\n+        raw: u32,\n+    }\n+\n     unsafe extern \"C++\" {\n         include!(\"tests/ffi/tests.h\");\n \ndiff --git /dev/null b/tests/ui/vec_opaque.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/vec_opaque.rs\n@@ -0,0 +1,34 @@\n+#[cxx::bridge]\n+mod handle {\n+    extern \"C++\" {\n+        type Job;\n+    }\n+}\n+\n+#[cxx::bridge]\n+mod ffi1 {\n+    extern \"C++\" {\n+        type Job;\n+    }\n+\n+    extern \"Rust\" {\n+        fn f() -> Vec<Job>;\n+    }\n+}\n+\n+#[cxx::bridge]\n+mod ffi2 {\n+    extern \"C++\" {\n+        type Job = crate::handle::Job;\n+    }\n+\n+    extern \"Rust\" {\n+        fn f() -> Vec<Job>;\n+    }\n+}\n+\n+fn f() -> Vec<handle::Job> {\n+    unimplemented!()\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/vec_opaque.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/vec_opaque.stderr\n@@ -0,0 +1,22 @@\n+error: Rust Vec containing C++ type is not supported yet\n+  --> $DIR/vec_opaque.rs:15:19\n+   |\n+15 |         fn f() -> Vec<Job>;\n+   |                   ^^^^^^^^\n+\n+error: needs a cxx::ExternType impl in order to be used as a vector element in Vec<Job>\n+  --> $DIR/vec_opaque.rs:11:9\n+   |\n+11 |         type Job;\n+   |         ^^^^^^^^\n+\n+error[E0271]: type mismatch resolving `<handle::Job as ExternType>::Kind == Trivial`\n+   --> $DIR/vec_opaque.rs:22:9\n+    |\n+22  |         type Job = crate::handle::Job;\n+    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Trivial`, found enum `cxx::kind::Opaque`\n+    |\n+   ::: $WORKSPACE/src/extern_type.rs\n+    |\n+    | pub fn verify_extern_kind<T: ExternType<Kind = Kind>, Kind: self::Kind>() {}\n+    |                                         ----------- required by this bound in `verify_extern_kind`\n",
        "problem_statement": "Can't use Vec<shared type from another module>\nConsider this slight modification of https://github.com/dtolnay/cxx/issues/297#issuecomment-727042059:\r\n\r\n```\r\n#[cxx::bridge(namespace = \"my_usage::ffi\")]\r\nmod ffi {\r\n    #[namespace = \"zx::ffi\"]\r\n    extern \"C++\" {\r\n        include!(\"cxx-handles-demo/src/handle.rs.h\");\r\n        type Job = crate::handle::ffi::Job;\r\n        type Process = crate::handle::ffi::Process;\r\n    }\r\n\r\n    extern \"Rust\" {\r\n        fn create_processes(name: &CxxString, job: &Job) -> Vec<Process>;\r\n    }\r\n}\r\n```\r\n\r\nIn 1.0.8 it says `Rust Vec containing C++ type is not supported yet` (at least it does in my morally equivalent example).\n",
        "hints_text": "This is a bug -- this shouldn't happen for types that have a `= crate::path::to::Definition`, and where the corresponding [ExternType](https://docs.rs/cxx/1.0.8/cxx/trait.ExternType.html) impl has Kind=Trivial (as is the case for all shared structs).\nDo you need a reproducing example (unfortunately, quite large at the moment, but I could try to minimize it)?\nNope, this is fine. Thanks!",
        "created_at": "2020-12-05T01:29:11Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 531,
        "instance_id": "dtolnay__cxx-531",
        "issue_numbers": [
            "57"
        ],
        "base_commit": "028d3d23f9c11be9c8d0a791dba36f905698f294",
        "patch": "diff --git a/book/src/binding/str.md b/book/src/binding/str.md\n--- a/book/src/binding/str.md\n+++ b/book/src/binding/str.md\n@@ -37,6 +37,13 @@ public:\n   const_iterator end() const noexcept;\n   const_iterator cbegin() const noexcept;\n   const_iterator cend() const noexcept;\n+\n+  bool operator==(const Str &) const noexcept;\n+  bool operator!=(const Str &) const noexcept;\n+  bool operator<(const Str &) const noexcept;\n+  bool operator<=(const Str &) const noexcept;\n+  bool operator>(const Str &) const noexcept;\n+  bool operator>=(const Str &) const noexcept;\n };\n \n std::ostream &operator<<(std::ostream &, const Str &);\ndiff --git a/book/src/binding/string.md b/book/src/binding/string.md\n--- a/book/src/binding/string.md\n+++ b/book/src/binding/string.md\n@@ -42,6 +42,13 @@ public:\n   const_iterator end() const noexcept;\n   const_iterator cbegin() const noexcept;\n   const_iterator cend() const noexcept;\n+\n+  bool operator==(const String &) const noexcept;\n+  bool operator!=(const String &) const noexcept;\n+  bool operator<(const String &) const noexcept;\n+  bool operator<=(const String &) const noexcept;\n+  bool operator>(const String &) const noexcept;\n+  bool operator>=(const String &) const noexcept;\n };\n \n std::ostream &operator<<(std::ostream &, const String &);\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -59,6 +59,13 @@ class String final {\n   const_iterator cbegin() const noexcept;\n   const_iterator cend() const noexcept;\n \n+  bool operator==(const String &) const noexcept;\n+  bool operator!=(const String &) const noexcept;\n+  bool operator<(const String &) const noexcept;\n+  bool operator<=(const String &) const noexcept;\n+  bool operator>(const String &) const noexcept;\n+  bool operator>=(const String &) const noexcept;\n+\n   // Internal API only intended for the cxxbridge code generator.\n   String(unsafe_bitcopy_t, const String &) noexcept;\n \ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -98,6 +105,13 @@ class Str final {\n   const_iterator cbegin() const noexcept;\n   const_iterator cend() const noexcept;\n \n+  bool operator==(const Str &) const noexcept;\n+  bool operator!=(const Str &) const noexcept;\n+  bool operator<(const Str &) const noexcept;\n+  bool operator<=(const Str &) const noexcept;\n+  bool operator>(const Str &) const noexcept;\n+  bool operator>=(const Str &) const noexcept;\n+\n private:\n   friend impl<Str>;\n   // Not necessarily ABI compatible with &str. Codegen will translate to\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -1,4 +1,5 @@\n #include \"../include/cxx.h\"\n+#include <algorithm>\n #include <cassert>\n #include <cstring>\n #include <exception>\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -140,6 +141,30 @@ String::const_iterator String::cend() const noexcept {\n   return this->data() + this->size();\n }\n \n+bool String::operator==(const String &rhs) const noexcept {\n+  return rust::Str(*this) == rust::Str(rhs);\n+}\n+\n+bool String::operator!=(const String &rhs) const noexcept {\n+  return rust::Str(*this) != rust::Str(rhs);\n+}\n+\n+bool String::operator<(const String &rhs) const noexcept {\n+  return rust::Str(*this) < rust::Str(rhs);\n+}\n+\n+bool String::operator<=(const String &rhs) const noexcept {\n+  return rust::Str(*this) <= rust::Str(rhs);\n+}\n+\n+bool String::operator>(const String &rhs) const noexcept {\n+  return rust::Str(*this) > rust::Str(rhs);\n+}\n+\n+bool String::operator>=(const String &rhs) const noexcept {\n+  return rust::Str(*this) >= rust::Str(rhs);\n+}\n+\n String::String(unsafe_bitcopy_t, const String &bits) noexcept\n     : repr(bits.repr) {}\n \ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -186,6 +211,39 @@ Str::const_iterator Str::cbegin() const noexcept { return this->ptr; }\n \n Str::const_iterator Str::cend() const noexcept { return this->ptr + this->len; }\n \n+bool Str::operator==(const Str &rhs) const noexcept {\n+  return this->len == rhs.len &&\n+         std::equal(this->begin(), this->end(), rhs.begin());\n+}\n+\n+bool Str::operator!=(const Str &rhs) const noexcept { return !(*this == rhs); }\n+\n+bool Str::operator<(const Str &rhs) const noexcept {\n+  return std::lexicographical_compare(this->begin(), this->end(), rhs.begin(),\n+                                      rhs.end());\n+}\n+\n+bool Str::operator<=(const Str &rhs) const noexcept {\n+  // std::mismatch(this->begin(), this->end(), rhs.begin(), rhs.end()), except\n+  // without Undefined Behavior on C++11 if rhs is shorter than *this.\n+  const_iterator liter = this->begin(), lend = this->end(), riter = rhs.begin(),\n+                 rend = rhs.end();\n+  while (liter != lend && riter != rend && *liter == *riter) {\n+    ++liter, ++riter;\n+  }\n+  if (liter == lend) {\n+    return true; // equal or *this is a prefix of rhs\n+  } else if (riter == rend) {\n+    return false; // rhs is a prefix of *this\n+  } else {\n+    return *liter <= *riter;\n+  }\n+}\n+\n+bool Str::operator>(const Str &rhs) const noexcept { return rhs < *this; }\n+\n+bool Str::operator>=(const Str &rhs) const noexcept { return rhs <= *this; }\n+\n std::ostream &operator<<(std::ostream &os, const Str &s) {\n   os.write(s.data(), s.size());\n   return os;\n",
        "test_patch": "diff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -6,6 +6,7 @@\n #include <numeric>\n #include <stdexcept>\n #include <string>\n+#include <tuple>\n \n extern \"C\" void cxx_test_suite_set_correct() noexcept;\n extern \"C\" tests::R *cxx_test_suite_get_box() noexcept;\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -656,6 +657,25 @@ extern \"C\" const char *cxx_run_test() noexcept {\n   ASSERT(Shared{1} == Shared{1});\n   ASSERT(Shared{1} != Shared{2});\n \n+  rust::String first = \"first\", second = \"second\", sec = \"sec\";\n+  bool (rust::String::*cmp)(const rust::String &) const;\n+  bool first_first, first_second, sec_second, second_sec;\n+  for (auto test : {\n+    std::tuple<decltype(cmp), bool, bool, bool, bool>\n+    {&rust::String::operator==, true, false, false, false},\n+    {&rust::String::operator!=, false, true, true, true},\n+    {&rust::String::operator<, false, true, true, false},\n+    {&rust::String::operator<=, true, true, true, false},\n+    {&rust::String::operator>, false, false, false, true},\n+    {&rust::String::operator>=, true, false, false, true},\n+  }) {\n+    std::tie(cmp, first_first, first_second, sec_second, second_sec) = test;\n+    ASSERT((first.*cmp)(first) == first_first);\n+    ASSERT((first.*cmp)(second) == first_second);\n+    ASSERT((sec.*cmp)(second) == sec_second);\n+    ASSERT((second.*cmp)(sec) == second_sec);\n+  }\n+\n   cxx_test_suite_set_correct();\n   return nullptr;\n }\n",
        "problem_statement": "Provide comparison operators for rust::Str and rust::String\nThe C++ types should come with operators for `==`, `!=`, `<`, `>`, `<=`, `>=`.\n",
        "hints_text": "While looking into adding this, I noticed that a few trivial functions of `alloc::String` are routed via FFI, e.g. `cxxbridge1$string$len` for `String::len`. So long as `Vec` has a guaranteed memory layout, and `String` is a `Vec<u8>`, then it should be possible to get the length out of `rust::String::repr[1]`, and similarly for the pointer.\r\n\r\nI bring this up because, if this would work reliably, then all these operators could be implemented with just an equality and a comparison function that operates on 2 string slices (technically two pointer + length pairs, since `&str` is not FFI safe), in addition to removing the accessors mentioned above.\r\n\r\n`alloc::String` is not yet marked as `repr_transparent`, pending https://github.com/rust-lang/rust/issues/70473.\r\n\r\nDo you think having `repr_transparent` on `String` is really a requirement in practice for this case, or should this go ahead before the issue above is implemented ? Because personally, I can't see how the layout of `String` could differ from `Vec<u8>` in practice, given its implementation.\nVec does not have a guaranteed layout.",
        "created_at": "2020-11-30T06:39:51Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 515,
        "instance_id": "dtolnay__cxx-515",
        "issue_numbers": [
            "120"
        ],
        "base_commit": "248215e2060e9d6d7814943bb1b1165741cc0d28",
        "patch": "diff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -159,7 +159,7 @@ fn pick_includes_and_builtins(out: &mut OutFile, apis: &[Api]) {\n                 Some(Isize) => out.builtin.rust_isize = true,\n                 Some(CxxString) => out.include.string = true,\n                 Some(RustString) => out.builtin.rust_string = true,\n-                Some(Bool) | Some(F32) | Some(F64) | None => {}\n+                Some(Bool) | Some(Char) | Some(F32) | Some(F64) | None => {}\n             },\n             Type::RustBox(_) => out.builtin.rust_box = true,\n             Type::RustVec(_) => out.builtin.rust_vec = true,\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -924,6 +924,7 @@ fn write_type(out: &mut OutFile, ty: &Type) {\n fn write_atom(out: &mut OutFile, atom: Atom) {\n     match atom {\n         Bool => write!(out, \"bool\"),\n+        Char => write!(out, \"char\"),\n         U8 => write!(out, \"uint8_t\"),\n         U16 => write!(out, \"uint16_t\"),\n         U32 => write!(out, \"uint32_t\"),\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -379,6 +379,7 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n #define FOR_EACH_RUST_VEC(MACRO)                                               \\\n   FOR_EACH_NUMERIC(MACRO)                                                      \\\n   MACRO(bool, bool)                                                            \\\n+  MACRO(char, char)                                                            \\\n   MACRO(string, rust::String)\n \n extern \"C\" {\ndiff --git a/src/symbols/rust_vec.rs b/src/symbols/rust_vec.rs\n--- a/src/symbols/rust_vec.rs\n+++ b/src/symbols/rust_vec.rs\n@@ -3,6 +3,7 @@ use crate::rust_vec::RustVec;\n use alloc::vec::Vec;\n use core::mem;\n use core::ptr;\n+use std::os::raw::c_char;\n \n macro_rules! rust_vec_shims {\n     ($segment:expr, $ty:ty) => {\ndiff --git a/src/symbols/rust_vec.rs b/src/symbols/rust_vec.rs\n--- a/src/symbols/rust_vec.rs\n+++ b/src/symbols/rust_vec.rs\n@@ -74,4 +75,5 @@ rust_vec_shims_for_primitive!(i64);\n rust_vec_shims_for_primitive!(f32);\n rust_vec_shims_for_primitive!(f64);\n \n+rust_vec_shims!(\"char\", c_char);\n rust_vec_shims!(\"string\", RustString);\ndiff --git a/syntax/atom.rs b/syntax/atom.rs\n--- a/syntax/atom.rs\n+++ b/syntax/atom.rs\n@@ -5,6 +5,7 @@ use std::fmt::{self, Display};\n #[derive(Copy, Clone, PartialEq)]\n pub enum Atom {\n     Bool,\n+    Char, // C char, not Rust char\n     U8,\n     U16,\n     U32,\ndiff --git a/syntax/atom.rs b/syntax/atom.rs\n--- a/syntax/atom.rs\n+++ b/syntax/atom.rs\n@@ -30,6 +31,7 @@ impl Atom {\n         use self::Atom::*;\n         match s {\n             \"bool\" => Some(Bool),\n+            \"c_char\" => Some(Char),\n             \"u8\" => Some(U8),\n             \"u16\" => Some(U16),\n             \"u32\" => Some(U32),\ndiff --git a/syntax/atom.rs b/syntax/atom.rs\n--- a/syntax/atom.rs\n+++ b/syntax/atom.rs\n@@ -60,6 +62,7 @@ impl AsRef<str> for Atom {\n         use self::Atom::*;\n         match self {\n             Bool => \"bool\",\n+            Char => \"c_char\",\n             U8 => \"u8\",\n             U16 => \"u16\",\n             U32 => \"u32\",\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -99,9 +99,9 @@ fn check_type_rust_vec(cx: &mut Check, ty: &Ty1) {\n         }\n \n         match Atom::from(&ident.rust) {\n-            None | Some(U8) | Some(U16) | Some(U32) | Some(U64) | Some(Usize) | Some(I8)\n-            | Some(I16) | Some(I32) | Some(I64) | Some(Isize) | Some(F32) | Some(F64)\n-            | Some(RustString) => return,\n+            None | Some(Char) | Some(U8) | Some(U16) | Some(U32) | Some(U64) | Some(Usize)\n+            | Some(I8) | Some(I16) | Some(I32) | Some(I64) | Some(Isize) | Some(F32)\n+            | Some(F64) | Some(RustString) => return,\n             Some(Bool) => { /* todo */ }\n             Some(CxxString) => {}\n         }\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -140,6 +140,7 @@ fn check_type_cxx_vector(cx: &mut Check, ptr: &Ty1) {\n             None | Some(U8) | Some(U16) | Some(U32) | Some(U64) | Some(Usize) | Some(I8)\n             | Some(I16) | Some(I32) | Some(I64) | Some(Isize) | Some(F32) | Some(F64)\n             | Some(CxxString) => return,\n+            Some(Char) => { /* todo */ }\n             Some(Bool) | Some(RustString) => {}\n         }\n     }\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -503,6 +504,8 @@ fn describe(cx: &mut Check, ty: &Type) -> String {\n                 \"opaque Rust type\".to_owned()\n             } else if Atom::from(&ident.rust) == Some(CxxString) {\n                 \"C++ string\".to_owned()\n+            } else if Atom::from(&ident.rust) == Some(Char) {\n+                \"C char\".to_owned()\n             } else {\n                 ident.rust.to_string()\n             }\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -11,7 +11,10 @@ impl ToTokens for Type {\n     fn to_tokens(&self, tokens: &mut TokenStream) {\n         match self {\n             Type::Ident(ident) => {\n-                if ident.rust == CxxString {\n+                if ident.rust == Char {\n+                    let span = ident.rust.span();\n+                    tokens.extend(quote_spanned!(span=> ::std::os::raw::));\n+                } else if ident.rust == CxxString {\n                     let span = ident.rust.span();\n                     tokens.extend(quote_spanned!(span=> ::cxx::));\n                 }\n",
        "test_patch": "diff --git a/tests/BUCK b/tests/BUCK\n--- a/tests/BUCK\n+++ b/tests/BUCK\n@@ -12,6 +12,7 @@ rust_test(\n rust_library(\n     name = \"ffi\",\n     srcs = [\n+        \"ffi/cast.rs\",\n         \"ffi/lib.rs\",\n         \"ffi/module.rs\",\n     ],\ndiff --git a/tests/BUILD b/tests/BUILD\n--- a/tests/BUILD\n+++ b/tests/BUILD\n@@ -15,6 +15,7 @@ rust_test(\n rust_library(\n     name = \"cxx_test_suite\",\n     srcs = [\n+        \"ffi/cast.rs\",\n         \"ffi/lib.rs\",\n         \"ffi/module.rs\",\n     ],\ndiff --git /dev/null b/tests/ffi/cast.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ffi/cast.rs\n@@ -0,0 +1,14 @@\n+use std::os::raw::c_char;\n+use std::slice;\n+\n+pub fn c_char_to_unsigned(slice: &[c_char]) -> &[u8] {\n+    let ptr = slice.as_ptr().cast::<u8>();\n+    let len = slice.len();\n+    unsafe { slice::from_raw_parts(ptr, len) }\n+}\n+\n+pub fn unsigned_to_c_char(slice: &[u8]) -> &[c_char] {\n+    let ptr = slice.as_ptr().cast::<c_char>();\n+    let len = slice.len();\n+    unsafe { slice::from_raw_parts(ptr, len) }\n+}\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -6,10 +6,12 @@\n     clippy::unnecessary_wraps\n )]\n \n+pub mod cast;\n pub mod module;\n \n use cxx::{CxxString, CxxVector, UniquePtr};\n use std::fmt::{self, Display};\n+use std::os::raw::c_char;\n \n #[cxx::bridge(namespace = \"tests\")]\n pub mod ffi {\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -81,7 +83,7 @@ pub mod ffi {\n         fn c_return_ref(shared: &Shared) -> &usize;\n         fn c_return_mut(shared: &mut Shared) -> &mut usize;\n         fn c_return_str(shared: &Shared) -> &str;\n-        fn c_return_sliceu8(shared: &Shared) -> &[u8];\n+        fn c_return_slice_char(shared: &Shared) -> &[c_char];\n         fn c_return_mutsliceu8(slice: &mut [u8]) -> &mut [u8];\n         fn c_return_rust_string() -> String;\n         fn c_return_unique_ptr_string() -> UniquePtr<CxxString>;\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -110,7 +112,7 @@ pub mod ffi {\n         fn c_take_ref_r(r: &R);\n         fn c_take_ref_c(c: &C);\n         fn c_take_str(s: &str);\n-        fn c_take_sliceu8(s: &[u8]);\n+        fn c_take_slice_char(s: &[c_char]);\n         fn c_take_slice_shared(s: &[Shared]);\n         fn c_take_rust_string(s: String);\n         fn c_take_unique_ptr_string(s: UniquePtr<CxxString>);\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -214,7 +216,7 @@ pub mod ffi {\n         fn r_take_ref_r(r: &R);\n         fn r_take_ref_c(c: &C);\n         fn r_take_str(s: &str);\n-        fn r_take_sliceu8(s: &[u8]);\n+        fn r_take_slice_char(s: &[c_char]);\n         fn r_take_rust_string(s: String);\n         fn r_take_unique_ptr_string(s: UniquePtr<CxxString>);\n         fn r_take_ref_vector(v: &CxxVector<u8>);\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -472,8 +474,9 @@ fn r_take_rust_string(s: String) {\n     assert_eq!(s, \"2020\");\n }\n \n-fn r_take_sliceu8(s: &[u8]) {\n+fn r_take_slice_char(s: &[c_char]) {\n     assert_eq!(s.len(), 5);\n+    let s = cast::c_char_to_unsigned(s);\n     assert_eq!(std::str::from_utf8(s).unwrap(), \"2020\\0\");\n }\n \ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -75,10 +75,9 @@ rust::Str c_return_str(const Shared &shared) {\n   return \"2020\";\n }\n \n-rust::Slice<const uint8_t> c_return_sliceu8(const Shared &shared) {\n+rust::Slice<const char> c_return_slice_char(const Shared &shared) {\n   (void)shared;\n-  return rust::Slice<const uint8_t>(\n-      reinterpret_cast<const uint8_t *>(SLICE_DATA), sizeof(SLICE_DATA));\n+  return rust::Slice<const char>(SLICE_DATA, sizeof(SLICE_DATA));\n }\n \n rust::Slice<uint8_t> c_return_mutsliceu8(rust::Slice<uint8_t> slice) {\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -243,9 +242,8 @@ void c_take_str(rust::Str s) {\n   }\n }\n \n-void c_take_sliceu8(rust::Slice<const uint8_t> s) {\n-  if (std::string(reinterpret_cast<const char *>(s.data()), s.size()) ==\n-      \"2020\") {\n+void c_take_slice_char(rust::Slice<const char> s) {\n+  if (std::string(s.data(), s.size()) == \"2020\") {\n     cxx_test_suite_set_correct();\n   }\n }\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -626,8 +624,7 @@ extern \"C\" const char *cxx_run_test() noexcept {\n   r_take_unique_ptr(std::unique_ptr<C>(new C{2020}));\n   r_take_ref_c(C{2020});\n   r_take_str(rust::Str(\"2020\"));\n-  r_take_sliceu8(rust::Slice<const uint8_t>(\n-      reinterpret_cast<const uint8_t *>(SLICE_DATA), sizeof(SLICE_DATA)));\n+  r_take_slice_char(rust::Slice<const char>(SLICE_DATA, sizeof(SLICE_DATA)));\n   r_take_rust_string(rust::String(\"2020\"));\n   r_take_unique_ptr_string(\n       std::unique_ptr<std::string>(new std::string(\"2020\")));\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -83,7 +83,7 @@ const size_t &c_return_ns_ref(const ::A::AShared &shared);\n const size_t &c_return_nested_ns_ref(const ::A::B::ABShared &shared);\n size_t &c_return_mut(Shared &shared);\n rust::Str c_return_str(const Shared &shared);\n-rust::Slice<const uint8_t> c_return_sliceu8(const Shared &shared);\n+rust::Slice<const char> c_return_slice_char(const Shared &shared);\n rust::Slice<uint8_t> c_return_mutsliceu8(rust::Slice<uint8_t> slice);\n rust::String c_return_rust_string();\n std::unique_ptr<std::string> c_return_unique_ptr_string();\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -114,7 +114,7 @@ void c_take_ref_r(const R &r);\n void c_take_ref_c(const C &c);\n void c_take_ref_ns_c(const ::H::H &h);\n void c_take_str(rust::Str s);\n-void c_take_sliceu8(rust::Slice<const uint8_t> s);\n+void c_take_slice_char(rust::Slice<const char> s);\n void c_take_slice_shared(rust::Slice<const Shared> s);\n void c_take_rust_string(rust::String s);\n void c_take_unique_ptr_string(std::unique_ptr<std::string> s);\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -1,7 +1,7 @@\n #![allow(clippy::assertions_on_constants, clippy::float_cmp, clippy::unit_cmp)]\n \n use cxx_test_suite::module::ffi2;\n-use cxx_test_suite::{ffi, R};\n+use cxx_test_suite::{cast, ffi, R};\n use std::cell::Cell;\n use std::ffi::CStr;\n \ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -41,7 +41,10 @@ fn test_c_return() {\n     assert_eq!(2020, *ffi::c_return_ns_ref(&ns_shared));\n     assert_eq!(2020, *ffi::c_return_nested_ns_ref(&nested_ns_shared));\n     assert_eq!(\"2020\", ffi::c_return_str(&shared));\n-    assert_eq!(b\"2020\\0\", ffi::c_return_sliceu8(&shared));\n+    assert_eq!(\n+        b\"2020\\0\",\n+        cast::c_char_to_unsigned(ffi::c_return_slice_char(&shared)),\n+    );\n     assert_eq!(\"2020\", ffi::c_return_rust_string());\n     assert_eq!(\"2020\", ffi::c_return_unique_ptr_string().to_str().unwrap());\n     assert_eq!(4, ffi::c_return_unique_ptr_vector_u8().len());\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -116,7 +119,7 @@ fn test_c_take() {\n     check!(ffi2::c_take_ref_ns_c(&unique_ptr_ns));\n     check!(cxx_test_suite::module::ffi::c_take_unique_ptr(unique_ptr));\n     check!(ffi::c_take_str(\"2020\"));\n-    check!(ffi::c_take_sliceu8(b\"2020\"));\n+    check!(ffi::c_take_slice_char(cast::unsigned_to_c_char(b\"2020\")));\n     check!(ffi::c_take_slice_shared(&[\n         ffi::Shared { z: 2020 },\n         ffi::Shared { z: 2021 },\n",
        "problem_statement": "Support c_char type\nThese should be implemented in terms of:\r\n\r\n- char = https://doc.rust-lang.org/std/os/raw/type.c_char.html\r\n- signed char = https://doc.rust-lang.org/std/os/raw/type.c_schar.html\r\n- unsigned char = https://doc.rust-lang.org/std/os/raw/type.c_uchar.html\r\n\r\nUseful for passing `&[c_char]` --\\> `rust::Slice<char>` --\\> `const char*`.\n",
        "hints_text": "Maybe only `char` is needed? I guess `signed char` and `unsigned char` will always be the same as `i8` and `u8` on platforms that Rust supports.",
        "created_at": "2020-11-26T04:07:41Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 502,
        "instance_id": "dtolnay__cxx-502",
        "issue_numbers": [
            "452"
        ],
        "base_commit": "cd271f2dc891cc7d836de66d219c9180adac198a",
        "patch": "diff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -323,6 +323,7 @@ returns of functions.\n <tr><td>String</td><td>rust::String</td><td></td></tr>\n <tr><td>&amp;str</td><td>rust::Str</td><td></td></tr>\n <tr><td>&amp;[u8]</td><td>rust::Slice&lt;const uint8_t&gt;</td><td><sup><i>arbitrary &amp;[T] not implemented yet</i></sup></td></tr>\n+<tr><td>&amp;mut [u8]</td><td>rust::Slice&lt;uint8_t&gt;</td><td><sup><i>arbitrary &amp;mut [T] not implemented yet</i></sup></td></tr>\n <tr><td><a href=\"https://docs.rs/cxx/1.0/cxx/struct.CxxString.html\">CxxString</a></td><td>std::string</td><td><sup><i>cannot be passed by value</i></sup></td></tr>\n <tr><td>Box&lt;T&gt;</td><td>rust::Box&lt;T&gt;</td><td><sup><i>cannot hold opaque C++ type</i></sup></td></tr>\n <tr><td><a href=\"https://docs.rs/cxx/1.0/cxx/struct.UniquePtr.html\">UniquePtr&lt;T&gt;</a></td><td>std::unique_ptr&lt;T&gt;</td><td><sup><i>cannot hold opaque Rust type</i></sup></td></tr>\ndiff --git a/book/src/SUMMARY.md b/book/src/SUMMARY.md\n--- a/book/src/SUMMARY.md\n+++ b/book/src/SUMMARY.md\n@@ -25,7 +25,7 @@\n - [Reference: built-in bindings](bindings.md)\n     - [String &mdash; rust::String](binding/string.md)\n     - [&str &mdash; rust::Str](binding/str.md)\n-    - [&&#91;T&#93; &mdash; rust::Slice\\<const T\\>](binding/slice.md)\n+    - [&&#91;T&#93;, &mut &#91;T&#93; &mdash; rust::Slice\\<T\\>](binding/slice.md)\n     - [CxxString &mdash; std::string](binding/cxxstring.md)\n     - [Box\\<T\\> &mdash; rust::Box\\<T\\>](binding/box.md)\n     - [UniquePtr\\<T\\> &mdash; std::unique\\_ptr\\<T\\>](binding/uniqueptr.md)\ndiff --git a/book/src/binding/slice.md b/book/src/binding/slice.md\n--- a/book/src/binding/slice.md\n+++ b/book/src/binding/slice.md\n@@ -1,5 +1,8 @@\n {{#title rust::Slice<T> \u2014 Rust \u2661 C++}}\n-# rust::Slice\\<T\\>\n+# rust::Slice\\<const T\\>,&ensp;rust::Slice\\<T\\>\n+\n+- Rust `&[T]` is written `rust::Slice<const T>` in C++\n+- Rust `&mut [T]` is written `rust::Slice<T>` in C++\n \n ### Public API:\n \ndiff --git a/book/src/binding/slice.md b/book/src/binding/slice.md\n--- a/book/src/binding/slice.md\n+++ b/book/src/binding/slice.md\n@@ -15,7 +18,10 @@ public:\n   Slice(const Slice<T> &) noexcept;\n   Slice(T *, size_t count) noexcept;\n \n+  // if std::is_const<T> {\n   Slice &operator=(const Slice<T> &) noexcept;\n+  // }\n+  Slice &operator=(Slice<T> &&) noexcept;\n \n   T *data() const noexcept;\n   size_t size() const noexcept;\ndiff --git a/book/src/binding/slice.md b/book/src/binding/slice.md\n--- a/book/src/binding/slice.md\n+++ b/book/src/binding/slice.md\n@@ -27,11 +33,14 @@ public:\n \n ### Restrictions:\n \n-Only &amp;\\[u8\\] i.e. rust::Slice\\<const uint8\\_t\\> is currently implemented.\n-Support for arbitrary &amp;\\[T\\] is coming.\n+Only T=u8 i.e. rust::Slice\\<const uint8\\_t\\> and rust::Slice\\<uint8\\_t\\> are\n+currently implemented. Support for arbitrary T is coming.\n \n Allowed as function argument or return value. Not supported in shared structs.\n-&amp;mut \\[T\\] is not supported yet.\n+\n+Only rust::Slice\\<const T\\> is copy-assignable, not rust::Slice\\<T\\>. (Both are\n+move-assignable.) You'll need to write std::move occasionally as a reminder that\n+accidentally exposing overlapping &amp;mut \\[T\\] to Rust is UB.\n \n ## Example\n \ndiff --git a/book/src/bindings.md b/book/src/bindings.md\n--- a/book/src/bindings.md\n+++ b/book/src/bindings.md\n@@ -12,6 +12,7 @@ returns of extern functions.\n <tr><td style=\"padding:3px 6px\">String</td><td style=\"padding:3px 6px\"><b><a href=\"binding/string.md\">rust::String</a></b></td><td style=\"padding:3px 6px\"></td></tr>\n <tr><td style=\"padding:3px 6px\">&amp;str</td><td style=\"padding:3px 6px\"><b><a href=\"binding/str.md\">rust::Str</a></b></td><td style=\"padding:3px 6px\"></td></tr>\n <tr><td style=\"padding:3px 6px\">&amp;[u8]</td><td style=\"padding:3px 6px\"><b><a href=\"binding/slice.md\">rust::Slice&lt;const&nbsp;uint8_t&gt;</a></b></td><td style=\"padding:3px 6px\"><sup><i>arbitrary &amp;[T] not implemented yet</i></sup></td></tr>\n+<tr><td style=\"padding:3px 6px\">&amp;mut [u8]</td><td style=\"padding:3px 6px\"><b><a href=\"binding/slice.md\">rust::Slice&lt;uint8_t&gt;</a></b></td><td style=\"padding:3px 6px\"><sup><i>arbitrary &amp;mut [T] not implemented yet</i></sup></td></tr>\n <tr><td style=\"padding:3px 6px\"><b><a href=\"binding/cxxstring.md\">CxxString</a></b></td><td style=\"padding:3px 6px\">std::string</td><td style=\"padding:3px 6px\"><sup><i>cannot be passed by value</i></sup></td></tr>\n <tr><td style=\"padding:3px 6px\">Box&lt;T&gt;</td><td style=\"padding:3px 6px\"><b><a href=\"binding/box.md\">rust::Box&lt;T&gt;</a></b></td><td style=\"padding:3px 6px\"><sup><i>cannot hold opaque C++ type</i></sup></td></tr>\n <tr><td style=\"padding:3px 6px\"><b><a href=\"binding/uniqueptr.md\">UniquePtr&lt;T&gt;</a></b></td><td style=\"padding:3px 6px\">std::unique_ptr&lt;T&gt;</td><td style=\"padding:3px 6px\"><sup><i>cannot hold opaque Rust type</i></sup></td></tr>\ndiff --git a/book/src/bindings.md b/book/src/bindings.md\n--- a/book/src/bindings.md\n+++ b/book/src/bindings.md\n@@ -43,7 +44,6 @@ matter of designing a nice API for each in its non-native language.\n \n <table>\n <tr><th>name in Rust</th><th>name in C++</th></tr>\n-<tr><td>&amp;mut [T]</td><td>rust::Slice&lt;T&gt;</td></tr>\n <tr><td>BTreeMap&lt;K, V&gt;</td><td><sup><i>tbd</i></sup></td></tr>\n <tr><td>HashMap&lt;K, V&gt;</td><td><sup><i>tbd</i></sup></td></tr>\n <tr><td>Arc&lt;T&gt;</td><td><sup><i>tbd</i></sup></td></tr>\ndiff --git a/gen/src/builtin.rs b/gen/src/builtin.rs\n--- a/gen/src/builtin.rs\n+++ b/gen/src/builtin.rs\n@@ -149,7 +149,7 @@ pub(super) fn write(out: &mut OutFile) {\n     if builtin.ptr_len {\n         out.begin_block(Block::Namespace(\"repr\"));\n         writeln!(out, \"struct PtrLen final {{\");\n-        writeln!(out, \"  const void *ptr;\");\n+        writeln!(out, \"  void *ptr;\");\n         writeln!(out, \"  size_t len;\");\n         writeln!(out, \"}};\");\n         out.end_block(Block::Namespace(\"repr\"));\ndiff --git a/gen/src/builtin.rs b/gen/src/builtin.rs\n--- a/gen/src/builtin.rs\n+++ b/gen/src/builtin.rs\n@@ -173,7 +173,10 @@ pub(super) fn write(out: &mut OutFile) {\n         }\n         if builtin.rust_str_repr {\n             writeln!(out, \"  static repr::PtrLen repr(Str str) noexcept {{\");\n-            writeln!(out, \"    return repr::PtrLen{{str.ptr, str.len}};\");\n+            writeln!(\n+                out,\n+                \"    return repr::PtrLen{{const_cast<char *>(str.ptr), str.len}};\",\n+            );\n             writeln!(out, \"  }}\");\n         }\n         writeln!(out, \"}};\");\ndiff --git a/gen/src/builtin.rs b/gen/src/builtin.rs\n--- a/gen/src/builtin.rs\n+++ b/gen/src/builtin.rs\n@@ -189,18 +192,21 @@ pub(super) fn write(out: &mut OutFile) {\n                 out,\n                 \"  static Slice<T> slice(repr::PtrLen repr) noexcept {{\",\n             );\n-            writeln!(\n-                out,\n-                \"    return {{static_cast<const T *>(repr.ptr), repr.len}};\",\n-            );\n+            writeln!(out, \"    return {{static_cast<T *>(repr.ptr), repr.len}};\");\n             writeln!(out, \"  }}\");\n         }\n         if builtin.rust_slice_repr {\n+            include.type_traits = true;\n             writeln!(\n                 out,\n                 \"  static repr::PtrLen repr(Slice<T> slice) noexcept {{\",\n             );\n-            writeln!(out, \"    return repr::PtrLen{{slice.ptr, slice.len}};\");\n+            writeln!(out, \"    return repr::PtrLen{{\");\n+            writeln!(\n+                out,\n+                \"        const_cast<typename ::std::remove_const<T>::type *>(slice.ptr),\",\n+            );\n+            writeln!(out, \"        slice.len}};\");\n             writeln!(out, \"  }}\");\n         }\n         writeln!(out, \"}};\");\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -436,9 +436,11 @@ fn write_cxx_function_shim<'a>(out: &mut OutFile<'a>, efn: &'a ExternFn) {\n             out.builtin.rust_str_repr = true;\n             write!(out, \"::rust::impl<::rust::Str>::repr(\");\n         }\n-        Some(Type::SliceRefU8(_)) if !indirect_return => {\n+        Some(ty @ Type::SliceRefU8(_)) if !indirect_return => {\n             out.builtin.rust_slice_repr = true;\n-            write!(out, \"::rust::impl<::rust::Slice<const uint8_t>>::repr(\")\n+            write!(out, \"::rust::impl<\");\n+            write_type(out, ty);\n+            write!(out, \">::repr(\");\n         }\n         _ => {}\n     }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -474,12 +476,13 @@ fn write_cxx_function_shim<'a>(out: &mut OutFile<'a>, efn: &'a ExternFn) {\n             out.builtin.unsafe_bitcopy = true;\n             write_type(out, &arg.ty);\n             write!(out, \"(::rust::unsafe_bitcopy, *{})\", arg.ident);\n-        } else if let Type::SliceRefU8(_) = arg.ty {\n-            write!(\n-                out,\n-                \"::rust::Slice<const uint8_t>(static_cast<const uint8_t *>({0}.ptr), {0}.len)\",\n-                arg.ident,\n-            );\n+        } else if let Type::SliceRefU8(slice) = &arg.ty {\n+            write_type(out, &arg.ty);\n+            write!(out, \"(static_cast<\");\n+            if slice.mutability.is_none() {\n+                write!(out, \"const \");\n+            }\n+            write!(out, \"uint8_t *>({0}.ptr), {0}.len)\", arg.ident);\n         } else if out.types.needs_indirect_abi(&arg.ty) {\n             out.include.utility = true;\n             write!(out, \"::std::move(*{})\", arg.ident);\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -507,7 +510,7 @@ fn write_cxx_function_shim<'a>(out: &mut OutFile<'a>, efn: &'a ExternFn) {\n         writeln!(out, \"        throw$.len = ::std::strlen(catch$);\");\n         writeln!(\n             out,\n-            \"        throw$.ptr = ::cxxbridge1$exception(catch$, throw$.len);\",\n+            \"        throw$.ptr = const_cast<char *>(::cxxbridge1$exception(catch$, throw$.len));\",\n         );\n         writeln!(out, \"      }});\");\n         writeln!(out, \"  return throw$;\");\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -694,7 +697,9 @@ fn write_rust_function_shim_impl(\n             }\n             Type::SliceRefU8(_) => {\n                 out.builtin.rust_slice_new = true;\n-                write!(out, \"::rust::impl<::rust::Slice<const uint8_t>>::slice(\");\n+                write!(out, \"::rust::impl<\");\n+                write_type(out, ret);\n+                write!(out, \">::slice(\");\n             }\n             _ => {}\n         }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -720,7 +725,9 @@ fn write_rust_function_shim_impl(\n             }\n             Type::SliceRefU8(_) => {\n                 out.builtin.rust_slice_repr = true;\n-                write!(out, \"::rust::impl<::rust::Slice<const uint8_t>>::repr(\");\n+                write!(out, \"::rust::impl<\");\n+                write_type(out, &arg.ty);\n+                write!(out, \">::repr(\");\n             }\n             ty if out.types.needs_indirect_abi(ty) => write!(out, \"&\"),\n             _ => {}\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -890,8 +897,12 @@ fn write_type(out: &mut OutFile, ty: &Type) {\n         Type::Str(_) => {\n             write!(out, \"::rust::Str\");\n         }\n-        Type::SliceRefU8(_) => {\n-            write!(out, \"::rust::Slice<const uint8_t>\");\n+        Type::SliceRefU8(ty) => {\n+            write!(out, \"::rust::Slice<\");\n+            if ty.mutability.is_none() {\n+                write!(out, \"const \");\n+            }\n+            write!(out, \"uint8_t>\");\n         }\n         Type::Fn(f) => {\n             write!(out, \"::rust::{}<\", if f.throws { \"TryFn\" } else { \"Fn\" });\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -87,16 +87,28 @@ class Str final {\n #endif // CXXBRIDGE1_RUST_STR\n \n #ifndef CXXBRIDGE1_RUST_SLICE\n-template <typename T>\n-class Slice final {\n-  static_assert(std::is_const<T>::value,\n-                \"&[T] needs to be written as rust::Slice<const T> in C++\");\n+namespace detail {\n+template <bool cond>\n+struct copy_assignable_if {};\n+\n+template <>\n+struct copy_assignable_if<false> {\n+  copy_assignable_if() noexcept = default;\n+  copy_assignable_if(const copy_assignable_if &) noexcept = default;\n+  copy_assignable_if &operator=(const copy_assignable_if &) noexcept = delete;\n+  copy_assignable_if &operator=(copy_assignable_if &&) noexcept = default;\n+};\n+} // namespace detail\n \n+template <typename T>\n+class Slice final\n+    : private detail::copy_assignable_if<std::is_const<T>::value> {\n public:\n   Slice() noexcept;\n   Slice(T *, size_t count) noexcept;\n \n   Slice &operator=(const Slice<T> &) noexcept = default;\n+  Slice &operator=(Slice<T> &&) noexcept = default;\n \n   T *data() const noexcept;\n   size_t size() const noexcept;\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -330,7 +330,10 @@ fn expand_cxx_function_shim(efn: &ExternFn, types: &Types) -> TokenStream {\n                 _ => quote!(#var),\n             },\n             Type::Str(_) => quote!(::cxx::private::RustStr::from(#var)),\n-            Type::SliceRefU8(_) => quote!(::cxx::private::RustSliceU8::from(#var)),\n+            Type::SliceRefU8(ty) => match ty.mutable {\n+                false => quote!(::cxx::private::RustSliceU8::from_ref(#var)),\n+                true => quote!(::cxx::private::RustSliceU8::from_mut(#var)),\n+            },\n             ty if types.needs_indirect_abi(ty) => quote!(#var.as_mut_ptr()),\n             _ => quote!(#var),\n         }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -423,7 +426,10 @@ fn expand_cxx_function_shim(efn: &ExternFn, types: &Types) -> TokenStream {\n                     _ => call,\n                 },\n                 Type::Str(_) => quote!(#call.as_str()),\n-                Type::SliceRefU8(_) => quote!(#call.as_slice()),\n+                Type::SliceRefU8(ty) => match ty.mutable {\n+                    false => quote!(#call.as_slice()),\n+                    true => quote!(#call.as_mut_slice()),\n+                },\n                 _ => call,\n             },\n         };\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -610,7 +616,10 @@ fn expand_rust_function_shim_impl(\n                 _ => quote!(#ident),\n             },\n             Type::Str(_) => quote!(#ident.as_str()),\n-            Type::SliceRefU8(_) => quote!(#ident.as_slice()),\n+            Type::SliceRefU8(ty) => match ty.mutable {\n+                false => quote!(#ident.as_slice()),\n+                true => quote!(#ident.as_mut_slice()),\n+            },\n             ty if types.needs_indirect_abi(ty) => quote!(::std::ptr::read(#ident)),\n             _ => quote!(#ident),\n         }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -654,7 +663,10 @@ fn expand_rust_function_shim_impl(\n             _ => None,\n         },\n         Type::Str(_) => Some(quote!(::cxx::private::RustStr::from)),\n-        Type::SliceRefU8(_) => Some(quote!(::cxx::private::RustSliceU8::from)),\n+        Type::SliceRefU8(ty) => match ty.mutable {\n+            false => Some(quote!(::cxx::private::RustSliceU8::from_ref)),\n+            true => Some(quote!(::cxx::private::RustSliceU8::from_mut)),\n+        },\n         _ => None,\n     });\n \ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -180,6 +180,17 @@ static_assert(std::is_trivially_move_assignable<Slice<const uint8_t>>::value,\n static_assert(std::is_trivially_destructible<Slice<const uint8_t>>::value,\n               \"trivial ~Slice()\");\n \n+static_assert(std::is_trivially_copy_constructible<Slice<uint8_t>>::value,\n+              \"trivial Slice(const Slice &)\");\n+static_assert(std::is_trivially_move_constructible<Slice<uint8_t>>::value,\n+              \"trivial Slice(Slice &&)\");\n+static_assert(!std::is_copy_assignable<Slice<uint8_t>>::value,\n+              \"delete Slice::operator=(const Slice &) for mut slices\");\n+static_assert(std::is_trivially_move_assignable<Slice<uint8_t>>::value,\n+              \"trivial Slice::operator=(Slice &&)\");\n+static_assert(std::is_trivially_destructible<Slice<uint8_t>>::value,\n+              \"trivial ~Slice()\");\n+\n extern \"C\" {\n const char *cxxbridge1$error(const char *ptr, size_t len) {\n   char *copy = new char[len];\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -332,6 +332,7 @@\n //! <tr><td>String</td><td>rust::String</td><td></td></tr>\n //! <tr><td>&amp;str</td><td>rust::Str</td><td></td></tr>\n //! <tr><td>&amp;[u8]</td><td>rust::Slice&lt;const uint8_t&gt;</td><td><sup><i>arbitrary &amp;[T] not implemented yet</i></sup></td></tr>\n+//! <tr><td>&amp;mut [u8]</td><td>rust::Slice&lt;uint8_t&gt;</td><td><sup><i>arbitrary &amp;mut [T] not implemented yet</i></sup></td></tr>\n //! <tr><td><a href=\"struct.CxxString.html\">CxxString</a></td><td>std::string</td><td><sup><i>cannot be passed by value</i></sup></td></tr>\n //! <tr><td>Box&lt;T&gt;</td><td>rust::Box&lt;T&gt;</td><td><sup><i>cannot hold opaque C++ type</i></sup></td></tr>\n //! <tr><td><a href=\"struct.UniquePtr.html\">UniquePtr&lt;T&gt;</a></td><td>std::unique_ptr&lt;T&gt;</td><td><sup><i>cannot hold opaque Rust type</i></sup></td></tr>\ndiff --git a/src/rust_sliceu8.rs b/src/rust_sliceu8.rs\n--- a/src/rust_sliceu8.rs\n+++ b/src/rust_sliceu8.rs\n@@ -11,16 +11,27 @@ pub struct RustSliceU8 {\n }\n \n impl RustSliceU8 {\n-    pub fn from(s: &[u8]) -> Self {\n+    pub fn from_ref(s: &[u8]) -> Self {\n         RustSliceU8 {\n             ptr: NonNull::from(s).cast::<u8>(),\n             len: s.len(),\n         }\n     }\n \n+    pub fn from_mut(s: &mut [u8]) -> Self {\n+        RustSliceU8 {\n+            len: s.len(),\n+            ptr: NonNull::from(s).cast::<u8>(),\n+        }\n+    }\n+\n     pub unsafe fn as_slice<'a>(self) -> &'a [u8] {\n         slice::from_raw_parts(self.ptr.as_ptr(), self.len)\n     }\n+\n+    pub unsafe fn as_mut_slice<'a>(self) -> &'a mut [u8] {\n+        slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len)\n+    }\n }\n \n const_assert_eq!(\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -178,7 +178,10 @@ fn check_type_ref(cx: &mut Check, ty: &Ref) {\n }\n \n fn check_type_slice(cx: &mut Check, ty: &Slice) {\n-    cx.error(ty, \"only &[u8] is supported so far, not other slice types\");\n+    cx.error(\n+        ty,\n+        \"only &[u8] and &mut [u8] are supported so far, not other slice types\",\n+    );\n }\n \n fn check_type_fn(cx: &mut Check, ty: &Signature) {\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -489,7 +492,10 @@ fn describe(cx: &mut Check, ty: &Type) -> String {\n         Type::Str(_) => \"&str\".to_owned(),\n         Type::CxxVector(_) => \"C++ vector\".to_owned(),\n         Type::Slice(_) => \"slice\".to_owned(),\n-        Type::SliceRefU8(_) => \"&[u8]\".to_owned(),\n+        Type::SliceRefU8(ty) => match ty.mutable {\n+            false => \"&[u8]\".to_owned(),\n+            true => \"&mut [u8]\".to_owned(),\n+        },\n         Type::Fn(_) => \"function pointer\".to_owned(),\n         Type::Void(_) => \"()\".to_owned(),\n     }\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -658,7 +658,7 @@ fn parse_type_reference(ty: &TypeReference, namespace: &Namespace) -> Result<Typ\n             }\n         }\n         Type::Slice(slice) => match &slice.inner {\n-            Type::Ident(ident) if ident.rust == U8 && ty.mutability.is_none() => Type::SliceRefU8,\n+            Type::Ident(ident) if ident.rust == U8 => Type::SliceRefU8,\n             _ => Type::Ref,\n         },\n         _ => Type::Ref,\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -77,6 +77,7 @@ pub mod ffi {\n         fn c_return_mut(shared: &mut Shared) -> &mut usize;\n         fn c_return_str(shared: &Shared) -> &str;\n         fn c_return_sliceu8(shared: &Shared) -> &[u8];\n+        fn c_return_mutsliceu8(slice: &mut [u8]) -> &mut [u8];\n         fn c_return_rust_string() -> String;\n         fn c_return_unique_ptr_string() -> UniquePtr<CxxString>;\n         fn c_return_unique_ptr_vector_u8() -> UniquePtr<CxxVector<u8>>;\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -140,6 +141,7 @@ pub mod ffi {\n         fn c_try_return_ref(s: &String) -> Result<&String>;\n         fn c_try_return_str(s: &str) -> Result<&str>;\n         fn c_try_return_sliceu8(s: &[u8]) -> Result<&[u8]>;\n+        fn c_try_return_mutsliceu8(s: &mut [u8]) -> Result<&mut [u8]>;\n         fn c_try_return_rust_string() -> Result<String>;\n         fn c_try_return_unique_ptr_string() -> Result<UniquePtr<CxxString>>;\n         fn c_try_return_rust_vec() -> Result<Vec<u8>>;\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -187,6 +189,7 @@ pub mod ffi {\n         fn r_return_mut(shared: &mut Shared) -> &mut usize;\n         fn r_return_str(shared: &Shared) -> &str;\n         fn r_return_sliceu8(shared: &Shared) -> &[u8];\n+        fn r_return_mutsliceu8(slice: &mut [u8]) -> &mut [u8];\n         fn r_return_rust_string() -> String;\n         fn r_return_unique_ptr_string() -> UniquePtr<CxxString>;\n         fn r_return_rust_vec() -> Vec<u8>;\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -220,6 +223,7 @@ pub mod ffi {\n         fn r_try_return_box() -> Result<Box<R>>;\n         fn r_fail_return_primitive() -> Result<usize>;\n         fn r_try_return_sliceu8(s: &[u8]) -> Result<&[u8]>;\n+        fn r_try_return_mutsliceu8(s: &mut [u8]) -> Result<&mut [u8]>;\n \n         fn get(self: &R) -> usize;\n         fn set(self: &mut R, n: usize) -> usize;\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -371,6 +375,10 @@ fn r_return_sliceu8(shared: &ffi::Shared) -> &[u8] {\n     b\"2020\"\n }\n \n+fn r_return_mutsliceu8(slice: &mut [u8]) -> &mut [u8] {\n+    slice\n+}\n+\n fn r_return_rust_string() -> String {\n     \"2020\".to_owned()\n }\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -509,6 +517,10 @@ fn r_try_return_sliceu8(slice: &[u8]) -> Result<&[u8], Error> {\n     Ok(slice)\n }\n \n+fn r_try_return_mutsliceu8(slice: &mut [u8]) -> Result<&mut [u8], Error> {\n+    Ok(slice)\n+}\n+\n fn r_aliased_function(x: i32) -> String {\n     x.to_string()\n }\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -77,6 +77,10 @@ rust::Slice<const uint8_t> c_return_sliceu8(const Shared &shared) {\n       reinterpret_cast<const uint8_t *>(SLICE_DATA), sizeof(SLICE_DATA));\n }\n \n+rust::Slice<uint8_t> c_return_mutsliceu8(rust::Slice<uint8_t> slice) {\n+  return slice;\n+}\n+\n rust::String c_return_rust_string() { return \"2020\"; }\n \n std::unique_ptr<std::string> c_return_unique_ptr_string() {\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -435,6 +439,10 @@ rust::Slice<const uint8_t> c_try_return_sliceu8(rust::Slice<const uint8_t> s) {\n   return s;\n }\n \n+rust::Slice<uint8_t> c_try_return_mutsliceu8(rust::Slice<uint8_t> s) {\n+  return s;\n+}\n+\n rust::String c_try_return_rust_string() { return c_return_rust_string(); }\n \n std::unique_ptr<std::string> c_try_return_unique_ptr_string() {\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -84,6 +84,7 @@ const size_t &c_return_nested_ns_ref(const ::A::B::ABShared &shared);\n size_t &c_return_mut(Shared &shared);\n rust::Str c_return_str(const Shared &shared);\n rust::Slice<const uint8_t> c_return_sliceu8(const Shared &shared);\n+rust::Slice<uint8_t> c_return_mutsliceu8(rust::Slice<uint8_t> slice);\n rust::String c_return_rust_string();\n std::unique_ptr<std::string> c_return_unique_ptr_string();\n std::unique_ptr<std::vector<uint8_t>> c_return_unique_ptr_vector_u8();\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -148,6 +149,7 @@ rust::Box<R> c_try_return_box();\n const rust::String &c_try_return_ref(const rust::String &);\n rust::Str c_try_return_str(rust::Str);\n rust::Slice<const uint8_t> c_try_return_sliceu8(rust::Slice<const uint8_t>);\n+rust::Slice<uint8_t> c_try_return_mutsliceu8(rust::Slice<uint8_t>);\n rust::String c_try_return_rust_string();\n std::unique_ptr<std::string> c_try_return_unique_ptr_string();\n rust::Vec<uint8_t> c_try_return_rust_vec();\n",
        "problem_statement": "&mut [u8] support\nThis seems to work, but I have no idea if it's the correct way to implement it.\r\n\r\nCloses #451.\n",
        "hints_text": "I mean, you could just copy it by getting the data pointer and constructing another slice from it anyway. But yeah, technically that is UB so maybe the copy constructor shouldn't exist.\r\n\r\nOh yeah, being able to reuse the Slice type for both mutable and immutable slices would be pretty nice. \nHmm, the tests are failing because rust::repr::PtrLen has a `const void*` as the pointer type which it's trying to cast to `uint8_t*`. How should this be fixed?\r\n\r\nEdit: also not seeing how to have the copy constructor only be available for `Slice<const T>` after #453. I tried messing around with std::enable_if/SFINAE but this is beyond my limited C++ knowledge :P\n> Hmm, the tests are failing because rust::repr::PtrLen has a `const void*` as the pointer type which it's trying to cast to `uint8_t*`. How should this be fixed?\r\n\r\nLooks like a job for https://en.cppreference.com/w/cpp/language/const_cast. Alternatively maybe if PtrLen were to contain `void*` it would work in both cases?\r\n\r\n> Edit: also not seeing how to have the copy constructor only be available for `Slice<const T>` after #453. I tried messing around with std::enable_if/SFINAE but this is beyond my limited C++ knowledge :P\r\n\r\nYeah something with enable_if. I'm not a C++ pro either, one of us will just need to poke on it until it works. -.-\nWell, this should work now. At least the tests pass, I can't check it with real code yet though because of #496.\nI can't get the enable_if on the slice constructors to work for some reason, and at this point I think I tried 7 different ways of doing it. It either works for both mutable and const slices or not at all. At this point I'd just leave it since C++ is already unsafe (even if that constructor was gone, you could still trivially copy mutable slices) unless you really want this check.\r\n\r\nEverything else seems to work now though, after testing it with [the project I'm using cxx with][1].\r\n\r\n[1]: https://github.com/2xsaiko/mcrestool",
        "created_at": "2020-11-24T21:46:27Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 483,
        "instance_id": "dtolnay__cxx-483",
        "issue_numbers": [
            "390"
        ],
        "base_commit": "bf1000f40e3755a2cebfcd59b35f30b591765749",
        "patch": "diff --git /dev/null b/.clang-tidy\nnew file mode 100644\n--- /dev/null\n+++ b/.clang-tidy\n@@ -0,0 +1,2 @@\n+Checks: clang-diagnostic-*,clang-analyzer-*,modernize-*,cppcoreguidelines-*,\n+    -modernize-use-trailing-return-type,-cppcoreguidelines-pro-type-reinterpret-cast\n",
        "test_patch": "diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml\n--- a/.github/workflows/ci.yml\n+++ b/.github/workflows/ci.yml\n@@ -94,3 +94,13 @@ jobs:\n       - uses: actions/checkout@v2\n       - uses: dtolnay/rust-toolchain@clippy\n       - run: cargo clippy --workspace --tests -- -Dclippy::all\n+\n+    clang-tidy:\n+      name: Clang Tidy\n+      runs-on: ubuntu-latest\n+      steps:\n+        - uses: actions/checkout@v2\n+        - name: Install clang-tidy\n+          run: sudo apt install clang-tidy-10\n+        - name: Run clang-tidy\n+          run: clang-tidy-10 src/cxx.cc --header-filter='cxx\\.h' -- -Iinclude -xc++ -std=c++11\n",
        "problem_statement": "Set up C++ linter or static analysis in CI\nI haven't done a C++ project before --- is there a good linter or static analyzer that we should be running on [include/cxx.h](https://github.com/dtolnay/cxx/blob/master/include/cxx.h) and [src/cxx.cc](https://github.com/dtolnay/cxx/blob/master/src/cxx.cc) in the GitHub Actions jobs?\n",
        "hints_text": "I'd argue that [clang-tidy](https://clang.llvm.org/extra/clang-tidy/) is one of the more up-to-date/complete/modern ones.\r\n\r\nA set of [checks](https://clang.llvm.org/extra/clang-tidy/checks/list.html) also need to be enabled. The default ones probably are not enough. I recommend at least `modernize-*`, `clang-analyzer-*`and `cppcoreguidelines-*`.\r\n\r\nI can have a look if you think clang-tidy is ok.\nThat would be great!",
        "created_at": "2020-11-17T21:06:44Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 981,
        "instance_id": "dtolnay__cxx-981",
        "issue_numbers": [
            "907"
        ],
        "base_commit": "ebf72757d2289221bf8d31009361327a28cf417c",
        "patch": "diff --git a/macro/src/derive.rs b/macro/src/derive.rs\n--- a/macro/src/derive.rs\n+++ b/macro/src/derive.rs\n@@ -140,7 +140,7 @@ fn struct_debug(strct: &Struct, span: Span) -> TokenStream {\n \n     quote_spanned! {span=>\n         impl #generics ::cxx::core::fmt::Debug for #ident #generics {\n-            fn fmt(&self, formatter: &mut ::cxx::core::fmt::Formatter) -> ::cxx::core::fmt::Result {\n+            fn fmt(&self, formatter: &mut ::cxx::core::fmt::Formatter<'_>) -> ::cxx::core::fmt::Result {\n                 formatter.debug_struct(#struct_name)\n                     #(.field(#field_names, &self.#fields))*\n                     .finish()\ndiff --git a/macro/src/derive.rs b/macro/src/derive.rs\n--- a/macro/src/derive.rs\n+++ b/macro/src/derive.rs\n@@ -251,7 +251,7 @@ fn enum_debug(enm: &Enum, span: Span) -> TokenStream {\n \n     quote_spanned! {span=>\n         impl ::cxx::core::fmt::Debug for #ident {\n-            fn fmt(&self, formatter: &mut ::cxx::core::fmt::Formatter) -> ::cxx::core::fmt::Result {\n+            fn fmt(&self, formatter: &mut ::cxx::core::fmt::Formatter<'_>) -> ::cxx::core::fmt::Result {\n                 match *self {\n                     #(#variants)*\n                     _ => ::cxx::core::write!(formatter, #fallback, self.repr),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -53,7 +53,7 @@ fn expand(ffi: Module, doc: Doc, attrs: OtherAttrs, apis: &[Api], types: &Types)\n     for api in apis {\n         if let Api::RustType(ety) = api {\n             expanded.extend(expand_rust_type_import(ety));\n-            hidden.extend(expand_rust_type_assert_unpin(ety));\n+            hidden.extend(expand_rust_type_assert_unpin(ety, types));\n         }\n     }\n \ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -70,7 +70,7 @@ fn expand(ffi: Module, doc: Doc, attrs: OtherAttrs, apis: &[Api], types: &Types)\n                 let ident = &ety.name.rust;\n                 if !types.structs.contains_key(ident) && !types.enums.contains_key(ident) {\n                     expanded.extend(expand_cxx_type(ety));\n-                    hidden.extend(expand_cxx_type_assert_pinned(ety));\n+                    hidden.extend(expand_cxx_type_assert_pinned(ety, types));\n                 }\n             }\n             Api::CxxFunction(efn) => {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -78,7 +78,7 @@ fn expand(ffi: Module, doc: Doc, attrs: OtherAttrs, apis: &[Api], types: &Types)\n             }\n             Api::RustType(ety) => {\n                 expanded.extend(expand_rust_type_impl(ety));\n-                hidden.extend(expand_rust_type_layout(ety));\n+                hidden.extend(expand_rust_type_layout(ety, types));\n             }\n             Api::RustFunction(efn) => hidden.extend(expand_rust_function_shim(efn, types)),\n             Api::TypeAlias(alias) => {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -186,6 +186,7 @@ fn expand_struct(strct: &Struct) -> TokenStream {\n \n fn expand_struct_operators(strct: &Struct) -> TokenStream {\n     let ident = &strct.name.rust;\n+    let generics = &strct.generics;\n     let mut operators = TokenStream::new();\n \n     for derive in &strct.derives {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -198,7 +199,7 @@ fn expand_struct_operators(strct: &Struct) -> TokenStream {\n                 operators.extend(quote_spanned! {span=>\n                     #[doc(hidden)]\n                     #[export_name = #link_name]\n-                    extern \"C\" fn #local_name(lhs: &#ident, rhs: &#ident) -> bool {\n+                    extern \"C\" fn #local_name #generics(lhs: &#ident #generics, rhs: &#ident #generics) -> bool {\n                         let __fn = concat!(\"<\", module_path!(), #prevent_unwind_label);\n                         ::cxx::private::prevent_unwind(__fn, || *lhs == *rhs)\n                     }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -211,7 +212,7 @@ fn expand_struct_operators(strct: &Struct) -> TokenStream {\n                     operators.extend(quote_spanned! {span=>\n                         #[doc(hidden)]\n                         #[export_name = #link_name]\n-                        extern \"C\" fn #local_name(lhs: &#ident, rhs: &#ident) -> bool {\n+                        extern \"C\" fn #local_name #generics(lhs: &#ident #generics, rhs: &#ident #generics) -> bool {\n                             let __fn = concat!(\"<\", module_path!(), #prevent_unwind_label);\n                             ::cxx::private::prevent_unwind(__fn, || *lhs != *rhs)\n                         }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -225,7 +226,7 @@ fn expand_struct_operators(strct: &Struct) -> TokenStream {\n                 operators.extend(quote_spanned! {span=>\n                     #[doc(hidden)]\n                     #[export_name = #link_name]\n-                    extern \"C\" fn #local_name(lhs: &#ident, rhs: &#ident) -> bool {\n+                    extern \"C\" fn #local_name #generics(lhs: &#ident #generics, rhs: &#ident #generics) -> bool {\n                         let __fn = concat!(\"<\", module_path!(), #prevent_unwind_label);\n                         ::cxx::private::prevent_unwind(__fn, || *lhs < *rhs)\n                     }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -237,7 +238,7 @@ fn expand_struct_operators(strct: &Struct) -> TokenStream {\n                 operators.extend(quote_spanned! {span=>\n                     #[doc(hidden)]\n                     #[export_name = #link_name]\n-                    extern \"C\" fn #local_name(lhs: &#ident, rhs: &#ident) -> bool {\n+                    extern \"C\" fn #local_name #generics(lhs: &#ident #generics, rhs: &#ident #generics) -> bool {\n                         let __fn = concat!(\"<\", module_path!(), #prevent_unwind_label);\n                         ::cxx::private::prevent_unwind(__fn, || *lhs <= *rhs)\n                     }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -250,7 +251,7 @@ fn expand_struct_operators(strct: &Struct) -> TokenStream {\n                     operators.extend(quote_spanned! {span=>\n                         #[doc(hidden)]\n                         #[export_name = #link_name]\n-                        extern \"C\" fn #local_name(lhs: &#ident, rhs: &#ident) -> bool {\n+                        extern \"C\" fn #local_name #generics(lhs: &#ident #generics, rhs: &#ident #generics) -> bool {\n                             let __fn = concat!(\"<\", module_path!(), #prevent_unwind_label);\n                             ::cxx::private::prevent_unwind(__fn, || *lhs > *rhs)\n                         }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -262,7 +263,7 @@ fn expand_struct_operators(strct: &Struct) -> TokenStream {\n                     operators.extend(quote_spanned! {span=>\n                         #[doc(hidden)]\n                         #[export_name = #link_name]\n-                        extern \"C\" fn #local_name(lhs: &#ident, rhs: &#ident) -> bool {\n+                        extern \"C\" fn #local_name #generics(lhs: &#ident #generics, rhs: &#ident #generics) -> bool {\n                             let __fn = concat!(\"<\", module_path!(), #prevent_unwind_label);\n                             ::cxx::private::prevent_unwind(__fn, || *lhs >= *rhs)\n                         }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -277,7 +278,7 @@ fn expand_struct_operators(strct: &Struct) -> TokenStream {\n                     #[doc(hidden)]\n                     #[export_name = #link_name]\n                     #[allow(clippy::cast_possible_truncation)]\n-                    extern \"C\" fn #local_name(this: &#ident) -> usize {\n+                    extern \"C\" fn #local_name #generics(this: &#ident #generics) -> usize {\n                         let __fn = concat!(\"<\", module_path!(), #prevent_unwind_label);\n                         ::cxx::private::prevent_unwind(__fn, || ::cxx::private::hash(this))\n                     }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -396,10 +397,13 @@ fn expand_cxx_type(ety: &ExternType) -> TokenStream {\n     }\n }\n \n-fn expand_cxx_type_assert_pinned(ety: &ExternType) -> TokenStream {\n+fn expand_cxx_type_assert_pinned(ety: &ExternType, types: &Types) -> TokenStream {\n     let ident = &ety.name.rust;\n     let infer = Token![_](ident.span());\n \n+    let resolve = types.resolve(ident);\n+    let lifetimes = resolve.generics.to_underscore_lifetimes();\n+\n     quote! {\n         let _: fn() = {\n             // Derived from https://github.com/nvzqz/static-assertions-rs.\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -424,7 +428,7 @@ fn expand_cxx_type_assert_pinned(ety: &ExternType) -> TokenStream {\n             // `_` can be resolved and this can compile. Fails to compile if\n             // user has added a manual Unpin impl for their opaque C++ type as\n             // then `__AmbiguousIfImpl<__Invalid>` also exists.\n-            <#ident as __AmbiguousIfImpl<#infer>>::infer\n+            <#ident #lifetimes as __AmbiguousIfImpl<#infer>>::infer\n         };\n     }\n }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -833,21 +837,25 @@ fn expand_rust_type_impl(ety: &ExternType) -> TokenStream {\n     impls\n }\n \n-fn expand_rust_type_assert_unpin(ety: &ExternType) -> TokenStream {\n+fn expand_rust_type_assert_unpin(ety: &ExternType, types: &Types) -> TokenStream {\n     let ident = &ety.name.rust;\n     let begin_span = Token![::](ety.type_token.span);\n     let unpin = quote_spanned! {ety.semi_token.span=>\n         #begin_span cxx::core::marker::Unpin\n     };\n+\n+    let resolve = types.resolve(ident);\n+    let lifetimes = resolve.generics.to_underscore_lifetimes();\n+\n     quote_spanned! {ident.span()=>\n         let _ = {\n             fn __AssertUnpin<T: ?::cxx::core::marker::Sized + #unpin>() {}\n-            __AssertUnpin::<#ident>\n+            __AssertUnpin::<#ident #lifetimes>\n         };\n     }\n }\n \n-fn expand_rust_type_layout(ety: &ExternType) -> TokenStream {\n+fn expand_rust_type_layout(ety: &ExternType, types: &Types) -> TokenStream {\n     // Rustc will render as follows if not sized:\n     //\n     //     type TheirType;\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -868,6 +876,9 @@ fn expand_rust_type_layout(ety: &ExternType) -> TokenStream {\n     let local_sizeof = format_ident!(\"__sizeof_{}\", ety.name.rust);\n     let local_alignof = format_ident!(\"__alignof_{}\", ety.name.rust);\n \n+    let resolve = types.resolve(ident);\n+    let lifetimes = resolve.generics.to_underscore_lifetimes();\n+\n     quote_spanned! {ident.span()=>\n         {\n             #[doc(hidden)]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -877,12 +888,12 @@ fn expand_rust_type_layout(ety: &ExternType) -> TokenStream {\n             #[doc(hidden)]\n             #[export_name = #link_sizeof]\n             extern \"C\" fn #local_sizeof() -> usize {\n-                __AssertSized::<#ident>().size()\n+                __AssertSized::<#ident #lifetimes>().size()\n             }\n             #[doc(hidden)]\n             #[export_name = #link_alignof]\n             extern \"C\" fn #local_alignof() -> usize {\n-                __AssertSized::<#ident>().align()\n+                __AssertSized::<#ident #lifetimes>().align()\n             }\n         }\n     }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1393,7 +1404,7 @@ fn expand_unique_ptr(\n     quote_spanned! {end_span=>\n         #unsafe_token impl #impl_generics ::cxx::private::UniquePtrTarget for #ident #ty_generics {\n             #[doc(hidden)]\n-            fn __typename(f: &mut ::cxx::core::fmt::Formatter) -> ::cxx::core::fmt::Result {\n+            fn __typename(f: &mut ::cxx::core::fmt::Formatter<'_>) -> ::cxx::core::fmt::Result {\n                 f.write_str(#name)\n             }\n             #[doc(hidden)]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1485,7 +1496,7 @@ fn expand_shared_ptr(\n     quote_spanned! {end_span=>\n         #unsafe_token impl #impl_generics ::cxx::private::SharedPtrTarget for #ident #ty_generics {\n             #[doc(hidden)]\n-            fn __typename(f: &mut ::cxx::core::fmt::Formatter) -> ::cxx::core::fmt::Result {\n+            fn __typename(f: &mut ::cxx::core::fmt::Formatter<'_>) -> ::cxx::core::fmt::Result {\n                 f.write_str(#name)\n             }\n             #[doc(hidden)]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1545,7 +1556,7 @@ fn expand_weak_ptr(key: NamedImplKey, types: &Types, explicit_impl: Option<&Impl\n     quote_spanned! {end_span=>\n         #unsafe_token impl #impl_generics ::cxx::private::WeakPtrTarget for #ident #ty_generics {\n             #[doc(hidden)]\n-            fn __typename(f: &mut ::cxx::core::fmt::Formatter) -> ::cxx::core::fmt::Result {\n+            fn __typename(f: &mut ::cxx::core::fmt::Formatter<'_>) -> ::cxx::core::fmt::Result {\n                 f.write_str(#name)\n             }\n             #[doc(hidden)]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1660,7 +1671,7 @@ fn expand_cxx_vector(\n     quote_spanned! {end_span=>\n         #unsafe_token impl #impl_generics ::cxx::private::VectorElement for #elem #ty_generics {\n             #[doc(hidden)]\n-            fn __typename(f: &mut ::cxx::core::fmt::Formatter) -> ::cxx::core::fmt::Result {\n+            fn __typename(f: &mut ::cxx::core::fmt::Formatter<'_>) -> ::cxx::core::fmt::Result {\n                 f.write_str(#name)\n             }\n             #[doc(hidden)]\ndiff --git a/macro/src/generics.rs b/macro/src/generics.rs\n--- a/macro/src/generics.rs\n+++ b/macro/src/generics.rs\n@@ -1,9 +1,9 @@\n use crate::syntax::instantiate::NamedImplKey;\n use crate::syntax::resolve::Resolution;\n-use crate::syntax::Impl;\n+use crate::syntax::{Impl, Lifetimes};\n use proc_macro2::TokenStream;\n use quote::ToTokens;\n-use syn::Token;\n+use syn::{Lifetime, Token};\n \n pub struct ImplGenerics<'a> {\n     explicit_impl: Option<&'a Impl>,\ndiff --git a/macro/src/generics.rs b/macro/src/generics.rs\n--- a/macro/src/generics.rs\n+++ b/macro/src/generics.rs\n@@ -61,3 +61,31 @@ impl<'a> ToTokens for TyGenerics<'a> {\n         }\n     }\n }\n+\n+pub struct UnderscoreLifetimes<'a> {\n+    generics: &'a Lifetimes,\n+}\n+\n+impl Lifetimes {\n+    pub fn to_underscore_lifetimes(&self) -> UnderscoreLifetimes {\n+        UnderscoreLifetimes { generics: self }\n+    }\n+}\n+\n+impl<'a> ToTokens for UnderscoreLifetimes<'a> {\n+    fn to_tokens(&self, tokens: &mut TokenStream) {\n+        let Lifetimes {\n+            lt_token,\n+            lifetimes,\n+            gt_token,\n+        } = self.generics;\n+        lt_token.to_tokens(tokens);\n+        for pair in lifetimes.pairs() {\n+            let (lifetime, punct) = pair.into_tuple();\n+            let lifetime = Lifetime::new(\"'_\", lifetime.span());\n+            lifetime.to_tokens(tokens);\n+            punct.to_tokens(tokens);\n+        }\n+        gt_token.to_tokens(tokens);\n+    }\n+}\n",
        "test_patch": "diff --git /dev/null b/tests/ui/deny_elided_lifetimes.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/deny_elided_lifetimes.rs\n@@ -0,0 +1,27 @@\n+#![deny(elided_lifetimes_in_paths)]\n+\n+#[cxx::bridge]\n+mod ffi {\n+    #[derive(PartialEq, PartialOrd, Hash)]\n+    struct Struct<'a> {\n+        reference: &'a i32,\n+    }\n+\n+    extern \"Rust\" {\n+        type Rust<'a>;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        type Cpp<'a>;\n+\n+        fn lifetime_named<'a>(s: &'a i32) -> UniquePtr<Cpp<'a>>;\n+\n+        fn lifetime_underscore(s: &i32) -> UniquePtr<Cpp<'_>>;\n+\n+        fn lifetime_elided(s: &i32) -> UniquePtr<Cpp>;\n+    }\n+}\n+\n+pub struct Rust<'a>(&'a i32);\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/deny_elided_lifetimes.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/deny_elided_lifetimes.stderr\n@@ -0,0 +1,15 @@\n+error: hidden lifetime parameters in types are deprecated\n+  --> tests/ui/deny_elided_lifetimes.rs:21:50\n+   |\n+21 |         fn lifetime_elided(s: &i32) -> UniquePtr<Cpp>;\n+   |                                                  ^^^ expected named lifetime parameter\n+   |\n+note: the lint level is defined here\n+  --> tests/ui/deny_elided_lifetimes.rs:1:9\n+   |\n+1  | #![deny(elided_lifetimes_in_paths)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider using the `'_` lifetime\n+   |\n+21 |         fn lifetime_elided(s: &i32) -> UniquePtr<Cpp<'_>>;\n+   |                                                  ~~~~~~~\n",
        "problem_statement": "Confusing elided-lifetimes-in-paths lint in bridge\nBuilding the demo with `-W elided-lifetimes-in-paths` results in the following:\r\n\r\n```\r\nwarning: hidden lifetime parameters in types are deprecated\r\n  --> demo/src/main.rs:22:63\r\n   |\r\n22 |         fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;\r\n   |                                                               ^- help: indicate the anonymous lifetime: `<'_>`\r\n   |\r\n   = note: requested on the command line with `-W elided-lifetimes-in-paths`\r\n\r\nwarning: 1 warning emitted\r\n```\r\n\r\nHowever, neither `cxx::UniquePtr` nor `BlobstoreClient` have a lifetime parameter, so of course trying to add one is an error (and of course the lint still triggers too):\r\n\r\n```\r\nwarning: hidden lifetime parameters in types are deprecated\r\n  --> demo/src/main.rs:22:66\r\n   |\r\n22 |         fn new_blobstore_client() -> UniquePtr<BlobstoreClient<'_>>;\r\n   |                                                                  ^^- help: indicate the anonymous lifetime: `<'_>`\r\n   |\r\n   = note: requested on the command line with `-W elided-lifetimes-in-paths`\r\n\r\nerror[E0106]: missing lifetime specifier\r\n  --> demo/src/main.rs:22:64\r\n   |\r\n22 |         fn new_blobstore_client() -> UniquePtr<BlobstoreClient<'_>>;\r\n   |                                                                ^^ expected named lifetime parameter\r\n   |\r\n   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\r\nhelp: consider using the `'static` lifetime\r\n   |\r\n22 |         fn new_blobstore_client() -> UniquePtr<BlobstoreClient<'static>>;\r\n   |                                                                ^^^^^^^\r\n\r\nerror[E0107]: this struct takes 0 lifetime arguments but 1 lifetime argument was supplied\r\n  --> demo/src/main.rs:22:48\r\n   |\r\n22 |         fn new_blobstore_client() -> UniquePtr<BlobstoreClient<'_>>;\r\n   |                                                ^^^^^^^^^^^^^^^---- help: remove these generics\r\n   |                                                |\r\n   |                                                expected 0 lifetime arguments\r\n   |\r\nnote: struct defined here, with 0 lifetime parameters\r\n  --> demo/src/main.rs:20:14\r\n   |\r\n20 |         type BlobstoreClient;\r\n   |              ^^^^^^^^^^^^^^^\r\n\r\nerror: aborting due to 2 previous errors; 1 warning emitted\r\n```\r\n\r\n\r\nLooking at the expanded output with `cargo expand`, I don't see any clues as to what missing anonymous lifetime the compiler might be intending to flag here. It's unclear to me if this is a lint bug, if the compiler diagnostic is just confusing due to the `cxx::bridge` proc macro, or something else.\r\n\r\nThis is an issue for us because our codebase uses both `-W rust_2018_idioms` and `-D warnings` by default. Worse, `elided-lifetimes-in-paths` can only be allowed at the crate level (https://github.com/rust-lang/rust/issues/71957) so we can't just allow it for the `cxx::bridge` module.\n",
        "hints_text": "Ahhhh, I see what it's trying to indicate now. It's complaining about the generated `UniquePtrTarget for BlobstoreClient` impl, which includes a `std::fmt::Formatter` type that is missing the anonymous lifetime. Ok, that should be easily fixable.\nI'm running into the same issue and wondering if there is any workaround for this?\r\n\r\n@sbrocket\r\nHow did you go about fixing it?",
        "created_at": "2021-12-10T21:27:18Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 951,
        "instance_id": "dtolnay__cxx-951",
        "issue_numbers": [
            "950"
        ],
        "base_commit": "6c0f458c52b52c76c2b8234443edf939d8eeaf3b",
        "patch": "diff --git a/book/src/binding/vec.md b/book/src/binding/vec.md\n--- a/book/src/binding/vec.md\n+++ b/book/src/binding/vec.md\n@@ -45,6 +45,7 @@ public:\n   void reserve(size_t new_cap);\n   void push_back(const T &value);\n   void push_back(T &&value);\n+  void clear();\n   template <typename... Args>\n   void emplace_back(Args &&...args);\n \ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1475,6 +1475,11 @@ fn write_rust_vec_extern(out: &mut OutFile, key: NamedImplKey) {\n         \"void cxxbridge1$rust_vec${}$set_len(::rust::Vec<{}> *ptr, ::std::size_t len) noexcept;\",\n         instance, inner,\n     );\n+    writeln!(\n+        out,\n+        \"void cxxbridge1$rust_vec${}$clear(::rust::Vec<{}> *ptr) noexcept;\",\n+        instance, inner,\n+    );\n }\n \n fn write_rust_box_impl(out: &mut OutFile, key: NamedImplKey) {\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1585,6 +1590,19 @@ fn write_rust_vec_impl(out: &mut OutFile, key: NamedImplKey) {\n         instance,\n     );\n     writeln!(out, \"}}\");\n+    writeln!(out, \"template <>\");\n+    begin_function_definition(out);\n+    writeln!(\n+        out,\n+        \"void Vec<{}>::clear() noexcept {{\",\n+        inner,\n+    );\n+    writeln!(\n+        out,\n+        \"  return cxxbridge1$rust_vec${}$clear(this);\",\n+        instance,\n+    );\n+    writeln!(out, \"}}\");\n }\n \n fn write_unique_ptr(out: &mut OutFile, key: NamedImplKey) {\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -318,6 +318,7 @@ class Vec final {\n   T &at(std::size_t n);\n   T &front() noexcept;\n   T &back() noexcept;\n+  void clear() noexcept;\n \n   void reserve(std::size_t new_cap);\n   void push_back(const T &value);\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1255,6 +1255,7 @@ fn expand_rust_vec(key: NamedImplKey, types: &Types, explicit_impl: Option<&Impl\n     let link_data = format!(\"{}data\", link_prefix);\n     let link_reserve_total = format!(\"{}reserve_total\", link_prefix);\n     let link_set_len = format!(\"{}set_len\", link_prefix);\n+    let link_clear = format!(\"{}clear\", link_prefix);\n \n     let local_prefix = format_ident!(\"{}__vec_\", elem);\n     let local_new = format_ident!(\"{}new\", local_prefix);\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1264,6 +1265,7 @@ fn expand_rust_vec(key: NamedImplKey, types: &Types, explicit_impl: Option<&Impl\n     let local_data = format_ident!(\"{}data\", local_prefix);\n     let local_reserve_total = format_ident!(\"{}reserve_total\", local_prefix);\n     let local_set_len = format_ident!(\"{}set_len\", local_prefix);\n+    let local_clear = format_ident!(\"{}clear\", local_prefix);\n \n     let (impl_generics, ty_generics) = generics::split_for_impl(key, explicit_impl, resolve);\n \ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1309,6 +1311,11 @@ fn expand_rust_vec(key: NamedImplKey, types: &Types, explicit_impl: Option<&Impl\n         unsafe extern \"C\" fn #local_set_len #impl_generics(this: *mut ::cxx::private::RustVec<#elem #ty_generics>, len: usize) {\n             (*this).set_len(len);\n         }\n+        #[doc(hidden)]\n+        #[export_name = #link_clear]\n+        unsafe extern \"C\" fn #local_clear #impl_generics(this: *mut ::cxx::private::RustVec<#elem #ty_generics>) {\n+            (*this).clear();\n+        }\n     }\n }\n \ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -567,6 +567,8 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n       const rust::Vec<CXX_TYPE> *ptr) noexcept;                                \\\n   void cxxbridge1$rust_vec$##RUST_TYPE##$reserve_total(                        \\\n       rust::Vec<CXX_TYPE> *ptr, std::size_t new_cap) noexcept;                 \\\n+  void cxxbridge1$rust_vec$##RUST_TYPE##$clear(                                \\\n+      rust::Vec<CXX_TYPE> *ptr) noexcept;                                      \\\n   void cxxbridge1$rust_vec$##RUST_TYPE##$set_len(rust::Vec<CXX_TYPE> *ptr,     \\\n                                                  std::size_t len) noexcept;\n \ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -598,7 +600,11 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n   template <>                                                                  \\\n   void Vec<CXX_TYPE>::set_len(std::size_t len) noexcept {                      \\\n     cxxbridge1$rust_vec$##RUST_TYPE##$set_len(this, len);                      \\\n-  }\n+  }                                                                            \\\n+  template <>                                                                  \\\n+  void Vec<CXX_TYPE>::clear() noexcept {                                       \\\n+    cxxbridge1$rust_vec$##RUST_TYPE##$clear(this);                             \\\n+  }   \n \n #define SHARED_PTR_OPS(RUST_TYPE, CXX_TYPE)                                    \\\n   static_assert(sizeof(std::shared_ptr<CXX_TYPE>) == 2 * sizeof(void *), \"\");  \\\ndiff --git a/src/rust_vec.rs b/src/rust_vec.rs\n--- a/src/rust_vec.rs\n+++ b/src/rust_vec.rs\n@@ -67,6 +67,10 @@ impl<T> RustVec<T> {\n     pub unsafe fn set_len(&mut self, len: usize) {\n         unsafe { self.as_mut_vec().set_len(len) }\n     }\n+\n+    pub fn clear(&mut self) {\n+        self.as_mut_vec().clear()\n+    }\n }\n \n impl RustVec<RustString> {\ndiff --git a/src/symbols/rust_vec.rs b/src/symbols/rust_vec.rs\n--- a/src/symbols/rust_vec.rs\n+++ b/src/symbols/rust_vec.rs\n@@ -54,6 +54,12 @@ macro_rules! rust_vec_shims {\n                     unsafe { (*this).set_len(len) }\n                 }\n             }\n+            attr! {\n+                #[export_name = concat!(\"cxxbridge1$rust_vec$\", $segment, \"$clear\")]\n+                unsafe extern \"C\" fn __clear(this: *mut RustVec<$ty>) {\n+                    unsafe { (*this).clear() }\n+                }\n+            }\n         };\n     };\n }\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -149,6 +149,7 @@ pub mod ffi {\n         fn c_take_rust_vec_index(v: Vec<u8>);\n         fn c_take_rust_vec_shared_index(v: Vec<Shared>);\n         fn c_take_rust_vec_shared_push(v: Vec<Shared>);\n+        fn c_take_rust_vec_shared_clear(v: Vec<Shared>);\n         fn c_take_rust_vec_shared_forward_iterator(v: Vec<Shared>);\n         fn c_take_rust_vec_shared_sort(v: Vec<Shared>);\n         fn c_take_ref_rust_vec(v: &Vec<u8>);\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -452,6 +452,13 @@ void c_take_rust_vec_shared_push(rust::Vec<Shared> v) {\n   }\n }\n \n+void c_take_rust_vec_shared_clear(rust::Vec<Shared> v) {\n+  v.clear();\n+  if (v.size() == 0) {\n+    cxx_test_suite_set_correct();\n+  }\n+}\n+\n void c_take_ref_rust_vec(const rust::Vec<uint8_t> &v) {\n   uint8_t sum = std::accumulate(v.begin(), v.end(), 0);\n   if (sum == 200) {\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -152,6 +152,7 @@ void c_take_rust_vec_nested_ns_shared(rust::Vec<::A::B::ABShared> v);\n void c_take_rust_vec_string(rust::Vec<rust::String> v);\n void c_take_rust_vec_shared_index(rust::Vec<Shared> v);\n void c_take_rust_vec_shared_push(rust::Vec<Shared> v);\n+void c_take_rust_vec_shared_clear(rust::Vec<Shared> v);\n void c_take_rust_vec_shared_forward_iterator(rust::Vec<Shared> v);\n void c_take_rust_vec_shared_sort(rust::Vec<Shared> v);\n void c_take_ref_rust_vec(const rust::Vec<uint8_t> &v);\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -167,6 +167,7 @@ fn test_c_take() {\n     check!(ffi::c_take_rust_vec_shared(shared_test_vec.clone()));\n     check!(ffi::c_take_rust_vec_shared_index(shared_test_vec.clone()));\n     check!(ffi::c_take_rust_vec_shared_push(shared_test_vec.clone()));\n+    check!(ffi::c_take_rust_vec_shared_clear(shared_test_vec.clone()));\n     check!(ffi::c_take_rust_vec_shared_forward_iterator(\n         shared_test_vec,\n     ));\n",
        "problem_statement": "How do you clear a Vec<T> from C++?\nI have a shared struct that contains a Rust Vec.\r\n\r\n``` Rust\r\nstruct Foo {\r\n    values: Vec<f32>\r\n}\r\n```\r\n\r\nThis becomes a `rust::cxxbridge::Vec` on the C++ side.\r\nUnfortunately this class doesn't seem to have a `clear` method which means I cannot re-use the same vector.\r\n\r\nHow can I clear an existing `Vec` from C++?\r\n\n",
        "hints_text": "```rust\r\n#[cxx::bridge]\r\nmod ffi {\r\n    extern \"Rust\" {\r\n        fn clear_vec(v: &mut Vec<f32>);\r\n    }\r\n}\r\n\r\nfn clear_vec(v: &mut Vec<f32>) {\r\n    v.clear();\r\n}\r\n```\r\n\r\nThis is callable from C++ as `clear_vec(foo.values)`.\r\n\r\nSeparately, we could build a `clear` member function into rust::Vec if somebody sends a PR.",
        "created_at": "2021-10-20T15:37:57Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 859,
        "instance_id": "dtolnay__cxx-859",
        "issue_numbers": [
            "857"
        ],
        "base_commit": "78c0c688b8a2ecfb786b32a7a798fd7d04b422a2",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1593,10 +1593,10 @@ fn expand_cxx_vector(\n                     #[link_name = #link_push_back]\n                     fn __push_back #impl_generics(\n                         this: ::std::pin::Pin<&mut ::cxx::CxxVector<#elem #ty_generics>>,\n-                        value: &mut ::std::mem::ManuallyDrop<#elem #ty_generics>,\n+                        value: *mut ::std::ffi::c_void,\n                     );\n                 }\n-                __push_back(this, value);\n+                __push_back(this, value as *mut ::std::mem::ManuallyDrop<Self> as *mut ::std::ffi::c_void);\n             }\n             #[doc(hidden)]\n             unsafe fn __pop_back(\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1607,10 +1607,10 @@ fn expand_cxx_vector(\n                     #[link_name = #link_pop_back]\n                     fn __pop_back #impl_generics(\n                         this: ::std::pin::Pin<&mut ::cxx::CxxVector<#elem #ty_generics>>,\n-                        out: &mut ::std::mem::MaybeUninit<#elem #ty_generics>,\n+                        out: *mut ::std::ffi::c_void,\n                     );\n                 }\n-                __pop_back(this, out);\n+                __pop_back(this, out as *mut ::std::mem::MaybeUninit<Self> as *mut ::std::ffi::c_void);\n             }\n         })\n     } else {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1635,9 +1635,12 @@ fn expand_cxx_vector(\n             unsafe fn __get_unchecked(v: *mut ::cxx::CxxVector<Self>, pos: usize) -> *mut Self {\n                 extern \"C\" {\n                     #[link_name = #link_get_unchecked]\n-                    fn __get_unchecked #impl_generics(_: *mut ::cxx::CxxVector<#elem #ty_generics>, _: usize) -> *mut #elem #ty_generics;\n+                    fn __get_unchecked #impl_generics(\n+                        v: *mut ::cxx::CxxVector<#elem #ty_generics>,\n+                        pos: usize,\n+                    ) -> *mut ::std::ffi::c_void;\n                 }\n-                __get_unchecked(v, pos)\n+                __get_unchecked(v, pos) as *mut Self\n             }\n             #by_value_methods\n             #[doc(hidden)]\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -23,7 +23,13 @@ use core::slice;\n /// pointer, as in `&CxxVector<T>` or `UniquePtr<CxxVector<T>>`.\n #[repr(C, packed)]\n pub struct CxxVector<T> {\n-    _private: [T; 0],\n+    // A thing, because repr(C) structs are not allowed to consist exclusively\n+    // of PhantomData fields.\n+    _void: [c_void; 0],\n+    // The conceptual vector elements to ensure that autotraits are propagated\n+    // correctly, e.g. CxxVector is UnwindSafe iff T is.\n+    _elements: PhantomData<[T]>,\n+    // Prevent unpin operation from Pin<&mut CxxVector<T>> to &mut CxxVector<T>.\n     _pinned: PhantomData<PhantomPinned>,\n }\n \n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -326,6 +326,7 @@ pub mod ffi {\n     }\n \n     impl Box<Shared> {}\n+    impl CxxVector<SharedString> {}\n }\n \n mod other {\ndiff --git a/tests/ui/vector_autotraits.stderr b/tests/ui/vector_autotraits.stderr\n--- a/tests/ui/vector_autotraits.stderr\n+++ b/tests/ui/vector_autotraits.stderr\n@@ -15,5 +15,6 @@ note: required because it appears within the type `NotThreadSafe`\n    |\n 7  |         type NotThreadSafe;\n    |              ^^^^^^^^^^^^^\n-   = note: required because it appears within the type `[NotThreadSafe; 0]`\n+   = note: required because it appears within the type `[NotThreadSafe]`\n+   = note: required because it appears within the type `PhantomData<[NotThreadSafe]>`\n    = note: required because it appears within the type `CxxVector<NotThreadSafe>`\n",
        "problem_statement": "Returning `&CxxVector<SharedString>` from C++ FFI gives \"not FFI-safe\" error\nSimilar to https://github.com/dtolnay/cxx/issues/249, but instead of using the SharedString directly, I get this error when the struct containing the string is returned via a CxxVector:\r\n\r\n```\r\n#[cxx::bridge]\r\npub mod ffi {\r\n  struct SharedString {\r\n    x: String,\r\n  }\r\n  unsafe extern \"C++\" {\r\n    type View;\r\n    fn get_strings(view: &View) -> &CxxVector<SharedString>;\r\n  }\r\n}\r\n```\n",
        "hints_text": "",
        "created_at": "2021-05-01T21:42:15Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 840,
        "instance_id": "dtolnay__cxx-840",
        "issue_numbers": [
            "838"
        ],
        "base_commit": "7775ad2dad273d4d1df65136a2d53d8b8e74a138",
        "patch": "diff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1833,6 +1833,7 @@ fn write_cxx_vector(out: &mut OutFile, key: NamedImplKey) {\n     );\n     writeln!(out, \"  return s.size();\");\n     writeln!(out, \"}}\");\n+\n     writeln!(\n         out,\n         \"{} *cxxbridge1$std$vector${}$get_unchecked(::std::vector<{}> *s, ::std::size_t pos) noexcept {{\",\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1840,6 +1841,7 @@ fn write_cxx_vector(out: &mut OutFile, key: NamedImplKey) {\n     );\n     writeln!(out, \"  return &(*s)[pos];\");\n     writeln!(out, \"}}\");\n+\n     if out.types.is_maybe_trivial(element) {\n         writeln!(\n             out,\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1849,6 +1851,15 @@ fn write_cxx_vector(out: &mut OutFile, key: NamedImplKey) {\n         writeln!(out, \"  v->push_back(::std::move(*value));\");\n         writeln!(out, \"  ::rust::destroy(value);\");\n         writeln!(out, \"}}\");\n+\n+        writeln!(\n+            out,\n+            \"void cxxbridge1$std$vector${}$pop_back(::std::vector<{}> *v, {} *out) noexcept {{\",\n+            instance, inner, inner,\n+        );\n+        writeln!(out, \"  ::new (out) {}(::std::move(v->back()));\", inner);\n+        writeln!(out, \"  v->pop_back();\");\n+        writeln!(out, \"}}\");\n     }\n \n     out.include.memory = true;\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1538,6 +1538,7 @@ fn expand_cxx_vector(\n     let link_size = format!(\"{}size\", prefix);\n     let link_get_unchecked = format!(\"{}get_unchecked\", prefix);\n     let link_push_back = format!(\"{}push_back\", prefix);\n+    let link_pop_back = format!(\"{}pop_back\", prefix);\n     let unique_ptr_prefix = format!(\n         \"cxxbridge1$unique_ptr$std$vector${}$\",\n         resolve.name.to_symbol(),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1555,7 +1556,7 @@ fn expand_cxx_vector(\n     let unsafe_token = format_ident!(\"unsafe\", span = begin_span);\n \n     let can_pass_element_by_value = types.is_maybe_trivial(elem);\n-    let push_back_method = if can_pass_element_by_value {\n+    let by_value_methods = if can_pass_element_by_value {\n         Some(quote_spanned! {end_span=>\n             #[doc(hidden)]\n             unsafe fn __push_back(\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1571,6 +1572,20 @@ fn expand_cxx_vector(\n                 }\n                 __push_back(this, value);\n             }\n+            #[doc(hidden)]\n+            unsafe fn __pop_back(\n+                this: ::std::pin::Pin<&mut ::cxx::CxxVector<Self>>,\n+                out: &mut ::std::mem::MaybeUninit<Self>,\n+            ) {\n+                extern \"C\" {\n+                    #[link_name = #link_pop_back]\n+                    fn __pop_back #impl_generics(\n+                        this: ::std::pin::Pin<&mut ::cxx::CxxVector<#elem #ty_generics>>,\n+                        out: &mut ::std::mem::MaybeUninit<#elem #ty_generics>,\n+                    );\n+                }\n+                __pop_back(this, out);\n+            }\n         })\n     } else {\n         None\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1598,7 +1613,7 @@ fn expand_cxx_vector(\n                 }\n                 __get_unchecked(v, pos)\n             }\n-            #push_back_method\n+            #by_value_methods\n             #[doc(hidden)]\n             fn __unique_ptr_null() -> *mut ::std::ffi::c_void {\n                 extern \"C\" {\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -503,6 +503,11 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n       std::vector<CXX_TYPE> *v, CXX_TYPE *value) noexcept {                    \\\n     v->push_back(std::move(*value));                                           \\\n     destroy(value);                                                            \\\n+  }                                                                            \\\n+  void cxxbridge1$std$vector$##RUST_TYPE##$pop_back(std::vector<CXX_TYPE> *v,  \\\n+                                                    CXX_TYPE *out) noexcept {  \\\n+    new (out) CXX_TYPE(std::move(v->back()));                                  \\\n+    v->pop_back();                                                             \\\n   }\n \n #define RUST_VEC_EXTERNS(RUST_TYPE, CXX_TYPE)                                  \\\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -8,7 +8,7 @@ use core::ffi::c_void;\n use core::fmt::{self, Debug};\n use core::iter::FusedIterator;\n use core::marker::{PhantomData, PhantomPinned};\n-use core::mem::{self, ManuallyDrop};\n+use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::pin::Pin;\n use core::ptr;\n use core::slice;\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -162,6 +162,21 @@ where\n             T::__push_back(self, &mut value);\n         }\n     }\n+\n+    pub fn pop(self: Pin<&mut Self>) -> Option<T>\n+    where\n+        T: ExternType<Kind = Trivial>,\n+    {\n+        if self.is_empty() {\n+            None\n+        } else {\n+            let mut value = MaybeUninit::uninit();\n+            Some(unsafe {\n+                T::__pop_back(self, &mut value);\n+                value.assume_init()\n+            })\n+        }\n+    }\n }\n \n /// Iterator over elements of a `CxxVector` by shared reference.\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -320,6 +335,14 @@ pub unsafe trait VectorElement: Sized {\n         unreachable!()\n     }\n     #[doc(hidden)]\n+    unsafe fn __pop_back(v: Pin<&mut CxxVector<Self>>, out: &mut MaybeUninit<Self>) {\n+        // Opaque C type vector elements do not get this method because they can\n+        // never exist by value on the Rust side of the bridge.\n+        let _ = v;\n+        let _ = out;\n+        unreachable!()\n+    }\n+    #[doc(hidden)]\n     fn __unique_ptr_null() -> *mut c_void;\n     #[doc(hidden)]\n     unsafe fn __unique_ptr_raw(raw: *mut CxxVector<Self>) -> *mut c_void;\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -331,7 +354,7 @@ pub unsafe trait VectorElement: Sized {\n     unsafe fn __unique_ptr_drop(repr: *mut c_void);\n }\n \n-macro_rules! vector_element_push_back {\n+macro_rules! vector_element_by_value_methods {\n     (opaque, $segment:expr, $ty:ty) => {};\n     (trivial, $segment:expr, $ty:ty) => {\n         #[doc(hidden)]\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -344,6 +367,16 @@ macro_rules! vector_element_push_back {\n             }\n             __push_back(v, value);\n         }\n+        #[doc(hidden)]\n+        unsafe fn __pop_back(v: Pin<&mut CxxVector<$ty>>, out: &mut MaybeUninit<$ty>) {\n+            extern \"C\" {\n+                attr! {\n+                    #[link_name = concat!(\"cxxbridge1$std$vector$\", $segment, \"$pop_back\")]\n+                    fn __pop_back(_: Pin<&mut CxxVector<$ty>>, _: &mut MaybeUninit<$ty>);\n+                }\n+            }\n+            __pop_back(v, out);\n+        }\n     };\n }\n \ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -376,7 +409,7 @@ macro_rules! impl_vector_element {\n                 }\n                 __get_unchecked(v, pos)\n             }\n-            vector_element_push_back!($kind, $segment, $ty);\n+            vector_element_by_value_methods!($kind, $segment, $ty);\n             #[doc(hidden)]\n             fn __unique_ptr_null() -> *mut c_void {\n                 extern \"C\" {\n",
        "test_patch": "diff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -336,7 +336,7 @@ void c_take_unique_ptr_string(std::unique_ptr<std::string> s) {\n }\n \n void c_take_unique_ptr_vector_u8(std::unique_ptr<std::vector<uint8_t>> v) {\n-  if (v->size() == 4) {\n+  if (v->size() == 3) {\n     cxx_test_suite_set_correct();\n   }\n }\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -150,9 +150,9 @@ fn test_c_take() {\n     check!(ffi::c_take_unique_ptr_string(\n         ffi::c_return_unique_ptr_string()\n     ));\n-    check!(ffi::c_take_unique_ptr_vector_u8(\n-        ffi::c_return_unique_ptr_vector_u8()\n-    ));\n+    let mut vector = ffi::c_return_unique_ptr_vector_u8();\n+    assert_eq!(vector.pin_mut().pop(), Some(9));\n+    check!(ffi::c_take_unique_ptr_vector_u8(vector));\n     let mut vector = ffi::c_return_unique_ptr_vector_f64();\n     vector.pin_mut().push(9.0);\n     check!(ffi::c_take_unique_ptr_vector_f64(vector));\n",
        "problem_statement": "CxxVector::pop\nWe should expose functionality analogous to https://doc.rust-lang.org/std/vec/struct.Vec.html#method.pop on the Rust `CxxVector`.\r\n\r\nThis issues is split out from #778.\n",
        "hints_text": "",
        "created_at": "2021-04-16T22:51:26Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 839,
        "instance_id": "dtolnay__cxx-839",
        "issue_numbers": [
            "778"
        ],
        "base_commit": "c5f472ef62f6307521cb1fe8a76a204438a6eee0",
        "patch": "diff --git a/gen/src/builtin.rs b/gen/src/builtin.rs\n--- a/gen/src/builtin.rs\n+++ b/gen/src/builtin.rs\n@@ -30,6 +30,7 @@ pub struct Builtins<'a> {\n     pub relocatable: bool,\n     pub friend_impl: bool,\n     pub is_complete: bool,\n+    pub destroy: bool,\n     pub deleter_if: bool,\n     pub content: Content<'a>,\n }\ndiff --git a/gen/src/builtin.rs b/gen/src/builtin.rs\n--- a/gen/src/builtin.rs\n+++ b/gen/src/builtin.rs\n@@ -334,6 +335,14 @@ pub(super) fn write(out: &mut OutFile) {\n         writeln!(out, \"}};\");\n     }\n \n+    if builtin.destroy {\n+        out.next_section();\n+        writeln!(out, \"template <typename T>\");\n+        writeln!(out, \"void destroy(T *ptr) {{\");\n+        writeln!(out, \"  ptr->~T();\");\n+        writeln!(out, \"}}\");\n+    }\n+\n     if builtin.deleter_if {\n         out.next_section();\n         writeln!(out, \"template <bool> struct deleter_if {{\");\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1823,6 +1823,8 @@ fn write_cxx_vector(out: &mut OutFile, key: NamedImplKey) {\n     let instance = element.to_mangled(out.types);\n \n     out.include.cstddef = true;\n+    out.include.utility = true;\n+    out.builtin.destroy = true;\n \n     writeln!(\n         out,\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1838,6 +1840,16 @@ fn write_cxx_vector(out: &mut OutFile, key: NamedImplKey) {\n     );\n     writeln!(out, \"  return &(*s)[pos];\");\n     writeln!(out, \"}}\");\n+    if out.types.is_maybe_trivial(element) {\n+        writeln!(\n+            out,\n+            \"void cxxbridge1$std$vector${}$push_back(::std::vector<{}> *v, {} *value) noexcept {{\",\n+            instance, inner, inner,\n+        );\n+        writeln!(out, \"  v->push_back(::std::move(*value));\");\n+        writeln!(out, \"  ::rust::destroy(value);\");\n+        writeln!(out, \"}}\");\n+    }\n \n     out.include.memory = true;\n     write_unique_ptr_common(out, UniquePtr::CxxVector(element));\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1537,6 +1537,7 @@ fn expand_cxx_vector(\n     let prefix = format!(\"cxxbridge1$std$vector${}$\", resolve.name.to_symbol());\n     let link_size = format!(\"{}size\", prefix);\n     let link_get_unchecked = format!(\"{}get_unchecked\", prefix);\n+    let link_push_back = format!(\"{}push_back\", prefix);\n     let unique_ptr_prefix = format!(\n         \"cxxbridge1$unique_ptr$std$vector${}$\",\n         resolve.name.to_symbol(),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1553,6 +1554,28 @@ fn expand_cxx_vector(\n     let end_span = explicit_impl.map_or(key.end_span, |explicit| explicit.brace_token.span);\n     let unsafe_token = format_ident!(\"unsafe\", span = begin_span);\n \n+    let can_pass_element_by_value = types.is_maybe_trivial(elem);\n+    let push_back_method = if can_pass_element_by_value {\n+        Some(quote_spanned! {end_span=>\n+            #[doc(hidden)]\n+            unsafe fn __push_back(\n+                this: ::std::pin::Pin<&mut ::cxx::CxxVector<Self>>,\n+                value: &mut ::std::mem::ManuallyDrop<Self>,\n+            ) {\n+                extern \"C\" {\n+                    #[link_name = #link_push_back]\n+                    fn __push_back #impl_generics(\n+                        this: ::std::pin::Pin<&mut ::cxx::CxxVector<#elem #ty_generics>>,\n+                        value: &mut ::std::mem::ManuallyDrop<#elem #ty_generics>,\n+                    );\n+                }\n+                __push_back(this, value);\n+            }\n+        })\n+    } else {\n+        None\n+    };\n+\n     quote_spanned! {end_span=>\n         #unsafe_token impl #impl_generics ::cxx::private::VectorElement for #elem #ty_generics {\n             #[doc(hidden)]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1575,6 +1598,7 @@ fn expand_cxx_vector(\n                 }\n                 __get_unchecked(v, pos)\n             }\n+            #push_back_method\n             #[doc(hidden)]\n             fn __unique_ptr_null() -> *mut ::std::ffi::c_void {\n                 extern \"C\" {\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -427,6 +427,13 @@ using isize_if_unique =\n } // namespace cxxbridge1\n } // namespace rust\n \n+namespace {\n+template <typename T>\n+void destroy(T *ptr) {\n+  ptr->~T();\n+}\n+} // namespace\n+\n extern \"C\" {\n void cxxbridge1$unique_ptr$std$string$null(\n     std::unique_ptr<std::string> *ptr) noexcept {\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -491,6 +498,13 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n     ptr->~unique_ptr();                                                        \\\n   }\n \n+#define STD_VECTOR_TRIVIAL_OPS(RUST_TYPE, CXX_TYPE)                            \\\n+  void cxxbridge1$std$vector$##RUST_TYPE##$push_back(                          \\\n+      std::vector<CXX_TYPE> *v, CXX_TYPE *value) noexcept {                    \\\n+    v->push_back(std::move(*value));                                           \\\n+    destroy(value);                                                            \\\n+  }\n+\n #define RUST_VEC_EXTERNS(RUST_TYPE, CXX_TYPE)                                  \\\n   void cxxbridge1$rust_vec$##RUST_TYPE##$new(                                  \\\n       rust::Vec<CXX_TYPE> *ptr) noexcept;                                      \\\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -603,10 +617,13 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n   MACRO(f32, float)                                                            \\\n   MACRO(f64, double)\n \n-#define FOR_EACH_STD_VECTOR(MACRO)                                             \\\n+#define FOR_EACH_TRIVIAL_STD_VECTOR(MACRO)                                     \\\n   FOR_EACH_NUMERIC(MACRO)                                                      \\\n   MACRO(usize, std::size_t)                                                    \\\n-  MACRO(isize, rust::isize)                                                    \\\n+  MACRO(isize, rust::isize)\n+\n+#define FOR_EACH_STD_VECTOR(MACRO)                                             \\\n+  FOR_EACH_TRIVIAL_STD_VECTOR(MACRO)                                           \\\n   MACRO(string, std::string)\n \n #define FOR_EACH_RUST_VEC(MACRO)                                               \\\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -627,6 +644,7 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n \n extern \"C\" {\n FOR_EACH_STD_VECTOR(STD_VECTOR_OPS)\n+FOR_EACH_TRIVIAL_STD_VECTOR(STD_VECTOR_TRIVIAL_OPS)\n FOR_EACH_RUST_VEC(RUST_VEC_EXTERNS)\n FOR_EACH_SHARED_PTR(SHARED_PTR_OPS)\n } // extern \"C\"\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -8,7 +8,7 @@ use core::ffi::c_void;\n use core::fmt::{self, Debug};\n use core::iter::FusedIterator;\n use core::marker::{PhantomData, PhantomPinned};\n-use core::mem;\n+use core::mem::{self, ManuallyDrop};\n use core::pin::Pin;\n use core::ptr;\n use core::slice;\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -146,6 +146,22 @@ where\n     pub fn iter_mut(self: Pin<&mut Self>) -> IterMut<T> {\n         IterMut { v: self, index: 0 }\n     }\n+\n+    /// Appends an element to the back of the vector.\n+    ///\n+    /// Matches the behavior of C++ [std::vector\\<T\\>::push_back][push_back].\n+    ///\n+    /// [push_back]: https://en.cppreference.com/w/cpp/container/vector/push_back\n+    pub fn push(self: Pin<&mut Self>, value: T)\n+    where\n+        T: ExternType<Kind = Trivial>,\n+    {\n+        let mut value = ManuallyDrop::new(value);\n+        unsafe {\n+            // C++ calls move constructor followed by destructor on `value`.\n+            T::__push_back(self, &mut value);\n+        }\n+    }\n }\n \n /// Iterator over elements of a `CxxVector` by shared reference.\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -296,6 +312,14 @@ pub unsafe trait VectorElement: Sized {\n     #[doc(hidden)]\n     unsafe fn __get_unchecked(v: *mut CxxVector<Self>, pos: usize) -> *mut Self;\n     #[doc(hidden)]\n+    unsafe fn __push_back(v: Pin<&mut CxxVector<Self>>, value: &mut ManuallyDrop<Self>) {\n+        // Opaque C type vector elements do not get this method because they can\n+        // never exist by value on the Rust side of the bridge.\n+        let _ = v;\n+        let _ = value;\n+        unreachable!()\n+    }\n+    #[doc(hidden)]\n     fn __unique_ptr_null() -> *mut c_void;\n     #[doc(hidden)]\n     unsafe fn __unique_ptr_raw(raw: *mut CxxVector<Self>) -> *mut c_void;\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -307,8 +331,24 @@ pub unsafe trait VectorElement: Sized {\n     unsafe fn __unique_ptr_drop(repr: *mut c_void);\n }\n \n+macro_rules! vector_element_push_back {\n+    (opaque, $segment:expr, $ty:ty) => {};\n+    (trivial, $segment:expr, $ty:ty) => {\n+        #[doc(hidden)]\n+        unsafe fn __push_back(v: Pin<&mut CxxVector<$ty>>, value: &mut ManuallyDrop<$ty>) {\n+            extern \"C\" {\n+                attr! {\n+                    #[link_name = concat!(\"cxxbridge1$std$vector$\", $segment, \"$push_back\")]\n+                    fn __push_back(_: Pin<&mut CxxVector<$ty>>, _: &mut ManuallyDrop<$ty>);\n+                }\n+            }\n+            __push_back(v, value);\n+        }\n+    };\n+}\n+\n macro_rules! impl_vector_element {\n-    ($segment:expr, $name:expr, $ty:ty) => {\n+    ($kind:ident, $segment:expr, $name:expr, $ty:ty) => {\n         const_assert_eq!(1, mem::align_of::<CxxVector<$ty>>());\n \n         unsafe impl VectorElement for $ty {\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -336,6 +376,7 @@ macro_rules! impl_vector_element {\n                 }\n                 __get_unchecked(v, pos)\n             }\n+            vector_element_push_back!($kind, $segment, $ty);\n             #[doc(hidden)]\n             fn __unique_ptr_null() -> *mut c_void {\n                 extern \"C\" {\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -396,7 +437,7 @@ macro_rules! impl_vector_element {\n \n macro_rules! impl_vector_element_for_primitive {\n     ($ty:ident) => {\n-        impl_vector_element!(stringify!($ty), stringify!($ty), $ty);\n+        impl_vector_element!(trivial, stringify!($ty), stringify!($ty), $ty);\n     };\n }\n \ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -413,4 +454,4 @@ impl_vector_element_for_primitive!(isize);\n impl_vector_element_for_primitive!(f32);\n impl_vector_element_for_primitive!(f64);\n \n-impl_vector_element!(\"string\", \"CxxString\", CxxString);\n+impl_vector_element!(opaque, \"string\", \"CxxString\", CxxString);\n",
        "test_patch": "diff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -342,7 +342,7 @@ void c_take_unique_ptr_vector_u8(std::unique_ptr<std::vector<uint8_t>> v) {\n }\n \n void c_take_unique_ptr_vector_f64(std::unique_ptr<std::vector<double>> v) {\n-  if (v->size() == 4) {\n+  if (v->size() == 5) {\n     cxx_test_suite_set_correct();\n   }\n }\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -354,7 +354,7 @@ void c_take_unique_ptr_vector_string(\n }\n \n void c_take_unique_ptr_vector_shared(std::unique_ptr<std::vector<Shared>> v) {\n-  if (v->size() == 2) {\n+  if (v->size() == 3) {\n     cxx_test_suite_set_correct();\n   }\n }\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -153,12 +153,12 @@ fn test_c_take() {\n     check!(ffi::c_take_unique_ptr_vector_u8(\n         ffi::c_return_unique_ptr_vector_u8()\n     ));\n-    check!(ffi::c_take_unique_ptr_vector_f64(\n-        ffi::c_return_unique_ptr_vector_f64()\n-    ));\n-    check!(ffi::c_take_unique_ptr_vector_shared(\n-        ffi::c_return_unique_ptr_vector_shared()\n-    ));\n+    let mut vector = ffi::c_return_unique_ptr_vector_f64();\n+    vector.pin_mut().push(9.0);\n+    check!(ffi::c_take_unique_ptr_vector_f64(vector));\n+    let mut vector = ffi::c_return_unique_ptr_vector_shared();\n+    vector.pin_mut().push(ffi::Shared { z: 9 });\n+    check!(ffi::c_take_unique_ptr_vector_shared(vector));\n     check!(ffi::c_take_ref_vector(&ffi::c_return_unique_ptr_vector_u8()));\n     let test_vec = [86_u8, 75_u8, 30_u8, 9_u8].to_vec();\n     check!(ffi::c_take_rust_vec(test_vec.clone()));\n",
        "problem_statement": "CxxVector::push_back\nAdding push_back/pop functionality (and other mutation functionality) to `CxxVector` would be helpful for `CxxVector`s containing types that rust can obtain (e.g. `CxxVector<CxxString>` or `CxxVector<SharedPtr<T>>`). Similarly, `CxxVector::new()` or `CxxVector::default()` would be helpful to create them from Rust.\n",
        "hints_text": "Absolutely -- I would accept a PR adding `push_back` and `pop`. For a workaround in the meantime, it's fairly easy to expose your own push function to Rust implemented in C++:\r\n\r\n```rust\r\n// src/lib.rs\r\n\r\n#[cxx::bridge]\r\nmod ffi {\r\n    struct Struct { test: i32 }\r\n\r\n    unsafe extern \"C++\" {\r\n        include!(\"example/include/example.h\");\r\n\r\n        fn vector_struct_push_back(vec: Pin<&mut CxxVector<Struct>>, val: Struct);\r\n    }\r\n}\r\n```\r\n\r\n```cpp\r\n// include/example.h\r\n\r\n#pragma once\r\n#include <vector>\r\n\r\nstruct Struct;\r\n\r\nvoid vector_struct_push_back(std::vector<Struct> &vec, Struct val);\r\n```\r\n\r\n```cpp\r\n// src/example.cc\r\n\r\n#include \"example/src/lib.rs.h\"\r\n\r\nvoid vector_struct_push_back(std::vector<Struct> &vec, Struct val) {\r\n  vec.push_back(std::move(val));\r\n}\r\n```",
        "created_at": "2021-04-16T22:30:50Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 167,
        "instance_id": "dtolnay__cxx-167",
        "issue_numbers": [
            "144"
        ],
        "base_commit": "1f5670249047033796d6840255113e18b385d1e9",
        "patch": "diff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -20,15 +20,15 @@ matrix:\n       rust: nightly-x86_64-pc-windows-gnu\n       before_script:\n         # windows is bad at symlinks\n-        - rm cmd/src/gen cmd/src/syntax gen/include macro/src/syntax src/gen src/syntax\n-        - cp -r include gen; cp -r gen cmd/src; cp -r syntax cmd/src; cp -r syntax macro/src; cp -r gen src; cp -r syntax src\n+        - rm gen/build/src/gen gen/build/src/syntax gen/cmd/src/gen gen/cmd/src/syntax gen/src/include macro/src/syntax\n+        - cp -r include gen/src; cp -r gen/src gen/build/src/gen; cp -r gen/src gen/cmd/src/gen; cp -r syntax gen/build/src; cp -r syntax gen/cmd/src; cp -r syntax macro/src\n \n     - name: Windows (msvc)\n       os: windows\n       rust: nightly-x86_64-pc-windows-msvc\n       before_script:\n-        - rm cmd/src/gen cmd/src/syntax gen/include macro/src/syntax src/gen src/syntax\n-        - cp -r include gen; cp -r gen cmd/src; cp -r syntax cmd/src; cp -r syntax macro/src; cp -r gen src; cp -r syntax src\n+        - rm gen/build/src/gen gen/build/src/syntax gen/cmd/src/gen gen/cmd/src/syntax gen/src/include macro/src/syntax\n+        - cp -r include gen/src; cp -r gen/src gen/build/src/gen; cp -r gen/src gen/cmd/src/gen; cp -r syntax gen/build/src; cp -r syntax gen/cmd/src; cp -r syntax macro/src\n \n     - name: Buck\n       rust: nightly\ndiff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -62,3 +62,7 @@ matrix:\n       rust: 1.42.0\n       script:\n         - cargo run --manifest-path demo-rs/Cargo.toml\n+\n+  # https://github.com/dtolnay/cxx/pull/167\n+  allow_failures:\n+    - name: Buck\ndiff --git a/BUCK b/BUCK\n--- a/BUCK\n+++ b/BUCK\n@@ -5,19 +5,13 @@ rust_library(\n     deps = [\n         \":core\",\n         \":macro\",\n-        \"//third-party:anyhow\",\n-        \"//third-party:cc\",\n-        \"//third-party:codespan-reporting\",\n         \"//third-party:link-cplusplus\",\n-        \"//third-party:proc-macro2\",\n-        \"//third-party:quote\",\n-        \"//third-party:syn\",\n     ],\n )\n \n rust_binary(\n     name = \"codegen\",\n-    srcs = glob([\"cmd/src/**\"]),\n+    srcs = glob([\"gen/cmd/src/**\"]),\n     crate = \"cxxbridge\",\n     visibility = [\"PUBLIC\"],\n     deps = [\ndiff --git a/BUCK b/BUCK\n--- a/BUCK\n+++ b/BUCK\n@@ -52,3 +46,17 @@ rust_library(\n         \"//third-party:syn\",\n     ],\n )\n+\n+rust_library(\n+    name = \"build\",\n+    srcs = glob([\"gen/build/src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+    deps = [\n+        \"//third-party:anyhow\",\n+        \"//third-party:cc\",\n+        \"//third-party:codespan-reporting\",\n+        \"//third-party:proc-macro2\",\n+        \"//third-party:quote\",\n+        \"//third-party:syn\",\n+    ],\n+)\ndiff --git a/BUILD b/BUILD\n--- a/BUILD\n+++ b/BUILD\n@@ -3,25 +3,18 @@ load(\"//tools/bazel:rust.bzl\", \"rust_binary\", \"rust_library\")\n rust_library(\n     name = \"cxx\",\n     srcs = glob([\"src/**/*.rs\"]),\n-    data = [\"src/gen/include/cxx.h\"],\n     visibility = [\"//visibility:public\"],\n     deps = [\n         \":core-lib\",\n         \":cxxbridge-macro\",\n-        \"//third-party:anyhow\",\n-        \"//third-party:cc\",\n-        \"//third-party:codespan-reporting\",\n         \"//third-party:link-cplusplus\",\n-        \"//third-party:proc-macro2\",\n-        \"//third-party:quote\",\n-        \"//third-party:syn\",\n     ],\n )\n \n rust_binary(\n     name = \"codegen\",\n-    srcs = glob([\"cmd/src/**/*.rs\"]),\n-    data = [\"cmd/src/gen/include/cxx.h\"],\n+    srcs = glob([\"gen/cmd/src/**/*.rs\"]),\n+    data = [\"gen/cmd/src/gen/include/cxx.h\"],\n     visibility = [\"//visibility:public\"],\n     deps = [\n         \"//third-party:anyhow\",\ndiff --git a/BUILD b/BUILD\n--- a/BUILD\n+++ b/BUILD\n@@ -57,3 +50,18 @@ rust_library(\n         \"//third-party:syn\",\n     ],\n )\n+\n+rust_library(\n+    name = \"build\",\n+    srcs = glob([\"gen/build/src/**/*.rs\"]),\n+    data = [\"gen/build/src/gen/include/cxx.h\"],\n+    visibility = [\"//visibility:public\"],\n+    deps = [\n+        \"//third-party:anyhow\",\n+        \"//third-party:cc\",\n+        \"//third-party:codespan-reporting\",\n+        \"//third-party:proc-macro2\",\n+        \"//third-party:quote\",\n+        \"//third-party:syn\",\n+    ],\n+)\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -219,8 +219,7 @@ set up any additional source files and compiler flags as normal.\n // build.rs\n \n fn main() {\n-    cxx::Build::new()\n-        .bridge(\"src/main.rs\")  // returns a cc::Build\n+    cxx_build::bridge(\"src/main.rs\")  // returns a cc::Build\n         .file(\"../demo-cxx/demo.cc\")\n         .flag(\"-std=c++11\")\n         .compile(\"cxxbridge-demo\");\ndiff --git a/cmd/LICENSE-APACHE /dev/null\n--- a/cmd/LICENSE-APACHE\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-../LICENSE-APACHE\n\\ No newline at end of file\ndiff --git a/cmd/LICENSE-MIT /dev/null\n--- a/cmd/LICENSE-MIT\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-../LICENSE-MIT\n\\ No newline at end of file\ndiff --git a/cmd/src/gen /dev/null\n--- a/cmd/src/gen\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-../../gen\n\\ No newline at end of file\ndiff --git a/cmd/src/syntax /dev/null\n--- a/cmd/src/syntax\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-../../syntax\n\\ No newline at end of file\ndiff --git a/demo-rs/Cargo.toml b/demo-rs/Cargo.toml\n--- a/demo-rs/Cargo.toml\n+++ b/demo-rs/Cargo.toml\n@@ -9,4 +9,4 @@ publish = false\n cxx = { path = \"..\" }\n \n [build-dependencies]\n-cxx = { path = \"..\" }\n+cxx-build = { path = \"../gen/build\" }\ndiff --git a/demo-rs/build.rs b/demo-rs/build.rs\n--- a/demo-rs/build.rs\n+++ b/demo-rs/build.rs\n@@ -1,6 +1,5 @@\n fn main() {\n-    cxx::Build::new()\n-        .bridge(\"src/main.rs\")\n+    cxx_build::bridge(\"src/main.rs\")\n         .file(\"../demo-cxx/demo.cc\")\n         .flag(\"-std=c++11\")\n         .compile(\"cxxbridge-demo\");\ndiff --git /dev/null b/gen/README.md\nnew file mode 100644\n--- /dev/null\n+++ b/gen/README.md\n@@ -0,0 +1,4 @@\n+This directory contains CXX's C++ code generator. This code generator has two\n+public frontends, one a command-line application (binary) in the *cmd* directory\n+and the other a library intended to be used from a build.rs in the *build*\n+directory.\ndiff --git /dev/null b/gen/build/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/gen/build/Cargo.toml\n@@ -0,0 +1,22 @@\n+[package]\n+name = \"cxx-build\"\n+version = \"0.2.12\"\n+authors = [\"David Tolnay <dtolnay@gmail.com>\"]\n+edition = \"2018\"\n+license = \"MIT OR Apache-2.0\"\n+description = \"C++ code generator for integrating `cxx` crate into a Cargo build.\"\n+repository = \"https://github.com/dtolnay/cxx\"\n+\n+[badges]\n+travis-ci = { repository = \"dtolnay/cxx\" }\n+\n+[dependencies]\n+anyhow = \"1.0\"\n+cc = \"1.0.49\"\n+codespan-reporting = \"0.9\"\n+proc-macro2 = { version = \"1.0\", features = [\"span-locations\"] }\n+quote = \"1.0\"\n+syn = { version = \"1.0\", features = [\"full\"] }\n+\n+[package.metadata.docs.rs]\n+targets = [\"x86_64-unknown-linux-gnu\"]\ndiff --git /dev/null b/gen/build/LICENSE-APACHE\nnew file mode 100644\n--- /dev/null\n+++ b/gen/build/LICENSE-APACHE\n@@ -0,0 +1,1 @@\n+../../LICENSE-APACHE\n\\ No newline at end of file\ndiff --git /dev/null b/gen/build/LICENSE-MIT\nnew file mode 100644\n--- /dev/null\n+++ b/gen/build/LICENSE-MIT\n@@ -0,0 +1,1 @@\n+../../LICENSE-MIT\n\\ No newline at end of file\ndiff --git /dev/null b/gen/build/src/gen\nnew file mode 100644\n--- /dev/null\n+++ b/gen/build/src/gen\n@@ -0,0 +1,1 @@\n+../../src\n\\ No newline at end of file\ndiff --git /dev/null b/gen/build/src/lib.rs\nnew file mode 100644\n--- /dev/null\n+++ b/gen/build/src/lib.rs\n@@ -0,0 +1,96 @@\n+//! The CXX code generator for constructing and compiling C++ code.\n+//!\n+//! This is intended to be used from Cargo build scripts to execute CXX's\n+//! C++ code generator, set up any additional compiler flags depending on\n+//! the use case, and make the C++ compiler invocation.\n+//!\n+//! <br>\n+//!\n+//! # Example\n+//!\n+//! Example of a canonical Cargo build script that builds a CXX bridge:\n+//!\n+//! ```no_run\n+//! // build.rs\n+//!\n+//! fn main() {\n+//!     cxx_build::bridge(\"src/main.rs\")\n+//!         .file(\"../demo-cxx/demo.cc\")\n+//!         .flag(\"-std=c++11\")\n+//!         .compile(\"cxxbridge-demo\");\n+//!\n+//!     println!(\"cargo:rerun-if-changed=src/main.rs\");\n+//!     println!(\"cargo:rerun-if-changed=../demo-cxx/demo.h\");\n+//!     println!(\"cargo:rerun-if-changed=../demo-cxx/demo.cc\");\n+//! }\n+//! ```\n+//!\n+//! A runnable working setup with this build script is shown in the\n+//! *demo-rs* and *demo-cxx* directories of [https://github.com/dtolnay/cxx].\n+//!\n+//! [https://github.com/dtolnay/cxx]: https://github.com/dtolnay/cxx\n+//!\n+//! <br>\n+//!\n+//! # Alternatives\n+//!\n+//! For use in non-Cargo builds like Bazel or Buck, CXX provides an\n+//! alternate way of invoking the C++ code generator as a standalone command\n+//! line tool. The tool is packaged as the `cxxbridge-cmd` crate.\n+//!\n+//! ```bash\n+//! $ cargo install cxxbridge-cmd  # or build it from the repo\n+//!\n+//! $ cxxbridge src/main.rs --header > path/to/mybridge.h\n+//! $ cxxbridge src/main.rs > path/to/mybridge.cc\n+//! ```\n+\n+mod error;\n+mod gen;\n+mod paths;\n+mod syntax;\n+\n+use crate::error::Result;\n+use crate::gen::Opt;\n+use anyhow::anyhow;\n+use std::fs;\n+use std::io::{self, Write};\n+use std::path::Path;\n+use std::process;\n+\n+/// This returns a [`cc::Build`] on which you should continue to set up any\n+/// additional source files or compiler flags, and lastly call its [`compile`]\n+/// method to execute the C++ build.\n+///\n+/// [`compile`]: https://docs.rs/cc/1.0.49/cc/struct.Build.html#method.compile\n+#[must_use]\n+pub fn bridge(rust_source_file: impl AsRef<Path>) -> cc::Build {\n+    match try_generate_bridge(rust_source_file.as_ref()) {\n+        Ok(build) => build,\n+        Err(err) => {\n+            let _ = writeln!(io::stderr(), \"\\n\\ncxxbridge error: {:?}\\n\\n\", anyhow!(err));\n+            process::exit(1);\n+        }\n+    }\n+}\n+\n+fn try_generate_bridge(rust_source_file: &Path) -> Result<cc::Build> {\n+    let header = gen::do_generate_header(rust_source_file, Opt::default());\n+    let header_path = paths::out_with_extension(rust_source_file, \".h\")?;\n+    fs::create_dir_all(header_path.parent().unwrap())?;\n+    fs::write(&header_path, header)?;\n+    paths::symlink_header(&header_path, rust_source_file);\n+\n+    let bridge = gen::do_generate_bridge(rust_source_file, Opt::default());\n+    let bridge_path = paths::out_with_extension(rust_source_file, \".cc\")?;\n+    fs::write(&bridge_path, bridge)?;\n+    let mut build = paths::cc_build();\n+    build.file(&bridge_path);\n+\n+    let ref cxx_h = paths::include_dir()?.join(\"rust\").join(\"cxx.h\");\n+    let _ = fs::create_dir_all(cxx_h.parent().unwrap());\n+    let _ = fs::remove_file(cxx_h);\n+    let _ = fs::write(cxx_h, gen::include::HEADER);\n+\n+    Ok(build)\n+}\ndiff --git /dev/null b/gen/build/src/syntax\nnew file mode 100644\n--- /dev/null\n+++ b/gen/build/src/syntax\n@@ -0,0 +1,1 @@\n+../../../syntax\n\\ No newline at end of file\ndiff --git /dev/null b/gen/cmd/LICENSE-APACHE\nnew file mode 100644\n--- /dev/null\n+++ b/gen/cmd/LICENSE-APACHE\n@@ -0,0 +1,1 @@\n+../../LICENSE-APACHE\n\\ No newline at end of file\ndiff --git /dev/null b/gen/cmd/LICENSE-MIT\nnew file mode 100644\n--- /dev/null\n+++ b/gen/cmd/LICENSE-MIT\n@@ -0,0 +1,1 @@\n+../../LICENSE-MIT\n\\ No newline at end of file\ndiff --git /dev/null b/gen/cmd/src/gen\nnew file mode 100644\n--- /dev/null\n+++ b/gen/cmd/src/gen\n@@ -0,0 +1,1 @@\n+../../src\n\\ No newline at end of file\ndiff --git /dev/null b/gen/cmd/src/syntax\nnew file mode 100644\n--- /dev/null\n+++ b/gen/cmd/src/syntax\n@@ -0,0 +1,1 @@\n+../../../syntax\n\\ No newline at end of file\ndiff --git a/gen/include /dev/null\n--- a/gen/include\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-../include\n\\ No newline at end of file\ndiff --git /dev/null b/gen/src/include\nnew file mode 100644\n--- /dev/null\n+++ b/gen/src/include\n@@ -0,0 +1,1 @@\n+../../include\n\\ No newline at end of file\ndiff --git a/macro/Cargo.toml b/macro/Cargo.toml\n--- a/macro/Cargo.toml\n+++ b/macro/Cargo.toml\n@@ -6,6 +6,7 @@ edition = \"2018\"\n license = \"MIT OR Apache-2.0\"\n description = \"Implementation detail of the `cxx` crate.\"\n repository = \"https://github.com/dtolnay/cxx\"\n+exclude = [\"README.md\"]\n \n [lib]\n proc-macro = true\ndiff --git /dev/null b/macro/README.md\nnew file mode 100644\n--- /dev/null\n+++ b/macro/README.md\n@@ -0,0 +1,3 @@\n+This directory contains CXX's Rust code generator, which is a procedural macro.\n+Users won't depend on this crate directly. Instead they'll invoke its macro\n+through the reexport in the main `cxx` crate.\ndiff --git a/src/gen /dev/null\n--- a/src/gen\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-../gen\n\\ No newline at end of file\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -224,8 +224,7 @@\n //! // build.rs\n //!\n //! fn main() {\n-//!     cxx::Build::new()\n-//!         .bridge(\"src/main.rs\")  // returns a cc::Build\n+//!     cxx_build::bridge(\"src/main.rs\")  // returns a cc::Build\n //!         .file(\"../demo-cxx/demo.cc\")\n //!         .flag(\"-std=c++11\")\n //!         .compile(\"cxxbridge-demo\");\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -363,18 +362,14 @@ mod concat;\n \n mod cxx_string;\n mod cxx_vector;\n-mod error;\n mod exception;\n mod function;\n-mod gen;\n mod opaque;\n-mod paths;\n mod result;\n mod rust_sliceu8;\n mod rust_str;\n mod rust_string;\n mod rust_vec;\n-mod syntax;\n mod unique_ptr;\n mod unwind;\n \ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -398,107 +393,3 @@ pub mod private {\n     pub use crate::unique_ptr::UniquePtrTarget;\n     pub use crate::unwind::catch_unwind;\n }\n-\n-use crate::error::Result;\n-use crate::gen::Opt;\n-use anyhow::anyhow;\n-use std::fs;\n-use std::io::{self, Write};\n-use std::path::Path;\n-use std::process;\n-\n-/// The CXX code generator for constructing and compiling C++ code.\n-///\n-/// This is intended to be used from Cargo build scripts to execute CXX's\n-/// C++ code generator, set up any additional compiler flags depending on\n-/// the use case, and make the C++ compiler invocation.\n-///\n-/// <br>\n-///\n-/// # Example\n-///\n-/// Example of a canonical Cargo build script that builds a CXX bridge:\n-///\n-/// ```no_run\n-/// // build.rs\n-///\n-/// fn main() {\n-///     cxx::Build::new()\n-///         .bridge(\"src/main.rs\")\n-///         .file(\"../demo-cxx/demo.cc\")\n-///         .flag(\"-std=c++11\")\n-///         .compile(\"cxxbridge-demo\");\n-///\n-///     println!(\"cargo:rerun-if-changed=src/main.rs\");\n-///     println!(\"cargo:rerun-if-changed=../demo-cxx/demo.h\");\n-///     println!(\"cargo:rerun-if-changed=../demo-cxx/demo.cc\");\n-/// }\n-/// ```\n-///\n-/// A runnable working setup with this build script is shown in the\n-/// *demo-rs* and *demo-cxx* directories of [https://github.com/dtolnay/cxx].\n-///\n-/// [https://github.com/dtolnay/cxx]: https://github.com/dtolnay/cxx\n-///\n-/// <br>\n-///\n-/// # Alternatives\n-///\n-/// For use in non-Cargo builds like Bazel or Buck, CXX provides an\n-/// alternate way of invoking the C++ code generator as a standalone command\n-/// line tool. The tool is packaged as the `cxxbridge-cmd` crate.\n-///\n-/// ```bash\n-/// $ cargo install cxxbridge-cmd  # or build it from the repo\n-///\n-/// $ cxxbridge src/main.rs --header > path/to/mybridge.h\n-/// $ cxxbridge src/main.rs > path/to/mybridge.cc\n-/// ```\n-#[must_use]\n-pub struct Build {\n-    _private: (),\n-}\n-\n-impl Build {\n-    /// Begin with a [`cc::Build`] in its default configuration.\n-    pub fn new() -> Self {\n-        Build { _private: () }\n-    }\n-\n-    /// This returns a [`cc::Build`] on which you should continue to set up\n-    /// any additional source files or compiler flags, and lastly call its\n-    /// [`compile`] method to execute the C++ build.\n-    ///\n-    /// [`compile`]: https://docs.rs/cc/1.0.49/cc/struct.Build.html#method.compile\n-    #[must_use]\n-    pub fn bridge(&self, rust_source_file: impl AsRef<Path>) -> cc::Build {\n-        match try_generate_bridge(rust_source_file.as_ref()) {\n-            Ok(build) => build,\n-            Err(err) => {\n-                let _ = writeln!(io::stderr(), \"\\n\\ncxxbridge error: {:?}\\n\\n\", anyhow!(err));\n-                process::exit(1);\n-            }\n-        }\n-    }\n-}\n-\n-fn try_generate_bridge(rust_source_file: &Path) -> Result<cc::Build> {\n-    let header = gen::do_generate_header(rust_source_file, Opt::default());\n-    let header_path = paths::out_with_extension(rust_source_file, \".h\")?;\n-    fs::create_dir_all(header_path.parent().unwrap())?;\n-    fs::write(&header_path, header)?;\n-    paths::symlink_header(&header_path, rust_source_file);\n-\n-    let bridge = gen::do_generate_bridge(rust_source_file, Opt::default());\n-    let bridge_path = paths::out_with_extension(rust_source_file, \".cc\")?;\n-    fs::write(&bridge_path, bridge)?;\n-    let mut build = paths::cc_build();\n-    build.file(&bridge_path);\n-\n-    let ref cxx_h = paths::include_dir()?.join(\"rust\").join(\"cxx.h\");\n-    let _ = fs::create_dir_all(cxx_h.parent().unwrap());\n-    let _ = fs::remove_file(cxx_h);\n-    let _ = fs::write(cxx_h, gen::include::HEADER);\n-\n-    Ok(build)\n-}\ndiff --git a/src/syntax /dev/null\n--- a/src/syntax\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-../syntax\n\\ No newline at end of file\ndiff --git a/third-party/Cargo.lock b/third-party/Cargo.lock\n--- a/third-party/Cargo.lock\n+++ b/third-party/Cargo.lock\n@@ -104,6 +113,7 @@ name = \"cxxbridge-demo\"\n version = \"0.0.0\"\n dependencies = [\n  \"cxx\",\n+ \"cxx-build\",\n ]\n \n [[package]]\n",
        "test_patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -15,25 +15,20 @@ exclude = [\"/demo-cxx\", \"/gen\", \"/syntax\", \"/third-party\"]\n travis-ci = { repository = \"dtolnay/cxx\" }\n \n [dependencies]\n-anyhow = \"1.0\"\n-cc = \"1.0.49\"\n-codespan-reporting = \"0.9\"\n cxxbridge-macro = { version = \"=0.2.12\", path = \"macro\" }\n link-cplusplus = \"1.0\"\n-proc-macro2 = { version = \"1.0\", features = [\"span-locations\"] }\n-quote = \"1.0\"\n-syn = { version = \"1.0\", features = [\"full\"] }\n \n [build-dependencies]\n cc = \"1.0.49\"\n \n [dev-dependencies]\n+cxx-build = { version = \"=0.2.12\", path = \"gen/build\" }\n cxx-test-suite = { version = \"0\", path = \"tests/ffi\" }\n rustversion = \"1.0\"\n trybuild = { version = \"1.0.21\", features = [\"diff\"] }\n \n [workspace]\n-members = [\"cmd\", \"demo-rs\", \"macro\", \"tests/ffi\"]\n+members = [\"demo-rs\", \"gen/build\", \"gen/cmd\", \"macro\", \"tests/ffi\"]\n \n [package.metadata.docs.rs]\n targets = [\"x86_64-unknown-linux-gnu\"]\ndiff --git a/tests/ffi/Cargo.toml b/tests/ffi/Cargo.toml\n--- a/tests/ffi/Cargo.toml\n+++ b/tests/ffi/Cargo.toml\n@@ -11,4 +11,4 @@ path = \"lib.rs\"\n cxx = { path = \"../..\" }\n \n [build-dependencies]\n-cxx = { path = \"../..\" }\n+cxx-build = { path = \"../../gen/build\" }\ndiff --git a/tests/ffi/build.rs b/tests/ffi/build.rs\n--- a/tests/ffi/build.rs\n+++ b/tests/ffi/build.rs\n@@ -3,8 +3,7 @@ fn main() {\n         return;\n     }\n \n-    cxx::Build::new()\n-        .bridge(\"lib.rs\")\n+    cxx_build::bridge(\"lib.rs\")\n         .file(\"tests.cc\")\n         .flag(\"-std=c++11\")\n         .compile(\"cxx-test-suite\");\ndiff --git a/third-party/Cargo.lock b/third-party/Cargo.lock\n--- a/third-party/Cargo.lock\n+++ b/third-party/Cargo.lock\n@@ -67,17 +67,25 @@ dependencies = [\n name = \"cxx\"\n version = \"0.2.12\"\n dependencies = [\n- \"anyhow\",\n  \"cc\",\n- \"codespan-reporting\",\n+ \"cxx-build\",\n  \"cxx-test-suite\",\n  \"cxxbridge-macro\",\n  \"link-cplusplus\",\n+ \"rustversion\",\n+ \"trybuild\",\n+]\n+\n+[[package]]\n+name = \"cxx-build\"\n+version = \"0.2.12\"\n+dependencies = [\n+ \"anyhow\",\n+ \"cc\",\n+ \"codespan-reporting\",\n  \"proc-macro2\",\n  \"quote\",\n- \"rustversion\",\n  \"syn\",\n- \"trybuild\",\n ]\n \n [[package]]\ndiff --git a/third-party/Cargo.lock b/third-party/Cargo.lock\n--- a/third-party/Cargo.lock\n+++ b/third-party/Cargo.lock\n@@ -85,6 +93,7 @@ name = \"cxx-test-suite\"\n version = \"0.0.0\"\n dependencies = [\n  \"cxx\",\n+ \"cxx-build\",\n ]\n \n [[package]]\n",
        "problem_statement": "Split cxx crate into runtime and build.rs components\nRight now, the cxx crate contains both runtime components (e.g. `cxx::unique_ptr`) and build time components (e.g. `cxx::gen`, `cxx::Build`).\r\n\r\nThis is negative because:\r\n* For cross compilation builds, this requires that what should be build-only dependencies be supported on the target.\r\n* This builds more functionality into the target binary than needed. If cxx is linked statically, there's a good chance most of this will be removed, but it will bloat in cases where it's linked dynamically.\r\n* For homogenous build systems (bazel, buck, etc.) this requires them to pull in the `cc` and `link_cplusplus` crates to their source tree, which will never actually be used.\r\n\r\nThe two ways I see forwards here are:\r\n* Split it using features. Users of homogenous build system, or who cared about binary size, etc. would be expected to disable a default feature to get a support-code-only version of the crate.\r\n* Split it into separate crates, e.g. cxx-support and cxx-build, possibly keeping the main cxx crate as a wrapper that re-exports both.\r\n\r\nOpinions?\n",
        "hints_text": "We should split the crate. I'll try to move the build-only stuff to a `cxx-codegen` crate and keep only the runtime components in `cxx`.\nDo you want to handle that yourself, or should I send up a PR? I had it temporarily split with a feature to get it working in my context.\nI will take care of this one since I'll probably be picky about the directory layout. It sounds like you have a workaround for now? If so, I'll aim to get this done and published early next week.",
        "created_at": "2020-04-30T01:18:12Z",
        "version": "0.2"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 162,
        "instance_id": "dtolnay__cxx-162",
        "issue_numbers": [
            "155"
        ],
        "base_commit": "a53c90f08a56fdf6d9da202282ac9bd370129c63",
        "patch": "diff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -230,6 +230,11 @@ fn check_api_fn(cx: &mut Check, efn: &ExternFn) {\n                 );\n             }\n         }\n+        if let Type::Ref(ity) = &arg.ty {\n+            if let Type::Ref(_) = &ity.inner {\n+                cx.error(arg, \"Passing a reference to a reference is not supported\");\n+            }\n+        }\n     }\n \n     if let Some(ty) = &efn.ret {\n",
        "test_patch": "diff --git /dev/null b/tests/ui/reference_to_reference.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/reference_to_reference.rs\n@@ -0,0 +1,13 @@\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"C\" {\n+        type ThingC;\n+        fn repro_c(t: &&ThingC);\n+    }\n+    extern \"Rust\" {\n+        type ThingR;\n+        fn repro_r(t: &&ThingR);\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/reference_to_reference.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/reference_to_reference.stderr\n@@ -0,0 +1,11 @@\n+error: Passing a reference to a reference is not supported\n+ --> $DIR/reference_to_reference.rs:5:20\n+  |\n+5 |         fn repro_c(t: &&ThingC);\n+  |                    ^^^^^^^^^^^\n+\n+error: Passing a reference to a reference is not supported\n+ --> $DIR/reference_to_reference.rs:9:20\n+  |\n+9 |         fn repro_r(t: &&ThingR);\n+  |                    ^^^^^^^^^^^\n",
        "problem_statement": "Reject references to references with a better error\nReferences to references currently fail to compile but only because we emit broken C++ code. We should catch this and intentionally report an error explaining that C++ doesn't like references to references.\r\n\r\n```rust\r\nmod ffi {\r\n    extern \"Rust\" {\r\n        type Thing;\r\n        fn repro(r: &&Thing);\r\n    }\r\n}\r\n```\r\n\r\n```console\r\n/target/debug/out/repro/src/main.rs.cc:152:44: error: duplicate \u2018const\u2019\r\n  152 | void cxxbridge02$repro(const const Thing & &r) noexcept;\r\n      |                              ^~~~~\r\n/target/debug/out/repro/src/main.rs.cc:152:60: error: cannot declare reference to \u2018const struct Thing&\u2019, which is not a typedef or a template type argument\r\n  152 | void cxxbridge02$repro(const const Thing & &r) noexcept;\r\n      |                                             ^\r\n```\n",
        "hints_text": "",
        "created_at": "2020-04-28T17:15:59Z",
        "version": "0.2"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 159,
        "instance_id": "dtolnay__cxx-159",
        "issue_numbers": [
            "154"
        ],
        "base_commit": "bd22ce57ddff10fb3060e4a2c2ed201098f2f013",
        "patch": "diff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -6,9 +6,9 @@ use crate::syntax::{\n use quote::{format_ident, quote};\n use syn::punctuated::Punctuated;\n use syn::{\n-    Abi, Error, Fields, FnArg, ForeignItem, ForeignItemFn, ForeignItemType, GenericArgument, Item,\n-    ItemForeignMod, ItemStruct, Pat, PathArguments, Result, ReturnType, Token, Type as RustType,\n-    TypeBareFn, TypePath, TypeReference, TypeSlice,\n+    Abi, Error, Fields, FnArg, ForeignItem, ForeignItemFn, ForeignItemType, GenericArgument, Ident,\n+    Item, ItemForeignMod, ItemStruct, Pat, PathArguments, Result, ReturnType, Token,\n+    Type as RustType, TypeBareFn, TypePath, TypeReference, TypeSlice,\n };\n \n pub mod kw {\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -193,6 +193,9 @@ fn parse_extern_fn(foreign_fn: &ForeignItemFn, lang: Lang) -> Result<ExternFn> {\n             FnArg::Typed(arg) => {\n                 let ident = match arg.pat.as_ref() {\n                     Pat::Ident(pat) => pat.ident.clone(),\n+                    Pat::Wild(pat) => {\n+                        Ident::new(&format!(\"_{}\", args.len()), pat.underscore_token.span)\n+                    }\n                     _ => return Err(Error::new_spanned(arg, \"unsupported signature\")),\n                 };\n                 let ty = parse_type(&arg.ty)?;\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -34,6 +34,8 @@ pub mod ffi {\n         fn c_return_ref_vector(c: &C) -> &CxxVector<u8>;\n         fn c_return_rust_vec() -> Vec<u8>;\n         fn c_return_ref_rust_vec(c: &C) -> &Vec<u8>;\n+        fn c_return_identity(_: usize) -> usize;\n+        fn c_return_sum(_: usize, _: usize) -> usize;\n \n         fn c_take_primitive(n: usize);\n         fn c_take_shared(shared: Shared);\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -86,6 +88,8 @@ pub mod ffi {\n         fn r_return_unique_ptr_string() -> UniquePtr<CxxString>;\n         fn r_return_rust_vec() -> Vec<u8>;\n         fn r_return_ref_rust_vec(shared: &Shared) -> &Vec<u8>;\n+        fn r_return_identity(_: usize) -> usize;\n+        fn r_return_sum(_: usize, _: usize) -> usize;\n \n         fn r_take_primitive(n: usize);\n         fn r_take_shared(shared: Shared);\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -184,6 +188,14 @@ fn r_return_ref_rust_vec(shared: &ffi::Shared) -> &Vec<u8> {\n     unimplemented!()\n }\n \n+fn r_return_identity(n: usize) -> usize {\n+    n\n+}\n+\n+fn r_return_sum(n1: usize, n2: usize) -> usize {\n+    n1 + n2\n+}\n+\n fn r_take_primitive(n: usize) {\n     assert_eq!(n, 2020);\n }\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -102,6 +102,14 @@ const rust::Vec<uint8_t> &c_return_ref_rust_vec(const C &c) {\n   throw std::runtime_error(\"unimplemented\");\n }\n \n+size_t c_return_identity(size_t n) {\n+  return n;\n+}\n+\n+size_t c_return_sum(size_t n1, size_t n2) {\n+  return n1 + n2;\n+}\n+\n void c_take_primitive(size_t n) {\n   if (n == 2020) {\n     cxx_test_suite_set_correct();\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -265,6 +273,8 @@ extern \"C\" const char *cxx_run_test() noexcept {\n   ASSERT(std::string(r_return_str(Shared{2020})) == \"2020\");\n   ASSERT(std::string(r_return_rust_string()) == \"2020\");\n   ASSERT(*r_return_unique_ptr_string() == \"2020\");\n+  ASSERT(r_return_identity(2020) == 2020);\n+  ASSERT(r_return_sum(2020, 1) == 2021);\n \n   r_take_primitive(2020);\n   r_take_shared(Shared{2020});\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -38,6 +38,8 @@ std::unique_ptr<std::vector<C>> c_return_unique_ptr_vector_opaque();\n const std::vector<uint8_t> &c_return_ref_vector(const C &c);\n rust::Vec<uint8_t> c_return_rust_vec();\n const rust::Vec<uint8_t> &c_return_ref_rust_vec(const C &c);\n+size_t c_return_identity(size_t n);\n+size_t c_return_sum(size_t n1, size_t n2);\n \n void c_take_primitive(size_t n);\n void c_take_shared(Shared shared);\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -49,6 +49,8 @@ fn test_c_return() {\n             .map(|o| o.z)\n             .sum(),\n     );\n+    assert_eq!(2020, ffi::c_return_identity(2020));\n+    assert_eq!(2021, ffi::c_return_sum(2020, 1));\n }\n \n #[test]\n",
        "problem_statement": "Allow wildcard argument names in extern function signature\nCurrently we reject this for no particular reason. Seems like an oversight.\r\n\r\n```rust\r\n#[cxx::bridge]\r\nmod ffi {\r\n    extern \"C\" {\r\n        fn repro(_: &str);\r\n    }\r\n}\r\n```\r\n\r\n```console\r\nerror[cxxbridge]: unsupported signature\r\n\r\n    \u250c\u2500\u2500 src/main.rs:4:18 \u2500\u2500\u2500\r\n    \u2502\r\n  4 \u2502         fn repro(_: &str);  // but `s: &str` works\r\n    \u2502                  ^^^^^^^ unsupported signature\r\n```\n",
        "hints_text": "",
        "created_at": "2020-04-27T23:23:51Z",
        "version": "0.2"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 131,
        "instance_id": "dtolnay__cxx-131",
        "issue_numbers": [
            "124"
        ],
        "base_commit": "ce855186ae3de12ea08b5a6cb95aa0e9553a44d6",
        "patch": "diff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -91,16 +91,28 @@ fn parse_foreign_mod(foreign_mod: ItemForeignMod) -> Result<Vec<Api>> {\n         Lang::Rust => Api::RustFunction,\n     };\n \n-    let mut items = Vec::new();\n+    let mut types = Vec::new();\n     for foreign in &foreign_mod.items {\n         match foreign {\n             ForeignItem::Type(foreign) => {\n                 check_reserved_name(&foreign.ident)?;\n                 let ety = parse_extern_type(foreign)?;\n-                items.push(api_type(ety));\n+                types.push(ety);\n             }\n+            _ => {}\n+        }\n+    }\n+    let single_type = if types.len() == 1 {\n+        Some(&types[0])\n+    } else {\n+        None\n+    };\n+    let mut items = Vec::new();\n+    for foreign in &foreign_mod.items {\n+        match foreign {\n+            ForeignItem::Type(_) => {}\n             ForeignItem::Fn(foreign) => {\n-                let efn = parse_extern_fn(foreign, lang)?;\n+                let efn = parse_extern_fn(foreign, lang, &single_type)?;\n                 items.push(api_function(efn));\n             }\n             ForeignItem::Macro(foreign) if foreign.mac.path.is_ident(\"include\") => {\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -110,6 +122,7 @@ fn parse_foreign_mod(foreign_mod: ItemForeignMod) -> Result<Vec<Api>> {\n             _ => return Err(Error::new_spanned(foreign, \"unsupported foreign item\")),\n         }\n     }\n+    items.extend(types.into_iter().map(|ety| api_type(ety)));\n     Ok(items)\n }\n \ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -141,7 +154,11 @@ fn parse_extern_type(foreign_type: &ForeignItemType) -> Result<ExternType> {\n     })\n }\n \n-fn parse_extern_fn(foreign_fn: &ForeignItemFn, lang: Lang) -> Result<ExternFn> {\n+fn parse_extern_fn(\n+    foreign_fn: &ForeignItemFn,\n+    lang: Lang,\n+    single_type: &Option<&ExternType>,\n+) -> Result<ExternFn> {\n     let generics = &foreign_fn.sig.generics;\n     if !generics.params.is_empty() || generics.where_clause.is_some() {\n         return Err(Error::new_spanned(\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -161,8 +178,19 @@ fn parse_extern_fn(foreign_fn: &ForeignItemFn, lang: Lang) -> Result<ExternFn> {\n     for arg in foreign_fn.sig.inputs.pairs() {\n         let (arg, comma) = arg.into_tuple();\n         match arg {\n-            FnArg::Receiver(receiver) => {\n-                return Err(Error::new_spanned(receiver, \"unsupported signature\"))\n+            FnArg::Receiver(rcvr) => {\n+                if let Some(ety) = single_type {\n+                    if let Some((and, _)) = rcvr.reference {\n+                        receiver = Some(Receiver {\n+                            ampersand: and,\n+                            mutability: rcvr.mutability,\n+                            var: Token![self](ety.ident.span()),\n+                            ty: ety.ident.clone(),\n+                        });\n+                        continue;\n+                    }\n+                }\n+                return Err(Error::new_spanned(rcvr, \"unsupported signature\"));\n             }\n             FnArg::Typed(arg) => {\n                 let ident = match arg.pat.as_ref() {\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -52,6 +52,8 @@ pub mod ffi {\n \n         fn get(self: &C) -> usize;\n         fn set(self: &mut C, n: usize) -> usize;\n+        fn get2(&self) -> usize;\n+        fn set2(&mut self, n: usize) -> usize;\n     }\n \n     extern \"Rust\" {\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -15,11 +15,18 @@ C::C(size_t n) : n(n) {}\n \n size_t C::get() const { return this->n; }\n \n+size_t C::get2() const { return this->n; }\n+\n size_t C::set(size_t n) {\n   this->n = n;\n   return this->n;\n }\n \n+size_t C::set2(size_t n) {\n+  this->n = n;\n+  return this->n;\n+}\n+\n size_t c_return_primitive() { return 2020; }\n \n Shared c_return_shared() { return Shared{2020}; }\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -13,6 +13,8 @@ class C {\n   C(size_t n);\n   size_t get() const;\n   size_t set(size_t n);\n+  size_t get2() const;\n+  size_t set2(size_t n);\n \n private:\n   size_t n;\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -102,8 +102,8 @@ fn test_c_method_calls() {\n     assert_eq!(2020, old_value);\n     assert_eq!(2021, unique_ptr.set(2021));\n     assert_eq!(2021, unique_ptr.get());\n-    assert_eq!(old_value, unique_ptr.set(old_value));\n-    assert_eq!(old_value, unique_ptr.get())\n+    assert_eq!(old_value, unique_ptr.set2(old_value));\n+    assert_eq!(old_value, unique_ptr.get2())\n }\n \n #[no_mangle]\n",
        "problem_statement": "Support &self shorthand if there is only one extern type in the block\nAs currently implemented, Rust associated methods and C++ member functions are currently specified with `self: &T` syntax.\r\n\r\n```rust\r\nextern \"C\" {\r\n    type C;\r\n    fn f(self: &C);\r\n}\r\n```\r\n\r\nInside of extern blocks that contain exactly one extern type, we should allow the usual `&self` and `&mut self` shorthand as well.\r\n\r\n```rust\r\nextern \"C\" {\r\n    type C;\r\n    fn f(&self);\r\n}\r\n```\n",
        "hints_text": "",
        "created_at": "2020-04-22T15:46:46Z",
        "version": "0.2"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 711,
        "instance_id": "dtolnay__cxx-711",
        "issue_numbers": [
            "708"
        ],
        "base_commit": "47cb2bbccd87d6895162c1829568ab229a8649d7",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -43,6 +43,7 @@ pub fn bridge(mut ffi: Module) -> Result<TokenStream> {\n fn expand(ffi: Module, doc: Doc, attrs: OtherAttrs, apis: &[Api], types: &Types) -> TokenStream {\n     let mut expanded = TokenStream::new();\n     let mut hidden = TokenStream::new();\n+    let mut forbid = TokenStream::new();\n \n     for api in apis {\n         if let Api::RustType(ety) = api {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -57,6 +58,7 @@ fn expand(ffi: Module, doc: Doc, attrs: OtherAttrs, apis: &[Api], types: &Types)\n             Api::Struct(strct) => {\n                 expanded.extend(expand_struct(strct));\n                 hidden.extend(expand_struct_operators(strct));\n+                forbid.extend(expand_struct_forbid_drop(strct));\n             }\n             Api::Enum(enm) => expanded.extend(expand_enum(enm)),\n             Api::CxxType(ety) => {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -104,6 +106,10 @@ fn expand(ffi: Module, doc: Doc, attrs: OtherAttrs, apis: &[Api], types: &Types)\n         }\n     }\n \n+    if !forbid.is_empty() {\n+        hidden.extend(expand_forbid(forbid));\n+    }\n+\n     // Work around https://github.com/rust-lang/rust/issues/67851.\n     if !hidden.is_empty() {\n         expanded.extend(quote! {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -265,6 +271,17 @@ fn expand_struct_operators(strct: &Struct) -> TokenStream {\n     operators\n }\n \n+fn expand_struct_forbid_drop(strct: &Struct) -> TokenStream {\n+    let ident = &strct.name.rust;\n+    let generics = &strct.generics;\n+    let span = ident.span();\n+    let impl_token = Token![impl](strct.visibility.span);\n+\n+    quote_spanned! {span=>\n+        #impl_token #generics self::Drop for super::#ident #generics {}\n+    }\n+}\n+\n fn expand_enum(enm: &Enum) -> TokenStream {\n     let ident = &enm.name.rust;\n     let doc = &enm.doc;\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -786,6 +803,17 @@ fn expand_rust_type_layout(ety: &ExternType) -> TokenStream {\n     }\n }\n \n+fn expand_forbid(impls: TokenStream) -> TokenStream {\n+    quote! {\n+        mod forbid {\n+            pub trait Drop {}\n+            #[allow(drop_bounds)]\n+            impl<T: ?::std::marker::Sized + ::std::ops::Drop> self::Drop for T {}\n+            #impls\n+        }\n+    }\n+}\n+\n fn expand_rust_function_shim(efn: &ExternFn, types: &Types) -> TokenStream {\n     let link_name = mangle::extern_fn(efn, types);\n     let local_name = match &efn.receiver {\n",
        "test_patch": "diff --git /dev/null b/tests/ui/drop_shared.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/drop_shared.rs\n@@ -0,0 +1,14 @@\n+#[cxx::bridge]\n+mod ffi {\n+    struct Shared {\n+        fd: i32,\n+    }\n+}\n+\n+impl Drop for ffi::Shared {\n+    fn drop(&mut self) {\n+        println!(\"close({})\", self.fd);\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/drop_shared.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/drop_shared.stderr\n@@ -0,0 +1,8 @@\n+error[E0119]: conflicting implementations of trait `ffi::_::forbid::Drop` for type `ffi::Shared`:\n+ --> $DIR/drop_shared.rs:3:5\n+  |\n+1 | #[cxx::bridge]\n+  | -------------- first implementation here\n+2 | mod ffi {\n+3 |     struct Shared {\n+  |     ^^^^^^^^^^^^^ conflicting implementation for `ffi::Shared`\n",
        "problem_statement": "Drop impl on Shared types is not called if dropped on C++ side\nThe C++ types generated for shared types are currently POD types, with only the trivial destructor. This means that if a shared type defined in a bridge has the Drop trait implemented, that Drop impl is only called if an instance of the shared type is dropped within Rust code, not within C++. Since there is nothing else that prevents implementing Drop for a shared type, this behavior is surprising and can lead to resource leaks or other unexpected behavior.\r\n\r\nI believe we can fix this pretty easily by generating a destructor for shared types that calls std::ptr::drop_in_place, similar to the Box wrapper. This will make the generated shared types non-POD types, but they will still be standard layout and thus should be fine for our FFI usage. (Also, it probably wouldn't hurt to generate some std::is_standard_layout static asserts on the C++ side?)\r\n\r\nI'm about to put up a PR that has a currently failing test which would pass once this issue is fixed. I can contribute a PR to fix this if the plan above sounds fine.\n",
        "hints_text": "One issue with above is that it seems like this could lead to double drops if the shared struct contains a Box or another struct that impls Drop. Not quite sure how to avoid that.\r\n\r\nIt also seems like that could be a current issue, maybe something that's already been accounted for? How do we avoid double drop if you Box a shared struct that contains another Box?\nPerhaps moving the object into a rust::ManuallyDrop in the destructor before passing it along to drop_in_place would do the job? I can't say I've ever written a destructor with `std::move(*this)` before so I'm not sure if that's problematic for reasons I haven't encountered before.\r\n\r\nActually, perhaps there isn't a way to make this work as expected at all, because moved-from variables are still destructed on the C++ side whereas they aren't on the Rust side. Consider a hypothetical CXX shared type that contains a single c_int field representing an \"owned\" file descriptor, for instance, with a Drop impl that closes the fd. `FdType fd1{open(\"foo.txt\")}; FdType fd2 = std::move(fd1);` would result in the Drop impl being called twice with the proposal above, not once.\r\n\r\nAny thoughts on how to make this work? It'd be nice to be able to create types on the FFI interface that 1) don't require heap allocation (Box/unique_ptr) and 2) can guarantee that owned resources are closed or cleaned up appropriately. But perhaps that's not possible and we should figure out how to block implementing Drop instead, to remove the footgun.\nC++ doesn't have any equivalent of Drop, so the current behavior is intentional. C++ destructors are a different thing; emulating Drop using destructors would require storing a drop flag inside the data structure, which is incompatible with having a matching layout on both sides.\r\n\r\n> It'd be nice to be able to create types on the FFI interface that 1) don't require heap allocation (Box/unique_ptr) and 2) can guarantee that owned resources are closed or cleaned up appropriately.\r\n\r\nExternType is the way to do this -- along the lines of https://cxx.rs/extern-c++.html#integrating-with-bindgen-generated-or-handwritten-unsafe-bindings. You can handwrite a destructor for the drop logic on the C++ side, using a drop flag or some other sentinel value for the moved-from state.\n> C++ doesn't have any equivalent of Drop, so the current behavior is intentional. C++ destructors are a different thing; emulating Drop using destructors would require storing a drop flag inside the data structure, which is incompatible with having a matching layout on both sides.\r\n> \r\n> > It'd be nice to be able to create types on the FFI interface that 1) don't require heap allocation (Box/unique_ptr) and 2) can guarantee that owned resources are closed or cleaned up appropriately.\r\n> \r\n> ExternType is the way to do this -- along the lines of https://cxx.rs/extern-c++.html#integrating-with-bindgen-generated-or-handwritten-unsafe-bindings. You can handwrite a destructor for the drop logic on the C++ side, using a drop flag or some other sentinel value for the moved-from state.\r\n\r\nI meant a shared type that could meet those requirements, but sure I can make do with some manual ExternType bindings, I hadn\u2019t thought of that.\r\n\r\nWe should prevent users from implementing Drop on shared types then IMO, to keep others from falling in the same trap. Perhaps if we just generated a `static_assertions::assert_not_impl_any!(T: Drop)` or equivalent for each shared type on the Rust side?",
        "created_at": "2021-02-12T06:12:45Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 707,
        "instance_id": "dtolnay__cxx-707",
        "issue_numbers": [
            "705"
        ],
        "base_commit": "1cb7e724c09cb18ef84e31b110921a3d878d3ff2",
        "patch": "diff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -413,6 +413,21 @@ union MaybeUninit {\n };\n } // namespace\n \n+namespace detail {\n+// On some platforms size_t is the same C++ type as one of the sized integer\n+// types; on others it is a distinct type. Only in the latter case do we need to\n+// define a specialized impl of rust::Vec<size_t>, because in the former case it\n+// would collide with one of the other specializations.\n+using usize_if_unique =\n+    typename std::conditional<std::is_same<size_t, uint64_t>::value ||\n+                                  std::is_same<size_t, uint32_t>::value,\n+                              struct usize_ignore, size_t>::type;\n+using isize_if_unique =\n+    typename std::conditional<std::is_same<rust::isize, int64_t>::value ||\n+                                  std::is_same<rust::isize, int32_t>::value,\n+                              struct isize_ignore, rust::isize>::type;\n+} // namespace detail\n+\n } // namespace cxxbridge1\n } // namespace rust\n \ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -602,6 +617,8 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n   FOR_EACH_NUMERIC(MACRO)                                                      \\\n   MACRO(bool, bool)                                                            \\\n   MACRO(char, char)                                                            \\\n+  MACRO(usize, rust::detail::usize_if_unique)                                  \\\n+  MACRO(isize, rust::detail::isize_if_unique)                                  \\\n   MACRO(string, rust::String)                                                  \\\n   MACRO(str, rust::Str)\n \ndiff --git a/src/symbols/rust_vec.rs b/src/symbols/rust_vec.rs\n--- a/src/symbols/rust_vec.rs\n+++ b/src/symbols/rust_vec.rs\n@@ -68,10 +68,12 @@ rust_vec_shims_for_primitive!(u8);\n rust_vec_shims_for_primitive!(u16);\n rust_vec_shims_for_primitive!(u32);\n rust_vec_shims_for_primitive!(u64);\n+rust_vec_shims_for_primitive!(usize);\n rust_vec_shims_for_primitive!(i8);\n rust_vec_shims_for_primitive!(i16);\n rust_vec_shims_for_primitive!(i32);\n rust_vec_shims_for_primitive!(i64);\n+rust_vec_shims_for_primitive!(isize);\n rust_vec_shims_for_primitive!(f32);\n rust_vec_shims_for_primitive!(f64);\n \n",
        "test_patch": "diff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -817,6 +817,14 @@ extern \"C\" const char *cxx_run_test() noexcept {\n   ASSERT(vec1[0] == 3 && vec1[1] == 4);\n   ASSERT(vec2[0] == 1 && vec2[1] == 2);\n \n+  // Test Vec<usize> and Vec<isize>. These are weird because on Linux and\n+  // Windows size_t is exactly the same C++ type as one of the sized integer\n+  // types (typically uint64_t, both of which are defined as unsigned long),\n+  // while on macOS it is a distinct type.\n+  // https://github.com/dtolnay/cxx/issues/705\n+  (void)rust::Vec<size_t>();\n+  (void)rust::Vec<rust::isize>();\n+\n   cxx_test_suite_set_correct();\n   return nullptr;\n }\n",
        "problem_statement": "Rust Vec not implemented for usize\nMaybe this is intentional, but when we put a `Vec<usize>` in our `cxxbridge` the Rust code builds fine, but when linking the C++ stuff we get unresolved symbols like this:\r\n\r\n```\r\nUndefined symbols for architecture x86_64:\r\n  \"rust::cxxbridge1::Vec<unsigned long>::Vec()\", referenced from:\r\n      rust::cxxbridge1::Vec<unsigned long>::Vec(rust::cxxbridge1::Vec<unsigned long>&&) in libanalysis_cxx_interface.a(lib.rs.cc.o)\r\n```\r\n\r\nThis is on Mac by the way - you may not get the same errors on Linux because of its crazy linking behaviour (not all symbols have to be defined at compile time IIRC).\r\n\r\nAnyway, I checked the Rust crate that we build (which depends on the `cxx` crate), and it seems to be missing the definition for `Vec<unsigned long>`, whereas it has definitions for other `Vec<some int>` types:\r\n\r\n```\r\n$ objdump -t analysis_rust/release/libanalysis_rust.a | grep __ZN4rust10cxxbridge13VecI | c++filt\r\n...\r\n0000000000000000         *UND* rust::cxxbridge1::Vec<rust::cxxbridge1::String>::Vec()\r\n0000000000000000         *UND* rust::cxxbridge1::Vec<unsigned int>::Vec()\r\n0000000000000000         *UND* rust::cxxbridge1::Vec<unsigned long long>::Vec()\r\n0000000000003f30 __float128     F __TEXT,__text rust::cxxbridge1::Vec<rust::cxxbridge1::Str>::reserve_total(unsigned long)\r\n0000000000003ef0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<rust::cxxbridge1::Str>::drop()\r\n0000000000003f40 __float128     F __TEXT,__text rust::cxxbridge1::Vec<rust::cxxbridge1::Str>::set_len(unsigned long)\r\n0000000000003ee0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<rust::cxxbridge1::Str>::Vec()\r\n0000000000003ed0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<rust::cxxbridge1::Str>::Vec()\r\n0000000000003eb0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<rust::cxxbridge1::String>::reserve_total(unsigned long)\r\n0000000000003e70 __float128     F __TEXT,__text rust::cxxbridge1::Vec<rust::cxxbridge1::String>::drop()\r\n0000000000003ec0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<rust::cxxbridge1::String>::set_len(unsigned long)\r\n0000000000003e60 __float128     F __TEXT,__text rust::cxxbridge1::Vec<rust::cxxbridge1::String>::Vec()\r\n0000000000003e50 __float128     F __TEXT,__text rust::cxxbridge1::Vec<rust::cxxbridge1::String>::Vec()\r\n0000000000003ab0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<signed char>::reserve_total(unsigned long)\r\n0000000000003a70 __float128     F __TEXT,__text rust::cxxbridge1::Vec<signed char>::drop()\r\n0000000000003ac0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<signed char>::set_len(unsigned long)\r\n0000000000003a60 __float128     F __TEXT,__text rust::cxxbridge1::Vec<signed char>::Vec()\r\n0000000000003a50 __float128     F __TEXT,__text rust::cxxbridge1::Vec<signed char>::Vec()\r\n0000000000003db0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<bool>::reserve_total(unsigned long)\r\n0000000000003d70 __float128     F __TEXT,__text rust::cxxbridge1::Vec<bool>::drop()\r\n0000000000003dc0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<bool>::set_len(unsigned long)\r\n0000000000003d60 __float128     F __TEXT,__text rust::cxxbridge1::Vec<bool>::Vec()\r\n0000000000003d50 __float128     F __TEXT,__text rust::cxxbridge1::Vec<bool>::Vec()\r\n0000000000003e30 __float128     F __TEXT,__text rust::cxxbridge1::Vec<char>::reserve_total(unsigned long)\r\n0000000000003df0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<char>::drop()\r\n0000000000003e40 __float128     F __TEXT,__text rust::cxxbridge1::Vec<char>::set_len(unsigned long)\r\n0000000000003de0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<char>::Vec()\r\n0000000000003dd0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<char>::Vec()\r\n0000000000003d30 __float128     F __TEXT,__text rust::cxxbridge1::Vec<double>::reserve_total(unsigned long)\r\n0000000000003cf0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<double>::drop()\r\n0000000000003d40 __float128     F __TEXT,__text rust::cxxbridge1::Vec<double>::set_len(unsigned long)\r\n0000000000003ce0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<double>::Vec()\r\n0000000000003cd0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<double>::Vec()\r\n0000000000003cb0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<float>::reserve_total(unsigned long)\r\n0000000000003c70 __float128     F __TEXT,__text rust::cxxbridge1::Vec<float>::drop()\r\n0000000000003cc0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<float>::set_len(unsigned long)\r\n0000000000003c60 __float128     F __TEXT,__text rust::cxxbridge1::Vec<float>::Vec()\r\n0000000000003c50 __float128     F __TEXT,__text rust::cxxbridge1::Vec<float>::Vec()\r\n00000000000038b0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned char>::reserve_total(unsigned long)\r\n0000000000003870 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned char>::drop()\r\n00000000000038c0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned char>::set_len(unsigned long)\r\n0000000000003860 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned char>::Vec()\r\n0000000000003850 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned char>::Vec()\r\n0000000000003bb0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<int>::reserve_total(unsigned long)\r\n0000000000003b70 __float128     F __TEXT,__text rust::cxxbridge1::Vec<int>::drop()\r\n0000000000003bc0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<int>::set_len(unsigned long)\r\n0000000000003b60 __float128     F __TEXT,__text rust::cxxbridge1::Vec<int>::Vec()\r\n0000000000003b50 __float128     F __TEXT,__text rust::cxxbridge1::Vec<int>::Vec()\r\n00000000000039b0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned int>::reserve_total(unsigned long)\r\n0000000000003970 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned int>::drop()\r\n00000000000039c0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned int>::set_len(unsigned long)\r\n0000000000003960 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned int>::Vec()\r\n0000000000003950 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned int>::Vec()\r\n0000000000003b30 __float128     F __TEXT,__text rust::cxxbridge1::Vec<short>::reserve_total(unsigned long)\r\n0000000000003af0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<short>::drop()\r\n0000000000003b40 __float128     F __TEXT,__text rust::cxxbridge1::Vec<short>::set_len(unsigned long)\r\n0000000000003ae0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<short>::Vec()\r\n0000000000003ad0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<short>::Vec()\r\n0000000000003930 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned short>::reserve_total(unsigned long)\r\n00000000000038f0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned short>::drop()\r\n0000000000003940 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned short>::set_len(unsigned long)\r\n00000000000038e0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned short>::Vec()\r\n00000000000038d0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned short>::Vec()\r\n0000000000003c30 __float128     F __TEXT,__text rust::cxxbridge1::Vec<long long>::reserve_total(unsigned long)\r\n0000000000003bf0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<long long>::drop()\r\n0000000000003c40 __float128     F __TEXT,__text rust::cxxbridge1::Vec<long long>::set_len(unsigned long)\r\n0000000000003be0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<long long>::Vec()\r\n0000000000003bd0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<long long>::Vec()\r\n0000000000003a30 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned long long>::reserve_total(unsigned long)\r\n00000000000039f0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned long long>::drop()\r\n0000000000003a40 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned long long>::set_len(unsigned long)\r\n00000000000039e0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned long long>::Vec()\r\n00000000000039d0 __float128     F __TEXT,__text rust::cxxbridge1::Vec<unsigned long long>::Vec()\r\n```\r\n\r\nAs far as I can tell, the C++ symbols are implemented [here](https://github.com/dtolnay/cxx/blob/5b4b829f8aa301fe3a512324dfacdb752f4958ff/src/cxx.cc#L583) which has this note:\r\n\r\n    // Usize and isize are the same type as one of the below.\r\n\r\nWhich is true, however the [symbol name mangling scheme](https://itanium-cxx-abi.github.io/cxx-abi/abi-mangling.html) actually has distinct encodings for `unsigned long` and `unsigned long long` even if they are actually identical types. Pretty stupid.\r\n\r\n\n",
        "hints_text": "",
        "created_at": "2021-02-09T07:35:18Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 694,
        "instance_id": "dtolnay__cxx-694",
        "issue_numbers": [
            "693"
        ],
        "base_commit": "921c16de1ccba79140433b56dc168d0184cfba63",
        "patch": "diff --git a/src/cxx_string.rs b/src/cxx_string.rs\n--- a/src/cxx_string.rs\n+++ b/src/cxx_string.rs\n@@ -188,7 +188,7 @@ impl PartialEq<str> for CxxString {\n pub struct StackString {\n     // Static assertions in cxx.cc validate that this is large enough and\n     // aligned enough.\n-    space: MaybeUninit<[*const (); 8]>,\n+    space: MaybeUninit<[usize; 8]>,\n }\n \n impl StackString {\n",
        "test_patch": "diff --git /dev/null b/tests/cxx_string.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/cxx_string.rs\n@@ -0,0 +1,15 @@\n+use cxx::{let_cxx_string, CxxString};\n+\n+#[test]\n+fn test_async_cxx_string() {\n+    async fn f() {\n+        let_cxx_string!(s = \"...\");\n+\n+        async fn g(_: &CxxString) {}\n+        g(&s).await;\n+    }\n+\n+    // https://github.com/dtolnay/cxx/issues/693\n+    fn assert_send(_: impl Send) {}\n+    assert_send(f());\n+}\n",
        "problem_statement": "let_cxx_string blocks async fn's Future from being Send\nThis error is wrong, std::string is fine to access from across threads.\r\n\r\n```rust\r\nuse cxx::{let_cxx_string, CxxString};\r\n\r\nasync fn f() {\r\n    let_cxx_string!(s = \"...\");\r\n\r\n    async fn g(_: &CxxString) {}\r\n    g(&s).await;\r\n}\r\n\r\nfn main() {\r\n    fn assert_send(_: impl Send) {}\r\n    assert_send(f());\r\n}\r\n```\r\n\r\n```console\r\nerror: future cannot be sent between threads safely\r\n  --> src/main.rs:12:5\r\n   |\r\n11 |     fn assert_send(_: impl Send) {}\r\n   |                            ---- required by this bound in `assert_send`\r\n12 |     assert_send(f());\r\n   |     ^^^^^^^^^^^ future returned by `f` is not `Send`\r\n   |\r\n   = help: within `impl Future`, the trait `Send` is not implemented for `*const ()`\r\nnote: future is not `Send` as this value is used across an await\r\n  --> src/main.rs:7:5\r\n   |\r\n4  |     let_cxx_string!(s = \"...\");\r\n   |     --------------------------- has type `StackString` which is not `Send`\r\n...\r\n7  |     g(&s).await;\r\n   |     ^^^^^^^^^^^ await occurs here, with `mut $var` maybe used later\r\n8  | }\r\n   | - `mut $var` is later dropped here\r\n```\n",
        "hints_text": "",
        "created_at": "2021-01-27T19:27:35Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 689,
        "instance_id": "dtolnay__cxx-689",
        "issue_numbers": [
            "164"
        ],
        "base_commit": "72d47c95a02fd22723aeac7d0893673dbac98488",
        "patch": "diff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -333,6 +333,7 @@ returns of functions.\n <tr><td><a href=\"https://docs.rs/cxx/1.0/cxx/struct.CxxVector.html\">CxxVector&lt;T&gt;</a></td><td>std::vector&lt;T&gt;</td><td><sup><i>cannot be passed by value, cannot hold opaque Rust type</i></sup></td></tr>\n <tr><td>fn(T, U) -&gt; V</td><td>rust::Fn&lt;V(T, U)&gt;</td><td><sup><i>only passing from Rust to C++ is implemented so far</i></sup></td></tr>\n <tr><td>Result&lt;T&gt;</td><td>throw/catch</td><td><sup><i>allowed as return type only</i></sup></td></tr>\n+<tr><td>*mut T, *const T</td><td>T*, const T*</td><td></td></tr>\n </table>\n \n The C++ API of the `rust` namespace is defined by the *include/cxx.h* file in\ndiff --git a/book/src/bindings.md b/book/src/bindings.md\n--- a/book/src/bindings.md\n+++ b/book/src/bindings.md\n@@ -22,6 +22,7 @@ returns of extern functions.\n <tr><td style=\"padding:3px 6px\"><b><a href=\"binding/cxxvector.md\">CxxVector&lt;T&gt;</a></b></td><td style=\"padding:3px 6px\">std::vector&lt;T&gt;</td><td style=\"padding:3px 6px\"><sup><i>cannot be passed by value, cannot hold opaque Rust type</i></sup></td></tr>\n <tr><td style=\"padding:3px 6px\">fn(T, U) -&gt; V</td><td style=\"padding:3px 6px\"><b><a href=\"binding/fn.md\">rust::Fn&lt;V(T, U)&gt;</a></b></td><td style=\"padding:3px 6px\"><sup><i>only passing from Rust to C++ is implemented so far</i></sup></td></tr>\n <tr><td style=\"padding:3px 6px\"><b><a href=\"binding/result.md\">Result&lt;T&gt;</a></b></td><td style=\"padding:3px 6px\">throw/catch</td><td style=\"padding:3px 6px\"><sup><i>allowed as return type only</i></sup></td></tr>\n+<tr><td style=\"padding:3px 6px\"><b><a href=\"binding/raw_ptr.md\">*const T, *mut T</a></b></td><td style=\"padding:3px 6px\">T*, const T*</td><td style=\"padding:3px 6px\"></td></tr>\n </table>\n \n <br>\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -222,7 +222,7 @@ fn pick_includes_and_builtins(out: &mut OutFile, apis: &[Api]) {\n             Type::Fn(_) => out.builtin.rust_fn = true,\n             Type::SliceRef(_) => out.builtin.rust_slice = true,\n             Type::Array(_) => out.include.array = true,\n-            Type::Ref(_) | Type::Void(_) => {}\n+            Type::Ref(_) | Type::Void(_) | Type::Ptr(_) => {}\n         }\n     }\n }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1179,6 +1179,13 @@ fn write_type(out: &mut OutFile, ty: &Type) {\n             write_type(out, &r.inner);\n             write!(out, \" &\");\n         }\n+        Type::Ptr(p) => {\n+            if !p.mutable {\n+                write!(out, \"const \");\n+            }\n+            write_type(out, &p.inner);\n+            write!(out, \" *\");\n+        }\n         Type::Str(_) => {\n             write!(out, \"::rust::Str\");\n         }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1253,7 +1260,7 @@ fn write_space_after_type(out: &mut OutFile, ty: &Type) {\n         | Type::SliceRef(_)\n         | Type::Fn(_)\n         | Type::Array(_) => write!(out, \" \"),\n-        Type::Ref(_) => {}\n+        Type::Ref(_) | Type::Ptr(_) => {}\n         Type::Void(_) => unreachable!(),\n     }\n }\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -8,6 +8,8 @@ use proc_macro2::{Delimiter, Group, Ident, TokenStream};\n use quote::{quote, ToTokens};\n use std::fmt::Display;\n \n+use super::Ptr;\n+\n pub(crate) struct Check<'a> {\n     apis: &'a [Api],\n     types: &'a Types<'a>,\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -35,6 +37,7 @@ fn do_typecheck(cx: &mut Check) {\n             Type::WeakPtr(ptr) => check_type_weak_ptr(cx, ptr),\n             Type::CxxVector(ptr) => check_type_cxx_vector(cx, ptr),\n             Type::Ref(ty) => check_type_ref(cx, ty),\n+            Type::Ptr(ty) => check_type_ptr(cx, ty),\n             Type::Array(array) => check_type_array(cx, array),\n             Type::Fn(ty) => check_type_fn(cx, ty),\n             Type::SliceRef(ty) => check_type_slice_ref(cx, ty),\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -221,7 +224,7 @@ fn check_type_ref(cx: &mut Check, ty: &Ref) {\n     }\n \n     match ty.inner {\n-        Type::Fn(_) | Type::Void(_) => {}\n+        Type::Fn(_) | Type::Void(_) | Type::Ptr(_) => {}\n         Type::Ref(_) => {\n             cx.error(ty, \"C++ does not allow references to references\");\n             return;\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -232,6 +235,12 @@ fn check_type_ref(cx: &mut Check, ty: &Ref) {\n     cx.error(ty, \"unsupported reference type\");\n }\n \n+fn check_type_ptr(cx: &mut Check, ty: &Ptr) {\n+    if let Type::Ident(_) = ty.inner { return }\n+\n+    cx.error(ty, \"unsupported pointer type\");\n+}\n+\n fn check_type_slice_ref(cx: &mut Check, ty: &SliceRef) {\n     let supported = !is_unsized(cx, &ty.inner)\n         || match &ty.inner {\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -558,6 +567,7 @@ fn is_unsized(cx: &mut Check, ty: &Type) -> bool {\n         | Type::SharedPtr(_)\n         | Type::WeakPtr(_)\n         | Type::Ref(_)\n+        | Type::Ptr(_)\n         | Type::Str(_)\n         | Type::SliceRef(_) => false,\n     }\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -631,6 +641,7 @@ fn describe(cx: &mut Check, ty: &Type) -> String {\n         Type::SharedPtr(_) => \"shared_ptr\".to_owned(),\n         Type::WeakPtr(_) => \"weak_ptr\".to_owned(),\n         Type::Ref(_) => \"reference\".to_owned(),\n+        Type::Ptr(_) => \"raw pointer\".to_owned(),\n         Type::Str(_) => \"&str\".to_owned(),\n         Type::CxxVector(_) => \"C++ vector\".to_owned(),\n         Type::SliceRef(_) => \"slice\".to_owned(),\ndiff --git a/syntax/impls.rs b/syntax/impls.rs\n--- a/syntax/impls.rs\n+++ b/syntax/impls.rs\n@@ -5,6 +5,8 @@ use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::{Deref, DerefMut};\n \n+use super::Ptr;\n+\n impl PartialEq for Include {\n     fn eq(&self, other: &Include) -> bool {\n         let Include {\ndiff --git a/syntax/impls.rs b/syntax/impls.rs\n--- a/syntax/impls.rs\n+++ b/syntax/impls.rs\n@@ -47,6 +49,7 @@ impl Hash for Type {\n             Type::SharedPtr(t) => t.hash(state),\n             Type::WeakPtr(t) => t.hash(state),\n             Type::Ref(t) => t.hash(state),\n+            Type::Ptr(t) => t.hash(state),\n             Type::Str(t) => t.hash(state),\n             Type::RustVec(t) => t.hash(state),\n             Type::CxxVector(t) => t.hash(state),\ndiff --git a/syntax/impls.rs b/syntax/impls.rs\n--- a/syntax/impls.rs\n+++ b/syntax/impls.rs\n@@ -189,6 +192,42 @@ impl Hash for Ref {\n     }\n }\n \n+impl Eq for Ptr {}\n+\n+impl PartialEq for Ptr {\n+    fn eq(&self, other: &Ptr) -> bool {\n+        let Ptr {\n+            star: _,\n+            mutable,\n+            inner,\n+            mutability: _,\n+            constness: _,\n+        } = self;\n+        let Ptr {\n+            star: _,\n+            mutable: mutable2,\n+            inner: inner2,\n+            mutability: _,\n+            constness: _,\n+        } = other;\n+        mutable == mutable2 && inner == inner2\n+    }\n+}\n+\n+impl Hash for Ptr {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        let Ptr {\n+            star: _,\n+            mutable,\n+            inner,\n+            mutability: _,\n+            constness: _,\n+        } = self;\n+        mutable.hash(state);\n+        inner.hash(state);\n+    }\n+}\n+\n impl Eq for SliceRef {}\n \n impl PartialEq for SliceRef {\ndiff --git a/syntax/improper.rs b/syntax/improper.rs\n--- a/syntax/improper.rs\n+++ b/syntax/improper.rs\n@@ -32,6 +32,7 @@ impl<'a> Types<'a> {\n                 Definite(false)\n             }\n             Type::Ref(ty) => self.determine_improper_ctype(&ty.inner),\n+            Type::Ptr(ty) => self.determine_improper_ctype(&ty.inner),\n             Type::Array(ty) => self.determine_improper_ctype(&ty.inner),\n         }\n     }\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -204,6 +204,7 @@ pub enum Type {\n     SharedPtr(Box<Ty1>),\n     WeakPtr(Box<Ty1>),\n     Ref(Box<Ref>),\n+    Ptr(Box<Ptr>),\n     Str(Box<Ref>),\n     CxxVector(Box<Ty1>),\n     Fn(Box<Signature>),\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -229,6 +230,14 @@ pub struct Ref {\n     pub mutability: Option<Token![mut]>,\n }\n \n+pub struct Ptr {\n+    pub star: Token![*],\n+    pub mutable: bool,\n+    pub inner: Type,\n+    pub mutability: Option<Token![mut]>,\n+    pub constness: Option<Token![const]>,\n+}\n+\n pub struct SliceRef {\n     pub ampersand: Token![&],\n     pub lifetime: Option<Lifetime>,\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -11,7 +11,7 @@ use crate::syntax::{\n use proc_macro2::{Delimiter, Group, Span, TokenStream, TokenTree};\n use quote::{format_ident, quote, quote_spanned};\n use std::mem;\n-use syn::parse::{ParseStream, Parser};\n+use syn::{TypePtr, parse::{ParseStream, Parser}};\n use syn::punctuated::Punctuated;\n use syn::{\n     Abi, Attribute, Error, Expr, Fields, FnArg, ForeignItem, ForeignItemFn, ForeignItemType,\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -21,6 +21,8 @@ use syn::{\n     TypeReference, Variant as RustVariant, Visibility,\n };\n \n+use super::Ptr;\n+\n pub mod kw {\n     syn::custom_keyword!(Pin);\n     syn::custom_keyword!(Result);\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -547,6 +549,7 @@ fn parse_extern_fn(\n         ));\n     }\n \n+    let unsafety = foreign_fn.sig.unsafety;\n     let mut receiver = None;\n     let mut args = Punctuated::new();\n     for arg in foreign_fn.sig.inputs.pairs() {\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -583,6 +586,11 @@ fn parse_extern_fn(\n                     let attrs = OtherAttrs::none();\n                     let visibility = Token![pub](ident.span());\n                     let name = pair(Namespace::default(), &ident, None, None);\n+                    if let Type::Ptr(_) = &ty {\n+                        if unsafety.is_none() {\n+                            return Err(Error::new_spanned(arg, \"pointer argument requires that the function be marked unsafe\"));\n+                        }\n+                    }\n                     args.push_value(Var {\n                         doc,\n                         attrs,\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -966,6 +974,7 @@ fn parse_impl(imp: ItemImpl) -> Result<Api> {\n         },\n         Type::Ident(_)\n         | Type::Ref(_)\n+        | Type::Ptr(_)\n         | Type::Str(_)\n         | Type::Fn(_)\n         | Type::Void(_)\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -1034,6 +1043,7 @@ fn parse_include(input: ParseStream) -> Result<Include> {\n fn parse_type(ty: &RustType) -> Result<Type> {\n     match ty {\n         RustType::Reference(ty) => parse_type_reference(ty),\n+        RustType::Ptr(ty) => parse_type_ptr(ty),\n         RustType::Path(ty) => parse_type_path(ty),\n         RustType::Array(ty) => parse_type_array(ty),\n         RustType::BareFn(ty) => parse_type_fn(ty),\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -1085,6 +1095,26 @@ fn parse_type_reference(ty: &TypeReference) -> Result<Type> {\n     })))\n }\n \n+fn parse_type_ptr(ty: &TypePtr) -> Result<Type> {\n+    let star = ty.star_token;\n+    let mutable = ty.mutability.is_some();\n+    let constness = ty.const_token;\n+    let mutability = ty.mutability;\n+    if !constness.is_some() && !mutable {\n+        return Err(Error::new_spanned(ty, \"pointer is neither const nor mut\"));\n+    }\n+\n+    let inner = parse_type(&ty.elem)?;\n+    \n+    Ok(Type::Ptr(Box::new(Ptr {\n+        star,\n+        mutable,\n+        inner,\n+        mutability,\n+        constness,\n+    })))\n+}\n+\n fn parse_type_path(ty: &TypePath) -> Result<Type> {\n     let path = &ty.path;\n     if ty.qself.is_none() && path.leading_colon.is_none() && path.segments.len() == 1 {\ndiff --git a/syntax/pod.rs b/syntax/pod.rs\n--- a/syntax/pod.rs\n+++ b/syntax/pod.rs\n@@ -29,7 +29,7 @@ impl<'a> Types<'a> {\n             | Type::WeakPtr(_)\n             | Type::CxxVector(_)\n             | Type::Void(_) => false,\n-            Type::Ref(_) | Type::Str(_) | Type::Fn(_) | Type::SliceRef(_) => true,\n+            Type::Ref(_) | Type::Str(_) | Type::Fn(_) | Type::SliceRef(_) | Type::Ptr(_) => true,\n             Type::Array(array) => self.is_guaranteed_pod(&array.inner),\n         }\n     }\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -7,6 +7,8 @@ use proc_macro2::{Ident, Span, TokenStream};\n use quote::{quote_spanned, ToTokens};\n use syn::{token, Token};\n \n+use super::Ptr;\n+\n impl ToTokens for Type {\n     fn to_tokens(&self, tokens: &mut TokenStream) {\n         match self {\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -27,6 +29,7 @@ impl ToTokens for Type {\n             | Type::CxxVector(ty)\n             | Type::RustVec(ty) => ty.to_tokens(tokens),\n             Type::Ref(r) | Type::Str(r) => r.to_tokens(tokens),\n+            Type::Ptr(p) => p.to_tokens(tokens),\n             Type::Array(a) => a.to_tokens(tokens),\n             Type::Fn(f) => f.to_tokens(tokens),\n             Type::Void(span) => tokens.extend(quote_spanned!(*span=> ())),\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -100,6 +103,22 @@ impl ToTokens for Ref {\n     }\n }\n \n+impl ToTokens for Ptr {\n+    fn to_tokens(&self, tokens: &mut TokenStream) {\n+        let Ptr {\n+            star,\n+            mutable: _,\n+            inner,\n+            mutability,\n+            constness,\n+        } = self;\n+        star.to_tokens(tokens);\n+        mutability.to_tokens(tokens);\n+        constness.to_tokens(tokens);\n+        inner.to_tokens(tokens);\n+    }\n+}\n+\n impl ToTokens for SliceRef {\n     fn to_tokens(&self, tokens: &mut TokenStream) {\n         let SliceRef {\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -51,6 +51,7 @@ impl<'a> Types<'a> {\n                 | Type::CxxVector(ty)\n                 | Type::RustVec(ty) => visit(all, &ty.inner),\n                 Type::Ref(r) => visit(all, &r.inner),\n+                Type::Ptr(p) => visit(all, &p.inner),\n                 Type::Array(a) => visit(all, &a.inner),\n                 Type::SliceRef(s) => visit(all, &s.inner),\n                 Type::Fn(f) => {\n",
        "test_patch": "diff --git /dev/null b/book/src/binding/raw_ptr.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/binding/raw_ptr.md\n@@ -0,0 +1,68 @@\n+{{#title *mut T, *const T \u2014 Rust \u2661 C++}}\n+# *mut T, *const T - Raw Pointers\n+\n+cxx supports tranfer of raw pointers across the FFI boundary.\n+\n+Generally, it's better to use the bindings for [std::unique_ptr\\<T\\>](uniqueptr.md)\n+or references. You should resort to using raw pointers only where lifetimes\n+are too complicated to model with standard cxx facilities.\n+\n+As is normal with raw pointers in Rust, you'll need to use `unsafe` when\n+working with them. In particular, to pass any raw pointer into a cxx\n+bridge function you will need to declare the function `unsafe`, even if\n+the overall `extern \"C++\"` section is already marked as `unsafe`. By calling\n+such a function, you're committing that you - the human - know enough about\n+the lifetimes of those objects that the compiler doesn't need to do checks.\n+\n+On the other hand, C++ functions can freely return raw pointers to\n+Rust without `unsafe`, but actually using those raw pointers in any way is likely\n+to require an `unsafe` keyword.\n+\n+## Example\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+\n+        include!(\"tests/ffi/tests.h\");\n+        //include!(\"example/include/container.h\");\n+\n+        type ComplexHierarchicContainer;\n+\n+        fn new_hierarchic_container() -> UniquePtr<ComplexHierarchicContainer>;\n+        fn add_value(self: Pin<&mut ComplexHierarchicContainer>, key: &CxxString, value: &CxxString);\n+        fn add_child(self: Pin<&mut ComplexHierarchicContainer>, key: &CxxString) -> *mut ComplexHierarchicContainer;\n+        // ...\n+    }\n+}\n+\n+fn main() {\n+    let mut container = ffi17::new_hierarchic_container();\n+    cxx::let_cxx_string!(key = \"a\");\n+    let mut subcontainer = container.pin_mut().add_child(&key);\n+    let mut subcontainer = unsafe { std::pin::Pin::new_unchecked(subcontainer.as_mut().unwrap()) };\n+    cxx::let_cxx_string!(key2 = \"b\");\n+    cxx::let_cxx_string!(value = \"c\");\n+    subcontainer.add_value(&key2, &value);\n+    // ...\n+}\n+```\n+\n+```cpp\n+// include/container.h\n+\n+#pragma once\n+\n+class ComplexHierarchicContainer {\n+public:\n+    ComplexHierarchicContainer();\n+    void add_value(const std::string& key, const std::string& value);\n+    ComplexHierarchicContainer* add_child(const std::string& key);\n+    // ...\n+};\n+\n+std::unique_ptr<ComplexHierarchicContainer> new_hierarchic_container();\n+```\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -121,6 +121,8 @@ pub mod ffi {\n         fn c_return_nested_ns_ref(shared: &ABShared) -> &usize;\n         fn c_return_ns_enum(n: u16) -> AEnum;\n         fn c_return_nested_ns_enum(n: u16) -> ABEnum;\n+        fn c_return_opaque_raw_ptr(n: usize) -> *const C;\n+        fn c_return_opaque_mut_raw_ptr(n: usize) -> *mut C;\n \n         fn c_take_primitive(n: usize);\n         fn c_take_shared(shared: Shared);\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -161,6 +163,12 @@ pub mod ffi {\n         fn c_take_nested_ns_shared(shared: ABShared);\n         fn c_take_rust_vec_ns_shared(v: Vec<AShared>);\n         fn c_take_rust_vec_nested_ns_shared(v: Vec<ABShared>);\n+        /// # Unsafety\n+        /// To keep clippy happy.\n+        unsafe fn c_take_opaque_mut_raw_ptr(c: *mut C) -> usize;\n+        /// # Unsafety\n+        /// To keep clippy happy.\n+        unsafe fn c_take_opaque_raw_ptr(c: *const C) -> usize;\n \n         fn c_try_return_void() -> Result<()>;\n         fn c_try_return_primitive() -> Result<usize>;\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -207,6 +207,24 @@ ::A::B::ABEnum c_return_nested_ns_enum(uint16_t n) {\n   }\n }\n \n+const C* c_return_opaque_raw_ptr(size_t c) {\n+  return new C(c);\n+}\n+\n+C* c_return_opaque_mut_raw_ptr(size_t c) {\n+  return new C(c);\n+}\n+\n+size_t c_take_opaque_raw_ptr(const C* c) {\n+  return c->get();\n+}\n+\n+size_t c_take_opaque_mut_raw_ptr(C* c) {\n+  size_t result = c->get();\n+  delete c;\n+  return result;\n+}\n+\n Borrow::Borrow(const std::string &s) : s(s) {}\n \n void Borrow::const_member() const {}\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -118,6 +118,8 @@ Enum c_return_enum(uint16_t n);\n ::A::AEnum c_return_ns_enum(uint16_t n);\n ::A::B::ABEnum c_return_nested_ns_enum(uint16_t n);\n std::unique_ptr<Borrow> c_return_borrow(const std::string &s);\n+const C* c_return_opaque_raw_ptr(size_t n);\n+C* c_return_opaque_mut_raw_ptr(size_t n);\n \n void c_take_primitive(size_t n);\n void c_take_shared(Shared shared);\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -161,6 +163,8 @@ void c_take_callback(rust::Fn<size_t(rust::String)> callback);\n void c_take_enum(Enum e);\n void c_take_ns_enum(::A::AEnum e);\n void c_take_nested_ns_enum(::A::B::ABEnum e);\n+size_t c_take_opaque_raw_ptr(const C* c);\n+size_t c_take_opaque_mut_raw_ptr(C* c);\n \n void c_try_return_void();\n size_t c_try_return_primitive();\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -335,3 +335,19 @@ fn test_extern_opaque() {\n     check!(ffi2::c_take_opaque_ns_ref(f.as_ref().unwrap()));\n     check!(ffi2::c_take_opaque_ns_ptr(f));\n }\n+\n+#[test]\n+fn test_raw_ptr() {\n+    let c = ffi::c_return_opaque_mut_raw_ptr(2023);\n+    let mut c_unique = unsafe { cxx::UniquePtr::from_raw(c) };\n+    assert_eq!(2023, c_unique.pin_mut().set_succeed(2023).unwrap());\n+    // c will be dropped as it's now in a UniquePtr\n+\n+    let c2 = ffi::c_return_opaque_mut_raw_ptr(2024);\n+    assert_eq!(2024, unsafe { ffi::c_take_opaque_raw_ptr(c2) });\n+    assert_eq!(2024, unsafe { ffi::c_take_opaque_mut_raw_ptr(c2) }); // deletes c2\n+\n+    let c3 = ffi::c_return_opaque_raw_ptr(2025);\n+    assert_eq!(2025, unsafe { ffi::c_take_opaque_raw_ptr(c3) });\n+    assert_eq!(2025, unsafe { ffi::c_take_opaque_mut_raw_ptr(c3 as *mut ffi::C) }); // deletes c3\n+}\n\\ No newline at end of file\ndiff --git /dev/null b/tests/ui/unsupported_ptr.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/unsupported_ptr.rs\n@@ -0,0 +1,40 @@\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+        type C;\n+\n+        fn not_unsafe_ptr(c: *mut C);\n+    }\n+}\n+\n+#[cxx::bridge]\n+mod ffi2 {\n+    unsafe extern \"C++\" {\n+        type C;\n+\n+        fn get_neither_const_nor_mut() -> *C;\n+    }\n+}\n+\n+#[cxx::bridge]\n+mod ffi3 {\n+    unsafe extern \"C++\" {\n+        type C;\n+\n+        fn get_ptr_ptr() -> *mut *mut C;\n+        fn get_ptr_reference() -> *mut & C;\n+        fn get_reference_ptr() -> & *mut C;\n+    }\n+}\n+\n+#[cxx::bridge]\n+mod ffi4 {\n+    unsafe extern \"C++\" {\n+        type C;\n+\n+        fn get_ptr_vector() -> UniquePtr<CxxVector<*mut C>>;\n+        fn get_ptr_unique() -> UniquePtr<*mut C>;\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/unsupported_ptr.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/unsupported_ptr.stderr\n@@ -0,0 +1,49 @@\n+error: expected mut or const in raw pointer type\n+  --> $DIR/unsupported_ptr.rs:15:43\n+   |\n+15 |         fn get_neither_const_nor_mut() -> *C;\n+   |                                           ^ expected mut or const in raw pointer type\n+   |\n+   = help: use `*mut T` or `*const T` as appropriate\n+\n+error: pointer argument requires that the function be marked unsafe\n+ --> $DIR/unsupported_ptr.rs:6:27\n+  |\n+6 |         fn not_unsafe_ptr(c: *mut C);\n+  |                           ^^^^^^^^^\n+\n+error: expected `const` or `mut`\n+  --> $DIR/unsupported_ptr.rs:15:44\n+   |\n+15 |         fn get_neither_const_nor_mut() -> *C;\n+   |                                            ^\n+\n+error: unsupported pointer type\n+  --> $DIR/unsupported_ptr.rs:24:29\n+   |\n+24 |         fn get_ptr_ptr() -> *mut *mut C;\n+   |                             ^^^^^^^^^^^\n+\n+error: unsupported pointer type\n+  --> $DIR/unsupported_ptr.rs:25:35\n+   |\n+25 |         fn get_ptr_reference() -> *mut & C;\n+   |                                   ^^^^^^^^\n+\n+error: unsupported reference type\n+  --> $DIR/unsupported_ptr.rs:26:35\n+   |\n+26 |         fn get_reference_ptr() -> & *mut C;\n+   |                                   ^^^^^^^^\n+\n+error: unsupported vector target type\n+  --> $DIR/unsupported_ptr.rs:35:42\n+   |\n+35 |         fn get_ptr_vector() -> UniquePtr<CxxVector<*mut C>>;\n+   |                                          ^^^^^^^^^^^^^^^^^^\n+\n+error: unsupported unique_ptr target type\n+  --> $DIR/unsupported_ptr.rs:36:32\n+   |\n+36 |         fn get_ptr_unique() -> UniquePtr<*mut C>;\n+   |                                ^^^^^^^^^^^^^^^^^\n",
        "problem_statement": "Allow raw pointers in extern fn signature\nSee https://github.com/dtolnay/cxx/issues/122#issuecomment-615372359 for the rationale.\r\n\r\n```rust\r\nmod ffi {\r\n    extern \"C\" {\r\n        type T;\r\n        unsafe fn f(_: *mut T);\r\n    }\r\n    extern \"Rust\" {\r\n        unsafe fn g(_: *mut T);\r\n    }\r\n}\r\n```\r\n\r\nThe presence of `*const` or `*mut` in a function argument should enforce that the function is marked unsafe.\n",
        "hints_text": "*Function pointers* need to get the same check too. A function pointer type that has a raw pointer argument should be required to be specified as unsafe.\r\n\r\n```rust\r\nextern \"Rust\" {\r\n    fn g(callback: unsafe fn(*mut T));\r\n}\r\n```\nIn contrast to argument position, a pointer in return position should *not* enforce that the function is unsafe. #283\r\n\r\n```rust\r\nextern \"C++\" {\r\n    type socc_examples_fixture;\r\n    type SDIDevicePropInfoDataset;\r\n\r\n    fn wait_for_IsEnable(\r\n        self: &mut socc_examples_fixture,\r\n        code: u16,\r\n        expect: u16,\r\n        retry_count: i32,\r\n    ) -> *mut SDIDevicePropInfoDataset;\r\n}\r\n```\nI am trying to call the following function found in `node.h` from Node.js\r\n```\r\n// Set up per-process state needed to run Node.js. This will consume arguments\r\n// from argv, fill exec_argv, and possibly add errors resulting from parsing\r\n// the arguments to `errors`. The return value is a suggested exit code for the\r\n// program; If it is 0, then initializing Node.js succeeded.\r\nNODE_EXTERN int InitializeNodeWithArgs(std::vector<std::string>* argv,\r\n                                       std::vector<std::string>* exec_argv,\r\n                                       std::vector<std::string>* errors);\r\n```\r\n\r\nGiven the `std::vector<std::string>* ...` arguments, I assume this falls into the problemspace for this issue?\r\n\r\nIs there a workaround I could try?\r\n\r\nMy code currently looks like this:\r\n```\r\n#[cxx::bridge(namespace = \"node\")]\r\nmod ffi {\r\n\r\n    extern \"C\" {\r\n        include!(\"node.h\");\r\n\r\n        fn InitializeNodeWithArgs(\r\n            args: *const CxxVector<CxxString>,\r\n            exec_args: *const CxxVector<CxxString>,\r\n            errors: *const CxxVector<CxxString>,\r\n        ) -> i32;\r\n    }\r\n}\r\n```\nThis is likely to be the next thing I look into adding. I haven't started yet. If anyone else thinks they'll do something in this area, please let me know so we can avoid duplication.",
        "created_at": "2021-01-23T19:35:59Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 688,
        "instance_id": "dtolnay__cxx-688",
        "issue_numbers": [
            "578"
        ],
        "base_commit": "2029c873c2733846e47516d540ae9ff525e0abfe",
        "patch": "diff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -389,6 +389,8 @@ fn check_api_fn(cx: &mut Check, efn: &ExternFn) {\n                 mutability = mutability,\n             );\n             cx.error(span, msg);\n+        } else if cx.types.enums.contains_key(&receiver.ty.rust) {\n+            cx.error(span, \"C++ does not allow member functions on enums\");\n         } else if !cx.types.structs.contains_key(&receiver.ty.rust)\n             && !cx.types.cxx.contains(&receiver.ty.rust)\n             && !cx.types.rust.contains(&receiver.ty.rust)\n",
        "test_patch": "diff --git /dev/null b/tests/ui/enum_receiver.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/enum_receiver.rs\n@@ -0,0 +1,11 @@\n+#[cxx::bridge]\n+mod ffi {\n+    enum Enum {\n+        Variant,\n+    }\n+    extern \"Rust\" {\n+        fn f(self: &Enum);\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/enum_receiver.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/enum_receiver.stderr\n@@ -0,0 +1,5 @@\n+error: C++ does not allow member functions on enums\n+ --> $DIR/enum_receiver.rs:7:20\n+  |\n+7 |         fn f(self: &Enum);\n+  |                    ^^^^^\n",
        "problem_statement": "Improve error message on enum used as method receiver\n```console\r\nerror[cxxbridge]: unrecognized receiver type\r\n  \u250c\u2500 /dev/stdin:1:66\r\n  \u2502\r\n1 \u2502 #[cxx::bridge] mod ffi { enum Enum {} extern \"Rust\" { fn f(self: &Enum); }}\r\n  \u2502                                                                  ^^^^^ unrecognized receiver type\r\n```\r\n\r\nThis needs to give some indication that member functions are not allowed by C++ on enums.\n",
        "hints_text": "",
        "created_at": "2021-01-20T21:16:11Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 828,
        "instance_id": "dtolnay__cxx-828",
        "issue_numbers": [
            "739"
        ],
        "base_commit": "7afede83fed580f3cae9a065b28ec8eaffae7a7e",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -14,7 +14,7 @@ use crate::{derive, generics};\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote, quote_spanned, ToTokens};\n use std::mem;\n-use syn::{parse_quote, punctuated, Lifetime, Result, Token};\n+use syn::{parse_quote, punctuated, Generics, Lifetime, Result, Token};\n \n pub fn bridge(mut ffi: Module) -> Result<TokenStream> {\n     let ref mut errors = Errors::new();\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -760,6 +760,7 @@ fn expand_function_pointer_trampoline(\n         local_name,\n         catch_unwind_label,\n         None,\n+        Some(&efn.generics),\n         body_span,\n     );\n     let var = &var.rust;\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -901,6 +902,7 @@ fn expand_rust_function_shim(efn: &ExternFn, types: &Types) -> TokenStream {\n         local_name,\n         catch_unwind_label,\n         invoke,\n+        None,\n         body_span,\n     )\n }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -912,9 +914,10 @@ fn expand_rust_function_shim_impl(\n     local_name: Ident,\n     catch_unwind_label: String,\n     invoke: Option<&Ident>,\n+    outer_generics: Option<&Generics>,\n     body_span: Span,\n ) -> TokenStream {\n-    let generics = &sig.generics;\n+    let generics = outer_generics.unwrap_or(&sig.generics);\n     let receiver_var = sig\n         .receiver\n         .as_ref()\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -158,6 +158,8 @@ pub mod ffi {\n         fn c_take_ref_shared_string(s: &SharedString) -> &SharedString;\n         fn c_take_callback(callback: fn(String) -> usize);\n         fn c_take_callback_ref(callback: fn(&String));\n+        #[cxx_name = \"c_take_callback_ref\"]\n+        fn c_take_callback_ref_lifetime<'a>(callback: fn(&'a String));\n         fn c_take_callback_mut(callback: fn(&mut String));\n         fn c_take_enum(e: Enum);\n         fn c_take_ns_enum(e: AEnum);\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -219,6 +219,7 @@ fn test_c_callback() {\n \n     check!(ffi::c_take_callback(callback));\n     check!(ffi::c_take_callback_ref(callback_ref));\n+    check!(ffi::c_take_callback_ref_lifetime(callback_ref));\n     check!(ffi::c_take_callback_mut(callback_mut));\n }\n \n",
        "problem_statement": "Undeclared lifetime when function pointer argument contains lifetime from extern signature\nRepro:\r\n\r\n```rust\r\n// src/main.rs\r\n\r\n#[cxx::bridge]\r\nmod ffi {\r\n    unsafe extern \"C++\" {\r\n        include!(\"example/include/header.h\");\r\n\r\n        fn call_back<'a>(i: &'a i32, f: fn(&'a i32));\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let i = 0i32;\r\n    ffi::call_back(&i, |_| {});\r\n}\r\n```\r\n\r\n```cpp\r\n// include/header.h\r\n\r\n#pragma once\r\n#include \"rust/cxx.h\"\r\n\r\ninline void call_back(const int32_t &i, rust::Fn<void(const int32_t &)> f) {\r\n  f(i);\r\n}\r\n```\r\n\r\n```console\r\nerror[E0261]: use of undeclared lifetime name `'a`\r\n --> src/main.rs:6:45\r\n  |\r\n1 | #[cxx::bridge]\r\n  |               - lifetime `'a` is missing in item created through this procedural macro\r\n...\r\n6 |         fn call_back<'a>(i: &'a i32, f: fn(&'a i32));\r\n  |                                             ^^ undeclared lifetime\r\n  |\r\n  = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\r\n  = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\r\nhelp: consider making the type lifetime-generic with a new `'a` lifetime\r\n  |\r\n6 |         fn call_back<'a>(i: &'a i32, f: for<'a> fn(&'a i32));\r\n  |                                         ^^^^^^^\r\n```\n",
        "hints_text": "The code being generated looks like:\r\n\r\n```rust\r\npub fn call_back<'a>(i: &'a i32, f: fn(arg0: &'a i32)) {\r\n    extern \"C\" {\r\n        #[link_name = \"cxxbridge1$call_back\"]\r\n        fn __call_back<'a>(i: &'a i32, f: ::cxx::private::FatFunction);\r\n    }\r\n    let f = ::cxx::private::FatFunction {\r\n        trampoline: {\r\n            extern \"C\" {\r\n                #[link_name = \"cxxbridge1$call_back$f$0\"]\r\n                fn trampoline();\r\n            }\r\n            #[doc(hidden)]\r\n            #[export_name = \"cxxbridge1$call_back$f$1\"]\r\n            unsafe extern \"C\" fn __(arg0: &'a i32, __extern: *const ()) {\r\n                let __fn = \"example::ffi::call_back::f\";\r\n                ::cxx::private::catch_unwind(__fn, move || {\r\n                    ::std::mem::transmute::<*const (), fn(arg0: &'a i32)>(__extern)(arg0)\r\n                })\r\n            }\r\n            trampoline as usize as *const ()\r\n        },\r\n        ptr: f as usize as *const (),\r\n    };\r\n    unsafe { __call_back(i, f) }\r\n}\r\n```\r\n\r\nwhere the bug is that `'a` is undeclared on the line starting with `unsafe extern \"C\" fn`.",
        "created_at": "2021-04-10T22:15:45Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 814,
        "instance_id": "dtolnay__cxx-814",
        "issue_numbers": [
            "738"
        ],
        "base_commit": "ffa979bd186e66b1a9031ef1daff3b4659cd33cc",
        "patch": "diff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -475,7 +475,7 @@ void panic [[noreturn]] (const char *msg);\n #define CXXBRIDGE1_RUST_FN\n template <typename Ret, typename... Args>\n Ret Fn<Ret(Args...)>::operator()(Args... args) const noexcept {\n-  return (*this->trampoline)(std::move(args)..., this->fn);\n+  return (*this->trampoline)(std::forward<Args>(args)..., this->fn);\n }\n \n template <typename Ret, typename... Args>\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -157,6 +157,8 @@ pub mod ffi {\n         fn c_take_ref_rust_vec_copy(v: &Vec<u8>);\n         fn c_take_ref_shared_string(s: &SharedString) -> &SharedString;\n         fn c_take_callback(callback: fn(String) -> usize);\n+        fn c_take_callback_ref(callback: fn(&String));\n+        fn c_take_callback_mut(callback: fn(&mut String));\n         fn c_take_enum(e: Enum);\n         fn c_take_ns_enum(e: AEnum);\n         fn c_take_nested_ns_enum(e: ABEnum);\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -494,6 +494,16 @@ void c_take_callback(rust::Fn<size_t(rust::String)> callback) {\n   callback(\"2020\");\n }\n \n+void c_take_callback_ref(rust::Fn<void(const rust::String &)> callback) {\n+  const rust::String string = \"2020\";\n+  callback(string);\n+}\n+\n+void c_take_callback_mut(rust::Fn<void(rust::String &)> callback) {\n+  rust::String string = \"2020\";\n+  callback(string);\n+}\n+\n void c_take_enum(Enum e) {\n   if (e == Enum::AVal) {\n     cxx_test_suite_set_correct();\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -160,6 +160,8 @@ void c_take_ref_rust_vec_index(const rust::Vec<uint8_t> &v);\n void c_take_ref_rust_vec_copy(const rust::Vec<uint8_t> &v);\n const SharedString &c_take_ref_shared_string(const SharedString &s);\n void c_take_callback(rust::Fn<size_t(rust::String)> callback);\n+void c_take_callback_ref(rust::Fn<void(const rust::String &)> callback);\n+void c_take_callback_mut(rust::Fn<void(rust::String &)> callback);\n void c_take_enum(Enum e);\n void c_take_ns_enum(::A::AEnum e);\n void c_take_nested_ns_enum(::A::B::ABEnum e);\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -204,7 +204,22 @@ fn test_c_callback() {\n         0\n     }\n \n+    #[allow(clippy::ptr_arg)]\n+    fn callback_ref(s: &String) {\n+        if s == \"2020\" {\n+            cxx_test_suite_set_correct();\n+        }\n+    }\n+\n+    fn callback_mut(s: &mut String) {\n+        if s == \"2020\" {\n+            cxx_test_suite_set_correct();\n+        }\n+    }\n+\n     check!(ffi::c_take_callback(callback));\n+    check!(ffi::c_take_callback_ref(callback_ref));\n+    check!(ffi::c_take_callback_mut(callback_mut));\n }\n \n #[test]\n",
        "problem_statement": "rust::Fn call with non-const reference argument fails to compile\nRepro:\r\n\r\n```rust\r\n// src/main.rs\r\n\r\n#[cxx::bridge]\r\nmod ffi {\r\n    unsafe extern \"C++\" {\r\n        include!(\"example/include/header.h\");\r\n\r\n        fn call_back(i: &mut i32, f: fn(&mut i32));\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let mut i = 0i32;\r\n    ffi::call_back(&mut i, |_| {});\r\n}\r\n```\r\n\r\n```cpp\r\n// include/header.h\r\n\r\n#pragma once\r\n#include \"rust/cxx.h\"\r\n\r\ninline void call_back(int32_t &i, rust::Fn<void(int32_t &)> f) {\r\n  f(i);\r\n}\r\n```\r\n\r\nThe build failure is:\r\n\r\n```console\r\nIn file included from example-f8c8c5261613a040/out/cxxbridge/crate/example/include/header.h:2,\r\n                 from example-f8c8c5261613a040/out/cxxbridge/sources/example/src/main.rs.cc:1:\r\nexample-f8c8c5261613a040/out/cxxbridge/include/rust/cxx.h: In instantiation of \u2018Ret rust::cxxbridge1::Fn<Ret(Args ...)>::operator()(Args ...) const [with Ret = void; Args = {int&}]\u2019:\r\nexample-f8c8c5261613a040/out/cxxbridge/crate/example/include/header.h:5:6:   required from here\r\nexample-f8c8c5261613a040/out/cxxbridge/include/rust/cxx.h:478:29: error: cannot bind non-const lvalue reference of type \u2018int&\u2019 to an rvalue of type \u2018std::remove_reference<int&>::type\u2019 {aka \u2018int\u2019}\r\n  478 |   return (*this->trampoline)(std::move(args)..., this->fn);\r\n      |          ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n```\r\n\r\nIt's possible that `std::move` needs to be `std::forward` instead, or something similar.\n",
        "hints_text": "Note that the same thing with const reference arguments does work.\r\n\r\n```diff\r\n-         fn call_back(i: &mut i32, f: fn(&mut i32));\r\n+         fn call_back(i: &i32, f: fn(&i32));\r\n\r\n- inline void call_back(int32_t &i, rust::Fn<void(int32_t &)> f) {\r\n+ inline void call_back(const int32_t &i, rust::Fn<void(const int32_t &)> f) {\r\n```",
        "created_at": "2021-04-09T03:48:23Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 813,
        "instance_id": "dtolnay__cxx-813",
        "issue_numbers": [
            "811"
        ],
        "base_commit": "035d798242263cfd96d551d95688f75009b472c8",
        "patch": "diff --git a/gen/src/check.rs b/gen/src/check.rs\n--- a/gen/src/check.rs\n+++ b/gen/src/check.rs\n@@ -4,7 +4,7 @@ use crate::syntax::{error, Api};\n use quote::{quote, quote_spanned};\n use std::path::{Component, Path};\n \n-pub(super) use crate::syntax::check::typecheck;\n+pub(super) use crate::syntax::check::{typecheck, Generator};\n \n pub(super) fn precheck(cx: &mut Errors, apis: &[Api], opt: &Opt) {\n     if !opt.allow_dot_includes {\ndiff --git a/gen/src/mod.rs b/gen/src/mod.rs\n--- a/gen/src/mod.rs\n+++ b/gen/src/mod.rs\n@@ -130,7 +130,8 @@ pub(super) fn generate(syntax: File, opt: &Opt) -> Result<GeneratedCode> {\n     let ref types = Types::collect(errors, apis);\n     check::precheck(errors, apis, opt);\n     errors.propagate()?;\n-    check::typecheck(errors, apis, types);\n+    let generator = check::Generator::Build;\n+    check::typecheck(errors, apis, types, generator);\n     errors.propagate()?;\n \n     // Some callers may wish to generate both header and implementation from the\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -35,7 +35,8 @@ pub fn bridge(mut ffi: Module) -> Result<TokenStream> {\n     let ref apis = syntax::parse_items(errors, content, trusted, namespace);\n     let ref types = Types::collect(errors, apis);\n     errors.propagate()?;\n-    check::typecheck(errors, apis, types);\n+    let generator = check::Generator::Macro;\n+    check::typecheck(errors, apis, types, generator);\n     errors.propagate()?;\n \n     Ok(expand(ffi, doc, attrs, apis, types))\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -2,24 +2,40 @@ use crate::syntax::atom::Atom::{self, *};\n use crate::syntax::report::Errors;\n use crate::syntax::visit::{self, Visit};\n use crate::syntax::{\n-    error, ident, trivial, Api, Array, Enum, ExternFn, ExternType, Impl, Lang, NamedType, Ptr,\n-    Receiver, Ref, Signature, SliceRef, Struct, Trait, Ty1, Type, TypeAlias, Types,\n+    error, ident, trivial, Api, Array, Enum, ExternFn, ExternType, Impl, Lang, Lifetimes,\n+    NamedType, Ptr, Receiver, Ref, Signature, SliceRef, Struct, Trait, Ty1, Type, TypeAlias, Types,\n };\n use proc_macro2::{Delimiter, Group, Ident, TokenStream};\n use quote::{quote, ToTokens};\n use std::fmt::Display;\n+use syn::{GenericParam, Generics, Lifetime};\n \n pub(crate) struct Check<'a> {\n     apis: &'a [Api],\n     types: &'a Types<'a>,\n     errors: &'a mut Errors,\n+    generator: Generator,\n }\n \n-pub(crate) fn typecheck(cx: &mut Errors, apis: &[Api], types: &Types) {\n+pub(crate) enum Generator {\n+    // cxx-build crate, cxxbridge cli, cxx-gen.\n+    #[allow(dead_code)]\n+    Build,\n+    // cxxbridge-macro. This is relevant in that the macro output is going to\n+    // get fed straight to rustc, so for errors that rustc already contains\n+    // logic to catch (probably with a better diagnostic than what the proc\n+    // macro API is able to produce), we avoid duplicating them in our own\n+    // diagnostics.\n+    #[allow(dead_code)]\n+    Macro,\n+}\n+\n+pub(crate) fn typecheck(cx: &mut Errors, apis: &[Api], types: &Types, generator: Generator) {\n     do_typecheck(&mut Check {\n         apis,\n         types,\n         errors: cx,\n+        generator,\n     });\n }\n \ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -294,6 +310,7 @@ fn check_type_fn(cx: &mut Check, ty: &Signature) {\n fn check_api_struct(cx: &mut Check, strct: &Struct) {\n     let name = &strct.name;\n     check_reserved_name(cx, &name.rust);\n+    check_lifetimes(cx, &strct.generics);\n \n     if strct.fields.is_empty() {\n         let span = span_for_struct_error(strct);\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -330,6 +347,7 @@ fn check_api_struct(cx: &mut Check, strct: &Struct) {\n \n fn check_api_enum(cx: &mut Check, enm: &Enum) {\n     check_reserved_name(cx, &enm.name.rust);\n+    check_lifetimes(cx, &enm.generics);\n \n     if enm.variants.is_empty() && !enm.explicit_repr {\n         let span = span_for_enum_error(enm);\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -349,6 +367,7 @@ fn check_api_enum(cx: &mut Check, enm: &Enum) {\n \n fn check_api_type(cx: &mut Check, ety: &ExternType) {\n     check_reserved_name(cx, &ety.name.rust);\n+    check_lifetimes(cx, &ety.generics);\n \n     for derive in &ety.derives {\n         if derive.what == Trait::ExternType && ety.lang == Lang::Rust {\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -400,6 +419,8 @@ fn check_api_fn(cx: &mut Check, efn: &ExternFn) {\n         }\n     }\n \n+    check_generics(cx, &efn.sig.generics);\n+\n     if let Some(receiver) = &efn.receiver {\n         let ref span = span_for_receiver_error(receiver);\n \ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -472,6 +493,8 @@ fn check_api_fn(cx: &mut Check, efn: &ExternFn) {\n }\n \n fn check_api_type_alias(cx: &mut Check, alias: &TypeAlias) {\n+    check_lifetimes(cx, &alias.generics);\n+\n     for derive in &alias.derives {\n         let msg = format!(\"derive({}) on extern type alias is not supported\", derive);\n         cx.error(derive, msg);\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -481,6 +504,8 @@ fn check_api_type_alias(cx: &mut Check, alias: &TypeAlias) {\n fn check_api_impl(cx: &mut Check, imp: &Impl) {\n     let ty = &imp.ty;\n \n+    check_lifetimes(cx, &imp.impl_generics);\n+\n     if let Some(negative) = imp.negative_token {\n         let span = quote!(#negative #ty);\n         cx.error(span, \"negative impl is not supported yet\");\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -583,6 +608,31 @@ fn check_reserved_name(cx: &mut Check, ident: &Ident) {\n     }\n }\n \n+fn check_reserved_lifetime(cx: &mut Check, lifetime: &Lifetime) {\n+    if lifetime.ident == \"static\" {\n+        match cx.generator {\n+            Generator::Macro => { /* rustc already reports this */ }\n+            Generator::Build => {\n+                cx.error(lifetime, error::RESERVED_LIFETIME);\n+            }\n+        }\n+    }\n+}\n+\n+fn check_lifetimes(cx: &mut Check, generics: &Lifetimes) {\n+    for lifetime in &generics.lifetimes {\n+        check_reserved_lifetime(cx, lifetime);\n+    }\n+}\n+\n+fn check_generics(cx: &mut Check, generics: &Generics) {\n+    for generic_param in &generics.params {\n+        if let GenericParam::Lifetime(def) = generic_param {\n+            check_reserved_lifetime(cx, &def.lifetime);\n+        }\n+    }\n+}\n+\n fn is_unsized(cx: &mut Check, ty: &Type) -> bool {\n     match ty {\n         Type::Ident(ident) => {\ndiff --git a/syntax/error.rs b/syntax/error.rs\n--- a/syntax/error.rs\n+++ b/syntax/error.rs\n@@ -21,6 +21,7 @@ pub static ERRORS: &[Error] = &[\n     DISCRIMINANT_OVERFLOW,\n     DOT_INCLUDE,\n     DOUBLE_UNDERSCORE,\n+    RESERVED_LIFETIME,\n     RUST_TYPE_BY_VALUE,\n     UNSUPPORTED_TYPE,\n     USE_NOT_ALLOWED,\ndiff --git a/syntax/error.rs b/syntax/error.rs\n--- a/syntax/error.rs\n+++ b/syntax/error.rs\n@@ -68,6 +69,12 @@ pub static DOUBLE_UNDERSCORE: Error = Error {\n     note: Some(\"identifiers containing double underscore are reserved in C++\"),\n };\n \n+pub static RESERVED_LIFETIME: Error = Error {\n+    msg: \"invalid lifetime parameter name: `'static`\",\n+    label: Some(\"'static is a reserved lifetime name\"),\n+    note: None,\n+};\n+\n pub static RUST_TYPE_BY_VALUE: Error = Error {\n     msg: \"opaque Rust type by value is not supported\",\n     label: None,\n",
        "test_patch": "diff --git /dev/null b/tests/ui/reserved_lifetime.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/reserved_lifetime.rs\n@@ -0,0 +1,10 @@\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+        type Logger;\n+\n+        fn logger<'static>() -> Pin<&'static Logger>;\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/reserved_lifetime.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/reserved_lifetime.stderr\n@@ -0,0 +1,5 @@\n+error[E0262]: invalid lifetime parameter name: `'static`\n+ --> $DIR/reserved_lifetime.rs:6:19\n+  |\n+6 |         fn logger<'static>() -> Pin<&'static Logger>;\n+  |                   ^^^^^^^ 'static is a reserved lifetime name\n",
        "problem_statement": "Diagnostic for invalid use of 'static as a lifetime parameter name\nAs observed in https://github.com/dtolnay/cxx/pull/779#issuecomment-815027747 -- `'static` is not supposed to be a name that you can give to a lifetime parameter. Rustc catches this anyway later in the compilation as a reserved lifetime name, but for our C++ code generator prior to rustc getting invoked, it would be good to add a dedicated diagnostic too catch this there too.\r\n\r\n```rust\r\nuse std::pin::Pin;\r\n\r\nstruct Logger {}\r\n\r\nfn logger<'static>() -> Pin<&'static mut Logger> {\r\n    unimplemented!()\r\n}\r\n```\r\n\r\n```console\r\nerror[E0262]: invalid lifetime parameter name: `'static`\r\n --> src/main.rs:5:11\r\n  |\r\n5 | fn logger<'static>() -> Pin<&'static mut Logger> {\r\n  |           ^^^^^^^ 'static is a reserved lifetime name\r\n```\n",
        "hints_text": "",
        "created_at": "2021-04-09T03:10:35Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 806,
        "instance_id": "dtolnay__cxx-806",
        "issue_numbers": [
            "805"
        ],
        "base_commit": "756b5b64f09525ccec07ba512a7e53e3419ad8f8",
        "patch": "diff --git a/macro/src/generics.rs b/macro/src/generics.rs\n--- a/macro/src/generics.rs\n+++ b/macro/src/generics.rs\n@@ -3,6 +3,7 @@ use crate::syntax::resolve::Resolution;\n use crate::syntax::Impl;\n use proc_macro2::TokenStream;\n use quote::ToTokens;\n+use syn::Token;\n \n pub struct ImplGenerics<'a> {\n     explicit_impl: Option<&'a Impl>,\ndiff --git a/macro/src/generics.rs b/macro/src/generics.rs\n--- a/macro/src/generics.rs\n+++ b/macro/src/generics.rs\n@@ -46,10 +47,17 @@ impl<'a> ToTokens for TyGenerics<'a> {\n     fn to_tokens(&self, tokens: &mut TokenStream) {\n         if let Some(imp) = self.explicit_impl {\n             imp.ty_generics.to_tokens(tokens);\n-        } else {\n-            self.key.lt_token.to_tokens(tokens);\n+        } else if !self.resolve.generics.lifetimes.is_empty() {\n+            let span = self.key.rust.span();\n+            self.key\n+                .lt_token\n+                .unwrap_or_else(|| Token![<](span))\n+                .to_tokens(tokens);\n             self.resolve.generics.lifetimes.to_tokens(tokens);\n-            self.key.gt_token.to_tokens(tokens);\n+            self.key\n+                .gt_token\n+                .unwrap_or_else(|| Token![>](span))\n+                .to_tokens(tokens);\n         }\n     }\n }\n",
        "test_patch": "diff --git /dev/null b/tests/ui/expected_named.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/expected_named.rs\n@@ -0,0 +1,9 @@\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+        type Borrowed<'a>;\n+        fn borrowed() -> UniquePtr<Borrowed>;\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/expected_named.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/expected_named.stderr\n@@ -0,0 +1,11 @@\n+error[E0106]: missing lifetime specifier\n+ --> $DIR/expected_named.rs:5:36\n+  |\n+5 |         fn borrowed() -> UniquePtr<Borrowed>;\n+  |                                    ^^^^^^^^ expected named lifetime parameter\n+  |\n+  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+  |\n+5 |         fn borrowed() -> UniquePtr<Borrowed<'static>>;\n+  |                                    ^^^^^^^^^^^^^^^^^\n",
        "problem_statement": "Fails to compile unique ptr containing C++ type with lifetime that is elided\n```cpp\r\n// include/header.h\r\n\r\n#pragma once\r\n#include <memory>\r\n#include <string>\r\n\r\nstruct Borrowed {};\r\nstd::unique_ptr<Borrowed> f(const std::string &x);\r\n```\r\n\r\n```rust\r\n// src/lib.rs\r\n\r\n#[cxx::bridge]\r\nmod ffi {\r\n    unsafe extern \"C++\" {\r\n        include!(\"example/include/example.h\");\r\n        type Borrowed<'a>;\r\n        fn f(x: &CxxString) -> UniquePtr<Borrowed>;\r\n    }\r\n}\r\n```\r\n\r\n```console\r\nerror: expected one of `!`, `(`, `+`, `::`, `<`, `where`, or `{`, found `'a`\r\n --> src/lib.rs:5:23\r\n  |\r\n5 |         type Borrowed<'a>;\r\n  |                       ^^ unexpected token\r\n6 |         fn f(x: &CxxString) -> UniquePtr<Borrowed>;\r\n  |                                                  - expected one of 7 possible tokens\r\n```\r\n\r\nThe generated code contains a chunk that looks like `unsafe impl < 'a > :: cxx :: private :: UniquePtrTarget for Borrowed 'a { /*...*/ }`, which is not valid Rust syntax.\r\n\r\nThis is a regression in 1.0.39.\n",
        "hints_text": "",
        "created_at": "2021-04-02T05:25:27Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 800,
        "instance_id": "dtolnay__cxx-800",
        "issue_numbers": [
            "799"
        ],
        "base_commit": "f72dfb9fdf18c3feb9be5f36d9189e9c31cb9682",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -619,7 +619,11 @@ fn expand_cxx_function_shim(efn: &ExternFn, types: &Types) -> TokenStream {\n                     },\n                     inner if types.is_considered_improper_ctype(inner) => {\n                         let mutability = ty.mutability;\n-                        quote!(&#mutability *#call.cast())\n+                        let deref_mut = quote!(&#mutability *#call.cast());\n+                        match ty.pinned {\n+                            false => deref_mut,\n+                            true => quote!(::std::pin::Pin::new_unchecked(#deref_mut)),\n+                        }\n                     }\n                     _ => call,\n                 },\n",
        "test_patch": "diff --git a/tests/ffi/module.rs b/tests/ffi/module.rs\n--- a/tests/ffi/module.rs\n+++ b/tests/ffi/module.rs\n@@ -52,6 +52,7 @@ pub mod ffi2 {\n         fn c_return_trivial_ns_ptr() -> UniquePtr<G>;\n         fn c_return_trivial_ns() -> G;\n         fn c_return_opaque_ptr() -> UniquePtr<E>;\n+        fn c_return_opaque_mut_pin(e: Pin<&mut E>) -> Pin<&mut E>;\n         fn c_return_ns_opaque_ptr() -> UniquePtr<F>;\n         fn c_return_ns_unique_ptr() -> UniquePtr<H>;\n         fn c_take_ref_ns_c(h: &H);\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -713,6 +713,8 @@ std::unique_ptr<E> c_return_opaque_ptr() {\n   return e;\n }\n \n+E &c_return_opaque_mut_pin(E &e) { return e; }\n+\n std::unique_ptr<::F::F> c_return_ns_opaque_ptr() {\n   auto f = std::unique_ptr<::F::F>(new ::F::F());\n   f->f = 40;\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -201,6 +201,7 @@ D c_return_trivial();\n std::unique_ptr<::G::G> c_return_trivial_ns_ptr();\n ::G::G c_return_trivial_ns();\n std::unique_ptr<E> c_return_opaque_ptr();\n+E &c_return_opaque_mut_pin(E &e);\n std::unique_ptr<::F::F> c_return_ns_opaque_ptr();\n \n rust::String cOverloadedFunction(int32_t x);\n",
        "problem_statement": "Regression in 1.0.40 handling of extern C++ return reference types\nWith 1.0.40, this code:\r\n\r\n```rust\r\n    unsafe extern \"C++\" {\r\n        include!(\"rpmostree-clientlib.h\");\r\n        fn client_require_root() -> Result<()>;\r\n        type ClientConnection;\r\n        fn new_client_connection() -> Result<UniquePtr<ClientConnection>>;\r\n        fn get_connection<'a>(self: Pin<&'a mut ClientConnection>) -> Pin<&'a mut GDBusConnection>;\r\n        fn transaction_connect_progress_sync(&self, address: &str) -> Result<()>;\r\n    }\r\n```\r\n\r\nno longer compiles:\r\n\r\n```\r\nerror[E0308]: mismatched types\r\n   --> rust/src/lib.rs:26:1\r\n    |\r\n26  | #[cxx::bridge(namespace = \"rpmostreecxx\")]\r\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Pin`, found `&mut _`\r\n...\r\n381 |         fn get_connection<'a>(self: Pin<&'a mut ClientConnection>) -> Pin<&'a mut GDBusConnection>;\r\n    |                                                                       ---------------------------- expected `Pin<&'a mut cxxrsutil::FFIGDBusConnection>` because of return type\r\n    |\r\n    = note:         expected struct `Pin<&'a mut cxxrsutil::FFIGDBusConnection>`\r\n            found mutable reference `&mut _`\r\n    = note: this error originates in an attribute macro (in Nightly builds, run with -Z macro-backtrace for more info)\r\n\r\nerror: aborting due to previous error\r\n\r\n```\r\n\r\n(Associated C++ code is here: https://github.com/coreos/rpm-ostree/blob/bef1fc792655e6a22cc8676949a6a5792686ee2b/src/app/rpmostree-clientlib.h#L37-L56)\r\n\r\nIt's not clear from the error message what exactly is wrong. It said it found a `&mut _` but the underlined type matches exactly the expected type (`GDBusConnection` is the same type as `cxxrsutil::FFIGDBusConnection`).\n",
        "hints_text": "",
        "created_at": "2021-03-30T22:06:06Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 62,
        "instance_id": "dtolnay__cxx-62",
        "issue_numbers": [
            "61"
        ],
        "base_commit": "eb87f6541003447aa627f7cc1179ec883cf2adf9",
        "patch": "diff --git a/BUCK b/BUCK\n--- a/BUCK\n+++ b/BUCK\n@@ -38,11 +38,11 @@ rust_binary(\n \n cxx_library(\n     name = \"core\",\n-    srcs = [\"src/cxxbridge.cc\"],\n+    srcs = [\"src/cxx.cc\"],\n     visibility = [\"PUBLIC\"],\n-    header_namespace = \"cxxbridge\",\n+    header_namespace = \"rust\",\n     exported_headers = {\n-        \"cxxbridge.h\": \"include/cxxbridge.h\",\n+        \"cxx.h\": \"include/cxx.h\",\n     },\n     exported_linker_flags = [\"-lstdc++\"],\n )\ndiff --git a/BUILD b/BUILD\n--- a/BUILD\n+++ b/BUILD\n@@ -3,7 +3,7 @@ load(\"//tools/bazel:rust.bzl\", \"rust_binary\", \"rust_library\")\n rust_library(\n     name = \"cxx\",\n     srcs = glob([\"src/**/*.rs\"]),\n-    data = [\"src/gen/include/cxxbridge.h\"],\n+    data = [\"src/gen/include/cxx.h\"],\n     visibility = [\"//visibility:public\"],\n     deps = [\n         \":core-lib\",\ndiff --git a/BUILD b/BUILD\n--- a/BUILD\n+++ b/BUILD\n@@ -23,7 +23,7 @@ rust_library(\n rust_binary(\n     name = \"codegen\",\n     srcs = glob([\"cmd/src/**/*.rs\"]),\n-    data = [\"cmd/src/gen/include/cxxbridge.h\"],\n+    data = [\"cmd/src/gen/include/cxx.h\"],\n     visibility = [\"//visibility:public\"],\n     deps = [\n         \"//third-party:anyhow\",\ndiff --git a/BUILD b/BUILD\n--- a/BUILD\n+++ b/BUILD\n@@ -39,16 +39,16 @@ rust_binary(\n \n cc_library(\n     name = \"core\",\n-    hdrs = [\"include/cxxbridge.h\"],\n-    include_prefix = \"cxxbridge\",\n+    hdrs = [\"include/cxx.h\"],\n+    include_prefix = \"rust\",\n     strip_include_prefix = \"include\",\n     visibility = [\"//visibility:public\"],\n )\n \n cc_library(\n     name = \"core-lib\",\n-    srcs = [\"src/cxxbridge.cc\"],\n-    hdrs = [\"include/cxxbridge.h\"],\n+    srcs = [\"src/cxx.cc\"],\n+    hdrs = [\"include/cxx.h\"],\n )\n \n rust_library(\ndiff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -306,9 +306,9 @@ of functions.\n <tr><td></td><td></td><td></td></tr>\n </table>\n \n-The C++ API of the `cxxbridge` namespace is defined by the *include/cxxbridge.h*\n-file in this repo. You will need to include this header in your C++ code when\n-working with those types.\n+The C++ API of the `rust` namespace is defined by the *include/cxx.h* file in\n+this repo. You will need to include this header in your C++ code when working\n+with those types.\n \n The following types are intended to be supported \"soon\" but are just not\n implemented yet. I don't expect any of these to be hard to make work but it's a\ndiff --git a/build.rs b/build.rs\n--- a/build.rs\n+++ b/build.rs\n@@ -1,8 +1,8 @@\n fn main() {\n     cc::Build::new()\n-        .file(\"src/cxxbridge.cc\")\n+        .file(\"src/cxx.cc\")\n         .flag(\"-std=c++11\")\n         .compile(\"cxxbridge01\");\n-    println!(\"cargo:rerun-if-changed=src/cxxbridge.cc\");\n-    println!(\"cargo:rerun-if-changed=include/cxxbridge.h\");\n+    println!(\"cargo:rerun-if-changed=src/cxx.cc\");\n+    println!(\"cargo:rerun-if-changed=include/cxx.h\");\n }\ndiff --git a/cmd/src/main.rs b/cmd/src/main.rs\n--- a/cmd/src/main.rs\n+++ b/cmd/src/main.rs\n@@ -14,7 +14,7 @@ use structopt::StructOpt;\n     usage = \"\\\n     cxxbridge <input>.rs              Emit .cc file for bridge to stdout\n     cxxbridge <input>.rs --header     Emit .h file for bridge to stdout\n-    cxxbridge --header                Emit cxxbridge.h header to stdout\",\n+    cxxbridge --header                Emit rust/cxx.h header to stdout\",\n     help_message = \"Print help information\",\n     version_message = \"Print version information\"\n )]\ndiff --git a/demo-cxx/demo.h b/demo-cxx/demo.h\n--- a/demo-cxx/demo.h\n+++ b/demo-cxx/demo.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include \"cxxbridge/cxxbridge.h\"\n+#include \"rust/cxx.h\"\n #include <memory>\n #include <string>\n \ndiff --git a/gen/include.rs b/gen/include.rs\n--- a/gen/include.rs\n+++ b/gen/include.rs\n@@ -1,6 +1,6 @@\n use std::fmt::{self, Display};\n \n-pub static HEADER: &str = include_str!(\"include/cxxbridge.h\");\n+pub static HEADER: &str = include_str!(\"include/cxx.h\");\n \n pub fn get(guard: &str) -> &'static str {\n     let ifndef = format!(\"#ifndef {}\", guard);\ndiff --git a/gen/include.rs b/gen/include.rs\n--- a/gen/include.rs\n+++ b/gen/include.rs\n@@ -10,7 +10,7 @@ pub fn get(guard: &str) -> &'static str {\n     if let (Some(begin), Some(end)) = (begin, end) {\n         &HEADER[begin..end + endif.len()]\n     } else {\n-        panic!(\"not found in cxxbridge.h header: {}\", guard)\n+        panic!(\"not found in cxx.h header: {}\", guard)\n     }\n }\n \ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -126,7 +126,7 @@ fn write_include_cxxbridge(out: &mut OutFile, apis: &[Api], types: &Types) {\n     out.begin_block(\"inline namespace cxxbridge01\");\n \n     if needs_rust_box || needs_manually_drop || needs_maybe_uninit {\n-        writeln!(out, \"// #include \\\"cxxbridge.h\\\"\");\n+        writeln!(out, \"// #include \\\"rust/cxx.h\\\"\");\n     }\n \n     if needs_rust_box {\ndiff --git a/src/cxxbridge.cc b/src/cxx.cc\n--- a/src/cxxbridge.cc\n+++ b/src/cxx.cc\n@@ -1,4 +1,4 @@\n-#include \"../include/cxxbridge.h\"\n+#include \"../include/cxx.h\"\n #include <cstring>\n #include <iostream>\n #include <memory>\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -310,9 +310,9 @@\n //! <tr><td></td><td></td><td></td></tr>\n //! </table>\n //!\n-//! The C++ API of the `cxxbridge` namespace is defined by the\n-//! *include/cxxbridge.h* file in https://github.com/dtolnay/cxx. You will need\n-//! to include this header in your C++ code when working with those types.\n+//! The C++ API of the `rust` namespace is defined by the *include/cxx.h* file\n+//! in https://github.com/dtolnay/cxx. You will need to include this header in\n+//! your C++ code when working with those types.\n //!\n //! The following types are intended to be supported \"soon\" but are just not\n //! implemented yet. I don't expect any of these to be hard to make work but\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -463,10 +463,10 @@ fn try_generate_bridge(rust_source_file: &Path) -> Result<cc::Build> {\n     let mut build = paths::cc_build();\n     build.file(&bridge_path);\n \n-    let ref cxxbridge_h = paths::include_dir()?.join(\"cxxbridge\").join(\"cxxbridge.h\");\n-    let _ = fs::create_dir_all(cxxbridge_h.parent().unwrap());\n-    let _ = fs::remove_file(cxxbridge_h);\n-    let _ = fs::write(cxxbridge_h, gen::include::HEADER);\n+    let ref cxx_h = paths::include_dir()?.join(\"rust\").join(\"cxx.h\");\n+    let _ = fs::create_dir_all(cxx_h.parent().unwrap());\n+    let _ = fs::remove_file(cxx_h);\n+    let _ = fs::write(cxx_h, gen::include::HEADER);\n \n     Ok(build)\n }\n",
        "test_patch": "diff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -1,5 +1,5 @@\n #pragma once\n-#include \"cxxbridge/cxxbridge.h\"\n+#include \"rust/cxx.h\"\n #include <memory>\n #include <string>\n \n",
        "problem_statement": "Decide header include path\nThe current setup exposes our C++ header as:\r\n\r\n```cpp\r\n#include \"cxxbridge/cxxbridge.h\"\r\n```\r\n\r\nThis isn't great because of the repetition, and also because all the symbols in the header are namespaced under `rust::` so an include path with rust in the name somewhere may make more sense.\r\n\r\nSomething like:\r\n\r\n- `#include \"cxxbridge/rust.h\"`\r\n- `#include \"rust/cxxbridge.h\"`\r\n- `#include \"rust/cxx.h\"`\n",
        "hints_text": "Currently leaning toward `\"rust/cxx.h\"`.",
        "created_at": "2020-03-11T23:52:54Z",
        "version": "0.1"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 48,
        "instance_id": "dtolnay__cxx-48",
        "issue_numbers": [
            "46"
        ],
        "base_commit": "d944446b9898a120b2f66a54ca86240e7189af9e",
        "patch": "diff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -298,10 +298,10 @@ of functions.\n \n <table>\n <tr><th>name in Rust</th><th>name in C++</th><th>restrictions</th></tr>\n-<tr><td>String</td><td>cxxbridge::RustString</td><td></td></tr>\n-<tr><td>&amp;str</td><td>cxxbridge::RustStr</td><td></td></tr>\n+<tr><td>String</td><td>rust::String</td><td></td></tr>\n+<tr><td>&amp;str</td><td>rust::Str</td><td></td></tr>\n <tr><td><a href=\"https://docs.rs/cxx/0.1/cxx/struct.CxxString.html\">CxxString</a></td><td>std::string</td><td><sup><i>cannot be passed by value</i></sup></td></tr>\n-<tr><td>Box&lt;T&gt;</td><td>cxxbridge::RustBox&lt;T&gt;</td><td><sup><i>cannot hold opaque C++ type</i></sup></td></tr>\n+<tr><td>Box&lt;T&gt;</td><td>rust::Box&lt;T&gt;</td><td><sup><i>cannot hold opaque C++ type</i></sup></td></tr>\n <tr><td><a href=\"https://docs.rs/cxx/0.1/cxx/struct.UniquePtr.html\">UniquePtr&lt;T&gt;</a></td><td>std::unique_ptr&lt;T&gt;</td><td><sup><i>cannot hold opaque Rust type</i></sup></td></tr>\n <tr><td></td><td></td><td></td></tr>\n </table>\ndiff --git a/demo-cxx/demo.cc b/demo-cxx/demo.cc\n--- a/demo-cxx/demo.cc\n+++ b/demo-cxx/demo.cc\n@@ -3,13 +3,13 @@\n #include <iostream>\n \n namespace org {\n-namespace rust {\n+namespace example {\n \n ThingC::ThingC(std::string appname) : appname(std::move(appname)) {}\n \n ThingC::~ThingC() { std::cout << \"done with ThingC\" << std::endl; }\n \n-std::unique_ptr<ThingC> make_demo(cxxbridge::RustStr appname) {\n+std::unique_ptr<ThingC> make_demo(rust::Str appname) {\n   return std::unique_ptr<ThingC>(new ThingC(appname));\n }\n \ndiff --git a/demo-cxx/demo.cc b/demo-cxx/demo.cc\n--- a/demo-cxx/demo.cc\n+++ b/demo-cxx/demo.cc\n@@ -17,5 +17,5 @@ const std::string &get_name(const ThingC &thing) { return thing.appname; }\n \n void do_thing(SharedThing state) { print_r(*state.y); }\n \n-} // namespace rust\n+} // namespace example\n } // namespace org\ndiff --git a/demo-cxx/demo.h b/demo-cxx/demo.h\n--- a/demo-cxx/demo.h\n+++ b/demo-cxx/demo.h\n@@ -4,7 +4,7 @@\n #include <string>\n \n namespace org {\n-namespace rust {\n+namespace example {\n \n class ThingC {\n public:\ndiff --git a/demo-cxx/demo.h b/demo-cxx/demo.h\n--- a/demo-cxx/demo.h\n+++ b/demo-cxx/demo.h\n@@ -16,9 +16,9 @@ class ThingC {\n \n struct SharedThing;\n \n-std::unique_ptr<ThingC> make_demo(cxxbridge::RustStr appname);\n+std::unique_ptr<ThingC> make_demo(rust::Str appname);\n const std::string &get_name(const ThingC &thing);\n void do_thing(SharedThing state);\n \n-} // namespace rust\n+} // namespace example\n } // namespace org\ndiff --git a/demo-rs/src/main.rs b/demo-rs/src/main.rs\n--- a/demo-rs/src/main.rs\n+++ b/demo-rs/src/main.rs\n@@ -1,4 +1,4 @@\n-#[cxx::bridge(namespace = org::rust)]\n+#[cxx::bridge(namespace = org::example)]\n mod ffi {\n     struct SharedThing {\n         z: i32,\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -21,21 +21,11 @@ pub(super) fn gen(namespace: Vec<String>, apis: &[Api], types: &Types, header: b\n     write_includes(out, types);\n     write_include_cxxbridge(out, types);\n \n-    if !header {\n-        out.next_section();\n-        write_namespace_alias(out, types);\n-    }\n-\n     out.next_section();\n     for name in &namespace {\n         writeln!(out, \"namespace {} {{\", name);\n     }\n \n-    if header {\n-        out.next_section();\n-        write_namespace_alias(out, types);\n-    }\n-\n     out.next_section();\n     for api in apis {\n         match api {\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -125,7 +115,8 @@ fn write_include_cxxbridge(out: &mut OutFile, types: &Types) {\n         }\n     }\n \n-    out.begin_block(\"namespace cxxbridge01\");\n+    out.begin_block(\"namespace rust\");\n+    out.begin_block(\"inline namespace cxxbridge01\");\n     if needs_rust_box {\n         writeln!(out, \"// #include \\\"cxxbridge.h\\\"\");\n         for line in include::get(\"CXXBRIDGE01_RUST_BOX\").lines() {\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -135,20 +126,7 @@ fn write_include_cxxbridge(out: &mut OutFile, types: &Types) {\n         }\n     }\n     out.end_block();\n-}\n-\n-fn write_namespace_alias(out: &mut OutFile, types: &Types) {\n-    let mut needs_namespace_alias = false;\n-    for ty in types {\n-        if let Type::RustBox(_) = ty {\n-            needs_namespace_alias = true;\n-            break;\n-        }\n-    }\n-\n-    if needs_namespace_alias {\n-        writeln!(out, \"namespace cxxbridge = cxxbridge01;\");\n-    }\n+    out.end_block();\n }\n \n fn write_struct(out: &mut OutFile, strct: &Struct) {\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -365,7 +343,7 @@ fn write_extern_return_type(out: &mut OutFile, ty: &Option<Type>, types: &Types)\n             write_type(out, &ty.inner);\n             write!(out, \" *\");\n         }\n-        Some(Type::Str(_)) => write!(out, \"::cxxbridge::RustStr::Repr \"),\n+        Some(Type::Str(_)) => write!(out, \"::rust::Str::Repr \"),\n         Some(ty) if types.needs_indirect_abi(ty) => write!(out, \"void \"),\n         _ => write_return_type(out, ty),\n     }\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -377,7 +355,7 @@ fn write_extern_arg(out: &mut OutFile, arg: &Var, types: &Types) {\n             write_type_space(out, &ty.inner);\n             write!(out, \"*\");\n         }\n-        Type::Str(_) => write!(out, \"::cxxbridge::RustStr::Repr \"),\n+        Type::Str(_) => write!(out, \"::rust::Str::Repr \"),\n         _ => write_type_space(out, &arg.ty),\n     }\n     if types.needs_indirect_abi(&arg.ty) {\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -401,11 +379,11 @@ fn write_type(out: &mut OutFile, ty: &Type) {\n             Some(I64) => write!(out, \"int64_t\"),\n             Some(Isize) => write!(out, \"ssize_t\"),\n             Some(CxxString) => write!(out, \"::std::string\"),\n-            Some(RustString) => write!(out, \"::cxxbridge::RustString\"),\n+            Some(RustString) => write!(out, \"::rust::String\"),\n             None => write!(out, \"{}\", ident),\n         },\n         Type::RustBox(ty) => {\n-            write!(out, \"::cxxbridge::RustBox<\");\n+            write!(out, \"::rust::Box<\");\n             write_type(out, &ty.inner);\n             write!(out, \">\");\n         }\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -422,7 +400,7 @@ fn write_type(out: &mut OutFile, ty: &Type) {\n             write!(out, \" &\");\n         }\n         Type::Str(_) => {\n-            write!(out, \"::cxxbridge::RustStr\");\n+            write!(out, \"::rust::Str\");\n         }\n     }\n }\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -458,7 +436,8 @@ fn write_generic_instantiations(out: &mut OutFile, types: &Types) {\n     }\n     out.end_block();\n \n-    out.begin_block(\"namespace cxxbridge01\");\n+    out.begin_block(\"namespace rust\");\n+    out.begin_block(\"inline namespace cxxbridge01\");\n     for ty in types {\n         if let Type::RustBox(ty) = ty {\n             if let Type::Ident(inner) = &ty.inner {\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -467,6 +446,7 @@ fn write_generic_instantiations(out: &mut OutFile, types: &Types) {\n         }\n     }\n     out.end_block();\n+    out.end_block();\n }\n \n fn write_rust_box_extern(out: &mut OutFile, ident: &Ident) {\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -482,27 +462,27 @@ fn write_rust_box_extern(out: &mut OutFile, ident: &Ident) {\n     writeln!(out, \"#define CXXBRIDGE01_RUST_BOX_{}\", instance);\n     writeln!(\n         out,\n-        \"void cxxbridge01$rust_box${}$uninit(::cxxbridge::RustBox<{}> *ptr) noexcept;\",\n+        \"void cxxbridge01$rust_box${}$uninit(::rust::Box<{}> *ptr) noexcept;\",\n         instance, inner,\n     );\n     writeln!(\n         out,\n-        \"void cxxbridge01$rust_box${}$set_raw(::cxxbridge::RustBox<{}> *ptr, {} *raw) noexcept;\",\n+        \"void cxxbridge01$rust_box${}$set_raw(::rust::Box<{}> *ptr, {} *raw) noexcept;\",\n         instance, inner, inner\n     );\n     writeln!(\n         out,\n-        \"void cxxbridge01$rust_box${}$drop(::cxxbridge::RustBox<{}> *ptr) noexcept;\",\n+        \"void cxxbridge01$rust_box${}$drop(::rust::Box<{}> *ptr) noexcept;\",\n         instance, inner,\n     );\n     writeln!(\n         out,\n-        \"const {} *cxxbridge01$rust_box${}$deref(const ::cxxbridge::RustBox<{}> *ptr) noexcept;\",\n+        \"const {} *cxxbridge01$rust_box${}$deref(const ::rust::Box<{}> *ptr) noexcept;\",\n         inner, instance, inner,\n     );\n     writeln!(\n         out,\n-        \"{} *cxxbridge01$rust_box${}$deref_mut(::cxxbridge::RustBox<{}> *ptr) noexcept;\",\n+        \"{} *cxxbridge01$rust_box${}$deref_mut(::rust::Box<{}> *ptr) noexcept;\",\n         inner, instance, inner,\n     );\n     writeln!(out, \"#endif // CXXBRIDGE01_RUST_BOX_{}\", instance);\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -518,7 +498,7 @@ fn write_rust_box_impl(out: &mut OutFile, ident: &Ident) {\n     let instance = inner.replace(\"::\", \"$\");\n \n     writeln!(out, \"template <>\");\n-    writeln!(out, \"void RustBox<{}>::uninit() noexcept {{\", inner);\n+    writeln!(out, \"void Box<{}>::uninit() noexcept {{\", inner);\n     writeln!(\n         out,\n         \"  return cxxbridge01$rust_box${}$uninit(this);\",\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -529,7 +509,7 @@ fn write_rust_box_impl(out: &mut OutFile, ident: &Ident) {\n     writeln!(out, \"template <>\");\n     writeln!(\n         out,\n-        \"void RustBox<{}>::set_raw({} *raw) noexcept {{\",\n+        \"void Box<{}>::set_raw({} *raw) noexcept {{\",\n         inner, inner,\n     );\n     writeln!(\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -540,7 +520,7 @@ fn write_rust_box_impl(out: &mut OutFile, ident: &Ident) {\n     writeln!(out, \"}}\");\n \n     writeln!(out, \"template <>\");\n-    writeln!(out, \"void RustBox<{}>::drop() noexcept {{\", inner);\n+    writeln!(out, \"void Box<{}>::drop() noexcept {{\", inner);\n     writeln!(\n         out,\n         \"  return cxxbridge01$rust_box${}$drop(this);\",\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -551,7 +531,7 @@ fn write_rust_box_impl(out: &mut OutFile, ident: &Ident) {\n     writeln!(out, \"template <>\");\n     writeln!(\n         out,\n-        \"const {} *RustBox<{}>::deref() const noexcept {{\",\n+        \"const {} *Box<{}>::deref() const noexcept {{\",\n         inner, inner,\n     );\n     writeln!(\ndiff --git a/gen/write.rs b/gen/write.rs\n--- a/gen/write.rs\n+++ b/gen/write.rs\n@@ -562,11 +542,7 @@ fn write_rust_box_impl(out: &mut OutFile, ident: &Ident) {\n     writeln!(out, \"}}\");\n \n     writeln!(out, \"template <>\");\n-    writeln!(\n-        out,\n-        \"{} *RustBox<{}>::deref_mut() noexcept {{\",\n-        inner, inner,\n-    );\n+    writeln!(out, \"{} *Box<{}>::deref_mut() noexcept {{\", inner, inner);\n     writeln!(\n         out,\n         \"  return cxxbridge01$rust_box${}$deref_mut(this);\",\ndiff --git a/include/cxxbridge.h b/include/cxxbridge.h\n--- a/include/cxxbridge.h\n+++ b/include/cxxbridge.h\n@@ -4,21 +4,19 @@\n #include <iostream>\n #include <string>\n \n-namespace cxxbridge01 {}\n-namespace cxxbridge = cxxbridge01;\n+namespace rust {\n+inline namespace cxxbridge01 {\n \n-namespace cxxbridge01 {\n-\n-class RustString final {\n+class String final {\n public:\n-  RustString() noexcept;\n-  RustString(const RustString &other) noexcept;\n-  RustString(RustString &&other) noexcept;\n-  RustString(const char *s);\n-  RustString(const std::string &s);\n-  RustString &operator=(const RustString &other) noexcept;\n-  RustString &operator=(RustString &&other) noexcept;\n-  ~RustString() noexcept;\n+  String() noexcept;\n+  String(const String &other) noexcept;\n+  String(String &&other) noexcept;\n+  String(const char *s);\n+  String(const std::string &s);\n+  String &operator=(const String &other) noexcept;\n+  String &operator=(String &&other) noexcept;\n+  ~String() noexcept;\n   operator std::string() const;\n \n   // Note: no null terminator.\ndiff --git a/include/cxxbridge.h b/include/cxxbridge.h\n--- a/include/cxxbridge.h\n+++ b/include/cxxbridge.h\n@@ -31,14 +29,14 @@ class RustString final {\n   std::array<uintptr_t, 3> repr;\n };\n \n-class RustStr final {\n+class Str final {\n public:\n-  RustStr() noexcept;\n-  RustStr(const char *s);\n-  RustStr(const std::string &s);\n-  RustStr(std::string &&s) = delete;\n-  RustStr(const RustStr &other) noexcept;\n-  RustStr &operator=(RustStr other) noexcept;\n+  Str() noexcept;\n+  Str(const char *s);\n+  Str(const std::string &s);\n+  Str(std::string &&s) = delete;\n+  Str(const Str &other) noexcept;\n+  Str &operator=(Str other) noexcept;\n   operator std::string() const;\n \n   // Note: no null terminator.\ndiff --git a/include/cxxbridge.h b/include/cxxbridge.h\n--- a/include/cxxbridge.h\n+++ b/include/cxxbridge.h\n@@ -54,7 +52,7 @@ class RustStr final {\n     const char *ptr;\n     size_t len;\n   };\n-  RustStr(Repr repr) noexcept;\n+  Str(Repr repr) noexcept;\n   operator Repr() noexcept;\n \n private:\ndiff --git a/include/cxxbridge.h b/include/cxxbridge.h\n--- a/include/cxxbridge.h\n+++ b/include/cxxbridge.h\n@@ -63,15 +61,15 @@ class RustStr final {\n \n #ifndef CXXBRIDGE01_RUST_BOX\n #define CXXBRIDGE01_RUST_BOX\n-template <typename T> class RustBox final {\n+template <typename T> class Box final {\n public:\n-  RustBox(const RustBox &other) : RustBox(*other) {}\n-  RustBox(RustBox &&other) noexcept : repr(other.repr) { other.repr = 0; }\n-  RustBox(const T &val) {\n+  Box(const Box &other) : Box(*other) {}\n+  Box(Box &&other) noexcept : repr(other.repr) { other.repr = 0; }\n+  Box(const T &val) {\n     this->uninit();\n     ::new (this->deref_mut()) T(val);\n   }\n-  RustBox &operator=(const RustBox &other) {\n+  Box &operator=(const Box &other) {\n     if (this != &other) {\n       if (this->repr) {\n         **this = *other;\ndiff --git a/include/cxxbridge.h b/include/cxxbridge.h\n--- a/include/cxxbridge.h\n+++ b/include/cxxbridge.h\n@@ -82,7 +80,7 @@ template <typename T> class RustBox final {\n     }\n     return *this;\n   }\n-  RustBox &operator=(RustBox &&other) noexcept {\n+  Box &operator=(Box &&other) noexcept {\n     if (this->repr) {\n       this->drop();\n     }\ndiff --git a/include/cxxbridge.h b/include/cxxbridge.h\n--- a/include/cxxbridge.h\n+++ b/include/cxxbridge.h\n@@ -90,7 +88,7 @@ template <typename T> class RustBox final {\n     other.repr = 0;\n     return *this;\n   }\n-  ~RustBox() noexcept {\n+  ~Box() noexcept {\n     if (this->repr) {\n       this->drop();\n     }\ndiff --git a/include/cxxbridge.h b/include/cxxbridge.h\n--- a/include/cxxbridge.h\n+++ b/include/cxxbridge.h\n@@ -103,8 +101,8 @@ template <typename T> class RustBox final {\n \n   // Important: requires that `raw` came from an into_raw call. Do not pass a\n   // pointer from `new` or any other source.\n-  static RustBox from_raw(T *raw) noexcept {\n-    RustBox box;\n+  static Box from_raw(T *raw) noexcept {\n+    Box box;\n     box.set_raw(raw);\n     return box;\n   }\ndiff --git a/include/cxxbridge.h b/include/cxxbridge.h\n--- a/include/cxxbridge.h\n+++ b/include/cxxbridge.h\n@@ -116,7 +114,7 @@ template <typename T> class RustBox final {\n   }\n \n private:\n-  RustBox() noexcept {}\n+  Box() noexcept {}\n   void uninit() noexcept;\n   void set_raw(T *) noexcept;\n   T *get_raw() noexcept;\ndiff --git a/include/cxxbridge.h b/include/cxxbridge.h\n--- a/include/cxxbridge.h\n+++ b/include/cxxbridge.h\n@@ -127,7 +125,8 @@ template <typename T> class RustBox final {\n };\n #endif // CXXBRIDGE01_RUST_BOX\n \n-std::ostream &operator<<(std::ostream &os, const RustString &s);\n-std::ostream &operator<<(std::ostream &os, const RustStr &s);\n+std::ostream &operator<<(std::ostream &os, const String &s);\n+std::ostream &operator<<(std::ostream &os, const Str &s);\n \n-} // namespace cxxbridge01\n+} // inline namespace cxxbridge01\n+} // namespace rust\ndiff --git a/src/cxxbridge.cc b/src/cxxbridge.cc\n--- a/src/cxxbridge.cc\n+++ b/src/cxxbridge.cc\n@@ -3,8 +3,6 @@\n #include <memory>\n #include <stdexcept>\n \n-namespace cxxbridge = cxxbridge01;\n-\n extern \"C\" {\n const char *cxxbridge01$cxx_string$data(const std::string &s) noexcept {\n   return s.data();\ndiff --git a/src/cxxbridge.cc b/src/cxxbridge.cc\n--- a/src/cxxbridge.cc\n+++ b/src/cxxbridge.cc\n@@ -14,56 +12,57 @@ size_t cxxbridge01$cxx_string$length(const std::string &s) noexcept {\n   return s.length();\n }\n \n-// RustString\n-void cxxbridge01$rust_string$new(cxxbridge::RustString *self) noexcept;\n-void cxxbridge01$rust_string$clone(cxxbridge::RustString *self,\n-                                   const cxxbridge::RustString &other) noexcept;\n-bool cxxbridge01$rust_string$from(cxxbridge::RustString *self, const char *ptr,\n+// rust::String\n+void cxxbridge01$rust_string$new(rust::String *self) noexcept;\n+void cxxbridge01$rust_string$clone(rust::String *self,\n+                                   const rust::String &other) noexcept;\n+bool cxxbridge01$rust_string$from(rust::String *self, const char *ptr,\n                                   size_t len) noexcept;\n-void cxxbridge01$rust_string$drop(cxxbridge::RustString *self) noexcept;\n+void cxxbridge01$rust_string$drop(rust::String *self) noexcept;\n const char *\n-cxxbridge01$rust_string$ptr(const cxxbridge::RustString *self) noexcept;\n-size_t cxxbridge01$rust_string$len(const cxxbridge::RustString *self) noexcept;\n+cxxbridge01$rust_string$ptr(const rust::String *self) noexcept;\n+size_t cxxbridge01$rust_string$len(const rust::String *self) noexcept;\n \n-// RustStr\n+// rust::Str\n bool cxxbridge01$rust_str$valid(const char *ptr, size_t len) noexcept;\n } // extern \"C\"\n \n-namespace cxxbridge01 {\n+namespace rust {\n+inline namespace cxxbridge01 {\n \n-RustString::RustString() noexcept { cxxbridge01$rust_string$new(this); }\n+String::String() noexcept { cxxbridge01$rust_string$new(this); }\n \n-RustString::RustString(const RustString &other) noexcept {\n+String::String(const String &other) noexcept {\n   cxxbridge01$rust_string$clone(this, other);\n }\n \n-RustString::RustString(RustString &&other) noexcept {\n+String::String(String &&other) noexcept {\n   this->repr = other.repr;\n   cxxbridge01$rust_string$new(&other);\n }\n \n-RustString::RustString(const char *s) {\n+String::String(const char *s) {\n   auto len = strlen(s);\n   if (!cxxbridge01$rust_string$from(this, s, len)) {\n-    throw std::invalid_argument(\"data for RustString is not utf-8\");\n+    throw std::invalid_argument(\"data for rust::String is not utf-8\");\n   }\n }\n \n-RustString::RustString(const std::string &s) {\n+String::String(const std::string &s) {\n   auto ptr = s.data();\n   auto len = s.length();\n   if (!cxxbridge01$rust_string$from(this, ptr, len)) {\n-    throw std::invalid_argument(\"data for RustString is not utf-8\");\n+    throw std::invalid_argument(\"data for rust::String is not utf-8\");\n   }\n }\n \n-RustString::~RustString() noexcept { cxxbridge01$rust_string$drop(this); }\n+String::~String() noexcept { cxxbridge01$rust_string$drop(this); }\n \n-RustString::operator std::string() const {\n+String::operator std::string() const {\n   return std::string(this->data(), this->size());\n }\n \n-RustString &RustString::operator=(const RustString &other) noexcept {\n+String &String::operator=(const String &other) noexcept {\n   if (this != &other) {\n     cxxbridge01$rust_string$drop(this);\n     cxxbridge01$rust_string$clone(this, other);\ndiff --git a/src/cxxbridge.cc b/src/cxxbridge.cc\n--- a/src/cxxbridge.cc\n+++ b/src/cxxbridge.cc\n@@ -71,7 +70,7 @@ RustString &RustString::operator=(const RustString &other) noexcept {\n   return *this;\n }\n \n-RustString &RustString::operator=(RustString &&other) noexcept {\n+String &String::operator=(String &&other) noexcept {\n   if (this != &other) {\n     cxxbridge01$rust_string$drop(this);\n     this->repr = other.repr;\ndiff --git a/src/cxxbridge.cc b/src/cxxbridge.cc\n--- a/src/cxxbridge.cc\n+++ b/src/cxxbridge.cc\n@@ -80,65 +79,66 @@ RustString &RustString::operator=(RustString &&other) noexcept {\n   return *this;\n }\n \n-const char *RustString::data() const noexcept {\n+const char *String::data() const noexcept {\n   return cxxbridge01$rust_string$ptr(this);\n }\n \n-size_t RustString::size() const noexcept {\n+size_t String::size() const noexcept {\n   return cxxbridge01$rust_string$len(this);\n }\n \n-size_t RustString::length() const noexcept {\n+size_t String::length() const noexcept {\n   return cxxbridge01$rust_string$len(this);\n }\n \n-std::ostream &operator<<(std::ostream &os, const RustString &s) {\n+std::ostream &operator<<(std::ostream &os, const String &s) {\n   os.write(s.data(), s.size());\n   return os;\n }\n \n-RustStr::RustStr() noexcept\n+Str::Str() noexcept\n     : repr(Repr{reinterpret_cast<const char *>(this), 0}) {}\n \n-RustStr::RustStr(const char *s) : repr(Repr{s, strlen(s)}) {\n+Str::Str(const char *s) : repr(Repr{s, strlen(s)}) {\n   if (!cxxbridge01$rust_str$valid(this->repr.ptr, this->repr.len)) {\n-    throw std::invalid_argument(\"data for RustStr is not utf-8\");\n+    throw std::invalid_argument(\"data for rust::Str is not utf-8\");\n   }\n }\n \n-RustStr::RustStr(const std::string &s) : repr(Repr{s.data(), s.length()}) {\n+Str::Str(const std::string &s) : repr(Repr{s.data(), s.length()}) {\n   if (!cxxbridge01$rust_str$valid(this->repr.ptr, this->repr.len)) {\n-    throw std::invalid_argument(\"data for RustStr is not utf-8\");\n+    throw std::invalid_argument(\"data for rust::Str is not utf-8\");\n   }\n }\n \n-RustStr::RustStr(const RustStr &) noexcept = default;\n+Str::Str(const Str &) noexcept = default;\n \n-RustStr &RustStr::operator=(RustStr other) noexcept {\n+Str &Str::operator=(Str other) noexcept {\n   this->repr = other.repr;\n   return *this;\n }\n \n-RustStr::operator std::string() const {\n+Str::operator std::string() const {\n   return std::string(this->data(), this->size());\n }\n \n-const char *RustStr::data() const noexcept { return this->repr.ptr; }\n+const char *Str::data() const noexcept { return this->repr.ptr; }\n \n-size_t RustStr::size() const noexcept { return this->repr.len; }\n+size_t Str::size() const noexcept { return this->repr.len; }\n \n-size_t RustStr::length() const noexcept { return this->repr.len; }\n+size_t Str::length() const noexcept { return this->repr.len; }\n \n-RustStr::RustStr(Repr repr_) noexcept : repr(repr_) {}\n+Str::Str(Repr repr_) noexcept : repr(repr_) {}\n \n-RustStr::operator Repr() noexcept { return this->repr; }\n+Str::operator Repr() noexcept { return this->repr; }\n \n-std::ostream &operator<<(std::ostream &os, const RustStr &s) {\n+std::ostream &operator<<(std::ostream &os, const Str &s) {\n   os.write(s.data(), s.size());\n   return os;\n }\n \n-} // namespace cxxbridge01\n+} // inline namespace cxxbridge01\n+} // namespace rust\n \n extern \"C\" {\n void cxxbridge01$unique_ptr$std$string$null(\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -302,10 +302,10 @@\n //!\n //! <table>\n //! <tr><th>name in Rust</th><th>name in C++</th><th>restrictions</th></tr>\n-//! <tr><td>String</td><td>cxxbridge::RustString</td><td></td></tr>\n-//! <tr><td>&amp;str</td><td>cxxbridge::RustStr</td><td></td></tr>\n+//! <tr><td>String</td><td>rust::String</td><td></td></tr>\n+//! <tr><td>&amp;str</td><td>rust::Str</td><td></td></tr>\n //! <tr><td><a href=\"https://docs.rs/cxx/0.1/cxx/struct.CxxString.html\">CxxString</a></td><td>std::string</td><td><sup><i>cannot be passed by value</i></sup></td></tr>\n-//! <tr><td>Box&lt;T&gt;</td><td>cxxbridge::RustBox&lt;T&gt;</td><td><sup><i>cannot hold opaque C++ type</i></sup></td></tr>\n+//! <tr><td>Box&lt;T&gt;</td><td>rust::Box&lt;T&gt;</td><td><sup><i>cannot hold opaque C++ type</i></sup></td></tr>\n //! <tr><td><a href=\"https://docs.rs/cxx/0.1/cxx/struct.UniquePtr.html\">UniquePtr&lt;T&gt;</a></td><td>std::unique_ptr&lt;T&gt;</td><td><sup><i>cannot hold opaque Rust type</i></sup></td></tr>\n //! <tr><td></td><td></td><td></td></tr>\n //! </table>\n",
        "test_patch": "diff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -19,12 +19,12 @@ std::unique_ptr<C> c_return_unique_ptr() {\n \n const size_t &c_return_ref(const Shared &shared) { return shared.z; }\n \n-cxxbridge::RustStr c_return_str(const Shared &shared) {\n+rust::Str c_return_str(const Shared &shared) {\n   (void)shared;\n   return \"2020\";\n }\n \n-cxxbridge::RustString c_return_rust_string() { return \"2020\"; }\n+rust::String c_return_rust_string() { return \"2020\"; }\n \n std::unique_ptr<std::string> c_return_unique_ptr_string() {\n   return std::unique_ptr<std::string>(new std::string(\"2020\"));\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -42,7 +42,7 @@ void c_take_shared(Shared shared) {\n   }\n }\n \n-void c_take_box(cxxbridge::RustBox<R> r) {\n+void c_take_box(rust::Box<R> r) {\n   (void)r;\n   cxx_test_suite_set_correct();\n }\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -61,13 +61,13 @@ void c_take_ref_c(const C &c) {\n   }\n }\n \n-void c_take_str(cxxbridge::RustStr s) {\n+void c_take_str(rust::Str s) {\n   if (std::string(s) == \"2020\") {\n     cxx_test_suite_set_correct();\n   }\n }\n \n-void c_take_rust_string(cxxbridge::RustString s) {\n+void c_take_rust_string(rust::String s) {\n   if (std::string(s) == \"2020\") {\n     cxx_test_suite_set_correct();\n   }\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -99,8 +99,8 @@ extern \"C\" const char *cxx_run_test() noexcept {\n   r_take_shared(Shared{2020});\n   r_take_unique_ptr(std::unique_ptr<C>(new C{2020}));\n   r_take_ref_c(C{2020});\n-  r_take_str(cxxbridge::RustStr(\"2020\"));\n-  // TODO r_take_rust_string(cxxbridge::RustString(\"2020\"));\n+  r_take_str(rust::Str(\"2020\"));\n+  // TODO r_take_rust_string(rust::String(\"2020\"));\n   r_take_unique_ptr_string(\n       std::unique_ptr<std::string>(new std::string(\"2020\")));\n \ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -19,21 +19,21 @@ class C {\n \n size_t c_return_primitive();\n Shared c_return_shared();\n-cxxbridge::RustBox<R> c_return_box();\n+rust::Box<R> c_return_box();\n std::unique_ptr<C> c_return_unique_ptr();\n const size_t &c_return_ref(const Shared &shared);\n-cxxbridge::RustStr c_return_str(const Shared &shared);\n-cxxbridge::RustString c_return_rust_string();\n+rust::Str c_return_str(const Shared &shared);\n+rust::String c_return_rust_string();\n std::unique_ptr<std::string> c_return_unique_ptr_string();\n \n void c_take_primitive(size_t n);\n void c_take_shared(Shared shared);\n-void c_take_box(cxxbridge::RustBox<R> r);\n+void c_take_box(rust::Box<R> r);\n void c_take_unique_ptr(std::unique_ptr<C> c);\n void c_take_ref_r(const R &r);\n void c_take_ref_c(const C &c);\n-void c_take_str(cxxbridge::RustStr s);\n-void c_take_rust_string(cxxbridge::RustString s);\n+void c_take_str(rust::Str s);\n+void c_take_rust_string(rust::String s);\n void c_take_unique_ptr_string(std::unique_ptr<std::string> s);\n \n } // namespace tests\n",
        "problem_statement": "Design C++ namespace scheme\n#5 and #8 call out that prefixed names like RustString and RustBox are not idiomatic and we should be placing these types in a namespace instead.\r\n\r\nThinking only of the code that I would want downstream to be writing, the style I find most readable is something like:\r\n\r\n```cpp\r\nvoid f(rust::Str s, rust::Box<Thing> b);\r\n```\r\n\r\nSome questions for @pravic and @slurps-mad-rips or anyone else:\r\n\r\n- I have the feeling it isn't appropriate for me to declare a top-level `rust` namespace with familiar type names like `Box` in it. That namespace \"belongs\" to the official Rust project. Is that feeling correct or is it not so bad?\r\n\r\n- I can define our types in `cxxbridge::rust` and recommend an import downstream to bring `rust` in scope when there isn't a collision with something else. Are C++ style guides generally okay with that or would people end up forced to write out `cxxbridge::rust::...` all over the place?\r\n\r\n- For the import, as far as I can tell it would be spelled `using rust = cxxbridge::rust;`. Is that right? There doesn't seem to be a way to avoid repeating \"rust\" such as `using cxxbridge::rust;`.\r\n\r\n    ```console\r\n    main.cc:11:18: error: using declaration cannot refer to a namespace\r\n    using cxxbridge::rust;\r\n          ~~~~~~~~~~~^\r\n    ```\r\n\r\n    ```console\r\n    main.cc:11:18: error: namespace \u2018cxxbridge01::rust\u2019 not allowed in using-declaration\r\n       11 | using cxxbridge::rust;\r\n          |                  ^~~~\r\n    ```\r\n\r\n- Any other thoughts on the namespace scheme? Thanks!\n",
        "hints_text": "Responses in order of questions:\r\n\r\n * The only top level namespace owned by anyone is the `posix` namespace (reserved for the Austin Group, if they ever decide to create a C++ interface) and `std`. If you're really concerned, what you can do is `namespace rust { inline namespace cxxbridge { /* declarations */ }}` (in C++20, you can do `namespace rust::inline cxxbridge {`), This will mangle the cxxbridge symbols, and if anyone ever has an issue or a Rust toplevel namespace is ever used, you can make the inline namespace uninlined and already compiled code won't break. That said, I don't think ABI stability *really* matters for this project :)\r\n\r\n* People would most likely not be down for this. While some folks are fine with it, not everyone is. It's a personal preference, but at that point, why have the `::rust` inner namespace?\r\n\r\n* Namespaces aren't treated like other declarations/using expressions in C++. You can do `namespace rust = cxxbridge::rust` or, `using namespace cxxbridge`. Both of these bring the `rust` namespace into scope, however the second form is looked down on, and the former approach is usually not liked because \"why didn't you just make that the top level anyhow?\". Most people end up doing `namespace fs = std::filesystem` in C++17 and it was enough of an issue that in C++23 (because we ran out of time for papers), we'll most likely have an alias namespace of `std::fs` \ud83d\ude05\r\n\r\n* Nothing else really, but keep in mind some people may want idiomatic C++ naming for the types as well. It wouldn't hurt to create type aliases that are all snake case. (i.e., `template <class T> using box = Box<T>;`)\nThank you! That answer solves everything I wanted.\r\n\r\nI'll go with `namespace rust::inline cxxbridge01`. You are right that ABI stability doesn't matter here, but rather ABI *instability* is a requirement. Since Rust allows multiple versions of a library to be linked together, and since this library claims to be safe, depending on multiple versions of it from one binary needs to behave safely.\r\n\r\nAnd I would be happy to expose snake case type aliases. I am sticking with the current case as the default featured one in documentation for my-employer-is-always-right reasons and it matches https://google.github.io/styleguide/cppguide.html#Type_Names, but I sympathize with wanting lowercase names where the surrounding code uses them.\n@dtolnay fair enough! I will say, keep in mind the `::inline` syntax is C++20 and isn't available everywhere at this time. That said if you're trying to *enforce* ABI instability, I would recommend doing\r\n`namespace rust { inline namespace cxxbridge { inline namespace v<generate a hash/use a date/version here> {`. This way hard linker errors will fire if the most inner inline namespace can't be found. Not the most empathetic approach to signaling what went wrong exactly to users, but it's better than bizarre runtime issues \ud83d\ude42\r\n\r\nThat said, since you're at Facebook, you might want to reach out to Michael Park and Eric Niebler who are on the C++ committee. They might be able to provide additional guidance regarding C++ API design :)\r\n",
        "created_at": "2020-03-01T21:49:29Z",
        "version": "0.1"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 36,
        "instance_id": "dtolnay__cxx-36",
        "issue_numbers": [
            "30",
            "32"
        ],
        "base_commit": "b5bc0b4c9a9497dd322ac0e456d8363193af5584",
        "patch": "diff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -25,3 +25,14 @@ matrix:\n       script:\n         - buck build :cxx#check --verbose=0\n         - buck run demo-rs --verbose=0\n+    - name: Bazel\n+      rust: nightly\n+      before_install:\n+        - wget -O install.sh https://github.com/bazelbuild/bazel/releases/download/2.1.1/bazel-2.1.1-installer-linux-x86_64.sh\n+        - chmod +x install.sh\n+        - ./install.sh --user\n+      before_script:\n+        - cp third-party/Cargo.lock .\n+        - cargo vendor --versioned-dirs --locked third-party/vendor\n+      script:\n+        - bazel run demo-rs:demo_rs --verbose_failures --noshow_progress\ndiff --git /dev/null b/BUILD\nnew file mode 100644\n--- /dev/null\n+++ b/BUILD\n@@ -0,0 +1,63 @@\n+load(\"//:build/rust.bzl\", \"rust_binary\", \"rust_library\")\n+\n+rust_library(\n+    name = \"cxx\",\n+    srcs = glob([\"src/**/*.rs\"]),\n+    data = [\"src/gen/include/cxxbridge.h\"],\n+    visibility = [\"//visibility:public\"],\n+    deps = [\n+        \":core_lib\",\n+        \":cxxbridge_macro\",\n+        \"//third-party:anyhow\",\n+        \"//third-party:cc\",\n+        \"//third-party:codespan\",\n+        \"//third-party:codespan_reporting\",\n+        \"//third-party:link_cplusplus\",\n+        \"//third-party:proc_macro2\",\n+        \"//third-party:quote\",\n+        \"//third-party:syn\",\n+        \"//third-party:thiserror\",\n+    ],\n+)\n+\n+rust_binary(\n+    name = \"codegen\",\n+    srcs = glob([\"cmd/src/**/*.rs\"]),\n+    data = [\"cmd/src/gen/include/cxxbridge.h\"],\n+    visibility = [\"//visibility:public\"],\n+    deps = [\n+        \"//third-party:anyhow\",\n+        \"//third-party:codespan\",\n+        \"//third-party:codespan_reporting\",\n+        \"//third-party:proc_macro2\",\n+        \"//third-party:quote\",\n+        \"//third-party:structopt\",\n+        \"//third-party:syn\",\n+        \"//third-party:thiserror\",\n+    ],\n+)\n+\n+cc_library(\n+    name = \"core\",\n+    hdrs = [\"include/cxxbridge.h\"],\n+    include_prefix = \"cxxbridge\",\n+    strip_include_prefix = \"include\",\n+    visibility = [\"//visibility:public\"],\n+)\n+\n+cc_library(\n+    name = \"core_lib\",\n+    srcs = [\"src/cxxbridge.cc\"],\n+    hdrs = [\"include/cxxbridge.h\"],\n+)\n+\n+rust_library(\n+    name = \"cxxbridge_macro\",\n+    srcs = glob([\"macro/src/**\"]),\n+    crate_type = \"proc-macro\",\n+    deps = [\n+        \"//third-party:proc_macro2\",\n+        \"//third-party:quote\",\n+        \"//third-party:syn\",\n+    ],\n+)\ndiff --git /dev/null b/WORKSPACE\nnew file mode 100644\n--- /dev/null\n+++ b/WORKSPACE\n@@ -0,0 +1,32 @@\n+load(\"@bazel_tools//tools/build_defs/repo:http.bzl\", \"http_archive\")\n+\n+http_archive(\n+    name = \"io_bazel_rules_rust\",\n+    sha256 = \"3d3faa85e49ebf4d26c40075549a17739d636360064b94a9d481b37ace0add82\",\n+    strip_prefix = \"rules_rust-6e87304c834c30b9c9f585cad19f30e7045281d7\",\n+    # Master branch as of 2020-02-22\n+    url = \"https://github.com/bazelbuild/rules_rust/archive/6e87304c834c30b9c9f585cad19f30e7045281d7.tar.gz\",\n+)\n+\n+http_archive(\n+    name = \"bazel_skylib\",\n+    sha256 = \"97e70364e9249702246c0e9444bccdc4b847bed1eb03c5a3ece4f83dfe6abc44\",\n+    urls = [\n+        \"https://mirror.bazel.build/github.com/bazelbuild/bazel-skylib/releases/download/1.0.2/bazel-skylib-1.0.2.tar.gz\",\n+        \"https://github.com/bazelbuild/bazel-skylib/releases/download/1.0.2/bazel-skylib-1.0.2.tar.gz\",\n+    ],\n+)\n+\n+load(\"@io_bazel_rules_rust//:workspace.bzl\", \"bazel_version\")\n+\n+bazel_version(name = \"bazel_version\")\n+\n+load(\"@io_bazel_rules_rust//rust:repositories.bzl\", \"rust_repository_set\")\n+\n+rust_repository_set(\n+    name = \"rust_1_42_beta\",\n+    exec_triple = \"x86_64-unknown-linux-gnu\",\n+    extra_target_triples = [],\n+    iso_date = \"2020-02-08\",\n+    version = \"beta\",\n+)\ndiff --git /dev/null b/build/rust.bzl\nnew file mode 100644\n--- /dev/null\n+++ b/build/rust.bzl\n@@ -0,0 +1,19 @@\n+load(\n+    \"@io_bazel_rules_rust//rust:rust.bzl\",\n+    _rust_binary = \"rust_binary\",\n+    _rust_library = \"rust_library\",\n+)\n+\n+def rust_binary(edition = \"2018\", **kwargs):\n+    _rust_binary(edition = edition, **kwargs)\n+\n+def third_party_rust_binary(rustc_flags = [], **kwargs):\n+    rustc_flags = rustc_flags + [\"--cap-lints=allow\"]\n+    rust_binary(rustc_flags = rustc_flags, **kwargs)\n+\n+def rust_library(edition = \"2018\", **kwargs):\n+    _rust_library(edition = edition, **kwargs)\n+\n+def third_party_rust_library(rustc_flags = [], **kwargs):\n+    rustc_flags = rustc_flags + [\"--cap-lints=allow\"]\n+    rust_library(rustc_flags = rustc_flags, **kwargs)\ndiff --git /dev/null b/demo-cxx/BUILD\nnew file mode 100644\n--- /dev/null\n+++ b/demo-cxx/BUILD\n@@ -0,0 +1,16 @@\n+cc_library(\n+    name = \"demo-cxx\",\n+    srcs = [\"demo.cc\"],\n+    visibility = [\"//visibility:public\"],\n+    deps = [\n+        \":include\",\n+        \"//demo-rs:include\",\n+    ],\n+)\n+\n+cc_library(\n+    name = \"include\",\n+    hdrs = [\"demo.h\"],\n+    visibility = [\"//visibility:public\"],\n+    deps = [\"//:core\"],\n+)\ndiff --git /dev/null b/demo-rs/BUILD\nnew file mode 100644\n--- /dev/null\n+++ b/demo-rs/BUILD\n@@ -0,0 +1,43 @@\n+load(\"//:build/rust.bzl\", \"rust_binary\", \"rust_library\")\n+\n+rust_binary(\n+    name = \"demo_rs\",\n+    srcs = glob([\"src/**\"]),\n+    deps = [\n+        \":gen\",\n+        \"//:cxx\",\n+        \"//demo-cxx\",\n+    ],\n+)\n+\n+cc_library(\n+    name = \"gen\",\n+    srcs = [\":gen-source\"],\n+    deps = [\n+        \":include\",\n+        \"//demo-cxx:include\",\n+    ],\n+)\n+\n+genrule(\n+    name = \"gen-header\",\n+    srcs = [\"src/main.rs\"],\n+    outs = [\"main.rs\"],\n+    cmd = \"$(location //:codegen) --header $< > $@\",\n+    tools = [\"//:codegen\"],\n+)\n+\n+genrule(\n+    name = \"gen-source\",\n+    srcs = [\"src/main.rs\"],\n+    outs = [\"gen-demo.cc\"],\n+    cmd = \"$(location //:codegen) $< > $@\",\n+    tools = [\"//:codegen\"],\n+)\n+\n+cc_library(\n+    name = \"include\",\n+    hdrs = [\":gen-header\"],\n+    include_prefix = \"demo-rs/src\",\n+    visibility = [\"//visibility:public\"],\n+)\ndiff --git /dev/null b/third-party/BUILD\nnew file mode 100644\n--- /dev/null\n+++ b/third-party/BUILD\n@@ -0,0 +1,249 @@\n+load(\n+    \"//:build/rust.bzl\",\n+    rust_binary = \"third_party_rust_binary\",\n+    rust_library = \"third_party_rust_library\",\n+)\n+load(\"@bazel_tools//tools/build_defs/pkg:pkg.bzl\", \"pkg_tar\")\n+\n+rust_library(\n+    name = \"anyhow\",\n+    srcs = glob([\"vendor/anyhow-1.0.26/src/**\"]),\n+    crate_features = [\"std\"],\n+    visibility = [\"//visibility:public\"],\n+)\n+\n+rust_library(\n+    name = \"bitflags\",\n+    srcs = glob([\"vendor/bitflags-1.2.1/src/**\"]),\n+)\n+\n+rust_library(\n+    name = \"cc\",\n+    srcs = glob([\"vendor/cc-1.0.50/src/**\"]),\n+    visibility = [\"//visibility:public\"],\n+)\n+\n+rust_library(\n+    name = \"clap\",\n+    srcs = glob([\"vendor/clap-2.33.0/src/**\"]),\n+    edition = \"2015\",\n+    deps = [\n+        \":bitflags\",\n+        \":textwrap\",\n+        \":unicode_width\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"codespan\",\n+    srcs = glob([\"vendor/codespan-0.7.0/src/**\"]),\n+    visibility = [\"//visibility:public\"],\n+    deps = [\":unicode_segmentation\"],\n+)\n+\n+rust_library(\n+    name = \"codespan_reporting\",\n+    srcs = glob([\"vendor/codespan-reporting-0.7.0/src/**\"]),\n+    visibility = [\"//visibility:public\"],\n+    deps = [\n+        \":codespan\",\n+        \":termcolor\",\n+        \":unicode_width\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"heck\",\n+    srcs = glob([\"vendor/heck-0.3.1/src/**\"]),\n+    edition = \"2015\",\n+    deps = [\":unicode_segmentation\"],\n+)\n+\n+rust_library(\n+    name = \"lazy_static\",\n+    srcs = glob([\"vendor/lazy_static-1.4.0/src/**\"]),\n+)\n+\n+rust_library(\n+    name = \"link_cplusplus\",\n+    srcs = glob([\"vendor/link-cplusplus-1.0.1/src/**\"]),\n+    visibility = [\"//visibility:public\"],\n+)\n+\n+rust_library(\n+    name = \"proc_macro_error\",\n+    srcs = glob([\"vendor/proc-macro-error-0.4.9/src/**\"]),\n+    rustc_flags = [\"--cfg=use_fallback\"],\n+    deps = [\n+        \":proc_macro2\",\n+        \":proc_macro_error_attr\",\n+        \":quote\",\n+        \":syn\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"proc_macro_error_attr\",\n+    srcs = glob([\"vendor/proc-macro-error-attr-0.4.9/src/**\"]),\n+    crate_type = \"proc-macro\",\n+    deps = [\n+        \":proc_macro2\",\n+        \":quote\",\n+        \":rustversion\",\n+        \":syn\",\n+        \":syn_mid\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"proc_macro2\",\n+    srcs = glob([\"vendor/proc-macro2-1.0.8/src/**\"]),\n+    crate_features = [\n+        \"proc-macro\",\n+        \"span-locations\",\n+    ],\n+    rustc_flags = [\n+        \"--cfg=span_locations\",\n+        \"--cfg=use_proc_macro\",\n+        \"--cfg=wrap_proc_macro\",\n+    ],\n+    visibility = [\"//visibility:public\"],\n+    deps = [\":unicode_xid\"],\n+)\n+\n+rust_library(\n+    name = \"quote\",\n+    srcs = glob([\"vendor/quote-1.0.2/src/**\"]),\n+    crate_features = [\"proc-macro\"],\n+    visibility = [\"//visibility:public\"],\n+    deps = [\":proc_macro2\"],\n+)\n+\n+rust_library(\n+    name = \"rustversion\",\n+    srcs = glob([\"vendor/rustversion-1.0.2/src/**\"]),\n+    crate_type = \"proc-macro\",\n+    out_dir_tar = \":rustversion_buildscript_outdir\",\n+    deps = [\n+        \":proc_macro2\",\n+        \":quote\",\n+        \":syn\",\n+    ],\n+)\n+\n+rust_binary(\n+    name = \"rustversion_buildscript\",\n+    srcs = glob([\"vendor/rustversion-1.0.2/build/**\"]),\n+    crate_root = \"vendor/rustversion-1.0.2/build/build.rs\",\n+)\n+\n+pkg_tar(\n+    name = \"rustversion_buildscript_outdir\",\n+    srcs = [\":rustversion_buildscript_run\"],\n+    extension = \"tar.gz\",\n+)\n+\n+genrule(\n+    name = \"rustversion_buildscript_run\",\n+    outs = [\"version.rs\"],\n+    cmd = \"OUT_DIR=$(@D) $(location :rustversion_buildscript)\",\n+    tools = [\":rustversion_buildscript\"],\n+)\n+\n+rust_library(\n+    name = \"structopt\",\n+    srcs = glob([\"vendor/structopt-0.3.9/src/**\"]),\n+    visibility = [\"//visibility:public\"],\n+    deps = [\n+        \":clap\",\n+        \":lazy_static\",\n+        \":structopt_derive\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"structopt_derive\",\n+    srcs = glob([\"vendor/structopt-derive-0.4.2/src/**\"]),\n+    crate_type = \"proc-macro\",\n+    deps = [\n+        \":heck\",\n+        \":proc_macro2\",\n+        \":proc_macro_error\",\n+        \":quote\",\n+        \":syn\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"syn\",\n+    srcs = glob([\"vendor/syn-1.0.14/src/**\"]),\n+    crate_features = [\n+        \"clone-impls\",\n+        \"derive\",\n+        \"full\",\n+        \"parsing\",\n+        \"printing\",\n+        \"proc-macro\",\n+    ],\n+    visibility = [\"//visibility:public\"],\n+    deps = [\n+        \":proc_macro2\",\n+        \":quote\",\n+        \":unicode_xid\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"syn_mid\",\n+    srcs = glob([\"vendor/syn-mid-0.5.0/src/**\"]),\n+    deps = [\n+        \":proc_macro2\",\n+        \":quote\",\n+        \":syn\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"termcolor\",\n+    srcs = glob([\"vendor/termcolor-1.1.0/src/**\"]),\n+)\n+\n+rust_library(\n+    name = \"textwrap\",\n+    srcs = glob([\"vendor/textwrap-0.11.0/src/**\"]),\n+    deps = [\":unicode_width\"],\n+)\n+\n+rust_library(\n+    name = \"thiserror\",\n+    srcs = glob([\"vendor/thiserror-1.0.11/src/**\"]),\n+    visibility = [\"//visibility:public\"],\n+    deps = [\":thiserror_impl\"],\n+)\n+\n+rust_library(\n+    name = \"thiserror_impl\",\n+    srcs = glob([\"vendor/thiserror-impl-1.0.11/src/**\"]),\n+    crate_type = \"proc-macro\",\n+    deps = [\n+        \":proc_macro2\",\n+        \":quote\",\n+        \":syn\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"unicode_segmentation\",\n+    srcs = glob([\"vendor/unicode-segmentation-1.6.0/src/**\"]),\n+    edition = \"2015\",\n+)\n+\n+rust_library(\n+    name = \"unicode_width\",\n+    srcs = glob([\"vendor/unicode-width-0.1.7/src/**\"]),\n+)\n+\n+rust_library(\n+    name = \"unicode_xid\",\n+    srcs = glob([\"vendor/unicode-xid-0.2.0/src/**\"]),\n+)\n",
        "test_patch": "diff --git a/.gitignore b/.gitignore\n--- a/.gitignore\n+++ b/.gitignore\n@@ -1,4 +1,8 @@\n /.buckd\n+/bazel-bin\n+/bazel-cxx\n+/bazel-out\n+/bazel-testlogs\n /buck-out\n /Cargo.lock\n /expand.cc\n",
        "problem_statement": "Add continuous integration build that uses Bazel\n\n(WIP) Bazel CI\nThis might get a little noisy as I make sure this stuff works on Travis.\n",
        "hints_text": "I've started working on this. I think the best example would use cargo raze to install cxx itself (using a path to the root of the repo), and build a small crate that uses cxx and a small rust dependency (like num_cpus). I have this script generating a bunch of Bazel build files now:\r\n\r\n```\r\n#!/usr/bin/env bash\r\n\r\ncargo generate-lockfile && \\\r\ncargo vendor --versioned-dirs --locked && \\\r\ncargo raze && \\\r\ncat >> $(find vendor/cxx-* -name \"BUILD.bazel\") <<- EOM\r\n\r\ncc_library(\r\n name=\"cxx_cc_library\",\r\n hdrs=glob([\"include/**/*.h\"]),\r\n srcs=glob([\"src/**/*.cc\"]),\r\n)\r\n\r\nEOM\r\n```\nLooks good! I think you may also need to add a dep from the cxx crate rust_library target on the cxx_cc_library target. I am open to accepting whatever metadata needs to go in our Cargo.toml to get cargo-raze to make sense of that dependency edge.\nIn my code, I'm only doing C++ to Rust, where you need to create a wrapper cc_library anyway, in Bazel. I just put the dependency on the generated library there. I think it would be a gnarlier and more brittle script to modify the deps of the rust_library.\r\n\r\nhttps://github.com/bazelbuild/rules_rust/tree/master/examples/ffi\r\n\r\nI'll do a Rust to C++ example as well, though.\nOK, this build installs Bazel, cargo-raze and generates build files, but doesn't actually do anything with Bazel yet. Will update. ",
        "created_at": "2020-02-23T00:02:33Z",
        "version": "0.1"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 34,
        "instance_id": "dtolnay__cxx-34",
        "issue_numbers": [
            "29"
        ],
        "base_commit": "bd3a6b27fbe857c1861ab645c9c0386f6173e421",
        "patch": "diff --git /dev/null b/.buckconfig\nnew file mode 100644\n--- /dev/null\n+++ b/.buckconfig\n@@ -0,0 +1,12 @@\n+[project]\n+  # We use some symlinks in the source tree, but they get eliminated by `cargo\n+  # publish` and `cargo vendor` so this allow_symlinks setting should not be\n+  # required downstream.\n+  allow_symlinks = allow\n+\n+[cxx]\n+  cxxflags = -std=c++11\n+\n+[rust]\n+  default_edition = 2018\n+  rustc_flags = -Crelocation-model=dynamic-no-pic --cap-lints=allow\ndiff --git a/.gitignore b/.gitignore\n--- a/.gitignore\n+++ b/.gitignore\n@@ -1,3 +1,5 @@\n+/.buckd\n+/buck-out\n /Cargo.lock\n /expand.cc\n /expand.rs\ndiff --git /dev/null b/BUCK\nnew file mode 100644\n--- /dev/null\n+++ b/BUCK\n@@ -0,0 +1,60 @@\n+rust_library(\n+    name = \"cxx\",\n+    srcs = glob([\"src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+    deps = [\n+        \":core\",\n+        \":macro\",\n+        \"//third-party:anyhow\",\n+        \"//third-party:cc\",\n+        \"//third-party:codespan\",\n+        \"//third-party:codespan-reporting\",\n+        \"//third-party:link-cplusplus\",\n+        \"//third-party:proc-macro2\",\n+        \"//third-party:quote\",\n+        \"//third-party:syn\",\n+        \"//third-party:thiserror\",\n+    ],\n+)\n+\n+rust_binary(\n+    name = \"codegen\",\n+    srcs = glob([\"cmd/src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+    env = {\n+        \"CARGO_PKG_AUTHORS\": \"David Tolnay <dtolnay@gmail.com>\",\n+    },\n+    deps = [\n+        \"//third-party:anyhow\",\n+        \"//third-party:codespan\",\n+        \"//third-party:codespan-reporting\",\n+        \"//third-party:proc-macro2\",\n+        \"//third-party:quote\",\n+        \"//third-party:structopt\",\n+        \"//third-party:syn\",\n+        \"//third-party:thiserror\",\n+    ],\n+)\n+\n+cxx_library(\n+    name = \"core\",\n+    srcs = [\"src/cxxbridge.cc\"],\n+    visibility = [\"PUBLIC\"],\n+    header_namespace = \"cxxbridge\",\n+    exported_headers = {\n+        \"cxxbridge.h\": \"include/cxxbridge.h\",\n+    },\n+    exported_linker_flags = [\"-lstdc++\"],\n+)\n+\n+rust_library(\n+    name = \"macro\",\n+    srcs = glob([\"macro/src/**\"]),\n+    proc_macro = True,\n+    crate = \"cxxbridge_macro\",\n+    deps = [\n+        \"//third-party:proc-macro2\",\n+        \"//third-party:quote\",\n+        \"//third-party:syn\",\n+    ],\n+)\ndiff --git /dev/null b/demo-cxx/BUCK\nnew file mode 100644\n--- /dev/null\n+++ b/demo-cxx/BUCK\n@@ -0,0 +1,16 @@\n+cxx_library(\n+    name = \"demo-cxx\",\n+    srcs = [\"demo.cc\"],\n+    visibility = [\"PUBLIC\"],\n+    deps = [\n+        \":include\",\n+        \"//demo-rs:include\",\n+    ],\n+)\n+\n+cxx_library(\n+    name = \"include\",\n+    exported_headers = [\"demo.h\"],\n+    visibility = [\"PUBLIC\"],\n+    deps = [\"//:core\"],\n+)\ndiff --git /dev/null b/demo-rs/BUCK\nnew file mode 100644\n--- /dev/null\n+++ b/demo-rs/BUCK\n@@ -0,0 +1,42 @@\n+rust_binary(\n+    name = \"demo-rs\",\n+    srcs = glob([\"src/**\"]),\n+    deps = [\n+        \":gen\",\n+        \"//:cxx\",\n+        \"//demo-cxx:demo-cxx\",\n+    ],\n+)\n+\n+cxx_library(\n+    name = \"gen\",\n+    srcs = [\":gen-source\"],\n+    deps = [\n+        \":include\",\n+        \"//demo-cxx:include\",\n+    ],\n+)\n+\n+genrule(\n+    name = \"gen-header\",\n+    srcs = [\"src/main.rs\"],\n+    cmd = \"$(exe //:codegen) --header ${SRCS} > ${OUT}\",\n+    type = \"cxxbridge\",\n+    out = \"gen-demo.h\",\n+)\n+\n+genrule(\n+    name = \"gen-source\",\n+    srcs = [\"src/main.rs\"],\n+    cmd = \"$(exe //:codegen) ${SRCS} > ${OUT}\",\n+    type = \"cxxbridge\",\n+    out = \"gen-demo.cc\",\n+)\n+\n+cxx_library(\n+    name = \"include\",\n+    exported_headers = {\n+        \"src/main.rs\": \":gen-header\",\n+    },\n+    visibility = [\"PUBLIC\"],\n+)\ndiff --git /dev/null b/third-party/.gitignore\nnew file mode 100644\n--- /dev/null\n+++ b/third-party/.gitignore\n@@ -0,0 +1,1 @@\n+/vendor\ndiff --git /dev/null b/third-party/BUCK\nnew file mode 100644\n--- /dev/null\n+++ b/third-party/BUCK\n@@ -0,0 +1,243 @@\n+# To be generated by Facebook's `reindeer` tool once that is open source.\n+\n+rust_library(\n+    name = \"anyhow\",\n+    srcs = glob([\"vendor/anyhow-1.0.26/src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+    features = [\"std\"],\n+)\n+\n+rust_library(\n+    name = \"bitflags\",\n+    srcs = glob([\"vendor/bitflags-1.2.1/src/**\"]),\n+)\n+\n+rust_library(\n+    name = \"cc\",\n+    srcs = glob([\"vendor/cc-1.0.50/src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+)\n+\n+rust_library(\n+    name = \"clap\",\n+    srcs = glob([\"vendor/clap-2.33.0/src/**\"]),\n+    edition = \"2015\",\n+    deps = [\n+        \":bitflags\",\n+        \":textwrap\",\n+        \":unicode-width\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"codespan\",\n+    srcs = glob([\"vendor/codespan-0.7.0/src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+    deps = [\":unicode-segmentation\"],\n+)\n+\n+rust_library(\n+    name = \"codespan-reporting\",\n+    srcs = glob([\"vendor/codespan-reporting-0.7.0/src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+    deps = [\n+        \":codespan\",\n+        \":termcolor\",\n+        \":unicode-width\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"heck\",\n+    srcs = glob([\"vendor/heck-0.3.1/src/**\"]),\n+    edition = \"2015\",\n+    deps = [\":unicode-segmentation\"],\n+)\n+\n+rust_library(\n+    name = \"lazy_static\",\n+    srcs = glob([\"vendor/lazy_static-1.4.0/src/**\"]),\n+)\n+\n+rust_library(\n+    name = \"link-cplusplus\",\n+    srcs = glob([\"vendor/link-cplusplus-1.0.1/src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+)\n+\n+rust_library(\n+    name = \"proc-macro-error\",\n+    srcs = glob([\"vendor/proc-macro-error-0.4.9/src/**\"]),\n+    rustc_flags = [\"--cfg=use_fallback\"],\n+    deps = [\n+        \":proc-macro-error-attr\",\n+        \":proc-macro2\",\n+        \":quote\",\n+        \":syn\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"proc-macro-error-attr\",\n+    srcs = glob([\"vendor/proc-macro-error-attr-0.4.9/src/**\"]),\n+    proc_macro = True,\n+    deps = [\n+        \":proc-macro2\",\n+        \":quote\",\n+        \":rustversion\",\n+        \":syn\",\n+        \":syn-mid\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"proc-macro2\",\n+    srcs = glob([\"vendor/proc-macro2-1.0.8/src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+    features = [\n+        \"proc-macro\",\n+        \"span-locations\",\n+    ],\n+    rustc_flags = [\n+        \"--cfg=span_locations\",\n+        \"--cfg=use_proc_macro\",\n+        \"--cfg=wrap_proc_macro\",\n+    ],\n+    deps = [\":unicode-xid\"],\n+)\n+\n+rust_library(\n+    name = \"quote\",\n+    srcs = glob([\"vendor/quote-1.0.2/src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+    features = [\"proc-macro\"],\n+    deps = [\":proc-macro2\"],\n+)\n+\n+rust_library(\n+    name = \"rustversion\",\n+    srcs = glob([\"vendor/rustversion-1.0.2/src/**\"]),\n+    mapped_srcs = {\n+        \":rustversion-buildscript-run\": \"vendor/rustversion-1.0.2/src/generated\",\n+    },\n+    proc_macro = True,\n+    env = {\n+        \"OUT_DIR\": \"generated\",\n+    },\n+    deps = [\n+        \":proc-macro2\",\n+        \":quote\",\n+        \":syn\",\n+    ],\n+)\n+\n+rust_binary(\n+    name = \"rustversion-buildscript\",\n+    srcs = glob([\"vendor/rustversion-1.0.2/build/**\"]),\n+    crate_root = \"vendor/rustversion-1.0.2/build/build.rs\",\n+)\n+\n+genrule(\n+    name = \"rustversion-buildscript-run\",\n+    cmd = \"OUT_DIR=${OUT} $(exe :rustversion-buildscript)\",\n+    type = \"build.rs\",\n+    out = \".\",\n+)\n+\n+rust_library(\n+    name = \"structopt\",\n+    srcs = glob([\"vendor/structopt-0.3.9/src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+    deps = [\n+        \":clap\",\n+        \":lazy_static\",\n+        \":structopt-derive\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"structopt-derive\",\n+    srcs = glob([\"vendor/structopt-derive-0.4.2/src/**\"]),\n+    proc_macro = True,\n+    deps = [\n+        \":heck\",\n+        \":proc-macro-error\",\n+        \":proc-macro2\",\n+        \":quote\",\n+        \":syn\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"syn\",\n+    srcs = glob([\"vendor/syn-1.0.14/src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+    features = [\n+        \"clone-impls\",\n+        \"derive\",\n+        \"full\",\n+        \"parsing\",\n+        \"printing\",\n+        \"proc-macro\",\n+    ],\n+    deps = [\n+        \":proc-macro2\",\n+        \":quote\",\n+        \":unicode-xid\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"syn-mid\",\n+    srcs = glob([\"vendor/syn-mid-0.5.0/src/**\"]),\n+    deps = [\n+        \":proc-macro2\",\n+        \":quote\",\n+        \":syn\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"termcolor\",\n+    srcs = glob([\"vendor/termcolor-1.1.0/src/**\"]),\n+)\n+\n+rust_library(\n+    name = \"textwrap\",\n+    srcs = glob([\"vendor/textwrap-0.11.0/src/**\"]),\n+    deps = [\":unicode-width\"],\n+)\n+\n+rust_library(\n+    name = \"thiserror\",\n+    srcs = glob([\"vendor/thiserror-1.0.11/src/**\"]),\n+    visibility = [\"PUBLIC\"],\n+    deps = [\":thiserror-impl\"],\n+)\n+\n+rust_library(\n+    name = \"thiserror-impl\",\n+    srcs = glob([\"vendor/thiserror-impl-1.0.11/src/**\"]),\n+    proc_macro = True,\n+    deps = [\n+        \":proc-macro2\",\n+        \":quote\",\n+        \":syn\",\n+    ],\n+)\n+\n+rust_library(\n+    name = \"unicode-segmentation\",\n+    srcs = glob([\"vendor/unicode-segmentation-1.6.0/src/**\"]),\n+    edition = \"2015\",\n+)\n+\n+rust_library(\n+    name = \"unicode-width\",\n+    srcs = glob([\"vendor/unicode-width-0.1.7/src/**\"]),\n+)\n+\n+rust_library(\n+    name = \"unicode-xid\",\n+    srcs = glob([\"vendor/unicode-xid-0.2.0/src/**\"]),\n+)\ndiff --git /dev/null b/third-party/Cargo.lock\nnew file mode 100644\n--- /dev/null\n+++ b/third-party/Cargo.lock\n@@ -0,0 +1,434 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+[[package]]\n+name = \"ansi_term\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"anyhow\"\n+version = \"1.0.26\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7825f6833612eb2414095684fcf6c635becf3ce97fe48cf6421321e93bfbd53c\"\n+\n+[[package]]\n+name = \"atty\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8\"\n+dependencies = [\n+ \"hermit-abi\",\n+ \"libc\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"bitflags\"\n+version = \"1.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n+\n+[[package]]\n+name = \"cc\"\n+version = \"1.0.50\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"95e28fa049fda1c330bcf9d723be7663a899c4679724b34c81e9f5a326aab8cd\"\n+\n+[[package]]\n+name = \"clap\"\n+version = \"2.33.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9\"\n+dependencies = [\n+ \"ansi_term\",\n+ \"atty\",\n+ \"bitflags\",\n+ \"strsim\",\n+ \"textwrap\",\n+ \"unicode-width\",\n+ \"vec_map\",\n+]\n+\n+[[package]]\n+name = \"codespan\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"21094c000d5db8035900662bbfddec754e79f795324254ac0817f36e5ccfc3f5\"\n+dependencies = [\n+ \"unicode-segmentation\",\n+]\n+\n+[[package]]\n+name = \"codespan-reporting\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"657b2c99e1f17bc3e5153808d9f704c8ba6171c3fe45e69fde26e2876156938b\"\n+dependencies = [\n+ \"codespan\",\n+ \"termcolor\",\n+ \"unicode-width\",\n+]\n+\n+[[package]]\n+name = \"cxx\"\n+version = \"0.1.2\"\n+dependencies = [\n+ \"anyhow\",\n+ \"cc\",\n+ \"codespan\",\n+ \"codespan-reporting\",\n+ \"cxxbridge-macro\",\n+ \"link-cplusplus\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"rustversion\",\n+ \"syn\",\n+ \"thiserror\",\n+ \"trybuild\",\n+]\n+\n+[[package]]\n+name = \"cxxbridge-cmd\"\n+version = \"0.1.2\"\n+dependencies = [\n+ \"anyhow\",\n+ \"codespan\",\n+ \"codespan-reporting\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"structopt\",\n+ \"syn\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"cxxbridge-demo\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cxx\",\n+]\n+\n+[[package]]\n+name = \"cxxbridge-macro\"\n+version = \"0.1.2\"\n+dependencies = [\n+ \"cxx\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"glob\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9b919933a397b79c37e33b77bb2aa3dc8eb6e165ad809e58ff75bc7db2e34574\"\n+\n+[[package]]\n+name = \"heck\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"20564e78d53d2bb135c343b3f47714a56af2061f1c928fdb541dc7b9fdd94205\"\n+dependencies = [\n+ \"unicode-segmentation\",\n+]\n+\n+[[package]]\n+name = \"hermit-abi\"\n+version = \"0.1.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e2c55f143919fbc0bc77e427fe2d74cf23786d7c1875666f2fde3ac3c659bb67\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"itoa\"\n+version = \"0.4.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b8b7a7c0c47db5545ed3fef7468ee7bb5b74691498139e4b3f6a20685dc6dd8e\"\n+\n+[[package]]\n+name = \"lazy_static\"\n+version = \"1.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.66\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d515b1f41455adea1313a4a2ac8a8a477634fbae63cc6100e3aebb207ce61558\"\n+\n+[[package]]\n+name = \"link-cplusplus\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"628cd9d7b5c99cb930617438a3d7896f5eb734647bc2838ded9ca50689507295\"\n+dependencies = [\n+ \"cc\",\n+]\n+\n+[[package]]\n+name = \"proc-macro-error\"\n+version = \"0.4.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"052b3c9af39c7e5e94245f820530487d19eb285faedcb40e0c3275132293f242\"\n+dependencies = [\n+ \"proc-macro-error-attr\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"rustversion\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"proc-macro-error-attr\"\n+version = \"0.4.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d175bef481c7902e63e3165627123fff3502f06ac043d3ef42d08c1246da9253\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"rustversion\",\n+ \"syn\",\n+ \"syn-mid\",\n+]\n+\n+[[package]]\n+name = \"proc-macro2\"\n+version = \"1.0.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3acb317c6ff86a4e579dfa00fc5e6cca91ecbb4e7eb2df0468805b674eb88548\"\n+dependencies = [\n+ \"unicode-xid\",\n+]\n+\n+[[package]]\n+name = \"quote\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n+dependencies = [\n+ \"proc-macro2\",\n+]\n+\n+[[package]]\n+name = \"rustversion\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b3bba175698996010c4f6dce5e7f173b6eb781fce25d2cfc45e27091ce0b79f6\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"ryu\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bfa8506c1de11c9c4e4c38863ccbe02a305c8188e85a05a784c9e11e1c3910c8\"\n+\n+[[package]]\n+name = \"serde\"\n+version = \"1.0.104\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"414115f25f818d7dfccec8ee535d76949ae78584fc4f79a6f45a904bf8ab4449\"\n+dependencies = [\n+ \"serde_derive\",\n+]\n+\n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.104\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"128f9e303a5a29922045a830221b8f78ec74a5f544944f3d5984f8ec3895ef64\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"1.0.48\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9371ade75d4c2d6cb154141b9752cf3781ec9c05e0e5cf35060e1e70ee7b9c25\"\n+dependencies = [\n+ \"itoa\",\n+ \"ryu\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"strsim\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n+\n+[[package]]\n+name = \"structopt\"\n+version = \"0.3.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a1bcbed7d48956fcbb5d80c6b95aedb553513de0a1b451ea92679d999c010e98\"\n+dependencies = [\n+ \"clap\",\n+ \"lazy_static\",\n+ \"structopt-derive\",\n+]\n+\n+[[package]]\n+name = \"structopt-derive\"\n+version = \"0.4.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"095064aa1f5b94d14e635d0a5684cf140c43ae40a0fd990708d38f5d669e5f64\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro-error\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"1.0.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"af6f3550d8dff9ef7dc34d384ac6f107e5d31c8f57d9f28e0081503f547ac8f5\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-xid\",\n+]\n+\n+[[package]]\n+name = \"syn-mid\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7be3539f6c128a931cf19dcee741c1af532c7fd387baa739c03dd2e96479338a\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"termcolor\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bb6bfa289a4d7c5766392812c0a1f4c1ba45afa1ad47803c11e1f407d846d75f\"\n+dependencies = [\n+ \"winapi-util\",\n+]\n+\n+[[package]]\n+name = \"textwrap\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060\"\n+dependencies = [\n+ \"unicode-width\",\n+]\n+\n+[[package]]\n+name = \"thiserror\"\n+version = \"1.0.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee14bf8e6767ab4c687c9e8bc003879e042a96fd67a3ba5934eadb6536bef4db\"\n+dependencies = [\n+ \"thiserror-impl\",\n+]\n+\n+[[package]]\n+name = \"thiserror-impl\"\n+version = \"1.0.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a7b51e1fbc44b5a0840be594fbc0f960be09050f2617e61e6aa43bef97cd3ef4\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"toml\"\n+version = \"0.5.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ffc92d160b1eef40665be3a05630d003936a3bc7da7421277846c2613e92c71a\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"trybuild\"\n+version = \"1.0.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3f5b3f750c701725331ac78e389b5d143b7d25f6b6ffffd0d419759a9063ac5f\"\n+dependencies = [\n+ \"glob\",\n+ \"lazy_static\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"termcolor\",\n+ \"toml\",\n+]\n+\n+[[package]]\n+name = \"unicode-segmentation\"\n+version = \"1.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e83e153d1053cbb5a118eeff7fd5be06ed99153f00dbcd8ae310c5fb2b22edc0\"\n+\n+[[package]]\n+name = \"unicode-width\"\n+version = \"0.1.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"caaa9d531767d1ff2150b9332433f32a24622147e5ebb1f26409d5da67afd479\"\n+\n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\"\n+\n+[[package]]\n+name = \"vec_map\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"05c78687fb1a80548ae3250346c3db86a80a7cdd77bda190189f2d0a0987c81a\"\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.3.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8093091eeb260906a183e6ae1abdba2ef5ef2257a21801128899c3fc699229c6\"\n+dependencies = [\n+ \"winapi-i686-pc-windows-gnu\",\n+ \"winapi-x86_64-pc-windows-gnu\",\n+]\n+\n+[[package]]\n+name = \"winapi-i686-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n+\n+[[package]]\n+name = \"winapi-util\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ccfbf554c6ad11084fb7517daca16cfdcaccbdadba4fc336f032a8b12c2ad80\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"winapi-x86_64-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n",
        "test_patch": "diff --git a/.travis.yml b/.travis.yml\n--- a/.travis.yml\n+++ b/.travis.yml\n@@ -9,3 +9,18 @@ os:\n script:\n   - cargo run --manifest-path demo-rs/Cargo.toml\n   - cargo test\n+\n+matrix:\n+  include:\n+    - name: Buck\n+      before_install:\n+        - sudo apt-get install -y openjdk-8-jdk\n+        - export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64\n+        - wget -O buck.deb https://github.com/facebook/buck/releases/download/v2019.10.17.01/buck.2019.10.17.01_all.deb\n+        - sudo dpkg -i buck.deb\n+      before_script:\n+        - cp third-party/Cargo.lock .\n+        - cargo vendor --versioned-dirs third-party/vendor\n+      script:\n+        - buck build :cxx#check --verbose=0\n+        - buck run demo-rs --verbose=0\n",
        "problem_statement": "Add continuous integration build that uses Buck\n\n",
        "hints_text": "",
        "created_at": "2020-02-18T05:27:14Z",
        "version": "0.1"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 794,
        "instance_id": "dtolnay__cxx-794",
        "issue_numbers": [
            "766"
        ],
        "base_commit": "fdbb2f84296ba3785053d1571c6ca8fa3b3e7711",
        "patch": "diff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -514,6 +514,7 @@ fn check_mut_return_restriction(cx: &mut Check, efn: &ExternFn) {\n \n     match &efn.ret {\n         Some(Type::Ref(ty)) if ty.mutable => {}\n+        Some(Type::SliceRef(slice)) if slice.mutable => {}\n         _ => return,\n     }\n \n",
        "test_patch": "diff --git a/tests/ui/mut_return.rs b/tests/ui/mut_return.rs\n--- a/tests/ui/mut_return.rs\n+++ b/tests/ui/mut_return.rs\n@@ -11,6 +11,7 @@ mod ffi {\n         unsafe fn g(t: &Thing) -> Pin<&mut CxxString>;\n         fn h(t: Box<Mut>) -> Pin<&mut CxxString>;\n         fn i<'a>(t: Box<Mut<'a>>) -> Pin<&'a mut CxxString>;\n+        fn j(t: &Thing) -> &mut [u8];\n     }\n }\n \ndiff --git a/tests/ui/mut_return.stderr b/tests/ui/mut_return.stderr\n--- a/tests/ui/mut_return.stderr\n+++ b/tests/ui/mut_return.stderr\n@@ -3,3 +3,9 @@ error: &mut return type is not allowed unless there is a &mut argument\n    |\n 10 |         fn f(t: &Thing) -> Pin<&mut CxxString>;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: &mut return type is not allowed unless there is a &mut argument\n+  --> $DIR/mut_return.rs:14:9\n+   |\n+14 |         fn j(t: &Thing) -> &mut [u8];\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
        "problem_statement": "Detect mutable slice in return position of a safe function\nThe check that detects turning a shared reference into an exclusive reference in a safe signature is not triggering for slice exclusive references, likely because those are represented differently from references to statically sized types in our internal syntax tree.\r\n\r\n```rust\r\n#[cxx::bridge]\r\nmod ffi {\r\n    unsafe extern \"C++\" {\r\n        fn f(x: &i32) -> &mut i32;  // correctly disallowed\r\n        fn g(x: &i32) -> &mut [i32];  // incorrectly allowed\r\n    }\r\n}\r\n```\r\n\r\n```console\r\nerror[cxxbridge]: &mut return type is not allowed unless there is a &mut argument\r\n  \u250c\u2500 src/main.rs:4:9\r\n  \u2502\r\n4 \u2502         fn f(x: &i32) -> &mut i32;\r\n  \u2502         ^^^^^^^^^^^^^^^^^^^^^^^^^^ &mut return type is not allowed unless there is a &mut argument\r\n```\n",
        "hints_text": "",
        "created_at": "2021-03-28T08:28:12Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 779,
        "instance_id": "dtolnay__cxx-779",
        "issue_numbers": [
            "765"
        ],
        "base_commit": "7eee043035d2fa4160d249371562c5325535c6ba",
        "patch": "diff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -1,5 +1,6 @@\n use crate::syntax::atom::Atom::{self, *};\n use crate::syntax::report::Errors;\n+use crate::syntax::visit::{self, Visit};\n use crate::syntax::{\n     error, ident, trivial, Api, Array, Enum, ExternFn, ExternType, Impl, Lang, NamedType, Ptr,\n     Receiver, Ref, Signature, SliceRef, Struct, Trait, Ty1, Type, TypeAlias, Types,\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -518,20 +519,45 @@ fn check_mut_return_restriction(cx: &mut Check, efn: &ExternFn) {\n         _ => return,\n     }\n \n-    if let Some(r) = &efn.receiver {\n-        if r.mutable {\n+    if let Some(receiver) = &efn.receiver {\n+        if receiver.mutable {\n+            return;\n+        }\n+        let resolve = cx.types.resolve(&receiver.ty);\n+        if !resolve.generics.lifetimes.is_empty() {\n             return;\n         }\n     }\n \n-    for arg in &efn.args {\n-        if let Type::Ref(ty) = &arg.ty {\n-            if ty.mutable {\n-                return;\n-            }\n+    struct FindLifetimeMut<'a> {\n+        cx: &'a Check<'a>,\n+        found: bool,\n+    }\n+\n+    impl<'t, 'a> Visit<'t> for FindLifetimeMut<'a> {\n+        fn visit_type(&mut self, ty: &'t Type) {\n+            self.found |= match ty {\n+                Type::Ref(ty) => ty.mutable,\n+                Type::Ident(ident) => {\n+                    let resolve = self.cx.types.resolve(ident);\n+                    !resolve.generics.lifetimes.is_empty()\n+                }\n+                _ => false,\n+            };\n+            visit::visit_type(self, ty);\n         }\n     }\n \n+    let mut visitor = FindLifetimeMut { cx, found: false };\n+\n+    for arg in &efn.args {\n+        visitor.visit_type(&arg.ty);\n+    }\n+\n+    if visitor.found {\n+        return;\n+    }\n+\n     cx.error(\n         efn,\n         \"&mut return type is not allowed unless there is a &mut argument\",\n",
        "test_patch": "diff --git a/tests/ui/mut_return.rs b/tests/ui/mut_return.rs\n--- a/tests/ui/mut_return.rs\n+++ b/tests/ui/mut_return.rs\n@@ -1,10 +1,16 @@\n #[cxx::bridge]\n mod ffi {\n+    extern \"Rust\" {\n+        type Mut<'a>;\n+    }\n+\n     unsafe extern \"C++\" {\n         type Thing;\n \n         fn f(t: &Thing) -> Pin<&mut CxxString>;\n         unsafe fn g(t: &Thing) -> Pin<&mut CxxString>;\n+        fn h(t: Box<Mut>) -> Pin<&mut CxxString>;\n+        fn i<'a>(t: Box<Mut<'a>>) -> Pin<&'a mut CxxString>;\n     }\n }\n \ndiff --git a/tests/ui/mut_return.stderr b/tests/ui/mut_return.stderr\n--- a/tests/ui/mut_return.stderr\n+++ b/tests/ui/mut_return.stderr\n@@ -1,5 +1,5 @@\n error: &mut return type is not allowed unless there is a &mut argument\n- --> $DIR/mut_return.rs:6:9\n-  |\n-6 |         fn f(t: &Thing) -> Pin<&mut CxxString>;\n-  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  --> $DIR/mut_return.rs:10:9\n+   |\n+10 |         fn f(t: &Thing) -> Pin<&mut CxxString>;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
        "problem_statement": "Allow mutable return reference on signatures with any lifetime in argument\nAs of #608 now that extern types defined in the bridge can be generic over lifetimes, it no longer makes sense to expect specifically a reference in one of the function arguments of a function that returns a mutable reference. The following two signatures would be perfectly valid:\r\n\r\n```rust\r\n#[cxx::bridge]\r\nmod ffi {\r\n    extern \"Rust\" {\r\n        type Thing<'a>;\r\n    }\r\n\r\n    unsafe extern \"C++\" {\r\n        fn f<'a>(t: Box<Thing<'a>>) -> &'a mut i32;\r\n        fn g(t: Box<Thing>) -> &mut i32;  // same thing, with lifetime elision\r\n    }\r\n}\r\n\r\npub struct Thing<'a>(&'a mut i32);\r\n```\r\n\r\nCurrent behavior:\r\n\r\n```console\r\nerror[cxxbridge]: &mut return type is not allowed unless there is a &mut argument\r\n  \u250c\u2500 src/main.rs:8:9\r\n  \u2502\r\n8 \u2502         fn f<'a>(t: Box<Thing<'a>>) -> &'a mut i32;\r\n  \u2502         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ &mut return type is not allowed unless there is a &mut argument\r\n\r\nerror[cxxbridge]: &mut return type is not allowed unless there is a &mut argument\r\n  \u250c\u2500 src/main.rs:9:9\r\n  \u2502\r\n9 \u2502         fn g(t: Box<Thing>) -> &mut i32;\r\n  \u2502         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ &mut return type is not allowed unless there is a &mut argument\r\n```\n",
        "hints_text": "",
        "created_at": "2021-03-26T22:00:28Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 775,
        "instance_id": "dtolnay__cxx-775",
        "issue_numbers": [
            "763"
        ],
        "base_commit": "07892531272c45dcbe39428bdcf0eefd6c729ea0",
        "patch": "diff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -508,6 +508,11 @@ fn check_api_impl(cx: &mut Check, imp: &Impl) {\n }\n \n fn check_mut_return_restriction(cx: &mut Check, efn: &ExternFn) {\n+    if efn.sig.unsafety.is_some() {\n+        // Unrestricted as long as the function is made unsafe-to-call.\n+        return;\n+    }\n+\n     match &efn.ret {\n         Some(Type::Ref(ty)) if ty.mutable => {}\n         _ => return,\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -204,6 +204,7 @@ impl ToTokens for Enum {\n impl ToTokens for ExternFn {\n     fn to_tokens(&self, tokens: &mut TokenStream) {\n         // Notional token range for error reporting purposes.\n+        self.unsafety.to_tokens(tokens);\n         self.sig.fn_token.to_tokens(tokens);\n         self.semi_token.to_tokens(tokens);\n     }\n",
        "test_patch": "diff --git /dev/null b/tests/ui/mut_return.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/mut_return.rs\n@@ -0,0 +1,11 @@\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+        type Thing;\n+\n+        fn f(t: &Thing) -> Pin<&mut CxxString>;\n+        unsafe fn g(t: &Thing) -> Pin<&mut CxxString>;\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/mut_return.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/mut_return.stderr\n@@ -0,0 +1,5 @@\n+error: &mut return type is not allowed unless there is a &mut argument\n+ --> $DIR/mut_return.rs:6:9\n+  |\n+6 |         fn f(t: &Thing) -> Pin<&mut CxxString>;\n+  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
        "problem_statement": "Allow mut from ref in unsafe-to-call signatures\nCurrently signatures that return a mutable reference but do not take any mutable reference arguments are disallowed. It should be fine to allow such signatures as long as they are made unsafe to call.\r\n\r\nCurrent behavior:\r\n\r\n```rust\r\n#[cxx::bridge]\r\nmod ffi {\r\n    extern \"C++\" {\r\n        type Thing;\r\n\r\n        unsafe fn f(t: &Thing) -> Pin<&mut CxxString>;\r\n    }\r\n}\r\n```\r\n\r\n```console\r\nerror[cxxbridge]: &mut return type is not allowed unless there is a &mut argument\r\n  \u250c\u2500 src/main.rs:6:16\r\n  \u2502\r\n6 \u2502         unsafe fn f(t: &Thing) -> Pin<&mut CxxString>;\r\n  \u2502                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ &mut return type is not allowed unless there is a &mut argument\r\n```\n",
        "hints_text": "",
        "created_at": "2021-03-26T21:09:47Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 762,
        "instance_id": "dtolnay__cxx-762",
        "issue_numbers": [
            "685"
        ],
        "base_commit": "d83dfe15de4f246aa019981403bc4f41557e9175",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1255,6 +1255,7 @@ fn expand_unique_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>)\n         || types.aliases.contains_key(ident);\n     let new_method = if can_construct_from_value {\n         Some(quote! {\n+            #[doc(hidden)]\n             fn __new(value: Self) -> *mut ::std::ffi::c_void {\n                 extern \"C\" {\n                     #[link_name = #link_uninit]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1276,9 +1277,11 @@ fn expand_unique_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>)\n \n     quote_spanned! {end_span=>\n         #unsafe_token impl #impl_generics ::cxx::private::UniquePtrTarget for #ident #ty_generics {\n+            #[doc(hidden)]\n             fn __typename(f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n                 f.write_str(#name)\n             }\n+            #[doc(hidden)]\n             fn __null() -> *mut ::std::ffi::c_void {\n                 extern \"C\" {\n                     #[link_name = #link_null]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1289,6 +1292,7 @@ fn expand_unique_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>)\n                 repr\n             }\n             #new_method\n+            #[doc(hidden)]\n             unsafe fn __raw(raw: *mut Self) -> *mut ::std::ffi::c_void {\n                 extern \"C\" {\n                     #[link_name = #link_raw]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1298,6 +1302,7 @@ fn expand_unique_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>)\n                 __raw(&mut repr, raw.cast());\n                 repr\n             }\n+            #[doc(hidden)]\n             unsafe fn __get(repr: *mut ::std::ffi::c_void) -> *const Self {\n                 extern \"C\" {\n                     #[link_name = #link_get]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1305,6 +1310,7 @@ fn expand_unique_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>)\n                 }\n                 __get(&repr).cast()\n             }\n+            #[doc(hidden)]\n             unsafe fn __release(mut repr: *mut ::std::ffi::c_void) -> *mut Self {\n                 extern \"C\" {\n                     #[link_name = #link_release]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1312,6 +1318,7 @@ fn expand_unique_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>)\n                 }\n                 __release(&mut repr).cast()\n             }\n+            #[doc(hidden)]\n             unsafe fn __drop(mut repr: *mut ::std::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_drop]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1344,6 +1351,7 @@ fn expand_shared_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>)\n         || types.aliases.contains_key(ident);\n     let new_method = if can_construct_from_value {\n         Some(quote! {\n+            #[doc(hidden)]\n             unsafe fn __new(value: Self, new: *mut ::std::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_uninit]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1363,9 +1371,11 @@ fn expand_shared_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>)\n \n     quote_spanned! {end_span=>\n         #unsafe_token impl #impl_generics ::cxx::private::SharedPtrTarget for #ident #ty_generics {\n+            #[doc(hidden)]\n             fn __typename(f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n                 f.write_str(#name)\n             }\n+            #[doc(hidden)]\n             unsafe fn __null(new: *mut ::std::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_null]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1374,6 +1384,7 @@ fn expand_shared_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>)\n                 __null(new);\n             }\n             #new_method\n+            #[doc(hidden)]\n             unsafe fn __clone(this: *const ::std::ffi::c_void, new: *mut ::std::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_clone]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1381,6 +1392,7 @@ fn expand_shared_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>)\n                 }\n                 __clone(this, new);\n             }\n+            #[doc(hidden)]\n             unsafe fn __get(this: *const ::std::ffi::c_void) -> *const Self {\n                 extern \"C\" {\n                     #[link_name = #link_get]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1388,6 +1400,7 @@ fn expand_shared_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>)\n                 }\n                 __get(this).cast()\n             }\n+            #[doc(hidden)]\n             unsafe fn __drop(this: *mut ::std::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_drop]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1422,9 +1435,11 @@ fn expand_weak_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>) -\n \n     quote_spanned! {end_span=>\n         #unsafe_token impl #impl_generics ::cxx::private::WeakPtrTarget for #ident #ty_generics {\n+            #[doc(hidden)]\n             fn __typename(f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n                 f.write_str(#name)\n             }\n+            #[doc(hidden)]\n             unsafe fn __null(new: *mut ::std::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_null]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1432,6 +1447,7 @@ fn expand_weak_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>) -\n                 }\n                 __null(new);\n             }\n+            #[doc(hidden)]\n             unsafe fn __clone(this: *const ::std::ffi::c_void, new: *mut ::std::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_clone]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1439,6 +1455,7 @@ fn expand_weak_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>) -\n                 }\n                 __clone(this, new);\n             }\n+            #[doc(hidden)]\n             unsafe fn __downgrade(shared: *const ::std::ffi::c_void, weak: *mut ::std::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_downgrade]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1446,6 +1463,7 @@ fn expand_weak_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>) -\n                 }\n                 __downgrade(shared, weak);\n             }\n+            #[doc(hidden)]\n             unsafe fn __upgrade(weak: *const ::std::ffi::c_void, shared: *mut ::std::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_upgrade]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1453,6 +1471,7 @@ fn expand_weak_ptr(ident: &Ident, types: &Types, explicit_impl: Option<&Impl>) -\n                 }\n                 __upgrade(weak, shared);\n             }\n+            #[doc(hidden)]\n             unsafe fn __drop(this: *mut ::std::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_drop]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1493,9 +1512,11 @@ fn expand_cxx_vector(elem: &Ident, explicit_impl: Option<&Impl>, types: &Types)\n \n     quote_spanned! {end_span=>\n         #unsafe_token impl #impl_generics ::cxx::private::VectorElement for #elem #ty_generics {\n+            #[doc(hidden)]\n             fn __typename(f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n                 f.write_str(#name)\n             }\n+            #[doc(hidden)]\n             fn __vector_size(v: &::cxx::CxxVector<Self>) -> usize {\n                 extern \"C\" {\n                     #[link_name = #link_size]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1503,6 +1524,7 @@ fn expand_cxx_vector(elem: &Ident, explicit_impl: Option<&Impl>, types: &Types)\n                 }\n                 unsafe { __vector_size(v) }\n             }\n+            #[doc(hidden)]\n             unsafe fn __get_unchecked(v: *mut ::cxx::CxxVector<Self>, pos: usize) -> *mut Self {\n                 extern \"C\" {\n                     #[link_name = #link_get_unchecked]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1510,6 +1532,7 @@ fn expand_cxx_vector(elem: &Ident, explicit_impl: Option<&Impl>, types: &Types)\n                 }\n                 __get_unchecked(v, pos)\n             }\n+            #[doc(hidden)]\n             fn __unique_ptr_null() -> *mut ::std::ffi::c_void {\n                 extern \"C\" {\n                     #[link_name = #link_unique_ptr_null]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1519,6 +1542,7 @@ fn expand_cxx_vector(elem: &Ident, explicit_impl: Option<&Impl>, types: &Types)\n                 unsafe { __unique_ptr_null(&mut repr) }\n                 repr\n             }\n+            #[doc(hidden)]\n             unsafe fn __unique_ptr_raw(raw: *mut ::cxx::CxxVector<Self>) -> *mut ::std::ffi::c_void {\n                 extern \"C\" {\n                     #[link_name = #link_unique_ptr_raw]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1528,6 +1552,7 @@ fn expand_cxx_vector(elem: &Ident, explicit_impl: Option<&Impl>, types: &Types)\n                 __unique_ptr_raw(&mut repr, raw);\n                 repr\n             }\n+            #[doc(hidden)]\n             unsafe fn __unique_ptr_get(repr: *mut ::std::ffi::c_void) -> *const ::cxx::CxxVector<Self> {\n                 extern \"C\" {\n                     #[link_name = #link_unique_ptr_get]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1535,6 +1560,7 @@ fn expand_cxx_vector(elem: &Ident, explicit_impl: Option<&Impl>, types: &Types)\n                 }\n                 __unique_ptr_get(&repr)\n             }\n+            #[doc(hidden)]\n             unsafe fn __unique_ptr_release(mut repr: *mut ::std::ffi::c_void) -> *mut ::cxx::CxxVector<Self> {\n                 extern \"C\" {\n                     #[link_name = #link_unique_ptr_release]\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1542,6 +1568,7 @@ fn expand_cxx_vector(elem: &Ident, explicit_impl: Option<&Impl>, types: &Types)\n                 }\n                 __unique_ptr_release(&mut repr)\n             }\n+            #[doc(hidden)]\n             unsafe fn __unique_ptr_drop(mut repr: *mut ::std::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_unique_ptr_drop]\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -260,17 +260,50 @@ where\n     }\n }\n \n-// Methods are private; not intended to be implemented outside of cxxbridge\n-// codebase.\n-#[doc(hidden)]\n+/// Trait bound for types which may be used as the `T` inside of a\n+/// `CxxVector<T>` in generic code.\n+///\n+/// This trait has no publicly callable or implementable methods. Implementing\n+/// it outside of the CXX codebase is not supported.\n+///\n+/// # Example\n+///\n+/// A bound `T: VectorElement` may be necessary when manipulating [`CxxVector`]\n+/// in generic code.\n+///\n+/// ```\n+/// use cxx::vector::{CxxVector, VectorElement};\n+/// use std::fmt::Display;\n+///\n+/// pub fn take_generic_vector<T>(vector: &CxxVector<T>)\n+/// where\n+///     T: VectorElement + Display,\n+/// {\n+///     println!(\"the vector elements are:\");\n+///     for element in vector {\n+///         println!(\"  \u2022 {}\", element);\n+///     }\n+/// }\n+/// ```\n+///\n+/// Writing the same generic function without a `VectorElement` trait bound\n+/// would not compile.\n pub unsafe trait VectorElement: Sized {\n+    #[doc(hidden)]\n     fn __typename(f: &mut fmt::Formatter) -> fmt::Result;\n+    #[doc(hidden)]\n     fn __vector_size(v: &CxxVector<Self>) -> usize;\n+    #[doc(hidden)]\n     unsafe fn __get_unchecked(v: *mut CxxVector<Self>, pos: usize) -> *mut Self;\n+    #[doc(hidden)]\n     fn __unique_ptr_null() -> *mut c_void;\n+    #[doc(hidden)]\n     unsafe fn __unique_ptr_raw(raw: *mut CxxVector<Self>) -> *mut c_void;\n+    #[doc(hidden)]\n     unsafe fn __unique_ptr_get(repr: *mut c_void) -> *const CxxVector<Self>;\n+    #[doc(hidden)]\n     unsafe fn __unique_ptr_release(repr: *mut c_void) -> *mut CxxVector<Self>;\n+    #[doc(hidden)]\n     unsafe fn __unique_ptr_drop(repr: *mut c_void);\n }\n \ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -279,9 +312,11 @@ macro_rules! impl_vector_element {\n         const_assert_eq!(1, mem::align_of::<CxxVector<$ty>>());\n \n         unsafe impl VectorElement for $ty {\n+            #[doc(hidden)]\n             fn __typename(f: &mut fmt::Formatter) -> fmt::Result {\n                 f.write_str($name)\n             }\n+            #[doc(hidden)]\n             fn __vector_size(v: &CxxVector<$ty>) -> usize {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -291,6 +326,7 @@ macro_rules! impl_vector_element {\n                 }\n                 unsafe { __vector_size(v) }\n             }\n+            #[doc(hidden)]\n             unsafe fn __get_unchecked(v: *mut CxxVector<$ty>, pos: usize) -> *mut $ty {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -300,6 +336,7 @@ macro_rules! impl_vector_element {\n                 }\n                 __get_unchecked(v, pos)\n             }\n+            #[doc(hidden)]\n             fn __unique_ptr_null() -> *mut c_void {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -311,6 +348,7 @@ macro_rules! impl_vector_element {\n                 unsafe { __unique_ptr_null(&mut repr) }\n                 repr\n             }\n+            #[doc(hidden)]\n             unsafe fn __unique_ptr_raw(raw: *mut CxxVector<Self>) -> *mut c_void {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -322,6 +360,7 @@ macro_rules! impl_vector_element {\n                 __unique_ptr_raw(&mut repr, raw);\n                 repr\n             }\n+            #[doc(hidden)]\n             unsafe fn __unique_ptr_get(repr: *mut c_void) -> *const CxxVector<Self> {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -331,6 +370,7 @@ macro_rules! impl_vector_element {\n                 }\n                 __unique_ptr_get(&repr)\n             }\n+            #[doc(hidden)]\n             unsafe fn __unique_ptr_release(mut repr: *mut c_void) -> *mut CxxVector<Self> {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -340,6 +380,7 @@ macro_rules! impl_vector_element {\n                 }\n                 __unique_ptr_release(&mut repr)\n             }\n+            #[doc(hidden)]\n             unsafe fn __unique_ptr_drop(mut repr: *mut c_void) {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -405,6 +405,7 @@ mod exception;\n mod extern_type;\n mod fmt;\n mod function;\n+pub mod memory;\n mod opaque;\n mod result;\n mod rust_slice;\ndiff --git /dev/null b/src/memory.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/memory.rs\n@@ -0,0 +1,8 @@\n+//! Less used details of `UniquePtr` and `SharedPtr`.\n+//!\n+//! The pointer types themselves are exposed at the crate root.\n+\n+pub use crate::shared_ptr::SharedPtrTarget;\n+pub use crate::unique_ptr::UniquePtrTarget;\n+#[doc(no_inline)]\n+pub use cxx::{SharedPtr, UniquePtr};\ndiff --git a/src/shared_ptr.rs b/src/shared_ptr.rs\n--- a/src/shared_ptr.rs\n+++ b/src/shared_ptr.rs\n@@ -152,8 +152,31 @@ where\n     }\n }\n \n-// Methods are private; not intended to be implemented outside of cxxbridge\n-// codebase.\n+/// Trait bound for types which may be used as the `T` inside of a\n+/// `SharedPtr<T>` in generic code.\n+///\n+/// This trait has no publicly callable or implementable methods. Implementing\n+/// it outside of the CXX codebase is not supported.\n+///\n+/// # Example\n+///\n+/// A bound `T: SharedPtrTarget` may be necessary when manipulating\n+/// [`SharedPtr`] in generic code.\n+///\n+/// ```\n+/// use cxx::memory::{SharedPtr, SharedPtrTarget};\n+/// use std::fmt::Display;\n+///\n+/// pub fn take_generic_ptr<T>(ptr: SharedPtr<T>)\n+/// where\n+///     T: SharedPtrTarget + Display,\n+/// {\n+///     println!(\"the shared_ptr points to: {}\", *ptr);\n+/// }\n+/// ```\n+///\n+/// Writing the same generic function without a `SharedPtrTarget` trait bound\n+/// would not compile.\n pub unsafe trait SharedPtrTarget {\n     #[doc(hidden)]\n     fn __typename(f: &mut fmt::Formatter) -> fmt::Result;\ndiff --git a/src/shared_ptr.rs b/src/shared_ptr.rs\n--- a/src/shared_ptr.rs\n+++ b/src/shared_ptr.rs\n@@ -181,9 +204,11 @@ pub unsafe trait SharedPtrTarget {\n macro_rules! impl_shared_ptr_target {\n     ($segment:expr, $name:expr, $ty:ty) => {\n         unsafe impl SharedPtrTarget for $ty {\n+            #[doc(hidden)]\n             fn __typename(f: &mut fmt::Formatter) -> fmt::Result {\n                 f.write_str($name)\n             }\n+            #[doc(hidden)]\n             unsafe fn __null(new: *mut c_void) {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/shared_ptr.rs b/src/shared_ptr.rs\n--- a/src/shared_ptr.rs\n+++ b/src/shared_ptr.rs\n@@ -193,6 +218,7 @@ macro_rules! impl_shared_ptr_target {\n                 }\n                 __null(new);\n             }\n+            #[doc(hidden)]\n             unsafe fn __new(value: Self, new: *mut c_void) {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/shared_ptr.rs b/src/shared_ptr.rs\n--- a/src/shared_ptr.rs\n+++ b/src/shared_ptr.rs\n@@ -202,6 +228,7 @@ macro_rules! impl_shared_ptr_target {\n                 }\n                 __uninit(new).cast::<$ty>().write(value);\n             }\n+            #[doc(hidden)]\n             unsafe fn __clone(this: *const c_void, new: *mut c_void) {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/shared_ptr.rs b/src/shared_ptr.rs\n--- a/src/shared_ptr.rs\n+++ b/src/shared_ptr.rs\n@@ -211,6 +238,7 @@ macro_rules! impl_shared_ptr_target {\n                 }\n                 __clone(this, new);\n             }\n+            #[doc(hidden)]\n             unsafe fn __get(this: *const c_void) -> *const Self {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/shared_ptr.rs b/src/shared_ptr.rs\n--- a/src/shared_ptr.rs\n+++ b/src/shared_ptr.rs\n@@ -220,6 +248,7 @@ macro_rules! impl_shared_ptr_target {\n                 }\n                 __get(this).cast()\n             }\n+            #[doc(hidden)]\n             unsafe fn __drop(this: *mut c_void) {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/unique_ptr.rs b/src/unique_ptr.rs\n--- a/src/unique_ptr.rs\n+++ b/src/unique_ptr.rs\n@@ -178,8 +178,31 @@ where\n     }\n }\n \n-// Methods are private; not intended to be implemented outside of cxxbridge\n-// codebase.\n+/// Trait bound for types which may be used as the `T` inside of a\n+/// `UniquePtr<T>` in generic code.\n+///\n+/// This trait has no publicly callable or implementable methods. Implementing\n+/// it outside of the CXX codebase is not supported.\n+///\n+/// # Example\n+///\n+/// A bound `T: UniquePtrTarget` may be necessary when manipulating\n+/// [`UniquePtr`] in generic code.\n+///\n+/// ```\n+/// use cxx::memory::{UniquePtr, UniquePtrTarget};\n+/// use std::fmt::Display;\n+///\n+/// pub fn take_generic_ptr<T>(ptr: UniquePtr<T>)\n+/// where\n+///     T: UniquePtrTarget + Display,\n+/// {\n+///     println!(\"the unique_ptr points to: {}\", *ptr);\n+/// }\n+/// ```\n+///\n+/// Writing the same generic function without a `UniquePtrTarget` trait bound\n+/// would not compile.\n pub unsafe trait UniquePtrTarget {\n     #[doc(hidden)]\n     fn __typename(f: &mut fmt::Formatter) -> fmt::Result;\ndiff --git a/src/unique_ptr.rs b/src/unique_ptr.rs\n--- a/src/unique_ptr.rs\n+++ b/src/unique_ptr.rs\n@@ -219,9 +242,11 @@ extern \"C\" {\n }\n \n unsafe impl UniquePtrTarget for CxxString {\n+    #[doc(hidden)]\n     fn __typename(f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(\"CxxString\")\n     }\n+    #[doc(hidden)]\n     fn __null() -> *mut c_void {\n         let mut repr = ptr::null_mut::<c_void>();\n         unsafe {\ndiff --git a/src/unique_ptr.rs b/src/unique_ptr.rs\n--- a/src/unique_ptr.rs\n+++ b/src/unique_ptr.rs\n@@ -229,17 +254,21 @@ unsafe impl UniquePtrTarget for CxxString {\n         }\n         repr\n     }\n+    #[doc(hidden)]\n     unsafe fn __raw(raw: *mut Self) -> *mut c_void {\n         let mut repr = ptr::null_mut::<c_void>();\n         unique_ptr_std_string_raw(&mut repr, raw);\n         repr\n     }\n+    #[doc(hidden)]\n     unsafe fn __get(repr: *mut c_void) -> *const Self {\n         unique_ptr_std_string_get(&repr)\n     }\n+    #[doc(hidden)]\n     unsafe fn __release(mut repr: *mut c_void) -> *mut Self {\n         unique_ptr_std_string_release(&mut repr)\n     }\n+    #[doc(hidden)]\n     unsafe fn __drop(mut repr: *mut c_void) {\n         unique_ptr_std_string_drop(&mut repr);\n     }\ndiff --git a/src/unique_ptr.rs b/src/unique_ptr.rs\n--- a/src/unique_ptr.rs\n+++ b/src/unique_ptr.rs\n@@ -249,21 +278,27 @@ unsafe impl<T> UniquePtrTarget for CxxVector<T>\n where\n     T: VectorElement,\n {\n+    #[doc(hidden)]\n     fn __typename(f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"CxxVector<{}>\", display(T::__typename))\n     }\n+    #[doc(hidden)]\n     fn __null() -> *mut c_void {\n         T::__unique_ptr_null()\n     }\n+    #[doc(hidden)]\n     unsafe fn __raw(raw: *mut Self) -> *mut c_void {\n         T::__unique_ptr_raw(raw)\n     }\n+    #[doc(hidden)]\n     unsafe fn __get(repr: *mut c_void) -> *const Self {\n         T::__unique_ptr_get(repr)\n     }\n+    #[doc(hidden)]\n     unsafe fn __release(repr: *mut c_void) -> *mut Self {\n         T::__unique_ptr_release(repr)\n     }\n+    #[doc(hidden)]\n     unsafe fn __drop(repr: *mut c_void) {\n         T::__unique_ptr_drop(repr);\n     }\ndiff --git a/src/vector.rs b/src/vector.rs\n--- a/src/vector.rs\n+++ b/src/vector.rs\n@@ -1,7 +1,8 @@\n-//! Less used details of `CxxVector` are exposed in this module. `CxxVector`\n-//! itself is exposed at the crate root.\n+//! Less used details of `CxxVector`.\n+//!\n+//! `CxxVector` itself is exposed at the crate root.\n \n-pub use crate::cxx_vector::{Iter, IterMut};\n+pub use crate::cxx_vector::{Iter, IterMut, VectorElement};\n #[doc(inline)]\n pub use crate::Vector;\n #[doc(no_inline)]\ndiff --git a/src/weak_ptr.rs b/src/weak_ptr.rs\n--- a/src/weak_ptr.rs\n+++ b/src/weak_ptr.rs\n@@ -111,9 +111,11 @@ pub unsafe trait WeakPtrTarget {\n macro_rules! impl_weak_ptr_target {\n     ($segment:expr, $name:expr, $ty:ty) => {\n         unsafe impl WeakPtrTarget for $ty {\n+            #[doc(hidden)]\n             fn __typename(f: &mut fmt::Formatter) -> fmt::Result {\n                 f.write_str($name)\n             }\n+            #[doc(hidden)]\n             unsafe fn __null(new: *mut c_void) {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/weak_ptr.rs b/src/weak_ptr.rs\n--- a/src/weak_ptr.rs\n+++ b/src/weak_ptr.rs\n@@ -123,6 +125,7 @@ macro_rules! impl_weak_ptr_target {\n                 }\n                 __null(new);\n             }\n+            #[doc(hidden)]\n             unsafe fn __clone(this: *const c_void, new: *mut c_void) {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/weak_ptr.rs b/src/weak_ptr.rs\n--- a/src/weak_ptr.rs\n+++ b/src/weak_ptr.rs\n@@ -132,6 +135,7 @@ macro_rules! impl_weak_ptr_target {\n                 }\n                 __clone(this, new);\n             }\n+            #[doc(hidden)]\n             unsafe fn __downgrade(shared: *const c_void, weak: *mut c_void) {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/weak_ptr.rs b/src/weak_ptr.rs\n--- a/src/weak_ptr.rs\n+++ b/src/weak_ptr.rs\n@@ -141,6 +145,7 @@ macro_rules! impl_weak_ptr_target {\n                 }\n                 __downgrade(shared, weak);\n             }\n+            #[doc(hidden)]\n             unsafe fn __upgrade(weak: *const c_void, shared: *mut c_void) {\n                 extern \"C\" {\n                     attr! {\ndiff --git a/src/weak_ptr.rs b/src/weak_ptr.rs\n--- a/src/weak_ptr.rs\n+++ b/src/weak_ptr.rs\n@@ -150,6 +155,7 @@ macro_rules! impl_weak_ptr_target {\n                 }\n                 __upgrade(weak, shared);\n             }\n+            #[doc(hidden)]\n             unsafe fn __drop(this: *mut c_void) {\n                 extern \"C\" {\n                     attr! {\n",
        "test_patch": "diff --git a/tests/ui/unique_ptr_twice.stderr b/tests/ui/unique_ptr_twice.stderr\n--- a/tests/ui/unique_ptr_twice.stderr\n+++ b/tests/ui/unique_ptr_twice.stderr\n@@ -1,4 +1,4 @@\n-error[E0119]: conflicting implementations of trait `cxx::private::UniquePtrTarget` for type `here::C`:\n+error[E0119]: conflicting implementations of trait `cxx::memory::UniquePtrTarget` for type `here::C`:\n   --> $DIR/unique_ptr_twice.rs:16:5\n    |\n 7  |     impl UniquePtr<C> {}\n",
        "problem_statement": "export UniquePtrTarget\nI'm writing a trait which has a function that returns a `UniquePtr` whose type depends on type of the rust struct implemeting it using an associated type.\r\n\r\n```rust\r\ntrait GetPtr {\r\n    type T: UniquePtrTarget;\r\n    fn get_ptr(self) -> UniquePtr<Self::T>;\r\n}\r\n\r\nimpl GetPtr for FirstRustType {\r\n    type T = ffi::FirstCppType;\r\n    fn get_ptr(self) -> UniquePtr<Self::T> {\r\n        ffi::get_first_ptr(self);\r\n    }\r\n}\r\n\r\nimpl GetPtr for SecondRustType {\r\n    type T = ffi::SecondCppType;\r\n    fn get_ptr(self) -> UniquePtr<Self::T> {\r\n        ffi::get_second_ptr(self);\r\n    }\r\n}\r\n```\r\n\r\nI need to specifically bound `T` by `UniquePtrTarget`, otherwise I get the following error:\r\n\r\n```\r\nthe trait bound `<Self as GetPtr>::T: UniquePtrTarget` is not satisfied\r\nthe trait `UniquePtrTarget` is not implemented for `<Self as GetPtr>::T`rustcE0277\r\n\r\nunique_ptr.rs(17, 8): required by this bound in `UniquePtr`\r\n\r\nlib.rs(34, 43): consider further restricting the associated type\r\n```\r\n\r\nI'd be glad to hear if there's a better option that I haven't considered.\r\n\r\nThanks,\r\nOliver\n",
        "hints_text": "",
        "created_at": "2021-03-25T06:10:42Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 743,
        "instance_id": "dtolnay__cxx-743",
        "issue_numbers": [
            "737"
        ],
        "base_commit": "3dafaede930026394649639ac0798aa39d6b439f",
        "patch": "diff --git a/src/cxx_string.rs b/src/cxx_string.rs\n--- a/src/cxx_string.rs\n+++ b/src/cxx_string.rs\n@@ -183,6 +183,38 @@ impl PartialEq<str> for CxxString {\n     }\n }\n \n+impl Eq for CxxString {}\n+\n+impl PartialOrd for CxxString {\n+    fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+        self.as_bytes().partial_cmp(other.as_bytes())\n+    }\n+}\n+\n+impl PartialOrd<str> for CxxString {\n+    fn partial_cmp(&self, other: &str) -> Option<core::cmp::Ordering> {\n+        self.as_bytes().partial_cmp(other.as_bytes())\n+    }\n+}\n+\n+impl PartialOrd<CxxString> for str {\n+    fn partial_cmp(&self, other: &CxxString) -> Option<core::cmp::Ordering> {\n+        self.as_bytes().partial_cmp(other.as_bytes())\n+    }\n+}\n+\n+impl Ord for CxxString {\n+    fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n+        self.as_bytes().cmp(other.as_bytes())\n+    }\n+}\n+\n+impl core::hash::Hash for CxxString {\n+    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {\n+        self.as_bytes().hash(state)\n+    }\n+}\n+\n #[doc(hidden)]\n #[repr(C)]\n pub struct StackString {\n",
        "test_patch": "diff --git a/tests/cxx_string.rs b/tests/cxx_string.rs\n--- a/tests/cxx_string.rs\n+++ b/tests/cxx_string.rs\n@@ -13,3 +13,34 @@ fn test_async_cxx_string() {\n     fn assert_send(_: impl Send) {}\n     assert_send(f());\n }\n+\n+#[test]\n+fn test_cmp_rust_str_cxx_string() {\n+    use std::cmp::Ordering;\n+    fn test_eq(rust_str: &str) {\n+        let_cxx_string!(cxx_string = rust_str);\n+        assert_eq!(rust_str.partial_cmp(&*cxx_string), Some(Ordering::Equal));\n+        assert_eq!((*cxx_string).partial_cmp(rust_str), Some(Ordering::Equal));\n+        assert_eq!(*cxx_string, *rust_str);\n+        assert_eq!(*rust_str, *cxx_string);\n+    }\n+\n+    fn test_ne(lhs: &str, rhs: &str) {\n+        let_cxx_string!(cxx_lhs = lhs);\n+        let_cxx_string!(cxx_rhs = rhs);\n+        assert_ne!(lhs.partial_cmp(&*cxx_rhs), Some(Ordering::Equal));\n+        assert_ne!(rhs.partial_cmp(&*cxx_lhs), Some(Ordering::Equal));\n+        assert_ne!((*cxx_lhs).partial_cmp(rhs), Some(Ordering::Equal));\n+        assert_ne!((*cxx_rhs).partial_cmp(lhs), Some(Ordering::Equal));\n+        assert_ne!(*cxx_lhs, *rhs);\n+        assert_ne!(*cxx_rhs, *lhs);\n+        assert_ne!(*rhs, *cxx_lhs);\n+        assert_ne!(*lhs, *cxx_rhs);\n+    }\n+    test_eq(\"abc\");\n+    test_eq(\"\");\n+    test_ne(\"abc\", \"Abc\");\n+    test_ne(\"abc\", \"\");\n+    // test utf8 character\n+    test_eq(\"\u2661\");\n+}\n",
        "problem_statement": "Trait impls for CxxString:  Hash, Ord, PartialOrd, Eq\nI need to use `&CxxString` as the key of a BTreeMap or HashMap. However there are some trait impls currently missing, which we should just make delegate to the underlying `&[u8]`. BTreeMap requires `Ord` and HashMap requires `Hash + Eq`.\n",
        "hints_text": "",
        "created_at": "2021-03-18T18:30:01Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 276,
        "instance_id": "dtolnay__cxx-276",
        "issue_numbers": [
            "88"
        ],
        "base_commit": "7f4b3ca2f9b84fea9358b6187ae1dfe096a8b9f3",
        "patch": "diff --git a/demo/Cargo.toml b/demo/Cargo.toml\n--- a/demo/Cargo.toml\n+++ b/demo/Cargo.toml\n@@ -1,5 +1,5 @@\n [package]\n-name = \"cxxbridge-demo\"\n+name = \"demo\"\n version = \"0.0.0\"\n authors = [\"David Tolnay <dtolnay@gmail.com>\"]\n edition = \"2018\"\ndiff --git a/gen/build/src/cargo.rs b/gen/build/src/cargo.rs\n--- a/gen/build/src/cargo.rs\n+++ b/gen/build/src/cargo.rs\n@@ -1,19 +1,19 @@\n-use crate::error::TargetDirError;\n use crate::paths::TargetDir;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::str;\n \n-pub(crate) fn target_dir() -> Result<TargetDir, TargetDirError> {\n-    let cargo = option_env!(\"CARGO\").unwrap_or(\"cargo\");\n-    let output = Command::new(cargo)\n-        .arg(\"metadata\")\n-        .arg(\"--no-deps\")\n-        .arg(\"--format-version=1\")\n-        .output()\n-        .map_err(TargetDirError::Io)?;\n-\n+pub(crate) fn target_dir(out_dir: &Path) -> TargetDir {\n     (|| {\n+        let cargo = option_env!(\"CARGO\").unwrap_or(\"cargo\");\n+        let output = Command::new(cargo)\n+            .current_dir(out_dir)\n+            .arg(\"metadata\")\n+            .arg(\"--no-deps\")\n+            .arg(\"--format-version=1\")\n+            .output()\n+            .ok()?;\n+\n         // Cargo only outputs utf8 encoded JSON.\n         let mut metadata = str::from_utf8(&output.stdout).ok()?;\n \ndiff --git a/gen/build/src/cargo.rs b/gen/build/src/cargo.rs\n--- a/gen/build/src/cargo.rs\n+++ b/gen/build/src/cargo.rs\n@@ -25,7 +25,7 @@ pub(crate) fn target_dir() -> Result<TargetDir, TargetDirError> {\n         let close_quote_index = metadata.find('\"')?;\n         let string = &metadata[..close_quote_index];\n         let target_directory = string.replace(\"\\\\\\\\\", \"\\\\\");\n-        Some(TargetDir(PathBuf::from(target_directory)))\n+        Some(TargetDir::Path(PathBuf::from(target_directory)))\n     })()\n-    .ok_or(TargetDirError::NotFound)\n+    .unwrap_or(TargetDir::Unknown)\n }\ndiff --git a/gen/build/src/error.rs b/gen/build/src/error.rs\n--- a/gen/build/src/error.rs\n+++ b/gen/build/src/error.rs\n@@ -1,28 +1,19 @@\n use crate::gen::fs;\n use std::error::Error as StdError;\n use std::fmt::{self, Display};\n-use std::io;\n \n pub(super) type Result<T, E = Error> = std::result::Result<T, E>;\n \n #[derive(Debug)]\n pub(super) enum Error {\n     MissingOutDir,\n-    TargetDir(TargetDirError),\n     Fs(fs::Error),\n }\n \n-#[derive(Debug)]\n-pub(crate) enum TargetDirError {\n-    Io(io::Error),\n-    NotFound,\n-}\n-\n impl Display for Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n             Error::MissingOutDir => write!(f, \"missing OUT_DIR environment variable\"),\n-            Error::TargetDir(_) => write!(f, \"unable to identify target dir\"),\n             Error::Fs(err) => err.fmt(f),\n         }\n     }\ndiff --git a/gen/build/src/error.rs b/gen/build/src/error.rs\n--- a/gen/build/src/error.rs\n+++ b/gen/build/src/error.rs\n@@ -31,10 +22,6 @@ impl Display for Error {\n impl StdError for Error {\n     fn source(&self) -> Option<&(dyn StdError + 'static)> {\n         match self {\n-            Error::TargetDir(err) => match err {\n-                TargetDirError::Io(err) => Some(err),\n-                TargetDirError::NotFound => None,\n-            },\n             Error::Fs(err) => err.source(),\n             _ => None,\n         }\ndiff --git a/gen/build/src/lib.rs b/gen/build/src/lib.rs\n--- a/gen/build/src/lib.rs\n+++ b/gen/build/src/lib.rs\n@@ -59,14 +59,14 @@ mod gen;\n mod paths;\n mod syntax;\n \n-use crate::error::Result;\n+use crate::error::{Error, Result};\n use crate::gen::error::report;\n use crate::gen::{fs, Opt};\n-use crate::paths::TargetDir;\n+use crate::paths::{PathExt, TargetDir};\n use cc::Build;\n use std::io::{self, Write};\n use std::iter;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process;\n \n /// This returns a [`cc::Build`] on which you should continue to set up any\ndiff --git a/gen/build/src/lib.rs b/gen/build/src/lib.rs\n--- a/gen/build/src/lib.rs\n+++ b/gen/build/src/lib.rs\n@@ -98,45 +98,99 @@ pub fn bridges(rust_source_files: impl IntoIterator<Item = impl AsRef<Path>>) ->\n     })\n }\n \n+struct Project {\n+    out_dir: PathBuf,\n+    target_dir: TargetDir,\n+}\n+\n+impl Project {\n+    fn init() -> Result<Self> {\n+        let out_dir = paths::out_dir()?;\n+\n+        let target_dir = match cargo::target_dir(&out_dir) {\n+            target_dir @ TargetDir::Path(_) => target_dir,\n+            // Fallback if Cargo did not work.\n+            TargetDir::Unknown => paths::search_parents_for_target_dir(&out_dir),\n+        };\n+\n+        Ok(Project {\n+            out_dir,\n+            target_dir,\n+        })\n+    }\n+}\n+\n fn build(rust_source_files: &mut dyn Iterator<Item = impl AsRef<Path>>) -> Result<Build> {\n-    let ref target_dir = paths::target_dir()?;\n-    let mut build = paths::cc_build(target_dir);\n+    let ref prj = Project::init()?;\n+    let mut build = Build::new();\n     build.cpp(true);\n     build.cpp_link_stdlib(None); // linked via link-cplusplus crate\n-    write_header(target_dir);\n+    build.include(paths::include_dir(prj));\n+    write_header(prj);\n+    symlink_crate(prj, &mut build);\n \n     for path in rust_source_files {\n-        generate_bridge(&mut build, path.as_ref(), target_dir)?;\n+        generate_bridge(prj, &mut build, path.as_ref())?;\n     }\n \n     Ok(build)\n }\n \n-fn write_header(target_dir: &TargetDir) {\n-    let ref cxx_h = paths::include_dir(target_dir).join(\"rust\").join(\"cxx.h\");\n+fn write_header(prj: &Project) {\n+    let ref cxx_h = prj.out_dir.join(\"cxxbridge\").join(\"rust\").join(\"cxx.h\");\n     let _ = write(cxx_h, gen::include::HEADER.as_bytes());\n+    if let TargetDir::Path(target_dir) = &prj.target_dir {\n+        let ref header_dir = target_dir.join(\"cxxbridge\").join(\"rust\");\n+        let _ = fs::create_dir_all(header_dir);\n+        let ref cxx_h = header_dir.join(\"cxx.h\");\n+        let _ = write(cxx_h, gen::include::HEADER.as_bytes());\n+    }\n }\n \n-fn generate_bridge(\n-    build: &mut Build,\n-    rust_source_file: &Path,\n-    target_dir: &TargetDir,\n-) -> Result<()> {\n+fn symlink_crate(prj: &Project, build: &mut Build) {\n+    let manifest_dir = match paths::manifest_dir() {\n+        Some(manifest_dir) => manifest_dir,\n+        None => return,\n+    };\n+    let package_name = match paths::package_name() {\n+        Some(package_name) => package_name,\n+        None => return,\n+    };\n+\n+    let mut link = paths::include_dir(prj);\n+    link.push(\"CRATE\");\n+    let _ = fs::create_dir_all(&link);\n+    let _ = paths::symlink_dir(manifest_dir, link.join(package_name));\n+    build.include(link);\n+}\n+\n+fn generate_bridge(prj: &Project, build: &mut Build, rust_source_file: &Path) -> Result<()> {\n     let opt = Opt::default();\n     let generated = gen::generate_from_path(rust_source_file, &opt);\n+    let ref rel_path = paths::local_relative_path(rust_source_file);\n+\n+    let ref rel_path_h = rel_path.with_appended_extension(\".h\");\n+    let ref header_path = paths::namespaced(&prj.out_dir, rel_path_h);\n+    write(header_path, &generated.header)?;\n \n-    let header_path = paths::out_with_extension(rust_source_file, \".h\", target_dir)?;\n-    fs::create_dir_all(header_path.parent().unwrap())?;\n-    write(&header_path, &generated.header)?;\n-    paths::symlink_header(&header_path, rust_source_file, target_dir);\n+    let ref link_path = paths::namespaced(&prj.out_dir, rel_path);\n+    let _ = paths::symlink_or_copy(header_path, link_path);\n+    if let TargetDir::Path(target_dir) = &prj.target_dir {\n+        let ref link_path = paths::namespaced(target_dir, rel_path);\n+        let _ = fs::create_dir_all(link_path.parent().unwrap());\n+        let _ = paths::symlink_or_copy(header_path, link_path);\n+        let _ = paths::symlink_or_copy(header_path, link_path.with_appended_extension(\".h\"));\n+    }\n \n-    let implementation_path = paths::out_with_extension(rust_source_file, \".cc\", target_dir)?;\n-    write(&implementation_path, &generated.implementation)?;\n-    build.file(&implementation_path);\n+    let ref rel_path_cc = rel_path.with_appended_extension(\".cc\");\n+    let ref implementation_path = paths::namespaced(&prj.out_dir, rel_path_cc);\n+    write(implementation_path, &generated.implementation)?;\n+    build.file(implementation_path);\n     Ok(())\n }\n \n fn write(path: &Path, content: &[u8]) -> Result<()> {\n+    let mut create_dir_error = None;\n     if path.exists() {\n         if let Ok(existing) = fs::read(path) {\n             if existing == content {\ndiff --git a/gen/build/src/lib.rs b/gen/build/src/lib.rs\n--- a/gen/build/src/lib.rs\n+++ b/gen/build/src/lib.rs\n@@ -146,8 +200,14 @@ fn write(path: &Path, content: &[u8]) -> Result<()> {\n         }\n         let _ = fs::remove_file(path);\n     } else {\n-        let _ = fs::create_dir_all(path.parent().unwrap());\n+        let parent = path.parent().unwrap();\n+        create_dir_error = fs::create_dir_all(parent).err();\n+    }\n+\n+    match fs::write(path, content) {\n+        // As long as write succeeded, ignore any create_dir_all error.\n+        Ok(()) => Ok(()),\n+        // If create_dir_all and write both failed, prefer the first error.\n+        Err(err) => Err(Error::Fs(create_dir_error.unwrap_or(err))),\n     }\n-    fs::write(path, content)?;\n-    Ok(())\n }\ndiff --git a/gen/build/src/paths.rs b/gen/build/src/paths.rs\n--- a/gen/build/src/paths.rs\n+++ b/gen/build/src/paths.rs\n@@ -1,124 +1,109 @@\n-use crate::cargo;\n use crate::error::{Error, Result};\n use crate::gen::fs;\n+use crate::Project;\n use std::env;\n-use std::ops::Deref;\n-use std::path::{Path, PathBuf};\n+use std::ffi::{OsStr, OsString};\n+use std::path::{Component, Path, PathBuf};\n \n-pub(crate) struct TargetDir(pub PathBuf);\n-\n-impl Deref for TargetDir {\n-    type Target = Path;\n-    fn deref(&self) -> &Self::Target {\n-        &self.0\n-    }\n+pub(crate) enum TargetDir {\n+    Path(PathBuf),\n+    Unknown,\n }\n \n-fn out_dir() -> Result<PathBuf> {\n+pub(crate) fn out_dir() -> Result<PathBuf> {\n     env::var_os(\"OUT_DIR\")\n         .map(PathBuf::from)\n         .ok_or(Error::MissingOutDir)\n }\n \n-pub(crate) fn cc_build(target_dir: &TargetDir) -> cc::Build {\n-    let mut build = cc::Build::new();\n-    build.include(include_dir(target_dir));\n-    build.include(target_dir.parent().unwrap());\n-    build\n+// Given a path provided by the user, determines where generated files related\n+// to that path should go in our out dir. In particular we don't want to\n+// accidentally write generated code upward of our out dir, even if the user\n+// passed a path containing lots of `..` or an absolute path.\n+pub(crate) fn local_relative_path(path: &Path) -> PathBuf {\n+    let mut rel_path = PathBuf::new();\n+    for component in path.components() {\n+        match component {\n+            Component::Prefix(_) | Component::RootDir | Component::CurDir => {}\n+            Component::ParentDir => drop(rel_path.pop()), // noop if empty\n+            Component::Normal(name) => rel_path.push(name),\n+        }\n+    }\n+    rel_path\n }\n \n-// Symlink the header file into a predictable place. The header generated from\n-// path/to/mod.rs gets linked to targets/cxxbridge/path/to/mod.rs.h.\n-pub(crate) fn symlink_header(path: &Path, original: &Path, target_dir: &TargetDir) {\n-    let _ = try_symlink_header(path, original, target_dir);\n+pub(crate) fn namespaced(base: &Path, rel_path: &Path) -> PathBuf {\n+    let mut path = base.to_owned();\n+    path.push(\"cxxbridge\");\n+    path.extend(package_name());\n+    path.push(rel_path);\n+    path\n }\n \n-fn try_symlink_header(path: &Path, original: &Path, target_dir: &TargetDir) -> Result<()> {\n-    let suffix = relative_to_parent_of_target_dir(original, target_dir)?;\n-    let ref dst = include_dir(target_dir).join(suffix);\n-\n-    fs::create_dir_all(dst.parent().unwrap())?;\n-    let _ = fs::remove_file(dst);\n-    symlink_or_copy(path, dst)?;\n-\n-    let mut file_name = dst.file_name().unwrap().to_os_string();\n-    file_name.push(\".h\");\n-    let ref dst2 = dst.with_file_name(file_name);\n-    symlink_or_copy(path, dst2)?;\n+pub(crate) trait PathExt {\n+    fn with_appended_extension(&self, suffix: impl AsRef<OsStr>) -> PathBuf;\n+}\n \n-    Ok(())\n+impl PathExt for Path {\n+    fn with_appended_extension(&self, suffix: impl AsRef<OsStr>) -> PathBuf {\n+        let mut file_name = self.file_name().unwrap().to_owned();\n+        file_name.push(suffix);\n+        self.with_file_name(file_name)\n+    }\n }\n \n-fn relative_to_parent_of_target_dir(original: &Path, target_dir: &TargetDir) -> Result<PathBuf> {\n-    let mut outer = target_dir.parent().unwrap();\n-    let original = canonicalize(original)?;\n-    loop {\n-        if let Ok(suffix) = original.strip_prefix(outer) {\n-            return Ok(suffix.to_owned());\n-        }\n-        match outer.parent() {\n-            Some(parent) => outer = parent,\n-            None => return Ok(original.components().skip(1).collect()),\n-        }\n+pub(crate) fn include_dir(prj: &Project) -> PathBuf {\n+    match &prj.target_dir {\n+        TargetDir::Path(target_dir) => target_dir.join(\"cxxbridge\"),\n+        TargetDir::Unknown => prj.out_dir.join(\"cxxbridge\"),\n     }\n }\n \n-pub(crate) fn out_with_extension(\n-    path: &Path,\n-    ext: &str,\n-    target_dir: &TargetDir,\n-) -> Result<PathBuf> {\n-    let mut file_name = path.file_name().unwrap().to_owned();\n-    file_name.push(ext);\n-\n-    let out_dir = out_dir()?;\n-    let rel = relative_to_parent_of_target_dir(path, target_dir)?;\n-    Ok(out_dir.join(rel).with_file_name(file_name))\n+pub(crate) fn manifest_dir() -> Option<PathBuf> {\n+    env::var_os(\"CARGO_MANIFEST_DIR\").map(PathBuf::from)\n }\n \n-pub(crate) fn include_dir(target_dir: &TargetDir) -> PathBuf {\n-    target_dir.join(\"cxxbridge\")\n+pub(crate) fn package_name() -> Option<OsString> {\n+    env::var_os(\"CARGO_PKG_NAME\")\n }\n \n-pub(crate) fn target_dir() -> Result<TargetDir> {\n-    let fallback_err = match cargo::target_dir() {\n-        Ok(target_dir) => return Ok(target_dir),\n-        Err(err) => Error::TargetDir(err),\n-    };\n+pub(crate) fn search_parents_for_target_dir(out_dir: &Path) -> TargetDir {\n+    // fs::canonicalize on Windows produces UNC paths which cl.exe is unable to\n+    // handle in includes.\n+    // https://github.com/rust-lang/rust/issues/42869\n+    // https://github.com/alexcrichton/cc-rs/issues/169\n+    let mut also_try_canonical = cfg!(not(windows));\n \n-    // Fallback if Cargo did not work.\n-    let mut dir = out_dir().and_then(canonicalize)?;\n+    let mut dir = out_dir.to_owned();\n     loop {\n-        if dir.ends_with(\"target\") {\n-            return Ok(TargetDir(dir));\n+        let is_target = dir.ends_with(\"target\");\n+        let parent_contains_cargo_toml = dir.with_file_name(\"Cargo.toml\").exists();\n+        if is_target && parent_contains_cargo_toml {\n+            return TargetDir::Path(dir);\n         }\n-        if !dir.pop() {\n-            return Err(fallback_err);\n+        if dir.pop() {\n+            continue;\n         }\n+        if also_try_canonical {\n+            if let Ok(canonical_dir) = out_dir.canonicalize() {\n+                dir = canonical_dir;\n+                also_try_canonical = false;\n+                continue;\n+            }\n+        }\n+        return TargetDir::Unknown;\n     }\n }\n \n-#[cfg(not(windows))]\n-fn canonicalize(path: impl AsRef<Path>) -> Result<PathBuf> {\n-    Ok(fs::canonicalize(path)?)\n-}\n-\n-#[cfg(windows)]\n-fn canonicalize(path: impl AsRef<Path>) -> Result<PathBuf> {\n-    // Real fs::canonicalize on Windows produces UNC paths which cl.exe is\n-    // unable to handle in includes. Use a poor approximation instead.\n-    // https://github.com/rust-lang/rust/issues/42869\n-    // https://github.com/alexcrichton/cc-rs/issues/169\n-    Ok(fs::current_dir()?.join(path))\n-}\n-\n #[cfg(unix)]\n-use self::fs::symlink_file as symlink_or_copy;\n+pub(crate) use self::fs::symlink_file as symlink_or_copy;\n \n #[cfg(windows)]\n-fn symlink_or_copy(src: &Path, dst: &Path) -> Result<()> {\n+pub(crate) fn symlink_or_copy(src: impl AsRef<Path>, dst: impl AsRef<Path>) -> Result<()> {\n     // Pre-Windows 10, symlinks require admin privileges. Since Windows 10, they\n     // require Developer Mode. If it fails, fall back to copying the file.\n+    let src = src.as_ref();\n+    let dst = dst.as_ref();\n     if fs::symlink_file(src, dst).is_err() {\n         fs::copy(src, dst)?;\n     }\ndiff --git a/gen/build/src/paths.rs b/gen/build/src/paths.rs\n--- a/gen/build/src/paths.rs\n+++ b/gen/build/src/paths.rs\n@@ -126,4 +111,12 @@ fn symlink_or_copy(src: &Path, dst: &Path) -> Result<()> {\n }\n \n #[cfg(not(any(unix, windows)))]\n-use self::fs::copy as symlink_or_copy;\n+pub(crate) use self::fs::copy as symlink_or_copy;\n+\n+#[cfg(any(unix, windows))]\n+pub(crate) use self::fs::symlink_dir;\n+\n+#[cfg(not(any(unix, windows)))]\n+pub(crate) fn symlink_dir(_src: impl AsRef<Path>, _dst: impl AsRef<Path>) -> Result<()> {\n+    Ok(())\n+}\ndiff --git a/gen/src/fs.rs b/gen/src/fs.rs\n--- a/gen/src/fs.rs\n+++ b/gen/src/fs.rs\n@@ -34,14 +34,6 @@ macro_rules! err {\n     }\n }\n \n-pub(crate) fn canonicalize(path: impl AsRef<Path>) -> Result<PathBuf> {\n-    let path = path.as_ref();\n-    match std::fs::canonicalize(path) {\n-        Ok(string) => Ok(string),\n-        Err(e) => err!(e, \"Unable to canonicalize path: `{}`\", path),\n-    }\n-}\n-\n pub(crate) fn copy(from: impl AsRef<Path>, to: impl AsRef<Path>) -> Result<u64> {\n     let from = from.as_ref();\n     let to = to.as_ref();\ndiff --git a/third-party/Cargo.lock b/third-party/Cargo.lock\n--- a/third-party/Cargo.lock\n+++ b/third-party/Cargo.lock\n@@ -114,14 +114,6 @@ dependencies = [\n  \"syn\",\n ]\n \n-[[package]]\n-name = \"cxxbridge-demo\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"cxx\",\n- \"cxx-build\",\n-]\n-\n [[package]]\n name = \"cxxbridge-flags\"\n version = \"0.3.9\"\ndiff --git a/third-party/Cargo.lock b/third-party/Cargo.lock\n--- a/third-party/Cargo.lock\n+++ b/third-party/Cargo.lock\n@@ -136,6 +128,14 @@ dependencies = [\n  \"syn\",\n ]\n \n+[[package]]\n+name = \"demo\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cxx\",\n+ \"cxx-build\",\n+]\n+\n [[package]]\n name = \"dissimilar\"\n version = \"1.0.2\"\n",
        "test_patch": "diff --git a/tests/BUCK b/tests/BUCK\n--- a/tests/BUCK\n+++ b/tests/BUCK\n@@ -24,9 +24,10 @@ cxx_library(\n         \":gen-lib-source\",\n         \":gen-module-source\",\n     ],\n+    header_namespace = \"cxx-test-suite\",\n     headers = {\n-        \"ffi/lib.rs.h\": \":gen-lib-header\",\n-        \"ffi/tests.h\": \"ffi/tests.h\",\n+        \"lib.rs.h\": \":gen-lib-header\",\n+        \"tests.h\": \"ffi/tests.h\",\n     },\n     deps = [\"//:core\"],\n )\ndiff --git a/tests/BUILD b/tests/BUILD\n--- a/tests/BUILD\n+++ b/tests/BUILD\n@@ -26,6 +26,8 @@ cc_library(\n         \":gen-module-source\",\n     ],\n     hdrs = [\"ffi/tests.h\"],\n+    include_prefix = \"cxx-test-suite\",\n+    strip_include_prefix = \"ffi\",\n     deps = [\n         \":lib-include\",\n         \"//:core\",\ndiff --git a/tests/BUILD b/tests/BUILD\n--- a/tests/BUILD\n+++ b/tests/BUILD\n@@ -51,7 +53,7 @@ genrule(\n cc_library(\n     name = \"lib-include\",\n     hdrs = [\":gen-lib-header\"],\n-    include_prefix = \"tests/ffi\",\n+    include_prefix = \"cxx-test-suite\",\n )\n \n genrule(\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -23,7 +23,7 @@ pub mod ffi {\n     }\n \n     extern \"C\" {\n-        include!(\"tests/ffi/tests.h\");\n+        include!(\"cxx-test-suite/tests.h\");\n \n         type C;\n \ndiff --git a/tests/ffi/module.rs b/tests/ffi/module.rs\n--- a/tests/ffi/module.rs\n+++ b/tests/ffi/module.rs\n@@ -4,7 +4,7 @@\n #[cxx::bridge(namespace = tests)]\n pub mod ffi {\n     extern \"C\" {\n-        include!(\"tests/ffi/tests.h\");\n+        include!(\"cxx-test-suite/tests.h\");\n \n         type C = crate::ffi::C;\n \ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -1,5 +1,5 @@\n-#include \"tests/ffi/tests.h\"\n-#include \"tests/ffi/lib.rs.h\"\n+#include \"cxx-test-suite/tests.h\"\n+#include \"cxx-test-suite/lib.rs.h\"\n #include <cstring>\n #include <iterator>\n #include <numeric>\n",
        "problem_statement": "Don't rely on the target directory being named 'target'\nCurrently, `paths::target_dir()` tries to find the `target` directory by looking at the name.\r\nThis has two problems:\r\n1. The user might have specified a different target directory by using the Cargo config option `target-dir` (https://doc.rust-lang.org/cargo/reference/config.html)\r\n2. The target directory might be called target, but actually be a symlink to something else that isn't called `target` - and `canonicalize` resolves symlinks.\r\n\r\nIn both cases, `paths::target_dir()` fails.\r\n\r\nWhat is the rationale for not putting all the generated code etc. in the OUT_DIR or a subdirectory thereof directly? If the latter is acceptable, I'm happy to submit a pull request changing the behavior...\n",
        "hints_text": "I would appreciate a PR to improve this.",
        "created_at": "2020-09-02T05:30:59Z",
        "version": "0.3"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 268,
        "instance_id": "dtolnay__cxx-268",
        "issue_numbers": [
            "205"
        ],
        "base_commit": "907debe8b471d75afa0aeaab79335470d6759e8e",
        "patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,9 +14,10 @@ keywords = [\"ffi\"]\n categories = [\"development-tools::ffi\", \"api-bindings\"]\n \n [features]\n-default = [] # c++11\n-\"c++14\" = []\n-\"c++17\" = []\n+default = [\"cxxbridge-flags/default\"] # c++11\n+\"c++14\" = [\"cxxbridge-flags/c++14\"]\n+\"c++17\" = [\"cxxbridge-flags/c++17\"]\n+\"c++20\" = [\"cxxbridge-flags/c++20\"]\n \n [dependencies]\n cxxbridge-macro = { version = \"=0.3.6\", path = \"macro\" }\ndiff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -24,6 +25,7 @@ link-cplusplus = \"1.0\"\n \n [build-dependencies]\n cc = \"1.0.49\"\n+cxxbridge-flags = { version = \"=0.3.6\", path = \"flags\", default-features = false }\n \n [dev-dependencies]\n cxx-build = { version = \"=0.3.6\", path = \"gen/build\" }\ndiff --git a/build.rs b/build.rs\n--- a/build.rs\n+++ b/build.rs\n@@ -3,13 +3,7 @@ fn main() {\n         .file(\"src/cxx.cc\")\n         .cpp(true)\n         .cpp_link_stdlib(None) // linked via link-cplusplus crate\n-        .flag_if_supported(if cfg!(feature = \"c++17\") {\n-            \"-std=c++17\"\n-        } else if cfg!(feature = \"c++14\") {\n-            \"-std=c++14\"\n-        } else {\n-            \"-std=c++11\"\n-        })\n+        .flag_if_supported(cxxbridge_flags::STD)\n         .compile(\"cxxbridge03\");\n     println!(\"cargo:rerun-if-changed=src/cxx.cc\");\n     println!(\"cargo:rerun-if-changed=include/cxx.h\");\ndiff --git /dev/null b/flags/Cargo.toml\nnew file mode 100644\n--- /dev/null\n+++ b/flags/Cargo.toml\n@@ -0,0 +1,17 @@\n+[package]\n+name = \"cxxbridge-flags\"\n+version = \"0.3.6\"\n+authors = [\"David Tolnay <dtolnay@gmail.com>\"]\n+edition = \"2018\"\n+license = \"MIT OR Apache-2.0\"\n+description = \"Compiler configuration of the `cxx` crate (implementation detail)\"\n+repository = \"https://github.com/dtolnay/cxx\"\n+\n+[features]\n+default = [] # c++11\n+\"c++14\" = []\n+\"c++17\" = []\n+\"c++20\" = []\n+\n+[package.metadata.docs.rs]\n+targets = [\"x86_64-unknown-linux-gnu\"]\ndiff --git /dev/null b/flags/src/impl.rs\nnew file mode 100644\n--- /dev/null\n+++ b/flags/src/impl.rs\n@@ -0,0 +1,20 @@\n+#[allow(unused_assignments, unused_mut, unused_variables)]\n+pub const STD: &str = {\n+    let mut flags = [\"-std=c++11\", \"/std:c++11\"];\n+\n+    #[cfg(feature = \"c++14\")]\n+    (flags = [\"-std=c++14\", \"/std:c++14\"]);\n+\n+    #[cfg(feature = \"c++17\")]\n+    (flags = [\"-std=c++17\", \"/std:c++17\"]);\n+\n+    #[cfg(feature = \"c++20\")]\n+    (flags = [\"-std=c++20\", \"/std:c++20\"]);\n+\n+    let [mut flag, msvc_flag] = flags;\n+\n+    #[cfg(target_env = \"msvc\")]\n+    (flag = msvc_flag);\n+\n+    flag\n+};\ndiff --git /dev/null b/flags/src/lib.rs\nnew file mode 100644\n--- /dev/null\n+++ b/flags/src/lib.rs\n@@ -0,0 +1,7 @@\n+//! This crate is an implementation detail of the `cxx` and `cxx-build` crates,\n+//! and does not expose any public API.\n+\n+mod r#impl;\n+\n+#[doc(hidden)]\n+pub use r#impl::*;\ndiff --git a/third-party/Cargo.lock b/third-party/Cargo.lock\n--- a/third-party/Cargo.lock\n+++ b/third-party/Cargo.lock\n@@ -94,6 +95,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"cxx\",\n  \"cxx-build\",\n+ \"cxxbridge-flags\",\n ]\n \n [[package]]\ndiff --git a/third-party/Cargo.lock b/third-party/Cargo.lock\n--- a/third-party/Cargo.lock\n+++ b/third-party/Cargo.lock\n@@ -116,6 +118,10 @@ dependencies = [\n  \"cxx-build\",\n ]\n \n+[[package]]\n+name = \"cxxbridge-flags\"\n+version = \"0.3.6\"\n+\n [[package]]\n name = \"cxxbridge-macro\"\n version = \"0.3.6\"\n",
        "test_patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -32,7 +34,7 @@ rustversion = \"1.0\"\n trybuild = { version = \"1.0.33\", features = [\"diff\"] }\n \n [workspace]\n-members = [\"demo-rs\", \"gen/build\", \"gen/cmd\", \"macro\", \"tests/ffi\"]\n+members = [\"demo-rs\", \"flags\", \"gen/build\", \"gen/cmd\", \"macro\", \"tests/ffi\"]\n \n [package.metadata.docs.rs]\n targets = [\"x86_64-unknown-linux-gnu\"]\ndiff --git a/tests/ffi/Cargo.toml b/tests/ffi/Cargo.toml\n--- a/tests/ffi/Cargo.toml\n+++ b/tests/ffi/Cargo.toml\n@@ -12,3 +12,4 @@ cxx = { path = \"../..\" }\n \n [build-dependencies]\n cxx-build = { path = \"../../gen/build\" }\n+cxxbridge-flags = { path = \"../../flags\" }\ndiff --git a/tests/ffi/build.rs b/tests/ffi/build.rs\n--- a/tests/ffi/build.rs\n+++ b/tests/ffi/build.rs\n@@ -6,6 +6,6 @@ fn main() {\n     let sources = vec![\"lib.rs\", \"module.rs\"];\n     cxx_build::bridges(sources)\n         .file(\"tests.cc\")\n-        .flag_if_supported(\"-std=c++11\")\n+        .flag_if_supported(cxxbridge_flags::STD)\n         .compile(\"cxx-test-suite\");\n }\ndiff --git a/third-party/Cargo.lock b/third-party/Cargo.lock\n--- a/third-party/Cargo.lock\n+++ b/third-party/Cargo.lock\n@@ -70,6 +70,7 @@ dependencies = [\n  \"cc\",\n  \"cxx-build\",\n  \"cxx-test-suite\",\n+ \"cxxbridge-flags\",\n  \"cxxbridge-macro\",\n  \"link-cplusplus\",\n  \"rustversion\",\n",
        "problem_statement": "specify c++ standard flag for msvc\n\n",
        "hints_text": "I can see that it's only  the four builds on nightly that are failing, and I can reproduce this locally on nightly. stable is fine.\r\n\r\nNote that the failed build is not because of trying to include the Windows flag support, but by trying to push the C++ version feature flags so that they are visible to the test suite's `build.rs` command. I guess as a workaround we could force the test suite to always use a particular C++ version and not worry about allowing a C++ version feature for the test suite?\r\n\r\nI'm not clear if it's a bug/stricter nightly requirement or a nightly regression though. Tempted to leave this open a few days and see if nightly fixes this.\r\n\r\nIt looks like another instance of https://github.com/rust-lang/cargo/issues/6941, which leads to an open bug raised by @dtolnay here https://github.com/rust-lang/cargo/issues/6915\r\n\r\nThe cargo bugs mention that part of the issue may be that cxx-test-suite is in dev-dependencies ",
        "created_at": "2020-08-29T00:33:18Z",
        "version": "0.3"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 267,
        "instance_id": "dtolnay__cxx-267",
        "issue_numbers": [
            "153"
        ],
        "base_commit": "13e4d3988cc681cbf06a582399946b37b9de882b",
        "patch": "diff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -276,7 +276,8 @@ void cxxbridge03$unique_ptr$std$string$drop(\n #define FOR_EACH_STD_VECTOR(MACRO)                                             \\\n   FOR_EACH_NUMERIC(MACRO)                                                      \\\n   MACRO(usize, size_t)                                                         \\\n-  MACRO(isize, rust::isize)\n+  MACRO(isize, rust::isize)                                                    \\\n+  MACRO(string, std::string)\n \n #define FOR_EACH_RUST_VEC(MACRO)                                               \\\n   FOR_EACH_NUMERIC(MACRO)                                                      \\\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -1,3 +1,4 @@\n+use crate::cxx_string::CxxString;\n use std::ffi::c_void;\n use std::fmt::{self, Display};\n use std::marker::PhantomData;\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -129,16 +130,16 @@ pub unsafe trait VectorElement: Sized {\n     unsafe fn __unique_ptr_drop(repr: *mut c_void);\n }\n \n-macro_rules! impl_vector_element_for_primitive {\n-    ($ty:ident) => {\n+macro_rules! impl_vector_element {\n+    ($segment:expr, $name:expr, $ty:ty) => {\n         const_assert_eq!(1, mem::align_of::<CxxVector<$ty>>());\n \n         unsafe impl VectorElement for $ty {\n-            const __NAME: &'static dyn Display = &stringify!($ty);\n+            const __NAME: &'static dyn Display = &$name;\n             fn __vector_size(v: &CxxVector<$ty>) -> usize {\n                 extern \"C\" {\n                     attr! {\n-                        #[link_name = concat!(\"cxxbridge03$std$vector$\", stringify!($ty), \"$size\")]\n+                        #[link_name = concat!(\"cxxbridge03$std$vector$\", $segment, \"$size\")]\n                         fn __vector_size(_: &CxxVector<$ty>) -> usize;\n                     }\n                 }\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -147,7 +148,7 @@ macro_rules! impl_vector_element_for_primitive {\n             unsafe fn __get_unchecked(v: &CxxVector<$ty>, pos: usize) -> &$ty {\n                 extern \"C\" {\n                     attr! {\n-                        #[link_name = concat!(\"cxxbridge03$std$vector$\", stringify!($ty), \"$get_unchecked\")]\n+                        #[link_name = concat!(\"cxxbridge03$std$vector$\", $segment, \"$get_unchecked\")]\n                         fn __get_unchecked(_: &CxxVector<$ty>, _: usize) -> *const $ty;\n                     }\n                 }\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -156,7 +157,7 @@ macro_rules! impl_vector_element_for_primitive {\n             fn __unique_ptr_null() -> *mut c_void {\n                 extern \"C\" {\n                     attr! {\n-                        #[link_name = concat!(\"cxxbridge03$unique_ptr$std$vector$\", stringify!($ty), \"$null\")]\n+                        #[link_name = concat!(\"cxxbridge03$unique_ptr$std$vector$\", $segment, \"$null\")]\n                         fn __unique_ptr_null(this: *mut *mut c_void);\n                     }\n                 }\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -167,7 +168,7 @@ macro_rules! impl_vector_element_for_primitive {\n             unsafe fn __unique_ptr_raw(raw: *mut CxxVector<Self>) -> *mut c_void {\n                 extern \"C\" {\n                     attr! {\n-                        #[link_name = concat!(\"cxxbridge03$unique_ptr$std$vector$\", stringify!($ty), \"$raw\")]\n+                        #[link_name = concat!(\"cxxbridge03$unique_ptr$std$vector$\", $segment, \"$raw\")]\n                         fn __unique_ptr_raw(this: *mut *mut c_void, raw: *mut CxxVector<$ty>);\n                     }\n                 }\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -178,7 +179,7 @@ macro_rules! impl_vector_element_for_primitive {\n             unsafe fn __unique_ptr_get(repr: *mut c_void) -> *const CxxVector<Self> {\n                 extern \"C\" {\n                     attr! {\n-                        #[link_name = concat!(\"cxxbridge03$unique_ptr$std$vector$\", stringify!($ty), \"$get\")]\n+                        #[link_name = concat!(\"cxxbridge03$unique_ptr$std$vector$\", $segment, \"$get\")]\n                         fn __unique_ptr_get(this: *const *mut c_void) -> *const CxxVector<$ty>;\n                     }\n                 }\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -187,7 +188,7 @@ macro_rules! impl_vector_element_for_primitive {\n             unsafe fn __unique_ptr_release(mut repr: *mut c_void) -> *mut CxxVector<Self> {\n                 extern \"C\" {\n                     attr! {\n-                        #[link_name = concat!(\"cxxbridge03$unique_ptr$std$vector$\", stringify!($ty), \"$release\")]\n+                        #[link_name = concat!(\"cxxbridge03$unique_ptr$std$vector$\", $segment, \"$release\")]\n                         fn __unique_ptr_release(this: *mut *mut c_void) -> *mut CxxVector<$ty>;\n                     }\n                 }\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -196,7 +197,7 @@ macro_rules! impl_vector_element_for_primitive {\n             unsafe fn __unique_ptr_drop(mut repr: *mut c_void) {\n                 extern \"C\" {\n                     attr! {\n-                        #[link_name = concat!(\"cxxbridge03$unique_ptr$std$vector$\", stringify!($ty), \"$drop\")]\n+                        #[link_name = concat!(\"cxxbridge03$unique_ptr$std$vector$\", $segment, \"$drop\")]\n                         fn __unique_ptr_drop(this: *mut *mut c_void);\n                     }\n                 }\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -206,6 +207,12 @@ macro_rules! impl_vector_element_for_primitive {\n     };\n }\n \n+macro_rules! impl_vector_element_for_primitive {\n+    ($ty:ident) => {\n+        impl_vector_element!(stringify!($ty), stringify!($ty), $ty);\n+    };\n+}\n+\n impl_vector_element_for_primitive!(u8);\n impl_vector_element_for_primitive!(u16);\n impl_vector_element_for_primitive!(u32);\ndiff --git a/src/cxx_vector.rs b/src/cxx_vector.rs\n--- a/src/cxx_vector.rs\n+++ b/src/cxx_vector.rs\n@@ -218,3 +225,5 @@ impl_vector_element_for_primitive!(i64);\n impl_vector_element_for_primitive!(isize);\n impl_vector_element_for_primitive!(f32);\n impl_vector_element_for_primitive!(f64);\n+\n+impl_vector_element!(\"string\", \"CxxString\", CxxString);\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -130,8 +130,8 @@ fn check_type_cxx_vector(cx: &mut Check, ptr: &Ty1) {\n \n         match Atom::from(ident) {\n             None | Some(U8) | Some(U16) | Some(U32) | Some(U64) | Some(Usize) | Some(I8)\n-            | Some(I16) | Some(I32) | Some(I64) | Some(Isize) | Some(F32) | Some(F64) => return,\n-            Some(CxxString) => { /* todo */ }\n+            | Some(I16) | Some(I32) | Some(I64) | Some(Isize) | Some(F32) | Some(F64)\n+            | Some(CxxString) => return,\n             Some(Bool) | Some(RustString) => {}\n         }\n     }\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -39,6 +39,7 @@ pub mod ffi {\n         fn c_return_unique_ptr_string() -> UniquePtr<CxxString>;\n         fn c_return_unique_ptr_vector_u8() -> UniquePtr<CxxVector<u8>>;\n         fn c_return_unique_ptr_vector_f64() -> UniquePtr<CxxVector<f64>>;\n+        fn c_return_unique_ptr_vector_string() -> UniquePtr<CxxVector<CxxString>>;\n         fn c_return_unique_ptr_vector_shared() -> UniquePtr<CxxVector<Shared>>;\n         fn c_return_unique_ptr_vector_opaque() -> UniquePtr<CxxVector<C>>;\n         fn c_return_ref_vector(c: &C) -> &CxxVector<u8>;\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -62,6 +63,7 @@ pub mod ffi {\n         fn c_take_unique_ptr_string(s: UniquePtr<CxxString>);\n         fn c_take_unique_ptr_vector_u8(v: UniquePtr<CxxVector<u8>>);\n         fn c_take_unique_ptr_vector_f64(v: UniquePtr<CxxVector<f64>>);\n+        fn c_take_unique_ptr_vector_string(v: UniquePtr<CxxVector<CxxString>>);\n         fn c_take_unique_ptr_vector_shared(v: UniquePtr<CxxVector<Shared>>);\n         fn c_take_ref_vector(v: &CxxVector<u8>);\n         fn c_take_rust_vec(v: Vec<u8>);\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -88,6 +88,11 @@ std::unique_ptr<std::vector<double>> c_return_unique_ptr_vector_f64() {\n   return vec;\n }\n \n+std::unique_ptr<std::vector<std::string>> c_return_unique_ptr_vector_string() {\n+  return std::unique_ptr<std::vector<std::string>>(\n+      new std::vector<std::string>());\n+}\n+\n std::unique_ptr<std::vector<Shared>> c_return_unique_ptr_vector_shared() {\n   auto vec = std::unique_ptr<std::vector<Shared>>(new std::vector<Shared>());\n   vec->push_back(Shared{1010});\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -210,6 +215,12 @@ void c_take_unique_ptr_vector_f64(std::unique_ptr<std::vector<double>> v) {\n   }\n }\n \n+void c_take_unique_ptr_vector_string(\n+    std::unique_ptr<std::vector<std::string>> v) {\n+  (void)v;\n+  cxx_test_suite_set_correct();\n+}\n+\n void c_take_unique_ptr_vector_shared(std::unique_ptr<std::vector<Shared>> v) {\n   if (v->size() == 2) {\n     cxx_test_suite_set_correct();\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -43,6 +43,7 @@ rust::String c_return_rust_string();\n std::unique_ptr<std::string> c_return_unique_ptr_string();\n std::unique_ptr<std::vector<uint8_t>> c_return_unique_ptr_vector_u8();\n std::unique_ptr<std::vector<double>> c_return_unique_ptr_vector_f64();\n+std::unique_ptr<std::vector<std::string>> c_return_unique_ptr_vector_string();\n std::unique_ptr<std::vector<Shared>> c_return_unique_ptr_vector_shared();\n std::unique_ptr<std::vector<C>> c_return_unique_ptr_vector_opaque();\n const std::vector<uint8_t> &c_return_ref_vector(const C &c);\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -67,6 +68,8 @@ void c_take_rust_string(rust::String s);\n void c_take_unique_ptr_string(std::unique_ptr<std::string> s);\n void c_take_unique_ptr_vector_u8(std::unique_ptr<std::vector<uint8_t>> v);\n void c_take_unique_ptr_vector_f64(std::unique_ptr<std::vector<double>> v);\n+void c_take_unique_ptr_vector_string(\n+    std::unique_ptr<std::vector<std::string>> v);\n void c_take_unique_ptr_vector_shared(std::unique_ptr<std::vector<Shared>> v);\n void c_take_ref_vector(const std::vector<uint8_t> &v);\n void c_take_rust_vec(rust::Vec<uint8_t> v);\n",
        "problem_statement": "Support Vec<String> and CxxVector<CxxString>\nThese were omitted from the original round of vector PRs but both should be possible to support.\n",
        "hints_text": "Do you have any suggestions for how to go about implementing this?\r\n\r\nAre there workarounds such as passing `&str`? (I did try this and couldn't get it working either, but I may have been doing something wrong).",
        "created_at": "2020-08-28T07:44:00Z",
        "version": "0.3"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 263,
        "instance_id": "dtolnay__cxx-263",
        "issue_numbers": [
            "256"
        ],
        "base_commit": "a7ba6a629ced417a20b1ba15d88e37d05409c704",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -256,10 +256,14 @@ fn expand_cxx_function_shim(namespace: &Namespace, efn: &ExternFn, types: &Types\n             Type::UniquePtr(_) => quote!(::cxx::UniquePtr::into_raw(#var)),\n             Type::RustVec(_) => quote!(#var.as_mut_ptr() as *const ::cxx::private::RustVec<_>),\n             Type::Ref(ty) => match &ty.inner {\n-                Type::Ident(ident) if ident == RustString => {\n-                    quote!(::cxx::private::RustString::from_ref(#var))\n-                }\n-                Type::RustVec(_) => quote!(::cxx::private::RustVec::from_ref(#var)),\n+                Type::Ident(ident) if ident == RustString => match ty.mutability {\n+                    None => quote!(::cxx::private::RustString::from_ref(#var)),\n+                    Some(_) => quote!(::cxx::private::RustString::from_mut(#var)),\n+                },\n+                Type::RustVec(_) => match ty.mutability {\n+                    None => quote!(::cxx::private::RustVec::from_ref(#var)),\n+                    Some(_) => quote!(::cxx::private::RustVec::from_mut(#var)),\n+                },\n                 _ => quote!(#var),\n             },\n             Type::Str(_) => quote!(::cxx::private::RustStr::from(#var)),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -331,10 +335,14 @@ fn expand_cxx_function_shim(namespace: &Namespace, efn: &ExternFn, types: &Types\n             Type::RustVec(_) => Some(quote!(#call.map(|r| r.into_vec()))),\n             Type::UniquePtr(_) => Some(quote!(#call.map(|r| ::cxx::UniquePtr::from_raw(r)))),\n             Type::Ref(ty) => match &ty.inner {\n-                Type::Ident(ident) if ident == RustString => {\n-                    Some(quote!(#call.map(|r| r.as_string())))\n-                }\n-                Type::RustVec(_) => Some(quote!(#call.map(|r| r.as_vec()))),\n+                Type::Ident(ident) if ident == RustString => match ty.mutability {\n+                    None => Some(quote!(#call.map(|r| r.as_string()))),\n+                    Some(_) => Some(quote!(#call.map(|r| r.as_mut_string()))),\n+                },\n+                Type::RustVec(_) => match ty.mutability {\n+                    None => Some(quote!(#call.map(|r| r.as_vec()))),\n+                    Some(_) => Some(quote!(#call.map(|r| r.as_mut_vec()))),\n+                },\n                 _ => None,\n             },\n             Type::Str(_) => Some(quote!(#call.map(|r| r.as_str()))),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -348,8 +356,14 @@ fn expand_cxx_function_shim(namespace: &Namespace, efn: &ExternFn, types: &Types\n             Type::RustVec(_) => Some(quote!(#call.into_vec())),\n             Type::UniquePtr(_) => Some(quote!(::cxx::UniquePtr::from_raw(#call))),\n             Type::Ref(ty) => match &ty.inner {\n-                Type::Ident(ident) if ident == RustString => Some(quote!(#call.as_string())),\n-                Type::RustVec(_) => Some(quote!(#call.as_vec())),\n+                Type::Ident(ident) if ident == RustString => match ty.mutability {\n+                    None => Some(quote!(#call.as_string())),\n+                    Some(_) => Some(quote!(#call.as_mut_string())),\n+                },\n+                Type::RustVec(_) => match ty.mutability {\n+                    None => Some(quote!(#call.as_vec())),\n+                    Some(_) => Some(quote!(#call.as_mut_vec())),\n+                },\n                 _ => None,\n             },\n             Type::Str(_) => Some(quote!(#call.as_str())),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -497,8 +511,14 @@ fn expand_rust_function_shim_impl(\n             Type::RustVec(_) => quote!(::std::mem::take((*#ident).as_mut_vec())),\n             Type::UniquePtr(_) => quote!(::cxx::UniquePtr::from_raw(#ident)),\n             Type::Ref(ty) => match &ty.inner {\n-                Type::Ident(i) if i == RustString => quote!(#ident.as_string()),\n-                Type::RustVec(_) => quote!(#ident.as_vec()),\n+                Type::Ident(i) if i == RustString => match ty.mutability {\n+                    None => quote!(#ident.as_string()),\n+                    Some(_) => quote!(#ident.as_mut_string()),\n+                },\n+                Type::RustVec(_) => match ty.mutability {\n+                    None => quote!(#ident.as_vec()),\n+                    Some(_) => quote!(#ident.as_mut_vec()),\n+                },\n                 _ => quote!(#ident),\n             },\n             Type::Str(_) => quote!(#ident.as_str()),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -532,10 +552,14 @@ fn expand_rust_function_shim_impl(\n             Type::RustVec(_) => Some(quote!(::cxx::private::RustVec::from(#call))),\n             Type::UniquePtr(_) => Some(quote!(::cxx::UniquePtr::into_raw(#call))),\n             Type::Ref(ty) => match &ty.inner {\n-                Type::Ident(ident) if ident == RustString => {\n-                    Some(quote!(::cxx::private::RustString::from_ref(#call)))\n-                }\n-                Type::RustVec(_) => Some(quote!(::cxx::private::RustVec::from_ref(#call))),\n+                Type::Ident(ident) if ident == RustString => match ty.mutability {\n+                    None => Some(quote!(::cxx::private::RustString::from_ref(#call))),\n+                    Some(_) => Some(quote!(::cxx::private::RustString::from_mut(#call))),\n+                },\n+                Type::RustVec(_) => match ty.mutability {\n+                    None => Some(quote!(::cxx::private::RustVec::from_ref(#call))),\n+                    Some(_) => Some(quote!(::cxx::private::RustVec::from_mut(#call))),\n+                },\n                 _ => None,\n             },\n             Type::Str(_) => Some(quote!(::cxx::private::RustStr::from(#call))),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -860,14 +884,19 @@ fn expand_extern_type(ty: &Type) -> TokenStream {\n             let elem = expand_extern_type(&ty.inner);\n             quote!(::cxx::private::RustVec<#elem>)\n         }\n-        Type::Ref(ty) => match &ty.inner {\n-            Type::Ident(ident) if ident == RustString => quote!(&::cxx::private::RustString),\n-            Type::RustVec(ty) => {\n-                let inner = expand_extern_type(&ty.inner);\n-                quote!(&::cxx::private::RustVec<#inner>)\n+        Type::Ref(ty) => {\n+            let mutability = ty.mutability;\n+            match &ty.inner {\n+                Type::Ident(ident) if ident == RustString => {\n+                    quote!(&#mutability ::cxx::private::RustString)\n+                }\n+                Type::RustVec(ty) => {\n+                    let inner = expand_extern_type(&ty.inner);\n+                    quote!(&#mutability ::cxx::private::RustVec<#inner>)\n+                }\n+                _ => quote!(#ty),\n             }\n-            _ => quote!(#ty),\n-        },\n+        }\n         Type::Str(_) => quote!(::cxx::private::RustStr),\n         Type::SliceRefU8(_) => quote!(::cxx::private::RustSliceU8),\n         _ => quote!(#ty),\ndiff --git a/src/rust_string.rs b/src/rust_string.rs\n--- a/src/rust_string.rs\n+++ b/src/rust_string.rs\n@@ -14,6 +14,10 @@ impl RustString {\n         unsafe { &*(s as *const String as *const RustString) }\n     }\n \n+    pub fn from_mut(s: &mut String) -> &mut Self {\n+        unsafe { &mut *(s as *mut String as *mut RustString) }\n+    }\n+\n     pub fn into_string(self) -> String {\n         self.repr\n     }\ndiff --git a/src/rust_vec.rs b/src/rust_vec.rs\n--- a/src/rust_vec.rs\n+++ b/src/rust_vec.rs\n@@ -16,6 +16,10 @@ impl<T> RustVec<T> {\n         unsafe { &*(v as *const Vec<T> as *const RustVec<T>) }\n     }\n \n+    pub fn from_mut(v: &mut Vec<T>) -> &mut Self {\n+        unsafe { &mut *(v as *mut Vec<T> as *mut RustVec<T>) }\n+    }\n+\n     pub fn into_vec(self) -> Vec<T> {\n         self.repr\n     }\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -32,6 +32,7 @@ pub mod ffi {\n         fn c_return_box() -> Box<R>;\n         fn c_return_unique_ptr() -> UniquePtr<C>;\n         fn c_return_ref(shared: &Shared) -> &usize;\n+        fn c_return_mut(shared: &mut Shared) -> &mut usize;\n         fn c_return_str(shared: &Shared) -> &str;\n         fn c_return_sliceu8(shared: &Shared) -> &[u8];\n         fn c_return_rust_string() -> String;\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -41,8 +42,10 @@ pub mod ffi {\n         fn c_return_unique_ptr_vector_shared() -> UniquePtr<CxxVector<Shared>>;\n         fn c_return_unique_ptr_vector_opaque() -> UniquePtr<CxxVector<C>>;\n         fn c_return_ref_vector(c: &C) -> &CxxVector<u8>;\n+        fn c_return_mut_vector(c: &mut C) -> &mut CxxVector<u8>;\n         fn c_return_rust_vec() -> Vec<u8>;\n         fn c_return_ref_rust_vec(c: &C) -> &Vec<u8>;\n+        fn c_return_mut_rust_vec(c: &mut C) -> &mut Vec<u8>;\n         fn c_return_identity(_: usize) -> usize;\n         fn c_return_sum(_: usize, _: usize) -> usize;\n         fn c_return_enum(n: u16) -> Enum;\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -113,11 +116,13 @@ pub mod ffi {\n         fn r_return_box() -> Box<R>;\n         fn r_return_unique_ptr() -> UniquePtr<C>;\n         fn r_return_ref(shared: &Shared) -> &usize;\n+        fn r_return_mut(shared: &mut Shared) -> &mut usize;\n         fn r_return_str(shared: &Shared) -> &str;\n         fn r_return_rust_string() -> String;\n         fn r_return_unique_ptr_string() -> UniquePtr<CxxString>;\n         fn r_return_rust_vec() -> Vec<u8>;\n         fn r_return_ref_rust_vec(shared: &Shared) -> &Vec<u8>;\n+        fn r_return_mut_rust_vec(shared: &mut Shared) -> &mut Vec<u8>;\n         fn r_return_identity(_: usize) -> usize;\n         fn r_return_sum(_: usize, _: usize) -> usize;\n         fn r_return_enum(n: u32) -> Enum;\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -195,6 +200,10 @@ fn r_return_ref(shared: &ffi::Shared) -> &usize {\n     &shared.z\n }\n \n+fn r_return_mut(shared: &mut ffi::Shared) -> &mut usize {\n+    &mut shared.z\n+}\n+\n fn r_return_str(shared: &ffi::Shared) -> &str {\n     let _ = shared;\n     \"2020\"\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -220,6 +229,11 @@ fn r_return_ref_rust_vec(shared: &ffi::Shared) -> &Vec<u8> {\n     unimplemented!()\n }\n \n+fn r_return_mut_rust_vec(shared: &mut ffi::Shared) -> &mut Vec<u8> {\n+    let _ = shared;\n+    unimplemented!()\n+}\n+\n fn r_return_identity(n: usize) -> usize {\n     n\n }\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -35,6 +35,8 @@ size_t C::get_fail() { throw std::runtime_error(\"unimplemented\"); }\n \n const std::vector<uint8_t> &C::get_v() const { return this->v; }\n \n+std::vector<uint8_t> &C::get_v() { return this->v; }\n+\n size_t c_return_primitive() { return 2020; }\n \n Shared c_return_shared() { return Shared{2020}; }\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -49,6 +51,8 @@ std::unique_ptr<C> c_return_unique_ptr() {\n \n const size_t &c_return_ref(const Shared &shared) { return shared.z; }\n \n+size_t &c_return_mut(Shared &shared) { return shared.z; }\n+\n rust::Str c_return_str(const Shared &shared) {\n   (void)shared;\n   return \"2020\";\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -99,6 +103,8 @@ const std::vector<uint8_t> &c_return_ref_vector(const C &c) {\n   return c.get_v();\n }\n \n+std::vector<uint8_t> &c_return_mut_vector(C &c) { return c.get_v(); }\n+\n rust::Vec<uint8_t> c_return_rust_vec() {\n   throw std::runtime_error(\"unimplemented\");\n }\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -108,6 +114,11 @@ const rust::Vec<uint8_t> &c_return_ref_rust_vec(const C &c) {\n   throw std::runtime_error(\"unimplemented\");\n }\n \n+rust::Vec<uint8_t> &c_return_mut_rust_vec(C &c) {\n+  (void)c;\n+  throw std::runtime_error(\"unimplemented\");\n+}\n+\n size_t c_return_identity(size_t n) { return n; }\n \n size_t c_return_sum(size_t n1, size_t n2) { return n1 + n2; }\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -19,6 +19,7 @@ class C {\n   size_t set_succeed(size_t n);\n   size_t get_fail();\n   const std::vector<uint8_t> &get_v() const;\n+  std::vector<uint8_t> &get_v();\n \n private:\n   size_t n;\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -35,6 +36,7 @@ Shared c_return_shared();\n rust::Box<R> c_return_box();\n std::unique_ptr<C> c_return_unique_ptr();\n const size_t &c_return_ref(const Shared &shared);\n+size_t &c_return_mut(Shared &shared);\n rust::Str c_return_str(const Shared &shared);\n rust::Slice<uint8_t> c_return_sliceu8(const Shared &shared);\n rust::String c_return_rust_string();\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -44,8 +46,10 @@ std::unique_ptr<std::vector<double>> c_return_unique_ptr_vector_f64();\n std::unique_ptr<std::vector<Shared>> c_return_unique_ptr_vector_shared();\n std::unique_ptr<std::vector<C>> c_return_unique_ptr_vector_opaque();\n const std::vector<uint8_t> &c_return_ref_vector(const C &c);\n+std::vector<uint8_t> &c_return_mut_vector(C &c);\n rust::Vec<uint8_t> c_return_rust_vec();\n const rust::Vec<uint8_t> &c_return_ref_rust_vec(const C &c);\n+rust::Vec<uint8_t> &c_return_mut_rust_vec(C &c);\n size_t c_return_identity(size_t n);\n size_t c_return_sum(size_t n1, size_t n2);\n Enum c_return_enum(uint16_t n);\n",
        "problem_statement": "Pass Vec of FFI-defined shared struct from C++ to Rust?\nI have a cxxbridge section that defines a shared type `Foo`, and I'd like to pass multiple such `Foo` objects from C++ to Rust in either a `std::vector` or a Rust `Vec`. The values need to be owned values, not references, because `Foo` in turn contains a `Box<RustOpaqueType>` that I need to move out of.\r\n\r\nIs this possible today? `std::vector` can only be passed by reference, so my initial attempt using `CxxVector` failed. There also doesn't seem to be any way to build a Rust `Vec` from the C++ side.\n",
        "hints_text": "Code generation using cxxbridge-cmd succeeded for this workaround attempt but then failed in the Rust build. I have another `&mut Box<OpaqueType>` parameter elsewhere and that works fine, so I guess this is something specific to `Vec`?\r\n\r\n```\r\n#[cxx::bridge(namespace = process::ffi)]\r\nmod ffi {\r\n    struct StartupHandle {\r\n        handle: Box<Handle>,\r\n        handle_type: u16,\r\n        arg: u16,\r\n    }\r\n\r\n    extern \"Rust\" {\r\n        type Handle;\r\n\r\n        fn add_handle_to_vec(vec: &mut Vec<StartupHandle>, handle: StartupHandle);\r\n    }\r\n}\r\n\r\nfn add_handle_to_vec(vec: &mut Vec<ffi::StartupHandle>, handle: ffi::StartupHandle) {\r\n    vec.push(handle);\r\n}\r\n```\r\n\r\n```\r\nerror[E0308]: mismatched types\r\n  --> ../../src/lib/process_builder/ffi/lib.rs:13:1\r\n   |\r\n13 | #[cxx::bridge(namespace = process::ffi)]\r\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\r\n   |\r\n   = note: expected mutable reference `&mut std::vec::Vec<ffi::StartupHandle>`\r\n                      found reference `&std::vec::Vec<ffi::StartupHandle>`\r\n   = note: this error originates in an attribute macro (in Nightly builds, run with -Z macro-backtrace for more info)\r\n```\nHere's the section of expanded macro (from `cargo expand`) that it seems to be failing on, note the non-mutable `::cxx::private::RustVec` reference:\r\n\r\n```\r\n        #[doc(hidden)]\r\n        #[export_name = \"process$ffi$cxxbridge03$add_handle_to_vec\"]\r\n        unsafe extern \"C\" fn __add_handle_to_vec(\r\n            vec: &::cxx::private::RustVec<StartupHandle>,\r\n            handle: *mut StartupHandle,\r\n        ) {\r\n            let __fn = \"_ffi_rust_lib_rustc_static::ffi::add_handle_to_vec\";\r\n            ::cxx::private::catch_unwind(__fn, move || {\r\n                super::add_handle_to_vec(vec.as_vec(), ::std::ptr::read(handle))\r\n            })\r\n        }\r\n```\n> ```console\r\n>    = note: expected mutable reference `&mut std::vec::Vec<ffi::StartupHandle>`\r\n>                       found reference `&std::vec::Vec<ffi::StartupHandle>`\r\n> ```\r\n\r\nThe fact that we generate noncompilable code here is a bug. What you wrote is supposed to work.\r\n\r\n<br>\r\n\r\n> `std::vector` can only be passed by reference, so my initial attempt using `CxxVector` failed.\r\n\r\nYeah, std::vector has a move constructor so Rust-style byte copy moves would screw it up. Therefore we can't allow std::vector to exist by value on the Rust side. As a workaround that isn't incompatible with Rust you can use std::unique_ptr\\<std::vector\\<T\\>\\> which is supported today ([tested here](https://github.com/dtolnay/cxx/blob/85487b00f8790fe28e8d82e9dfab3b3145503631/tests/ffi/lib.rs#L40)).\nI'm happy to take a swing at fixing the bug, I'll see if I can find some time over the next couple days.",
        "created_at": "2020-08-27T07:59:22Z",
        "version": "0.3"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 231,
        "instance_id": "dtolnay__cxx-231",
        "issue_numbers": [
            "219"
        ],
        "base_commit": "4caede68764f2ed0a57fba26f10c3728fc1849b3",
        "patch": "diff --git a/gen/cmd/src/main.rs b/gen/cmd/src/main.rs\n--- a/gen/cmd/src/main.rs\n+++ b/gen/cmd/src/main.rs\n@@ -35,6 +35,15 @@ struct Opt {\n     #[structopt(long)]\n     header: bool,\n \n+    /// Optional annotation for implementations of C++ function\n+    /// wrappers that may be exposed to Rust. You may for example\n+    /// need to provide __declspec(dllexport) or\n+    /// __attribute__((visibility(\"default\"))) if Rust code from\n+    /// one shared object or executable depends on these C++ functions\n+    /// in another.\n+    #[structopt(long)]\n+    cxx_impl_annotations: Option<String>,\n+\n     /// Any additional headers to #include\n     #[structopt(short, long)]\n     include: Vec<String>,\ndiff --git a/gen/cmd/src/main.rs b/gen/cmd/src/main.rs\n--- a/gen/cmd/src/main.rs\n+++ b/gen/cmd/src/main.rs\n@@ -49,6 +58,7 @@ fn main() {\n \n     let gen = gen::Opt {\n         include: opt.include,\n+        cxx_impl_annotations: opt.cxx_impl_annotations,\n     };\n \n     match (opt.input, opt.header) {\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -86,13 +86,13 @@ pub(super) fn gen(\n         out.begin_block(\"extern \\\"C\\\"\");\n         write_exception_glue(out, apis);\n         for api in apis {\n-            let (efn, write): (_, fn(_, _, _)) = match api {\n+            let (efn, write): (_, fn(_, _, _, _)) = match api {\n                 Api::CxxFunction(efn) => (efn, write_cxx_function_shim),\n                 Api::RustFunction(efn) => (efn, write_rust_function_decl),\n                 _ => continue,\n             };\n             out.next_section();\n-            write(out, efn, types);\n+            write(out, efn, types, &opt.cxx_impl_annotations);\n         }\n         out.end_block(\"extern \\\"C\\\"\");\n     }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -399,7 +399,17 @@ fn write_exception_glue(out: &mut OutFile, apis: &[Api]) {\n     }\n }\n \n-fn write_cxx_function_shim(out: &mut OutFile, efn: &ExternFn, types: &Types) {\n+fn write_cxx_function_shim(\n+    out: &mut OutFile,\n+    efn: &ExternFn,\n+    types: &Types,\n+    impl_annotations: &Option<String>,\n+) {\n+    if !out.header {\n+        if let Some(annotation) = impl_annotations {\n+            write!(out, \"{} \", annotation);\n+        }\n+    }\n     if efn.throws {\n         write!(out, \"::rust::Str::Repr \");\n     } else {\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -560,7 +570,7 @@ fn write_function_pointer_trampoline(\n     write_rust_function_shim_impl(out, &c_trampoline, f, types, &r_trampoline, indirect_call);\n }\n \n-fn write_rust_function_decl(out: &mut OutFile, efn: &ExternFn, types: &Types) {\n+fn write_rust_function_decl(out: &mut OutFile, efn: &ExternFn, types: &Types, _: &Option<String>) {\n     let link_name = mangle::extern_fn(&out.namespace, efn);\n     let indirect_call = false;\n     write_rust_function_decl_impl(out, &link_name, efn, types, indirect_call);\n",
        "test_patch": "diff --git a/gen/src/mod.rs b/gen/src/mod.rs\n--- a/gen/src/mod.rs\n+++ b/gen/src/mod.rs\n@@ -24,38 +24,81 @@ struct Input {\n pub(super) struct Opt {\n     /// Any additional headers to #include\n     pub include: Vec<String>,\n+    /// Whether to set __attribute__((visibility(\"default\")))\n+    /// or similar annotations on function implementations.\n+    pub cxx_impl_annotations: Option<String>,\n }\n \n pub(super) fn do_generate_bridge(path: &Path, opt: Opt) -> Vec<u8> {\n     let header = false;\n-    generate(path, opt, header)\n+    generate_from_path(path, opt, header)\n }\n \n pub(super) fn do_generate_header(path: &Path, opt: Opt) -> Vec<u8> {\n     let header = true;\n-    generate(path, opt, header)\n+    generate_from_path(path, opt, header)\n }\n \n-fn generate(path: &Path, opt: Opt, header: bool) -> Vec<u8> {\n+fn generate_from_path(path: &Path, opt: Opt, header: bool) -> Vec<u8> {\n     let source = match fs::read_to_string(path) {\n         Ok(source) => source,\n         Err(err) => format_err(path, \"\", Error::Io(err)),\n     };\n-    match (|| -> Result<_> {\n-        proc_macro2::fallback::force();\n-        let ref mut errors = Errors::new();\n-        let syntax = syn::parse_file(&source)?;\n-        let bridge = find::find_bridge_mod(syntax)?;\n-        let ref namespace = bridge.namespace;\n-        let ref apis = syntax::parse_items(errors, bridge.module);\n-        let ref types = Types::collect(errors, apis);\n-        errors.propagate()?;\n-        check::typecheck(errors, namespace, apis, types);\n-        errors.propagate()?;\n-        let out = write::gen(namespace, apis, types, opt, header);\n-        Ok(out)\n-    })() {\n-        Ok(out) => out.content(),\n+    match generate(&source, opt, header) {\n+        Ok(out) => out,\n         Err(err) => format_err(path, &source, err),\n     }\n }\n+\n+fn generate(source: &str, opt: Opt, header: bool) -> Result<Vec<u8>> {\n+    proc_macro2::fallback::force();\n+    let ref mut errors = Errors::new();\n+    let syntax = syn::parse_file(&source)?;\n+    let bridge = find::find_bridge_mod(syntax)?;\n+    let ref namespace = bridge.namespace;\n+    let ref apis = syntax::parse_items(errors, bridge.module);\n+    let ref types = Types::collect(errors, apis);\n+    errors.propagate()?;\n+    check::typecheck(errors, namespace, apis, types);\n+    errors.propagate()?;\n+    let out = write::gen(namespace, apis, types, opt, header);\n+    Ok(out.content())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::gen::{generate, Opt};\n+\n+    const CPP_EXAMPLE: &'static str = r#\"\n+        #[cxx::bridge]\n+        mod ffi {\n+            extern \"C\" {\n+                pub fn do_cpp_thing(foo: &str);\n+            }\n+        }\n+        \"#;\n+\n+    #[test]\n+    fn test_cpp() {\n+        let opts = Opt {\n+            include: Vec::new(),\n+            cxx_impl_annotations: None,\n+        };\n+        let output = generate(CPP_EXAMPLE, opts, false).unwrap();\n+        let output = std::str::from_utf8(&output).unwrap();\n+        // To avoid continual breakage we won't test every byte.\n+        // Let's look for the major features.\n+        assert!(output.contains(\"void cxxbridge03$do_cpp_thing(::rust::Str::Repr foo)\"));\n+    }\n+\n+    #[test]\n+    fn test_annotation() {\n+        let opts = Opt {\n+            include: Vec::new(),\n+            cxx_impl_annotations: Some(\"ANNOTATION\".to_string()),\n+        };\n+        let output = generate(CPP_EXAMPLE, opts, false).unwrap();\n+        let output = std::str::from_utf8(&output).unwrap();\n+        assert!(output.contains(\"ANNOTATION void cxxbridge03$do_cpp_thing(::rust::Str::Repr foo)\"));\n+    }\n+}\n",
        "problem_statement": "Add ability to set symbol visibility\nTL;DR:\r\n\r\nI've needed to hack my generated `.cc` files to change:\r\n\r\n```cpp\r\nextern \"C\" {\r\nvoid base$cxxbridge03$log_string(::rust::Str::Repr msg) noexcept {\r\n  void (*log_string$)(::rust::Str) = log_string;\r\n  log_string$(msg);\r\n}\r\n} // extern \"C\"\r\n```\r\n\r\nto\r\n\r\n```cpp\r\nextern \"C\" {\r\n__attribute__((visibility(\"default\"))) void base$cxxbridge03$log_string(::rust::Str::Repr msg) noexcept {\r\n  void (*log_string$)(::rust::Str) = log_string;\r\n  log_string$(msg);\r\n}\r\n```\r\n\r\nI would like to add the ability to do that, possibly with an additional parameter to the `cxx::bridge` macro alongside the existing `namespace` parameter.\r\n\r\nHere's why.\r\n\r\nOur final build products are:\r\n* C++ library `libservices.so`. This C++ depends upon APIs exported from...\r\n* C++ library `libbase.so`\r\n\r\nEach contains a blob of Rust code:\r\n* Rust rlib `librust_services.rlib`\r\n* Rust rlib `librust_base.rlib`\r\n\r\n`librust_services.rlib` uses APIs exported publicly by `librust_base.rlib`. Specifically, the code in `librust_services.rlib` uses a `log()` API within `librust_base.rlib`, which in turn uses native code within the rest of `libbase.so`.\r\n\r\nThe only officially approved way to make these C++ binaries is by generating two Rust `staticlib`s:\r\n* Rust staticlib `libservices_rust_deps.a`\r\n* Rust staticlib `libbase_rust_deps.a`\r\nand then linking them into the .so files with all the rest of the C++ code.\r\n\r\nSo we hope to achieve this call stack:\r\n* Rust code in `librust_services.rlib` (which gets built into `libservices.so`). It calls\r\n* Rust code in `librust_base.rlib`, which calls\r\n* Native code elsewhere in `libbase.so`\r\n\r\nSo, where should the code in `librust_base.rlib` end up? Specifically this `log()` Rust API?\r\n\r\nIdeally, that Rust API would _only_ be in `libbase.so` and so the Rust code within `libservices.so` would call other Rust code in `libbase.so`. But as far as I know, that's impossible. Rust doesn't provide a way to mark Rust code as exported from a `staticlib` - there is no equivalent to the C directive `__attribute__((visibility(\"default\")))`. (Again, as far as I understand it) Rust will only attempt to keep C-facing APIs marked with `#[no_mangle]` directive; there's no way to ask that a given Rust API is exported from a `.so` which is downstream of a `staticlib`. (Maybe this merits an issue filed against rust - I'd be interested in opinions - this conflation of exporting vs naming seems to cause trouble now and again, e.g. https://github.com/rust-lang/rust/issues/54135#issuecomment-607935953).\r\n\r\nGiven that we can't export the Rust `log()` API from `libbase.so`, we need to build the Rust code into `libservices.so`. But now the Rust code has to depend upon the C++ implementations, which means we need to export them from `libbase.so`. Hence - the need for the generated C++ code to export the symbols from `libbase.so`.\r\n\r\nWould you accept a PR to add this exporting ability?\n",
        "hints_text": "Thanks for the detailed explanation. I would accept a PR for a c++ code generator command line flag or an attribute (`#[cxx::bridge(namespace = base, dso_export)]`?) or whatever you think is more appropriate. Or is it something that would be reasonable to emit unconditionally?\nThanks! I've decided to poke the bear of the underlying issue first, and we'll see how that goes, but I fully expect a PR to land on your virtual desk at some point here.",
        "created_at": "2020-07-22T00:26:24Z",
        "version": "0.3"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 196,
        "instance_id": "dtolnay__cxx-196",
        "issue_numbers": [
            "175"
        ],
        "base_commit": "699351bc78c30bfcf1b57da62e6d25fc35b0cdeb",
        "patch": "diff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -365,7 +365,9 @@ fn write_enum(out: &mut OutFile, enm: &Enum) {\n     for line in enm.doc.to_string().lines() {\n         writeln!(out, \"//{}\", line);\n     }\n-    writeln!(out, \"enum class {} : uint32_t {{\", enm.ident);\n+    write!(out, \"enum class {} : \", enm.ident);\n+    write_atom(out, enm.repr);\n+    writeln!(out, \" {{\");\n     for variant in &enm.variants {\n         writeln!(out, \"  {} = {},\", variant.ident, variant.discriminant);\n     }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -373,16 +375,15 @@ fn write_enum(out: &mut OutFile, enm: &Enum) {\n }\n \n fn check_enum(out: &mut OutFile, enm: &Enum) {\n-    writeln!(\n-        out,\n-        \"static_assert(sizeof({}) == sizeof(uint32_t), \\\"incorrect size\\\");\",\n-        enm.ident\n-    );\n+    write!(out, \"static_assert(sizeof({}) == sizeof(\", enm.ident);\n+    write_atom(out, enm.repr);\n+    writeln!(out, \"), \\\"incorrect size\\\");\");\n     for variant in &enm.variants {\n+        write!(out, \"static_assert(static_cast<\");\n+        write_atom(out, enm.repr);\n         writeln!(\n             out,\n-            \"static_assert(static_cast<uint32_t>({}::{}) == {},\n-              \\\"disagrees with the value in #[cxx::bridge]\\\");\",\n+            \">({}::{}) == {}, \\\"disagrees with the value in #[cxx::bridge]\\\");\",\n             enm.ident, variant.ident, variant.discriminant,\n         );\n     }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -849,21 +850,7 @@ fn write_extern_arg(out: &mut OutFile, arg: &Var, types: &Types) {\n fn write_type(out: &mut OutFile, ty: &Type) {\n     match ty {\n         Type::Ident(ident) => match Atom::from(ident) {\n-            Some(Bool) => write!(out, \"bool\"),\n-            Some(U8) => write!(out, \"uint8_t\"),\n-            Some(U16) => write!(out, \"uint16_t\"),\n-            Some(U32) => write!(out, \"uint32_t\"),\n-            Some(U64) => write!(out, \"uint64_t\"),\n-            Some(Usize) => write!(out, \"size_t\"),\n-            Some(I8) => write!(out, \"int8_t\"),\n-            Some(I16) => write!(out, \"int16_t\"),\n-            Some(I32) => write!(out, \"int32_t\"),\n-            Some(I64) => write!(out, \"int64_t\"),\n-            Some(Isize) => write!(out, \"::rust::isize\"),\n-            Some(F32) => write!(out, \"float\"),\n-            Some(F64) => write!(out, \"double\"),\n-            Some(CxxString) => write!(out, \"::std::string\"),\n-            Some(RustString) => write!(out, \"::rust::String\"),\n+            Some(atom) => write_atom(out, atom),\n             None => write!(out, \"{}\", ident),\n         },\n         Type::RustBox(ty) => {\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -922,6 +909,26 @@ fn write_type(out: &mut OutFile, ty: &Type) {\n     }\n }\n \n+fn write_atom(out: &mut OutFile, atom: Atom) {\n+    match atom {\n+        Bool => write!(out, \"bool\"),\n+        U8 => write!(out, \"uint8_t\"),\n+        U16 => write!(out, \"uint16_t\"),\n+        U32 => write!(out, \"uint32_t\"),\n+        U64 => write!(out, \"uint64_t\"),\n+        Usize => write!(out, \"size_t\"),\n+        I8 => write!(out, \"int8_t\"),\n+        I16 => write!(out, \"int16_t\"),\n+        I32 => write!(out, \"int32_t\"),\n+        I64 => write!(out, \"int64_t\"),\n+        Isize => write!(out, \"::rust::isize\"),\n+        F32 => write!(out, \"float\"),\n+        F64 => write!(out, \"double\"),\n+        CxxString => write!(out, \"::std::string\"),\n+        RustString => write!(out, \"::rust::String\"),\n+    }\n+}\n+\n fn write_type_space(out: &mut OutFile, ty: &Type) {\n     write_type(out, ty);\n     write_space_after_type(out, ty);\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -143,6 +143,7 @@ fn expand_struct(strct: &Struct) -> TokenStream {\n fn expand_enum(enm: &Enum) -> TokenStream {\n     let ident = &enm.ident;\n     let doc = &enm.doc;\n+    let repr = enm.repr;\n     let variants = enm.variants.iter().map(|variant| {\n         let variant_ident = &variant.ident;\n         let discriminant = &variant.discriminant;\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -155,7 +156,7 @@ fn expand_enum(enm: &Enum) -> TokenStream {\n         #[derive(Copy, Clone, PartialEq, Eq)]\n         #[repr(transparent)]\n         pub struct #ident {\n-            pub repr: u32,\n+            pub repr: #repr,\n         }\n \n         #[allow(non_upper_case_globals)]\ndiff --git a/syntax/atom.rs b/syntax/atom.rs\n--- a/syntax/atom.rs\n+++ b/syntax/atom.rs\n@@ -23,8 +23,12 @@ pub enum Atom {\n \n impl Atom {\n     pub fn from(ident: &Ident) -> Option<Self> {\n+        Self::from_str(ident.to_string().as_str())\n+    }\n+\n+    pub fn from_str(s: &str) -> Option<Self> {\n         use self::Atom::*;\n-        match ident.to_string().as_str() {\n+        match s {\n             \"bool\" => Some(Bool),\n             \"u8\" => Some(U8),\n             \"u16\" => Some(U16),\ndiff --git a/syntax/attrs.rs b/syntax/attrs.rs\n--- a/syntax/attrs.rs\n+++ b/syntax/attrs.rs\n@@ -1,5 +1,7 @@\n use crate::syntax::report::Errors;\n+use crate::syntax::Atom::{self, *};\n use crate::syntax::{Derive, Doc};\n+use proc_macro2::Ident;\n use syn::parse::{ParseStream, Parser as _};\n use syn::{Attribute, Error, LitStr, Path, Result, Token};\n \ndiff --git a/syntax/attrs.rs b/syntax/attrs.rs\n--- a/syntax/attrs.rs\n+++ b/syntax/attrs.rs\n@@ -7,6 +9,7 @@ use syn::{Attribute, Error, LitStr, Path, Result, Token};\n pub struct Parser<'a> {\n     pub doc: Option<&'a mut Doc>,\n     pub derives: Option<&'a mut Vec<Derive>>,\n+    pub repr: Option<&'a mut Option<Atom>>,\n }\n \n pub(super) fn parse_doc(cx: &mut Errors, attrs: &[Attribute]) -> Doc {\ndiff --git a/syntax/attrs.rs b/syntax/attrs.rs\n--- a/syntax/attrs.rs\n+++ b/syntax/attrs.rs\n@@ -44,6 +47,16 @@ pub(super) fn parse(cx: &mut Errors, attrs: &[Attribute], mut parser: Parser) {\n                 }\n                 Err(err) => return cx.push(err),\n             }\n+        } else if attr.path.is_ident(\"repr\") {\n+            match attr.parse_args_with(parse_repr_attribute) {\n+                Ok(attr) => {\n+                    if let Some(repr) = &mut parser.repr {\n+                        **repr = Some(attr);\n+                        continue;\n+                    }\n+                }\n+                Err(err) => return cx.push(err),\n+            }\n         }\n         return cx.error(attr, \"unsupported attribute\");\n     }\ndiff --git a/syntax/attrs.rs b/syntax/attrs.rs\n--- a/syntax/attrs.rs\n+++ b/syntax/attrs.rs\n@@ -69,3 +82,18 @@ fn parse_derive_attribute(input: ParseStream) -> Result<Vec<Derive>> {\n         })\n         .collect()\n }\n+\n+fn parse_repr_attribute(input: ParseStream) -> Result<Atom> {\n+    let begin = input.cursor();\n+    let ident: Ident = input.parse()?;\n+    if let Some(atom) = Atom::from(&ident) {\n+        match atom {\n+            U8 | U16 | U32 | U64 | Usize | I8 | I16 | I32 | I64 | Isize => return Ok(atom),\n+            _ => {}\n+        }\n+    }\n+    Err(Error::new_spanned(\n+        begin.token_stream(),\n+        \"unrecognized repr\",\n+    ))\n+}\ndiff --git /dev/null b/syntax/discriminant.rs\nnew file mode 100644\n--- /dev/null\n+++ b/syntax/discriminant.rs\n@@ -0,0 +1,280 @@\n+use crate::syntax::Atom::{self, *};\n+use proc_macro2::{Literal, Span, TokenStream};\n+use quote::ToTokens;\n+use std::cmp::Ordering;\n+use std::collections::BTreeSet;\n+use std::fmt::{self, Display};\n+use std::str::FromStr;\n+use std::u64;\n+use syn::{Error, Expr, Lit, Result, Token, UnOp};\n+\n+pub struct DiscriminantSet {\n+    repr: Option<Atom>,\n+    values: BTreeSet<Discriminant>,\n+    previous: Option<Discriminant>,\n+}\n+\n+#[derive(Copy, Clone, Eq, PartialEq)]\n+pub struct Discriminant {\n+    negative: bool,\n+    magnitude: u64,\n+}\n+\n+impl DiscriminantSet {\n+    pub fn new(repr: Option<Atom>) -> Self {\n+        DiscriminantSet {\n+            repr,\n+            values: BTreeSet::new(),\n+            previous: None,\n+        }\n+    }\n+\n+    pub fn insert(&mut self, expr: &Expr) -> Result<Discriminant> {\n+        let (discriminant, repr) = expr_to_discriminant(expr)?;\n+        match (self.repr, repr) {\n+            (None, _) => self.repr = repr,\n+            (Some(prev), Some(repr)) if prev != repr => {\n+                let msg = format!(\"expected {}, found {}\", prev, repr);\n+                return Err(Error::new(Span::call_site(), msg));\n+            }\n+            _ => {}\n+        }\n+        insert(self, discriminant)\n+    }\n+\n+    pub fn insert_next(&mut self) -> Result<Discriminant> {\n+        let discriminant = match self.previous {\n+            None => Discriminant::zero(),\n+            Some(mut discriminant) if discriminant.negative => {\n+                discriminant.magnitude -= 1;\n+                if discriminant.magnitude == 0 {\n+                    discriminant.negative = false;\n+                }\n+                discriminant\n+            }\n+            Some(mut discriminant) => {\n+                if discriminant.magnitude == u64::MAX {\n+                    let msg = format!(\"discriminant overflow on value after {}\", u64::MAX);\n+                    return Err(Error::new(Span::call_site(), msg));\n+                }\n+                discriminant.magnitude += 1;\n+                discriminant\n+            }\n+        };\n+        insert(self, discriminant)\n+    }\n+\n+    pub fn inferred_repr(&self) -> Result<Atom> {\n+        if let Some(repr) = self.repr {\n+            return Ok(repr);\n+        }\n+        if self.values.is_empty() {\n+            return Ok(U8);\n+        }\n+        let min = *self.values.iter().next().unwrap();\n+        let max = *self.values.iter().next_back().unwrap();\n+        for bounds in &BOUNDS {\n+            if bounds.min <= min && max <= bounds.max {\n+                return Ok(bounds.repr);\n+            }\n+        }\n+        let msg = \"these discriminant values do not fit in any supported enum repr type\";\n+        Err(Error::new(Span::call_site(), msg))\n+    }\n+}\n+\n+fn expr_to_discriminant(expr: &Expr) -> Result<(Discriminant, Option<Atom>)> {\n+    match expr {\n+        Expr::Lit(expr) => {\n+            if let Lit::Int(lit) = &expr.lit {\n+                let discriminant = lit.base10_parse::<Discriminant>()?;\n+                let repr = parse_int_suffix(lit.suffix())?;\n+                return Ok((discriminant, repr));\n+            }\n+        }\n+        Expr::Unary(unary) => {\n+            if let UnOp::Neg(_) = unary.op {\n+                let (mut discriminant, repr) = expr_to_discriminant(&unary.expr)?;\n+                discriminant.negative ^= true;\n+                return Ok((discriminant, repr));\n+            }\n+        }\n+        _ => {}\n+    }\n+    Err(Error::new_spanned(\n+        expr,\n+        \"enums with non-integer literal discriminants are not supported yet\",\n+    ))\n+}\n+\n+fn insert(set: &mut DiscriminantSet, discriminant: Discriminant) -> Result<Discriminant> {\n+    if let Some(expected_repr) = set.repr {\n+        for bounds in &BOUNDS {\n+            if bounds.repr != expected_repr {\n+                continue;\n+            }\n+            if bounds.min <= discriminant && discriminant <= bounds.max {\n+                break;\n+            }\n+            let msg = format!(\n+                \"discriminant value `{}` is outside the limits of {}\",\n+                discriminant, expected_repr,\n+            );\n+            return Err(Error::new(Span::call_site(), msg));\n+        }\n+    }\n+    if set.values.insert(discriminant) {\n+        set.previous = Some(discriminant);\n+        Ok(discriminant)\n+    } else {\n+        let msg = format!(\"discriminant value `{}` already exists\", discriminant);\n+        Err(Error::new(Span::call_site(), msg))\n+    }\n+}\n+\n+impl Discriminant {\n+    const fn zero() -> Self {\n+        Discriminant {\n+            negative: false,\n+            magnitude: 0,\n+        }\n+    }\n+\n+    const fn pos(u: u64) -> Self {\n+        Discriminant {\n+            negative: false,\n+            magnitude: u,\n+        }\n+    }\n+\n+    const fn neg(i: i64) -> Self {\n+        Discriminant {\n+            negative: i < 0,\n+            // This is `i.abs() as u64` but without overflow on MIN. Uses the\n+            // fact that MIN.wrapping_abs() wraps back to MIN whose binary\n+            // representation is 1<<63, and thus the `as u64` conversion\n+            // produces 1<<63 too which happens to be the correct unsigned\n+            // magnitude.\n+            magnitude: i.wrapping_abs() as u64,\n+        }\n+    }\n+}\n+\n+impl Display for Discriminant {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.negative {\n+            f.write_str(\"-\")?;\n+        }\n+        Display::fmt(&self.magnitude, f)\n+    }\n+}\n+\n+impl ToTokens for Discriminant {\n+    fn to_tokens(&self, tokens: &mut TokenStream) {\n+        if self.negative {\n+            Token![-](Span::call_site()).to_tokens(tokens);\n+        }\n+        Literal::u64_unsuffixed(self.magnitude).to_tokens(tokens);\n+    }\n+}\n+\n+impl FromStr for Discriminant {\n+    type Err = Error;\n+\n+    fn from_str(mut s: &str) -> Result<Self> {\n+        let negative = s.starts_with('-');\n+        if negative {\n+            s = &s[1..];\n+        }\n+        match s.parse::<u64>() {\n+            Ok(magnitude) => Ok(Discriminant {\n+                negative,\n+                magnitude,\n+            }),\n+            Err(_) => Err(Error::new(\n+                Span::call_site(),\n+                \"discriminant value outside of supported range\",\n+            )),\n+        }\n+    }\n+}\n+\n+impl Ord for Discriminant {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        match (self.negative, other.negative) {\n+            (true, true) => self.magnitude.cmp(&other.magnitude).reverse(),\n+            (true, false) => Ordering::Less, // negative < positive\n+            (false, true) => Ordering::Greater, // positive > negative\n+            (false, false) => self.magnitude.cmp(&other.magnitude),\n+        }\n+    }\n+}\n+\n+impl PartialOrd for Discriminant {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+fn parse_int_suffix(suffix: &str) -> Result<Option<Atom>> {\n+    if suffix.is_empty() {\n+        return Ok(None);\n+    }\n+    if let Some(atom) = Atom::from_str(suffix) {\n+        match atom {\n+            U8 | U16 | U32 | U64 | Usize | I8 | I16 | I32 | I64 | Isize => return Ok(Some(atom)),\n+            _ => {}\n+        }\n+    }\n+    let msg = format!(\"unrecognized integer suffix: `{}`\", suffix);\n+    Err(Error::new(Span::call_site(), msg))\n+}\n+\n+struct Bounds {\n+    repr: Atom,\n+    min: Discriminant,\n+    max: Discriminant,\n+}\n+\n+const BOUNDS: [Bounds; 8] = [\n+    Bounds {\n+        repr: U8,\n+        min: Discriminant::zero(),\n+        max: Discriminant::pos(std::u8::MAX as u64),\n+    },\n+    Bounds {\n+        repr: I8,\n+        min: Discriminant::neg(std::i8::MIN as i64),\n+        max: Discriminant::pos(std::i8::MAX as u64),\n+    },\n+    Bounds {\n+        repr: U16,\n+        min: Discriminant::zero(),\n+        max: Discriminant::pos(std::u16::MAX as u64),\n+    },\n+    Bounds {\n+        repr: I16,\n+        min: Discriminant::neg(std::i16::MIN as i64),\n+        max: Discriminant::pos(std::i16::MAX as u64),\n+    },\n+    Bounds {\n+        repr: U32,\n+        min: Discriminant::zero(),\n+        max: Discriminant::pos(std::u32::MAX as u64),\n+    },\n+    Bounds {\n+        repr: I32,\n+        min: Discriminant::neg(std::i32::MIN as i64),\n+        max: Discriminant::pos(std::i32::MAX as u64),\n+    },\n+    Bounds {\n+        repr: U64,\n+        min: Discriminant::zero(),\n+        max: Discriminant::pos(std::u64::MAX),\n+    },\n+    Bounds {\n+        repr: I64,\n+        min: Discriminant::neg(std::i64::MIN),\n+        max: Discriminant::pos(std::i64::MAX as u64),\n+    },\n+];\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -4,6 +4,7 @@ pub mod atom;\n mod attrs;\n pub mod check;\n mod derive;\n+mod discriminant;\n mod doc;\n pub mod error;\n pub mod ident;\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -17,11 +18,12 @@ pub mod symbol;\n mod tokens;\n pub mod types;\n \n+use self::discriminant::Discriminant;\n use self::parse::kw;\n use proc_macro2::{Ident, Span};\n use syn::punctuated::Punctuated;\n use syn::token::{Brace, Bracket, Paren};\n-use syn::{Lifetime, LitStr, Token, Type as RustType};\n+use syn::{Expr, Lifetime, LitStr, Token, Type as RustType};\n \n pub use self::atom::Atom;\n pub use self::derive::Derive;\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -61,6 +63,7 @@ pub struct Enum {\n     pub ident: Ident,\n     pub brace_token: Brace,\n     pub variants: Vec<Variant>,\n+    pub repr: Atom,\n }\n \n pub struct ExternFn {\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -106,7 +109,8 @@ pub struct Receiver {\n \n pub struct Variant {\n     pub ident: Ident,\n-    pub discriminant: u32,\n+    pub discriminant: Discriminant,\n+    pub expr: Option<Expr>,\n }\n \n pub enum Type {\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -1,3 +1,4 @@\n+use crate::syntax::discriminant::DiscriminantSet;\n use crate::syntax::report::Errors;\n use crate::syntax::Atom::*;\n use crate::syntax::{\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -5,16 +6,13 @@ use crate::syntax::{\n     Struct, Ty1, Type, TypeAlias, Var, Variant,\n };\n use proc_macro2::TokenStream;\n-use quote::{format_ident, quote};\n-use std::collections::HashSet;\n-use std::u32;\n+use quote::{format_ident, quote, quote_spanned};\n use syn::parse::{ParseStream, Parser};\n use syn::punctuated::Punctuated;\n use syn::{\n-    Abi, Attribute, Error, Expr, ExprLit, Fields, FnArg, ForeignItem, ForeignItemFn,\n-    ForeignItemType, GenericArgument, Ident, Item, ItemEnum, ItemForeignMod, ItemStruct, Lit, Pat,\n-    PathArguments, Result, ReturnType, Token, Type as RustType, TypeBareFn, TypePath,\n-    TypeReference, TypeSlice, Variant as RustVariant,\n+    Abi, Attribute, Error, Fields, FnArg, ForeignItem, ForeignItemFn, ForeignItemType,\n+    GenericArgument, Ident, Item, ItemEnum, ItemForeignMod, ItemStruct, Pat, PathArguments, Result,\n+    ReturnType, Token, Type as RustType, TypeBareFn, TypePath, TypeReference, TypeSlice,\n };\n \n pub mod kw {\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -62,6 +60,7 @@ fn parse_struct(cx: &mut Errors, item: ItemStruct) -> Result<Api> {\n         attrs::Parser {\n             doc: Some(&mut doc),\n             derives: Some(&mut derives),\n+            ..Default::default()\n         },\n     );\n \ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -105,69 +104,71 @@ fn parse_enum(cx: &mut Errors, item: ItemEnum) -> Result<Api> {\n         ));\n     }\n \n-    let doc = attrs::parse_doc(cx, &item.attrs);\n+    let mut doc = Doc::new();\n+    let mut repr = None;\n+    attrs::parse(\n+        cx,\n+        &item.attrs,\n+        attrs::Parser {\n+            doc: Some(&mut doc),\n+            repr: Some(&mut repr),\n+            ..Default::default()\n+        },\n+    );\n \n     let mut variants = Vec::new();\n-    let mut discriminants = HashSet::new();\n-    let mut prev_discriminant = None;\n+    let mut discriminants = DiscriminantSet::new(repr);\n     for variant in item.variants {\n         match variant.fields {\n             Fields::Unit => {}\n             _ => {\n-                return Err(Error::new_spanned(\n-                    variant,\n-                    \"enums with data are not supported yet\",\n-                ));\n+                cx.error(variant, \"enums with data are not supported yet\");\n+                break;\n             }\n         }\n-        if variant.discriminant.is_none() && prev_discriminant == Some(u32::MAX) {\n-            let msg = format!(\"discriminant overflow on value after {}\", u32::MAX);\n-            return Err(Error::new_spanned(variant, msg));\n-        }\n-        let discriminant =\n-            parse_discriminant(&variant)?.unwrap_or_else(|| prev_discriminant.map_or(0, |n| n + 1));\n-        if !discriminants.insert(discriminant) {\n-            let msg = format!(\"discriminant value `{}` already exists\", discriminant);\n-            return Err(Error::new_spanned(variant, msg));\n-        }\n+        let expr = variant.discriminant.as_ref().map(|(_, expr)| expr);\n+        let try_discriminant = match &expr {\n+            Some(lit) => discriminants.insert(lit),\n+            None => discriminants.insert_next(),\n+        };\n+        let discriminant = match try_discriminant {\n+            Ok(discriminant) => discriminant,\n+            Err(err) => {\n+                cx.error(variant, err);\n+                break;\n+            }\n+        };\n+        let expr = variant.discriminant.map(|(_, expr)| expr);\n         variants.push(Variant {\n             ident: variant.ident,\n             discriminant,\n+            expr,\n         });\n-        prev_discriminant = Some(discriminant);\n+    }\n+\n+    let enum_token = item.enum_token;\n+    let brace_token = item.brace_token;\n+\n+    let mut repr = U8;\n+    match discriminants.inferred_repr() {\n+        Ok(inferred) => repr = inferred,\n+        Err(err) => {\n+            let span = quote_spanned!(brace_token.span=> #enum_token {});\n+            cx.error(span, err);\n+            variants.clear();\n+        }\n     }\n \n     Ok(Api::Enum(Enum {\n         doc,\n-        enum_token: item.enum_token,\n+        enum_token,\n         ident: item.ident,\n-        brace_token: item.brace_token,\n+        brace_token,\n         variants,\n+        repr,\n     }))\n }\n \n-fn parse_discriminant(variant: &RustVariant) -> Result<Option<u32>> {\n-    match &variant.discriminant {\n-        None => Ok(None),\n-        Some((\n-            _,\n-            Expr::Lit(ExprLit {\n-                lit: Lit::Int(n), ..\n-            }),\n-        )) => match n.base10_parse() {\n-            Ok(val) => Ok(Some(val)),\n-            Err(_) => Err(Error::new_spanned(\n-                variant,\n-                \"cannot parse enum discriminant as an integer\",\n-            )),\n-        },\n-        _ => Err(Error::new_spanned(\n-            variant,\n-            \"enums with non-integer literal discriminants are not supported yet\",\n-        )),\n-    }\n-}\n-\n fn parse_foreign_mod(cx: &mut Errors, foreign_mod: ItemForeignMod, out: &mut Vec<Api>) {\n     let lang = match parse_lang(foreign_mod.abi) {\n         Ok(lang) => lang,\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -1,6 +1,6 @@\n use crate::syntax::atom::Atom::*;\n use crate::syntax::{\n-    Derive, Enum, ExternFn, ExternType, Receiver, Ref, Signature, Slice, Struct, Ty1, Type,\n+    Atom, Derive, Enum, ExternFn, ExternType, Receiver, Ref, Signature, Slice, Struct, Ty1, Type,\n     TypeAlias, Var,\n };\n use proc_macro2::{Ident, Span, TokenStream};\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -75,6 +75,12 @@ impl ToTokens for Derive {\n     }\n }\n \n+impl ToTokens for Atom {\n+    fn to_tokens(&self, tokens: &mut TokenStream) {\n+        Ident::new(self.as_ref(), Span::call_site()).to_tokens(tokens);\n+    }\n+}\n+\n impl ToTokens for ExternType {\n     fn to_tokens(&self, tokens: &mut TokenStream) {\n         // Notional token range for error reporting purposes.\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -44,7 +44,7 @@ pub mod ffi {\n         fn c_return_ref_rust_vec(c: &C) -> &Vec<u8>;\n         fn c_return_identity(_: usize) -> usize;\n         fn c_return_sum(_: usize, _: usize) -> usize;\n-        fn c_return_enum(n: u32) -> Enum;\n+        fn c_return_enum(n: u16) -> Enum;\n \n         fn c_take_primitive(n: usize);\n         fn c_take_shared(shared: Shared);\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -89,6 +89,7 @@ pub mod ffi {\n         type COwnedEnum;\n     }\n \n+    #[repr(u32)]\n     enum COwnedEnum {\n         CVal1,\n         CVal2,\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -107,10 +107,10 @@ size_t c_return_identity(size_t n) { return n; }\n \n size_t c_return_sum(size_t n1, size_t n2) { return n1 + n2; }\n \n-Enum c_return_enum(uint32_t n) {\n-  if (n <= static_cast<uint32_t>(Enum::AVal)) {\n+Enum c_return_enum(uint16_t n) {\n+  if (n <= static_cast<uint16_t>(Enum::AVal)) {\n     return Enum::AVal;\n-  } else if (n <= static_cast<uint32_t>(Enum::BVal)) {\n+  } else if (n <= static_cast<uint16_t>(Enum::BVal)) {\n     return Enum::BVal;\n   } else {\n     return Enum::CVal;\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -7,7 +7,7 @@ namespace tests {\n \n struct R;\n struct Shared;\n-enum class Enum : uint32_t;\n+enum class Enum : uint16_t;\n \n class C {\n public:\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -46,7 +46,7 @@ rust::Vec<uint8_t> c_return_rust_vec();\n const rust::Vec<uint8_t> &c_return_ref_rust_vec(const C &c);\n size_t c_return_identity(size_t n);\n size_t c_return_sum(size_t n1, size_t n2);\n-Enum c_return_enum(uint32_t n);\n+Enum c_return_enum(uint16_t n);\n \n void c_take_primitive(size_t n);\n void c_take_shared(Shared shared);\ndiff --git /dev/null b/tests/ui/enum_inconsistent.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/enum_inconsistent.rs\n@@ -0,0 +1,9 @@\n+#[cxx::bridge]\n+mod ffi {\n+    enum Bad {\n+        A = 1u16,\n+        B = 2i64,\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/enum_inconsistent.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/enum_inconsistent.stderr\n@@ -0,0 +1,5 @@\n+error: expected u16, found i64\n+ --> $DIR/enum_inconsistent.rs:5:9\n+  |\n+5 |         B = 2i64,\n+  |         ^^^^^^^^\ndiff --git a/tests/ui/enum_match_without_wildcard.stderr b/tests/ui/enum_match_without_wildcard.stderr\n--- a/tests/ui/enum_match_without_wildcard.stderr\n+++ b/tests/ui/enum_match_without_wildcard.stderr\n@@ -1,11 +1,11 @@\n-error[E0004]: non-exhaustive patterns: `A { repr: 2u32..=std::u32::MAX }` not covered\n+error[E0004]: non-exhaustive patterns: `A { repr: 2u8..=std::u8::MAX }` not covered\n   --> $DIR/enum_match_without_wildcard.rs:12:11\n    |\n 1  | #[cxx::bridge]\n    | -------------- `ffi::A` defined here\n ...\n 12 |     match a {\n-   |           ^ pattern `A { repr: 2u32..=std::u32::MAX }` not covered\n+   |           ^ pattern `A { repr: 2u8..=std::u8::MAX }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `ffi::A`\ndiff --git /dev/null b/tests/ui/enum_out_of_bounds.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/enum_out_of_bounds.rs\n@@ -0,0 +1,9 @@\n+#[cxx::bridge]\n+mod ffi {\n+    #[repr(u32)]\n+    enum Bad {\n+        A = 0xFFFF_FFFF_FFFF_FFFF,\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/enum_out_of_bounds.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/enum_out_of_bounds.stderr\n@@ -0,0 +1,5 @@\n+error: discriminant value `18446744073709551615` is outside the limits of u32\n+ --> $DIR/enum_out_of_bounds.rs:5:9\n+  |\n+5 |         A = 0xFFFF_FFFF_FFFF_FFFF,\n+  |         ^^^^^^^^^^^^^^^^^^^^^^^^^\ndiff --git a/tests/ui/enum_overflows.rs b/tests/ui/enum_overflows.rs\n--- a/tests/ui/enum_overflows.rs\n+++ b/tests/ui/enum_overflows.rs\n@@ -1,14 +1,14 @@\n #[cxx::bridge]\n mod ffi {\n     enum Good1 {\n-        A = 0xffffffff,\n+        A = 0xFFFF_FFFF_FFFF_FFFF,\n     }\n     enum Good2 {\n-        B = 0xffffffff,\n+        B = 0xFFFF_FFFF_FFFF_FFFF,\n         C = 2020,\n     }\n     enum Bad {\n-        D = 0xfffffffe,\n+        D = 0xFFFF_FFFF_FFFF_FFFE,\n         E,\n         F,\n     }\ndiff --git a/tests/ui/enum_overflows.stderr b/tests/ui/enum_overflows.stderr\n--- a/tests/ui/enum_overflows.stderr\n+++ b/tests/ui/enum_overflows.stderr\n@@ -1,4 +1,4 @@\n-error: discriminant overflow on value after 4294967295\n+error: discriminant overflow on value after 18446744073709551615\n   --> $DIR/enum_overflows.rs:13:9\n    |\n 13 |         F,\ndiff --git /dev/null b/tests/ui/enum_unsatisfiable.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/enum_unsatisfiable.rs\n@@ -0,0 +1,9 @@\n+#[cxx::bridge]\n+mod ffi {\n+    enum Bad {\n+        A = -0xFFFF_FFFF_FFFF_FFFF,\n+        B = 0xFFFF_FFFF_FFFF_FFFF,\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/enum_unsatisfiable.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/enum_unsatisfiable.stderr\n@@ -0,0 +1,8 @@\n+error: these discriminant values do not fit in any supported enum repr type\n+ --> $DIR/enum_unsatisfiable.rs:3:5\n+  |\n+3 | /     enum Bad {\n+4 | |         A = -0xFFFF_FFFF_FFFF_FFFF,\n+5 | |         B = 0xFFFF_FFFF_FFFF_FFFF,\n+6 | |     }\n+  | |_____^\n",
        "problem_statement": "Represent enums using the smallest sufficient integer type\nThe C-style enum support added in #170 unconditionally uses `u32` / `uint32_t` as the representation. However, this means a negative discriminant like `-1` or a large discriminant like `0xfffffffff` won't compile. Additionally, an explicitly typed discriminant literal like `0u8` just ignores the type.\r\n\r\nIt would be nice to infer the intended discriminant type from the values. For example:\r\n\r\n- If the discriminants are `0`, `1`, `2` -> `u8`\r\n- If they are `-1`, `0`, `1` -> `i8`\r\n- If they are `0u16`, `1`, `2` -> `u16`\n",
        "hints_text": "I would add to this that we should be able to specify the integer type so that we can match an existing C++ enum.\nSpecifying the integer type is shown in my third bullet, where the discriminant is written as `0u16` so the representation is decided as `u16`.\r\n\r\nInterop with an existing C++ enum is tracked separately by #177.\nI was thinking more along the lines of allowing users to annotate the enum with \"#[repr(u8)]\" or whatever and use that when available.  This seems to me to be an easier way to force the type to be something specific than forcing users to set discriminant values.\r\n\r\nThis does overlap with #177, but I'm mentioning it here because I feel like it should override what you're suggesting here.\n:+1: I am on board with recognizing #\\[repr(u8)\\].",
        "created_at": "2020-05-11T07:01:23Z",
        "version": "0.3"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 194,
        "instance_id": "dtolnay__cxx-194",
        "issue_numbers": [
            "44"
        ],
        "base_commit": "32439dae389e4439c7e8e1d4bd650765c23854e0",
        "patch": "diff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -228,7 +228,7 @@ cxx-build = \"0.3\"\n fn main() {\n     cxx_build::bridge(\"src/main.rs\")  // returns a cc::Build\n         .file(\"../demo-cxx/demo.cc\")\n-        .flag(\"-std=c++11\")\n+        .flag_if_supported(\"-std=c++11\")\n         .compile(\"cxxbridge-demo\");\n \n     println!(\"cargo:rerun-if-changed=src/main.rs\");\ndiff --git a/build.rs b/build.rs\n--- a/build.rs\n+++ b/build.rs\n@@ -3,7 +3,7 @@ fn main() {\n         .file(\"src/cxx.cc\")\n         .cpp(true)\n         .cpp_link_stdlib(None) // linked via link-cplusplus crate\n-        .flag(\"-std=c++11\")\n+        .flag_if_supported(\"-std=c++11\")\n         .compile(\"cxxbridge03\");\n     println!(\"cargo:rerun-if-changed=src/cxx.cc\");\n     println!(\"cargo:rerun-if-changed=include/cxx.h\");\ndiff --git a/demo-rs/build.rs b/demo-rs/build.rs\n--- a/demo-rs/build.rs\n+++ b/demo-rs/build.rs\n@@ -1,7 +1,7 @@\n fn main() {\n     cxx_build::bridge(\"src/main.rs\")\n         .file(\"../demo-cxx/demo.cc\")\n-        .flag(\"-std=c++11\")\n+        .flag_if_supported(\"-std=c++11\")\n         .compile(\"cxxbridge-demo\");\n \n     println!(\"cargo:rerun-if-changed=src/main.rs\");\ndiff --git a/gen/build/src/lib.rs b/gen/build/src/lib.rs\n--- a/gen/build/src/lib.rs\n+++ b/gen/build/src/lib.rs\n@@ -16,7 +16,7 @@\n //! fn main() {\n //!     cxx_build::bridge(\"src/main.rs\")\n //!         .file(\"../demo-cxx/demo.cc\")\n-//!         .flag(\"-std=c++11\")\n+//!         .flag_if_supported(\"-std=c++11\")\n //!         .compile(\"cxxbridge-demo\");\n //!\n //!     println!(\"cargo:rerun-if-changed=src/main.rs\");\ndiff --git a/gen/build/src/lib.rs b/gen/build/src/lib.rs\n--- a/gen/build/src/lib.rs\n+++ b/gen/build/src/lib.rs\n@@ -83,7 +83,7 @@ pub fn bridge(rust_source_file: impl AsRef<Path>) -> cc::Build {\n /// let source_files = vec![\"src/main.rs\", \"src/path/to/other.rs\"];\n /// cxx_build::bridges(source_files)\n ///     .file(\"../demo-cxx/demo.cc\")\n-///     .flag(\"-std=c++11\")\n+///     .flag_if_supported(\"-std=c++11\")\n ///     .compile(\"cxxbridge-demo\");\n /// ```\n pub fn bridges(rust_source_files: impl IntoIterator<Item = impl AsRef<Path>>) -> cc::Build {\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -233,7 +233,7 @@\n //! fn main() {\n //!     cxx_build::bridge(\"src/main.rs\")  // returns a cc::Build\n //!         .file(\"../demo-cxx/demo.cc\")\n-//!         .flag(\"-std=c++11\")\n+//!         .flag_if_supported(\"-std=c++11\")\n //!         .compile(\"cxxbridge-demo\");\n //!\n //!     println!(\"cargo:rerun-if-changed=src/main.rs\");\n",
        "test_patch": "diff --git a/tests/ffi/build.rs b/tests/ffi/build.rs\n--- a/tests/ffi/build.rs\n+++ b/tests/ffi/build.rs\n@@ -6,6 +6,6 @@ fn main() {\n     let sources = vec![\"lib.rs\", \"module.rs\"];\n     cxx_build::bridges(sources)\n         .file(\"tests.cc\")\n-        .flag(\"-std=c++11\")\n+        .flag_if_supported(\"-std=c++11\")\n         .compile(\"cxx-test-suite\");\n }\n",
        "problem_statement": "-std=c++11 is not required on MSVC\nBuilding on x86_64-pc-windows-msvc currently emits this warning:\r\n\r\n```console\r\nwarning: cl : Command line warning D9002 : ignoring unknown option '-std=c++11'\r\n```\r\n\r\nAccording to https://docs.microsoft.com/en-us/cpp/build/reference/std-specify-language-standard-version?view=vs-2019, C++11 is the default with flags `/std:c++14` and `/std:c++17` for the newer standards.\r\n\r\nWe should find a way to pass `-std=c++11` only when it's required, such as on x86_64-apple-darwin where C++98 is the default. https://opensource.apple.com/source/clang/clang-800.0.42.1/src/tools/clang/www/cxx_status.html\r\n\r\n```console\r\nrunning: \"cc\" \"-O0\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"-g\" \"-fno-omit-frame-pointer\" \"-m64\" \"-Wall\" \"-Wextra\" \"-o\" \"/Users/travis/build/dtolnay/cxx/target/debug/build/cxx-f198c1b742072022/out/src/cxxbridge.o\" \"-c\" \"src/cxxbridge.cc\"\r\n\r\nIn file included from src/cxxbridge.cc:1:\r\nsrc/../include/cxxbridge.h:9:18: warning: 'final' keyword is a C++11 extension [-Wc++11-extensions]\r\nclass RustString final {\r\n                 ^\r\n```\n",
        "hints_text": "",
        "created_at": "2020-05-09T09:44:36Z",
        "version": "0.3"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 190,
        "instance_id": "dtolnay__cxx-190",
        "issue_numbers": [
            "99"
        ],
        "base_commit": "6e80833572b3bf6e7b47cb54ebbd5d79cc97d4f1",
        "patch": "diff --git a/gen/build/Cargo.toml b/gen/build/Cargo.toml\n--- a/gen/build/Cargo.toml\n+++ b/gen/build/Cargo.toml\n@@ -13,7 +13,7 @@ cc = \"1.0.49\"\n codespan-reporting = \"0.9\"\n proc-macro2 = { version = \"1.0.12\", features = [\"span-locations\"] }\n quote = \"1.0\"\n-syn = { version = \"1.0\", features = [\"full\"] }\n+syn = { version = \"1.0.19\", features = [\"full\"] }\n \n [package.metadata.docs.rs]\n targets = [\"x86_64-unknown-linux-gnu\"]\ndiff --git a/gen/cmd/Cargo.toml b/gen/cmd/Cargo.toml\n--- a/gen/cmd/Cargo.toml\n+++ b/gen/cmd/Cargo.toml\n@@ -17,7 +17,7 @@ codespan-reporting = \"0.9\"\n proc-macro2 = { version = \"1.0.12\", features = [\"span-locations\"] }\n quote = \"1.0\"\n structopt = \"0.3\"\n-syn = { version = \"1.0\", features = [\"full\"] }\n+syn = { version = \"1.0.19\", features = [\"full\"] }\n \n [package.metadata.docs.rs]\n targets = [\"x86_64-unknown-linux-gnu\"]\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -971,10 +971,6 @@ fn to_mangled(namespace: &Namespace, ty: &Type) -> String {\n }\n \n fn write_generic_instantiations(out: &mut OutFile, types: &Types) {\n-    fn allow_unique_ptr(ident: &Ident) -> bool {\n-        Atom::from(ident).is_none()\n-    }\n-\n     out.begin_block(\"extern \\\"C\\\"\");\n     for ty in types {\n         if let Type::RustBox(ty) = ty {\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -991,14 +987,14 @@ fn write_generic_instantiations(out: &mut OutFile, types: &Types) {\n             }\n         } else if let Type::UniquePtr(ptr) = ty {\n             if let Type::Ident(inner) = &ptr.inner {\n-                if allow_unique_ptr(inner) {\n+                if Atom::from(inner).is_none() && !types.aliases.contains_key(inner) {\n                     out.next_section();\n                     write_unique_ptr(out, inner, types);\n                 }\n             }\n         } else if let Type::CxxVector(ptr) = ty {\n             if let Type::Ident(inner) = &ptr.inner {\n-                if Atom::from(inner).is_none() {\n+                if Atom::from(inner).is_none() && !types.aliases.contains_key(inner) {\n                     out.next_section();\n                     write_cxx_vector(out, ty, inner, types);\n                 }\ndiff --git a/macro/Cargo.toml b/macro/Cargo.toml\n--- a/macro/Cargo.toml\n+++ b/macro/Cargo.toml\n@@ -13,8 +13,8 @@ proc-macro = true\n \n [dependencies]\n proc-macro2 = \"1.0\"\n-quote = \"1.0\"\n-syn = { version = \"1.0\", features = [\"full\"] }\n+quote = \"1.0.4\"\n+syn = { version = \"1.0.19\", features = [\"full\"] }\n \n [dev-dependencies]\n cxx = { version = \"0.3\", path = \"..\" }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -3,7 +3,7 @@ use crate::syntax::namespace::Namespace;\n use crate::syntax::report::Errors;\n use crate::syntax::symbol::Symbol;\n use crate::syntax::{\n-    self, check, mangle, Api, Enum, ExternFn, ExternType, Signature, Struct, Type, Types,\n+    self, check, mangle, Api, Enum, ExternFn, ExternType, Signature, Struct, Type, TypeAlias, Types,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote, quote_spanned, ToTokens};\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -46,7 +46,7 @@ fn expand(namespace: &Namespace, ffi: ItemMod, apis: &[Api], types: &Types) -> T\n             Api::Enum(enm) => expanded.extend(expand_enum(enm)),\n             Api::CxxType(ety) => {\n                 if !types.enums.contains_key(&ety.ident) {\n-                    expanded.extend(expand_cxx_type(ety));\n+                    expanded.extend(expand_cxx_type(namespace, ety));\n                 }\n             }\n             Api::CxxFunction(efn) => {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -55,6 +55,10 @@ fn expand(namespace: &Namespace, ffi: ItemMod, apis: &[Api], types: &Types) -> T\n             Api::RustFunction(efn) => {\n                 hidden.extend(expand_rust_function_shim(namespace, efn, types))\n             }\n+            Api::TypeAlias(alias) => {\n+                expanded.extend(expand_type_alias(alias));\n+                hidden.extend(expand_type_alias_verify(namespace, alias));\n+            }\n         }\n     }\n \ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -73,13 +77,13 @@ fn expand(namespace: &Namespace, ffi: ItemMod, apis: &[Api], types: &Types) -> T\n             }\n         } else if let Type::UniquePtr(ptr) = ty {\n             if let Type::Ident(ident) = &ptr.inner {\n-                if Atom::from(ident).is_none() {\n+                if Atom::from(ident).is_none() && !types.aliases.contains_key(ident) {\n                     expanded.extend(expand_unique_ptr(namespace, ident, types));\n                 }\n             }\n         } else if let Type::CxxVector(ptr) = ty {\n             if let Type::Ident(ident) = &ptr.inner {\n-                if Atom::from(ident).is_none() {\n+                if Atom::from(ident).is_none() && !types.aliases.contains_key(ident) {\n                     // Generate impl for CxxVector<T> if T is a struct or opaque\n                     // C++ type. Impl for primitives is already provided by cxx\n                     // crate.\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -161,15 +165,21 @@ fn expand_enum(enm: &Enum) -> TokenStream {\n     }\n }\n \n-fn expand_cxx_type(ety: &ExternType) -> TokenStream {\n+fn expand_cxx_type(namespace: &Namespace, ety: &ExternType) -> TokenStream {\n     let ident = &ety.ident;\n     let doc = &ety.doc;\n+    let type_id = type_id(namespace, ident);\n+\n     quote! {\n         #doc\n         #[repr(C)]\n         pub struct #ident {\n             _private: ::cxx::private::Opaque,\n         }\n+\n+        unsafe impl ::cxx::ExternType for #ident {\n+            type Id = #type_id;\n+        }\n     }\n }\n \ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -554,6 +564,40 @@ fn expand_rust_function_shim_impl(\n     }\n }\n \n+fn expand_type_alias(alias: &TypeAlias) -> TokenStream {\n+    let ident = &alias.ident;\n+    let ty = &alias.ty;\n+    quote! {\n+        pub type #ident = #ty;\n+    }\n+}\n+\n+fn expand_type_alias_verify(namespace: &Namespace, alias: &TypeAlias) -> TokenStream {\n+    let ident = &alias.ident;\n+    let type_id = type_id(namespace, ident);\n+    let begin_span = alias.type_token.span;\n+    let end_span = alias.semi_token.span;\n+    let begin = quote_spanned!(begin_span=> ::cxx::private::verify_extern_type::<);\n+    let end = quote_spanned!(end_span=> >);\n+\n+    quote! {\n+        const _: fn() = #begin #ident, #type_id #end;\n+    }\n+}\n+\n+fn type_id(namespace: &Namespace, ident: &Ident) -> TokenStream {\n+    let mut path = String::new();\n+    for name in namespace {\n+        path += &name.to_string();\n+        path += \"::\";\n+    }\n+    path += &ident.to_string();\n+\n+    quote! {\n+        ::cxx::type_id!(#path)\n+    }\n+}\n+\n fn expand_rust_box(namespace: &Namespace, ident: &Ident) -> TokenStream {\n     let link_prefix = format!(\"cxxbridge03$box${}{}$\", namespace, ident);\n     let link_uninit = format!(\"{}uninit\", link_prefix);\ndiff --git a/macro/src/lib.rs b/macro/src/lib.rs\n--- a/macro/src/lib.rs\n+++ b/macro/src/lib.rs\n@@ -11,10 +11,11 @@ extern crate proc_macro;\n \n mod expand;\n mod syntax;\n+mod type_id;\n \n use crate::syntax::namespace::Namespace;\n use proc_macro::TokenStream;\n-use syn::{parse_macro_input, ItemMod};\n+use syn::{parse_macro_input, ItemMod, LitStr};\n \n /// `#[cxx::bridge] mod ffi { ... }`\n ///\ndiff --git a/macro/src/lib.rs b/macro/src/lib.rs\n--- a/macro/src/lib.rs\n+++ b/macro/src/lib.rs\n@@ -44,3 +45,9 @@ pub fn bridge(args: TokenStream, input: TokenStream) -> TokenStream {\n         .unwrap_or_else(|err| err.to_compile_error())\n         .into()\n }\n+\n+#[proc_macro]\n+pub fn type_id(input: TokenStream) -> TokenStream {\n+    let arg = parse_macro_input!(input as LitStr);\n+    type_id::expand(arg).into()\n+}\ndiff --git /dev/null b/macro/src/type_id.rs\nnew file mode 100644\n--- /dev/null\n+++ b/macro/src/type_id.rs\n@@ -0,0 +1,29 @@\n+use proc_macro2::TokenStream;\n+use quote::{format_ident, quote};\n+use syn::LitStr;\n+\n+// \"folly::File\" => `(f, o, l, l, y, (), F, i, l, e)`\n+pub fn expand(arg: LitStr) -> TokenStream {\n+    let mut ids = Vec::new();\n+\n+    for word in arg.value().split(\"::\") {\n+        if !ids.is_empty() {\n+            ids.push(quote!(()));\n+        }\n+        for ch in word.chars() {\n+            ids.push(match ch {\n+                'A'..='Z' | 'a'..='z' => {\n+                    let t = format_ident!(\"{}\", ch);\n+                    quote!(::cxx::#t)\n+                }\n+                '0'..='9' | '_' => {\n+                    let t = format_ident!(\"_{}\", ch);\n+                    quote!(::cxx::#t)\n+                }\n+                _ => quote!([(); #ch as _]),\n+            });\n+        }\n+    }\n+\n+    quote! { (#(#ids,)*) }\n+}\ndiff --git /dev/null b/src/extern_type.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/extern_type.rs\n@@ -0,0 +1,110 @@\n+/// A type for which the layout is determined by its C++ definition.\n+///\n+/// This trait serves the following two related purposes.\n+///\n+/// <br>\n+///\n+/// ## Safely unifying occurrences of the same extern type\n+///\n+/// `ExternType` makes it possible for CXX to safely share a consistent Rust\n+/// type across multiple #\\[cxx::bridge\\] invocations that refer to a common\n+/// extern C++ type.\n+///\n+/// In the following snippet, two #\\[cxx::bridge\\] invocations in different\n+/// files (possibly different crates) both contain function signatures involving\n+/// the same C++ type `example::Demo`. If both were written just containing\n+/// `type Demo;`, then both macro expansions would produce their own separate\n+/// Rust type called `Demo` and thus the compiler wouldn't allow us to take the\n+/// `Demo` returned by `file1::ffi::create_demo` and pass it as the `Demo`\n+/// argument accepted by `file2::ffi::take_ref_demo`. Instead, one of the two\n+/// `Demo`s has been defined as an extern type alias of the other, making them\n+/// the same type in Rust. The CXX code generator will use an automatically\n+/// generated `ExternType` impl emitted in file1 to statically verify that in\n+/// file2 `crate::file1::ffi::Demo` really does refer to the C++ type\n+/// `example::Demo` as expected in file2.\n+///\n+/// ```no_run\n+/// // file1.rs\n+/// # mod file1 {\n+/// #[cxx::bridge(namespace = example)]\n+/// pub mod ffi {\n+///     extern \"C\" {\n+///         type Demo;\n+///\n+///         fn create_demo() -> UniquePtr<Demo>;\n+///     }\n+/// }\n+/// # }\n+///\n+/// // file2.rs\n+/// #[cxx::bridge(namespace = example)]\n+/// pub mod ffi {\n+///     extern \"C\" {\n+///         type Demo = crate::file1::ffi::Demo;\n+///\n+///         fn take_ref_demo(demo: &Demo);\n+///     }\n+/// }\n+/// #\n+/// # fn main() {}\n+/// ```\n+///\n+/// <br><br>\n+///\n+/// ## Integrating with bindgen-generated types\n+///\n+/// Handwritten `ExternType` impls make it possible to plug in a data structure\n+/// emitted by bindgen as the definition of an opaque C++ type emitted by CXX.\n+///\n+/// By writing the unsafe `ExternType` impl, the programmer asserts that the C++\n+/// namespace and type name given in the type id refers to a C++ type that is\n+/// equivalent to Rust type that is the `Self` type of the impl.\n+///\n+/// ```no_run\n+/// # const _: &str = stringify! {\n+/// mod folly_sys;  // the bindgen-generated bindings\n+/// # };\n+/// # mod folly_sys {\n+/// #     #[repr(transparent)]\n+/// #     pub struct StringPiece([usize; 2]);\n+/// # }\n+///\n+/// use cxx::{type_id, ExternType};\n+///\n+/// unsafe impl ExternType for folly_sys::StringPiece {\n+///     type Id = type_id!(\"folly::StringPiece\");\n+/// }\n+///\n+/// #[cxx::bridge(namespace = folly)]\n+/// pub mod ffi {\n+///     extern \"C\" {\n+///         include!(\"rust_cxx_bindings.h\");\n+///\n+///         type StringPiece = crate::folly_sys::StringPiece;\n+///\n+///         fn print_string_piece(s: &StringPiece);\n+///     }\n+/// }\n+///\n+/// // Now if we construct a StringPiece or obtain one through one\n+/// // of the bindgen-generated signatures, we are able to pass it\n+/// // along to ffi::print_string_piece.\n+/// #\n+/// # fn main() {}\n+/// ```\n+pub unsafe trait ExternType {\n+    /// A type-level representation of the type's C++ namespace and type name.\n+    ///\n+    /// This will always be defined using `type_id!` in the following form:\n+    ///\n+    /// ```\n+    /// # struct TypeName;\n+    /// # unsafe impl cxx::ExternType for TypeName {\n+    /// type Id = cxx::type_id!(\"name::space::of::TypeName\");\n+    /// # }\n+    /// ```\n+    type Id;\n+}\n+\n+#[doc(hidden)]\n+pub fn verify_extern_type<T: ExternType<Id = Id>, Id>() {}\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -345,6 +345,7 @@\n \n #![doc(html_root_url = \"https://docs.rs/cxx/0.3.0\")]\n #![deny(improper_ctypes)]\n+#![allow(non_camel_case_types)]\n #![allow(\n     clippy::cognitive_complexity,\n     clippy::declare_interior_mutable_const,\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -369,6 +370,7 @@ mod macros;\n mod cxx_string;\n mod cxx_vector;\n mod exception;\n+mod extern_type;\n mod function;\n mod opaque;\n mod result;\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -385,13 +387,18 @@ mod symbols;\n pub use crate::cxx_string::CxxString;\n pub use crate::cxx_vector::CxxVector;\n pub use crate::exception::Exception;\n+pub use crate::extern_type::ExternType;\n pub use crate::unique_ptr::UniquePtr;\n-pub use cxxbridge_macro::bridge;\n+pub use cxxbridge_macro::{bridge};\n+\n+/// For use in impls of the `ExternType` trait. See [`ExternType`].\n+pub use cxxbridge_macro::type_id;\n \n // Not public API.\n #[doc(hidden)]\n pub mod private {\n     pub use crate::cxx_vector::VectorElement;\n+    pub use crate::extern_type::verify_extern_type;\n     pub use crate::function::FatFunction;\n     pub use crate::opaque::Opaque;\n     pub use crate::result::{r#try, Result};\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -402,3 +409,19 @@ pub mod private {\n     pub use crate::unique_ptr::UniquePtrTarget;\n     pub use crate::unwind::catch_unwind;\n }\n+\n+macro_rules! chars {\n+    ($($ch:ident)*) => {\n+        $(\n+            #[doc(hidden)]\n+            pub enum $ch {}\n+        )*\n+    };\n+}\n+\n+chars! {\n+    _0 _1 _2 _3 _4 _5 _6 _7 _8 _9\n+    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n+    a b c d e f g h i j k l m n o p q r s t u v w x y z\n+    __ // underscore\n+}\ndiff --git a/syntax/ident.rs b/syntax/ident.rs\n--- a/syntax/ident.rs\n+++ b/syntax/ident.rs\n@@ -42,6 +42,9 @@ pub(crate) fn check_all(cx: &mut Check, namespace: &Namespace, apis: &[Api]) {\n                     check(cx, &arg.ident);\n                 }\n             }\n+            Api::TypeAlias(alias) => {\n+                check(cx, &alias.ident);\n+            }\n         }\n     }\n }\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -20,7 +20,7 @@ use self::parse::kw;\n use proc_macro2::{Ident, Span};\n use syn::punctuated::Punctuated;\n use syn::token::{Brace, Bracket, Paren};\n-use syn::{Lifetime, LitStr, Token};\n+use syn::{Lifetime, LitStr, Token, Type as RustType};\n \n pub use self::atom::Atom;\n pub use self::doc::Doc;\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -35,6 +35,7 @@ pub enum Api {\n     CxxFunction(ExternFn),\n     RustType(ExternType),\n     RustFunction(ExternFn),\n+    TypeAlias(TypeAlias),\n }\n \n pub struct ExternType {\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -68,6 +69,14 @@ pub struct ExternFn {\n     pub semi_token: Token![;],\n }\n \n+pub struct TypeAlias {\n+    pub type_token: Token![type],\n+    pub ident: Ident,\n+    pub eq_token: Token![=],\n+    pub ty: RustType,\n+    pub semi_token: Token![;],\n+}\n+\n pub struct Signature {\n     pub fn_token: Token![fn],\n     pub receiver: Option<Receiver>,\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -2,17 +2,19 @@ use crate::syntax::report::Errors;\n use crate::syntax::Atom::*;\n use crate::syntax::{\n     attrs, error, Api, Doc, Enum, ExternFn, ExternType, Lang, Receiver, Ref, Signature, Slice,\n-    Struct, Ty1, Type, Var, Variant,\n+    Struct, Ty1, Type, TypeAlias, Var, Variant,\n };\n+use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n use std::collections::HashSet;\n use std::u32;\n+use syn::parse::{ParseStream, Parser};\n use syn::punctuated::Punctuated;\n use syn::{\n-    Abi, Error, Expr, ExprLit, Fields, FnArg, ForeignItem, ForeignItemFn, ForeignItemType,\n-    GenericArgument, Ident, Item, ItemEnum, ItemForeignMod, ItemStruct, Lit, Pat, PathArguments,\n-    Result, ReturnType, Token, Type as RustType, TypeBareFn, TypePath, TypeReference, TypeSlice,\n-    Variant as RustVariant,\n+    Abi, Attribute, Error, Expr, ExprLit, Fields, FnArg, ForeignItem, ForeignItemFn,\n+    ForeignItemType, GenericArgument, Ident, Item, ItemEnum, ItemForeignMod, ItemStruct, Lit, Pat,\n+    PathArguments, Result, ReturnType, Token, Type as RustType, TypeBareFn, TypePath,\n+    TypeReference, TypeSlice, Variant as RustVariant,\n };\n \n pub mod kw {\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -182,16 +184,21 @@ fn parse_foreign_mod(cx: &mut Errors, foreign_mod: ItemForeignMod, out: &mut Vec\n                     Err(err) => cx.push(err),\n                 }\n             }\n+            ForeignItem::Verbatim(tokens) => match parse_extern_verbatim(tokens, lang) {\n+                Ok(api) => items.push(api),\n+                Err(err) => cx.push(err),\n+            },\n             _ => cx.error(foreign, \"unsupported foreign item\"),\n         }\n     }\n \n     let mut types = items.iter().filter_map(|item| match item {\n-        Api::CxxType(ty) | Api::RustType(ty) => Some(ty),\n+        Api::CxxType(ty) | Api::RustType(ty) => Some(&ty.ident),\n+        Api::TypeAlias(alias) => Some(&alias.ident),\n         _ => None,\n     });\n     if let (Some(single_type), None) = (types.next(), types.next()) {\n-        let single_type = single_type.ident.clone();\n+        let single_type = single_type.clone();\n         for item in &mut items {\n             if let Api::CxxFunction(efn) | Api::RustFunction(efn) = item {\n                 if let Some(receiver) = &mut efn.receiver {\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -336,6 +343,44 @@ fn parse_extern_fn(foreign_fn: &ForeignItemFn, lang: Lang) -> Result<Api> {\n     }))\n }\n \n+fn parse_extern_verbatim(tokens: &TokenStream, lang: Lang) -> Result<Api> {\n+    // type Alias = crate::path::to::Type;\n+    fn parse(input: ParseStream) -> Result<TypeAlias> {\n+        let attrs = input.call(Attribute::parse_outer)?;\n+        let type_token: Token![type] = match input.parse()? {\n+            Some(type_token) => type_token,\n+            None => {\n+                let span = input.cursor().token_stream();\n+                return Err(Error::new_spanned(span, \"unsupported foreign item\"));\n+            }\n+        };\n+        let ident: Ident = input.parse()?;\n+        let eq_token: Token![=] = input.parse()?;\n+        let ty: RustType = input.parse()?;\n+        let semi_token: Token![;] = input.parse()?;\n+        attrs::parse_doc(&attrs)?;\n+\n+        Ok(TypeAlias {\n+            type_token,\n+            ident,\n+            eq_token,\n+            ty,\n+            semi_token,\n+        })\n+    }\n+\n+    let type_alias = parse.parse2(tokens.clone())?;\n+    match lang {\n+        Lang::Cxx => Ok(Api::TypeAlias(type_alias)),\n+        Lang::Rust => {\n+            let (type_token, semi_token) = (type_alias.type_token, type_alias.semi_token);\n+            let span = quote!(#type_token #semi_token);\n+            let msg = \"type alias in extern \\\"Rust\\\" block is not supported\";\n+            Err(Error::new_spanned(span, msg))\n+        }\n+    }\n+}\n+\n fn parse_type(ty: &RustType) -> Result<Type> {\n     match ty {\n         RustType::Reference(ty) => parse_type_reference(ty),\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -1,6 +1,7 @@\n use crate::syntax::atom::Atom::*;\n use crate::syntax::{\n-    Derive, Enum, ExternFn, ExternType, Receiver, Ref, Signature, Slice, Struct, Ty1, Type, Var,\n+    Derive, Enum, ExternFn, ExternType, Receiver, Ref, Signature, Slice, Struct, Ty1, Type,\n+    TypeAlias, Var,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{quote_spanned, ToTokens};\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -86,6 +87,14 @@ impl ToTokens for ExternType {\n     }\n }\n \n+impl ToTokens for TypeAlias {\n+    fn to_tokens(&self, tokens: &mut TokenStream) {\n+        // Notional token range for error reporting purposes.\n+        self.type_token.to_tokens(tokens);\n+        self.ident.to_tokens(tokens);\n+    }\n+}\n+\n impl ToTokens for Struct {\n     fn to_tokens(&self, tokens: &mut TokenStream) {\n         // Notional token range for error reporting purposes.\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -1,7 +1,7 @@\n use crate::syntax::atom::Atom::{self, *};\n use crate::syntax::report::Errors;\n use crate::syntax::set::OrderedSet as Set;\n-use crate::syntax::{Api, Derive, Enum, Struct, Type};\n+use crate::syntax::{Api, Derive, Enum, Struct, Type, TypeAlias};\n use proc_macro2::Ident;\n use quote::ToTokens;\n use std::collections::{BTreeMap as Map, HashSet as UnorderedSet};\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -12,6 +12,7 @@ pub struct Types<'a> {\n     pub enums: Map<Ident, &'a Enum>,\n     pub cxx: Set<'a, Ident>,\n     pub rust: Set<'a, Ident>,\n+    pub aliases: Map<Ident, &'a TypeAlias>,\n }\n \n impl<'a> Types<'a> {\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -21,6 +22,7 @@ impl<'a> Types<'a> {\n         let mut enums = Map::new();\n         let mut cxx = Set::new();\n         let mut rust = Set::new();\n+        let mut aliases = Map::new();\n \n         fn visit<'a>(all: &mut Set<'a, Type>, ty: &'a Type) {\n             all.insert(ty);\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -96,6 +98,14 @@ impl<'a> Types<'a> {\n                         visit(&mut all, ret);\n                     }\n                 }\n+                Api::TypeAlias(alias) => {\n+                    let ident = &alias.ident;\n+                    if !type_names.insert(ident) {\n+                        duplicate_name(cx, alias, ident);\n+                    }\n+                    cxx.insert(ident);\n+                    aliases.insert(ident.clone(), alias);\n+                }\n             }\n         }\n \ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -105,6 +115,7 @@ impl<'a> Types<'a> {\n             enums,\n             cxx,\n             rust,\n+            aliases,\n         }\n     }\n \ndiff --git a/third-party/BUCK b/third-party/BUCK\n--- a/third-party/BUCK\n+++ b/third-party/BUCK\n@@ -131,7 +131,7 @@ rust_library(\n \n rust_library(\n     name = \"syn\",\n-    srcs = glob([\"vendor/syn-1.0.18/src/**\"]),\n+    srcs = glob([\"vendor/syn-1.0.19/src/**\"]),\n     visibility = [\"PUBLIC\"],\n     features = [\n         \"clone-impls\",\ndiff --git a/third-party/BUILD b/third-party/BUILD\n--- a/third-party/BUILD\n+++ b/third-party/BUILD\n@@ -136,7 +136,7 @@ rust_library(\n \n rust_library(\n     name = \"syn\",\n-    srcs = glob([\"vendor/syn-1.0.18/src/**\"]),\n+    srcs = glob([\"vendor/syn-1.0.19/src/**\"]),\n     crate_features = [\n         \"clone-impls\",\n         \"derive\",\ndiff --git a/third-party/Cargo.lock b/third-party/Cargo.lock\n--- a/third-party/Cargo.lock\n+++ b/third-party/Cargo.lock\n@@ -307,9 +307,9 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.18\"\n+version = \"1.0.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"410a7488c0a728c7ceb4ad59b9567eb4053d02e8cc7f5c0e0eeeb39518369213\"\n+checksum = \"e8e5aa70697bb26ee62214ae3288465ecec0000f05182f039b477001f08f5ae7\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\ndiff --git a/third-party/Cargo.lock b/third-party/Cargo.lock\n--- a/third-party/Cargo.lock\n+++ b/third-party/Cargo.lock\n@@ -356,9 +356,9 @@ dependencies = [\n \n [[package]]\n name = \"trybuild\"\n-version = \"1.0.26\"\n+version = \"1.0.27\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4e5696e4fd793743fbcc29943fe965ea3993b6c3d2a6a3a35c6680d926fd3a49\"\n+checksum = \"744665442556a91933cee5e75b0371376eb03498c4d0bfbcebd2a9882b4fb5ef\"\n dependencies = [\n  \"dissimilar\",\n  \"glob\",\n",
        "test_patch": "diff --git a/Cargo.toml b/Cargo.toml\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -22,7 +22,7 @@ cc = \"1.0.49\"\n cxx-build = { version = \"=0.3.0\", path = \"gen/build\" }\n cxx-test-suite = { version = \"0\", path = \"tests/ffi\" }\n rustversion = \"1.0\"\n-trybuild = { version = \"1.0.21\", features = [\"diff\"] }\n+trybuild = { version = \"1.0.27\", features = [\"diff\"] }\n \n [workspace]\n members = [\"demo-rs\", \"gen/build\", \"gen/cmd\", \"macro\", \"tests/ffi\"]\ndiff --git a/tests/BUCK b/tests/BUCK\n--- a/tests/BUCK\n+++ b/tests/BUCK\n@@ -6,7 +6,10 @@ rust_test(\n \n rust_library(\n     name = \"ffi\",\n-    srcs = [\"ffi/lib.rs\"],\n+    srcs = [\n+        \"ffi/lib.rs\",\n+        \"ffi/module.rs\",\n+    ],\n     crate = \"cxx_test_suite\",\n     deps = [\n         \":impl\",\ndiff --git a/tests/BUCK b/tests/BUCK\n--- a/tests/BUCK\n+++ b/tests/BUCK\n@@ -18,25 +21,33 @@ cxx_library(\n     name = \"impl\",\n     srcs = [\n         \"ffi/tests.cc\",\n-        \":gen-source\",\n+        \":gen-lib-source\",\n+        \":gen-module-source\",\n     ],\n     headers = {\n-        \"ffi/lib.rs.h\": \":gen-header\",\n+        \"ffi/lib.rs.h\": \":gen-lib-header\",\n         \"ffi/tests.h\": \"ffi/tests.h\",\n     },\n     deps = [\"//:core\"],\n )\n \n genrule(\n-    name = \"gen-header\",\n+    name = \"gen-lib-header\",\n     srcs = [\"ffi/lib.rs\"],\n     cmd = \"$(exe //:codegen) --header ${SRCS} > ${OUT}\",\n-    out = \"generated.h\",\n+    out = \"lib.rs.h\",\n )\n \n genrule(\n-    name = \"gen-source\",\n+    name = \"gen-lib-source\",\n     srcs = [\"ffi/lib.rs\"],\n     cmd = \"$(exe //:codegen) ${SRCS} > ${OUT}\",\n-    out = \"generated.cc\",\n+    out = \"lib.rs.cc\",\n+)\n+\n+genrule(\n+    name = \"gen-module-source\",\n+    srcs = [\"ffi/module.rs\"],\n+    cmd = \"$(exe //:codegen) ${SRCS} > ${OUT}\",\n+    out = \"module.rs.cc\",\n )\ndiff --git a/tests/BUILD b/tests/BUILD\n--- a/tests/BUILD\n+++ b/tests/BUILD\n@@ -8,7 +8,10 @@ rust_test(\n \n rust_library(\n     name = \"cxx_test_suite\",\n-    srcs = [\"ffi/lib.rs\"],\n+    srcs = [\n+        \"ffi/lib.rs\",\n+        \"ffi/module.rs\",\n+    ],\n     deps = [\n         \":impl\",\n         \"//:cxx\",\ndiff --git a/tests/BUILD b/tests/BUILD\n--- a/tests/BUILD\n+++ b/tests/BUILD\n@@ -19,17 +22,18 @@ cc_library(\n     name = \"impl\",\n     srcs = [\n         \"ffi/tests.cc\",\n-        \":gen-source\",\n+        \":gen-lib-source\",\n+        \":gen-module-source\",\n     ],\n     hdrs = [\"ffi/tests.h\"],\n     deps = [\n-        \":include\",\n+        \":lib-include\",\n         \"//:core\",\n     ],\n )\n \n genrule(\n-    name = \"gen-header\",\n+    name = \"gen-lib-header\",\n     srcs = [\"ffi/lib.rs\"],\n     outs = [\"lib.rs.h\"],\n     cmd = \"$(location //:codegen) --header $< > $@\",\ndiff --git a/tests/BUILD b/tests/BUILD\n--- a/tests/BUILD\n+++ b/tests/BUILD\n@@ -37,15 +41,23 @@ genrule(\n )\n \n genrule(\n-    name = \"gen-source\",\n+    name = \"gen-lib-source\",\n     srcs = [\"ffi/lib.rs\"],\n-    outs = [\"generated.cc\"],\n+    outs = [\"lib.rs.cc\"],\n     cmd = \"$(location //:codegen) $< > $@\",\n     tools = [\"//:codegen\"],\n )\n \n cc_library(\n-    name = \"include\",\n-    hdrs = [\":gen-header\"],\n+    name = \"lib-include\",\n+    hdrs = [\":gen-lib-header\"],\n     include_prefix = \"tests/ffi\",\n )\n+\n+genrule(\n+    name = \"gen-module-source\",\n+    srcs = [\"ffi/module.rs\"],\n+    outs = [\"module.rs.cc\"],\n+    cmd = \"$(location //:codegen) $< > $@\",\n+    tools = [\"//:codegen\"],\n+)\ndiff --git a/tests/ffi/build.rs b/tests/ffi/build.rs\n--- a/tests/ffi/build.rs\n+++ b/tests/ffi/build.rs\n@@ -3,7 +3,8 @@ fn main() {\n         return;\n     }\n \n-    cxx_build::bridge(\"lib.rs\")\n+    let sources = vec![\"lib.rs\", \"module.rs\"];\n+    cxx_build::bridges(sources)\n         .file(\"tests.cc\")\n         .flag(\"-std=c++11\")\n         .compile(\"cxx-test-suite\");\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -4,6 +4,8 @@\n     clippy::trivially_copy_pass_by_ref\n )]\n \n+pub mod module;\n+\n use cxx::{CxxString, UniquePtr};\n use std::fmt::{self, Display};\n \ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -47,7 +49,6 @@ pub mod ffi {\n         fn c_take_primitive(n: usize);\n         fn c_take_shared(shared: Shared);\n         fn c_take_box(r: Box<R>);\n-        fn c_take_unique_ptr(c: UniquePtr<C>);\n         fn c_take_ref_r(r: &R);\n         fn c_take_ref_c(c: &C);\n         fn c_take_str(s: &str);\ndiff --git /dev/null b/tests/ffi/module.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ffi/module.rs\n@@ -0,0 +1,13 @@\n+// Rustfmt mangles the extern type alias.\n+// https://github.com/rust-lang/rustfmt/issues/4159\n+#[rustfmt::skip]\n+#[cxx::bridge(namespace = tests)]\n+pub mod ffi {\n+    extern \"C\" {\n+        include!(\"tests/ffi/tests.h\");\n+\n+        type C = crate::ffi::C;\n+\n+        fn c_take_unique_ptr(c: UniquePtr<C>);\n+    }\n+}\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -89,7 +89,7 @@ fn test_c_take() {\n     check!(ffi::c_take_shared(ffi::Shared { z: 2020 }));\n     check!(ffi::c_take_box(Box::new(2020)));\n     check!(ffi::c_take_ref_c(&unique_ptr));\n-    check!(ffi::c_take_unique_ptr(unique_ptr));\n+    check!(cxx_test_suite::module::ffi::c_take_unique_ptr(unique_ptr));\n     check!(ffi::c_take_str(\"2020\"));\n     check!(ffi::c_take_sliceu8(b\"2020\"));\n     check!(ffi::c_take_rust_string(\"2020\".to_owned()));\ndiff --git /dev/null b/tests/ui/type_alias_rust.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/type_alias_rust.rs\n@@ -0,0 +1,9 @@\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"Rust\" {\n+        /// Incorrect.\n+        type Alias = crate::Type;\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/type_alias_rust.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/type_alias_rust.stderr\n@@ -0,0 +1,5 @@\n+error: type alias in extern \"Rust\" block is not supported\n+ --> $DIR/type_alias_rust.rs:5:9\n+  |\n+5 |         type Alias = crate::Type;\n+  |         ^^^^^^^^^^^^^^^^^^^^^^^^^\ndiff --git /dev/null b/tests/ui/wrong_type_id.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/wrong_type_id.rs\n@@ -0,0 +1,15 @@\n+#[cxx::bridge(namespace = folly)]\n+mod here {\n+    extern \"C\" {\n+        type StringPiece;\n+    }\n+}\n+\n+#[cxx::bridge(namespace = folly)]\n+mod there {\n+    extern \"C\" {\n+        type ByteRange = crate::here::StringPiece;\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/wrong_type_id.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/wrong_type_id.stderr\n@@ -0,0 +1,13 @@\n+error[E0271]: type mismatch resolving `<here::StringPiece as cxx::extern_type::ExternType>::Id == (cxx::f, cxx::o, cxx::l, cxx::l, cxx::y, (), cxx::B, cxx::y, cxx::t, cxx::e, cxx::R, cxx::a, cxx::n, cxx::g, cxx::e)`\n+   --> $DIR/wrong_type_id.rs:11:9\n+    |\n+11  |         type ByteRange = crate::here::StringPiece;\n+    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected a tuple with 15 elements, found one with 17 elements\n+    |\n+   ::: $WORKSPACE/src/extern_type.rs:110:41\n+    |\n+110 | pub fn verify_extern_type<T: ExternType<Id = Id>, Id>() {}\n+    |                                         ------- required by this bound in `cxx::extern_type::verify_extern_type`\n+    |\n+    = note: expected tuple `(cxx::f, cxx::o, cxx::l, cxx::l, cxx::y, (), cxx::B, cxx::y, cxx::t, cxx::e, cxx::R, cxx::a, cxx::n, cxx::g, cxx::e)`\n+               found tuple `(cxx::f, cxx::o, cxx::l, cxx::l, cxx::y, (), cxx::S, cxx::t, cxx::r, cxx::i, cxx::n, cxx::g, cxx::P, cxx::i, cxx::e, cxx::c, cxx::e)`\n",
        "problem_statement": "Multiple FFI blocks referencing types from one another\nI have two files requiring FFI, `json.rs` and `basevalue.rs`. I'd like to keep the FFI blocks local to those files, instead of having a central `ffi.rs`, but right now this is not possible.\r\n\r\nMy FFI block in `basevalue.rs`.\r\n```rust\r\n#[cxx::bridge(namespace = base)]\r\npub mod ffi {\r\n    extern \"C\" {\r\n        include!(\"base/values_rust.h\");\r\n        type RawOptionalBaseValue;\r\n        fn RustOptionalBaseValueSetString(v: &mut RawOptionalBaseValue, value: &str);\r\n        fn RustOptionalBaseValueSetBool(v: &mut RawOptionalBaseValue, val: bool);\r\n        // etc.\r\n    }\r\n}\r\n```\r\n\r\nMy FFI block in `json.rs`:\r\n```rust\r\n#[cxx::bridge(namespace = base)]\r\npub mod ffi {\r\n    extern \"Rust\" {\r\n        pub fn decode_json(\r\n            bv: UniquePtr<RawOptionalBaseValue>,\r\n            json: &str\r\n        ) -> bool;\r\n    }\r\n}       \r\n```\r\n\r\nNote that the `json.rs` block references a type from the `basevalue.rs` block.\r\n\r\nThis gives\r\n```\r\nerror[cxxbridge]: unsupported type\r\n```\r\n\r\nwhich is unsurprising, and I imagine is really hard to solve.\r\n\r\n(The exact code above is significantly simplified so obviously don't try to build it; if this issue isn't as \"known\" as I expect, let me know and I'll make a minimal test case).\n",
        "hints_text": "I've encountered this in my work codebase as well. What we've done for now is declare RawOptionalBaseValue as an opaque C type in both files, and then do unsafe pointer casts from one to the other where necessary:\r\n\r\n```rust\r\n// :(\r\nfn convert(bv: &mut first::ffi::BaseValue) -> &mut second::ffi::BaseValue {\r\n    unsafe {\r\n        &mut *(bv as *mut first::ffi::BaseValue as *mut second::ffi::BaseValue)\r\n    }\r\n}\r\n```\r\n\r\nObviously I'd like to support this better. It needs some more design work but I have some ideas for how to make it work safely and seamlessly, based on treating opaque C types in a way that doesn't produce a distinguishable representation in different places when using the same header and type name:\r\n\r\n```rust\r\n// effectively this, but encoded without relying on const generics\r\ntype RawOptionalBaseValue = OpaqueC<\"base/values_rust.h\", \"RawOptionalBaseValue\">;\r\n```\nThe part that needs design work is how to deal with codebases in which the same import path might not always refer to the same exact file; in that case allowing the interconversion would be bad. I'm confident it's solvable but just needs some attention.\nThanks, your workaround worked nicely for me.\nDoes anyone know how bindgen deals with the same issue? If we do two bindgen invocations in two different crates but some of the types are in common (something like folly::StringPiece which both crates might use) then do they also have the problem of those becoming two incompatible StringPiece types on the Rust side?\r\n\r\nI guess they provide a workaround of `--opaque-type folly::StringPiece` which turns it into `pub type folly_StringPiece = [u64; 2usize]` which is the same type in every crate, but it's not great because it's also the same type as lots of other non-StringPiece types.\nI got a chance to think about this a bit today. I think what I'd like looks more or less like this:\r\n\r\n```rust\r\n// basevalue.rs\r\n\r\n#[cxx::bridge(namespace = base)]\r\npub mod ffi {\r\n    extern \"C\" {\r\n        include!(\"base/values_rust.h\");\r\n\r\n        type RawOptionalBaseValue;\r\n\r\n        fn /* ... */\r\n    }\r\n}\r\n```\r\n\r\n```rust\r\n// json.rs\r\n\r\n#[cxx::bridge(namespace = base)]\r\npub mod ffi {\r\n    extern \"C\" {\r\n        type RawOptionalBaseValue = basevalue::ffi::RawOptionalBaseValue;\r\n\r\n        fn /* ... */\r\n    }\r\n}\r\n```\r\n\r\nwhere the first `type` expands to something like:\r\n\r\n```rust\r\n// same as today\r\n#[repr(C)]\r\npub struct RawOptionalBaseValue {\r\n    _private: ::cxx::private::Opaque,\r\n}\r\n\r\n// new\r\nunsafe impl ::cxx::private::ExternType for RawOptionalBaseValue {\r\n    type Id = /*type-encoding of \"base::RawOptionalBaseValue\"*/;\r\n}\r\n```\r\n\r\nwhile the second `type` expands to something like:\r\n\r\n```rust\r\n// assume that they're the same\r\npub use basevalue::ffi::RawOptionalBaseValue as RawOptionalBaseValue;\r\n\r\n// but also enforce that they're the same at compile time\r\nconst _: fn() = ::cxx::private::enforce_extern_type_id::<\r\n    RawOptionalBaseValue,\r\n    /*type-encoding of \"base::RawOptionalBaseValue\"*/,\r\n>;\r\n```\r\n\r\nand in CXX we provide:\r\n\r\n```rust\r\n#[doc(hidden)]\r\npub fn enforce_extern_type_id<T: ExternType<Id = Id>, Id>() {}\r\n```\r\n\r\nThe exact type-encoding there for the strings isn't important and I am not particularly worried about figuring out something that will work. Longer term we'll use a \"non-type template parameter\" a.k.a. \"const generic\" with the actual string literal, but for now you can conceptualize a possible encoding as:\r\n\r\n- `\"ABC\"` \\<-\\> `ch::A<ch::B<ch::C>>`\r\n\r\nwhere each of those is a distinct `struct A<Rest = ()>(PhantomData<Rest>)`. This wouldn't necessarily be how we do it for various reasons but it gives the same effect.\nIn fact we'd likely end up making the trait `ExternType` public (but still unsafe) so that the user can write their own impls for any bindgen-generated types to let those interop seamlessly with cxx bridge extern functions.\r\n\r\n```rust\r\nunsafe impl cxx::ExternType for folly_sys::StringPiece {\r\n    type Id = cxx::type_id!(\"folly::StringPiece\");\r\n}\r\n```",
        "created_at": "2020-05-08T09:05:06Z",
        "version": "0.3"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 1281,
        "instance_id": "dtolnay__cxx-1281",
        "issue_numbers": [
            "1191"
        ],
        "base_commit": "e5c32aa3d5ec9a16e6230162c7da39d023b64d3d",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -142,6 +142,7 @@ fn expand(ffi: Module, doc: Doc, attrs: OtherAttrs, apis: &[Api], types: &Types)\n         #[allow(\n             non_camel_case_types,\n             non_snake_case,\n+            unused_unsafe, // FIXME: only needed by rustc 1.64 and older\n             clippy::extra_unused_type_parameters,\n             clippy::items_after_statements,\n             clippy::ptr_as_ptr,\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -718,12 +719,9 @@ fn expand_cxx_function_shim(efn: &ExternFn, types: &Types) -> TokenStream {\n             expr = quote_spanned!(span=> ::cxx::core::result::Result::Ok(#expr));\n         }\n     };\n-    let mut dispatch = quote!(#setup #expr);\n+    let dispatch = quote_spanned!(span=> unsafe { #setup #expr });\n     let visibility = efn.visibility;\n     let unsafety = &efn.sig.unsafety;\n-    if unsafety.is_none() {\n-        dispatch = quote_spanned!(span=> unsafe { #dispatch });\n-    }\n     let fn_token = efn.sig.fn_token;\n     let ident = &efn.name.rust;\n     let generics = &efn.generics;\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -985,22 +983,31 @@ fn expand_rust_function_shim_impl(\n     });\n     let all_args = receiver.into_iter().chain(args);\n \n+    let mut requires_unsafe = false;\n     let arg_vars = sig.args.iter().map(|arg| {\n         let var = &arg.name.rust;\n         let span = var.span();\n         match &arg.ty {\n             Type::Ident(i) if i.rust == RustString => {\n+                requires_unsafe = true;\n                 quote_spanned!(span=> ::cxx::core::mem::take((*#var).as_mut_string()))\n             }\n-            Type::RustBox(_) => quote_spanned!(span=> ::cxx::alloc::boxed::Box::from_raw(#var)),\n+            Type::RustBox(_) => {\n+                requires_unsafe = true;\n+                quote_spanned!(span=> ::cxx::alloc::boxed::Box::from_raw(#var))\n+            }\n             Type::RustVec(vec) => {\n+                requires_unsafe = true;\n                 if vec.inner == RustString {\n                     quote_spanned!(span=> ::cxx::core::mem::take((*#var).as_mut_vec_string()))\n                 } else {\n                     quote_spanned!(span=> ::cxx::core::mem::take((*#var).as_mut_vec()))\n                 }\n             }\n-            Type::UniquePtr(_) => quote_spanned!(span=> ::cxx::UniquePtr::from_raw(#var)),\n+            Type::UniquePtr(_) => {\n+                requires_unsafe = true;\n+                quote_spanned!(span=> ::cxx::UniquePtr::from_raw(#var))\n+            }\n             Type::Ref(ty) => match &ty.inner {\n                 Type::Ident(i) if i.rust == RustString => match ty.mutable {\n                     false => quote_spanned!(span=> #var.as_string()),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1016,8 +1023,12 @@ fn expand_rust_function_shim_impl(\n                 },\n                 _ => quote!(#var),\n             },\n-            Type::Str(_) => quote_spanned!(span=> #var.as_str()),\n+            Type::Str(_) => {\n+                requires_unsafe = true;\n+                quote_spanned!(span=> #var.as_str())\n+            }\n             Type::SliceRef(slice) => {\n+                requires_unsafe = true;\n                 let inner = &slice.inner;\n                 match slice.mutable {\n                     false => quote_spanned!(span=> #var.as_slice::<#inner>()),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1025,6 +1036,7 @@ fn expand_rust_function_shim_impl(\n                 }\n             }\n             ty if types.needs_indirect_abi(ty) => {\n+                requires_unsafe = true;\n                 quote_spanned!(span=> ::cxx::core::ptr::read(#var))\n             }\n             _ => quote!(#var),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1042,6 +1054,7 @@ fn expand_rust_function_shim_impl(\n         }\n         None => {\n             requires_closure = true;\n+            requires_unsafe = true;\n             quote!(::cxx::core::mem::transmute::<*const (), #sig>(__extern))\n         }\n     };\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1109,12 +1122,18 @@ fn expand_rust_function_shim_impl(\n             None => quote_spanned!(span=> &mut ()),\n         };\n         requires_closure = true;\n+        requires_unsafe = true;\n         expr = quote_spanned!(span=> ::cxx::private::r#try(#out, #expr));\n     } else if indirect_return {\n         requires_closure = true;\n+        requires_unsafe = true;\n         expr = quote_spanned!(span=> ::cxx::core::ptr::write(__return, #expr));\n     }\n \n+    if requires_unsafe {\n+        expr = quote_spanned!(span=> unsafe { #expr });\n+    }\n+\n     let closure = if requires_closure {\n         quote_spanned!(span=> move || #expr)\n     } else {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1193,9 +1212,14 @@ fn expand_rust_function_shim_super(\n         }\n     };\n \n+    let mut body = quote_spanned!(span=> #call(#(#vars,)*));\n+    if unsafety.is_some() {\n+        body = quote_spanned!(span=> unsafe { #body });\n+    }\n+\n     quote_spanned! {span=>\n         #unsafety fn #local_name #generics(#(#all_args,)*) #ret {\n-            #call(#(#vars,)*)\n+            #body\n         }\n     }\n }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1286,13 +1310,13 @@ fn expand_rust_box(key: NamedImplKey, types: &Types, explicit_impl: Option<&Impl\n         #[export_name = #link_dealloc]\n         unsafe extern \"C\" fn #local_dealloc #impl_generics(ptr: *mut ::cxx::core::mem::MaybeUninit<#ident #ty_generics>) {\n             // No prevent_unwind: the global allocator is not allowed to panic.\n-            let _ = ::cxx::alloc::boxed::Box::from_raw(ptr);\n+            let _ = unsafe { ::cxx::alloc::boxed::Box::from_raw(ptr) };\n         }\n         #[doc(hidden)]\n         #[export_name = #link_drop]\n         unsafe extern \"C\" fn #local_drop #impl_generics(this: *mut ::cxx::alloc::boxed::Box<#ident #ty_generics>) {\n             let __fn = concat!(\"<\", module_path!(), #prevent_unwind_drop_label);\n-            ::cxx::private::prevent_unwind(__fn, || ::cxx::core::ptr::drop_in_place(this));\n+            ::cxx::private::prevent_unwind(__fn, || unsafe { ::cxx::core::ptr::drop_in_place(this) });\n         }\n     }\n }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1334,49 +1358,61 @@ fn expand_rust_vec(key: NamedImplKey, types: &Types, explicit_impl: Option<&Impl\n         #[export_name = #link_new]\n         unsafe extern \"C\" fn #local_new #impl_generics(this: *mut ::cxx::private::RustVec<#elem #ty_generics>) {\n             // No prevent_unwind: cannot panic.\n-            ::cxx::core::ptr::write(this, ::cxx::private::RustVec::new());\n+            unsafe {\n+                ::cxx::core::ptr::write(this, ::cxx::private::RustVec::new());\n+            }\n         }\n         #[doc(hidden)]\n         #[export_name = #link_drop]\n         unsafe extern \"C\" fn #local_drop #impl_generics(this: *mut ::cxx::private::RustVec<#elem #ty_generics>) {\n             let __fn = concat!(\"<\", module_path!(), #prevent_unwind_drop_label);\n-            ::cxx::private::prevent_unwind(__fn, || ::cxx::core::ptr::drop_in_place(this));\n+            ::cxx::private::prevent_unwind(\n+                __fn,\n+                || unsafe { ::cxx::core::ptr::drop_in_place(this) },\n+            );\n         }\n         #[doc(hidden)]\n         #[export_name = #link_len]\n         unsafe extern \"C\" fn #local_len #impl_generics(this: *const ::cxx::private::RustVec<#elem #ty_generics>) -> usize {\n             // No prevent_unwind: cannot panic.\n-            (*this).len()\n+            unsafe { (*this).len() }\n         }\n         #[doc(hidden)]\n         #[export_name = #link_capacity]\n         unsafe extern \"C\" fn #local_capacity #impl_generics(this: *const ::cxx::private::RustVec<#elem #ty_generics>) -> usize {\n             // No prevent_unwind: cannot panic.\n-            (*this).capacity()\n+            unsafe { (*this).capacity() }\n         }\n         #[doc(hidden)]\n         #[export_name = #link_data]\n         unsafe extern \"C\" fn #local_data #impl_generics(this: *const ::cxx::private::RustVec<#elem #ty_generics>) -> *const #elem #ty_generics {\n             // No prevent_unwind: cannot panic.\n-            (*this).as_ptr()\n+            unsafe { (*this).as_ptr() }\n         }\n         #[doc(hidden)]\n         #[export_name = #link_reserve_total]\n         unsafe extern \"C\" fn #local_reserve_total #impl_generics(this: *mut ::cxx::private::RustVec<#elem #ty_generics>, new_cap: usize) {\n             // No prevent_unwind: the global allocator is not allowed to panic.\n-            (*this).reserve_total(new_cap);\n+            unsafe {\n+                (*this).reserve_total(new_cap);\n+            }\n         }\n         #[doc(hidden)]\n         #[export_name = #link_set_len]\n         unsafe extern \"C\" fn #local_set_len #impl_generics(this: *mut ::cxx::private::RustVec<#elem #ty_generics>, len: usize) {\n             // No prevent_unwind: cannot panic.\n-            (*this).set_len(len);\n+            unsafe {\n+                (*this).set_len(len);\n+            }\n         }\n         #[doc(hidden)]\n         #[export_name = #link_truncate]\n         unsafe extern \"C\" fn #local_truncate #impl_generics(this: *mut ::cxx::private::RustVec<#elem #ty_generics>, len: usize) {\n             let __fn = concat!(\"<\", module_path!(), #prevent_unwind_drop_label);\n-            ::cxx::private::prevent_unwind(__fn, || (*this).truncate(len));\n+            ::cxx::private::prevent_unwind(\n+                __fn,\n+                || unsafe { (*this).truncate(len) },\n+            );\n         }\n     }\n }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1408,7 +1444,9 @@ fn expand_unique_ptr(\n                     fn __uninit(this: *mut ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>) -> *mut ::cxx::core::ffi::c_void;\n                 }\n                 let mut repr = ::cxx::core::mem::MaybeUninit::uninit();\n-                unsafe { __uninit(&mut repr).cast::<#ident #ty_generics>().write(value) }\n+                unsafe {\n+                    __uninit(&mut repr).cast::<#ident #ty_generics>().write(value);\n+                }\n                 repr\n             }\n         })\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1431,7 +1469,9 @@ fn expand_unique_ptr(\n                     fn __null(this: *mut ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>);\n                 }\n                 let mut repr = ::cxx::core::mem::MaybeUninit::uninit();\n-                unsafe { __null(&mut repr) }\n+                unsafe {\n+                    __null(&mut repr);\n+                }\n                 repr\n             }\n             #new_method\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1441,7 +1481,9 @@ fn expand_unique_ptr(\n                     fn __raw(this: *mut ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>, raw: *mut ::cxx::core::ffi::c_void);\n                 }\n                 let mut repr = ::cxx::core::mem::MaybeUninit::uninit();\n-                __raw(&mut repr, raw.cast());\n+                unsafe {\n+                    __raw(&mut repr, raw.cast());\n+                }\n                 repr\n             }\n             unsafe fn __get(repr: ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>) -> *const Self {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1449,21 +1491,23 @@ fn expand_unique_ptr(\n                     #[link_name = #link_get]\n                     fn __get(this: *const ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>) -> *const ::cxx::core::ffi::c_void;\n                 }\n-                __get(&repr).cast()\n+                unsafe { __get(&repr).cast() }\n             }\n             unsafe fn __release(mut repr: ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>) -> *mut Self {\n                 extern \"C\" {\n                     #[link_name = #link_release]\n                     fn __release(this: *mut ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>) -> *mut ::cxx::core::ffi::c_void;\n                 }\n-                __release(&mut repr).cast()\n+                unsafe { __release(&mut repr).cast() }\n             }\n             unsafe fn __drop(mut repr: ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>) {\n                 extern \"C\" {\n                     #[link_name = #link_drop]\n                     fn __drop(this: *mut ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>);\n                 }\n-                __drop(&mut repr);\n+                unsafe {\n+                    __drop(&mut repr);\n+                }\n             }\n         }\n     }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1494,7 +1538,9 @@ fn expand_shared_ptr(\n                     #[link_name = #link_uninit]\n                     fn __uninit(new: *mut ::cxx::core::ffi::c_void) -> *mut ::cxx::core::ffi::c_void;\n                 }\n-                __uninit(new).cast::<#ident #ty_generics>().write(value);\n+                unsafe {\n+                    __uninit(new).cast::<#ident #ty_generics>().write(value);\n+                }\n             }\n         })\n     } else {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1515,7 +1561,9 @@ fn expand_shared_ptr(\n                     #[link_name = #link_null]\n                     fn __null(new: *mut ::cxx::core::ffi::c_void);\n                 }\n-                __null(new);\n+                unsafe {\n+                    __null(new);\n+                }\n             }\n             #new_method\n             unsafe fn __clone(this: *const ::cxx::core::ffi::c_void, new: *mut ::cxx::core::ffi::c_void) {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1523,21 +1571,25 @@ fn expand_shared_ptr(\n                     #[link_name = #link_clone]\n                     fn __clone(this: *const ::cxx::core::ffi::c_void, new: *mut ::cxx::core::ffi::c_void);\n                 }\n-                __clone(this, new);\n+                unsafe {\n+                    __clone(this, new);\n+                }\n             }\n             unsafe fn __get(this: *const ::cxx::core::ffi::c_void) -> *const Self {\n                 extern \"C\" {\n                     #[link_name = #link_get]\n                     fn __get(this: *const ::cxx::core::ffi::c_void) -> *const ::cxx::core::ffi::c_void;\n                 }\n-                __get(this).cast()\n+                unsafe { __get(this).cast() }\n             }\n             unsafe fn __drop(this: *mut ::cxx::core::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_drop]\n                     fn __drop(this: *mut ::cxx::core::ffi::c_void);\n                 }\n-                __drop(this);\n+                unsafe {\n+                    __drop(this);\n+                }\n             }\n         }\n     }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1570,35 +1622,45 @@ fn expand_weak_ptr(key: NamedImplKey, types: &Types, explicit_impl: Option<&Impl\n                     #[link_name = #link_null]\n                     fn __null(new: *mut ::cxx::core::ffi::c_void);\n                 }\n-                __null(new);\n+                unsafe {\n+                    __null(new);\n+                }\n             }\n             unsafe fn __clone(this: *const ::cxx::core::ffi::c_void, new: *mut ::cxx::core::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_clone]\n                     fn __clone(this: *const ::cxx::core::ffi::c_void, new: *mut ::cxx::core::ffi::c_void);\n                 }\n-                __clone(this, new);\n+                unsafe {\n+                    __clone(this, new);\n+                }\n             }\n             unsafe fn __downgrade(shared: *const ::cxx::core::ffi::c_void, weak: *mut ::cxx::core::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_downgrade]\n                     fn __downgrade(shared: *const ::cxx::core::ffi::c_void, weak: *mut ::cxx::core::ffi::c_void);\n                 }\n-                __downgrade(shared, weak);\n+                unsafe {\n+                    __downgrade(shared, weak);\n+                }\n             }\n             unsafe fn __upgrade(weak: *const ::cxx::core::ffi::c_void, shared: *mut ::cxx::core::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_upgrade]\n                     fn __upgrade(weak: *const ::cxx::core::ffi::c_void, shared: *mut ::cxx::core::ffi::c_void);\n                 }\n-                __upgrade(weak, shared);\n+                unsafe {\n+                    __upgrade(weak, shared);\n+                }\n             }\n             unsafe fn __drop(this: *mut ::cxx::core::ffi::c_void) {\n                 extern \"C\" {\n                     #[link_name = #link_drop]\n                     fn __drop(this: *mut ::cxx::core::ffi::c_void);\n                 }\n-                __drop(this);\n+                unsafe {\n+                    __drop(this);\n+                }\n             }\n         }\n     }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1648,7 +1710,12 @@ fn expand_cxx_vector(\n                         value: *mut ::cxx::core::ffi::c_void,\n                     );\n                 }\n-                __push_back(this, value as *mut ::cxx::core::mem::ManuallyDrop<Self> as *mut ::cxx::core::ffi::c_void);\n+                unsafe {\n+                    __push_back(\n+                        this,\n+                        value as *mut ::cxx::core::mem::ManuallyDrop<Self> as *mut ::cxx::core::ffi::c_void,\n+                    );\n+                }\n             }\n             unsafe fn __pop_back(\n                 this: ::cxx::core::pin::Pin<&mut ::cxx::CxxVector<Self>>,\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1661,7 +1728,12 @@ fn expand_cxx_vector(\n                         out: *mut ::cxx::core::ffi::c_void,\n                     );\n                 }\n-                __pop_back(this, out as *mut ::cxx::core::mem::MaybeUninit<Self> as *mut ::cxx::core::ffi::c_void);\n+                unsafe {\n+                    __pop_back(\n+                        this,\n+                        out as *mut ::cxx::core::mem::MaybeUninit<Self> as *mut ::cxx::core::ffi::c_void,\n+                    );\n+                }\n             }\n         })\n     } else {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1695,7 +1767,7 @@ fn expand_cxx_vector(\n                         pos: usize,\n                     ) -> *mut ::cxx::core::ffi::c_void;\n                 }\n-                __get_unchecked(v, pos) as *mut Self\n+                unsafe { __get_unchecked(v, pos) as *mut Self }\n             }\n             #by_value_methods\n             fn __unique_ptr_null() -> ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void> {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1704,7 +1776,9 @@ fn expand_cxx_vector(\n                     fn __unique_ptr_null(this: *mut ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>);\n                 }\n                 let mut repr = ::cxx::core::mem::MaybeUninit::uninit();\n-                unsafe { __unique_ptr_null(&mut repr) }\n+                unsafe {\n+                    __unique_ptr_null(&mut repr);\n+                }\n                 repr\n             }\n             unsafe fn __unique_ptr_raw(raw: *mut ::cxx::CxxVector<Self>) -> ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void> {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1713,7 +1787,9 @@ fn expand_cxx_vector(\n                     fn __unique_ptr_raw #impl_generics(this: *mut ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>, raw: *mut ::cxx::CxxVector<#elem #ty_generics>);\n                 }\n                 let mut repr = ::cxx::core::mem::MaybeUninit::uninit();\n-                __unique_ptr_raw(&mut repr, raw);\n+                unsafe {\n+                    __unique_ptr_raw(&mut repr, raw);\n+                }\n                 repr\n             }\n             unsafe fn __unique_ptr_get(repr: ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>) -> *const ::cxx::CxxVector<Self> {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1721,21 +1797,23 @@ fn expand_cxx_vector(\n                     #[link_name = #link_unique_ptr_get]\n                     fn __unique_ptr_get #impl_generics(this: *const ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>) -> *const ::cxx::CxxVector<#elem #ty_generics>;\n                 }\n-                __unique_ptr_get(&repr)\n+                unsafe { __unique_ptr_get(&repr) }\n             }\n             unsafe fn __unique_ptr_release(mut repr: ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>) -> *mut ::cxx::CxxVector<Self> {\n                 extern \"C\" {\n                     #[link_name = #link_unique_ptr_release]\n                     fn __unique_ptr_release #impl_generics(this: *mut ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>) -> *mut ::cxx::CxxVector<#elem #ty_generics>;\n                 }\n-                __unique_ptr_release(&mut repr)\n+                unsafe { __unique_ptr_release(&mut repr) }\n             }\n             unsafe fn __unique_ptr_drop(mut repr: ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>) {\n                 extern \"C\" {\n                     #[link_name = #link_unique_ptr_drop]\n                     fn __unique_ptr_drop(this: *mut ::cxx::core::mem::MaybeUninit<*mut ::cxx::core::ffi::c_void>);\n                 }\n-                __unique_ptr_drop(&mut repr);\n+                unsafe {\n+                    __unique_ptr_drop(&mut repr);\n+                }\n             }\n         }\n     }\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -1,3 +1,4 @@\n+#![forbid(unsafe_op_in_unsafe_fn)]\n #![allow(\n     clippy::boxed_local,\n     clippy::derive_partial_eq_without_eq,\n",
        "problem_statement": "Use `unsafe` blocks in `unsafe fn`s\n`cxx::bridge` generates code incompatible with the  `unsafe_op_in_unsafe_fn` lint. Since this is a useful lint and it's likely to become an error in the future, `cxx::bridge` should wrap unsafe ops in `unsafe` blocks always.\r\n\r\nRight now it's impossible to use it with `forbid(unsafe_op_in_unsafe_fn)` and requires explicit `allow()` attributes with `deny(...)`\n",
        "hints_text": "+1\r\n\r\nWe had some issues with this, too, and have fixed it in our project-private fork of the crate. Would be nicer to have it fixed upstream.\n> +1\n> \n> \n> \n> We had some issues with this, too, and have fixed it in our project-private fork of the crate. Would be nicer to have it fixed upstream.\n\n@schreter why don't you submit the change as a PR? \n@bridiver \r\n\r\n> why don't you submit the change as a PR?\r\n\r\n**Bluntly put, because I feel it's pointless.**\r\n\r\nWe wanted to contribute major stuff upstream (by-value passing, proper customizable exception support, etc.), primarily what we need for our \"big\" project with C++/Rust interop (about 8M LOCs C++ + 2M LOCs Rust). I have some PRs there open since half a year with no review from the maintainer, also no reaction to nudges in other PRs/issues.\r\n\r\n**Therefore, I gave up.**\r\n\r\nMaybe a small change like this would work, I got some micro-changes merged. Feel free to try to open a PR, but other small changes got also zero reaction from the maintainer. Anything what is not a trivial bugfix seems to be ignored.\r\n\r\nI'm sorry for the project, but I can't expend the time for upstream anymore. Maybe we'll publish a new, divergent crate based on this one, which contains all our improvements, but I don't promise. No manpower to drive this and deadlines are pressing.\n> Maybe we'll publish a new, divergent crate based on this one, which contains all our improvements, but I don't promise. No manpower to drive this and deadlines are pressing.\r\n\r\n@schreter I highly recommend at least pushing your forked branch to GitHub. Judging from reactions on your other PRs, others are definitely interested in the changes. Some of us may be willing to take on the effort of ongoing maintenance, whether that means publishing a fork to crates.io or preparing and managing PRs for this repo.\r\n\r\nSpeaking from experience as a maintainer of a few open source projects, it takes a lot of activation energy to review PRs. @dtolnay maintains a _lot_ of popular crates; I imagine he'll get to the PRs you've opened when he's ready.\n@dtolnay can you advise what's the best way to run the cxx test suite so that `cxx::bridge` macro output is built with `forbid(unsafe_op_in_unsafe_fn)`? I guess specifically for the trybuild tests.\r\n\r\nNot looking for any further attention here, this just might help with writing a PR later.\n@chbaker0 we use `-Dunsafe_op_in_unsafe_fn` and we're doing this to work around it for cxx\r\n```\r\n#[allow(unsafe_op_in_unsafe_fn)]\r\n#[cxx::bridge(...)]\r\n...\r\n```",
        "created_at": "2023-10-28T02:45:52Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 1251,
        "instance_id": "dtolnay__cxx-1251",
        "issue_numbers": [
            "1250"
        ],
        "base_commit": "cffc6b001839d60f3415cc82bdca04458471688d",
        "patch": "diff --git a/gen/build/src/out.rs b/gen/build/src/out.rs\n--- a/gen/build/src/out.rs\n+++ b/gen/build/src/out.rs\n@@ -1,8 +1,8 @@\n use crate::error::{Error, Result};\n use crate::gen::fs;\n use crate::paths;\n-use std::io;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n+use std::{env, io};\n \n pub(crate) fn write(path: impl AsRef<Path>, content: &[u8]) -> Result<()> {\n     let path = path.as_ref();\ndiff --git a/gen/build/src/out.rs b/gen/build/src/out.rs\n--- a/gen/build/src/out.rs\n+++ b/gen/build/src/out.rs\n@@ -33,6 +33,8 @@ pub(crate) fn symlink_file(original: impl AsRef<Path>, link: impl AsRef<Path>) -\n     let original = original.as_ref();\n     let link = link.as_ref();\n \n+    let original = best_effort_relativize_symlink(original, link);\n+\n     let mut create_dir_error = None;\n     if fs::exists(link) {\n         best_effort_remove(link);\ndiff --git a/gen/build/src/out.rs b/gen/build/src/out.rs\n--- a/gen/build/src/out.rs\n+++ b/gen/build/src/out.rs\n@@ -64,7 +66,7 @@ pub(crate) fn symlink_file(original: impl AsRef<Path>, link: impl AsRef<Path>) -\n }\n \n pub(crate) fn symlink_dir(original: impl AsRef<Path>, link: impl AsRef<Path>) -> Result<()> {\n-    let original = original.as_ref();\n+    let original = best_effort_relativize_symlink(original.as_ref(), link.as_ref());\n     let link = link.as_ref();\n \n     let mut create_dir_error = None;\n",
        "test_patch": "diff --git a/gen/build/src/out.rs b/gen/build/src/out.rs\n--- a/gen/build/src/out.rs\n+++ b/gen/build/src/out.rs\n@@ -117,3 +119,116 @@ fn best_effort_remove(path: &Path) {\n         }\n     }\n }\n+\n+fn best_effort_relativize_symlink(original: impl AsRef<Path>, link: impl AsRef<Path>) -> PathBuf {\n+    let original = original.as_ref();\n+    let link = link.as_ref();\n+\n+    // relativization only makes sense if there is a semantically meaningful root between the two\n+    // (aka it's unlikely that a user moving a directory will cause a break).\n+    // e.g. /Volumes/code/library/src/lib.rs and /Volumes/code/library/target/path/to/something.a\n+    // have a meaningful shared root of /Volumes/code/library, as the person who moves target\n+    // out of library would expect it to break.\n+    // on the other hand, /Volumes/code/library/src/lib.rs and /Volumes/shared_target do not, since\n+    // moving library to a different location should not be expected to break things.\n+    let likely_no_semantic_root = env::var_os(\"CARGO_TARGET_DIR\").is_some();\n+\n+    if likely_no_semantic_root\n+        || original.is_relative()\n+        || link.is_relative()\n+        || path_contains_intermediate_components(original)\n+        || path_contains_intermediate_components(link)\n+    {\n+        return original.to_path_buf();\n+    }\n+\n+    let shared_root = shared_root(original, link);\n+\n+    if shared_root == PathBuf::new() {\n+        return original.to_path_buf();\n+    }\n+\n+    let relative_original = original.strip_prefix(&shared_root).expect(\"unreachable\");\n+    let mut link = link\n+        .parent()\n+        .expect(\"we know that link is an absolute path, so at least one parent exists\")\n+        .to_path_buf();\n+\n+    let mut path_to_shared_root = PathBuf::new();\n+    while link != shared_root {\n+        path_to_shared_root.push(\"..\");\n+        assert!(\n+            link.pop(),\n+            \"we know there is a shared root of nonzero size, so this should never return 'no parent'\"\n+        );\n+    }\n+\n+    path_to_shared_root.join(relative_original)\n+}\n+\n+fn path_contains_intermediate_components(path: impl AsRef<Path>) -> bool {\n+    path.as_ref().iter().any(|segment| segment == \"..\")\n+}\n+\n+fn shared_root(left: &Path, right: &Path) -> PathBuf {\n+    let mut shared_root = PathBuf::new();\n+    let mut left = left.iter();\n+    let mut right = right.iter();\n+    loop {\n+        let left = left.next();\n+        let right = right.next();\n+\n+        if left != right || left.is_none() {\n+            return shared_root;\n+        }\n+        shared_root.push(left.unwrap());\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::out::best_effort_relativize_symlink;\n+\n+    #[cfg(not(windows))]\n+    #[test]\n+    fn test_relativize_symlink_unix() {\n+        assert_eq!(\n+            best_effort_relativize_symlink(\"/foo/bar/baz\", \"/foo/spam/eggs\")\n+                .to_str()\n+                .unwrap(),\n+            \"../bar/baz\"\n+        );\n+        assert_eq!(\n+            best_effort_relativize_symlink(\"/foo/bar/../baz\", \"/foo/spam/eggs\")\n+                .to_str()\n+                .unwrap(),\n+            \"/foo/bar/../baz\"\n+        );\n+        assert_eq!(\n+            best_effort_relativize_symlink(\"/foo/bar/baz\", \"/foo/spam/./eggs\")\n+                .to_str()\n+                .unwrap(),\n+            \"../bar/baz\"\n+        );\n+    }\n+\n+    #[cfg(windows)]\n+    #[test]\n+    fn test_relativize_symlink_windows() {\n+        use std::path::PathBuf;\n+        let windows_target: PathBuf = [\"c:\\\\\", \"windows\", \"foo\"].iter().collect();\n+        let windows_link: PathBuf = [\"c:\\\\\", \"users\", \"link\"].iter().collect();\n+        let windows_different_volume_link: PathBuf = [\"d:\\\\\", \"users\", \"link\"].iter().collect();\n+\n+        assert_eq!(\n+            best_effort_relativize_symlink(windows_target.clone(), windows_link)\n+                .to_str()\n+                .unwrap(),\n+            \"..\\\\windows\\\\foo\"\n+        );\n+        assert_eq!(\n+            best_effort_relativize_symlink(windows_target.clone(), windows_different_volume_link),\n+            windows_target\n+        );\n+    }\n+}\n",
        "problem_statement": "Emit with relative symlinks?\nI'm using https://crane.dev to build a Cargo project with Nix. Crane has an elegant feature where it can precompile all dependencies in one build step (which is cached) so unless you change your dependencies, no recompile of dependencies is required. This drastically speeds up builds.\r\n\r\nThe approximate process by which it does this is:\r\n\r\n```\r\ncargo build\r\nmv target $out\r\n```\r\n\r\nUnfortunately, cxx seems unique in our tech stack in that it creates absolute symlinks in its output, which end up like:\r\n\r\n```\r\nlrwxr-xr-x  1 root  wheel  189  1 Jan  1970 ./release/build/mycrate-461e0524ef218d12/out/cxxbridge/include/mycrate/src/lib.rs -> /private/tmp/nix-build-cargo-package-deps-0.0.1.drv-1/source/target/release/build/mycrate-461e0524ef218d12/out/cxxbridge/include/mycrate/src/lib.rs.h\r\n```\r\n\r\nUnfortunately, the tempdir is immediately deleted. I'm wondering if there's a reason other than simplicity that absolute symlinks are used here, and whether a PR might be accepted that adjusts them to being relative? At the moment I am resolving this problem by running `symlinks -rc $PWD` on the directory after the build has occurred, but this feels more fragile than fixing the source.\r\n\r\nI _think_ that this would also have the effect of meaning that cxx builds are not broken after a move of the project directory, but am not 100% on how cache invalidation works.\n",
        "hints_text": "I would be open to a PR that makes the symlinks relative.",
        "created_at": "2023-08-05T16:54:58Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 1150,
        "instance_id": "dtolnay__cxx-1150",
        "issue_numbers": [
            "1149"
        ],
        "base_commit": "13e7e104148a2075acb1a605184bd0cd3e83c420",
        "patch": "diff --git a/syntax/names.rs b/syntax/names.rs\n--- a/syntax/names.rs\n+++ b/syntax/names.rs\n@@ -3,7 +3,8 @@ use crate::syntax::{Lifetimes, NamedType, Pair, Symbol};\n use proc_macro2::{Ident, Span};\n use std::fmt::{self, Display};\n use std::iter;\n-use syn::parse::{Error, Result};\n+use syn::ext::IdentExt;\n+use syn::parse::{Error, Parser, Result};\n use syn::punctuated::Punctuated;\n \n #[derive(Clone)]\ndiff --git a/syntax/names.rs b/syntax/names.rs\n--- a/syntax/names.rs\n+++ b/syntax/names.rs\n@@ -41,7 +42,7 @@ impl ForeignName {\n     pub fn parse(text: &str, span: Span) -> Result<Self> {\n         // TODO: support C++ names containing whitespace (`unsigned int`) or\n         // non-alphanumeric characters (`operator++`).\n-        match syn::parse_str::<Ident>(text) {\n+        match Ident::parse_any.parse_str(text) {\n             Ok(ident) => {\n                 let text = ident.to_string();\n                 Ok(ForeignName { text })\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -43,6 +43,7 @@ pub mod ffi {\n     #[namespace = \"A\"]\n     #[derive(Copy, Clone, Default)]\n     struct AShared {\n+        #[cxx_name = \"type\"]\n         z: usize,\n     }\n \ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -86,7 +86,9 @@ std::unique_ptr<::H::H> c_return_ns_unique_ptr() {\n \n const size_t &c_return_ref(const Shared &shared) { return shared.z; }\n \n-const size_t &c_return_ns_ref(const ::A::AShared &shared) { return shared.z; }\n+const size_t &c_return_ns_ref(const ::A::AShared &shared) {\n+  return shared.type;\n+}\n \n const size_t &c_return_nested_ns_ref(const ::A::B::ABShared &shared) {\n   return shared.z;\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -240,7 +242,7 @@ void c_take_shared(Shared shared) {\n }\n \n void c_take_ns_shared(::A::AShared shared) {\n-  if (shared.z == 2020) {\n+  if (shared.type == 2020) {\n     cxx_test_suite_set_correct();\n   }\n }\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -397,7 +399,7 @@ void c_take_rust_vec_shared(rust::Vec<Shared> v) {\n void c_take_rust_vec_ns_shared(rust::Vec<::A::AShared> v) {\n   uint32_t sum = 0;\n   for (auto i : v) {\n-    sum += i.z;\n+    sum += i.type;\n   }\n   if (sum == 2021) {\n     cxx_test_suite_set_correct();\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -916,7 +918,7 @@ ::tests::D ns_c_return_trivial() {\n }\n \n void ns_c_take_ns_shared(::A::AShared shared) {\n-  if (shared.z == 2020) {\n+  if (shared.type == 2020) {\n     cxx_test_suite_set_correct();\n   }\n }\n",
        "problem_statement": "`#[cxx_name = \"type\"]` yields an error \"expected identifier\"\nI have a struct in C++ with a field named **type**:\r\n\r\n```cpp\r\nstruct X {\r\n    int32 type;\r\n}\r\n```\r\n\r\nThen I represent it in Rust as a shared type inside of the `#[cxx::bridge]` mod:\r\n\r\n```rust\r\nstruct X {\r\n    #[cxx_name = \"type\"]\r\n    x_type: i32,\r\n}\r\n```\r\n\r\nBut this yields an error:\r\n```\r\n error[cxxbridge]: expected identifier\r\n      \u250c\u2500 src/lib.rs:138:22\r\n      \u2502\r\n  138 \u2502         #[cxx_name = \"type\"]\r\n      \u2502                      ^^^^^^ expected identifier\r\n```\r\n\r\nAt the same time other values for `cxx_name` such as `type1` work fine.\n",
        "hints_text": "",
        "created_at": "2023-01-07T20:03:34Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 1128,
        "instance_id": "dtolnay__cxx-1128",
        "issue_numbers": [
            "1126"
        ],
        "base_commit": "3e065f76a45122796909c2a7c72377606dff4f81",
        "patch": "diff --git a/macro/src/type_id.rs b/macro/src/type_id.rs\n--- a/macro/src/type_id.rs\n+++ b/macro/src/type_id.rs\n@@ -1,6 +1,7 @@\n use crate::syntax::qualified::QualifiedName;\n use proc_macro2::{TokenStream, TokenTree};\n use quote::{format_ident, quote, ToTokens};\n+use syn::ext::IdentExt;\n \n pub enum Crate {\n     Cxx,\ndiff --git a/macro/src/type_id.rs b/macro/src/type_id.rs\n--- a/macro/src/type_id.rs\n+++ b/macro/src/type_id.rs\n@@ -24,7 +25,7 @@ pub fn expand(krate: Crate, arg: QualifiedName) -> TokenStream {\n         if !ids.is_empty() {\n             ids.push(quote!(()));\n         }\n-        for ch in word.to_string().chars() {\n+        for ch in word.unraw().to_string().chars() {\n             ids.push(match ch {\n                 'A'..='Z' | 'a'..='z' => {\n                     let t = format_ident!(\"{}\", ch);\ndiff --git a/syntax/qualified.rs b/syntax/qualified.rs\n--- a/syntax/qualified.rs\n+++ b/syntax/qualified.rs\n@@ -1,5 +1,5 @@\n use syn::ext::IdentExt;\n-use syn::parse::{ParseStream, Result};\n+use syn::parse::{Error, ParseStream, Result};\n use syn::{Ident, LitStr, Token};\n \n pub struct QualifiedName {\ndiff --git a/syntax/qualified.rs b/syntax/qualified.rs\n--- a/syntax/qualified.rs\n+++ b/syntax/qualified.rs\n@@ -8,21 +8,8 @@ pub struct QualifiedName {\n \n impl QualifiedName {\n     pub fn parse_unquoted(input: ParseStream) -> Result<Self> {\n-        let mut segments = Vec::new();\n-        let mut trailing_punct = true;\n-        let leading_colons: Option<Token![::]> = input.parse()?;\n-        while trailing_punct && input.peek(Ident::peek_any) {\n-            let ident = Ident::parse_any(input)?;\n-            segments.push(ident);\n-            let colons: Option<Token![::]> = input.parse()?;\n-            trailing_punct = colons.is_some();\n-        }\n-        if segments.is_empty() && leading_colons.is_none() {\n-            return Err(input.error(\"expected path\"));\n-        } else if trailing_punct {\n-            return Err(input.error(\"expected path segment\"));\n-        }\n-        Ok(QualifiedName { segments })\n+        let allow_raw = true;\n+        parse_unquoted(input, allow_raw)\n     }\n \n     pub fn parse_quoted_or_unquoted(input: ParseStream) -> Result<Self> {\ndiff --git a/syntax/qualified.rs b/syntax/qualified.rs\n--- a/syntax/qualified.rs\n+++ b/syntax/qualified.rs\n@@ -32,10 +19,41 @@ impl QualifiedName {\n                 let segments = Vec::new();\n                 Ok(QualifiedName { segments })\n             } else {\n-                lit.parse_with(Self::parse_unquoted)\n+                lit.parse_with(|input: ParseStream| {\n+                    let allow_raw = false;\n+                    parse_unquoted(input, allow_raw)\n+                })\n             }\n         } else {\n             Self::parse_unquoted(input)\n         }\n     }\n }\n+\n+fn parse_unquoted(input: ParseStream, allow_raw: bool) -> Result<QualifiedName> {\n+    let mut segments = Vec::new();\n+    let mut trailing_punct = true;\n+    let leading_colons: Option<Token![::]> = input.parse()?;\n+    while trailing_punct && input.peek(Ident::peek_any) {\n+        let mut ident = Ident::parse_any(input)?;\n+        if let Some(unraw) = ident.to_string().strip_prefix(\"r#\") {\n+            if !allow_raw {\n+                let msg = format!(\n+                    \"raw identifier `{}` is not allowed in a quoted namespace; use `{}`, or remove quotes\",\n+                    ident, unraw,\n+                );\n+                return Err(Error::new(ident.span(), msg));\n+            }\n+            ident = Ident::new(unraw, ident.span());\n+        }\n+        segments.push(ident);\n+        let colons: Option<Token![::]> = input.parse()?;\n+        trailing_punct = colons.is_some();\n+    }\n+    if segments.is_empty() && leading_colons.is_none() {\n+        return Err(input.error(\"expected path\"));\n+    } else if trailing_punct {\n+        return Err(input.error(\"expected path segment\"));\n+    }\n+    Ok(QualifiedName { segments })\n+}\n",
        "test_patch": "diff --git /dev/null b/tests/ui/raw_ident_namespace.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/raw_ident_namespace.rs\n@@ -0,0 +1,53 @@\n+use cxx::{type_id, ExternType};\n+\n+#[repr(transparent)]\n+pub struct QuotedRaw(usize);\n+\n+unsafe impl ExternType for QuotedRaw {\n+    type Id = type_id!(\"org::r#box::implementation::QuotedRaw\");\n+    type Kind = cxx::kind::Trivial;\n+}\n+\n+#[repr(transparent)]\n+pub struct QuotedKeyword(usize);\n+\n+unsafe impl ExternType for QuotedKeyword {\n+    type Id = type_id!(\"org::box::implementation::QuotedKeyword\");\n+    type Kind = cxx::kind::Trivial;\n+}\n+\n+#[repr(transparent)]\n+pub struct UnquotedRaw(usize);\n+\n+unsafe impl ExternType for UnquotedRaw {\n+    type Id = type_id!(org::r#box::implementation::UnquotedRaw);\n+    type Kind = cxx::kind::Trivial;\n+}\n+\n+#[repr(transparent)]\n+pub struct UnquotedKeyword(usize);\n+\n+unsafe impl ExternType for UnquotedKeyword {\n+    type Id = type_id!(org::box::implementation::UnquotedKeyword);\n+    type Kind = cxx::kind::Trivial;\n+}\n+\n+#[cxx::bridge]\n+pub mod ffi {\n+    extern \"C++\" {\n+        #[namespace = \"org::r#box::implementation\"]\n+        type QuotedRaw = crate::QuotedRaw;\n+\n+        #[namespace = \"org::box::implementation\"]\n+        type QuotedKeyword = crate::QuotedKeyword;\n+\n+        #[namespace = org::r#box::implementation]\n+        type UnquotedRaw = crate::UnquotedRaw;\n+\n+        // Not allowed by rustc (independent of cxx):\n+        // #[namespace = org::box::implementation]\n+        // type UnquotedKeyword = crate::UnquotedKeyword;\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/raw_ident_namespace.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/raw_ident_namespace.stderr\n@@ -0,0 +1,11 @@\n+error: raw identifier `r#box` is not allowed in a quoted namespace; use `box`, or remove quotes\n+ --> tests/ui/raw_ident_namespace.rs:7:24\n+  |\n+7 |     type Id = type_id!(\"org::r#box::implementation::QuotedRaw\");\n+  |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: raw identifier `r#box` is not allowed in a quoted namespace; use `box`, or remove quotes\n+  --> tests/ui/raw_ident_namespace.rs:38:23\n+   |\n+38 |         #[namespace = \"org::r#box::implementation\"]\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
        "problem_statement": "Namespaces with raw-escaped reserved Rust words generate invalid C++\n<!--  \u2764\ufe0f  -->\r\n\r\nGiven the following example:\r\n\r\n```rust\r\n#[cxx::bridge]\r\npub(crate) mod ffi {\r\n    unsafe extern \"C++\" {\r\n        #[namespace = ::my::company::r#box::implementation]\r\n        type MyBox;\r\n    }\r\n}\r\n```\r\n\r\nThe following code is generated:\r\n\r\n\r\n```cpp\r\n::std::shared_ptr<:my::company::r#box::implementation> MyBox;\r\n```\r\n\r\n```cpp\r\nnamespace r#box { ... }\r\n```\r\n\r\nThese are both invalid and generate the following errors:\r\n```\r\n<SNIP>:16: error: expected '{'        \r\n    namespace r#box {                                                                                             \r\n               ^                                                                                                  \r\n<SNIP>: error: expected unqualified-id                           \r\n<SNIP>: error: no member named 'r' in namespace 'my::company'                                                                   \r\n  ::std::shared_ptr<::my::company::r#box::implementation::MyBox> my_box;       \r\n                    ~~~~~~~~~~~~~~~^                            \r\n3 errors generated.                        \r\n```\r\n\r\nArguably, cxx should strip out the rust-specific `r#` and generate C++ code as if there wasn't an escape from rust to begin with.\r\n\r\nMaybe related: #287 \n",
        "hints_text": "If anyone's running into this issue, you can quote the namespace attribute value without the raw-escape token to allow Rust to permit it as well:\r\n\r\n```rust\r\n#[cxx::bridge]\r\npub(crate) mod ffi {\r\n    unsafe extern \"C++\" {\r\n        #[namespace = \"::my::company::box::implementation\"]\r\n        type MyBox;\r\n    }\r\n}\r\n```\r\n\r\nAs the need to quote is a limitation from Rust rather than cxx.",
        "created_at": "2022-11-08T08:51:39Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 1104,
        "instance_id": "dtolnay__cxx-1104",
        "issue_numbers": [
            "1103"
        ],
        "base_commit": "35f4b680f2bf109dcc8daa9a25d9e5c6779a94d4",
        "patch": "diff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -123,10 +123,9 @@ fn check_type_rust_vec(cx: &mut Check, ty: &Ty1) {\n             }\n \n             match Atom::from(&ident.rust) {\n-                None | Some(Char) | Some(U8) | Some(U16) | Some(U32) | Some(U64) | Some(Usize)\n-                | Some(I8) | Some(I16) | Some(I32) | Some(I64) | Some(Isize) | Some(F32)\n-                | Some(F64) | Some(RustString) => return,\n-                Some(Bool) => { /* todo */ }\n+                None | Some(Bool) | Some(Char) | Some(U8) | Some(U16) | Some(U32) | Some(U64)\n+                | Some(Usize) | Some(I8) | Some(I16) | Some(I32) | Some(I64) | Some(Isize)\n+                | Some(F32) | Some(F64) | Some(RustString) => return,\n                 Some(CxxString) => {}\n             }\n         }\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -114,10 +114,11 @@ pub mod ffi {\n         fn c_return_unique_ptr_vector_opaque() -> UniquePtr<CxxVector<C>>;\n         fn c_return_ref_vector(c: &C) -> &CxxVector<u8>;\n         fn c_return_mut_vector(c: Pin<&mut C>) -> Pin<&mut CxxVector<u8>>;\n-        fn c_return_rust_vec() -> Vec<u8>;\n+        fn c_return_rust_vec_u8() -> Vec<u8>;\n         fn c_return_ref_rust_vec(c: &C) -> &Vec<u8>;\n         fn c_return_mut_rust_vec(c: Pin<&mut C>) -> &mut Vec<u8>;\n         fn c_return_rust_vec_string() -> Vec<String>;\n+        fn c_return_rust_vec_bool() -> Vec<bool>;\n         fn c_return_identity(_: usize) -> usize;\n         fn c_return_sum(_: usize, _: usize) -> usize;\n         fn c_return_enum(n: u16) -> Enum;\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -158,7 +158,7 @@ const std::vector<uint8_t> &c_return_ref_vector(const C &c) {\n \n std::vector<uint8_t> &c_return_mut_vector(C &c) { return c.get_v(); }\n \n-rust::Vec<uint8_t> c_return_rust_vec() {\n+rust::Vec<uint8_t> c_return_rust_vec_u8() {\n   rust::Vec<uint8_t> vec{2, 0, 2, 0};\n   return vec;\n }\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -177,6 +177,10 @@ rust::Vec<rust::String> c_return_rust_vec_string() {\n   return {\"2\", \"0\", \"2\", \"0\"};\n }\n \n+rust::Vec<bool> c_return_rust_vec_bool() {\n+  return {true, true, false};\n+}\n+\n size_t c_return_identity(size_t n) { return n; }\n \n size_t c_return_sum(size_t n1, size_t n2) { return n1 + n2; }\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -111,10 +111,11 @@ std::unique_ptr<std::vector<Shared>> c_return_unique_ptr_vector_shared();\n std::unique_ptr<std::vector<C>> c_return_unique_ptr_vector_opaque();\n const std::vector<uint8_t> &c_return_ref_vector(const C &c);\n std::vector<uint8_t> &c_return_mut_vector(C &c);\n-rust::Vec<uint8_t> c_return_rust_vec();\n+rust::Vec<uint8_t> c_return_rust_vec_u8();\n const rust::Vec<uint8_t> &c_return_ref_rust_vec(const C &c);\n rust::Vec<uint8_t> &c_return_mut_rust_vec(C &c);\n rust::Vec<rust::String> c_return_rust_vec_string();\n+rust::Vec<bool> c_return_rust_vec_bool();\n size_t c_return_identity(size_t n);\n size_t c_return_sum(size_t n1, size_t n2);\n Enum c_return_enum(uint16_t n);\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -71,6 +71,8 @@ fn test_c_return() {\n             .map(|o| o.z)\n             .sum(),\n     );\n+    assert_eq!(b\"\\x02\\0\\x02\\0\"[..], ffi::c_return_rust_vec_u8());\n+    assert_eq!([true, true, false][..], ffi::c_return_rust_vec_bool());\n     assert_eq!(2020, ffi::c_return_identity(2020));\n     assert_eq!(2021, ffi::c_return_sum(2020, 1));\n     match ffi::c_return_enum(0) {\n",
        "problem_statement": "[Feature Request] Support Vec<bool>\nCan we please add support for Vec<bool>? There shouldn't be any special magic required, and though #169 claims to have fixed it, the snippet below doesn't work in any post-`1.0.0` version of `cxx` I tried.\r\n\r\n```\r\n#[cxx::bridge]\r\nmod ffi {\r\n    unsafe extern \"C++\" {\r\n        fn gimme_vecbool() -> Vec<bool>;\r\n    }\r\n}\r\n```\r\n\r\nCurrently, the only workaround I know about is wrapping the `bool` in a structure, which works but is annoying to work with.\n",
        "hints_text": "",
        "created_at": "2022-09-28T00:44:09Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 482,
        "instance_id": "dtolnay__cxx-482",
        "issue_numbers": [
            "345"
        ],
        "base_commit": "f47403fccd1222f407fe316aad1a5a3cb0c777cf",
        "patch": "diff --git a/book/book.toml b/book/book.toml\n--- a/book/book.toml\n+++ b/book/book.toml\n@@ -16,3 +16,7 @@ cname = \"cxx.rs\"\n git-repository-url = \"https://github.com/dtolnay/cxx\"\n playground = { copyable = false }\n print = { enable = false }\n+\n+[output.html.redirect]\n+\"binding/index.html\" = \"../bindings.html\"\n+\"build/index.html\" = \"../building.html\"\ndiff --git a/book/src/SUMMARY.md b/book/src/SUMMARY.md\n--- a/book/src/SUMMARY.md\n+++ b/book/src/SUMMARY.md\n@@ -1,3 +1,35 @@\n # Summary\n \n-[Rust \u2764\ufe0f C++](about.md)\n+- [Rust \u2764\ufe0f C++](index.md)\n+\n+- [Core concepts](concepts.md)\n+\n+- [Tutorial](tutorial.md)\n+\n+- [Other Rust&ndash;C++ interop tools](context.md)\n+\n+- [Multi-language build system options](building.md)\n+    - [Cargo](build/cargo.md)\n+    - [Bazel](build/bazel.md)\n+    - [CMake](build/cmake.md)\n+    - [More...](build/other.md)\n+\n+- [Reference: the bridge module](reference.md)\n+    - [extern \"Rust\"](extern-rust.md)\n+    - [extern \"C++\"](extern-c++.md)\n+    - [Shared types](shared.md)\n+    - [Attributes](attributes.md)\n+    - [Async functions](async.md)\n+    - [Error handling](binding/result.md)\n+\n+- [Reference: built-in bindings](bindings.md)\n+    - [String &mdash; rust::String](binding/string.md)\n+    - [&str &mdash; rust::Str](binding/str.md)\n+    - [&&#91;T&#93; &mdash; rust::Slice\\<const T\\>](binding/slice.md)\n+    - [CxxString &mdash; std::string](binding/cxxstring.md)\n+    - [Box\\<T\\> &mdash; rust::Box\\<T\\>](binding/box.md)\n+    - [UniquePtr\\<T\\> &mdash; std::unique\\_ptr\\<T\\>](binding/uniqueptr.md)\n+    - [Vec\\<T\\> &mdash; rust::Vec\\<T\\>](binding/vec.md)\n+    - [CxxVector\\<T\\> &mdash; std::vector\\<T\\>](binding/cxxvector.md)\n+    - [Function pointers](binding/fn.md)\n+    - [Result\\<T\\>](binding/result.md)\ndiff --git a/book/src/about.md /dev/null\n--- a/book/src/about.md\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-### Coming soon\ndiff --git /dev/null b/book/src/async.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/async.md\n@@ -0,0 +1,86 @@\n+{{#title Async functions \u2014 Rust \u2661 C++}}\n+# Async functions\n+\n+Direct FFI of async functions is absolutely in scope for CXX (on C++20 and up)\n+but is not implemented yet in the current release. We are aiming for an\n+implementation that is as easy as:\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+        async fn doThing(arg: Arg) -> Ret;\n+    }\n+}\n+```\n+\n+```cpp,hidelines\n+rust::Future<Ret> doThing(Arg arg) {\n+  auto v1 = co_await f();\n+  auto v2 = co_await g(arg);\n+  co_return v1 + v2;\n+}\n+```\n+\n+## Workaround\n+\n+For now the recommended approach is to handle the return codepath over a oneshot\n+channel (such as [`futures::channel::oneshot`]) represented in an opaque Rust\n+type on the FFI.\n+\n+[`futures::channel::oneshot`]: https://docs.rs/futures/0.3.8/futures/channel/oneshot/index.html\n+\n+```rust,noplayground\n+// bridge.rs\n+\n+use futures::channel::oneshot;\n+\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"Rust\" {\n+        type DoThingContext;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"path/to/bridge_shim.h\");\n+\n+        fn shim_doThing(\n+            arg: Arg,\n+            done: fn(Box<DoThingContext>, ret: Ret),\n+            ctx: Box<DoThingContext>,\n+        );\n+    }\n+}\n+\n+struct DoThingContext(oneshot::Sender<Ret>);\n+\n+pub async fn do_thing(arg: Arg) -> Ret {\n+    let (tx, rx) = oneshot::channel();\n+    let context = Box::new(DoThingContext(tx));\n+\n+    ffi::shim_doThing(\n+        arg,\n+        |tx, ret| { let _ = tx.0.send(ret); },\n+        context,\n+    );\n+\n+    rx.await.unwrap()\n+}\n+```\n+\n+```cpp\n+// bridge_shim.cc\n+\n+#include \"path/to/bridge.rs.h\"\n+#include \"rust/cxx.h\"\n+\n+void shim_doThing(\n+    Arg arg,\n+    rust::Fn<void(rust::Box<DoThingContext> ctx, Ret ret)> done,\n+    rust::Box<DoThingContext> ctx) noexcept {\n+  doThing(arg)\n+      .then([done, ctx(std::move(ctx))](auto &&res) mutable {\n+        (*done)(std::move(ctx), std::move(res));\n+      });\n+}\n+```\ndiff --git /dev/null b/book/src/attributes.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/attributes.md\n@@ -0,0 +1,74 @@\n+{{#title Attributes \u2014 Rust \u2661 C++}}\n+# Attributes\n+\n+## namespace\n+\n+The top-level cxx::bridge attribute macro takes an optional `namespace` argument\n+to control the C++ namespace into which to emit extern Rust items and the\n+namespace in which to expect to find the extern C++ items.\n+\n+```rust,noplayground\n+#[cxx::bridge(namespace = \"path::of::my::company\")]\n+mod ffi {\n+    extern \"Rust\" {\n+        type MyType;  // emitted to path::of::my::company::MyType\n+    }\n+\n+    extern \"C++\" {\n+        type TheirType;  // refers to path::of::my::company::TheirType\n+    }\n+}\n+```\n+\n+Additionally, a `#[namespace = \"...\"]` attribute may be used inside the bridge\n+module on any extern block or individual item. An item will inherit the\n+namespace specified on its surrounding extern block if any, otherwise the\n+namespace specified with the top level cxx::bridge attribute if any, otherwise\n+the global namespace.\n+\n+```rust,noplayground\n+#[cxx::bridge(namespace = \"third_priority\")]\n+mod ffi {\n+    #[namespace = \"second_priority\"]\n+    extern \"Rust\" {\n+        fn f();\n+\n+        #[namespace = \"first_priority\"]\n+        fn g();\n+    }\n+\n+    extern \"Rust\" {\n+        fn h();\n+    }\n+}\n+```\n+\n+The above would result in functions `::second_priority::f`,\n+`::first_priority::g`, `::third_priority::h`.\n+\n+## rust\\_name, cxx\\_name\n+\n+Sometimes you want the Rust name of a function to differ from its C++ name.\n+Importantly, this enables binding multiple overloads of the same C++ function\n+name using distinct Rust names.\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+        #[rust_name = \"i32_overloaded_function\"]\n+        fn cOverloadedFunction(x: i32) -> String;\n+        #[rust_name = \"str_overloaded_function\"]\n+        fn cOverloadedFunction(x: &str) -> String;\n+    }\n+}\n+```\n+\n+The `#[rust_name = \"...\"]` attribute replaces the name that Rust should use for\n+this function, and an analogous `#[cxx_name = \"...\"]` attribute replaces the\n+name that C++ should use.\n+\n+Either of the two attributes may be used on extern \"Rust\" as well as extern\n+\"C++\" functions, according to which one you find clearer in context.\n+\n+Support for renaming type names and enum variants is not implemented yet.\ndiff --git /dev/null b/book/src/binding/box.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/binding/box.md\n@@ -0,0 +1,120 @@\n+{{#title rust::Box<T> \u2014 Rust \u2661 C++}}\n+# rust::Box\\<T\\>\n+\n+### Public API:\n+\n+```cpp,hidelines\n+// rust/cxx.h\n+#\n+# #include <type_traits>\n+#\n+# namespace rust {\n+\n+template <typename T>\n+class Box final {\n+public:\n+  using value_type = T;\n+  using const_pointer =\n+      typename std::add_pointer<typename std::add_const<T>::type>::type;\n+  using pointer = typename std::add_pointer<T>::type;\n+\n+  Box(const Box &);\n+  Box(Box &&) noexcept;\n+  ~Box() noexcept;\n+\n+  explicit Box(const T &);\n+  explicit Box(T &&);\n+\n+  Box &operator=(const Box &);\n+  Box &operator=(Box &&) noexcept;\n+\n+  const T *operator->() const noexcept;\n+  const T &operator*() const noexcept;\n+  T *operator->() noexcept;\n+  T &operator*() noexcept;\n+\n+  template <typename... Fields>\n+  static Box in_place(Fields &&...);\n+\n+  // Important: requires that `raw` came from an into_raw call. Do not\n+  // pass a pointer from `new` or any other source.\n+  static Box from_raw(T *) noexcept;\n+\n+  T *into_raw() noexcept;\n+};\n+#\n+# } // namespace rust\n+```\n+\n+### Restrictions:\n+\n+Box\\<T\\> does not support T being an opaque C++ type. You should use\n+[UniquePtr\\<T\\>](uniqueptr.md) instead for transferring ownership of opaque C++\n+types on the language boundary.\n+\n+If T is an opaque Rust type, the Rust type is required to be [Sized] i.e. size\n+known at compile time. In the future we may introduce support for dynamically\n+sized opaque Rust types.\n+\n+[Sized]: https://doc.rust-lang.org/std/marker/trait.Sized.html\n+\n+## Example\n+\n+This program uses a Box to pass ownership of some opaque piece of Rust state\n+over to C++ and then back to a Rust callback, which is a useful pattern for\n+implementing [async functions over FFI](../async.md).\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+use std::io::Write;\n+\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"Rust\" {\n+        type File;\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"example/include/example.h\");\n+\n+        fn f(\n+            callback: fn(Box<File>, fst: &str, snd: &str),\n+            out: Box<File>,\n+        );\n+    }\n+}\n+\n+pub struct File(std::fs::File);\n+\n+fn main() {\n+    let out = std::fs::File::create(\"example.log\").unwrap();\n+\n+    ffi::f(\n+        |mut out, fst, snd| { let _ = write!(out.0, \"{}{}\\n\", fst, snd); },\n+        Box::new(File(out)),\n+    );\n+}\n+```\n+\n+```cpp\n+// include/example.h\n+\n+#pragma once\n+#include \"example/src/main.rs.h\"\n+#include \"rust/cxx.h\"\n+\n+void f(rust::Fn<void(rust::Box<File>, rust::Str, rust::Str)> callback,\n+       rust::Box<File> out);\n+```\n+\n+```cpp\n+// include/example.cc\n+\n+#include \"example/include/example.h\"\n+\n+void f(rust::Fn<void(rust::Box<File>, rust::Str, rust::Str)> callback,\n+       rust::Box<File> out) {\n+  callback(std::move(out), \"fearless\", \"concurrency\");\n+}\n+```\ndiff --git /dev/null b/book/src/binding/cxxstring.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/binding/cxxstring.md\n@@ -0,0 +1,137 @@\n+{{#title std::string \u2014 Rust \u2661 C++}}\n+# std::string\n+\n+The Rust binding of std::string is called **[`CxxString`]**. See the link for\n+documentation of the Rust API.\n+\n+[`CxxString`]: https://docs.rs/cxx/*/cxx/struct.CxxString.html\n+\n+### Restrictions:\n+\n+Rust code can never obtain a CxxString by value. C++'s string requires a move\n+constructor and may hold internal pointers, which is not compatible with Rust's\n+move behavior. Instead in Rust code we will only ever look at a CxxString\n+through a reference or smart pointer, as in &CxxString or Pin\\<&mut CxxString\\>\n+or UniquePtr\\<CxxString\\>.\n+\n+In order to construct a CxxString on the stack from Rust, you must use the\n+[`let_cxx_string!`] macro which will pin the string properly. The code below\n+uses this in one place, and the link covers the syntax.\n+\n+[`let_cxx_string!`]: https://docs.rs/cxx/*/cxx/macro.let_cxx_string.html\n+\n+## Example\n+\n+This example uses C++17's std::variant to build a toy JSON type. JSON can hold\n+various types including strings, and JSON's object type is a map with string\n+keys. The example demonstrates Rust indexing into one of those maps.\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+use cxx::let_cxx_string;\n+\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+        include!(\"example/include/json.h\");\n+\n+        type json;\n+        type object;\n+\n+        fn isNull(self: &json) -> bool;\n+        fn isNumber(self: &json) -> bool;\n+        fn isString(self: &json) -> bool;\n+        fn isArray(self: &json) -> bool;\n+        fn isObject(self: &json) -> bool;\n+\n+        fn getNumber(self: &json) -> f64;\n+        fn getString(self: &json) -> &CxxString;\n+        fn getArray(self: &json) -> &CxxVector<json>;\n+        fn getObject(self: &json) -> &object;\n+\n+        #[cxx_name = \"at\"]  // https://en.cppreference.com/w/cpp/container/map/at\n+        fn get<'a>(self: &'a object, key: &CxxString) -> &'a json;\n+\n+        fn load_config() -> UniquePtr<json>;\n+    }\n+}\n+\n+fn main() {\n+    let config = ffi::load_config();\n+\n+    let_cxx_string!(key = \"name\");\n+    println!(\"{}\", config.getObject().get(&key).getString());\n+}\n+```\n+\n+```cpp\n+// include/json.h\n+\n+#pragma once\n+#include <map>\n+#include <memory>\n+#include <variant>\n+#include <vector>\n+\n+class json final {\n+public:\n+  static const json null;\n+  using number = double;\n+  using string = std::string;\n+  using array = std::vector<json>;\n+  using object = std::map<string, json>;\n+\n+  json() noexcept = default;\n+  json(const json &) = default;\n+  json(json &&) = default;\n+  template <typename... T>\n+  json(T &&... value) : value(std::forward<T>(value)...) {}\n+\n+  bool isNull() const;\n+  bool isNumber() const;\n+  bool isString() const;\n+  bool isArray() const;\n+  bool isObject() const;\n+\n+  number getNumber() const;\n+  const string &getString() const;\n+  const array &getArray() const;\n+  const object &getObject() const;\n+\n+private:\n+  std::variant<std::monostate, number, string, array, object> value;\n+};\n+\n+using object = json::object;\n+\n+std::unique_ptr<json> load_config();\n+```\n+\n+```cpp\n+// include/json.cc\n+\n+#include \"example/include/json.h\"\n+#include <initializer_list>\n+#include <utility>\n+\n+const json json::null{};\n+bool json::isNull() const { return std::holds_alternative<std::monostate>(value); }\n+bool json::isNumber() const { return std::holds_alternative<number>(value); }\n+bool json::isString() const { return std::holds_alternative<string>(value); }\n+bool json::isArray() const { return std::holds_alternative<array>(value); }\n+bool json::isObject() const { return std::holds_alternative<object>(value); }\n+json::number json::getNumber() const { return std::get<number>(value); }\n+const json::string &json::getString() const { return std::get<string>(value); }\n+const json::array &json::getArray() const { return std::get<array>(value); }\n+const json::object &json::getObject() const { return std::get<object>(value); }\n+\n+std::unique_ptr<json> load_config() {\n+  return std::make_unique<json>(\n+      std::in_place_type<json::object>,\n+      std::initializer_list<std::pair<const std::string, json>>{\n+          {\"name\", \"cxx-example\"},\n+          {\"edition\", 2018.},\n+          {\"repository\", json::null}});\n+}\n+```\ndiff --git /dev/null b/book/src/binding/cxxvector.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/binding/cxxvector.md\n@@ -0,0 +1,62 @@\n+{{#title std::vector<T> \u2014 Rust \u2661 C++}}\n+# std::vector\\<T\\>\n+\n+The Rust binding of std::vector\\<T\\> is called **[`CxxVector<T>`]**. See the\n+link for documentation of the Rust API.\n+\n+[`CxxVector<T>`]: https://docs.rs/cxx/*/cxx/struct.CxxVector.html\n+\n+### Restrictions:\n+\n+Rust code can never obtain a CxxVector by value. Instead in Rust code we will\n+only ever look at a vector behind a reference or smart pointer, as in\n+&CxxVector\\<T\\> or UniquePtr\\<CxxVector\\<T\\>\\>.\n+\n+CxxVector\\<T\\> does not support T being an opaque Rust type. You should use a\n+Vec\\<T\\> (C++ rust::Vec\\<T\\>) instead for collections of opaque Rust types on\n+the language boundary.\n+\n+## Example\n+\n+This program involves Rust code converting a `CxxVector<CxxString>` (i.e.\n+`std::vector<std::string>`) into a Rust `Vec<String>`.\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+#![no_main] // main defined in C++ by main.cc\n+\n+use cxx::{CxxString, CxxVector};\n+\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"Rust\" {\n+        fn f(vec: &CxxVector<CxxString>);\n+    }\n+}\n+\n+fn f(vec: &CxxVector<CxxString>) {\n+    let vec: Vec<String> = vec\n+        .iter()\n+        .map(|s| s.to_string_lossy().into_owned())\n+        .collect();\n+    g(&vec);\n+}\n+\n+fn g(vec: &[String]) {\n+    println!(\"{:?}\", vec);\n+}\n+```\n+\n+```cpp\n+// src/main.cc\n+\n+#include \"example/src/main.rs.h\"\n+#include <string>\n+#include <vector>\n+\n+int main() {\n+  std::vector<std::string> vec{\"fearless\", \"concurrency\"};\n+  f(vec);\n+}\n+```\ndiff --git /dev/null b/book/src/binding/fn.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/binding/fn.md\n@@ -0,0 +1,34 @@\n+{{#title Function pointers \u2014 Rust \u2661 C++}}\n+# Function pointers\n+\n+### Public API:\n+\n+```cpp,hidelines\n+// rust/cxx.h\n+#\n+# namespace rust {\n+\n+template <typename Signature>\n+class Fn;\n+\n+template <typename Ret, typename... Args>\n+class Fn<Ret(Args...)> final {\n+public:\n+  Ret operator()(Args... args) const noexcept;\n+  Fn operator*() const noexcept;\n+};\n+#\n+# } // namespace rust\n+```\n+\n+### Restrictions:\n+\n+Function pointers with a Result return type are not implemented yet.\n+\n+Passing a function pointer from C++ to Rust is not implemented yet, only from\n+Rust to an `extern \"C++\"` function is implemented.\n+\n+## Example\n+\n+Function pointers are commonly useful for implementing [async functions over\n+FFI](../async.md). See the example code on that page.\ndiff --git /dev/null b/book/src/binding/result.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/binding/result.md\n@@ -0,0 +1,148 @@\n+{{#title Result<T> \u2014 Rust \u2661 C++}}\n+# Result\\<T\\>\n+\n+Result\\<T\\> is allowed as the return type of an extern function in either\n+direction. Its behavior is to translate to/from C++ exceptions. If your codebase\n+does not use C++ exceptions, or prefers to represent fallibility using something\n+like outcome\\<T\\>, leaf::result\\<T\\>, StatusOr\\<T\\>, etc then you'll need to\n+handle the translation of those to Rust Result\\<T\\> using your own shims for\n+now. Better support for this is planned.\n+\n+If an exception is thrown from an `extern \"C++\"` function that is *not* declared\n+by the CXX bridge to return Result, the program calls C++'s `std::terminate`.\n+The behavior is equivalent to the same exception being thrown through a\n+`noexcept` C++ function.\n+\n+If a panic occurs in *any* `extern \"Rust\"` function, regardless of whether it is\n+declared by the CXX bridge to return Result, a message is logged and the program\n+calls Rust's `std::process::abort`.\n+\n+## Returning Result from Rust to C++\n+\n+An `extern \"Rust\"` function returning a Result turns into a `throw` in C++ if\n+the Rust side produces an error.\n+\n+Note that the return type written inside of cxx::bridge must be written without\n+a second type parameter. Only the Ok type is specified for the purpose of the\n+FFI. The Rust *implementation* (outside of the bridge module) may pick any error\n+type as long as it has a std::fmt::Display impl.\n+\n+```rust,noplayground\n+# use std::io;\n+#\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"Rust\" {\n+        fn fallible1(depth: usize) -> Result<String>;\n+        fn fallible2() -> Result<()>;\n+    }\n+}\n+\n+fn fallible1(depth: usize) -> anyhow::Result<String> {\n+    if depth == 0 {\n+        return Err(anyhow::Error::msg(\"fallible1 requires depth > 0\"));\n+    }\n+    ...\n+}\n+\n+fn fallible2() -> Result<(), io::Error> {\n+    ...\n+    Ok(())\n+}\n+```\n+\n+The exception that gets thrown by CXX on the C++ side is always of type\n+`rust::Error` and has the following C++ public API. The `what()` member function\n+gives the error message according to the Rust error's std::fmt::Display impl.\n+\n+```cpp,hidelines\n+// rust/cxx.h\n+#\n+# namespace rust {\n+\n+class Error final : public std::exception {\n+public:\n+  Error(const Error &);\n+  Error(Error &&) noexcept;\n+  ~Error() noexcept;\n+\n+  Error &operator=(const Error &);\n+  Error &operator=(Error &&) noexcept;\n+\n+  const char *what() const noexcept override;\n+};\n+#\n+# } // namespace rust\n+```\n+\n+## Returning Result from C++ to Rust\n+\n+An `extern \"C++\"` function returning a Result turns into a `catch` in C++ that\n+converts the exception into an Err for Rust.\n+\n+Note that the return type written inside of cxx::bridge must be written without\n+a second type parameter. Only the Ok type is specified for the purpose of the\n+FFI. The resulting error type created by CXX when an `extern \"C++\"` function\n+throws will always be of type **[`cxx::Exception`]**.\n+\n+[`cxx::Exception`]: https://docs.rs/cxx/*/cxx/struct.Exception.html\n+\n+```rust,noplayground\n+# use std::process;\n+#\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+        include!(\"example/include/example.h\");\n+        fn fallible1(depth: usize) -> Result<String>;\n+        fn fallible2() -> Result<()>;\n+    }\n+}\n+\n+fn main() {\n+    if let Err(err) = ffi::fallible1(99) {\n+        eprintln!(\"Error: {}\", err);\n+        process::exit(1);\n+    }\n+}\n+```\n+\n+The specific set of caught exceptions and the conversion to error message are\n+both customizable. The way you do this is by defining a template function\n+`rust::behavior::trycatch` with a suitable signature inside any one of the\n+headers `include!`'d by your cxx::bridge.\n+\n+The template signature is required to be:\n+\n+```cpp,hidelines\n+namespace rust {\n+namespace behavior {\n+\n+template <typename Try, typename Fail>\n+static void trycatch(Try &&func, Fail &&fail) noexcept;\n+\n+} // namespace behavior\n+} // namespace rust\n+```\n+\n+The default `trycatch` used by CXX if you have not provided your own is the\n+following. You must follow the same pattern: invoke `func` with no arguments,\n+catch whatever exception(s) you want, and invoke `fail` with the error message\n+you'd like for the Rust error to have.\n+\n+```cpp,hidelines\n+# #include <exception>\n+#\n+# namespace rust {\n+# namespace behavior {\n+#\n+template <typename Try, typename Fail>\n+static void trycatch(Try &&func, Fail &&fail) noexcept try {\n+  func();\n+} catch (const std::exception &e) {\n+  fail(e.what());\n+}\n+#\n+# } // namespace behavior\n+# } // namespace rust\n+```\ndiff --git /dev/null b/book/src/binding/slice.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/binding/slice.md\n@@ -0,0 +1,115 @@\n+{{#title rust::Slice<T> \u2014 Rust \u2661 C++}}\n+# rust::Slice\\<T\\>\n+\n+### Public API:\n+\n+```cpp,hidelines\n+// rust/cxx.h\n+#\n+# namespace rust {\n+\n+template <typename T>\n+class Slice final {\n+public:\n+  Slice() noexcept;\n+  Slice(const Slice<T> &) noexcept;\n+  Slice(T *, size_t count) noexcept;\n+\n+  Slice &operator=(const Slice<T> &) noexcept;\n+\n+  T *data() const noexcept;\n+  size_t size() const noexcept;\n+  size_t length() const noexcept;\n+};\n+#\n+# } // namespace rust\n+```\n+\n+### Restrictions:\n+\n+Only &amp;\\[u8\\] i.e. rust::Slice\\<const uint8\\_t\\> is currently implemented.\n+Support for arbitrary &amp;\\[T\\] is coming.\n+\n+Allowed as function argument or return value. Not supported in shared structs.\n+&amp;mut \\[T\\] is not supported yet.\n+\n+## Example\n+\n+This example is a C++ program that constructs a slice containing JSON data (by\n+reading from stdin, but it could be from anywhere), then calls into Rust to\n+pretty-print that JSON data into a std::string via the [serde_json] and\n+[serde_transcode] crates.\n+\n+[serde_json]: https://github.com/serde-rs/json\n+[serde_transcode]: https://github.com/sfackler/serde-transcode\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+#![no_main] // main defined in C++ by main.cc\n+\n+use cxx::CxxString;\n+use std::io::{self, Write};\n+use std::pin::Pin;\n+\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"Rust\" {\n+        fn prettify_json(input: &[u8], output: Pin<&mut CxxString>) -> Result<()>;\n+    }\n+}\n+\n+struct WriteToCxxString<'a>(Pin<&'a mut CxxString>);\n+\n+impl<'a> Write for WriteToCxxString<'a> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.as_mut().push_bytes(buf);\n+        Ok(buf.len())\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+fn prettify_json(input: &[u8], output: Pin<&mut CxxString>) -> serde_json::Result<()> {\n+    let writer = WriteToCxxString(output);\n+    let mut deserializer = serde_json::Deserializer::from_slice(input);\n+    let mut serializer = serde_json::Serializer::pretty(writer);\n+    serde_transcode::transcode(&mut deserializer, &mut serializer)\n+}\n+```\n+\n+```cpp\n+// src/main.cc\n+\n+#include \"example/src/main.rs.h\"\n+#include <iostream>\n+#include <iterator>\n+#include <string>\n+#include <vector>\n+\n+int main() {\n+  // Read json from stdin.\n+  std::istreambuf_iterator<char> begin{std::cin}, end;\n+  std::vector<unsigned char> input{begin, end};\n+  rust::Slice<const uint8_t> slice{input.data(), input.size()};\n+\n+  // Prettify using serde_json and serde_transcode.\n+  std::string output;\n+  prettify_json(slice, output);\n+\n+  // Write to stdout.\n+  std::cout << output << std::endl;\n+}\n+```\n+\n+Testing the example:\n+\n+```console\n+$  echo '{\"fearless\":\"concurrency\"}' | cargo run\n+    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n+     Running `target/debug/example`\n+{\n+  \"fearless\": \"concurrency\"\n+}\n+```\ndiff --git /dev/null b/book/src/binding/str.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/binding/str.md\n@@ -0,0 +1,101 @@\n+{{#title rust::Str \u2014 Rust \u2661 C++}}\n+# rust::Str\n+\n+### Public API:\n+\n+```cpp,hidelines\n+// rust/cxx.h\n+#\n+# #include <iosfwd>\n+# #include <string>\n+#\n+# namespace rust {\n+\n+class Str final {\n+public:\n+  Str() noexcept;\n+  Str(const Str &) noexcept;\n+\n+  // Throws std::invalid_argument if not utf-8.\n+  Str(const std::string &);\n+  Str(const char *);\n+  Str(const char *, size_t);\n+  Str(std::string &&) = delete;\n+\n+  Str &operator=(const Str &) noexcept;\n+\n+  explicit operator std::string() const;\n+\n+  // Note: no null terminator.\n+  const char *data() const noexcept;\n+  size_t size() const noexcept;\n+  size_t length() const noexcept;\n+};\n+\n+std::ostream &operator<<(std::ostream &, const Str &);\n+#\n+# } // namespace rust\n+```\n+\n+### Notes:\n+\n+**Be aware that rust::Str behaves like &amp;str i.e. it is a borrow!**&ensp;C++\n+needs to be mindful of the lifetimes at play.\n+\n+Just to reiterate: &amp;str is rust::Str. Do not try to write &amp;str as `const\n+rust::Str &`. A language-level C++ reference is not able to capture the fat\n+pointer nature of &amp;str.\n+\n+### Restrictions:\n+\n+Allowed as function argument or return value. Not supported in shared structs\n+yet. `&mut str` is not supported yet, but is also extremely obscure so this is\n+fine.\n+\n+## Example\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"Rust\" {\n+        fn r(greeting: &str);\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"example/include/greeting.h\");\n+        fn c(greeting: &str);\n+    }\n+}\n+\n+fn r(greeting: &str) {\n+    println!(\"{}\", greeting);\n+}\n+\n+fn main() {\n+    ffi::c(\"hello from Rust\");\n+}\n+```\n+\n+```cpp\n+// include/greeting.h\n+\n+#pragma once\n+#include \"example/src/main.rs.h\"\n+#include \"rust/cxx.h\"\n+\n+void c(rust::Str greeting);\n+```\n+\n+```cpp\n+// src/greeting.cc\n+\n+#include \"example/include/greeting.h\"\n+#include <iostream>\n+\n+void c(rust::Str greeting) {\n+  std::cout << greeting << std::endl;\n+  r(\"hello from C++\");\n+}\n+```\ndiff --git /dev/null b/book/src/binding/string.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/binding/string.md\n@@ -0,0 +1,94 @@\n+{{#title rust::String \u2014 Rust \u2661 C++}}\n+# rust::String\n+\n+### Public API:\n+\n+```cpp,hidelines\n+// rust/cxx.h\n+#\n+# #include <iosfwd>\n+# #include <string>\n+#\n+# namespace rust {\n+\n+class String final {\n+public:\n+  String() noexcept;\n+  String(const String &) noexcept;\n+  String(String &&) noexcept;\n+  ~String() noexcept;\n+\n+  // Throws std::invalid_argument if not utf-8.\n+  String(const std::string &);\n+  String(const char *);\n+  String(const char *, size_t);\n+\n+  String &operator=(const String &) noexcept;\n+  String &operator=(String &&) noexcept;\n+\n+  explicit operator std::string() const;\n+\n+  // Note: no null terminator.\n+  const char *data() const noexcept;\n+  size_t size() const noexcept;\n+  size_t length() const noexcept;\n+};\n+\n+std::ostream &operator<<(std::ostream &, const String &);\n+#\n+# } // namespace rust\n+```\n+\n+### Restrictions:\n+\n+None. Strings may be used as function arguments and function return values, by\n+value or by reference, as well as fields of shared structs.\n+\n+## Example\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+#[cxx::bridge]\n+mod ffi {\n+    struct ConcatRequest {\n+        fst: String,\n+        snd: String,\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"example/include/concat.h\");\n+        fn concat(r: ConcatRequest) -> String;\n+    }\n+}\n+\n+fn main() {\n+    let concatenated = ffi::concat(ffi::ConcatRequest {\n+        fst: \"fearless\".to_owned(),\n+        snd: \"concurrency\".to_owned(),\n+    });\n+    println!(\"concatenated: {:?}\", concatenated);\n+}\n+```\n+\n+```cpp\n+// include/concat.h\n+\n+#pragma once\n+#include \"example/src/main.rs.h\"\n+#include \"rust/cxx.h\"\n+\n+rust::String concat(ConcatRequest r);\n+```\n+\n+```cpp\n+// src/concat.cc\n+\n+#include \"example/include/concat.h\"\n+\n+rust::String concat(ConcatRequest r) {\n+  // The full suite of operator overloads hasn't been added\n+  // yet on rust::String, but we can get it done like this:\n+  return std::string(r.fst) + std::string(r.snd);\n+}\n+```\ndiff --git /dev/null b/book/src/binding/uniqueptr.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/binding/uniqueptr.md\n@@ -0,0 +1,63 @@\n+{{#title std::unique_ptr<T> \u2014 Rust \u2661 C++}}\n+# std::unique\\_ptr\\<T\\>\n+\n+The Rust binding of std::unique\\_ptr\\<T\\> is called **[`UniquePtr<T>`]**. See\n+the link for documentation of the Rust API.\n+\n+[`UniquePtr<T>`]: https://docs.rs/cxx/*/cxx/struct.UniquePtr.html\n+\n+### Restrictions:\n+\n+Only `std::unique_ptr<T, std::default_delete<T>>` is currently supported. Custom\n+deleters may be supported in the future.\n+\n+UniquePtr\\<T\\> does not support T being an opaque Rust type. You should use a\n+Box\\<T\\> (C++ [rust::Box\\<T\\>](box.md)) instead for transferring ownership of\n+opaque Rust types on the language boundary.\n+\n+## Example\n+\n+UniquePtr is commonly useful for returning opaque C++ objects to Rust. This use\n+case was featured in the [*blobstore tutorial*](../tutorial.md).\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+        include!(\"example/include/blobstore.h\");\n+\n+        type BlobstoreClient;\n+\n+        fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;\n+        // ...\n+    }\n+}\n+\n+fn main() {\n+    let client = ffi::new_blobstore_client();\n+    // ...\n+}\n+```\n+\n+```cpp\n+// include/blobstore.h\n+\n+#pragma once\n+#include <memory>\n+\n+class BlobstoreClient;\n+\n+std::unique_ptr<BlobstoreClient> new_blobstore_client();\n+```\n+\n+```cpp\n+// src/blobstore.cc\n+\n+#include \"example/include/blobstore.h\"\n+\n+std::unique_ptr<BlobstoreClient> new_blobstore_client() {\n+  return std::make_unique<BlobstoreClient>();\n+}\n+```\ndiff --git /dev/null b/book/src/binding/vec.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/binding/vec.md\n@@ -0,0 +1,128 @@\n+{{#title rust::Vec<T> \u2014 Rust \u2661 C++}}\n+# rust::Vec\\<T\\>\n+\n+### Public API:\n+\n+```cpp,hidelines\n+// rust/cxx.h\n+#\n+# #include <iterator>\n+# #include <type_traits>\n+#\n+# namespace rust {\n+\n+template <typename T>\n+class Vec final {\n+public:\n+  using value_type = T;\n+\n+  Vec() noexcept;\n+  Vec(Vec &&) noexcept;\n+  ~Vec() noexcept;\n+\n+  Vec &operator=(Vec &&) noexcept;\n+\n+  size_t size() const noexcept;\n+  bool empty() const noexcept;\n+  const T *data() const noexcept;\n+  T *data() noexcept;\n+\n+  const T &operator[](size_t n) const noexcept;\n+  const T &at(size_t n) const;\n+\n+  const T &front() const;\n+  const T &back() const;\n+\n+  void reserve(size_t new_cap);\n+  void push_back(const T &value);\n+  void push_back(T &&value);\n+  template <typename... Args>\n+  void emplace_back(Args &&... args);\n+\n+  class const_iterator final {\n+  public:\n+    using difference_type = ptrdiff_t;\n+    using value_type = typename std::add_const<T>::type;\n+    using pointer =\n+        typename std::add_pointer<typename std::add_const<T>::type>::type;\n+    using reference = typename std::add_lvalue_reference<\n+        typename std::add_const<T>::type>::type;\n+    using iterator_category = std::forward_iterator_tag;\n+\n+    const T &operator*() const noexcept;\n+    const T *operator->() const noexcept;\n+    const_iterator &operator++() noexcept;\n+    const_iterator operator++(int) noexcept;\n+    bool operator==(const const_iterator &) const noexcept;\n+    bool operator!=(const const_iterator &) const noexcept;\n+  };\n+\n+  const_iterator begin() const noexcept;\n+  const_iterator end() const noexcept;\n+};\n+#\n+# } // namespace rust\n+```\n+\n+### Restrictions:\n+\n+Vec\\<T\\> does not support T being an opaque C++ type. You should use\n+CxxVector\\<T\\> (C++ std::vector\\<T\\>) instead for collections of opaque C++\n+types on the language boundary.\n+\n+## Example\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+#[cxx::bridge]\n+mod ffi {\n+    struct Shared {\n+        v: u32,\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"example/include/example.h\");\n+\n+        fn f(elements: Vec<Shared>);\n+    }\n+}\n+\n+fn main() {\n+    let shared = |v| ffi::Shared { v };\n+    let elements = vec![shared(3), shared(2), shared(1)];\n+    ffi::f(elements);\n+}\n+```\n+\n+```cpp\n+// include/example.h\n+\n+#pragma once\n+#include \"example/src/main.rs.h\"\n+#include \"rust/cxx.h\"\n+\n+void f(rust::Vec<Shared> elements);\n+```\n+\n+```cpp\n+// src/example.cc\n+\n+#include \"example/include/example.h\"\n+#include <algorithm>\n+#include <cassert>\n+#include <iostream>\n+#include <iterator>\n+#include <vector>\n+\n+void f(rust::Vec<Shared> v) {\n+  for (auto shared : v) {\n+    std::cout << shared.v << std::endl;\n+  }\n+\n+  // Copy the elements to a C++ std::vector using STL algorithm.\n+  std::vector<Shared> stdv;\n+  std::copy(v.begin(), v.end(), std::back_inserter(stdv));\n+  assert(v.size() == stdv.size());\n+}\n+```\ndiff --git /dev/null b/book/src/bindings.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/bindings.md\n@@ -0,0 +1,54 @@\n+{{#title Built-in bindings \u2014 Rust \u2661 C++}}\n+# Built-in bindings reference\n+\n+In addition to all the primitive types (i32 &lt;=&gt; int32_t), the following\n+common types may be used in the fields of shared structs and the arguments and\n+returns of extern functions.\n+\n+<br>\n+\n+<table>\n+<tr><th>name in Rust</th><th>name in C++</th><th>restrictions</th></tr>\n+<tr><td style=\"padding:3px 6px\">String</td><td style=\"padding:3px 6px\"><b><a href=\"binding/string.md\">rust::String</a></b></td><td style=\"padding:3px 6px\"></td></tr>\n+<tr><td style=\"padding:3px 6px\">&amp;str</td><td style=\"padding:3px 6px\"><b><a href=\"binding/str.md\">rust::Str</a></b></td><td style=\"padding:3px 6px\"></td></tr>\n+<tr><td style=\"padding:3px 6px\">&amp;[u8]</td><td style=\"padding:3px 6px\"><b><a href=\"binding/slice.md\">rust::Slice&lt;const&nbsp;uint8_t&gt;</a></b></td><td style=\"padding:3px 6px\"><sup><i>arbitrary &amp;[T] not implemented yet</i></sup></td></tr>\n+<tr><td style=\"padding:3px 6px\"><b><a href=\"binding/cxxstring.md\">CxxString</a></b></td><td style=\"padding:3px 6px\">std::string</td><td style=\"padding:3px 6px\"><sup><i>cannot be passed by value</i></sup></td></tr>\n+<tr><td style=\"padding:3px 6px\">Box&lt;T&gt;</td><td style=\"padding:3px 6px\"><b><a href=\"binding/box.md\">rust::Box&lt;T&gt;</a></b></td><td style=\"padding:3px 6px\"><sup><i>cannot hold opaque C++ type</i></sup></td></tr>\n+<tr><td style=\"padding:3px 6px\"><b><a href=\"binding/uniqueptr.md\">UniquePtr&lt;T&gt;</a></b></td><td style=\"padding:3px 6px\">std::unique_ptr&lt;T&gt;</td><td style=\"padding:3px 6px\"><sup><i>cannot hold opaque Rust type</i></sup></td></tr>\n+<tr><td style=\"padding:3px 6px\">Vec&lt;T&gt;</td><td style=\"padding:3px 6px\"><b><a href=\"binding/vec.md\">rust::Vec&lt;T&gt;</a></b></td><td style=\"padding:3px 6px\"><sup><i>cannot hold opaque C++ type</i></sup></td></tr>\n+<tr><td style=\"padding:3px 6px\"><b><a href=\"binding/cxxvector.md\">CxxVector&lt;T&gt;</a></b></td><td style=\"padding:3px 6px\">std::vector&lt;T&gt;</td><td style=\"padding:3px 6px\"><sup><i>cannot be passed by value, cannot hold opaque Rust type</i></sup></td></tr>\n+<tr><td style=\"padding:3px 6px\">fn(T, U) -&gt; V</td><td style=\"padding:3px 6px\"><b><a href=\"binding/fn.md\">rust::Fn&lt;V(T, U)&gt;</a></b></td><td style=\"padding:3px 6px\"><sup><i>only passing from Rust to C++ is implemented so far</i></sup></td></tr>\n+<tr><td style=\"padding:3px 6px\"><b><a href=\"binding/result.md\">Result&lt;T&gt;</a></b></td><td style=\"padding:3px 6px\">throw/catch</td><td style=\"padding:3px 6px\"><sup><i>allowed as return type only</i></sup></td></tr>\n+</table>\n+\n+<br>\n+\n+The C++ API of the `rust` namespace is defined by the *include/cxx.h* file in\n+the CXX GitHub repo. You will need to include this header in your C++ code when\n+working with those types. **When using Cargo and the cxx-build crate, the header\n+is made available to you at `#include \"rust/cxx.h\"`.**\n+\n+The `rust` namespace additionally provides lowercase type aliases of all the\n+types mentioned in the table, for use in codebases preferring that style. For\n+example `rust::String`, `rust::Vec` may alternatively be written `rust::string`,\n+`rust::vec` etc.\n+\n+## Pending bindings\n+\n+The following types are intended to be supported \"soon\" but are just not\n+implemented yet. I don't expect any of these to be hard to make work but it's a\n+matter of designing a nice API for each in its non-native language.\n+\n+<br>\n+\n+<table>\n+<tr><th>name in Rust</th><th>name in C++</th></tr>\n+<tr><td>&amp;mut [T]</td><td>rust::Slice&lt;T&gt;</td></tr>\n+<tr><td>BTreeMap&lt;K, V&gt;</td><td><sup><i>tbd</i></sup></td></tr>\n+<tr><td>HashMap&lt;K, V&gt;</td><td><sup><i>tbd</i></sup></td></tr>\n+<tr><td>Arc&lt;T&gt;</td><td><sup><i>tbd</i></sup></td></tr>\n+<tr><td>Option&lt;T&gt;</td><td><sup><i>tbd</i></sup></td></tr>\n+<tr><td><sup><i>tbd</i></sup></td><td>std::map&lt;K, V&gt;</td></tr>\n+<tr><td><sup><i>tbd</i></sup></td><td>std::unordered_map&lt;K, V&gt;</td></tr>\n+<tr><td><sup><i>tbd</i></sup></td><td>std::shared_ptr&lt;T&gt;</td></tr>\n+</table>\ndiff --git /dev/null b/book/src/build/cargo.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/build/cargo.md\n@@ -0,0 +1,306 @@\n+{{#title Cargo-based setup \u2014 Rust \u2661 C++}}\n+# Cargo-based builds\n+\n+As one aspect of delivering a good Rust&ndash;C++ interop experience, CXX turns\n+Cargo into a quite usable build system for C++ projects published as a\n+collection of crates.io packages, including a consistent and frictionless\n+experience `#include`-ing C++ headers across dependencies.\n+\n+## Canonical setup\n+\n+CXX's integration with Cargo is handled through the [cxx-build] crate.\n+\n+[cxx-build]: https://docs.rs/cxx-build\n+\n+```toml,hidelines\n+## Cargo.toml\n+# [package]\n+# name = \"...\"\n+# version = \"...\"\n+# edition = \"2018\"\n+\n+[dependencies]\n+cxx = \"1.0\"\n+\n+[build-dependencies]\n+cxx-build = \"1.0\"\n+```\n+\n+The canonical build script is as follows. The indicated line returns a\n+[`cc::Build`] instance (from the usual widely used `cc` crate) on which you can\n+set up any additional source files and compiler flags as normal.\n+\n+[`cc::Build`]: https://docs.rs/cc/1.0/cc/struct.Build.html\n+\n+```rust,noplayground\n+// build.rs\n+\n+fn main() {\n+    cxx_build::bridge(\"src/main.rs\")  // returns a cc::Build\n+        .file(\"src/demo.cc\")\n+        .flag_if_supported(\"-std=c++11\")\n+        .compile(\"cxxbridge-demo\");\n+\n+    println!(\"cargo:rerun-if-changed=src/main.rs\");\n+    println!(\"cargo:rerun-if-changed=src/demo.cc\");\n+    println!(\"cargo:rerun-if-changed=include/demo.h\");\n+}\n+```\n+\n+The `rerun-if-changed` lines are optional but make it so that Cargo does not\n+spend time recompiling your C++ code when only non-C++ code has changed since\n+the previous Cargo build. By default without any `rerun-if-changed`, Cargo will\n+re-execute the build script after *any* file changed in the project.\n+\n+If stuck, try comparing what you have against the *demo/* directory of the CXX\n+GitHub repo, which maintains a working Cargo-based setup for the blobstore\n+tutorial (chapter 3).\n+\n+## Header include paths\n+\n+With cxx-build, by default your include paths always start with the crate name.\n+This applies to both `#include` within your C++ code, and `include!` in the\n+`extern \"C++\"` section of your Rust cxx::bridge.\n+\n+Your crate name is determined by the `name` entry in Cargo.toml.\n+\n+For example if your crate is named `yourcratename` and contains a C++ header\n+file `path/to/header.h` relative to Cargo.toml, that file will be includable as:\n+\n+```cpp\n+#include \"yourcratename/path/to/header.h\"\n+```\n+\n+A crate can choose a prefix for its headers that is different from the crate\n+name by modifying **[`CFG.include_prefix`][CFG]** from build.rs:\n+\n+[CFG]: https://docs.rs/cxx-build/*/cxx_build/static.CFG.html\n+\n+```rust,noplayground\n+// build.rs\n+\n+use cxx_build::CFG;\n+\n+fn main() {\n+    CFG.include_prefix = \"my/project\";\n+\n+    cxx_build::bridge(...)...\n+}\n+```\n+\n+Subsequently the header located at `path/to/header.h` would now be includable\n+as:\n+\n+```cpp\n+#include \"my/project/path/to/header.h\"\n+```\n+\n+The empty string `\"\"` is a valid include prefix and will make it possible to\n+have `#include \"path/to/header.h\"`. However, if your crate is a library, be\n+considerate of possible name collisions that may occur in downstream crates. If\n+using an empty include prefix, you'll want to make sure your headers' local path\n+within the crate is sufficiently namespaced or unique.\n+\n+## Including generated code\n+\n+If your `#[cxx::bridge]` module contains an `extern \"Rust\"` block i.e. types or\n+functions exposed from Rust to C++, or any shared data structures, the\n+CXX-generated C++ header declaring those things is available using a `.rs.h`\n+extension on the Rust source file's name.\n+\n+```cpp\n+// the header generated from path/to/lib.rs\n+#include \"yourcratename/path/to/lib.rs.h\"\n+```\n+\n+For giggles, it's also available using just a plain `.rs` extension as if you\n+were including the Rust file directly. Use whichever you find more palatable.\n+\n+```cpp\n+#include \"yourcratename/path/to/lib.rs\"\n+```\n+\n+## Including headers from dependencies\n+\n+You get to include headers from your dependencies, both handwritten ones\n+contained as `.h` files in their Cargo package, as well as CXX-generated ones.\n+\n+It works the same as an include of a local header: use the crate name (or their\n+include\\_prefix if their crate changed it) followed by the relative path of the\n+header within the crate.\n+\n+```cpp\n+#include \"dependencycratename/path/to/their/header.h`\n+```\n+\n+Note that cross-crate imports are only made available between **direct\n+dependencies**. You must directly depend on the other crate in order to #include\n+its headers; a transitive dependency is not sufficient.\n+\n+Additionally, headers from a direct dependency are only importable if the\n+dependency's Cargo.toml manifest contains a `links` key. If not, its headers\n+will not be importable from outside of the same crate. See *[the `links`\n+manifest key][links]* in the Cargo reference.\n+\n+[links]: https://doc.rust-lang.org/cargo/reference/build-scripts.html#the-links-manifest-key\n+\n+<br><br><br>\n+\n+# Advanced features\n+\n+The following CFG settings are only relevant to you if you are writing a library\n+that needs to support downstream crates `#include`-ing its C++ public headers.\n+\n+## Publicly exporting header directories\n+\n+**[`CFG.exported_header_dirs`][CFG]** (vector of absolute paths) defines a set\n+of additional directories from which the current crate, directly dependent\n+crates, and further crates to which this crate's headers are exported (more\n+below) will be able to `#include` headers.\n+\n+Adding a directory to `exported_header_dirs` is similar to adding it to the\n+current build via the `cc` crate's [`Build::include`], but *also* makes the\n+directory available to downstream crates that want to `#include` one of the\n+headers from your crate. If the dir were added only using `Build::include`, the\n+downstream crate including your header would need to manually add the same\n+directory to their own build as well.\n+\n+[`Build::include`]: https://docs.rs/cc/1/cc/struct.Build.html#method.include\n+\n+When using `exported_header_dirs`, your crate must also set a `links` key for\n+itself in Cargo.toml. See [*the `links` manifest key*][links]. The reason is\n+that Cargo imposes no ordering on the execution of build scripts without a\n+`links` key, which means the downstream crate's build script might otherwise\n+execute before yours decides what to put into `exported_header_dirs`.\n+\n+### Example\n+\n+One of your crate's headers wants to include a system library, such as `#include\n+\"Python.h\"`.\n+\n+```rust,noplayground\n+// build.rs\n+\n+use cxx_build::CFG;\n+use std::path::PathBuf;\n+\n+fn main() {\n+    let python3 = pkg_config::probe_library(\"python3\").unwrap();\n+    let python_include_paths = python3.include_paths.iter().map(PathBuf::as_path);\n+    CFG.exported_header_dirs.extend(python_include_paths);\n+\n+    cxx_build::bridge(\"src/bridge.rs\").compile(\"demo\");\n+}\n+```\n+\n+### Example\n+\n+Your crate wants to rearrange the headers that it exports vs how they're laid\n+out locally inside the crate's source directory.\n+\n+Suppose the crate as published contains a file at `./include/myheader.h` but\n+wants it available to downstream crates as `#include \"foo/v1/public.h\"`.\n+\n+```rust,noplayground\n+// build.rs\n+\n+use cxx_build::CFG;\n+use std::path::Path;\n+use std::{env, fs};\n+\n+fn main() {\n+    let out_dir = env::var_os(\"OUT_DIR\").unwrap();\n+    let headers = Path::new(&out_dir).join(\"headers\");\n+    CFG.exported_header_dirs.push(&headers);\n+\n+    // We contain `include/myheader.h` locally, but\n+    // downstream will use `#include \"foo/v1/public.h\"`\n+    let foo = headers.join(\"foo\").join(\"v1\");\n+    fs::create_dir_all(&foo).unwrap();\n+    fs::copy(\"include/myheader.h\", foo.join(\"public.h\")).unwrap();\n+\n+    cxx_build::bridge(\"src/bridge.rs\").compile(\"demo\");\n+}\n+```\n+\n+## Publicly exporting dependencies\n+\n+**[`CFG.exported_header_prefixes`][CFG]** (vector of strings) each refer to the\n+`include_prefix` of one of your direct dependencies, or a prefix thereof. They\n+describe which of your dependencies participate in your crate's C++ public API,\n+as opposed to private use by your crate's implementation.\n+\n+As a general rule, if one of your headers `#include`s something from one of your\n+dependencies, you need to put that dependency's `include_prefix` into\n+`CFG.exported_header_prefixes` (*or* their `links` key into\n+`CFG.exported_header_links`; see below). On the other hand if only your C++\n+implementation files and *not* your headers are importing from the dependency,\n+you do not export that dependency.\n+\n+The significance of exported headers is that if downstream code (crate **\ud835\udc9c**)\n+contains an `#include` of a header from your crate (**\u212c**) and your header\n+contains an `#include` of something from your dependency (**\ud835\udc9e**), the exported\n+dependency **\ud835\udc9e** becomes available during the downstream crate **\ud835\udc9c**'s build.\n+Otherwise the downstream crate **\ud835\udc9c** doesn't know about **\ud835\udc9e** and wouldn't be\n+able to find what header your header is referring to, and would fail to build.\n+\n+When using `exported_header_prefixes`, your crate must also set a `links` key\n+for itself in Cargo.toml.\n+\n+### Example\n+\n+Suppose you have a crate with 5 direct dependencies and the `include_prefix` for\n+each one are:\n+\n+- \"crate0\"\n+- \"group/api/crate1\"\n+- \"group/api/crate2\"\n+- \"group/api/contrib/crate3\"\n+- \"detail/crate4\"\n+\n+Your header involves types from the first four so we re-export those as part of\n+your public API, while crate4 is only used internally by your cc file not your\n+header, so we do not export:\n+\n+```rust,noplayground\n+// build.rs\n+\n+use cxx_build::CFG;\n+\n+fn main() {\n+    CFG.exported_header_prefixes = vec![\"crate0\", \"group/api\"];\n+\n+    cxx_build::bridge(\"src/bridge.rs\")\n+        .file(\"src/impl.cc\")\n+        .compile(\"demo\");\n+}\n+```\n+\n+<br>\n+\n+For more fine grained control, there is **[`CFG.exported_header_links`][CFG]**\n+(vector of strings) which each refer to the `links` attribute ([*the `links`\n+manifest key*][links]) of one of your crate's direct dependencies.\n+\n+This achieves an equivalent result to `CFG.exported_header_prefixes` by\n+re-exporting a C++ dependency as part of your crate's public API, except with\n+finer control for cases when multiple crates might be sharing the same\n+`include_prefix` and you'd like to export some but not others. Links attributes\n+are guaranteed to be unique identifiers by Cargo.\n+\n+When using `exported_header_links`, your crate must also set a `links` key for\n+itself in Cargo.toml.\n+\n+### Example\n+\n+```rust,noplayground\n+// build.rs\n+\n+use cxx_build::CFG;\n+\n+fn main() {\n+    CFG.exported_header_links.push(\"git2\");\n+\n+    cxx_build::bridge(\"src/bridge.rs\").compile(\"demo\");\n+}\n+```\ndiff --git /dev/null b/book/src/build/cmake.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/build/cmake.md\n@@ -0,0 +1,24 @@\n+{{#title CMake \u2014 Rust \u2661 C++}}\n+# CMake\n+\n+There is not an officially endorsed CMake setup for CXX, but a few developers\n+have shared one that they got working. You can try one of these as a starting\n+point. If you feel that you have arrived at a CMake setup that is superior to\n+what is available in these links, feel free to make a PR adding it to this list.\n+\n+<br>\n+\n+---\n+\n+- **<https://github.com/XiangpengHao/cxx-cmake-example>**\n+\n+  - Supports cross-language link time optimization (LTO)\n+\n+---\n+\n+- **<https://github.com/david-cattermole/cxx-demo-example>**\n+\n+  - Includes a cbindgen component\n+  - Tested on Windows 10 with MSVC, and on Linux\n+\n+---\ndiff --git /dev/null b/book/src/build/other.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/build/other.md\n@@ -0,0 +1,75 @@\n+{{#title Other build systems \u2014 Rust \u2661 C++}}\n+# Some other build system\n+\n+You will need to achieve at least these three things:\n+\n+- Produce the CXX-generated C++ bindings code.\n+- Compile the generated C++ code.\n+- Link the resulting objects together with your other C++ and Rust objects.\n+\n+### Producing the generated code\n+\n+CXX's Rust code generation automatically happens when the `#[cxx::bridge]`\n+procedural macro is expanded during the normal Rust compilation process, so no\n+special build steps are required there.\n+\n+But the C++ side of the bindings needs to be generated. Your options are:\n+\n+- Use the `cxxbridge` command, which is a standalone command line interface to\n+  the CXX C++ code generator. Wire up your build system to compile and invoke\n+  this tool.\n+\n+  ```console\n+  $  cxxbridge src/bridge.rs --header > path/to/bridge.rs.h\n+  $  cxxbridge src/bridge.rs > path/to/bridge.rs.cc\n+  ```\n+\n+  It's packaged as the `cxxbridge-cmd` crate on crates.io or can be built from\n+  the *gen/cmd/* directory of the CXX GitHub repo.\n+\n+- Or, build your own code generator frontend on top of the [cxx-gen] crate. This\n+  is currently unofficial and unsupported.\n+\n+[cxx-gen]: https://docs.rs/cxx-gen\n+\n+### Compiling C++\n+\n+However you like. We can provide no guidance.\n+\n+### Linking the C++ and Rust together\n+\n+When linking a binary which contains mixed Rust and C++ code, you will have to\n+choose between using the Rust toolchain (`rustc`) or the C++ toolchain which you\n+may already have extensively tuned.\n+\n+Rust does not generate simple standalone `.o` files, so you can't just throw the\n+Rust-generated code into your existing C++ toolchain linker. Instead you need to\n+choose one of these options:\n+\n+* Use `rustc` as the final linker. Pass any non-Rust libraries using `-L\n+  <directory>` and `-l<library>` rustc arguments, and/or `#[link]` directives in\n+  your Rust code. If you need to link against C/C++ `.o` files you can use\n+  `-Clink-arg=file.o`.\n+\n+* Use your C++ linker. In this case, you first need to use `rustc` and/or\n+  `cargo` to generate a _single_ Rust `staticlib` target and pass that into your\n+  foreign linker invocation.\n+\n+  * If you need to link multiple Rust subsystems, you will need to generate a\n+    _single_ `staticlib` perhaps using lots of `extern crate` statements to\n+    include multiple Rust `rlib`s.  Multiple Rust `staticlib` files are likely\n+    to conflict.\n+\n+Passing Rust `rlib`s directly into your non-Rust linker is not supported (but\n+apparently sometimes works).\n+\n+See the [Rust reference's *Linkage*][linkage] page for some general information\n+here.\n+\n+[linkage]: https://doc.rust-lang.org/reference/linkage.html\n+\n+The following open rust-lang issues might hold more recent guidance or\n+inspiration: [rust-lang/rust#73632], [rust-lang/rust#73295].\n+\n+[rust-lang/rust#73632]: https://github.com/rust-lang/rust/issues/73632\n+[rust-lang/rust#73295]: https://github.com/rust-lang/rust/issues/73295\ndiff --git /dev/null b/book/src/building.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/building.md\n@@ -0,0 +1,20 @@\n+{{#title Multi-language build system options \u2014 Rust \u2661 C++}}\n+# Multi-language build system options\n+\n+CXX is designed to be convenient to integrate into a variety of build systems.\n+\n+If you are working in a project that does not already have a preferred build\n+system for its C++ code *or* which will be relying heavily on open source\n+libraries from the Rust package registry, you're likely to have the easiest\n+experience with Cargo which is the build system commonly used by open source\n+Rust projects. Refer to the ***[Cargo](build/cargo.md)*** chapter about CXX's\n+Cargo support.\n+\n+Among build systems designed for first class multi-language support, Bazel is a\n+solid choice. Refer to the ***[Bazel](build/bazel.md)*** chapter.\n+\n+If your codebase is already invested in CMake, refer to the\n+***[CMake](build/cmake.md)*** chapter.\n+\n+If you have some other build system that you'd like to try to make work with\n+CXX, see [this page](build/other.md) for notes.\ndiff --git /dev/null b/book/src/concepts.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/concepts.md\n@@ -0,0 +1,85 @@\n+{{#title Core concepts \u2014 Rust \u2661 C++}}\n+# Core concepts\n+\n+This page is a brief overview of the major concepts of CXX, enough so that you\n+recognize the shape of things as you read the tutorial and following chapters.\n+\n+In CXX, the language of the FFI boundary involves 3 kinds of items:\n+\n+- **Shared structs** &mdash; data structures whose fields are made visible to\n+  both languages. The definition written within cxx::bridge in Rust is usually\n+  the single source of truth, though there are ways to do sharing based on a\n+  bindgen-generated definition with C++ as source of truth.\n+\n+- **Opaque types** &mdash; their fields are secret from the other language.\n+  These cannot be passed across the FFI by value but only behind an indirection,\n+  such as a reference `&`, a Rust `Box`, or a C++ `unique_ptr`. Can be a type\n+  alias for an arbitrarily complicated generic language-specific type depending\n+  on your use case.\n+\n+- **Functions** &mdash; implemented in either language, callable from the other\n+  language.\n+\n+```rust,noplayground,focuscomment\n+# #[cxx::bridge]\n+# mod ffi {\n+    // Any shared structs, whose fields will be visible to both languages.\n+#     struct BlobMetadata {\n+#         size: usize,\n+#         tags: Vec<String>,\n+#     }\n+#\n+#     extern \"Rust\" {\n+        // Zero or more opaque types which both languages can pass around\n+        // but only Rust can see the fields.\n+#         type MultiBuf;\n+#\n+        // Functions implemented in Rust.\n+#         fn next_chunk(buf: &mut MultiBuf) -> &[u8];\n+#     }\n+#\n+#     unsafe extern \"C++\" {\n+        // One or more headers with the matching C++ declarations for the\n+        // enclosing extern \"C++\" block. Our code generators don't read it\n+        // but it gets #include'd and used in static assertions to ensure\n+        // our picture of the FFI boundary is accurate.\n+#         include!(\"demo/include/blobstore.h\");\n+#\n+        // Zero or more opaque types which both languages can pass around\n+        // but only C++ can see the fields.\n+#         type BlobstoreClient;\n+#\n+        // Functions implemented in C++.\n+#         fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;\n+#         fn put(&self, parts: &mut MultiBuf) -> u64;\n+#         fn tag(&self, blobid: u64, tag: &str);\n+#         fn metadata(&self, blobid: u64) -> BlobMetadata;\n+#     }\n+# }\n+```\n+\n+Within the `extern \"Rust\"` part of the CXX bridge we list the types and\n+functions for which Rust is the source of truth. These all implicitly refer to\n+the `super` module, the parent module of the CXX bridge. You can think of the\n+two items listed in the example above as being like `use super::MultiBuf` and\n+`use super::next_chunk` except re-exported to C++. The parent module will either\n+contain the definitions directly for simple things, or contain the relevant\n+`use` statements to bring them into scope from elsewhere.\n+\n+Within the `extern \"C++\"` part, we list types and functions for which C++ is the\n+source of truth, as well as the header(s) that declare those APIs. In the future\n+it's possible that this section could be generated bindgen-style from the\n+headers but for now we need the signatures written out; static assertions verify\n+that they are accurate.\n+\n+<br><br>\n+\n+Be aware that the design of this library is intentionally restrictive and\n+opinionated! It isn't a goal to be flexible enough to handle an arbitrary\n+signature in either language. Instead this project is about carving out a highly\n+expressive set of functionality about which we can make powerful safety\n+guarantees today and extend over time. You may find that it takes some practice\n+to use CXX bridge effectively as it won't work in all the ways that you may be\n+used to.\n+\n+<br>\ndiff --git /dev/null b/book/src/extern-c++.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/extern-c++.md\n@@ -0,0 +1,315 @@\n+{{#title extern \"C++\" \u2014 Rust \u2661 C++}}\n+# extern \"C++\"\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"C++\" {\n+        include!(\"path/to/header.h\");\n+        include!(\"path/to/another.h\");\n+\n+        ...\n+    }\n+}\n+```\n+\n+The `extern \"C++\"` section of a CXX bridge declares C++ types and signatures to\n+be made available to Rust, and gives the paths of the header(s) which contain\n+the corresponding C++ declarations.\n+\n+A bridge module may contain zero or more extern \"C++\" blocks.\n+\n+## Opaque C++ types\n+\n+Type defined in C++ that are made available to Rust, but only behind an\n+indirection.\n+\n+```rust,noplayground\n+# #[cxx::bridge]\n+# mod ffi {\n+    extern \"C++\" {\n+        # include!(\"path/to/header.h\");\n+        #\n+        type MyType;\n+        type MyOtherType;\n+    }\n+# }\n+```\n+\n+For example in the ***[Tutorial](tutorial.md)*** we saw `BlobstoreClient`\n+implemented as an opaque C++ type. The blobstore client was created in C++ and\n+returned to Rust by way of a UniquePtr.\n+\n+**Mutability:** Unlike extern Rust types and shared types, an extern C++ type is\n+not permitted to be passed by plain mutable reference `&mut MyType` across the\n+FFI bridge. For mutation support, the bridge is required to use `Pin<&mut\n+MyType>`. This is to safeguard against things like mem::swap-ing the contents of\n+two mutable references, given that Rust doesn't have information about the size\n+of the underlying object and couldn't invoke an appropriate C++ move constructor\n+anyway.\n+\n+**Thread safety:** Be aware that CXX does not assume anything about the thread\n+safety of your extern C++ types. In other words the `MyType` etc bindings which\n+CXX produces for you in Rust *do not* come with `Send` and `Sync` impls. If you\n+are sure that your C++ type satisfies the requirements of `Send` and/or `Sync`\n+and need to leverage that fact from Rust, you must provide your own unsafe\n+marker trait impls.\n+\n+```rust,noplayground\n+# #[cxx::bridge]\n+# mod ffi {\n+#     extern \"C++\" {\n+#         include!(\"path/to/header.h\");\n+#\n+#         type MyType;\n+#     }\n+# }\n+#\n+/// The C++ implementation of MyType is thread safe.\n+unsafe impl Send for ffi::MyType {}\n+unsafe impl Sync for ffi::MyType {}\n+```\n+\n+Take care in doing this because thread safety in C++ can be extremely tricky to\n+assess if you are coming from a Rust background. For example the\n+`BlobstoreClient` type in the tutorial is *not thread safe* despite doing only\n+completely innocuous things in its implementation. Concurrent calls to the `tag`\n+member function trigger a data race on the `blobs` map.\n+\n+## Functions and member functions\n+\n+This largely follows the same principles as ***[extern\n+\"Rust\"](extern-rust.md)*** functions and methods. In particular, any signature\n+with a `self` parameter is interpreted as a C++ non-static member function and\n+exposed to Rust as a method.\n+\n+The programmer **does not** need to promise that the signatures they have typed\n+in are accurate; that would be unreasonable. CXX performs static assertions that\n+the signatures exactly correspond with what is declared in C++. Rather, the\n+programmer is only on the hook for things that C++'s static information is not\n+precise enough to capture, i.e. things that would only be represented at most by\n+comments in the C++ code unintelligible to a static assertion: namely whether\n+the C++ function is safe or unsafe to be called from Rust.\n+\n+**Safety:** the extern \"C++\" block is responsible for deciding whether to expose\n+each signature inside as safe-to-call or unsafe-to-call. If an extern block\n+contains at least one safe-to-call signature, it must be written as an `unsafe\n+extern` block, which serves as an item level unsafe block to indicate that an\n+unchecked safety claim is being made about the contents of the block.\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+        # include!(\"path/to/header.h\");\n+        #\n+        fn f();  // safe to call\n+    }\n+\n+    extern \"C++\" {\n+        unsafe fn g();  // unsafe to call\n+    }\n+}\n+```\n+\n+\n+## Reusing existing binding types\n+\n+Extern C++ types support a syntax for declaring that a Rust binding of the\n+correct C++ type already exists outside of the current bridge module. This\n+avoids generating a fresh new binding which Rust's type system would consider\n+non-interchangeable with the first.\n+\n+```rust,noplayground\n+#[cxx::bridge(namespace = \"path::to\")]\n+mod ffi {\n+    extern \"C++\" {\n+        type MyType = crate::existing::MyType;\n+    }\n+\n+    extern \"Rust\" {\n+        fn f(x: &MyType) -> usize;\n+    }\n+}\n+```\n+\n+In this case rather than producing a unique new Rust type `ffi::MyType` for the\n+Rust binding of C++'s `::path::to::MyType`, CXX will reuse the already existing\n+binding at `crate::existing::MyType` in expressing the signature of `f` and any\n+other uses of `MyType` within the bridge module.\n+\n+CXX safely validates that `crate::existing::MyType` is in fact a binding for the\n+right C++ type `::path::to::MyType` by generating a static assertion based on\n+`crate::existing::MyType`'s implementation of [`ExternType`], which is a trait\n+automatically implemented by CXX for bindings that it generates but can also be\n+manually implemented as described below.\n+\n+[`ExternType`]: https://docs.rs/cxx/*/cxx/trait.ExternType.html\n+\n+`ExternType` serves the following two related use cases.\n+\n+#### Safely unifying occurrences of an extern type across bridges\n+\n+In the following snippet, two #\\[cxx::bridge\\] invocations in different files\n+(possibly different crates) both contain function signatures involving the same\n+C++ type `example::Demo`. If both were written just containing `type Demo;`,\n+then both macro expansions would produce their own separate Rust type called\n+`Demo` and thus the compiler wouldn't allow us to take the `Demo` returned by\n+`file1::ffi::create_demo` and pass it as the `Demo` argument accepted by\n+`file2::ffi::take_ref_demo`. Instead, one of the two `Demo`s has been defined as\n+an extern type alias of the other, making them the same type in Rust.\n+\n+```rust,noplayground\n+// file1.rs\n+#[cxx::bridge(namespace = \"example\")]\n+pub mod ffi {\n+    unsafe extern \"C++\" {\n+        type Demo;\n+\n+        fn create_demo() -> UniquePtr<Demo>;\n+    }\n+}\n+```\n+\n+```rust,noplayground\n+// file2.rs\n+#[cxx::bridge(namespace = \"example\")]\n+pub mod ffi {\n+    unsafe extern \"C++\" {\n+        type Demo = crate::file1::ffi::Demo;\n+\n+        fn take_ref_demo(demo: &Demo);\n+    }\n+}\n+```\n+\n+#### Integrating with bindgen-generated or handwritten unsafe bindings\n+\n+Handwritten `ExternType` impls make it possible to plug in a data structure\n+emitted by bindgen as the definition of a C++ type emitted by CXX.\n+\n+By writing the unsafe `ExternType` impl, the programmer asserts that the C++\n+namespace and type name given in the type id refers to a C++ type that is\n+equivalent to Rust type that is the `Self` type of the impl.\n+\n+```rust,noplayground\n+mod folly_sys;  // the bindgen-generated bindings\n+\n+use cxx::{type_id, ExternType};\n+\n+unsafe impl ExternType for folly_sys::StringPiece {\n+    type Id = type_id!(\"folly::StringPiece\");\n+    type Kind = cxx::kind::Opaque;\n+}\n+\n+#[cxx::bridge(namespace = \"folly\")]\n+pub mod ffi {\n+    unsafe extern \"C++\" {\n+        include!(\"rust_cxx_bindings.h\");\n+\n+        type StringPiece = crate::folly_sys::StringPiece;\n+\n+        fn print_string_piece(s: &StringPiece);\n+    }\n+}\n+\n+// Now if we construct a StringPiece or obtain one through one\n+// of the bindgen-generated signatures, we are able to pass it\n+// along to ffi::print_string_piece.\n+```\n+\n+The `ExternType::Id` associated type encodes a type-level representation of the\n+type's C++ namespace and type name. It will always be defined using the\n+`type_id!` macro exposed in the cxx crate.\n+\n+The `ExternType::Kind` associated type will always be either\n+[`cxx::kind::Opaque`] or [`cxx::kind::Trivial`] identifying whether a C++ type\n+is soundly relocatable by Rust's move semantics. A C++ type is only okay to hold\n+and pass around by value in Rust if its [move constructor is trivial] and it has\n+no destructor. In CXX, these are called Trivial extern C++ types, while types\n+with nontrivial move behavior or a destructor must be considered Opaque and\n+handled by Rust only behind an indirection, such as a reference or UniquePtr.\n+\n+[`cxx::kind::Opaque`]: https://docs.rs/cxx/*/cxx/kind/enum.Opaque.html\n+[`cxx::kind::Trivial`]: https://docs.rs/cxx/*/cxx/kind/enum.Trivial.html\n+[move constructor is trivial]: https://en.cppreference.com/w/cpp/types/is_move_constructible\n+\n+If you believe your C++ type reflected by the ExternType impl is indeed fine to\n+hold by value and move in Rust, you can specify:\n+\n+```rust,noplayground\n+# unsafe impl cxx::ExternType for TypeName {\n+#     type Id = cxx::type_id!(\"name::space::of::TypeName\");\n+    type Kind = cxx::kind::Trivial;\n+# }\n+```\n+\n+which will enable you to pass it into C++ functions by value, return it by\n+value, and include it in `struct`s that you have declared to `cxx::bridge`. Your\n+claim about the triviality of the C++ type will be checked by a `static_assert`\n+in the generated C++ side of the binding.\n+\n+## Explicit shim trait impls\n+\n+This is a somewhat niche feature, but important when you need it.\n+\n+CXX's support for C++'s std::unique\\_ptr and std::vector is built on a set of\n+internal trait impls connecting the Rust API of UniquePtr and CxxVector to\n+underlying template instantiations performed by the C++ compiler.\n+\n+When reusing a binding type across multiple bridge modules as described in the\n+previous section, you may find that your code needs some trait impls which CXX\n+hasn't decided to generate.\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi1 {\n+    extern \"C++\" {\n+        include!(\"path/to/header.h\");\n+\n+        type A;\n+        type B;\n+\n+        // Okay: CXX sees UniquePtr<B> using a type B defined within the same\n+        // bridge, and automatically emits the right template instantiations\n+        // corresponding to std::unique_ptr<B>.\n+        fn get_b() -> UniquePtr<B>;\n+    }\n+}\n+\n+#[cxx::bridge]\n+mod ffi2 {\n+    extern \"C++\" {\n+        type A = crate::ffi1::A;\n+\n+        // Rust trait error: CXX processing this module has no visibility into\n+        // whether template instantiations corresponding to std::unique_ptr<A>\n+        // have already been emitted by the upstream library, so it does not\n+        // emit them here. If the upstream library does not have any signatures\n+        // involving UniquePtr<A>, an explicit instantiation of the template\n+        // needs to be requested in one module or the other.\n+        fn get_a() -> UniquePtr<A>;\n+    }\n+}\n+```\n+\n+You can request a specific template instantiation at a particular location in\n+the Rust crate hierarchy by writing `impl UniquePtr<A> {}` inside of the bridge\n+module which defines `A` but does not otherwise contain any use of\n+`UniquePtr<A>`.\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi1 {\n+    extern \"C++\" {\n+        include!(\"path/to/header.h\");\n+\n+        type A;\n+        type B;\n+\n+        fn get_b() -> UniquePtr<B>;\n+    }\n+\n+    impl UniquePtr<A> {}  // explicit instantiation\n+}\n+```\ndiff --git /dev/null b/book/src/extern-rust.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/extern-rust.md\n@@ -0,0 +1,165 @@\n+{{#title extern \"Rust\" \u2014 Rust \u2661 C++}}\n+# extern \"Rust\"\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"Rust\" {\n+\n+    }\n+}\n+```\n+\n+The `extern \"Rust\"` section of a CXX bridge declares Rust types and signatures\n+to be made available to C++.\n+\n+The CXX code generator uses your extern \"Rust\" section(s) to produce a C++\n+header file containing the corresponding C++ declarations. The generated header\n+has the same path as the Rust source file containing the bridge, except with a\n+`.rs.h` file extension.\n+\n+A bridge module may contain zero or more extern \"Rust\" blocks.\n+\n+## Opaque Rust types\n+\n+Types defined in Rust that are made available to C++, but only behind an\n+indirection.\n+\n+```rust,noplayground\n+# #[cxx::bridge]\n+# mod ffi {\n+    extern \"Rust\" {\n+        type MyType;\n+        type MyOtherType;\n+        type OneMoreType;\n+    }\n+# }\n+```\n+\n+For example in the ***[Tutorial](tutorial.md)*** we saw `MultiBuf` used in this\n+way. Rust code created the `MultiBuf`, passed a `&mut MultiBuf` to C++, and C++\n+later passed a `&mut MultiBuf` back across the bridge to Rust.\n+\n+Another example is the one on the ***[Box\\<T\\>](binding/box.md)*** page, which\n+exposes the Rust standard library's `std::fs::File` to C++ as an opaque type in\n+a similar way but with Box as the indirection rather than &mut.\n+\n+The types named as opaque types (`MyType` etc) refer to types in the `super`\n+module, the parent module of the CXX bridge. You can think of an opaque type `T`\n+as being like a re-export `use super::T` made available to C++ via the generated\n+header.\n+\n+Opaque types are currently required to be [`Sized`] and [`Unpin`]. In\n+particular, a trait object `dyn MyTrait` or slice `[T]` may not be used for an\n+opaque Rust type. These restrictions may be lifted in the future.\n+\n+[`Sized`]: https://doc.rust-lang.org/std/marker/trait.Sized.html\n+[`Unpin`]: https://doc.rust-lang.org/std/marker/trait.Unpin.html\n+\n+For now, types used as extern Rust types are required to be defined by the same\n+crate that contains the bridge using them. This restriction may be lifted in the\n+future.\n+\n+The bridge's parent module will contain the appropriate imports or definitions\n+for these types.\n+\n+```rust,noplayground\n+use path::to::MyType;\n+\n+pub struct MyOtherType {\n+    ...\n+}\n+#\n+# #[cxx::bridge]\n+# mod ffi {\n+#     extern \"Rust\" {\n+#         type MyType;\n+#         type MyOtherType;\n+#     }\n+# }\n+```\n+\n+## Functions\n+\n+Rust functions made callable to C++.\n+\n+Just like for opaque types, these functions refer implicitly to something in\n+scope in the `super` module, whether defined there or imported by some `use`\n+statement.\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"Rust\" {\n+        struct MyType;\n+        fn f() -> Box<MyType>;\n+    }\n+}\n+\n+struct MyType(i32);\n+\n+fn f() -> Box<MyType> {\n+    return Box::new(MyType(1));\n+}\n+```\n+\n+Extern Rust function signature may consist of types defined in the bridge,\n+primitives, and [any of these additional bindings](bindings.md).\n+\n+## Methods\n+\n+Any signature with a `self` parameter is interpreted as a Rust method and\n+exposed to C++ as a non-static member function.\n+\n+```rust,noplayground\n+# #[cxx::bridge]\n+# mod ffi {\n+    extern \"Rust\" {\n+        type MyType;\n+        fn f(&self) -> usize;\n+    }\n+# }\n+```\n+\n+The `self` parameter may be a shared reference `&self`, an exclusive reference\n+`&mut self`, or a pinned reference `self: Pin<&mut Self>`. A by-value `self` is\n+not currently supported.\n+\n+If the surrounding `extern \"Rust\"` block contains exactly one extern type, that\n+type is implicitly the receiver for a `&self` or `&mut self` method. If the\n+surrounding block contains *more than one* extern type, a receiver type must be\n+provided explicitly for the self parameter, or you can consider splitting into\n+multiple extern blocks.\n+\n+```rust,noplayground\n+# #[cxx::bridge]\n+# mod ffi {\n+    extern \"Rust\" {\n+        type First;\n+        type Second;\n+        fn bar(self: &First);\n+        fn foo(self: &mut Second);\n+    }\n+# }\n+```\n+\n+## Functions with explicit lifetimes\n+\n+An extern Rust function signature is allowed to contain explicit lifetimes but\n+in this case the function must be declared unsafe-to-call. This is pretty\n+meaningless given we're talking about calls from C++, but at least it draws some\n+extra attention from the caller that they may be responsible for upholding some\n+atypical lifetime relationship.\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"Rust\" {\n+        type MyType;\n+        unsafe fn f<'a>(&'a self, s: &str) -> &'a str;\n+    }\n+}\n+```\n+\n+Bounds on a lifetime (like `<'a, 'b: 'a>`) are not currently supported. Nor are\n+type parameters or where-clauses.\ndiff --git /dev/null b/book/src/index.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/index.md\n@@ -0,0 +1,83 @@\n+<div class=\"badges\">\n+<a href=\"https://github.com/dtolnay/cxx\"><img src=\"https://img.shields.io/badge/github-8da0cb?style=for-the-badge&labelColor=555555&logo=github\" alt=\"github\" height=\"28\" class=\"badge\"></a><a href=\"https://crates.io/crates/cxx\"><img src=\"https://img.shields.io/badge/crates.io-fc8d62?style=for-the-badge&labelColor=555555&logo=rust\" alt=\"crates-io\" height=\"28\" class=\"badge\"></a><a href=\"https://docs.rs/cxx\"><img src=\"https://img.shields.io/badge/docs.rs-66c2a5?style=for-the-badge&labelColor=555555&logoColor=white&logo=data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDUxMiA1MTIiPjxwYXRoIGZpbGw9IiNmNWY1ZjUiIGQ9Ik00ODguNiAyNTAuMkwzOTIgMjE0VjEwNS41YzAtMTUtOS4zLTI4LjQtMjMuNC0zMy43bC0xMDAtMzcuNWMtOC4xLTMuMS0xNy4xLTMuMS0yNS4zIDBsLTEwMCAzNy41Yy0xNC4xIDUuMy0yMy40IDE4LjctMjMuNCAzMy43VjIxNGwtOTYuNiAzNi4yQzkuMyAyNTUuNSAwIDI2OC45IDAgMjgzLjlWMzk0YzAgMTMuNiA3LjcgMjYuMSAxOS45IDMyLjJsMTAwIDUwYzEwLjEgNS4xIDIyLjEgNS4xIDMyLjIgMGwxMDMuOS01MiAxMDMuOSA1MmMxMC4xIDUuMSAyMi4xIDUuMSAzMi4yIDBsMTAwLTUwYzEyLjItNi4xIDE5LjktMTguNiAxOS45LTMyLjJWMjgzLjljMC0xNS05LjMtMjguNC0yMy40LTMzLjd6TTM1OCAyMTQuOGwtODUgMzEuOXYtNjguMmw4NS0zN3Y3My4zek0xNTQgMTA0LjFsMTAyLTM4LjIgMTAyIDM4LjJ2LjZsLTEwMiA0MS40LTEwMi00MS40di0uNnptODQgMjkxLjFsLTg1IDQyLjV2LTc5LjFsODUtMzguOHY3NS40em0wLTExMmwtMTAyIDQxLjQtMTAyLTQxLjR2LS42bDEwMi0zOC4yIDEwMiAzOC4ydi42em0yNDAgMTEybC04NSA0Mi41di03OS4xbDg1LTM4Ljh2NzUuNHptMC0xMTJsLTEwMiA0MS40LTEwMi00MS40di0uNmwxMDItMzguMiAxMDIgMzguMnYuNnoiPjwvcGF0aD48L3N2Zz4K\" alt=\"docs-rs\" height=\"28\" class=\"badge\"></a>\n+</div>\n+\n+# CXX \u2014 safe interop between Rust and C++\n+\n+This library provides a safe mechanism for calling C++ code from Rust and Rust\n+code from C++. It carves out a regime of commonality where Rust and C++ are\n+semantically very similar and guides the programmer to express their language\n+boundary effectively within this regime. CXX fills in the low level stuff so\n+that you get a safe binding, preventing the pitfalls of doing a foreign function\n+interface over unsafe C-style signatures.\n+\n+<div style=\"height:226px;padding:34px 0 24px\">\n+<object type=\"image/svg+xml\" data=\"overview.svg\"></object>\n+</div>\n+\n+From a high level description of the language boundary, CXX uses static analysis\n+of the types and function signatures to protect both Rust's and C++'s\n+invariants. Then it uses a pair of code generators to implement the boundary\n+efficiently on both sides together with any necessary static assertions for\n+later in the build process to verify correctness.\n+\n+The resulting FFI bridge operates at zero or negligible overhead, i.e. no\n+copying, no serialization, no memory allocation, no runtime checks needed.\n+\n+The FFI signatures are able to use native data structures from whichever side\n+they please. In addition, CXX provides builtin bindings for key standard library\n+types like strings, vectors, Box, unique\\_ptr, etc to expose an idiomatic API on\n+those types to the other language.\n+\n+## Example\n+\n+In this example we are writing a Rust application that calls a C++ client of a\n+large-file blobstore service. The blobstore supports a `put` operation for a\n+discontiguous buffer upload. For example we might be uploading snapshots of a\n+circular buffer which would tend to consist of 2 pieces, or fragments of a file\n+spread across memory for some other reason (like a rope data structure).\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"Rust\" {\n+        type MultiBuf;\n+\n+        fn next_chunk(buf: &mut MultiBuf) -> &[u8];\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"example/include/blobstore.h\");\n+\n+        type BlobstoreClient;\n+\n+        fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;\n+        fn put(self: &BlobstoreClient, buf: &mut MultiBuf) -> Result<u64>;\n+    }\n+}\n+```\n+\n+Now we simply provide Rust definitions of all the things in the `extern \"Rust\"`\n+block and C++ definitions of all the things in the `extern \"C++\"` block, and get\n+to call back and forth safely.\n+\n+The [***Tutorial***](tutorial.md) chapter walks through a fleshed out version of\n+this blobstore example in full detail, including all of the Rust code and all of\n+the C++ code. The code is also provided in runnable form in the *demo* directory\n+of <https://github.com/dtolnay/cxx>. To try it out, run `cargo run` from that\n+directory.\n+\n+- [demo/src/main.rs](https://github.com/dtolnay/cxx/blob/master/demo/src/main.rs)\n+- [demo/include/blobstore.h](https://github.com/dtolnay/cxx/blob/master/demo/include/blobstore.h)\n+- [demo/src/blobstore.cc](https://github.com/dtolnay/cxx/blob/master/demo/src/blobstore.cc)\n+\n+The key takeaway, which is enabled by the CXX library, is that the Rust code in\n+main.rs is 100% ordinary safe Rust code working idiomatically with Rust types\n+while the C++ code in blobstore.cc is 100% ordinary C++ code working\n+idiomatically with C++ types. The Rust code feels like Rust and the C++ code\n+feels like C++, not like C-style \"FFI glue\".\n+\n+<br>\n+\n+***Chapter outline:** See the hamburger menu in the top left if you are on a\n+small screen and it didn't open with a sidebar by default.*\ndiff --git /dev/null b/book/src/overview.svg\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/overview.svg\n@@ -0,0 +1,131 @@\n+<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"696\" height=\"224\">\n+    <style>line, path, circle,rect,polygon {\n+                          stroke: black;\n+                          stroke-width: 2;\n+                          stroke-opacity: 1;\n+                          fill-opacity: 1;\n+                          stroke-linecap: round;\n+                          stroke-linejoin: miter;\n+                        }\n+\n+                    text {\n+                        fill: black;\n+                        }\n+                        rect.backdrop{\n+                            stroke: none;\n+                            fill: white;\n+                            fill-opacity: 0;\n+                        }\n+                        .broken{\n+                            stroke-dasharray: 8;\n+                        }\n+                        .filled{\n+                            fill: black;\n+                        }\n+                        .bg_filled{\n+                            fill: white;\n+                        }\n+                        .nofill{\n+                            fill: white;\n+                            fill-opacity: 0;\n+                        }\n+\n+                        text {\n+                         font-family: monospace;\n+                         font-size: 14px;\n+                        }\n+\n+                        .end_marked_arrow{\n+                            marker-end: url(#arrow);\n+                         }\n+                        .start_marked_arrow{\n+                            marker-start: url(#arrow);\n+                         }\n+\n+                        .end_marked_diamond{\n+                            marker-end: url(#diamond);\n+                         }\n+                        .start_marked_diamond{\n+                            marker-start: url(#diamond);\n+                         }\n+\n+                        .end_marked_circle{\n+                            marker-end: url(#circle);\n+                         }\n+                        .start_marked_circle{\n+                            marker-start: url(#circle);\n+                         }\n+\n+                        .end_marked_open_circle{\n+                            marker-end: url(#open_circle);\n+                         }\n+                        .start_marked_open_circle{\n+                            marker-start: url(#open_circle);\n+                         }\n+\n+                        .end_marked_big_open_circle{\n+                            marker-end: url(#big_open_circle);\n+                         }\n+                        .start_marked_big_open_circle{\n+                            marker-start: url(#big_open_circle);\n+                         }\n+\n+                         \n+                        </style>\n+    <defs>\n+        <marker id=\"arrow\" viewBox=\"-2 -2 8 8\" refX=\"4\" refY=\"2\" markerWidth=\"7\" markerHeight=\"7\" orient=\"auto-start-reverse\">\n+            <polygon points=\"0,0 0,4 4,2 0,0\"></polygon>\n+        </marker>\n+        <marker id=\"diamond\" viewBox=\"-2 -2 8 8\" refX=\"4\" refY=\"2\" markerWidth=\"7\" markerHeight=\"7\" orient=\"auto-start-reverse\">\n+            <polygon points=\"0,2 2,0 4,2 2,4 0,2\"></polygon>\n+        </marker>\n+        <marker id=\"circle\" viewBox=\"0 0 8 8\" refX=\"4\" refY=\"4\" markerWidth=\"7\" markerHeight=\"7\" orient=\"auto-start-reverse\">\n+            <circle cx=\"4\" cy=\"4\" r=\"2\" class=\"filled\"></circle>\n+        </marker>\n+        <marker id=\"open_circle\" viewBox=\"0 0 8 8\" refX=\"4\" refY=\"4\" markerWidth=\"7\" markerHeight=\"7\" orient=\"auto-start-reverse\">\n+            <circle cx=\"4\" cy=\"4\" r=\"2\" class=\"bg_filled\"></circle>\n+        </marker>\n+        <marker id=\"big_open_circle\" viewBox=\"0 0 8 8\" refX=\"4\" refY=\"4\" markerWidth=\"7\" markerHeight=\"7\" orient=\"auto-start-reverse\">\n+            <circle cx=\"4\" cy=\"4\" r=\"3\" class=\"bg_filled\"></circle>\n+        </marker>\n+    </defs>\n+    <rect class=\"backdrop\" x=\"0\" y=\"0\" width=\"696\" height=\"224\"></rect>\n+    <rect x=\"148\" y=\"168\" width=\"136\" height=\"32\" class=\"solid nofill\" rx=\"4\"></rect>\n+    <text x=\"162\" y=\"188\" >Rust bindings</text>\n+    <rect x=\"412\" y=\"168\" width=\"128\" height=\"32\" class=\"solid nofill\" rx=\"4\"></rect>\n+    <text x=\"426\" y=\"188\" >C++ bindings</text>\n+    <text x=\"272\" y=\"28\" >#[cxx::bridge] mod</text>\n+    <text x=\"250\" y=\"44\" >description of boundary</text>\n+    <line x1=\"220\" y1=\"120\" x2=\"220\" y2=\"160\" class=\"solid end_marked_arrow\"></line>\n+    <line x1=\"476\" y1=\"120\" x2=\"476\" y2=\"160\" class=\"solid end_marked_arrow\"></line>\n+    <text x=\"74\" y=\"140\" >Safe</text>\n+    <text x=\"34\" y=\"156\" >straightforward</text>\n+    <text x=\"530\" y=\"156\" >Straightforward</text>\n+    <polygon points=\"48,180 40,184 48,188\" class=\"filled\"></polygon>\n+    <line x1=\"48\" y1=\"184\" x2=\"144\" y2=\"184\" class=\"solid end_marked_arrow\"></line>\n+    <polygon points=\"296,180 288,184 296,188\" class=\"filled\"></polygon>\n+    <line x1=\"296\" y1=\"184\" x2=\"408\" y2=\"184\" class=\"broken end_marked_arrow\"></line>\n+    <polygon points=\"552,180 544,184 552,188\" class=\"filled\"></polygon>\n+    <line x1=\"552\" y1=\"184\" x2=\"648\" y2=\"184\" class=\"solid end_marked_arrow\"></line>\n+    <text x=\"2\" y=\"188\" >Rust</text>\n+    <text x=\"2\" y=\"204\" >code</text>\n+    <text x=\"658\" y=\"204\" >code</text>\n+    <text x=\"202\" y=\"108\" >Macro expansion</text>\n+    <text x=\"370\" y=\"108\" >Code generation</text>\n+    <text x=\"58\" y=\"172\" >Rust APIs</text>\n+    <text x=\"298\" y=\"172\" >Hidden C ABI</text>\n+    <text x=\"562\" y=\"172\" >C++ APIs</text>\n+    <text x=\"658\" y=\"188\" >C++</text>\n+    <g>\n+        <path d=\"M 228,8 A 8,8 0,0,0 220,16\" class=\"nofill\"></path>\n+        <line x1=\"228\" y1=\"8\" x2=\"468\" y2=\"8\" class=\"solid\"></line>\n+        <path d=\"M 468,8 A 8,8 0,0,1 476,16\" class=\"nofill\"></path>\n+        <line x1=\"220\" y1=\"16\" x2=\"220\" y2=\"48\" class=\"solid\"></line>\n+        <line x1=\"476\" y1=\"16\" x2=\"476\" y2=\"48\" class=\"solid\"></line>\n+        <path d=\"M 220,48 A 8,8 0,0,0 228,56\" class=\"nofill\"></path>\n+        <line x1=\"228\" y1=\"56\" x2=\"468\" y2=\"56\" class=\"solid\"></line>\n+        <line x1=\"348\" y1=\"56\" x2=\"348\" y2=\"120\" class=\"solid\"></line>\n+        <path d=\"M 476,48 A 8,8 0,0,1 468,56\" class=\"nofill\"></path>\n+        <line x1=\"220\" y1=\"120\" x2=\"476\" y2=\"120\" class=\"solid\"></line>\n+    </g>\n+</svg>\ndiff --git /dev/null b/book/src/reference.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/reference.md\n@@ -0,0 +1,29 @@\n+{{#title The bridge module \u2014 Rust \u2661 C++}}\n+# The bridge module reference\n+\n+The ***[Core concepts](concepts.md)*** in chapter 2 covered the high level model\n+that CXX uses to represent a language boundary. This chapter builds on that one\n+to document an exhaustive reference on the syntax and functionality of\n+\\#\\[cxx::bridge\\].\n+\n+- ***[extern \"Rust\"](extern-rust.md)*** &mdash; exposing opaque Rust types, Rust\n+  functions, Rust methods to C++; functions with lifetimes.\n+\n+- ***[extern \"C++\"](extern-c++.md)*** &mdash; binding opaque C++ types, C++\n+  functions, C++ member functions; sharing an opaque type definition across\n+  multiple bridge modules or different crates; using bindgen-generated data\n+  structures across a CXX bridge; Rust orphan-rule-compatible way to request\n+  that particular glue code be emitted in a specific bridge module.\n+\n+- ***[Shared types](shared.md)*** &mdash; shared structs; shared enums; using\n+  Rust as source of truth vs C++ as source of truth.\n+\n+- ***[Attributes](attributes.md)*** &mdash; working with namespaces; giving\n+  functions a different name in their non-native language.\n+\n+- ***[Async functions](async.md)*** &mdash; integrating async C++ with async\n+  Rust.\n+\n+- ***[Error handling](binding/result.md)*** &mdash; representing fallibility on\n+  the language boundary; accessing a Rust error message from C++; customizing\n+  the set of caught exceptions and their conversion to a Rust error message.\ndiff --git /dev/null b/book/src/shared.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/shared.md\n@@ -0,0 +1,181 @@\n+{{#title Shared types \u2014 Rust \u2661 C++}}\n+# Shared types\n+\n+Shared types enable *both* languages to have visibility into the internals of a\n+type. This is in contrast to opaque Rust types and opaque C++ types, for which\n+only one side gets to manipulate the internals.\n+\n+Unlike opaque types, the FFI bridge is allowed to pass and return shared types\n+by value.\n+\n+The order in which shared types are written is not important. C++ is order\n+sensitive but CXX will topologically sort and forward-declare your types as\n+necessary.\n+\n+## Shared structs and enums\n+\n+For enums, only C-like a.k.a. unit variants are currently supported.\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi {\n+    struct PlayingCard {\n+        suit: Suit,\n+        value: u8,  // A=1, J=11, Q=12, K=13\n+    }\n+\n+    enum Suit {\n+        Clubs,\n+        Diamonds,\n+        Hearts,\n+        Spades,\n+    }\n+\n+    unsafe extern \"C++\" {\n+        fn deck() -> Vec<PlayingCard>;\n+        fn sort(cards: &mut Vec<PlayingCard>);\n+    }\n+}\n+```\n+\n+## The generated data structures\n+\n+Shared structs compile to an aggregate-initialization compatible C++ struct.\n+\n+Shared enums compile to a C++ `enum class` with a sufficiently sized integral\n+base type decided by CXX.\n+\n+```cpp\n+// generated header\n+\n+struct PlayingCard final {\n+  Suit suit;\n+  uint8_t value;\n+};\n+\n+enum class Suit : uint8_t {\n+  Clubs = 0,\n+  Diamonds = 1,\n+  Hearts = 2,\n+  Spades = 3,\n+};\n+```\n+\n+Because it is not UB in C++ for an `enum class` to hold a value different from\n+all of the listed variants, we use a Rust representation for shared enums that\n+is compatible with this. The API you'll get is something like:\n+\n+```rust,noplayground\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+#[repr(transparent)]\n+pub struct Suit {\n+    pub repr: u8,\n+}\n+#[allow(non_upper_case_globals)]\n+impl Suit {\n+    pub const Clubs: Self = Suit { repr: 0 };\n+    pub const Diamonds: Self = Suit { repr: 1 };\n+    pub const Hearts: Self = Suit { repr: 2 };\n+    pub const Spades: Self = Suit { repr: 3 };\n+}\n+```\n+\n+Notice you're free to treat the enum as an integer in Rust code via the public\n+`repr` field.\n+\n+Pattern matching with `match` still works but will require you to write wildcard\n+arms to handle the situation of an enum value that is not one of the listed\n+variants.\n+\n+```rust,noplayground\n+fn main() {\n+    let suit: Suit = /*...*/;\n+    match suit {\n+        Suit::Clubs => ...,\n+        Suit::Diamonds => ...,\n+        Suit::Hearts => ...,\n+        Suit::Spades => ...,\n+        _ => ...,  // fallback arm\n+    }\n+}\n+```\n+\n+## Enum discriminants\n+\n+You may provide explicit discriminants for some or all of the enum variants, in\n+which case those numbers will be propagated into the generated C++ `enum class`.\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi {\n+    enum SmallPrime {\n+        Two = 2,\n+        Three = 3,\n+        Five = 5,\n+        Seven = 7,\n+    }\n+}\n+```\n+\n+Variants without an explicit discriminant are assigned the previous discriminant\n+plus 1. If the first variant has not been given an explicit discriminant, it is\n+assigned discriminant 0.\n+\n+By default CXX represents your enum using the smallest integer type capable of\n+fitting all the discriminants (whether explicit or implicit). If you need a\n+different representation for reasons, provide a `repr` attribute.\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi {\n+    #[repr(i32)]\n+    enum Enum {\n+        Zero,\n+        One,\n+        Five = 5,\n+        Six,\n+    }\n+}\n+```\n+\n+```cpp\n+// generated header\n+\n+enum class Enum : int32_t {\n+  Zero = 0,\n+  One = 1,\n+  Five = 5,\n+  Six = 6,\n+};\n+```\n+\n+## Extern enums\n+\n+If you need to interoperate with an already existing enum for which an existing\n+C++ definition is the source of truth, make sure that definition is provided by\n+some header in the bridge and then declare your enum *additionally* as an extern\n+C++ type.\n+\n+```rust,noplayground\n+#[cxx::bridge]\n+mod ffi {\n+    enum Enum {\n+        Yes,\n+        No,\n+    }\n+\n+    extern \"C++\" {\n+        include!(\"path/to/the/header.h\");\n+        type Enum;\n+    }\n+}\n+```\n+\n+CXX will recognize this pattern and, instead of generating a C++ definition of\n+the enum, will instead generate C++ static assertions asserting that the\n+variants and discriminant values and integer representation written in Rust all\n+correctly match the existing C++ enum definition.\n+\n+Extern enums support all the same features as ordinary shared enums (explicit\n+discriminants, repr). Again, CXX will static assert that all of those things you\n+wrote are correct.\ndiff --git /dev/null b/book/src/tutorial.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/tutorial.md\n@@ -0,0 +1,687 @@\n+{{#title Tutorial \u2014 Rust \u2661 C++}}\n+# Tutorial: CXX blobstore client\n+\n+This example walks through a Rust application that calls into a C++ client of a\n+blobstore service. In fact we'll see calls going in both directions: Rust to C++\n+as well as C++ to Rust. For your own use case it may be that you need just one\n+of these directions.\n+\n+All of the code involved in the example is shown on this page, but it's also\n+provided in runnable form in the *demo* directory of\n+<https://github.com/dtolnay/cxx>. To try it out directly, run `cargo run` from\n+that directory.\n+\n+This tutorial assumes you've read briefly about **shared structs**, **opaque\n+types**, and **functions** in the [*Core concepts*](concepts.md) page.\n+\n+## Creating the project\n+\n+We'll use Cargo, which is the build system commonly used by open source Rust\n+projects. (CXX works with other build systems too; refer to chapter 5.)\n+\n+Create a blank Cargo project: `mkdir cxx-demo`; `cd cxx-demo`; `cargo init`.\n+\n+Edit the Cargo.toml to add a dependency on the `cxx` crate:\n+\n+```toml,hidelines\n+## Cargo.toml\n+# [package]\n+# name = \"cxx-demo\"\n+# version = \"0.1.0\"\n+# edition = \"2018\"\n+\n+[dependencies]\n+cxx = \"1.0\"\n+```\n+\n+We'll revisit this Cargo.toml later when we get to compiling some C++ code.\n+\n+## Defining the language boundary\n+\n+CXX relies on a description of the function signatures that will be exposed from\n+each language to the other. You provide this description using `extern` blocks\n+in a Rust module annotated with the `#[cxx::bridge]` attribute macro.\n+\n+We'll open with just the following at the top of src/main.rs and walk through\n+each item in detail.\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+#[cxx::bridge]\n+mod ffi {\n+\n+}\n+#\n+# fn main() {}\n+```\n+\n+The contents of this module will be everything that needs to be agreed upon by\n+both sides of the FFI boundary.\n+\n+## Calling a C++ function from Rust\n+\n+Let's obtain an instance of the C++ blobstore client, a class `BlobstoreClient`\n+defined in C++.\n+\n+We'll treat `BlobstoreClient` as an *opaque type* in CXX's classification so\n+that Rust does not need to assume anything about its implementation, not even\n+its size or alignment. In general, a C++ type might have a move-constructor\n+which is incompatible with Rust's move semantics, or may hold internal\n+references which cannot be modeled by Rust's borrowing system. Though there are\n+alternatives, the easiest way to not care about any such thing on an FFI\n+boundary is to require no knowledge about a type by treating it as opaque.\n+\n+Opaque types may only be manipulated behind an indirection such as a reference\n+`&`, a Rust `Box`, or a `UniquePtr` (Rust binding of `std::unique_ptr`). We'll\n+add a function through which C++ can return a `std::unique_ptr<BlobstoreClient>`\n+to Rust.\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+#[cxx::bridge]\n+mod ffi {\n+    unsafe extern \"C++\" {\n+        include!(\"cxx-demo/include/blobstore.h\");\n+\n+        type BlobstoreClient;\n+\n+        fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;\n+    }\n+}\n+\n+fn main() {\n+    let client = ffi::new_blobstore_client();\n+}\n+```\n+\n+The nature of `unsafe` extern blocks is clarified in more detail in the\n+[*extern \"C++\"*](extern-c++.md) chapter. In brief: the programmer is **not**\n+promising that the signatures they have typed in are accurate; that would be\n+unreasonable. CXX performs static assertions that the signatures exactly match\n+what is declared in C++. Rather, the programmer is only on the hook for things\n+that C++'s semantics are not precise enough to capture, i.e. things that would\n+only be represented at most by comments in the C++ code. In this case, it's\n+whether `new_blobstore_client` is safe or unsafe to call. If that function said\n+something like \"must be called at most once or we'll stomp yer memery\", Rust\n+would instead want to expose it as `unsafe fn new_blobstore_client`, this time\n+inside a safe `extern \"C++\"` block because the programmer is no longer on the\n+hook for any safety claim about the signature.\n+\n+If you build this file right now with `cargo build`, it won't build because we\n+haven't written a C++ implementation of `new_blobstore_client` nor instructed\n+Cargo about how to link it into the resulting binary. You'll see an error from\n+the linker like this:\n+\n+```console\n+error: linking with `cc` failed: exit code: 1\n+ |\n+ = /bin/ld: target/debug/deps/cxx-demo-7cb7fddf3d67d880.rcgu.o: in function `cxx_demo::ffi::new_blobstore_client':\n+   src/main.rs:1: undefined reference to `cxxbridge1$new_blobstore_client'\n+   collect2: error: ld returned 1 exit status\n+```\n+\n+## Adding in the C++ code\n+\n+In CXX's integration with Cargo, all #include paths begin with a crate name by\n+default (when not explicitly selected otherwise by a crate; see\n+`CFG.include_prefix` in chapter 5). That's why we see\n+`include!(\"cxx-demo/include/blobstore.h\")` above &mdash; we'll be putting the\n+C++ header at relative path `include/blobstore.h` within the Rust crate. If your\n+crate is named something other than `cxx-demo` according to the `name` field in\n+Cargo.toml, you will need to use that name everywhere in place of `cxx-demo`\n+throughout this tutorial.\n+\n+```cpp\n+// include/blobstore.h\n+\n+#pragma once\n+#include <memory>\n+\n+class BlobstoreClient {\n+public:\n+  BlobstoreClient();\n+};\n+\n+std::unique_ptr<BlobstoreClient> new_blobstore_client();\n+```\n+\n+```cpp\n+// src/blobstore.cc\n+\n+#include \"cxx-demo/include/blobstore.h\"\n+\n+BlobstoreClient::BlobstoreClient() {}\n+\n+std::unique_ptr<BlobstoreClient> new_blobstore_client() {\n+  return std::unique_ptr<BlobstoreClient>(new BlobstoreClient());\n+}\n+```\n+\n+Using `std::make_unique` would work too, as long as you pass `-std=c++14` to the\n+C++ compiler as described later on.\n+\n+The placement in *include/* and *src/* is not significant; you can place C++\n+code anywhere else in the crate as long as you use the right paths throughout\n+the tutorial.\n+\n+Be aware that *CXX does not look at any of these files.* You're free to put\n+arbitrary C++ code in here, #include your own libraries, etc. All we do is emit\n+static assertions against what you provide in the headers.\n+\n+## Compiling the C++ code with Cargo\n+\n+Cargo has a [build scripts] feature suitable for compiling non-Rust code.\n+\n+We need to introduce a new build-time dependency on CXX's C++ code generator in\n+Cargo.toml:\n+\n+```toml,hidelines\n+## Cargo.toml\n+# [package]\n+# name = \"cxx-demo\"\n+# version = \"0.1.0\"\n+# edition = \"2018\"\n+\n+[dependencies]\n+cxx = \"1.0\"\n+\n+[build-dependencies]\n+cxx-build = \"1.0\"\n+```\n+\n+Then add a build.rs build script adjacent to Cargo.toml to run the cxx-build\n+code generator and C++ compiler. The relevant arguments are the path to the Rust\n+source file containing the cxx::bridge language boundary definition, and the\n+paths to any additional C++ source files to be compiled during the Rust crate's\n+build.\n+\n+```rust,noplayground\n+// build.rs\n+\n+fn main() {\n+    cxx_build::bridge(\"src/main.rs\")\n+        .file(\"src/blobstore.cc\")\n+        .compile(\"cxx-demo\");\n+}\n+```\n+\n+This build.rs would also be where you set up C++ compiler flags, for example if\n+you'd like to have access to `std::make_unique` from C++14. See the page on\n+***[Cargo-based builds](build/cargo.md)*** for more details about CXX's Cargo\n+integration.\n+\n+```rust,noplayground\n+# // build.rs\n+#\n+# fn main() {\n+    cxx_build::bridge(\"src/main.rs\")\n+        .file(\"src/blobstore.cc\")\n+        .flag_if_supported(\"-std=c++14\")\n+        .compile(\"cxx-demo\");\n+# }\n+```\n+\n+[build scripts]: https://doc.rust-lang.org/cargo/reference/build-scripts.html\n+\n+The project should now build and run successfully, though not do anything useful\n+yet.\n+\n+```console\n+cxx-demo$  cargo run\n+  Compiling cxx-demo v0.1.0\n+  Finished dev [unoptimized + debuginfo] target(s) in 0.34s\n+  Running `target/debug/cxx-demo`\n+\n+cxx-demo$\n+```\n+\n+## Calling a Rust function from C++\n+\n+Our C++ blobstore supports a `put` operation for a discontiguous buffer upload.\n+For example we might be uploading snapshots of a circular buffer which would\n+tend to consist of 2 pieces, or fragments of a file spread across memory for\n+some other reason (like a rope data structure).\n+\n+We'll express this by handing off an iterator over contiguous borrowed chunks.\n+This loosely resembles the API of the widely used `bytes` crate's `Buf` trait.\n+During a `put`, we'll make C++ call back into Rust to obtain contiguous chunks\n+of the upload (all with no copying or allocation on the language boundary). In\n+reality the C++ client might contain some sophisticated batching of chunks\n+and/or parallel uploading that all of this ties into.\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+#[cxx::bridge]\n+mod ffi {\n+    extern \"Rust\" {\n+        type MultiBuf;\n+\n+        fn next_chunk(buf: &mut MultiBuf) -> &[u8];\n+    }\n+\n+    unsafe extern \"C++\" {\n+        include!(\"cxx-demo/include/blobstore.h\");\n+\n+        type BlobstoreClient;\n+\n+        fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;\n+        fn put(&self, parts: &mut MultiBuf) -> u64;\n+    }\n+}\n+#\n+# fn main() {\n+#     let client = ffi::new_blobstore_client();\n+# }\n+```\n+\n+Any signature having a `self` parameter (the Rust name for C++'s `this`) is\n+considered a method / non-static member function. If there is only one `type` in\n+the surrounding extern block, it'll be a method of that type. If there is more\n+than one `type`, you can disambiguate which one a method belongs to by writing\n+`self: &BlobstoreClient` in the argument list.\n+\n+As usual, now we need to provide Rust definitions of everything declared by the\n+`extern \"Rust\"` block and a C++ definition of the new signature declared by the\n+`extern \"C++\"` block.\n+\n+```rust,noplayground\n+// src/main.rs\n+#\n+# #[cxx::bridge]\n+# mod ffi {\n+#     extern \"Rust\" {\n+#         type MultiBuf;\n+#\n+#         fn next_chunk(buf: &mut MultiBuf) -> &[u8];\n+#     }\n+#\n+#     unsafe extern \"C++\" {\n+#         include!(\"cxx-demo/include/blobstore.h\");\n+#\n+#         type BlobstoreClient;\n+#\n+#         fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;\n+#         fn put(&self, parts: &mut MultiBuf) -> u64;\n+#     }\n+# }\n+\n+// An iterator over contiguous chunks of a discontiguous file object. Toy\n+// implementation uses a Vec<Vec<u8>> but in reality this might be iterating\n+// over some more complex Rust data structure like a rope, or maybe loading\n+// chunks lazily from somewhere.\n+pub struct MultiBuf {\n+    chunks: Vec<Vec<u8>>,\n+    pos: usize,\n+}\n+\n+pub fn next_chunk(buf: &mut MultiBuf) -> &[u8] {\n+    let next = buf.chunks.get(buf.pos);\n+    buf.pos += 1;\n+    next.map(Vec::as_slice).unwrap_or(&[])\n+}\n+#\n+# fn main() {\n+#     let client = ffi::new_blobstore_client();\n+# }\n+```\n+\n+```cpp,hidelines\n+// include/blobstore.h\n+\n+# #pragma once\n+# #include <memory>\n+#\n+struct MultiBuf;\n+\n+class BlobstoreClient {\n+public:\n+  BlobstoreClient();\n+  uint64_t put(MultiBuf &buf) const;\n+};\n+#\n+#std::unique_ptr<BlobstoreClient> new_blobstore_client();\n+```\n+\n+In blobstore.cc we're able to call the Rust `next_chunk` function, exposed to\n+C++ by a header `main.rs.h` generated by the CXX code generator. In CXX's Cargo\n+integration this generated header has a path containing the crate name, the\n+relative path of the Rust source file within the crate, and a `.rs.h` extension.\n+\n+```cpp,hidelines\n+// src/blobstore.cc\n+\n+##include \"cxx-demo/include/blobstore.h\"\n+##include \"cxx-demo/src/main.rs.h\"\n+##include <functional>\n+#\n+# BlobstoreClient::BlobstoreClient() {}\n+#\n+# std::unique_ptr<BlobstoreClient> new_blobstore_client() {\n+#   return std::make_unique<BlobstoreClient>();\n+# }\n+\n+// Upload a new blob and return a blobid that serves as a handle to the blob.\n+uint64_t BlobstoreClient::put(MultiBuf &buf) const {\n+  // Traverse the caller's chunk iterator.\n+  std::string contents;\n+  while (true) {\n+    auto chunk = next_chunk(buf);\n+    if (chunk.size() == 0) {\n+      break;\n+    }\n+    contents.append(reinterpret_cast<const char *>(chunk.data()), chunk.size());\n+  }\n+\n+  // Pretend we did something useful to persist the data.\n+  auto blobid = std::hash<std::string>{}(contents);\n+  return blobid;\n+}\n+```\n+\n+This is now ready to use. :)\n+\n+```rust,noplayground\n+// src/main.rs\n+#\n+# #[cxx::bridge]\n+# mod ffi {\n+#     extern \"Rust\" {\n+#         type MultiBuf;\n+#\n+#         fn next_chunk(buf: &mut MultiBuf) -> &[u8];\n+#     }\n+#\n+#     unsafe extern \"C++\" {\n+#         include!(\"cxx-demo/include/blobstore.h\");\n+#\n+#         type BlobstoreClient;\n+#\n+#         fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;\n+#         fn put(&self, parts: &mut MultiBuf) -> u64;\n+#     }\n+# }\n+#\n+# pub struct MultiBuf {\n+#     chunks: Vec<Vec<u8>>,\n+#     pos: usize,\n+# }\n+# pub fn next_chunk(buf: &mut MultiBuf) -> &[u8] {\n+#     let next = buf.chunks.get(buf.pos);\n+#     buf.pos += 1;\n+#     next.map(Vec::as_slice).unwrap_or(&[])\n+# }\n+\n+fn main() {\n+    let client = ffi::new_blobstore_client();\n+\n+    // Upload a blob.\n+    let chunks = vec![b\"fearless\".to_vec(), b\"concurrency\".to_vec()];\n+    let mut buf = MultiBuf { chunks, pos: 0 };\n+    let blobid = client.put(&mut buf);\n+    println!(\"blobid = {}\", blobid);\n+}\n+```\n+\n+```console\n+cxx-demo$  cargo run\n+  Compiling cxx-demo v0.1.0\n+  Finished dev [unoptimized + debuginfo] target(s) in 0.41s\n+  Running `target/debug/cxx-demo`\n+\n+blobid = 9851996977040795552\n+```\n+\n+## Interlude: What gets generated?\n+\n+For the curious, it's easy to look behind the scenes at what CXX has done to\n+make these function calls work. You shouldn't need to do this during normal\n+usage of CXX, but for the purpose of this tutorial it can be educative.\n+\n+CXX comprises *two* code generators: a Rust one (which is the cxx::bridge\n+attribute procedural macro) and a C++ one.\n+\n+### Rust generated code\n+\n+It's easiest to view the output of the procedural macro by installing\n+[cargo-expand]. Then run `cargo expand ::ffi` to macro-expand the `mod ffi`\n+module.\n+\n+[cargo-expand]: https://github.com/dtolnay/cargo-expand\n+\n+```console\n+cxx-demo$  cargo install cargo-expand\n+cxx-demo$  cargo expand ::ffi\n+```\n+\n+You'll see some deeply unpleasant code involving `#[repr(C)]`, `#[link_name]`,\n+and `#[export_name]`.\n+\n+### C++ generated code\n+\n+For debugging convenience, `cxx_build` links all generated C++ code into Cargo's\n+target directory under *target/cxxbridge/*.\n+\n+```console\n+cxx-demo$  exa -T target/cxxbridge/\n+target/cxxbridge\n+\u251c\u2500\u2500 cxx-demo\n+\u2502  \u2514\u2500\u2500 src\n+\u2502     \u251c\u2500\u2500 main.rs.cc -> ../../../debug/build/cxx-demo-11c6f678ce5c3437/out/cxxbridge/sources/cxx-demo/src/main.rs.cc\n+\u2502     \u2514\u2500\u2500 main.rs.h -> ../../../debug/build/cxx-demo-11c6f678ce5c3437/out/cxxbridge/include/cxx-demo/src/main.rs.h\n+\u2514\u2500\u2500 rust\n+   \u2514\u2500\u2500 cxx.h -> ~/.cargo/registry/src/github.com-1ecc6299db9ec823/cxx-1.0.0/include/cxx.h\n+```\n+\n+In those files you'll see declarations or templates of any CXX Rust types\n+present in your language boundary (like `rust::Slice<T>` for `&[T]`) and `extern\n+\"C\"` signatures corresponding to your extern functions.\n+\n+If it fits your workflow better, the CXX C++ code generator is also available as\n+a standalone executable which outputs generated code to stdout.\n+\n+```console\n+cxx-demo$  cargo install cxxbridge-cmd\n+cxx-demo$  cxxbridge src/main.rs\n+```\n+\n+## Shared data structures\n+\n+So far the calls in both directions above only used **opaque types**, not\n+**shared structs**.\n+\n+Shared structs are data structures whose complete definition is visible to both\n+languages, making it possible to pass them by value across the language\n+boundary. Shared structs translate to a C++ aggregate-initialization compatible\n+struct exactly matching the layout of the Rust one.\n+\n+As the last step of this demo, we'll use a shared struct `BlobMetadata` to pass\n+metadata about blobs between our Rust application and C++ blobstore client.\n+\n+```rust,noplayground\n+// src/main.rs\n+\n+#[cxx::bridge]\n+mod ffi {\n+    struct BlobMetadata {\n+        size: usize,\n+        tags: Vec<String>,\n+    }\n+\n+    extern \"Rust\" {\n+        // ...\n+#         type MultiBuf;\n+#\n+#         fn next_chunk(buf: &mut MultiBuf) -> &[u8];\n+    }\n+\n+    unsafe extern \"C++\" {\n+        // ...\n+#         include!(\"cxx-demo/include/blobstore.h\");\n+#\n+#         type BlobstoreClient;\n+#\n+#         fn new_blobstore_client() -> UniquePtr<BlobstoreClient>;\n+#         fn put(&self, parts: &mut MultiBuf) -> u64;\n+        fn tag(&self, blobid: u64, tag: &str);\n+        fn metadata(&self, blobid: u64) -> BlobMetadata;\n+    }\n+}\n+#\n+# pub struct MultiBuf {\n+#     chunks: Vec<Vec<u8>>,\n+#     pos: usize,\n+# }\n+# pub fn next_chunk(buf: &mut MultiBuf) -> &[u8] {\n+#     let next = buf.chunks.get(buf.pos);\n+#     buf.pos += 1;\n+#     next.map(Vec::as_slice).unwrap_or(&[])\n+# }\n+\n+fn main() {\n+    let client = ffi::new_blobstore_client();\n+\n+    // Upload a blob.\n+    let chunks = vec![b\"fearless\".to_vec(), b\"concurrency\".to_vec()];\n+    let mut buf = MultiBuf { chunks, pos: 0 };\n+    let blobid = client.put(&mut buf);\n+    println!(\"blobid = {}\", blobid);\n+\n+    // Add a tag.\n+    client.tag(blobid, \"rust\");\n+\n+    // Read back the tags.\n+    let metadata = client.metadata(blobid);\n+    println!(\"tags = {:?}\", metadata.tags);\n+}\n+```\n+\n+```cpp,hidelines\n+// include/blobstore.h\n+#\n+# #pragma once\n+# #include \"rust/cxx.h\"\n+# #include <memory>\n+\n+struct MultiBuf;\n+struct BlobMetadata;\n+\n+class BlobstoreClient {\n+public:\n+  BlobstoreClient();\n+  uint64_t put(MultiBuf &buf) const;\n+  void tag(uint64_t blobid, rust::Str tag) const;\n+  BlobMetadata metadata(uint64_t blobid) const;\n+\n+private:\n+  class impl;\n+  std::shared_ptr<impl> impl;\n+};\n+#\n+# std::unique_ptr<BlobstoreClient> new_blobstore_client();\n+```\n+\n+```cpp,hidelines\n+// src/blobstore.cc\n+\n+##include \"cxx-demo/include/blobstore.h\"\n+##include \"cxx-demo/src/main.rs.h\"\n+##include <algorithm>\n+##include <functional>\n+##include <set>\n+##include <string>\n+##include <unordered_map>\n+\n+// Toy implementation of an in-memory blobstore.\n+//\n+// In reality the implementation of BlobstoreClient could be a large\n+// complex C++ library.\n+class BlobstoreClient::impl {\n+  friend BlobstoreClient;\n+  using Blob = struct {\n+    std::string data;\n+    std::set<std::string> tags;\n+  };\n+  std::unordered_map<uint64_t, Blob> blobs;\n+};\n+\n+BlobstoreClient::BlobstoreClient() : impl(new class BlobstoreClient::impl) {}\n+#\n+# // Upload a new blob and return a blobid that serves as a handle to the blob.\n+# uint64_t BlobstoreClient::put(MultiBuf &buf) const {\n+#   // Traverse the caller's chunk iterator.\n+#   std::string contents;\n+#   while (true) {\n+#     auto chunk = next_chunk(buf);\n+#     if (chunk.size() == 0) {\n+#       break;\n+#     }\n+#     contents.append(reinterpret_cast<const char *>(chunk.data()), chunk.size());\n+#   }\n+#\n+#   // Insert into map and provide caller the handle.\n+#   auto blobid = std::hash<std::string>{}(contents);\n+#   impl->blobs[blobid] = {std::move(contents), {}};\n+#   return blobid;\n+# }\n+\n+// Add tag to an existing blob.\n+void BlobstoreClient::tag(uint64_t blobid, rust::Str tag) const {\n+  impl->blobs[blobid].tags.emplace(tag);\n+}\n+\n+// Retrieve metadata about a blob.\n+BlobMetadata BlobstoreClient::metadata(uint64_t blobid) const {\n+  BlobMetadata metadata{};\n+  auto blob = impl->blobs.find(blobid);\n+  if (blob != impl->blobs.end()) {\n+    metadata.size = blob->second.data.size();\n+    std::for_each(blob->second.tags.cbegin(), blob->second.tags.cend(),\n+                  [&](auto &t) { metadata.tags.emplace_back(t); });\n+  }\n+  return metadata;\n+}\n+#\n+# std::unique_ptr<BlobstoreClient> new_blobstore_client() {\n+#   return std::make_unique<BlobstoreClient>();\n+# }\n+```\n+\n+```console\n+cxx-demo$  cargo run\n+  Running `target/debug/cxx-demo`\n+\n+blobid = 9851996977040795552\n+tags = [\"rust\"]\n+```\n+\n+*You've now seen all the code involved in the tutorial. It's available all\n+together in runnable form in the* demo *directory of\n+<https://github.com/dtolnay/cxx>. You can run it directly without stepping\n+through the steps above by running `cargo run` from that directory.*\n+\n+<br>\n+\n+# Takeaways\n+\n+The key contribution of CXX is it gives you Rust&ndash;C++ interop in which\n+*all* of the Rust side of the code you write *really* looks like you are just\n+writing normal Rust, and the C++ side *really* looks like you are just writing\n+normal C++.\n+\n+You've seen in this tutorial that none of the code involved feels like C or like\n+the usual perilous \"FFI glue\" prone to leaks or memory safety flaws.\n+\n+An expressive system of opaque types, shared types, and key standard library\n+type bindings enables API design on the language boundary that captures the\n+proper ownership and borrowing contracts of the interface.\n+\n+CXX plays to the strengths of the Rust type system *and* C++ type system *and*\n+the programmer's intuitions. An individual working on the C++ side without a\n+Rust background, or the Rust side without a C++ background, will be able to\n+apply all their usual intuitions and best practices about development in their\n+language to maintain a correct FFI.\n+\n+<br><br>\n",
        "test_patch": "diff --git /dev/null b/book/src/build/bazel.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/build/bazel.md\n@@ -0,0 +1,106 @@\n+{{#title Bazel, Buck \u2014 Rust \u2661 C++}}\n+## Bazel, Buck, potentially other similar environments\n+\n+Starlark-based build systems with the ability to compile a code generator and\n+invoke it as a `genrule` will run CXX's C++ code generator via its `cxxbridge`\n+command line interface.\n+\n+The tool is packaged as the `cxxbridge-cmd` crate on crates.io or can be built\n+from the *gen/cmd/* directory of the CXX GitHub repo.\n+\n+```console\n+$  cargo install cxxbridge-cmd\n+\n+$  cxxbridge src/bridge.rs --header > path/to/bridge.rs.h\n+$  cxxbridge src/bridge.rs > path/to/bridge.rs.cc\n+```\n+\n+The CXX repo maintains working Bazel `BUILD` and Buck `BUCK` targets for the\n+complete blobstore tutorial (chapter 3) for your reference, tested in CI. These\n+aren't meant to be directly what you use in your codebase, but serve as an\n+illustration of one possible working pattern.\n+\n+```python\n+# tools/bazel/rust_cxx_bridge.bzl\n+\n+load(\"@bazel_skylib//rules:run_binary.bzl\", \"run_binary\")\n+load(\"@rules_cc//cc:defs.bzl\", \"cc_library\")\n+\n+def rust_cxx_bridge(name, src, deps = []):\n+    native.alias(\n+        name = \"%s/header\" % name,\n+        actual = src + \".h\",\n+    )\n+\n+    native.alias(\n+        name = \"%s/source\" % name,\n+        actual = src + \".cc\",\n+    )\n+\n+    run_binary(\n+        name = \"%s/generated\" % name,\n+        srcs = [src],\n+        outs = [\n+            src + \".h\",\n+            src + \".cc\",\n+        ],\n+        args = [\n+            \"$(location %s)\" % src,\n+            \"-o\",\n+            \"$(location %s.h)\" % src,\n+            \"-o\",\n+            \"$(location %s.cc)\" % src,\n+        ],\n+        tool = \"//:codegen\",\n+    )\n+\n+    cc_library(\n+        name = name,\n+        srcs = [src + \".cc\"],\n+        deps = deps + [\":%s/include\" % name],\n+    )\n+\n+    cc_library(\n+        name = \"%s/include\" % name,\n+        hdrs = [src + \".h\"],\n+    )\n+```\n+\n+```python\n+# demo/BUILD\n+\n+load(\"@rules_cc//cc:defs.bzl\", \"cc_library\")\n+load(\"//tools/bazel:rust.bzl\", \"rust_binary\")\n+load(\"//tools/bazel:rust_cxx_bridge.bzl\", \"rust_cxx_bridge\")\n+\n+rust_binary(\n+    name = \"demo\",\n+    srcs = glob([\"src/**/*.rs\"]),\n+    deps = [\n+        \":blobstore-sys\",\n+        \":bridge\",\n+        \"//:cxx\",\n+    ],\n+)\n+\n+rust_cxx_bridge(\n+    name = \"bridge\",\n+    src = \"src/main.rs\",\n+    deps = [\":blobstore-include\"],\n+)\n+\n+cc_library(\n+    name = \"blobstore-sys\",\n+    srcs = [\"src/blobstore.cc\"],\n+    deps = [\n+        \":blobstore-include\",\n+        \":bridge/include\",\n+    ],\n+)\n+\n+cc_library(\n+    name = \"blobstore-include\",\n+    hdrs = [\"include/blobstore.h\"],\n+    deps = [\"//:core\"],\n+)\n+```\ndiff --git /dev/null b/book/src/context.md\nnew file mode 100644\n--- /dev/null\n+++ b/book/src/context.md\n@@ -0,0 +1,118 @@\n+{{#title Other Rust\u2013C++ interop tools \u2014 Rust \u2661 C++}}\n+# Context: other Rust&ndash;C++ interop tools\n+\n+When it comes to interacting with an idiomatic Rust API or idiomatic C++ API\n+from the other language, the generally applicable approaches outside of the CXX\n+crate are:\n+\n+- Build a C-compatible wrapper around the code (expressed using `extern \"C\"`\n+  signatures, primitives, C-compatible structs, raw pointers). Translate that\n+  manually to equivalent `extern \"C\"` declarations in the other language and\n+  keep them in sync. Preferably, build a safe/idiomatic wrapper around the\n+  translated `extern \"C\"` signatures for callers to use.\n+\n+- Build a C wrapper around the C++ code and use **[bindgen]** to translate that\n+  programmatically to `extern \"C\"` Rust signatures. Preferably, build a\n+  safe/idiomatic Rust wrapper on top.\n+\n+- Build a C-compatible Rust wrapper around the Rust code and use **[cbindgen]**\n+  to translate that programmatically to an `extern \"C\"` C++ header. Preferably,\n+  build an idiomatic C++ wrapper.\n+\n+**If the code you are binding is already *\"effectively C\"*, the above has you\n+covered.** You should use bindgen or cbindgen, or manually translated C\n+signatures if there aren't too many and they seldom change.\n+\n+[bindgen]: https://github.com/rust-lang/rust-bindgen\n+[cbindgen]: https://github.com/eqrion/cbindgen\n+\n+## C++ vs C\n+\n+Bindgen has some basic support for C++. It can reason about classes, member\n+functions, and the layout of templated types. However, everything it does\n+related to C++ is best-effort only. Bindgen starts from a point of wanting to\n+generate declarations for everything, so any C++ detail that it hasn't\n+implemented will cause a crash if you are lucky ([bindgen#388]) or more likely\n+silently emit an incompatible signature ([bindgen#380], [bindgen#607],\n+[bindgen#652], [bindgen#778], [bindgen#1194]) which will do arbitrary\n+memory-unsafe things at runtime whenever called.\n+\n+[bindgen#388]: https://github.com/rust-lang/rust-bindgen/issues/388\n+[bindgen#380]: https://github.com/rust-lang/rust-bindgen/issues/380\n+[bindgen#607]: https://github.com/rust-lang/rust-bindgen/issues/607\n+[bindgen#652]: https://github.com/rust-lang/rust-bindgen/issues/652\n+[bindgen#778]: https://github.com/rust-lang/rust-bindgen/issues/778\n+[bindgen#1194]: https://github.com/rust-lang/rust-bindgen/issues/1194\n+\n+Thus using bindgen correctly requires not just juggling all your pointers\n+correctly at the language boundary, but also understanding ABI details and their\n+workarounds and reliably applying them. For example, the programmer will\n+discover that their program sometimes segfaults if they call a function that\n+returns std::unique\\_ptr\\<T\\> through bindgen. Why? Because unique\\_ptr, despite\n+being \"just a pointer\", has a different ABI than a pointer or a C struct\n+containing a pointer ([bindgen#778]) and is not directly expressible in Rust.\n+Bindgen emitted something that *looks* reasonable and you will have a hell of a\n+time in gdb working out what went wrong. Eventually people learn to avoid\n+anything involving a non-trivial copy constructor, destructor, or inheritance,\n+and instead stick to raw pointers and primitives and trivial structs only\n+&mdash; in other words C.\n+\n+## Geometric intuition for why there is so much opportunity for improvement\n+\n+The CXX project attempts a different approach to C++ FFI.\n+\n+Imagine Rust and C and C++ as three vertices of a scalene triangle, with length\n+of the edges being related to similarity of the languages when it comes to\n+library design.\n+\n+The most similar pair (the shortest edge) is Rust&ndash;C++. These languages\n+have largely compatible concepts of things like ownership, vectors, strings,\n+fallibility, etc that translate clearly from signatures in either language to\n+signatures in the other language.\n+\n+When we make a binding for an idiomatic C++ API using bindgen, and we fall down\n+to raw pointers and primitives and trivial structs as described above, what we\n+are really doing is coding the two longest edges of the triangle: getting from\n+C++ down to C, and C back up to Rust. The Rust&ndash;C edge always involves a\n+great deal of `unsafe` code, and the C++&ndash;C edge similarly requires care\n+just for basic memory safety. Something as basic as \"how do I pass ownership of\n+a string to the other language?\" becomes a strap-yourself-in moment,\n+particularly for someone not already an expert in one or both sides.\n+\n+You should think of the `cxx` crate as being the midpoint of the Rust&ndash;C++\n+edge. Rather than coding the two long edges, you will code half the short edge\n+in Rust and half the short edge in C++, in both cases with the library playing\n+to the strengths of the Rust type system *and* the C++ type system to help\n+assure correctness.\n+\n+If you've already been through the tutorial in the previous chapter, take a\n+moment to appreciate that the C++ side *really* looks like we are just writing\n+C++ and the Rust side *really* looks like we are just writing Rust. Anything you\n+could do wrong in Rust, and almost anything you could reasonably do wrong in\n+C++, will be caught by the compiler. This highlights that we are on the \"short\n+edge of the triangle\".\n+\n+But it all still boils down to the same things: it's still FFI from one piece of\n+native code to another, nothing is getting serialized or allocated or\n+runtime-checked in between.\n+\n+## Role of CXX\n+\n+The role of CXX is to capture the language boundary with more fidelity than what\n+`extern \"C\"` is able to represent. You can think of CXX as being a replacement\n+for `extern \"C\"` in a sense.\n+\n+From this perspective, CXX is a lower level tool than the bindgens. Just as\n+bindgen and cbindgen are built on top of `extern \"C\"`, it makes sense to think\n+about higher level tools built on top of CXX. Such a tool might consume a C++\n+header and/or Rust module (and/or IDL like Thrift) and emit the corresponding\n+safe cxx::bridge language boundary, leveraging CXX's static analysis and\n+underlying implementation of that boundary. We are beginning to see this space\n+explored by the [autocxx] tool, though nothing yet ready for broad use in the\n+way that CXX on its own is.\n+\n+[autocxx]: https://github.com/google/autocxx\n+\n+But note in other ways CXX is higher level than the bindgens, with rich support\n+for common standard library types. CXX's types serve as an intuitive vocabulary\n+for designing a good boundary between components in different languages.\n",
        "problem_statement": "Initial commit of book content.\nStart of a book, working towards #179.\r\n\r\n@dtolnay I'm sure you'll have a ton of edits you'll want to do here, but I hope it's a good start.\n",
        "hints_text": "",
        "created_at": "2020-11-17T16:23:47Z",
        "version": "0.5"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 454,
        "instance_id": "dtolnay__cxx-454",
        "issue_numbers": [
            "137"
        ],
        "base_commit": "86857455387b4a986de763dd4084716481ece177",
        "patch": "diff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -285,9 +285,9 @@ fn parse_lang(abi: &Abi) -> Result<Lang> {\n         }\n     };\n     match name.value().as_str() {\n-        \"C\" | \"C++\" => Ok(Lang::Cxx),\n+        \"C++\" => Ok(Lang::Cxx),\n         \"Rust\" => Ok(Lang::Rust),\n-        _ => Err(Error::new_spanned(abi, \"unrecognized ABI\")),\n+        _ => Err(Error::new_spanned(abi, \"unrecognized ABI, requires either \\\"C++\\\" or \\\"Rust\\\"\")),\n     }\n }\n \n",
        "test_patch": "diff --git a/tests/ui/multiple_parse_error.stderr b/tests/ui/multiple_parse_error.stderr\n--- a/tests/ui/multiple_parse_error.stderr\n+++ b/tests/ui/multiple_parse_error.stderr\n@@ -4,7 +4,7 @@ error: struct with generic parameters is not supported yet\n 3 |     struct Monad<T>;\n   |     ^^^^^^^^^^^^^^^\n \n-error: unrecognized ABI\n+error: unrecognized ABI, requires either \"C++\" or \"Rust\"\n  --> $DIR/multiple_parse_error.rs:5:5\n   |\n 5 |     extern \"Haskell\" {}\n",
        "problem_statement": "Consider mandating `extern \"C++\"` for C++ things\nWe currently accept both `extern \"C\"` and `extern \"C++\"` and treat them the same.\r\n\r\nHowever with #4 we may end up wanting to translate the two languages somewhat differently, in particular mapping Rust references to pointers in C and references in C++.\r\n\r\nWe can't make this change in the near term because until recently Rustfmt would silently rewrite `extern \"C++\"` into `extern \"Rust\"` (https://github.com/rust-lang/rustfmt/issues/4086). \ud83e\udd26\ud83e\udd26\u200d\u2640\ufe0f\ud83e\udd26\u200d\u2642\ufe0f\n",
        "hints_text": "> Rustfmt would silently rewrite `extern \"C++\"` into `extern \"Rust\"`\r\n\r\nIf only it did that for more general C++ code.",
        "created_at": "2020-11-11T18:41:53Z",
        "version": "0.5"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 443,
        "instance_id": "dtolnay__cxx-443",
        "issue_numbers": [
            "442"
        ],
        "base_commit": "0cb4514cfb42e5b4ecf76701a6387c364070b1ed",
        "patch": "diff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -698,11 +698,13 @@ fn write_rust_function_shim_impl(\n         write!(out, \"::rust::repr::PtrLen error$ = \");\n     }\n     write!(out, \"{}(\", invoke);\n+    let mut needs_comma = false;\n     if sig.receiver.is_some() {\n         write!(out, \"*this\");\n+        needs_comma = true;\n     }\n-    for (i, arg) in sig.args.iter().enumerate() {\n-        if i > 0 || sig.receiver.is_some() {\n+    for arg in &sig.args {\n+        if needs_comma {\n             write!(out, \", \");\n         }\n         match &arg.ty {\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -725,15 +727,17 @@ fn write_rust_function_shim_impl(\n             ty if ty != RustString && out.types.needs_indirect_abi(ty) => write!(out, \"$.value\"),\n             _ => {}\n         }\n+        needs_comma = true;\n     }\n     if indirect_return {\n-        if !sig.args.is_empty() {\n+        if needs_comma {\n             write!(out, \", \");\n         }\n         write!(out, \"&return$.value\");\n+        needs_comma = true;\n     }\n     if indirect_call {\n-        if !sig.args.is_empty() || indirect_return {\n+        if needs_comma {\n             write!(out, \", \");\n         }\n         write!(out, \"extern$\");\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -274,7 +274,7 @@ pub mod ffi {\n         fn r_return_r2(n: usize) -> Box<R2>;\n         fn get(self: &R2) -> usize;\n         fn set(self: &mut R2, n: usize) -> usize;\n-        fn r_method_on_shared(self: &Shared) -> usize;\n+        fn r_method_on_shared(self: &Shared) -> String;\n \n         #[cxx_name = \"rAliasedFunction\"]\n         fn r_aliased_function(x: i32) -> String;\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -318,8 +318,8 @@ impl R2 {\n }\n \n impl ffi::Shared {\n-    fn r_method_on_shared(&self) -> usize {\n-        2020\n+    fn r_method_on_shared(&self) -> String {\n+        \"2020\".to_owned()\n     }\n }\n \ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -626,7 +626,7 @@ extern \"C\" const char *cxx_run_test() noexcept {\n   ASSERT(r2->get() == 2021);\n   ASSERT(r2->set(2020) == 2020);\n   ASSERT(r2->get() == 2020);\n-  ASSERT(Shared{0}.r_method_on_shared() == 2020);\n+  ASSERT(std::string(Shared{0}.r_method_on_shared()) == \"2020\");\n \n   ASSERT(std::string(rAliasedFunction(2020)) == \"2020\");\n \n",
        "problem_statement": "Bug when defining methods on shared structs\n```rust\r\n// str_test.rs\r\n#[cxx::bridge]\r\nmod ffi {\r\n    struct A {\r\n        a: f32,\r\n    }\r\n\r\n    extern \"Rust\"{\r\n        fn hello(self: &A) -> String;\r\n    }\r\n}\r\n```\r\n\r\nThen run \r\n```bash\r\ncxxbridge str_test.rs\r\n```\r\n\r\nWe get:\r\n```cpp\r\n...\r\n\r\n::rust::String A::hello() const noexcept {\r\n  ::rust::MaybeUninit<::rust::String> return$;\r\n  cxxbridge05$A$hello(*this&return$.value);\r\n  return ::std::move(return$.value);\r\n}\r\n```\r\n\r\nNote that there's a missing \",\" in hello invocation.\r\nIt should be `cxxbridge05$A$hello(*this, &return$.value);` instead of `cxxbridge05$A$hello(*this&return$.value);`\r\n\r\n\r\n<!--  \u2764\ufe0f  -->\n",
        "hints_text": "",
        "created_at": "2020-11-10T16:51:53Z",
        "version": "0.5"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 411,
        "instance_id": "dtolnay__cxx-411",
        "issue_numbers": [
            "292"
        ],
        "base_commit": "dd9e987fd6f7627d8582c960ef13c11aa8888264",
        "patch": "diff --git a/gen/src/toposort.rs b/gen/src/toposort.rs\n--- a/gen/src/toposort.rs\n+++ b/gen/src/toposort.rs\n@@ -1,8 +1,44 @@\n-use crate::syntax::{Api, Types};\n-use std::iter::FromIterator;\n+use crate::syntax::{Api, Struct, Type, Types};\n+use std::collections::btree_map::{BTreeMap as Map, Entry};\n \n-pub fn sort<'a>(apis: &'a [Api], types: &Types) -> Vec<&'a Api> {\n-    // TODO https://github.com/dtolnay/cxx/issues/292\n-    let _ = types;\n-    Vec::from_iter(apis)\n+enum Mark {\n+    Visiting,\n+    Visited,\n+}\n+\n+pub fn sort<'a>(apis: &'a [Api], types: &Types<'a>) -> Vec<&'a Struct> {\n+    let mut sorted = Vec::new();\n+    let ref mut marks = Map::new();\n+    for api in apis {\n+        if let Api::Struct(strct) = api {\n+            visit(strct, &mut sorted, marks, types);\n+        }\n+    }\n+    sorted\n+}\n+\n+fn visit<'a>(\n+    strct: &'a Struct,\n+    sorted: &mut Vec<&'a Struct>,\n+    marks: &mut Map<*const Struct, Mark>,\n+    types: &Types<'a>,\n+) {\n+    match marks.entry(strct) {\n+        Entry::Occupied(entry) => match entry.get() {\n+            Mark::Visiting => panic!(\"not a DAG\"), // FIXME\n+            Mark::Visited => return,\n+        },\n+        Entry::Vacant(entry) => {\n+            entry.insert(Mark::Visiting);\n+        }\n+    }\n+    for field in &strct.fields {\n+        if let Type::Ident(ident) = &field.ty {\n+            if let Some(inner) = types.structs.get(&ident.rust) {\n+                visit(inner, sorted, marks, types);\n+            }\n+        }\n+    }\n+    marks.insert(strct, Mark::Visited);\n+    sorted.push(strct);\n }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -76,14 +76,8 @@ fn write_data_structures<'a>(out: &mut OutFile<'a>, apis: &'a [Api]) {\n         }\n     }\n \n-    for api in toposort::sort(apis, out.types) {\n+    for api in apis {\n         match api {\n-            Api::Struct(strct) => {\n-                out.next_section();\n-                if !out.types.cxx.contains(&strct.name.rust) {\n-                    write_struct(out, strct);\n-                }\n-            }\n             Api::Enum(enm) => {\n                 out.next_section();\n                 if out.types.cxx.contains(&enm.name.rust) {\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -102,6 +96,13 @@ fn write_data_structures<'a>(out: &mut OutFile<'a>, apis: &'a [Api]) {\n         }\n     }\n \n+    for strct in toposort::sort(apis, out.types) {\n+        out.next_section();\n+        if !out.types.cxx.contains(&strct.name.rust) {\n+            write_struct(out, strct);\n+        }\n+    }\n+\n     out.next_section();\n     for api in apis {\n         if let Api::TypeAlias(ety) = api {\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -277,6 +277,27 @@ pub mod ffi {\n         #[cxx_name = \"rAliasedFunction\"]\n         fn r_aliased_function(x: i32) -> String;\n     }\n+\n+    struct Dag0 {\n+        i: i32,\n+    }\n+\n+    struct Dag1 {\n+        dag2: Dag2,\n+        vec: Vec<Dag3>,\n+    }\n+\n+    struct Dag2 {\n+        dag4: Dag4,\n+    }\n+\n+    struct Dag3 {\n+        dag1: Dag1,\n+    }\n+\n+    struct Dag4 {\n+        dag0: Dag0,\n+    }\n }\n \n pub type R = usize;\n",
        "problem_statement": "Nested structs lead to incomplete type error\nIf I put this in my `mod ffi`:\r\n\r\n    struct A {\r\n        b: B,\r\n    }\r\n    struct B {\r\n        c: i32,\r\n    }\r\n\r\nI get this error during compilation:\r\n\r\n```\r\nwarning: /.../lib.rs.cc:255:5: error: field has incomplete type 'org::example::B'\r\nwarning:   B b;\r\nwarning:     ^\r\nwarning: /.../lib.rs.cc:225:8: note: forward declaration of 'org::example::B'\r\nwarning: struct B;\r\nwarning:        ^\r\nwarning: 1 error generated.\r\n```\r\n\r\nIf I change it to `b: Box<B>` it works fine.\n",
        "hints_text": "We'll want to implement a topological sort for data structures to fix this. The current implementation in cxx::bridge for shared structs is really basic, it just forward declares them all in original order and then defines them all in original order.\r\n\r\n```cpp\r\nstruct A;\r\nstruct B;\r\n\r\nstruct A final {\r\n  B b;\r\n};\r\n\r\nstruct B final {\r\n  int32_t c;\r\n};\r\n```\r\n\r\nThat's fine if forward references are boxed (as you noticed) or if the structs are topologically ordered already. (So a workaround for you is to put B before A in the cxx::bridge source file.)\nMarking <kbd>help wanted</kbd>. A correct topological sort implementation here should handle translating this:\r\n\r\n```rust\r\nstruct X { y: Y }\r\nstruct Y { z: UniquePtr<Z> }\r\nstruct Z { x: X }\r\n```\r\n\r\ninto this:\r\n\r\n```cpp\r\nstruct Z;\r\n\r\nstruct Y final { std::unique_ptr<Z> z; };\r\nstruct X final { Y y; };\r\nstruct Z final { X x; };\r\n```",
        "created_at": "2020-11-04T02:16:44Z",
        "version": "0.5"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 408,
        "instance_id": "dtolnay__cxx-408",
        "issue_numbers": [
            "249"
        ],
        "base_commit": "5e88a0d840f953a98c361cc7f25be53315a87a55",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -208,7 +208,7 @@ fn expand_cxx_function_decl(efn: &ExternFn, types: &Types) -> TokenStream {\n     });\n     let args = efn.args.iter().map(|arg| {\n         let ident = &arg.ident;\n-        let ty = expand_extern_type(&arg.ty, types);\n+        let ty = expand_extern_type(&arg.ty, types, true);\n         if arg.ty == RustString {\n             quote!(#ident: *const #ty)\n         } else if let Type::RustVec(_) = arg.ty {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -225,11 +225,11 @@ fn expand_cxx_function_decl(efn: &ExternFn, types: &Types) -> TokenStream {\n     let ret = if efn.throws {\n         quote!(-> ::cxx::private::Result)\n     } else {\n-        expand_extern_return_type(&efn.ret, types)\n+        expand_extern_return_type(&efn.ret, types, true)\n     };\n     let mut outparam = None;\n     if indirect_return(efn, types) {\n-        let ret = expand_extern_type(efn.ret.as_ref().unwrap(), types);\n+        let ret = expand_extern_type(efn.ret.as_ref().unwrap(), types, true);\n         outparam = Some(quote!(__return: *mut #ret));\n     }\n     let link_name = mangle::extern_fn(efn, types);\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -287,6 +287,10 @@ fn expand_cxx_function_shim(efn: &ExternFn, types: &Types) -> TokenStream {\n                     None => quote!(::cxx::private::RustVec::from_ref(#var)),\n                     Some(_) => quote!(::cxx::private::RustVec::from_mut(#var)),\n                 },\n+                inner if types.is_considered_improper_ctype(inner) => match ty.mutability {\n+                    None => quote!(#var as *const #inner as *const ::std::ffi::c_void),\n+                    Some(_) => quote!(#var as *mut #inner as *mut ::std::ffi::c_void),\n+                },\n                 _ => quote!(#var),\n             },\n             Type::Str(_) => quote!(::cxx::private::RustStr::from(#var)),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -323,7 +327,7 @@ fn expand_cxx_function_shim(efn: &ExternFn, types: &Types) -> TokenStream {\n         .collect::<TokenStream>();\n     let local_name = format_ident!(\"__{}\", efn.name.rust);\n     let call = if indirect_return {\n-        let ret = expand_extern_type(efn.ret.as_ref().unwrap(), types);\n+        let ret = expand_extern_type(efn.ret.as_ref().unwrap(), types, true);\n         setup.extend(quote! {\n             let mut __return = ::std::mem::MaybeUninit::<#ret>::uninit();\n         });\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -376,6 +380,10 @@ fn expand_cxx_function_shim(efn: &ExternFn, types: &Types) -> TokenStream {\n                         None => quote!(#call.as_vec()),\n                         Some(_) => quote!(#call.as_mut_vec()),\n                     },\n+                    inner if types.is_considered_improper_ctype(inner) => {\n+                        let mutability = ty.mutability;\n+                        quote!(&#mutability *#call.cast())\n+                    }\n                     _ => call,\n                 },\n                 Type::Str(_) => quote!(#call.as_str()),\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -508,7 +516,7 @@ fn expand_rust_function_shim_impl(\n     });\n     let args = sig.args.iter().map(|arg| {\n         let ident = &arg.ident;\n-        let ty = expand_extern_type(&arg.ty, types);\n+        let ty = expand_extern_type(&arg.ty, types, false);\n         if types.needs_indirect_abi(&arg.ty) {\n             quote!(#ident: *mut #ty)\n         } else {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -609,7 +617,7 @@ fn expand_rust_function_shim_impl(\n     let mut outparam = None;\n     let indirect_return = indirect_return(sig, types);\n     if indirect_return {\n-        let ret = expand_extern_type(sig.ret.as_ref().unwrap(), types);\n+        let ret = expand_extern_type(sig.ret.as_ref().unwrap(), types, false);\n         outparam = Some(quote!(__return: *mut #ret,));\n     }\n     if sig.throws {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -627,7 +635,7 @@ fn expand_rust_function_shim_impl(\n     let ret = if sig.throws {\n         quote!(-> ::cxx::private::Result)\n     } else {\n-        expand_extern_return_type(&sig.ret, types)\n+        expand_extern_return_type(&sig.ret, types, false)\n     };\n \n     let pointer = match invoke {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -939,15 +947,15 @@ fn indirect_return(sig: &Signature, types: &Types) -> bool {\n         .map_or(false, |ret| sig.throws || types.needs_indirect_abi(ret))\n }\n \n-fn expand_extern_type(ty: &Type, types: &Types) -> TokenStream {\n+fn expand_extern_type(ty: &Type, types: &Types, proper: bool) -> TokenStream {\n     match ty {\n         Type::Ident(ident) if ident.rust == RustString => quote!(::cxx::private::RustString),\n         Type::RustBox(ty) | Type::UniquePtr(ty) => {\n-            let inner = expand_extern_type(&ty.inner, types);\n+            let inner = expand_extern_type(&ty.inner, types, proper);\n             quote!(*mut #inner)\n         }\n         Type::RustVec(ty) => {\n-            let elem = expand_extern_type(&ty.inner, types);\n+            let elem = expand_extern_type(&ty.inner, types, proper);\n             quote!(::cxx::private::RustVec<#elem>)\n         }\n         Type::Ref(ty) => {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -957,9 +965,13 @@ fn expand_extern_type(ty: &Type, types: &Types) -> TokenStream {\n                     quote!(&#mutability ::cxx::private::RustString)\n                 }\n                 Type::RustVec(ty) => {\n-                    let inner = expand_extern_type(&ty.inner, types);\n+                    let inner = expand_extern_type(&ty.inner, types, proper);\n                     quote!(&#mutability ::cxx::private::RustVec<#inner>)\n                 }\n+                inner if proper && types.is_considered_improper_ctype(inner) => match mutability {\n+                    None => quote!(*const ::std::ffi::c_void),\n+                    Some(_) => quote!(*#mutability ::std::ffi::c_void),\n+                },\n                 _ => quote!(#ty),\n             }\n         }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -969,11 +981,11 @@ fn expand_extern_type(ty: &Type, types: &Types) -> TokenStream {\n     }\n }\n \n-fn expand_extern_return_type(ret: &Option<Type>, types: &Types) -> TokenStream {\n+fn expand_extern_return_type(ret: &Option<Type>, types: &Types, proper: bool) -> TokenStream {\n     let ret = match ret {\n         Some(ret) if !types.needs_indirect_abi(ret) => ret,\n         _ => return TokenStream::new(),\n     };\n-    let ty = expand_extern_type(ret, types);\n+    let ty = expand_extern_type(ret, types, proper);\n     quote!(-> #ty)\n }\ndiff --git /dev/null b/syntax/improper.rs\nnew file mode 100644\n--- /dev/null\n+++ b/syntax/improper.rs\n@@ -0,0 +1,36 @@\n+use self::ImproperCtype::*;\n+use crate::syntax::atom::Atom::{self, *};\n+use crate::syntax::{Type, Types};\n+use proc_macro2::Ident;\n+\n+pub enum ImproperCtype<'a> {\n+    Definite(bool),\n+    Depends(&'a Ident),\n+}\n+\n+impl<'a> Types<'a> {\n+    // yes, no, maybe\n+    pub fn determine_improper_ctype(&self, ty: &Type) -> ImproperCtype<'a> {\n+        match ty {\n+            Type::Ident(ident) => {\n+                let ident = &ident.rust;\n+                if let Some(atom) = Atom::from(ident) {\n+                    Definite(atom == RustString)\n+                } else if let Some(strct) = self.structs.get(ident) {\n+                    Depends(&strct.name.rust) // iterate to fixed-point\n+                } else {\n+                    Definite(self.rust.contains(ident))\n+                }\n+            }\n+            Type::RustBox(_)\n+            | Type::RustVec(_)\n+            | Type::Str(_)\n+            | Type::Fn(_)\n+            | Type::Void(_)\n+            | Type::Slice(_)\n+            | Type::SliceRefU8(_) => Definite(true),\n+            Type::UniquePtr(_) | Type::CxxVector(_) => Definite(false),\n+            Type::Ref(ty) => self.determine_improper_ctype(&ty.inner),\n+        }\n+    }\n+}\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -10,6 +10,7 @@ pub mod error;\n pub mod file;\n pub mod ident;\n mod impls;\n+mod improper;\n pub mod mangle;\n mod names;\n pub mod namespace;\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -1,4 +1,5 @@\n use crate::syntax::atom::Atom::{self, *};\n+use crate::syntax::improper::ImproperCtype;\n use crate::syntax::report::Errors;\n use crate::syntax::set::OrderedSet as Set;\n use crate::syntax::{\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -19,6 +20,7 @@ pub struct Types<'a> {\n     pub required_trivial: Map<&'a Ident, TrivialReason<'a>>,\n     pub explicit_impls: Set<&'a Impl>,\n     pub resolutions: Map<&'a Ident, &'a Pair>,\n+    pub struct_improper_ctypes: UnorderedSet<&'a Ident>,\n }\n \n impl<'a> Types<'a> {\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -32,6 +34,7 @@ impl<'a> Types<'a> {\n         let mut untrusted = Map::new();\n         let mut explicit_impls = Set::new();\n         let mut resolutions = Map::new();\n+        let struct_improper_ctypes = UnorderedSet::new();\n \n         fn visit<'a>(all: &mut Set<&'a Type>, ty: &'a Type) {\n             all.insert(ty);\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -190,7 +193,7 @@ impl<'a> Types<'a> {\n             }\n         }\n \n-        Types {\n+        let mut types = Types {\n             all,\n             structs,\n             enums,\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -201,7 +204,34 @@ impl<'a> Types<'a> {\n             required_trivial,\n             explicit_impls,\n             resolutions,\n+            struct_improper_ctypes,\n+        };\n+\n+        let mut unresolved_structs: Vec<&Ident> = types.structs.keys().copied().collect();\n+        let mut new_information = true;\n+        while new_information {\n+            new_information = false;\n+            unresolved_structs.retain(|ident| {\n+                let mut retain = false;\n+                for var in &types.structs[ident].fields {\n+                    if match types.determine_improper_ctype(&var.ty) {\n+                        ImproperCtype::Depends(inner) => {\n+                            retain = true;\n+                            types.struct_improper_ctypes.contains(inner)\n+                        }\n+                        ImproperCtype::Definite(improper) => improper,\n+                    } {\n+                        types.struct_improper_ctypes.insert(ident);\n+                        new_information = true;\n+                        return false;\n+                    }\n+                }\n+                // If all fields definite false, remove from unresolved_structs.\n+                retain\n+            });\n         }\n+\n+        types\n     }\n \n     pub fn needs_indirect_abi(&self, ty: &Type) -> bool {\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -227,6 +257,19 @@ impl<'a> Types<'a> {\n         false\n     }\n \n+    // Types that trigger rustc's default #[warn(improper_ctypes)] lint, even if\n+    // they may be otherwise unproblematic to mention in an extern signature.\n+    // For example in a signature like `extern \"C\" fn(*const String)`, rustc\n+    // refuses to believe that C could know how to supply us with a pointer to a\n+    // Rust String, even though C could easily have obtained that pointer\n+    // legitimately from a Rust call.\n+    pub fn is_considered_improper_ctype(&self, ty: &Type) -> bool {\n+        match self.determine_improper_ctype(ty) {\n+            ImproperCtype::Definite(improper) => improper,\n+            ImproperCtype::Depends(ident) => self.struct_improper_ctypes.contains(ident),\n+        }\n+    }\n+\n     pub fn resolve(&self, ident: &ResolvableName) -> &Pair {\n         self.resolutions\n             .get(&ident.rust)\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -69,6 +69,10 @@ pub mod ffi {\n         z: usize,\n     }\n \n+    struct SharedString {\n+        msg: String,\n+    }\n+\n     enum Enum {\n         AVal,\n         BVal = 2020,\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -169,6 +173,7 @@ pub mod ffi {\n         fn c_take_ref_rust_vec_string(v: &Vec<String>);\n         fn c_take_ref_rust_vec_index(v: &Vec<u8>);\n         fn c_take_ref_rust_vec_copy(v: &Vec<u8>);\n+        fn c_take_ref_shared_string(s: &SharedString) -> &SharedString;\n         fn c_take_callback(callback: fn(String) -> usize);\n         fn c_take_enum(e: Enum);\n         fn c_take_ns_enum(e: AEnum);\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -385,6 +385,13 @@ void c_take_ref_rust_vec_copy(const rust::Vec<uint8_t> &v) {\n   }\n }\n \n+const SharedString &c_take_ref_shared_string(const SharedString &s) {\n+  if (std::string(s.msg) == \"2020\") {\n+    cxx_test_suite_set_correct();\n+  }\n+  return s;\n+}\n+\n void c_take_callback(rust::Fn<size_t(rust::String)> callback) {\n   callback(\"2020\");\n }\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -36,6 +36,7 @@ namespace tests {\n \n struct R;\n struct Shared;\n+struct SharedString;\n enum class Enum : uint16_t;\n \n class C {\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -134,6 +135,7 @@ void c_take_ref_rust_vec(const rust::Vec<uint8_t> &v);\n void c_take_ref_rust_vec_string(const rust::Vec<rust::String> &v);\n void c_take_ref_rust_vec_index(const rust::Vec<uint8_t> &v);\n void c_take_ref_rust_vec_copy(const rust::Vec<uint8_t> &v);\n+const SharedString &c_take_ref_shared_string(const SharedString &s);\n void c_take_callback(rust::Fn<size_t(rust::String)> callback);\n void c_take_enum(Enum e);\n void c_take_ns_enum(::A::AEnum e);\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -137,6 +137,9 @@ fn test_c_take() {\n     check!(ffi::c_take_ref_rust_vec(&test_vec));\n     check!(ffi::c_take_ref_rust_vec_index(&test_vec));\n     check!(ffi::c_take_ref_rust_vec_copy(&test_vec));\n+    check!(ffi::c_take_ref_shared_string(&ffi::SharedString {\n+        msg: \"2020\".to_owned()\n+    }));\n     let ns_shared_test_vec = vec![ffi::AShared { z: 1010 }, ffi::AShared { z: 1011 }];\n     check!(ffi::c_take_rust_vec_ns_shared(ns_shared_test_vec));\n     let nested_ns_shared_test_vec = vec![ffi::ABShared { z: 1010 }, ffi::ABShared { z: 1011 }];\n",
        "problem_statement": "Pass-by-reference of shared struct containing String to C++ FFI gives \"not FFI-safe\" error\n\r\n`src/main.rs`:\r\n\r\n```\r\n#[cxx::bridge(namespace = org::example)]\r\nmod ffi {\r\n    struct SharedThing {\r\n        x: String,\r\n    }\r\n\r\n    extern \"C\" {\r\n        include!(\"src/demo.h\");\r\n        fn do_thing(state: &SharedThing);\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let shared = ffi::SharedThing {\r\n        x: \"hello\".to_string(),\r\n    };\r\n    ffi::do_thing(&shared);\r\n}\r\n```\r\n\r\n`src/demo.h`:\r\n\r\n```\r\n#pragma once\r\n#include <string>\r\n\r\n#include \"rust/cxx.h\"\r\n\r\nnamespace org {\r\nnamespace example {\r\n\r\nstruct SharedThing;\r\n\r\nvoid do_thing(const SharedThing& state);\r\n\r\n}  // namespace example\r\n}  // namespace org\r\n```\r\n\r\n`src/demo.cc`:\r\n\r\n```\r\n#include \"src/demo.h\"\r\n\r\n#include <iostream>\r\n\r\n#include \"src/main.rs.h\"\r\n\r\nnamespace org {\r\nnamespace example {\r\n\r\nvoid do_thing(const SharedThing& state) { std::cout << state.x << std::endl; }\r\n\r\n}  // namespace example\r\n}  // namespace org\r\n```\r\n\r\n`build.rs`:\r\n\r\n```\r\nfn main() {\r\n    cxx_build::bridge(\"src/main.rs\")\r\n        .file(\"src/demo.cc\")\r\n        .flag_if_supported(\"-std=c++14\")\r\n        .compile(\"cxxbridge-demo\");\r\n\r\n    println!(\"cargo:rerun-if-changed=src/main.rs\");\r\n    println!(\"cargo:rerun-if-changed=src/demo.h\");\r\n    println!(\"cargo:rerun-if-changed=src/demo.cc\");\r\n}\r\n```\r\n\r\n`Cargo.toml`:\r\n\r\n```\r\n[package]\r\nname = \"cxx_test\"\r\nversion = \"0.1.0\"\r\nedition = \"2018\"\r\n\r\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\r\n\r\n[dependencies]\r\ncxx = \"0.3\"\r\n\r\n\r\n[build-dependencies]\r\ncxx-build = \"0.3\"\r\n```\r\n\r\nResulting error:\r\n```\r\nerror: `extern` block uses type `std::string::String`, which is not FFI-safe\r\n --> src/main.rs:9:28\r\n  |\r\n9 |         fn do_thing(state: &SharedThing);\r\n  |                            ^^^^^^^^^^^^ not FFI-safe\r\n  |\r\nnote: the lint level is defined here\r\n --> src/main.rs:1:1\r\n  |\r\n1 | #[cxx::bridge(namespace = org::example)]\r\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  = help: consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\r\n  = note: this struct has unspecified layout\r\n  = note: this error originates in an attribute macro (in Nightly builds, run with -Z macro-backtrace for more info)\r\n\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `cxx_test`.\r\n```\r\n\r\nChanging it to pass-by-value works fine.\r\n\r\nChanging `x` to a non-String type also works.\n",
        "hints_text": "Can confirm this. Passing `String` on its own (by value or shared-ref) works as expected:\r\n```\r\n#[cxx::bridge]\r\nmod ffi {\r\n\textern \"C\" {\r\n\t\tfn pass_by_ref(s: &String) -> String;\r\n\t\tfn pass_by_value(s: String) -> String;\r\n\t}\r\n}\r\n```\r\n\r\nBut good to hear that it's still possible to pass the struct by value as a workaround.  \r\nFor completeness, there are a few other ways I tried to pass strings to C++:\r\n* `Box<String>` fails with _unsupported target type of Box_\r\n* `Box<str>` fails with _unsupported type_\r\n* `*const char` fails with _unsupported type_\r\n* `Vec<u8>` also fails with _not FFI-safe_, if enclosing struct is passed by reference\r\n* `&str` would need a lifetime annotation, fails with _struct with generic parameters is not supported yet_\r\n* `CxxString` cannot be constructed from Rust\r\n\nI have been using a `UniquePtr<CxxString>` in structs. As you note you can't construct them from Rust, but you can expose another C++ API which makes one from a `&str`.",
        "created_at": "2020-11-03T02:33:17Z",
        "version": "0.5"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 396,
        "instance_id": "dtolnay__cxx-396",
        "issue_numbers": [
            "232"
        ],
        "base_commit": "98f2b5f6cd9b3842f0cd4e37831f9d70cc89cd42",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -594,7 +594,7 @@ fn expand_rust_function_shim_impl(\n                 quote!(#receiver_type::#ident)\n             }\n         },\n-        None => quote!(__extern),\n+        None => quote!(::std::mem::transmute::<*const (), #sig>(__extern)),\n     };\n     call.extend(quote! { (#(#vars),*) });\n \ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -662,7 +662,7 @@ fn expand_rust_function_shim_impl(\n     };\n \n     let pointer = match invoke {\n-        None => Some(quote!(__extern: #sig)),\n+        None => Some(quote!(__extern: *const ())),\n         Some(_) => None,\n     };\n \n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -169,10 +169,7 @@ pub mod ffi {\n         fn c_take_ref_rust_vec_string(v: &Vec<String>);\n         fn c_take_ref_rust_vec_index(v: &Vec<u8>);\n         fn c_take_ref_rust_vec_copy(v: &Vec<u8>);\n-        /*\n-        // https://github.com/dtolnay/cxx/issues/232\n         fn c_take_callback(callback: fn(String) -> usize);\n-        */\n         fn c_take_enum(e: Enum);\n         fn c_take_ns_enum(e: AEnum);\n         fn c_take_nested_ns_enum(e: ABEnum);\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -385,12 +385,9 @@ void c_take_ref_rust_vec_copy(const rust::Vec<uint8_t> &v) {\n   }\n }\n \n-/*\n-// https://github.com/dtolnay/cxx/issues/232\n void c_take_callback(rust::Fn<size_t(rust::String)> callback) {\n   callback(\"2020\");\n }\n-*/\n \n void c_take_enum(Enum e) {\n   if (e == Enum::AVal) {\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -134,10 +134,7 @@ void c_take_ref_rust_vec(const rust::Vec<uint8_t> &v);\n void c_take_ref_rust_vec_string(const rust::Vec<rust::String> &v);\n void c_take_ref_rust_vec_index(const rust::Vec<uint8_t> &v);\n void c_take_ref_rust_vec_copy(const rust::Vec<uint8_t> &v);\n-/*\n-// https://github.com/dtolnay/cxx/issues/232\n void c_take_callback(rust::Fn<size_t(rust::String)> callback);\n-*/\n void c_take_enum(Enum e);\n void c_take_ns_enum(::A::AEnum e);\n void c_take_nested_ns_enum(::A::B::ABEnum e);\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -149,8 +149,6 @@ fn test_c_take() {\n     check!(ffi::c_take_nested_ns_enum(ffi::ABEnum::ABAVal));\n }\n \n-/*\n-// https://github.com/dtolnay/cxx/issues/232\n #[test]\n fn test_c_callback() {\n     fn callback(s: String) -> usize {\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -162,7 +160,6 @@ fn test_c_callback() {\n \n     check!(ffi::c_take_callback(callback));\n }\n-*/\n \n #[test]\n fn test_c_call_r() {\n",
        "problem_statement": "fn argument to extern fn warns as not FFI-safe\nThe ui tests started failing with a new warning on `fn` being not FFI-safe. I'll remove c_take_callback from the test suite for now to keep the ui tests active but we should fix this.\r\n\r\n```console\r\nEXPECTED:\r\n\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\r\nerror: enums with generic parameters are not allowed\r\n --> $DIR/generic_enum.rs:3:5\r\n  |\r\n3 |     enum A<T> {\r\n  |     ^^^^^^^^^\r\n\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\r\n\r\nACTUAL OUTPUT:\r\n\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\r\nwarning: `extern` fn uses type `fn(std::string::String) -> usize`, which is not FFI-safe\r\n  --> $DIR/lib.rs:67:38\r\n   |\r\n67 |         fn c_take_callback(callback: fn(String) -> usize);\r\n   |                                      ^^^^^^^^^^^^^^^^^^^ not FFI-safe\r\n   |\r\n   = note: `#[warn(improper_ctypes_definitions)]` on by default\r\n   = help: consider using an `extern fn(...) -> ...` function pointer instead\r\n   = note: this function pointer has Rust-specific calling convention\r\n\r\nwarning: 1 warning emitted\r\n\r\nerror: enums with generic parameters are not allowed\r\n --> $DIR/generic_enum.rs:3:5\r\n  |\r\n3 |     enum A<T> {\r\n  |     ^^^^^^^^^\r\n\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\u2508\r\n```\n",
        "hints_text": "",
        "created_at": "2020-11-01T06:55:23Z",
        "version": "0.5"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 392,
        "instance_id": "dtolnay__cxx-392",
        "issue_numbers": [
            "386"
        ],
        "base_commit": "630af887178ee02c9f2671efcb085759920aa6c7",
        "patch": "diff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -32,6 +32,7 @@ pub(super) fn gen<'a>(apis: &[Api], types: &'a Types, opt: &Opt, header: bool) -\n \n     let apis_by_namespace = NamespaceEntries::new(apis);\n \n+    gen_namespace_forward_declarations(&apis_by_namespace, out);\n     gen_namespace_contents(&apis_by_namespace, types, opt, header, out);\n \n     if !header {\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -44,13 +45,7 @@ pub(super) fn gen<'a>(apis: &[Api], types: &'a Types, opt: &Opt, header: bool) -\n     out_file\n }\n \n-fn gen_namespace_contents(\n-    ns_entries: &NamespaceEntries,\n-    types: &Types,\n-    opt: &Opt,\n-    header: bool,\n-    out: &mut OutFile,\n-) {\n+fn gen_namespace_forward_declarations(ns_entries: &NamespaceEntries, out: &mut OutFile) {\n     let apis = ns_entries.entries();\n \n     out.next_section();\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -63,6 +58,24 @@ fn gen_namespace_contents(\n         }\n     }\n \n+    out.next_section();\n+\n+    for (child_ns, child_ns_entries) in ns_entries.children() {\n+        writeln!(out, \"namespace {} {{\", child_ns);\n+        gen_namespace_forward_declarations(&child_ns_entries, out);\n+        writeln!(out, \"}} // namespace {}\", child_ns);\n+    }\n+}\n+\n+fn gen_namespace_contents(\n+    ns_entries: &NamespaceEntries,\n+    types: &Types,\n+    opt: &Opt,\n+    header: bool,\n+    out: &mut OutFile,\n+) {\n+    let apis = ns_entries.entries();\n+\n     let mut methods_for_type = HashMap::new();\n     for api in apis.iter() {\n         if let Api::RustFunction(efn) = api {\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -101,6 +101,16 @@ pub mod ffi {\n         z: usize,\n     }\n \n+    #[namespace = \"first\"]\n+    struct First {\n+        second: Box<Second>,\n+    }\n+\n+    #[namespace = \"second\"]\n+    struct Second {\n+        i: i32,\n+    }\n+\n     extern \"C\" {\n         include!(\"tests/ffi/tests.h\");\n \n",
        "problem_statement": "Order sensitivity across namespaces\nThe namespace sorting introduced in #370 does not handle alphabetically lesser namespaces referencing items from alphabetically greater namespaces.\r\n\r\n```rust\r\n#[cxx::bridge]\r\nmod ffi {\r\n    #[namespace = \"first\"]\r\n    struct First {\r\n        second: Box<Second>,\r\n    }\r\n\r\n    #[namespace = \"second\"]\r\n    struct Second {\r\n        i: i32,\r\n    }\r\n}\r\n```\r\n\r\n```console\r\ntarget/debug/build/demo-d74fe843f72e57b6/out/cxxbridge/sources/demo/src/main.rs.cc:154:17: error: \u2018::second\u2019 has not been declared\r\n  154 |   ::rust::Box<::second::Second> second;\r\n      |                 ^~~~~~\r\ntarget/debug/build/demo-d74fe843f72e57b6/out/cxxbridge/sources/demo/src/main.rs.cc:154:31: error: template argument 1 is invalid\r\n  154 |   ::rust::Box<::second::Second> second;\r\n      |                               ^\r\n```\n",
        "hints_text": "Good spot.\r\n\r\nI am assuming that the correct fix is to write out forward declarations across all namespaces, and then iterate all the namespaces again to write everything else. I shall do so when I get a moment.\nActually that is nonsense and won't work at all. I need to first look into how sensitive cxx is to definition order irrespective of namespaces.\nThere is order sensitivity without namespaces too:\r\n\r\n```rust\r\n    struct A {\r\n        b: B\r\n    }\r\n\r\n    struct B {\r\n        c: i32\r\n    }\r\n```\r\n\r\nworks in normal Rust code, but does not work in a `#[cxx::bridge]` mod.\r\n\r\n```\r\ncargo:warning=/Users/adetaylor/dev/cxx/target/debug/build/demo-0110b4ddc5238254/out/cxxbridge/sources/demo/src/main.rs.cc:205:21: error: field has incomplete type '::org::example::B'\r\n  cargo:warning=  ::org::example::B b;\r\n  cargo:warning=                    ^\r\n  cargo:warning=/Users/adetaylor/dev/cxx/target/debug/build/demo-0110b4ddc5238254/out/cxxbridge/sources/demo/src/main.rs.cc:189:8: note: forward declaration of 'org::example::B'\r\n  cargo:warning=struct B;\r\n  cargo:warning=       ^\r\n  cargo:warning=1 error generated.\r\n```\r\n\r\nI assume this is a known limitation of what can be put in `cxx::bridge` mods, but I think it probably makes sense to fix this at the same time by doing a topological sort of all the structs then outputting them in that order. This sounds fun. However, it would be nice to use an algorithm which, instead of sorting into a list of types, sorts into a list _of lists_ of types. Then within each inner list we can continue to sort by namespace to avoid outputting too many zillions of namespace declarations.\nThe \"field has incomplete type\" issue is #292. I should have used `second: Box<Second>` for this one; fixed the repro at the top. Topological sort could solve both but I would also accept just forward declarations to close this one.\nOK cool. I will probably just do the forward declaration thing then. It may not be for a few days; it's proving to be a busy weekend.",
        "created_at": "2020-11-01T05:34:15Z",
        "version": "0.5"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 391,
        "instance_id": "dtolnay__cxx-391",
        "issue_numbers": [
            "118"
        ],
        "base_commit": "1549106cb02a216c2182e3c75cfc8aad13834d13",
        "patch": "diff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -619,7 +619,6 @@ fn write_cxx_function_shim(out: &mut OutFile, efn: &ExternFn, impl_annotations:\n     }\n     match &efn.ret {\n         Some(Type::Ref(_)) => write!(out, \"&\"),\n-        Some(Type::Str(_)) if !indirect_return => write!(out, \"::rust::Str::Repr(\"),\n         Some(Type::SliceRefU8(_)) if !indirect_return => {\n             write!(out, \"::rust::Slice<uint8_t>::Repr(\")\n         }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -659,7 +658,7 @@ fn write_cxx_function_shim(out: &mut OutFile, efn: &ExternFn, impl_annotations:\n     match &efn.ret {\n         Some(Type::RustBox(_)) => write!(out, \".into_raw()\"),\n         Some(Type::UniquePtr(_)) => write!(out, \".release()\"),\n-        Some(Type::Str(_)) | Some(Type::SliceRefU8(_)) if !indirect_return => write!(out, \")\"),\n+        Some(Type::SliceRefU8(_)) if !indirect_return => write!(out, \")\"),\n         _ => {}\n     }\n     if indirect_return {\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -866,7 +865,6 @@ fn write_rust_function_shim_impl(\n             write!(out, \", \");\n         }\n         match &arg.ty {\n-            Type::Str(_) => write!(out, \"::rust::Str::Repr(\"),\n             Type::SliceRefU8(_) => write!(out, \"::rust::Slice<uint8_t>::Repr(\"),\n             ty if out.types.needs_indirect_abi(ty) => write!(out, \"&\"),\n             _ => {}\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -875,7 +873,7 @@ fn write_rust_function_shim_impl(\n         match &arg.ty {\n             Type::RustBox(_) => write!(out, \".into_raw()\"),\n             Type::UniquePtr(_) => write!(out, \".release()\"),\n-            Type::Str(_) | Type::SliceRefU8(_) => write!(out, \")\"),\n+            Type::SliceRefU8(_) => write!(out, \")\"),\n             ty if ty != RustString && out.types.needs_indirect_abi(ty) => write!(out, \"$.value\"),\n             _ => {}\n         }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -939,7 +937,6 @@ fn write_indirect_return_type(out: &mut OutFile, ty: &Type) {\n             write_type(out, &ty.inner);\n             write!(out, \" *\");\n         }\n-        Type::Str(_) => write!(out, \"::rust::Str::Repr\"),\n         Type::SliceRefU8(_) => write!(out, \"::rust::Slice<uint8_t>::Repr\"),\n         _ => write_type(out, ty),\n     }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -967,7 +964,6 @@ fn write_extern_return_type_space(out: &mut OutFile, ty: &Option<Type>) {\n             write_type(out, &ty.inner);\n             write!(out, \" *\");\n         }\n-        Some(Type::Str(_)) => write!(out, \"::rust::Str::Repr \"),\n         Some(Type::SliceRefU8(_)) => write!(out, \"::rust::Slice<uint8_t>::Repr \"),\n         Some(ty) if out.types.needs_indirect_abi(ty) => write!(out, \"void \"),\n         _ => write_return_type(out, ty),\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -980,7 +976,6 @@ fn write_extern_arg(out: &mut OutFile, arg: &Var) {\n             write_type_space(out, &ty.inner);\n             write!(out, \"*\");\n         }\n-        Type::Str(_) => write!(out, \"::rust::Str::Repr \"),\n         Type::SliceRefU8(_) => write!(out, \"::rust::Slice<uint8_t>::Repr \"),\n         _ => write_type_space(out, &arg.ty),\n     }\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -79,19 +79,11 @@ class Str final {\n   Str(const Str &) noexcept = default;\n   ~Str() noexcept = default;\n \n-  // Repr is PRIVATE; must not be used other than by our generated code.\n-  //\n+private:\n   // Not necessarily ABI compatible with &str. Codegen will translate to\n   // cxx::rust_str::RustStr which matches this layout.\n-  struct Repr final {\n-    const char *ptr;\n-    size_t len;\n-  };\n-  Str(Repr) noexcept;\n-  explicit operator Repr() const noexcept;\n-\n-private:\n-  Repr repr;\n+  const char *ptr;\n+  size_t len;\n };\n #endif // CXXBRIDGE05_RUST_STR\n \ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -115,33 +115,33 @@ std::ostream &operator<<(std::ostream &os, const String &s) {\n   return os;\n }\n \n-Str::Str() noexcept : repr(Repr{reinterpret_cast<const char *>(1), 0}) {}\n+Str::Str() noexcept : ptr(reinterpret_cast<const char *>(1)), len(0) {}\n \n-static void initStr(Str::Repr repr) {\n-  if (!cxxbridge05$str$valid(repr.ptr, repr.len)) {\n+static void initStr(const char *ptr, size_t len) {\n+  if (!cxxbridge05$str$valid(ptr, len)) {\n     panic<std::invalid_argument>(\"data for rust::Str is not utf-8\");\n   }\n }\n \n-Str::Str(const std::string &s) : repr(Repr{s.data(), s.length()}) {\n-  initStr(this->repr);\n+Str::Str(const std::string &s) : ptr(s.data()), len(s.length()) {\n+  initStr(this->ptr, this->len);\n }\n \n-Str::Str(const char *s) : repr(Repr{s, std::strlen(s)}) {\n+Str::Str(const char *s) : ptr(s), len(std::strlen(s)) {\n   assert(s != nullptr);\n-  initStr(this->repr);\n+  initStr(this->ptr, this->len);\n }\n \n Str::Str(const char *s, size_t len)\n-    : repr(\n-          Repr{s == nullptr && len == 0 ? reinterpret_cast<const char *>(1) : s,\n-               len}) {\n+    : ptr(s == nullptr && len == 0 ? reinterpret_cast<const char *>(1) : s),\n+      len(len) {\n   assert(s != nullptr || len == 0);\n-  initStr(this->repr);\n+  initStr(this->ptr, this->len);\n }\n \n Str &Str::operator=(Str other) noexcept {\n-  this->repr = other.repr;\n+  this->ptr = other.ptr;\n+  this->len = other.len;\n   return *this;\n }\n \ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -149,15 +149,11 @@ Str::operator std::string() const {\n   return std::string(this->data(), this->size());\n }\n \n-const char *Str::data() const noexcept { return this->repr.ptr; }\n-\n-size_t Str::size() const noexcept { return this->repr.len; }\n-\n-size_t Str::length() const noexcept { return this->repr.len; }\n+const char *Str::data() const noexcept { return this->ptr; }\n \n-Str::Str(Repr repr_) noexcept : repr(repr_) {}\n+size_t Str::size() const noexcept { return this->len; }\n \n-Str::operator Repr() const noexcept { return this->repr; }\n+size_t Str::length() const noexcept { return this->len; }\n \n std::ostream &operator<<(std::ostream &os, const Str &s) {\n   os.write(s.data(), s.size());\n",
        "test_patch": "diff --git a/tests/cxx_gen.rs b/tests/cxx_gen.rs\n--- a/tests/cxx_gen.rs\n+++ b/tests/cxx_gen.rs\n@@ -18,7 +18,7 @@ fn test_extern_c_function() {\n     let output = str::from_utf8(&generated.implementation).unwrap();\n     // To avoid continual breakage we won't test every byte.\n     // Let's look for the major features.\n-    assert!(output.contains(\"void cxxbridge05$do_cpp_thing(::rust::Str::Repr foo)\"));\n+    assert!(output.contains(\"void cxxbridge05$do_cpp_thing(::rust::Str foo)\"));\n }\n \n #[test]\ndiff --git a/tests/cxx_gen.rs b/tests/cxx_gen.rs\n--- a/tests/cxx_gen.rs\n+++ b/tests/cxx_gen.rs\n@@ -28,5 +28,5 @@ fn test_impl_annotation() {\n     let source = BRIDGE0.parse().unwrap();\n     let generated = generate_header_and_cc(source, &opt).unwrap();\n     let output = str::from_utf8(&generated.implementation).unwrap();\n-    assert!(output.contains(\"ANNOTATION void cxxbridge05$do_cpp_thing(::rust::Str::Repr foo)\"));\n+    assert!(output.contains(\"ANNOTATION void cxxbridge05$do_cpp_thing(::rust::Str foo)\"));\n }\n",
        "problem_statement": "Remove Str::Repr nested struct from cxx.h\nThis should be implemented some other way. It shouldn't be necessary to include this \"private\" public nested struct which is only supposed to be used by our code generator. Instead the code generator should be built using only public constructors and member functions on rust::Str.\n",
        "hints_text": "",
        "created_at": "2020-11-01T00:37:53Z",
        "version": "0.5"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 361,
        "instance_id": "dtolnay__cxx-361",
        "issue_numbers": [
            "360"
        ],
        "base_commit": "e35673d7debe16222c1667131e51969c093e225c",
        "patch": "diff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1245,7 +1245,12 @@ fn write_unique_ptr_common(out: &mut OutFile, ty: &Type, types: &Types) {\n     let instance = to_mangled(&out.namespace, ty);\n \n     let can_construct_from_value = match ty {\n-        Type::Ident(ident) => types.structs.contains_key(ident),\n+        // Some aliases are to opaque types; some are to trivial types.\n+        // We can't know at code generation time, so we generate both C++\n+        // and Rust side bindings for a \"new\" method anyway. But the Rust\n+        // code can't be called for Opaque types because the 'new'\n+        // method is not implemented.\n+        Type::Ident(ident) => types.structs.contains_key(ident) || types.aliases.contains_key(ident),\n         _ => false,\n     };\n \ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -814,7 +814,7 @@ fn expand_unique_ptr(\n     let link_release = format!(\"{}release\", prefix);\n     let link_drop = format!(\"{}drop\", prefix);\n \n-    let new_method = if types.structs.contains_key(ident) {\n+    let new_method = if types.structs.contains_key(ident) || types.aliases.contains_key(ident) {\n         Some(quote! {\n             fn __new(mut value: Self) -> *mut ::std::ffi::c_void {\n                 extern \"C\" {\ndiff --git a/src/unique_ptr.rs b/src/unique_ptr.rs\n--- a/src/unique_ptr.rs\n+++ b/src/unique_ptr.rs\n@@ -1,5 +1,7 @@\n use crate::cxx_string::CxxString;\n use crate::cxx_vector::{self, CxxVector, VectorElement};\n+use crate::ExternType;\n+use crate::kind::Trivial;\n use core::ffi::c_void;\n use core::fmt::{self, Debug, Display};\n use core::marker::PhantomData;\ndiff --git a/src/unique_ptr.rs b/src/unique_ptr.rs\n--- a/src/unique_ptr.rs\n+++ b/src/unique_ptr.rs\n@@ -32,7 +34,9 @@ where\n     }\n \n     /// Allocates memory on the heap and makes a UniquePtr pointing to it.\n-    pub fn new(value: T) -> Self {\n+    pub fn new(value: T) -> Self\n+    where\n+    T: ExternType<Kind = Trivial> {\n         UniquePtr {\n             repr: T::__new(value),\n             ty: PhantomData,\n",
        "test_patch": "diff --git a/tests/BUCK b/tests/BUCK\n--- a/tests/BUCK\n+++ b/tests/BUCK\n@@ -3,7 +3,10 @@ load(\"//tools/buck:rust_cxx_bridge.bzl\", \"rust_cxx_bridge\")\n rust_test(\n     name = \"test\",\n     srcs = [\"test.rs\"],\n-    deps = [\":ffi\"],\n+    deps = [\n+        \":ffi\",\n+        \"//:cxx\",\n+    ],\n )\n \n rust_library(\ndiff --git a/tests/BUILD b/tests/BUILD\n--- a/tests/BUILD\n+++ b/tests/BUILD\n@@ -6,7 +6,10 @@ rust_test(\n     name = \"test\",\n     size = \"small\",\n     srcs = [\"test.rs\"],\n-    deps = [\":cxx_test_suite\"],\n+    deps = [\n+        \":cxx_test_suite\",\n+        \"//:cxx\",\n+    ],\n )\n \n rust_library(\ndiff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -16,13 +16,13 @@ mod other {\n \n     #[repr(C)]\n     pub struct D {\n-        d: u64,\n+        pub d: u64,\n     }\n \n     #[repr(C)]\n     pub struct E {\n-        e: u64,\n         e_str: CxxString,\n+        e: u64,\n     }\n \n     unsafe impl ExternType for D {\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -199,6 +199,7 @@ fn test_extern_trivial() {\n     check!(ffi2::c_take_trivial(d));\n     let d = ffi2::c_return_trivial_ptr();\n     check!(ffi2::c_take_trivial_ptr(d));\n+    cxx::UniquePtr::new(ffi2::D { d: 42 });\n }\n \n #[test]\ndiff --git /dev/null b/tests/ui/unique_ptr_to_opaque.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/unique_ptr_to_opaque.rs\n@@ -0,0 +1,26 @@\n+mod outside {\n+    #[repr(C)]\n+    pub struct C {\n+        pub a: u8,\n+    }\n+    unsafe impl cxx::ExternType for C {\n+        type Id = cxx::type_id!(\"C\");\n+        type Kind = cxx::kind::Opaque;\n+    }\n+}\n+\n+\n+#[cxx::bridge]\n+mod ffi {\n+    impl UniquePtr<C> {}\n+\n+    extern \"C\" {\n+        type C = crate::outside::C;\n+    }\n+\n+    impl UniquePtr<C> {}\n+}\n+\n+fn main() {\n+    cxx::UniquePtr::new(outside::C { a: 4 } );\n+}\ndiff --git /dev/null b/tests/ui/unique_ptr_to_opaque.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/unique_ptr_to_opaque.stderr\n@@ -0,0 +1,7 @@\n+error[E0271]: type mismatch resolving `<outside::C as ExternType>::Kind == Trivial`\n+  --> $DIR/unique_ptr_to_opaque.rs:25:5\n+   |\n+25 |     cxx::UniquePtr::new(outside::C { a: 4 } );\n+   |     ^^^^^^^^^^^^^^^^^^^ expected enum `Trivial`, found enum `cxx::kind::Opaque`\n+   |\n+   = note: required by `UniquePtr::<T>::new`\n",
        "problem_statement": "Allow UniquePtr::new on Trivial ExternTypes\nExample from autocxx:\r\n\r\n```rust\r\nmod ffi {\r\n    unsafe impl cxx::ExternType for bindgen::A {\r\n        type Id = cxx::type_id!(\"A\");\r\n        type Kind = cxx::kind::Trivial;\r\n    }\r\n    mod bindgen {\r\n        #[repr(C)]\r\n        pub struct A {\r\n            pub a: u32,\r\n        }\r\n    }\r\n    #[cxx::bridge]\r\n    pub mod cxxbridge {\r\n        impl UniquePtr<A> {}\r\n        extern \"C\" {\r\n            include!(\"input.h\");\r\n            type A = super::bindgen::A;\r\n        }\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let a = ffi::cxxbridge::A { a: 14 };\r\n    let _ = cxx::UniquePtr::new(a);\r\n}\r\n```\r\n\r\nfails because it hits this `unreachable!`:\r\n\r\n```rust\r\n// Methods are private; not intended to be implemented outside of cxxbridge\r\n// codebase.\r\npub unsafe trait UniquePtrTarget {\r\n   //...\r\n    #[doc(hidden)]\r\n    fn __new(value: Self) -> *mut c_void\r\n    where\r\n        Self: Sized,\r\n    {\r\n        // Opaque C types do not get this method because they can never exist by\r\n        // value on the Rust side of the bridge.\r\n        let _ = value;\r\n        unreachable!()\r\n    }\r\n    //...\r\n}\r\n```\r\n\r\nThe fix is for `expand_unique_ptr` in `expand.rs` to generate a `__new` method under slightly more circumstances, when an extern type is known to be trivial.\n",
        "hints_text": "",
        "created_at": "2020-10-12T23:21:03Z",
        "version": "0.5"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 336,
        "instance_id": "dtolnay__cxx-336",
        "issue_numbers": [
            "329"
        ],
        "base_commit": "c86633d53c1150048cbcb2605403ffb227c853b4",
        "patch": "diff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1056,14 +1056,18 @@ fn write_generic_instantiations(out: &mut OutFile, types: &Types) {\n             }\n         } else if let Type::UniquePtr(ptr) = ty {\n             if let Type::Ident(inner) = &ptr.inner {\n-                if Atom::from(inner).is_none() && !types.aliases.contains_key(inner) {\n+                if Atom::from(inner).is_none()\n+                    && (!types.aliases.contains_key(inner) || types.explicit_impls.contains(ty))\n+                {\n                     out.next_section();\n                     write_unique_ptr(out, inner, types);\n                 }\n             }\n         } else if let Type::CxxVector(ptr) = ty {\n             if let Type::Ident(inner) = &ptr.inner {\n-                if Atom::from(inner).is_none() && !types.aliases.contains_key(inner) {\n+                if Atom::from(inner).is_none()\n+                    && (!types.aliases.contains_key(inner) || types.explicit_impls.contains(ty))\n+                {\n                     out.next_section();\n                     write_cxx_vector(out, ty, inner, types);\n                 }\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -39,7 +39,7 @@ fn expand(ffi: Module, apis: &[Api], types: &Types) -> TokenStream {\n \n     for api in apis {\n         match api {\n-            Api::Include(_) | Api::RustType(_) => {}\n+            Api::Include(_) | Api::RustType(_) | Api::Impl(_) => {}\n             Api::Struct(strct) => expanded.extend(expand_struct(strct)),\n             Api::Enum(enm) => expanded.extend(expand_enum(enm)),\n             Api::CxxType(ety) => {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -76,13 +76,17 @@ fn expand(ffi: Module, apis: &[Api], types: &Types) -> TokenStream {\n             }\n         } else if let Type::UniquePtr(ptr) = ty {\n             if let Type::Ident(ident) = &ptr.inner {\n-                if Atom::from(ident).is_none() && !types.aliases.contains_key(ident) {\n+                if Atom::from(ident).is_none()\n+                    && (!types.aliases.contains_key(ident) || types.explicit_impls.contains(ty))\n+                {\n                     expanded.extend(expand_unique_ptr(namespace, ident, types));\n                 }\n             }\n         } else if let Type::CxxVector(ptr) = ty {\n             if let Type::Ident(ident) = &ptr.inner {\n-                if Atom::from(ident).is_none() && !types.aliases.contains_key(ident) {\n+                if Atom::from(ident).is_none()\n+                    && (!types.aliases.contains_key(ident) || types.explicit_impls.contains(ty))\n+                {\n                     // Generate impl for CxxVector<T> if T is a struct or opaque\n                     // C++ type. Impl for primitives is already provided by cxx\n                     // crate.\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -3,8 +3,8 @@ use crate::syntax::namespace::Namespace;\n use crate::syntax::report::Errors;\n use crate::syntax::types::TrivialReason;\n use crate::syntax::{\n-    error, ident, Api, Enum, ExternFn, ExternType, Lang, Receiver, Ref, Slice, Struct, Ty1, Type,\n-    Types,\n+    error, ident, Api, Enum, ExternFn, ExternType, Impl, Lang, Receiver, Ref, Slice, Struct, Ty1,\n+    Type, Types,\n };\n use proc_macro2::{Delimiter, Group, Ident, TokenStream};\n use quote::{quote, ToTokens};\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -48,6 +48,7 @@ fn do_typecheck(cx: &mut Check) {\n             Api::Enum(enm) => check_api_enum(cx, enm),\n             Api::CxxType(ety) | Api::RustType(ety) => check_api_type(cx, ety),\n             Api::CxxFunction(efn) | Api::RustFunction(efn) => check_api_fn(cx, efn),\n+            Api::Impl(imp) => check_api_impl(cx, imp),\n             _ => {}\n         }\n     }\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -286,6 +287,18 @@ fn check_api_fn(cx: &mut Check, efn: &ExternFn) {\n     check_multiple_arg_lifetimes(cx, efn);\n }\n \n+fn check_api_impl(cx: &mut Check, imp: &Impl) {\n+    if let Type::UniquePtr(ty) | Type::CxxVector(ty) = &imp.ty {\n+        if let Type::Ident(inner) = &ty.inner {\n+            if Atom::from(inner).is_none() {\n+                return;\n+            }\n+        }\n+    }\n+\n+    cx.error(imp, \"unsupported Self type of explicit impl\");\n+}\n+\n fn check_mut_return_restriction(cx: &mut Check, efn: &ExternFn) {\n     match &efn.ret {\n         Some(Type::Ref(ty)) if ty.mutability.is_some() => {}\ndiff --git a/syntax/file.rs b/syntax/file.rs\n--- a/syntax/file.rs\n+++ b/syntax/file.rs\n@@ -2,8 +2,8 @@ use crate::syntax::namespace::Namespace;\n use quote::quote;\n use syn::parse::{Error, Parse, ParseStream, Result};\n use syn::{\n-    braced, token, Abi, Attribute, ForeignItem, Ident, Item as RustItem, ItemEnum, ItemStruct,\n-    ItemUse, LitStr, Token, Visibility,\n+    braced, token, Abi, Attribute, ForeignItem, Ident, Item as RustItem, ItemEnum, ItemImpl,\n+    ItemStruct, ItemUse, LitStr, Token, Visibility,\n };\n \n pub struct Module {\ndiff --git a/syntax/file.rs b/syntax/file.rs\n--- a/syntax/file.rs\n+++ b/syntax/file.rs\n@@ -22,6 +22,7 @@ pub enum Item {\n     Enum(ItemEnum),\n     ForeignMod(ItemForeignMod),\n     Use(ItemUse),\n+    Impl(ItemImpl),\n     Other(RustItem),\n }\n \ndiff --git a/syntax/file.rs b/syntax/file.rs\n--- a/syntax/file.rs\n+++ b/syntax/file.rs\n@@ -99,6 +100,7 @@ impl Parse for Item {\n                 brace_token: item.brace_token,\n                 items: item.items,\n             })),\n+            RustItem::Impl(item) => Ok(Item::Impl(ItemImpl { attrs, ..item })),\n             RustItem::Use(item) => Ok(Item::Use(ItemUse { attrs, ..item })),\n             other => Ok(Item::Other(other)),\n         }\ndiff --git a/syntax/ident.rs b/syntax/ident.rs\n--- a/syntax/ident.rs\n+++ b/syntax/ident.rs\n@@ -20,7 +20,7 @@ pub(crate) fn check_all(cx: &mut Check, namespace: &Namespace, apis: &[Api]) {\n \n     for api in apis {\n         match api {\n-            Api::Include(_) => {}\n+            Api::Include(_) | Api::Impl(_) => {}\n             Api::Struct(strct) => {\n                 check(cx, &strct.ident);\n                 for field in &strct.fields {\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -42,6 +42,7 @@ pub enum Api {\n     RustType(ExternType),\n     RustFunction(ExternFn),\n     TypeAlias(TypeAlias),\n+    Impl(Impl),\n }\n \n pub struct ExternType {\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -87,6 +88,12 @@ pub struct TypeAlias {\n     pub semi_token: Token![;],\n }\n \n+pub struct Impl {\n+    pub impl_token: Token![impl],\n+    pub ty: Type,\n+    pub brace_token: Brace,\n+}\n+\n pub struct Signature {\n     pub unsafety: Option<Token![unsafe]>,\n     pub fn_token: Token![fn],\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -3,17 +3,17 @@ use crate::syntax::file::{Item, ItemForeignMod};\n use crate::syntax::report::Errors;\n use crate::syntax::Atom::*;\n use crate::syntax::{\n-    attrs, error, Api, Doc, Enum, ExternFn, ExternType, Lang, Receiver, Ref, Signature, Slice,\n-    Struct, Ty1, Type, TypeAlias, Var, Variant,\n+    attrs, error, Api, Doc, Enum, ExternFn, ExternType, Impl, Lang, Receiver, Ref, Signature,\n+    Slice, Struct, Ty1, Type, TypeAlias, Var, Variant,\n };\n-use proc_macro2::{TokenStream, TokenTree};\n+use proc_macro2::{Delimiter, Group, TokenStream, TokenTree};\n use quote::{format_ident, quote, quote_spanned};\n use syn::parse::{ParseStream, Parser};\n use syn::punctuated::Punctuated;\n use syn::{\n     Abi, Attribute, Error, Fields, FnArg, ForeignItem, ForeignItemFn, ForeignItemType,\n-    GenericArgument, Ident, ItemEnum, ItemStruct, LitStr, Pat, PathArguments, Result, ReturnType,\n-    Token, Type as RustType, TypeBareFn, TypePath, TypeReference, TypeSlice,\n+    GenericArgument, Ident, ItemEnum, ItemImpl, ItemStruct, LitStr, Pat, PathArguments, Result,\n+    ReturnType, Token, Type as RustType, TypeBareFn, TypePath, TypeReference, TypeSlice,\n };\n \n pub mod kw {\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -33,6 +33,10 @@ pub fn parse_items(cx: &mut Errors, items: Vec<Item>, trusted: bool) -> Vec<Api>\n                 Err(err) => cx.push(err),\n             },\n             Item::ForeignMod(foreign_mod) => parse_foreign_mod(cx, foreign_mod, &mut apis, trusted),\n+            Item::Impl(item) => match parse_impl(item) {\n+                Ok(imp) => apis.push(imp),\n+                Err(err) => cx.push(err),\n+            },\n             Item::Use(item) => cx.error(item, error::USE_NOT_ALLOWED),\n             Item::Other(item) => cx.error(item, \"unsupported item\"),\n         }\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -420,6 +424,37 @@ fn parse_extern_verbatim(cx: &mut Errors, tokens: &TokenStream, lang: Lang) -> R\n     }\n }\n \n+fn parse_impl(imp: ItemImpl) -> Result<Api> {\n+    if !imp.items.is_empty() {\n+        let mut span = Group::new(Delimiter::Brace, TokenStream::new());\n+        span.set_span(imp.brace_token.span);\n+        return Err(Error::new_spanned(span, \"expected an empty impl block\"));\n+    }\n+\n+    let self_ty = &imp.self_ty;\n+    if let Some((bang, path, for_token)) = &imp.trait_ {\n+        let span = quote!(#bang #path #for_token #self_ty);\n+        return Err(Error::new_spanned(\n+            span,\n+            \"unexpected impl, expected something like `impl UniquePtr<T> {}`\",\n+        ));\n+    }\n+\n+    let generics = &imp.generics;\n+    if !generics.params.is_empty() || generics.where_clause.is_some() {\n+        return Err(Error::new_spanned(\n+            imp,\n+            \"generic parameters on an impl is not supported\",\n+        ));\n+    }\n+\n+    Ok(Api::Impl(Impl {\n+        impl_token: imp.impl_token,\n+        ty: parse_type(&self_ty)?,\n+        brace_token: imp.brace_token,\n+    }))\n+}\n+\n fn parse_include(input: ParseStream) -> Result<String> {\n     if input.peek(LitStr) {\n         return Ok(input.parse::<LitStr>()?.value());\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -1,7 +1,7 @@\n use crate::syntax::atom::Atom::*;\n use crate::syntax::{\n-    Atom, Derive, Enum, ExternFn, ExternType, Receiver, Ref, Signature, Slice, Struct, Ty1, Type,\n-    TypeAlias, Var,\n+    Atom, Derive, Enum, ExternFn, ExternType, Impl, Receiver, Ref, Signature, Slice, Struct, Ty1,\n+    Type, TypeAlias, Var,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{quote_spanned, ToTokens};\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -121,6 +121,14 @@ impl ToTokens for ExternFn {\n     }\n }\n \n+impl ToTokens for Impl {\n+    fn to_tokens(&self, tokens: &mut TokenStream) {\n+        self.impl_token.to_tokens(tokens);\n+        self.ty.to_tokens(tokens);\n+        self.brace_token.surround(tokens, |_tokens| {});\n+    }\n+}\n+\n impl ToTokens for Signature {\n     fn to_tokens(&self, tokens: &mut TokenStream) {\n         self.fn_token.to_tokens(tokens);\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -15,6 +15,7 @@ pub struct Types<'a> {\n     pub aliases: Map<&'a Ident, &'a TypeAlias>,\n     pub untrusted: Map<&'a Ident, &'a ExternType>,\n     pub required_trivial: Map<&'a Ident, TrivialReason<'a>>,\n+    pub explicit_impls: Set<&'a Type>,\n }\n \n impl<'a> Types<'a> {\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -26,6 +27,7 @@ impl<'a> Types<'a> {\n         let mut rust = Set::new();\n         let mut aliases = Map::new();\n         let mut untrusted = Map::new();\n+        let mut explicit_impls = Set::new();\n \n         fn visit<'a>(all: &mut Set<&'a Type>, ty: &'a Type) {\n             all.insert(ty);\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -133,6 +135,10 @@ impl<'a> Types<'a> {\n                     cxx.insert(ident);\n                     aliases.insert(ident, alias);\n                 }\n+                Api::Impl(imp) => {\n+                    visit(&mut all, &imp.ty);\n+                    explicit_impls.insert(&imp.ty);\n+                }\n             }\n         }\n \ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -179,6 +185,7 @@ impl<'a> Types<'a> {\n             aliases,\n             untrusted,\n             required_trivial,\n+            explicit_impls,\n         }\n     }\n \n",
        "test_patch": "diff --git /dev/null b/tests/ui/bad_explicit_impl.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/bad_explicit_impl.rs\n@@ -0,0 +1,10 @@\n+#[cxx::bridge]\n+mod ffi {\n+    struct S {\n+        x: u8,\n+    }\n+\n+    impl fn() -> &S {}\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/bad_explicit_impl.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/bad_explicit_impl.stderr\n@@ -0,0 +1,5 @@\n+error: unsupported Self type of explicit impl\n+ --> $DIR/bad_explicit_impl.rs:7:5\n+  |\n+7 |     impl fn() -> &S {}\n+  |     ^^^^^^^^^^^^^^^^^^\ndiff --git /dev/null b/tests/ui/impl_trait_for_type.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/impl_trait_for_type.rs\n@@ -0,0 +1,10 @@\n+#[cxx::bridge]\n+mod ffi {\n+    struct S {\n+        x: u8,\n+    }\n+\n+    impl UniquePtrTarget for S {}\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/impl_trait_for_type.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/impl_trait_for_type.stderr\n@@ -0,0 +1,5 @@\n+error: unexpected impl, expected something like `impl UniquePtr<T> {}`\n+ --> $DIR/impl_trait_for_type.rs:7:10\n+  |\n+7 |     impl UniquePtrTarget for S {}\n+  |          ^^^^^^^^^^^^^^^^^^^^^\ndiff --git /dev/null b/tests/ui/nonempty_impl_block.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/nonempty_impl_block.rs\n@@ -0,0 +1,12 @@\n+#[cxx::bridge]\n+mod ffi {\n+    struct S {\n+        x: u8,\n+    }\n+\n+    impl UniquePtr<S> {\n+        fn new() -> Self;\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/nonempty_impl_block.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/nonempty_impl_block.stderr\n@@ -0,0 +1,8 @@\n+error: expected an empty impl block\n+ --> $DIR/nonempty_impl_block.rs:7:23\n+  |\n+7 |       impl UniquePtr<S> {\n+  |  _______________________^\n+8 | |         fn new() -> Self;\n+9 | |     }\n+  | |_____^\ndiff --git /dev/null b/tests/ui/unique_ptr_twice.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/unique_ptr_twice.rs\n@@ -0,0 +1,19 @@\n+#[cxx::bridge]\n+mod here {\n+    extern \"C\" {\n+        type C;\n+    }\n+\n+    impl UniquePtr<C> {}\n+}\n+\n+#[cxx::bridge]\n+mod there {\n+    extern \"C\" {\n+        type C = crate::here::C;\n+    }\n+\n+    impl UniquePtr<C> {}\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/unique_ptr_twice.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/unique_ptr_twice.stderr\n@@ -0,0 +1,10 @@\n+error[E0119]: conflicting implementations of trait `cxx::private::UniquePtrTarget` for type `here::C`:\n+  --> $DIR/unique_ptr_twice.rs:10:1\n+   |\n+1  | #[cxx::bridge]\n+   | -------------- first implementation here\n+...\n+10 | #[cxx::bridge]\n+   | ^^^^^^^^^^^^^^ conflicting implementation for `here::C`\n+   |\n+   = note: this error originates in an attribute macro (in Nightly builds, run with -Z macro-backtrace for more info)\n",
        "problem_statement": "impl UniquePtrTarget for T;\nBuilds on top of #325. Fixes #236.\n",
        "hints_text": "Can we do this without exposing - and requiring users to know - the internal trait names like `UniquePtrTarget`? In #308 dtolnay@ suggested something like `impl Vec<T> {}` and `impl UniquePtr<T> {}`.\nYes, probably, I will amend that way after I eventually rebase on top of your stuff.\nOne other thing to consider here. For Vec and Box after my PR #308, the following only fails at C++ compile time because we don't have traits similar to `UniquePtrTarget` and `VectorElement` for those that can be checked with a trait bound.\r\n\r\n```\r\n#[cxx::bridge]\r\nmod here {\r\n    struct Shared {\r\n        z: usize,\r\n    }\r\n}\r\n\r\n#[cxx::bridge]\r\nmod there {\r\n    type Shared = crate::here::Shared;\r\n\r\n    extern \"C\" {\r\n        fn c_take_rust_vec_shared(v: Vec<Shared>);\r\n    }\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\nWe might want to add those in a separate PR to improve the diagnostics, plus then we can point people at this option.",
        "created_at": "2020-10-04T07:30:53Z",
        "version": "0.4"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 609,
        "instance_id": "dtolnay__cxx-609",
        "issue_numbers": [
            "607"
        ],
        "base_commit": "cd1430c5ef65932a24c7fd2fd478db16a8cb19e1",
        "patch": "diff --git a/README.md b/README.md\n--- a/README.md\n+++ b/README.md\n@@ -351,7 +351,6 @@ matter of designing a nice API for each in its non-native language.\n <tr><td>Option&lt;T&gt;</td><td><sup><i>tbd</i></sup></td></tr>\n <tr><td><sup><i>tbd</i></sup></td><td>std::map&lt;K, V&gt;</td></tr>\n <tr><td><sup><i>tbd</i></sup></td><td>std::unordered_map&lt;K, V&gt;</td></tr>\n-<tr><td><sup><i>tbd</i></sup></td><td>std::weak_ptr&lt;T&gt;</td></tr>\n </table>\n \n <br>\ndiff --git a/book/src/bindings.md b/book/src/bindings.md\n--- a/book/src/bindings.md\n+++ b/book/src/bindings.md\n@@ -52,5 +52,4 @@ matter of designing a nice API for each in its non-native language.\n <tr><td>Option&lt;T&gt;</td><td><sup><i>tbd</i></sup></td></tr>\n <tr><td><sup><i>tbd</i></sup></td><td>std::map&lt;K, V&gt;</td></tr>\n <tr><td><sup><i>tbd</i></sup></td><td>std::unordered_map&lt;K, V&gt;</td></tr>\n-<tr><td><sup><i>tbd</i></sup></td><td>std::weak_ptr&lt;T&gt;</td></tr>\n </table>\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -208,7 +208,7 @@ fn pick_includes_and_builtins(out: &mut OutFile, apis: &[Api]) {\n             Type::RustBox(_) => out.builtin.rust_box = true,\n             Type::RustVec(_) => out.builtin.rust_vec = true,\n             Type::UniquePtr(_) => out.include.memory = true,\n-            Type::SharedPtr(_) => out.include.memory = true,\n+            Type::SharedPtr(_) | Type::WeakPtr(_) => out.include.memory = true,\n             Type::Str(_) => out.builtin.rust_str = true,\n             Type::CxxVector(_) => out.include.vector = true,\n             Type::Fn(_) => out.builtin.rust_fn = true,\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1172,6 +1172,11 @@ fn write_type(out: &mut OutFile, ty: &Type) {\n             write_type(out, &ptr.inner);\n             write!(out, \">\");\n         }\n+        Type::WeakPtr(ptr) => {\n+            write!(out, \"::std::weak_ptr<\");\n+            write_type(out, &ptr.inner);\n+            write!(out, \">\");\n+        }\n         Type::CxxVector(ty) => {\n             write!(out, \"::std::vector<\");\n             write_type(out, &ty.inner);\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1251,6 +1256,7 @@ fn write_space_after_type(out: &mut OutFile, ty: &Type) {\n         | Type::RustBox(_)\n         | Type::UniquePtr(_)\n         | Type::SharedPtr(_)\n+        | Type::WeakPtr(_)\n         | Type::Str(_)\n         | Type::CxxVector(_)\n         | Type::RustVec(_)\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1357,6 +1363,16 @@ fn write_generic_instantiations(out: &mut OutFile) {\n                     write_shared_ptr(out, inner);\n                 }\n             }\n+        } else if let Type::WeakPtr(ptr) = ty {\n+            if let Type::Ident(inner) = &ptr.inner {\n+                if Atom::from(&inner.rust).is_none()\n+                    && (!out.types.aliases.contains_key(&inner.rust)\n+                        || out.types.explicit_impls.contains(ty))\n+                {\n+                    out.next_section();\n+                    write_weak_ptr(out, inner);\n+                }\n+            }\n         } else if let Type::CxxVector(vector) = ty {\n             if let Type::Ident(inner) = &vector.inner {\n                 if Atom::from(&inner.rust).is_none()\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1749,6 +1765,65 @@ fn write_shared_ptr(out: &mut OutFile, ident: &RustName) {\n     writeln!(out, \"}}\");\n }\n \n+fn write_weak_ptr(out: &mut OutFile, ident: &RustName) {\n+    let resolved = out.types.resolve(ident);\n+    let inner = resolved.to_fully_qualified();\n+    let instance = ident.to_symbol(out.types);\n+\n+    out.include.new = true;\n+    out.include.utility = true;\n+\n+    writeln!(\n+        out,\n+        \"static_assert(sizeof(::std::weak_ptr<{}>) == 2 * sizeof(void *), \\\"\\\");\",\n+        inner,\n+    );\n+    writeln!(\n+        out,\n+        \"static_assert(alignof(::std::weak_ptr<{}>) == alignof(void *), \\\"\\\");\",\n+        inner,\n+    );\n+    writeln!(\n+        out,\n+        \"void cxxbridge1$weak_ptr${}$null(::std::weak_ptr<{}> *ptr) noexcept {{\",\n+        instance, inner,\n+    );\n+    writeln!(out, \"  ::new (ptr) ::std::weak_ptr<{}>();\", inner);\n+    writeln!(out, \"}}\");\n+    writeln!(\n+        out,\n+        \"void cxxbridge1$weak_ptr${}$clone(const ::std::weak_ptr<{}>& self, ::std::weak_ptr<{}> *ptr) noexcept {{\",\n+        instance, inner, inner,\n+    );\n+    writeln!(out, \"  ::new (ptr) ::std::weak_ptr<{}>(self);\", inner);\n+    writeln!(out, \"}}\");\n+    writeln!(\n+        out,\n+        \"void cxxbridge1$weak_ptr${}$downgrade(const ::std::shared_ptr<{}>& shared, ::std::weak_ptr<{}> *weak) noexcept {{\",\n+        instance, inner, inner,\n+    );\n+    writeln!(out, \"  ::new (weak) ::std::weak_ptr<{}>(shared);\", inner);\n+    writeln!(out, \"}}\");\n+    writeln!(\n+        out,\n+        \"void cxxbridge1$weak_ptr${}$upgrade(const ::std::weak_ptr<{}>& weak, ::std::shared_ptr<{}> *shared) noexcept {{\",\n+        instance, inner, inner,\n+    );\n+    writeln!(\n+        out,\n+        \"  ::new (shared) ::std::shared_ptr<{}>(weak.lock());\",\n+        inner,\n+    );\n+    writeln!(out, \"}}\");\n+    writeln!(\n+        out,\n+        \"void cxxbridge1$weak_ptr${}$drop(::std::weak_ptr<{}> *self) noexcept {{\",\n+        instance, inner,\n+    );\n+    writeln!(out, \"  self->~weak_ptr();\");\n+    writeln!(out, \"}}\");\n+}\n+\n fn write_cxx_vector(out: &mut OutFile, element: &RustName) {\n     let inner = element.to_typename(out.types);\n     let instance = element.to_mangled(out.types);\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -101,6 +101,14 @@ fn expand(ffi: Module, apis: &[Api], types: &Types) -> TokenStream {\n                     expanded.extend(expand_shared_ptr(ident, types, explicit_impl));\n                 }\n             }\n+        } else if let Type::WeakPtr(ptr) = ty {\n+            if let Type::Ident(ident) = &ptr.inner {\n+                if Atom::from(&ident.rust).is_none()\n+                    && (explicit_impl.is_some() || !types.aliases.contains_key(&ident.rust))\n+                {\n+                    expanded.extend(expand_weak_ptr(ident, types, explicit_impl));\n+                }\n+            }\n         } else if let Type::CxxVector(ptr) = ty {\n             if let Type::Ident(ident) = &ptr.inner {\n                 if Atom::from(&ident.rust).is_none()\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1229,6 +1237,62 @@ fn expand_shared_ptr(ident: &RustName, types: &Types, explicit_impl: Option<&Imp\n     }\n }\n \n+fn expand_weak_ptr(ident: &RustName, types: &Types, explicit_impl: Option<&Impl>) -> TokenStream {\n+    let name = ident.rust.to_string();\n+    let prefix = format!(\"cxxbridge1$weak_ptr${}$\", ident.to_symbol(types));\n+    let link_null = format!(\"{}null\", prefix);\n+    let link_clone = format!(\"{}clone\", prefix);\n+    let link_downgrade = format!(\"{}downgrade\", prefix);\n+    let link_upgrade = format!(\"{}upgrade\", prefix);\n+    let link_drop = format!(\"{}drop\", prefix);\n+\n+    let begin_span =\n+        explicit_impl.map_or_else(Span::call_site, |explicit| explicit.impl_token.span);\n+    let end_span = explicit_impl.map_or_else(Span::call_site, |explicit| explicit.brace_token.span);\n+    let unsafe_token = format_ident!(\"unsafe\", span = begin_span);\n+\n+    quote_spanned! {end_span=>\n+        #unsafe_token impl ::cxx::private::WeakPtrTarget for #ident {\n+            const __NAME: &'static dyn ::std::fmt::Display = &#name;\n+            unsafe fn __null(new: *mut ::std::ffi::c_void) {\n+                extern \"C\" {\n+                    #[link_name = #link_null]\n+                    fn __null(new: *mut ::std::ffi::c_void);\n+                }\n+                __null(new);\n+            }\n+            unsafe fn __clone(this: *const ::std::ffi::c_void, new: *mut ::std::ffi::c_void) {\n+                extern \"C\" {\n+                    #[link_name = #link_clone]\n+                    fn __clone(this: *const ::std::ffi::c_void, new: *mut ::std::ffi::c_void);\n+                }\n+                __clone(this, new);\n+            }\n+            unsafe fn __downgrade(shared: *const ::std::ffi::c_void, weak: *mut ::std::ffi::c_void) {\n+                extern \"C\" {\n+                    #[link_name = #link_downgrade]\n+                    fn __downgrade(shared: *const ::std::ffi::c_void, weak: *mut ::std::ffi::c_void);\n+                }\n+                __downgrade(shared, weak);\n+            }\n+            unsafe fn __upgrade(weak: *const ::std::ffi::c_void, shared: *mut ::std::ffi::c_void) {\n+                extern \"C\" {\n+                    #[link_name = #link_upgrade]\n+                    fn __upgrade(weak: *const ::std::ffi::c_void, shared: *mut ::std::ffi::c_void);\n+                }\n+                __upgrade(weak, shared);\n+            }\n+            unsafe fn __drop(this: *mut ::std::ffi::c_void) {\n+                extern \"C\" {\n+                    #[link_name = #link_drop]\n+                    fn __drop(this: *mut ::std::ffi::c_void);\n+                }\n+                __drop(this);\n+            }\n+        }\n+    }\n+}\n+\n fn expand_cxx_vector(elem: &RustName, explicit_impl: Option<&Impl>, types: &Types) -> TokenStream {\n     let _ = explicit_impl;\n     let name = elem.rust.to_string();\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -508,6 +508,31 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n   void cxxbridge1$std$shared_ptr$##RUST_TYPE##$drop(                           \\\n       const std::shared_ptr<CXX_TYPE> *self) noexcept {                        \\\n     self->~shared_ptr();                                                       \\\n+  }                                                                            \\\n+  static_assert(sizeof(std::weak_ptr<CXX_TYPE>) == 2 * sizeof(void *), \"\");    \\\n+  static_assert(alignof(std::weak_ptr<CXX_TYPE>) == alignof(void *), \"\");      \\\n+  void cxxbridge1$std$weak_ptr$##RUST_TYPE##$null(                             \\\n+      std::weak_ptr<CXX_TYPE> *ptr) noexcept {                                 \\\n+    new (ptr) std::weak_ptr<CXX_TYPE>();                                       \\\n+  }                                                                            \\\n+  void cxxbridge1$std$weak_ptr$##RUST_TYPE##$clone(                            \\\n+      const std::weak_ptr<CXX_TYPE> &self,                                     \\\n+      std::weak_ptr<CXX_TYPE> *ptr) noexcept {                                 \\\n+    new (ptr) std::weak_ptr<CXX_TYPE>(self);                                   \\\n+  }                                                                            \\\n+  void cxxbridge1$std$weak_ptr$##RUST_TYPE##$downgrade(                        \\\n+      const std::shared_ptr<CXX_TYPE> &shared,                                 \\\n+      std::weak_ptr<CXX_TYPE> *weak) noexcept {                                \\\n+    new (weak) std::weak_ptr<CXX_TYPE>(shared);                                \\\n+  }                                                                            \\\n+  void cxxbridge1$std$weak_ptr$##RUST_TYPE##$upgrade(                          \\\n+      const std::weak_ptr<CXX_TYPE> &weak,                                     \\\n+      std::shared_ptr<CXX_TYPE> *shared) noexcept {                            \\\n+    new (shared) std::shared_ptr<CXX_TYPE>(weak.lock());                       \\\n+  }                                                                            \\\n+  void cxxbridge1$std$weak_ptr$##RUST_TYPE##$drop(                             \\\n+      const std::weak_ptr<CXX_TYPE> *self) noexcept {                          \\\n+    self->~weak_ptr();                                                         \\\n   }\n \n // Usize and isize are the same type as one of the below.\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -360,7 +360,6 @@\n //! <tr><td>Option&lt;T&gt;</td><td><sup><i>tbd</i></sup></td></tr>\n //! <tr><td><sup><i>tbd</i></sup></td><td>std::map&lt;K, V&gt;</td></tr>\n //! <tr><td><sup><i>tbd</i></sup></td><td>std::unordered_map&lt;K, V&gt;</td></tr>\n-//! <tr><td><sup><i>tbd</i></sup></td><td>std::weak_ptr&lt;T&gt;</td></tr>\n //! </table>\n \n #![no_std]\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -411,6 +410,7 @@ mod unique_ptr;\n mod unwind;\n #[path = \"cxx_vector.rs\"]\n pub mod vector;\n+mod weak_ptr;\n \n pub use crate::exception::Exception;\n pub use crate::extern_type::{kind, ExternType};\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -419,6 +419,7 @@ pub use crate::string::CxxString;\n pub use crate::unique_ptr::UniquePtr;\n #[doc(inline)]\n pub use crate::vector::CxxVector;\n+pub use crate::weak_ptr::WeakPtr;\n pub use cxxbridge_macro::bridge;\n \n /// For use in impls of the `ExternType` trait. See [`ExternType`].\ndiff --git a/src/lib.rs b/src/lib.rs\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -457,6 +458,7 @@ pub mod private {\n     pub use crate::unique_ptr::UniquePtrTarget;\n     pub use crate::unwind::catch_unwind;\n     pub use crate::vector::VectorElement;\n+    pub use crate::weak_ptr::WeakPtrTarget;\n }\n \n mod actually_private {\ndiff --git a/src/shared_ptr.rs b/src/shared_ptr.rs\n--- a/src/shared_ptr.rs\n+++ b/src/shared_ptr.rs\n@@ -1,5 +1,6 @@\n use crate::kind::Trivial;\n use crate::string::CxxString;\n+use crate::weak_ptr::{WeakPtr, WeakPtrTarget};\n use crate::ExternType;\n use core::ffi::c_void;\n use core::fmt::{self, Debug, Display};\ndiff --git a/src/shared_ptr.rs b/src/shared_ptr.rs\n--- a/src/shared_ptr.rs\n+++ b/src/shared_ptr.rs\n@@ -61,6 +62,24 @@ where\n         let this = self as *const Self as *const c_void;\n         unsafe { T::__get(this).as_ref() }\n     }\n+\n+    /// Constructs new WeakPtr as a non-owning reference to the object managed\n+    /// by `self`. If `self` manages no object, the WeakPtr manages no object\n+    /// too.\n+    ///\n+    /// Matches the behavior of [std::weak_ptr\\<T\\>::weak_ptr(const std::shared_ptr\\<T\\> \\&)](https://en.cppreference.com/w/cpp/memory/weak_ptr/weak_ptr).\n+    pub fn downgrade(self: &SharedPtr<T>) -> WeakPtr<T>\n+    where\n+        T: WeakPtrTarget,\n+    {\n+        let this = self as *const Self as *const c_void;\n+        let mut weak_ptr = MaybeUninit::<WeakPtr<T>>::uninit();\n+        let new = weak_ptr.as_mut_ptr().cast();\n+        unsafe {\n+            T::__downgrade(this, new);\n+            weak_ptr.assume_init()\n+        }\n+    }\n }\n \n unsafe impl<T> Send for SharedPtr<T> where T: Send + Sync + SharedPtrTarget {}\ndiff --git /dev/null b/src/weak_ptr.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/weak_ptr.rs\n@@ -0,0 +1,184 @@\n+use crate::shared_ptr::{SharedPtr, SharedPtrTarget};\n+use crate::string::CxxString;\n+use core::ffi::c_void;\n+use core::fmt::{self, Debug, Display};\n+use core::marker::PhantomData;\n+use core::mem::MaybeUninit;\n+\n+/// Binding to C++ `std::weak_ptr<T>`.\n+///\n+/// The typical way to construct a WeakPtr from Rust is by [downgrading] from a\n+/// SharedPtr.\n+///\n+/// [downgrading]: crate::SharedPtr::downgrade\n+#[repr(C)]\n+pub struct WeakPtr<T>\n+where\n+    T: WeakPtrTarget,\n+{\n+    repr: [*mut c_void; 2],\n+    ty: PhantomData<T>,\n+}\n+\n+impl<T> WeakPtr<T>\n+where\n+    T: WeakPtrTarget,\n+{\n+    /// Makes a new WeakPtr wrapping a null pointer.\n+    ///\n+    /// Matches the behavior of default-constructing a std::weak\\_ptr.\n+    pub fn null() -> Self {\n+        let mut weak_ptr = MaybeUninit::<WeakPtr<T>>::uninit();\n+        let new = weak_ptr.as_mut_ptr().cast();\n+        unsafe {\n+            T::__null(new);\n+            weak_ptr.assume_init()\n+        }\n+    }\n+\n+    /// Upgrades a non-owning reference into an owning reference if possible,\n+    /// otherwise to a null reference.\n+    ///\n+    /// Matches the behavior of [std::weak_ptr\\<T\\>::lock](https://en.cppreference.com/w/cpp/memory/weak_ptr/lock).\n+    pub fn upgrade(&self) -> SharedPtr<T>\n+    where\n+        T: SharedPtrTarget,\n+    {\n+        let this = self as *const Self as *const c_void;\n+        let mut shared_ptr = MaybeUninit::<SharedPtr<T>>::uninit();\n+        let new = shared_ptr.as_mut_ptr().cast();\n+        unsafe {\n+            T::__upgrade(this, new);\n+            shared_ptr.assume_init()\n+        }\n+    }\n+}\n+\n+unsafe impl<T> Send for WeakPtr<T> where T: Send + Sync + WeakPtrTarget {}\n+unsafe impl<T> Sync for WeakPtr<T> where T: Send + Sync + WeakPtrTarget {}\n+\n+impl<T> Clone for WeakPtr<T>\n+where\n+    T: WeakPtrTarget,\n+{\n+    fn clone(&self) -> Self {\n+        let mut weak_ptr = MaybeUninit::<WeakPtr<T>>::uninit();\n+        let new = weak_ptr.as_mut_ptr().cast();\n+        let this = self as *const Self as *mut c_void;\n+        unsafe {\n+            T::__clone(this, new);\n+            weak_ptr.assume_init()\n+        }\n+    }\n+}\n+\n+impl<T> Drop for WeakPtr<T>\n+where\n+    T: WeakPtrTarget,\n+{\n+    fn drop(&mut self) {\n+        let this = self as *mut Self as *mut c_void;\n+        unsafe { T::__drop(this) }\n+    }\n+}\n+\n+impl<T> Debug for WeakPtr<T>\n+where\n+    T: Debug + WeakPtrTarget + SharedPtrTarget,\n+{\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+        Debug::fmt(&self.upgrade(), formatter)\n+    }\n+}\n+\n+// Methods are private; not intended to be implemented outside of cxxbridge\n+// codebase.\n+pub unsafe trait WeakPtrTarget {\n+    #[doc(hidden)]\n+    const __NAME: &'static dyn Display;\n+    #[doc(hidden)]\n+    unsafe fn __null(new: *mut c_void);\n+    #[doc(hidden)]\n+    unsafe fn __clone(this: *const c_void, new: *mut c_void);\n+    #[doc(hidden)]\n+    unsafe fn __downgrade(shared: *const c_void, new: *mut c_void);\n+    #[doc(hidden)]\n+    unsafe fn __upgrade(weak: *const c_void, shared: *mut c_void);\n+    #[doc(hidden)]\n+    unsafe fn __drop(this: *mut c_void);\n+}\n+\n+macro_rules! impl_weak_ptr_target {\n+    ($segment:expr, $name:expr, $ty:ty) => {\n+        unsafe impl WeakPtrTarget for $ty {\n+            const __NAME: &'static dyn Display = &$name;\n+            unsafe fn __null(new: *mut c_void) {\n+                extern \"C\" {\n+                    attr! {\n+                        #[link_name = concat!(\"cxxbridge1$std$weak_ptr$\", $segment, \"$null\")]\n+                        fn __null(new: *mut c_void);\n+                    }\n+                }\n+                __null(new);\n+            }\n+            unsafe fn __clone(this: *const c_void, new: *mut c_void) {\n+                extern \"C\" {\n+                    attr! {\n+                        #[link_name = concat!(\"cxxbridge1$std$weak_ptr$\", $segment, \"$clone\")]\n+                        fn __clone(this: *const c_void, new: *mut c_void);\n+                    }\n+                }\n+                __clone(this, new);\n+            }\n+            unsafe fn __downgrade(shared: *const c_void, weak: *mut c_void) {\n+                extern \"C\" {\n+                    attr! {\n+                        #[link_name = concat!(\"cxxbridge1$std$weak_ptr$\", $segment, \"$downgrade\")]\n+                        fn __downgrade(shared: *const c_void, weak: *mut c_void);\n+                    }\n+                }\n+                __downgrade(shared, weak);\n+            }\n+            unsafe fn __upgrade(weak: *const c_void, shared: *mut c_void) {\n+                extern \"C\" {\n+                    attr! {\n+                        #[link_name = concat!(\"cxxbridge1$std$weak_ptr$\", $segment, \"$upgrade\")]\n+                        fn __upgrade(weak: *const c_void, shared: *mut c_void);\n+                    }\n+                }\n+                __upgrade(weak, shared);\n+            }\n+            unsafe fn __drop(this: *mut c_void) {\n+                extern \"C\" {\n+                    attr! {\n+                        #[link_name = concat!(\"cxxbridge1$std$weak_ptr$\", $segment, \"$drop\")]\n+                        fn __drop(this: *mut c_void);\n+                    }\n+                }\n+                __drop(this);\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! impl_weak_ptr_target_for_primitive {\n+    ($ty:ident) => {\n+        impl_weak_ptr_target!(stringify!($ty), stringify!($ty), $ty);\n+    };\n+}\n+\n+impl_weak_ptr_target_for_primitive!(bool);\n+impl_weak_ptr_target_for_primitive!(u8);\n+impl_weak_ptr_target_for_primitive!(u16);\n+impl_weak_ptr_target_for_primitive!(u32);\n+impl_weak_ptr_target_for_primitive!(u64);\n+impl_weak_ptr_target_for_primitive!(usize);\n+impl_weak_ptr_target_for_primitive!(i8);\n+impl_weak_ptr_target_for_primitive!(i16);\n+impl_weak_ptr_target_for_primitive!(i32);\n+impl_weak_ptr_target_for_primitive!(i64);\n+impl_weak_ptr_target_for_primitive!(isize);\n+impl_weak_ptr_target_for_primitive!(f32);\n+impl_weak_ptr_target_for_primitive!(f64);\n+\n+impl_weak_ptr_target!(\"string\", \"CxxString\", CxxString);\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -32,6 +32,7 @@ fn do_typecheck(cx: &mut Check) {\n             Type::RustVec(ty) => check_type_rust_vec(cx, ty),\n             Type::UniquePtr(ptr) => check_type_unique_ptr(cx, ptr),\n             Type::SharedPtr(ptr) => check_type_shared_ptr(cx, ptr),\n+            Type::WeakPtr(ptr) => check_type_weak_ptr(cx, ptr),\n             Type::CxxVector(ptr) => check_type_cxx_vector(cx, ptr),\n             Type::Ref(ty) => check_type_ref(cx, ty),\n             Type::Array(array) => check_type_array(cx, array),\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -152,6 +153,27 @@ fn check_type_shared_ptr(cx: &mut Check, ptr: &Ty1) {\n     cx.error(ptr, \"unsupported shared_ptr target type\");\n }\n \n+fn check_type_weak_ptr(cx: &mut Check, ptr: &Ty1) {\n+    if let Type::Ident(ident) = &ptr.inner {\n+        if cx.types.rust.contains(&ident.rust) {\n+            cx.error(ptr, \"weak_ptr of a Rust type is not supported yet\");\n+            return;\n+        }\n+\n+        match Atom::from(&ident.rust) {\n+            None | Some(Bool) | Some(U8) | Some(U16) | Some(U32) | Some(U64) | Some(Usize)\n+            | Some(I8) | Some(I16) | Some(I32) | Some(I64) | Some(Isize) | Some(F32)\n+            | Some(F64) | Some(CxxString) => return,\n+            Some(Char) | Some(RustString) => {}\n+        }\n+    } else if let Type::CxxVector(_) = &ptr.inner {\n+        cx.error(ptr, \"std::weak_ptr<std::vector> is not supported yet\");\n+        return;\n+    }\n+\n+    cx.error(ptr, \"unsupported weak_ptr target type\");\n+}\n+\n fn check_type_cxx_vector(cx: &mut Check, ptr: &Ty1) {\n     if let Type::Ident(ident) = &ptr.inner {\n         if cx.types.rust.contains(&ident.rust) {\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -434,6 +456,7 @@ fn check_api_impl(cx: &mut Check, imp: &Impl) {\n         | Type::RustVec(ty)\n         | Type::UniquePtr(ty)\n         | Type::SharedPtr(ty)\n+        | Type::WeakPtr(ty)\n         | Type::CxxVector(ty) => {\n             if let Type::Ident(inner) = &ty.inner {\n                 if Atom::from(&inner.rust).is_none() {\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -506,6 +529,7 @@ fn check_reserved_name(cx: &mut Check, ident: &Ident) {\n     if ident == \"Box\"\n         || ident == \"UniquePtr\"\n         || ident == \"SharedPtr\"\n+        || ident == \"WeakPtr\"\n         || ident == \"Vec\"\n         || ident == \"CxxVector\"\n         || ident == \"str\"\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -527,6 +551,7 @@ fn is_unsized(cx: &mut Check, ty: &Type) -> bool {\n         | Type::RustVec(_)\n         | Type::UniquePtr(_)\n         | Type::SharedPtr(_)\n+        | Type::WeakPtr(_)\n         | Type::Ref(_)\n         | Type::Str(_)\n         | Type::SliceRef(_) => false,\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -599,6 +624,7 @@ fn describe(cx: &mut Check, ty: &Type) -> String {\n         Type::RustVec(_) => \"Vec\".to_owned(),\n         Type::UniquePtr(_) => \"unique_ptr\".to_owned(),\n         Type::SharedPtr(_) => \"shared_ptr\".to_owned(),\n+        Type::WeakPtr(_) => \"weak_ptr\".to_owned(),\n         Type::Ref(_) => \"reference\".to_owned(),\n         Type::Str(_) => \"&str\".to_owned(),\n         Type::CxxVector(_) => \"C++ vector\".to_owned(),\ndiff --git a/syntax/impls.rs b/syntax/impls.rs\n--- a/syntax/impls.rs\n+++ b/syntax/impls.rs\n@@ -46,6 +46,7 @@ impl Hash for Type {\n             Type::RustBox(t) => t.hash(state),\n             Type::UniquePtr(t) => t.hash(state),\n             Type::SharedPtr(t) => t.hash(state),\n+            Type::WeakPtr(t) => t.hash(state),\n             Type::Ref(t) => t.hash(state),\n             Type::Str(t) => t.hash(state),\n             Type::RustVec(t) => t.hash(state),\ndiff --git a/syntax/impls.rs b/syntax/impls.rs\n--- a/syntax/impls.rs\n+++ b/syntax/impls.rs\n@@ -67,6 +68,7 @@ impl PartialEq for Type {\n             (Type::RustBox(lhs), Type::RustBox(rhs)) => lhs == rhs,\n             (Type::UniquePtr(lhs), Type::UniquePtr(rhs)) => lhs == rhs,\n             (Type::SharedPtr(lhs), Type::SharedPtr(rhs)) => lhs == rhs,\n+            (Type::WeakPtr(lhs), Type::WeakPtr(rhs)) => lhs == rhs,\n             (Type::Ref(lhs), Type::Ref(rhs)) => lhs == rhs,\n             (Type::Str(lhs), Type::Str(rhs)) => lhs == rhs,\n             (Type::RustVec(lhs), Type::RustVec(rhs)) => lhs == rhs,\ndiff --git a/syntax/improper.rs b/syntax/improper.rs\n--- a/syntax/improper.rs\n+++ b/syntax/improper.rs\n@@ -28,7 +28,9 @@ impl<'a> Types<'a> {\n             | Type::Fn(_)\n             | Type::Void(_)\n             | Type::SliceRef(_) => Definite(true),\n-            Type::UniquePtr(_) | Type::SharedPtr(_) | Type::CxxVector(_) => Definite(false),\n+            Type::UniquePtr(_) | Type::SharedPtr(_) | Type::WeakPtr(_) | Type::CxxVector(_) => {\n+                Definite(false)\n+            }\n             Type::Ref(ty) => self.determine_improper_ctype(&ty.inner),\n             Type::Array(ty) => self.determine_improper_ctype(&ty.inner),\n         }\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -170,6 +170,7 @@ pub enum Type {\n     RustVec(Box<Ty1>),\n     UniquePtr(Box<Ty1>),\n     SharedPtr(Box<Ty1>),\n+    WeakPtr(Box<Ty1>),\n     Ref(Box<Ref>),\n     Str(Box<Ref>),\n     CxxVector(Box<Ty1>),\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -901,6 +901,16 @@ fn parse_type_path(ty: &TypePath) -> Result<Type> {\n                             rangle: generic.gt_token,\n                         })));\n                     }\n+                } else if ident == \"WeakPtr\" && generic.args.len() == 1 {\n+                    if let GenericArgument::Type(arg) = &generic.args[0] {\n+                        let inner = parse_type(arg)?;\n+                        return Ok(Type::WeakPtr(Box::new(Ty1 {\n+                            name: ident,\n+                            langle: generic.lt_token,\n+                            inner,\n+                            rangle: generic.gt_token,\n+                        })));\n+                    }\n                 } else if ident == \"CxxVector\" && generic.args.len() == 1 {\n                     if let GenericArgument::Type(arg) = &generic.args[0] {\n                         let inner = parse_type(arg)?;\ndiff --git a/syntax/pod.rs b/syntax/pod.rs\n--- a/syntax/pod.rs\n+++ b/syntax/pod.rs\n@@ -26,6 +26,7 @@ impl<'a> Types<'a> {\n             | Type::RustVec(_)\n             | Type::UniquePtr(_)\n             | Type::SharedPtr(_)\n+            | Type::WeakPtr(_)\n             | Type::CxxVector(_)\n             | Type::Void(_) => false,\n             Type::Ref(_) | Type::Str(_) | Type::Fn(_) | Type::SliceRef(_) => true,\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -23,6 +23,7 @@ impl ToTokens for Type {\n             Type::RustBox(ty)\n             | Type::UniquePtr(ty)\n             | Type::SharedPtr(ty)\n+            | Type::WeakPtr(ty)\n             | Type::CxxVector(ty)\n             | Type::RustVec(ty) => ty.to_tokens(tokens),\n             Type::Ref(r) | Type::Str(r) => r.to_tokens(tokens),\ndiff --git a/syntax/tokens.rs b/syntax/tokens.rs\n--- a/syntax/tokens.rs\n+++ b/syntax/tokens.rs\n@@ -46,7 +47,7 @@ impl ToTokens for Ty1 {\n     fn to_tokens(&self, tokens: &mut TokenStream) {\n         let span = self.name.span();\n         let name = self.name.to_string();\n-        if let \"UniquePtr\" | \"SharedPtr\" | \"CxxVector\" = name.as_str() {\n+        if let \"UniquePtr\" | \"SharedPtr\" | \"WeakPtr\" | \"CxxVector\" = name.as_str() {\n             tokens.extend(quote_spanned!(span=> ::cxx::));\n         } else if name == \"Vec\" {\n             tokens.extend(quote_spanned!(span=> ::std::vec::));\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -45,6 +45,7 @@ impl<'a> Types<'a> {\n                 Type::RustBox(ty)\n                 | Type::UniquePtr(ty)\n                 | Type::SharedPtr(ty)\n+                | Type::WeakPtr(ty)\n                 | Type::CxxVector(ty)\n                 | Type::RustVec(ty) => visit(all, &ty.inner),\n                 Type::Ref(r) => visit(all, &r.inner),\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -178,6 +178,8 @@ pub mod ffi {\n         fn c_method_mut_on_shared(self: &mut Shared) -> &mut usize;\n         fn c_set_array(self: &mut Array, value: i32);\n \n+        fn c_get_use_count(weak: &WeakPtr<C>) -> usize;\n+\n         #[rust_name = \"i32_overloaded_method\"]\n         fn cOverloadedMethod(&self, x: i32) -> String;\n         #[rust_name = \"str_overloaded_method\"]\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -538,6 +538,10 @@ const rust::Vec<uint8_t> &c_try_return_ref_rust_vec(const C &c) {\n   throw std::runtime_error(\"unimplemented\");\n }\n \n+size_t c_get_use_count(const std::weak_ptr<C> &weak) noexcept {\n+  return weak.use_count();\n+}\n+\n extern \"C\" C *cxx_test_suite_get_unique_ptr() noexcept {\n   return std::unique_ptr<C>(new C{2020}).release();\n }\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -168,6 +168,8 @@ rust::Vec<uint8_t> c_try_return_rust_vec();\n rust::Vec<rust::String> c_try_return_rust_vec_string();\n const rust::Vec<uint8_t> &c_try_return_ref_rust_vec(const C &c);\n \n+size_t c_get_use_count(const std::weak_ptr<C> &weak) noexcept;\n+\n void c_take_trivial_ptr(std::unique_ptr<D> d);\n void c_take_trivial_ref(const D &d);\n void c_take_trivial(D d);\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -1,5 +1,6 @@\n #![allow(clippy::assertions_on_constants, clippy::float_cmp, clippy::unit_cmp)]\n \n+use cxx::SharedPtr;\n use cxx_test_suite::module::ffi2;\n use cxx_test_suite::{cast, ffi, R};\n use std::cell::Cell;\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -36,7 +37,6 @@ fn test_c_return() {\n     assert_eq!(2020, ffi::c_return_shared().z);\n     assert_eq!(2020, ffi::c_return_box().0);\n     ffi::c_return_unique_ptr();\n-    ffi::c_return_shared_ptr();\n     ffi2::c_return_ns_unique_ptr();\n     assert_eq!(2020, *ffi::c_return_ref(&shared));\n     assert_eq!(2020, *ffi::c_return_ns_ref(&ns_shared));\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -241,6 +241,20 @@ fn test_c_method_calls() {\n     assert_eq!(array.a.len() as i32 * val, array.r_get_array_sum());\n }\n \n+#[test]\n+fn test_shared_ptr_weak_ptr() {\n+    let shared_ptr = ffi::c_return_shared_ptr();\n+    let weak_ptr = SharedPtr::downgrade(&shared_ptr);\n+    assert_eq!(1, ffi::c_get_use_count(&weak_ptr));\n+\n+    assert!(!weak_ptr.upgrade().is_null());\n+    assert_eq!(1, ffi::c_get_use_count(&weak_ptr));\n+\n+    drop(shared_ptr);\n+    assert_eq!(0, ffi::c_get_use_count(&weak_ptr));\n+    assert!(weak_ptr.upgrade().is_null());\n+}\n+\n #[test]\n fn test_c_ns_method_calls() {\n     let unique_ptr = ffi2::ns_c_return_unique_ptr_ns();\n",
        "problem_statement": "Add binding for std::weak_ptr\nhttps://en.cppreference.com/w/cpp/memory/weak_ptr/weak_ptr\r\n\r\nWe support std::shared_ptr from #536, and weak_ptr often occurs in related code.\n",
        "hints_text": "",
        "created_at": "2020-12-29T02:25:11Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 603,
        "instance_id": "dtolnay__cxx-603",
        "issue_numbers": [
            "532"
        ],
        "base_commit": "5ce110e8075c32130c2f3fda9c500b8f956426e6",
        "patch": "diff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -210,6 +210,7 @@ fn check_type_ref(cx: &mut Check, ty: &Ref) {\n fn check_type_slice_ref(cx: &mut Check, ty: &SliceRef) {\n     let supported = match &ty.inner {\n         Type::Str(_) | Type::SliceRef(_) => false,\n+        Type::Ident(ident) => !is_opaque_cxx(cx, &ident.rust),\n         element => !is_unsized(cx, element),\n     };\n \ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -217,9 +218,7 @@ fn check_type_slice_ref(cx: &mut Check, ty: &SliceRef) {\n         let mutable = if ty.mutable { \"mut \" } else { \"\" };\n         let mut msg = format!(\"unsupported &{}[T] element type\", mutable);\n         if let Type::Ident(ident) = &ty.inner {\n-            if cx.types.rust.contains(&ident.rust) {\n-                msg += \": opaque Rust type is not supported yet\";\n-            } else if is_opaque_cxx(cx, &ident.rust) {\n+            if is_opaque_cxx(cx, &ident.rust) {\n                 msg += \": opaque C++ type is not supported yet\";\n             }\n         }\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -121,6 +121,7 @@ pub mod ffi {\n         fn c_take_slice_char(s: &[c_char]);\n         fn c_take_slice_shared(s: &[Shared]);\n         fn c_take_slice_shared_sort(s: &mut [Shared]);\n+        fn c_take_slice_r(s: &[R]);\n         fn c_take_rust_string(s: String);\n         fn c_take_unique_ptr_string(s: UniquePtr<CxxString>);\n         fn c_take_unique_ptr_vector_u8(v: UniquePtr<CxxVector<u8>>);\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -289,6 +289,12 @@ void c_take_slice_shared_sort(rust::Slice<Shared> s) {\n   }\n }\n \n+void c_take_slice_r(rust::Slice<const R> s) {\n+  if (s.size() == 2 && s[0].get() == 2020 && s[1].get() == 2021) {\n+    cxx_test_suite_set_correct();\n+  }\n+}\n+\n void c_take_rust_string(rust::String s) {\n   if (std::string(s) == \"2020\") {\n     cxx_test_suite_set_correct();\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -124,6 +124,7 @@ void c_take_str(rust::Str s);\n void c_take_slice_char(rust::Slice<const char> s);\n void c_take_slice_shared(rust::Slice<const Shared> s);\n void c_take_slice_shared_sort(rust::Slice<Shared> s);\n+void c_take_slice_r(rust::Slice<const R> s);\n void c_take_rust_string(rust::String s);\n void c_take_unique_ptr_string(std::unique_ptr<std::string> s);\n void c_take_unique_ptr_vector_u8(std::unique_ptr<std::vector<uint8_t>> v);\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -132,6 +132,7 @@ fn test_c_take() {\n         ffi::Shared { z: 4 },\n     ];\n     check!(ffi::c_take_slice_shared_sort(shared_sort_slice));\n+    check!(ffi::c_take_slice_r(&[R(2020), R(2021)]));\n     assert_eq!(shared_sort_slice[0].z, 0);\n     assert_eq!(shared_sort_slice[1].z, 2);\n     assert_eq!(shared_sort_slice[2].z, 4);\n",
        "problem_statement": "Support opaque Rust types in a rust::Slice\nCurrently only primitives and shared types are supported in a slice in the FFI.\r\n\r\nThe following is currently rejected, but it should be possible to support:\r\n\r\n```rust\r\n#[cxx::bridge]\r\nmod ffi {\r\n    extern \"Rust\" {\r\n        type MyType;\r\n    }\r\n\r\n    unsafe extern \"C++\" {\r\n        fn f(slice: &[MyType]);\r\n    }\r\n}\r\n```\r\n\r\nThe slice iterators and indexing operations will need to obtain a `stride` at runtime from Rust, exactly like we already do for rust::Vec containing opaque Rust types.\n",
        "hints_text": "Can `&[String]` be supported as well? If not, I guess a workaround would be wrapping it into a struct...\n`&[String]` should already be working. If not, please file a separate issue with a repro.\nSorry, I confused it with `&[&str]`, which doesn't seem to be.",
        "created_at": "2020-12-27T21:20:49Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 585,
        "instance_id": "dtolnay__cxx-585",
        "issue_numbers": [
            "583"
        ],
        "base_commit": "b03d41d5d4a415815c9c810709ffc1e1336f958d",
        "patch": "diff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -464,6 +464,12 @@ fn check_mut_return_restriction(cx: &mut Check, efn: &ExternFn) {\n         _ => return,\n     }\n \n+    if let Some(r) = &efn.receiver {\n+        if r.mutable {\n+            return;\n+        }\n+    }\n+\n     for arg in &efn.args {\n         if let Type::Ref(ty) = &arg.ty {\n             if ty.mutable {\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -165,9 +165,13 @@ pub mod ffi {\n         fn get(self: &C) -> usize;\n         fn set(self: Pin<&mut C>, n: usize) -> usize;\n         fn get2(&self) -> usize;\n+        fn getRef(self: &C) -> &usize;\n+        fn getMut(self: Pin<&mut C>) -> &mut usize;\n         fn set_succeed(self: Pin<&mut C>, n: usize) -> Result<usize>;\n         fn get_fail(self: Pin<&mut C>) -> Result<usize>;\n         fn c_method_on_shared(self: &Shared) -> usize;\n+        fn c_method_ref_on_shared(self: &Shared) -> &usize;\n+        fn c_method_mut_on_shared(self: &mut Shared) -> &mut usize;\n         fn c_set_array(self: &mut Array, value: i32);\n \n         #[rust_name = \"i32_overloaded_method\"]\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -22,6 +22,10 @@ size_t C::get() const { return this->n; }\n \n size_t C::get2() const { return this->n; }\n \n+const size_t &C::getRef() const { return this->n; }\n+\n+size_t &C::getMut() { return this->n; }\n+\n size_t C::set(size_t n) {\n   this->n = n;\n   return this->n;\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -33,6 +37,12 @@ size_t C::get_fail() { throw std::runtime_error(\"unimplemented\"); }\n \n size_t Shared::c_method_on_shared() const noexcept { return 2021; }\n \n+const size_t &Shared::c_method_ref_on_shared() const noexcept {\n+  return this->z;\n+}\n+\n+size_t &Shared::c_method_mut_on_shared() noexcept { return this->z; }\n+\n void Array::c_set_array(int32_t val) noexcept {\n   this->a = {val, val, val, val};\n }\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -45,6 +45,8 @@ class C {\n   size_t get() const;\n   size_t set(size_t n);\n   size_t get2() const;\n+  const size_t &getRef() const;\n+  size_t &getMut();\n   size_t set_succeed(size_t n);\n   size_t get_fail();\n   const std::vector<uint8_t> &get_v() const;\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -210,9 +210,13 @@ fn test_c_method_calls() {\n     assert_eq!(2021, unique_ptr.pin_mut().set(2021));\n     assert_eq!(2021, unique_ptr.get());\n     assert_eq!(2021, unique_ptr.get2());\n+    assert_eq!(2021, *unique_ptr.getRef());\n+    assert_eq!(2021, *unique_ptr.pin_mut().getMut());\n     assert_eq!(2022, unique_ptr.pin_mut().set_succeed(2022).unwrap());\n     assert!(unique_ptr.pin_mut().get_fail().is_err());\n     assert_eq!(2021, ffi::Shared { z: 0 }.c_method_on_shared());\n+    assert_eq!(2022, *ffi::Shared { z: 2022 }.c_method_ref_on_shared());\n+    assert_eq!(2023, *ffi::Shared { z: 2023 }.c_method_mut_on_shared());\n \n     let val = 42;\n     let mut array = ffi::Array { a: [0, 0, 0, 0] };\n",
        "problem_statement": "Pinning and mut\nHi!\r\n\r\nI'm trying to refactor my Skia bindings to use cxx.\r\nA `Surface` (`SkSurface`) has an associated `Canvas` (`SkCanvas`) that I'm trying to return.\r\n\r\nHere's a sample with some stuff omitted:\r\n\r\n```rust\r\nunsafe extern \"C++\" {\r\n    type Canvas;\r\n    type Surface;\r\n\r\n    fn canvas(self: Pin<&mut Surface>) -> Pin<&mut Canvas>;\r\n}\r\n```\r\n\r\nWhen building I get: `&mut return type is not allowed unless there is a &mut argument`\r\n\r\nMaybe I'm missing something obvious, but I can't find anything in docs.\r\n\r\nThanks,\r\nChrister\n",
        "hints_text": "I think adding this:\r\n\r\n```rust\r\nif let Some(ref r) = efn.receiver {\r\n    if r.mutable {\r\n        return;\r\n    }\r\n}\r\n```\r\n\r\nbefore https://github.com/dtolnay/cxx/blob/83cbe894dcf6605ab3ad44ca851476b6e3e7dcf1/syntax/check.rs#L467 would work.",
        "created_at": "2020-12-18T19:05:57Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 554,
        "instance_id": "dtolnay__cxx-554",
        "issue_numbers": [
            "532"
        ],
        "base_commit": "8e5af76cf09d7fc5adf0c67f81dedbdfc5dca354",
        "patch": "diff --git a/gen/src/builtin.rs b/gen/src/builtin.rs\n--- a/gen/src/builtin.rs\n+++ b/gen/src/builtin.rs\n@@ -136,6 +136,7 @@ pub(super) fn write(out: &mut OutFile) {\n     ifndef::write(out, builtin.rust_isize, \"CXXBRIDGE1_RUST_ISIZE\");\n     ifndef::write(out, builtin.opaque, \"CXXBRIDGE1_RUST_OPAQUE\");\n     ifndef::write(out, builtin.relocatable, \"CXXBRIDGE1_RELOCATABLE\");\n+    ifndef::write(out, builtin.relocatable, \"CXXBRIDGE1_DETAIL_SIZEOF\");\n \n     out.begin_block(Block::Namespace(\"detail\"));\n \ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1253,6 +1253,7 @@ impl<'a> ToMangled for UniquePtr<'a> {\n }\n \n fn write_generic_instantiations(out: &mut OutFile) {\n+\n     if out.header {\n         return;\n     }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1311,6 +1312,14 @@ fn write_generic_instantiations(out: &mut OutFile) {\n                     write_cxx_vector(out, inner);\n                 }\n             }\n+        } else if let Type::Ident(name) = ty {\n+            if Atom::from(&name.rust).is_none()\n+                && (!out.types.aliases.contains_key(&name.rust)\n+                    || out.types.explicit_impls.contains(ty))\n+            {\n+                out.next_section();\n+                write_rust_sizeof_extern(out, name);\n+            }\n         }\n     }\n     out.end_block(Block::ExternC);\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1336,6 +1345,13 @@ fn write_generic_instantiations(out: &mut OutFile) {\n                     write_rust_vec_impl(out, inner);\n                 }\n             }\n+        } else if let Type::Ident(name) = ty {\n+            if Atom::from(&name.rust).is_none()\n+                && (!out.types.aliases.contains_key(&name.rust)\n+                    || out.types.explicit_impls.contains(ty))\n+            {\n+                write_rust_sizeof_impl(out, name);\n+            }\n         }\n     }\n     out.end_block(Block::InlineNamespace(\"cxxbridge1\"));\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1366,6 +1382,36 @@ fn write_rust_box_extern(out: &mut OutFile, ident: &Pair) {\n     writeln!(out, \"#endif // CXXBRIDGE1_RUST_BOX_{}\", instance);\n }\n \n+fn write_rust_sizeof_extern(out: &mut OutFile, element: &RustName) {\n+    let instance = element.to_mangled(out.types);\n+\n+    writeln!(out, \"#ifndef CXX_BRIDGE_RUST_SIZEOF_{}\", instance);\n+    writeln!(out, \"#define CXX_BRIDGE_RUST_SIZEOF_{}\", instance);\n+    writeln!(out, \"::std::size_t cxxbridge1$rust_sizeof${}() noexcept;\", instance);\n+    writeln!(out, \"#endif // CXX_BRIDGE_RUST_SIZEOF_{}\", instance);\n+\n+}\n+\n+fn write_rust_sizeof_impl(out: &mut OutFile, element: &RustName) {\n+    let instance = element.to_mangled(out.types);\n+    let typename = element.to_typename(out.types);\n+\n+    writeln!(out, \"#ifndef CXX_BRIDGE_RUST_SIZEOF_IMPL_{}\", instance);\n+    writeln!(out, \"#define CXX_BRIDGE_RUST_SIZEOF_IMPL_{}\", instance);\n+    out.begin_block(Block::Namespace(\"detail\"));\n+    writeln!(out, \"template<>\");\n+    writeln!(out, \"::std::size_t rust_sizeof<{}>() {{\", typename);\n+    writeln!( out, \"  return cxxbridge1$rust_sizeof${}();\", instance);\n+    writeln!(out, \" }}\");\n+    writeln!(out, \"template<>\");\n+    writeln!(out, \"::std::size_t rust_sizeof<const {}>() {{\", typename);\n+    writeln!( out, \"  return cxxbridge1$rust_sizeof${}();\", instance);\n+    writeln!(out, \" }}\");\n+    out.end_block(Block::Namespace(\"detail\"));\n+    writeln!(out, \"#endif // CXX_BRIDGE_RUST_SIZEOF_IMPL_{}\", instance);\n+\n+}\n+\n fn write_rust_vec_extern(out: &mut OutFile, element: &RustName) {\n     let inner = element.to_typename(out.types);\n     let instance = element.to_mangled(out.types);\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1409,11 +1455,6 @@ fn write_rust_vec_extern(out: &mut OutFile, element: &RustName) {\n         \"void cxxbridge1$rust_vec${}$set_len(::rust::Vec<{}> *ptr, ::std::size_t len) noexcept;\",\n         instance, inner,\n     );\n-    writeln!(\n-        out,\n-        \"::std::size_t cxxbridge1$rust_vec${}$stride() noexcept;\",\n-        instance,\n-    );\n     writeln!(out, \"#endif // CXXBRIDGE1_RUST_VEC_{}\", instance);\n }\n \ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1513,11 +1554,6 @@ fn write_rust_vec_impl(out: &mut OutFile, element: &RustName) {\n         instance,\n     );\n     writeln!(out, \"}}\");\n-\n-    writeln!(out, \"template <>\");\n-    writeln!(out, \"::std::size_t Vec<{}>::stride() noexcept {{\", inner);\n-    writeln!(out, \"  return cxxbridge1$rust_vec${}$stride();\", instance);\n-    writeln!(out, \"}}\");\n }\n \n fn write_unique_ptr(out: &mut OutFile, ident: &RustName) {\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -30,6 +30,14 @@ template <typename T>\n class impl;\n }\n \n+#ifndef CXXBRIDGE1_DETAIL_SIZEOF\n+#define CXXBRIDGE1_DETAIL_SIZEOF\n+namespace detail {\n+template <typename T>\n+std::size_t rust_sizeof();\n+} // namespace detail\n+#endif // CXXBRIDGE1_DETAIL_SIZEOF\n+\n #ifndef CXXBRIDGE1_RUST_STRING\n #define CXXBRIDGE1_RUST_STRING\n // https://cxx.rs/binding/string.html\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -156,6 +164,8 @@ class Slice final\n   T *data() const noexcept;\n   std::size_t size() const noexcept;\n   std::size_t length() const noexcept;\n+  T &operator[](std::size_t n) noexcept;\n+  T &at(std::size_t n);\n \n   // Important in order for System V ABI to pass in registers.\n   Slice(const Slice<T> &) noexcept = default;\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -167,6 +177,7 @@ class Slice final\n \n private:\n   friend impl<Slice>;\n+  static std::size_t stride() noexcept;\n   // Not necessarily ABI compatible with &[T]. Codegen will translate to\n   // cxx::rust_slice::RustSlice which matches this layout.\n   T *ptr;\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -192,6 +203,7 @@ class Slice<T>::iterator final {\n private:\n   friend class Slice;\n   T *pos;\n+  std::size_t stride;\n };\n #endif // CXXBRIDGE1_RUST_SLICE\n \ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -524,16 +536,37 @@ T *Slice<T>::iterator::operator->() const noexcept {\n   return this->pos;\n }\n \n+template <typename T>\n+T &Slice<T>::operator[](std::size_t n) noexcept {\n+  auto data = const_cast<char*>(reinterpret_cast<const char *>(this->data()));\n+  return *reinterpret_cast<T *>(data + n * this->stride());\n+}\n+\n+template <typename T>\n+T &Slice<T>::at(std::size_t n) {\n+  if (n >= this->size()) {\n+    panic<std::out_of_range>(\"rust::Slice index out of range\");\n+  }\n+  return (*this)[n];\n+}\n+\n+template <typename T>\n+size_t Slice<T>::stride() noexcept {\n+  return detail::rust_sizeof<T>();\n+}\n+\n template <typename T>\n typename Slice<T>::iterator &Slice<T>::iterator::operator++() noexcept {\n-  ++this->pos;\n+  auto data = const_cast<char*>(reinterpret_cast<const char *>(this->pos));\n+  this->pos = reinterpret_cast<T *>(data + this->stride);\n   return *this;\n }\n \n template <typename T>\n typename Slice<T>::iterator Slice<T>::iterator::operator++(int) noexcept {\n   auto ret = iterator(*this);\n-  ++this->pos;\n+  auto data = const_cast<char*>(reinterpret_cast<const char *>(this->pos));\n+  this->pos = reinterpret_cast<T *>(data + this->stride);\n   return ret;\n }\n \ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -551,6 +584,7 @@ template <typename T>\n typename Slice<T>::iterator Slice<T>::begin() const noexcept {\n   iterator it;\n   it.pos = this->ptr;\n+  it.stride = this->stride();\n   return it;\n }\n \ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -558,6 +592,7 @@ template <typename T>\n typename Slice<T>::iterator Slice<T>::end() const noexcept {\n   iterator it = this->begin();\n   it.pos += this->len;\n+  it.stride = this->stride();\n   return it;\n }\n #endif // CXXBRIDGE1_RUST_SLICE\ndiff --git a/include/cxx.h b/include/cxx.h\n--- a/include/cxx.h\n+++ b/include/cxx.h\n@@ -752,6 +787,11 @@ const T &Vec<T>::at(std::size_t n) const {\n   return (*this)[n];\n }\n \n+template <typename T>\n+size_t Vec<T>::stride() noexcept {\n+  return detail::rust_sizeof<T>();\n+}\n+\n template <typename T>\n const T &Vec<T>::front() const noexcept {\n   assert(!this->empty());\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -109,6 +109,12 @@ fn expand(ffi: Module, apis: &[Api], types: &Types) -> TokenStream {\n                     expanded.extend(expand_cxx_vector(ident, explicit_impl, types));\n                 }\n             }\n+        } else if let Type::Ident(ident) = ty {\n+            let explicit_impl = types.explicit_impls.get(ty);\n+            if Atom::from(&ident.rust).is_none()\n+                    && (explicit_impl.is_some() || !types.aliases.contains_key(&ident.rust)) {\n+                hidden.extend(expand_rust_sizeof(ident, types));\n+            }\n         }\n     }\n \ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -982,6 +988,20 @@ fn expand_rust_box(ident: &RustName, types: &Types) -> TokenStream {\n     }\n }\n \n+fn expand_rust_sizeof(elem: &RustName, types: &Types) -> TokenStream {\n+    let link_sizeof = format!(\"cxxbridge1$rust_sizeof${}\", elem.to_symbol(types));\n+    let local_sizeof = format_ident!(\"{}__sizeof\", elem.rust);\n+\n+    let span = elem.span();\n+    quote_spanned! {span=>\n+        #[doc(hidden)]\n+        #[export_name = #link_sizeof]\n+        unsafe extern \"C\" fn #local_sizeof() -> usize {\n+            ::std::mem::size_of::<#elem>()\n+        }\n+    }\n+}\n+\n fn expand_rust_vec(elem: &RustName, types: &Types) -> TokenStream {\n     let link_prefix = format!(\"cxxbridge1$rust_vec${}$\", elem.to_symbol(types));\n     let link_new = format!(\"{}new\", link_prefix);\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -991,7 +1011,6 @@ fn expand_rust_vec(elem: &RustName, types: &Types) -> TokenStream {\n     let link_data = format!(\"{}data\", link_prefix);\n     let link_reserve_total = format!(\"{}reserve_total\", link_prefix);\n     let link_set_len = format!(\"{}set_len\", link_prefix);\n-    let link_stride = format!(\"{}stride\", link_prefix);\n \n     let local_prefix = format_ident!(\"{}__vec_\", elem.rust);\n     let local_new = format_ident!(\"{}new\", local_prefix);\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1001,7 +1020,6 @@ fn expand_rust_vec(elem: &RustName, types: &Types) -> TokenStream {\n     let local_data = format_ident!(\"{}data\", local_prefix);\n     let local_reserve_total = format_ident!(\"{}reserve_total\", local_prefix);\n     let local_set_len = format_ident!(\"{}set_len\", local_prefix);\n-    let local_stride = format_ident!(\"{}stride\", local_prefix);\n \n     let span = elem.span();\n     quote_spanned! {span=>\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1042,11 +1060,6 @@ fn expand_rust_vec(elem: &RustName, types: &Types) -> TokenStream {\n         unsafe extern \"C\" fn #local_set_len(this: *mut ::cxx::private::RustVec<#elem>, len: usize) {\n             (*this).set_len(len);\n         }\n-        #[doc(hidden)]\n-        #[export_name = #link_stride]\n-        unsafe extern \"C\" fn #local_stride() -> usize {\n-            ::std::mem::size_of::<#elem>()\n-        }\n     }\n }\n \ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -436,6 +436,16 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n     ptr->~unique_ptr();                                                        \\\n   }\n \n+#define RUST_SIZEOF_OPS(RUST_TYPE, CXX_TYPE)                                   \\\n+  template <>                                                                  \\\n+  size_t rust_sizeof<CXX_TYPE>() {                                             \\\n+    return sizeof(CXX_TYPE);                                                   \\\n+  }                                                                            \\\n+  template <>                                                                  \\\n+  size_t rust_sizeof<const CXX_TYPE>() {                                       \\\n+    return sizeof(CXX_TYPE);                                                   \\\n+  }                                                                            \\\n+\n #define RUST_VEC_EXTERNS(RUST_TYPE, CXX_TYPE)                                  \\\n   void cxxbridge1$rust_vec$##RUST_TYPE##$new(                                  \\\n       rust::Vec<CXX_TYPE> *ptr) noexcept;                                      \\\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -450,8 +460,7 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n   void cxxbridge1$rust_vec$##RUST_TYPE##$reserve_total(                        \\\n       rust::Vec<CXX_TYPE> *ptr, std::size_t cap) noexcept;                     \\\n   void cxxbridge1$rust_vec$##RUST_TYPE##$set_len(rust::Vec<CXX_TYPE> *ptr,     \\\n-                                                 std::size_t len) noexcept;    \\\n-  std::size_t cxxbridge1$rust_vec$##RUST_TYPE##$stride() noexcept;\n+                                                 std::size_t len) noexcept;\n \n #define RUST_VEC_OPS(RUST_TYPE, CXX_TYPE)                                      \\\n   template <>                                                                  \\\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -482,10 +491,6 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n   void Vec<CXX_TYPE>::set_len(std::size_t len) noexcept {                      \\\n     cxxbridge1$rust_vec$##RUST_TYPE##$set_len(this, len);                      \\\n   }                                                                            \\\n-  template <>                                                                  \\\n-  std::size_t Vec<CXX_TYPE>::stride() noexcept {                               \\\n-    return cxxbridge1$rust_vec$##RUST_TYPE##$stride();                         \\\n-  }\n \n #define SHARED_PTR_OPS(RUST_TYPE, CXX_TYPE)                                    \\\n   static_assert(sizeof(std::shared_ptr<CXX_TYPE>) == 2 * sizeof(void *), \"\");  \\\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -534,7 +539,7 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n   MACRO(isize, rust::isize)                                                    \\\n   MACRO(string, std::string)\n \n-#define FOR_EACH_RUST_VEC(MACRO)                                               \\\n+#define FOR_EACH_RUST_BASE_TYPE(MACRO)                                         \\\n   FOR_EACH_NUMERIC(MACRO)                                                      \\\n   MACRO(bool, bool)                                                            \\\n   MACRO(char, char)                                                            \\\ndiff --git a/src/cxx.cc b/src/cxx.cc\n--- a/src/cxx.cc\n+++ b/src/cxx.cc\n@@ -548,12 +553,15 @@ static_assert(sizeof(std::string) <= kMaxExpectedWordsInString * sizeof(void *),\n \n extern \"C\" {\n FOR_EACH_STD_VECTOR(STD_VECTOR_OPS)\n-FOR_EACH_RUST_VEC(RUST_VEC_EXTERNS)\n FOR_EACH_SHARED_PTR(SHARED_PTR_OPS)\n+FOR_EACH_RUST_BASE_TYPE(RUST_VEC_EXTERNS)\n } // extern \"C\"\n \n namespace rust {\n inline namespace cxxbridge1 {\n-FOR_EACH_RUST_VEC(RUST_VEC_OPS)\n+FOR_EACH_RUST_BASE_TYPE(RUST_VEC_OPS)\n+namespace detail {\n+FOR_EACH_RUST_BASE_TYPE(RUST_SIZEOF_OPS)\n+} // namespace detail\n } // namespace cxxbridge1\n } // namespace rust\ndiff --git /dev/null b/src/symbols/rust_sizeof.rs\nnew file mode 100644\n--- /dev/null\n+++ b/src/symbols/rust_sizeof.rs\n@@ -0,0 +1,41 @@\n+use crate::rust_string::RustString;\n+use alloc::vec::Vec;\n+use core::mem;\n+use std::os::raw::c_char;\n+\n+macro_rules! rust_stride_shims {\n+    ($segment:expr, $ty:ty) => {\n+        const_assert_eq!(mem::size_of::<[usize; 3]>(), mem::size_of::<Vec<$ty>>());\n+        const_assert_eq!(mem::align_of::<usize>(), mem::align_of::<Vec<$ty>>());\n+\n+        const _: () = {\n+            attr! {\n+                #[export_name = concat!(\"cxxbridge1$rust_stride$\", $segment)]\n+                unsafe extern \"C\" fn __stride() -> usize {\n+                    mem::size_of::<$ty>()\n+                }\n+            }\n+        };\n+    };\n+}\n+\n+macro_rules! rust_stride_shims_for_primitive {\n+    ($ty:ident) => {\n+        rust_stride_shims!(stringify!($ty), $ty);\n+    };\n+}\n+\n+rust_stride_shims_for_primitive!(bool);\n+rust_stride_shims_for_primitive!(u8);\n+rust_stride_shims_for_primitive!(u16);\n+rust_stride_shims_for_primitive!(u32);\n+rust_stride_shims_for_primitive!(u64);\n+rust_stride_shims_for_primitive!(i8);\n+rust_stride_shims_for_primitive!(i16);\n+rust_stride_shims_for_primitive!(i32);\n+rust_stride_shims_for_primitive!(i64);\n+rust_stride_shims_for_primitive!(f32);\n+rust_stride_shims_for_primitive!(f64);\n+\n+rust_stride_shims!(\"char\", c_char);\n+rust_stride_shims!(\"string\", RustString);\ndiff --git a/src/symbols/rust_vec.rs b/src/symbols/rust_vec.rs\n--- a/src/symbols/rust_vec.rs\n+++ b/src/symbols/rust_vec.rs\n@@ -53,12 +53,6 @@ macro_rules! rust_vec_shims {\n                     (*this).repr.set_len(len);\n                 }\n             }\n-            attr! {\n-                #[export_name = concat!(\"cxxbridge1$rust_vec$\", $segment, \"$stride\")]\n-                unsafe extern \"C\" fn __stride() -> usize {\n-                    mem::size_of::<$ty>()\n-                }\n-            }\n         };\n     };\n }\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -210,6 +210,7 @@ fn check_type_ref(cx: &mut Check, ty: &Ref) {\n fn check_type_slice_ref(cx: &mut Check, ty: &SliceRef) {\n     let supported = match &ty.inner {\n         Type::Str(_) | Type::SliceRef(_) => false,\n+        Type::Ident(ident) => !is_opaque_cxx(cx, &ident.rust),\n         element => !is_unsized(cx, element),\n     };\n \ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -217,9 +218,7 @@ fn check_type_slice_ref(cx: &mut Check, ty: &SliceRef) {\n         let mutable = if ty.mutable { \"mut \" } else { \"\" };\n         let mut msg = format!(\"unsupported &{}[T] element type\", mutable);\n         if let Type::Ident(ident) = &ty.inner {\n-            if cx.types.rust.contains(&ident.rust) {\n-                msg += \": opaque Rust type is not supported yet\";\n-            } else if is_opaque_cxx(cx, &ident.rust) {\n+            if is_opaque_cxx(cx, &ident.rust) {\n                 msg += \": opaque C++ type is not supported yet\";\n             }\n         }\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -120,6 +120,8 @@ pub mod ffi {\n         fn c_take_str(s: &str);\n         fn c_take_slice_char(s: &[c_char]);\n         fn c_take_slice_shared(s: &[Shared]);\n+        fn c_take_slice_not_usized(s: &[Second]);\n+        fn c_take_slice_not_usized_mut(s: &mut [Second]);\n         fn c_take_rust_string(s: String);\n         fn c_take_unique_ptr_string(s: UniquePtr<CxxString>);\n         fn c_take_unique_ptr_vector_u8(v: UniquePtr<CxxVector<u8>>);\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -274,7 +274,19 @@ void c_take_slice_char(rust::Slice<const char> s) {\n }\n \n void c_take_slice_shared(rust::Slice<const Shared> s) {\n-  if (s.size() == 2 && s.data()->z == 2020 && (s.data() + 1)->z == 2021) {\n+  if (s.size() == 2 && s[0].z == 2020 && s[1].z == 2021) {\n+    cxx_test_suite_set_correct();\n+  }\n+}\n+\n+void c_take_slice_not_usized(rust::Slice<const second::Second> s) {\n+  if (s.size() == 2 && s[0].i == 1 && s[0].e == tests::COwnedEnum::CVAL1 && s[1].i == 2 && s[1].e == COwnedEnum::CVAL2) {\n+    cxx_test_suite_set_correct();\n+  }\n+}\n+\n+void c_take_slice_not_usized_mut(rust::Slice<second::Second> s) {\n+  if (s.size() == 2 && s[0].i == 1 && s[0].e == tests::COwnedEnum::CVAL1 && s[1].i == 2 && s[1].e == COwnedEnum::CVAL2) {\n     cxx_test_suite_set_correct();\n   }\n }\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -32,6 +32,10 @@ class H {\n };\n } // namespace H\n \n+namespace second {\n+  struct Second;\n+}\n+\n namespace tests {\n \n struct R;\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -123,6 +127,8 @@ void c_take_ref_ns_c(const ::H::H &h);\n void c_take_str(rust::Str s);\n void c_take_slice_char(rust::Slice<const char> s);\n void c_take_slice_shared(rust::Slice<const Shared> s);\n+void c_take_slice_not_usized(rust::Slice<const ::second::Second> s);\n+void c_take_slice_not_usized_mut(rust::Slice<::second::Second> s);\n void c_take_rust_string(rust::String s);\n void c_take_unique_ptr_string(std::unique_ptr<std::string> s);\n void c_take_unique_ptr_vector_u8(std::unique_ptr<std::vector<uint8_t>> v);\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -125,6 +125,14 @@ fn test_c_take() {\n         ffi::Shared { z: 2020 },\n         ffi::Shared { z: 2021 },\n     ]));\n+    check!(ffi::c_take_slice_not_usized(&[\n+        ffi::Second { i: 1, e: ffi::COwnedEnum::CVal1 },\n+        ffi::Second { i: 2, e: ffi::COwnedEnum::CVal2 },\n+    ]));\n+    check!(ffi::c_take_slice_not_usized_mut(&mut [\n+        ffi::Second { i: 1, e: ffi::COwnedEnum::CVal1 },\n+        ffi::Second { i: 2, e: ffi::COwnedEnum::CVal2 },\n+    ]));\n     check!(ffi::c_take_rust_string(\"2020\".to_owned()));\n     check!(ffi::c_take_unique_ptr_string(\n         ffi::c_return_unique_ptr_string()\n",
        "problem_statement": "Support opaque Rust types in a rust::Slice\nCurrently only primitives and shared types are supported in a slice in the FFI.\r\n\r\nThe following is currently rejected, but it should be possible to support:\r\n\r\n```rust\r\n#[cxx::bridge]\r\nmod ffi {\r\n    extern \"Rust\" {\r\n        type MyType;\r\n    }\r\n\r\n    unsafe extern \"C++\" {\r\n        fn f(slice: &[MyType]);\r\n    }\r\n}\r\n```\r\n\r\nThe slice iterators and indexing operations will need to obtain a `stride` at runtime from Rust, exactly like we already do for rust::Vec containing opaque Rust types.\n",
        "hints_text": "Can `&[String]` be supported as well? If not, I guess a workaround would be wrapping it into a struct...\n`&[String]` should already be working. If not, please file a separate issue with a repro.\nSorry, I confused it with `&[&str]`, which doesn't seem to be.",
        "created_at": "2020-12-09T22:14:08Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 550,
        "instance_id": "dtolnay__cxx-550",
        "issue_numbers": [
            "549"
        ],
        "base_commit": "06183a751fe4c363a04f3e35b38ddb11f78c13b2",
        "patch": "diff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -1,4 +1,3 @@\n-use crate::gen::block::Block;\n use crate::gen::nested::NamespaceEntries;\n use crate::gen::out::OutFile;\n use crate::gen::{builtin, include, Opt};\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -8,6 +7,7 @@ use crate::syntax::{\n     derive, mangle, Api, Enum, ExternFn, ExternType, Pair, RustName, Signature, Struct, Trait,\n     Type, Types, Var,\n };\n+use crate::{gen::block::Block, syntax::types::TrivialReason};\n use proc_macro2::Ident;\n use std::collections::{HashMap, HashSet};\n \ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -117,8 +117,8 @@ fn write_data_structures<'a>(out: &mut OutFile<'a>, apis: &'a [Api]) {\n     out.next_section();\n     for api in apis {\n         if let Api::TypeAlias(ety) = api {\n-            if out.types.required_trivial.contains_key(&ety.name.rust) {\n-                check_trivial_extern_type(out, &ety.name)\n+            if let Some(reasons) = out.types.required_trivial.get(&ety.name.rust) {\n+                check_trivial_extern_type(out, &ety.name, reasons)\n             }\n         }\n     }\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -366,7 +366,7 @@ fn check_enum<'a>(out: &mut OutFile<'a>, enm: &'a Enum) {\n     }\n }\n \n-fn check_trivial_extern_type(out: &mut OutFile, id: &Pair) {\n+fn check_trivial_extern_type(out: &mut OutFile, id: &Pair, reasons: &[TrivialReason]) {\n     // NOTE: The following static assertion is just nice-to-have and not\n     // necessary for soundness. That's because triviality is always declared by\n     // the user in the form of an unsafe impl of cxx::ExternType:\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -402,13 +402,16 @@ fn check_trivial_extern_type(out: &mut OutFile, id: &Pair) {\n \n     let id = id.to_fully_qualified();\n     out.builtin.relocatable = true;\n-    writeln!(out, \"static_assert(\");\n-    writeln!(out, \"    ::rust::IsRelocatable<{}>::value,\", id);\n-    writeln!(\n-        out,\n-        \"    \\\"type {} marked as Trivial in Rust is not trivially move constructible and trivially destructible in C++\\\");\",\n-        id,\n-    );\n+    for reason in reasons {\n+        writeln!(out, \"static_assert(\");\n+        writeln!(out, \"    ::rust::IsRelocatable<{}>::value,\", id);\n+        writeln!(\n+            out,\n+            \"    \\\"type {} is not move constructible and trivially destructible in C++ yet is used as a trivial type in Rust ({})\\\");\",\n+            id,\n+            reason\n+        );\n+    }\n }\n \n fn write_struct_operator_decls<'a>(out: &mut OutFile<'a>, strct: &'a Struct) {\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -1,6 +1,5 @@\n use crate::syntax::atom::Atom::{self, *};\n use crate::syntax::report::Errors;\n-use crate::syntax::types::TrivialReason;\n use crate::syntax::{\n     error, ident, Api, Array, Enum, ExternFn, ExternType, Impl, Lang, Receiver, Ref, Signature,\n     SliceRef, Struct, Trait, Ty1, Type, TypeAlias, Types,\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -189,7 +188,7 @@ fn check_type_ref(cx: &mut Check, ty: &Ref) {\n             cx.error(\n                 ty,\n                 format!(\n-                    \"mutable reference to C++ type requires a pin -- use Pin<&mut {}>\",\n+                    \"mutable reference to C++ type requires a pin -- use Pin<&mut {}> or declare the type Trivial in a cxx::ExternType impl\",\n                     requires_pin,\n                 ),\n             );\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -325,19 +324,15 @@ fn check_api_type(cx: &mut Check, ety: &ExternType) {\n         cx.error(span, \"extern type bounds are not implemented yet\");\n     }\n \n-    if let Some(reason) = cx.types.required_trivial.get(&ety.name.rust) {\n-        let what = match reason {\n-            TrivialReason::StructField(strct) => format!(\"a field of `{}`\", strct.name.rust),\n-            TrivialReason::FunctionArgument(efn) => format!(\"an argument of `{}`\", efn.name.rust),\n-            TrivialReason::FunctionReturn(efn) => format!(\"a return value of `{}`\", efn.name.rust),\n-            TrivialReason::BoxTarget => format!(\"Box<{}>\", ety.name.rust),\n-            TrivialReason::VecElement => format!(\"a vector element in Vec<{}>\", ety.name.rust),\n-        };\n-        let msg = format!(\n-            \"needs a cxx::ExternType impl in order to be used as {}\",\n-            what,\n-        );\n-        cx.error(ety, msg);\n+    if let Some(reasons) = cx.types.required_trivial.get(&ety.name.rust) {\n+        for reason in reasons {\n+            let what = reason.describe_in_context(&ety);\n+            let msg = format!(\n+                \"needs a cxx::ExternType impl in order to be used as {}\",\n+                what,\n+            );\n+            cx.error(ety, msg);\n+        }\n     }\n }\n \ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -385,7 +380,7 @@ fn check_api_fn(cx: &mut Check, efn: &ExternFn) {\n             cx.error(\n                 span,\n                 format!(\n-                    \"mutable reference to C++ type requires a pin -- use `self: Pin<&mut {}>`\",\n+                    \"mutable reference to opaque C++ type requires a pin -- use `self: Pin<&mut {}>` or declare the type Trivial in a cxx::ExternType impl\",\n                     receiver.ty.rust,\n                 ),\n             );\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -8,7 +8,7 @@ use crate::syntax::{\n };\n use proc_macro2::Ident;\n use quote::ToTokens;\n-use std::collections::BTreeMap as Map;\n+use std::{collections::BTreeMap as Map, fmt::Display};\n \n pub struct Types<'a> {\n     pub all: Set<&'a Type>,\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -18,7 +18,7 @@ pub struct Types<'a> {\n     pub rust: Set<&'a Ident>,\n     pub aliases: Map<&'a Ident, &'a TypeAlias>,\n     pub untrusted: Map<&'a Ident, &'a ExternType>,\n-    pub required_trivial: Map<&'a Ident, TrivialReason<'a>>,\n+    pub required_trivial: Map<&'a Ident, Vec<TrivialReason<'a>>>,\n     pub explicit_impls: Set<&'a Impl>,\n     pub resolutions: Map<&'a RustName, &'a Pair>,\n     pub struct_improper_ctypes: UnorderedSet<&'a Ident>,\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -169,15 +169,17 @@ impl<'a> Types<'a> {\n         // we check that this is permissible. We do this _after_ scanning all\n         // the APIs above, in case some function or struct references a type\n         // which is declared subsequently.\n-        let mut required_trivial = Map::new();\n-        let mut insist_alias_types_are_trivial = |ty: &'a Type, reason| {\n-            if let Type::Ident(ident) = ty {\n-                if cxx.contains(&ident.rust)\n-                    && !structs.contains_key(&ident.rust)\n-                    && !enums.contains_key(&ident.rust)\n-                {\n-                    required_trivial.entry(&ident.rust).or_insert(reason);\n-                }\n+        let mut required_trivial: Map<_, Vec<_>> = Map::new();\n+\n+        let mut insist_extern_types_are_trivial = |ident: &'a RustName, reason| {\n+            if cxx.contains(&ident.rust)\n+                && !structs.contains_key(&ident.rust)\n+                && !enums.contains_key(&ident.rust)\n+            {\n+                required_trivial\n+                    .entry(&ident.rust)\n+                    .or_default()\n+                    .push(reason);\n             }\n         };\n         for api in apis {\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -185,17 +187,23 @@ impl<'a> Types<'a> {\n                 Api::Struct(strct) => {\n                     let reason = TrivialReason::StructField(strct);\n                     for field in &strct.fields {\n-                        insist_alias_types_are_trivial(&field.ty, reason);\n+                        if let Type::Ident(ident) = &field.ty {\n+                            insist_extern_types_are_trivial(&ident, reason);\n+                        }\n                     }\n                 }\n                 Api::CxxFunction(efn) | Api::RustFunction(efn) => {\n                     let reason = TrivialReason::FunctionArgument(efn);\n                     for arg in &efn.args {\n-                        insist_alias_types_are_trivial(&arg.ty, reason);\n+                        if let Type::Ident(ident) = &arg.ty {\n+                            insist_extern_types_are_trivial(&ident, reason);\n+                        }\n                     }\n                     if let Some(ret) = &efn.ret {\n                         let reason = TrivialReason::FunctionReturn(efn);\n-                        insist_alias_types_are_trivial(&ret, reason);\n+                        if let Type::Ident(ident) = &ret {\n+                            insist_extern_types_are_trivial(&ident, reason);\n+                        }\n                     }\n                 }\n                 _ => {}\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -205,11 +213,37 @@ impl<'a> Types<'a> {\n             match ty {\n                 Type::RustBox(ty) => {\n                     let reason = TrivialReason::BoxTarget;\n-                    insist_alias_types_are_trivial(&ty.inner, reason);\n+                    if let Type::Ident(ident) = &ty.inner {\n+                        insist_extern_types_are_trivial(&ident, reason);\n+                    }\n                 }\n                 Type::RustVec(ty) => {\n                     let reason = TrivialReason::VecElement;\n-                    insist_alias_types_are_trivial(&ty.inner, reason);\n+                    if let Type::Ident(ident) = &ty.inner {\n+                        insist_extern_types_are_trivial(&ident, reason);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        for api in apis {\n+            match api {\n+                Api::CxxFunction(efn) | Api::RustFunction(efn) => {\n+                    let reason = TrivialReason::UnpinnedMutableReferenceFunctionArgument(efn);\n+                    if let Some(receiver) = &efn.receiver {\n+                        if receiver.mutable && !receiver.pinned {\n+                            insist_extern_types_are_trivial(&receiver.ty, reason);\n+                        }\n+                    }\n+                    for arg in &efn.args {\n+                        if let Type::Ref(reff) = &arg.ty {\n+                            if reff.mutable && !reff.pinned {\n+                                if let Type::Ident(ident) = &reff.inner {\n+                                    insist_extern_types_are_trivial(&ident, reason);\n+                                }\n+                            }\n+                        }\n+                    }\n                 }\n                 _ => {}\n             }\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -310,6 +344,36 @@ pub enum TrivialReason<'a> {\n     FunctionReturn(&'a ExternFn),\n     BoxTarget,\n     VecElement,\n+    UnpinnedMutableReferenceFunctionArgument(&'a ExternFn),\n+}\n+\n+impl<'a> TrivialReason<'a> {\n+    pub fn describe_in_context(&self, ety: &ExternType) -> String {\n+        match self {\n+            TrivialReason::BoxTarget => format!(\"Box<{}>\", ety.name.rust),\n+            TrivialReason::VecElement => format!(\"a vector element in Vec<{}>\", ety.name.rust),\n+            _ => self.to_string(),\n+        }\n+    }\n+}\n+\n+impl<'a> Display for TrivialReason<'a> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            TrivialReason::StructField(strct) => write!(f, \"a field of `{}`\", strct.name.rust),\n+            TrivialReason::FunctionArgument(efn) => write!(f, \"an argument of `{}`\", efn.name.rust),\n+            TrivialReason::FunctionReturn(efn) => {\n+                write!(f, \"a return value of `{}`\", efn.name.rust)\n+            }\n+            TrivialReason::BoxTarget => write!(f, \"in a Box<...>\"),\n+            TrivialReason::VecElement => write!(f, \"a Vec<...> element\"),\n+            TrivialReason::UnpinnedMutableReferenceFunctionArgument(efn) => write!(\n+                f,\n+                \"a non-pinned mutable reference argument of {}\",\n+                efn.name.rust\n+            ),\n+        }\n+    }\n }\n \n fn duplicate_name(cx: &mut Errors, sp: impl ToTokens, ident: &Ident) {\n",
        "test_patch": "diff --git a/tests/ffi/module.rs b/tests/ffi/module.rs\n--- a/tests/ffi/module.rs\n+++ b/tests/ffi/module.rs\n@@ -32,12 +32,16 @@ pub mod ffi2 {\n \n         fn c_take_trivial_ptr(d: UniquePtr<D>);\n         fn c_take_trivial_ref(d: &D);\n+        fn c_take_trivial_ref_method(self: &D);\n+        fn c_take_trivial_mut_ref_method(self: &mut D);\n         fn c_take_trivial(d: D);\n         fn c_take_trivial_ns_ptr(g: UniquePtr<G>);\n         fn c_take_trivial_ns_ref(g: &G);\n         fn c_take_trivial_ns(g: G);\n         fn c_take_opaque_ptr(e: UniquePtr<E>);\n         fn c_take_opaque_ref(e: &E);\n+        fn c_take_opaque_ref_method(self: &E);\n+        fn c_take_opaque_mut_ref_method(self: Pin<&mut E>);\n         fn c_take_opaque_ns_ptr(e: UniquePtr<F>);\n         fn c_take_opaque_ns_ref(e: &F);\n         fn c_return_trivial_ptr() -> UniquePtr<D>;\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -529,6 +529,18 @@ void c_take_trivial_ref(const D &d) {\n   }\n }\n \n+void D::c_take_trivial_ref_method() const {\n+  if (d == 30) {\n+    cxx_test_suite_set_correct();\n+  }\n+}\n+\n+void D::c_take_trivial_mut_ref_method() {\n+  if (d == 30) {\n+    cxx_test_suite_set_correct();\n+  }\n+}\n+\n void c_take_trivial(D d) {\n   if (d.d == 30) {\n     cxx_test_suite_set_correct();\ndiff --git a/tests/ffi/tests.cc b/tests/ffi/tests.cc\n--- a/tests/ffi/tests.cc\n+++ b/tests/ffi/tests.cc\n@@ -571,6 +583,18 @@ void c_take_opaque_ref(const E &e) {\n   }\n }\n \n+void E::c_take_opaque_ref_method() const {\n+  if (e == 40 && e_str == \"hello\") {\n+    cxx_test_suite_set_correct();\n+  }\n+}\n+\n+void E::c_take_opaque_mut_ref_method() {\n+  if (e == 40 && e_str == \"hello\") {\n+    cxx_test_suite_set_correct();\n+  }\n+}\n+\n void c_take_opaque_ns_ref(const ::F::F &f) {\n   if (f.f == 40 && f.f_str == \"hello\") {\n     cxx_test_suite_set_correct();\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -59,11 +59,15 @@ class C {\n \n struct D {\n   uint64_t d;\n+  void c_take_trivial_ref_method() const;\n+  void c_take_trivial_mut_ref_method();\n };\n \n struct E {\n   uint64_t e;\n   std::string e_str;\n+  void c_take_opaque_ref_method() const;\n+  void c_take_opaque_mut_ref_method();\n };\n \n enum COwnedEnum {\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -263,10 +263,14 @@ fn test_rust_name_attribute() {\n \n #[test]\n fn test_extern_trivial() {\n-    let d = ffi2::c_return_trivial();\n+    let mut d = ffi2::c_return_trivial();\n     check!(ffi2::c_take_trivial_ref(&d));\n+    check!(d.c_take_trivial_ref_method());\n+    check!(d.c_take_trivial_mut_ref_method());\n     check!(ffi2::c_take_trivial(d));\n-    let d = ffi2::c_return_trivial_ptr();\n+    let mut d = ffi2::c_return_trivial_ptr();\n+    check!(d.c_take_trivial_ref_method());\n+    check!(d.c_take_trivial_mut_ref_method());\n     check!(ffi2::c_take_trivial_ptr(d));\n     cxx::UniquePtr::new(ffi2::D { d: 42 });\n     let d = ffi2::ns_c_return_trivial();\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -282,8 +286,10 @@ fn test_extern_trivial() {\n \n #[test]\n fn test_extern_opaque() {\n-    let e = ffi2::c_return_opaque_ptr();\n+    let mut e = ffi2::c_return_opaque_ptr();\n     check!(ffi2::c_take_opaque_ref(e.as_ref().unwrap()));\n+    check!(e.c_take_opaque_ref_method());\n+    check!(e.pin_mut().c_take_opaque_mut_ref_method());\n     check!(ffi2::c_take_opaque_ptr(e));\n \n     let f = ffi2::c_return_ns_opaque_ptr();\ndiff --git a/tests/ui/by_value_not_supported.stderr b/tests/ui/by_value_not_supported.stderr\n--- a/tests/ui/by_value_not_supported.stderr\n+++ b/tests/ui/by_value_not_supported.stderr\n@@ -22,6 +22,18 @@ error: needs a cxx::ExternType impl in order to be used as a field of `S`\n 10 |         type C;\n    |         ^^^^^^\n \n+error: needs a cxx::ExternType impl in order to be used as an argument of `f`\n+  --> $DIR/by_value_not_supported.rs:10:9\n+   |\n+10 |         type C;\n+   |         ^^^^^^\n+\n+error: needs a cxx::ExternType impl in order to be used as a return value of `f`\n+  --> $DIR/by_value_not_supported.rs:10:9\n+   |\n+10 |         type C;\n+   |         ^^^^^^\n+\n error: passing opaque C++ type by value is not supported\n   --> $DIR/by_value_not_supported.rs:16:14\n    |\ndiff --git a/tests/ui/pin_mut_opaque.stderr b/tests/ui/pin_mut_opaque.stderr\n--- a/tests/ui/pin_mut_opaque.stderr\n+++ b/tests/ui/pin_mut_opaque.stderr\n@@ -1,28 +1,46 @@\n-error: mutable reference to C++ type requires a pin -- use Pin<&mut Opaque>\n+error: mutable reference to C++ type requires a pin -- use Pin<&mut Opaque> or declare the type Trivial in a cxx::ExternType impl\n  --> $DIR/pin_mut_opaque.rs:5:19\n   |\n 5 |         fn f(arg: &mut Opaque);\n   |                   ^^^^^^^^^^^\n \n-error: mutable reference to C++ type requires a pin -- use Pin<&mut CxxString>\n+error: mutable reference to C++ type requires a pin -- use Pin<&mut CxxString> or declare the type Trivial in a cxx::ExternType impl\n  --> $DIR/pin_mut_opaque.rs:8:17\n   |\n 8 |         fn s(s: &mut CxxString);\n   |                 ^^^^^^^^^^^^^^\n \n-error: mutable reference to C++ type requires a pin -- use Pin<&mut CxxVector<...>>\n+error: mutable reference to C++ type requires a pin -- use Pin<&mut CxxVector<...>> or declare the type Trivial in a cxx::ExternType impl\n  --> $DIR/pin_mut_opaque.rs:9:17\n   |\n 9 |         fn v(v: &mut CxxVector<u8>);\n   |                 ^^^^^^^^^^^^^^^^^^\n \n-error: mutable reference to C++ type requires a pin -- use `self: Pin<&mut Opaque>`\n+error: needs a cxx::ExternType impl in order to be used as a non-pinned mutable reference argument of f\n+ --> $DIR/pin_mut_opaque.rs:4:9\n+  |\n+4 |         type Opaque;\n+  |         ^^^^^^^^^^^\n+\n+error: needs a cxx::ExternType impl in order to be used as a non-pinned mutable reference argument of g\n+ --> $DIR/pin_mut_opaque.rs:4:9\n+  |\n+4 |         type Opaque;\n+  |         ^^^^^^^^^^^\n+\n+error: needs a cxx::ExternType impl in order to be used as a non-pinned mutable reference argument of h\n+ --> $DIR/pin_mut_opaque.rs:4:9\n+  |\n+4 |         type Opaque;\n+  |         ^^^^^^^^^^^\n+\n+error: mutable reference to opaque C++ type requires a pin -- use `self: Pin<&mut Opaque>` or declare the type Trivial in a cxx::ExternType impl\n  --> $DIR/pin_mut_opaque.rs:6:14\n   |\n 6 |         fn g(&mut self);\n   |              ^^^^^^^^^\n \n-error: mutable reference to C++ type requires a pin -- use `self: Pin<&mut Opaque>`\n+error: mutable reference to opaque C++ type requires a pin -- use `self: Pin<&mut Opaque>` or declare the type Trivial in a cxx::ExternType impl\n  --> $DIR/pin_mut_opaque.rs:7:20\n   |\n 7 |         fn h(self: &mut Opaque);\n",
        "problem_statement": "Error message not quite correct for Trivial/Opaque mistakes in extern types\nIf I modify the demo example along these lines:\r\n\r\n```rust\r\nunsafe impl ExternType for bindgen::BlobstoreClient {\r\n    type Id = type_id!(\"org::blobstore::BlobstoreClient\");\r\n    type Kind = cxx::kind::Opaque; // no good!\r\n}\r\n\r\nmod bindgen {\r\n    #[repr(C)]\r\n    pub struct BlobstoreClient {\r\n        a: u32,\r\n    }\r\n}\r\n\r\n#[cxx::bridge(namespace = \"org::blobstore\")]\r\nmod ffi {\r\n    impl UniquePtr<BlobstoreClient> {}\r\n\r\n    // C++ types and signatures exposed to Rust.\r\n    unsafe extern \"C++\" {\r\n        include!(\"demo/include/blobstore.h\");\r\n\r\n        type BlobstoreClient = super::bindgen::BlobstoreClient;\r\n\r\n        fn update(blob: BlobstoreClient); // reason why the type needs to be Trivial\r\n    }\r\n}\r\n```\r\n\r\nExpected behavior:\r\n* Rust error message that `cxx::Kind::Opaque` is insufficient and the kind needs to be `cxx::Kind::Trivial`\r\n\r\nIdeal behavior:\r\n* Rust error message that `cxx::Kind::Opaque` is insufficient, _with details from the `TrivialReason` saying _why_ it needs to be `Trivial`\r\n\r\nActual behavior:\r\n* When building the demo, the C++ is built first, giving an error: `error: static_assert failed due to requirement '::rust::IsRelocatable<org::blobstore::BlobstoreClient>::value' \"type ::org::blobstore::BlobstoreClient marked as Trivial in Rust is not trivially move constructible and trivially destructible in C++\"`\r\n* We never see any Rust compilation or errors.\r\n\r\nAt the very least, this sentence is factually incorrect, because the type is not _marked_ as Trivial. It _needs to be_ trivial and that's what the error message should be saying.\r\n\r\nAt least in the `cargo` case the C++ will always be built first and I can't think of any way to get a nice error message pertaining to the `Kind` of the `ExternType` since that's entirely invisible to `cxx::bridge` and therefore to the generated C++. For other build systems, I guess it's 50/50 whether the user sees the Rust or C++ error message first.\r\n\r\nBefore I raise a small PR to fix the wording of the C++ error message, I wondered whether you had any cunning plans to squeeze out a better error message in these cases.\r\n\r\nNB I have not tried the _exact_ code I state above. I am encountering these symptoms for my WIP in #546.\n",
        "hints_text": "",
        "created_at": "2020-12-08T01:01:29Z",
        "version": "1.0"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 187,
        "instance_id": "dtolnay__cxx-187",
        "issue_numbers": [
            "177"
        ],
        "base_commit": "24d22b471abf8949dfed8810a4ba314a5b7041d6",
        "patch": "diff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -66,7 +66,11 @@ pub(super) fn gen(\n             }\n             Api::Enum(enm) => {\n                 out.next_section();\n-                write_enum(out, enm);\n+                if types.cxx.contains(&enm.ident) {\n+                    check_enum(out, enm);\n+                } else {\n+                    write_enum(out, enm);\n+                }\n             }\n             Api::RustType(ety) => {\n                 if let Some(methods) = methods_for_type.get(&ety.ident) {\ndiff --git a/gen/src/write.rs b/gen/src/write.rs\n--- a/gen/src/write.rs\n+++ b/gen/src/write.rs\n@@ -373,6 +377,27 @@ fn write_enum(out: &mut OutFile, enm: &Enum) {\n     writeln!(out, \"}};\");\n }\n \n+fn check_enum(out: &mut OutFile, enm: &Enum) {\n+    writeln!(\n+        out,\n+        \"static_assert(sizeof({}) == sizeof(uint32_t), \\\"incorrect size\\\");\",\n+        enm.ident\n+    );\n+    let mut prev_discriminant = None;\n+    for variant in &enm.variants {\n+        let discriminant = variant\n+            .discriminant\n+            .unwrap_or_else(|| prev_discriminant.map_or(0, |n| n + 1));\n+        writeln!(\n+            out,\n+            \"static_assert(static_cast<uint32_t>({}::{}) == {},\n+              \\\"disagrees with the value in #[cxx::bridge]\\\");\",\n+            enm.ident, variant.ident, discriminant,\n+        );\n+        prev_discriminant = Some(discriminant);\n+    }\n+}\n+\n fn write_exception_glue(out: &mut OutFile, apis: &[Api]) {\n     let mut has_cxx_throws = false;\n     for api in apis {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -44,7 +44,11 @@ fn expand(namespace: &Namespace, ffi: ItemMod, apis: &[Api], types: &Types) -> T\n             Api::Include(_) | Api::RustType(_) => {}\n             Api::Struct(strct) => expanded.extend(expand_struct(strct)),\n             Api::Enum(enm) => expanded.extend(expand_enum(enm)),\n-            Api::CxxType(ety) => expanded.extend(expand_cxx_type(ety)),\n+            Api::CxxType(ety) => {\n+                if !types.enums.contains_key(&ety.ident) {\n+                    expanded.extend(expand_cxx_type(ety));\n+                }\n+            }\n             Api::CxxFunction(efn) => {\n                 expanded.extend(expand_cxx_function_shim(namespace, efn, types));\n             }\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -61,15 +61,18 @@ impl<'a> Types<'a> {\n                 }\n                 Api::Enum(enm) => {\n                     let ident = &enm.ident;\n-                    if type_names.insert(ident) {\n-                        enums.insert(ident.clone(), enm);\n-                    } else {\n+                    // We allow declaring the same type as a shared enum and as a Cxxtype, as this\n+                    // means not to emit the C++ enum definition.\n+                    if !type_names.insert(ident) && !cxx.contains(ident) {\n                         duplicate_name(cx, enm, ident);\n                     }\n+                    enums.insert(ident.clone(), enm);\n                 }\n                 Api::CxxType(ety) => {\n                     let ident = &ety.ident;\n-                    if !type_names.insert(ident) {\n+                    // We allow declaring the same type as a shared enum and as a Cxxtype, as this\n+                    // means not to emit the C++ enum definition.\n+                    if !type_names.insert(ident) && !enums.contains_key(ident) {\n                         duplicate_name(cx, ety, ident);\n                     }\n                     cxx.insert(ident);\n",
        "test_patch": "diff --git a/tests/ffi/lib.rs b/tests/ffi/lib.rs\n--- a/tests/ffi/lib.rs\n+++ b/tests/ffi/lib.rs\n@@ -84,6 +84,15 @@ pub mod ffi {\n         fn set2(&mut self, n: usize) -> usize;\n     }\n \n+    extern \"C\" {\n+        type COwnedEnum;\n+    }\n+\n+    enum COwnedEnum {\n+        CVal1,\n+        CVal2,\n+    }\n+\n     extern \"Rust\" {\n         type R;\n         type R2;\ndiff --git a/tests/ffi/tests.h b/tests/ffi/tests.h\n--- a/tests/ffi/tests.h\n+++ b/tests/ffi/tests.h\n@@ -23,6 +23,11 @@ class C {\n   std::vector<uint8_t> v;\n };\n \n+enum COwnedEnum {\n+  CVal1,\n+  CVal2,\n+};\n+\n size_t c_return_primitive();\n Shared c_return_shared();\n rust::Box<R> c_return_box();\n",
        "problem_statement": "Extern C-like enums\nThe enum support from #170 doesn't apply to interop with existing enums for which C++ is the source of truth.\r\n\r\nI wonder if we could handle this use case as follows:\r\n\r\n```rust\r\nmod ffi {\r\n    enum SmallPrime {\r\n        Two = 2,\r\n        Three = 3,\r\n        Five = 5,\r\n    }\r\n\r\n    extern \"C\" {\r\n        type SmallPrime;\r\n    }\r\n}\r\n```\r\n\r\nwhere we ask that the enum variants be provided just like in #170, but if the same type name is also an extern \"C\" type then we don't emit a C++ enum class definition, but instead emit static assertions on the C++ side asserting that the cxx bridge discriminants are all the same as the existing C++ enum's values.\n",
        "hints_text": "",
        "created_at": "2020-05-04T22:28:01Z",
        "version": "0.3"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 186,
        "instance_id": "dtolnay__cxx-186",
        "issue_numbers": [
            "183"
        ],
        "base_commit": "2ec14632c091bcb459b83b953f465a96c5030ff9",
        "patch": "diff --git a/gen/src/mod.rs b/gen/src/mod.rs\n--- a/gen/src/mod.rs\n+++ b/gen/src/mod.rs\n@@ -8,6 +8,7 @@ mod write;\n \n use self::error::{format_err, Error, Result};\n use crate::syntax::namespace::Namespace;\n+use crate::syntax::report::Errors;\n use crate::syntax::{self, check, Types};\n use quote::quote;\n use std::fs;\ndiff --git a/gen/src/mod.rs b/gen/src/mod.rs\n--- a/gen/src/mod.rs\n+++ b/gen/src/mod.rs\n@@ -42,12 +43,15 @@ fn generate(path: &Path, opt: Opt, header: bool) -> Vec<u8> {\n     };\n     match (|| -> Result<_> {\n         proc_macro2::fallback::force();\n+        let ref mut errors = Errors::new();\n         let syntax = syn::parse_file(&source)?;\n         let bridge = find_bridge_mod(syntax)?;\n         let ref namespace = bridge.namespace;\n-        let ref apis = syntax::parse_items(bridge.module)?;\n-        let ref types = Types::collect(apis)?;\n-        check::typecheck(namespace, apis, types)?;\n+        let ref apis = syntax::parse_items(errors, bridge.module);\n+        let ref types = Types::collect(errors, apis);\n+        errors.propagate()?;\n+        check::typecheck(errors, namespace, apis, types);\n+        errors.propagate()?;\n         let out = write::gen(namespace, apis, types, opt, header);\n         Ok(out)\n     })() {\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -1,5 +1,6 @@\n use crate::syntax::atom::Atom::{self, *};\n use crate::syntax::namespace::Namespace;\n+use crate::syntax::report::Errors;\n use crate::syntax::symbol::Symbol;\n use crate::syntax::{\n     self, check, mangle, Api, Enum, ExternFn, ExternType, Signature, Struct, Type, Types,\ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -8,16 +9,22 @@ use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote, quote_spanned, ToTokens};\n use syn::{parse_quote, Error, ItemMod, Result, Token};\n \n-pub fn bridge(namespace: &Namespace, ffi: ItemMod) -> Result<TokenStream> {\n-    let ident = &ffi.ident;\n-    let content = ffi.content.ok_or(Error::new(\n+pub fn bridge(namespace: &Namespace, mut ffi: ItemMod) -> Result<TokenStream> {\n+    let ref mut errors = Errors::new();\n+    let content = ffi.content.take().ok_or(Error::new(\n         Span::call_site(),\n         \"#[cxx::bridge] module must have inline contents\",\n     ))?;\n-    let ref apis = syntax::parse_items(content.1)?;\n-    let ref types = Types::collect(apis)?;\n-    check::typecheck(namespace, apis, types)?;\n+    let ref apis = syntax::parse_items(errors, content.1);\n+    let ref types = Types::collect(errors, apis);\n+    errors.propagate()?;\n+    check::typecheck(errors, namespace, apis, types);\n+    errors.propagate()?;\n+\n+    Ok(expand(namespace, ffi, apis, types))\n+}\n \n+fn expand(namespace: &Namespace, ffi: ItemMod, apis: &[Api], types: &Types) -> TokenStream {\n     let mut expanded = TokenStream::new();\n     let mut hidden = TokenStream::new();\n \ndiff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -93,15 +100,16 @@ pub fn bridge(namespace: &Namespace, ffi: ItemMod) -> Result<TokenStream> {\n         .into_iter()\n         .filter(|attr| attr.path.is_ident(\"doc\"));\n     let vis = &ffi.vis;\n+    let ident = &ffi.ident;\n \n-    Ok(quote! {\n+    quote! {\n         #(#attrs)*\n         #[deny(improper_ctypes)]\n         #[allow(non_snake_case)]\n         #vis mod #ident {\n             #expanded\n         }\n-    })\n+    }\n }\n \n fn expand_struct(strct: &Struct) -> TokenStream {\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -1,5 +1,6 @@\n use crate::syntax::atom::Atom::{self, *};\n use crate::syntax::namespace::Namespace;\n+use crate::syntax::report::Errors;\n use crate::syntax::{\n     error, ident, Api, Enum, ExternFn, ExternType, Lang, Receiver, Ref, Slice, Struct, Ty1, Type,\n     Types,\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -9,25 +10,21 @@ use quote::{quote, ToTokens};\n use std::collections::HashSet;\n use std::fmt::Display;\n use std::u32;\n-use syn::{Error, Result};\n \n pub(crate) struct Check<'a> {\n     namespace: &'a Namespace,\n     apis: &'a [Api],\n     types: &'a Types<'a>,\n-    errors: &'a mut Vec<Error>,\n+    errors: &'a mut Errors,\n }\n \n-pub(crate) fn typecheck(namespace: &Namespace, apis: &[Api], types: &Types) -> Result<()> {\n-    let mut errors = Vec::new();\n-    let mut cx = Check {\n+pub(crate) fn typecheck(cx: &mut Errors, namespace: &Namespace, apis: &[Api], types: &Types) {\n+    do_typecheck(&mut Check {\n         namespace,\n         apis,\n         types,\n-        errors: &mut errors,\n-    };\n-    do_typecheck(&mut cx);\n-    combine_errors(errors)\n+        errors: cx,\n+    });\n }\n \n fn do_typecheck(cx: &mut Check) {\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -59,7 +56,7 @@ fn do_typecheck(cx: &mut Check) {\n \n impl Check<'_> {\n     pub(crate) fn error(&mut self, sp: impl ToTokens, msg: impl Display) {\n-        self.errors.push(Error::new_spanned(sp, msg));\n+        self.errors.error(sp, msg);\n     }\n }\n \ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -373,18 +370,6 @@ fn span_for_receiver_error(receiver: &Receiver) -> TokenStream {\n     }\n }\n \n-fn combine_errors(errors: Vec<Error>) -> Result<()> {\n-    let mut iter = errors.into_iter();\n-    let mut all_errors = match iter.next() {\n-        Some(err) => err,\n-        None => return Ok(()),\n-    };\n-    for err in iter {\n-        all_errors.combine(err);\n-    }\n-    Err(all_errors)\n-}\n-\n fn describe(cx: &mut Check, ty: &Type) -> String {\n     match ty {\n         Type::Ident(ident) => {\ndiff --git a/syntax/mod.rs b/syntax/mod.rs\n--- a/syntax/mod.rs\n+++ b/syntax/mod.rs\n@@ -10,6 +10,7 @@ mod impls;\n pub mod mangle;\n pub mod namespace;\n mod parse;\n+pub mod report;\n pub mod set;\n pub mod symbol;\n mod tokens;\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -1,3 +1,4 @@\n+use crate::syntax::report::Errors;\n use crate::syntax::Atom::*;\n use crate::syntax::{\n     attrs, error, Api, Doc, Enum, ExternFn, ExternType, Lang, Receiver, Ref, Signature, Slice,\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -16,27 +17,24 @@ pub mod kw {\n     syn::custom_keyword!(Result);\n }\n \n-pub fn parse_items(items: Vec<Item>) -> Result<Vec<Api>> {\n+pub fn parse_items(cx: &mut Errors, items: Vec<Item>) -> Vec<Api> {\n     let mut apis = Vec::new();\n     for item in items {\n         match item {\n-            Item::Struct(item) => {\n-                let strct = parse_struct(item)?;\n-                apis.push(strct);\n-            }\n-            Item::Enum(item) => {\n-                let enm = parse_enum(item)?;\n-                apis.push(enm);\n-            }\n-            Item::ForeignMod(foreign_mod) => {\n-                let functions = parse_foreign_mod(foreign_mod)?;\n-                apis.extend(functions);\n-            }\n-            Item::Use(item) => return Err(Error::new_spanned(item, error::USE_NOT_ALLOWED)),\n-            _ => return Err(Error::new_spanned(item, \"unsupported item\")),\n+            Item::Struct(item) => match parse_struct(item) {\n+                Ok(strct) => apis.push(strct),\n+                Err(err) => cx.push(err),\n+            },\n+            Item::Enum(item) => match parse_enum(item) {\n+                Ok(enm) => apis.push(enm),\n+                Err(err) => cx.push(err),\n+            },\n+            Item::ForeignMod(foreign_mod) => parse_foreign_mod(cx, foreign_mod, &mut apis),\n+            Item::Use(item) => cx.error(item, error::USE_NOT_ALLOWED),\n+            _ => cx.error(item, \"unsupported item\"),\n         }\n     }\n-    Ok(apis)\n+    apis\n }\n \n fn parse_struct(item: ItemStruct) -> Result<Api> {\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -151,8 +149,11 @@ fn parse_variant(variant: RustVariant) -> Result<Variant> {\n     }\n }\n \n-fn parse_foreign_mod(foreign_mod: ItemForeignMod) -> Result<Vec<Api>> {\n-    let lang = parse_lang(foreign_mod.abi)?;\n+fn parse_foreign_mod(cx: &mut Errors, foreign_mod: ItemForeignMod, out: &mut Vec<Api>) {\n+    let lang = match parse_lang(foreign_mod.abi) {\n+        Ok(lang) => lang,\n+        Err(err) => return cx.push(err),\n+    };\n     let api_type = match lang {\n         Lang::Cxx => Api::CxxType,\n         Lang::Rust => Api::RustType,\ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -165,19 +166,21 @@ fn parse_foreign_mod(foreign_mod: ItemForeignMod) -> Result<Vec<Api>> {\n     let mut items = Vec::new();\n     for foreign in &foreign_mod.items {\n         match foreign {\n-            ForeignItem::Type(foreign) => {\n-                let ety = parse_extern_type(foreign)?;\n-                items.push(api_type(ety));\n-            }\n-            ForeignItem::Fn(foreign) => {\n-                let efn = parse_extern_fn(foreign, lang)?;\n-                items.push(api_function(efn));\n-            }\n+            ForeignItem::Type(foreign) => match parse_extern_type(foreign) {\n+                Ok(ety) => items.push(api_type(ety)),\n+                Err(err) => cx.push(err),\n+            },\n+            ForeignItem::Fn(foreign) => match parse_extern_fn(foreign, lang) {\n+                Ok(efn) => items.push(api_function(efn)),\n+                Err(err) => cx.push(err),\n+            },\n             ForeignItem::Macro(foreign) if foreign.mac.path.is_ident(\"include\") => {\n-                let include = foreign.mac.parse_body()?;\n-                items.push(Api::Include(include));\n+                match foreign.mac.parse_body() {\n+                    Ok(include) => items.push(Api::Include(include)),\n+                    Err(err) => cx.push(err),\n+                }\n             }\n-            _ => return Err(Error::new_spanned(foreign, \"unsupported foreign item\")),\n+            _ => cx.error(foreign, \"unsupported foreign item\"),\n         }\n     }\n \ndiff --git a/syntax/parse.rs b/syntax/parse.rs\n--- a/syntax/parse.rs\n+++ b/syntax/parse.rs\n@@ -198,7 +201,7 @@ fn parse_foreign_mod(foreign_mod: ItemForeignMod) -> Result<Vec<Api>> {\n         }\n     }\n \n-    Ok(items)\n+    out.extend(items);\n }\n \n fn parse_lang(abi: Abi) -> Result<Lang> {\ndiff --git /dev/null b/syntax/report.rs\nnew file mode 100644\n--- /dev/null\n+++ b/syntax/report.rs\n@@ -0,0 +1,33 @@\n+use quote::ToTokens;\n+use std::fmt::Display;\n+use syn::{Error, Result};\n+\n+pub struct Errors {\n+    errors: Vec<Error>,\n+}\n+\n+impl Errors {\n+    pub fn new() -> Self {\n+        Errors { errors: Vec::new() }\n+    }\n+\n+    pub fn error(&mut self, sp: impl ToTokens, msg: impl Display) {\n+        self.errors.push(Error::new_spanned(sp, msg));\n+    }\n+\n+    pub fn push(&mut self, error: Error) {\n+        self.errors.push(error);\n+    }\n+\n+    pub fn propagate(&mut self) -> Result<()> {\n+        let mut iter = self.errors.drain(..);\n+        let mut all_errors = match iter.next() {\n+            Some(err) => err,\n+            None => return Ok(()),\n+        };\n+        for err in iter {\n+            all_errors.combine(err);\n+        }\n+        Err(all_errors)\n+    }\n+}\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -1,10 +1,10 @@\n use crate::syntax::atom::Atom::{self, *};\n+use crate::syntax::report::Errors;\n use crate::syntax::set::OrderedSet as Set;\n use crate::syntax::{Api, Derive, Enum, Struct, Type};\n use proc_macro2::Ident;\n use quote::ToTokens;\n use std::collections::{BTreeMap as Map, HashSet as UnorderedSet};\n-use syn::{Error, Result};\n \n pub struct Types<'a> {\n     pub all: Set<'a, Type>,\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -15,7 +15,7 @@ pub struct Types<'a> {\n }\n \n impl<'a> Types<'a> {\n-    pub fn collect(apis: &'a [Api]) -> Result<Self> {\n+    pub fn collect(cx: &mut Errors, apis: &'a [Api]) -> Self {\n         let mut all = Set::new();\n         let mut structs = Map::new();\n         let mut enums = Map::new();\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -50,39 +50,41 @@ impl<'a> Types<'a> {\n                 Api::Include(_) => {}\n                 Api::Struct(strct) => {\n                     let ident = &strct.ident;\n-                    if !type_names.insert(ident) {\n-                        return Err(duplicate_name(strct, ident));\n+                    if type_names.insert(ident) {\n+                        structs.insert(ident.clone(), strct);\n+                    } else {\n+                        duplicate_name(cx, strct, ident);\n                     }\n-                    structs.insert(ident.clone(), strct);\n                     for field in &strct.fields {\n                         visit(&mut all, &field.ty);\n                     }\n                 }\n                 Api::Enum(enm) => {\n                     let ident = &enm.ident;\n-                    if !type_names.insert(ident) {\n-                        return Err(duplicate_name(enm, ident));\n+                    if type_names.insert(ident) {\n+                        enums.insert(ident.clone(), enm);\n+                    } else {\n+                        duplicate_name(cx, enm, ident);\n                     }\n-                    enums.insert(ident.clone(), enm);\n                 }\n                 Api::CxxType(ety) => {\n                     let ident = &ety.ident;\n                     if !type_names.insert(ident) {\n-                        return Err(duplicate_name(ety, ident));\n+                        duplicate_name(cx, ety, ident);\n                     }\n                     cxx.insert(ident);\n                 }\n                 Api::RustType(ety) => {\n                     let ident = &ety.ident;\n                     if !type_names.insert(ident) {\n-                        return Err(duplicate_name(ety, ident));\n+                        duplicate_name(cx, ety, ident);\n                     }\n                     rust.insert(ident);\n                 }\n                 Api::CxxFunction(efn) | Api::RustFunction(efn) => {\n                     let ident = &efn.ident;\n                     if !function_names.insert((&efn.receiver, ident)) {\n-                        return Err(duplicate_name(efn, ident));\n+                        duplicate_name(cx, efn, ident);\n                     }\n                     for arg in &efn.args {\n                         visit(&mut all, &arg.ty);\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -94,13 +96,13 @@ impl<'a> Types<'a> {\n             }\n         }\n \n-        Ok(Types {\n+        Types {\n             all,\n             structs,\n             enums,\n             cxx,\n             rust,\n-        })\n+        }\n     }\n \n     pub fn needs_indirect_abi(&self, ty: &Type) -> bool {\ndiff --git a/syntax/types.rs b/syntax/types.rs\n--- a/syntax/types.rs\n+++ b/syntax/types.rs\n@@ -135,7 +137,7 @@ impl<'t, 'a> IntoIterator for &'t Types<'a> {\n     }\n }\n \n-fn duplicate_name(sp: impl ToTokens, ident: &Ident) -> Error {\n+fn duplicate_name(cx: &mut Errors, sp: impl ToTokens, ident: &Ident) {\n     let msg = format!(\"the name `{}` is defined multiple times\", ident);\n-    Error::new_spanned(sp, msg)\n+    cx.error(sp, msg);\n }\n",
        "test_patch": "diff --git /dev/null b/tests/ui/multiple_parse_error.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/multiple_parse_error.rs\n@@ -0,0 +1,9 @@\n+#[cxx::bridge]\n+mod ffi {\n+    struct Monad<T>;\n+\n+    extern \"Haskell\" {\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/multiple_parse_error.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/multiple_parse_error.stderr\n@@ -0,0 +1,11 @@\n+error: struct with generic parameters is not supported yet\n+ --> $DIR/multiple_parse_error.rs:3:5\n+  |\n+3 |     struct Monad<T>;\n+  |     ^^^^^^^^^^^^^^^\n+\n+error: unrecognized ABI\n+ --> $DIR/multiple_parse_error.rs:5:5\n+  |\n+5 |     extern \"Haskell\" {\n+  |     ^^^^^^^^^^^^^^^^\n",
        "problem_statement": "Batch parse errors\nCurrently any error detected inside [cxx/syntax/parse.rs](https://github.com/dtolnay/cxx/blob/18cd7572131a0bf86d23eeca40ad436b7c6f35ed/syntax/parse.rs) aborts the code generator and thus at most one parse error is reported at a time. In the typechecker we have a much better system using cx.error(...). We should apply the same for parse errors.\n",
        "hints_text": "",
        "created_at": "2020-05-04T08:31:40Z",
        "version": "0.3"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 182,
        "instance_id": "dtolnay__cxx-182",
        "issue_numbers": [
            "178"
        ],
        "base_commit": "e720e852c1733cca64e0abcae36bd56d5bc92799",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -137,14 +137,16 @@ fn expand_enum(enm: &Enum) -> TokenStream {\n                 .unwrap_or_else(|| prev_discriminant.map_or(0, |n| n + 1));\n             *prev_discriminant = Some(discriminant);\n             Some(quote! {\n-                pub const #variant_ident: Self = #ident(#discriminant);\n+                pub const #variant_ident: Self = #ident { repr: #discriminant };\n             })\n         });\n     quote! {\n         #doc\n         #[derive(Copy, Clone, PartialEq, Eq)]\n         #[repr(transparent)]\n-        pub struct #ident(u32);\n+        pub struct #ident {\n+            pub repr: u32,\n+        }\n \n         #[allow(non_upper_case_globals)]\n         impl #ident {\n",
        "test_patch": "diff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -52,15 +52,15 @@ fn test_c_return() {\n     assert_eq!(2020, ffi::c_return_identity(2020));\n     assert_eq!(2021, ffi::c_return_sum(2020, 1));\n     match ffi::c_return_enum(0) {\n-        ffi::Enum::AVal => {}\n+        enm @ ffi::Enum::AVal => assert_eq!(0, enm.repr),\n         _ => assert!(false),\n     }\n     match ffi::c_return_enum(1) {\n-        ffi::Enum::BVal => {}\n+        enm @ ffi::Enum::BVal => assert_eq!(2020, enm.repr),\n         _ => assert!(false),\n     }\n     match ffi::c_return_enum(2021) {\n-        ffi::Enum::CVal => {}\n+        enm @ ffi::Enum::CVal => assert_eq!(2021, enm.repr),\n         _ => assert!(false),\n     }\n }\ndiff --git a/tests/test.rs b/tests/test.rs\n--- a/tests/test.rs\n+++ b/tests/test.rs\n@@ -160,6 +160,13 @@ fn test_c_method_calls() {\n     assert_eq!(old_value, unique_ptr.get2())\n }\n \n+#[test]\n+fn test_enum_representations() {\n+    assert_eq!(0, ffi::Enum::AVal.repr);\n+    assert_eq!(2020, ffi::Enum::BVal.repr);\n+    assert_eq!(2021, ffi::Enum::CVal.repr);\n+}\n+\n #[no_mangle]\n extern \"C\" fn cxx_test_suite_get_box() -> *mut cxx_test_suite::R {\n     Box::into_raw(Box::new(2020usize))\ndiff --git a/tests/ui/enum_match_without_wildcard.stderr b/tests/ui/enum_match_without_wildcard.stderr\n--- a/tests/ui/enum_match_without_wildcard.stderr\n+++ b/tests/ui/enum_match_without_wildcard.stderr\n@@ -1,11 +1,11 @@\n-error[E0004]: non-exhaustive patterns: `A(2u32..=std::u32::MAX)` not covered\n+error[E0004]: non-exhaustive patterns: `A { repr: 2u32..=std::u32::MAX }` not covered\n   --> $DIR/enum_match_without_wildcard.rs:12:11\n    |\n 1  | #[cxx::bridge]\n    | -------------- `ffi::A` defined here\n ...\n 12 |     match a {\n-   |           ^ pattern `A(2u32..=std::u32::MAX)` not covered\n+   |           ^ pattern `A { repr: 2u32..=std::u32::MAX }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `ffi::A`\n",
        "problem_statement": "Expose enum value as integer\n#170 produces \"enums\" with a private integer representation, and public associated constants corresponding to the variants.\r\n\r\n```rust\r\n#[derive(Copy, Clone, PartialEq, Eq)]\r\n#[repr(transparent)]\r\npub enum SmallPrime(u32);\r\n\r\n#[allow(non_upper_case_globals)]\r\nimpl SmallPrime {\r\n    pub const Two: Self = SmallPrime(2);\r\n    pub const Three: Self = SmallPrime(3);\r\n    pub const Five: Self = SmallPrime(6);\r\n}\r\n```\r\n\r\nThis behaves like an ordinary Rust enum in all ways except that it enforces a wildcard match arm when matched (which is deliberate) and that it cannot be cast using `as` to a primitive (which is unfortunate).\r\n\r\nWe should expose some way to get the primitive value. Maybe a method, maybe just a straightforward public field like `n.repr`.\n",
        "hints_text": "",
        "created_at": "2020-05-01T21:05:28Z",
        "version": "0.3"
    },
    {
        "repo": "dtolnay/cxx",
        "pull_number": 180,
        "instance_id": "dtolnay__cxx-180",
        "issue_numbers": [
            "176"
        ],
        "base_commit": "c4ddb4d172e2d048bd13b2840a8af75e90f2e3f0",
        "patch": "diff --git a/macro/src/expand.rs b/macro/src/expand.rs\n--- a/macro/src/expand.rs\n+++ b/macro/src/expand.rs\n@@ -127,14 +127,19 @@ fn expand_struct(strct: &Struct) -> TokenStream {\n fn expand_enum(enm: &Enum) -> TokenStream {\n     let ident = &enm.ident;\n     let doc = &enm.doc;\n-    let variants = enm.variants.iter().scan(0, |next_discriminant, variant| {\n-        let variant_ident = &variant.ident;\n-        let discriminant = variant.discriminant.unwrap_or(*next_discriminant);\n-        *next_discriminant = discriminant + 1;\n-        Some(quote! {\n-            pub const #variant_ident: Self = #ident(#discriminant);\n-        })\n-    });\n+    let variants = enm\n+        .variants\n+        .iter()\n+        .scan(None, |prev_discriminant, variant| {\n+            let variant_ident = &variant.ident;\n+            let discriminant = variant\n+                .discriminant\n+                .unwrap_or_else(|| prev_discriminant.map_or(0, |n| n + 1));\n+            *prev_discriminant = Some(discriminant);\n+            Some(quote! {\n+                pub const #variant_ident: Self = #ident(#discriminant);\n+            })\n+        });\n     quote! {\n         #doc\n         #[derive(Copy, Clone, PartialEq, Eq)]\ndiff --git a/syntax/check.rs b/syntax/check.rs\n--- a/syntax/check.rs\n+++ b/syntax/check.rs\n@@ -204,14 +204,23 @@ fn check_api_enum(cx: &mut Check, enm: &Enum) {\n     }\n \n     let mut discriminants = HashSet::new();\n-    enm.variants.iter().fold(0, |next_discriminant, variant| {\n-        let discriminant = variant.discriminant.unwrap_or(next_discriminant);\n-        if !discriminants.insert(discriminant) {\n-            let msg = format!(\"discriminant value `{}` already exists\", discriminant);\n-            cx.error(span_for_enum_error(enm), msg);\n-        }\n-        discriminant + 1\n-    });\n+    enm.variants\n+        .iter()\n+        .fold(None, |prev_discriminant, variant| {\n+            if variant.discriminant.is_none() && prev_discriminant.unwrap_or(0) == u32::MAX {\n+                let msg = format!(\"overflowed on value after {}\", prev_discriminant.unwrap());\n+                cx.error(span_for_enum_error(enm), msg);\n+                return None;\n+            }\n+            let discriminant = variant\n+                .discriminant\n+                .unwrap_or_else(|| prev_discriminant.map_or(0, |n| n + 1));\n+            if !discriminants.insert(discriminant) {\n+                let msg = format!(\"discriminant value `{}` already exists\", discriminant);\n+                cx.error(span_for_enum_error(enm), msg);\n+            }\n+            Some(discriminant)\n+        });\n }\n \n fn check_api_type(cx: &mut Check, ty: &ExternType) {\n",
        "test_patch": "diff --git /dev/null b/tests/ui/enum_overflows.rs\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/enum_overflows.rs\n@@ -0,0 +1,17 @@\n+#[cxx::bridge]\n+mod ffi {\n+    enum Good1 {\n+        A = 0xffffffff,\n+    }\n+    enum Good2 {\n+        B = 0xffffffff,\n+        C = 2020,\n+    }\n+    enum Bad {\n+        D = 0xfffffffe,\n+        E,\n+        F,\n+    }\n+}\n+\n+fn main() {}\ndiff --git /dev/null b/tests/ui/enum_overflows.stderr\nnew file mode 100644\n--- /dev/null\n+++ b/tests/ui/enum_overflows.stderr\n@@ -0,0 +1,9 @@\n+error: overflowed on value after 4294967295\n+  --> $DIR/enum_overflows.rs:10:5\n+   |\n+10 | /     enum Bad {\n+11 | |         D = 0xfffffffe,\n+12 | |         E,\n+13 | |         F,\n+14 | |     }\n+   | |_____^\n",
        "problem_statement": "Handle discriminant overflow gracefully\nAs implemented in #170, the following will cause a panic in the code generator. The first one should compile. The second one should produce some reasonable intentional error message instead.\r\n\r\n```rust\r\nenum En {\r\n    A = 0xffffffff,\r\n}\r\n```\r\n\r\n```rust\r\nenum En {\r\n    A = 0xfffffffe,\r\n    B,\r\n    C,\r\n}\r\n```\r\n\n",
        "hints_text": "",
        "created_at": "2020-05-01T17:02:59Z",
        "version": "0.3"
    }
]