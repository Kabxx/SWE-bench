[
    {
        "repo": "getgrit/gritql",
        "pull_number": 544,
        "instance_id": "getgrit__gritql-544",
        "issue_numbers": [
            "445"
        ],
        "base_commit": "5e7ca26133fd2d847f73966ca5c45b121b132faf",
        "patch": "diff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -27,6 +27,7 @@ use crate::{\n     yaml::Yaml,\n };\n use anyhow::Result;\n+use clap::builder::PossibleValue;\n use clap::ValueEnum;\n use grit_util::Order;\n use grit_util::{Ast, AstNode, ByteRange, CodeRange, Language, Parser, SnippetTree};\ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -45,16 +46,12 @@ use std::path::PathBuf;\n #[cfg(feature = \"finder\")]\n use std::str::FromStr;\n \n-#[derive(ValueEnum, Debug, Clone, Copy, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]\n-#[clap(rename_all = \"lower\")]\n+#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]\n #[serde(rename_all = \"lowercase\")]\n pub enum PatternLanguage {\n-    #[value(skip)]\n     JavaScript,\n-    #[value(skip)]\n     TypeScript,\n     #[default]\n-    #[value(name = \"js\")]\n     #[serde(rename = \"js\")]\n     Tsx,\n     Html,\ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -63,9 +60,7 @@ pub enum PatternLanguage {\n     Java,\n     CSharp,\n     Python,\n-    #[value(name = \"markdown\")]\n     MarkdownBlock,\n-    #[value(skip)]\n     MarkdownInline,\n     Go,\n     Rust,\ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -78,7 +73,6 @@ pub enum PatternLanguage {\n     Toml,\n     Php,\n     PhpOnly,\n-    #[value(skip)]\n     Universal,\n }\n \ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -118,6 +112,46 @@ impl From<&TargetLanguage> for PatternLanguage {\n     }\n }\n \n+// see: https://github.com/clap-rs/clap/issues/4416\n+impl ValueEnum for PatternLanguage {\n+    // we need to implement the skip variants here ourselves now\n+    fn value_variants<'a>() -> &'a [Self] {\n+        &[\n+            Self::Tsx,\n+            Self::Html,\n+            Self::Css,\n+            Self::Json,\n+            Self::Java,\n+            Self::CSharp,\n+            Self::Python,\n+            Self::MarkdownBlock,\n+            Self::Go,\n+            Self::Rust,\n+            Self::Ruby,\n+            Self::Solidity,\n+            Self::Hcl,\n+            Self::Yaml,\n+            Self::Sql,\n+            Self::Vue,\n+            Self::Toml,\n+            Self::Php,\n+            Self::PhpOnly,\n+        ]\n+    }\n+\n+    // we need to implement the lowercase/rename transformations here ourselves now\n+    // but we use fmt / .to_string() to do so\n+    fn to_possible_value<'a>(&self) -> Option<PossibleValue> {\n+        // needed to convert String to &'static str\n+        let lang_name: &'static str = Box::leak(self.to_string().into_boxed_str());\n+        Some(\n+            PossibleValue::new(lang_name)\n+                .aliases(self.get_file_extensions())\n+                .aliases(self.get_lang_aliases()),\n+        )\n+    }\n+}\n+\n impl PatternLanguage {\n     pub fn from_tree(tree: &Tree) -> Option<Self> {\n         let root = tree.root_node();\ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -174,7 +208,7 @@ impl PatternLanguage {\n     }\n \n     pub fn from_string(name: &str, flavor: Option<&str>) -> Option<Self> {\n-        match name {\n+        let lang = match name {\n             \"js\" => match flavor {\n                 Some(\"jsx\") => Some(Self::Tsx),\n                 Some(\"flow\") => Some(Self::Tsx),\ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -211,6 +245,33 @@ impl PatternLanguage {\n             },\n             \"universal\" => Some(Self::Universal),\n             _ => None,\n+        };\n+        if let Some(lang) = lang {\n+            return Some(lang);\n+        }\n+        if let Some(lang) = Self::from_extension(name) {\n+            return Some(lang);\n+        }\n+        let name = name.to_lowercase();\n+        for lang in PatternLanguage::enumerate() {\n+            for alias in lang.get_lang_aliases() {\n+                if *alias == name {\n+                    return Some(lang);\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    // https://github.com/getgrit/gritql/issues/445\n+    // add any more language aliases here\n+    fn get_lang_aliases(&self) -> &'static [&'static str] {\n+        match self {\n+            PatternLanguage::JavaScript => &[\"javascript\"],\n+            PatternLanguage::TypeScript => &[\"typescript\"],\n+            PatternLanguage::Tsx => &[\"javascript\", \"typescript\", \"flow\"],\n+            PatternLanguage::Sql => &[\"mysql\", \"postgresql\"],\n+            _ => &[],\n         }\n     }\n \n",
        "test_patch": "diff --git a/crates/cli_bin/tests/apply.rs b/crates/cli_bin/tests/apply.rs\n--- a/crates/cli_bin/tests/apply.rs\n+++ b/crates/cli_bin/tests/apply.rs\n@@ -2821,6 +2821,98 @@ def renamed(name):\n     Ok(())\n }\n \n+/// simple stdin example from documentation\n+#[test]\n+fn apply_stdin_simple() -> Result<()> {\n+    let (_temp_dir, fixture_dir) = get_fixture(\"limit_files\", false)?;\n+\n+    let input_file = r#\"console.log(hello)\"#;\n+    let expected_output = r#\"console.log(goodbye)\"#;\n+\n+    let mut cmd = get_test_cmd()?;\n+    cmd.arg(\"apply\")\n+        .arg(\"`hello` => `goodbye`\")\n+        .arg(\"--stdin\")\n+        .arg(\"--lang\")\n+        .arg(\"js\")\n+        .current_dir(&fixture_dir);\n+\n+    cmd.write_stdin(String::from_utf8(input_file.into())?);\n+\n+    let result = cmd.output()?;\n+\n+    let stderr = String::from_utf8(result.stderr)?;\n+    println!(\"stderr: {:?}\", stderr);\n+    let stdout = String::from_utf8(result.stdout)?;\n+    println!(\"stdout: {:?}\", stdout);\n+\n+    assert!(result.status.success(), \"Command should have succeeded\");\n+    assert!(stdout.contains(expected_output));\n+\n+    Ok(())\n+}\n+\n+/// simple stdin example from documentation, but using a language alias\n+#[test]\n+fn apply_stdin_with_lang_alias() -> Result<()> {\n+    let (_temp_dir, fixture_dir) = get_fixture(\"limit_files\", false)?;\n+\n+    let input_file = r#\"console.log(hello)\"#;\n+    let expected_output = r#\"console.log(goodbye)\"#;\n+\n+    let mut cmd = get_test_cmd()?;\n+    cmd.arg(\"apply\")\n+        .arg(\"`hello` => `goodbye`\")\n+        .arg(\"--stdin\")\n+        .arg(\"--lang\")\n+        .arg(\"javascript\")\n+        .current_dir(&fixture_dir);\n+\n+    cmd.write_stdin(String::from_utf8(input_file.into())?);\n+\n+    let result = cmd.output()?;\n+\n+    let stderr = String::from_utf8(result.stderr)?;\n+    println!(\"stderr: {:?}\", stderr);\n+    let stdout = String::from_utf8(result.stdout)?;\n+    println!(\"stdout: {:?}\", stdout);\n+\n+    assert!(result.status.success(), \"Command should have succeeded\");\n+    assert!(stdout.contains(expected_output));\n+\n+    Ok(())\n+}\n+\n+/// simple stdin example from documentation, but using a language alias\n+#[test]\n+fn apply_stdin_with_invalid_lang_alias() -> Result<()> {\n+    let (_temp_dir, fixture_dir) = get_fixture(\"limit_files\", false)?;\n+\n+    let input_file = r#\"console.log(hello)\"#;\n+\n+    let mut cmd = get_test_cmd()?;\n+    cmd.arg(\"apply\")\n+        .arg(\"`hello` => `goodbye`\")\n+        .arg(\"--stdin\")\n+        .arg(\"--lang\")\n+        .arg(\"markdowninline\")\n+        .current_dir(&fixture_dir);\n+\n+    cmd.write_stdin(String::from_utf8(input_file.into())?);\n+\n+    let result = cmd.output()?;\n+\n+    let stderr = String::from_utf8(result.stderr)?;\n+    println!(\"stderr: {:?}\", stderr);\n+    let stdout = String::from_utf8(result.stdout)?;\n+    println!(\"stdout: {:?}\", stdout);\n+\n+    assert!(!result.status.success(), \"Command should have failed\");\n+    assert!(stderr.contains(\"markdowninline\"));\n+\n+    Ok(())\n+}\n+\n /// Ban multiple stdin paths\n #[test]\n fn apply_stdin_two_paths() -> Result<()> {\n",
        "problem_statement": "Aliases for `--lang`\nI'd like to be able to use aliases like `py` for the lang argument:\r\n\r\n```\r\ngrit apply --lang py 'identifier()'\r\nerror: invalid value 'py' for '--language <LANGUAGE>'\r\n  [possible values: js, html, css, json, java, csharp, python, markdown, go, rust, ruby, solidity, hcl, yaml, sql, vue, toml, php, phponly]\r\n\r\n  tip: a similar value exists: 'python'\r\n```\n",
        "hints_text": "/bounty $20\nlooking at this - I don't see '--language' or 'invalid value' in the codebase - looking for the source for the CLI option `grit apply`\r\n\r\nlooks like `cli/src/commands/apply.rs` is the place\r\n\nHere's my first stab at it: https://github.com/getgrit/gritql/pull/478\n@itsdheerajdp Don't submit code you never ran. Until you actually validate that the command shared fixes the issue it isn't worth my time to review.",
        "created_at": "2024-10-20T17:31:09Z",
        "version": "0.4"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 143,
        "instance_id": "getgrit__gritql-143",
        "issue_numbers": [
            "142"
        ],
        "base_commit": "0100191d6c42dfd51ba50a486059f931c96dc0f4",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -1924,6 +1924,7 @@ dependencies = [\n  \"ignore\",\n  \"indicatif\",\n  \"indicatif-log-bridge\",\n+ \"insta\",\n  \"lazy_static\",\n  \"log\",\n  \"marzano-auth\",\ndiff --git a/crates/cli/src/analyze.rs b/crates/cli/src/analyze.rs\n--- a/crates/cli/src/analyze.rs\n+++ b/crates/cli/src/analyze.rs\n@@ -13,13 +13,13 @@ use grit_cache::paths::cache_for_cwd;\n use ignore::Walk;\n use indicatif::{MultiProgress, ProgressBar, ProgressDrawTarget, ProgressStyle};\n \n+#[allow(unused_imports)]\n+use marzano_core::pattern::built_in_functions::BuiltIns;\n use marzano_core::pattern::{\n     api::{AnalysisLog, DoneFile, MatchResult},\n     compiler::CompilationResult,\n     Problem,\n };\n-#[allow(unused_imports)]\n-use marzano_core::pattern::built_in_functions::BuiltIns;\n use marzano_language::target_language::PatternLanguage;\n use marzano_util::cache::GritCache;\n use marzano_util::position::Position;\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -30,9 +30,9 @@ use std::collections::BTreeMap;\n use tokio::fs;\n \n use crate::{\n-    analyze::par_apply_pattern, community::parse_eslint_output, error::GoodError,\n-    flags::OutputFormat, messenger_variant::create_emitter, result_formatting::get_human_error,\n-    updater::Updater,\n+    analyze::par_apply_pattern, community::parse_eslint_output, diff::extract_modified_ranges,\n+    error::GoodError, flags::OutputFormat, messenger_variant::create_emitter,\n+    result_formatting::get_human_error, updater::Updater,\n };\n \n use marzano_messenger::{\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -92,10 +92,18 @@ pub struct ApplyPatternArgs {\n             hide = true,\n         )]\n     pub visibility: VisibilityLevels,\n+    #[clap(\n+        long = \"only-in-diff\",\n+        help = \"Only rewrite ranges that are inside the provided unified diff\",\n+        hide = true,\n+        conflicts_with = \"only_in_json\"\n+    )]\n+    only_in_diff: Option<PathBuf>,\n     #[clap(\n         long = \"only-in-json\",\n         help = \"Only rewrite ranges that are inside the provided eslint-style JSON file\",\n-        hide = true\n+        hide = true,\n+        conflicts_with = \"only_in_diff\"\n     )]\n     only_in_json: Option<PathBuf>,\n     #[clap(\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -109,7 +117,7 @@ pub struct ApplyPatternArgs {\n     /// Clear cache before running apply\n     #[clap(long = \"refresh-cache\", conflicts_with = \"cache\")]\n     pub refresh_cache: bool,\n-    #[clap(long = \"language\", alias=\"lang\")]\n+    #[clap(long = \"language\", alias = \"lang\")]\n     pub language: Option<PatternLanguage>,\n }\n \ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -123,6 +131,7 @@ impl Default for ApplyPatternArgs {\n             format: Default::default(),\n             interactive: Default::default(),\n             visibility: VisibilityLevels::Hidden,\n+            only_in_diff: Default::default(),\n             only_in_json: Default::default(),\n             output_file: Default::default(),\n             cache: Default::default(),\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -188,6 +197,9 @@ pub(crate) async fn run_apply_pattern(\n     let filter_range = if let Some(json_path) = arg.only_in_json.clone() {\n         let json_ranges = flushable_unwrap!(emitter, parse_eslint_output(json_path));\n         Some(json_ranges)\n+    } else if let Some(diff_path) = arg.only_in_diff.clone() {\n+        let diff_ranges = flushable_unwrap!(emitter, extract_modified_ranges(&diff_path));\n+        Some(diff_ranges)\n     } else {\n         None\n     };\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -230,7 +242,6 @@ pub(crate) async fn run_apply_pattern(\n \n         let pattern_libs = flushable_unwrap!(emitter, get_grit_files_from_cwd().await);\n         let (mut lang, pattern_body) = if pattern.ends_with(\".grit\") || pattern.ends_with(\".md\") {\n-    \n             match fs::read_to_string(pattern.clone()).await {\n                 Ok(pb) => {\n                     if pattern.ends_with(\".grit\") {\ndiff --git a/crates/cli/src/commands/check.rs b/crates/cli/src/commands/check.rs\n--- a/crates/cli/src/commands/check.rs\n+++ b/crates/cli/src/commands/check.rs\n@@ -33,6 +33,7 @@ use marzano_messenger::emit::{Messager, VisibilityLevels};\n use cli_server::check::CheckMessenger;\n \n use crate::{\n+    diff::extract_modified_ranges,\n     error::GoodError,\n     flags::{GlobalFormatFlags, OutputFormat},\n     github::{log_check_annotations, write_check_summary},\ndiff --git a/crates/cli/src/commands/check.rs b/crates/cli/src/commands/check.rs\n--- a/crates/cli/src/commands/check.rs\n+++ b/crates/cli/src/commands/check.rs\n@@ -69,6 +70,12 @@ pub struct CheckArg {\n     /// Output annotations for a GitHub actions workflow\n     #[clap(long = \"github-actions\")]\n     pub github_actions: bool,\n+    #[clap(\n+        long = \"only-in-diff\",\n+        help = \"Only check ranges that are inside the provided unified diff\",\n+        hide = true\n+    )]\n+    pub only_in_diff: Option<PathBuf>,\n }\n \n pub(crate) async fn run_check(\ndiff --git a/crates/cli/src/commands/check.rs b/crates/cli/src/commands/check.rs\n--- a/crates/cli/src/commands/check.rs\n+++ b/crates/cli/src/commands/check.rs\n@@ -117,6 +124,13 @@ pub(crate) async fn run_check(\n         std::env::current_dir()?\n     };\n \n+    let filter_range = if let Some(diff_path) = arg.only_in_diff.clone() {\n+        let diff_ranges = extract_modified_ranges(&diff_path)?;\n+        Some(diff_ranges)\n+    } else {\n+        None\n+    };\n+\n     // Construct a resolver\n     let resolver = GritModuleResolver::new(current_dir.to_str().unwrap());\n \ndiff --git a/crates/cli/src/commands/check.rs b/crates/cli/src/commands/check.rs\n--- a/crates/cli/src/commands/check.rs\n+++ b/crates/cli/src/commands/check.rs\n@@ -132,7 +146,7 @@ pub(crate) async fn run_check(\n                 .make_pattern(&body, Some(p.local_name.to_string()))\n                 .unwrap();\n             let lang = PatternLanguage::get_language(&p.body);\n-            match rich_pattern.compile(&grit_files, lang, None) {\n+            match rich_pattern.compile(&grit_files, lang, filter_range.clone()) {\n                 Ok(c) => Ok((p.local_name.clone(), c.problem)),\n                 Err(e) => {\n                     bail!(\"Unable to compile pattern {}:\\n{}\", p.local_name, e);\ndiff --git a/crates/cli/src/commands/mod.rs b/crates/cli/src/commands/mod.rs\n--- a/crates/cli/src/commands/mod.rs\n+++ b/crates/cli/src/commands/mod.rs\n@@ -40,7 +40,7 @@ use crate::{\n     flags::{GlobalFormatFlags, OutputFormat},\n     updater::Updater,\n };\n-use anyhow::{Result};\n+use anyhow::Result;\n use apply::ApplyArgs;\n use auth::{Auth, AuthCommands};\n use check::CheckArg;\ndiff --git a/crates/cli/src/commands/mod.rs b/crates/cli/src/commands/mod.rs\n--- a/crates/cli/src/commands/mod.rs\n+++ b/crates/cli/src/commands/mod.rs\n@@ -52,7 +52,7 @@ use indicatif_log_bridge::LogWrapper;\n use init::InitArgs;\n use install::InstallArgs;\n use list::ListArgs;\n-use log::{LevelFilter};\n+use log::LevelFilter;\n use lsp::LspArgs;\n use marzano_messenger::emit::ApplyDetails;\n use parse::ParseArgs;\ndiff --git a/crates/cli/src/commands/plumbing.rs b/crates/cli/src/commands/plumbing.rs\n--- a/crates/cli/src/commands/plumbing.rs\n+++ b/crates/cli/src/commands/plumbing.rs\n@@ -11,14 +11,13 @@ use std::io::{stdin, Read};\n use std::path::Path;\n use std::path::PathBuf;\n \n-use crate::analytics::{track_event_line};\n+use crate::analytics::track_event_line;\n use crate::flags::GlobalFormatFlags;\n use crate::lister::list_applyables;\n use crate::resolver::{get_grit_files_from, resolve_from, Source};\n use crate::utils::is_pattern_name;\n \n-\n-use super::super::analytics::{AnalyticsArgs};\n+use super::super::analytics::AnalyticsArgs;\n use super::apply_pattern::{run_apply_pattern, ApplyPatternArgs};\n use super::check::{run_check, CheckArg};\n use super::init::{init_config_from_cwd, init_global_grit_modules};\ndiff --git a/crates/cli/src/lib.rs b/crates/cli/src/lib.rs\n--- a/crates/cli/src/lib.rs\n+++ b/crates/cli/src/lib.rs\n@@ -2,6 +2,7 @@ mod analytics;\n mod analyze;\n pub mod commands;\n mod community;\n+mod diff;\n pub mod error;\n mod flags;\n mod github;\ndiff --git a/crates/cli/src/lib.rs b/crates/cli/src/lib.rs\n--- a/crates/cli/src/lib.rs\n+++ b/crates/cli/src/lib.rs\n@@ -17,7 +18,7 @@ mod ux;\n #[cfg(feature = \"workflows_v2\")]\n mod workflows;\n \n-// git2 uses openssl, but breaks windows, so we need \n+// git2 uses openssl, but breaks windows, so we need\n // to import openssl and specify the vendored feature in order\n // to prevet git2 from breaking on windows\n-use openssl as _;\n\\ No newline at end of file\n+use openssl as _;\ndiff --git /dev/null b/crates/cli_bin/fixtures/only_diff/index.js\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/only_diff/index.js\n@@ -0,0 +1,15 @@\n+export const king = '9';\n+\n+module.exports = {\n+  queen: '8',\n+};\n+\n+export async function createTeam() {\n+  console.log('really cool');\n+}\n+\n+export const addTeamToOrgSubscription = () => console.log('cool');\n+\n+module.exports = {};\n+\n+export const queen = '9';\ndiff --git /dev/null b/crates/cli_bin/fixtures/only_diff_check/.grit/grit.yaml\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/only_diff_check/.grit/grit.yaml\n@@ -0,0 +1,6 @@\n+version: 0.0.3\n+patterns:\n+  - name: github.com/getgrit/stdlib#no_console_log\n+    level: error\n+  - name: github.com/getgrit/stdlib#es6_arrow_functions\n+    level: error\ndiff --git /dev/null b/crates/cli_bin/fixtures/only_diff_check/index.js\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/only_diff_check/index.js\n@@ -0,0 +1,19 @@\n+export const king = '9';\n+\n+module.exports = {\n+  queen: '8',\n+};\n+\n+export const wow = () => {\n+  return;\n+}\n+\n+export async function createTeam() {\n+  console.log('very cool');\n+}\n+\n+export const addTeamToOrgSubscription = () => console.log('cool');\n+\n+module.exports = {};\n+\n+export const queen = '9';\ndiff --git a/crates/util/src/position.rs b/crates/util/src/position.rs\n--- a/crates/util/src/position.rs\n+++ b/crates/util/src/position.rs\n@@ -324,7 +324,7 @@ impl From<RangeWithoutByte> for UtilRange {\n     }\n }\n \n-#[derive(Debug, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[serde(rename_all = \"camelCase\")]\n pub struct FileRange {\n     pub file_path: String,\n",
        "test_patch": "diff --git a/crates/cli/Cargo.toml b/crates/cli/Cargo.toml\n--- a/crates/cli/Cargo.toml\n+++ b/crates/cli/Cargo.toml\n@@ -71,6 +71,7 @@ buildkite-test-collector = \"0.1.1\"\n similar = \"2.2.1\"\n reqwest = { version = \"0.11.22\", features = [\"blocking\", \"json\"] }\n marzano-test-utils = { path = \"../test_utils\" }\n+insta = { version = \"1.30.0\", features = [\"yaml\"] }\n \n \n [features]\ndiff --git /dev/null b/crates/cli/src/diff.rs\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli/src/diff.rs\n@@ -0,0 +1,227 @@\n+use anyhow::Result;\n+use marzano_util::position::{FileRange, Position, RangeWithoutByte, UtilRange};\n+use std::{fs::File, io::Read, path::PathBuf, str::FromStr};\n+\n+pub fn extract_modified_ranges(diff_path: &PathBuf) -> Result<Vec<FileRange>> {\n+    let mut file = File::open(diff_path)?;\n+    let mut diff = String::new();\n+\n+    file.read_to_string(&mut diff)?;\n+    parse_modified_ranges(&diff)\n+}\n+\n+fn parse_modified_ranges(diff: &str) -> Result<Vec<FileRange>> {\n+    let mut results = Vec::new();\n+    let lines = diff.lines();\n+\n+    let mut current_file = String::new();\n+    let mut start_pos = Position { line: 0, column: 0 };\n+    let mut end_pos = Position { line: 0, column: 0 };\n+\n+    for line in lines {\n+        if line.starts_with(\"+++\") {\n+            current_file = line.split_whitespace().nth(1).unwrap_or(\"\").to_string();\n+            if current_file.starts_with(\"b/\") {\n+                current_file = current_file[2..].to_string();\n+            }\n+        } else if line.starts_with(\"@@\") {\n+            if current_file == \"/dev/null\" {\n+                continue;\n+            }\n+            let range_part = line.split_whitespace().nth(2).unwrap_or(\"\");\n+            let range_parts: Vec<&str> = range_part.split(',').collect();\n+            if let Ok(line_num) = u32::from_str(range_parts[0].trim_start_matches('+')) {\n+                start_pos.line = line_num;\n+                end_pos.line = line_num\n+                    + range_parts\n+                        .get(1)\n+                        .map_or(0, |&x| x.parse::<u32>().unwrap_or(0))\n+                        .saturating_sub(1);\n+            }\n+\n+            results.push(FileRange {\n+                file_path: current_file.clone(),\n+                range: UtilRange::RangeWithoutByte(RangeWithoutByte {\n+                    start: start_pos,\n+                    end: end_pos,\n+                }),\n+            });\n+        }\n+    }\n+\n+    Ok(results)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use insta::assert_yaml_snapshot;\n+\n+    #[test]\n+    fn parse_one_file_diff() {\n+        let diff = r#\"diff --git a/crates/cli_bin/fixtures/es6/empty_export_object.js b/crates/cli_bin/fixtures/es6/empty_export_object.js\n+index adacd90..71b96e0 100644\n+--- a/crates/cli_bin/fixtures/es6/empty_export_object.js\n++++ b/crates/cli_bin/fixtures/es6/empty_export_object.js\n+@@ -5,7 +5,7 @@ module.exports = {\n+    };\n+    \n+    export async function createTeam() {\n+-  console.log('cool');\n++  console.log('very cool');\n+    }\n+    \n+    export const addTeamToOrgSubscription = () => console.log('cool');\n+\"#;\n+        let parsed = parse_modified_ranges(diff).unwrap();\n+        assert_yaml_snapshot!(parsed);\n+    }\n+\n+    #[test]\n+    fn parse_with_multiple_files() {\n+        let diff = r#\"diff --git a/crates/cli_bin/fixtures/es6/empty_export_object.js b/crates/cli_bin/fixtures/es6/empty_export_object.js\n+index adacd90..71b96e0 100644\n+--- a/crates/cli_bin/fixtures/es6/empty_export_object.js\n++++ b/crates/cli_bin/fixtures/es6/empty_export_object.js\n+@@ -5,7 +5,7 @@ module.exports = {\n+    };\n+    \n+    export async function createTeam() {\n+-  console.log('cool');\n++  console.log('very cool');\n+    }\n+    \n+    export const addTeamToOrgSubscription = () => console.log('cool');\n+diff --git a/crates/cli_bin/fixtures/es6/export_object.js b/crates/cli_bin/fixtures/es6/export_object.js\n+index f6e1a2c..2c58ad2 100644\n+--- a/crates/cli_bin/fixtures/es6/export_object.js\n++++ b/crates/cli_bin/fixtures/es6/export_object.js\n+@@ -2,7 +2,9 @@ async function createTeam() {\n+    console.log('cool');\n+    }\n+    \n+-const addTeamToOrgSubscription = () => console.log('cool');\n++const addTeamToOrgSubscription = () => {\n++  console.log('cool')\n++};\n+    \n+    module.exports = {\n+    createTeam,\n+\"#;\n+        let parsed = parse_modified_ranges(diff).unwrap();\n+        assert_yaml_snapshot!(parsed);\n+    }\n+\n+    #[test]\n+    fn parse_with_created_file() {\n+        let diff = r#\"diff --git a/crates/cli_bin/fixtures/es6/empty_export_object.js b/crates/cli_bin/fixtures/es6/empty_export_object.js\n+index adacd90..71b96e0 100644\n+--- a/crates/cli_bin/fixtures/es6/empty_export_object.js\n++++ b/crates/cli_bin/fixtures/es6/empty_export_object.js\n+@@ -5,7 +5,7 @@ module.exports = {\n+    };\n+    \n+    export async function createTeam() {\n+-  console.log('cool');\n++  console.log('very cool');\n+    }\n+    \n+    export const addTeamToOrgSubscription = () => console.log('cool');\n+diff --git a/crates/cli_bin/fixtures/es6/export_object.js b/crates/cli_bin/fixtures/es6/export_object.js\n+index f6e1a2c..2c58ad2 100644\n+--- a/crates/cli_bin/fixtures/es6/export_object.js\n++++ b/crates/cli_bin/fixtures/es6/export_object.js\n+@@ -2,7 +2,9 @@ async function createTeam() {\n+    console.log('cool');\n+    }\n+    \n+-const addTeamToOrgSubscription = () => console.log('cool');\n++const addTeamToOrgSubscription = () => {\n++  console.log('cool')\n++};\n+    \n+    module.exports = {\n+    createTeam,\n+diff --git a/crates/cli_bin/fixtures/es6/index.js b/crates/cli_bin/fixtures/es6/index.js\n+new file mode 100644\n+index 0000000..7b232cd\n+--- /dev/null\n++++ b/crates/cli_bin/fixtures/es6/index.js\n+@@ -0,0 +1,12 @@\n++async function createTeam() {\n++  console.log(\"cool\");\n++}\n++\n++const addTeamToOrgSubscription = () => {\n++  console.log(\"cool\");\n++};\n++\n++module.exports = {\n++  createTeam,\n++  addTeamToOrgSubscription,\n++};\n+\"#;\n+        let parsed = parse_modified_ranges(diff).unwrap();\n+        assert_yaml_snapshot!(parsed);\n+    }\n+\n+    #[test]\n+    fn parse_with_deleted_file() {\n+        let diff = r#\"diff --git a/crates/cli_bin/fixtures/es6/empty_export_object.js b/crates/cli_bin/fixtures/es6/empty_export_object.js\n+index adacd90..71b96e0 100644\n+--- a/crates/cli_bin/fixtures/es6/empty_export_object.js\n++++ b/crates/cli_bin/fixtures/es6/empty_export_object.js\n+@@ -5,7 +5,7 @@ module.exports = {\n+    };\n+    \n+    export async function createTeam() {\n+-  console.log('cool');\n++  console.log('very cool');\n+    }\n+    \n+    export const addTeamToOrgSubscription = () => console.log('cool');\n+diff --git a/crates/cli_bin/fixtures/es6/export.js b/crates/cli_bin/fixtures/es6/export.js\n+deleted file mode 100644\n+index 52de8a9..0000000\n+--- a/crates/cli_bin/fixtures/es6/export.js\n++++ /dev/null\n+@@ -1,19 +0,0 @@\n+-const king = '9';\n+-\n+-module.exports = {\n+-  king,\n+-  queen: '8',\n+-};\n+-\n+-async function createTeam() {\n+-  console.log('cool');\n+-}\n+-\n+-const addTeamToOrgSubscription = () => console.log('cool');\n+-\n+-module.exports = {\n+-  createTeam,\n+-  addTeamToOrgSubscription,\n+-};\n+-\n+-module.exports.queen = '9';\n+diff --git a/crates/cli_bin/fixtures/es6/export_object.js b/crates/cli_bin/fixtures/es6/export_object.js\n+index f6e1a2c..2c58ad2 100644\n+--- a/crates/cli_bin/fixtures/es6/export_object.js\n++++ b/crates/cli_bin/fixtures/es6/export_object.js\n+@@ -2,7 +2,9 @@ async function createTeam() {\n+    console.log('cool');\n+    }\n+    \n+-const addTeamToOrgSubscription = () => console.log('cool');\n++const addTeamToOrgSubscription = () => {\n++  console.log('cool')\n++};\n+    \n+    module.exports = {\n+    createTeam,\n+\"#;\n+        let parsed = parse_modified_ranges(diff).unwrap();\n+        assert_yaml_snapshot!(parsed);\n+    }\n+}\ndiff --git /dev/null b/crates/cli/src/snapshots/marzano_cli__diff__tests__parse_one_file_diff.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli/src/snapshots/marzano_cli__diff__tests__parse_one_file_diff.snap\n@@ -0,0 +1,13 @@\n+---\n+source: crates/cli/src/diff.rs\n+expression: parsed\n+---\n+- filePath: crates/cli_bin/fixtures/es6/empty_export_object.js\n+  range:\n+    RangeWithoutByte:\n+      start:\n+        line: 5\n+        column: 0\n+      end:\n+        line: 11\n+        column: 0\ndiff --git /dev/null b/crates/cli/src/snapshots/marzano_cli__diff__tests__parse_with_created_file.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli/src/snapshots/marzano_cli__diff__tests__parse_with_created_file.snap\n@@ -0,0 +1,31 @@\n+---\n+source: crates/cli/src/diff.rs\n+expression: parsed\n+---\n+- filePath: crates/cli_bin/fixtures/es6/empty_export_object.js\n+  range:\n+    RangeWithoutByte:\n+      start:\n+        line: 5\n+        column: 0\n+      end:\n+        line: 11\n+        column: 0\n+- filePath: crates/cli_bin/fixtures/es6/export_object.js\n+  range:\n+    RangeWithoutByte:\n+      start:\n+        line: 2\n+        column: 0\n+      end:\n+        line: 10\n+        column: 0\n+- filePath: crates/cli_bin/fixtures/es6/index.js\n+  range:\n+    RangeWithoutByte:\n+      start:\n+        line: 1\n+        column: 0\n+      end:\n+        line: 12\n+        column: 0\ndiff --git /dev/null b/crates/cli/src/snapshots/marzano_cli__diff__tests__parse_with_deleted_file.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli/src/snapshots/marzano_cli__diff__tests__parse_with_deleted_file.snap\n@@ -0,0 +1,22 @@\n+---\n+source: crates/cli/src/diff.rs\n+expression: parsed\n+---\n+- filePath: crates/cli_bin/fixtures/es6/empty_export_object.js\n+  range:\n+    RangeWithoutByte:\n+      start:\n+        line: 5\n+        column: 0\n+      end:\n+        line: 11\n+        column: 0\n+- filePath: crates/cli_bin/fixtures/es6/export_object.js\n+  range:\n+    RangeWithoutByte:\n+      start:\n+        line: 2\n+        column: 0\n+      end:\n+        line: 10\n+        column: 0\ndiff --git /dev/null b/crates/cli/src/snapshots/marzano_cli__diff__tests__parse_with_multiple_files.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli/src/snapshots/marzano_cli__diff__tests__parse_with_multiple_files.snap\n@@ -0,0 +1,22 @@\n+---\n+source: crates/cli/src/diff.rs\n+expression: parsed\n+---\n+- filePath: crates/cli_bin/fixtures/es6/empty_export_object.js\n+  range:\n+    RangeWithoutByte:\n+      start:\n+        line: 5\n+        column: 0\n+      end:\n+        line: 11\n+        column: 0\n+- filePath: crates/cli_bin/fixtures/es6/export_object.js\n+  range:\n+    RangeWithoutByte:\n+      start:\n+        line: 2\n+        column: 0\n+      end:\n+        line: 10\n+        column: 0\ndiff --git a/crates/cli/src/updater.rs b/crates/cli/src/updater.rs\n--- a/crates/cli/src/updater.rs\n+++ b/crates/cli/src/updater.rs\n@@ -785,10 +785,13 @@ mod tests {\n         let cli_release_date = updater._get_app_release_date(SupportedApp::Cli)?;\n         assert_eq!(\n             cli_release_date,\n-            DateTime::<Utc>::from_naive_utc_and_offset(NaiveDate::from_ymd_opt(2023, 7, 12)\n-                .unwrap()\n-                .and_hms_opt(5, 2, 9)\n-                .unwrap(), Utc),\n+            DateTime::<Utc>::from_naive_utc_and_offset(\n+                NaiveDate::from_ymd_opt(2023, 7, 12)\n+                    .unwrap()\n+                    .and_hms_opt(5, 2, 9)\n+                    .unwrap(),\n+                Utc\n+            ),\n         );\n \n         Ok(())\ndiff --git /dev/null b/crates/cli_bin/fixtures/only_diff/test.diff\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/only_diff/test.diff\n@@ -0,0 +1,13 @@\n+diff --git a/index.js b/index.js\n+index adacd90..58e40c0 100644\n+--- a/index.js\n++++ b/index.js\n+@@ -5,7 +5,7 @@ module.exports = {\n+ };\n+ \n+ export async function createTeam() {\n+-  console.log('cool');\n++  console.log('really cool');\n+ }\n+ \n+ export const addTeamToOrgSubscription = () => console.log('cool');\ndiff --git /dev/null b/crates/cli_bin/fixtures/only_diff_check/test.diff\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/only_diff_check/test.diff\n@@ -0,0 +1,18 @@\n+diff --git a/index.js b/index.js\n+index adacd90..58e40c0 100644\n+--- a/index.js\n++++ b/index.js\n+@@ -4,8 +4,12 @@ module.exports = {\n+   queen: '8',\n+ };\n+ \n++export const wow() => {\n++  return;\n++}\n++\n+ export async function createTeam() {\n+-  console.log('really cool');\n++  console.log('very cool');\n+ }\n+ \n+ export const addTeamToOrgSubscription = () => console.log('cool');\ndiff --git a/crates/cli_bin/tests/apply.rs b/crates/cli_bin/tests/apply.rs\n--- a/crates/cli_bin/tests/apply.rs\n+++ b/crates/cli_bin/tests/apply.rs\n@@ -2239,3 +2239,27 @@ fn invalid_language_option_apply() -> Result<()> {\n \n     Ok(())\n }\n+\n+#[test]\n+fn apply_only_in_diff() -> Result<()> {\n+    let (_temp_dir, dir) = get_fixture(\"only_diff\", true)?;\n+\n+    let mut cmd = get_test_cmd()?;\n+\n+    cmd.arg(\"apply\").arg(\"no_console_log\").arg(\"--only-in-diff\").arg(\"test.diff\").current_dir(dir.clone());\n+\n+    let output = cmd.output()?;\n+\n+    assert!(\n+        output.status.success(),\n+        \"Command failed\"\n+    );\n+\n+    assert!(String::from_utf8(output.stdout)?.contains(\"Processed 1 files and found 1 match\"));\n+    \n+    let content = std::fs::read_to_string(dir.join(\"index.js\"))?;\n+    assert!(!content.contains(\"console.log('really cool')\"));\n+    assert!(content.contains(\"console.log('cool')\"));\n+\n+    Ok(())\n+}\ndiff --git a/crates/cli_bin/tests/check.rs b/crates/cli_bin/tests/check.rs\n--- a/crates/cli_bin/tests/check.rs\n+++ b/crates/cli_bin/tests/check.rs\n@@ -183,3 +183,22 @@ fn does_not_attempt_to_check_universal_pattern() -> Result<()> {\n     assert!(output.contains(\"Fix available\"));\n     Ok(())\n }\n+\n+#[test]\n+fn check_only_in_diff() -> Result<()> {\n+    let (_temp_dir, dir) = get_fixture(\"only_diff_check\", true)?;\n+\n+    let mut cmd = get_test_cmd()?;\n+\n+    cmd.arg(\"check\").arg(\"--only-in-diff\").arg(\"test.diff\").current_dir(dir.clone());\n+\n+    let output = cmd.output()?;\n+\n+    let output = String::from_utf8_lossy(&output.stdout).to_string();\n+    let mut lines: Vec<&str> = output.lines().collect();\n+    lines.sort();\n+    let output = lines.join(\"\\n\");\n+    assert_snapshot!(output);\n+\n+    Ok(())\n+}\ndiff --git /dev/null b/crates/cli_bin/tests/snapshots/check__check_only_in_diff.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/tests/snapshots/check__check_only_in_diff.snap\n@@ -0,0 +1,8 @@\n+---\n+source: crates/cli_bin/tests/check.rs\n+expression: output\n+---\n+  12:3    rewrite    Remove `console.log` statements.    Fix available.    no_console_log\n+  7:20    rewrite    Converts function expressions to ES6 arrow functions    Fix available.    es6_arrow_functions\n+./index.js\n+1 files with rewrites. Run grit check --fix to apply changes.\n",
        "problem_statement": "`grit apply` only in diff\nSimilar to the [only_in_json](https://github.com/getgrit/gritql/blob/3581187ffbf6b9d88bd86ee2089a92d148f71e68/crates/cli/src/commands/apply_pattern.rs#L95-L100) flag, we should have a `only-in-diff` flag that can point to a git diff to limit the apply to.\n",
        "hints_text": "",
        "created_at": "2024-04-02T23:00:03Z"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 151,
        "instance_id": "getgrit__gritql-151",
        "issue_numbers": [
            "134"
        ],
        "base_commit": "d0aa4d0c6bd4775c730412e06b5926119571bb8b",
        "patch": "diff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -18,6 +18,7 @@ use marzano_core::pattern::{\n use marzano_gritmodule::fetcher::KeepFetcherKind;\n use marzano_gritmodule::markdown::get_body_from_md_content;\n use marzano_gritmodule::searcher::find_grit_modules_dir;\n+use marzano_gritmodule::utils::is_pattern_name;\n use marzano_language::target_language::{expand_paths, PatternLanguage};\n \n use marzano_util::position::Position;\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -47,7 +48,7 @@ use marzano_messenger::{\n };\n \n use crate::resolver::{get_grit_files_from_cwd, GritModuleResolver};\n-use crate::utils::{has_uncommitted_changes, is_pattern_name};\n+use crate::utils::has_uncommitted_changes;\n \n use super::init::init_config_from_cwd;\n \ndiff --git a/crates/cli/src/commands/plumbing.rs b/crates/cli/src/commands/plumbing.rs\n--- a/crates/cli/src/commands/plumbing.rs\n+++ b/crates/cli/src/commands/plumbing.rs\n@@ -5,6 +5,7 @@ use marzano_gritmodule::config::GritPatternTestInfo;\n use marzano_gritmodule::fetcher::KeepFetcherKind;\n use marzano_gritmodule::patterns_directory::PatternsDirectory;\n use marzano_gritmodule::searcher::find_grit_modules_dir;\n+use marzano_gritmodule::utils::is_pattern_name;\n use marzano_messenger::emit::ApplyDetails;\n use serde::{Deserialize, Serialize};\n use std::io::{stdin, Read};\ndiff --git a/crates/cli/src/commands/plumbing.rs b/crates/cli/src/commands/plumbing.rs\n--- a/crates/cli/src/commands/plumbing.rs\n+++ b/crates/cli/src/commands/plumbing.rs\n@@ -15,7 +16,6 @@ use crate::analytics::track_event_line;\n use crate::flags::GlobalFormatFlags;\n use crate::lister::list_applyables;\n use crate::resolver::{get_grit_files_from, resolve_from, Source};\n-use crate::utils::is_pattern_name;\n \n use super::super::analytics::AnalyticsArgs;\n use super::apply_pattern::{run_apply_pattern, ApplyPatternArgs};\ndiff --git a/crates/cli/src/resolver.rs b/crates/cli/src/resolver.rs\n--- a/crates/cli/src/resolver.rs\n+++ b/crates/cli/src/resolver.rs\n@@ -32,6 +32,7 @@ pub struct GritModuleResolver<'a> {\n     _root_directory: &'a str,\n }\n \n+#[derive(Debug)]\n pub struct RichPattern<'b> {\n     pub body: &'b str,\n     pub name: Option<String>,\ndiff --git a/crates/cli/src/utils.rs b/crates/cli/src/utils.rs\n--- a/crates/cli/src/utils.rs\n+++ b/crates/cli/src/utils.rs\n@@ -1,7 +1,6 @@\n use clap::ValueEnum;\n use git2::{Repository, StatusOptions};\n use marzano_gritmodule::searcher::find_git_dir_from;\n-use regex::Regex;\n use serde::{Deserialize, Serialize};\n use std::{\n     fmt::{Display, Formatter},\ndiff --git a/crates/cli/src/utils.rs b/crates/cli/src/utils.rs\n--- a/crates/cli/src/utils.rs\n+++ b/crates/cli/src/utils.rs\n@@ -73,11 +72,6 @@ pub fn get_random_port() -> Option<u16> {\n     Some(port)\n }\n \n-pub fn is_pattern_name(pattern: &str) -> bool {\n-    let regex = Regex::new(r\"^[a-zA-Z_][a-zA-Z0-9_]*(\\(\\))?$\").unwrap();\n-    regex.is_match(pattern)\n-}\n-\n pub async fn has_uncommitted_changes(dir: PathBuf) -> bool {\n     let git_dir = match find_git_dir_from(dir).await {\n         Some(git_dir) => git_dir,\ndiff --git a/crates/gritmodule/src/config.rs b/crates/gritmodule/src/config.rs\n--- a/crates/gritmodule/src/config.rs\n+++ b/crates/gritmodule/src/config.rs\n@@ -9,8 +9,8 @@ use std::{\n };\n use tree_sitter::Parser;\n \n-use crate::{fetcher::ModuleRepo, parser::PatternFileExt};\n-use anyhow::Result;\n+use crate::{fetcher::ModuleRepo, parser::PatternFileExt, utils::is_pattern_name};\n+use anyhow::{bail, Result};\n \n #[derive(Debug, Deserialize)]\n pub struct GritGitHubConfig {\ndiff --git a/crates/gritmodule/src/config.rs b/crates/gritmodule/src/config.rs\n--- a/crates/gritmodule/src/config.rs\n+++ b/crates/gritmodule/src/config.rs\n@@ -273,6 +273,10 @@ pub fn pattern_config_to_model(\n     let defined_local_name = split_name.next();\n     let local_name = defined_local_name.unwrap_or(&pattern.name).to_string();\n \n+    if !is_pattern_name(&local_name) && local_name != NAMESPACE_IMPORT_INDICATOR {\n+        bail!(\"Invalid pattern name: {}. Grit patterns must match the regex /[\\\\^#A-Za-z_][A-Za-z0-9_]*/. For more info, consult the docs at https://docs.grit.io/guides/patterns#pattern-definitions.\", local_name);\n+    }\n+\n     let module: Option<ModuleRepo> = match repo {\n         None => None,\n         Some(_) => {\ndiff --git a/crates/gritmodule/src/utils.rs b/crates/gritmodule/src/utils.rs\n--- a/crates/gritmodule/src/utils.rs\n+++ b/crates/gritmodule/src/utils.rs\n@@ -2,6 +2,7 @@ use std::{env::current_exe, fs::canonicalize, path::Path};\n \n use anyhow::{bail, Result};\n use marzano_core::pattern::api::MatchResult;\n+use regex::Regex;\n \n /// Extracts the *rewritten* (after applying a pattern) path from a `MatchResult`.\n pub fn extract_path(result: &MatchResult) -> Option<&String> {\ndiff --git a/crates/gritmodule/src/utils.rs b/crates/gritmodule/src/utils.rs\n--- a/crates/gritmodule/src/utils.rs\n+++ b/crates/gritmodule/src/utils.rs\n@@ -25,3 +26,8 @@ pub fn remove_dir_all_safe(dir: &Path) -> Result<()> {\n     std::fs::remove_dir_all(dir)?;\n     Ok(())\n }\n+\n+pub fn is_pattern_name(pattern: &str) -> bool {\n+    let regex = Regex::new(r\"^[a-zA-Z_][a-zA-Z0-9_]*(\\(\\))?$\").unwrap();\n+    regex.is_match(pattern)\n+}\n",
        "test_patch": "diff --git /dev/null b/crates/cli_bin/fixtures/config_invalid_name/.grit/grit.yaml\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/config_invalid_name/.grit/grit.yaml\n@@ -0,0 +1,9 @@\n+version: 0.0.1\n+patterns:\n+  - name: test-bad\n+    tags:\n+      - style\n+      - debugging\n+    level: error\n+    body: |\n+      `$a = $b` => `console.log($b)`\ndiff --git /dev/null b/crates/cli_bin/fixtures/config_invalid_name/test.js\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/config_invalid_name/test.js\n@@ -0,0 +1,3 @@\n+class Button extends Component {\n+  a = 1;\n+}\ndiff --git a/crates/cli_bin/tests/apply.rs b/crates/cli_bin/tests/apply.rs\n--- a/crates/cli_bin/tests/apply.rs\n+++ b/crates/cli_bin/tests/apply.rs\n@@ -2263,3 +2263,23 @@ fn apply_only_in_diff() -> Result<()> {\n \n     Ok(())\n }\n+\n+#[test]\n+fn config_pattern_with_invalid_name() -> Result<()> {\n+    let (_temp_dir, dir) = get_fixture(\"config_invalid_name\", true)?;\n+\n+    let mut cmd = get_test_cmd()?;\n+\n+    cmd.arg(\"apply\").arg(\"test-bad\").current_dir(dir.clone());\n+\n+    let output = cmd.output()?;\n+\n+    assert!(\n+        !output.status.success(),\n+        \"Command should have failed\"\n+    );\n+\n+    assert_snapshot!(String::from_utf8(output.stderr)?);\n+\n+    Ok(())\n+}\ndiff --git /dev/null b/crates/cli_bin/tests/snapshots/apply__config_pattern_with_invalid_name.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/tests/snapshots/apply__config_pattern_with_invalid_name.snap\n@@ -0,0 +1,5 @@\n+---\n+source: crates/cli_bin/tests/apply.rs\n+expression: \"String::from_utf8(output.stderr)?\"\n+---\n+Error: Invalid pattern name: test-bad. Grit patterns must match the regex /[\\^#A-Za-z_][A-Za-z0-9_]*/. For more info, consult the docs at https://docs.grit.io/guides/patterns#pattern-definitions.\n",
        "problem_statement": "Error message when pattern name contains invalid characters is confusing\nThe error message that comes out when a pattern name contains a `-` is confusing and not helpful\r\n\r\nReproducer:\r\n`grit.yaml`\r\n```yaml\r\npatterns:\r\n  - name: use-winston\r\n    level: error\r\n    body: |\r\n      `console.log($msg)` => `winston.log($msg)` where {\r\n        $msg <: not within or { `it($_, $_)`, `test($_, $_)`, `describe($_, $_)` }\r\n      }\r\n```\r\n\r\nRun:\r\n```\r\n$ grit apply use-winston\r\nYour working tree currently has untracked changes and Grit will rewrite files in place. Do you want to proceed? yes\r\nERROR (code: 299) - Pattern syntax error at 1:1. If you hit this error while running grit apply on a pattern from the Grit standard library, try running grit init. If you are running a custom pattern, check out the docs at https://docs.grit.io/ for help with writing patterns.\r\n```\n",
        "hints_text": "Yes, we can definitely improve this. Something like this would be much better:\r\n\r\n > Pattern `use-winston` at 2:1 contains invalid character \"-\".",
        "created_at": "2024-04-04T05:08:54Z"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 562,
        "instance_id": "getgrit__gritql-562",
        "issue_numbers": [
            "485"
        ],
        "base_commit": "a1b312bdefed4982f7a96304b88577762f7edcf1",
        "patch": "diff --git a/crates/cli/src/analyze.rs b/crates/cli/src/analyze.rs\n--- a/crates/cli/src/analyze.rs\n+++ b/crates/cli/src/analyze.rs\n@@ -18,7 +18,7 @@ use indicatif::{MultiProgress, ProgressBar, ProgressDrawTarget, ProgressStyle};\n use marzano_core::built_in_functions::BuiltIns;\n use marzano_core::pattern_compiler::{src_to_problem_libs, CompilationResult};\n use marzano_core::{\n-    api::{AnalysisLog, DoneFile, MatchResult},\n+    api::{AnalysisLog, MatchResult},\n     problem::Problem,\n };\n use marzano_language::target_language::PatternLanguage;\ndiff --git a/crates/cli/src/analyze.rs b/crates/cli/src/analyze.rs\n--- a/crates/cli/src/analyze.rs\n+++ b/crates/cli/src/analyze.rs\n@@ -205,49 +205,19 @@ where\n                 if file.file_type().unwrap().is_dir() {\n                     continue;\n                 }\n-                if !&compiled.language.match_extension(\n-                    file.path()\n+                if !my_input.paths.contains(&file.path().to_path_buf()) {\n+                    let ext = file\n+                        .path()\n                         .extension()\n                         .unwrap_or_default()\n                         .to_str()\n-                        .unwrap_or_default(),\n-                ) {\n-                    processed.fetch_add(1, Ordering::SeqCst);\n-                    let path_string = file.path().to_string_lossy().to_string();\n-                    if my_input.paths.contains(&file.path().to_path_buf()) {\n-                        let log = MatchResult::AnalysisLog(AnalysisLog {\n-                            level: 410,\n-                            message: format!(\n-                                \"Skipped {} since it is not a {} file\",\n-                                path_string,\n-                                &compiled.language.to_string()\n-                            ),\n-                            position: Position::first(),\n-                            file: path_string.to_string(),\n-                            engine_id: \"marzano\".to_string(),\n-                            range: None,\n-                            syntax_tree: None,\n-                            source: None,\n-                        });\n-                        let done_file = MatchResult::DoneFile(DoneFile {\n-                            relative_file_path: path_string,\n-                            has_results: Some(false),\n-                            file_hash: None,\n-                            from_cache: false,\n-                        });\n-                        emitter.handle_results(\n-                            vec![log, done_file],\n-                            details,\n-                            arg.dry_run,\n-                            arg.format,\n-                            &mut interactive,\n-                            None,\n-                            Some(processed),\n-                            None,\n-                            &compiled.language,\n-                        );\n+                        .unwrap_or_default();\n+                    if !&compiled.language.match_extension(ext) {\n+                        // only skip the file if it was discovered by the walker\n+                        // don't skip if it was explicitly passed in as a path\n+                        // https://github.com/getgrit/gritql/issues/485\n+                        continue;\n                     }\n-                    continue;\n                 }\n                 file_paths_tx.send(file.path().to_path_buf()).unwrap();\n             }\ndiff --git /dev/null b/crates/cli_bin/fixtures/invalid_extensions/some_folder/file1.py\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/invalid_extensions/some_folder/file1.py\n@@ -0,0 +1,1 @@\n+class MyClass(object): ...\ndiff --git /dev/null b/crates/cli_bin/fixtures/invalid_extensions/some_folder/file2.pyi\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/invalid_extensions/some_folder/file2.pyi\n@@ -0,0 +1,1 @@\n+class MyClass(object): ...\ndiff --git /dev/null b/crates/cli_bin/fixtures/invalid_extensions/some_folder/file3.nopy\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/invalid_extensions/some_folder/file3.nopy\n@@ -0,0 +1,1 @@\n+class MyClass(object): ...\ndiff --git /dev/null b/crates/cli_bin/fixtures/invalid_extensions/some_folder/file4.js.py\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/invalid_extensions/some_folder/file4.js.py\n@@ -0,0 +1,3 @@\n+const mine = (object) => {\n+    return String(object) + 'is mine';\n+};\ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -287,7 +287,7 @@ impl PatternLanguage {\n             PatternLanguage::Json => &[\"json\"],\n             PatternLanguage::Java => &[\"java\"],\n             PatternLanguage::CSharp => &[\"cs\"],\n-            PatternLanguage::Python => &[\"py\", \"ipynb\"],\n+            PatternLanguage::Python => &[\"py\", \"pyi\", \"ipynb\"],\n             PatternLanguage::MarkdownBlock => &[\"md\", \"mdx\", \"mdoc\"],\n             PatternLanguage::MarkdownInline => &[\"md\", \"mdx\", \"mdoc\"],\n             PatternLanguage::Go => &[\"go\"],\ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -343,7 +343,7 @@ impl PatternLanguage {\n             \"java\" => Some(Self::Java),\n             \"cs\" => Some(Self::CSharp),\n             \"ipynb\" => Some(Self::Python),\n-            \"py\" => Some(Self::Python),\n+            \"py\" | \"pyi\" => Some(Self::Python),\n             \"md\" | \"mdx\" | \"mdoc\" => Some(Self::MarkdownBlock),\n             \"go\" => Some(Self::Go),\n             \"rs\" => Some(Self::Rust),\n",
        "test_patch": "diff --git a/crates/cli_bin/tests/apply.rs b/crates/cli_bin/tests/apply.rs\n--- a/crates/cli_bin/tests/apply.rs\n+++ b/crates/cli_bin/tests/apply.rs\n@@ -2913,6 +2913,144 @@ fn apply_stdin_with_invalid_lang_alias() -> Result<()> {\n     Ok(())\n }\n \n+/// test that we can apply to a folder which contains valid and invalid python extensions\n+/// see https://github.com/getgrit/gritql/issues/485\n+#[test]\n+fn apply_to_folder_with_invalid_python_extension() -> Result<()> {\n+    let (_temp_dir, fixture_dir) = get_fixture(\"invalid_extensions\", false)?;\n+\n+    let mut cmd = get_test_cmd()?;\n+    cmd.arg(\"apply\")\n+        .arg(\"`object` => ``\")\n+        .arg(\"some_folder\")\n+        .arg(\"--lang=py\")\n+        .arg(\"--force\")\n+        .current_dir(&fixture_dir);\n+\n+    let result = cmd.output()?;\n+\n+    let stderr = String::from_utf8(result.stderr)?;\n+    println!(\"stderr: {:?}\", stderr);\n+    let stdout = String::from_utf8(result.stdout)?;\n+    println!(\"stdout: {:?}\", stdout);\n+\n+    assert!(result.status.success(), \"Command failed\");\n+    // Read back the file3.nopy file to ensure it was processed\n+    let target_file = fixture_dir.join(\"some_folder/file3.nopy\");\n+    let content: String = fs_err::read_to_string(target_file)?;\n+    assert_snapshot!(content);\n+\n+    // ensure we don't get the old error message:\n+    assert!(!stdout.contains(\"file3.nopy: ERROR (code: 410)\"));\n+    assert!(stdout.contains(\"some_folder/file4.js.py: ERROR (code: 300) - Error parsing source code at 1:7 in some_folder/file4.js.py. This may cause otherwise applicable queries to not match\"));\n+    assert!(stdout.contains(\"Processed 3 files and found 4 matches\"));\n+\n+    Ok(())\n+}\n+\n+/// test that we can apply to a path with an invalid python extension\n+/// see https://github.com/getgrit/gritql/issues/485\n+#[test]\n+fn apply_to_path_with_invalid_python_extension() -> Result<()> {\n+    let (_temp_dir, fixture_dir) = get_fixture(\"invalid_extensions\", false)?;\n+\n+    let mut cmd = get_test_cmd()?;\n+    cmd.arg(\"apply\")\n+        .arg(\"`object` => ``\")\n+        .arg(\"some_folder/file1.py\")\n+        .arg(\"some_folder/file2.pyi\")\n+        .arg(\"some_folder/file3.nopy\")\n+        .arg(\"--lang=py\")\n+        .arg(\"--force\")\n+        .current_dir(&fixture_dir);\n+\n+    let result = cmd.output()?;\n+\n+    let stderr = String::from_utf8(result.stderr)?;\n+    println!(\"stderr: {:?}\", stderr);\n+    let stdout = String::from_utf8(result.stdout)?;\n+    println!(\"stdout: {:?}\", stdout);\n+\n+    assert!(result.status.success(), \"Command failed\");\n+    // Read back the file3.nopy file to ensure it was processed\n+    let target_file = fixture_dir.join(\"some_folder/file3.nopy\");\n+    let content: String = fs_err::read_to_string(target_file)?;\n+    assert_snapshot!(content);\n+\n+    // ensure we don't get the old error message:\n+    assert!(!stdout.contains(\"file3.nopy: ERROR (code: 410)\"));\n+    assert!(stdout.contains(\"Processed 3 files and found 3 matches\"));\n+\n+    Ok(())\n+}\n+\n+/// test that we can apply to a path with an invalid javascript extension\n+/// see https://github.com/getgrit/gritql/issues/485\n+#[test]\n+fn apply_to_path_with_invalid_javascript_extension() -> Result<()> {\n+    let (_temp_dir, fixture_dir) = get_fixture(\"invalid_extensions\", false)?;\n+\n+    let mut cmd = get_test_cmd()?;\n+    cmd.arg(\"apply\")\n+        .arg(\"`object` => ``\")\n+        .arg(\"some_folder/file4.js.py\")\n+        .arg(\"--lang=js\")\n+        .arg(\"--force\")\n+        .current_dir(&fixture_dir);\n+\n+    let result = cmd.output()?;\n+\n+    let stderr = String::from_utf8(result.stderr)?;\n+    println!(\"stderr: {:?}\", stderr);\n+    let stdout = String::from_utf8(result.stdout)?;\n+    println!(\"stdout: {:?}\", stdout);\n+\n+    assert!(result.status.success(), \"Command failed\");\n+    // Read back the file4.js.py file to ensure it was processed\n+    let target_file = fixture_dir.join(\"some_folder/file4.js.py\");\n+    let content: String = fs_err::read_to_string(target_file)?;\n+    assert_snapshot!(content);\n+\n+    assert!(stdout.contains(\"Processed 1 files and found 2 matches\"));\n+\n+    Ok(())\n+}\n+\n+/// test that we show an 'Error parsing source code' when we try to apply\n+/// to a path which contains the wrong language as specified in the lang flag\n+/// see https://github.com/getgrit/gritql/issues/485\n+#[test]\n+fn apply_to_path_with_invalid_lang() -> Result<()> {\n+    let (_temp_dir, fixture_dir) = get_fixture(\"invalid_extensions\", false)?;\n+\n+    let mut cmd = get_test_cmd()?;\n+    cmd.arg(\"apply\")\n+        .arg(\"`object` => ``\")\n+        .arg(\"some_folder/file4.js.py\")\n+        .arg(\"--lang=py\")\n+        .arg(\"--force\")\n+        .current_dir(&fixture_dir);\n+\n+    let result = cmd.output()?;\n+\n+    let stderr = String::from_utf8(result.stderr)?;\n+    println!(\"stderr: {:?}\", stderr);\n+    let stdout = String::from_utf8(result.stdout)?;\n+    println!(\"stdout: {:?}\", stdout);\n+\n+    assert!(result.status.success(), \"Command failed\");\n+    // Read back the file4.js.py file to ensure it was processed\n+    let target_file = fixture_dir.join(\"some_folder/file4.js.py\");\n+    let content: String = fs_err::read_to_string(target_file)?;\n+    assert_snapshot!(content);\n+\n+    // we should get an error message about the wrong language / Error parsing source code\n+    assert!(stdout.contains(\"some_folder/file4.js.py: ERROR (code: 300) - Error parsing source code at 1:7 in some_folder/file4.js.py. This may cause otherwise applicable queries to not match.\"));\n+    assert!(stdout.contains(\"Processed 1 files and found 2 matches\"));\n+\n+    Ok(())\n+}\n+\n /// Ban multiple stdin paths\n #[test]\n fn apply_stdin_two_paths() -> Result<()> {\ndiff --git /dev/null b/crates/cli_bin/tests/snapshots/apply__apply_to_folder_with_invalid_python_extension.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/tests/snapshots/apply__apply_to_folder_with_invalid_python_extension.snap\n@@ -0,0 +1,5 @@\n+---\n+source: crates/cli_bin/tests/apply.rs\n+expression: content\n+---\n+class MyClass(object): ...\ndiff --git /dev/null b/crates/cli_bin/tests/snapshots/apply__apply_to_path_with_invalid_javascript_extension.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/tests/snapshots/apply__apply_to_path_with_invalid_javascript_extension.snap\n@@ -0,0 +1,7 @@\n+---\n+source: crates/cli_bin/tests/apply.rs\n+expression: content\n+---\n+const mine = () => {\n+    return String() + 'is mine';\n+};\ndiff --git /dev/null b/crates/cli_bin/tests/snapshots/apply__apply_to_path_with_invalid_lang.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/tests/snapshots/apply__apply_to_path_with_invalid_lang.snap\n@@ -0,0 +1,7 @@\n+---\n+source: crates/cli_bin/tests/apply.rs\n+expression: content\n+---\n+const mine = () => {\n+    return String() + 'is mine';\n+};\ndiff --git /dev/null b/crates/cli_bin/tests/snapshots/apply__apply_to_path_with_invalid_python_extension.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/tests/snapshots/apply__apply_to_path_with_invalid_python_extension.snap\n@@ -0,0 +1,5 @@\n+---\n+source: crates/cli_bin/tests/apply.rs\n+expression: content\n+---\n+class MyClass(): ...\n",
        "problem_statement": "Allow for non-standard suffixes/filenames for languages\nI have files that should be treated as python, but do not end in `.py`. I can't convince `grit` to respect the files and treat them as python with any option or config value that I've found. Instead, grit fails with:\r\n\r\n```\r\nERROR (code: 410) - Skipped <mypath here> since it is not a python file\r\n```\r\n\r\nMy workaround is hardlinking <mypath> to <mypath>.py, but it would be ideal to force grit to ignore the suffix, or to register alternative patterns as a file type using `grit.yaml`.\n",
        "hints_text": "I think there's two immediate things we could do:\r\n\r\n- Adjust [this logic](https://github.com/getgrit/gritql/blob/44e1536af813f62c5c48dedc781aed56e3089cc9/crates/cli/src/analyze.rs#L208-L218) so that if the path of the file is directly specified (vs. being discovered via traversal) we always attempt to parse it.\r\n- Add an `--extensions` flag to override which extensions are parsed at runtime.\r\n\r\nHappy to review a PR.\nI think option #1 is best.\n/bounty $10",
        "created_at": "2024-10-24T22:56:17Z",
        "version": "0.4"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 125,
        "instance_id": "getgrit__gritql-125",
        "issue_numbers": [
            "44"
        ],
        "base_commit": "43b48f883b70e57505a46b73b71b8696d9afcac2",
        "patch": "diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -69,12 +100,3 @@ These steps are done in our cloud environment and are not necessary for contribu\n - There are also `exhaustive` runtime checks that error if a switch case doesn\u2019t handle a language, like `makeSingleLineComment`. Search for `exhaustive(lang` and fill those out too.\n - Regenerate both DB/prisma types to add it to the DB schema and GraphQL types.\n - Add the language to `language-selector.tsx`. Pick an icon from [https://react-icons.github.io](https://react-icons.github.io/), usually from the Simple Icons category.\n-\n-## Development Tools\n-\n-Make sure you have the following tools installed to guarantee everything works:\n-\n-- Rust Toolchain\n-  - In order to create WASM builds, you should run `rustup target install wasm32-unknown-unknown`\n-- `terraform` CLI. See https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli\n-- `npx`. Install with Node.js: https://docs.npmjs.com/downloading-and-installing-node-js-and-npm\n",
        "test_patch": "diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md\n--- a/CONTRIBUTING.md\n+++ b/CONTRIBUTING.md\n@@ -9,6 +9,37 @@ We welcome contributions in the form of pull requests and issues.\n \n Note that this codebase isn't yet extensively documented. If you get stuck, please ask for help [on Discord](https://docs.grit.io/discord).\n \n+## Development Setup\n+\n+A high-level overview of tools you need to have installed:\n+\n+* Rust toolchain: for compiling the codebase. You'll need [`rustc`](https://rustup.rs/) v1.74 or newer.\n+  * To create WASM builds, run `rustup target install wasm32-unknown-unknown`.\n+* C/C++ compiler. macOS: [Xcode Command Line Tools](https://download.developer.apple.com/Developer_Tools/Command_Line_Tools_for_Xcode_15.3/Command_Line_Tools_for_Xcode_15.3.dmg) via `xcode-select --install`, Linux: [gcc](https://learnubuntu.com/install-gcc/), Windows: [Microsoft Visual C++](https://visualstudio.microsoft.com/vs/features/cplusplus/).\n+* Emscripten: a C/C++ compiler toolchain for WASM. Install v3.1.56 with [`emsdk`](https://emscripten.org/docs/getting_started/downloads.html).\n+* Node.js runtime: `node`, `npm`, `npx` are used to generate parsers from `grammar.js` files. You'll need [`node`](https://nodejs.org/en/download) v18.5.0 or newer.\n+* Yarn package manager. You'll need [`yarn`](https://classic.yarnpkg.com/en/docs/install) (classic). Install v1.22.19 with `npm install --global yarn`.\n+* Tree-Sitter CLI: provides [`tree-sitter`](https://github.com/tree-sitter/tree-sitter/tree/master/cli) binary for testing grammars. Install v0.22.2 with `npm install --global tree-sitter-cli`.\n+* Terraform CLI. Install [`terraform`](https://developer.hashicorp.com/terraform/tutorials/aws-get-started/install-cli) with `brew tap hashicorp/tap && brew install hashicorp/tap/terraform`. \n+\n+## Building the Code\n+\n+Use `git` to clone this repository into a location of your choice. \n+```bash\n+git clone https://github.com/getgrit/gritql.git\n+```\n+\n+Change into the cloned repository and make sure all submodules are correctly set up, including any nested submodules:\n+```bash\n+cd gritql\n+git submodule update --init --recursive\n+```\n+\n+Before making any changes to the code, make sure you can run the tests and everything is initially passing:\n+```bash\n+cargo test --workspace\n+```\n+\n ## Feature Flags\n \n We use [feature flags](https://doc.rust-lang.org/cargo/reference/features.html) to control which parts of the codebase are compiled.\n",
        "problem_statement": "Improve contribution guide\nThe contributing guide covers from Grit-specific things, but doesn't provide a brief introduction to building the repo and making contributions.\r\n\r\nWe should provide a step by step guide for new contributors.\n",
        "hints_text": "",
        "created_at": "2024-04-01T10:05:53Z"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 566,
        "instance_id": "getgrit__gritql-566",
        "issue_numbers": [
            "416"
        ],
        "base_commit": "67e36d7e3d7e0200499a734263e7fb7cf66f5d1f",
        "patch": "diff --git a/crates/language/src/python.rs b/crates/language/src/python.rs\n--- a/crates/language/src/python.rs\n+++ b/crates/language/src/python.rs\n@@ -79,11 +79,22 @@ impl Language for Python {\n \n     fn check_replacements(&self, n: NodeWithSource<'_>, replacements: &mut Vec<Replacement>) {\n         if n.node.is_error() {\n-            if n.text().is_ok_and(|t| t == \"->\") {\n+            // https://github.com/getgrit/gritql/issues/416 single line example\n+            if n.text().is_ok_and(|t| t == \"->\") || n.text().is_ok_and(|t| t == \",\") {\n                 replacements.push(Replacement::new(n.range(), \"\"));\n             }\n             return;\n         }\n+        if n.node.kind() == \",\" {\n+            // https://github.com/getgrit/gritql/issues/416 multi line example\n+            if let Some(prev) = n.node.prev_sibling() {\n+                let empty = prev.range().end_byte() == prev.range().start_byte();\n+                if empty {\n+                    replacements.push(Replacement::new(n.range(), \"\"));\n+                    return;\n+                }\n+            }\n+        }\n         if n.node.kind() == \"import_from_statement\" {\n             if let Some(name_field) = n.node.child_by_field_name(\"name\") {\n                 let names_text = name_field\n",
        "test_patch": "diff --git a/crates/core/src/test.rs b/crates/core/src/test.rs\n--- a/crates/core/src/test.rs\n+++ b/crates/core/src/test.rs\n@@ -12272,6 +12272,66 @@ fn trailing_comma_import_from_python_with_alias() {\n     .unwrap();\n }\n \n+// refer to https://github.com/getgrit/gritql/issues/416\n+#[test]\n+fn trailing_comma_after_argument_removal() {\n+    run_test_expected({\n+        TestArgExpected {\n+            pattern: r#\"\n+                language python\n+                `TaskMetadata($args)` where {\n+                        $args <: contains `n_samples=$_` => .\n+                    }\n+                \"#.to_owned(),\n+            source: r#\"\n+                TaskMetadata(\n+                    description=\"Parallel news titles from the Tbilisi City Hall website (https://tbilisi.gov.ge/).\",\n+                    main_score=\"f1\", domains=[\"News\"],\n+                    text_creation=\"created\",\n+                    n_samples={_EVAL_SPLIT: 1820},\n+                    reference=\"https://huggingface.co/datasets/jupyterjazz/tbilisi-city-hall-titles\"\n+                )\n+            \"#\n+                .to_owned(),\n+            expected: r#\"\n+                TaskMetadata(\n+                    description=\"Parallel news titles from the Tbilisi City Hall website (https://tbilisi.gov.ge/).\",\n+                    main_score=\"f1\", domains=[\"News\"],\n+                    text_creation=\"created\",\n+\n+                    reference=\"https://huggingface.co/datasets/jupyterjazz/tbilisi-city-hall-titles\"\n+                )\n+            \"#\n+                .to_owned(),\n+        }\n+    })\n+    .unwrap();\n+}\n+\n+/// Same as above test, but ensures the behavior doesn't depend on line breaks\n+#[test]\n+fn trailing_comma_after_argument_removal_one_line() {\n+    run_test_expected({\n+        TestArgExpected {\n+            pattern: r#\"\n+                language python\n+                `TaskMetadata($args)` where {\n+                        $args <: contains `n_samples=$_` => .\n+                    }\n+                \"#.to_owned(),\n+            source: r#\"\n+                TaskMetadata(description=\"Parallel news titles from the Tbilisi City Hall website (https://tbilisi.gov.ge/).\", main_score=\"f1\", domains=[\"News\"], text_creation=\"created\", n_samples={_EVAL_SPLIT: 1820}, reference=\"https://huggingface.co/datasets/jupyterjazz/tbilisi-city-hall-titles\")\n+            \"#\n+                .to_owned(),\n+            expected: r#\"\n+                TaskMetadata(description=\"Parallel news titles from the Tbilisi City Hall website (https://tbilisi.gov.ge/).\", main_score=\"f1\", domains=[\"News\"], text_creation=\"created\",  reference=\"https://huggingface.co/datasets/jupyterjazz/tbilisi-city-hall-titles\")\n+            \"#\n+                .to_owned(),\n+        }\n+    })\n+    .unwrap();\n+}\n+\n #[test]\n fn python_orphaned_from_imports() {\n     run_test_expected({\n",
        "problem_statement": "Hanging commas after removing kwargs in Python\nContinuing from Discord [message](https://discord.com/channels/1140989670751219762/1140989757392953424/1261006232618143877).\r\n\r\n```grit\r\n`TaskMetadata($args)` where {\r\n    $args <: any {\r\n        contains `n_samples=$_` as $ns_kwarg where {\r\n            $ns_kwarg <: `n_samples = $ns_val` => .\r\n        },\r\n        contains keyword_argument(name=\"avg_character_length\") as $avg_kwarg where {\r\n            $avg_kwarg <: `avg_character_length = $avg_val` => `stats=GeneralDescriptiveStats(n_samples=$ns_val, avg_character_length=$avg_val)`\r\n        },\r\n    },\r\n}\r\n```\r\n\r\n```python\r\nfrom pydantic import BaseModel\r\n\r\n\r\nclass TaskMetadata(BaseModel):\r\n    n_samples: dict[str, int]\r\n    avg_character_length: dict[str, float]\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    TaskMetadata(\r\n        name=\"TbilisiCityHallBitextMining\",\r\n        dataset={\r\n            \"path\": \"jupyterjazz/tbilisi-city-hall-titles\",\r\n            \"revision\": \"798bb599140565cca2dab8473035fa167e5ee602\",\r\n        },\r\n        description=\"Parallel news titles from the Tbilisi City Hall website (https://tbilisi.gov.ge/).\",\r\n        type=\"BitextMining\",\r\n        category=\"s2s\",\r\n        eval_splits=[_EVAL_SPLIT],\r\n        eval_langs=_EVAL_LANGS,\r\n        main_score=\"f1\",\r\n        domains=[\"News\"],\r\n        text_creation=\"created\",\r\n        n_samples={_EVAL_SPLIT: 1820},\r\n        reference=\"https://huggingface.co/datasets/jupyterjazz/tbilisi-city-hall-titles\",\r\n        date=(\"2024-05-02\", \"2024-05-03\"),\r\n        form=[\"written\"],\r\n        task_subtypes=[],\r\n        license=\"Not specified\",\r\n        socioeconomic_status=\"mixed\",\r\n        annotations_creators=\"derived\",\r\n        dialect=[],\r\n        bibtex_citation=\"\",\r\n        avg_character_length={_EVAL_SPLIT: 78},\r\n    )\r\n```\r\n\r\nMorgante suggested it might be a bug somewhere around [here](https://github.com/getgrit/gritql/blob/9587e9e5558c583d69514c1f581f8244ac551616/crates/core/src/inline_snippets.rs#L298).\r\n\r\nResults in a dangling comma:\r\n![image copy](https://github.com/getgrit/gritql/assets/8526086/c7cd828f-90e4-4750-bdaa-94884605374b)\r\n\n",
        "hints_text": "Thanks a ton for the work you do! The DSL is super interesting, albeit/because it is a challenge to wrap my head around. Love it being open source!\n> Thanks a ton for the work you do! The DSL is super interesting, albeit/because it is a challenge to wrap my head around. Love it being open source!\r\n\r\nThank you! Please also do provide feedback on areas we could improve the documentation for.\r\n\r\nFor this issue, the fix will involve our comma [algorithm](https://github.com/getgrit/gritql/blob/9587e9e5558c583d69514c1f581f8244ac551616/crates/core/src/inline_snippets.rs#L298). Happy to accept a PR if someone fixes this case.\n/bounty $50",
        "created_at": "2024-10-26T22:32:00Z",
        "version": "0.5"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 361,
        "instance_id": "getgrit__gritql-361",
        "issue_numbers": [
            "356"
        ],
        "base_commit": "cce7a9b791b7ecd653f2df41e804d83c82f3cfb7",
        "patch": "diff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -17,8 +17,8 @@ use marzano_core::api::{AllDone, AllDoneReason, AnalysisLog, MatchResult};\n use marzano_core::pattern_compiler::CompilationResult;\n use marzano_gritmodule::fetcher::KeepFetcherKind;\n use marzano_gritmodule::markdown::get_body_from_md_content;\n-use marzano_gritmodule::searcher::find_grit_modules_dir;\n-use marzano_gritmodule::utils::is_pattern_name;\n+use marzano_gritmodule::searcher::{find_global_grit_dir, find_grit_modules_dir};\n+use marzano_gritmodule::utils::{is_pattern_name, parse_remote_name};\n use marzano_language::target_language::PatternLanguage;\n use serde::{Deserialize, Serialize};\n use std::collections::BTreeMap;\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -41,11 +41,13 @@ use marzano_messenger::{\n     output_mode::OutputMode,\n };\n \n-use crate::resolver::{get_grit_files_from_flags_or_cwd, GritModuleResolver};\n+use crate::resolver::{\n+    get_grit_files_from_flags_or_cwd, get_grit_files_from_known_grit_dir, GritModuleResolver,\n+};\n use crate::utils::has_uncommitted_changes;\n \n use super::filters::SharedFilterArgs;\n-use super::init::init_config_from_cwd;\n+use super::init::{init_config_from_cwd, init_global_grit_modules};\n \n /// Apply a pattern to a set of paths on disk which will be rewritten in place\n #[derive(Deserialize)]\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -319,17 +321,25 @@ pub(crate) async fn run_apply_pattern(\n             .unwrap_or_else(|| &cwd)\n             .to_path_buf();\n         let mod_dir = find_grit_modules_dir(target_grit_dir.clone()).await;\n+        let target_remote = parse_remote_name(&pattern);\n+        let is_remote_name = target_remote.is_some();\n \n         if !env::var(\"GRIT_DOWNLOADS_DISABLED\")\n             .unwrap_or_else(|_| \"false\".to_owned())\n             .parse::<bool>()\n             .unwrap_or(false)\n             && mod_dir.is_err()\n+            && target_remote.is_none()\n         {\n             flushable_unwrap!(\n                 emitter,\n                 init_config_from_cwd::<KeepFetcherKind>(target_grit_dir, false).await\n             );\n+        } else if let Some(target) = &target_remote {\n+            flushable_unwrap!(\n+                emitter,\n+                init_global_grit_modules::<KeepFetcherKind>(Some(target)).await\n+            );\n         }\n \n         #[cfg(feature = \"grit_tracing\")]\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -356,10 +366,18 @@ pub(crate) async fn run_apply_pattern(\n         #[cfg(feature = \"grit_tracing\")]\n         let grit_file_discovery = span!(tracing::Level::INFO, \"grit_file_discovery\",).entered();\n \n-        let pattern_libs = flushable_unwrap!(\n-            emitter,\n-            get_grit_files_from_flags_or_cwd(format_flags).await\n-        );\n+        let pattern_libs = if let Some(target) = target_remote {\n+            let global = find_global_grit_dir().await?;\n+            flushable_unwrap!(\n+                emitter,\n+                get_grit_files_from_known_grit_dir(&global, vec![target]).await\n+            )\n+        } else {\n+            flushable_unwrap!(\n+                emitter,\n+                get_grit_files_from_flags_or_cwd(format_flags).await\n+            )\n+        };\n \n         let (mut lang, pattern_body) = if pattern.ends_with(\".grit\") || pattern.ends_with(\".md\") {\n             match fs::read_to_string(pattern.clone()).await {\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -396,29 +414,32 @@ pub(crate) async fn run_apply_pattern(\n                     }\n                 }\n             }\n+        } else if is_pattern_name(&pattern) {\n+            let raw_name = pattern.trim_end_matches(\"()\");\n+            details.named_pattern = Some(raw_name.to_string());\n+            let presumptive_grit_file = pattern_libs.get(format!(\"{}.grit\", raw_name).as_str());\n+            let lang = match presumptive_grit_file {\n+                Some(g) => PatternLanguage::get_language(g),\n+                None => PatternLanguage::get_language(&pattern),\n+            };\n+            let body = if pattern.ends_with(')') {\n+                pattern.clone()\n+            } else {\n+                format!(\"{}()\", pattern)\n+            };\n+            (lang, body)\n+        } else if is_remote_name {\n+            let raw_name = pattern.split('#').last().unwrap_or(&pattern);\n+            let presumptive_grit_file = pattern_libs.get(format!(\"{}.grit\", raw_name).as_str());\n+            let lang = match presumptive_grit_file {\n+                Some(g) => PatternLanguage::get_language(g),\n+                None => PatternLanguage::get_language(raw_name),\n+            };\n+            let body = format!(\"{}()\", raw_name);\n+            (lang, body)\n         } else {\n-            match is_pattern_name(&pattern) {\n-                true => {\n-                    let raw_name = pattern.trim_end_matches(\"()\");\n-                    details.named_pattern = Some(raw_name.to_string());\n-                    let presumptive_grit_file =\n-                        pattern_libs.get(format!(\"{}.grit\", raw_name).as_str());\n-                    let lang = match presumptive_grit_file {\n-                        Some(g) => PatternLanguage::get_language(g),\n-                        None => PatternLanguage::get_language(&pattern),\n-                    };\n-                    let body = if pattern.ends_with(')') {\n-                        pattern.clone()\n-                    } else {\n-                        format!(\"{}()\", pattern)\n-                    };\n-                    (lang, body)\n-                }\n-                false => {\n-                    let lang = PatternLanguage::get_language(&pattern);\n-                    (lang, pattern.clone())\n-                }\n-            }\n+            let lang = PatternLanguage::get_language(&pattern);\n+            (lang, pattern.clone())\n         };\n         if let Some(lang_option) = &default_lang {\n             if let Some(lang) = lang {\ndiff --git a/crates/cli/src/commands/init.rs b/crates/cli/src/commands/init.rs\n--- a/crates/cli/src/commands/init.rs\n+++ b/crates/cli/src/commands/init.rs\n@@ -3,7 +3,7 @@ use std::{env, fmt, io::ErrorKind, path::PathBuf, str::FromStr};\n \n use tracing::instrument;\n \n-use anyhow::{Context, Result};\n+use anyhow::{bail, Context, Result};\n use clap::Args;\n use colored::Colorize;\n use log::info;\ndiff --git a/crates/cli/src/commands/init.rs b/crates/cli/src/commands/init.rs\n--- a/crates/cli/src/commands/init.rs\n+++ b/crates/cli/src/commands/init.rs\n@@ -28,7 +28,7 @@ pub struct InitArgs {\n \n pub(crate) async fn run_init(arg: InitArgs) -> Result<()> {\n     if arg.global {\n-        init_global_grit_modules::<CleanFetcherKind>().await?;\n+        init_global_grit_modules::<CleanFetcherKind>(None).await?;\n     } else {\n         let cwd = std::env::current_dir()?;\n         init_config_from_cwd::<CleanFetcherKind>(cwd, true).await?;\ndiff --git a/crates/cli/src/commands/init.rs b/crates/cli/src/commands/init.rs\n--- a/crates/cli/src/commands/init.rs\n+++ b/crates/cli/src/commands/init.rs\n@@ -62,12 +62,12 @@ pub async fn init_config_from_cwd<T: FetcherType>(\n         Some(config) => PathBuf::from_str(&config).unwrap(),\n         None => {\n             if !create_local {\n-                return init_global_grit_modules::<T>().await;\n+                return init_global_grit_modules::<T>(None).await;\n             }\n             let git_dir = match find_git_dir_from(cwd).await {\n                 Some(dir) => dir,\n                 None => {\n-                    return init_global_grit_modules::<T>().await;\n+                    return init_global_grit_modules::<T>(None).await;\n                 }\n             };\n             let git_path = PathBuf::from_str(&git_dir).unwrap();\ndiff --git a/crates/cli/src/commands/init.rs b/crates/cli/src/commands/init.rs\n--- a/crates/cli/src/commands/init.rs\n+++ b/crates/cli/src/commands/init.rs\n@@ -112,17 +112,45 @@ patterns:\n     ))?);\n     let parent_str = &grit_parent.to_string_lossy().to_string();\n     let repo = ModuleRepo::from_dir(&config_path).await;\n-    fetch_modules::<T>(&repo, parent_str).await?;\n+    fetch_modules::<T>(&repo, parent_str, None).await?;\n     Ok(ConfigSource::Local(config_path))\n }\n \n-pub async fn init_global_grit_modules<T: FetcherType>() -> Result<ConfigSource> {\n+pub async fn init_global_grit_modules<T: FetcherType>(\n+    from_module: Option<&ModuleRepo>,\n+) -> Result<ConfigSource> {\n     let global_grit_modules_dir = find_global_grit_modules_dir().await?;\n \n     let token = env::var(\"GRIT_PROVIDER_TOKEN\").ok();\n     let fetcher = T::make_fetcher(global_grit_modules_dir, token);\n-    fetcher.prep_grit_modules()?;\n-    install_default_stdlib(&fetcher, None).await?;\n+\n+    if let Some(module) = from_module {\n+        let location = match fetcher.fetch_grit_module(module) {\n+            Ok(loc) => loc,\n+            Err(err) => {\n+                bail!(\n+                    \"Failed to fetch remote grit module {}: {}\",\n+                    module.full_name,\n+                    err.to_string()\n+                )\n+            }\n+        };\n+        fetch_modules::<T>(\n+            module,\n+            &location,\n+            Some(\n+                fetcher\n+                    .clone_dir()\n+                    .parent()\n+                    .context(\"Unable to find global grit dir\")?\n+                    .to_path_buf(),\n+            ),\n+        )\n+        .await?;\n+    } else {\n+        fetcher.prep_grit_modules()?;\n+        install_default_stdlib(&fetcher, None).await?;\n+    }\n \n     Ok(ConfigSource::Global(find_global_grit_dir().await?))\n }\ndiff --git a/crates/cli/src/commands/plumbing.rs b/crates/cli/src/commands/plumbing.rs\n--- a/crates/cli/src/commands/plumbing.rs\n+++ b/crates/cli/src/commands/plumbing.rs\n@@ -202,7 +202,7 @@ pub(crate) async fn run_plumbing(\n             if input.paths.is_empty() {\n                 return Ok(());\n             }\n-            init_global_grit_modules::<KeepFetcherKind>().await?;\n+            init_global_grit_modules::<KeepFetcherKind>(None).await?;\n             let combined_args = CheckArg {\n                 paths: input.paths,\n                 ..args\ndiff --git a/crates/cli/src/resolver.rs b/crates/cli/src/resolver.rs\n--- a/crates/cli/src/resolver.rs\n+++ b/crates/cli/src/resolver.rs\n@@ -64,8 +64,12 @@ impl<'b> fmt::Display for RichPattern<'b> {\n     }\n }\n \n-async fn from_known_grit_dir(config_path: &Path) -> Result<PatternsDirectory> {\n-    let stdlib_modules = get_stdlib_modules();\n+pub async fn get_grit_files_from_known_grit_dir(\n+    config_path: &Path,\n+    must_process: Vec<ModuleRepo>,\n+) -> Result<PatternsDirectory> {\n+    let mut stdlib_modules = get_stdlib_modules();\n+    stdlib_modules.extend(must_process);\n \n     let grit_parent = PathBuf::from(config_path.parent().context(format!(\n         \"Unable to find parent of .grit directory at {}\",\ndiff --git a/crates/cli/src/resolver.rs b/crates/cli/src/resolver.rs\n--- a/crates/cli/src/resolver.rs\n+++ b/crates/cli/src/resolver.rs\n@@ -84,7 +88,7 @@ pub async fn get_grit_files_from(cwd: Option<PathBuf>) -> Result<PatternsDirecto\n     };\n \n     match existing_config {\n-        Some(config) => from_known_grit_dir(&PathBuf::from(config)).await,\n+        Some(config) => get_grit_files_from_known_grit_dir(&PathBuf::from(config), vec![]).await,\n         None => {\n             let stdlib_modules = get_stdlib_modules();\n \ndiff --git a/crates/cli/src/resolver.rs b/crates/cli/src/resolver.rs\n--- a/crates/cli/src/resolver.rs\n+++ b/crates/cli/src/resolver.rs\n@@ -108,7 +112,7 @@ pub async fn get_grit_files_from_flags_or_cwd(\n     flags: &GlobalFormatFlags,\n ) -> Result<PatternsDirectory> {\n     if let Some(grit_dir) = &flags.grit_dir {\n-        from_known_grit_dir(grit_dir).await\n+        get_grit_files_from_known_grit_dir(grit_dir, vec![]).await\n     } else {\n         let cwd = std::env::current_dir()?;\n         get_grit_files_from(Some(cwd)).await\ndiff --git a/crates/gritmodule/src/fetcher.rs b/crates/gritmodule/src/fetcher.rs\n--- a/crates/gritmodule/src/fetcher.rs\n+++ b/crates/gritmodule/src/fetcher.rs\n@@ -262,6 +262,7 @@ fn clone_repo<'a>(\n }\n \n pub trait GritModuleFetcher: Send + Sync {\n+    fn clone_dir(&self) -> &PathBuf;\n     fn fetch_grit_module(&self, repo: &ModuleRepo) -> Result<String>;\n     fn prep_grit_modules(&self) -> Result<()>;\n }\ndiff --git a/crates/gritmodule/src/fetcher.rs b/crates/gritmodule/src/fetcher.rs\n--- a/crates/gritmodule/src/fetcher.rs\n+++ b/crates/gritmodule/src/fetcher.rs\n@@ -319,6 +320,10 @@ impl CleanFetcher {\n }\n \n impl GritModuleFetcher for CleanFetcher {\n+    fn clone_dir(&self) -> &PathBuf {\n+        &self.clone_dir\n+    }\n+\n     fn fetch_grit_module(&self, repo: &ModuleRepo) -> Result<String> {\n         let target_dir = self.get_grit_module_dir(repo);\n         self.clone_repo(repo, &target_dir)?;\ndiff --git a/crates/gritmodule/src/fetcher.rs b/crates/gritmodule/src/fetcher.rs\n--- a/crates/gritmodule/src/fetcher.rs\n+++ b/crates/gritmodule/src/fetcher.rs\n@@ -362,6 +367,10 @@ impl KeepFetcher {\n }\n \n impl GritModuleFetcher for KeepFetcher {\n+    fn clone_dir(&self) -> &PathBuf {\n+        &self.clone_dir\n+    }\n+\n     fn fetch_grit_module(&self, repo: &ModuleRepo) -> Result<String> {\n         let target_dir = self.get_grit_module_dir(repo);\n         self.clone_repo(repo, &target_dir)?;\ndiff --git a/crates/gritmodule/src/resolver.rs b/crates/gritmodule/src/resolver.rs\n--- a/crates/gritmodule/src/resolver.rs\n+++ b/crates/gritmodule/src/resolver.rs\n@@ -92,9 +92,10 @@ pub async fn find_user_patterns() -> Result<Vec<ResolvedGritDefinition>> {\n pub async fn fetch_modules<T: FetcherType>(\n     module: &ModuleRepo,\n     grit_parent_dir: &str,\n+    override_grit_dir: Option<PathBuf>,\n ) -> Result<()> {\n     let as_path = PathBuf::from_str(grit_parent_dir).unwrap();\n-    let grit_dir = as_path.join(REPO_CONFIG_DIR_NAME);\n+    let grit_dir = override_grit_dir.unwrap_or_else(|| as_path.join(REPO_CONFIG_DIR_NAME));\n \n     // Since git cloning is slow, two processes can try to clone at the same time and cause issues because they are overwriting each other\n     // To avoid this, we create a random dir name and move it to the actual gritmodules dir after cloning is complete\ndiff --git a/crates/gritmodule/src/utils.rs b/crates/gritmodule/src/utils.rs\n--- a/crates/gritmodule/src/utils.rs\n+++ b/crates/gritmodule/src/utils.rs\n@@ -4,6 +4,8 @@ use anyhow::{bail, Result};\n use marzano_core::api::MatchResult;\n use regex::Regex;\n \n+use crate::fetcher::ModuleRepo;\n+\n /// Extracts the *rewritten* (after applying a pattern) path from a `MatchResult`.\n pub fn extract_path(result: &MatchResult) -> Option<&String> {\n     match result {\ndiff --git a/crates/gritmodule/src/utils.rs b/crates/gritmodule/src/utils.rs\n--- a/crates/gritmodule/src/utils.rs\n+++ b/crates/gritmodule/src/utils.rs\n@@ -31,3 +33,18 @@ pub fn is_pattern_name(pattern: &str) -> bool {\n     let regex = Regex::new(r\"^[a-zA-Z_][a-zA-Z0-9_]*(\\(\\))?$\").unwrap();\n     regex.is_match(pattern)\n }\n+\n+pub fn parse_remote_name(pattern: &str) -> Option<ModuleRepo> {\n+    let hash_index = pattern.find('#');\n+    let hash_index = match hash_index {\n+        Some(index) => index,\n+        None => return None,\n+    };\n+    let repo_str = &pattern[..hash_index];\n+    let pattern_name = &pattern[hash_index + 1..];\n+    if is_pattern_name(pattern_name) {\n+        ModuleRepo::from_repo_str(repo_str).ok()\n+    } else {\n+        None\n+    }\n+}\ndiff --git a/crates/lsp/src/patterns.rs b/crates/lsp/src/patterns.rs\n--- a/crates/lsp/src/patterns.rs\n+++ b/crates/lsp/src/patterns.rs\n@@ -40,7 +40,7 @@ pub async fn prep_grit_modules(\n     let grit_dir = grit_parent.join(REPO_CONFIG_DIR_NAME);\n     let repo = ModuleRepo::from_dir(&grit_dir).await;\n     if fetch {\n-        let _ = fetch_modules::<KeepFetcherKind>(&repo, &grit_parent.to_string_lossy()).await;\n+        let _ = fetch_modules::<KeepFetcherKind>(&repo, &grit_parent.to_string_lossy(), None).await;\n     }\n     let parent_str = grit_parent.to_string_lossy().to_string();\n     Ok((repo, parent_str, Some(stdlib_modules)))\n",
        "test_patch": "diff --git /dev/null b/crates/cli_bin/fixtures/valibot/test.js\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/valibot/test.js\n@@ -0,0 +1,7 @@\n+const Schema1 = v.string([v.email(\"Email required\")]);\n+const Schema2 = v.string([v.email(), v.endsWith(\"@example.com\")]);\n+const Schema3 = v.string([\n+  v.email(),\n+  v.endsWith(\"@example.com\"),\n+  v.maxLength(30),\n+]);\ndiff --git a/crates/cli_bin/tests/apply.rs b/crates/cli_bin/tests/apply.rs\n--- a/crates/cli_bin/tests/apply.rs\n+++ b/crates/cli_bin/tests/apply.rs\n@@ -2806,3 +2806,24 @@ def cool(name):\n \n     Ok(())\n }\n+\n+#[test]\n+fn apply_remote_pattern() -> Result<()> {\n+    let (_temp_dir, dir) = get_fixture(\"valibot\", false)?;\n+\n+    let mut cmd = get_test_cmd()?;\n+\n+    cmd.arg(\"apply\")\n+        .arg(\"github.com/fabian-hiller/valibot#migrate_to_v0_31_0\")\n+        .current_dir(dir.clone());\n+\n+    let output = cmd.output()?;\n+\n+    assert!(output.status.success(), \"Command should have succeeded\");\n+\n+    let test_file = dir.join(\"test.js\");\n+    let content: String = fs_err::read_to_string(&test_file)?;\n+    assert_snapshot!(content);\n+\n+    Ok(())\n+}\ndiff --git /dev/null b/crates/cli_bin/tests/snapshots/apply__apply_remote_pattern.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/tests/snapshots/apply__apply_remote_pattern.snap\n@@ -0,0 +1,9 @@\n+---\n+source: crates/cli_bin/tests/apply.rs\n+expression: content\n+---\n+const Schema1 = v.pipe(v.string(), v.email(\"Email required\"));\n+const Schema2 = v.pipe(v.string(), v.email(), v.endsWith(\"@example.com\"));\n+const Schema3 = v.pipe(v.string(), v.email(),\n+  v.endsWith(\"@example.com\"),\n+  v.maxLength(30),);\n",
        "problem_statement": "Automatic apply modules by URL\nInstead of needing to add a module locally to install it, we should allow applying patterns from remote modules directly.\r\n\r\nFor example:\r\n```\r\ngrit apply github.com/fabian-hiller/valibot#valibot_v03\r\n```\n",
        "hints_text": "",
        "created_at": "2024-05-28T12:43:01Z",
        "version": "0.2"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 69,
        "instance_id": "getgrit__gritql-69",
        "issue_numbers": [
            "58"
        ],
        "base_commit": "61241d62777664d4487437c41555af40ffb6e42b",
        "patch": "diff --git a/Cargo.lock b/Cargo.lock\n--- a/Cargo.lock\n+++ b/Cargo.lock\n@@ -2021,12 +2021,14 @@ name = \"marzano-language\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n+ \"clap\",\n  \"enum_dispatch\",\n  \"ignore\",\n  \"itertools 0.10.5\",\n  \"lazy_static\",\n  \"marzano-util\",\n  \"regex\",\n+ \"serde\",\n  \"serde_json\",\n  \"tree-sitter-c-sharp\",\n  \"tree-sitter-css\",\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -109,6 +109,8 @@ pub struct ApplyPatternArgs {\n     /// Clear cache before running apply\n     #[clap(long = \"refresh-cache\", conflicts_with = \"cache\")]\n     pub refresh_cache: bool,\n+    #[clap(long = \"language\", alias=\"lang\")]\n+    pub language: Option<PatternLanguage>,\n }\n \n impl Default for ApplyPatternArgs {\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -125,6 +127,7 @@ impl Default for ApplyPatternArgs {\n             output_file: Default::default(),\n             cache: Default::default(),\n             refresh_cache: Default::default(),\n+            language: Default::default(),\n         }\n     }\n }\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -226,7 +229,8 @@ pub(crate) async fn run_apply_pattern(\n         }\n \n         let pattern_libs = flushable_unwrap!(emitter, get_grit_files_from_cwd().await);\n-        let (lang, pattern_body) = if pattern.ends_with(\".grit\") || pattern.ends_with(\".md\") {\n+        let (mut lang, pattern_body) = if pattern.ends_with(\".grit\") || pattern.ends_with(\".md\") {\n+    \n             match fs::read_to_string(pattern.clone()).await {\n                 Ok(pb) => {\n                     if pattern.ends_with(\".grit\") {\ndiff --git a/crates/cli/src/commands/apply_pattern.rs b/crates/cli/src/commands/apply_pattern.rs\n--- a/crates/cli/src/commands/apply_pattern.rs\n+++ b/crates/cli/src/commands/apply_pattern.rs\n@@ -285,6 +289,18 @@ pub(crate) async fn run_apply_pattern(\n                 }\n             }\n         };\n+        if let Some(lang_option) = &arg.language {\n+            if let Some(lang) = lang {\n+                if lang != *lang_option {\n+                    return Err(anyhow::anyhow!(\n+                        \"Language option {} does not match pattern language {}\",\n+                        lang_option,\n+                        lang\n+                    ));\n+                }\n+            }\n+            lang = Some(*lang_option);\n+        }\n         let pattern_libs = flushable_unwrap!(\n             emitter,\n             pattern_libs.get_language_directory_or_default(lang)\ndiff --git a/crates/language/Cargo.toml b/crates/language/Cargo.toml\n--- a/crates/language/Cargo.toml\n+++ b/crates/language/Cargo.toml\n@@ -27,6 +27,7 @@ tree-sitter-ruby = { path = \"../../resources/language-metavariables/tree-sitter-\n tree-sitter-sql = { path = \"../../resources/language-metavariables/tree-sitter-sql\", optional = true }\n tree-sitter-vue = { path = \"../../resources/language-metavariables/tree-sitter-vue\", optional = true }\n tree-sitter-toml = { path = \"../../resources/language-metavariables/tree-sitter-toml\", optional = true }\n+serde = { version = \"1.0.164\", features = [\"derive\"] }\n serde_json = { version = \"1.0.91\", features = [\"preserve_order\"] }\n marzano-util = { path = \"../util\" }\n regex = \"1.7.1\"\ndiff --git a/crates/language/Cargo.toml b/crates/language/Cargo.toml\n--- a/crates/language/Cargo.toml\n+++ b/crates/language/Cargo.toml\n@@ -37,6 +38,7 @@ ignore = { version = \"0.4.21\", optional = true }\n web-sys = { version = \"0.3.66\", features = [\"console\"], optional = true }\n tree-sitter-traversal = { version = \"0.1.2\", default-features = false }\n enum_dispatch = \"0.3.12\"\n+clap = { version = \"4.1.13\", features = [\"derive\"] }\n \n [dev-dependencies]\n trim-margin = \"0.1.0\"\ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -24,6 +24,8 @@ use crate::{\n };\n use anyhow::Result;\n use enum_dispatch::enum_dispatch;\n+use clap::ValueEnum;\n+use serde::Serialize;\n use std::borrow::Cow;\n use std::fmt;\n use std::hash::Hash;\ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -42,11 +44,15 @@ use std::path::PathBuf;\n #[cfg(feature = \"finder\")]\n use std::str::FromStr;\n \n-#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash)]\n+#[derive(ValueEnum, Debug, Clone, Copy, Default, PartialEq, Eq, Hash, Serialize)]\n+#[clap(rename_all = \"lower\")]\n pub enum PatternLanguage {\n+    #[value(skip)]\n     JavaScript,\n+    #[value(skip)]\n     TypeScript,\n     #[default]\n+    #[value(name = \"js\")]\n     Tsx,\n     Html,\n     Css,\ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -54,7 +60,9 @@ pub enum PatternLanguage {\n     Java,\n     CSharp, // f\n     Python,\n+    #[value(name = \"markdown\")]\n     MarkdownBlock,\n+    #[value(skip)]\n     MarkdownInline,\n     Go,\n     Rust,\ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -65,6 +73,7 @@ pub enum PatternLanguage {\n     Sql,\n     Vue,\n     Toml,\n+    #[value(skip)]\n     Universal,\n }\n \ndiff --git a/crates/language/src/target_language.rs b/crates/language/src/target_language.rs\n--- a/crates/language/src/target_language.rs\n+++ b/crates/language/src/target_language.rs\n@@ -371,6 +380,7 @@ impl PatternLanguage {\n     }\n }\n \n+\n #[cfg(feature = \"finder\")]\n pub fn expand_paths(\n     start_paths: &[PathBuf],\n",
        "test_patch": "diff --git a/crates/cli_bin/tests/apply.rs b/crates/cli_bin/tests/apply.rs\n--- a/crates/cli_bin/tests/apply.rs\n+++ b/crates/cli_bin/tests/apply.rs\n@@ -2015,3 +2015,169 @@ fn ignores_file_in_grit_dir() -> Result<()> {\n \n     Ok(())\n }\n+\n+#[test]\n+fn language_option_file_pattern_apply() -> Result<()> {\n+    // Keep _temp_dir around so that the tempdir is not deleted\n+    let (_temp_dir, dir) = get_fixture(\"simple_python\", false)?;\n+    let origin_content = std::fs::read_to_string(dir.join(\"main.py\"))?;\n+\n+    // from the tempdir as cwd, run init\n+    run_init(&dir.as_path())?;\n+\n+    // from the tempdir as cwd, run marzano apply\n+    let mut apply_cmd = get_test_cmd()?;\n+    apply_cmd.current_dir(dir.as_path());\n+    apply_cmd.arg(\"apply\").arg(\"--force\").arg(\"pattern.grit\").arg(\"--language\").arg(\"java\");\n+    let output = apply_cmd.output()?;\n+\n+    // Assert that the command failed\n+    assert!(\n+        !output.status.success(),\n+        \"Command with incorrect language option should fail: {}\",\n+        String::from_utf8(output.stdout)?\n+    );\n+\n+    // Read back the main.py file\n+    let target_file = dir.join(\"main.py\");\n+    let content: String = std::fs::read_to_string(target_file)?;\n+\n+    assert_eq!(origin_content, content);\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn language_option_inline_pattern_apply() -> Result<()> {\n+    let pattern = r\"`os.getenv` => `dotenv.fetch`\";\n+    // Keep _temp_dir around so that the tempdir is not deleted\n+    let (_temp_dir, dir) = get_fixture(\"simple_python\", false)?;\n+\n+    // from the tempdir as cwd, run init\n+    run_init(&dir.as_path())?;\n+\n+    // from the tempdir as cwd, run marzano apply\n+    let mut apply_cmd = get_test_cmd()?;\n+    apply_cmd.current_dir(dir.as_path());\n+    apply_cmd.arg(\"apply\").arg(pattern).arg(\"--force\").arg(\"--lang\").arg(\"python\");\n+    let output = apply_cmd.output()?;\n+\n+    // Assert that the command executed successfully\n+    assert!(\n+        output.status.success(),\n+        \"Command didn't finish successfully: {}\",\n+        String::from_utf8(output.stdout)?\n+    );\n+\n+    // Read back the main.py file\n+    let target_file = dir.join(\"main.py\");\n+    let content: String = std::fs::read_to_string(target_file)?;\n+\n+    // assert that it matches snapshot\n+    assert_snapshot!(content);\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn language_option_named_pattern_apply() -> Result<()> {\n+    let pattern = r\"pattern test_pattern() {\n+        `os.getenv` => `dotenv.fetch`\n+    }\n+    test_pattern()\n+    \";\n+    // Keep _temp_dir around so that the tempdir is not deleted\n+    let (_temp_dir, dir) = get_fixture(\"simple_python\", false)?;\n+\n+    // from the tempdir as cwd, run init\n+    run_init(&dir.as_path())?;\n+\n+    // from the tempdir as cwd, run marzano apply\n+    let mut apply_cmd = get_test_cmd()?;\n+    apply_cmd.current_dir(dir.as_path());\n+    apply_cmd.arg(\"apply\").arg(pattern).arg(\"--force\").arg(\"--lang\").arg(\"python\");\n+    let output = apply_cmd.output()?;\n+\n+    // Assert that the command executed successfully\n+    assert!(\n+        output.status.success(),\n+        \"Command didn't finish successfully: {}\",\n+        String::from_utf8(output.stdout)?\n+    );\n+\n+    // Read back the main.py file\n+    let target_file = dir.join(\"main.py\");\n+    let content: String = std::fs::read_to_string(target_file)?;\n+\n+    // assert that it matches snapshot\n+    assert_snapshot!(content);\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn language_option_conflict_apply() -> Result<()> {\n+    let pattern = r\"language java\n+     `os.getenv` => `dotenv.fetch`\";\n+    // Keep _temp_dir around so that the tempdir is not deleted\n+    let (_temp_dir, dir) = get_fixture(\"simple_python\", false)?;\n+\n+    let origin_content = std::fs::read_to_string(dir.join(\"main.py\"))?;\n+\n+    // from the tempdir as cwd, run init\n+    run_init(&dir.as_path())?;\n+\n+    // from the tempdir as cwd, run marzano apply\n+    let mut apply_cmd = get_test_cmd()?;\n+    apply_cmd.current_dir(dir.as_path());\n+    apply_cmd.arg(\"apply\").arg(pattern).arg(\"--force\").arg(\"--language\").arg(\"python\");\n+    let output = apply_cmd.output()?;\n+\n+    // Assert that the command failed\n+    assert!(\n+        !output.status.success(),\n+        \"Command with conflict language option and pattern should fail\"\n+    );\n+\n+    // Read back the main.py file\n+    let target_file = dir.join(\"main.py\");\n+    let content: String = std::fs::read_to_string(target_file)?;\n+\n+    // assert that it matches snapshot\n+    assert_eq!(origin_content, content);\n+\n+    Ok(())\n+}\n+\n+#[test]\n+fn invalid_language_option_apply() -> Result<()> {\n+    let pattern = r\"`os.getenv` => `dotenv.fetch`\";\n+    // Keep _temp_dir around so that the tempdir is not deleted\n+    let (_temp_dir, dir) = get_fixture(\"simple_python\", false)?;\n+    let origin_content = std::fs::read_to_string(dir.join(\"main.py\"))?;\n+\n+    // from the tempdir as cwd, run init\n+    run_init(&dir.as_path())?;\n+\n+    // from the tempdir as cwd, run marzano apply\n+    let mut apply_cmd = get_test_cmd()?;\n+    apply_cmd.current_dir(dir.as_path());\n+    apply_cmd.arg(\"apply\").arg(pattern).arg(\"--force\").arg(\"--lang\").arg(\"__invalid\");\n+    let output = apply_cmd.output()?;\n+\n+    // Assert that the command failed\n+    assert!(\n+        !output.status.success(),\n+        \"Command with invalid language option should fail: {}\",\n+        String::from_utf8(output.stdout)?\n+    );\n+\n+    // Read back the main.py file\n+    let target_file = dir.join(\"main.py\");\n+    let content: String = std::fs::read_to_string(target_file)?;\n+\n+    // assert that it matches snapshot\n+    assert_eq!(origin_content, content);\n+\n+    Ok(())\n+}\ndiff --git /dev/null b/crates/cli_bin/tests/snapshots/apply__language_option_inline_pattern_apply.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/tests/snapshots/apply__language_option_inline_pattern_apply.snap\n@@ -0,0 +1,12 @@\n+---\n+source: crates/cli_bin/tests/apply.rs\n+assertion_line: 2079\n+expression: content\n+---\n+import os\n+\n+import openai\n+from flask import Flask, redirect, render_template, request, url_for\n+\n+app = Flask(__name__)\n+openai.api_key = dotenv.fetch(\"OPENAI_API_KEY\")\ndiff --git /dev/null b/crates/cli_bin/tests/snapshots/apply__language_option_named_pattern_apply.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/tests/snapshots/apply__language_option_named_pattern_apply.snap\n@@ -0,0 +1,12 @@\n+---\n+source: crates/cli_bin/tests/apply.rs\n+assertion_line: 2114\n+expression: content\n+---\n+import os\n+\n+import openai\n+from flask import Flask, redirect, render_template, request, url_for\n+\n+app = Flask(__name__)\n+openai.api_key = dotenv.fetch(\"OPENAI_API_KEY\")\n",
        "problem_statement": "`--language` flag on the CLI\nFor simple inline patterns, needing to specify the language in the declaration is a hindrance.\r\n\r\nFor example:\r\n```\r\n$ grit apply 'language css\r\nr\"--red-(.+)\"($var)'\r\n```\r\n\r\nThis would be more ergonomic:\r\n```\r\n$ grit apply 'r\"--red-(.+)\"($var)'' --language css\r\n```\n",
        "hints_text": "/bounty $25",
        "created_at": "2024-03-25T02:57:32Z"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 569,
        "instance_id": "getgrit__gritql-569",
        "issue_numbers": [
            "394"
        ],
        "base_commit": "e12de3b59978e462269263088ef834b90e0be244",
        "patch": "diff --git a/crates/core/src/ast_node.rs b/crates/core/src/ast_node.rs\n--- a/crates/core/src/ast_node.rs\n+++ b/crates/core/src/ast_node.rs\n@@ -149,6 +149,12 @@ impl AstLeafNode {\n             text: text.to_owned(),\n         })\n     }\n+    pub fn is_equivalent_class(&self, sort: SortId) -> bool {\n+        if let Some(e) = &self.equivalence_class {\n+            return e.contains(sort);\n+        }\n+        false\n+    }\n }\n \n impl AstLeafNodePattern<MarzanoQueryContext> for AstLeafNode {\ndiff --git a/crates/language/src/language.rs b/crates/language/src/language.rs\n--- a/crates/language/src/language.rs\n+++ b/crates/language/src/language.rs\n@@ -51,6 +51,9 @@ impl LeafEquivalenceClass {\n                     .is_some_and(|s| s == self.representative)\n             })\n     }\n+    pub fn contains(&self, sort: SortId) -> bool {\n+        self.class.iter().any(|c| c.sort == sort)\n+    }\n     pub(crate) fn new(\n         representative: &str,\n         sort: SortId,\ndiff --git a/crates/language/src/language.rs b/crates/language/src/language.rs\n--- a/crates/language/src/language.rs\n+++ b/crates/language/src/language.rs\n@@ -120,6 +123,10 @@ pub(crate) fn normalize_double_quote_string(s: &str) -> Option<&str> {\n     s.strip_prefix('\"')?.strip_suffix('\"')\n }\n \n+pub(crate) fn normalize_single_quote_string(s: &str) -> Option<&str> {\n+    s.strip_prefix('\\'')?.strip_suffix('\\'')\n+}\n+\n pub(crate) fn kind_and_field_id_for_field_map(\n     lang: &TSLanguage,\n     names: Vec<(&str, &str, FieldExpectationCondition)>,\ndiff --git a/crates/language/src/yaml.rs b/crates/language/src/yaml.rs\n--- a/crates/language/src/yaml.rs\n+++ b/crates/language/src/yaml.rs\n@@ -1,6 +1,7 @@\n use crate::language::{\n-    fields_for_nodes, normalize_double_quote_string, normalize_identity, Field,\n-    LeafEquivalenceClass, LeafNormalizer, MarzanoLanguage, NodeTypes, SortId, TSLanguage,\n+    fields_for_nodes, normalize_double_quote_string, normalize_identity,\n+    normalize_single_quote_string, Field, LeafEquivalenceClass, LeafNormalizer, MarzanoLanguage,\n+    NodeTypes, SortId, TSLanguage,\n };\n use grit_util::Language;\n use marzano_util::node_with_source::NodeWithSource;\ndiff --git a/crates/language/src/yaml.rs b/crates/language/src/yaml.rs\n--- a/crates/language/src/yaml.rs\n+++ b/crates/language/src/yaml.rs\n@@ -45,6 +46,10 @@ impl Yaml {\n                     language.id_for_node_kind(\"double_quote_scalar\", true),\n                     normalize_double_quote_string,\n                 ),\n+                LeafNormalizer::new(\n+                    language.id_for_node_kind(\"single_quote_scalar\", true),\n+                    normalize_single_quote_string,\n+                ),\n             ]]\n         });\n         let metavariable_sort = language.id_for_node_kind(\"grit_metavariable\", true);\n",
        "test_patch": "diff --git /dev/null b/crates/cli_bin/fixtures/yaml_strings/build.yml\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/yaml_strings/build.yml\n@@ -0,0 +1,6 @@\n+# https://github.com/actions/runner-images/blob/main/README.md#available-images\n+steps:\n+  - \"ubuntu-latest\"\n+  - 'ubuntu-latest'\n+  - ubuntu-latest\n+  - something random\ndiff --git a/crates/cli_bin/tests/apply.rs b/crates/cli_bin/tests/apply.rs\n--- a/crates/cli_bin/tests/apply.rs\n+++ b/crates/cli_bin/tests/apply.rs\n@@ -3051,6 +3051,39 @@ fn apply_to_path_with_invalid_lang() -> Result<()> {\n     Ok(())\n }\n \n+/// test that we can apply to a yaml file containing equivalent strings but with different formatting/representations\n+/// see https://github.com/getgrit/gritql/issues/394\n+#[test]\n+fn apply_to_yaml_with_multiple_equivalent_strings() -> Result<()> {\n+    let (_temp_dir, fixture_dir) = get_fixture(\"yaml_strings\", false)?;\n+\n+    let mut cmd = get_test_cmd()?;\n+    cmd.arg(\"apply\")\n+        .arg(\"`'ubuntu-latest'` => `'ubuntu-22.04'`\")\n+        .arg(\"build.yml\")\n+        .arg(\"--lang=yaml\")\n+        .arg(\"--force\")\n+        .current_dir(&fixture_dir);\n+\n+    let result = cmd.output()?;\n+\n+    let stderr = String::from_utf8(result.stderr)?;\n+    println!(\"stderr: {:?}\", stderr);\n+    let stdout = String::from_utf8(result.stdout)?;\n+    println!(\"stdout: {:?}\", stdout);\n+\n+    assert!(result.status.success(), \"Command failed\");\n+    // Read back the build.yml file to ensure it was processed correctly\n+    let target_file = fixture_dir.join(\"build.yml\");\n+    let content: String = fs_err::read_to_string(target_file)?;\n+    assert_snapshot!(content);\n+\n+    // ensure all equivalent strings were replaced\n+    assert!(stdout.contains(\"Processed 1 files and found 3 matches\"));\n+\n+    Ok(())\n+}\n+\n /// Ban multiple stdin paths\n #[test]\n fn apply_stdin_two_paths() -> Result<()> {\ndiff --git /dev/null b/crates/cli_bin/tests/snapshots/apply__apply_to_yaml_with_multiple_equivalent_strings.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/tests/snapshots/apply__apply_to_yaml_with_multiple_equivalent_strings.snap\n@@ -0,0 +1,10 @@\n+---\n+source: crates/cli_bin/tests/apply.rs\n+expression: content\n+---\n+# https://github.com/actions/runner-images/blob/main/README.md#available-images\n+steps:\n+  - 'ubuntu-22.04'\n+  - 'ubuntu-22.04'\n+  - 'ubuntu-22.04'\n+  - something random\ndiff --git a/crates/core/src/marzano_code_snippet.rs b/crates/core/src/marzano_code_snippet.rs\n--- a/crates/core/src/marzano_code_snippet.rs\n+++ b/crates/core/src/marzano_code_snippet.rs\n@@ -64,11 +64,70 @@ impl Matcher<MarzanoQueryContext> for MarzanoCodeSnippet {\n             return Ok(false);\n         };\n \n-        if let Some((_, pattern)) = self\n-            .patterns\n-            .iter()\n-            .find(|(id, _)| *id == node.node.kind_id())\n-        {\n+        if let Some((_, pattern)) = self.patterns.iter().find(|(id, p)| {\n+            let kind_id = node.node.kind_id();\n+            if *id == kind_id {\n+                return true;\n+            }\n+            // use equivalence classes to match 'ubuntu-latest' and \"ubuntu-latest\" in yaml\n+            // i.e. to match string_scalar, single_quote_scalar, and double_quote_scalar\n+            // see https://github.com/getgrit/gritql/issues/394\n+            match p {\n+                Pattern::AstLeafNode(p) => p.is_equivalent_class(kind_id),\n+                Pattern::AstNode(_) => false,\n+                Pattern::Some(_) => false,\n+                Pattern::Every(_) => false,\n+                Pattern::List(_) => false,\n+                Pattern::ListIndex(_) => false,\n+                Pattern::Map(_) => false,\n+                Pattern::Accessor(_) => false,\n+                Pattern::Call(_) => false,\n+                Pattern::Regex(_) => false,\n+                Pattern::File(_) => false,\n+                Pattern::Files(_) => false,\n+                Pattern::Bubble(_) => false,\n+                Pattern::Limit(_) => false,\n+                Pattern::CallBuiltIn(_) => false,\n+                Pattern::CallFunction(_) => false,\n+                Pattern::CallForeignFunction(_) => false,\n+                Pattern::CallbackPattern(_) => false,\n+                Pattern::Assignment(_) => false,\n+                Pattern::Accumulate(_) => false,\n+                Pattern::StringConstant(_) => false,\n+                Pattern::IntConstant(_) => false,\n+                Pattern::FloatConstant(_) => false,\n+                Pattern::BooleanConstant(_) => false,\n+                Pattern::Variable(_) => false,\n+                Pattern::Add(_) => false,\n+                Pattern::Subtract(_) => false,\n+                Pattern::Multiply(_) => false,\n+                Pattern::Divide(_) => false,\n+                Pattern::Modulo(_) => false,\n+                Pattern::And(_) => false,\n+                Pattern::Or(_) => false,\n+                Pattern::Maybe(_) => false,\n+                Pattern::Any(_) => false,\n+                Pattern::CodeSnippet(_) => false,\n+                Pattern::Rewrite(_) => false,\n+                Pattern::Range(_) => false,\n+                Pattern::Contains(_) => false,\n+                Pattern::Includes(_) => false,\n+                Pattern::Within(_) => false,\n+                Pattern::After(_) => false,\n+                Pattern::Before(_) => false,\n+                Pattern::Where(_) => false,\n+                Pattern::Undefined => false,\n+                Pattern::Top => false,\n+                Pattern::Underscore => false,\n+                Pattern::Bottom => false,\n+                Pattern::Not(_) => false,\n+                Pattern::If(_) => false,\n+                Pattern::Dots => false,\n+                Pattern::Dynamic(_) => false,\n+                Pattern::Sequential(_) => false,\n+                Pattern::Like(_) => false,\n+            }\n+        }) {\n             pattern.execute(resolved, state, context, logs)\n         } else {\n             Ok(false)\ndiff --git a/crates/language/src/yaml.rs b/crates/language/src/yaml.rs\n--- a/crates/language/src/yaml.rs\n+++ b/crates/language/src/yaml.rs\n@@ -154,6 +159,18 @@ mod tests {\n         assert!(!nodes.is_empty());\n     }\n \n+    #[test]\n+    fn simple_strings() {\n+        let snippet = \"steps:\\n  - runs_on: \\\"ubuntu-latest\\\"\\n  - runs_on: 'ubuntu-latest'\\n  - runs_on: ubuntu-latest\";\n+        let lang = Yaml::new(None);\n+        let snippets = lang.parse_snippet_contexts(snippet);\n+        let nodes = nodes_from_indices(&snippets);\n+        for node in &nodes {\n+            print_node(&node.node)\n+        }\n+        assert!(!nodes.is_empty());\n+    }\n+\n     #[test]\n     fn simple_yaml_metavariable() {\n         let snippet = \"$list\";\n",
        "problem_statement": "String equivalence in yaml\nTwo different yaml strings should be treated identically in patterns.\r\n\r\nFor example, this pattern should match all 3 nodes in the yaml file:\r\n\r\n```\r\nlanguage yaml\r\n\r\n`'ubuntu-latest'`\r\n```\r\n\r\nSample file:\r\n```\r\nsteps:\r\n    - runs_on: \"ubuntu-latest\"\r\n    - runs_on: 'ubuntu-latest'\r\n    - runs_on: ubuntu-latest\r\n\r\n```\r\n\r\nIt looks like the problem is the underlying AST representations are different in the yaml grammar between single-quote and double-quote strings.\n",
        "hints_text": "hey @morgante ,\r\nI would like to work on this. I'm new to this project. Can you help me understand this problem?\nHi @dekkku I've added some more details on the problem above.\r\n\r\nIn theory we already have some logic for normalizing \"equivalence classes\" like this: https://github.com/getgrit/gritql/blob/b526a07022ef8b5b2c1969763d11955d4b332c4c/crates/language/src/yaml.rs#L119C8-L133\r\n\r\nUnfortunately it doesn't seem to be working as intended.\n/bounty $50",
        "created_at": "2024-10-29T23:31:38Z",
        "version": "0.5"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 122,
        "instance_id": "getgrit__gritql-122",
        "issue_numbers": [
            "121"
        ],
        "base_commit": "0ca9be8758f7181caff713926385758a2a109e46",
        "patch": "diff --git a/crates/language/src/python.rs b/crates/language/src/python.rs\n--- a/crates/language/src/python.rs\n+++ b/crates/language/src/python.rs\n@@ -1,5 +1,7 @@\n use std::sync::OnceLock;\n \n+use tree_sitter::Node;\n+\n use crate::language::{fields_for_nodes, Field, Language, SortId, TSLanguage};\n \n static NODE_TYPES_STRING: &str =\n",
        "test_patch": "diff --git a/crates/core/src/test.rs b/crates/core/src/test.rs\n--- a/crates/core/src/test.rs\n+++ b/crates/core/src/test.rs\n@@ -7700,6 +7700,46 @@ fn multiply_decimals() {\n     .unwrap();\n }\n \n+#[test]\n+fn python_removes_orphaned_type_arrow() {\n+    run_test_expected({\n+        TestArgExpected {\n+            pattern: r#\"\n+                |language python\n+                |\n+                |function_definition($name, $return_type) where {\n+                |  $name <: `foo`,\n+                |  $return_type => .\n+                |}\n+                |\"#\n+            .trim_margin()\n+            .unwrap(),\n+            source: r#\"\n+                |def foo() -> None:\n+                |    print('hi')\n+                |\n+                |def bar() -> SomeType:\n+                |    print('hello')\n+                |    return SomeType\n+                |\"#\n+            .trim_margin()\n+            .unwrap(),\n+            // The whitespace is fine, because Ruff will remove it\n+            expected: r#\"\n+                |def foo()  :\n+                |    print('hi')\n+                |\n+                |def bar() -> SomeType:\n+                |    print('hello')\n+                |    return SomeType\n+                |\"#\n+            .trim_margin()\n+            .unwrap(),\n+        }\n+    })\n+    .unwrap();\n+}\n+\n #[test]\n fn removes_orphaned_semicolon() {\n     run_test_expected({\ndiff --git a/crates/language/src/python.rs b/crates/language/src/python.rs\n--- a/crates/language/src/python.rs\n+++ b/crates/language/src/python.rs\n@@ -77,6 +79,17 @@ impl Language for Python {\n     fn is_comment(&self, id: SortId) -> bool {\n         id == self.comment_sort\n     }\n+\n+    fn check_orphaned(&self, n: Node<'_>, src: &str, orphan_ranges: &mut Vec<tree_sitter::Range>) {\n+        if n.is_error() {\n+            let Ok(text) = n.utf8_text(src.as_bytes()) else {\n+                return;\n+            };\n+            if &text == \"->\" {\n+                orphan_ranges.push(n.range());\n+            }\n+        }\n+    }\n }\n \n #[cfg(test)]\n",
        "problem_statement": "Python: Invalid rewrite for `$something => .`\n## Summary\r\n\r\nInvalid rewrites when trying to remove a node.\r\n\r\n## Repro\r\n\r\nhttps://app.grit.io/studio?key=Mtz14P9InB2-2vdJYtxLk\r\n\r\n```gritql\r\nengine marzano(0.1)\r\nlanguage python\r\n\r\n\r\npattern test_func($name, $parameters, $return_type, $body) {\r\n    function_definition($name, $parameters, $return_type, $body) as $function where {\r\n        $name <: r\"test_.*\",\r\n    }\r\n}\r\n\r\npattern test_class($name, $superclasses, $body) {\r\n    class_definition($name, $superclasses, $body) as $cls where {\r\n        $superclasses <: contains `TestCase`,\r\n    }\r\n}\r\n\r\ntest_func($return_type) as $function where {\r\n    $function <: within test_class(),\r\n    $return_type => .\r\n}\r\n```\r\n\r\nAnd target:\r\n\r\n```python\r\nfrom unittest import TestCase\r\n\r\nclass TestFirst(TestCase):\r\n  def test_typed(self) -> None:\r\n    pass\r\n\r\n  def test_another(self):\r\n    pass\r\n```\r\n\r\nProduces the following:\r\n\r\n<img width=\"813\" alt=\"image\" src=\"https://github.com/getgrit/gritql/assets/5855806/4397b22d-f2e4-412f-9c06-b41dddbac4a7\">\r\n\r\nThe dangling ` -> :` is invalid, the `->` should be removed as well.\r\n\r\nI also noticed this in some cases while removing some kwarg from a list of kwargs -- unfortunately I don't have a repro on that though. Removing a kwarg in some cases left a dangling comma, i.e. `Something(a=1, b=2, c=3)` -> \"remove kwarg `a`\" -> `Something(, b=2, c=3)` invalid.\r\n\n",
        "hints_text": "This would fall under the category of removing \"orphaned\" nodes. Ex. in TypeScript we will remove trailing semicolons if a statement is deleted.\r\n\r\nThe relevant code is here: https://github.com/getgrit/gritql/blob/0ca9be8758f7181caff713926385758a2a109e46/crates/language/src/xscript_util.rs#L70C15-L70C36\r\n\r\nWe'd welcome a contribution to extend this to Python.\r\n\r\nAs a workaround, you can rewrite the whole node.\r\n\r\n```\r\nengine marzano(0.1)\r\nlanguage python\r\n\r\n\r\npattern test_func($name, $parameters, $return_type, $body) {\r\n    function_definition($name, $parameters, $return_type, $body) as $function where {\r\n        $name <: r\"test_.*\",\r\n    }\r\n}\r\n\r\npattern test_class($name, $superclasses, $body) {\r\n    class_definition($name, $superclasses, $body) as $cls where {\r\n        $superclasses <: contains `TestCase`,\r\n    }\r\n}\r\n\r\ntest_func($parameters, $body, $name) as $function where {\r\n    $function <: within test_class(),\r\n    $function => `def $name($parameters): $body`\r\n}\r\n```\nThanks for the code pointer! I may check it out, but can't promise I have time immediately.\r\n\r\nRegarding your suggestion, unfortunately I have noticed that rewriting the whole node drops comment nodes at the start of `$body`. Perhaps this is another issue?\r\n\r\nhttps://app.grit.io/studio?key=CMQmy5VOetz2Rc5F1Fq-L\r\n\r\n<img width=\"1006\" alt=\"image\" src=\"https://github.com/getgrit/gritql/assets/5855806/10bc5106-06b3-412a-bcfe-0bccb26c4d7d\">\r\n\r\n\r\n\nYeah, it looks like that's a problem with the grammar including the comment inside the parent instead of the body.",
        "created_at": "2024-03-29T21:26:34Z"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 558,
        "instance_id": "getgrit__gritql-558",
        "issue_numbers": [
            "423"
        ],
        "base_commit": "e5d3023f44d34fd3fcf18e12174602a84c56cbc3",
        "patch": "diff --git /dev/null b/crates/cli_bin/fixtures/pattern_non_existent/.grit/grit.yaml\nnew file mode 100644\n--- /dev/null\n+++ b/crates/cli_bin/fixtures/pattern_non_existent/.grit/grit.yaml\n@@ -0,0 +1,3 @@\n+version: 0.0.1\n+patterns:\n+  - file: patterns/non_existent.md\ndiff --git a/crates/gritmodule/src/parser.rs b/crates/gritmodule/src/parser.rs\n--- a/crates/gritmodule/src/parser.rs\n+++ b/crates/gritmodule/src/parser.rs\n@@ -98,10 +98,17 @@ pub async fn get_patterns_from_file(\n     ext: PatternFileExt,\n     overrides: GritDefinitionOverrides,\n ) -> Result<Vec<ModuleGritPattern>> {\n-    let repo_root = find_repo_root_from(path.clone()).await?;\n-    let content = fs::read_to_string(&path).await?;\n+    let path_str = path.to_string_lossy();\n+    let repo_root = find_repo_root_from(path.clone()).await.context(format!(\n+        \"Failed to find repository root from path {}\",\n+        path_str\n+    ))?;\n+    let content = fs::read_to_string(&path).await.context(format!(\n+        \"Failed to find pattern at {}. Does it exist?\",\n+        extract_relative_path(&path_str, &repo_root)\n+    ))?;\n     let mut file = RichFile {\n-        path: path.to_string_lossy().to_string(),\n+        path: path_str.to_string(),\n         content,\n     };\n     ext.get_patterns(&mut file, &source_module, &repo_root, overrides)\n",
        "test_patch": "diff --git a/crates/cli_bin/tests/patterns_test.rs b/crates/cli_bin/tests/patterns_test.rs\n--- a/crates/cli_bin/tests/patterns_test.rs\n+++ b/crates/cli_bin/tests/patterns_test.rs\n@@ -180,6 +180,27 @@ fn fails_recursion() -> Result<()> {\n     Ok(())\n }\n \n+#[test]\n+fn fails_to_find_non_existent_file() -> Result<()> {\n+    let (_temp_dir, temp_fixture_path) = get_fixture(\"pattern_non_existent\", false)?;\n+\n+    let mut cmd = get_test_cmd()?;\n+    cmd.arg(\"patterns\")\n+        .arg(\"test\")\n+        .current_dir(&temp_fixture_path);\n+    let output = cmd.output()?;\n+    let stdout = String::from_utf8(output.stdout)?;\n+    let stderr = String::from_utf8(output.stderr)?;\n+    println!(\"stdout: {}\", stdout);\n+    println!(\"stderr: {}\", stderr);\n+\n+    assert!(\n+        stderr.contains(\"Failed to find pattern at .grit/patterns/non_existent.md. Does it exist?\")\n+    );\n+\n+    Ok(())\n+}\n+\n #[test]\n fn test_multifile_fails_if_unchanged_file_has_incorrect_expected() -> Result<()> {\n     let (_temp_dir, fixture_dir) = get_fixture(\"test_multifile_fail\", true)?;\n",
        "problem_statement": "clearer messages when a referenced file is missing\nEarlier today, I was updating some patterns and when I went to run `grit patterns test` hit the following.\r\n\r\n```\r\n$ grit patterns test\r\nError: No such file or directory (os error 2)\r\n```\r\n\r\nI did all the usual things thinking this was something I broke in my environment (somehow lost grit) however, that all looked good. After a while, I busted out strace and it turned out this came from grit trying to look up a file in the pattern.\r\n\r\n```\r\n$ strace -f -e trace=open,openat ~/.grit/bin/grit patterns test\r\n\r\n.. snip\r\n\r\n[pid   799] openat(AT_FDCWD, \"/mnt/share/.grit/grit.yaml\", O_RDONLY|O_CLOEXEC) = 9\r\n[pid   799] openat(AT_FDCWD, \"/mnt/share/.grit/../docs/guides/version_5_upgrade.m\", O_RDONLY|O_CLOEXEC) = -1 ENOENT (No such file or directory)\r\n[pid   798] +++ exited with 0 +++\r\n[pid   797] +++ exited with 0 +++\r\n[pid   791] +++ exited with 0 +++\r\n[pid   799] +++ exited with 0 +++\r\nError: No such file or directory (os error [pid   799] openat(AT_FDCWD, \"/mnt/share/.grit/../docs/guides/version_5_upgrade.m\", O_RDONLY) = -1 ENOENT (No such file or directory)\r\n2)\r\n\r\n.. snip\r\n```\r\n\r\nYep, I did a stupid and removed a trailing letter of the file extension.\r\n\r\nTo make this easier to debug for others, perhaps wrapping this sort of error up in a nicer handler would be useful? Something like this would be helpful: \r\n\r\n```\r\n$ grit patterns test\r\n\r\nFailed to find pattern at \"/mnt/share/.grit/../docs/guides/version_5_upgrade.m\". Does it exist?\r\n```\r\n\n",
        "hints_text": "/bounty $20",
        "created_at": "2024-10-23T22:35:01Z",
        "version": "0.4"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 363,
        "instance_id": "getgrit__gritql-363",
        "issue_numbers": [
            "362"
        ],
        "base_commit": "3b39014a294de6167626b7b70750be7c3c4de5fe",
        "patch": "diff --git a/crates/core/src/pattern_compiler/auto_wrap.rs b/crates/core/src/pattern_compiler/auto_wrap.rs\n--- a/crates/core/src/pattern_compiler/auto_wrap.rs\n+++ b/crates/core/src/pattern_compiler/auto_wrap.rs\n@@ -314,6 +314,19 @@ fn should_wrap_in_file<Q: QueryContext>(\n             &pattern_definitions[call.index].pattern,\n             pattern_definitions,\n         ),\n+        Pattern::And(a) => a\n+            .patterns\n+            .iter()\n+            .all(|c| should_wrap_in_file(c, pattern_definitions)),\n+        Pattern::Or(o) => o\n+            .patterns\n+            .iter()\n+            .all(|c| should_wrap_in_file(c, pattern_definitions)),\n+        Pattern::Any(a) => a\n+            .patterns\n+            .iter()\n+            .all(|c| should_wrap_in_file(c, pattern_definitions)),\n+        Pattern::Not(n) => should_wrap_in_file(&n.pattern, pattern_definitions),\n         Pattern::AstNode(_)\n         | Pattern::Contains(_)\n         | Pattern::List(_)\ndiff --git a/crates/core/src/pattern_compiler/auto_wrap.rs b/crates/core/src/pattern_compiler/auto_wrap.rs\n--- a/crates/core/src/pattern_compiler/auto_wrap.rs\n+++ b/crates/core/src/pattern_compiler/auto_wrap.rs\n@@ -326,10 +339,6 @@ fn should_wrap_in_file<Q: QueryContext>(\n         | Pattern::CallForeignFunction(_)\n         | Pattern::Assignment(_)\n         | Pattern::Accumulate(_)\n-        | Pattern::And(_)\n-        | Pattern::Or(_)\n-        | Pattern::Any(_)\n-        | Pattern::Not(_)\n         | Pattern::If(_)\n         | Pattern::Undefined\n         | Pattern::Top\n",
        "test_patch": "diff --git a/crates/core/src/test.rs b/crates/core/src/test.rs\n--- a/crates/core/src/test.rs\n+++ b/crates/core/src/test.rs\n@@ -14950,3 +14950,40 @@ fn ruby_array_global() {\n     })\n     .unwrap();\n }\n+\n+#[test]\n+fn or_file() {\n+    run_test_expected({\n+        TestArgExpected {\n+            pattern: r#\"\n+                |language js\n+                |\n+                |or {\n+                |   bubble file($body) where {\n+                |       $body <: contains `i` => .\n+                |   },\n+                |   bubble file($body) where {\n+                |       $body <: contains `1` => .\n+                |   }\n+                |}\n+                |\"#\n+            .trim_margin()\n+            .unwrap(),\n+            source: r#\"\n+                |var increment = function (i) {\n+                |   return i + 1;\n+                |};\n+                |\"#\n+            .trim_margin()\n+            .unwrap(),\n+            expected: r#\"\n+                |var increment = function () {\n+                |   return  + 1;\n+                |};\n+                |\"#\n+            .trim_margin()\n+            .unwrap(),\n+        }\n+    })\n+    .unwrap();\n+}\n",
        "problem_statement": "`or file()` pattern doesn't work properly\nThis should work:\r\n```\r\nor {\r\n    bubble file($body) where {\r\n        $body <: contains `i` => .\r\n    },\r\n    bubble file($body) where {\r\n        $body <: contains `1` => .\r\n    }\r\n}\r\n```\r\n\r\nIt's like a bug in autowrap.\n",
        "hints_text": "",
        "created_at": "2024-05-29T09:28:22Z",
        "version": "0.2"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 309,
        "instance_id": "getgrit__gritql-309",
        "issue_numbers": [
            "308"
        ],
        "base_commit": "e79db2d13a8b0817f0bf13164d5661b73ac1b5eb",
        "patch": "diff --git a/crates/language/src/js_like.rs b/crates/language/src/js_like.rs\n--- a/crates/language/src/js_like.rs\n+++ b/crates/language/src/js_like.rs\n@@ -170,6 +170,8 @@ pub(crate) fn jslike_check_replacements(\n         && n.text()\n             .is_ok_and(|t| [\"var\", \"let\", \"const\"].contains(&t.as_ref()))\n         || n.node.kind() == \"empty_statement\"\n+            && n.parent()\n+                .is_some_and(|p| [\"program\", \"statement_block\"].contains(&p.node.kind().as_ref()))\n     {\n         replacement_ranges.push(Replacement::new(n.range(), \"\"));\n     } else if n.node.kind() == \"import_statement\" {\n",
        "test_patch": "diff --git a/crates/core/src/test.rs b/crates/core/src/test.rs\n--- a/crates/core/src/test.rs\n+++ b/crates/core/src/test.rs\n@@ -3883,6 +3883,38 @@ fn js_paren_params() {\n     .unwrap();\n }\n \n+#[test]\n+fn js_preserve_significant_empty_statements() {\n+    run_test_expected({\n+        TestArgExpected {\n+            pattern: r#\"`$body` => `$body`\"#.to_owned(),\n+            source: r#\"\n+            for(;;);\n+            if(true);\n+            while(true);\"#\n+                .to_owned(),\n+            expected: r#\"\n+            for(;;);\n+            if(true);\n+            while(true);\"#\n+                .to_owned(),\n+        }\n+    })\n+    .unwrap();\n+}\n+\n+#[test]\n+fn js_remove_redundant_empty_statements() {\n+    run_test_expected({\n+        TestArgExpected {\n+            pattern: r#\"`$body` => `$body`\"#.to_owned(),\n+            source: r#\";;{;;};;\"#.to_owned(),\n+            expected: r#\"{}\"#.to_owned(),\n+        }\n+    })\n+    .unwrap();\n+}\n+\n #[test]\n fn array_destrcutring_snippet() {\n     run_test_match({\n",
        "problem_statement": "Rewrite wrongly removes the empty statement after the `if` condition in JavaScript.\nThis issue is similar to #307.\n\n#### Pattern\r\n\r\n```grit\r\nengine marzano(0.1)\r\nlanguage js\r\n\r\n`$body` => `$body`\r\n```\r\n\r\n#### Code before\r\n\r\n```javascript\r\nlet a = true;\nif (a);\nconsole.log(a);\r\n```\r\n\r\n#### Code After\r\n\r\n```javascript\r\nlet a = true;\nif (a)\nconsole.log(a);\r\n```\r\n\r\n#### Expected Behavior\r\n\r\nThe code shouldn't be modified. The empty statement after the `if` condition shouldn't be removed. I think this issue also applys to other cases like `else`, `while`, `do`, .etc.\n\nAs is suggested by @morgante in https://github.com/getgrit/gritql/issues/307#issuecomment-2094723187, this is also likely caused by the empty statement cleaning up in https://github.com/getgrit/gritql/blob/662b6acd48acbe2190377458bc4dd1933543dc8d/crates/language/src/js_like.rs#L157.\r\n\r\n#### Reproduction\r\n\r\nhttps://app.grit.io/studio?key=mBKTvyQw9obvK0czFYbBq\n",
        "hints_text": "",
        "created_at": "2024-05-05T17:22:18Z",
        "version": "0.2"
    },
    {
        "repo": "getgrit/gritql",
        "pull_number": 397,
        "instance_id": "getgrit__gritql-397",
        "issue_numbers": [
            "392"
        ],
        "base_commit": "265f882f5cccf79648e86691b07cf589d48a630a",
        "patch": "diff --git /dev/null b/crates/gritmodule/fixtures/pattern_files/.grit/grit.yaml\nnew file mode 100644\n--- /dev/null\n+++ b/crates/gritmodule/fixtures/pattern_files/.grit/grit.yaml\n@@ -0,0 +1,12 @@\n+version: 0.0.1\n+patterns:\n+  - name: remove_console_error\n+    level: error\n+    body: |\n+      engine marzano(0.1)\n+      language js\n+\n+      `console.error($_)` => .\n+pattern_files:\n+  - docs/guides/version_5_upgrade.md\n+  - docs/guides/something.md\ndiff --git /dev/null b/crates/gritmodule/fixtures/pattern_files/docs/guides/something.md\nnew file mode 100644\n--- /dev/null\n+++ b/crates/gritmodule/fixtures/pattern_files/docs/guides/something.md\n@@ -0,0 +1,82 @@\n+---\n+title: Compare `null` using  `===` or `!==`\n+---\n+\n+Comparing to `null` needs a type-checking operator (=== or !==), to avoid incorrect results when the value is `undefined`.\n+\n+tags: #good\n+\n+```grit\n+engine marzano(0.1)\n+language js\n+\n+// We use the syntax-tree node binary_expression to capture all expressions where $a and $b are operated on by \"==\" or \"!=\".\n+// This code takes advantage of Grit's allowing us to nest rewrites inside match conditions and to match syntax-tree fields on patterns.\n+binary_expression($operator, $left, $right) where {\n+    $operator <: or  { \"==\" => `===` , \"!=\" => `!==` },\n+    or { $left <: `null`, $right <: `null`}\n+}\n+\n+```\n+\n+```\n+\n+```\n+\n+## `$val == null` => `$val === null`\n+\n+```javascript\n+if (val == null) {\n+  done();\n+}\n+```\n+\n+```typescript\n+if (val === null) {\n+  done();\n+}\n+```\n+\n+## `$val != null` => `$val !== null`\n+\n+```javascript\n+if (val != null) {\n+  done();\n+}\n+```\n+\n+```typescript\n+if (val !== null) {\n+  done();\n+}\n+```\n+\n+## `$val != null` => `$val !== null` into `while`\n+\n+```javascript\n+while (val != null) {\n+  did();\n+}\n+```\n+\n+```typescript\n+while (val !== null) {\n+  did();\n+}\n+```\n+\n+## Do not change `$val === null`\n+\n+```javascript\n+if (val === null) {\n+  done();\n+}\n+```\n+\n+## Do not change `$val !== null`\n+\n+```\n+while (val !== null) {\n+  doSomething();\n+}\n+```\ndiff --git /dev/null b/crates/gritmodule/fixtures/pattern_files/docs/guides/version_5_upgrade.md\nnew file mode 100644\n--- /dev/null\n+++ b/crates/gritmodule/fixtures/pattern_files/docs/guides/version_5_upgrade.md\n@@ -0,0 +1,82 @@\n+---\n+title: Compare `null` using  `===` or `!==`\n+---\n+\n+Comparing to `null` needs a type-checking operator (=== or !==), to avoid incorrect results when the value is `undefined`.\n+\n+tags: #good\n+\n+```grit\n+engine marzano(0.1)\n+language js\n+\n+// We use the syntax-tree node binary_expression to capture all expressions where $a and $b are operated on by \"==\" or \"!=\".\n+// This code takes advantage of Grit's allowing us to nest rewrites inside match conditions and to match syntax-tree fields on patterns.\n+binary_expression($operator, $left, $right) where {\n+    $operator <: or  { \"==\" => `===` , \"!=\" => `!==` },\n+    or { $left <: `null`, $right <: `null`}\n+}\n+\n+```\n+\n+```\n+\n+```\n+\n+## `$val == null` => `$val === null`\n+\n+```javascript\n+if (val == null) {\n+  done();\n+}\n+```\n+\n+```typescript\n+if (val === null) {\n+  done();\n+}\n+```\n+\n+## `$val != null` => `$val !== null`\n+\n+```javascript\n+if (val != null) {\n+  done();\n+}\n+```\n+\n+```typescript\n+if (val !== null) {\n+  done();\n+}\n+```\n+\n+## `$val != null` => `$val !== null` into `while`\n+\n+```javascript\n+while (val != null) {\n+  did();\n+}\n+```\n+\n+```typescript\n+while (val !== null) {\n+  did();\n+}\n+```\n+\n+## Do not change `$val === null`\n+\n+```javascript\n+if (val === null) {\n+  done();\n+}\n+```\n+\n+## Do not change `$val !== null`\n+\n+```\n+while (val !== null) {\n+  doSomething();\n+}\n+```\ndiff --git a/crates/gritmodule/src/config.rs b/crates/gritmodule/src/config.rs\n--- a/crates/gritmodule/src/config.rs\n+++ b/crates/gritmodule/src/config.rs\n@@ -35,12 +35,14 @@ pub struct GritGitHubConfig {\n #[derive(Debug, Deserialize)]\n pub struct GritConfig {\n     pub patterns: Vec<GritDefinitionConfig>,\n+    pub pattern_files: Option<Vec<String>>,\n     pub github: Option<GritGitHubConfig>,\n }\n \n #[derive(Debug, Deserialize)]\n pub struct SerializedGritConfig {\n     pub patterns: Vec<GritSerializedDefinitionConfig>,\n+    pub pattern_files: Option<Vec<String>>,\n     pub github: Option<GritGitHubConfig>,\n }\n \ndiff --git a/crates/gritmodule/src/resolver.rs b/crates/gritmodule/src/resolver.rs\n--- a/crates/gritmodule/src/resolver.rs\n+++ b/crates/gritmodule/src/resolver.rs\n@@ -535,7 +535,7 @@ async fn get_grit_files_for_module(\n         Some(config) => {\n             if let Some(module) = module {\n                 let repo_root = find_repo_root_from(repo_path).await?;\n-                get_patterns_from_yaml(&config, module, &repo_root)?\n+                get_patterns_from_yaml(&config, module, &repo_root, repo_dir).await?\n             } else {\n                 vec![]\n             }\ndiff --git a/crates/gritmodule/src/resolver.rs b/crates/gritmodule/src/resolver.rs\n--- a/crates/gritmodule/src/resolver.rs\n+++ b/crates/gritmodule/src/resolver.rs\n@@ -586,7 +586,7 @@ async fn resolve_patterns_for_module(\n         Some(config) => {\n             if let Some(module) = module {\n                 let repo_root = find_repo_root_from(repo_path).await?;\n-                get_patterns_from_yaml(&config, module, &repo_root)?\n+                get_patterns_from_yaml(&config, module, &repo_root, repo_dir).await?\n             } else {\n                 vec![]\n             }\ndiff --git a/crates/gritmodule/src/yaml.rs b/crates/gritmodule/src/yaml.rs\n--- a/crates/gritmodule/src/yaml.rs\n+++ b/crates/gritmodule/src/yaml.rs\n@@ -1,7 +1,10 @@\n use anyhow::{bail, Result};\n use grit_util::Position;\n use marzano_util::rich_path::RichFile;\n-use std::{collections::HashSet, path::Path};\n+use std::{\n+    collections::HashSet,\n+    path::{Path, PathBuf},\n+};\n use tokio::fs;\n \n use crate::{\ndiff --git a/crates/gritmodule/src/yaml.rs b/crates/gritmodule/src/yaml.rs\n--- a/crates/gritmodule/src/yaml.rs\n+++ b/crates/gritmodule/src/yaml.rs\n@@ -10,7 +13,7 @@ use crate::{\n         ModuleGritPattern, SerializedGritConfig, CONFIG_FILE_NAMES, REPO_CONFIG_DIR_NAME,\n     },\n     fetcher::ModuleRepo,\n-    parser::extract_relative_file_path,\n+    parser::{extract_relative_file_path, get_patterns_from_file, PatternFileExt},\n };\n \n pub fn get_grit_config(source: &str, source_path: &str) -> Result<GritConfig> {\ndiff --git a/crates/gritmodule/src/yaml.rs b/crates/gritmodule/src/yaml.rs\n--- a/crates/gritmodule/src/yaml.rs\n+++ b/crates/gritmodule/src/yaml.rs\n@@ -27,6 +30,7 @@ pub fn get_grit_config(source: &str, source_path: &str) -> Result<GritConfig> {\n \n     let new_config = GritConfig {\n         github: serialized.github,\n+        pattern_files: serialized.pattern_files,\n         patterns: serialized\n             .patterns\n             .into_iter()\ndiff --git a/crates/gritmodule/src/yaml.rs b/crates/gritmodule/src/yaml.rs\n--- a/crates/gritmodule/src/yaml.rs\n+++ b/crates/gritmodule/src/yaml.rs\n@@ -37,10 +41,11 @@ pub fn get_grit_config(source: &str, source_path: &str) -> Result<GritConfig> {\n     Ok(new_config)\n }\n \n-pub fn get_patterns_from_yaml(\n+pub async fn get_patterns_from_yaml(\n     file: &RichFile,\n     source_module: &ModuleRepo,\n     root: &Option<String>,\n+    repo_dir: &str,\n ) -> Result<Vec<ModuleGritPattern>> {\n     let mut config = get_grit_config(&file.content, &extract_relative_file_path(file, root))?;\n \ndiff --git a/crates/gritmodule/src/yaml.rs b/crates/gritmodule/src/yaml.rs\n--- a/crates/gritmodule/src/yaml.rs\n+++ b/crates/gritmodule/src/yaml.rs\n@@ -50,11 +55,38 @@ pub fn get_patterns_from_yaml(\n         pattern.position = Some(Position::from_byte_index(&file.content, offset));\n     }\n \n-    config\n+    let patterns = config\n         .patterns\n         .into_iter()\n         .map(|pattern| pattern_config_to_model(pattern, source_module))\n-        .collect()\n+        .collect();\n+\n+    if config.pattern_files.is_none() {\n+        return patterns;\n+    }\n+\n+    let mut patterns = patterns?;\n+    let mut file_readers = Vec::new();\n+\n+    for pattern_file in config.pattern_files.unwrap() {\n+        let pattern_file = PathBuf::from(repo_dir).join(&pattern_file);\n+        let extension = PatternFileExt::from_path(&pattern_file);\n+        if extension.is_none() {\n+            continue;\n+        }\n+        let extension = extension.unwrap();\n+        file_readers.push(tokio::spawn(get_patterns_from_file(\n+            pattern_file,\n+            Some(source_module.clone()),\n+            extension,\n+        )));\n+    }\n+\n+    for file_reader in file_readers {\n+        patterns.extend(file_reader.await??);\n+    }\n+\n+    Ok(patterns)\n }\n \n pub fn extract_grit_modules(content: &str, path: &str) -> Result<Vec<String>> {\ndiff --git a/crates/gritmodule/src/yaml.rs b/crates/gritmodule/src/yaml.rs\n--- a/crates/gritmodule/src/yaml.rs\n+++ b/crates/gritmodule/src/yaml.rs\n@@ -163,7 +195,9 @@ github:\n             .to_string(),\n         };\n         let repo = Default::default();\n-        let patterns = get_patterns_from_yaml(&grit_yaml, &repo, &None).unwrap();\n+        let patterns = get_patterns_from_yaml(&grit_yaml, &repo, &None, \"getgrit/rewriter\")\n+            .await\n+            .unwrap();\n         assert_eq!(patterns.len(), 4);\n         assert_yaml_snapshot!(patterns);\n     }\n",
        "test_patch": "diff --git a/crates/gritmodule/src/resolver.rs b/crates/gritmodule/src/resolver.rs\n--- a/crates/gritmodule/src/resolver.rs\n+++ b/crates/gritmodule/src/resolver.rs\n@@ -934,4 +934,20 @@ mod tests {\n         resolved_patterns.sort_by(|a, b| a.language.to_string().cmp(&b.language.to_string()));\n         assert_yaml_snapshot!(resolved_patterns);\n     }\n+\n+    #[tokio::test]\n+    async fn finds_patterns_from_custom_pattern_files() {\n+        let module_repo = ModuleRepo::from_host_repo(\"github.com\", \"getgrit/rewriter\").unwrap();\n+        let repo_dir = \"fixtures/pattern_files\";\n+        let (mut resolved_patterns, errored_patterns) =\n+            super::resolve_patterns(&module_repo, repo_dir, None)\n+                .await\n+                .unwrap();\n+\n+        assert_eq!(resolved_patterns.len(), 3);\n+        assert_eq!(errored_patterns.len(), 0);\n+\n+        resolved_patterns.sort_by(|a, b| a.local_name.cmp(&b.local_name));\n+        assert_yaml_snapshot!(resolved_patterns);\n+    }\n }\ndiff --git /dev/null b/crates/gritmodule/src/snapshots/marzano_gritmodule__resolver__tests__finds_patterns_from_custom_pattern_files.snap\nnew file mode 100644\n--- /dev/null\n+++ b/crates/gritmodule/src/snapshots/marzano_gritmodule__resolver__tests__finds_patterns_from_custom_pattern_files.snap\n@@ -0,0 +1,284 @@\n+---\n+source: crates/gritmodule/src/resolver.rs\n+expression: resolved_patterns\n+---\n+- config:\n+    name: remove_console_error\n+    body: \"engine marzano(0.1)\\nlanguage js\\n\\n`console.error($_)` => .\\n\"\n+    level: error\n+    title: ~\n+    description: ~\n+    tags: ~\n+    samples: ~\n+    path: \".grit/grit.yaml\"\n+    position:\n+      line: 3\n+      column: 11\n+    raw: ~\n+  module:\n+    type: Module\n+    host: github.com\n+    fullName: getgrit/rewriter\n+    remote: \"https://github.com/getgrit/rewriter.git\"\n+    providerName: github.com/getgrit/rewriter\n+  localName: remove_console_error\n+  body: \"engine marzano(0.1)\\nlanguage js\\n\\n`console.error($_)` => .\\n\"\n+  kind: pattern\n+  language: js\n+  visibility: public\n+- config:\n+    name: something\n+    body: \"engine marzano(0.1)\\nlanguage js\\n\\n// We use the syntax-tree node binary_expression to capture all expressions where $a and $b are operated on by \\\"==\\\" or \\\"!=\\\".\\n// This code takes advantage of Grit's allowing us to nest rewrites inside match conditions and to match syntax-tree fields on patterns.\\nbinary_expression($operator, $left, $right) where {\\n    $operator <: or  { \\\"==\\\" => `===` , \\\"!=\\\" => `!==` },\\n    or { $left <: `null`, $right <: `null`}\\n}\\n\\n\"\n+    level: info\n+    title: \"Compare `null` using  `===` or `!==`\"\n+    description: \"Comparing to `null` needs a type-checking operator (=== or !==), to avoid incorrect results when the value is `undefined`.\"\n+    tags: ~\n+    samples:\n+      - name: ~\n+        input: \"\\n\"\n+        output: ~\n+        input_range:\n+          start:\n+            line: 23\n+            column: 1\n+          end:\n+            line: 24\n+            column: 1\n+          startByte: 657\n+          endByte: 658\n+        output_range: ~\n+      - name: \"`$val == null` => `$val === null`\"\n+        input: \"if (val == null) {\\n  done();\\n}\\n\"\n+        output: \"if (val === null) {\\n  done();\\n}\\n\"\n+        input_range:\n+          start:\n+            line: 29\n+            column: 1\n+          end:\n+            line: 32\n+            column: 1\n+          startByte: 715\n+          endByte: 746\n+        output_range:\n+          start:\n+            line: 35\n+            column: 1\n+          end:\n+            line: 38\n+            column: 1\n+          startByte: 765\n+          endByte: 797\n+      - name: \"`$val != null` => `$val !== null`\"\n+        input: \"if (val != null) {\\n  done();\\n}\\n\"\n+        output: \"if (val !== null) {\\n  done();\\n}\\n\"\n+        input_range:\n+          start:\n+            line: 43\n+            column: 1\n+          end:\n+            line: 46\n+            column: 1\n+          startByte: 854\n+          endByte: 885\n+        output_range:\n+          start:\n+            line: 49\n+            column: 1\n+          end:\n+            line: 52\n+            column: 1\n+          startByte: 904\n+          endByte: 936\n+      - name: \"`$val != null` => `$val !== null` into `while`\"\n+        input: \"while (val != null) {\\n  did();\\n}\\n\"\n+        output: \"while (val !== null) {\\n  did();\\n}\\n\"\n+        input_range:\n+          start:\n+            line: 57\n+            column: 1\n+          end:\n+            line: 60\n+            column: 1\n+          startByte: 1006\n+          endByte: 1039\n+        output_range:\n+          start:\n+            line: 63\n+            column: 1\n+          end:\n+            line: 66\n+            column: 1\n+          startByte: 1058\n+          endByte: 1092\n+      - name: \"Do not change `$val === null`\"\n+        input: \"if (val === null) {\\n  done();\\n}\\n\"\n+        output: ~\n+        input_range:\n+          start:\n+            line: 71\n+            column: 1\n+          end:\n+            line: 74\n+            column: 1\n+          startByte: 1145\n+          endByte: 1177\n+        output_range: ~\n+      - name: \"Do not change `$val !== null`\"\n+        input: \"while (val !== null) {\\n  doSomething();\\n}\\n\"\n+        output: ~\n+        input_range:\n+          start:\n+            line: 79\n+            column: 1\n+          end:\n+            line: 82\n+            column: 1\n+          startByte: 1220\n+          endByte: 1262\n+        output_range: ~\n+    path: fixtures/pattern_files/docs/guides/something.md\n+    position:\n+      line: 10\n+      column: 1\n+    raw:\n+      format: markdown\n+      content: \"---\\ntitle: Compare `null` using  `===` or `!==`\\n---\\n\\nComparing to `null` needs a type-checking operator (=== or !==), to avoid incorrect results when the value is `undefined`.\\n\\ntags: #good\\n\\n```grit\\nengine marzano(0.1)\\nlanguage js\\n\\n// We use the syntax-tree node binary_expression to capture all expressions where $a and $b are operated on by \\\"==\\\" or \\\"!=\\\".\\n// This code takes advantage of Grit's allowing us to nest rewrites inside match conditions and to match syntax-tree fields on patterns.\\nbinary_expression($operator, $left, $right) where {\\n    $operator <: or  { \\\"==\\\" => `===` , \\\"!=\\\" => `!==` },\\n    or { $left <: `null`, $right <: `null`}\\n}\\n\\n```\\n\\n```\\n\\n```\\n\\n## `$val == null` => `$val === null`\\n\\n```javascript\\nif (val == null) {\\n  done();\\n}\\n```\\n\\n```typescript\\nif (val === null) {\\n  done();\\n}\\n```\\n\\n## `$val != null` => `$val !== null`\\n\\n```javascript\\nif (val != null) {\\n  done();\\n}\\n```\\n\\n```typescript\\nif (val !== null) {\\n  done();\\n}\\n```\\n\\n## `$val != null` => `$val !== null` into `while`\\n\\n```javascript\\nwhile (val != null) {\\n  did();\\n}\\n```\\n\\n```typescript\\nwhile (val !== null) {\\n  did();\\n}\\n```\\n\\n## Do not change `$val === null`\\n\\n```javascript\\nif (val === null) {\\n  done();\\n}\\n```\\n\\n## Do not change `$val !== null`\\n\\n```\\nwhile (val !== null) {\\n  doSomething();\\n}\\n```\\n\"\n+  module:\n+    type: Module\n+    host: github.com\n+    fullName: getgrit/rewriter\n+    remote: \"https://github.com/getgrit/rewriter.git\"\n+    providerName: github.com/getgrit/rewriter\n+  localName: something\n+  body: \"engine marzano(0.1)\\nlanguage js\\n\\n// We use the syntax-tree node binary_expression to capture all expressions where $a and $b are operated on by \\\"==\\\" or \\\"!=\\\".\\n// This code takes advantage of Grit's allowing us to nest rewrites inside match conditions and to match syntax-tree fields on patterns.\\nbinary_expression($operator, $left, $right) where {\\n    $operator <: or  { \\\"==\\\" => `===` , \\\"!=\\\" => `!==` },\\n    or { $left <: `null`, $right <: `null`}\\n}\\n\\n\"\n+  kind: pattern\n+  language: js\n+  visibility: public\n+- config:\n+    name: version_5_upgrade\n+    body: \"engine marzano(0.1)\\nlanguage js\\n\\n// We use the syntax-tree node binary_expression to capture all expressions where $a and $b are operated on by \\\"==\\\" or \\\"!=\\\".\\n// This code takes advantage of Grit's allowing us to nest rewrites inside match conditions and to match syntax-tree fields on patterns.\\nbinary_expression($operator, $left, $right) where {\\n    $operator <: or  { \\\"==\\\" => `===` , \\\"!=\\\" => `!==` },\\n    or { $left <: `null`, $right <: `null`}\\n}\\n\\n\"\n+    level: info\n+    title: \"Compare `null` using  `===` or `!==`\"\n+    description: \"Comparing to `null` needs a type-checking operator (=== or !==), to avoid incorrect results when the value is `undefined`.\"\n+    tags: ~\n+    samples:\n+      - name: ~\n+        input: \"\\n\"\n+        output: ~\n+        input_range:\n+          start:\n+            line: 23\n+            column: 1\n+          end:\n+            line: 24\n+            column: 1\n+          startByte: 657\n+          endByte: 658\n+        output_range: ~\n+      - name: \"`$val == null` => `$val === null`\"\n+        input: \"if (val == null) {\\n  done();\\n}\\n\"\n+        output: \"if (val === null) {\\n  done();\\n}\\n\"\n+        input_range:\n+          start:\n+            line: 29\n+            column: 1\n+          end:\n+            line: 32\n+            column: 1\n+          startByte: 715\n+          endByte: 746\n+        output_range:\n+          start:\n+            line: 35\n+            column: 1\n+          end:\n+            line: 38\n+            column: 1\n+          startByte: 765\n+          endByte: 797\n+      - name: \"`$val != null` => `$val !== null`\"\n+        input: \"if (val != null) {\\n  done();\\n}\\n\"\n+        output: \"if (val !== null) {\\n  done();\\n}\\n\"\n+        input_range:\n+          start:\n+            line: 43\n+            column: 1\n+          end:\n+            line: 46\n+            column: 1\n+          startByte: 854\n+          endByte: 885\n+        output_range:\n+          start:\n+            line: 49\n+            column: 1\n+          end:\n+            line: 52\n+            column: 1\n+          startByte: 904\n+          endByte: 936\n+      - name: \"`$val != null` => `$val !== null` into `while`\"\n+        input: \"while (val != null) {\\n  did();\\n}\\n\"\n+        output: \"while (val !== null) {\\n  did();\\n}\\n\"\n+        input_range:\n+          start:\n+            line: 57\n+            column: 1\n+          end:\n+            line: 60\n+            column: 1\n+          startByte: 1006\n+          endByte: 1039\n+        output_range:\n+          start:\n+            line: 63\n+            column: 1\n+          end:\n+            line: 66\n+            column: 1\n+          startByte: 1058\n+          endByte: 1092\n+      - name: \"Do not change `$val === null`\"\n+        input: \"if (val === null) {\\n  done();\\n}\\n\"\n+        output: ~\n+        input_range:\n+          start:\n+            line: 71\n+            column: 1\n+          end:\n+            line: 74\n+            column: 1\n+          startByte: 1145\n+          endByte: 1177\n+        output_range: ~\n+      - name: \"Do not change `$val !== null`\"\n+        input: \"while (val !== null) {\\n  doSomething();\\n}\\n\"\n+        output: ~\n+        input_range:\n+          start:\n+            line: 79\n+            column: 1\n+          end:\n+            line: 82\n+            column: 1\n+          startByte: 1220\n+          endByte: 1262\n+        output_range: ~\n+    path: fixtures/pattern_files/docs/guides/version_5_upgrade.md\n+    position:\n+      line: 10\n+      column: 1\n+    raw:\n+      format: markdown\n+      content: \"---\\ntitle: Compare `null` using  `===` or `!==`\\n---\\n\\nComparing to `null` needs a type-checking operator (=== or !==), to avoid incorrect results when the value is `undefined`.\\n\\ntags: #good\\n\\n```grit\\nengine marzano(0.1)\\nlanguage js\\n\\n// We use the syntax-tree node binary_expression to capture all expressions where $a and $b are operated on by \\\"==\\\" or \\\"!=\\\".\\n// This code takes advantage of Grit's allowing us to nest rewrites inside match conditions and to match syntax-tree fields on patterns.\\nbinary_expression($operator, $left, $right) where {\\n    $operator <: or  { \\\"==\\\" => `===` , \\\"!=\\\" => `!==` },\\n    or { $left <: `null`, $right <: `null`}\\n}\\n\\n```\\n\\n```\\n\\n```\\n\\n## `$val == null` => `$val === null`\\n\\n```javascript\\nif (val == null) {\\n  done();\\n}\\n```\\n\\n```typescript\\nif (val === null) {\\n  done();\\n}\\n```\\n\\n## `$val != null` => `$val !== null`\\n\\n```javascript\\nif (val != null) {\\n  done();\\n}\\n```\\n\\n```typescript\\nif (val !== null) {\\n  done();\\n}\\n```\\n\\n## `$val != null` => `$val !== null` into `while`\\n\\n```javascript\\nwhile (val != null) {\\n  did();\\n}\\n```\\n\\n```typescript\\nwhile (val !== null) {\\n  did();\\n}\\n```\\n\\n## Do not change `$val === null`\\n\\n```javascript\\nif (val === null) {\\n  done();\\n}\\n```\\n\\n## Do not change `$val !== null`\\n\\n```\\nwhile (val !== null) {\\n  doSomething();\\n}\\n```\\n\"\n+  module:\n+    type: Module\n+    host: github.com\n+    fullName: getgrit/rewriter\n+    remote: \"https://github.com/getgrit/rewriter.git\"\n+    providerName: github.com/getgrit/rewriter\n+  localName: version_5_upgrade\n+  body: \"engine marzano(0.1)\\nlanguage js\\n\\n// We use the syntax-tree node binary_expression to capture all expressions where $a and $b are operated on by \\\"==\\\" or \\\"!=\\\".\\n// This code takes advantage of Grit's allowing us to nest rewrites inside match conditions and to match syntax-tree fields on patterns.\\nbinary_expression($operator, $left, $right) where {\\n    $operator <: or  { \\\"==\\\" => `===` , \\\"!=\\\" => `!==` },\\n    or { $left <: `null`, $right <: `null`}\\n}\\n\\n\"\n+  kind: pattern\n+  language: js\n+  visibility: public\ndiff --git a/crates/gritmodule/src/yaml.rs b/crates/gritmodule/src/yaml.rs\n--- a/crates/gritmodule/src/yaml.rs\n+++ b/crates/gritmodule/src/yaml.rs\n@@ -136,8 +168,8 @@ patterns:\n         }\n     }\n \n-    #[test]\n-    fn gets_module_patterns() {\n+    #[tokio::test]\n+    async fn gets_module_patterns() {\n         let grit_yaml = RichFile {\n             path: String::new(),\n             content: r#\"version: 0.0.1\n",
        "problem_statement": "Find patterns elsewhere in directory tree\nSometimes we would like to pull in patterns (especially *test patterns*) from other documentation.\r\n\r\nFor example, Terraform modules [like this](https://github.com/cloudflare/terraform-provider-cloudflare/pull/3413#issuecomment-2198848293) *must* store docs in a `docs/guides` directory [according to Hashicorp](https://developer.hashicorp.com/terraform/registry/providers/docs#directory-structure).\r\n\r\nRight now we require all testable patterns to be found in `.grit/patterns` but we should consider pulling them in from elsewhere.\n",
        "hints_text": "It's probably sufficient to add a `pattern_files` array in `.grit/grit.yaml` to list additional files in the repo that should be parsed as testable patterns.\r\n\r\nFor example:\r\n\r\n```\r\nversion: 0.2.0\r\npatterns: []\r\npattern_files:\r\n- docs/guides/version-5-upgrade.md\r\n```",
        "created_at": "2024-07-04T09:37:31Z",
        "version": "0.3"
    }
]